diff --git a/.buildscript/deploy_snapshot.sh b/.buildscript/deploy_snapshot.sh
new file mode 100755
index 0000000000..4e141cad64
--- /dev/null
+++ b/.buildscript/deploy_snapshot.sh
@@ -0,0 +1,26 @@
+#!/bin/bash
+#
+# Deploy a jar, source jar, and javadoc jar to Sonatype's snapshot repo.
+#
+# Adapted from https://coderwall.com/p/9b_lfq and
+# http://benlimmer.com/2013/12/26/automatically-publish-javadoc-to-gh-pages-with-travis-ci/
+
+SLUG="square/okhttp"
+JDK="oraclejdk8"
+BRANCH="master"
+
+set -e
+
+if [ "$TRAVIS_REPO_SLUG" != "$SLUG" ]; then
+  echo "Skipping snapshot deployment: wrong repository. Expected '$SLUG' but was '$TRAVIS_REPO_SLUG'."
+elif [ "$TRAVIS_JDK_VERSION" != "$JDK" ]; then
+  echo "Skipping snapshot deployment: wrong JDK. Expected '$JDK' but was '$TRAVIS_JDK_VERSION'."
+elif [ "$TRAVIS_PULL_REQUEST" != "false" ]; then
+  echo "Skipping snapshot deployment: was pull request."
+elif [ "$TRAVIS_BRANCH" != "$BRANCH" ]; then
+  echo "Skipping snapshot deployment: wrong branch. Expected '$BRANCH' but was '$TRAVIS_BRANCH'."
+else
+  echo "Deploying snapshot..."
+  mvn clean source:jar javadoc:jar deploy --settings=".buildscript/settings.xml" -Dmaven.test.skip=true
+  echo "Snapshot deployed!"
+fi
diff --git a/.buildscript/settings.xml b/.buildscript/settings.xml
new file mode 100644
index 0000000000..91f444b228
--- /dev/null
+++ b/.buildscript/settings.xml
@@ -0,0 +1,9 @@
+<settings>
+  <servers>
+    <server>
+      <id>sonatype-nexus-snapshots</id>
+      <username>${env.CI_DEPLOY_USERNAME}</username>
+      <password>${env.CI_DEPLOY_PASSWORD}</password>
+    </server>
+  </servers>
+</settings>
diff --git a/.github/CONTRIBUTING.md b/.github/CONTRIBUTING.md
new file mode 100644
index 0000000000..0b26b8467b
--- /dev/null
+++ b/.github/CONTRIBUTING.md
@@ -0,0 +1,17 @@
+Contributing
+============
+
+If you would like to contribute code to OkHttp you can do so through GitHub by
+forking the repository and sending a pull request.
+
+When submitting code, please make every effort to follow existing conventions
+and style in order to keep the code as readable as possible. Please also make
+sure your code compiles by running `mvn clean verify`. Checkstyle failures
+during compilation indicate errors in your style and can be viewed in the
+`checkstyle-result.xml` file.
+
+Before your code can be accepted into the project you must also sign the
+[Individual Contributor License Agreement (CLA)][1].
+
+
+ [1]: https://spreadsheets.google.com/spreadsheet/viewform?formkey=dDViT2xzUHAwRkI3X3k5Z0lQM091OGc6MQ&ndplr=1
diff --git a/.github/ISSUE_TEMPLATE.md b/.github/ISSUE_TEMPLATE.md
new file mode 100644
index 0000000000..e65d371715
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE.md
@@ -0,0 +1,12 @@
+What kind of issue is this?
+
+ - [ ] Question. This issue tracker is not the place for questions. If you want to ask how to do
+       something, or to understand why something isn't working the way you expect it to, use Stack
+       Overflow. https://stackoverflow.com/questions/tagged/okhttp
+
+ - [ ] Bug report. If you’ve found a bug, spend the time to write a failing test. Bugs with tests
+       get fixed. Here’s an example: https://gist.github.com/swankjesse/981fcae102f513eb13ed
+
+ - [ ] Feature Request. Start by telling us what problem you’re trying to solve. Often a solution
+       already exists! Don’t send pull requests to implement new features without first getting our
+       support. Sometimes we leave features out on purpose to keep the project small.
diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000000..226a3f3d65
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,24 @@
+.classpath
+.project
+.settings
+eclipsebin
+
+bin
+gen
+build
+out
+lib
+
+target
+pom.xml.*
+release.properties
+
+.idea
+*.iml
+*.ipr
+*.iws
+classes
+
+obj
+
+.DS_Store
diff --git a/.gitmodules b/.gitmodules
new file mode 100644
index 0000000000..d29f0b1218
--- /dev/null
+++ b/.gitmodules
@@ -0,0 +1,3 @@
+[submodule "okhttp-hpacktests/src/test/resources/hpack-test-case"]
+	path = okhttp-hpacktests/src/test/resources/hpack-test-case
+	url = git://github.com/http2jp/hpack-test-case.git
diff --git a/.travis.yml b/.travis.yml
new file mode 100644
index 0000000000..f20f14fc6a
--- /dev/null
+++ b/.travis.yml
@@ -0,0 +1,30 @@
+language: java
+
+jdk:
+  - oraclejdk8
+
+addons:
+  apt:
+    packages:
+      - oracle-java8-installer # Updates JDK 8 to the latest available.
+
+after_success:
+  - .buildscript/deploy_snapshot.sh
+
+env:
+  global:
+    - secure: "S0BTJVrF4fUCwhTdmoQY6LYr5r1wgXZ/p8lc5bIgUUsc1Ckalwt7s/GDwPuLJ4702sI5t56Eye2iEIMUjeFJKqebZRsX1C5oYsYFxGi3BGlepstYpmj0gLXuSWqCLniS9zmHXCxLhLkC6KxPVjhDlbq76XQx0o3K1J8oEIj/PCE="
+    - secure: "awV7yLXURjlPbTOladsNDZk74KYCNXoiZpAP0gQFfK4Sc0fc7+kg8z/yhdWXeTxjsIZ6m0dVDHTqnH8ytnydwXpBam8JdQJ+EAWA6R3Svq1BR1bzl/PcZUoz+Xn8lMXdU3yA1p4qtQlUhMxwsE3MOVe24HSDJPAu4XeWFj1j3qo="
+
+branches:
+  except:
+    - gh-pages
+
+notifications:
+  email: false
+
+sudo: false
+
+cache:
+  directories:
+    - $HOME/.m2
diff --git a/BUG-BOUNTY.md b/BUG-BOUNTY.md
new file mode 100644
index 0000000000..b2c35b2da0
--- /dev/null
+++ b/BUG-BOUNTY.md
@@ -0,0 +1,10 @@
+Serious about security
+======================
+
+Square recognizes the important contributions the security research community
+can make. We therefore encourage reporting security issues with the code
+contained in this repository.
+
+If you believe you have discovered a security vulnerability, please follow the
+guidelines at https://hackerone.com/square-open-source
+
diff --git a/CHANGELOG.md b/CHANGELOG.md
new file mode 100644
index 0000000000..7183846420
--- /dev/null
+++ b/CHANGELOG.md
@@ -0,0 +1,1373 @@
+Change Log
+==========
+
+## Version 3.9.0
+
+_2017-09-03_
+
+ *  **Interceptors are more capable.** The `Chain` interface now offers access
+    to the call and can adjust all call timeouts. Note that this change is
+    source-incompatible for code that implements the `Chain` interface.
+    We don't expect this to be a problem in practice!
+
+ *  **OkHttp has an experimental new API for tracking metrics.** The new
+    `EventListener` API is designed to help developers monitor HTTP requests'
+    size and duration. This feature is an unstable preview: the API is subject
+    to change, and the implementation is incomplete. This is a big new API we
+    are eager for feedback.
+
+ *  New: Support ALPN via Google Play Services' Dynamic Security Provider. This
+    expands HTTP/2 support to older Android devices that have Google Play
+    Services.
+ *  New: Consider all routes when looking for candidate coalesced connections.
+    This increases the likelihood that HTTP/2 connections will be shared.
+ *  New: Authentication challenges and credentials now use a charset. Use this in
+    your authenticator to support user names and passwords with non-ASCII
+    characters.
+ *  New: Accept a charset in `FormBody.Builder`. Previously form bodies were
+    always UTF-8.
+ *  New: Support the `immutable` cache-control directive.
+ *  Fix: Don't crash when an HTTP/2 call is redirected while the connection is
+    being shut down.
+ *  Fix: Don't drop headers of healthy streams that raced with `GOAWAY` frames.
+    This bug would cause HTTP/2 streams to occasional hang when the connection
+    was shutting down.
+ *  Fix: Honor `OkHttpClient.retryOnConnectionFailure()` when the response is a
+    HTTP 408 Request Timeout. If retries are enabled, OkHttp will retry exactly
+    once in response to a 408.
+ *  Fix: Don't crash when reading the empty `HEAD` response body if it specifies
+    a `Content-Length`.
+ *  Fix: Don't crash if the thread is interrupted while reading the public
+    suffix database.
+ *  Fix: Use relative resource path when loading the public suffix database.
+    Loading the resource using a path relative to the class prevents conflicts
+    when the OkHttp classes are relocated (shaded) by allowing multiple private
+    copies of the database.
+ *  Fix: Accept cookies for URLs that have an IPv6 address for a host.
+ *  Fix: Don't log the protocol (HTTP/1.1, h2) in HttpLoggingInterceptor if the
+    protocol isn't negotiated yet! Previously we'd log HTTP/1.1 by default, and
+    this was confusing.
+ *  Fix: Omit the message from MockWebServer's HTTP/2 `:status` header.
+ *  Fix: Handle 'Expect: 100 Continue' properly in MockWebServer.
+
+
+## Version 3.8.1
+
+_2017-06-18_
+
+ *  Fix: Recover gracefully from stale coalesced connections. We had a bug where
+    connection coalescing (introduced in OkHttp 3.7.0) and stale connection
+    recovery could interact to cause a `NoSuchElementException` crash in the
+    `RouteSelector`.
+
+
+## Version 3.8.0
+
+_2017-05-13_
+
+
+ *  **OkHttp now uses `@Nullable` to annotate all possibly-null values.** We've
+    added a compile-time dependency on the JSR 305 annotations. This is a
+    [provided][maven_provided] dependency and does not need to be included in
+    your build configuration, `.jar` file, or `.apk`. We use
+    `@ParametersAreNonnullByDefault` and all parameters and return types are
+    never null unless explicitly annotated `@Nullable`.
+
+ *  **Warning: this release is source-incompatible for Kotlin users.**
+    Nullability was previously ambiguous and lenient but now the compiler will
+    enforce strict null checks.
+
+ *  New: The response message is now non-null. This is the "Not Found" in the
+    status line "HTTP 404 Not Found". If you are building responses
+    programmatically (with `new Response.Builder()`) you must now always supply
+    a message. An empty string `""` is permitted. This value was never null on
+    responses returned by OkHttp itself, and it was an old mistake to permit
+    application code to omit a message.
+
+ *  The challenge's scheme and realm are now non-null. If you are calling
+    `new Challenge(scheme, realm)` you must provide non-null values. These were
+    never null in challenges created by OkHttp, but could have been null in
+    application code that creates challenges.
+
+ *  New: The `TlsVersion` of a `Handshake` is now non-null. If you are calling
+    `Handshake.get()` with a null TLS version, you must instead now provide a
+    non-null `TlsVersion`. Cache responses persisted prior to OkHttp 3.0 did not
+    store a TLS version; for these unknown values the handshake is defaulted to
+    `TlsVersion.SSL_3_0`.
+
+ *  New: Upgrade to Okio 1.13.0.
+
+     ```xml
+     <dependency>
+       <groupId>com.squareup.okio</groupId>
+       <artifactId>okio</artifactId>
+       <version>1.13.0</version>
+     </dependency>
+
+     com.squareup.okio:okio:1.13.0
+     ```
+
+ *  Fix: gracefully recover when Android 7.0's sockets throw an unexpected
+    `NullPointerException`.
+
+## Version 3.7.0
+
+_2017-04-15_
+
+ *  **OkHttp no longer recovers from TLS handshake failures by attempting a TLSv1 connection.**
+    The fallback was necessary for servers that implemented version negotiation incorrectly. Now
+    that 99.99% of servers do it right this fallback is obsolete.
+ *  Fix: Do not honor cookies set on a public domain. Previously a malicious site could inject
+    cookies on top-level domains like `co.uk` because our cookie parser didn't honor the [public
+    suffix][public_suffix] list. Alongside this fix is a new API, `HttpUrl.topPrivateDomain()`,
+    which returns the privately domain name if the URL has one.
+ *  Fix: Change `MediaType.charset()` to return null for unexpected charsets.
+ *  Fix: Don't skip cache invalidation if the invalidating response has no body.
+ *  Fix: Don't use a cryptographic random number generator for web sockets. Some Android devices
+    implement `SecureRandom` incorrectly!
+ *  Fix: Correctly canonicalize IPv6 addresses in `HttpUrl`. This prevented OkHttp from trusting
+    HTTPS certificates issued to certain IPv6 addresses.
+ *  Fix: Don't reuse connections after an unsuccessful `Expect: 100-continue`.
+ *  Fix: Handle either `TLS_` or `SSL_` prefixes for cipher suite names. This is necessary for
+    IBM JVMs that use the `SSL_` prefix exclusively.
+ *  Fix: Reject HTTP/2 data frames if the stream ID is 0.
+ *  New: Upgrade to Okio 1.12.0.
+
+     ```xml
+     <dependency>
+       <groupId>com.squareup.okio</groupId>
+       <artifactId>okio</artifactId>
+       <version>1.12.0</version>
+     </dependency>
+
+     com.squareup.okio:okio:1.12.0
+     ```
+
+ *  New: Connection coalescing. OkHttp may reuse HTTP/2 connections across calls that share an IP
+    address and HTTPS certificate, even if their domain names are different.
+ *  New: MockWebServer's `RecordedRequest` exposes the requested `HttpUrl` with `getRequestUrl()`.
+
+
+## Version 3.6.0
+
+_2017-01-29_
+
+ *  Fix: Don't crash with a "cache is closed" error when there is an error initializing the cache.
+ *  Fix: Calling `disconnect()` on a connecting `HttpUrlConnection` could cause it to retry in an
+    infinite loop! This regression was introduced in OkHttp 2.7.0.
+ *  Fix: Drop cookies that contain ASCII NULL and other bad characters. Previously such cookies
+    would cause OkHttp to crash when they were included in a request.
+ *  Fix: Release duplicated multiplexed connections. If we concurrently establish connections to an
+    HTTP/2 server, close all but the first connection.
+ *  Fix: Fail the HTTP/2 connection if first frame isn't `SETTINGS`.
+ *  Fix: Forbid spaces in header names.
+ *  Fix: Don't offer to do gzip if the request is partial.
+ *  Fix: MockWebServer is now usable with JUnit 5. That update [broke the rules][junit_5_rules].
+ *  New: Support `Expect: 100-continue` as a request header. Callers can use this header to
+    pessimistically hold off on transmitting a request body until a server gives the go-ahead.
+ *  New: Permit network interceptors to rewrite the host header for HTTP/2. This makes it possible
+    to do domain fronting.
+ *  New: charset support for `Credentials.basic()`.
+
+
+## Version 3.5.0
+
+_2016-11-30_
+
+ *  **Web Sockets are now a stable feature of OkHttp.** Since being introduced as a beta feature in
+    OkHttp 2.3 our web socket client has matured. Connect to a server's web socket with
+    `OkHttpClient.newWebSocket()`, send messages with `send()`, and receive messages with the
+    `WebSocketListener`.
+
+    The `okhttp-ws` submodule is no longer available and `okhttp-ws` artifacts from previous
+    releases of OkHttp are not compatible with OkHttp 3.5. When upgrading to the new package
+    please note that the `WebSocket` and `WebSocketCall` classes have been merged. Sending messages
+    is now asynchronous and they may be enqueued before the web socket is connected.
+
+ *  **OkHttp no longer attempts a direct connection if the system's HTTP proxy fails.** This
+    behavior was surprising because OkHttp was disregarding the user's specified configuration. If
+    you need to customize proxy fallback behavior, implement your own `java.net.ProxySelector`.
+
+ *  Fix: Support TLSv1.3 on devices that support it.
+
+ *  Fix: Share pooled connections across equivalent `OkHttpClient` instances. Previous releases had
+    a bug where a shared connection pool did not guarantee shared connections in some cases.
+ *  Fix: Prefer the server's response body on all conditional cache misses. Previously we would
+    return the cached response's body if it had a newer `Last-Modified` date.
+ *  Fix: Update the stored timestamp on conditional cache hits.
+ *  New: Optimized HTTP/2 request header encoding. More headers are HPACK-encoded and string
+    literals are now Huffman-encoded.
+ *  New: Expose `Part` headers and body in `Multipart`.
+ *  New: Make `ResponseBody.string()` and `ResponseBody.charStream()` BOM-aware. If your HTTP
+    response body begins with a [byte order mark][bom] it will be consumed and used to select a
+    charset for the remaining bytes. Most applications should not need a byte order mark.
+
+ *  New: Upgrade to Okio 1.11.0.
+
+     ```xml
+     <dependency>
+       <groupId>com.squareup.okio</groupId>
+       <artifactId>okio</artifactId>
+       <version>1.11.0</version>
+     </dependency>
+
+     com.squareup.okio:okio:1.11.0
+     ```
+
+ *  Fix: Avoid sending empty HTTP/2 data frames when there is no request body.
+ *  Fix: Add a leading `.` for better domain matching in `JavaNetCookieJar`.
+ *  Fix: Gracefully recover from HTTP/2 connection shutdowns at start of request.
+ *  Fix: Be lenient if a `MediaType`'s character set is `'single-quoted'`.
+ *  Fix: Allow horizontal tab characters in header values.
+ *  Fix: When parsing HTTP authentication headers permit challenge parameters in any order.
+
+
+## Version 3.4.2
+
+_2016-11-03_
+
+ *  Fix: Recover gracefully when an HTTP/2 connection is shutdown. We had a
+    bug where shutdown HTTP/2 connections were considered usable. This caused
+    infinite loops when calls attempted to recover.
+
+
+## Version 3.4.1
+
+_2016-07-10_
+
+ *  **Fix a major bug in encoding HTTP headers.** In 3.4.0 and 3.4.0-RC1 OkHttp
+    had an off-by-one bug in our HPACK encoder. This bug could have caused the
+    wrong headers to be emitted after a sequence of HTTP/2 requests! Everyone
+    who is using OkHttp 3.4.0 or 3.4.0-RC1 should upgrade for this bug fix.
+
+
+## Version 3.4.0
+
+_2016-07-08_
+
+ *  New: Support dynamic table size changes to HPACK Encoder.
+ *  Fix: Use `TreeMap` in `Headers.toMultimap()`. This makes string lookups on
+    the returned map case-insensitive.
+ *  Fix: Don't share the OkHttpClient's `Dispatcher` in `HttpURLConnection`.
+
+
+## Version 3.4.0-RC1
+
+_2016-07-02_
+
+ *  **We’ve rewritten HttpURLConnection and HttpsURLConnection.** Previously we
+    shared a single HTTP engine between two frontend APIs: `HttpURLConnection`
+    and `Call`. With this release we’ve rearranged things so that the
+    `HttpURLConnection` frontend now delegates to the `Call` APIs internally.
+    This has enabled substantial simplifications and optimizations in the OkHttp
+    core for both frontends.
+
+    For most HTTP requests the consequences of this change will be negligible.
+    If your application uses `HttpURLConnection.connect()`,
+    `setFixedLengthStreamingMode()`, or `setChunkedStreamingMode()`, OkHttp will
+    now use a async dispatcher thread to establish the HTTP connection.
+
+    We don’t expect this change to have any behavior or performance
+    consequences. Regardless, please exercise your `OkUrlFactory` and
+    `HttpURLConnection` code when applying this update.
+
+ *  **Cipher suites may now have arbitrary names.** Previously `CipherSuite` was
+    a Java enum and it was impossible to define new cipher suites without first
+    upgrading OkHttp. With this change it is now a regular Java class with
+    enum-like constants. Application code that uses enum methods on cipher
+    suites (`ordinal()`, `name()`, etc.) will break with this change.
+
+ *  Fix: `CertificatePinner` now matches canonicalized hostnames. Previously
+    this was case sensitive. This change should also make it easier to configure
+    certificate pinning for internationalized domain names.
+ *  Fix: Don’t crash on non-ASCII `ETag` headers. Previously OkHttp would reject
+    these headers when validating a cached response.
+ *  Fix: Don’t allow remote peer to arbitrarily size the HPACK decoder dynamic
+    table.
+ *  Fix: Honor per-host configuration in Android’s network security config.
+    Previously disabling cleartext for any host would disable cleartext for all
+    hosts. Note that this setting is only available on Android 24+.
+ *  New: HPACK compression is now dynamic. This should improve performance when
+    transmitting request headers over HTTP/2.
+ *  New: `Dispatcher.setIdleCallback()` can be used to signal when there are no
+    calls in flight. This is useful for [testing with
+    Espresso][okhttp_idling_resource].
+ *  New: Upgrade to Okio 1.9.0.
+
+     ```xml
+     <dependency>
+       <groupId>com.squareup.okio</groupId>
+       <artifactId>okio</artifactId>
+       <version>1.9.0</version>
+     </dependency>
+     ```
+
+
+## Version 3.3.1
+
+_2016-05-28_
+
+ *  Fix: The plaintext check in HttpLoggingInterceptor incorrectly classified
+    newline characters as control characters. This is fixed.
+ *  Fix: Don't crash reading non-ASCII characters in HTTP/2 headers or in cached
+    HTTP headers.
+ *  Fix: Retain the response body when an attempt to open a web socket returns a
+    non-101 response code.
+
+
+## Version 3.3.0
+
+_2016-05-24_
+
+ *  New: `Response.sentRequestAtMillis()` and `receivedResponseAtMillis()`
+    methods track the system's local time when network calls are made. These
+    replace the `OkHttp-Sent-Millis` and `OkHttp-Received-Millis` headers that were
+    present in earlier versions of OkHttp.
+ *  New: Accept user-provided trust managers in `OkHttpClient.Builder`. This
+    allows OkHttp to satisfy its TLS requirements directly. Otherwise OkHttp
+    will use reflection to extract the `TrustManager` from the
+    `SSLSocketFactory`.
+ *  New: Support prerelease Java 9. This gets ALPN from the platform rather than
+    relying on the alpn-boot bootclasspath override.
+ *  New: `HttpLoggingInterceptor` now logs connection failures.
+ *  New: Upgrade to Okio 1.8.0.
+
+     ```xml
+     <dependency>
+       <groupId>com.squareup.okio</groupId>
+       <artifactId>okio</artifactId>
+       <version>1.8.0</version>
+     </dependency>
+     ```
+
+ *  Fix: Gracefully recover from a failure to rebuild the cache journal.
+ *  Fix: Don't corrupt cache entries when a cache entry is evicted while it is
+    being updated.
+ *  Fix: Make logging more consistent throughout OkHttp.
+ *  Fix: Log plaintext bodies only. This uses simple heuristics to differentiate
+    text from other data.
+ *  Fix: Recover from `REFUSED_STREAM` errors in HTTP/2. This should improve
+    interoperability with Nginx 1.10.0, which [refuses][nginx_959] streams
+    created before HTTP/2 settings have been acknowledged.
+ *  Fix: Improve recovery from failed routes.
+ *  Fix: Accommodate tunneling proxies that close the connection after an auth
+    challenge.
+ *  Fix: Use the proxy authenticator when authenticating HTTP proxies. This
+    regression was introduced in OkHttp 3.0.
+ *  Fix: Fail fast if network interceptors transform the response body such that
+    closing it doesn't also close the underlying stream. We had a bug where
+    OkHttp would attempt to reuse a connection but couldn't because it was still
+    held by a prior request.
+ *  Fix: Ensure network interceptors always have access to the underlying
+    connection.
+ *  Fix: Use `X509TrustManagerExtensions` on Android 17+.
+ *  Fix: Unblock waiting dispatchers on MockWebServer shutdown.
+
+
+## Version 3.2.0
+
+_2016-02-25_
+
+ *  Fix: Change the certificate pinner to always build full chains. This
+    prevents a potential crash when using certificate pinning with the Google
+    Play Services security provider.
+ *  Fix: Make IPv6 request lines consistent with Firefox and Chrome.
+ *  Fix: Recover gracefully when trimming the response cache fails.
+ *  New: Add multiple path segments using a single string in `HttpUrl.Builder`.
+ *  New: Support SHA-256 pins in certificate pinner.
+
+
+## Version 3.1.2
+
+_2016-02-10_
+
+ *  Fix: Don’t crash when finding the trust manager on Robolectric. We attempted
+    to detect the host platform and got confused because Robolectric looks like
+    Android but isn’t!
+ *  Fix: Change `CertificatePinner` to skip sanitizing the certificate chain
+    when no certificates were pinned. This avoids an SSL failure in insecure
+    “trust everyone” configurations, such as when talking to a development
+    HTTPS server that has a self-signed certificate.
+
+
+## Version 3.1.1
+
+_2016-02-07_
+
+ *  Fix: Don't crash when finding the trust manager if the Play Services (GMS)
+    security provider is installed.
+ *  Fix: The previous release introduced a performance regression on Android,
+    caused by looking up CA certificates. This is now fixed.
+
+
+## Version 3.1.0
+
+_2016-02-06_
+
+ *  New: WebSockets now defer some writes. This should improve performance for
+    some applications.
+ *  New: Override `equals()` and `hashCode()` in our new cookie class. This
+    class now defines equality by value rather than by reference.
+ *  New: Handle 408 responses by retrying the request. This allows servers to
+    direct clients to retry rather than failing permanently.
+ *  New: Expose the framed protocol in `Connection`. Previously this would
+    return the application-layer protocol (HTTP/1.1 or HTTP/1.0); now it always
+    returns the wire-layer protocol (HTTP/2, SPDY/3.1, or HTTP/1.1).
+ *  Fix: Permit the trusted CA root to be pinned by `CertificatePinner`.
+ *  Fix: Silently ignore unknown HTTP/2 settings. Previously this would cause
+    the entire connection to fail.
+ *  Fix: Don’t crash on unexpected charsets in the logging interceptor.
+ *  Fix: `OkHttpClient` is now non-final for the benefit of mocking frameworks.
+    Mocking sophisticated classes like `OkHttpClient` is fragile and you
+    shouldn’t do it. But if that’s how you want to live your life we won’t stand
+    in your way!
+
+
+## Version 3.0.1
+
+_2016-01-14_
+
+ *  Rollback OSGi support. This was causing library jars to include more classes
+    than expected, which interfered with Gradle builds.
+
+
+## Version 3.0.0
+
+_2016-01-13_
+
+This release commits to a stable 3.0 API. Read the 3.0.0-RC1 changes for advice
+on upgrading from 2.x to 3.x.
+
+ *  **The `Callback` interface now takes a `Call`**. This makes it easier to
+    check if the call was canceled from within the callback. When migrating
+    async calls to this new API, `Call` is now the first parameter for both
+    `onResponse()` and `onFailure()`.
+ *  Fix: handle multiple cookies in `JavaNetCookieJar` on Android.
+ *  Fix: improve the default HTTP message in MockWebServer responses.
+ *  Fix: don't leak file handles when a conditional GET throws.
+ *  Fix: Use charset specified by the request body content type in OkHttp's
+    logging interceptor.
+ *  Fix: Don't eagerly release pools on cache hits.
+ *  New: Make OkHttp OSGi ready.
+ *  New: Add already-implemented interfaces Closeable and Flushable to the cache.
+
+## Version 3.0.0-RC1
+
+_2016-01-02_
+
+OkHttp 3 is a major release focused on API simplicity and consistency. The API
+changes are numerous but most are cosmetic. Applications should be able to
+upgrade from the 2.x API to the 3.x API mechanically and without risk.
+
+Because the release includes breaking API changes, we're changing the project's
+package name from `com.squareup.okhttp` to `okhttp3`. This should make it
+possible for large applications to migrate incrementally. The Maven group ID
+is now `com.squareup.okhttp3`. For an explanation of this strategy, see Jake
+Wharton's post, [Java Interoperability Policy for Major Version
+Updates][major_versions].
+
+This release obsoletes OkHttp 2.x, and all code that uses OkHttp's
+`com.squareup.okhttp` package should upgrade to the `okhttp3` package. Libraries
+that depend on OkHttp should upgrade quickly to prevent applications from being
+stuck on the old version.
+
+ *  **There is no longer a global singleton connection pool.** In OkHttp 2.x,
+    all `OkHttpClient` instances shared a common connection pool by default.
+    In OkHttp 3.x, each new `OkHttpClient` gets its own private connection pool.
+    Applications should avoid creating many connection pools as doing so
+    prevents connection reuse. Each connection pool holds its own set of
+    connections alive so applications that have many pools also risk exhausting
+    memory!
+
+    The best practice in OkHttp 3 is to create a single OkHttpClient instance
+    and share it throughout the application. Requests that needs a customized
+    client should call `OkHttpClient.newBuilder()` on that shared instance.
+    This allows customization without the drawbacks of separate connection
+    pools.
+
+ *  **OkHttpClient is now stateless.** In the 2.x API `OkHttpClient` had getters
+    and setters. Internally each request was forced to make its own complete
+    snapshot of the `OkHttpClient` instance to defend against racy configuration
+    changes. In 3.x, `OkHttpClient` is now stateless and has a builder. Note
+    that this class is not strictly immutable as it has stateful members like
+    the connection pool and cache.
+
+ *  **Get and Set prefixes are now avoided.** With ubiquitous builders
+    throughout OkHttp these accessor prefixes aren't necessary. Previously
+    OkHttp used _get_ and _set_ prefixes sporadically which make the API
+    inconsistent and awkward to explore.
+
+ *  **OkHttpClient now implements the new `Call.Factory` interface.** This
+    interface will make your code easier to test. When you test code that makes
+    HTTP requests, you can use this interface to replace the real `OkHttpClient`
+    with your own mocks or fakes.
+
+    The interface will also let you use OkHttp's API with another HTTP client's
+    implementation. This is useful in sandboxed environments like Google App
+    Engine.
+
+ *  **OkHttp now does cookies.** We've replaced `java.net.CookieHandler` with
+    a new interface, `CookieJar` and added our own `Cookie` model class. This
+    new cookie follows the latest RFC and supports the same cookie attributes
+    as modern web browsers.
+
+ *  **Form and Multipart bodies are now modeled.** We've replaced the opaque
+    `FormEncodingBuilder` with the more powerful `FormBody` and
+    `FormBody.Builder` combo. Similarly we've upgraded `MultipartBuilder` into
+    `MultipartBody`, `MultipartBody.Part`, and `MultipartBody.Builder`.
+
+ *  **The Apache HTTP client and HttpURLConnection APIs are deprecated.** They
+    continue to work as they always have, but we're moving everything to the new
+    OkHttp 3 API. The `okhttp-apache` and `okhttp-urlconnection` modules should
+    be only be used to accelerate a transition to OkHttp's request/response API.
+    These deprecated modules will be dropped in an upcoming OkHttp 3.x release.
+
+ *  **Canceling batches of calls is now the application's responsibility.**
+    The API to cancel calls by tag has been removed and replaced with a more
+    general mechanism. The dispatcher now exposes all in-flight calls via its
+    `runningCalls()` and `queuedCalls()` methods. You can write code that
+    selects calls by tag, host, or whatever, and invokes `Call.cancel()` on the
+    ones that are no longer necessary.
+
+ *  **OkHttp no longer uses the global `java.net.Authenticator` by default.**
+    We've changed our `Authenticator` interface to authenticate web and proxy
+    authentication failures through a single method. An adapter for the old
+    authenticator is available in the `okhttp-urlconnection` module.
+
+ *  Fix: Don't throw `IOException` on `ResponseBody.contentLength()` or `close()`.
+ *  Fix: Never throw converting an `HttpUrl` to a `java.net.URI`. This changes
+    the `uri()` method to handle malformed percent-escapes and characters
+    forbidden by `URI`.
+ *  Fix: When a connect times out, attempt an alternate route. Previously route
+    selection was less efficient when differentiating failures.
+ *  New: `Response.peekBody()` lets you access the response body without
+    consuming it. This may be handy for interceptors!
+ *  New: `HttpUrl.newBuilder()` resolves a link to a builder.
+ *  New: Add the TLS version to the `Handshake`.
+ *  New: Drop `Request.uri()` and `Request#urlString()`. Just use
+    `Request.url().uri()` and `Request.url().toString()`.
+ *  New: Add URL to HTTP response logging.
+ *  New: Make `HttpUrl` the blessed URL method of `Request`.
+
+
+## Version 2.7.5
+
+_2016-02-25_
+
+ *  Fix: Change the certificate pinner to always build full chains. This
+    prevents a potential crash when using certificate pinning with the Google
+    Play Services security provider.
+
+
+## Version 2.7.4
+
+_2016-02-07_
+
+ *  Fix: Don't crash when finding the trust manager if the Play Services (GMS)
+    security provider is installed.
+ *  Fix: The previous release introduced a performance regression on Android,
+    caused by looking up CA certificates. This is now fixed.
+
+
+## Version 2.7.3
+
+_2016-02-06_
+
+ *  Fix: Permit the trusted CA root to be pinned by `CertificatePinner`.
+
+
+## Version 2.7.2
+
+_2016-01-07_
+
+ *  Fix: Don't eagerly release stream allocations on cache hits. We might still
+    need them to handle redirects.
+
+
+## Version 2.7.1
+
+_2016-01-01_
+
+ *  Fix: Don't do a health check on newly-created connections. This is
+    unnecessary work that could put the client in an inconsistent state if the
+    health check fails.
+
+
+## Version 2.7.0
+
+_2015-12-13_
+
+ *  **Rewritten connection management.** Previously OkHttp's connection pool
+    managed both idle and active connections for HTTP/2, but only idle
+    connections for HTTP/1.x. With this update the connection pool manages both
+    idle and active connections for everything. OkHttp now detects and warns on
+    connections that were allocated but never released, and will enforce HTTP/2
+    stream limits. This update also fixes `Call.cancel()` to not do I/O on the
+    calling thread.
+ *  Fix: Don't log gzipped data in the logging interceptor.
+ *  Fix: Don't resolve DNS addresses when connecting through a SOCKS proxy.
+ *  Fix: Drop the synthetic `OkHttp-Selected-Protocol` response header.
+ *  Fix: Support 204 and 205 'No Content' replies in the logging interceptor.
+ *  New: Add `Call.isExecuted()`.
+
+
+## Version 2.6.0
+
+_2015-11-22_
+
+ *  **New Logging Interceptor.** The `logging-interceptor` subproject offers
+    simple request and response logging. It may be configured to log headers and
+    bodies for debugging. It requires this Maven dependency:
+
+     ```xml
+     <dependency>
+       <groupId>com.squareup.okhttp</groupId>
+       <artifactId>logging-interceptor</artifactId>
+       <version>2.6.0</version>
+     </dependency>
+     ```
+
+    Configure basic logging like this:
+
+    ```java
+    HttpLoggingInterceptor loggingInterceptor = new HttpLoggingInterceptor();
+    loggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BASIC);
+    client.networkInterceptors().add(loggingInterceptor);
+    ```
+
+    **Warning:** Avoid `Level.HEADERS` and `Level.BODY` in production because
+    they could leak passwords and other authentication credentials to insecure
+    logs.
+
+ *  **WebSocket API now uses `RequestBody` and `ResponseBody` for messages.**
+    This is a backwards-incompatible API change.
+
+ *  **The DNS service is now pluggable.** In some situations this may be useful
+    to manually prioritize specific IP addresses.
+
+ *  Fix: Don't throw when converting an `HttpUrl` to a `java.net.URI`.
+    Previously URLs with special characters like `|` and `[` would break when
+    subjected to URI’s overly-strict validation.
+ *  Fix: Don't re-encode `+` as `%20` in encoded URL query strings. OkHttp
+    prefers `%20` when doing its own encoding, but will retain `+` when that is
+    provided.
+ *  Fix: Enforce that callers call `WebSocket.close()` on IO errors. Error
+    handling in WebSockets is significantly improved.
+ *  Fix: Don't use SPDY/3 style header concatenation for HTTP/2 request headers.
+    This could have corrupted requests where multiple headers had the same name,
+    as in cookies.
+ *  Fix: Reject bad characters in the URL hostname. Previously characters like
+    `\0` would cause a late crash when building the request.
+ *  Fix: Allow interceptors to change the request method.
+ *  Fix: Don’t use the request's `User-Agent` or `Proxy-Authorization` when
+    connecting to an HTTPS server via an HTTP tunnel. The `Proxy-Authorization`
+    header was being leaked to the origin server.
+ *  Fix: Digits may be used in a URL scheme.
+ *  Fix: Improve connection timeout recovery.
+ *  Fix: Recover from `getsockname` crashes impacting Android releases prior to
+    4.2.2.
+ *  Fix: Drop partial support for HTTP/1.0. Previously OkHttp would send
+    `HTTP/1.0` on connections after seeing a response with `HTTP/1.0`. The fixed
+    behavior is consistent with Firefox and Chrome.
+ *  Fix: Allow a body in `OPTIONS` requests.
+ *  Fix: Don't percent-encode non-ASCII characters in URL fragments.
+ *  Fix: Handle null fragments.
+ *  Fix: Don’t crash on interceptors that throw `IOException` before a
+    connection is attempted.
+ *  New: Support [WebDAV][webdav] HTTP methods.
+ *  New: Buffer WebSocket frames for better performance.
+ *  New: Drop support for `TLS_DHE_DSS_WITH_AES_128_CBC_SHA`, our only remaining
+    DSS cipher suite. This is consistent with Firefox and Chrome which have also
+    dropped these cipher suite.
+
+## Version 2.5.0
+
+_2015-08-25_
+
+ *  **Timeouts now default to 10 seconds.** Previously we defaulted to never
+    timing out, and that was a lousy policy. If establishing a connection,
+    reading the next byte from a connection, or writing the next byte to a
+    connection takes more than 10 seconds to complete, you’ll need to adjust
+    the timeouts manually.
+
+ *  **OkHttp now rejects request headers that contain invalid characters.** This
+    includes potential security problems (newline characters) as well as simple
+    non-ASCII characters (including international characters and emoji).
+
+ *  **Call canceling is more reliable.**  We had a bug where a socket being
+     connected wasn't being closed when the application used `Call.cancel()`.
+
+ *  **Changing a HttpUrl’s scheme now tracks the default port.** We had a bug
+    where changing a URL from `http` to `https` would leave it on port 80.
+
+ *  **Okio has been updated to 1.6.0.**
+     ```xml
+     <dependency>
+       <groupId>com.squareup.okio</groupId>
+       <artifactId>okio</artifactId>
+       <version>1.6.0</version>
+     </dependency>
+     ```
+
+ *  New: `Cache.initialize()`. Call this on a background thread to eagerly
+    initialize the response cache.
+ *  New: Fold `MockWebServerRule` into `MockWebServer`. This makes it easier to
+    write JUnit tests with `MockWebServer`. The `MockWebServer` library now
+    depends on JUnit, though it continues to work with all testing frameworks.
+ *  Fix: `FormEncodingBuilder` is now consistent with browsers in which
+    characters it escapes. Previously we weren’t percent-encoding commas,
+    parens, and other characters.
+ *  Fix: Relax `FormEncodingBuilder` to support building empty forms.
+ *  Fix: Timeouts throw `SocketTimeoutException`, not `InterruptedIOException`.
+ *  Fix: Change `MockWebServer` to use the same logic as OkHttp when determining
+    whether an HTTP request permits a body.
+ *  Fix: `HttpUrl` now uses the canonical form for IPv6 addresses.
+ *  Fix: Use `HttpUrl` internally.
+ *  Fix: Recover from Android 4.2.2 EBADF crashes.
+ *  Fix: Don't crash with an `IllegalStateException` if an HTTP/2 or SPDY
+    write fails, leaving the connection in an inconsistent state.
+ *  Fix: Make sure the default user agent is ASCII.
+
+
+## Version 2.4.0
+
+_2015-05-22_
+
+ *  **Forbid response bodies on HTTP 204 and 205 responses.** Webservers that
+    return such malformed responses will now trigger a `ProtocolException` in
+    the client.
+
+ *  **WebSocketListener has incompatible changes.** The `onOpen()` method is now
+    called on the reader thread, so implementations must return before further
+    websocket messages will be delivered. The `onFailure()` method now includes
+    an HTTP response if one was returned.
+
+## Version 2.4.0-RC1
+
+_2015-05-16_
+
+ *  **New HttpUrl API.** It's like `java.net.URL` but good. Note that
+    `Request.Builder.url()` now throws `IllegalArgumentException` on malformed
+    URLs. (Previous releases would throw a `MalformedURLException` when calling
+    a malformed URL.)
+
+ *  **We've improved connect failure recovery.** We now differentiate between
+    setup, connecting, and connected and implement appropriate recovery rules
+    for each. This changes `Address` to no longer use `ConnectionSpec`. (This is
+    an incompatible API change).
+
+ *  **`FormEncodingBuilder` now uses `%20` instead of `+` for encoded spaces.**
+    Both are permitted-by-spec, but `%20` requires fewer special cases.
+
+ *  **Okio has been updated to 1.4.0.**
+     ```xml
+     <dependency>
+       <groupId>com.squareup.okio</groupId>
+       <artifactId>okio</artifactId>
+       <version>1.4.0</version>
+     </dependency>
+     ```
+
+ *  **`Request.Builder` no longer accepts null if a request body is required.**
+    Passing null will now fail for request methods that require a body. Instead
+    use an empty body such as this one:
+
+    ```java
+        RequestBody.create(null, new byte[0]);
+    ```
+
+ * **`CertificatePinner` now supports wildcard hostnames.** As always with
+   certificate pinning, you must be very careful to avoid [bricking][brick]
+   your app. You'll need to pin both the top-level domain and the `*.` domain
+   for full coverage.
+
+    ```java
+     client.setCertificatePinner(new CertificatePinner.Builder()
+         .add("publicobject.com",   "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=")
+         .add("*.publicobject.com", "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=")
+         .add("publicobject.com",   "sha1/SXxoaOSEzPC6BgGmxAt/EAcsajw=")
+         .add("*.publicobject.com", "sha1/SXxoaOSEzPC6BgGmxAt/EAcsajw=")
+         .add("publicobject.com",   "sha1/blhOM3W9V/bVQhsWAcLYwPU6n24=")
+         .add("*.publicobject.com", "sha1/blhOM3W9V/bVQhsWAcLYwPU6n24=")
+         .add("publicobject.com",   "sha1/T5x9IXmcrQ7YuQxXnxoCmeeQ84c=")
+         .add("*.publicobject.com", "sha1/T5x9IXmcrQ7YuQxXnxoCmeeQ84c=")
+         .build());
+    ```
+
+ *  **Interceptors lists are now deep-copied by `OkHttpClient.clone()`.**
+    Previously clones shared interceptors, which made it difficult to customize
+    the interceptors on a request-by-request basis.
+
+ *  New: `Headers.toMultimap()`.
+ *  New: `RequestBody.create(MediaType, ByteString)`.
+ *  New: `ConnectionSpec.isCompatible(SSLSocket)`.
+ *  New: `Dispatcher.getQueuedCallCount()` and
+    `Dispatcher.getRunningCallCount()`. These can be useful in diagnostics.
+ *  Fix: OkHttp no longer shares timeouts between pooled connections. This was
+    causing some applications to crash when connections were reused.
+ *  Fix: `OkApacheClient` now allows an empty `PUT` and `POST`.
+ *  Fix: Websockets no longer rebuffer socket streams.
+ *  Fix: Websockets are now better at handling close frames.
+ *  Fix: Content type matching is now case insensitive.
+ *  Fix: `Vary` headers are not lost with `android.net.http.HttpResponseCache`.
+ *  Fix: HTTP/2 wasn't enforcing stream timeouts when writing the underlying
+    connection. Now it is.
+ *  Fix: Never return null on `call.proceed()`. This was a bug in call
+    cancelation.
+ *  Fix: When a network interceptor mutates a request, that change is now
+    reflected in `Response.networkResponse()`.
+ *  Fix: Badly-behaving caches now throw a checked exception instead of a
+    `NullPointerException`.
+ *  Fix: Better handling of uncaught exceptions in MockWebServer with HTTP/2.
+
+## Version 2.3.0
+
+_2015-03-16_
+
+ *  **HTTP/2 support.** We've done interop testing and haven't seen any
+    problems. HTTP/2 support has been a big effort and we're particularly
+    thankful to Adrian Cole who has helped us to reach this milestone.
+
+ *  **RC4 cipher suites are no longer supported by default.** To connect to
+    old, obsolete servers relying on these cipher suites, you must create a
+    custom `ConnectionSpec`.
+
+ *  **Beta WebSockets support.**. The `okhttp-ws` subproject offers a new
+    websockets client. Please try it out! When it's ready we intend to include
+    it with the core OkHttp library.
+
+ *  **Okio updated to 1.3.0.**
+
+    ```xml
+    <dependency>
+      <groupId>com.squareup.okio</groupId>
+      <artifactId>okio</artifactId>
+      <version>1.3.0</version>
+    </dependency>
+    ```
+
+ *  **Fix: improve parallelism of async requests.** OkHttp's Dispatcher had a
+    misconfigured `ExecutorService` that limited the number of worker threads.
+    If you're using `Call.enqueue()` this update should significantly improve
+    request concurrency.
+
+ *  **Fix: Lazily initialize the response cache.** This avoids strict mode
+    warnings when initializing OkHttp on Android‘s main thread.
+
+ *  **Fix: Disable ALPN on Android 4.4.** That release of the feature was
+    unstable and prone to native crashes in the underlying OpenSSL code.
+ *  Fix: Don't send both `If-None-Match` and `If-Modified-Since` cache headers
+    when both are applicable.
+ *  Fix: Fail early when a port is out of range.
+ *  Fix: Offer `Content-Length` headers for multipart request bodies.
+ *  Fix: Throw `UnknownServiceException` if a cleartext connection is attempted
+    when explicitly forbidden.
+ *  Fix: Throw a `SSLPeerUnverifiedException` when host verification fails.
+ *  Fix: MockWebServer explicitly closes sockets. (On some Android releases,
+    closing the input stream and output stream of a socket is not sufficient.
+ *  Fix: Buffer outgoing HTTP/2 frames to limit how many outgoing frames are
+    created.
+ *  Fix: Avoid crashing when cache writing fails due to a full disk.
+ *  Fix: Improve caching of private responses.
+ *  Fix: Update cache-by-default response codes.
+ *  Fix: Reused `Request.Builder` instances no longer hold stale URL fields.
+ *  New: ConnectionSpec can now be configured to use the SSL socket's default
+    cipher suites. To use, set the cipher suites to `null`.
+ *  New: Support `DELETE` with a request body.
+ *  New: `Headers.of(Map)` creates headers from a Map.
+
+
+## Version 2.2.0
+
+_2014-12-30_
+
+ *  **`RequestBody.contentLength()` now throws `IOException`.**
+    This is a source-incompatible change. If you have code that calls
+    `RequestBody.contentLength()`, your compile will break with this
+    update. The change is binary-compatible, however: code compiled
+    for OkHttp 2.0 and 2.1 will continue to work with this update.
+
+ *  **`COMPATIBLE_TLS` no longer supports SSLv3.** In response to the
+    [POODLE](http://googleonlinesecurity.blogspot.ca/2014/10/this-poodle-bites-exploiting-ssl-30.html)
+    vulnerability, OkHttp no longer offers SSLv3 when negotiation an
+    HTTPS connection. If you continue to need to connect to webservers
+    running SSLv3, you must manually configure your own `ConnectionSpec`.
+
+ *  **OkHttp now offers interceptors.** Interceptors are a powerful mechanism
+    that can monitor, rewrite, and retry calls. The [project
+    wiki](https://github.com/square/okhttp/wiki/Interceptors) has a full
+    introduction to this new API.
+
+ *  New: APIs to iterate and selectively clear the response cache.
+ *  New: Support for SOCKS proxies.
+ *  New: Support for `TLS_FALLBACK_SCSV`.
+ *  New: Update HTTP/2 support to `h2-16` and `hpack-10`.
+ *  New: APIs to prevent retrying non-idempotent requests.
+ *  Fix: Drop NPN support. Going forward we support ALPN only.
+ *  Fix: The hostname verifier is now strict. This is consistent with the hostname
+    verifier in modern browsers.
+ *  Fix: Improve `CONNECT` handling for misbehaving HTTP proxies.
+ *  Fix: Don't retry requests that failed due to timeouts.
+ *  Fix: Cache 302s and 308s that include appropriate response headers.
+ *  Fix: Improve pooling of connections that use proxy selectors.
+ *  Fix: Don't leak connections when using ALPN on the desktop.
+ *  Fix: Update Jetty ALPN to `7.1.2.v20141202` (Java 7) and `8.1.2.v20141202` (Java 8).
+    This fixes a bug in resumed TLS sessions where the wrong protocol could be
+    selected.
+ *  Fix: Don't crash in SPDY and HTTP/2 when disconnecting before connecting.
+ *  Fix: Avoid a reverse DNS-lookup for a numeric proxy address
+ *  Fix: Resurrect http/2 frame logging.
+ *  Fix: Limit to 20 authorization attempts.
+
+## Version 2.1.0
+
+_2014-11-11_
+
+ *  New: Typesafe APIs for interacting with cipher suites and TLS versions.
+ *  Fix: Don't crash when mixing authorization challenges with upload retries.
+
+
+## Version 2.1.0-RC1
+
+_2014-11-04_
+
+ *  **OkHttp now caches private responses**. We've changed from a shared cache
+    to a private cache, and will now store responses that use an `Authorization`
+    header. This means OkHttp's cache shouldn't be used on middleboxes that sit
+    between user agents and the origin server.
+
+ *  **TLS configuration updated.** OkHttp now explicitly enables TLSv1.2,
+    TLSv1.1 and TLSv1.0 where they are supported. It will continue to perform
+    only one fallback, to SSLv3. Applications can now configure this with the
+    `ConnectionSpec` class.
+
+    To disable TLS fallback:
+
+    ```java
+    client.setConnectionSpecs(Arrays.asList(
+        ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT));
+    ```
+
+    To disable cleartext connections, permitting `https` URLs only:
+
+    ```java
+    client.setConnectionSpecs(Arrays.asList(
+        ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS));
+    ```
+
+ *  **New cipher suites.** Please confirm that your webservers are reachable
+    with this limited set of cipher suites.
+
+    ```
+                                             Android
+    Name                                     Version
+
+    TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256  5.0
+    TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256    5.0
+    TLS_DHE_RSA_WITH_AES_128_GCM_SHA256      5.0
+    TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA     4.0
+    TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA     4.0
+    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA       4.0
+    TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA       4.0
+    TLS_ECDHE_ECDSA_WITH_RC4_128_SHA         4.0
+    TLS_ECDHE_RSA_WITH_RC4_128_SHA           4.0
+    TLS_DHE_RSA_WITH_AES_128_CBC_SHA         2.3
+    TLS_DHE_DSS_WITH_AES_128_CBC_SHA         2.3
+    TLS_DHE_RSA_WITH_AES_256_CBC_SHA         2.3
+    TLS_RSA_WITH_AES_128_GCM_SHA256          5.0
+    TLS_RSA_WITH_AES_128_CBC_SHA             2.3
+    TLS_RSA_WITH_AES_256_CBC_SHA             2.3
+    SSL_RSA_WITH_3DES_EDE_CBC_SHA            2.3  (Deprecated in 5.0)
+    SSL_RSA_WITH_RC4_128_SHA                 2.3
+    SSL_RSA_WITH_RC4_128_MD5                 2.3  (Deprecated in 5.0)
+    ```
+
+ *  **Okio updated to 1.0.1.**
+
+    ```xml
+    <dependency>
+      <groupId>com.squareup.okio</groupId>
+      <artifactId>okio</artifactId>
+      <version>1.0.1</version>
+    </dependency>
+    ```
+
+ *  **New APIs to permit easy certificate pinning.** Be warned, certificate
+    pinning is dangerous and could prevent your application from trusting your
+    server!
+
+ *  **Cache improvements.** This release fixes some severe cache problems
+    including a bug where the cache could be corrupted upon certain access
+    patterns. We also fixed a bug where the cache was being cleared due to a
+    corrupted journal. We've added APIs to configure a request's `Cache-Control`
+    headers, and to manually clear the cache.
+
+ *  **Request cancellation fixes.** This update fixes a bug where synchronous
+    requests couldn't be canceled by tag. This update avoids crashing when
+    `onResponse()` throws an `IOException`. That failure will now be logged
+    instead of notifying the thread's uncaught exception handler. We've added a
+    new API, `Call.isCanceled()` to check if a call has been canceled.
+
+ *  New: Update `MultipartBuilder` to support content length.
+ *  New: Make it possible to mock `OkHttpClient` and `Call`.
+ *  New: Update to h2-14 and hpack-9.
+ *  New: OkHttp includes a user-agent by default, like `okhttp/2.1.0-RC1`.
+ *  Fix: Handle response code `308 Permanent Redirect`.
+ *  Fix: Don't skip the callback if a call is canceled.
+ *  Fix: Permit hostnames with underscores.
+ *  Fix: Permit overriding the content-type in `OkApacheClient`.
+ *  Fix: Use the socket factory for direct connections.
+ *  Fix: Honor `OkUrlFactory` APIs that disable redirects.
+ *  Fix: Don't crash on concurrent modification of `SPDY` SPDY settings.
+
+## Version 2.0.0
+
+This release commits to a stable 2.0 API. Read the 2.0.0-RC1 changes for advice
+on upgrading from 1.x to 2.x.
+
+_2014-06-21_
+
+ *  **API Change**: Use `IOException` in `Callback.onFailure()`. This is
+    a source-incompatible change, and is different from OkHttp 2.0.0-RC2 which
+    used `Throwable`.
+ *  Fix: Fixed a caching bug where we weren't storing rewritten request headers
+    like `Accept-Encoding`.
+ *  Fix: Fixed bugs in handling the SPDY window size. This was stalling certain
+    large downloads
+ *  Update the language level to Java 7. (OkHttp requires Android 2.3+ or Java 7+.)
+
+## Version 2.0.0-RC2
+
+_2014-06-11_
+
+This update fixes problems in 2.0.0-RC1. Read the 2.0.0-RC1 changes for
+advice on upgrading from 1.x to 2.x.
+
+ *  Fix: Don't leak connections! There was a regression in 2.0.0-RC1 where
+    connections were neither closed nor pooled.
+ *  Fix: Revert builder-style return types from OkHttpClient's timeout methods
+    for binary compatibility with OkHttp 1.x.
+ *  Fix: Don't skip client stream 1 on SPDY/3.1. This fixes SPDY connectivity to
+    `https://google.com`, which doesn't follow the SPDY/3.1 spec!
+ *  Fix: Always configure NPN headers. This fixes connectivity to
+    `https://facebook.com` when SPDY and HTTP/2 are both disabled. Otherwise an
+    unexpected NPN response is received and OkHttp crashes.
+ *  Fix: Write continuation frames when HPACK data is larger than 16383 bytes.
+ *  Fix: Don't drop uncaught exceptions thrown in async calls.
+ *  Fix: Throw an exception eagerly when a request body is not legal. Previously
+    we ignored the problem at request-building time, only to crash later with a
+    `NullPointerException`.
+ *  Fix: Include a backwards-compatible `OkHttp-Response-Source` header with
+    `OkUrlFactory `responses.
+ *  Fix: Don't include a default User-Agent header in requests made with the Call
+    API. Requests made with OkUrlFactory will continue to have a default user
+    agent.
+ *  New: Guava-like API to create headers:
+
+    ```java
+    Headers headers = Headers.of(name1, value1, name2, value2, ...).
+    ```
+
+ *  New: Make the content-type header optional for request bodies.
+ *  New: `Response.isSuccessful()` is a convenient API to check response codes.
+ *  New: The response body can now be read outside of the callback. Response
+    bodies must always be closed, otherwise they will leak connections!
+ *  New: APIs to create multipart request bodies (`MultipartBuilder`) and form
+    encoding bodies (`FormEncodingBuilder`).
+
+## Version 2.0.0-RC1
+
+_2014-05-23_
+
+OkHttp 2 is designed around a new API that is true to HTTP, with classes for
+requests, responses, headers, and calls. It uses modern Java patterns like
+immutability and chained builders. The API now offers asynchronous callbacks
+in addition to synchronous blocking calls.
+
+#### API Changes
+
+ *  **New Request and Response types,** each with their own builder. There's also
+    a `RequestBody` class to write the request body to the network and a
+    `ResponseBody` to read the response body from the network. The standalone
+    `Headers` class offers full access to the HTTP headers.
+
+ *  **Okio dependency added.** OkHttp now depends on
+    [Okio](https://github.com/square/okio), an I/O library that makes it easier
+    to access, store and process data. Using this library internally makes OkHttp
+    faster while consuming less memory. You can write a `RequestBody` as an Okio
+    `BufferedSink` and a `ResponseBody` as an Okio `BufferedSource`. Standard
+    `InputStream` and `OutputStream` access is also available.
+
+ *  **New Call and Callback types** execute requests and receive their
+    responses. Both types of calls can be canceled via the `Call` or the
+    `OkHttpClient`.
+
+ *  **URLConnection support has moved to the okhttp-urlconnection module.**
+    If you're upgrading from 1.x, this change will impact you. You will need to
+    add the `okhttp-urlconnection` module to your project and use the
+    `OkUrlFactory` to create new instances of `HttpURLConnection`:
+
+    ```java
+    // OkHttp 1.x:
+    HttpURLConnection connection = client.open(url);
+
+    // OkHttp 2.x:
+    HttpURLConnection connection = new OkUrlFactory(client).open(url);
+    ```
+
+ *  **Custom caches are no longer supported.** In OkHttp 1.x it was possible to
+    define your own response cache with the `java.net.ResponseCache` and OkHttp's
+    `OkResponseCache` interfaces. Both of these APIs have been dropped. In
+    OkHttp 2 the built-in disk cache is the only supported response cache.
+
+ *  **HttpResponseCache has been renamed to Cache.** Install it with
+    `OkHttpClient.setCache(...)` instead of `OkHttpClient.setResponseCache(...)`.
+
+ *  **OkAuthenticator has been replaced with Authenticator.** This new
+    authenticator has access to the full incoming response and can respond with
+    whichever followup request is appropriate. The `Challenge` class is now a
+    top-level class and `Credential` is replaced with a utility class called
+    `Credentials`.
+
+ *  **OkHttpClient.getFollowProtocolRedirects() renamed to
+    getFollowSslRedirects()**. We reserve the word _protocol_ for the HTTP
+    version being used (HTTP/1.1, HTTP/2). The old name of this method was
+    misleading; it was always used to configure redirects between `https://` and
+    `http://` schemes.
+
+ *  **RouteDatabase is no longer public API.** OkHttp continues to track which
+    routes have failed but this is no exposed in the API.
+
+ *  **ResponseSource is gone.** This enum exposed whether a response came from
+    the cache, network, or both. OkHttp 2 offers more detail with raw access to
+    the cache and network responses in the new `Response` class.
+
+ *  **TunnelRequest is gone.** It specified how to connect to an HTTP proxy.
+    OkHttp 2 uses the new `Request` class for this.
+
+ *  **Dispatcher** is a new class that manages the queue of asynchronous calls. It
+    implements limits on total in-flight calls and in-flight calls per host.
+
+#### Implementation changes
+
+ * Support Android `TrafficStats` socket tagging.
+ * Drop authentication headers on redirect.
+ * Added support for compressed data frames.
+ * Process push promise callbacks in order.
+ * Update to http/2 draft 12.
+ * Update to HPACK draft 07.
+ * Add ALPN support. Maven will use ALPN on OpenJDK 8.
+ * Update NPN dependency to target `jdk7u60-b13` and `Oracle jdk7u55-b13`.
+ * Ensure SPDY variants support zero-length DELETE and POST.
+ * Prevent leaking a cache item's InputStreams when metadata read fails.
+ * Use a string to identify TLS versions in routes.
+ * Add frame logger for HTTP/2.
+ * Replacing `httpMinorVersion` with `Protocol`. Expose HTTP/1.0 as a potential protocol.
+ * Use `Protocol` to describe framing.
+ * Implement write timeouts for HTTP/1.1 streams.
+ * Avoid use of SPDY stream ID 1, as that's typically used for UPGRADE.
+ * Support OAuth in `Authenticator`.
+ * Permit a dangling semicolon in media type parsing.
+
+## Version 1.6.0
+
+_2014-05-23_
+
+ * Offer bridges to make it easier to migrate from OkHttp 1.x to OkHttp 2.0.
+   This adds `OkUrlFactory`, `Cache`, and `@Deprecated` annotations for APIs
+   dropped in 2.0.
+
+## Version 1.5.4
+
+_2014-04-14_
+
+ * Drop ALPN support in Android. There's a concurrency bug in all
+   currently-shipping versions.
+ * Support asynchronous disconnects by breaking the socket only. This should
+   prevent flakiness from multiple threads concurrently accessing a stream.
+
+## Version 1.5.3
+
+_2014-03-29_
+
+ * Fix bug where the Content-Length header was not always dropped when
+   following a redirect from a POST to a GET.
+ * Implement basic support for `Thread.interrupt()`. OkHttp now checks
+   for an interruption before doing a blocking call. If it is interrupted,
+   it throws an `InterruptedIOException`.
+
+## Version 1.5.2
+
+_2014-03-17_
+
+ * Fix bug where deleting a file that was absent from the `HttpResponseCache`
+   caused an IOException.
+ * Fix bug in HTTP/2 where our HPACK decoder wasn't emitting entries in
+   certain eviction scenarios, leading to dropped response headers.
+
+## Version 1.5.1
+
+_2014-03-11_
+
+ * Fix 1.5.0 regression where connections should not have been recycled.
+ * Fix 1.5.0 regression where transparent Gzip was broken by attempting to
+   recover from another I/O failure.
+ * Fix problems where spdy/3.1 headers may not have been compressed properly.
+ * Fix problems with spdy/3.1 and http/2 where the wrong window size was being
+   used.
+ * Fix 1.5.0 regression where conditional cache responses could corrupt the
+   connection pool.
+
+
+## Version 1.5.0
+
+_2014-03-07_
+
+
+##### OkHttp no longer uses the default SSL context.
+
+Applications that want to use the global SSL context with OkHttp should configure their
+OkHttpClient instances with the following:
+
+```java
+okHttpClient.setSslSocketFactory(HttpsURLConnection.getDefaultSSLSocketFactory());
+```
+
+A simpler solution is to avoid the shared default SSL socket factory. Instead, if you
+need to customize SSL, do so for your specific OkHttpClient instance only.
+
+##### Synthetic headers have changed
+
+Previously OkHttp added a synthetic response header, `OkHttp-Selected-Transport`. It
+has been replaced with a new synthetic header, `OkHttp-Selected-Protocol`.
+
+##### Changes
+
+ * New: Support for `HTTP-draft-09/2.0`.
+ * New: Support for `spdy/3.1`. Dropped support for `spdy/3`.
+ * New: Use ALPN on Android platforms that support it (4.4+)
+ * New: CacheControl model and parser.
+ * New: Protocol selection in MockWebServer.
+ * Fix: Route selection shouldn't use TLS modes that we know will fail.
+ * Fix: Cache SPDY responses even if the response body is closed prematurely.
+ * Fix: Use strict timeouts when aborting a download.
+ * Fix: Support Shoutcast HTTP responses like `ICY 200 OK`.
+ * Fix: Don't unzip if there isn't a response body.
+ * Fix: Don't leak gzip streams on redirects.
+ * Fix: Don't do DNS lookups on invalid hosts.
+ * Fix: Exhaust the underlying stream when reading gzip streams.
+ * Fix: Support the `PATCH` method.
+ * Fix: Support request bodies on `DELETE` method.
+ * Fix: Drop the `okhttp-protocols` module.
+ * Internal: Replaced internal byte array buffers with pooled buffers ("OkBuffer").
+
+
+## Version 1.3.0
+
+_2014-01-11_
+
+ * New: Support for "PATCH" HTTP method in client and MockWebServer.
+ * Fix: Drop `Content-Length` header when redirected from POST to GET.
+ * Fix: Correctly read cached header entries with malformed header names.
+ * Fix: Do not directly support any authentication schemes other than "Basic".
+ * Fix: Respect read timeouts on recycled connections.
+ * Fix: Transmit multiple cookie values as a single header with delimiter.
+ * Fix: Ensure `null` is never returned from a connection's `getHeaderFields()`.
+ * Fix: Persist proper `Content-Encoding` header to cache for GZip responses.
+ * Fix: Eliminate rare race condition in SPDY streams that would prevent connection reuse.
+ * Fix: Change HTTP date formats to UTC to conform to RFC2616 section 3.3.
+ * Fix: Support SPDY header blocks with trailing bytes.
+ * Fix: Allow `;` as separator for `Cache-Control` header.
+ * Fix: Correct bug where HTTPS POST requests were always automatically buffered.
+ * Fix: Honor read timeout when parsing SPDY headers.
+
+
+## Version 1.2.1
+
+_2013-08-23_
+
+ * Resolve issue with 'jar-with-dependencies' artifact creation.
+ * Fix: Support empty SPDY header values.
+
+
+## Version 1.2.0
+
+_2013-08-11_
+
+ *  New APIs on OkHttpClient to set default timeouts for connect and read.
+ *  Fix bug when caching SPDY responses.
+ *  Fix a bug with SPDY plus half-closed streams. (thanks kwuollett)
+ *  Fix a bug in `Content-Length` reporting for gzipped streams in the Apache
+    HTTP client adapter. (thanks kwuollett)
+ *  Work around the Alcatel `getByInetAddress` bug (thanks k.kocel)
+ *  Be more aggressive about testing pooled sockets before reuse. (thanks
+    warpspin)
+ *  Include `Content-Type` and `Content-Encoding` in the Apache HTTP client
+    adapter. (thanks kwuollett)
+ *  Add a media type class to OkHttp.
+ *  Change custom header prefix:
+
+    ```
+    X-Android-Sent-Millis is now OkHttp-Sent-Millis
+    X-Android-Received-Millis is now OkHttp-Received-Millis
+    X-Android-Response-Source is now OkHttp-Response-Source
+    X-Android-Selected-Transport is now OkHttp-Selected-Transport
+    ```
+ *  Improve cache invalidation for POST-like requests.
+ *  Bring MockWebServer into OkHttp and teach it SPDY.
+
+
+## Version 1.1.1
+
+_2013-06-23_
+
+ * Fix: ClassCastException when caching responses that were redirected from
+   HTTP to HTTPS.
+
+
+## Version 1.1.0
+
+_2013-06-15_
+
+ * Fix: Connection reuse was broken for most HTTPS connections due to a bug in
+   the way the hostname verifier was selected.
+ * Fix: Locking bug in SpdyConnection.
+ * Fix: Ignore null header values (for compatibility with HttpURLConnection).
+ * Add URLStreamHandlerFactory support so that `URL.openConnection()` uses
+   OkHttp.
+ * Expose the transport ("http/1.1", "spdy/3", etc.) via magic request headers.
+   Use `X-Android-Transports` to write the preferred transports and
+   `X-Android-Selected-Transport` to read the negotiated transport.
+
+
+## Version 1.0.2
+
+_2013-05-11_
+
+ * Fix: Remove use of Java 6-only APIs.
+ * Fix: Properly handle exceptions from `NetworkInterface` when querying MTU.
+ * Fix: Ensure MTU has a reasonable default and upper-bound.
+
+
+## Version 1.0.1
+
+_2013-05-06_
+
+ * Correct casing of SSL in method names (`getSslSocketFactory`/`setSslSocketFactory`).
+
+
+## Version 1.0.0
+
+_2013-05-06_
+
+Initial release.
+
+ [brick]: https://noncombatant.org/2015/05/01/about-http-public-key-pinning/
+ [webdav]: https://tools.ietf.org/html/rfc4918
+ [major_versions]: http://jakewharton.com/java-interoperability-policy-for-major-version-updates/
+ [nginx_959]: https://trac.nginx.org/nginx/ticket/959
+ [okhttp_idling_resource]: https://github.com/JakeWharton/okhttp-idling-resource
+ [bom]: https://en.wikipedia.org/wiki/Byte_order_mark
+ [junit_5_rules]: http://junit.org/junit5/docs/current/user-guide/#migrating-from-junit4-rulesupport
+ [public_suffix]: https://publicsuffix.org/
+ [maven_provided]: https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html
diff --git a/LICENSE.txt b/LICENSE.txt
new file mode 100644
index 0000000000..d645695673
--- /dev/null
+++ b/LICENSE.txt
@@ -0,0 +1,202 @@
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright [yyyy] [name of copyright owner]
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
diff --git a/README.md b/README.md
new file mode 100644
index 0000000000..b3514263bf
--- /dev/null
+++ b/README.md
@@ -0,0 +1,81 @@
+OkHttp
+======
+
+An HTTP & HTTP/2 client for Android and Java applications. For more information see [the website][1] and [the wiki][2].
+
+Download
+--------
+
+Download [the latest JAR][3] or grab via Maven:
+```xml
+<dependency>
+  <groupId>com.squareup.okhttp3</groupId>
+  <artifactId>okhttp</artifactId>
+  <version>3.9.0</version>
+</dependency>
+```
+or Gradle:
+```groovy
+compile 'com.squareup.okhttp3:okhttp:3.9.0'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+
+MockWebServer
+-------------
+
+A library for testing HTTP, HTTPS, and HTTP/2 clients.
+
+MockWebServer coupling with OkHttp is essential for proper testing of HTTP/2 so that code can be shared.
+
+### Download
+
+Download [the latest JAR][4] or grab via Maven:
+```xml
+<dependency>
+  <groupId>com.squareup.okhttp3</groupId>
+  <artifactId>mockwebserver</artifactId>
+  <version>3.9.0</version>
+  <scope>test</scope>
+</dependency>
+```
+or Gradle:
+```groovy
+testCompile 'com.squareup.okhttp3:mockwebserver:3.9.0'
+```
+
+ProGuard
+--------
+
+If you are using ProGuard you might need to add the following options:
+
+```
+-dontwarn okhttp3.**
+-dontwarn okio.**
+-dontwarn javax.annotation.**
+# A resource is loaded with a relative path so the package of this class must be preserved.
+-keepnames class okhttp3.internal.publicsuffix.PublicSuffixDatabase
+```
+
+License
+-------
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+
+ [1]: http://square.github.io/okhttp
+ [2]: https://github.com/square/okhttp/wiki
+ [3]: https://search.maven.org/remote_content?g=com.squareup.okhttp3&a=okhttp&v=LATEST
+ [4]: https://search.maven.org/remote_content?g=com.squareup.okhttp3&a=mockwebserver&v=LATEST
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/benchmarks/README.md b/benchmarks/README.md
new file mode 100644
index 0000000000..ee9be3ff47
--- /dev/null
+++ b/benchmarks/README.md
@@ -0,0 +1,8 @@
+OkHttp Benchmarks
+=======================================
+
+This module allows you to test the performance of HTTP clients.
+
+### Running
+  1. If you made modifications to `Benchmark` run `mvn compile`.
+  2. Run `mvn exec:exec` to launch a new JVM, which will execute the benchmark.
diff --git a/benchmarks/pom.xml b/benchmarks/pom.xml
new file mode 100644
index 0000000000..36a9aee9d5
--- /dev/null
+++ b/benchmarks/pom.xml
@@ -0,0 +1,142 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp3</groupId>
+    <artifactId>parent</artifactId>
+    <version>3.10.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>benchmarks</artifactId>
+  <name>Benchmarks</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.google.caliper</groupId>
+      <artifactId>caliper</artifactId>
+      <version>1.0-beta-1</version>
+    </dependency>
+    <!-- caliper needs to be updated to be compatible with guava 16 -->
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+      <version>14.0.1</version>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-urlconnection</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>org.bouncycastle</groupId>
+      <artifactId>bcprov-jdk15on</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.httpcomponents</groupId>
+      <artifactId>httpclient</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>io.netty</groupId>
+      <artifactId>netty-transport</artifactId>
+      <version>4.0.15.Final</version>
+    </dependency>
+    <dependency>
+      <groupId>io.netty</groupId>
+      <artifactId>netty-handler</artifactId>
+      <version>4.0.15.Final</version>
+    </dependency>
+    <dependency>
+      <groupId>io.netty</groupId>
+      <artifactId>netty-codec-http</artifactId>
+      <version>4.0.15.Final</version>
+    </dependency>
+    <!-- Netty needs this if gzip is enabled. -->
+    <dependency>
+      <groupId>com.jcraft</groupId>
+      <artifactId>jzlib</artifactId>
+      <version>1.1.2</version>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>exec-maven-plugin</artifactId>
+        <executions>
+          <execution>
+            <goals>
+              <goal>java</goal>
+            </goals>
+          </execution>
+        </executions>
+        <configuration>
+          <executable>java</executable>
+          <arguments>
+            <argument>-Xms512m</argument>
+            <argument>-Xmx512m</argument>
+            <commandlineArgs>-Xbootclasspath/p:${bootclasspath}</commandlineArgs>
+            <argument>-classpath</argument>
+            <classpath />
+            <argument>okhttp3.benchmarks.Benchmark</argument>
+          </arguments>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+  <profiles>
+    <profile>
+      <id>alpn-when-jdk7</id>
+      <activation>
+        <jdk>1.7</jdk>
+      </activation>
+      <dependencies>
+        <dependency>
+          <groupId>org.mortbay.jetty.alpn</groupId>
+          <artifactId>alpn-boot</artifactId>
+          <version>${alpn.jdk7.version}</version>
+          <scope>provided</scope>
+        </dependency>
+      </dependencies>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8</id>
+      <activation>
+        <jdk>1.8</jdk>
+      </activation>
+      <dependencies>
+        <dependency>
+          <groupId>org.mortbay.jetty.alpn</groupId>
+          <artifactId>alpn-boot</artifactId>
+          <version>${alpn.jdk8.version}</version>
+          <scope>provided</scope>
+        </dependency>
+      </dependencies>
+      <build>
+        <plugins>
+          <plugin>
+            <!-- Fails on caliper's ASM on OpenJDK 8. -->
+            <groupId>org.codehaus.mojo</groupId>
+            <artifactId>animal-sniffer-maven-plugin</artifactId>
+            <executions>
+              <execution>
+                <phase>none</phase>
+              </execution>
+            </executions>
+          </plugin>
+        </plugins>
+      </build>
+    </profile>
+  </profiles>
+</project>
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java b/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java
new file mode 100644
index 0000000000..2fffd7cbf8
--- /dev/null
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.benchmarks;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.concurrent.TimeUnit;
+import java.util.zip.GZIPInputStream;
+import okhttp3.HttpUrl;
+import okhttp3.internal.tls.SslClient;
+import org.apache.http.Header;
+import org.apache.http.HttpResponse;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.conn.ClientConnectionManager;
+import org.apache.http.conn.scheme.Scheme;
+import org.apache.http.conn.ssl.SSLSocketFactory;
+import org.apache.http.impl.client.DefaultHttpClient;
+import org.apache.http.impl.conn.PoolingClientConnectionManager;
+
+/** Benchmark Apache HTTP client. */
+class ApacheHttpClient extends SynchronousHttpClient {
+  private static final boolean VERBOSE = false;
+
+  private HttpClient client;
+
+  @Override public void prepare(Benchmark benchmark) {
+    super.prepare(benchmark);
+    ClientConnectionManager connectionManager = new PoolingClientConnectionManager();
+    if (benchmark.tls) {
+      SslClient sslClient = SslClient.localhost();
+      connectionManager.getSchemeRegistry().register(
+          new Scheme("https", 443, new SSLSocketFactory(sslClient.sslContext)));
+    }
+    client = new DefaultHttpClient(connectionManager);
+  }
+
+  @Override public Runnable request(HttpUrl url) {
+    return new ApacheHttpClientRequest(url);
+  }
+
+  class ApacheHttpClientRequest implements Runnable {
+    private final HttpUrl url;
+
+    ApacheHttpClientRequest(HttpUrl url) {
+      this.url = url;
+    }
+
+    public void run() {
+      long start = System.nanoTime();
+      try {
+        HttpResponse response = client.execute(new HttpGet(url.toString()));
+        InputStream in = response.getEntity().getContent();
+        Header contentEncoding = response.getFirstHeader("Content-Encoding");
+        if (contentEncoding != null && contentEncoding.getValue().equals("gzip")) {
+          in = new GZIPInputStream(in);
+        }
+
+        long total = readAllAndClose(in);
+        long finish = System.nanoTime();
+
+        if (VERBOSE) {
+          System.out.println(String.format("Transferred % 8d bytes in %4d ms",
+              total, TimeUnit.NANOSECONDS.toMillis(finish - start)));
+        }
+      } catch (IOException e) {
+        System.out.println("Failed: " + e);
+      }
+    }
+  }
+}
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java b/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java
new file mode 100644
index 0000000000..0ec59a0573
--- /dev/null
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java
@@ -0,0 +1,216 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.benchmarks;
+
+import com.google.caliper.Param;
+import com.google.caliper.model.ArbitraryMeasurement;
+import com.google.caliper.runner.CaliperMain;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Random;
+import java.util.concurrent.TimeUnit;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import okhttp3.HttpUrl;
+import okhttp3.Protocol;
+import okhttp3.internal.tls.SslClient;
+import okhttp3.mockwebserver.Dispatcher;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okio.Buffer;
+import okio.GzipSink;
+
+/**
+ * This benchmark is fake, but may be useful for certain relative comparisons. It uses a local
+ * connection to a MockWebServer to measure how many identical requests per second can be carried
+ * over a fixed number of threads.
+ */
+public class Benchmark extends com.google.caliper.Benchmark {
+  private static final int NUM_REPORTS = 10;
+  private static final boolean VERBOSE = false;
+
+  private final Random random = new Random(0);
+
+  /** Which client to run. */
+  @Param
+  Client client;
+
+  /** How many concurrent requests to execute. */
+  @Param({"1", "10"})
+  int concurrencyLevel;
+
+  /** How many requests to enqueue to await threads to execute them. */
+  @Param({"10"})
+  int targetBacklog;
+
+  /** True to use TLS. */
+  // TODO: compare different ciphers?
+  @Param
+  boolean tls;
+
+  /** True to use gzip content-encoding for the response body. */
+  @Param
+  boolean gzip;
+
+  /** Don't combine chunked with HTTP_2; that's not allowed. */
+  @Param
+  boolean chunked;
+
+  /** The size of the HTTP response body, in uncompressed bytes. */
+  @Param({"128", "1048576"})
+  int bodyByteCount;
+
+  /** How many additional headers were included, beyond the built-in ones. */
+  @Param({"0", "20"})
+  int headerCount;
+
+  /** Which ALPN protocols are in use. Only useful with TLS. */
+  List<Protocol> protocols = Arrays.asList(Protocol.HTTP_1_1);
+
+  public static void main(String[] args) {
+    List<String> allArgs = new ArrayList<>();
+    allArgs.add("--instrument");
+    allArgs.add("arbitrary");
+    allArgs.addAll(Arrays.asList(args));
+
+    CaliperMain.main(Benchmark.class, allArgs.toArray(new String[allArgs.size()]));
+  }
+
+  @ArbitraryMeasurement(description = "requests per second")
+  public double run() throws Exception {
+    if (VERBOSE) System.out.println(toString());
+    HttpClient httpClient = client.create();
+
+    // Prepare the client & server
+    httpClient.prepare(this);
+    MockWebServer server = startServer();
+    HttpUrl url = server.url("/");
+
+    int requestCount = 0;
+    long reportStart = System.nanoTime();
+    long reportPeriod = TimeUnit.SECONDS.toNanos(1);
+    int reports = 0;
+    double best = 0.0;
+
+    // Run until we've printed enough reports.
+    while (reports < NUM_REPORTS) {
+      // Print a report if we haven't recently.
+      long now = System.nanoTime();
+      double reportDuration = now - reportStart;
+      if (reportDuration > reportPeriod) {
+        double requestsPerSecond = requestCount / reportDuration * TimeUnit.SECONDS.toNanos(1);
+        if (VERBOSE) {
+          System.out.println(String.format("Requests per second: %.1f", requestsPerSecond));
+        }
+        best = Math.max(best, requestsPerSecond);
+        requestCount = 0;
+        reportStart = now;
+        reports++;
+      }
+
+      // Fill the job queue with work.
+      while (httpClient.acceptingJobs()) {
+        httpClient.enqueue(url);
+        requestCount++;
+      }
+
+      // The job queue is full. Take a break.
+      sleep(1);
+    }
+
+    return best;
+  }
+
+  @Override public String toString() {
+    List<Object> modifiers = new ArrayList<>();
+    if (tls) modifiers.add("tls");
+    if (gzip) modifiers.add("gzip");
+    if (chunked) modifiers.add("chunked");
+    modifiers.addAll(protocols);
+
+    return String.format("%s %s\nbodyByteCount=%s headerCount=%s concurrencyLevel=%s",
+        client, modifiers, bodyByteCount, headerCount, concurrencyLevel);
+  }
+
+  private void sleep(int millis) {
+    try {
+      Thread.sleep(millis);
+    } catch (InterruptedException ignored) {
+    }
+  }
+
+  private MockWebServer startServer() throws IOException {
+    Logger.getLogger(MockWebServer.class.getName()).setLevel(Level.WARNING);
+    MockWebServer server = new MockWebServer();
+
+    if (tls) {
+      SslClient sslClient = SslClient.localhost();
+      server.useHttps(sslClient.socketFactory, false);
+      server.setProtocols(protocols);
+    }
+
+    final MockResponse response = newResponse();
+    server.setDispatcher(new Dispatcher() {
+      @Override public MockResponse dispatch(RecordedRequest request) {
+        return response;
+      }
+    });
+
+    server.start();
+    return server;
+  }
+
+  private MockResponse newResponse() throws IOException {
+    byte[] bytes = new byte[bodyByteCount];
+    random.nextBytes(bytes);
+    Buffer body = new Buffer().write(bytes);
+
+    MockResponse result = new MockResponse();
+
+    if (gzip) {
+      Buffer gzipBody = new Buffer();
+      GzipSink gzipSink = new GzipSink(gzipBody);
+      gzipSink.write(body, body.size());
+      gzipSink.close();
+      body = gzipBody;
+      result.addHeader("Content-Encoding: gzip");
+    }
+
+    if (chunked) {
+      result.setChunkedBody(body, 1024);
+    } else {
+      result.setBody(body);
+    }
+
+    for (int i = 0; i < headerCount; i++) {
+      result.addHeader(randomString(12), randomString(20));
+    }
+
+    return result;
+  }
+
+  private String randomString(int length) {
+    String alphabet = "-abcdefghijklmnopqrstuvwxyz";
+    char[] result = new char[length];
+    for (int i = 0; i < length; i++) {
+      result[i] = alphabet.charAt(random.nextInt(alphabet.length()));
+    }
+    return new String(result);
+  }
+}
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/Client.java b/benchmarks/src/main/java/okhttp3/benchmarks/Client.java
new file mode 100644
index 0000000000..b7c6b3f3b9
--- /dev/null
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/Client.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.benchmarks;
+
+enum Client {
+  OkHttp {
+    @Override HttpClient create() {
+      return new OkHttp();
+    }
+  },
+
+  OkHttpAsync {
+    @Override HttpClient create() {
+      return new OkHttpAsync();
+    }
+  },
+
+  Apache {
+    @Override HttpClient create() {
+      return new ApacheHttpClient();
+    }
+  },
+
+  UrlConnection {
+    @Override HttpClient create() {
+      return new UrlConnection();
+    }
+  },
+
+  Netty {
+    @Override HttpClient create() {
+      return new NettyHttpClient();
+    }
+  };
+
+  abstract HttpClient create();
+}
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/HttpClient.java b/benchmarks/src/main/java/okhttp3/benchmarks/HttpClient.java
new file mode 100644
index 0000000000..0c0986ffeb
--- /dev/null
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/HttpClient.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.benchmarks;
+
+import okhttp3.HttpUrl;
+
+/** An HTTP client to benchmark. */
+interface HttpClient {
+  void prepare(Benchmark benchmark);
+
+  void enqueue(HttpUrl url) throws Exception;
+
+  boolean acceptingJobs();
+}
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java b/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java
new file mode 100644
index 0000000000..cd7286d374
--- /dev/null
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java
@@ -0,0 +1,194 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.benchmarks;
+
+import io.netty.bootstrap.Bootstrap;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.PooledByteBufAllocator;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInitializer;
+import io.netty.channel.ChannelOption;
+import io.netty.channel.ChannelPipeline;
+import io.netty.channel.SimpleChannelInboundHandler;
+import io.netty.channel.nio.NioEventLoopGroup;
+import io.netty.channel.socket.SocketChannel;
+import io.netty.channel.socket.nio.NioSocketChannel;
+import io.netty.handler.codec.http.DefaultFullHttpRequest;
+import io.netty.handler.codec.http.HttpClientCodec;
+import io.netty.handler.codec.http.HttpContent;
+import io.netty.handler.codec.http.HttpContentDecompressor;
+import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.HttpMethod;
+import io.netty.handler.codec.http.HttpObject;
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.HttpResponse;
+import io.netty.handler.codec.http.HttpVersion;
+import io.netty.handler.codec.http.LastHttpContent;
+import io.netty.handler.ssl.SslHandler;
+import java.util.ArrayDeque;
+import java.util.Deque;
+import java.util.concurrent.TimeUnit;
+import javax.net.ssl.SSLEngine;
+import okhttp3.HttpUrl;
+import okhttp3.internal.tls.SslClient;
+
+/** Netty isn't an HTTP client, but it's almost one. */
+class NettyHttpClient implements HttpClient {
+  private static final boolean VERBOSE = false;
+
+  // Guarded by this. Real apps need more capable connection management.
+  private final Deque<HttpChannel> freeChannels = new ArrayDeque<>();
+  private final Deque<HttpUrl> backlog = new ArrayDeque<>();
+
+  private int totalChannels = 0;
+  private int concurrencyLevel;
+  private int targetBacklog;
+  private Bootstrap bootstrap;
+
+  @Override public void prepare(final Benchmark benchmark) {
+    this.concurrencyLevel = benchmark.concurrencyLevel;
+    this.targetBacklog = benchmark.targetBacklog;
+
+    ChannelInitializer<SocketChannel> channelInitializer = new ChannelInitializer<SocketChannel>() {
+      @Override public void initChannel(SocketChannel channel) throws Exception {
+        ChannelPipeline pipeline = channel.pipeline();
+
+        if (benchmark.tls) {
+          SslClient sslClient = SslClient.localhost();
+          SSLEngine engine = sslClient.sslContext.createSSLEngine();
+          engine.setUseClientMode(true);
+          pipeline.addLast("ssl", new SslHandler(engine));
+        }
+
+        pipeline.addLast("codec", new HttpClientCodec());
+        pipeline.addLast("inflater", new HttpContentDecompressor());
+        pipeline.addLast("handler", new HttpChannel(channel));
+      }
+    };
+
+    bootstrap = new Bootstrap();
+    bootstrap.group(new NioEventLoopGroup(concurrencyLevel))
+        .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)
+        .channel(NioSocketChannel.class)
+        .handler(channelInitializer);
+  }
+
+  @Override public void enqueue(HttpUrl url) throws Exception {
+    HttpChannel httpChannel = null;
+    synchronized (this) {
+      if (!freeChannels.isEmpty()) {
+        httpChannel = freeChannels.pop();
+      } else if (totalChannels < concurrencyLevel) {
+        totalChannels++; // Create a new channel. (outside of the synchronized block).
+      } else {
+        backlog.add(url); // Enqueue this for later, to be picked up when another request completes.
+        return;
+      }
+    }
+    if (httpChannel == null) {
+      Channel channel = bootstrap.connect(url.host(), url.port())
+          .sync().channel();
+      httpChannel = (HttpChannel) channel.pipeline().last();
+    }
+    httpChannel.sendRequest(url);
+  }
+
+  @Override public synchronized boolean acceptingJobs() {
+    return backlog.size() < targetBacklog || hasFreeChannels();
+  }
+
+  private boolean hasFreeChannels() {
+    int activeChannels = totalChannels - freeChannels.size();
+    return activeChannels < concurrencyLevel;
+  }
+
+  private void release(HttpChannel httpChannel) {
+    HttpUrl url;
+    synchronized (this) {
+      url = backlog.pop();
+      if (url == null) {
+        // There were no URLs in the backlog. Pool this channel for later.
+        freeChannels.push(httpChannel);
+        return;
+      }
+    }
+
+    // We removed a URL from the backlog. Schedule it right away.
+    httpChannel.sendRequest(url);
+  }
+
+  class HttpChannel extends SimpleChannelInboundHandler<HttpObject> {
+    private final SocketChannel channel;
+    byte[] buffer = new byte[1024];
+    int total;
+    long start;
+
+    HttpChannel(SocketChannel channel) {
+      this.channel = channel;
+    }
+
+    private void sendRequest(HttpUrl url) {
+      start = System.nanoTime();
+      total = 0;
+      HttpRequest request = new DefaultFullHttpRequest(
+          HttpVersion.HTTP_1_1, HttpMethod.GET, url.encodedPath());
+      request.headers().set(HttpHeaders.Names.HOST, url.host());
+      request.headers().set(HttpHeaders.Names.ACCEPT_ENCODING, HttpHeaders.Values.GZIP);
+      channel.writeAndFlush(request);
+    }
+
+    @Override protected void channelRead0(
+        ChannelHandlerContext context, HttpObject message) throws Exception {
+      if (message instanceof HttpResponse) {
+        receive((HttpResponse) message);
+      }
+      if (message instanceof HttpContent) {
+        receive((HttpContent) message);
+        if (message instanceof LastHttpContent) {
+          release(this);
+        }
+      }
+    }
+
+    @Override public void channelInactive(ChannelHandlerContext ctx) throws Exception {
+      super.channelInactive(ctx);
+    }
+
+    void receive(HttpResponse response) {
+      // Don't do anything with headers.
+    }
+
+    void receive(HttpContent content) {
+      // Consume the response body.
+      ByteBuf byteBuf = content.content();
+      for (int toRead; (toRead = byteBuf.readableBytes()) > 0; ) {
+        byteBuf.readBytes(buffer, 0, Math.min(buffer.length, toRead));
+        total += toRead;
+      }
+
+      if (VERBOSE && content instanceof LastHttpContent) {
+        long finish = System.nanoTime();
+        System.out.println(String.format("Transferred % 8d bytes in %4d ms",
+            total, TimeUnit.NANOSECONDS.toMillis(finish - start)));
+      }
+    }
+
+    @Override public void exceptionCaught(ChannelHandlerContext context, Throwable cause) {
+      System.out.println("Failed: " + cause);
+    }
+  }
+}
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java
new file mode 100644
index 0000000000..7460aa66f6
--- /dev/null
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.benchmarks;
+
+import java.io.IOException;
+import java.util.concurrent.TimeUnit;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLSession;
+import javax.net.ssl.SSLSocketFactory;
+import okhttp3.Call;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.ResponseBody;
+import okhttp3.internal.tls.SslClient;
+
+class OkHttp extends SynchronousHttpClient {
+  private static final boolean VERBOSE = false;
+
+  private OkHttpClient client;
+
+  @Override public void prepare(Benchmark benchmark) {
+    super.prepare(benchmark);
+    client = new OkHttpClient.Builder()
+        .protocols(benchmark.protocols)
+        .build();
+
+    if (benchmark.tls) {
+      SslClient sslClient = SslClient.localhost();
+      SSLSocketFactory socketFactory = sslClient.socketFactory;
+      HostnameVerifier hostnameVerifier = new HostnameVerifier() {
+        @Override public boolean verify(String s, SSLSession session) {
+          return true;
+        }
+      };
+      client = new OkHttpClient.Builder()
+          .sslSocketFactory(socketFactory, sslClient.trustManager)
+          .hostnameVerifier(hostnameVerifier)
+          .build();
+    }
+  }
+
+  @Override public Runnable request(HttpUrl url) {
+    Call call = client.newCall(new Request.Builder().url(url).build());
+    return new OkHttpRequest(call);
+  }
+
+  class OkHttpRequest implements Runnable {
+    private final Call call;
+
+    OkHttpRequest(Call call) {
+      this.call = call;
+    }
+
+    public void run() {
+      long start = System.nanoTime();
+      try {
+        ResponseBody body = call.execute().body();
+        long total = readAllAndClose(body.byteStream());
+        long finish = System.nanoTime();
+
+        if (VERBOSE) {
+          System.out.println(String.format("Transferred % 8d bytes in %4d ms",
+              total, TimeUnit.NANOSECONDS.toMillis(finish - start)));
+        }
+      } catch (IOException e) {
+        System.out.println("Failed: " + e);
+      }
+    }
+  }
+}
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/OkHttpAsync.java b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttpAsync.java
new file mode 100644
index 0000000000..57cb75cacc
--- /dev/null
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttpAsync.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.benchmarks;
+
+import java.io.IOException;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLSession;
+import javax.net.ssl.SSLSocketFactory;
+import okhttp3.Call;
+import okhttp3.Callback;
+import okhttp3.Dispatcher;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.tls.SslClient;
+
+class OkHttpAsync implements HttpClient {
+  private static final boolean VERBOSE = false;
+
+  private final AtomicInteger requestsInFlight = new AtomicInteger();
+
+  private OkHttpClient client;
+  private Callback callback;
+  private int concurrencyLevel;
+  private int targetBacklog;
+
+  @Override public void prepare(final Benchmark benchmark) {
+    concurrencyLevel = benchmark.concurrencyLevel;
+    targetBacklog = benchmark.targetBacklog;
+
+    client = new OkHttpClient.Builder()
+        .protocols(benchmark.protocols)
+        .dispatcher(new Dispatcher(new ThreadPoolExecutor(benchmark.concurrencyLevel,
+            benchmark.concurrencyLevel, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>())))
+        .build();
+
+    if (benchmark.tls) {
+      SslClient sslClient = SslClient.localhost();
+      SSLSocketFactory socketFactory = sslClient.socketFactory;
+      HostnameVerifier hostnameVerifier = new HostnameVerifier() {
+        @Override public boolean verify(String s, SSLSession session) {
+          return true;
+        }
+      };
+      client = client.newBuilder()
+          .sslSocketFactory(socketFactory, sslClient.trustManager)
+          .hostnameVerifier(hostnameVerifier)
+          .build();
+    }
+
+    callback = new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+        System.out.println("Failed: " + e);
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        ResponseBody body = response.body();
+        long total = SynchronousHttpClient.readAllAndClose(body.byteStream());
+        long finish = System.nanoTime();
+        if (VERBOSE) {
+          long start = (Long) response.request().tag();
+          System.out.printf("Transferred % 8d bytes in %4d ms%n",
+              total, TimeUnit.NANOSECONDS.toMillis(finish - start));
+        }
+        requestsInFlight.decrementAndGet();
+      }
+    };
+  }
+
+  @Override public void enqueue(HttpUrl url) throws Exception {
+    requestsInFlight.incrementAndGet();
+    client.newCall(new Request.Builder().tag(System.nanoTime()).url(url).build()).enqueue(callback);
+  }
+
+  @Override public synchronized boolean acceptingJobs() {
+    return requestsInFlight.get() < (concurrencyLevel + targetBacklog);
+  }
+}
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/SynchronousHttpClient.java b/benchmarks/src/main/java/okhttp3/benchmarks/SynchronousHttpClient.java
new file mode 100644
index 0000000000..4a17b8693d
--- /dev/null
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/SynchronousHttpClient.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.benchmarks;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import okhttp3.HttpUrl;
+
+/** Any HTTP client with a blocking API. */
+abstract class SynchronousHttpClient implements HttpClient {
+  ThreadPoolExecutor executor;
+  int targetBacklog;
+
+  @Override public void prepare(Benchmark benchmark) {
+    this.targetBacklog = benchmark.targetBacklog;
+    executor = new ThreadPoolExecutor(benchmark.concurrencyLevel, benchmark.concurrencyLevel,
+        1, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());
+  }
+
+  @Override public void enqueue(HttpUrl url) {
+    executor.execute(request(url));
+  }
+
+  @Override public boolean acceptingJobs() {
+    return executor.getQueue().size() < targetBacklog;
+  }
+
+  static long readAllAndClose(InputStream in) throws IOException {
+    byte[] buffer = new byte[1024];
+    long total = 0;
+    for (int count; (count = in.read(buffer)) != -1; ) {
+      total += count;
+    }
+    in.close();
+    return total;
+  }
+
+  abstract Runnable request(HttpUrl url);
+}
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java b/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java
new file mode 100644
index 0000000000..560534c829
--- /dev/null
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.benchmarks;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.util.concurrent.TimeUnit;
+import java.util.zip.GZIPInputStream;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLSession;
+import javax.net.ssl.SSLSocketFactory;
+import okhttp3.HttpUrl;
+import okhttp3.internal.tls.SslClient;
+
+class UrlConnection extends SynchronousHttpClient {
+  private static final boolean VERBOSE = false;
+
+  @Override public void prepare(Benchmark benchmark) {
+    super.prepare(benchmark);
+    if (benchmark.tls) {
+      SslClient sslClient = SslClient.localhost();
+      SSLSocketFactory socketFactory = sslClient.socketFactory;
+      HostnameVerifier hostnameVerifier = new HostnameVerifier() {
+        @Override public boolean verify(String s, SSLSession session) {
+          return true;
+        }
+      };
+      HttpsURLConnection.setDefaultHostnameVerifier(hostnameVerifier);
+      HttpsURLConnection.setDefaultSSLSocketFactory(socketFactory);
+    }
+  }
+
+  @Override public Runnable request(HttpUrl url) {
+    return new UrlConnectionRequest(url);
+  }
+
+  static class UrlConnectionRequest implements Runnable {
+    private final HttpUrl url;
+
+    UrlConnectionRequest(HttpUrl url) {
+      this.url = url;
+    }
+
+    public void run() {
+      long start = System.nanoTime();
+      try {
+        HttpURLConnection urlConnection = (HttpURLConnection) url.url().openConnection();
+        InputStream in = urlConnection.getInputStream();
+        if ("gzip".equals(urlConnection.getHeaderField("Content-Encoding"))) {
+          in = new GZIPInputStream(in);
+        }
+
+        long total = readAllAndClose(in);
+        long finish = System.nanoTime();
+
+        if (VERBOSE) {
+          System.out.println(String.format("Transferred % 8d bytes in %4d ms",
+              total, TimeUnit.NANOSECONDS.toMillis(finish - start)));
+        }
+      } catch (IOException e) {
+        System.out.println("Failed: " + e);
+      }
+    }
+  }
+}
diff --git a/checkstyle.xml b/checkstyle.xml
new file mode 100644
index 0000000000..1e4d8e6d1d
--- /dev/null
+++ b/checkstyle.xml
@@ -0,0 +1,147 @@
+<?xml version="1.0"?>
+<!DOCTYPE module PUBLIC
+    "-//Puppy Crawl//DTD Check Configuration 1.3//EN"
+    "http://www.puppycrawl.com/dtds/configuration_1_3.dtd">
+
+<module name="Checker">
+  <module name="SuppressWarningsFilter"/>
+  <module name="NewlineAtEndOfFile"/>
+  <module name="FileLength"/>
+  <module name="FileTabCharacter"/>
+
+  <!-- Trailing spaces -->
+  <module name="RegexpSingleline">
+    <property name="format" value="\s+$"/>
+    <property name="message" value="Line has trailing spaces."/>
+  </module>
+
+  <!-- Space after 'for' and 'if' -->
+  <module name="RegexpSingleline">
+    <property name="format" value="^\s*(for|if)\b[^ ]"/>
+    <property name="message" value="Space needed before opening parenthesis."/>
+  </module>
+
+  <!-- For each spacing -->
+  <module name="RegexpSingleline">
+    <property name="format" value="^\s*for \(.*?([^ ]:|:[^ ])"/>
+    <property name="message" value="Space needed around ':' character."/>
+  </module>
+
+  <module name="TreeWalker">
+    <property name="cacheFile" value="${checkstyle.cache.file}"/>
+
+    <!-- Checks for Javadoc comments.                     -->
+    <!-- See http://checkstyle.sf.net/config_javadoc.html -->
+    <!--module name="JavadocMethod"/-->
+    <!--module name="JavadocType"/-->
+    <!--module name="JavadocVariable"/-->
+    <module name="JavadocStyle"/>
+
+
+    <!-- Checks for Naming Conventions.                  -->
+    <!-- See http://checkstyle.sf.net/config_naming.html -->
+    <!--<module name="ConstantName"/>-->
+    <module name="LocalFinalVariableName"/>
+    <module name="LocalVariableName"/>
+    <module name="MemberName"/>
+    <module name="MethodName"/>
+    <!--<module name="PackageName"/>-->
+    <module name="ParameterName"/>
+    <module name="StaticVariableName"/>
+    <module name="TypeName"/>
+
+
+    <!-- Checks for imports                              -->
+    <!-- See http://checkstyle.sf.net/config_import.html -->
+    <module name="AvoidStarImport"/>
+    <module name="IllegalImport"/>
+    <!-- defaults to sun.* packages -->
+    <module name="RedundantImport"/>
+    <module name="UnusedImports">
+      <property name="processJavadoc" value="true"/>
+    </module>
+
+
+    <!-- Checks for Size Violations.                    -->
+    <!-- See http://checkstyle.sf.net/config_sizes.html -->
+    <module name="LineLength">
+      <property name="max" value="100"/>
+    </module>
+    <module name="MethodLength">
+      <property name="max" value="200"/>
+    </module>
+
+
+    <!-- Checks for whitespace                               -->
+    <!-- See http://checkstyle.sf.net/config_whitespace.html -->
+    <module name="GenericWhitespace"/>
+    <!--<module name="EmptyForIteratorPad"/>-->
+    <module name="MethodParamPad"/>
+    <!--<module name="NoWhitespaceAfter"/>-->
+    <!--<module name="NoWhitespaceBefore"/>-->
+    <module name="OperatorWrap"/>
+    <module name="ParenPad"/>
+    <module name="TypecastParenPad"/>
+    <module name="WhitespaceAfter"/>
+    <module name="WhitespaceAround">
+      <property name="tokens"
+          value="ASSIGN, BAND, BAND_ASSIGN, BOR, BOR_ASSIGN, BSR, BSR_ASSIGN, BXOR, BXOR_ASSIGN,
+          COLON, DIV, DIV_ASSIGN, DO_WHILE, EQUAL, GE, GT, LAND, LCURLY, LE, LITERAL_CATCH,
+          LITERAL_DO, LITERAL_ELSE, LITERAL_FINALLY, LITERAL_FOR, LITERAL_IF, LITERAL_RETURN,
+          LITERAL_SWITCH, LITERAL_SYNCHRONIZED, LITERAL_TRY, LITERAL_WHILE, LOR, LT, MINUS,
+          MINUS_ASSIGN, MOD, MOD_ASSIGN, NOT_EQUAL, PLUS, PLUS_ASSIGN, QUESTION, SL, SLIST,
+          SL_ASSIGN, SR, SR_ASSIGN, STAR, STAR_ASSIGN, LITERAL_ASSERT, TYPE_EXTENSION_AND"/>
+    </module>
+
+
+    <!-- Modifier Checks                                    -->
+    <!-- See http://checkstyle.sf.net/config_modifiers.html -->
+    <module name="ModifierOrder"/>
+    <module name="RedundantModifier"/>
+
+
+    <!-- Checks for blocks. You know, those {}'s         -->
+    <!-- See http://checkstyle.sf.net/config_blocks.html -->
+    <module name="AvoidNestedBlocks"/>
+    <!--module name="EmptyBlock"/-->
+    <module name="LeftCurly"/>
+    <!--<module name="NeedBraces"/>-->
+    <module name="RightCurly"/>
+
+
+    <!-- Checks for common coding problems               -->
+    <!-- See http://checkstyle.sf.net/config_coding.html -->
+    <!--module name="AvoidInlineConditionals"/-->
+    <module name="CovariantEquals"/>
+    <module name="EmptyStatement"/>
+    <!--<module name="EqualsAvoidNull"/>-->
+    <module name="EqualsHashCode"/>
+    <!--module name="HiddenField"/-->
+    <module name="IllegalInstantiation"/>
+    <!--module name="InnerAssignment"/-->
+    <!--module name="MagicNumber"/-->
+    <!--module name="MissingSwitchDefault"/-->
+    <!--<module name="RedundantThrows"/>-->
+    <module name="SimplifyBooleanExpression"/>
+    <module name="SimplifyBooleanReturn"/>
+
+    <!-- Checks for class design                         -->
+    <!-- See http://checkstyle.sf.net/config_design.html -->
+    <!--module name="DesignForExtension"/-->
+    <!--<module name="FinalClass"/>-->
+    <module name="HideUtilityClassConstructor"/>
+    <module name="InterfaceIsType"/>
+    <!--module name="VisibilityModifier"/-->
+
+
+    <!-- Miscellaneous other checks.                   -->
+    <!-- See http://checkstyle.sf.net/config_misc.html -->
+    <module name="ArrayTypeStyle"/>
+    <!--module name="FinalParameters"/-->
+    <!--module name="TodoComment"/-->
+    <module name="UpperEll"/>
+
+    <!-- Make the @SuppressWarnings annotations available to Checkstyle -->
+    <module name="SuppressWarningsHolder"/>
+  </module>
+</module>
diff --git a/deploy_website.sh b/deploy_website.sh
new file mode 100755
index 0000000000..c9b7f156b0
--- /dev/null
+++ b/deploy_website.sh
@@ -0,0 +1,36 @@
+#!/bin/bash
+
+set -ex
+
+REPO="git@github.com:square/okhttp.git"
+DIR=temp-clone
+
+# Delete any existing temporary website clone
+rm -rf $DIR
+
+# Clone the current repo into temp folder
+git clone $REPO $DIR
+
+# Move working directory into temp folder
+cd $DIR
+
+# Checkout and track the gh-pages branch
+git checkout -t origin/gh-pages
+
+# Delete everything that isn't versioned (1.x, 2.x)
+ls | grep -E -v '^\d+\.x$' | xargs rm -rf
+
+# Copy website files from real repo
+cp -R ../website/* .
+
+# Stage all files in git and create a commit
+git add .
+git add -u
+git commit -m "Website at $(date)"
+
+# Push the new files up to GitHub
+git push origin gh-pages
+
+# Delete our temp folder
+cd ..
+rm -rf $DIR
diff --git a/mockwebserver/README.md b/mockwebserver/README.md
new file mode 100644
index 0000000000..06cf0723f5
--- /dev/null
+++ b/mockwebserver/README.md
@@ -0,0 +1,170 @@
+MockWebServer
+=============
+
+A scriptable web server for testing HTTP clients
+
+
+### Motivation
+
+This library makes it easy to test that your app Does The Right Thing when it
+makes HTTP and HTTPS calls. It lets you specify which responses to return and
+then verify that requests were made as expected.
+
+Because it exercises your full HTTP stack, you can be confident that you're
+testing everything. You can even copy & paste HTTP responses from your real web
+server to create representative test cases. Or test that your code survives in
+awkward-to-reproduce situations like 500 errors or slow-loading responses.
+
+
+### Example
+
+Use MockWebServer the same way that you use mocking frameworks like
+[Mockito](https://github.com/mockito/mockito):
+
+1. Script the mocks.
+2. Run application code.
+3. Verify that the expected requests were made.
+
+Here's a complete example:
+
+```java
+public void test() throws Exception {
+  // Create a MockWebServer. These are lean enough that you can create a new
+  // instance for every unit test.
+  MockWebServer server = new MockWebServer();
+
+  // Schedule some responses.
+  server.enqueue(new MockResponse().setBody("hello, world!"));
+  server.enqueue(new MockResponse().setBody("sup, bra?"));
+  server.enqueue(new MockResponse().setBody("yo dog"));
+
+  // Start the server.
+  server.start();
+
+  // Ask the server for its URL. You'll need this to make HTTP requests.
+  HttpUrl baseUrl = server.url("/v1/chat/");
+
+  // Exercise your application code, which should make those HTTP requests.
+  // Responses are returned in the same order that they are enqueued.
+  Chat chat = new Chat(baseUrl);
+
+  chat.loadMore();
+  assertEquals("hello, world!", chat.messages());
+
+  chat.loadMore();
+  chat.loadMore();
+  assertEquals(""
+      + "hello, world!\n"
+      + "sup, bra?\n"
+      + "yo dog", chat.messages());
+
+  // Optional: confirm that your app made the HTTP requests you were expecting.
+  RecordedRequest request1 = server.takeRequest();
+  assertEquals("/v1/chat/messages/", request1.getPath());
+  assertNotNull(request1.getHeader("Authorization"));
+
+  RecordedRequest request2 = server.takeRequest();
+  assertEquals("/v1/chat/messages/2", request2.getPath());
+
+  RecordedRequest request3 = server.takeRequest();
+  assertEquals("/v1/chat/messages/3", request3.getPath());
+
+  // Shut down the server. Instances cannot be reused.
+  server.shutdown();
+}
+```
+
+Your unit tests might move the `server` into a field so you can shut it down
+from your test's `tearDown()`.
+
+### API
+
+#### MockResponse
+
+Mock responses default to an empty response body and a `200` status code.
+You can set a custom body with a string, input stream or byte array. Also
+add headers with a fluent builder API.
+
+```java
+MockResponse response = new MockResponse()
+    .addHeader("Content-Type", "application/json; charset=utf-8")
+    .addHeader("Cache-Control", "no-cache")
+    .setBody("{}");
+```
+
+MockResponse can be used to simulate a slow network. This is useful for
+testing timeouts and interactive testing.
+
+```java
+response.throttleBody(1024, 1, TimeUnit.SECONDS);
+```
+
+
+#### RecordedRequest
+
+Verify requests by their method, path, HTTP version, body, and headers.
+
+```java
+RecordedRequest request = server.takeRequest();
+assertEquals("POST /v1/chat/send HTTP/1.1", request.getRequestLine());
+assertEquals("application/json; charset=utf-8", request.getHeader("Content-Type"));
+assertEquals("{}", request.getBody().readUtf8());
+```
+
+#### Dispatcher
+
+By default MockWebServer uses a queue to specify a series of responses. Use a
+Dispatcher to handle requests using another policy. One natural policy is to
+dispatch on the request path.
+You can, for example, filter the request instead of using `server.enqueue()`.
+
+```java
+final Dispatcher dispatcher = new Dispatcher() {
+
+    @Override
+    public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
+
+        if (request.getPath().equals("/v1/login/auth/")){
+            return new MockResponse().setResponseCode(200);
+        } else if (request.getPath().equals("v1/check/version/")){
+            return new MockResponse().setResponseCode(200).setBody("version=9");
+        } else if (request.getPath().equals("/v1/profile/info")) {
+            return new MockResponse().setResponseCode(200).setBody("{\\\"info\\\":{\\\"name\":\"Lucas Albuquerque\",\"age\":\"21\",\"gender\":\"male\"}}");
+        }
+        return new MockResponse().setResponseCode(404);
+    }
+};
+server.setDispatcher(dispatcher);
+```
+
+
+### Download
+
+Get MockWebServer via Maven:
+```xml
+<dependency>
+  <groupId>com.squareup.okhttp3</groupId>
+  <artifactId>mockwebserver</artifactId>
+  <version>(insert latest version)</version>
+  <scope>test</scope>
+</dependency>
+```
+
+or via Gradle 
+```groovy
+testCompile 'com.squareup.okhttp3:mockwebserver:(insert latest version)'
+```
+
+### License
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
diff --git a/mockwebserver/pom.xml b/mockwebserver/pom.xml
new file mode 100644
index 0000000000..de258420ef
--- /dev/null
+++ b/mockwebserver/pom.xml
@@ -0,0 +1,68 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp3</groupId>
+    <artifactId>parent</artifactId>
+    <version>3.10.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>mockwebserver</artifactId>
+  <name>MockWebServer</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.bouncycastle</groupId>
+      <artifactId>bcprov-jdk15on</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-javadoc-plugin</artifactId>
+        <configuration>
+          <links>
+            <link>http://square.github.io/okhttp/javadoc/</link>
+            <link>http://square.github.io/okio/</link>
+          </links>
+        </configuration>
+      </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-assembly-plugin</artifactId>
+        <configuration>
+          <descriptorRefs>
+            <descriptorRef>jar-with-dependencies</descriptorRef>
+          </descriptorRefs>
+        </configuration>
+        <executions>
+          <execution>
+            <phase>package</phase>
+            <goals>
+              <goal>single</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/mockwebserver/src/main/java/okhttp3/internal/http2/Http2Server.java b/mockwebserver/src/main/java/okhttp3/internal/http2/Http2Server.java
new file mode 100644
index 0000000000..643ab1eb4c
--- /dev/null
+++ b/mockwebserver/src/main/java/okhttp3/internal/http2/Http2Server.java
@@ -0,0 +1,188 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package okhttp3.internal.http2;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import okhttp3.Protocol;
+import okhttp3.internal.Util;
+import okhttp3.internal.platform.Platform;
+import okhttp3.internal.tls.SslClient;
+import okio.BufferedSink;
+import okio.Okio;
+import okio.Source;
+
+import static okhttp3.internal.platform.Platform.INFO;
+
+/** A basic HTTP/2 server that serves the contents of a local directory. */
+public final class Http2Server extends Http2Connection.Listener {
+  static final Logger logger = Logger.getLogger(Http2Server.class.getName());
+
+  private final File baseDirectory;
+  private final SSLSocketFactory sslSocketFactory;
+
+  public Http2Server(File baseDirectory, SSLSocketFactory sslSocketFactory) {
+    this.baseDirectory = baseDirectory;
+    this.sslSocketFactory = sslSocketFactory;
+  }
+
+  private void run() throws Exception {
+    ServerSocket serverSocket = new ServerSocket(8888);
+    serverSocket.setReuseAddress(true);
+
+    while (true) {
+      Socket socket = null;
+      try {
+        socket = serverSocket.accept();
+
+        SSLSocket sslSocket = doSsl(socket);
+        String protocolString = Platform.get().getSelectedProtocol(sslSocket);
+        Protocol protocol = protocolString != null ? Protocol.get(protocolString) : null;
+        if (protocol != Protocol.HTTP_2) {
+          throw new ProtocolException("Protocol " + protocol + " unsupported");
+        }
+        Http2Connection connection = new Http2Connection.Builder(false)
+            .socket(sslSocket)
+            .listener(this)
+            .build();
+        connection.start();
+      } catch (IOException e) {
+        logger.log(Level.INFO, "Http2Server connection failure: " + e);
+        Util.closeQuietly(socket);
+      } catch (Exception e) {
+        logger.log(Level.WARNING, "Http2Server unexpected failure", e);
+        Util.closeQuietly(socket);
+      }
+    }
+  }
+
+  private SSLSocket doSsl(Socket socket) throws IOException {
+    SSLSocket sslSocket = (SSLSocket) sslSocketFactory.createSocket(
+        socket, socket.getInetAddress().getHostAddress(), socket.getPort(), true);
+    sslSocket.setUseClientMode(false);
+    Platform.get().configureTlsExtensions(sslSocket, null,
+        Collections.singletonList(Protocol.HTTP_2));
+    sslSocket.startHandshake();
+    return sslSocket;
+  }
+
+  @Override public void onStream(Http2Stream stream) throws IOException {
+    try {
+      List<Header> requestHeaders = stream.getRequestHeaders();
+      String path = null;
+      for (int i = 0, size = requestHeaders.size(); i < size; i++) {
+        if (requestHeaders.get(i).name.equals(Header.TARGET_PATH)) {
+          path = requestHeaders.get(i).value.utf8();
+          break;
+        }
+      }
+
+      if (path == null) {
+        // TODO: send bad request error
+        throw new AssertionError();
+      }
+
+      File file = new File(baseDirectory + path);
+
+      if (file.isDirectory()) {
+        serveDirectory(stream, file.listFiles());
+      } else if (file.exists()) {
+        serveFile(stream, file);
+      } else {
+        send404(stream, path);
+      }
+    } catch (IOException e) {
+      Platform.get().log(INFO, "Failure serving Http2Stream: " + e.getMessage(), null);
+    }
+  }
+
+  private void send404(Http2Stream stream, String path) throws IOException {
+    List<Header> responseHeaders = Arrays.asList(
+        new Header(":status", "404"),
+        new Header(":version", "HTTP/1.1"),
+        new Header("content-type", "text/plain")
+    );
+    stream.sendResponseHeaders(responseHeaders, true);
+    BufferedSink out = Okio.buffer(stream.getSink());
+    out.writeUtf8("Not found: " + path);
+    out.close();
+  }
+
+  private void serveDirectory(Http2Stream stream, File[] files) throws IOException {
+    List<Header> responseHeaders = Arrays.asList(
+        new Header(":status", "200"),
+        new Header(":version", "HTTP/1.1"),
+        new Header("content-type", "text/html; charset=UTF-8")
+    );
+    stream.sendResponseHeaders(responseHeaders, true);
+    BufferedSink out = Okio.buffer(stream.getSink());
+    for (File file : files) {
+      String target = file.isDirectory() ? (file.getName() + "/") : file.getName();
+      out.writeUtf8("<a href='" + target + "'>" + target + "</a><br>");
+    }
+    out.close();
+  }
+
+  private void serveFile(Http2Stream stream, File file) throws IOException {
+    List<Header> responseHeaders = Arrays.asList(
+        new Header(":status", "200"),
+        new Header(":version", "HTTP/1.1"),
+        new Header("content-type", contentType(file))
+    );
+    stream.sendResponseHeaders(responseHeaders, true);
+    Source source = Okio.source(file);
+    try {
+      BufferedSink out = Okio.buffer(stream.getSink());
+      out.writeAll(source);
+      out.close();
+    } finally {
+      Util.closeQuietly(source);
+    }
+  }
+
+  private String contentType(File file) {
+    if (file.getName().endsWith(".css")) return "text/css";
+    if (file.getName().endsWith(".gif")) return "image/gif";
+    if (file.getName().endsWith(".html")) return "text/html";
+    if (file.getName().endsWith(".jpeg")) return "image/jpeg";
+    if (file.getName().endsWith(".jpg")) return "image/jpeg";
+    if (file.getName().endsWith(".js")) return "application/javascript";
+    if (file.getName().endsWith(".png")) return "image/png";
+    return "text/plain";
+  }
+
+  public static void main(String... args) throws Exception {
+    if (args.length != 1 || args[0].startsWith("-")) {
+      System.out.println("Usage: Http2Server <base directory>");
+      return;
+    }
+
+    Http2Server server = new Http2Server(new File(args[0]),
+        SslClient.localhost().sslContext.getSocketFactory());
+    server.run();
+  }
+}
diff --git a/mockwebserver/src/main/java/okhttp3/internal/tls/HeldCertificate.java b/mockwebserver/src/main/java/okhttp3/internal/tls/HeldCertificate.java
new file mode 100644
index 0000000000..eedfc2a094
--- /dev/null
+++ b/mockwebserver/src/main/java/okhttp3/internal/tls/HeldCertificate.java
@@ -0,0 +1,173 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.tls;
+
+import java.math.BigInteger;
+import java.security.GeneralSecurityException;
+import java.security.KeyPair;
+import java.security.KeyPairGenerator;
+import java.security.SecureRandom;
+import java.security.Security;
+import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+import java.util.UUID;
+import javax.security.auth.x500.X500Principal;
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.DERSequence;
+import org.bouncycastle.asn1.x509.BasicConstraints;
+import org.bouncycastle.asn1.x509.GeneralName;
+import org.bouncycastle.asn1.x509.X509Extensions;
+import org.bouncycastle.jce.provider.BouncyCastleProvider;
+import org.bouncycastle.x509.X509V3CertificateGenerator;
+
+import static okhttp3.internal.Util.verifyAsIpAddress;
+
+/**
+ * A certificate and its private key. This can be used on the server side by HTTPS servers, or on
+ * the client side to verify those HTTPS servers. A held certificate can also be used to sign other
+ * held certificates, as done in practice by certificate authorities.
+ */
+public final class HeldCertificate {
+  public final X509Certificate certificate;
+  public final KeyPair keyPair;
+
+  public HeldCertificate(X509Certificate certificate, KeyPair keyPair) {
+    this.certificate = certificate;
+    this.keyPair = keyPair;
+  }
+
+  public static final class Builder {
+    static {
+      Security.addProvider(new BouncyCastleProvider());
+    }
+
+    private final long duration = 1000L * 60 * 60 * 24; // One day.
+    private String hostname;
+    private List<String> altNames = new ArrayList<>();
+    private String serialNumber = "1";
+    private KeyPair keyPair;
+    private HeldCertificate issuedBy;
+    private int maxIntermediateCas;
+
+    public Builder serialNumber(String serialNumber) {
+      this.serialNumber = serialNumber;
+      return this;
+    }
+
+    /**
+     * Set this certificate's name. Typically this is the URL hostname for TLS certificates. This is
+     * the CN (common name) in the certificate. Will be a random string if no value is provided.
+     */
+    public Builder commonName(String hostname) {
+      this.hostname = hostname;
+      return this;
+    }
+
+    public Builder keyPair(KeyPair keyPair) {
+      this.keyPair = keyPair;
+      return this;
+    }
+
+    /**
+     * Set the certificate that signs this certificate. If unset, a self-signed certificate will be
+     * generated.
+     */
+    public Builder issuedBy(HeldCertificate signedBy) {
+      this.issuedBy = signedBy;
+      return this;
+    }
+
+    /**
+     * Set this certificate to be a certificate authority, with up to {@code maxIntermediateCas}
+     * intermediate certificate authorities beneath it.
+     */
+    public Builder ca(int maxIntermediateCas) {
+      this.maxIntermediateCas = maxIntermediateCas;
+      return this;
+    }
+
+    /**
+     * Adds a subject alternative name to the certificate. This is usually a hostname or IP address.
+     * If no subject alternative names are added that extension will not be used.
+     */
+    public Builder subjectAlternativeName(String altName) {
+      altNames.add(altName);
+      return this;
+    }
+
+    public HeldCertificate build() throws GeneralSecurityException {
+      // Subject, public & private keys for this certificate.
+      KeyPair heldKeyPair = keyPair != null
+          ? keyPair
+          : generateKeyPair();
+      X500Principal subject = hostname != null
+          ? new X500Principal("CN=" + hostname)
+          : new X500Principal("CN=" + UUID.randomUUID());
+
+      // Subject, public & private keys for this certificate's signer. It may be self signed!
+      KeyPair signedByKeyPair;
+      X500Principal signedByPrincipal;
+      if (issuedBy != null) {
+        signedByKeyPair = issuedBy.keyPair;
+        signedByPrincipal = issuedBy.certificate.getSubjectX500Principal();
+      } else {
+        signedByKeyPair = heldKeyPair;
+        signedByPrincipal = subject;
+      }
+
+      // Generate & sign the certificate.
+      long now = System.currentTimeMillis();
+      X509V3CertificateGenerator generator = new X509V3CertificateGenerator();
+      generator.setSerialNumber(new BigInteger(serialNumber));
+      generator.setIssuerDN(signedByPrincipal);
+      generator.setNotBefore(new Date(now));
+      generator.setNotAfter(new Date(now + duration));
+      generator.setSubjectDN(subject);
+      generator.setPublicKey(heldKeyPair.getPublic());
+      generator.setSignatureAlgorithm("SHA256WithRSAEncryption");
+
+      if (maxIntermediateCas > 0) {
+        generator.addExtension(X509Extensions.BasicConstraints, true,
+            new BasicConstraints(maxIntermediateCas));
+      }
+
+      if (!altNames.isEmpty()) {
+        ASN1Encodable[] encodableAltNames = new ASN1Encodable[altNames.size()];
+        for (int i = 0, size = altNames.size(); i < size; i++) {
+          String altName = altNames.get(i);
+          int tag = verifyAsIpAddress(altName)
+              ? GeneralName.iPAddress
+              : GeneralName.dNSName;
+          encodableAltNames[i] = new GeneralName(tag, altName);
+        }
+        generator.addExtension(X509Extensions.SubjectAlternativeName, true,
+            new DERSequence(encodableAltNames));
+      }
+
+      X509Certificate certificate = generator.generateX509Certificate(
+          signedByKeyPair.getPrivate(), "BC");
+      return new HeldCertificate(certificate, heldKeyPair);
+    }
+
+    public KeyPair generateKeyPair() throws GeneralSecurityException {
+      KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA", "BC");
+      keyPairGenerator.initialize(1024, new SecureRandom());
+      return keyPairGenerator.generateKeyPair();
+    }
+  }
+}
diff --git a/mockwebserver/src/main/java/okhttp3/internal/tls/SslClient.java b/mockwebserver/src/main/java/okhttp3/internal/tls/SslClient.java
new file mode 100644
index 0000000000..e86e8675ff
--- /dev/null
+++ b/mockwebserver/src/main/java/okhttp3/internal/tls/SslClient.java
@@ -0,0 +1,169 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.tls;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.security.GeneralSecurityException;
+import java.security.KeyPair;
+import java.security.KeyStore;
+import java.security.SecureRandom;
+import java.security.cert.Certificate;
+import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import javax.net.ssl.KeyManagerFactory;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.X509TrustManager;
+
+/**
+ * Combines an SSL socket factory and trust manager, a pairing enough for OkHttp or MockWebServer to
+ * create a secure connection.
+ */
+public final class SslClient {
+  private static SslClient localhost; // Lazily initialized.
+
+  public final SSLContext sslContext;
+  public final SSLSocketFactory socketFactory;
+  public final X509TrustManager trustManager;
+
+  private SslClient(SSLContext sslContext, X509TrustManager trustManager) {
+    this.sslContext = sslContext;
+    this.socketFactory = sslContext.getSocketFactory();
+    this.trustManager = trustManager;
+  }
+
+  /** Returns an SSL client for this host's localhost address. */
+  public static synchronized SslClient localhost() {
+    if (localhost != null) return localhost;
+
+    try {
+      // Generate a self-signed cert for the server to serve and the client to trust.
+      HeldCertificate heldCertificate = new HeldCertificate.Builder()
+          .serialNumber("1")
+          .commonName(InetAddress.getByName("localhost").getCanonicalHostName())
+          .build();
+
+      localhost = new Builder()
+          .certificateChain(heldCertificate.keyPair, heldCertificate.certificate)
+          .addTrustedCertificate(heldCertificate.certificate)
+          .build();
+
+      return localhost;
+    } catch (GeneralSecurityException | UnknownHostException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  public static class Builder {
+    private final List<X509Certificate> chainCertificates = new ArrayList<>();
+    private final List<X509Certificate> certificates = new ArrayList<>();
+    private KeyPair keyPair;
+    private String keyStoreType = KeyStore.getDefaultType();
+
+    /**
+     * Configure the certificate chain to use when serving HTTPS responses. The first certificate is
+     * the server's certificate, further certificates are included in the handshake so the client
+     * can build a trusted path to a CA certificate.
+     */
+    public Builder certificateChain(HeldCertificate localCert, HeldCertificate... chain) {
+      X509Certificate[] certificates = new X509Certificate[chain.length];
+      for (int i = 0; i < chain.length; i++) {
+        certificates[i] = chain[i].certificate;
+      }
+      return certificateChain(localCert.keyPair, localCert.certificate, certificates);
+    }
+
+    public Builder certificateChain(KeyPair keyPair, X509Certificate keyCert,
+        X509Certificate... certificates) {
+      this.keyPair = keyPair;
+      this.chainCertificates.add(keyCert);
+      this.chainCertificates.addAll(Arrays.asList(certificates));
+      this.certificates.addAll(Arrays.asList(certificates));
+      return this;
+    }
+
+    /**
+     * Add a certificate authority that this client trusts. Servers that provide certificate chains
+     * signed by these roots (or their intermediates) will be accepted.
+     */
+    public Builder addTrustedCertificate(X509Certificate certificate) {
+      this.certificates.add(certificate);
+      return this;
+    }
+
+    public Builder keyStoreType(String keyStoreType) {
+      this.keyStoreType = keyStoreType;
+      return this;
+    }
+
+    public SslClient build() {
+      try {
+        // Put the certificate in a key store.
+        char[] password = "password".toCharArray();
+        KeyStore keyStore = newEmptyKeyStore(password);
+
+        if (keyPair != null) {
+          Certificate[] certificates = chainCertificates.toArray(
+              new Certificate[chainCertificates.size()]);
+          keyStore.setKeyEntry("private", keyPair.getPrivate(), password, certificates);
+        }
+
+        for (int i = 0; i < certificates.size(); i++) {
+          keyStore.setCertificateEntry("cert_" + i, certificates.get(i));
+        }
+
+        // Wrap it up in an SSL context.
+        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(
+            KeyManagerFactory.getDefaultAlgorithm());
+        keyManagerFactory.init(keyStore, password);
+        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+            TrustManagerFactory.getDefaultAlgorithm());
+        trustManagerFactory.init(keyStore);
+        TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
+
+        if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
+          throw new IllegalStateException("Unexpected default trust managers:"
+              + Arrays.toString(trustManagers));
+        }
+
+        SSLContext sslContext = SSLContext.getInstance("TLS");
+        sslContext.init(keyManagerFactory.getKeyManagers(), trustManagers, new SecureRandom());
+
+        return new SslClient(sslContext, (X509TrustManager) trustManagers[0]);
+      } catch (GeneralSecurityException gse) {
+        throw new AssertionError(gse);
+      }
+    }
+
+    private KeyStore newEmptyKeyStore(char[] password) throws GeneralSecurityException {
+      try {
+        KeyStore keyStore = KeyStore.getInstance(keyStoreType);
+        InputStream in = null; // By convention, 'null' creates an empty key store.
+        keyStore.load(in, password);
+        return keyStore;
+      } catch (IOException e) {
+        throw new AssertionError(e);
+      }
+    }
+  }
+}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/Dispatcher.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/Dispatcher.java
new file mode 100644
index 0000000000..9f4fc9fb66
--- /dev/null
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/Dispatcher.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.mockwebserver;
+
+/** Handler for mock server requests. */
+public abstract class Dispatcher {
+  /**
+   * Returns a response to satisfy {@code request}. This method may block (for instance, to wait on
+   * a CountdownLatch).
+   */
+  public abstract MockResponse dispatch(RecordedRequest request) throws InterruptedException;
+
+  /**
+   * Returns an early guess of the next response, used for policy on how an incoming request should
+   * be received. The default implementation returns an empty response. Mischievous implementations
+   * can return other values to test HTTP edge cases, such as unhappy socket policies or throttled
+   * request bodies.
+   */
+  public MockResponse peek() {
+    return new MockResponse().setSocketPolicy(SocketPolicy.KEEP_OPEN);
+  }
+
+  /**
+   * Release any resources held by this dispatcher. Any requests that are currently being dispatched
+   * should return immediately. Responses returned after shutdown will not be transmitted: their
+   * socket connections have already been closed.
+   */
+  public void shutdown() {
+  }
+}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
new file mode 100644
index 0000000000..36457229ed
--- /dev/null
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
@@ -0,0 +1,316 @@
+/*
+ * Copyright (C) 2011 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.mockwebserver;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import okhttp3.Headers;
+import okhttp3.WebSocketListener;
+import okhttp3.internal.Internal;
+import okhttp3.internal.http2.Settings;
+import okio.Buffer;
+
+/** A scripted response to be replayed by the mock web server. */
+public final class MockResponse implements Cloneable {
+  private static final String CHUNKED_BODY_HEADER = "Transfer-encoding: chunked";
+
+  private String status;
+  private Headers.Builder headers = new Headers.Builder();
+
+  private Buffer body;
+
+  private long throttleBytesPerPeriod = Long.MAX_VALUE;
+  private long throttlePeriodAmount = 1;
+  private TimeUnit throttlePeriodUnit = TimeUnit.SECONDS;
+
+  private SocketPolicy socketPolicy = SocketPolicy.KEEP_OPEN;
+  private int http2ErrorCode = -1;
+
+  private long bodyDelayAmount = 0;
+  private TimeUnit bodyDelayUnit = TimeUnit.MILLISECONDS;
+
+  private long headersDelayAmount = 0;
+  private TimeUnit headersDelayUnit = TimeUnit.MILLISECONDS;
+
+  private List<PushPromise> promises = new ArrayList<>();
+  private Settings settings;
+  private WebSocketListener webSocketListener;
+
+  /** Creates a new mock response with an empty body. */
+  public MockResponse() {
+    setResponseCode(200);
+    setHeader("Content-Length", 0);
+  }
+
+  @Override public MockResponse clone() {
+    try {
+      MockResponse result = (MockResponse) super.clone();
+      result.headers = headers.build().newBuilder();
+      result.promises = new ArrayList<>(promises);
+      return result;
+    } catch (CloneNotSupportedException e) {
+      throw new AssertionError();
+    }
+  }
+
+  /** Returns the HTTP response line, such as "HTTP/1.1 200 OK". */
+  public String getStatus() {
+    return status;
+  }
+
+  public MockResponse setResponseCode(int code) {
+    String reason = "Mock Response";
+    if (code >= 100 && code < 200) {
+      reason = "Informational";
+    } else if (code >= 200 && code < 300) {
+      reason = "OK";
+    } else if (code >= 300 && code < 400) {
+      reason = "Redirection";
+    } else if (code >= 400 && code < 500) {
+      reason = "Client Error";
+    } else if (code >= 500 && code < 600) {
+      reason = "Server Error";
+    }
+    return setStatus("HTTP/1.1 " + code + " " + reason);
+  }
+
+  public MockResponse setStatus(String status) {
+    this.status = status;
+    return this;
+  }
+
+  /** Returns the HTTP headers, such as "Content-Length: 0". */
+  public Headers getHeaders() {
+    return headers.build();
+  }
+
+  /**
+   * Removes all HTTP headers including any "Content-Length" and "Transfer-encoding" headers that
+   * were added by default.
+   */
+  public MockResponse clearHeaders() {
+    headers = new Headers.Builder();
+    return this;
+  }
+
+  /**
+   * Adds {@code header} as an HTTP header. For well-formed HTTP {@code header} should contain a
+   * name followed by a colon and a value.
+   */
+  public MockResponse addHeader(String header) {
+    headers.add(header);
+    return this;
+  }
+
+  /**
+   * Adds a new header with the name and value. This may be used to add multiple headers with the
+   * same name.
+   */
+  public MockResponse addHeader(String name, Object value) {
+    headers.add(name, String.valueOf(value));
+    return this;
+  }
+
+  /**
+   * Adds a new header with the name and value. This may be used to add multiple headers with the
+   * same name. Unlike {@link #addHeader(String, Object)} this does not validate the name and
+   * value.
+   */
+  public MockResponse addHeaderLenient(String name, Object value) {
+    Internal.instance.addLenient(headers, name, String.valueOf(value));
+    return this;
+  }
+
+  /**
+   * Removes all headers named {@code name}, then adds a new header with the name and value.
+   */
+  public MockResponse setHeader(String name, Object value) {
+    removeHeader(name);
+    return addHeader(name, value);
+  }
+
+  /** Replaces all headers with those specified in {@code headers}. */
+  public MockResponse setHeaders(Headers headers) {
+    this.headers = headers.newBuilder();
+    return this;
+  }
+
+  /** Removes all headers named {@code name}. */
+  public MockResponse removeHeader(String name) {
+    headers.removeAll(name);
+    return this;
+  }
+
+  /** Returns a copy of the raw HTTP payload. */
+  public Buffer getBody() {
+    return body != null ? body.clone() : null;
+  }
+
+  public MockResponse setBody(Buffer body) {
+    setHeader("Content-Length", body.size());
+    this.body = body.clone(); // Defensive copy.
+    return this;
+  }
+
+  /** Sets the response body to the UTF-8 encoded bytes of {@code body}. */
+  public MockResponse setBody(String body) {
+    return setBody(new Buffer().writeUtf8(body));
+  }
+
+  /**
+   * Sets the response body to {@code body}, chunked every {@code maxChunkSize} bytes.
+   */
+  public MockResponse setChunkedBody(Buffer body, int maxChunkSize) {
+    removeHeader("Content-Length");
+    headers.add(CHUNKED_BODY_HEADER);
+
+    Buffer bytesOut = new Buffer();
+    while (!body.exhausted()) {
+      long chunkSize = Math.min(body.size(), maxChunkSize);
+      bytesOut.writeHexadecimalUnsignedLong(chunkSize);
+      bytesOut.writeUtf8("\r\n");
+      bytesOut.write(body, chunkSize);
+      bytesOut.writeUtf8("\r\n");
+    }
+    bytesOut.writeUtf8("0\r\n\r\n"); // Last chunk + empty trailer + CRLF.
+
+    this.body = bytesOut;
+    return this;
+  }
+
+  /**
+   * Sets the response body to the UTF-8 encoded bytes of {@code body}, chunked every {@code
+   * maxChunkSize} bytes.
+   */
+  public MockResponse setChunkedBody(String body, int maxChunkSize) {
+    return setChunkedBody(new Buffer().writeUtf8(body), maxChunkSize);
+  }
+
+  public SocketPolicy getSocketPolicy() {
+    return socketPolicy;
+  }
+
+  public MockResponse setSocketPolicy(SocketPolicy socketPolicy) {
+    this.socketPolicy = socketPolicy;
+    return this;
+  }
+
+  public int getHttp2ErrorCode() {
+    return http2ErrorCode;
+  }
+
+  /**
+   * Sets the <a href="https://tools.ietf.org/html/rfc7540#section-7">HTTP/2 error code</a> to be
+   * returned when resetting the stream. This is only valid with {@link
+   * SocketPolicy#RESET_STREAM_AT_START}.
+   */
+  public MockResponse setHttp2ErrorCode(int http2ErrorCode) {
+    this.http2ErrorCode = http2ErrorCode;
+    return this;
+  }
+
+  /**
+   * Throttles the request reader and response writer to sleep for the given period after each
+   * series of {@code bytesPerPeriod} bytes are transferred. Use this to simulate network behavior.
+   */
+  public MockResponse throttleBody(long bytesPerPeriod, long period, TimeUnit unit) {
+    this.throttleBytesPerPeriod = bytesPerPeriod;
+    this.throttlePeriodAmount = period;
+    this.throttlePeriodUnit = unit;
+    return this;
+  }
+
+  public long getThrottleBytesPerPeriod() {
+    return throttleBytesPerPeriod;
+  }
+
+  public long getThrottlePeriod(TimeUnit unit) {
+    return unit.convert(throttlePeriodAmount, throttlePeriodUnit);
+  }
+
+  /**
+   * Set the delayed time of the response body to {@code delay}. This applies to the response body
+   * only; response headers are not affected.
+   */
+  public MockResponse setBodyDelay(long delay, TimeUnit unit) {
+    bodyDelayAmount = delay;
+    bodyDelayUnit = unit;
+    return this;
+  }
+
+  public long getBodyDelay(TimeUnit unit) {
+    return unit.convert(bodyDelayAmount, bodyDelayUnit);
+  }
+
+  public MockResponse setHeadersDelay(long delay, TimeUnit unit) {
+    headersDelayAmount = delay;
+    headersDelayUnit = unit;
+    return this;
+  }
+
+  public long getHeadersDelay(TimeUnit unit) {
+    return unit.convert(headersDelayAmount, headersDelayUnit);
+  }
+
+  /**
+   * When {@link MockWebServer#setProtocols(java.util.List) protocols} include {@linkplain
+   * okhttp3.Protocol#HTTP_2}, this attaches a pushed stream to this response.
+   */
+  public MockResponse withPush(PushPromise promise) {
+    this.promises.add(promise);
+    return this;
+  }
+
+  /** Returns the streams the server will push with this response. */
+  public List<PushPromise> getPushPromises() {
+    return promises;
+  }
+
+  /**
+   * When {@linkplain MockWebServer#setProtocols(java.util.List) protocols} include {@linkplain
+   * okhttp3.Protocol#HTTP_2 HTTP/2}, this pushes {@code settings} before writing the response.
+   */
+  public MockResponse withSettings(Settings settings) {
+    this.settings = settings;
+    return this;
+  }
+
+  public Settings getSettings() {
+    return settings;
+  }
+
+  /**
+   * Attempts to perform a web socket upgrade on the connection. This will overwrite any previously
+   * set status or body.
+   */
+  public MockResponse withWebSocketUpgrade(WebSocketListener listener) {
+    setStatus("HTTP/1.1 101 Switching Protocols");
+    setHeader("Connection", "Upgrade");
+    setHeader("Upgrade", "websocket");
+    body = null;
+    webSocketListener = listener;
+    return this;
+  }
+
+  public WebSocketListener getWebSocketListener() {
+    return webSocketListener;
+  }
+
+  @Override public String toString() {
+    return status;
+  }
+}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
new file mode 100644
index 0000000000..677adbae7d
--- /dev/null
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
@@ -0,0 +1,983 @@
+/*
+ * Copyright (C) 2011 Google Inc.
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package okhttp3.mockwebserver;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.ProtocolException;
+import java.net.Proxy;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.net.SocketException;
+import java.security.SecureRandom;
+import java.security.cert.CertificateException;
+import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Locale;
+import java.util.Set;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import javax.net.ServerSocketFactory;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.Headers;
+import okhttp3.HttpUrl;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.Internal;
+import okhttp3.internal.NamedRunnable;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.HttpMethod;
+import okhttp3.internal.http2.ErrorCode;
+import okhttp3.internal.http2.Header;
+import okhttp3.internal.http2.Http2Connection;
+import okhttp3.internal.http2.Http2Stream;
+import okhttp3.internal.http2.Settings;
+import okhttp3.internal.platform.Platform;
+import okhttp3.internal.ws.RealWebSocket;
+import okhttp3.internal.ws.WebSocketProtocol;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.Okio;
+import okio.Sink;
+import okio.Timeout;
+import org.junit.rules.ExternalResource;
+
+import static okhttp3.internal.Util.closeQuietly;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_DURING_REQUEST_BODY;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY;
+import static okhttp3.mockwebserver.SocketPolicy.EXPECT_CONTINUE;
+import static okhttp3.mockwebserver.SocketPolicy.FAIL_HANDSHAKE;
+import static okhttp3.mockwebserver.SocketPolicy.NO_RESPONSE;
+import static okhttp3.mockwebserver.SocketPolicy.RESET_STREAM_AT_START;
+import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
+import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END;
+import static okhttp3.mockwebserver.SocketPolicy.UPGRADE_TO_SSL_AT_END;
+
+/**
+ * A scriptable web server. Callers supply canned responses and the server replays them upon request
+ * in sequence.
+ */
+public final class MockWebServer extends ExternalResource implements Closeable {
+  static {
+    Internal.initializeInstanceForTests();
+  }
+
+  private static final X509TrustManager UNTRUSTED_TRUST_MANAGER = new X509TrustManager() {
+    @Override public void checkClientTrusted(X509Certificate[] chain, String authType)
+        throws CertificateException {
+      throw new CertificateException();
+    }
+
+    @Override public void checkServerTrusted(X509Certificate[] chain, String authType) {
+      throw new AssertionError();
+    }
+
+    @Override public X509Certificate[] getAcceptedIssuers() {
+      throw new AssertionError();
+    }
+  };
+
+  private static final Logger logger = Logger.getLogger(MockWebServer.class.getName());
+
+  private final BlockingQueue<RecordedRequest> requestQueue = new LinkedBlockingQueue<>();
+
+  private final Set<Socket> openClientSockets =
+      Collections.newSetFromMap(new ConcurrentHashMap<Socket, Boolean>());
+  private final Set<Http2Connection> openConnections =
+      Collections.newSetFromMap(new ConcurrentHashMap<Http2Connection, Boolean>());
+  private final AtomicInteger requestCount = new AtomicInteger();
+  private long bodyLimit = Long.MAX_VALUE;
+  private ServerSocketFactory serverSocketFactory = ServerSocketFactory.getDefault();
+  private ServerSocket serverSocket;
+  private SSLSocketFactory sslSocketFactory;
+  private ExecutorService executor;
+  private boolean tunnelProxy;
+  private Dispatcher dispatcher = new QueueDispatcher();
+
+  private int port = -1;
+  private InetSocketAddress inetSocketAddress;
+  private boolean protocolNegotiationEnabled = true;
+  private List<Protocol> protocols = Util.immutableList(Protocol.HTTP_2, Protocol.HTTP_1_1);
+
+  private boolean started;
+
+  @Override protected synchronized void before() {
+    if (started) return;
+    try {
+      start();
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  public int getPort() {
+    before();
+    return port;
+  }
+
+  public String getHostName() {
+    before();
+    return inetSocketAddress.getAddress().getCanonicalHostName();
+  }
+
+  public Proxy toProxyAddress() {
+    before();
+    InetSocketAddress address = new InetSocketAddress(inetSocketAddress.getAddress()
+            .getCanonicalHostName(), getPort());
+    return new Proxy(Proxy.Type.HTTP, address);
+  }
+
+  public void setServerSocketFactory(ServerSocketFactory serverSocketFactory) {
+    if (executor != null) {
+      throw new IllegalStateException(
+          "setServerSocketFactory() must be called before start()");
+    }
+    this.serverSocketFactory = serverSocketFactory;
+  }
+
+  /**
+   * Returns a URL for connecting to this server.
+   *
+   * @param path the request path, such as "/".
+   */
+  public HttpUrl url(String path) {
+    return new HttpUrl.Builder()
+        .scheme(sslSocketFactory != null ? "https" : "http")
+        .host(getHostName())
+        .port(getPort())
+        .build()
+        .resolve(path);
+  }
+
+  /**
+   * Sets the number of bytes of the POST body to keep in memory to the given limit.
+   */
+  public void setBodyLimit(long maxBodyLength) {
+    this.bodyLimit = maxBodyLength;
+  }
+
+  /**
+   * Sets whether ALPN is used on incoming HTTPS connections to negotiate a protocol like HTTP/1.1
+   * or HTTP/2. Call this method to disable negotiation and restrict connections to HTTP/1.1.
+   */
+  public void setProtocolNegotiationEnabled(boolean protocolNegotiationEnabled) {
+    this.protocolNegotiationEnabled = protocolNegotiationEnabled;
+  }
+
+  /**
+   * Indicates the protocols supported by ALPN on incoming HTTPS connections. This list is ignored
+   * when {@link #setProtocolNegotiationEnabled negotiation is disabled}.
+   *
+   * @param protocols the protocols to use, in order of preference. The list must contain
+   * {@linkplain Protocol#HTTP_1_1}. It must not contain null.
+   */
+  public void setProtocols(List<Protocol> protocols) {
+    protocols = Util.immutableList(protocols);
+    if (!protocols.contains(Protocol.HTTP_1_1)) {
+      throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
+    }
+    if (protocols.contains(null)) {
+      throw new IllegalArgumentException("protocols must not contain null");
+    }
+    this.protocols = protocols;
+  }
+
+  /**
+   * Serve requests with HTTPS rather than otherwise.
+   *
+   * @param tunnelProxy true to expect the HTTP CONNECT method before negotiating TLS.
+   */
+  public void useHttps(SSLSocketFactory sslSocketFactory, boolean tunnelProxy) {
+    this.sslSocketFactory = sslSocketFactory;
+    this.tunnelProxy = tunnelProxy;
+  }
+
+  /**
+   * Awaits the next HTTP request, removes it, and returns it. Callers should use this to verify the
+   * request was sent as intended. This method will block until the request is available, possibly
+   * forever.
+   *
+   * @return the head of the request queue
+   */
+  public RecordedRequest takeRequest() throws InterruptedException {
+    return requestQueue.take();
+  }
+
+  /**
+   * Awaits the next HTTP request (waiting up to the specified wait time if necessary), removes it,
+   * and returns it. Callers should use this to verify the request was sent as intended within the
+   * given time.
+   *
+   * @param timeout how long to wait before giving up, in units of {@code unit}
+   * @param unit a {@code TimeUnit} determining how to interpret the {@code timeout} parameter
+   * @return the head of the request queue
+   */
+  public RecordedRequest takeRequest(long timeout, TimeUnit unit) throws InterruptedException {
+    return requestQueue.poll(timeout, unit);
+  }
+
+  /**
+   * Returns the number of HTTP requests received thus far by this server. This may exceed the
+   * number of HTTP connections when connection reuse is in practice.
+   */
+  public int getRequestCount() {
+    return requestCount.get();
+  }
+
+  /**
+   * Scripts {@code response} to be returned to a request made in sequence. The first request is
+   * served by the first enqueued response; the second request by the second enqueued response; and
+   * so on.
+   *
+   * @throws ClassCastException if the default dispatcher has been replaced with {@link
+   * #setDispatcher(Dispatcher)}.
+   */
+  public void enqueue(MockResponse response) {
+    ((QueueDispatcher) dispatcher).enqueueResponse(response.clone());
+  }
+
+  /** Equivalent to {@code start(0)}. */
+  public void start() throws IOException {
+    start(0);
+  }
+
+  /**
+   * Starts the server on the loopback interface for the given port.
+   *
+   * @param port the port to listen to, or 0 for any available port. Automated tests should always
+   * use port 0 to avoid flakiness when a specific port is unavailable.
+   */
+  public void start(int port) throws IOException {
+    start(InetAddress.getByName("localhost"), port);
+  }
+
+  /**
+   * Starts the server on the given address and port.
+   *
+   * @param inetAddress the address to create the server socket on
+   * @param port the port to listen to, or 0 for any available port. Automated tests should always
+   * use port 0 to avoid flakiness when a specific port is unavailable.
+   */
+  public void start(InetAddress inetAddress, int port) throws IOException {
+    start(new InetSocketAddress(inetAddress, port));
+  }
+
+  /**
+   * Starts the server and binds to the given socket address.
+   *
+   * @param inetSocketAddress the socket address to bind the server on
+   */
+  private synchronized void start(InetSocketAddress inetSocketAddress) throws IOException {
+    if (started) throw new IllegalStateException("start() already called");
+    started = true;
+
+    executor = Executors.newCachedThreadPool(Util.threadFactory("MockWebServer", false));
+    this.inetSocketAddress = inetSocketAddress;
+    serverSocket = serverSocketFactory.createServerSocket();
+    // Reuse if the user specified a port
+    serverSocket.setReuseAddress(inetSocketAddress.getPort() != 0);
+    serverSocket.bind(inetSocketAddress, 50);
+
+    port = serverSocket.getLocalPort();
+    executor.execute(new NamedRunnable("MockWebServer %s", port) {
+      @Override protected void execute() {
+        try {
+          logger.info(MockWebServer.this + " starting to accept connections");
+          acceptConnections();
+        } catch (Throwable e) {
+          logger.log(Level.WARNING, MockWebServer.this + " failed unexpectedly", e);
+        }
+
+        // Release all sockets and all threads, even if any close fails.
+        closeQuietly(serverSocket);
+        for (Iterator<Socket> s = openClientSockets.iterator(); s.hasNext(); ) {
+          closeQuietly(s.next());
+          s.remove();
+        }
+        for (Iterator<Http2Connection> s = openConnections.iterator(); s.hasNext(); ) {
+          closeQuietly(s.next());
+          s.remove();
+        }
+        dispatcher.shutdown();
+        executor.shutdown();
+      }
+
+      private void acceptConnections() throws Exception {
+        while (true) {
+          Socket socket;
+          try {
+            socket = serverSocket.accept();
+          } catch (SocketException e) {
+            logger.info(MockWebServer.this + " done accepting connections: " + e.getMessage());
+            return;
+          }
+          SocketPolicy socketPolicy = dispatcher.peek().getSocketPolicy();
+          if (socketPolicy == DISCONNECT_AT_START) {
+            dispatchBookkeepingRequest(0, socket);
+            socket.close();
+          } else {
+            openClientSockets.add(socket);
+            serveConnection(socket);
+          }
+        }
+      }
+    });
+  }
+
+  public synchronized void shutdown() throws IOException {
+    if (!started) return;
+    if (serverSocket == null) throw new IllegalStateException("shutdown() before start()");
+
+    // Cause acceptConnections() to break out.
+    serverSocket.close();
+
+    // Await shutdown.
+    try {
+      if (!executor.awaitTermination(5, TimeUnit.SECONDS)) {
+        throw new IOException("Gave up waiting for executor to shut down");
+      }
+    } catch (InterruptedException e) {
+      throw new AssertionError();
+    }
+  }
+
+  @Override protected synchronized void after() {
+    try {
+      shutdown();
+    } catch (IOException e) {
+      logger.log(Level.WARNING, "MockWebServer shutdown failed", e);
+    }
+  }
+
+  private void serveConnection(final Socket raw) {
+    executor.execute(new NamedRunnable("MockWebServer %s", raw.getRemoteSocketAddress()) {
+      int sequenceNumber = 0;
+
+      @Override protected void execute() {
+        try {
+          processConnection();
+        } catch (IOException e) {
+          logger.info(
+              MockWebServer.this + " connection from " + raw.getInetAddress() + " failed: " + e);
+        } catch (Exception e) {
+          logger.log(Level.SEVERE,
+              MockWebServer.this + " connection from " + raw.getInetAddress() + " crashed", e);
+        }
+      }
+
+      public void processConnection() throws Exception {
+        Protocol protocol = Protocol.HTTP_1_1;
+        Socket socket;
+        if (sslSocketFactory != null) {
+          if (tunnelProxy) {
+            createTunnel();
+          }
+          SocketPolicy socketPolicy = dispatcher.peek().getSocketPolicy();
+          if (socketPolicy == FAIL_HANDSHAKE) {
+            dispatchBookkeepingRequest(sequenceNumber, raw);
+            processHandshakeFailure(raw);
+            return;
+          }
+          socket = sslSocketFactory.createSocket(raw, raw.getInetAddress().getHostAddress(),
+              raw.getPort(), true);
+          SSLSocket sslSocket = (SSLSocket) socket;
+          sslSocket.setUseClientMode(false);
+          openClientSockets.add(socket);
+
+          if (protocolNegotiationEnabled) {
+            Platform.get().configureTlsExtensions(sslSocket, null, protocols);
+          }
+
+          sslSocket.startHandshake();
+
+          if (protocolNegotiationEnabled) {
+            String protocolString = Platform.get().getSelectedProtocol(sslSocket);
+            protocol = protocolString != null ? Protocol.get(protocolString) : Protocol.HTTP_1_1;
+          }
+          openClientSockets.remove(raw);
+        } else {
+          socket = raw;
+        }
+
+        if (protocol == Protocol.HTTP_2) {
+          Http2SocketHandler http2SocketHandler = new Http2SocketHandler(socket, protocol);
+          Http2Connection connection = new Http2Connection.Builder(false)
+              .socket(socket)
+              .listener(http2SocketHandler)
+              .build();
+          connection.start();
+          openConnections.add(connection);
+          openClientSockets.remove(socket);
+          return;
+        } else if (protocol != Protocol.HTTP_1_1) {
+          throw new AssertionError();
+        }
+
+        BufferedSource source = Okio.buffer(Okio.source(socket));
+        BufferedSink sink = Okio.buffer(Okio.sink(socket));
+
+        while (processOneRequest(socket, source, sink)) {
+        }
+
+        if (sequenceNumber == 0) {
+          logger.warning(MockWebServer.this
+              + " connection from "
+              + raw.getInetAddress()
+              + " didn't make a request");
+        }
+
+        socket.close();
+        openClientSockets.remove(socket);
+      }
+
+      /**
+       * Respond to CONNECT requests until a SWITCH_TO_SSL_AT_END response is
+       * dispatched.
+       */
+      private void createTunnel() throws IOException, InterruptedException {
+        BufferedSource source = Okio.buffer(Okio.source(raw));
+        BufferedSink sink = Okio.buffer(Okio.sink(raw));
+        while (true) {
+          SocketPolicy socketPolicy = dispatcher.peek().getSocketPolicy();
+          if (!processOneRequest(raw, source, sink)) {
+            throw new IllegalStateException("Tunnel without any CONNECT!");
+          }
+          if (socketPolicy == UPGRADE_TO_SSL_AT_END) return;
+        }
+      }
+
+      /**
+       * Reads a request and writes its response. Returns true if further calls should be attempted
+       * on the socket.
+       */
+      private boolean processOneRequest(Socket socket, BufferedSource source, BufferedSink sink)
+          throws IOException, InterruptedException {
+        RecordedRequest request = readRequest(socket, source, sink, sequenceNumber);
+        if (request == null) return false;
+
+        requestCount.incrementAndGet();
+        requestQueue.add(request);
+
+        MockResponse response = dispatcher.dispatch(request);
+        if (response.getSocketPolicy() == DISCONNECT_AFTER_REQUEST) {
+          socket.close();
+          return false;
+        }
+        if (response.getSocketPolicy() == NO_RESPONSE) {
+          // This read should block until the socket is closed. (Because nobody is writing.)
+          if (source.exhausted()) return false;
+          throw new ProtocolException("unexpected data");
+        }
+
+        boolean reuseSocket = true;
+        boolean requestWantsWebSockets = "Upgrade".equalsIgnoreCase(request.getHeader("Connection"))
+            && "websocket".equalsIgnoreCase(request.getHeader("Upgrade"));
+        boolean responseWantsWebSockets = response.getWebSocketListener() != null;
+        if (requestWantsWebSockets && responseWantsWebSockets) {
+          handleWebSocketUpgrade(socket, source, sink, request, response);
+          reuseSocket = false;
+        } else {
+          writeHttpResponse(socket, sink, response);
+        }
+
+        if (logger.isLoggable(Level.INFO)) {
+          logger.info(MockWebServer.this + " received request: " + request
+              + " and responded: " + response);
+        }
+
+        // See warnings associated with these socket policies in SocketPolicy.
+        if (response.getSocketPolicy() == DISCONNECT_AT_END) {
+          socket.close();
+          return false;
+        } else if (response.getSocketPolicy() == SHUTDOWN_INPUT_AT_END) {
+          socket.shutdownInput();
+        } else if (response.getSocketPolicy() == SHUTDOWN_OUTPUT_AT_END) {
+          socket.shutdownOutput();
+        }
+
+        sequenceNumber++;
+        return reuseSocket;
+      }
+    });
+  }
+
+  private void processHandshakeFailure(Socket raw) throws Exception {
+    SSLContext context = SSLContext.getInstance("TLS");
+    context.init(null, new TrustManager[] {UNTRUSTED_TRUST_MANAGER}, new SecureRandom());
+    SSLSocketFactory sslSocketFactory = context.getSocketFactory();
+    SSLSocket socket = (SSLSocket) sslSocketFactory.createSocket(
+        raw, raw.getInetAddress().getHostAddress(), raw.getPort(), true);
+    try {
+      socket.startHandshake(); // we're testing a handshake failure
+      throw new AssertionError();
+    } catch (IOException expected) {
+    }
+    socket.close();
+  }
+
+  private void dispatchBookkeepingRequest(int sequenceNumber, Socket socket)
+      throws InterruptedException {
+    RecordedRequest request = new RecordedRequest(
+        null, null, null, -1, null, sequenceNumber, socket);
+    requestCount.incrementAndGet();
+    requestQueue.add(request);
+    dispatcher.dispatch(request);
+  }
+
+  /** @param sequenceNumber the index of this request on this connection. */
+  private RecordedRequest readRequest(Socket socket, BufferedSource source, BufferedSink sink,
+      int sequenceNumber) throws IOException {
+    String request;
+    try {
+      request = source.readUtf8LineStrict();
+    } catch (IOException streamIsClosed) {
+      return null; // no request because we closed the stream
+    }
+    if (request.length() == 0) {
+      return null; // no request because the stream is exhausted
+    }
+
+    Headers.Builder headers = new Headers.Builder();
+    long contentLength = -1;
+    boolean chunked = false;
+    boolean expectContinue = false;
+    String header;
+    while ((header = source.readUtf8LineStrict()).length() != 0) {
+      Internal.instance.addLenient(headers, header);
+      String lowercaseHeader = header.toLowerCase(Locale.US);
+      if (contentLength == -1 && lowercaseHeader.startsWith("content-length:")) {
+        contentLength = Long.parseLong(header.substring(15).trim());
+      }
+      if (lowercaseHeader.startsWith("transfer-encoding:")
+          && lowercaseHeader.substring(18).trim().equals("chunked")) {
+        chunked = true;
+      }
+      if (lowercaseHeader.startsWith("expect:")
+          && lowercaseHeader.substring(7).trim().equalsIgnoreCase("100-continue")) {
+        expectContinue = true;
+      }
+    }
+
+    if (expectContinue && dispatcher.peek().getSocketPolicy() == EXPECT_CONTINUE) {
+      sink.writeUtf8("HTTP/1.1 100 Continue\r\n");
+      sink.writeUtf8("Content-Length: 0\r\n");
+      sink.writeUtf8("\r\n");
+      sink.flush();
+    }
+
+    boolean hasBody = false;
+    TruncatingBuffer requestBody = new TruncatingBuffer(bodyLimit);
+    List<Integer> chunkSizes = new ArrayList<>();
+    MockResponse policy = dispatcher.peek();
+    if (contentLength != -1) {
+      hasBody = contentLength > 0;
+      throttledTransfer(policy, socket, source, Okio.buffer(requestBody), contentLength, true);
+    } else if (chunked) {
+      hasBody = true;
+      while (true) {
+        int chunkSize = Integer.parseInt(source.readUtf8LineStrict().trim(), 16);
+        if (chunkSize == 0) {
+          readEmptyLine(source);
+          break;
+        }
+        chunkSizes.add(chunkSize);
+        throttledTransfer(policy, socket, source, Okio.buffer(requestBody), chunkSize, true);
+        readEmptyLine(source);
+      }
+    }
+
+    String method = request.substring(0, request.indexOf(' '));
+    if (hasBody && !HttpMethod.permitsRequestBody(method)) {
+      throw new IllegalArgumentException("Request must not have a body: " + request);
+    }
+
+    return new RecordedRequest(request, headers.build(), chunkSizes, requestBody.receivedByteCount,
+        requestBody.buffer, sequenceNumber, socket);
+  }
+
+  private void handleWebSocketUpgrade(Socket socket, BufferedSource source, BufferedSink sink,
+      RecordedRequest request, MockResponse response) throws IOException {
+    String key = request.getHeader("Sec-WebSocket-Key");
+    response.setHeader("Sec-WebSocket-Accept", WebSocketProtocol.acceptHeader(key));
+
+    writeHttpResponse(socket, sink, response);
+
+    // Adapt the request and response into our Request and Response domain model.
+    String scheme = request.getTlsVersion() != null ? "https" : "http";
+    String authority = request.getHeader("Host"); // Has host and port.
+    final Request fancyRequest = new Request.Builder()
+        .url(scheme + "://" + authority + "/")
+        .headers(request.getHeaders())
+        .build();
+    final Response fancyResponse = new Response.Builder()
+        .code(Integer.parseInt(response.getStatus().split(" ")[1]))
+        .message(response.getStatus().split(" ", 3)[2])
+        .headers(response.getHeaders())
+        .request(fancyRequest)
+        .protocol(Protocol.HTTP_1_1)
+        .build();
+
+    final CountDownLatch connectionClose = new CountDownLatch(1);
+    RealWebSocket.Streams streams = new RealWebSocket.Streams(false, source, sink) {
+      @Override public void close() {
+        connectionClose.countDown();
+      }
+    };
+    RealWebSocket webSocket = new RealWebSocket(fancyRequest,
+        response.getWebSocketListener(), new SecureRandom());
+    response.getWebSocketListener().onOpen(webSocket, fancyResponse);
+    String name = "MockWebServer WebSocket " + request.getPath();
+    webSocket.initReaderAndWriter(name, 0, streams);
+    try {
+      webSocket.loopReader();
+
+      // Even if messages are no longer being read we need to wait for the connection close signal.
+      try {
+        connectionClose.await();
+      } catch (InterruptedException ignored) {
+      }
+
+    } catch (IOException e) {
+      webSocket.failWebSocket(e, null);
+    } finally {
+      closeQuietly(source);
+    }
+  }
+
+  private void writeHttpResponse(Socket socket, BufferedSink sink, MockResponse response)
+      throws IOException {
+    sleepIfDelayed(response.getBodyDelay(TimeUnit.MILLISECONDS));
+    sink.writeUtf8(response.getStatus());
+    sink.writeUtf8("\r\n");
+
+    Headers headers = response.getHeaders();
+    for (int i = 0, size = headers.size(); i < size; i++) {
+      sink.writeUtf8(headers.name(i));
+      sink.writeUtf8(": ");
+      sink.writeUtf8(headers.value(i));
+      sink.writeUtf8("\r\n");
+    }
+    sink.writeUtf8("\r\n");
+    sink.flush();
+
+    Buffer body = response.getBody();
+    if (body == null) return;
+    sleepIfDelayed(response.getBodyDelay(TimeUnit.MILLISECONDS));
+    throttledTransfer(response, socket, body, sink, body.size(), false);
+  }
+
+  private void sleepIfDelayed(long delayMs) {
+    if (delayMs != 0) {
+      try {
+        Thread.sleep(delayMs);
+      } catch (InterruptedException e) {
+        throw new AssertionError(e);
+      }
+    }
+  }
+
+  /**
+   * Transfer bytes from {@code source} to {@code sink} until either {@code byteCount} bytes have
+   * been transferred or {@code source} is exhausted. The transfer is throttled according to {@code
+   * policy}.
+   */
+  private void throttledTransfer(MockResponse policy, Socket socket, BufferedSource source,
+      BufferedSink sink, long byteCount, boolean isRequest) throws IOException {
+    if (byteCount == 0) return;
+
+    Buffer buffer = new Buffer();
+    long bytesPerPeriod = policy.getThrottleBytesPerPeriod();
+    long periodDelayMs = policy.getThrottlePeriod(TimeUnit.MILLISECONDS);
+
+    long halfByteCount = byteCount / 2;
+    boolean disconnectHalfway = isRequest
+        ? policy.getSocketPolicy() == DISCONNECT_DURING_REQUEST_BODY
+        : policy.getSocketPolicy() == DISCONNECT_DURING_RESPONSE_BODY;
+
+    while (!socket.isClosed()) {
+      for (int b = 0; b < bytesPerPeriod; ) {
+        // Ensure we do not read past the allotted bytes in this period.
+        long toRead = Math.min(byteCount, bytesPerPeriod - b);
+        // Ensure we do not read past halfway if the policy will kill the connection.
+        if (disconnectHalfway) {
+          toRead = Math.min(toRead, byteCount - halfByteCount);
+        }
+
+        long read = source.read(buffer, toRead);
+        if (read == -1) return;
+
+        sink.write(buffer, read);
+        sink.flush();
+        b += read;
+        byteCount -= read;
+
+        if (disconnectHalfway && byteCount == halfByteCount) {
+          socket.close();
+          return;
+        }
+
+        if (byteCount == 0) return;
+      }
+
+      if (periodDelayMs != 0) {
+        try {
+          Thread.sleep(periodDelayMs);
+        } catch (InterruptedException e) {
+          throw new AssertionError();
+        }
+      }
+    }
+  }
+
+  private void readEmptyLine(BufferedSource source) throws IOException {
+    String line = source.readUtf8LineStrict();
+    if (line.length() != 0) throw new IllegalStateException("Expected empty but was: " + line);
+  }
+
+  /**
+   * Sets the dispatcher used to match incoming requests to mock responses. The default dispatcher
+   * simply serves a fixed sequence of responses from a {@link #enqueue(MockResponse) queue}; custom
+   * dispatchers can vary the response based on timing or the content of the request.
+   */
+  public void setDispatcher(Dispatcher dispatcher) {
+    if (dispatcher == null) throw new NullPointerException();
+    this.dispatcher = dispatcher;
+  }
+
+  @Override public String toString() {
+    return "MockWebServer[" + port + "]";
+  }
+
+  @Override public void close() throws IOException {
+    shutdown();
+  }
+
+  /** A buffer wrapper that drops data after {@code bodyLimit} bytes. */
+  private static class TruncatingBuffer implements Sink {
+    private final Buffer buffer = new Buffer();
+    private long remainingByteCount;
+    private long receivedByteCount;
+
+    TruncatingBuffer(long bodyLimit) {
+      remainingByteCount = bodyLimit;
+    }
+
+    @Override public void write(Buffer source, long byteCount) throws IOException {
+      long toRead = Math.min(remainingByteCount, byteCount);
+      if (toRead > 0) {
+        source.read(buffer, toRead);
+      }
+      long toSkip = byteCount - toRead;
+      if (toSkip > 0) {
+        source.skip(toSkip);
+      }
+      remainingByteCount -= toRead;
+      receivedByteCount += byteCount;
+    }
+
+    @Override public void flush() throws IOException {
+    }
+
+    @Override public Timeout timeout() {
+      return Timeout.NONE;
+    }
+
+    @Override public void close() throws IOException {
+    }
+  }
+
+  /** Processes HTTP requests layered over HTTP/2. */
+  private class Http2SocketHandler extends Http2Connection.Listener {
+    private final Socket socket;
+    private final Protocol protocol;
+    private final AtomicInteger sequenceNumber = new AtomicInteger();
+
+    private Http2SocketHandler(Socket socket, Protocol protocol) {
+      this.socket = socket;
+      this.protocol = protocol;
+    }
+
+    @Override public void onStream(Http2Stream stream) throws IOException {
+      MockResponse peekedResponse = dispatcher.peek();
+      if (peekedResponse.getSocketPolicy() == RESET_STREAM_AT_START) {
+        try {
+          dispatchBookkeepingRequest(sequenceNumber.getAndIncrement(), socket);
+          stream.close(ErrorCode.fromHttp2(peekedResponse.getHttp2ErrorCode()));
+          return;
+        } catch (InterruptedException e) {
+          throw new InterruptedIOException();
+        }
+      }
+
+      RecordedRequest request = readRequest(stream);
+      requestCount.incrementAndGet();
+      requestQueue.add(request);
+
+      MockResponse response;
+      try {
+        response = dispatcher.dispatch(request);
+      } catch (InterruptedException e) {
+        throw new AssertionError(e);
+      }
+      if (response.getSocketPolicy() == DISCONNECT_AFTER_REQUEST) {
+        socket.close();
+        return;
+      }
+      writeResponse(stream, response);
+      if (logger.isLoggable(Level.INFO)) {
+        logger.info(MockWebServer.this + " received request: " + request
+            + " and responded: " + response + " protocol is " + protocol.toString());
+      }
+
+      if (response.getSocketPolicy() == DISCONNECT_AT_END) {
+        Http2Connection connection = stream.getConnection();
+        connection.shutdown(ErrorCode.NO_ERROR);
+      }
+    }
+
+    private RecordedRequest readRequest(Http2Stream stream) throws IOException {
+      List<Header> streamHeaders = stream.getRequestHeaders();
+      Headers.Builder httpHeaders = new Headers.Builder();
+      String method = "<:method omitted>";
+      String path = "<:path omitted>";
+      boolean readBody = true;
+      for (int i = 0, size = streamHeaders.size(); i < size; i++) {
+        ByteString name = streamHeaders.get(i).name;
+        String value = streamHeaders.get(i).value.utf8();
+        if (name.equals(Header.TARGET_METHOD)) {
+          method = value;
+        } else if (name.equals(Header.TARGET_PATH)) {
+          path = value;
+        } else if (protocol == Protocol.HTTP_2) {
+          httpHeaders.add(name.utf8(), value);
+        } else {
+          throw new IllegalStateException();
+        }
+        if (name.utf8().equals("expect") && value.equalsIgnoreCase("100-continue")) {
+          // Don't read the body unless we've invited the client to send it.
+          readBody = false;
+        }
+      }
+      Headers headers = httpHeaders.build();
+
+      MockResponse peek = dispatcher.peek();
+      if (!readBody && peek.getSocketPolicy() == EXPECT_CONTINUE) {
+        stream.sendResponseHeaders(Collections.singletonList(
+            new Header(Header.RESPONSE_STATUS, ByteString.encodeUtf8("100 Continue"))), true);
+        stream.getConnection().flush();
+        readBody = true;
+      }
+
+      Buffer body = new Buffer();
+      if (readBody) {
+        String contentLengthString = headers.get("content-length");
+        long byteCount = contentLengthString != null
+            ? Long.parseLong(contentLengthString)
+            : Long.MAX_VALUE;
+        throttledTransfer(peek, socket, Okio.buffer(stream.getSource()), body, byteCount, true);
+      }
+
+      String requestLine = method + ' ' + path + " HTTP/1.1";
+      List<Integer> chunkSizes = Collections.emptyList(); // No chunked encoding for HTTP/2.
+      return new RecordedRequest(requestLine, headers, chunkSizes, body.size(), body,
+          sequenceNumber.getAndIncrement(), socket);
+    }
+
+    private void writeResponse(Http2Stream stream, MockResponse response) throws IOException {
+      Settings settings = response.getSettings();
+      if (settings != null) {
+        stream.getConnection().setSettings(settings);
+      }
+
+      if (response.getSocketPolicy() == NO_RESPONSE) {
+        return;
+      }
+      List<Header> http2Headers = new ArrayList<>();
+      String[] statusParts = response.getStatus().split(" ", 3);
+      if (statusParts.length < 2) {
+        throw new AssertionError("Unexpected status: " + response.getStatus());
+      }
+      // TODO: constants for well-known header names.
+      http2Headers.add(new Header(Header.RESPONSE_STATUS, statusParts[1]));
+      Headers headers = response.getHeaders();
+      for (int i = 0, size = headers.size(); i < size; i++) {
+        http2Headers.add(new Header(headers.name(i), headers.value(i)));
+      }
+
+      sleepIfDelayed(response.getHeadersDelay(TimeUnit.MILLISECONDS));
+
+      Buffer body = response.getBody();
+      boolean closeStreamAfterHeaders = body != null || !response.getPushPromises().isEmpty();
+      stream.sendResponseHeaders(http2Headers, closeStreamAfterHeaders);
+      pushPromises(stream, response.getPushPromises());
+      if (body != null) {
+        BufferedSink sink = Okio.buffer(stream.getSink());
+        sleepIfDelayed(response.getBodyDelay(TimeUnit.MILLISECONDS));
+        throttledTransfer(response, socket, body, sink, body.size(), false);
+        sink.close();
+      } else if (closeStreamAfterHeaders) {
+        stream.close(ErrorCode.NO_ERROR);
+      }
+    }
+
+    private void pushPromises(Http2Stream stream, List<PushPromise> promises) throws IOException {
+      for (PushPromise pushPromise : promises) {
+        List<Header> pushedHeaders = new ArrayList<>();
+        pushedHeaders.add(new Header(Header.TARGET_AUTHORITY, url(pushPromise.path()).host()));
+        pushedHeaders.add(new Header(Header.TARGET_METHOD, pushPromise.method()));
+        pushedHeaders.add(new Header(Header.TARGET_PATH, pushPromise.path()));
+        Headers pushPromiseHeaders = pushPromise.headers();
+        for (int i = 0, size = pushPromiseHeaders.size(); i < size; i++) {
+          pushedHeaders.add(new Header(pushPromiseHeaders.name(i), pushPromiseHeaders.value(i)));
+        }
+        String requestLine = pushPromise.method() + ' ' + pushPromise.path() + " HTTP/1.1";
+        List<Integer> chunkSizes = Collections.emptyList(); // No chunked encoding for HTTP/2.
+        requestQueue.add(new RecordedRequest(requestLine, pushPromise.headers(), chunkSizes, 0,
+            new Buffer(), sequenceNumber.getAndIncrement(), socket));
+        boolean hasBody = pushPromise.response().getBody() != null;
+        Http2Stream pushedStream =
+            stream.getConnection().pushStream(stream.getId(), pushedHeaders, hasBody);
+        writeResponse(pushedStream, pushPromise.response());
+      }
+    }
+  }
+}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/PushPromise.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/PushPromise.java
new file mode 100644
index 0000000000..744127cadd
--- /dev/null
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/PushPromise.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.mockwebserver;
+
+import okhttp3.Headers;
+
+/** An HTTP request initiated by the server. */
+public final class PushPromise {
+  private final String method;
+  private final String path;
+  private final Headers headers;
+  private final MockResponse response;
+
+  public PushPromise(String method, String path, Headers headers, MockResponse response) {
+    this.method = method;
+    this.path = path;
+    this.headers = headers;
+    this.response = response;
+  }
+
+  public String method() {
+    return method;
+  }
+
+  public String path() {
+    return path;
+  }
+
+  public Headers headers() {
+    return headers;
+  }
+
+  public MockResponse response() {
+    return response;
+  }
+}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/QueueDispatcher.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/QueueDispatcher.java
new file mode 100644
index 0000000000..4071d4718b
--- /dev/null
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/QueueDispatcher.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.mockwebserver;
+
+import java.net.HttpURLConnection;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.logging.Logger;
+
+/**
+ * Default dispatcher that processes a script of responses. Populate the script by calling {@link
+ * #enqueueResponse(MockResponse)}.
+ */
+public class QueueDispatcher extends Dispatcher {
+  /**
+   * Enqueued on shutdown to release threads waiting on {@link #dispatch}. Note that this response
+   * isn't transmitted because the connection is closed before this response is returned.
+   */
+  private static final MockResponse DEAD_LETTER = new MockResponse()
+      .setStatus("HTTP/1.1 " + 503 + " shutting down");
+
+  private static final Logger logger = Logger.getLogger(QueueDispatcher.class.getName());
+  protected final BlockingQueue<MockResponse> responseQueue = new LinkedBlockingQueue<>();
+  private MockResponse failFastResponse;
+
+  @Override public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
+    // To permit interactive/browser testing, ignore requests for favicons.
+    final String requestLine = request.getRequestLine();
+    if (requestLine != null && requestLine.equals("GET /favicon.ico HTTP/1.1")) {
+      logger.info("served " + requestLine);
+      return new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_FOUND);
+    }
+
+    if (failFastResponse != null && responseQueue.peek() == null) {
+      // Fail fast if there's no response queued up.
+      return failFastResponse;
+    }
+
+    MockResponse result = responseQueue.take();
+
+    // If take() returned because we're shutting down, then enqueue another dead letter so that any
+    // other threads waiting on take() will also return.
+    if (result == DEAD_LETTER) responseQueue.add(DEAD_LETTER);
+
+    return result;
+  }
+
+  @Override public MockResponse peek() {
+    MockResponse peek = responseQueue.peek();
+    if (peek != null) return peek;
+    if (failFastResponse != null) return failFastResponse;
+    return super.peek();
+  }
+
+  public void enqueueResponse(MockResponse response) {
+    responseQueue.add(response);
+  }
+
+  @Override public void shutdown() {
+    responseQueue.add(DEAD_LETTER);
+  }
+
+  public void setFailFast(boolean failFast) {
+    MockResponse failFastResponse = failFast
+        ? new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_FOUND)
+        : null;
+    setFailFast(failFastResponse);
+  }
+
+  public void setFailFast(MockResponse failFastResponse) {
+    this.failFastResponse = failFastResponse;
+  }
+}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java
new file mode 100644
index 0000000000..672d42bc76
--- /dev/null
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java
@@ -0,0 +1,137 @@
+/*
+ * Copyright (C) 2011 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package okhttp3.mockwebserver;
+
+import java.net.Socket;
+import java.util.List;
+import javax.net.ssl.SSLSocket;
+import okhttp3.Headers;
+import okhttp3.HttpUrl;
+import okhttp3.TlsVersion;
+import okio.Buffer;
+
+/** An HTTP request that came into the mock web server. */
+public final class RecordedRequest {
+  private final String requestLine;
+  private final String method;
+  private final String path;
+  private final Headers headers;
+  private final List<Integer> chunkSizes;
+  private final long bodySize;
+  private final Buffer body;
+  private final int sequenceNumber;
+  private final TlsVersion tlsVersion;
+  private final HttpUrl requestUrl;
+
+  public RecordedRequest(String requestLine, Headers headers, List<Integer> chunkSizes,
+      long bodySize, Buffer body, int sequenceNumber, Socket socket) {
+    this.requestLine = requestLine;
+    this.headers = headers;
+    this.chunkSizes = chunkSizes;
+    this.bodySize = bodySize;
+    this.body = body;
+    this.sequenceNumber = sequenceNumber;
+    this.tlsVersion = socket instanceof SSLSocket
+        ? TlsVersion.forJavaName(((SSLSocket) socket).getSession().getProtocol())
+        : null;
+
+    if (requestLine != null) {
+      int methodEnd = requestLine.indexOf(' ');
+      int pathEnd = requestLine.indexOf(' ', methodEnd + 1);
+      this.method = requestLine.substring(0, methodEnd);
+      this.path = requestLine.substring(methodEnd + 1, pathEnd);
+
+      String scheme = socket instanceof SSLSocket ? "https" : "http";
+      String hostname = socket.getInetAddress().getHostName();
+      int port = socket.getLocalPort();
+      this.requestUrl = HttpUrl.parse(String.format("%s://%s:%s%s", scheme, hostname, port, path));
+    } else {
+      this.requestUrl = null;
+      this.method = null;
+      this.path = null;
+    }
+  }
+
+  public HttpUrl getRequestUrl() {
+    return requestUrl;
+  }
+
+  public String getRequestLine() {
+    return requestLine;
+  }
+
+  public String getMethod() {
+    return method;
+  }
+
+  public String getPath() {
+    return path;
+  }
+
+  /** Returns all headers. */
+  public Headers getHeaders() {
+    return headers;
+  }
+
+  /** Returns the first header named {@code name}, or null if no such header exists. */
+  public String getHeader(String name) {
+    List<String> values = headers.values(name);
+    return values.isEmpty() ? null : values.get(0);
+  }
+
+  /**
+   * Returns the sizes of the chunks of this request's body, or an empty list if the request's body
+   * was empty or unchunked.
+   */
+  public List<Integer> getChunkSizes() {
+    return chunkSizes;
+  }
+
+  /**
+   * Returns the total size of the body of this POST request (before truncation).
+   */
+  public long getBodySize() {
+    return bodySize;
+  }
+
+  /** Returns the body of this POST request. This may be truncated. */
+  public Buffer getBody() {
+    return body;
+  }
+
+  /** @deprecated Use {@link #getBody() getBody().readUtf8()}. */
+  public String getUtf8Body() {
+    return getBody().readUtf8();
+  }
+
+  /**
+   * Returns the index of this request on its HTTP connection. Since a single HTTP connection may
+   * serve multiple requests, each request is assigned its own sequence number.
+   */
+  public int getSequenceNumber() {
+    return sequenceNumber;
+  }
+
+  /** Returns the connection's TLS version or null if the connection doesn't use SSL. */
+  public TlsVersion getTlsVersion() {
+    return tlsVersion;
+  }
+
+  @Override public String toString() {
+    return requestLine;
+  }
+}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java
new file mode 100644
index 0000000000..521c5a0e58
--- /dev/null
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2011 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package okhttp3.mockwebserver;
+
+/**
+ * What should be done with the incoming socket.
+ *
+ * <p>Be careful when using values like {@link #DISCONNECT_AT_END}, {@link #SHUTDOWN_INPUT_AT_END}
+ * and {@link #SHUTDOWN_OUTPUT_AT_END} that close a socket after a response, and where there are
+ * follow-up requests. The client is unblocked and free to continue as soon as it has received the
+ * entire response body. If and when the client makes a subsequent request using a pooled socket the
+ * server may not have had time to close the socket. The socket will be closed at an indeterminate
+ * point before or during the second request. It may be closed after client has started sending the
+ * request body. If a request body is not retryable then the client may fail the request, making
+ * client behavior non-deterministic. Add delays in the client to improve the chances that the
+ * server has closed the socket before follow up requests are made.
+ */
+public enum SocketPolicy {
+
+  /**
+   * Keep the socket open after the response. This is the default HTTP/1.1 behavior.
+   */
+  KEEP_OPEN,
+
+  /**
+   * Close the socket after the response. This is the default HTTP/1.0 behavior. For HTTP/2
+   * connections, this sends a <a href="https://tools.ietf.org/html/rfc7540#section-6.8">GOAWAY
+   * frame</a> immediately after the response and will close the connection when the client's socket
+   * is exhausted.
+   *
+   * <p>See {@link SocketPolicy} for reasons why this can cause test flakiness and how to avoid it.
+   */
+  DISCONNECT_AT_END,
+
+  /**
+   * Wrap the socket with SSL at the completion of this request/response pair. Used for CONNECT
+   * messages to tunnel SSL over an HTTP proxy.
+   */
+  UPGRADE_TO_SSL_AT_END,
+
+  /**
+   * Request immediate close of connection without even reading the request. Use to simulate buggy
+   * SSL servers closing connections in response to unrecognized TLS extensions.
+   */
+  DISCONNECT_AT_START,
+
+  /**
+   * Close connection after reading the request but before writing the response. Use this to
+   * simulate late connection pool failures.
+   */
+  DISCONNECT_AFTER_REQUEST,
+
+  /** Close connection after reading half of the request body (if present). */
+  DISCONNECT_DURING_REQUEST_BODY,
+
+  /** Close connection after writing half of the response body (if present). */
+  DISCONNECT_DURING_RESPONSE_BODY,
+
+  /** Don't trust the client during the SSL handshake. */
+  FAIL_HANDSHAKE,
+
+  /**
+   * Shutdown the socket input after sending the response. For testing bad behavior.
+   *
+   * <p>See {@link SocketPolicy} for reasons why this can cause test flakiness and how to avoid it.
+   */
+  SHUTDOWN_INPUT_AT_END,
+
+  /**
+   * Shutdown the socket output after sending the response. For testing bad behavior.
+   *
+   * <p>See {@link SocketPolicy} for reasons why this can cause test flakiness and how to avoid it.
+   */
+  SHUTDOWN_OUTPUT_AT_END,
+
+  /**
+   * Don't respond to the request but keep the socket open. For testing read response header timeout
+   * issue.
+   */
+  NO_RESPONSE,
+
+  /**
+   * Fail HTTP/2 requests without processing them by sending an {@linkplain
+   * MockResponse#getHttp2ErrorCode() HTTP/2 error code}.
+   */
+  RESET_STREAM_AT_START,
+
+  /**
+   * Transmit a {@code HTTP/1.1 100 Continue} response before reading the HTTP request body.
+   * Typically this response is sent when a client makes a request with the header {@code
+   * Expect: 100-continue}.
+   */
+  EXPECT_CONTINUE
+}
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java
new file mode 100644
index 0000000000..5f189dc608
--- /dev/null
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.mockwebserver;
+
+import java.io.IOException;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicInteger;
+import org.junit.After;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+public class CustomDispatcherTest {
+  private MockWebServer mockWebServer = new MockWebServer();
+
+  @After public void tearDown() throws Exception {
+    mockWebServer.shutdown();
+  }
+
+  @Test public void simpleDispatch() throws Exception {
+    mockWebServer.start();
+    final List<RecordedRequest> requestsMade = new ArrayList<>();
+    final Dispatcher dispatcher = new Dispatcher() {
+      @Override
+      public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
+        requestsMade.add(request);
+        return new MockResponse();
+      }
+    };
+    assertEquals(0, requestsMade.size());
+    mockWebServer.setDispatcher(dispatcher);
+    final URL url = mockWebServer.url("/").url();
+    final HttpURLConnection conn = (HttpURLConnection) url.openConnection();
+    conn.getResponseCode(); // Force the connection to hit the "server".
+    // Make sure our dispatcher got the request.
+    assertEquals(1, requestsMade.size());
+  }
+
+  @Test public void outOfOrderResponses() throws Exception {
+    AtomicInteger firstResponseCode = new AtomicInteger();
+    AtomicInteger secondResponseCode = new AtomicInteger();
+    mockWebServer.start();
+    final String secondRequest = "/bar";
+    final String firstRequest = "/foo";
+    final CountDownLatch latch = new CountDownLatch(1);
+    final Dispatcher dispatcher = new Dispatcher() {
+      @Override
+      public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
+        if (request.getPath().equals(firstRequest)) {
+          latch.await();
+        }
+        return new MockResponse();
+      }
+    };
+    mockWebServer.setDispatcher(dispatcher);
+    final Thread startsFirst = buildRequestThread(firstRequest, firstResponseCode);
+    startsFirst.start();
+    final Thread endsFirst = buildRequestThread(secondRequest, secondResponseCode);
+    endsFirst.start();
+    endsFirst.join();
+    assertEquals(0, firstResponseCode.get()); // First response is still waiting.
+    assertEquals(200, secondResponseCode.get()); // Second response is done.
+    latch.countDown();
+    startsFirst.join();
+    assertEquals(200, firstResponseCode.get()); // And now it's done!
+    assertEquals(200, secondResponseCode.get()); // (Still done).
+  }
+
+  private Thread buildRequestThread(final String path, final AtomicInteger responseCode) {
+    return new Thread(new Runnable() {
+      @Override public void run() {
+        final URL url = mockWebServer.url(path).url();
+        final HttpURLConnection conn;
+        try {
+          conn = (HttpURLConnection) url.openConnection();
+          responseCode.set(conn.getResponseCode()); // Force the connection to hit the "server".
+        } catch (IOException e) {
+        }
+      }
+    });
+  }
+}
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
new file mode 100644
index 0000000000..0db518288a
--- /dev/null
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
@@ -0,0 +1,459 @@
+/*
+ * Copyright (C) 2011 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.mockwebserver;
+
+import java.io.BufferedReader;
+import java.io.Closeable;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.net.ConnectException;
+import java.net.HttpURLConnection;
+import java.net.ProtocolException;
+import java.net.SocketTimeoutException;
+import java.net.URL;
+import java.net.URLConnection;
+import java.nio.charset.StandardCharsets;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import okhttp3.Headers;
+import okhttp3.HttpUrl;
+import okhttp3.internal.Util;
+import org.junit.After;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+import static java.util.concurrent.TimeUnit.NANOSECONDS;
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class MockWebServerTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  @Test public void defaultMockResponse() {
+    MockResponse response = new MockResponse();
+    assertEquals(Arrays.asList("Content-Length: 0"), headersToList(response));
+    assertEquals("HTTP/1.1 200 OK", response.getStatus());
+  }
+
+  @Test public void setResponseMockReason() {
+    String[] reasons = {
+        "Mock Response",
+        "Informational",
+        "OK",
+        "Redirection",
+        "Client Error",
+        "Server Error",
+        "Mock Response"
+    };
+    for (int i = 0; i < 600; i++) {
+      MockResponse response = new MockResponse().setResponseCode(i);
+      String expectedReason = reasons[i / 100];
+      assertEquals("HTTP/1.1 " + i + " " + expectedReason, response.getStatus());
+      assertEquals(Arrays.asList("Content-Length: 0"), headersToList(response));
+    }
+  }
+
+  @Test public void setStatusControlsWholeStatusLine() {
+    MockResponse response = new MockResponse().setStatus("HTTP/1.1 202 That'll do pig");
+    assertEquals(Arrays.asList("Content-Length: 0"), headersToList(response));
+    assertEquals("HTTP/1.1 202 That'll do pig", response.getStatus());
+  }
+
+  @Test public void setBodyAdjustsHeaders() throws IOException {
+    MockResponse response = new MockResponse().setBody("ABC");
+    assertEquals(Arrays.asList("Content-Length: 3"), headersToList(response));
+    assertEquals("ABC", response.getBody().readUtf8());
+  }
+
+  @Test public void mockResponseAddHeader() {
+    MockResponse response = new MockResponse()
+        .clearHeaders()
+        .addHeader("Cookie: s=square")
+        .addHeader("Cookie", "a=android");
+    assertEquals(Arrays.asList("Cookie: s=square", "Cookie: a=android"), headersToList(response));
+  }
+
+  @Test public void mockResponseSetHeader() {
+    MockResponse response = new MockResponse()
+        .clearHeaders()
+        .addHeader("Cookie: s=square")
+        .addHeader("Cookie: a=android")
+        .addHeader("Cookies: delicious");
+    response.setHeader("cookie", "r=robot");
+    assertEquals(Arrays.asList("Cookies: delicious", "cookie: r=robot"), headersToList(response));
+  }
+
+  @Test public void mockResponseSetHeaders() {
+    MockResponse response = new MockResponse()
+        .clearHeaders()
+        .addHeader("Cookie: s=square")
+        .addHeader("Cookies: delicious");
+
+    response.setHeaders(new Headers.Builder().add("Cookie", "a=android").build());
+
+    assertEquals(Arrays.asList("Cookie: a=android"), headersToList(response));
+  }
+
+  @Test public void regularResponse() throws Exception {
+    server.enqueue(new MockResponse().setBody("hello world"));
+
+    URL url = server.url("/").url();
+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+    connection.setRequestProperty("Accept-Language", "en-US");
+    InputStream in = connection.getInputStream();
+    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
+    assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());
+    assertEquals("hello world", reader.readLine());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("GET / HTTP/1.1", request.getRequestLine());
+    assertEquals("en-US", request.getHeader("Accept-Language"));
+  }
+
+  @Test public void redirect() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: " + server.url("/new-path"))
+        .setBody("This page has moved!"));
+    server.enqueue(new MockResponse().setBody("This is the new location!"));
+
+    URLConnection connection = server.url("/").url().openConnection();
+    InputStream in = connection.getInputStream();
+    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
+    assertEquals("This is the new location!", reader.readLine());
+
+    RecordedRequest first = server.takeRequest();
+    assertEquals("GET / HTTP/1.1", first.getRequestLine());
+    RecordedRequest redirect = server.takeRequest();
+    assertEquals("GET /new-path HTTP/1.1", redirect.getRequestLine());
+  }
+
+  /**
+   * Test that MockWebServer blocks for a call to enqueue() if a request is made before a mock
+   * response is ready.
+   */
+  @Test public void dispatchBlocksWaitingForEnqueue() throws Exception {
+    new Thread() {
+      @Override public void run() {
+        try {
+          Thread.sleep(1000);
+        } catch (InterruptedException ignored) {
+        }
+        server.enqueue(new MockResponse().setBody("enqueued in the background"));
+      }
+    }.start();
+
+    URLConnection connection = server.url("/").url().openConnection();
+    InputStream in = connection.getInputStream();
+    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
+    assertEquals("enqueued in the background", reader.readLine());
+  }
+
+  @Test public void nonHexadecimalChunkSize() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("G\r\nxxxxxxxxxxxxxxxx\r\n0\r\n\r\n")
+        .clearHeaders()
+        .addHeader("Transfer-encoding: chunked"));
+
+    URLConnection connection = server.url("/").url().openConnection();
+    InputStream in = connection.getInputStream();
+    try {
+      in.read();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void responseTimeout() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("ABC")
+        .clearHeaders()
+        .addHeader("Content-Length: 4"));
+    server.enqueue(new MockResponse().setBody("DEF"));
+
+    URLConnection urlConnection = server.url("/").url().openConnection();
+    urlConnection.setReadTimeout(1000);
+    InputStream in = urlConnection.getInputStream();
+    assertEquals('A', in.read());
+    assertEquals('B', in.read());
+    assertEquals('C', in.read());
+    try {
+      in.read(); // if Content-Length was accurate, this would return -1 immediately
+      fail();
+    } catch (SocketTimeoutException expected) {
+    }
+
+    URLConnection urlConnection2 = server.url("/").url().openConnection();
+    InputStream in2 = urlConnection2.getInputStream();
+    assertEquals('D', in2.read());
+    assertEquals('E', in2.read());
+    assertEquals('F', in2.read());
+    assertEquals(-1, in2.read());
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void disconnectAtStart() throws Exception {
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
+    server.enqueue(new MockResponse()); // The jdk's HttpUrlConnection is a bastard.
+    server.enqueue(new MockResponse());
+    try {
+      server.url("/a").url().openConnection().getInputStream();
+    } catch (IOException expected) {
+    }
+    server.url("/b").url().openConnection().getInputStream(); // Should succeed.
+  }
+
+  /**
+   * Throttle the request body by sleeping 500ms after every 3 bytes. With a 6-byte request, this
+   * should yield one sleep for a total delay of 500ms.
+   */
+  @Test public void throttleRequest() throws Exception {
+    server.enqueue(new MockResponse()
+        .throttleBody(3, 500, TimeUnit.MILLISECONDS));
+
+    long startNanos = System.nanoTime();
+    URLConnection connection = server.url("/").url().openConnection();
+    connection.setDoOutput(true);
+    connection.getOutputStream().write("ABCDEF".getBytes("UTF-8"));
+    InputStream in = connection.getInputStream();
+    assertEquals(-1, in.read());
+    long elapsedNanos = System.nanoTime() - startNanos;
+    long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
+
+    assertTrue(Util.format("Request + Response: %sms", elapsedMillis), elapsedMillis >= 500);
+    assertTrue(Util.format("Request + Response: %sms", elapsedMillis), elapsedMillis < 1000);
+  }
+
+  /**
+   * Throttle the response body by sleeping 500ms after every 3 bytes. With a 6-byte response, this
+   * should yield one sleep for a total delay of 500ms.
+   */
+  @Test public void throttleResponse() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("ABCDEF")
+        .throttleBody(3, 500, TimeUnit.MILLISECONDS));
+
+    long startNanos = System.nanoTime();
+    URLConnection connection = server.url("/").url().openConnection();
+    InputStream in = connection.getInputStream();
+    assertEquals('A', in.read());
+    assertEquals('B', in.read());
+    assertEquals('C', in.read());
+    assertEquals('D', in.read());
+    assertEquals('E', in.read());
+    assertEquals('F', in.read());
+    assertEquals(-1, in.read());
+    long elapsedNanos = System.nanoTime() - startNanos;
+    long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
+
+    assertTrue(Util.format("Request + Response: %sms", elapsedMillis), elapsedMillis >= 500);
+    assertTrue(Util.format("Request + Response: %sms", elapsedMillis), elapsedMillis < 1000);
+  }
+
+  /** Delay the response body by sleeping 1s. */
+  @Test public void delayResponse() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("ABCDEF")
+        .setBodyDelay(1, SECONDS));
+
+    long startNanos = System.nanoTime();
+    URLConnection connection = server.url("/").url().openConnection();
+    InputStream in = connection.getInputStream();
+    assertEquals('A', in.read());
+    long elapsedNanos = System.nanoTime() - startNanos;
+    long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
+    assertTrue(Util.format("Request + Response: %sms", elapsedMillis), elapsedMillis >= 1000);
+
+    in.close();
+  }
+
+  @Test public void disconnectRequestHalfway() throws IOException {
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_DURING_REQUEST_BODY));
+    // Limit the size of the request body that the server holds in memory to an arbitrary
+    // 3.5 MBytes so this test can pass on devices with little memory.
+    server.setBodyLimit(7 * 512 * 1024);
+
+    HttpURLConnection connection = (HttpURLConnection) server.url("/").url().openConnection();
+    connection.setRequestMethod("POST");
+    connection.setDoOutput(true);
+    connection.setFixedLengthStreamingMode(1024 * 1024 * 1024); // 1 GB
+    connection.connect();
+    OutputStream out = connection.getOutputStream();
+
+    byte[] data = new byte[1024 * 1024];
+    int i;
+    for (i = 0; i < 1024; i++) {
+      try {
+        out.write(data);
+        out.flush();
+      } catch (IOException e) {
+        break;
+      }
+    }
+    assertEquals(512f, i, 10f); // Halfway +/- 1%
+  }
+
+  @Test public void disconnectResponseHalfway() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("ab")
+        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY));
+
+    URLConnection connection = server.url("/").url().openConnection();
+    assertEquals(2, connection.getContentLength());
+    InputStream in = connection.getInputStream();
+    assertEquals('a', in.read());
+    try {
+      int byteRead = in.read();
+      // OpenJDK behavior: end of stream.
+      assertEquals(-1, byteRead);
+    } catch (ProtocolException e) {
+      // On Android, HttpURLConnection is implemented by OkHttp v2. OkHttp
+      // treats an incomplete response body as a ProtocolException.
+    }
+  }
+
+  private List<String> headersToList(MockResponse response) {
+    Headers headers = response.getHeaders();
+    int size = headers.size();
+    List<String> headerList = new ArrayList<>(size);
+    for (int i = 0; i < size; i++) {
+      headerList.add(headers.name(i) + ": " + headers.value(i));
+    }
+    return headerList;
+  }
+
+  @Test public void shutdownWithoutStart() throws IOException {
+    MockWebServer server = new MockWebServer();
+    server.shutdown();
+  }
+
+  @Test public void closeViaClosable() throws IOException {
+    Closeable server = new MockWebServer();
+    server.close();
+  }
+
+  @Test public void shutdownWithoutEnqueue() throws IOException {
+    MockWebServer server = new MockWebServer();
+    server.start();
+    server.shutdown();
+  }
+
+  @After public void tearDown() throws IOException {
+    server.shutdown();
+  }
+
+  @Test public void portImplicitlyStarts() throws IOException {
+    assertTrue(server.getPort() > 0);
+  }
+
+  @Test public void hostnameImplicitlyStarts() throws IOException {
+    assertNotNull(server.getHostName());
+  }
+
+  @Test public void toProxyAddressImplicitlyStarts() throws IOException {
+    assertNotNull(server.toProxyAddress());
+  }
+
+  @Test public void differentInstancesGetDifferentPorts() throws IOException {
+    MockWebServer other = new MockWebServer();
+    assertNotEquals(server.getPort(), other.getPort());
+    other.shutdown();
+  }
+
+  @Test public void statementStartsAndStops() throws Throwable {
+    final AtomicBoolean called = new AtomicBoolean();
+    Statement statement = server.apply(new Statement() {
+      @Override public void evaluate() throws Throwable {
+        called.set(true);
+        server.url("/").url().openConnection().connect();
+      }
+    }, Description.EMPTY);
+
+    statement.evaluate();
+
+    assertTrue(called.get());
+    try {
+      server.url("/").url().openConnection().connect();
+      fail();
+    } catch (ConnectException expected) {
+    }
+  }
+
+  @Test public void shutdownWhileBlockedDispatching() throws Exception {
+    // Enqueue a request that'll cause MockWebServer to hang on QueueDispatcher.dispatch().
+    HttpURLConnection connection = (HttpURLConnection) server.url("/").url().openConnection();
+    connection.setReadTimeout(500);
+    try {
+      connection.getResponseCode();
+      fail();
+    } catch (SocketTimeoutException expected) {
+    }
+
+    // Shutting down the server should unblock the dispatcher.
+    server.shutdown();
+  }
+
+  @Test public void requestUrlReconstructed() throws Exception {
+    server.enqueue(new MockResponse().setBody("hello world"));
+
+    URL url = server.url("/a/deep/path?key=foo%20bar").url();
+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+    InputStream in = connection.getInputStream();
+    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
+    assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());
+    assertEquals("hello world", reader.readLine());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("GET /a/deep/path?key=foo%20bar HTTP/1.1", request.getRequestLine());
+
+    HttpUrl requestUrl = request.getRequestUrl();
+    assertEquals("http", requestUrl.scheme());
+    assertEquals(server.getHostName(), requestUrl.host());
+    assertEquals(server.getPort(), requestUrl.port());
+    assertEquals("/a/deep/path", requestUrl.encodedPath());
+    assertEquals("foo bar", requestUrl.queryParameter("key"));
+  }
+
+  @Test public void http100Continue() throws Exception {
+    server.enqueue(new MockResponse().setBody("response"));
+
+    URL url = server.url("/").url();
+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+    connection.setDoOutput(true);
+    connection.setRequestProperty("Expect", "100-Continue");
+    connection.getOutputStream().write("request".getBytes(StandardCharsets.UTF_8));
+
+    InputStream in = connection.getInputStream();
+    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
+    assertEquals("response", reader.readLine());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("request", request.getBody().readUtf8());
+  }
+}
diff --git a/okcurl/README.md b/okcurl/README.md
new file mode 100644
index 0000000000..4c65202b11
--- /dev/null
+++ b/okcurl/README.md
@@ -0,0 +1,7 @@
+OkCurl
+======
+
+_A curl for the next-generation web._
+
+OkCurl is an OkHttp-backed curl clone which allows you to test OkHttp's HTTP engine (including
+HTTP/2) against web servers.
diff --git a/okcurl/pom.xml b/okcurl/pom.xml
new file mode 100644
index 0000000000..c444a23b4d
--- /dev/null
+++ b/okcurl/pom.xml
@@ -0,0 +1,96 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp3</groupId>
+    <artifactId>parent</artifactId>
+    <version>3.10.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>okcurl</artifactId>
+  <name>OkCurl</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.bouncycastle</groupId>
+      <artifactId>bcprov-jdk15on</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>io.airlift</groupId>
+      <artifactId>airline</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <resources>
+      <resource>
+        <directory>src/main/resources</directory>
+        <filtering>true</filtering>
+      </resource>
+    </resources>
+
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-assembly-plugin</artifactId>
+        <configuration>
+          <descriptorRefs>
+            <descriptorRef>jar-with-dependencies</descriptorRef>
+          </descriptorRefs>
+          <archive>
+            <manifest>
+              <mainClass>okhttp3.curl.Main</mainClass>
+            </manifest>
+          </archive>
+        </configuration>
+        <executions>
+          <execution>
+            <phase>package</phase>
+            <goals>
+              <goal>single</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
+      <plugin>
+        <groupId>org.skife.maven</groupId>
+        <artifactId>really-executable-jar-maven-plugin</artifactId>
+        <version>1.1.0</version>
+        <executions>
+          <execution>
+            <phase>package</phase>
+            <goals>
+              <goal>really-executable-jar</goal>
+            </goals>
+          </execution>
+        </executions>
+        <configuration>
+          <flags>-Xbootclasspath/p:$0</flags>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/okcurl/src/main/java/okhttp3/curl/Main.java b/okcurl/src/main/java/okhttp3/curl/Main.java
new file mode 100644
index 0000000000..ddff8e6790
--- /dev/null
+++ b/okcurl/src/main/java/okhttp3/curl/Main.java
@@ -0,0 +1,288 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.curl;
+
+import com.google.common.base.Joiner;
+import io.airlift.airline.Arguments;
+import io.airlift.airline.Command;
+import io.airlift.airline.HelpOption;
+import io.airlift.airline.Option;
+import io.airlift.airline.SingleCommand;
+import java.io.IOException;
+import java.io.InputStream;
+import java.security.cert.X509Certificate;
+import java.util.List;
+import java.util.Properties;
+import java.util.logging.ConsoleHandler;
+import java.util.logging.Level;
+import java.util.logging.LogRecord;
+import java.util.logging.Logger;
+import java.util.logging.SimpleFormatter;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSession;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.Headers;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.StatusLine;
+import okhttp3.internal.http2.Http2;
+import okio.BufferedSource;
+import okio.Okio;
+import okio.Sink;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+@Command(name = Main.NAME, description = "A curl for the next-generation web.")
+public class Main extends HelpOption implements Runnable {
+  static final String NAME = "okcurl";
+  static final int DEFAULT_TIMEOUT = -1;
+  private static Logger frameLogger;
+
+  static Main fromArgs(String... args) {
+    return SingleCommand.singleCommand(Main.class).parse(args);
+  }
+
+  public static void main(String... args) {
+    fromArgs(args).run();
+  }
+
+  private static String versionString() {
+    try {
+      Properties prop = new Properties();
+      InputStream in = Main.class.getResourceAsStream("/okcurl-version.properties");
+      prop.load(in);
+      in.close();
+      return prop.getProperty("version");
+    } catch (IOException e) {
+      throw new AssertionError("Could not load okcurl-version.properties.");
+    }
+  }
+
+  private static String protocols() {
+    return Joiner.on(", ").join(Protocol.values());
+  }
+
+  @Option(name = {"-X", "--request"}, description = "Specify request command to use")
+  public String method;
+
+  @Option(name = {"-d", "--data"}, description = "HTTP POST data")
+  public String data;
+
+  @Option(name = {"-H", "--header"}, description = "Custom header to pass to server")
+  public List<String> headers;
+
+  @Option(name = {"-A", "--user-agent"}, description = "User-Agent to send to server")
+  public String userAgent = NAME + "/" + versionString();
+
+  @Option(name = "--connect-timeout", description = "Maximum time allowed for connection (seconds)")
+  public int connectTimeout = DEFAULT_TIMEOUT;
+
+  @Option(name = "--read-timeout", description = "Maximum time allowed for reading data (seconds)")
+  public int readTimeout = DEFAULT_TIMEOUT;
+
+  @Option(name = {"-L", "--location"}, description = "Follow redirects")
+  public boolean followRedirects;
+
+  @Option(name = {"-k", "--insecure"},
+      description = "Allow connections to SSL sites without certs")
+  public boolean allowInsecure;
+
+  @Option(name = {"-i", "--include"}, description = "Include protocol headers in the output")
+  public boolean showHeaders;
+
+  @Option(name = "--frames", description = "Log HTTP/2 frames to STDERR")
+  public boolean showHttp2Frames;
+
+  @Option(name = {"-e", "--referer"}, description = "Referer URL")
+  public String referer;
+
+  @Option(name = {"-V", "--version"}, description = "Show version number and quit")
+  public boolean version;
+
+  @Arguments(title = "url", description = "Remote resource URL")
+  public String url;
+
+  private OkHttpClient client;
+
+  @Override public void run() {
+    if (showHelpIfRequested()) {
+      return;
+    }
+    if (version) {
+      System.out.println(NAME + " " + versionString());
+      System.out.println("Protocols: " + protocols());
+      return;
+    }
+
+    if (showHttp2Frames) {
+      enableHttp2FrameLogging();
+    }
+
+    client = createClient();
+    Request request = createRequest();
+    try {
+      Response response = client.newCall(request).execute();
+      if (showHeaders) {
+        System.out.println(StatusLine.get(response));
+        Headers headers = response.headers();
+        for (int i = 0, size = headers.size(); i < size; i++) {
+          System.out.println(headers.name(i) + ": " + headers.value(i));
+        }
+        System.out.println();
+      }
+
+      // Stream the response to the System.out as it is returned from the server.
+      Sink out = Okio.sink(System.out);
+      BufferedSource source = response.body().source();
+      while (!source.exhausted()) {
+        out.write(source.buffer(), source.buffer().size());
+        out.flush();
+      }
+
+      response.body().close();
+    } catch (IOException e) {
+      e.printStackTrace();
+    } finally {
+      close();
+    }
+  }
+
+  private OkHttpClient createClient() {
+    OkHttpClient.Builder builder = new OkHttpClient.Builder();
+    builder.followSslRedirects(followRedirects);
+    if (connectTimeout != DEFAULT_TIMEOUT) {
+      builder.connectTimeout(connectTimeout, SECONDS);
+    }
+    if (readTimeout != DEFAULT_TIMEOUT) {
+      builder.readTimeout(readTimeout, SECONDS);
+    }
+    if (allowInsecure) {
+      X509TrustManager trustManager = createInsecureTrustManager();
+      SSLSocketFactory sslSocketFactory = createInsecureSslSocketFactory(trustManager);
+      builder.sslSocketFactory(sslSocketFactory, trustManager);
+      builder.hostnameVerifier(createInsecureHostnameVerifier());
+    }
+    return builder.build();
+  }
+
+  private String getRequestMethod() {
+    if (method != null) {
+      return method;
+    }
+    if (data != null) {
+      return "POST";
+    }
+    return "GET";
+  }
+
+  private RequestBody getRequestBody() {
+    if (data == null) {
+      return null;
+    }
+    String bodyData = data;
+
+    String mimeType = "application/x-www-form-urlencoded";
+    if (headers != null) {
+      for (String header : headers) {
+        String[] parts = header.split(":", -1);
+        if ("Content-Type".equalsIgnoreCase(parts[0])) {
+          mimeType = parts[1].trim();
+          headers.remove(header);
+          break;
+        }
+      }
+    }
+
+    return RequestBody.create(MediaType.parse(mimeType), bodyData);
+  }
+
+  Request createRequest() {
+    Request.Builder request = new Request.Builder();
+
+    request.url(url);
+    request.method(getRequestMethod(), getRequestBody());
+
+    if (headers != null) {
+      for (String header : headers) {
+        String[] parts = header.split(":", 2);
+        request.header(parts[0], parts[1]);
+      }
+    }
+    if (referer != null) {
+      request.header("Referer", referer);
+    }
+    request.header("User-Agent", userAgent);
+
+    return request.build();
+  }
+
+  private void close() {
+    client.connectionPool().evictAll(); // Close any persistent connections.
+  }
+
+  private static X509TrustManager createInsecureTrustManager() {
+    return new X509TrustManager() {
+      @Override public void checkClientTrusted(X509Certificate[] chain, String authType) {
+      }
+
+      @Override public void checkServerTrusted(X509Certificate[] chain, String authType) {
+      }
+
+      @Override public X509Certificate[] getAcceptedIssuers() {
+        return new X509Certificate[0];
+      }
+    };
+  }
+
+  private static SSLSocketFactory createInsecureSslSocketFactory(TrustManager trustManager) {
+    try {
+      SSLContext context = SSLContext.getInstance("TLS");
+      context.init(null, new TrustManager[] {trustManager}, null);
+      return context.getSocketFactory();
+    } catch (Exception e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  private static HostnameVerifier createInsecureHostnameVerifier() {
+    return new HostnameVerifier() {
+      @Override public boolean verify(String s, SSLSession sslSession) {
+        return true;
+      }
+    };
+  }
+
+  private static void enableHttp2FrameLogging() {
+    frameLogger = Logger.getLogger(Http2.class.getName());
+    frameLogger.setLevel(Level.FINE);
+    ConsoleHandler handler = new ConsoleHandler();
+    handler.setLevel(Level.FINE);
+    handler.setFormatter(new SimpleFormatter() {
+      @Override public String format(LogRecord record) {
+        return Util.format("%s%n", record.getMessage());
+      }
+    });
+    frameLogger.addHandler(handler);
+  }
+}
diff --git a/okcurl/src/main/resources/okcurl-version.properties b/okcurl/src/main/resources/okcurl-version.properties
new file mode 100644
index 0000000000..defbd48204
--- /dev/null
+++ b/okcurl/src/main/resources/okcurl-version.properties
@@ -0,0 +1 @@
+version=${project.version}
diff --git a/okcurl/src/test/java/okhttp3/curl/MainTest.java b/okcurl/src/test/java/okhttp3/curl/MainTest.java
new file mode 100644
index 0000000000..12fe6d5ec4
--- /dev/null
+++ b/okcurl/src/test/java/okhttp3/curl/MainTest.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.curl;
+
+import java.io.IOException;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okio.Buffer;
+import org.junit.Test;
+
+import static okhttp3.curl.Main.fromArgs;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+
+public class MainTest {
+  @Test public void simple() {
+    Request request = fromArgs("http://example.com").createRequest();
+    assertEquals("GET", request.method());
+    assertEquals("http://example.com/", request.url().toString());
+    assertNull(request.body());
+  }
+
+  @Test public void put() throws IOException {
+    Request request = fromArgs("-X", "PUT", "-d", "foo", "http://example.com").createRequest();
+    assertEquals("PUT", request.method());
+    assertEquals("http://example.com/", request.url().toString());
+    assertEquals(3, request.body().contentLength());
+  }
+
+  @Test public void dataPost() {
+    Request request = fromArgs("-d", "foo", "http://example.com").createRequest();
+    RequestBody body = request.body();
+    assertEquals("POST", request.method());
+    assertEquals("http://example.com/", request.url().toString());
+    assertEquals("application/x-www-form-urlencoded; charset=utf-8", body.contentType().toString());
+    assertEquals("foo", bodyAsString(body));
+  }
+
+  @Test public void dataPut() {
+    Request request = fromArgs("-d", "foo", "-X", "PUT", "http://example.com").createRequest();
+    RequestBody body = request.body();
+    assertEquals("PUT", request.method());
+    assertEquals("http://example.com/", request.url().toString());
+    assertEquals("application/x-www-form-urlencoded; charset=utf-8", body.contentType().toString());
+    assertEquals("foo", bodyAsString(body));
+  }
+
+  @Test public void contentTypeHeader() {
+    Request request = fromArgs("-d", "foo", "-H", "Content-Type: application/json",
+        "http://example.com").createRequest();
+    RequestBody body = request.body();
+    assertEquals("POST", request.method());
+    assertEquals("http://example.com/", request.url().toString());
+    assertEquals("application/json; charset=utf-8", body.contentType().toString());
+    assertEquals("foo", bodyAsString(body));
+  }
+
+  @Test public void referer() {
+    Request request = fromArgs("-e", "foo", "http://example.com").createRequest();
+    assertEquals("GET", request.method());
+    assertEquals("http://example.com/", request.url().toString());
+    assertEquals("foo", request.header("Referer"));
+    assertNull(request.body());
+  }
+
+  @Test public void userAgent() {
+    Request request = fromArgs("-A", "foo", "http://example.com").createRequest();
+    assertEquals("GET", request.method());
+    assertEquals("http://example.com/", request.url().toString());
+    assertEquals("foo", request.header("User-Agent"));
+    assertNull(request.body());
+  }
+
+  @Test public void headerSplitWithDate() {
+    Request request = fromArgs("-H", "If-Modified-Since: Mon, 18 Aug 2014 15:16:06 GMT",
+        "http://example.com").createRequest();
+    assertEquals("Mon, 18 Aug 2014 15:16:06 GMT", request.header("If-Modified-Since"));
+  }
+
+  private static String bodyAsString(RequestBody body) {
+    try {
+      Buffer buffer = new Buffer();
+      body.writeTo(buffer);
+      return buffer.readString(body.contentType().charset());
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    }
+  }
+}
diff --git a/okhttp-android-support/pom.xml b/okhttp-android-support/pom.xml
new file mode 100644
index 0000000000..e2ff34c2e4
--- /dev/null
+++ b/okhttp-android-support/pom.xml
@@ -0,0 +1,63 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp3</groupId>
+    <artifactId>parent</artifactId>
+    <version>3.10.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>okhttp-android-support</artifactId>
+  <name>OkHttp Android Platform Support</name>
+  <description>Classes to support the Android platform's use of OkHttp (not required for most
+    developers).
+  </description>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-urlconnection</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-javadoc-plugin</artifactId>
+        <configuration>
+          <excludePackageNames>okhttp3.internal.*</excludePackageNames>
+          <links>
+            <link>http://square.github.io/okhttp/javadoc/</link>
+          </links>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/okhttp-android-support/src/main/java/okhttp3/AndroidInternal.java b/okhttp-android-support/src/main/java/okhttp3/AndroidInternal.java
new file mode 100644
index 0000000000..de5788539a
--- /dev/null
+++ b/okhttp-android-support/src/main/java/okhttp3/AndroidInternal.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.net.ResponseCache;
+import okhttp3.internal.huc.CacheAdapter;
+
+/**
+ * Back doors to enable the use of OkHttp within the Android platform libraries. OkHttp is used to
+ * provide the default {@link java.net.HttpURLConnection} / {@link javax.net.ssl.HttpsURLConnection}
+ * implementation including support for a custom {@link ResponseCache}.
+ */
+public class AndroidInternal {
+
+  private AndroidInternal() {
+  }
+
+  /** Sets the response cache to be used to read and write cached responses. */
+  public static void setResponseCache(OkUrlFactory okUrlFactory, ResponseCache responseCache) {
+    OkHttpClient.Builder builder = okUrlFactory.client().newBuilder();
+    if (responseCache instanceof OkCacheContainer) {
+      // Avoid adding layers of wrappers. Rather than wrap the ResponseCache in yet another layer to
+      // make the ResponseCache look like an InternalCache, we can unwrap the Cache instead.
+      // This means that Cache stats will be correctly updated.
+      OkCacheContainer okCacheContainer = (OkCacheContainer) responseCache;
+      builder.cache(okCacheContainer.getCache());
+    } else {
+      builder.setInternalCache(responseCache != null ? new CacheAdapter(responseCache) : null);
+    }
+    okUrlFactory.setClient(builder.build());
+  }
+}
diff --git a/okhttp-android-support/src/main/java/okhttp3/AndroidShimResponseCache.java b/okhttp-android-support/src/main/java/okhttp3/AndroidShimResponseCache.java
new file mode 100644
index 0000000000..c46a0cb9fd
--- /dev/null
+++ b/okhttp-android-support/src/main/java/okhttp3/AndroidShimResponseCache.java
@@ -0,0 +1,142 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.CacheRequest;
+import java.net.CacheResponse;
+import java.net.ResponseCache;
+import java.net.URI;
+import java.net.URLConnection;
+import java.util.List;
+import java.util.Map;
+import okhttp3.internal.huc.JavaApiConverter;
+
+/**
+ * A class provided for use by Android so that it can continue supporting a {@link ResponseCache}
+ * with stats.
+ */
+public class AndroidShimResponseCache extends ResponseCache {
+
+  private final Cache delegate;
+
+  private AndroidShimResponseCache(Cache delegate) {
+    this.delegate = delegate;
+  }
+
+  public static AndroidShimResponseCache create(File directory, long maxSize) throws IOException {
+    Cache cache = new Cache(directory, maxSize);
+    return new AndroidShimResponseCache(cache);
+  }
+
+  public boolean isEquivalent(File directory, long maxSize) {
+    Cache installedCache = getCache();
+    return (installedCache.directory().equals(directory)
+        && installedCache.maxSize() == maxSize
+        && !installedCache.isClosed());
+  }
+
+  public Cache getCache() {
+    return delegate;
+  }
+
+  @Override public CacheResponse get(URI uri, String requestMethod,
+      Map<String, List<String>> requestHeaders) throws IOException {
+    Request okRequest = JavaApiConverter.createOkRequest(uri, requestMethod, requestHeaders);
+    Response okResponse = delegate.internalCache.get(okRequest);
+    if (okResponse == null) {
+      return null;
+    }
+    return JavaApiConverter.createJavaCacheResponse(okResponse);
+  }
+
+  @Override public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
+    Response okResponse = JavaApiConverter.createOkResponseForCachePut(uri, urlConnection);
+    if (okResponse == null) {
+      // The URLConnection is not cacheable or could not be converted. Stop.
+      return null;
+    }
+    okhttp3.internal.cache.CacheRequest okCacheRequest =
+        delegate.internalCache.put(okResponse);
+    if (okCacheRequest == null) {
+      return null;
+    }
+    return JavaApiConverter.createJavaCacheRequest(okCacheRequest);
+  }
+
+  /**
+   * Returns the number of bytes currently being used to store the values in this cache. This may be
+   * greater than the {@link #maxSize} if a background deletion is pending.
+   */
+  public long size() throws IOException {
+    return delegate.size();
+  }
+
+  /**
+   * Returns the maximum number of bytes that this cache should use to store its data.
+   */
+  public long maxSize() {
+    return delegate.maxSize();
+  }
+
+  /**
+   * Force buffered operations to the filesystem. This ensures that responses written to the cache
+   * will be available the next time the cache is opened, even if this process is killed.
+   */
+  public void flush() throws IOException {
+    delegate.flush();
+  }
+
+  /**
+   * Returns the number of HTTP requests that required the network to either supply a response or
+   * validate a locally cached response.
+   */
+  public int getNetworkCount() {
+    return delegate.networkCount();
+  }
+
+  /**
+   * Returns the number of HTTP requests whose response was provided by the cache. This may include
+   * conditional {@code GET} requests that were validated over the network.
+   */
+  public int getHitCount() {
+    return delegate.hitCount();
+  }
+
+  /**
+   * Returns the total number of HTTP requests that were made. This includes both client requests
+   * and requests that were made on the client's behalf to handle a redirects and retries.
+   */
+  public int getRequestCount() {
+    return delegate.requestCount();
+  }
+
+  /**
+   * Uninstalls the cache and releases any active resources. Stored contents will remain on the
+   * filesystem.
+   */
+  public void close() throws IOException {
+    delegate.close();
+  }
+
+  /**
+   * Uninstalls the cache and deletes all of its stored contents.
+   */
+  public void delete() throws IOException {
+    delegate.delete();
+  }
+}
diff --git a/okhttp-android-support/src/main/java/okhttp3/OkCacheContainer.java b/okhttp-android-support/src/main/java/okhttp3/OkCacheContainer.java
new file mode 100644
index 0000000000..d52cb0133d
--- /dev/null
+++ b/okhttp-android-support/src/main/java/okhttp3/OkCacheContainer.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+/**
+ * An interface that allows OkHttp to detect that a {@link java.net.ResponseCache} contains a {@link
+ * Cache}.
+ */
+public interface OkCacheContainer {
+  Cache getCache();
+}
diff --git a/okhttp-android-support/src/main/java/okhttp3/internal/huc/CacheAdapter.java b/okhttp-android-support/src/main/java/okhttp3/internal/huc/CacheAdapter.java
new file mode 100644
index 0000000000..5bca95b937
--- /dev/null
+++ b/okhttp-android-support/src/main/java/okhttp3/internal/huc/CacheAdapter.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.huc;
+
+import java.io.IOException;
+import java.io.OutputStream;
+import java.net.CacheResponse;
+import java.net.HttpURLConnection;
+import java.net.ResponseCache;
+import java.net.URI;
+import java.util.List;
+import java.util.Map;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.cache.CacheRequest;
+import okhttp3.internal.cache.CacheStrategy;
+import okhttp3.internal.cache.InternalCache;
+import okio.Okio;
+import okio.Sink;
+
+/** Adapts {@link ResponseCache} to {@link InternalCache}. */
+public final class CacheAdapter implements InternalCache {
+  private final ResponseCache delegate;
+
+  public CacheAdapter(ResponseCache delegate) {
+    this.delegate = delegate;
+  }
+
+  public ResponseCache getDelegate() {
+    return delegate;
+  }
+
+  @Override public Response get(Request request) throws IOException {
+    CacheResponse javaResponse = getJavaCachedResponse(request);
+    if (javaResponse == null) {
+      return null;
+    }
+    return JavaApiConverter.createOkResponseForCacheGet(request, javaResponse);
+  }
+
+  @Override public CacheRequest put(Response response) throws IOException {
+    URI uri = response.request().url().uri();
+    HttpURLConnection connection = JavaApiConverter.createJavaUrlConnectionForCachePut(response);
+    final java.net.CacheRequest request = delegate.put(uri, connection);
+    if (request == null) {
+      return null;
+    }
+    return new CacheRequest() {
+      @Override public Sink body() throws IOException {
+        OutputStream body = request.getBody();
+        return body != null ? Okio.sink(body) : null;
+      }
+
+      @Override public void abort() {
+        request.abort();
+      }
+    };
+  }
+
+  @Override public void remove(Request request) throws IOException {
+    // This method is treated as optional and there is no obvious way of implementing it with
+    // ResponseCache. Removing items from the cache due to modifications made from this client is
+    // not essential given that modifications could be made from any other client. We have to assume
+    // that it's ok to keep using the cached data. Otherwise the server shouldn't declare it as
+    // cacheable or the client should be careful about caching it.
+  }
+
+  @Override public void update(Response cached, Response network) {
+    // This method is treated as optional and there is no obvious way of implementing it with
+    // ResponseCache. Updating headers is useful if the server changes the metadata for a resource
+    // (e.g. max age) to extend or truncate the life of that resource in the cache. If the metadata
+    // is not updated the caching behavior may not be optimal, but will obey the metadata sent
+    // with the original cached response.
+  }
+
+  @Override public void trackConditionalCacheHit() {
+    // This method is optional.
+  }
+
+  @Override public void trackResponse(CacheStrategy cacheStrategy) {
+    // This method is optional.
+  }
+
+  /**
+   * Returns the {@link CacheResponse} from the delegate by converting the OkHttp {@link Request}
+   * into the arguments required by the {@link ResponseCache}.
+   */
+  private CacheResponse getJavaCachedResponse(Request request) throws IOException {
+    Map<String, List<String>> headers = JavaApiConverter.extractJavaHeaders(request);
+    return delegate.get(request.url().uri(), request.method(), headers);
+  }
+}
diff --git a/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java b/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java
new file mode 100644
index 0000000000..1dec85cdc0
--- /dev/null
+++ b/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java
@@ -0,0 +1,892 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.huc;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.CacheResponse;
+import java.net.HttpURLConnection;
+import java.net.ProtocolException;
+import java.net.SecureCacheResponse;
+import java.net.URI;
+import java.net.URLConnection;
+import java.security.Principal;
+import java.security.cert.Certificate;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSocketFactory;
+import okhttp3.CipherSuite;
+import okhttp3.Handshake;
+import okhttp3.Headers;
+import okhttp3.MediaType;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.TlsVersion;
+import okhttp3.internal.Internal;
+import okhttp3.internal.JavaNetHeaders;
+import okhttp3.internal.Util;
+import okhttp3.internal.cache.CacheRequest;
+import okhttp3.internal.http.HttpHeaders;
+import okhttp3.internal.http.HttpMethod;
+import okhttp3.internal.http.StatusLine;
+import okhttp3.internal.platform.Platform;
+import okio.BufferedSource;
+import okio.Okio;
+import okio.Sink;
+
+/**
+ * Helper methods that convert between Java and OkHttp representations.
+ */
+public final class JavaApiConverter {
+  /** Synthetic response header: the local time when the request was sent. */
+  private static final String SENT_MILLIS = Platform.get().getPrefix() + "-Sent-Millis";
+
+  /** Synthetic response header: the local time when the response was received. */
+  private static final String RECEIVED_MILLIS = Platform.get().getPrefix() + "-Received-Millis";
+
+  private JavaApiConverter() {
+  }
+
+  /**
+   * Creates an OkHttp {@link Response} using the supplied {@link URI} and {@link URLConnection} to
+   * supply the data. The URLConnection is assumed to already be connected. If this method returns
+   * {@code null} the response is uncacheable.
+   */
+  public static Response createOkResponseForCachePut(URI uri, URLConnection urlConnection)
+      throws IOException {
+
+    HttpURLConnection httpUrlConnection = (HttpURLConnection) urlConnection;
+
+    Response.Builder okResponseBuilder = new Response.Builder();
+
+    // Request: Create one from the URL connection.
+    Headers responseHeaders = createHeaders(urlConnection.getHeaderFields());
+    // Some request headers are needed for Vary caching.
+    Headers varyHeaders = varyHeaders(urlConnection, responseHeaders);
+    if (varyHeaders == null) {
+      return null;
+    }
+
+    // OkHttp's Call API requires a placeholder body; the real body will be streamed separately.
+    String requestMethod = httpUrlConnection.getRequestMethod();
+    RequestBody placeholderBody = HttpMethod.requiresRequestBody(requestMethod)
+        ? Util.EMPTY_REQUEST
+        : null;
+
+    Request okRequest = new Request.Builder()
+        .url(uri.toString())
+        .method(requestMethod, placeholderBody)
+        .headers(varyHeaders)
+        .build();
+    okResponseBuilder.request(okRequest);
+
+    // Status line
+    StatusLine statusLine = StatusLine.parse(extractStatusLine(httpUrlConnection));
+    okResponseBuilder.protocol(statusLine.protocol);
+    okResponseBuilder.code(statusLine.code);
+    okResponseBuilder.message(statusLine.message);
+
+    // A network response is required for the Cache to find any Vary headers it needs.
+    Response networkResponse = okResponseBuilder.build();
+    okResponseBuilder.networkResponse(networkResponse);
+
+    // Response headers
+    Headers okHeaders = extractOkResponseHeaders(httpUrlConnection, okResponseBuilder);
+    okResponseBuilder.headers(okHeaders);
+
+    // Response body
+    ResponseBody okBody = createOkBody(urlConnection);
+    okResponseBuilder.body(okBody);
+
+    // Handle SSL handshake information as needed.
+    if (httpUrlConnection instanceof HttpsURLConnection) {
+      HttpsURLConnection httpsUrlConnection = (HttpsURLConnection) httpUrlConnection;
+
+      Certificate[] peerCertificates;
+      try {
+        peerCertificates = httpsUrlConnection.getServerCertificates();
+      } catch (SSLPeerUnverifiedException e) {
+        peerCertificates = null;
+      }
+
+      Certificate[] localCertificates = httpsUrlConnection.getLocalCertificates();
+
+      String cipherSuiteString = httpsUrlConnection.getCipherSuite();
+      CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);
+      Handshake handshake = Handshake.get(TlsVersion.SSL_3_0, cipherSuite,
+          nullSafeImmutableList(peerCertificates), nullSafeImmutableList(localCertificates));
+      okResponseBuilder.handshake(handshake);
+    }
+
+    return okResponseBuilder.build();
+  }
+
+  /**
+   * Returns headers for the header names and values in the {@link Map}.
+   */
+  private static Headers createHeaders(Map<String, List<String>> headers) {
+    Headers.Builder builder = new Headers.Builder();
+    for (Map.Entry<String, List<String>> header : headers.entrySet()) {
+      if (header.getKey() == null || header.getValue() == null) {
+        continue;
+      }
+      String name = header.getKey().trim();
+      for (String value : header.getValue()) {
+        String trimmedValue = value.trim();
+        Internal.instance.addLenient(builder, name, trimmedValue);
+      }
+    }
+    return builder.build();
+  }
+
+  private static Headers varyHeaders(URLConnection urlConnection, Headers responseHeaders) {
+    if (HttpHeaders.hasVaryAll(responseHeaders)) {
+      // "*" means that this will be treated as uncacheable anyway.
+      return null;
+    }
+    Set<String> varyFields = HttpHeaders.varyFields(responseHeaders);
+    if (varyFields.isEmpty()) {
+      return new Headers.Builder().build();
+    }
+
+    // This probably indicates another HTTP stack is trying to use the shared ResponseCache.
+    // We cannot guarantee this case will work properly because we cannot reliably extract *all*
+    // the request header values, and we can't get multiple Vary request header values.
+    // We also can't be sure about the Accept-Encoding behavior of other stacks.
+    if (!(urlConnection instanceof CacheHttpURLConnection
+        || urlConnection instanceof CacheHttpsURLConnection)) {
+      return null;
+    }
+
+    // This is the case we expect: The URLConnection is from a call to
+    // JavaApiConverter.createJavaUrlConnection() and we have access to the user's request headers.
+    Map<String, List<String>> requestProperties = urlConnection.getRequestProperties();
+    Headers.Builder result = new Headers.Builder();
+    for (String fieldName : varyFields) {
+      List<String> fieldValues = requestProperties.get(fieldName);
+      if (fieldValues == null) {
+        if (fieldName.equals("Accept-Encoding")) {
+          // Accept-Encoding is special. If OkHttp sees Accept-Encoding is unset it will add
+          // "gzip". We don't have access to the request that was actually made so we must do the
+          // same.
+          result.add("Accept-Encoding", "gzip");
+        }
+      } else {
+        for (String fieldValue : fieldValues) {
+          Internal.instance.addLenient(result, fieldName, fieldValue);
+        }
+      }
+    }
+    return result.build();
+  }
+
+  /**
+   * Creates an OkHttp {@link Response} using the supplied {@link Request} and {@link CacheResponse}
+   * to supply the data.
+   */
+  static Response createOkResponseForCacheGet(Request request, CacheResponse javaResponse)
+      throws IOException {
+
+    // Build a cache request for the response to use.
+    Headers responseHeaders = createHeaders(javaResponse.getHeaders());
+    Headers varyHeaders;
+    if (HttpHeaders.hasVaryAll(responseHeaders)) {
+      // "*" means that this will be treated as uncacheable anyway.
+      varyHeaders = new Headers.Builder().build();
+    } else {
+      varyHeaders = HttpHeaders.varyHeaders(request.headers(), responseHeaders);
+    }
+
+    Request cacheRequest = new Request.Builder()
+        .url(request.url())
+        .method(request.method(), null)
+        .headers(varyHeaders)
+        .build();
+
+    Response.Builder okResponseBuilder = new Response.Builder();
+
+    // Request: Use the cacheRequest we built.
+    okResponseBuilder.request(cacheRequest);
+
+    // Status line: Java has this as one of the headers.
+    StatusLine statusLine = StatusLine.parse(extractStatusLine(javaResponse));
+    okResponseBuilder.protocol(statusLine.protocol);
+    okResponseBuilder.code(statusLine.code);
+    okResponseBuilder.message(statusLine.message);
+
+    // Response headers
+    Headers okHeaders = extractOkHeaders(javaResponse, okResponseBuilder);
+    okResponseBuilder.headers(okHeaders);
+
+    // Response body
+    ResponseBody okBody = createOkBody(okHeaders, javaResponse);
+    okResponseBuilder.body(okBody);
+
+    // Handle SSL handshake information as needed.
+    if (javaResponse instanceof SecureCacheResponse) {
+      SecureCacheResponse javaSecureCacheResponse = (SecureCacheResponse) javaResponse;
+
+      // Handshake doesn't support null lists.
+      List<Certificate> peerCertificates;
+      try {
+        peerCertificates = javaSecureCacheResponse.getServerCertificateChain();
+      } catch (SSLPeerUnverifiedException e) {
+        peerCertificates = Collections.emptyList();
+      }
+      List<Certificate> localCertificates = javaSecureCacheResponse.getLocalCertificateChain();
+      if (localCertificates == null) {
+        localCertificates = Collections.emptyList();
+      }
+
+      String cipherSuiteString = javaSecureCacheResponse.getCipherSuite();
+      CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);
+      Handshake handshake = Handshake.get(
+          TlsVersion.SSL_3_0, cipherSuite, peerCertificates, localCertificates);
+      okResponseBuilder.handshake(handshake);
+    }
+
+    return okResponseBuilder.build();
+  }
+
+  /**
+   * Creates an OkHttp {@link Request} from the supplied information.
+   *
+   * <p>This method allows a {@code null} value for {@code requestHeaders} for situations where a
+   * connection is already connected and access to the headers has been lost. See {@link
+   * java.net.HttpURLConnection#getRequestProperties()} for details.
+   */
+  public static Request createOkRequest(
+      URI uri, String requestMethod, Map<String, List<String>> requestHeaders) {
+    // OkHttp's Call API requires a placeholder body; the real body will be streamed separately.
+    RequestBody placeholderBody = HttpMethod.requiresRequestBody(requestMethod)
+        ? Util.EMPTY_REQUEST
+        : null;
+
+    Request.Builder builder = new Request.Builder()
+        .url(uri.toString())
+        .method(requestMethod, placeholderBody);
+
+    if (requestHeaders != null) {
+      Headers headers = extractOkHeaders(requestHeaders, null);
+      builder.headers(headers);
+    }
+    return builder.build();
+  }
+
+  /**
+   * Creates a {@link java.net.CacheResponse} of the correct (sub)type using information gathered
+   * from the supplied {@link Response}.
+   */
+  public static CacheResponse createJavaCacheResponse(final Response response) {
+    final Headers headers = withSyntheticHeaders(response);
+    final ResponseBody body = response.body();
+    if (response.request().isHttps()) {
+      final Handshake handshake = response.handshake();
+      return new SecureCacheResponse() {
+        @Override
+        public String getCipherSuite() {
+          return handshake != null ? handshake.cipherSuite().javaName() : null;
+        }
+
+        @Override
+        public List<Certificate> getLocalCertificateChain() {
+          if (handshake == null) return null;
+          // Java requires null, not an empty list here.
+          List<Certificate> certificates = handshake.localCertificates();
+          return certificates.size() > 0 ? certificates : null;
+        }
+
+        @Override
+        public List<Certificate> getServerCertificateChain() throws SSLPeerUnverifiedException {
+          if (handshake == null) return null;
+          // Java requires null, not an empty list here.
+          List<Certificate> certificates = handshake.peerCertificates();
+          return certificates.size() > 0 ? certificates : null;
+        }
+
+        @Override
+        public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
+          if (handshake == null) return null;
+          return handshake.peerPrincipal();
+        }
+
+        @Override
+        public Principal getLocalPrincipal() {
+          if (handshake == null) return null;
+          return handshake.localPrincipal();
+        }
+
+        @Override
+        public Map<String, List<String>> getHeaders() throws IOException {
+          // Java requires that the entry with a null key be the status line.
+          return JavaNetHeaders.toMultimap(headers, StatusLine.get(response).toString());
+        }
+
+        @Override
+        public InputStream getBody() throws IOException {
+          if (body == null) return null;
+          return body.byteStream();
+        }
+      };
+    } else {
+      return new CacheResponse() {
+        @Override
+        public Map<String, List<String>> getHeaders() throws IOException {
+          // Java requires that the entry with a null key be the status line.
+          return JavaNetHeaders.toMultimap(headers, StatusLine.get(response).toString());
+        }
+
+        @Override
+        public InputStream getBody() throws IOException {
+          if (body == null) return null;
+          return body.byteStream();
+        }
+      };
+    }
+  }
+
+  public static java.net.CacheRequest createJavaCacheRequest(final CacheRequest okCacheRequest) {
+    return new java.net.CacheRequest() {
+      @Override
+      public void abort() {
+        okCacheRequest.abort();
+      }
+
+      @Override
+      public OutputStream getBody() throws IOException {
+        Sink body = okCacheRequest.body();
+        if (body == null) {
+          return null;
+        }
+        return Okio.buffer(body).outputStream();
+      }
+    };
+  }
+
+  /**
+   * Creates an {@link java.net.HttpURLConnection} of the correct subclass from the supplied OkHttp
+   * {@link Response}.
+   */
+  static HttpURLConnection createJavaUrlConnectionForCachePut(Response okResponse) {
+    okResponse = okResponse.newBuilder()
+        .body(null)
+        .headers(withSyntheticHeaders(okResponse))
+        .build();
+    Request request = okResponse.request();
+    // Create an object of the correct class in case the ResponseCache uses instanceof.
+    if (request.isHttps()) {
+      return new CacheHttpsURLConnection(new CacheHttpURLConnection(okResponse));
+    } else {
+      return new CacheHttpURLConnection(okResponse);
+    }
+  }
+
+  private static Headers withSyntheticHeaders(Response okResponse) {
+    return okResponse.headers().newBuilder()
+        .add(SENT_MILLIS, Long.toString(okResponse.sentRequestAtMillis()))
+        .add(RECEIVED_MILLIS, Long.toString(okResponse.receivedResponseAtMillis()))
+        .build();
+  }
+
+  /**
+   * Extracts an immutable request header map from the supplied {@link Headers}.
+   */
+  static Map<String, List<String>> extractJavaHeaders(Request request) {
+    return JavaNetHeaders.toMultimap(request.headers(), null);
+  }
+
+  /**
+   * Extracts OkHttp headers from the supplied {@link java.net.CacheResponse}. Only real headers are
+   * extracted. See {@link #extractStatusLine(java.net.CacheResponse)}.
+   */
+  private static Headers extractOkHeaders(
+      CacheResponse javaResponse, Response.Builder okResponseBuilder) throws IOException {
+    Map<String, List<String>> javaResponseHeaders = javaResponse.getHeaders();
+    return extractOkHeaders(javaResponseHeaders, okResponseBuilder);
+  }
+
+  /**
+   * Extracts OkHttp headers from the supplied {@link java.net.HttpURLConnection}. Only real headers
+   * are extracted. See {@link #extractStatusLine(java.net.HttpURLConnection)}.
+   */
+  private static Headers extractOkResponseHeaders(
+      HttpURLConnection httpUrlConnection, Response.Builder okResponseBuilder) {
+    Map<String, List<String>> javaResponseHeaders = httpUrlConnection.getHeaderFields();
+    return extractOkHeaders(javaResponseHeaders, okResponseBuilder);
+  }
+
+  /**
+   * Extracts OkHttp headers from the supplied {@link Map}. Only real headers are extracted. Any
+   * entry (one with a {@code null} key) is discarded. Special internal headers used to track cache
+   * metadata are omitted from the result and added to {@code okResponseBuilder} instead.
+   */
+  // @VisibleForTesting
+  static Headers extractOkHeaders(
+      Map<String, List<String>> javaHeaders, Response.Builder okResponseBuilder) {
+    Headers.Builder okHeadersBuilder = new Headers.Builder();
+    for (Map.Entry<String, List<String>> javaHeader : javaHeaders.entrySet()) {
+      String name = javaHeader.getKey();
+      if (name == null) {
+        // The Java API uses the null key to store the status line in responses.
+        // Earlier versions of OkHttp would use the null key to store the "request line" in
+        // requests. e.g. "GET / HTTP 1.1". Although this is no longer the case it must be
+        // explicitly ignored because Headers.Builder does not support null keys.
+        continue;
+      }
+      if (okResponseBuilder != null && javaHeader.getValue().size() == 1) {
+        if (name.equals(SENT_MILLIS)) {
+          okResponseBuilder.sentRequestAtMillis(Long.valueOf(javaHeader.getValue().get(0)));
+          continue;
+        }
+        if (name.equals(RECEIVED_MILLIS)) {
+          okResponseBuilder.receivedResponseAtMillis(Long.valueOf(javaHeader.getValue().get(0)));
+          continue;
+        }
+      }
+      for (String value : javaHeader.getValue()) {
+        Internal.instance.addLenient(okHeadersBuilder, name, value);
+      }
+    }
+    return okHeadersBuilder.build();
+  }
+
+  /**
+   * Extracts the status line from the supplied Java API {@link java.net.HttpURLConnection}. As per
+   * the spec, the status line is held as the header with the null key. Returns {@code null} if
+   * there is no status line.
+   */
+  private static String extractStatusLine(HttpURLConnection httpUrlConnection) {
+    // Java specifies that this will be be response header with a null key.
+    return httpUrlConnection.getHeaderField(null);
+  }
+
+  /**
+   * Extracts the status line from the supplied Java API {@link java.net.CacheResponse}. As per the
+   * spec, the status line is held as the header with the null key. Throws a {@link
+   * ProtocolException} if there is no status line.
+   */
+  private static String extractStatusLine(CacheResponse javaResponse) throws IOException {
+    Map<String, List<String>> javaResponseHeaders = javaResponse.getHeaders();
+    return extractStatusLine(javaResponseHeaders);
+  }
+
+  // VisibleForTesting
+  static String extractStatusLine(Map<String, List<String>> javaResponseHeaders)
+      throws ProtocolException {
+    List<String> values = javaResponseHeaders.get(null);
+    if (values == null || values.size() == 0) {
+      // The status line is missing. This suggests a badly behaving cache.
+      throw new ProtocolException(
+          "CacheResponse is missing a \'null\' header containing the status line. Headers="
+              + javaResponseHeaders);
+    }
+    return values.get(0);
+  }
+
+  /**
+   * Creates an OkHttp Response.Body containing the supplied information.
+   */
+  private static ResponseBody createOkBody(final Headers okHeaders,
+      final CacheResponse cacheResponse) throws IOException {
+    final BufferedSource body = Okio.buffer(Okio.source(cacheResponse.getBody()));
+    return new ResponseBody() {
+      @Override
+      public MediaType contentType() {
+        String contentTypeHeader = okHeaders.get("Content-Type");
+        return contentTypeHeader == null ? null : MediaType.parse(contentTypeHeader);
+      }
+
+      @Override
+      public long contentLength() {
+        return HttpHeaders.contentLength(okHeaders);
+      }
+
+      @Override public BufferedSource source() {
+        return body;
+      }
+    };
+  }
+
+  /**
+   * Creates an OkHttp Response.Body containing the supplied information.
+   */
+  private static ResponseBody createOkBody(final URLConnection urlConnection) throws IOException {
+    if (!urlConnection.getDoInput()) {
+      return null;
+    }
+
+    final BufferedSource body = Okio.buffer(Okio.source(urlConnection.getInputStream()));
+    return new ResponseBody() {
+      @Override public MediaType contentType() {
+        String contentTypeHeader = urlConnection.getContentType();
+        return contentTypeHeader == null ? null : MediaType.parse(contentTypeHeader);
+      }
+
+      @Override public long contentLength() {
+        String s = urlConnection.getHeaderField("Content-Length");
+        return stringToLong(s);
+      }
+
+      @Override public BufferedSource source() {
+        return body;
+      }
+    };
+  }
+
+  /**
+   * An {@link java.net.HttpURLConnection} that represents an HTTP request at the point where the
+   * request has been made, and the response headers have been received, but the body content, if
+   * present, has not been read yet. This intended to provide enough information for {@link
+   * java.net.ResponseCache} subclasses and no more.
+   *
+   * <p>Much of the method implementations are overrides to delegate to the OkHttp request and
+   * response, or to deny access to information as a real HttpURLConnection would after connection.
+   */
+  private static final class CacheHttpURLConnection extends HttpURLConnection {
+
+    private final Request request;
+    private final Response response;
+
+    CacheHttpURLConnection(Response response) {
+      super(response.request().url().url());
+      this.request = response.request();
+      this.response = response;
+
+      // Configure URLConnection inherited fields.
+      this.connected = true;
+      this.doOutput = request.body() != null;
+      this.doInput = true;
+      this.useCaches = true;
+
+      // Configure HttpUrlConnection inherited fields.
+      this.method = request.method();
+    }
+
+    // HTTP connection lifecycle methods
+
+    @Override
+    public void connect() throws IOException {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public void disconnect() {
+      throw throwRequestModificationException();
+    }
+
+    // HTTP Request methods
+
+    @Override
+    public void setRequestProperty(String key, String value) {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public void addRequestProperty(String key, String value) {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public String getRequestProperty(String key) {
+      return request.header(key);
+    }
+
+    @Override
+    public Map<String, List<String>> getRequestProperties() {
+      // The RI and OkHttp's HttpURLConnectionImpl fail this call after connect() as required by the
+      // spec. There seems no good reason why this should fail while getRequestProperty() is ok.
+      // We don't fail here, because we need all request header values for caching Vary responses
+      // correctly.
+      return JavaNetHeaders.toMultimap(request.headers(), null);
+    }
+
+    @Override
+    public void setFixedLengthStreamingMode(int contentLength) {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public void setFixedLengthStreamingMode(long contentLength) {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public void setChunkedStreamingMode(int chunklen) {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public void setInstanceFollowRedirects(boolean followRedirects) {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public boolean getInstanceFollowRedirects() {
+      // Return the platform default.
+      return super.getInstanceFollowRedirects();
+    }
+
+    @Override
+    public void setRequestMethod(String method) throws ProtocolException {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public String getRequestMethod() {
+      return request.method();
+    }
+
+    // HTTP Response methods
+
+    @Override
+    public String getHeaderFieldKey(int position) {
+      // Deal with index 0 meaning "status line"
+      if (position < 0) {
+        throw new IllegalArgumentException("Invalid header index: " + position);
+      }
+      if (position == 0 || position > response.headers().size()) {
+        return null;
+      }
+      return response.headers().name(position - 1);
+    }
+
+    @Override
+    public String getHeaderField(int position) {
+      // Deal with index 0 meaning "status line"
+      if (position < 0) {
+        throw new IllegalArgumentException("Invalid header index: " + position);
+      }
+      if (position == 0) {
+        return StatusLine.get(response).toString();
+      }
+      if (position > response.headers().size()) {
+        return null;
+      }
+      return response.headers().value(position - 1);
+    }
+
+    @Override
+    public String getHeaderField(String fieldName) {
+      return fieldName == null
+          ? StatusLine.get(response).toString()
+          : response.headers().get(fieldName);
+    }
+
+    @Override
+    public Map<String, List<String>> getHeaderFields() {
+      return JavaNetHeaders.toMultimap(response.headers(), StatusLine.get(response).toString());
+    }
+
+    @Override
+    public int getResponseCode() throws IOException {
+      return response.code();
+    }
+
+    @Override
+    public String getResponseMessage() throws IOException {
+      return response.message();
+    }
+
+    @Override
+    public InputStream getErrorStream() {
+      return null;
+    }
+
+    // HTTP miscellaneous methods
+
+    @Override
+    public boolean usingProxy() {
+      // It's safe to return false here, even if a proxy is in use. The problem is we don't
+      // necessarily know if we're going to use a proxy by the time we ask the cache for a response.
+      return false;
+    }
+
+    // URLConnection methods
+
+    @Override
+    public void setConnectTimeout(int timeout) {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public int getConnectTimeout() {
+      // Impossible to say.
+      return 0;
+    }
+
+    @Override
+    public void setReadTimeout(int timeout) {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public int getReadTimeout() {
+      // Impossible to say.
+      return 0;
+    }
+
+    @Override
+    public Object getContent() throws IOException {
+      throw throwResponseBodyAccessException();
+    }
+
+    @Override
+    public Object getContent(Class[] classes) throws IOException {
+      throw throwResponseBodyAccessException();
+    }
+
+    @Override
+    public InputStream getInputStream() throws IOException {
+      return new InputStream() {
+        @Override public int read() throws IOException {
+          throw throwResponseBodyAccessException();
+        }
+      };
+    }
+
+    @Override
+    public OutputStream getOutputStream() throws IOException {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public void setDoInput(boolean doInput) {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public boolean getDoInput() {
+      return doInput;
+    }
+
+    @Override
+    public void setDoOutput(boolean doOutput) {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public boolean getDoOutput() {
+      return doOutput;
+    }
+
+    @Override
+    public void setAllowUserInteraction(boolean allowUserInteraction) {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public boolean getAllowUserInteraction() {
+      return false;
+    }
+
+    @Override
+    public void setUseCaches(boolean useCaches) {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public boolean getUseCaches() {
+      return super.getUseCaches();
+    }
+
+    @Override
+    public void setIfModifiedSince(long ifModifiedSince) {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public long getIfModifiedSince() {
+      return stringToLong(request.headers().get("If-Modified-Since"));
+    }
+
+    @Override
+    public boolean getDefaultUseCaches() {
+      return super.getDefaultUseCaches();
+    }
+
+    @Override
+    public void setDefaultUseCaches(boolean defaultUseCaches) {
+      super.setDefaultUseCaches(defaultUseCaches);
+    }
+  }
+
+  /** An HttpsURLConnection to offer to the cache. */
+  private static final class CacheHttpsURLConnection extends DelegatingHttpsURLConnection {
+    private final CacheHttpURLConnection delegate;
+
+    CacheHttpsURLConnection(CacheHttpURLConnection delegate) {
+      super(delegate);
+      this.delegate = delegate;
+    }
+
+    @Override protected Handshake handshake() {
+      return delegate.response.handshake();
+    }
+
+    @Override public void setHostnameVerifier(HostnameVerifier hostnameVerifier) {
+      throw throwRequestModificationException();
+    }
+
+    @Override public HostnameVerifier getHostnameVerifier() {
+      throw throwRequestSslAccessException();
+    }
+
+    @Override public void setSSLSocketFactory(SSLSocketFactory socketFactory) {
+      throw throwRequestModificationException();
+    }
+
+    @Override public SSLSocketFactory getSSLSocketFactory() {
+      throw throwRequestSslAccessException();
+    }
+  }
+
+  private static RuntimeException throwRequestModificationException() {
+    throw new UnsupportedOperationException("ResponseCache cannot modify the request.");
+  }
+
+  private static RuntimeException throwRequestHeaderAccessException() {
+    throw new UnsupportedOperationException("ResponseCache cannot access request headers");
+  }
+
+  private static RuntimeException throwRequestSslAccessException() {
+    throw new UnsupportedOperationException("ResponseCache cannot access SSL internals");
+  }
+
+  private static RuntimeException throwResponseBodyAccessException() {
+    throw new UnsupportedOperationException("ResponseCache cannot access the response body.");
+  }
+
+  private static <T> List<T> nullSafeImmutableList(T[] elements) {
+    return elements == null ? Collections.<T>emptyList() : Util.immutableList(elements);
+  }
+
+  private static long stringToLong(String s) {
+    if (s == null) return -1;
+    try {
+      return Long.parseLong(s);
+    } catch (NumberFormatException e) {
+      return -1;
+    }
+  }
+}
diff --git a/okhttp-android-support/src/test/java/okhttp3/AbstractResponseCache.java b/okhttp-android-support/src/test/java/okhttp3/AbstractResponseCache.java
new file mode 100644
index 0000000000..d755487c92
--- /dev/null
+++ b/okhttp-android-support/src/test/java/okhttp3/AbstractResponseCache.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.CacheRequest;
+import java.net.CacheResponse;
+import java.net.ResponseCache;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.net.URLConnection;
+import java.util.List;
+import java.util.Map;
+
+public class AbstractResponseCache extends ResponseCache {
+  @Override public CacheResponse get(URI uri, String requestMethod,
+      Map<String, List<String>> requestHeaders) throws IOException {
+    return null;
+  }
+
+  @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
+    return null;
+  }
+
+  public static URI toUri(URL serverUrl) {
+    try {
+      return serverUrl.toURI();
+    } catch (URISyntaxException e) {
+      throw new AssertionError(e);
+    }
+  }
+}
diff --git a/okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCache.java b/okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCache.java
new file mode 100644
index 0000000000..c569a3b365
--- /dev/null
+++ b/okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCache.java
@@ -0,0 +1,183 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package okhttp3.android;
+
+import java.io.Closeable;
+import java.io.File;
+import java.io.IOException;
+import java.net.CacheRequest;
+import java.net.CacheResponse;
+import java.net.ResponseCache;
+import java.net.URI;
+import java.net.URLConnection;
+import java.util.List;
+import java.util.Map;
+import okhttp3.AndroidShimResponseCache;
+import okhttp3.Cache;
+import okhttp3.OkCacheContainer;
+
+/**
+ * A copy of android.net.http.HttpResponseCache taken from AOSP. Android need to keep this code
+ * working somehow. Dependencies on okhttp3 are com.android.okhttp on Android.
+ *
+ * <p>This class exists in okhttp-android-support to help keep the API as it always has been on
+ * Android. The public API cannot be changed. This class delegates to {@link
+ * AndroidShimResponseCache}, a class that exists in a package that enables it to interact with
+ * non-public OkHttp classes.
+ */
+public final class HttpResponseCache extends ResponseCache implements Closeable, OkCacheContainer {
+
+  private AndroidShimResponseCache shimResponseCache;
+
+  private HttpResponseCache(AndroidShimResponseCache shimResponseCache) {
+    this.shimResponseCache = shimResponseCache;
+  }
+
+  /**
+   * Returns the currently-installed {@code HttpResponseCache}, or null if there is no cache
+   * installed or it is not a {@code HttpResponseCache}.
+   */
+  public static HttpResponseCache getInstalled() {
+    ResponseCache installed = ResponseCache.getDefault();
+    if (installed instanceof HttpResponseCache) {
+      return (HttpResponseCache) installed;
+    }
+    return null;
+  }
+
+  /**
+   * Creates a new HTTP response cache and sets it as the system default cache.
+   *
+   * @param directory the directory to hold cache data.
+   * @param maxSize the maximum size of the cache in bytes.
+   * @return the newly-installed cache
+   * @throws java.io.IOException if {@code directory} cannot be used for this cache. Most
+   * applications should respond to this exception by logging a warning.
+   */
+  public static synchronized HttpResponseCache install(File directory, long maxSize) throws
+      IOException {
+    ResponseCache installed = ResponseCache.getDefault();
+
+    if (installed instanceof HttpResponseCache) {
+      HttpResponseCache installedResponseCache = (HttpResponseCache) installed;
+      // don't close and reopen if an equivalent cache is already installed
+      AndroidShimResponseCache trueResponseCache = installedResponseCache.shimResponseCache;
+      if (trueResponseCache.isEquivalent(directory, maxSize)) {
+        return installedResponseCache;
+      } else {
+        // The HttpResponseCache that owns this object is about to be replaced.
+        trueResponseCache.close();
+      }
+    }
+
+    AndroidShimResponseCache trueResponseCache =
+        AndroidShimResponseCache.create(directory, maxSize);
+    HttpResponseCache newResponseCache = new HttpResponseCache(trueResponseCache);
+    ResponseCache.setDefault(newResponseCache);
+    return newResponseCache;
+  }
+
+  @Override public CacheResponse get(URI uri, String requestMethod,
+      Map<String, List<String>> requestHeaders) throws IOException {
+    return shimResponseCache.get(uri, requestMethod, requestHeaders);
+  }
+
+  @Override public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
+    return shimResponseCache.put(uri, urlConnection);
+  }
+
+  /**
+   * Returns the number of bytes currently being used to store the values in this cache. This may be
+   * greater than the {@link #maxSize} if a background deletion is pending.
+   */
+  public long size() {
+    try {
+      return shimResponseCache.size();
+    } catch (IOException e) {
+      // This can occur if the cache failed to lazily initialize. Return -1 to mean "unknown".
+      return -1;
+    }
+  }
+
+  /**
+   * Returns the maximum number of bytes that this cache should use to store its data.
+   */
+  public long maxSize() {
+    return shimResponseCache.maxSize();
+  }
+
+  /**
+   * Force buffered operations to the filesystem. This ensures that responses written to the cache
+   * will be available the next time the cache is opened, even if this process is killed.
+   */
+  public void flush() {
+    try {
+      shimResponseCache.flush();
+    } catch (IOException ignored) {
+    }
+  }
+
+  /**
+   * Returns the number of HTTP requests that required the network to either supply a response or
+   * validate a locally cached response.
+   */
+  public int getNetworkCount() {
+    return shimResponseCache.getNetworkCount();
+  }
+
+  /**
+   * Returns the number of HTTP requests whose response was provided by the cache. This may include
+   * conditional {@code GET} requests that were validated over the network.
+   */
+  public int getHitCount() {
+    return shimResponseCache.getHitCount();
+  }
+
+  /**
+   * Returns the total number of HTTP requests that were made. This includes both client requests
+   * and requests that were made on the client's behalf to handle a redirects and retries.
+   */
+  public int getRequestCount() {
+    return shimResponseCache.getRequestCount();
+  }
+
+  /**
+   * Uninstalls the cache and releases any active resources. Stored contents will remain on the
+   * filesystem.
+   */
+  @Override public void close() throws IOException {
+    if (ResponseCache.getDefault() == this) {
+      ResponseCache.setDefault(null);
+    }
+    shimResponseCache.close();
+  }
+
+  /**
+   * Uninstalls the cache and deletes all of its stored contents.
+   */
+  public void delete() throws IOException {
+    if (ResponseCache.getDefault() == this) {
+      ResponseCache.setDefault(null);
+    }
+    shimResponseCache.delete();
+  }
+
+  @Override
+  public Cache getCache() {
+    return shimResponseCache.getCache();
+  }
+}
diff --git a/okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCacheTest.java b/okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCacheTest.java
new file mode 100644
index 0000000000..dcb1c01815
--- /dev/null
+++ b/okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCacheTest.java
@@ -0,0 +1,175 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package okhttp3.android;
+
+import java.io.File;
+import java.io.InputStream;
+import java.net.CacheRequest;
+import java.net.CacheResponse;
+import java.net.ResponseCache;
+import java.net.URI;
+import java.net.URLConnection;
+import java.util.List;
+import java.util.Map;
+import okhttp3.AndroidInternal;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+import okhttp3.OkUrlFactory;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.fail;
+
+/**
+ * A port of Android's android.net.http.HttpResponseCacheTest to JUnit4.
+ */
+public final class HttpResponseCacheTest {
+  @Rule public TemporaryFolder cacheRule = new TemporaryFolder();
+  @Rule public MockWebServer server = new MockWebServer();
+
+  private File cacheDir;
+  private OkUrlFactory urlFactory;
+
+  @Before public void setUp() throws Exception {
+    cacheDir = cacheRule.getRoot();
+    urlFactory = new OkUrlFactory(new OkHttpClient());
+  }
+
+  @After public void tearDown() throws Exception {
+    ResponseCache.setDefault(null);
+  }
+
+  @Test public void install() throws Exception {
+    HttpResponseCache installed = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
+    assertNotNull(installed);
+    assertSame(installed, ResponseCache.getDefault());
+    assertSame(installed, HttpResponseCache.getDefault());
+  }
+
+  @Test public void secondEquivalentInstallDoesNothing() throws Exception {
+    HttpResponseCache first = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
+    HttpResponseCache another = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
+    assertSame(first, another);
+  }
+
+  @Test public void installClosesPreviouslyInstalled() throws Exception {
+    HttpResponseCache first = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
+    initializeCache(first);
+
+    HttpResponseCache another = HttpResponseCache.install(cacheDir, 8 * 1024 * 1024);
+    initializeCache(another);
+
+    assertNotSame(first, another);
+    try {
+      first.flush();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  @Test public void getInstalledWithWrongTypeInstalled() {
+    ResponseCache.setDefault(new ResponseCache() {
+      @Override
+      public CacheResponse get(URI uri, String requestMethod,
+          Map<String, List<String>> requestHeaders) {
+        return null;
+      }
+
+      @Override
+      public CacheRequest put(URI uri, URLConnection connection) {
+        return null;
+      }
+    });
+    assertNull(HttpResponseCache.getInstalled());
+  }
+
+  @Test public void closeCloses() throws Exception {
+    HttpResponseCache cache = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
+    initializeCache(cache);
+
+    cache.close();
+    try {
+      cache.flush();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  @Test public void closeUninstalls() throws Exception {
+    HttpResponseCache cache = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
+    cache.close();
+    assertNull(ResponseCache.getDefault());
+  }
+
+  @Test public void deleteUninstalls() throws Exception {
+    HttpResponseCache cache = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
+    cache.delete();
+    assertNull(ResponseCache.getDefault());
+  }
+
+  /**
+   * Make sure that statistics tracking are wired all the way through the wrapper class.
+   * http://code.google.com/p/android/issues/detail?id=25418
+   */
+  @Test public void statisticsTracking() throws Exception {
+    HttpResponseCache cache = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
+
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
+
+    URLConnection c1 = openUrl(server.url("/"));
+
+    InputStream inputStream = c1.getInputStream();
+    assertEquals('A', inputStream.read());
+    inputStream.close();
+    assertEquals(1, cache.getRequestCount());
+    assertEquals(1, cache.getNetworkCount());
+    assertEquals(0, cache.getHitCount());
+
+    URLConnection c2 = openUrl(server.url("/"));
+    assertEquals('A', c2.getInputStream().read());
+
+    URLConnection c3 = openUrl(server.url("/"));
+    assertEquals('A', c3.getInputStream().read());
+    assertEquals(3, cache.getRequestCount());
+    assertEquals(1, cache.getNetworkCount());
+    assertEquals(2, cache.getHitCount());
+  }
+
+  // This mimics the Android HttpHandler, which is found in the okhttp3 package.
+  private URLConnection openUrl(HttpUrl url) {
+    ResponseCache responseCache = ResponseCache.getDefault();
+    AndroidInternal.setResponseCache(urlFactory, responseCache);
+    return urlFactory.open(url.url());
+  }
+
+  private void initializeCache(HttpResponseCache cache) {
+    // Ensure the cache is initialized, otherwise various methods are no-ops.
+    cache.size();
+  }
+}
diff --git a/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java
new file mode 100644
index 0000000000..53470ce87b
--- /dev/null
+++ b/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java
@@ -0,0 +1,295 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.huc;
+
+import java.io.IOException;
+import java.net.CacheRequest;
+import java.net.CacheResponse;
+import java.net.HttpURLConnection;
+import java.net.ResponseCache;
+import java.net.URI;
+import java.net.URL;
+import java.net.URLConnection;
+import java.nio.charset.StandardCharsets;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.HttpsURLConnection;
+import okhttp3.AbstractResponseCache;
+import okhttp3.OkHttpClient;
+import okhttp3.OkUrlFactory;
+import okhttp3.RecordingHostnameVerifier;
+import okhttp3.internal.Internal;
+import okhttp3.internal.cache.InternalCache;
+import okhttp3.internal.tls.SslClient;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okio.Buffer;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+/**
+ * A white-box test for {@link CacheAdapter}. See also:
+ * <ul>
+ *     <li>{@link ResponseCacheTest} for black-box tests that check that {@link ResponseCache}
+ *         classes are called correctly by OkHttp.
+ *     <li>{@link JavaApiConverterTest} for tests that check Java API classes / OkHttp conversion
+ *         logic.
+ * </ul>
+ */
+public class CacheAdapterTest {
+  private SslClient sslClient = SslClient.localhost();
+  private HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+  private MockWebServer server;
+  private OkHttpClient client;
+  private HttpURLConnection connection;
+
+  @Before public void setUp() throws Exception {
+    server = new MockWebServer();
+    client = new OkHttpClient();
+  }
+
+  @After public void tearDown() throws Exception {
+    if (connection != null) {
+      connection.disconnect();
+    }
+    server.shutdown();
+  }
+
+  @Test public void get_httpGet() throws Exception {
+    final URL serverUrl = configureServer(new MockResponse());
+    assertEquals("http", serverUrl.getProtocol());
+
+    ResponseCache responseCache = new AbstractResponseCache() {
+      @Override public CacheResponse get(
+          URI uri, String method, Map<String, List<String>> headers) throws IOException {
+        try {
+          assertEquals(toUri(serverUrl), uri);
+          assertEquals("GET", method);
+          assertTrue("Arbitrary standard header not present", headers.containsKey("User-Agent"));
+          assertEquals(Collections.singletonList("value1"), headers.get("key1"));
+          return null;
+        } catch (Throwable t) {
+          throw new IOException("unexpected cache failure", t);
+        }
+      }
+    };
+    setInternalCache(new CacheAdapter(responseCache));
+
+    connection = new OkUrlFactory(client).open(serverUrl);
+    connection.setRequestProperty("key1", "value1");
+
+    executeGet(connection);
+  }
+
+  @Test public void get_httpsGet() throws Exception {
+    final URL serverUrl = configureHttpsServer(new MockResponse());
+    assertEquals("https", serverUrl.getProtocol());
+
+    ResponseCache responseCache = new AbstractResponseCache() {
+      @Override public CacheResponse get(URI uri, String method, Map<String, List<String>> headers)
+          throws IOException {
+        try {
+          assertEquals("https", uri.getScheme());
+          assertEquals(toUri(serverUrl), uri);
+          assertEquals("GET", method);
+          assertTrue("Arbitrary standard header not present", headers.containsKey("User-Agent"));
+          assertEquals(Collections.singletonList("value1"), headers.get("key1"));
+          return null;
+        } catch (Throwable t) {
+          throw new IOException("unexpected cache failure", t);
+        }
+      }
+    };
+    setInternalCache(new CacheAdapter(responseCache));
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(hostnameVerifier)
+        .build();
+
+    connection = new OkUrlFactory(client).open(serverUrl);
+    connection.setRequestProperty("key1", "value1");
+
+    executeGet(connection);
+  }
+
+  @Test public void put_httpGet() throws Exception {
+    final String statusLine = "HTTP/1.1 200 Fantastic";
+    final byte[] response = "ResponseString".getBytes(StandardCharsets.UTF_8);
+    final URL serverUrl = configureServer(
+        new MockResponse()
+            .setStatus(statusLine)
+            .addHeader("A", "c")
+            .setBody(new Buffer().write(response)));
+
+    ResponseCache responseCache = new AbstractResponseCache() {
+      @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
+        try {
+          assertTrue(connection instanceof HttpURLConnection);
+          assertFalse(connection instanceof HttpsURLConnection);
+
+          assertEquals(response.length, connection.getContentLength());
+
+          HttpURLConnection httpUrlConnection = (HttpURLConnection) connection;
+          assertEquals("GET", httpUrlConnection.getRequestMethod());
+          assertTrue(httpUrlConnection.getDoInput());
+          assertFalse(httpUrlConnection.getDoOutput());
+
+          assertEquals("Fantastic", httpUrlConnection.getResponseMessage());
+          assertEquals(toUri(serverUrl), uri);
+          assertEquals(serverUrl, connection.getURL());
+          assertEquals("value", connection.getRequestProperty("key"));
+
+          // Check retrieval by string key.
+          assertEquals(statusLine, httpUrlConnection.getHeaderField(null));
+          assertEquals("c", httpUrlConnection.getHeaderField("A"));
+          // The RI and OkHttp supports case-insensitive matching for this method.
+          assertEquals("c", httpUrlConnection.getHeaderField("a"));
+          return null;
+        } catch (Throwable t) {
+          throw new IOException("unexpected cache failure", t);
+        }
+      }
+    };
+    setInternalCache(new CacheAdapter(responseCache));
+
+    connection = new OkUrlFactory(client).open(serverUrl);
+    connection.setRequestProperty("key", "value");
+    executeGet(connection);
+  }
+
+  @Test public void put_httpPost() throws Exception {
+    final String statusLine = "HTTP/1.1 200 Fantastic";
+    final URL serverUrl = configureServer(
+        new MockResponse()
+            .setStatus(statusLine)
+            .addHeader("A", "c"));
+
+    ResponseCache responseCache = new AbstractResponseCache() {
+      @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
+        try {
+          assertTrue(connection instanceof HttpURLConnection);
+          assertFalse(connection instanceof HttpsURLConnection);
+
+          assertEquals(0, connection.getContentLength());
+
+          HttpURLConnection httpUrlConnection = (HttpURLConnection) connection;
+          assertEquals("POST", httpUrlConnection.getRequestMethod());
+          assertTrue(httpUrlConnection.getDoInput());
+          assertTrue(httpUrlConnection.getDoOutput());
+
+          assertEquals("Fantastic", httpUrlConnection.getResponseMessage());
+          assertEquals(toUri(serverUrl), uri);
+          assertEquals(serverUrl, connection.getURL());
+          assertEquals("value", connection.getRequestProperty("key"));
+
+          // Check retrieval by string key.
+          assertEquals(statusLine, httpUrlConnection.getHeaderField(null));
+          assertEquals("c", httpUrlConnection.getHeaderField("A"));
+          // The RI and OkHttp supports case-insensitive matching for this method.
+          assertEquals("c", httpUrlConnection.getHeaderField("a"));
+          return null;
+        } catch (Throwable t) {
+          throw new IOException("unexpected cache failure", t);
+        }
+      }
+    };
+    setInternalCache(new CacheAdapter(responseCache));
+
+    connection = new OkUrlFactory(client).open(serverUrl);
+
+    executePost(connection);
+  }
+
+  @Test public void put_httpsGet() throws Exception {
+    final URL serverUrl = configureHttpsServer(new MockResponse());
+    assertEquals("https", serverUrl.getProtocol());
+
+    ResponseCache responseCache = new AbstractResponseCache() {
+      @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
+        try {
+          assertTrue(connection instanceof HttpsURLConnection);
+          assertEquals(toUri(serverUrl), uri);
+          assertEquals(serverUrl, connection.getURL());
+
+          HttpsURLConnection cacheHttpsUrlConnection = (HttpsURLConnection) connection;
+          HttpsURLConnection realHttpsUrlConnection =
+              (HttpsURLConnection) CacheAdapterTest.this.connection;
+          assertEquals(realHttpsUrlConnection.getCipherSuite(),
+              cacheHttpsUrlConnection.getCipherSuite());
+          assertEquals(realHttpsUrlConnection.getPeerPrincipal(),
+              cacheHttpsUrlConnection.getPeerPrincipal());
+          assertArrayEquals(realHttpsUrlConnection.getLocalCertificates(),
+              cacheHttpsUrlConnection.getLocalCertificates());
+          assertArrayEquals(realHttpsUrlConnection.getServerCertificates(),
+              cacheHttpsUrlConnection.getServerCertificates());
+          assertEquals(realHttpsUrlConnection.getLocalPrincipal(),
+              cacheHttpsUrlConnection.getLocalPrincipal());
+          return null;
+        } catch (Throwable t) {
+          throw new IOException("unexpected cache failure", t);
+        }
+      }
+    };
+    setInternalCache(new CacheAdapter(responseCache));
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(hostnameVerifier)
+        .build();
+
+    connection = new OkUrlFactory(client).open(serverUrl);
+    executeGet(connection);
+  }
+
+  private void executeGet(HttpURLConnection connection) throws IOException {
+    connection.connect();
+    connection.getHeaderFields();
+    connection.disconnect();
+  }
+
+  private void executePost(HttpURLConnection connection) throws IOException {
+    connection.setDoOutput(true);
+    connection.connect();
+    connection.getOutputStream().write("Hello World".getBytes());
+    connection.disconnect();
+  }
+
+  private URL configureServer(MockResponse mockResponse) throws Exception {
+    server.enqueue(mockResponse);
+    server.start();
+    return server.url("/").url();
+  }
+
+  private URL configureHttpsServer(MockResponse mockResponse) throws Exception {
+    server.useHttps(sslClient.socketFactory, false /* tunnelProxy */);
+    server.enqueue(mockResponse);
+    server.start();
+    return server.url("/").url();
+  }
+
+  private void setInternalCache(InternalCache internalCache) {
+    OkHttpClient.Builder builder = client.newBuilder();
+    Internal.instance.setCache(builder, internalCache);
+    client = builder.build();
+  }
+}
diff --git a/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java
new file mode 100644
index 0000000000..c14d6d57f4
--- /dev/null
+++ b/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java
@@ -0,0 +1,693 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.huc;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.CacheResponse;
+import java.net.HttpURLConnection;
+import java.net.SecureCacheResponse;
+import java.net.URI;
+import java.nio.charset.StandardCharsets;
+import java.security.Principal;
+import java.security.cert.Certificate;
+import java.security.cert.CertificateException;
+import java.security.cert.CertificateFactory;
+import java.security.cert.X509Certificate;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import okhttp3.CipherSuite;
+import okhttp3.Handshake;
+import okhttp3.Headers;
+import okhttp3.MediaType;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.TlsVersion;
+import okhttp3.internal.Internal;
+import okhttp3.internal.Util;
+import okhttp3.mockwebserver.MockWebServer;
+import okio.Buffer;
+import okio.BufferedSource;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public class JavaApiConverterTest {
+
+  // $ openssl req -x509 -nodes -days 36500 -subj '/CN=localhost' -config ./cert.cnf \
+  //     -newkey rsa:512 -out cert.pem
+  private static final X509Certificate LOCAL_CERT = certificate(""
+      + "-----BEGIN CERTIFICATE-----\n"
+      + "MIIBWDCCAQKgAwIBAgIJANS1EtICX2AZMA0GCSqGSIb3DQEBBQUAMBQxEjAQBgNV\n"
+      + "BAMTCWxvY2FsaG9zdDAgFw0xMjAxMDIxOTA4NThaGA8yMTExMTIwOTE5MDg1OFow\n"
+      + "FDESMBAGA1UEAxMJbG9jYWxob3N0MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAPpt\n"
+      + "atK8r4/hf4hSIs0os/BSlQLbRBaK9AfBReM4QdAklcQqe6CHsStKfI8pp0zs7Ptg\n"
+      + "PmMdpbttL0O7mUboBC8CAwEAAaM1MDMwMQYDVR0RBCowKIIVbG9jYWxob3N0Lmxv\n"
+      + "Y2FsZG9tYWlugglsb2NhbGhvc3SHBH8AAAEwDQYJKoZIhvcNAQEFBQADQQD0ntfL\n"
+      + "DCzOCv9Ma6Lv5o5jcYWVxvBSTsnt22hsJpWD1K7iY9lbkLwl0ivn73pG2evsAn9G\n"
+      + "X8YKH52fnHsCrhSD\n"
+      + "-----END CERTIFICATE-----");
+
+  // openssl req -x509 -nodes -days 36500 -subj '/CN=*.0.0.1' -newkey rsa:512 -out cert.pem
+  private static final X509Certificate SERVER_CERT = certificate(""
+      + "-----BEGIN CERTIFICATE-----\n"
+      + "MIIBkjCCATygAwIBAgIJAMdemqOwd/BEMA0GCSqGSIb3DQEBBQUAMBIxEDAOBgNV\n"
+      + "BAMUByouMC4wLjEwIBcNMTAxMjIwMTY0NDI1WhgPMjExMDExMjYxNjQ0MjVaMBIx\n"
+      + "EDAOBgNVBAMUByouMC4wLjEwXDANBgkqhkiG9w0BAQEFAANLADBIAkEAqY8c9Qrt\n"
+      + "YPWCvb7lclI+aDHM6fgbJcHsS9Zg8nUOh5dWrS7AgeA25wyaokFl4plBbbHQe2j+\n"
+      + "cCjsRiJIcQo9HwIDAQABo3MwcTAdBgNVHQ4EFgQUJ436TZPJvwCBKklZZqIvt1Yt\n"
+      + "JjEwQgYDVR0jBDswOYAUJ436TZPJvwCBKklZZqIvt1YtJjGhFqQUMBIxEDAOBgNV\n"
+      + "BAMUByouMC4wLjGCCQDHXpqjsHfwRDAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEB\n"
+      + "BQUAA0EAk9i88xdjWoewqvE+iMC9tD2obMchgFDaHH0ogxxiRaIKeEly3g0uGxIt\n"
+      + "fl2WRY8hb4x+zRrwsFaLEpdEvqcjOQ==\n"
+      + "-----END CERTIFICATE-----");
+
+  @Rule public MockWebServer server = new MockWebServer();
+
+  @Before public void setUp() throws Exception {
+    Internal.initializeInstanceForTests();
+  }
+
+  @Test public void createOkResponseForCacheGet() throws Exception {
+    final String statusLine = "HTTP/1.1 200 Fantastic";
+    URI uri = new URI("http://foo/bar");
+    Request request = new Request.Builder().url(uri.toURL()).build();
+    CacheResponse cacheResponse = new CacheResponse() {
+      @Override public Map<String, List<String>> getHeaders() throws IOException {
+        Map<String, List<String>> headers = new LinkedHashMap<>();
+        headers.put(null, Collections.singletonList(statusLine));
+        headers.put("xyzzy", Arrays.asList("bar", "baz"));
+        return headers;
+      }
+
+      @Override public InputStream getBody() throws IOException {
+        return new ByteArrayInputStream("HelloWorld".getBytes(StandardCharsets.UTF_8));
+      }
+    };
+
+    Response response = JavaApiConverter.createOkResponseForCacheGet(request, cacheResponse);
+    Request cacheRequest = response.request();
+    assertEquals(request.url(), cacheRequest.url());
+    assertEquals(request.method(), cacheRequest.method());
+    assertEquals(0, request.headers().size());
+
+    assertEquals(Protocol.HTTP_1_1, response.protocol());
+    assertEquals(200, response.code());
+    assertEquals("Fantastic", response.message());
+    Headers okResponseHeaders = response.headers();
+    assertEquals("baz", okResponseHeaders.get("xyzzy"));
+    assertEquals("HelloWorld", response.body().string());
+    assertNull(response.handshake());
+  }
+
+  /** Test for https://code.google.com/p/android/issues/detail?id=160522 */
+  @Test public void createOkResponseForCacheGet_withMissingStatusLine() throws Exception {
+    URI uri = new URI("http://foo/bar");
+    Request request = new Request.Builder().url(uri.toURL()).build();
+    CacheResponse cacheResponse = new CacheResponse() {
+      @Override public Map<String, List<String>> getHeaders() throws IOException {
+        Map<String, List<String>> headers = new LinkedHashMap<>();
+        // Headers is deliberately missing an entry with a null key.
+        headers.put("xyzzy", Arrays.asList("bar", "baz"));
+        return headers;
+      }
+
+      @Override public InputStream getBody() throws IOException {
+        return null; // Should never be called
+      }
+    };
+
+    try {
+      JavaApiConverter.createOkResponseForCacheGet(request, cacheResponse);
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void createOkResponseForCacheGet_secure() throws Exception {
+    final String statusLine = "HTTP/1.1 200 Fantastic";
+    final Principal localPrincipal = LOCAL_CERT.getSubjectX500Principal();
+    final List<Certificate> localCertificates = Arrays.<Certificate>asList(LOCAL_CERT);
+    final Principal serverPrincipal = SERVER_CERT.getSubjectX500Principal();
+    final List<Certificate> serverCertificates = Arrays.<Certificate>asList(SERVER_CERT);
+    URI uri = new URI("https://foo/bar");
+    Request request = new Request.Builder().url(uri.toURL()).build();
+    SecureCacheResponse cacheResponse = new SecureCacheResponse() {
+      @Override public Map<String, List<String>> getHeaders() throws IOException {
+        Map<String, List<String>> headers = new LinkedHashMap<>();
+        headers.put(null, Collections.singletonList(statusLine));
+        headers.put("xyzzy", Arrays.asList("bar", "baz"));
+        return headers;
+      }
+
+      @Override public InputStream getBody() throws IOException {
+        return new ByteArrayInputStream("HelloWorld".getBytes(StandardCharsets.UTF_8));
+      }
+
+      @Override public String getCipherSuite() {
+        return "SSL_RSA_WITH_NULL_MD5";
+      }
+
+      @Override public List<Certificate> getLocalCertificateChain() {
+        return localCertificates;
+      }
+
+      @Override public List<Certificate> getServerCertificateChain()
+          throws SSLPeerUnverifiedException {
+        return serverCertificates;
+      }
+
+      @Override public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
+        return serverPrincipal;
+      }
+
+      @Override public Principal getLocalPrincipal() {
+        return localPrincipal;
+      }
+    };
+
+    Response response = JavaApiConverter.createOkResponseForCacheGet(request, cacheResponse);
+    Request cacheRequest = response.request();
+    assertEquals(request.url(), cacheRequest.url());
+    assertEquals(request.method(), cacheRequest.method());
+    assertEquals(0, request.headers().size());
+
+    assertEquals(Protocol.HTTP_1_1, response.protocol());
+    assertEquals(200, response.code());
+    assertEquals("Fantastic", response.message());
+    Headers okResponseHeaders = response.headers();
+    assertEquals("baz", okResponseHeaders.get("xyzzy"));
+    assertEquals("HelloWorld", response.body().string());
+
+    Handshake handshake = response.handshake();
+    assertNotNull(handshake);
+    assertNotNullAndEquals(CipherSuite.TLS_RSA_WITH_NULL_MD5, handshake.cipherSuite());
+    assertEquals(localPrincipal, handshake.localPrincipal());
+    assertEquals(serverPrincipal, handshake.peerPrincipal());
+    assertEquals(serverCertificates, handshake.peerCertificates());
+    assertEquals(localCertificates, handshake.localCertificates());
+  }
+
+  @Test public void createOkRequest_nullRequestHeaders() throws Exception {
+    URI uri = new URI("http://foo/bar");
+
+    Map<String, List<String>> javaRequestHeaders = null;
+    Request request = JavaApiConverter.createOkRequest(uri, "POST", javaRequestHeaders);
+    assertFalse(request.isHttps());
+    assertEquals(uri, request.url().uri());
+    Headers okRequestHeaders = request.headers();
+    assertEquals(0, okRequestHeaders.size());
+    assertEquals("POST", request.method());
+  }
+
+  @Test public void createOkRequest_nonNullRequestHeaders() throws Exception {
+    URI uri = new URI("https://foo/bar");
+
+    Map<String, List<String>> javaRequestHeaders = new LinkedHashMap<>();
+    javaRequestHeaders.put("Foo", Arrays.asList("Bar"));
+    Request request = JavaApiConverter.createOkRequest(uri, "POST", javaRequestHeaders);
+    assertTrue(request.isHttps());
+    assertEquals(uri, request.url().uri());
+    Headers okRequestHeaders = request.headers();
+    assertEquals(1, okRequestHeaders.size());
+    assertEquals("Bar", okRequestHeaders.get("Foo"));
+    assertEquals("POST", request.method());
+  }
+
+  // Older versions of OkHttp would store the "request line" as a header with a
+  // null key. To support the Android usecase where an old version of OkHttp uses
+  // a newer, Android-bundled, version of HttpResponseCache the null key must be
+  // explicitly ignored.
+  @Test public void createOkRequest_nullRequestHeaderKey() throws Exception {
+    URI uri = new URI("https://foo/bar");
+
+    Map<String, List<String>> javaRequestHeaders = new LinkedHashMap<>();
+    javaRequestHeaders.put(null, Arrays.asList("GET / HTTP 1.1"));
+    javaRequestHeaders.put("Foo", Arrays.asList("Bar"));
+    Request request = JavaApiConverter.createOkRequest(uri, "POST", javaRequestHeaders);
+    assertTrue(request.isHttps());
+    assertEquals(uri, request.url().uri());
+    Headers okRequestHeaders = request.headers();
+    assertEquals(1, okRequestHeaders.size());
+    assertEquals("Bar", okRequestHeaders.get("Foo"));
+    assertEquals("POST", request.method());
+  }
+
+  @Test public void createJavaUrlConnection_requestChangesForbidden() throws Exception {
+    Response okResponse = createArbitraryOkResponse();
+    HttpURLConnection httpUrlConnection =
+        JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
+    // Check an arbitrary (not complete) set of methods that can be used to modify the
+    // request.
+    try {
+      httpUrlConnection.setRequestProperty("key", "value");
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+    try {
+      httpUrlConnection.setFixedLengthStreamingMode(1234);
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+    try {
+      httpUrlConnection.setRequestMethod("PUT");
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+    try {
+      httpUrlConnection.getHeaderFields().put("key", Collections.singletonList("value"));
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+    try {
+      httpUrlConnection.getOutputStream();
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+  }
+
+  @Test public void createJavaUrlConnection_connectionChangesForbidden() throws Exception {
+    Response okResponse = createArbitraryOkResponse();
+    HttpURLConnection httpUrlConnection =
+        JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
+    try {
+      httpUrlConnection.connect();
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+    try {
+      httpUrlConnection.disconnect();
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+  }
+
+  @Test public void createJavaUrlConnection_responseChangesForbidden() throws Exception {
+    Response okResponse = createArbitraryOkResponse();
+    HttpURLConnection httpUrlConnection =
+        JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
+    // Check an arbitrary (not complete) set of methods that can be used to access the response
+    // body.
+    InputStream is = httpUrlConnection.getInputStream();
+    try {
+      is.read();
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+    try {
+      httpUrlConnection.getContent();
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+    try {
+      httpUrlConnection.setFixedLengthStreamingMode(1234);
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+    try {
+      httpUrlConnection.setRequestMethod("PUT");
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+    try {
+      httpUrlConnection.getHeaderFields().put("key", Collections.singletonList("value"));
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+  }
+
+  @Test public void createJavaUrlConnection_responseHeadersOk() throws Exception {
+    ResponseBody responseBody = createResponseBody("BodyText");
+    Response okResponse = new Response.Builder()
+        .request(createArbitraryOkRequest())
+        .protocol(Protocol.HTTP_1_1)
+        .code(200)
+        .message("Fantastic")
+        .addHeader("A", "c")
+        .addHeader("B", "d")
+        .addHeader("A", "e")
+        .addHeader("Content-Length", Long.toString(responseBody.contentLength()))
+        .body(responseBody)
+        .build();
+
+    HttpURLConnection httpUrlConnection =
+        JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
+    assertEquals(200, httpUrlConnection.getResponseCode());
+    assertEquals("Fantastic", httpUrlConnection.getResponseMessage());
+    assertEquals(responseBody.contentLength(), httpUrlConnection.getContentLength());
+
+    // Check retrieval by string key.
+    assertEquals("HTTP/1.1 200 Fantastic", httpUrlConnection.getHeaderField(null));
+    assertEquals("e", httpUrlConnection.getHeaderField("A"));
+    // The RI and OkHttp supports case-insensitive matching for this method.
+    assertEquals("e", httpUrlConnection.getHeaderField("a"));
+
+    // Check retrieval using a Map.
+    Map<String, List<String>> responseHeaders = httpUrlConnection.getHeaderFields();
+    assertEquals(Arrays.asList("HTTP/1.1 200 Fantastic"), responseHeaders.get(null));
+    assertEquals(newSet("c", "e"), newSet(responseHeaders.get("A")));
+    // OkHttp supports case-insensitive matching here. The RI does not.
+    assertEquals(newSet("c", "e"), newSet(responseHeaders.get("a")));
+
+    // Check the Map iterator contains the expected mappings.
+    assertHeadersContainsMapping(responseHeaders, null, "HTTP/1.1 200 Fantastic");
+    assertHeadersContainsMapping(responseHeaders, "A", "c", "e");
+    assertHeadersContainsMapping(responseHeaders, "B", "d");
+
+    // Check immutability of the headers Map.
+    try {
+      responseHeaders.put("N", Arrays.asList("o"));
+      fail("Modified an unmodifiable view.");
+    } catch (UnsupportedOperationException expected) {
+    }
+    try {
+      responseHeaders.get("A").add("f");
+      fail("Modified an unmodifiable view.");
+    } catch (UnsupportedOperationException expected) {
+    }
+
+    // Check retrieval of headers by index.
+    assertEquals(null, httpUrlConnection.getHeaderFieldKey(0));
+    assertEquals("HTTP/1.1 200 Fantastic", httpUrlConnection.getHeaderField(0));
+    // After header zero there may be additional entries provided at the beginning or end by the
+    // implementation. It's probably important that the relative ordering of the headers is
+    // preserved, particularly if there are multiple value for the same key.
+    int i = 1;
+    while (!httpUrlConnection.getHeaderFieldKey(i).equals("A")) {
+      i++;
+    }
+    // Check the ordering of the headers set by app code.
+    assertResponseHeaderAtIndex(httpUrlConnection, i++, "A", "c");
+    assertResponseHeaderAtIndex(httpUrlConnection, i++, "B", "d");
+    assertResponseHeaderAtIndex(httpUrlConnection, i++, "A", "e");
+    // There may be some additional headers provided by the implementation.
+    while (httpUrlConnection.getHeaderField(i) != null) {
+      assertNotNull(httpUrlConnection.getHeaderFieldKey(i));
+      i++;
+    }
+    // Confirm the correct behavior when the index is out-of-range.
+    assertNull(httpUrlConnection.getHeaderFieldKey(i));
+  }
+
+  private static void assertResponseHeaderAtIndex(HttpURLConnection httpUrlConnection,
+      int headerIndex, String expectedKey, String expectedValue) {
+    assertEquals(expectedKey, httpUrlConnection.getHeaderFieldKey(headerIndex));
+    assertEquals(expectedValue, httpUrlConnection.getHeaderField(headerIndex));
+  }
+
+  private void assertHeadersContainsMapping(Map<String, List<String>> headers, String expectedKey,
+      String... expectedValues) {
+    assertTrue(headers.containsKey(expectedKey));
+    assertEquals(newSet(expectedValues), newSet(headers.get(expectedKey)));
+  }
+
+  @Test public void createJavaUrlConnection_accessibleRequestInfo_GET() throws Exception {
+    Request okRequest = createArbitraryOkRequest().newBuilder()
+        .get()
+        .build();
+    Response okResponse = createArbitraryOkResponse(okRequest);
+    HttpURLConnection httpUrlConnection =
+        JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
+
+    assertEquals("GET", httpUrlConnection.getRequestMethod());
+    assertTrue(httpUrlConnection.getDoInput());
+    assertFalse(httpUrlConnection.getDoOutput());
+  }
+
+  @Test public void createJavaUrlConnection_accessibleRequestInfo_POST() throws Exception {
+    Request okRequest = createArbitraryOkRequest().newBuilder()
+        .post(createRequestBody("PostBody"))
+        .build();
+    Response okResponse = createArbitraryOkResponse(okRequest);
+    HttpURLConnection httpUrlConnection =
+        JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
+
+    assertEquals("POST", httpUrlConnection.getRequestMethod());
+    assertTrue(httpUrlConnection.getDoInput());
+    assertTrue(httpUrlConnection.getDoOutput());
+  }
+
+  @Test public void createJavaUrlConnection_https_extraHttpsMethods() throws Exception {
+    Request okRequest = createArbitraryOkRequest().newBuilder()
+        .get()
+        .url("https://secure/request")
+        .build();
+    Handshake handshake = Handshake.get(TlsVersion.SSL_3_0, CipherSuite.TLS_RSA_WITH_NULL_MD5,
+        Arrays.<Certificate>asList(SERVER_CERT), Arrays.<Certificate>asList(LOCAL_CERT));
+    Response okResponse = createArbitraryOkResponse(okRequest).newBuilder()
+        .handshake(handshake)
+        .build();
+    HttpsURLConnection httpsUrlConnection =
+        (HttpsURLConnection) JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
+
+    assertEquals("SSL_RSA_WITH_NULL_MD5", httpsUrlConnection.getCipherSuite());
+    assertEquals(SERVER_CERT.getSubjectX500Principal(), httpsUrlConnection.getPeerPrincipal());
+    assertArrayEquals(new Certificate[] {LOCAL_CERT}, httpsUrlConnection.getLocalCertificates());
+    assertArrayEquals(new Certificate[] {SERVER_CERT},
+        httpsUrlConnection.getServerCertificates());
+    assertEquals(LOCAL_CERT.getSubjectX500Principal(), httpsUrlConnection.getLocalPrincipal());
+  }
+
+  @Test public void createJavaUrlConnection_https_forbiddenFields() throws Exception {
+    Request okRequest = createArbitraryOkRequest().newBuilder()
+        .url("https://secure/request")
+        .build();
+    Response okResponse = createArbitraryOkResponse(okRequest);
+    HttpsURLConnection httpsUrlConnection =
+        (HttpsURLConnection) JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
+
+    try {
+      httpsUrlConnection.getHostnameVerifier();
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+    try {
+      httpsUrlConnection.getSSLSocketFactory();
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+  }
+
+  @Test public void createJavaCacheResponse_httpGet() throws Exception {
+    Request okRequest =
+        createArbitraryOkRequest().newBuilder()
+            .url("http://insecure/request")
+            .get()
+            .build();
+    Response okResponse = createArbitraryOkResponse(okRequest).newBuilder()
+        .protocol(Protocol.HTTP_1_1)
+        .code(200)
+        .message("Fantastic")
+        .addHeader("key1", "value1_1")
+        .addHeader("key2", "value2")
+        .addHeader("key1", "value1_2")
+        .body(null)
+        .build();
+    CacheResponse javaCacheResponse = JavaApiConverter.createJavaCacheResponse(okResponse);
+    assertFalse(javaCacheResponse instanceof SecureCacheResponse);
+    Map<String, List<String>> javaHeaders = javaCacheResponse.getHeaders();
+    assertEquals(Arrays.asList("value1_1", "value1_2"), javaHeaders.get("key1"));
+    assertEquals(Arrays.asList("HTTP/1.1 200 Fantastic"), javaHeaders.get(null));
+    assertNull(javaCacheResponse.getBody());
+  }
+
+  @Test public void createJavaCacheResponse_httpPost() throws Exception {
+    Request okRequest =
+        createArbitraryOkRequest().newBuilder()
+            .url("http://insecure/request")
+            .post(createRequestBody("RequestBody"))
+            .build();
+    ResponseBody responseBody = createResponseBody("ResponseBody");
+    Response okResponse = createArbitraryOkResponse(okRequest).newBuilder()
+        .protocol(Protocol.HTTP_1_1)
+        .code(200)
+        .message("Fantastic")
+        .addHeader("key1", "value1_1")
+        .addHeader("key2", "value2")
+        .addHeader("key1", "value1_2")
+        .body(responseBody)
+        .build();
+    CacheResponse javaCacheResponse = JavaApiConverter.createJavaCacheResponse(okResponse);
+    assertFalse(javaCacheResponse instanceof SecureCacheResponse);
+    Map<String, List<String>> javaHeaders = javaCacheResponse.getHeaders();
+    assertEquals(Arrays.asList("value1_1", "value1_2"), javaHeaders.get("key1"));
+    assertEquals(Arrays.asList("HTTP/1.1 200 Fantastic"), javaHeaders.get(null));
+    assertEquals("ResponseBody", readAll(javaCacheResponse.getBody()));
+  }
+
+  @Test public void createJavaCacheResponse_httpsPost() throws Exception {
+    Request okRequest =
+        createArbitraryOkRequest().newBuilder()
+            .url("https://secure/request")
+            .post(createRequestBody("RequestBody"))
+            .build();
+    ResponseBody responseBody = createResponseBody("ResponseBody");
+    Handshake handshake = Handshake.get(TlsVersion.SSL_3_0, CipherSuite.TLS_RSA_WITH_NULL_MD5,
+        Arrays.<Certificate>asList(SERVER_CERT), Arrays.<Certificate>asList(LOCAL_CERT));
+    Response okResponse = createArbitraryOkResponse(okRequest).newBuilder()
+        .protocol(Protocol.HTTP_1_1)
+        .code(200)
+        .message("Fantastic")
+        .addHeader("key1", "value1_1")
+        .addHeader("key2", "value2")
+        .addHeader("key1", "value1_2")
+        .body(responseBody)
+        .handshake(handshake)
+        .build();
+    SecureCacheResponse javaCacheResponse =
+        (SecureCacheResponse) JavaApiConverter.createJavaCacheResponse(okResponse);
+    Map<String, List<String>> javaHeaders = javaCacheResponse.getHeaders();
+    assertEquals(Arrays.asList("value1_1", "value1_2"), javaHeaders.get("key1"));
+    assertEquals(Arrays.asList("HTTP/1.1 200 Fantastic"), javaHeaders.get(null));
+    assertEquals("ResponseBody", readAll(javaCacheResponse.getBody()));
+    assertEquals(handshake.cipherSuite().javaName(), javaCacheResponse.getCipherSuite());
+    assertEquals(handshake.localCertificates(), javaCacheResponse.getLocalCertificateChain());
+    assertEquals(handshake.peerCertificates(), javaCacheResponse.getServerCertificateChain());
+    assertEquals(handshake.localPrincipal(), javaCacheResponse.getLocalPrincipal());
+    assertEquals(handshake.peerPrincipal(), javaCacheResponse.getPeerPrincipal());
+  }
+
+  @Test public void extractJavaHeaders() throws Exception {
+    Request okRequest = createArbitraryOkRequest().newBuilder()
+        .addHeader("key1", "value1_1")
+        .addHeader("key2", "value2")
+        .addHeader("key1", "value1_2")
+        .build();
+    Map<String, List<String>> javaHeaders = JavaApiConverter.extractJavaHeaders(okRequest);
+
+    assertEquals(Arrays.asList("value1_1", "value1_2"), javaHeaders.get("key1"));
+    assertEquals(Arrays.asList("value2"), javaHeaders.get("key2"));
+  }
+
+  @Test public void extractOkHeaders() {
+    Map<String, List<String>> javaResponseHeaders = new LinkedHashMap<>();
+    javaResponseHeaders.put(null, Arrays.asList("StatusLine"));
+    javaResponseHeaders.put("key1", Arrays.asList("value1_1", "value1_2"));
+    javaResponseHeaders.put("key2", Arrays.asList("value2"));
+
+    Headers okHeaders = JavaApiConverter.extractOkHeaders(javaResponseHeaders, null);
+    assertEquals(3, okHeaders.size()); // null entry should be stripped out
+    assertEquals(Arrays.asList("value1_1", "value1_2"), okHeaders.values("key1"));
+    assertEquals(Arrays.asList("value2"), okHeaders.values("key2"));
+  }
+
+  @Test public void extractStatusLine() throws Exception {
+    Map<String, List<String>> javaResponseHeaders = new LinkedHashMap<>();
+    javaResponseHeaders.put(null, Arrays.asList("StatusLine"));
+    javaResponseHeaders.put("key1", Arrays.asList("value1_1", "value1_2"));
+    javaResponseHeaders.put("key2", Arrays.asList("value2"));
+    assertEquals("StatusLine", JavaApiConverter.extractStatusLine(javaResponseHeaders));
+
+    try {
+      JavaApiConverter.extractStatusLine(Collections.<String, List<String>>emptyMap());
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  private static <T> void assertNotNullAndEquals(T expected, T actual) {
+    assertNotNull(actual);
+    assertEquals(expected, actual);
+  }
+
+  private static X509Certificate certificate(String certificate) {
+    try {
+      return (X509Certificate) CertificateFactory.getInstance("X.509").generateCertificate(
+          new ByteArrayInputStream(certificate.getBytes(Util.UTF_8)));
+    } catch (CertificateException e) {
+      fail();
+      return null;
+    }
+  }
+
+  @SafeVarargs
+  private static <T> Set<T> newSet(T... elements) {
+    return newSet(Arrays.asList(elements));
+  }
+
+  private static <T> Set<T> newSet(List<T> elements) {
+    return new LinkedHashSet<>(elements);
+  }
+
+  private static Request createArbitraryOkRequest() {
+    return new Request.Builder().url("http://arbitrary/url").build();
+  }
+
+  private static Response createArbitraryOkResponse(Request request) {
+    return new Response.Builder()
+        .request(request)
+        .protocol(Protocol.HTTP_1_1)
+        .code(200)
+        .message("Arbitrary")
+        .build();
+  }
+
+  private static Response createArbitraryOkResponse() {
+    return createArbitraryOkResponse(createArbitraryOkRequest());
+  }
+
+  private static RequestBody createRequestBody(String bodyText) {
+    return RequestBody.create(MediaType.parse("text/plain"), bodyText);
+  }
+
+  private static ResponseBody createResponseBody(String bodyText) {
+    final Buffer source = new Buffer().writeUtf8(bodyText);
+    final long contentLength = source.size();
+    return new ResponseBody() {
+      @Override public MediaType contentType() {
+        return MediaType.parse("text/plain; charset=utf-8");
+      }
+
+      @Override public long contentLength() {
+        return contentLength;
+      }
+
+      @Override public BufferedSource source() {
+        return source;
+      }
+    };
+  }
+
+  private String readAll(InputStream in) throws IOException {
+    ByteArrayOutputStream buffer = new ByteArrayOutputStream();
+    int value;
+    while ((value = in.read()) != -1) {
+      buffer.write(value);
+    }
+    in.close();
+    return buffer.toString("UTF-8");
+  }
+}
diff --git a/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java
new file mode 100644
index 0000000000..51bf46cc88
--- /dev/null
+++ b/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java
@@ -0,0 +1,2200 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package okhttp3.internal.huc;
+
+import java.io.BufferedReader;
+import java.io.ByteArrayInputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.net.CacheRequest;
+import java.net.CacheResponse;
+import java.net.CookieManager;
+import java.net.HttpCookie;
+import java.net.HttpURLConnection;
+import java.net.ProtocolException;
+import java.net.ResponseCache;
+import java.net.SecureCacheResponse;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.net.URLConnection;
+import java.nio.charset.StandardCharsets;
+import java.security.Principal;
+import java.security.cert.Certificate;
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.TimeZone;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.HttpsURLConnection;
+import okhttp3.AbstractResponseCache;
+import okhttp3.AndroidInternal;
+import okhttp3.AndroidShimResponseCache;
+import okhttp3.Headers;
+import okhttp3.OkHttpClient;
+import okhttp3.OkUrlFactory;
+import okhttp3.RecordingHostnameVerifier;
+import okhttp3.internal.Internal;
+import okhttp3.internal.cache.InternalCache;
+import okhttp3.internal.tls.SslClient;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.mockwebserver.SocketPolicy;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.GzipSink;
+import okio.Okio;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeFalse;
+
+/**
+ * Tests the interaction between OkHttp and {@link ResponseCache}. Based on okhttp3.CacheTest with
+ * changes for ResponseCache and HttpURLConnection.
+ */
+public final class ResponseCacheTest {
+  @Rule public TemporaryFolder cacheRule = new TemporaryFolder();
+  @Rule public MockWebServer server = new MockWebServer();
+  @Rule public MockWebServer server2 = new MockWebServer();
+
+  private HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+  private SslClient sslClient = SslClient.localhost();
+  private ResponseCache cache;
+  private CookieManager cookieManager;
+  private OkUrlFactory urlFactory;
+
+  @Before public void setUp() throws Exception {
+    server.setProtocolNegotiationEnabled(false);
+
+    cache = AndroidShimResponseCache.create(cacheRule.getRoot(), 10 * 1024 * 1024);
+    urlFactory = new OkUrlFactory(new OkHttpClient());
+    AndroidInternal.setResponseCache(urlFactory, cache);
+
+    cookieManager = new CookieManager();
+  }
+
+  @After public void tearDown() throws Exception {
+    ResponseCache.setDefault(null);
+  }
+
+  private HttpURLConnection openConnection(URL url) {
+    return urlFactory.open(url);
+  }
+
+  /**
+   * Test that response caching is consistent with the RI and the spec.
+   * http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.4
+   */
+  @Test public void responseCachingByResponseCode() throws Exception {
+    // Test each documented HTTP/1.1 code, plus the first unused value in each range.
+    // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
+
+    // We can't test 100 because it's not really a response.
+    // assertCached(false, 100);
+    assertCached(false, 101);
+    assertCached(false, 102);
+    assertCached(true, 200);
+    assertCached(false, 201);
+    assertCached(false, 202);
+    assertCached(true, 203);
+    assertCached(true, 204);
+    assertCached(false, 205);
+    assertCached(false, 206); //Electing to not cache partial responses
+    assertCached(false, 207);
+    assertCached(true, 300);
+    assertCached(true, 301);
+    assertCached(true, 302);
+    assertCached(false, 303);
+    assertCached(false, 304);
+    assertCached(false, 305);
+    assertCached(false, 306);
+    assertCached(true, 307);
+    assertCached(true, 308);
+    assertCached(false, 400);
+    assertCached(false, 401);
+    assertCached(false, 402);
+    assertCached(false, 403);
+    assertCached(true, 404);
+    assertCached(true, 405);
+    assertCached(false, 406);
+    assertCached(false, 408);
+    assertCached(false, 409);
+    // the HTTP spec permits caching 410s, but the RI doesn't.
+    assertCached(true, 410);
+    assertCached(false, 411);
+    assertCached(false, 412);
+    assertCached(false, 413);
+    assertCached(true, 414);
+    assertCached(false, 415);
+    assertCached(false, 416);
+    assertCached(false, 417);
+    assertCached(false, 418);
+
+    assertCached(false, 500);
+    assertCached(true, 501);
+    assertCached(false, 502);
+    assertCached(false, 503);
+    assertCached(false, 504);
+    assertCached(false, 505);
+    assertCached(false, 506);
+  }
+
+  private void assertCached(boolean shouldPut, int responseCode) throws Exception {
+    int expectedResponseCode = responseCode;
+
+    server = new MockWebServer();
+    MockResponse mockResponse = new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setResponseCode(responseCode)
+        .setBody("ABCDE")
+        .addHeader("WWW-Authenticate: challenge");
+    if (responseCode == HttpURLConnection.HTTP_PROXY_AUTH) {
+      mockResponse.addHeader("Proxy-Authenticate: Basic realm=\"protected area\"");
+    } else if (responseCode == HttpURLConnection.HTTP_UNAUTHORIZED) {
+      mockResponse.addHeader("WWW-Authenticate: Basic realm=\"protected area\"");
+    } else if (responseCode == HttpURLConnection.HTTP_NO_CONTENT
+        || responseCode == HttpURLConnection.HTTP_RESET) {
+      mockResponse.setBody(""); // We forbid bodies for 204 and 205.
+    }
+    server.enqueue(mockResponse);
+
+    if (responseCode == HttpURLConnection.HTTP_CLIENT_TIMEOUT) {
+      // 408's are a bit of an outlier because we may repeat the request if we encounter this
+      // response code. In this scenario, there are 2 responses: the initial 408 and then the 200
+      // because of the retry. We just want to ensure the initial 408 isn't cached.
+      expectedResponseCode = 200;
+      server.enqueue(new MockResponse()
+          .setHeader("Cache-Control", "no-store")
+          .setBody("FGHIJ"));
+    }
+
+    server.start();
+
+    URL url = server.url("/").url();
+    HttpURLConnection connection = openConnection(url);
+    assertEquals(expectedResponseCode, connection.getResponseCode());
+
+    // Exhaust the content stream.
+    readAscii(connection);
+
+    CacheResponse cached = cache.get(url.toURI(), "GET", null);
+    if (shouldPut) {
+      assertNotNull(Integer.toString(responseCode), cached);
+    } else {
+      assertNull(Integer.toString(responseCode), cached);
+    }
+    server.shutdown(); // tearDown() isn't sufficient; this test starts multiple servers
+  }
+
+  @Test public void responseCachingAndInputStreamSkipWithFixedLength() throws IOException {
+    testResponseCaching(TransferKind.FIXED_LENGTH);
+  }
+
+  @Test public void responseCachingAndInputStreamSkipWithChunkedEncoding() throws IOException {
+    testResponseCaching(TransferKind.CHUNKED);
+  }
+
+  @Test public void responseCachingAndInputStreamSkipWithNoLengthHeaders() throws IOException {
+    testResponseCaching(TransferKind.END_OF_STREAM);
+  }
+
+  /**
+   * HttpURLConnection.getInputStream().skip(long) causes ResponseCache corruption
+   * http://code.google.com/p/android/issues/detail?id=8175
+   */
+  private void testResponseCaching(TransferKind transferKind) throws IOException {
+    MockResponse mockResponse = new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setStatus("HTTP/1.1 200 Fantastic");
+    transferKind.setBody(mockResponse, "I love puppies but hate spiders", 1);
+    server.enqueue(mockResponse);
+
+    // Make sure that calling skip() doesn't omit bytes from the cache.
+    HttpURLConnection urlConnection = openConnection(server.url("/").url());
+    InputStream in = urlConnection.getInputStream();
+    assertEquals("I love ", readAscii(urlConnection, "I love ".length()));
+    reliableSkip(in, "puppies but hate ".length());
+    assertEquals("spiders", readAscii(urlConnection, "spiders".length()));
+    assertEquals(-1, in.read());
+    in.close();
+
+    urlConnection = openConnection(server.url("/").url()); // cached!
+    in = urlConnection.getInputStream();
+    assertEquals("I love puppies but hate spiders",
+        readAscii(urlConnection, "I love puppies but hate spiders".length()));
+    assertEquals(200, urlConnection.getResponseCode());
+    assertEquals("Fantastic", urlConnection.getResponseMessage());
+
+    assertEquals(-1, in.read());
+    in.close();
+  }
+
+  @Test public void secureResponseCaching() throws IOException {
+    assumeFalse(getPlatform().equals("jdk9"));
+
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setBody("ABC"));
+
+    HttpsURLConnection c1 = (HttpsURLConnection) openConnection(server.url("/").url());
+    c1.setSSLSocketFactory(sslClient.socketFactory);
+    c1.setHostnameVerifier(hostnameVerifier);
+    assertEquals("ABC", readAscii(c1));
+
+    // OpenJDK 6 fails on this line, complaining that the connection isn't open yet
+    String suite = c1.getCipherSuite();
+    List<Certificate> localCerts = toListOrNull(c1.getLocalCertificates());
+    List<Certificate> serverCerts = toListOrNull(c1.getServerCertificates());
+    Principal peerPrincipal = c1.getPeerPrincipal();
+    Principal localPrincipal = c1.getLocalPrincipal();
+
+    HttpsURLConnection c2 = (HttpsURLConnection) openConnection(server.url("/").url()); // cached!
+    c2.setSSLSocketFactory(sslClient.socketFactory);
+    c2.setHostnameVerifier(hostnameVerifier);
+    assertEquals("ABC", readAscii(c2));
+
+    assertEquals(suite, c2.getCipherSuite());
+    assertEquals(localCerts, toListOrNull(c2.getLocalCertificates()));
+    assertEquals(serverCerts, toListOrNull(c2.getServerCertificates()));
+    assertEquals(peerPrincipal, c2.getPeerPrincipal());
+    assertEquals(localPrincipal, c2.getLocalPrincipal());
+  }
+
+  @Test public void responseCachingAndRedirects() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
+        .addHeader("Location: /foo"));
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setBody("ABC"));
+    server.enqueue(new MockResponse()
+        .setBody("DEF"));
+
+    HttpURLConnection connection = openConnection(server.url("/").url());
+    assertEquals("ABC", readAscii(connection));
+
+    connection = openConnection(server.url("/").url()); // cached!
+    assertEquals("ABC", readAscii(connection));
+  }
+
+  @Test public void redirectToCachedResult() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("ABC"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
+        .addHeader("Location: /foo"));
+    server.enqueue(new MockResponse()
+        .setBody("DEF"));
+
+    assertEquals("ABC", readAscii(openConnection(server.url("/foo").url())));
+    RecordedRequest request1 = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", request1.getRequestLine());
+    assertEquals(0, request1.getSequenceNumber());
+
+    assertEquals("ABC", readAscii(openConnection(server.url("/bar").url())));
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals("GET /bar HTTP/1.1", request2.getRequestLine());
+    assertEquals(1, request2.getSequenceNumber());
+
+    // an unrelated request should reuse the pooled connection
+    assertEquals("DEF", readAscii(openConnection(server.url("/baz").url())));
+    RecordedRequest request3 = server.takeRequest();
+    assertEquals("GET /baz HTTP/1.1", request3.getRequestLine());
+    assertEquals(2, request3.getSequenceNumber());
+  }
+
+  @Test public void secureResponseCachingAndRedirects() throws IOException {
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
+        .addHeader("Location: /foo"));
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setBody("ABC"));
+    server.enqueue(new MockResponse()
+        .setBody("DEF"));
+
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(hostnameVerifier)
+        .build());
+
+    HttpsURLConnection connection1 = (HttpsURLConnection) openConnection(server.url("/").url());
+    assertEquals("ABC", readAscii(connection1));
+    assertNotNull(connection1.getCipherSuite());
+
+    // Cached!
+    HttpsURLConnection connection2 = (HttpsURLConnection) openConnection(server.url("/").url());
+    assertEquals("ABC", readAscii(connection2));
+    assertNotNull(connection2.getCipherSuite());
+
+    assertEquals(connection1.getCipherSuite(), connection2.getCipherSuite());
+  }
+
+  /**
+   * We've had bugs where caching and cross-protocol redirects yield class cast exceptions internal
+   * to the cache because we incorrectly assumed that HttpsURLConnection was always HTTPS and
+   * HttpURLConnection was always HTTP; in practice redirects mean that each can do either.
+   *
+   * https://github.com/square/okhttp/issues/214
+   */
+  @Test public void secureResponseCachingAndProtocolRedirects() throws IOException {
+    server2.useHttps(sslClient.socketFactory, false);
+    server2.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setBody("ABC"));
+    server2.enqueue(new MockResponse()
+        .setBody("DEF"));
+
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
+        .addHeader("Location: " + server2.url("/").url()));
+
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(hostnameVerifier)
+        .build());
+
+    HttpURLConnection connection1 = openConnection(server.url("/").url());
+    assertEquals("ABC", readAscii(connection1));
+
+    // Cached!
+    HttpURLConnection connection2 = openConnection(server.url("/").url());
+    assertEquals("ABC", readAscii(connection2));
+  }
+
+  @Test public void foundCachedWithExpiresHeader() throws Exception {
+    temporaryRedirectCachedWithCachingHeader(302, "Expires", formatDate(1, TimeUnit.HOURS));
+  }
+
+  @Test public void foundCachedWithCacheControlHeader() throws Exception {
+    temporaryRedirectCachedWithCachingHeader(302, "Cache-Control", "max-age=60");
+  }
+
+  @Test public void temporaryRedirectCachedWithExpiresHeader() throws Exception {
+    temporaryRedirectCachedWithCachingHeader(307, "Expires", formatDate(1, TimeUnit.HOURS));
+  }
+
+  @Test public void temporaryRedirectCachedWithCacheControlHeader() throws Exception {
+    temporaryRedirectCachedWithCachingHeader(307, "Cache-Control", "max-age=60");
+  }
+
+  @Test public void foundNotCachedWithoutCacheHeader() throws Exception {
+    temporaryRedirectNotCachedWithoutCachingHeader(302);
+  }
+
+  @Test public void temporaryRedirectNotCachedWithoutCacheHeader() throws Exception {
+    temporaryRedirectNotCachedWithoutCachingHeader(307);
+  }
+
+  private void temporaryRedirectCachedWithCachingHeader(
+      int responseCode, String headerName, String headerValue) throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(responseCode)
+        .addHeader(headerName, headerValue)
+        .addHeader("Location", "/a"));
+    server.enqueue(new MockResponse()
+        .addHeader(headerName, headerValue)
+        .setBody("a"));
+    server.enqueue(new MockResponse()
+        .setBody("b"));
+    server.enqueue(new MockResponse()
+        .setBody("c"));
+
+    URL url = server.url("/").url();
+    assertEquals("a", readAscii(openConnection(url)));
+    assertEquals("a", readAscii(openConnection(url)));
+  }
+
+  private void temporaryRedirectNotCachedWithoutCachingHeader(int responseCode) throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(responseCode)
+        .addHeader("Location", "/a"));
+    server.enqueue(new MockResponse()
+        .setBody("a"));
+    server.enqueue(new MockResponse()
+        .setBody("b"));
+
+    URL url = server.url("/").url();
+    assertEquals("a", readAscii(openConnection(url)));
+    assertEquals("b", readAscii(openConnection(url)));
+  }
+
+  @Test public void serverDisconnectsPrematurelyWithContentLengthHeader() throws IOException {
+    testServerPrematureDisconnect(TransferKind.FIXED_LENGTH);
+  }
+
+  @Test public void serverDisconnectsPrematurelyWithChunkedEncoding() throws IOException {
+    testServerPrematureDisconnect(TransferKind.CHUNKED);
+  }
+
+  @Test public void serverDisconnectsPrematurelyWithNoLengthHeaders() throws IOException {
+    // Intentionally empty. This case doesn't make sense because there's no
+    // such thing as a premature disconnect when the disconnect itself
+    // indicates the end of the data stream.
+  }
+
+  private void testServerPrematureDisconnect(TransferKind transferKind) throws IOException {
+    MockResponse response = new MockResponse();
+    transferKind.setBody(response, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 16);
+    server.enqueue(truncateViolently(response, 16));
+    server.enqueue(new MockResponse()
+        .setBody("Request #2"));
+
+    BufferedReader reader = new BufferedReader(
+        new InputStreamReader(openConnection(server.url("/").url()).getInputStream()));
+    assertEquals("ABCDE", reader.readLine());
+    try {
+      reader.readLine();
+      fail("This implementation silently ignored a truncated HTTP body.");
+    } catch (IOException expected) {
+    } finally {
+      reader.close();
+    }
+
+    URLConnection connection = openConnection(server.url("/").url());
+    assertEquals("Request #2", readAscii(connection));
+  }
+
+  @Test public void clientPrematureDisconnectWithContentLengthHeader() throws IOException {
+    testClientPrematureDisconnect(TransferKind.FIXED_LENGTH);
+  }
+
+  @Test public void clientPrematureDisconnectWithChunkedEncoding() throws IOException {
+    testClientPrematureDisconnect(TransferKind.CHUNKED);
+  }
+
+  @Test public void clientPrematureDisconnectWithNoLengthHeaders() throws IOException {
+    testClientPrematureDisconnect(TransferKind.END_OF_STREAM);
+  }
+
+  private void testClientPrematureDisconnect(TransferKind transferKind) throws IOException {
+    // Setting a low transfer speed ensures that stream discarding will time out.
+    MockResponse response = new MockResponse()
+        .throttleBody(6, 1, TimeUnit.SECONDS);
+    transferKind.setBody(response, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 1024);
+    server.enqueue(response);
+    server.enqueue(new MockResponse()
+        .setBody("Request #2"));
+
+    URLConnection connection = openConnection(server.url("/").url());
+    InputStream in = connection.getInputStream();
+    assertEquals("ABCDE", readAscii(connection, 5));
+    in.close();
+    try {
+      in.read();
+      fail("Expected an IOException because the stream is closed.");
+    } catch (IOException expected) {
+    }
+
+    connection = openConnection(server.url("/").url());
+    assertEquals("Request #2", readAscii(connection));
+  }
+
+  @Test public void defaultExpirationDateFullyCachedForLessThan24Hours() throws Exception {
+    //      last modified: 105 seconds ago
+    //             served:   5 seconds ago
+    //   default lifetime: (105 - 5) / 10 = 10 seconds
+    //            expires:  10 seconds from served date = 5 seconds from now
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
+        .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
+        .setBody("A"));
+
+    URL url = server.url("/").url();
+    assertEquals("A", readAscii(openConnection(url)));
+    URLConnection connection = openConnection(url);
+    assertEquals("A", readAscii(connection));
+    assertNull(connection.getHeaderField("Warning"));
+  }
+
+  @Test public void defaultExpirationDateConditionallyCached() throws Exception {
+    //      last modified: 115 seconds ago
+    //             served:  15 seconds ago
+    //   default lifetime: (115 - 15) / 10 = 10 seconds
+    //            expires:  10 seconds from served date = 5 seconds ago
+    String lastModifiedDate = formatDate(-115, TimeUnit.SECONDS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
+        .addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Date: " + formatDate(-15, TimeUnit.SECONDS)));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+  }
+
+  @Test public void defaultExpirationDateFullyCachedForMoreThan24Hours() throws Exception {
+    //      last modified: 105 days ago
+    //             served:   5 days ago
+    //   default lifetime: (105 - 5) / 10 = 10 days
+    //            expires:  10 days from served date = 5 days from now
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-105, TimeUnit.DAYS))
+        .addHeader("Date: " + formatDate(-5, TimeUnit.DAYS))
+        .setBody("A"));
+
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+    URLConnection connection = openConnection(server.url("/").url());
+    assertEquals("A", readAscii(connection));
+    assertEquals("113 HttpURLConnection \"Heuristic expiration\"",
+        connection.getHeaderField("Warning"));
+  }
+
+  @Test public void noDefaultExpirationForUrlsWithQueryString() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
+        .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.url("/?foo=bar").url();
+    assertEquals("A", readAscii(openConnection(url)));
+    assertEquals("B", readAscii(openConnection(url)));
+  }
+
+  @Test public void expirationDateInThePastWithLastModifiedHeader() throws Exception {
+    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
+        .addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+  }
+
+  @Test public void expirationDateInThePastWithNoLastModifiedHeader() throws Exception {
+    assertNotCached(new MockResponse()
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+  }
+
+  @Test public void expirationDateInTheFuture() throws Exception {
+    assertFullyCached(new MockResponse()
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+  }
+
+  @Test public void maxAgePreferredWithMaxAgeAndExpires() throws Exception {
+    assertFullyCached(new MockResponse()
+        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgeInThePastWithDateAndLastModifiedHeaders() throws Exception {
+    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
+        .addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
+        .addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Cache-Control: max-age=60"));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+  }
+
+  @Test public void maxAgeInThePastWithDateHeaderButNoLastModifiedHeader() throws Exception {
+    // Chrome interprets max-age relative to the local clock. Both our cache
+    // and Firefox both use the earlier of the local and server's clock.
+    assertNotCached(new MockResponse()
+        .addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgeInTheFutureWithDateHeader() throws Exception {
+    assertFullyCached(new MockResponse()
+        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgeInTheFutureWithNoDateHeader() throws Exception {
+    assertFullyCached(new MockResponse()
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgeWithLastModifiedButNoServedDate() throws Exception {
+    assertFullyCached(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgeInTheFutureWithDateAndLastModifiedHeaders() throws Exception {
+    assertFullyCached(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
+        .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgePreferredOverLowerSharedMaxAge() throws Exception {
+    assertFullyCached(new MockResponse()
+        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
+        .addHeader("Cache-Control: s-maxage=60")
+        .addHeader("Cache-Control: max-age=180"));
+  }
+
+  @Test public void maxAgePreferredOverHigherMaxAge() throws Exception {
+    assertNotCached(new MockResponse()
+        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
+        .addHeader("Cache-Control: s-maxage=180")
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void requestMethodOptionsIsNotCached() throws Exception {
+    testRequestMethod("OPTIONS", false);
+  }
+
+  @Test public void requestMethodGetIsCached() throws Exception {
+    testRequestMethod("GET", true);
+  }
+
+  @Test public void requestMethodHeadIsNotCached() throws Exception {
+    // We could support this but choose not to for implementation simplicity
+    testRequestMethod("HEAD", false);
+  }
+
+  @Test public void requestMethodPostIsNotCached() throws Exception {
+    // We could support this but choose not to for implementation simplicity
+    testRequestMethod("POST", false);
+  }
+
+  @Test public void requestMethodPutIsNotCached() throws Exception {
+    testRequestMethod("PUT", false);
+  }
+
+  @Test public void requestMethodDeleteIsNotCached() throws Exception {
+    testRequestMethod("DELETE", false);
+  }
+
+  @Test public void requestMethodTraceIsNotCached() throws Exception {
+    testRequestMethod("TRACE", false);
+  }
+
+  private void testRequestMethod(String requestMethod, boolean expectCached) throws Exception {
+    // 1. seed the cache (potentially)
+    // 2. expect a cache hit or miss
+    server.enqueue(new MockResponse()
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .addHeader("X-Response-ID: 1"));
+    server.enqueue(new MockResponse()
+        .addHeader("X-Response-ID: 2"));
+
+    URL url = server.url("/").url();
+
+    HttpURLConnection request1 = openConnection(url);
+    request1.setRequestMethod(requestMethod);
+    addRequestBodyIfNecessary(requestMethod, request1);
+    request1.getInputStream().close();
+    assertEquals("1", request1.getHeaderField("X-Response-ID"));
+
+    URLConnection request2 = openConnection(url);
+    request2.getInputStream().close();
+    if (expectCached) {
+      assertEquals("1", request2.getHeaderField("X-Response-ID"));
+    } else {
+      assertEquals("2", request2.getHeaderField("X-Response-ID"));
+    }
+  }
+
+  private void addRequestBodyIfNecessary(String requestMethod, HttpURLConnection connection)
+      throws IOException {
+    if (requestMethod.equals("POST") || requestMethod.equals("PUT")) {
+      connection.setDoOutput(true);
+      OutputStream requestBody = connection.getOutputStream();
+      requestBody.write('x');
+      requestBody.close();
+    }
+  }
+
+  @Test public void postInvalidatesCache() throws Exception {
+    testMethodInvalidates("POST");
+  }
+
+  @Test public void putInvalidatesCache() throws Exception {
+    testMethodInvalidates("PUT");
+  }
+
+  @Test public void deleteMethodInvalidatesCache() throws Exception {
+    testMethodInvalidates("DELETE");
+  }
+
+  private void testMethodInvalidates(String requestMethod) throws Exception {
+    // 1. seed the cache
+    // 2. invalidate it
+    // 3. expect a cache miss
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+    server.enqueue(new MockResponse()
+        .setBody("C"));
+
+    URL url = server.url("/").url();
+
+    assertEquals("A", readAscii(openConnection(url)));
+
+    HttpURLConnection invalidateConnection = openConnection(url);
+    invalidateConnection.setRequestMethod(requestMethod);
+    assertEquals("B", readAscii(invalidateConnection));
+
+    assertEquals("C", readAscii(openConnection(url)));
+  }
+
+  /**
+   * Equivalent to {@code CacheTest.postInvalidatesCacheWithUncacheableResponse()} but demonstrating
+   * that {@link ResponseCache} provides no mechanism for cache invalidation as the result of
+   * locally-made requests. In reality invalidation could take place from other clients at any
+   * time.
+   */
+  @Test public void postInvalidatesCacheWithUncacheableResponse() throws Exception {
+    // 1. seed the cache
+    // 2. invalidate it with uncacheable response
+    // 3. the cache to return the original value
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse()
+        .setBody("B")
+        .setResponseCode(500));
+
+    URL url = server.url("/").url();
+
+    assertEquals("A", readAscii(openConnection(url)));
+
+    HttpURLConnection invalidate = openConnection(url);
+    invalidate.setRequestMethod("POST");
+    addRequestBodyIfNecessary("POST", invalidate);
+    assertEquals("B", readAscii(invalidate));
+
+    assertEquals("A", readAscii(openConnection(url)));
+  }
+
+  @Test public void etag() throws Exception {
+    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
+        .addHeader("ETag: v1"));
+    assertEquals("v1", conditionalRequest.getHeader("If-None-Match"));
+  }
+
+  /** If both If-Modified-Since and If-None-Match conditions apply, send only If-None-Match. */
+  @Test public void etagAndExpirationDateInThePast() throws Exception {
+    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
+        .addHeader("ETag: v1")
+        .addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    assertEquals("v1", conditionalRequest.getHeader("If-None-Match"));
+    assertNull(conditionalRequest.getHeader("If-Modified-Since"));
+  }
+
+  @Test public void etagAndExpirationDateInTheFuture() throws Exception {
+    assertFullyCached(new MockResponse()
+        .addHeader("ETag: v1")
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+  }
+
+  @Test public void cacheControlNoCache() throws Exception {
+    assertNotCached(new MockResponse()
+        .addHeader("Cache-Control: no-cache"));
+  }
+
+  @Test public void cacheControlNoCacheAndExpirationDateInTheFuture() throws Exception {
+    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
+        .addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: no-cache"));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+  }
+
+  @Test public void pragmaNoCache() throws Exception {
+    assertNotCached(new MockResponse()
+        .addHeader("Pragma: no-cache"));
+  }
+
+  @Test public void pragmaNoCacheAndExpirationDateInTheFuture() throws Exception {
+    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
+        .addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .addHeader("Pragma: no-cache"));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+  }
+
+  @Test public void cacheControlNoStore() throws Exception {
+    assertNotCached(new MockResponse()
+        .addHeader("Cache-Control: no-store"));
+  }
+
+  @Test public void cacheControlNoStoreAndExpirationDateInTheFuture() throws Exception {
+    assertNotCached(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: no-store"));
+  }
+
+  @Test public void partialRangeResponsesDoNotCorruptCache() throws Exception {
+    // 1. request a range
+    // 2. request a full document, expecting a cache miss
+    server.enqueue(new MockResponse()
+        .setBody("AA")
+        .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .addHeader("Content-Range: bytes 1000-1001/2000"));
+    server.enqueue(new MockResponse()
+        .setBody("BB"));
+
+    URL url = server.url("/").url();
+
+    HttpURLConnection range = openConnection(url);
+    range.addRequestProperty("Range", "bytes=1000-1001");
+    assertEquals("AA", readAscii(range));
+
+    assertEquals("BB", readAscii(openConnection(url)));
+  }
+
+  @Test public void serverReturnsDocumentOlderThanCache() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse()
+        .setBody("B")
+        .addHeader("Last-Modified: " + formatDate(-4, TimeUnit.HOURS)));
+
+    URL url = server.url("/").url();
+
+    assertEquals("A", readAscii(openConnection(url)));
+    assertEquals("B", readAscii(openConnection(url)));
+  }
+
+  @Test public void clientSideNoStore() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("B"));
+
+    HttpURLConnection connection1 = openConnection(server.url("/").url());
+    connection1.setRequestProperty("Cache-Control", "no-store");
+    assertEquals("A", readAscii(connection1));
+
+    HttpURLConnection connection2 = openConnection(server.url("/").url());
+    assertEquals("B", readAscii(connection2));
+  }
+
+  @Test public void nonIdentityEncodingAndConditionalCache() throws Exception {
+    assertNonIdentityEncodingCached(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+  }
+
+  @Test public void nonIdentityEncodingAndFullCache() throws Exception {
+    assertNonIdentityEncodingCached(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+  }
+
+  private void assertNonIdentityEncodingCached(MockResponse response) throws Exception {
+    server.enqueue(response
+        .setBody(gzip("ABCABCABC"))
+        .addHeader("Content-Encoding: gzip"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    // At least three request/response pairs are required because after the first request is cached
+    // a different execution path might be taken. Thus modifications to the cache applied during
+    // the second request might not be visible until another request is performed.
+    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
+    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
+    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
+  }
+
+  @Test public void notModifiedSpecifiesEncoding() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(gzip("ABCABCABC"))
+        .addHeader("Content-Encoding: gzip")
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
+        .addHeader("Content-Encoding: gzip"));
+    server.enqueue(new MockResponse()
+        .setBody("DEFDEFDEF"));
+
+    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
+    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
+    assertEquals("DEFDEFDEF", readAscii(openConnection(server.url("/").url())));
+  }
+
+  /** https://github.com/square/okhttp/issues/947 */
+  @Test public void gzipAndVaryOnAcceptEncoding() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(gzip("ABCABCABC"))
+        .addHeader("Content-Encoding: gzip")
+        .addHeader("Vary: Accept-Encoding")
+        .addHeader("Cache-Control: max-age=60"));
+    server.enqueue(new MockResponse()
+        .setBody("FAIL"));
+
+    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
+    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
+  }
+
+  @Test public void expiresDateBeforeModifiedDate() throws Exception {
+    assertConditionallyCached(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(-2, TimeUnit.HOURS)));
+  }
+
+  @Test public void requestMaxAge() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+
+    URLConnection connection = openConnection(server.url("/").url());
+    connection.addRequestProperty("Cache-Control", "max-age=30");
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void requestMinFresh() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+
+    URLConnection connection = openConnection(server.url("/").url());
+    connection.addRequestProperty("Cache-Control", "min-fresh=120");
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void requestMaxStale() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Cache-Control: max-age=120")
+        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+
+    URLConnection connection = openConnection(server.url("/").url());
+    connection.addRequestProperty("Cache-Control", "max-stale=180");
+    assertEquals("A", readAscii(connection));
+    assertEquals("110 HttpURLConnection \"Response is stale\"",
+        connection.getHeaderField("Warning"));
+  }
+
+  @Test public void requestMaxStaleDirectiveWithNoValue() throws IOException {
+    // Add a stale response to the cache.
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Cache-Control: max-age=120")
+        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+
+    // With max-stale, we'll return that stale response.
+    URLConnection maxStaleConnection = openConnection(server.url("/").url());
+    maxStaleConnection.setRequestProperty("Cache-Control", "max-stale");
+    assertEquals("A", readAscii(maxStaleConnection));
+    assertEquals("110 HttpURLConnection \"Response is stale\"",
+        maxStaleConnection.getHeaderField("Warning"));
+  }
+
+  @Test public void requestMaxStaleNotHonoredWithMustRevalidate() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Cache-Control: max-age=120, must-revalidate")
+        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+
+    URLConnection connection = openConnection(server.url("/").url());
+    connection.addRequestProperty("Cache-Control", "max-stale=180");
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void requestOnlyIfCachedWithNoResponseCached() throws IOException {
+    // (no responses enqueued)
+
+    HttpURLConnection connection = openConnection(server.url("/").url());
+    connection.addRequestProperty("Cache-Control", "only-if-cached");
+    assertGatewayTimeout(connection);
+  }
+
+  @Test public void requestOnlyIfCachedWithFullResponseCached() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+    URLConnection connection = openConnection(server.url("/").url());
+    connection.addRequestProperty("Cache-Control", "only-if-cached");
+    assertEquals("A", readAscii(connection));
+  }
+
+  @Test public void requestOnlyIfCachedWithConditionalResponseCached() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES)));
+
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+    HttpURLConnection connection = openConnection(server.url("/").url());
+    connection.addRequestProperty("Cache-Control", "only-if-cached");
+    assertGatewayTimeout(connection);
+  }
+
+  @Test public void requestOnlyIfCachedWithUnhelpfulResponseCached() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A"));
+
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+    HttpURLConnection connection = openConnection(server.url("/").url());
+    connection.addRequestProperty("Cache-Control", "only-if-cached");
+    assertGatewayTimeout(connection);
+  }
+
+  @Test public void requestCacheControlNoCache() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
+        .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    URL url = server.url("/").url();
+    assertEquals("A", readAscii(openConnection(url)));
+    URLConnection connection = openConnection(url);
+    connection.setRequestProperty("Cache-Control", "no-cache");
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void requestPragmaNoCache() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
+        .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    URL url = server.url("/").url();
+    assertEquals("A", readAscii(openConnection(url)));
+    URLConnection connection = openConnection(url);
+    connection.setRequestProperty("Pragma", "no-cache");
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void clientSuppliedIfModifiedSinceWithCachedResult() throws Exception {
+    MockResponse response = new MockResponse()
+        .addHeader("ETag: v3")
+        .addHeader("Cache-Control: max-age=0");
+    String ifModifiedSinceDate = formatDate(-24, TimeUnit.HOURS);
+    RecordedRequest request =
+        assertClientSuppliedCondition(response, "If-Modified-Since", ifModifiedSinceDate);
+    assertEquals(ifModifiedSinceDate, request.getHeader("If-Modified-Since"));
+    assertNull(request.getHeader("If-None-Match"));
+  }
+
+  @Test public void clientSuppliedIfNoneMatchSinceWithCachedResult() throws Exception {
+    String lastModifiedDate = formatDate(-3, TimeUnit.MINUTES);
+    MockResponse response = new MockResponse()
+        .addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
+        .addHeader("Cache-Control: max-age=0");
+    RecordedRequest request = assertClientSuppliedCondition(response, "If-None-Match", "v1");
+    assertEquals("v1", request.getHeader("If-None-Match"));
+    assertNull(request.getHeader("If-Modified-Since"));
+  }
+
+  private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String conditionName,
+      String conditionValue) throws Exception {
+    server.enqueue(seed.setBody("A"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    URL url = server.url("/").url();
+    assertEquals("A", readAscii(openConnection(url)));
+
+    HttpURLConnection connection = openConnection(url);
+    connection.addRequestProperty(conditionName, conditionValue);
+    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection.getResponseCode());
+    assertEquals("", readAscii(connection));
+
+    server.takeRequest(); // seed
+    return server.takeRequest();
+  }
+
+  /**
+   * For Last-Modified and Date headers, we should echo the date back in the exact format we were
+   * served.
+   */
+  @Test public void retainServedDateFormat() throws Exception {
+    // Serve a response with a non-standard date format that OkHttp supports.
+    Date lastModifiedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-1));
+    Date servedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-2));
+    DateFormat dateFormat = new SimpleDateFormat("EEE dd-MMM-yyyy HH:mm:ss z", Locale.US);
+    dateFormat.setTimeZone(TimeZone.getTimeZone("EDT"));
+    String lastModifiedString = dateFormat.format(lastModifiedDate);
+    String servedString = dateFormat.format(servedDate);
+
+    // This response should be conditionally cached.
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + lastModifiedString)
+        .addHeader("Expires: " + servedString)
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+
+    // The first request has no conditions.
+    RecordedRequest request1 = server.takeRequest();
+    assertNull(request1.getHeader("If-Modified-Since"));
+
+    // The 2nd request uses the server's date format.
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals(lastModifiedString, request2.getHeader("If-Modified-Since"));
+  }
+
+  @Test public void clientSuppliedConditionWithoutCachedResult() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    HttpURLConnection connection = openConnection(server.url("/").url());
+    String clientIfModifiedSince = formatDate(-24, TimeUnit.HOURS);
+    connection.addRequestProperty("If-Modified-Since", clientIfModifiedSince);
+    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection.getResponseCode());
+    assertEquals("", readAscii(connection));
+  }
+
+  @Test public void authorizationRequestFullyCached() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.url("/").url();
+    URLConnection connection = openConnection(url);
+    connection.addRequestProperty("Authorization", "password");
+    assertEquals("A", readAscii(connection));
+    assertEquals("A", readAscii(openConnection(url)));
+  }
+
+  @Test public void contentLocationDoesNotPopulateCache() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Content-Location: /bar")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", readAscii(openConnection(server.url("/foo").url())));
+    assertEquals("B", readAscii(openConnection(server.url("/bar").url())));
+  }
+
+  @Test public void connectionIsReturnedToPoolAfterConditionalSuccess() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", readAscii(openConnection(server.url("/a").url())));
+    assertEquals("A", readAscii(openConnection(server.url("/a").url())));
+    assertEquals("B", readAscii(openConnection(server.url("/b").url())));
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertEquals(2, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void varyMatchesChangedRequestHeaderField() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.url("/").url();
+    HttpURLConnection frenchConnection = openConnection(url);
+    frenchConnection.setRequestProperty("Accept-Language", "fr-CA");
+    assertEquals("A", readAscii(frenchConnection));
+
+    HttpURLConnection englishConnection = openConnection(url);
+    englishConnection.setRequestProperty("Accept-Language", "en-US");
+    assertEquals("B", readAscii(englishConnection));
+  }
+
+  @Test public void varyMatchesUnchangedRequestHeaderField() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.url("/").url();
+    HttpURLConnection frenchConnection1 = openConnection(url);
+    frenchConnection1.setRequestProperty("Accept-Language", "fr-CA");
+    assertEquals("A", readAscii(frenchConnection1));
+
+    HttpURLConnection frenchConnection2 = openConnection(url);
+    frenchConnection2.setRequestProperty("Accept-Language", "fr-CA");
+    assertEquals("A", readAscii(frenchConnection2));
+  }
+
+  @Test public void varyMatchesAbsentRequestHeaderField() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Foo")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+  }
+
+  @Test public void varyMatchesAddedRequestHeaderField() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Foo")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+    HttpURLConnection connection2 = openConnection(server.url("/").url());
+    connection2.setRequestProperty("Foo", "bar");
+    assertEquals("B", readAscii(connection2));
+  }
+
+  @Test public void varyMatchesRemovedRequestHeaderField() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Foo")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    HttpURLConnection connection1 = openConnection(server.url("/").url());
+    connection1.setRequestProperty("Foo", "bar");
+    assertEquals("A", readAscii(connection1));
+    assertEquals("B", readAscii(openConnection(server.url("/").url())));
+  }
+
+  @Test public void varyFieldsAreCaseInsensitive() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: ACCEPT-LANGUAGE")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.url("/").url();
+    HttpURLConnection frenchConnection1 = openConnection(url);
+    frenchConnection1.setRequestProperty("Accept-Language", "fr-CA");
+    assertEquals("A", readAscii(frenchConnection1));
+    HttpURLConnection frenchConnection2 = openConnection(url);
+    frenchConnection2.setRequestProperty("accept-language", "fr-CA");
+    assertEquals("A", readAscii(frenchConnection2));
+  }
+
+  @Test public void varyMultipleFieldsWithMatch() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language, Accept-Charset")
+        .addHeader("Vary: Accept-Encoding")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.url("/").url();
+    HttpURLConnection frenchConnection1 = openConnection(url);
+    frenchConnection1.setRequestProperty("Accept-Language", "fr-CA");
+    frenchConnection1.setRequestProperty("Accept-Charset", "UTF-8");
+    frenchConnection1.setRequestProperty("Accept-Encoding", "identity");
+    assertEquals("A", readAscii(frenchConnection1));
+    HttpURLConnection frenchConnection2 = openConnection(url);
+    frenchConnection2.setRequestProperty("Accept-Language", "fr-CA");
+    frenchConnection2.setRequestProperty("Accept-Charset", "UTF-8");
+    frenchConnection2.setRequestProperty("Accept-Encoding", "identity");
+    assertEquals("A", readAscii(frenchConnection2));
+  }
+
+  @Test public void varyMultipleFieldsWithNoMatch() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language, Accept-Charset")
+        .addHeader("Vary: Accept-Encoding")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.url("/").url();
+    HttpURLConnection frenchConnection = openConnection(url);
+    frenchConnection.setRequestProperty("Accept-Language", "fr-CA");
+    frenchConnection.setRequestProperty("Accept-Charset", "UTF-8");
+    frenchConnection.setRequestProperty("Accept-Encoding", "identity");
+    assertEquals("A", readAscii(frenchConnection));
+    HttpURLConnection englishConnection = openConnection(url);
+    englishConnection.setRequestProperty("Accept-Language", "en-CA");
+    englishConnection.setRequestProperty("Accept-Charset", "UTF-8");
+    englishConnection.setRequestProperty("Accept-Encoding", "identity");
+    assertEquals("B", readAscii(englishConnection));
+  }
+
+  @Test public void varyMultipleFieldValuesWithMatch() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.url("/").url();
+    HttpURLConnection multiConnection1 = openConnection(url);
+    multiConnection1.setRequestProperty("Accept-Language", "fr-CA, fr-FR");
+    multiConnection1.addRequestProperty("Accept-Language", "en-US");
+    assertEquals("A", readAscii(multiConnection1));
+
+    HttpURLConnection multiConnection2 = openConnection(url);
+    multiConnection2.setRequestProperty("Accept-Language", "fr-CA, fr-FR");
+    multiConnection2.addRequestProperty("Accept-Language", "en-US");
+    assertEquals("A", readAscii(multiConnection2));
+  }
+
+  @Test public void varyMultipleFieldValuesWithNoMatch() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.url("/").url();
+    HttpURLConnection multiConnection = openConnection(url);
+    multiConnection.setRequestProperty("Accept-Language", "fr-CA, fr-FR");
+    multiConnection.addRequestProperty("Accept-Language", "en-US");
+    assertEquals("A", readAscii(multiConnection));
+
+    HttpURLConnection notFrenchConnection = openConnection(url);
+    notFrenchConnection.setRequestProperty("Accept-Language", "fr-CA");
+    notFrenchConnection.addRequestProperty("Accept-Language", "en-US");
+    assertEquals("B", readAscii(notFrenchConnection));
+  }
+
+  @Test public void varyAsterisk() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: *")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+    assertEquals("B", readAscii(openConnection(server.url("/").url())));
+  }
+
+  @Test public void varyAndHttps() throws Exception {
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(hostnameVerifier)
+        .build());
+
+    URL url = server.url("/").url();
+    HttpURLConnection connection1 = openConnection(url);
+    connection1.setRequestProperty("Accept-Language", "en-US");
+    assertEquals("A", readAscii(connection1));
+
+    HttpURLConnection connection2 = openConnection(url);
+    connection2.setRequestProperty("Accept-Language", "en-US");
+    assertEquals("A", readAscii(connection2));
+  }
+
+  @Test public void getHeadersReturnsNetworkEndToEndHeaders() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Allow: GET, HEAD")
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .addHeader("Allow: GET, HEAD, PUT")
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    URLConnection connection1 = openConnection(server.url("/").url());
+    assertEquals("A", readAscii(connection1));
+    assertEquals("GET, HEAD", connection1.getHeaderField("Allow"));
+
+    URLConnection connection2 = openConnection(server.url("/").url());
+    assertEquals("A", readAscii(connection2));
+    assertEquals("GET, HEAD, PUT", connection2.getHeaderField("Allow"));
+  }
+
+  @Test public void getHeadersReturnsCachedHopByHopHeaders() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Transfer-Encoding: identity")
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .addHeader("Transfer-Encoding: none")
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    URLConnection connection1 = openConnection(server.url("/").url());
+    assertEquals("A", readAscii(connection1));
+    assertEquals("identity", connection1.getHeaderField("Transfer-Encoding"));
+
+    URLConnection connection2 = openConnection(server.url("/").url());
+    assertEquals("A", readAscii(connection2));
+    assertEquals("identity", connection2.getHeaderField("Transfer-Encoding"));
+  }
+
+  @Test public void getHeadersDeletesCached100LevelWarnings() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Warning: 199 test danger")
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    URLConnection connection1 = openConnection(server.url("/").url());
+    assertEquals("A", readAscii(connection1));
+    assertEquals("199 test danger", connection1.getHeaderField("Warning"));
+
+    URLConnection connection2 = openConnection(server.url("/").url());
+    assertEquals("A", readAscii(connection2));
+    assertEquals(null, connection2.getHeaderField("Warning"));
+  }
+
+  @Test public void getHeadersRetainsCached200LevelWarnings() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Warning: 299 test danger")
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    URLConnection connection1 = openConnection(server.url("/").url());
+    assertEquals("A", readAscii(connection1));
+    assertEquals("299 test danger", connection1.getHeaderField("Warning"));
+
+    URLConnection connection2 = openConnection(server.url("/").url());
+    assertEquals("A", readAscii(connection2));
+    assertEquals("299 test danger", connection2.getHeaderField("Warning"));
+  }
+
+  public void assertCookies(URL url, String... expectedCookies) throws Exception {
+    List<String> actualCookies = new ArrayList<>();
+    for (HttpCookie cookie : cookieManager.getCookieStore().get(url.toURI())) {
+      actualCookies.add(cookie.toString());
+    }
+    assertEquals(Arrays.asList(expectedCookies), actualCookies);
+  }
+
+  @Test public void doNotCachePartialResponse() throws Exception {
+    assertNotCached(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
+        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
+        .addHeader("Content-Range: bytes 100-100/200")
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  /**
+   * Equivalent to {@code CacheTest.conditionalHitUpdatesCache()}, except a Java standard cache has
+   * no means to update the headers for an existing entry so the behavior is different.
+   */
+  @Test public void conditionalHitDoesNotUpdateCache() throws Exception {
+    // A response that is cacheable, but with a short life.
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(0, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    // A response that refers to the previous response, but is cacheable with a long life.
+    // Contains a header we can recognize as having come from the server.
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Allow: GET, HEAD")
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    // A response that is cacheable with a long life.
+    server.enqueue(new MockResponse()
+        .setBody("B")
+        .addHeader("Cache-Control: max-age=30"));
+    // A response that should never be requested.
+    server.enqueue(new MockResponse()
+        .setBody("C"));
+
+    // cache miss; seed the cache with an entry that will require a network hit to be sure it is
+    // still valid
+    HttpURLConnection connection1 = openConnection(server.url("/a").url());
+    assertEquals("A", readAscii(connection1));
+    assertEquals(null, connection1.getHeaderField("Allow"));
+
+    // conditional cache hit; The cached data should be returned, but the cache is not updated.
+    HttpURLConnection connection2 = openConnection(server.url("/a").url());
+    assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
+    assertEquals("A", readAscii(connection2));
+    assertEquals("GET, HEAD", connection2.getHeaderField("Allow"));
+
+    // conditional cache hit; The server responds with new data. The cache is updated.
+    HttpURLConnection connection3 = openConnection(server.url("/a").url());
+    assertEquals("B", readAscii(connection3));
+
+    // full cache hit; The data from connection3 has now replaced that from connection 1.
+    HttpURLConnection connection4 = openConnection(server.url("/a").url());
+    assertEquals("B", readAscii(connection4));
+
+    assertEquals(3, server.getRequestCount());
+  }
+
+  @Test public void responseSourceHeaderCached() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+    URLConnection connection = openConnection(server.url("/").url());
+    connection.addRequestProperty("Cache-Control", "only-if-cached");
+    assertEquals("A", readAscii(connection));
+  }
+
+  @Test public void responseSourceHeaderConditionalCacheFetched() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Date: " + formatDate(-31, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse()
+        .setBody("B")
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+    HttpURLConnection connection = openConnection(server.url("/").url());
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void responseSourceHeaderConditionalCacheNotFetched() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Cache-Control: max-age=0")
+        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse()
+        .setResponseCode(304));
+
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+    HttpURLConnection connection = openConnection(server.url("/").url());
+    assertEquals("A", readAscii(connection));
+  }
+
+  @Test public void responseSourceHeaderFetched() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A"));
+
+    URLConnection connection = openConnection(server.url("/").url());
+    assertEquals("A", readAscii(connection));
+  }
+
+  @Test public void emptyResponseHeaderNameFromCacheIsLenient() throws Exception {
+    Headers.Builder headers = new Headers.Builder()
+        .add("Cache-Control: max-age=120");
+    Internal.instance.addLenient(headers, ": A");
+    server.enqueue(new MockResponse()
+        .setHeaders(headers.build())
+        .setBody("body"));
+
+    HttpURLConnection connection = openConnection(server.url("/").url());
+    assertEquals("A", connection.getHeaderField(""));
+  }
+
+  /**
+   * @param delta the offset from the current date to use. Negative values yield dates in the past;
+   * positive values yield dates in the future.
+   */
+  private String formatDate(long delta, TimeUnit timeUnit) {
+    return formatDate(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
+  }
+
+  private String formatDate(Date date) {
+    DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
+    rfc1123.setTimeZone(TimeZone.getTimeZone("GMT"));
+    return rfc1123.format(date);
+  }
+
+  private void assertNotCached(MockResponse response) throws Exception {
+    server.enqueue(response.setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.url("/").url();
+    assertEquals("A", readAscii(openConnection(url)));
+    assertEquals("B", readAscii(openConnection(url)));
+  }
+
+  /** @return the request with the conditional get headers. */
+  private RecordedRequest assertConditionallyCached(MockResponse response) throws Exception {
+    // scenario 1: condition succeeds
+    server.enqueue(response.setBody("A").setStatus("HTTP/1.1 200 A-OK"));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    // scenario 2: condition fails
+    server.enqueue(response.setBody("B").setStatus("HTTP/1.1 200 B-OK"));
+    server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 C-OK").setBody("C"));
+
+    URL valid = server.url("/valid").url();
+    HttpURLConnection connection1 = openConnection(valid);
+    assertEquals("A", readAscii(connection1));
+    assertEquals(HttpURLConnection.HTTP_OK, connection1.getResponseCode());
+    assertEquals("A-OK", connection1.getResponseMessage());
+    HttpURLConnection connection2 = openConnection(valid);
+    assertEquals("A", readAscii(connection2));
+    assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
+    assertEquals("A-OK", connection2.getResponseMessage());
+
+    URL invalid = server.url("/invalid").url();
+    HttpURLConnection connection3 = openConnection(invalid);
+    assertEquals("B", readAscii(connection3));
+    assertEquals(HttpURLConnection.HTTP_OK, connection3.getResponseCode());
+    assertEquals("B-OK", connection3.getResponseMessage());
+    HttpURLConnection connection4 = openConnection(invalid);
+    assertEquals("C", readAscii(connection4));
+    assertEquals(HttpURLConnection.HTTP_OK, connection4.getResponseCode());
+    assertEquals("C-OK", connection4.getResponseMessage());
+
+    server.takeRequest(); // regular get
+    return server.takeRequest(); // conditional get
+  }
+
+  private void assertFullyCached(MockResponse response) throws Exception {
+    server.enqueue(response.setBody("A"));
+    server.enqueue(response.setBody("B"));
+
+    URL url = server.url("/").url();
+    assertEquals("A", readAscii(openConnection(url)));
+    assertEquals("A", readAscii(openConnection(url)));
+  }
+
+  /**
+   * Shortens the body of {@code response} but not the corresponding headers. Only useful to test
+   * how clients respond to the premature conclusion of the HTTP body.
+   */
+  private MockResponse truncateViolently(MockResponse response, int numBytesToKeep) {
+    response.setSocketPolicy(SocketPolicy.DISCONNECT_AT_END);
+    Headers headers = response.getHeaders();
+    Buffer truncatedBody = new Buffer();
+    truncatedBody.write(response.getBody(), numBytesToKeep);
+    response.setBody(truncatedBody);
+    response.setHeaders(headers);
+    return response;
+  }
+
+  enum TransferKind {
+    CHUNKED() {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize)
+          throws IOException {
+        response.setChunkedBody(content, chunkSize);
+      }
+    },
+    FIXED_LENGTH() {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
+        response.setBody(content);
+      }
+    },
+    END_OF_STREAM() {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
+        response.setBody(content);
+        response.setSocketPolicy(SocketPolicy.DISCONNECT_AT_END);
+        response.removeHeader("Content-Length");
+      }
+    };
+
+    abstract void setBody(MockResponse response, Buffer content, int chunkSize) throws IOException;
+
+    void setBody(MockResponse response, String content, int chunkSize) throws IOException {
+      setBody(response, new Buffer().writeUtf8(content), chunkSize);
+    }
+  }
+
+  /** Returns a gzipped copy of {@code bytes}. */
+  public Buffer gzip(String data) throws IOException {
+    Buffer result = new Buffer();
+    BufferedSink sink = Okio.buffer(new GzipSink(result));
+    sink.writeUtf8(data);
+    sink.close();
+    return result;
+  }
+
+  /**
+   * Reads {@code count} characters from the stream. If the stream is exhausted before {@code count}
+   * characters can be read, the remaining characters are returned and the stream is closed.
+   */
+  private String readAscii(URLConnection connection, int count) throws IOException {
+    HttpURLConnection httpConnection = (HttpURLConnection) connection;
+    InputStream in = httpConnection.getResponseCode() < HttpURLConnection.HTTP_BAD_REQUEST
+        ? connection.getInputStream() : httpConnection.getErrorStream();
+    StringBuilder result = new StringBuilder();
+    for (int i = 0; i < count; i++) {
+      int value = in.read();
+      if (value == -1) {
+        in.close();
+        break;
+      }
+      result.append((char) value);
+    }
+    return result.toString();
+  }
+
+  private String readAscii(URLConnection connection) throws IOException {
+    return readAscii(connection, Integer.MAX_VALUE);
+  }
+
+  private void reliableSkip(InputStream in, int length) throws IOException {
+    while (length > 0) {
+      length -= in.skip(length);
+    }
+  }
+
+  private void assertGatewayTimeout(HttpURLConnection connection) throws IOException {
+    try {
+      connection.getInputStream();
+      fail();
+    } catch (FileNotFoundException expected) {
+    }
+    assertEquals(504, connection.getResponseCode());
+    assertEquals(-1, connection.getErrorStream().read());
+  }
+
+  private static <T> List<T> toListOrNull(T[] arrayOrNull) {
+    return arrayOrNull != null ? Arrays.asList(arrayOrNull) : null;
+  }
+
+  // Android-added tests.
+
+  /**
+   * Test that we can interrogate the response when the cache is being populated.
+   * http://code.google.com/p/android/issues/detail?id=7787
+   */
+  @Test public void responseCacheCallbackApis() throws Exception {
+    final String body = "ABCDE";
+    final AtomicInteger cacheCount = new AtomicInteger();
+
+    server.enqueue(new MockResponse()
+        .setStatus("HTTP/1.1 200 Fantastic")
+        .addHeader("Content-Type: text/plain")
+        .addHeader("fgh: ijk")
+        .setBody(body));
+
+    setInternalCache(new CacheAdapter(new AbstractResponseCache() {
+      @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
+        HttpURLConnection httpURLConnection = (HttpURLConnection) connection;
+        assertEquals(server.url("/").url(), uri.toURL());
+        assertEquals(200, httpURLConnection.getResponseCode());
+        InputStream is = httpURLConnection.getInputStream();
+        try {
+          is.read();
+          fail();
+        } catch (UnsupportedOperationException expected) {
+        }
+        assertEquals("5", connection.getHeaderField("Content-Length"));
+        assertEquals("text/plain", connection.getHeaderField("Content-Type"));
+        assertEquals("ijk", connection.getHeaderField("fgh"));
+        cacheCount.incrementAndGet();
+        return null;
+      }
+    }));
+
+    URL url = server.url("/").url();
+    HttpURLConnection connection = openConnection(url);
+    assertEquals(body, readAscii(connection));
+    assertEquals(1, cacheCount.get());
+  }
+
+  /** Don't explode if the cache returns a null body. http://b/3373699 */
+  @Test public void responseCacheReturnsNullOutputStream() throws Exception {
+    final AtomicBoolean aborted = new AtomicBoolean();
+    setInternalCache(new CacheAdapter(new AbstractResponseCache() {
+      @Override public CacheRequest put(URI uri, URLConnection connection) {
+        return new CacheRequest() {
+          @Override public void abort() {
+            aborted.set(true);
+          }
+
+          @Override public OutputStream getBody() throws IOException {
+            return null;
+          }
+        };
+      }
+    }));
+
+    server.enqueue(new MockResponse().setBody("abcdef"));
+
+    HttpURLConnection connection = openConnection(server.url("/").url());
+    assertEquals("abc", readAscii(connection, 3));
+    connection.getInputStream().close();
+    assertFalse(aborted.get()); // The best behavior is ambiguous, but RI 6 doesn't abort here
+  }
+
+  /**
+   * Fail if a badly-behaved cache returns a null status line header.
+   * https://code.google.com/p/android/issues/detail?id=160522
+   */
+  @Test public void responseCacheReturnsNullStatusLine() throws Exception {
+    String cachedContentString = "Hello";
+    final byte[] cachedContent = cachedContentString.getBytes(StandardCharsets.US_ASCII);
+
+    setInternalCache(new CacheAdapter(new AbstractResponseCache() {
+      @Override
+      public CacheResponse get(URI uri, String requestMethod,
+          Map<String, List<String>> requestHeaders)
+          throws IOException {
+        return new CacheResponse() {
+          @Override public Map<String, List<String>> getHeaders() throws IOException {
+            String contentType = "text/plain";
+            Map<String, List<String>> headers = new LinkedHashMap<>();
+            headers.put("Content-Length", Arrays.asList(Integer.toString(cachedContent.length)));
+            headers.put("Content-Type", Arrays.asList(contentType));
+            headers.put("Expires", Arrays.asList(formatDate(-1, TimeUnit.HOURS)));
+            headers.put("Cache-Control", Arrays.asList("max-age=60"));
+            // Crucially, the header with a null key is missing, which renders the cache response
+            // unusable because OkHttp only caches responses with cacheable response codes.
+            return headers;
+          }
+
+          @Override public InputStream getBody() throws IOException {
+            return new ByteArrayInputStream(cachedContent);
+          }
+        };
+      }
+    }));
+    HttpURLConnection connection = openConnection(server.url("/").url());
+    // If there was no status line from the cache an exception will be thrown. No network request
+    // should be made.
+    try {
+      connection.getResponseCode();
+      fail();
+    } catch (ProtocolException expected) {
+    }
+  }
+
+  private static class InsecureResponseCache extends ResponseCache {
+
+    private final ResponseCache delegate;
+
+    private InsecureResponseCache(ResponseCache delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
+      return delegate.put(uri, connection);
+    }
+
+    @Override public CacheResponse get(URI uri, String requestMethod,
+        Map<String, List<String>> requestHeaders) throws IOException {
+      final CacheResponse response = delegate.get(uri, requestMethod, requestHeaders);
+      if (response instanceof SecureCacheResponse) {
+        return new CacheResponse() {
+          @Override public InputStream getBody() throws IOException {
+            return response.getBody();
+          }
+
+          @Override public Map<String, List<String>> getHeaders() throws IOException {
+            return response.getHeaders();
+          }
+        };
+      }
+      return response;
+    }
+  }
+
+  @Test public void cacheReturnsInsecureResponseForSecureRequest() throws IOException {
+    assumeFalse(getPlatform().equals("jdk9"));
+
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse().setBody("ABC"));
+    server.enqueue(new MockResponse().setBody("DEF"));
+
+    AndroidInternal.setResponseCache(urlFactory, new InsecureResponseCache(cache));
+
+    HttpsURLConnection connection1 = (HttpsURLConnection) openConnection(server.url("/").url());
+    connection1.setSSLSocketFactory(sslClient.socketFactory);
+    connection1.setHostnameVerifier(hostnameVerifier);
+    assertEquals("ABC", readAscii(connection1));
+
+    // Not cached!
+    HttpsURLConnection connection2 = (HttpsURLConnection) openConnection(server.url("/").url());
+    connection2.setSSLSocketFactory(sslClient.socketFactory);
+    connection2.setHostnameVerifier(hostnameVerifier);
+    assertEquals("DEF", readAscii(connection2));
+  }
+
+  @Test public void responseCacheRequestHeaders() throws IOException, URISyntaxException {
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+
+    final AtomicReference<Map<String, List<String>>> requestHeadersRef = new AtomicReference<>();
+    setInternalCache(new CacheAdapter(new AbstractResponseCache() {
+      @Override public CacheResponse get(URI uri, String requestMethod,
+          Map<String, List<String>> requestHeaders) throws IOException {
+        requestHeadersRef.set(requestHeaders);
+        return null;
+      }
+    }));
+
+    URL url = server.url("/").url();
+    URLConnection urlConnection = openConnection(url);
+    urlConnection.addRequestProperty("A", "android");
+    readAscii(urlConnection);
+    assertEquals(Arrays.asList("android"), requestHeadersRef.get().get("A"));
+  }
+
+  @Test public void responseCachingWithoutBody() throws IOException {
+    MockResponse response =
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+            .setStatus("HTTP/1.1 200 Fantastic");
+    server.enqueue(response);
+
+    HttpURLConnection urlConnection = openConnection(server.url("/").url());
+    assertEquals(200, urlConnection.getResponseCode());
+    assertEquals("Fantastic", urlConnection.getResponseMessage());
+    assertTrue(urlConnection.getDoInput());
+    InputStream is = urlConnection.getInputStream();
+    assertEquals(-1, is.read());
+    is.close();
+
+    urlConnection = openConnection(server.url("/").url()); // cached!
+    assertTrue(urlConnection.getDoInput());
+    InputStream cachedIs = urlConnection.getInputStream();
+    assertEquals(-1, cachedIs.read());
+    cachedIs.close();
+    assertEquals(200, urlConnection.getResponseCode());
+    assertEquals("Fantastic", urlConnection.getResponseMessage());
+  }
+
+  @Test public void useCachesFalseDoesNotWriteToCache() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URLConnection connection = openConnection(server.url("/").url());
+    connection.setUseCaches(false);
+    assertEquals("A", readAscii(connection));
+    assertEquals("B", readAscii(openConnection(server.url("/").url())));
+  }
+
+  @Test public void useCachesFalseDoesNotReadFromCache() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+    URLConnection connection = openConnection(server.url("/").url());
+    connection.setUseCaches(false);
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void defaultUseCachesSetsInitialValueOnly() throws Exception {
+    URL url = new URL("http://localhost/");
+    URLConnection c1 = openConnection(url);
+    URLConnection c2 = openConnection(url);
+    assertTrue(c1.getDefaultUseCaches());
+    c1.setDefaultUseCaches(false);
+    try {
+      assertTrue(c1.getUseCaches());
+      assertTrue(c2.getUseCaches());
+      URLConnection c3 = openConnection(url);
+      assertFalse(c3.getUseCaches());
+    } finally {
+      c1.setDefaultUseCaches(true);
+    }
+  }
+
+  // Other stacks (e.g. older versions of OkHttp bundled inside Android apps) can interact with the
+  // default ResponseCache. We try to keep this case working as much as possible because apps break
+  // if we don't.
+  @Test public void otherStacks_cacheHitWithoutVary() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("FAIL"));
+
+    // Set the cache as the shared cache.
+    ResponseCache.setDefault(cache);
+
+    // Use the platform's HTTP stack.
+    URLConnection connection = server.url("/").url().openConnection();
+    assertFalse(connection instanceof OkHttpURLConnection);
+    assertEquals("A", readAscii(connection));
+
+    URLConnection connection2 = server.url("/").url().openConnection();
+    assertFalse(connection2 instanceof OkHttpURLConnection);
+    assertEquals("A", readAscii(connection2));
+  }
+
+  // Other stacks (e.g. older versions of OkHttp bundled inside Android apps) can interact with the
+  // default ResponseCache. We can't keep the Vary case working because we can't get to the Vary
+  // request headers after connect(). Accept-Encoding has special behavior so we test it explicitly.
+  @Test public void otherStacks_cacheMissWithVaryAcceptEncoding() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Encoding")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    // Set the cache as the shared cache.
+    ResponseCache.setDefault(cache);
+
+    // Use the platform's HTTP stack.
+    URLConnection connection = server.url("/").url().openConnection();
+    assertFalse(connection instanceof OkHttpURLConnection);
+    assertEquals("A", readAscii(connection));
+
+    URLConnection connection2 = server.url("/").url().openConnection();
+    assertFalse(connection2 instanceof OkHttpURLConnection);
+    assertEquals("B", readAscii(connection2));
+  }
+
+  // Other stacks (e.g. older versions of OkHttp bundled inside Android apps) can interact with the
+  // default ResponseCache. We can't keep the Vary case working because we can't get to the Vary
+  // request headers after connect().
+  @Test public void otherStacks_cacheMissWithVary() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    // Set the cache as the shared cache.
+    ResponseCache.setDefault(cache);
+
+    // Use the platform's HTTP stack.
+    URLConnection connection = server.url("/").url().openConnection();
+    assertFalse(connection instanceof OkHttpURLConnection);
+    connection.setRequestProperty("Accept-Language", "en-US");
+    assertEquals("A", readAscii(connection));
+
+    URLConnection connection2 = server.url("/").url().openConnection();
+    assertFalse(connection2 instanceof OkHttpURLConnection);
+    assertEquals("B", readAscii(connection2));
+  }
+
+  // Other stacks (e.g. older versions of OkHttp bundled inside Android apps) can interact with the
+  // default ResponseCache. We can't keep the Vary case working, because we can't get to the Vary
+  // request headers after connect().
+  @Test public void otherStacks_cacheMissWithVaryAsterisk() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: *")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    // Set the cache as the shared cache.
+    ResponseCache.setDefault(cache);
+
+    // Use the platform's HTTP stack.
+    URLConnection connection = server.url("/").url().openConnection();
+    assertFalse(connection instanceof OkHttpURLConnection);
+    assertEquals("A", readAscii(connection));
+
+    URLConnection connection2 = server.url("/").url().openConnection();
+    assertFalse(connection2 instanceof OkHttpURLConnection);
+    assertEquals("B", readAscii(connection2));
+  }
+
+  private void setInternalCache(InternalCache internalCache) {
+    OkHttpClient.Builder builder = urlFactory.client().newBuilder();
+    Internal.instance.setCache(builder, internalCache);
+    urlFactory.setClient(builder.build());
+  }
+
+  private String getPlatform() {
+    return System.getProperty("okhttp.platform", "platform");
+  }
+}
diff --git a/okhttp-apache/README.md b/okhttp-apache/README.md
new file mode 100644
index 0000000000..ac71ec215a
--- /dev/null
+++ b/okhttp-apache/README.md
@@ -0,0 +1,7 @@
+OkHttp Apache HttpClient Implementation
+=======================================
+
+This module is an implementation of the Apache `HttpClient` interface that is backed by OkHttp.
+
+**Warning**: Many core features of Apache HTTP client are not implemented by this API. This includes
+the keep-alive strategy, cookie store, credentials provider, route planner and others.
diff --git a/okhttp-apache/pom.xml b/okhttp-apache/pom.xml
new file mode 100644
index 0000000000..4cf6878138
--- /dev/null
+++ b/okhttp-apache/pom.xml
@@ -0,0 +1,61 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp3</groupId>
+    <artifactId>parent</artifactId>
+    <version>3.10.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>okhttp-apache</artifactId>
+  <name>OkHttp Apache HttpClient</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.httpcomponents</groupId>
+      <artifactId>httpclient</artifactId>
+      <scope>provided</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-javadoc-plugin</artifactId>
+        <configuration>
+          <links>
+            <link>http://square.github.io/okhttp/javadoc/</link>
+            <link>http://hc.apache.org/httpcomponents-client-4.3.x/httpclient/apidocs/</link>
+            <link>https://hc.apache.org/httpcomponents-core-4.3.x/httpcore/apidocs/</link>
+          </links>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/okhttp-apache/src/main/java/okhttp3/apache/HttpEntityBody.java b/okhttp-apache/src/main/java/okhttp3/apache/HttpEntityBody.java
new file mode 100644
index 0000000000..45d27aafd1
--- /dev/null
+++ b/okhttp-apache/src/main/java/okhttp3/apache/HttpEntityBody.java
@@ -0,0 +1,41 @@
+package okhttp3.apache;
+
+import java.io.IOException;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import okio.BufferedSink;
+import org.apache.http.HttpEntity;
+
+/** Adapts an {@link HttpEntity} to OkHttp's {@link RequestBody}. */
+final class HttpEntityBody extends RequestBody {
+  private static final MediaType DEFAULT_MEDIA_TYPE = MediaType.parse("application/octet-stream");
+
+  private final HttpEntity entity;
+  private final MediaType mediaType;
+
+  HttpEntityBody(HttpEntity entity, String contentTypeHeader) {
+    this.entity = entity;
+
+    if (contentTypeHeader != null) {
+      mediaType = MediaType.parse(contentTypeHeader);
+    } else if (entity.getContentType() != null) {
+      mediaType = MediaType.parse(entity.getContentType().getValue());
+    } else {
+      // Apache is forgiving and lets you skip specifying a content type with an entity. OkHttp is
+      // not forgiving so we fall back to a generic type if it's missing.
+      mediaType = DEFAULT_MEDIA_TYPE;
+    }
+  }
+
+  @Override public long contentLength() {
+    return entity.getContentLength();
+  }
+
+  @Override public MediaType contentType() {
+    return mediaType;
+  }
+
+  @Override public void writeTo(BufferedSink sink) throws IOException {
+    entity.writeTo(sink.outputStream());
+  }
+}
diff --git a/okhttp-apache/src/main/java/okhttp3/apache/OkApacheClient.java b/okhttp-apache/src/main/java/okhttp3/apache/OkApacheClient.java
new file mode 100644
index 0000000000..d1241d3d01
--- /dev/null
+++ b/okhttp-apache/src/main/java/okhttp3/apache/OkApacheClient.java
@@ -0,0 +1,208 @@
+// Copyright 2013 Square, Inc.
+package okhttp3.apache;
+
+import java.io.IOException;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import okhttp3.Headers;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.Util;
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpEntityEnclosingRequest;
+import org.apache.http.HttpHost;
+import org.apache.http.HttpRequest;
+import org.apache.http.HttpResponse;
+import org.apache.http.RequestLine;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.ResponseHandler;
+import org.apache.http.client.methods.HttpUriRequest;
+import org.apache.http.conn.ClientConnectionManager;
+import org.apache.http.conn.params.ConnRouteParams;
+import org.apache.http.entity.InputStreamEntity;
+import org.apache.http.message.BasicHttpResponse;
+import org.apache.http.params.AbstractHttpParams;
+import org.apache.http.params.HttpParams;
+import org.apache.http.protocol.HttpContext;
+
+import static java.net.Proxy.Type.HTTP;
+import static org.apache.http.HttpVersion.HTTP_1_1;
+
+/**
+ * @deprecated OkHttp will be dropping its ability to be used with {@link HttpClient} in an upcoming
+ * release. Applications that need this should either downgrade to the Apache implementation or
+ * upgrade to OkHttp's Request/Response API.
+ */
+public final class OkApacheClient implements HttpClient {
+  private static Request transformRequest(HttpRequest request) {
+    Request.Builder builder = new Request.Builder();
+
+    RequestLine requestLine = request.getRequestLine();
+    String method = requestLine.getMethod();
+    builder.url(requestLine.getUri());
+
+    String contentType = null;
+    for (Header header : request.getAllHeaders()) {
+      String name = header.getName();
+      if ("Content-Type".equalsIgnoreCase(name)) {
+        contentType = header.getValue();
+      } else {
+        builder.header(name, header.getValue());
+      }
+    }
+
+    RequestBody body = null;
+    if (request instanceof HttpEntityEnclosingRequest) {
+      HttpEntity entity = ((HttpEntityEnclosingRequest) request).getEntity();
+      if (entity != null) {
+        // Wrap the entity in a custom Body which takes care of the content, length, and type.
+        body = new HttpEntityBody(entity, contentType);
+
+        Header encoding = entity.getContentEncoding();
+        if (encoding != null) {
+          builder.header(encoding.getName(), encoding.getValue());
+        }
+      } else {
+        body = Util.EMPTY_REQUEST;
+      }
+    }
+    builder.method(method, body);
+
+    return builder.build();
+  }
+
+  private static HttpResponse transformResponse(Response response) {
+    int code = response.code();
+    String message = response.message();
+    BasicHttpResponse httpResponse = new BasicHttpResponse(HTTP_1_1, code, message);
+
+    ResponseBody body = response.body();
+    InputStreamEntity entity = new InputStreamEntity(body.byteStream(), body.contentLength());
+    httpResponse.setEntity(entity);
+
+    Headers headers = response.headers();
+    for (int i = 0, size = headers.size(); i < size; i++) {
+      String name = headers.name(i);
+      String value = headers.value(i);
+      httpResponse.addHeader(name, value);
+      if ("Content-Type".equalsIgnoreCase(name)) {
+        entity.setContentType(value);
+      } else if ("Content-Encoding".equalsIgnoreCase(name)) {
+        entity.setContentEncoding(value);
+      }
+    }
+
+    return httpResponse;
+  }
+
+  private final HttpParams params = new AbstractHttpParams() {
+    @Override public Object getParameter(String name) {
+      if (name.equals(ConnRouteParams.DEFAULT_PROXY)) {
+        Proxy proxy = client.proxy();
+        if (proxy == null) {
+          return null;
+        }
+        InetSocketAddress address = (InetSocketAddress) proxy.address();
+        return new HttpHost(address.getHostName(), address.getPort());
+      }
+      throw new IllegalArgumentException(name);
+    }
+
+    @Override public HttpParams setParameter(String name, Object value) {
+      if (name.equals(ConnRouteParams.DEFAULT_PROXY)) {
+        HttpHost host = (HttpHost) value;
+        Proxy proxy = null;
+        if (host != null) {
+          proxy = new Proxy(HTTP, new InetSocketAddress(host.getHostName(), host.getPort()));
+        }
+        client = client.newBuilder()
+            .proxy(proxy)
+            .build();
+        return this;
+      }
+      throw new IllegalArgumentException(name);
+    }
+
+    @Override public HttpParams copy() {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override public boolean removeParameter(String name) {
+      throw new UnsupportedOperationException();
+    }
+  };
+
+  private OkHttpClient client;
+
+  public OkApacheClient() {
+    this(new OkHttpClient());
+  }
+
+  public OkApacheClient(OkHttpClient client) {
+    this.client = client;
+  }
+
+  @Override public HttpParams getParams() {
+    return params;
+  }
+
+  @Override public ClientConnectionManager getConnectionManager() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override public HttpResponse execute(HttpUriRequest request) throws IOException {
+    return execute(null, request, (HttpContext) null);
+  }
+
+  @Override public HttpResponse execute(HttpUriRequest request, HttpContext context)
+      throws IOException {
+    return execute(null, request, context);
+  }
+
+  @Override public HttpResponse execute(HttpHost host, HttpRequest request) throws IOException {
+    return execute(host, request, (HttpContext) null);
+  }
+
+  @Override public HttpResponse execute(HttpHost host, HttpRequest request, HttpContext context)
+      throws IOException {
+    Request okRequest = transformRequest(request);
+    Response okResponse = client.newCall(okRequest).execute();
+    return transformResponse(okResponse);
+  }
+
+  @Override public <T> T execute(HttpUriRequest request, ResponseHandler<? extends T> handler)
+      throws IOException {
+    return execute(null, request, handler, null);
+  }
+
+  @Override public <T> T execute(HttpUriRequest request, ResponseHandler<? extends T> handler,
+      HttpContext context) throws IOException {
+    return execute(null, request, handler, context);
+  }
+
+  @Override public <T> T execute(HttpHost host, HttpRequest request,
+      ResponseHandler<? extends T> handler) throws IOException {
+    return execute(host, request, handler, null);
+  }
+
+  @Override public <T> T execute(HttpHost host, HttpRequest request,
+      ResponseHandler<? extends T> handler, HttpContext context) throws IOException {
+    HttpResponse response = execute(host, request, context);
+    try {
+      return handler.handleResponse(response);
+    } finally {
+      consumeContentQuietly(response);
+    }
+  }
+
+  private static void consumeContentQuietly(HttpResponse response) {
+    try {
+      response.getEntity().consumeContent();
+    } catch (Throwable ignored) {
+    }
+  }
+}
diff --git a/okhttp-apache/src/test/java/okhttp3/apache/OkApacheClientTest.java b/okhttp-apache/src/test/java/okhttp3/apache/OkApacheClientTest.java
new file mode 100644
index 0000000000..77493a2540
--- /dev/null
+++ b/okhttp-apache/src/test/java/okhttp3/apache/OkApacheClientTest.java
@@ -0,0 +1,281 @@
+package okhttp3.apache;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URISyntaxException;
+import java.util.zip.GZIPInputStream;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okio.Buffer;
+import okio.GzipSink;
+import okio.Okio;
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpResponse;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.client.methods.HttpPost;
+import org.apache.http.client.methods.HttpPut;
+import org.apache.http.entity.ByteArrayEntity;
+import org.apache.http.entity.InputStreamEntity;
+import org.apache.http.entity.StringEntity;
+import org.apache.http.util.EntityUtils;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static okhttp3.internal.Util.UTF_8;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+
+public class OkApacheClientTest {
+  private MockWebServer server;
+  private OkApacheClient client;
+
+  @Before public void setUp() throws IOException {
+    client = new OkApacheClient();
+    server = new MockWebServer();
+    server.start();
+  }
+
+  @After public void tearDown() throws IOException {
+    server.shutdown();
+  }
+
+  @Test public void success() throws Exception {
+    server.enqueue(new MockResponse().setBody("Hello, World!"));
+
+    HttpGet request = new HttpGet(server.url("/").url().toURI());
+    HttpResponse response = client.execute(request);
+    String actual = EntityUtils.toString(response.getEntity());
+    assertEquals("Hello, World!", actual);
+  }
+
+  @Test public void redirect() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(302).addHeader("Location", "/foo"));
+    server.enqueue(new MockResponse().setBody("Hello, Redirect!"));
+
+    HttpGet request = new HttpGet(server.url("/").url().toURI());
+    HttpResponse response = client.execute(request);
+    String actual = EntityUtils.toString(response.getEntity(), UTF_8);
+    assertEquals("Hello, Redirect!", actual);
+  }
+
+  @Test public void sessionExpired() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(422));
+
+    HttpGet request = new HttpGet(server.url("/").url().toURI());
+    HttpResponse response = client.execute(request);
+    assertEquals(422, response.getStatusLine().getStatusCode());
+  }
+
+  @Test public void headers() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Foo", "Bar"));
+    server.enqueue(new MockResponse().addHeader("Foo", "Bar").addHeader("Foo", "Baz"));
+
+    HttpGet request1 = new HttpGet(server.url("/").url().toURI());
+    HttpResponse response1 = client.execute(request1);
+    Header[] headers1 = response1.getHeaders("Foo");
+    assertEquals(1, headers1.length);
+    assertEquals("Bar", headers1[0].getValue());
+
+    HttpGet request2 = new HttpGet(server.url("/").url().toURI());
+    HttpResponse response2 = client.execute(request2);
+    Header[] headers2 = response2.getHeaders("Foo");
+    assertEquals(2, headers2.length);
+    assertEquals("Bar", headers2[0].getValue());
+    assertEquals("Baz", headers2[1].getValue());
+  }
+
+  @Test public void postByteEntity() throws Exception {
+    server.enqueue(new MockResponse());
+
+    final HttpPost post = new HttpPost(server.url("/").url().toURI());
+    byte[] body = "Hello, world!".getBytes(UTF_8);
+    post.setEntity(new ByteArrayEntity(body));
+    client.execute(post);
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("Hello, world!", request.getBody().readUtf8());
+    assertEquals(request.getHeader("Content-Length"), "13");
+  }
+
+  @Test public void postInputStreamEntity() throws Exception {
+    server.enqueue(new MockResponse());
+
+    final HttpPost post = new HttpPost(server.url("/").url().toURI());
+    byte[] body = "Hello, world!".getBytes(UTF_8);
+    post.setEntity(new InputStreamEntity(new ByteArrayInputStream(body), body.length));
+    client.execute(post);
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("Hello, world!", request.getBody().readUtf8());
+    assertEquals(request.getHeader("Content-Length"), "13");
+  }
+
+  @Test public void postEmptyEntity() throws Exception {
+    server.enqueue(new MockResponse());
+    final HttpPost post = new HttpPost(server.url("/").url().toURI());
+    client.execute(post);
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals(0, request.getBodySize());
+    assertNotNull(request.getBody());
+  }
+
+  @Test public void putEmptyEntity() throws Exception {
+    server.enqueue(new MockResponse());
+    final HttpPut put = new HttpPut(server.url("/").url().toURI());
+    client.execute(put);
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals(0, request.getBodySize());
+    assertNotNull(request.getBody());
+  }
+
+  @Test public void postOverrideContentType() throws Exception {
+    server.enqueue(new MockResponse());
+
+    HttpPost httpPost = new HttpPost();
+    httpPost.setURI(server.url("/").url().toURI());
+    httpPost.addHeader("Content-Type", "application/xml");
+    httpPost.setEntity(new StringEntity("<yo/>"));
+    client.execute(httpPost);
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals(request.getHeader("Content-Type"), "application/xml");
+  }
+
+  @Test public void contentType() throws Exception {
+    server.enqueue(new MockResponse().setBody("<html><body><h1>Hello, World!</h1></body></html>")
+        .setHeader("Content-Type", "text/html"));
+    server.enqueue(new MockResponse().setBody("{\"Message\": { \"text\": \"Hello, World!\" } }")
+        .setHeader("Content-Type", "application/json"));
+    server.enqueue(new MockResponse().setBody("Hello, World!"));
+
+    HttpGet request1 = new HttpGet(server.url("/").url().toURI());
+    HttpResponse response1 = client.execute(request1);
+    Header[] headers1 = response1.getHeaders("Content-Type");
+    assertEquals(1, headers1.length);
+    assertEquals("text/html", headers1[0].getValue());
+    assertNotNull(response1.getEntity().getContentType());
+    assertEquals("text/html", response1.getEntity().getContentType().getValue());
+
+    HttpGet request2 = new HttpGet(server.url("/").url().toURI());
+    HttpResponse response2 = client.execute(request2);
+    Header[] headers2 = response2.getHeaders("Content-Type");
+    assertEquals(1, headers2.length);
+    assertEquals("application/json", headers2[0].getValue());
+    assertNotNull(response2.getEntity().getContentType());
+    assertEquals("application/json", response2.getEntity().getContentType().getValue());
+
+    HttpGet request3 = new HttpGet(server.url("/").url().toURI());
+    HttpResponse response3 = client.execute(request3);
+    Header[] headers3 = response3.getHeaders("Content-Type");
+    assertEquals(0, headers3.length);
+    assertNull(response3.getEntity().getContentType());
+  }
+
+  @Test public void contentTypeIsCaseInsensitive() throws URISyntaxException, IOException {
+    server.enqueue(new MockResponse().setBody("{\"Message\": { \"text\": \"Hello, World!\" } }")
+        .setHeader("cONTENT-tYPE", "application/json"));
+
+    HttpGet request = new HttpGet(server.url("/").url().toURI());
+    HttpResponse response = client.execute(request);
+    assertEquals("application/json", response.getEntity().getContentType().getValue());
+  }
+
+  @Test public void contentEncoding() throws Exception {
+    String text = "{\"Message\": { \"text\": \"Hello, World!\" } }";
+    server.enqueue(new MockResponse().setBody(gzip(text))
+        .setHeader("Content-Encoding", "gzip"));
+
+    HttpGet request = new HttpGet(server.url("/").url().toURI());
+    request.setHeader("Accept-encoding", "gzip"); // Not transparent gzip.
+    HttpResponse response = client.execute(request);
+    HttpEntity entity = response.getEntity();
+
+    Header[] encodingHeaders = response.getHeaders("Content-Encoding");
+    assertEquals(1, encodingHeaders.length);
+    assertEquals("gzip", encodingHeaders[0].getValue());
+    assertNotNull(entity.getContentEncoding());
+    assertEquals("gzip", entity.getContentEncoding().getValue());
+
+    assertEquals(text, gunzip(entity));
+  }
+
+  @Test public void jsonGzipResponse() throws Exception {
+    String text = "{\"Message\": { \"text\": \"Hello, World!\" } }";
+    server.enqueue(new MockResponse().setBody(gzip(text))
+        .setHeader("Content-Encoding", "gzip")
+        .setHeader("Content-Type", "application/json"));
+
+    HttpGet request1 = new HttpGet(server.url("/").url().toURI());
+    request1.setHeader("Accept-encoding", "gzip"); // Not transparent gzip.
+
+    HttpResponse response = client.execute(request1);
+    HttpEntity entity = response.getEntity();
+
+    Header[] encodingHeaders = response.getHeaders("Content-Encoding");
+    assertEquals(1, encodingHeaders.length);
+    assertEquals("gzip", encodingHeaders[0].getValue());
+    assertNotNull(entity.getContentEncoding());
+    assertEquals("gzip", entity.getContentEncoding().getValue());
+
+    Header[] typeHeaders = response.getHeaders("Content-Type");
+    assertEquals(1, typeHeaders.length);
+    assertEquals("application/json", typeHeaders[0].getValue());
+    assertNotNull(entity.getContentType());
+    assertEquals("application/json", entity.getContentType().getValue());
+
+    assertEquals(text, gunzip(entity));
+  }
+
+  @Test public void jsonTransparentGzipResponse() throws Exception {
+    String text = "{\"Message\": { \"text\": \"Hello, World!\" } }";
+    server.enqueue(new MockResponse().setBody(gzip(text))
+        .setHeader("Content-Encoding", "gzip")
+        .setHeader("Content-Type", "application/json"));
+
+    HttpGet request = new HttpGet(server.url("/").url().toURI());
+    HttpResponse response = client.execute(request);
+    HttpEntity entity = response.getEntity();
+
+    // Expecting transparent gzip response by not adding header "Accept-encoding: gzip"
+    Header[] encodingHeaders = response.getHeaders("Content-Encoding");
+    assertEquals(0, encodingHeaders.length);
+    assertNull(entity.getContentEncoding());
+
+    // Content length should be absent.
+    Header[] lengthHeaders = response.getHeaders("Content-Length");
+    assertEquals(0, lengthHeaders.length);
+    assertEquals(-1, entity.getContentLength());
+
+    Header[] typeHeaders = response.getHeaders("Content-Type");
+    assertEquals(1, typeHeaders.length);
+    assertEquals("application/json", typeHeaders[0].getValue());
+    assertNotNull(entity.getContentType());
+    assertEquals("application/json", entity.getContentType().getValue());
+
+    assertEquals(text, EntityUtils.toString(entity, UTF_8));
+  }
+
+  private static Buffer gzip(String body) throws IOException {
+    Buffer buffer = new Buffer();
+    Okio.buffer(new GzipSink(buffer)).writeUtf8(body).close();
+    return buffer;
+  }
+
+  private static String gunzip(HttpEntity body) throws IOException {
+    InputStream in = new GZIPInputStream(body.getContent());
+    Buffer buffer = new Buffer();
+    byte[] temp = new byte[1024];
+    int read;
+    while ((read = in.read(temp)) != -1) {
+      buffer.write(temp, 0, read);
+    }
+    return buffer.readUtf8();
+  }
+}
diff --git a/okhttp-hpacktests/README.md b/okhttp-hpacktests/README.md
new file mode 100644
index 0000000000..6b85c9a000
--- /dev/null
+++ b/okhttp-hpacktests/README.md
@@ -0,0 +1,19 @@
+OkHttp HPACK tests
+==================
+
+These tests use the [hpack-test-case][1] project to validate OkHttp's HPACK
+implementation.  The HPACK test cases are in a separate git submodule, so to
+initialize them, you must run:
+
+    git submodule init
+    git submodule update
+
+TODO
+----
+
+ * Add maven goal to avoid manual call to git submodule init.
+ * Make hpack-test-case update itself from git, and run new tests.
+ * Add maven goal to generate stories and a pull request to hpack-test-case
+   to have others validate our output.
+
+[1]: https://github.com/http2jp/hpack-test-case 
diff --git a/okhttp-hpacktests/pom.xml b/okhttp-hpacktests/pom.xml
new file mode 100644
index 0000000000..12bc4e4b49
--- /dev/null
+++ b/okhttp-hpacktests/pom.xml
@@ -0,0 +1,62 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp3</groupId>
+    <artifactId>parent</artifactId>
+    <version>3.5.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>okhttp-hpacktests</artifactId>
+  <name>OkHttp HPACK Tests</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.okio</groupId>
+      <artifactId>okio</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.moshi</groupId>
+      <artifactId>moshi</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <!-- Do not deploy this as an artifact to Maven central. -->
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-deploy-plugin</artifactId>
+        <configuration>
+          <skip>true</skip>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackDecodeInteropTest.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackDecodeInteropTest.java
new file mode 100644
index 0000000000..dbcc99f55f
--- /dev/null
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackDecodeInteropTest.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import java.util.Collection;
+import okhttp3.internal.http2.hpackjson.Story;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static okhttp3.internal.http2.hpackjson.HpackJsonUtil.storiesForCurrentDraft;
+
+@RunWith(Parameterized.class)
+public class HpackDecodeInteropTest extends HpackDecodeTestBase {
+
+  public HpackDecodeInteropTest(Story story) {
+    super(story);
+  }
+
+  @Parameterized.Parameters(name = "{0}")
+  public static Collection<Story[]> createStories() throws Exception {
+    return createStories(storiesForCurrentDraft());
+  }
+
+  @Test
+  public void testGoodDecoderInterop() throws Exception {
+    testDecoder();
+  }
+}
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackDecodeTestBase.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackDecodeTestBase.java
new file mode 100644
index 0000000000..a3f69da38c
--- /dev/null
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackDecodeTestBase.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.LinkedHashSet;
+import java.util.List;
+import okhttp3.internal.http2.hpackjson.Case;
+import okhttp3.internal.http2.hpackjson.HpackJsonUtil;
+import okhttp3.internal.http2.hpackjson.Story;
+import okio.Buffer;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+/**
+ * Tests Hpack implementation using https://github.com/http2jp/hpack-test-case/
+ */
+public class HpackDecodeTestBase {
+
+  /**
+   * Reads all stories in the folders provided, asserts if no story found.
+   */
+  protected static Collection<Story[]> createStories(String[] interopTests)
+      throws Exception {
+    List<Story[]> result = new ArrayList<>();
+    for (String interopTestName : interopTests) {
+      List<Story> stories = HpackJsonUtil.readStories(interopTestName);
+      if (stories.isEmpty()) {
+        fail("No stories for: " + interopTestName);
+      }
+      for (Story story : stories) {
+        result.add(new Story[] {story});
+      }
+    }
+    return result;
+  }
+
+  private final Buffer bytesIn = new Buffer();
+  private final Hpack.Reader hpackReader = new Hpack.Reader(4096, bytesIn);
+
+  private final Story story;
+
+  public HpackDecodeTestBase(Story story) {
+    this.story = story;
+  }
+
+  /**
+   * Expects wire to be set for all cases, and compares the decoder's output to expected headers.
+   */
+  protected void testDecoder() throws Exception {
+    testDecoder(story);
+  }
+
+  protected void testDecoder(Story story) throws Exception {
+    for (Case caze : story.getCases()) {
+      bytesIn.write(caze.getWire());
+      hpackReader.readHeaders();
+      assertSetEquals(String.format("seqno=%d", caze.getSeqno()), caze.getHeaders(),
+          hpackReader.getAndResetHeaderList());
+    }
+  }
+
+  /**
+   * Checks if {@code expected} and {@code observed} are equal when viewed as a set and headers are
+   * deduped.
+   *
+   * TODO: See if duped headers should be preserved on decode and verify.
+   */
+  private static void assertSetEquals(
+      String message, List<Header> expected, List<Header> observed) {
+    assertEquals(message, new LinkedHashSet<>(expected), new LinkedHashSet<>(observed));
+  }
+
+  protected Story getStory() {
+    return story;
+  }
+}
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackRoundTripTest.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackRoundTripTest.java
new file mode 100644
index 0000000000..55325ce53d
--- /dev/null
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackRoundTripTest.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import java.util.Collection;
+import okhttp3.internal.http2.hpackjson.Case;
+import okhttp3.internal.http2.hpackjson.Story;
+import okio.Buffer;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+/**
+ * Tests for round-tripping headers through hpack..
+ */
+// TODO: update hpack-test-case with the output of our encoder.
+// This test will hide complementary bugs in the encoder and decoder,
+// We should test that the encoder is producing responses that are
+// d]
+@RunWith(Parameterized.class)
+public class HpackRoundTripTest extends HpackDecodeTestBase {
+
+  private static final String[] RAW_DATA = {"raw-data"};
+
+  @Parameterized.Parameters(name = "{0}")
+  public static Collection<Story[]> getStories() throws Exception {
+    return createStories(RAW_DATA);
+  }
+
+  private Buffer bytesOut = new Buffer();
+  private Hpack.Writer hpackWriter = new Hpack.Writer(bytesOut);
+
+  public HpackRoundTripTest(Story story) {
+    super(story);
+  }
+
+  @Test
+  public void testRoundTrip() throws Exception {
+    Story story = getStory().clone();
+    // Mutate cases in base class.
+    for (Case caze : story.getCases()) {
+      hpackWriter.writeHeaders(caze.getHeaders());
+      caze.setWire(bytesOut.readByteString());
+    }
+
+    testDecoder(story);
+  }
+}
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/Case.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/Case.java
new file mode 100644
index 0000000000..f1685f3800
--- /dev/null
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/Case.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2.hpackjson;
+
+import java.util.ArrayList;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import okhttp3.internal.http2.Header;
+import okio.ByteString;
+
+/**
+ * Representation of an individual case (set of headers and wire format). There are many cases for a
+ * single story.  This class is used reflectively with Moshi to parse stories.
+ */
+public class Case implements Cloneable {
+
+  private int seqno;
+  private String wire;
+  private List<Map<String, String>> headers;
+
+  public List<Header> getHeaders() {
+    List<Header> result = new ArrayList<>();
+    for (Map<String, String> inputHeader : headers) {
+      Map.Entry<String, String> entry = inputHeader.entrySet().iterator().next();
+      result.add(new Header(entry.getKey(), entry.getValue()));
+    }
+    return result;
+  }
+
+  public ByteString getWire() {
+    return ByteString.decodeHex(wire);
+  }
+
+  public int getSeqno() {
+    return seqno;
+  }
+
+  public void setWire(ByteString wire) {
+    this.wire = wire.hex();
+  }
+
+  @Override
+  protected Case clone() throws CloneNotSupportedException {
+    Case result = new Case();
+    result.seqno = seqno;
+    result.wire = wire;
+    result.headers = new ArrayList<>();
+    for (Map<String, String> header : headers) {
+      result.headers.add(new LinkedHashMap<String, String>(header));
+    }
+    return result;
+  }
+}
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/HpackJsonUtil.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/HpackJsonUtil.java
new file mode 100644
index 0000000000..39b1489d4b
--- /dev/null
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/HpackJsonUtil.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2.hpackjson;
+
+import com.squareup.moshi.JsonAdapter;
+import com.squareup.moshi.Moshi;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URISyntaxException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import okio.Okio;
+
+/**
+ * Utilities for reading HPACK tests.
+ */
+public final class HpackJsonUtil {
+  /** Earliest draft that is code-compatible with latest. */
+  private static final int BASE_DRAFT = 9;
+
+  private static final String STORY_RESOURCE_FORMAT = "/hpack-test-case/%s/story_%02d.json";
+
+  private static final Moshi MOSHI = new Moshi.Builder().build();
+  private static final JsonAdapter<Story> STORY_JSON_ADAPTER = MOSHI.adapter(Story.class);
+
+  private static Story readStory(InputStream jsonResource) throws IOException {
+    return STORY_JSON_ADAPTER.fromJson(Okio.buffer(Okio.source(jsonResource)));
+  }
+
+  private static Story readStory(File file) throws IOException {
+    return STORY_JSON_ADAPTER.fromJson(Okio.buffer(Okio.source(file)));
+  }
+
+  /** Iterate through the hpack-test-case resources, only picking stories for the current draft. */
+  public static String[] storiesForCurrentDraft() throws URISyntaxException {
+    File testCaseDirectory = new File(HpackJsonUtil.class.getResource("/hpack-test-case").toURI());
+    List<String> storyNames = new ArrayList<>();
+    for (File path : testCaseDirectory.listFiles()) {
+      if (path.isDirectory() && Arrays.asList(path.list()).contains("story_00.json")) {
+        try {
+          Story firstStory = readStory(new File(path, "story_00.json"));
+          if (firstStory.getDraft() >= BASE_DRAFT) {
+            storyNames.add(path.getName());
+          }
+        } catch (IOException ignored) {
+          // Skip this path.
+        }
+      }
+    }
+    return storyNames.toArray(new String[storyNames.size()]);
+  }
+
+  /**
+   * Reads stories named "story_xx.json" from the folder provided.
+   */
+  public static List<Story> readStories(String testFolderName) throws Exception {
+    List<Story> result = new ArrayList<>();
+    int i = 0;
+    while (true) { // break after last test.
+      String storyResourceName = String.format(STORY_RESOURCE_FORMAT, testFolderName, i);
+      InputStream storyInputStream = HpackJsonUtil.class.getResourceAsStream(storyResourceName);
+      if (storyInputStream == null) {
+        break;
+      }
+      try {
+        Story story = readStory(storyInputStream);
+        story.setFileName(storyResourceName);
+        result.add(story);
+        i++;
+      } finally {
+        storyInputStream.close();
+      }
+    }
+    return result;
+  }
+
+  private HpackJsonUtil() {
+  } // Utilities only.
+}
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/Story.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/Story.java
new file mode 100644
index 0000000000..288a87b81f
--- /dev/null
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/Story.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2.hpackjson;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Representation of one story, a set of request headers to encode or decode. This class is used
+ * reflectively with Moshi to parse stories from files.
+ */
+public class Story implements Cloneable {
+
+  private transient String fileName;
+  private List<Case> cases;
+  private int draft;
+  private String description;
+
+  /**
+   * The filename is only used in the toString representation.
+   */
+  void setFileName(String fileName) {
+    this.fileName = fileName;
+  }
+
+  public List<Case> getCases() {
+    return cases;
+  }
+
+  /** We only expect stories that match the draft we've implemented to pass. */
+  public int getDraft() {
+    return draft;
+  }
+
+  @Override
+  public Story clone() throws CloneNotSupportedException {
+    Story story = new Story();
+    story.fileName = this.fileName;
+    story.cases = new ArrayList<>();
+    for (Case caze : cases) {
+      story.cases.add(caze.clone());
+    }
+    story.draft = draft;
+    story.description = description;
+    return story;
+  }
+
+  @Override
+  public String toString() {
+    // Used as the test name.
+    return fileName;
+  }
+}
diff --git a/okhttp-hpacktests/src/test/resources/hpack-test-case b/okhttp-hpacktests/src/test/resources/hpack-test-case
new file mode 160000
index 0000000000..a5652bc2bc
--- /dev/null
+++ b/okhttp-hpacktests/src/test/resources/hpack-test-case
@@ -0,0 +1 @@
+Subproject commit a5652bc2bc3d2a992f39446369fb004a72e881d4
diff --git a/okhttp-logging-interceptor/README.md b/okhttp-logging-interceptor/README.md
new file mode 100644
index 0000000000..1c5dcd952a
--- /dev/null
+++ b/okhttp-logging-interceptor/README.md
@@ -0,0 +1,50 @@
+Logging Interceptor
+===================
+
+An [OkHttp interceptor][1] which logs HTTP request and response data.
+
+```java
+HttpLoggingInterceptor logging = new HttpLoggingInterceptor();
+logging.setLevel(Level.BASIC);
+OkHttpClient client = new OkHttpClient.Builder()
+  .addInterceptor(logging)
+  .build();
+```
+
+You can change the log level at any time by calling `setLevel`.
+
+To log to a custom location, pass a `Logger` instance to the constructor.
+```java
+HttpLoggingInterceptor logging = new HttpLoggingInterceptor(new Logger() {
+  @Override public void log(String message) {
+    Timber.tag("OkHttp").d(message);
+  }
+});
+```
+
+**Warning**: The logs generated by this interceptor when using the `HEADERS` or `BODY` levels has
+the potential to leak sensitive information such as "Authorization" or "Cookie" headers and the
+contents of request and response bodies. This data should only be logged in a controlled way or in
+a non-production environment.
+
+
+Download
+--------
+
+Get via Maven:
+```xml
+<dependency>
+  <groupId>com.squareup.okhttp3</groupId>
+  <artifactId>logging-interceptor</artifactId>
+  <version>(insert latest version)</version>
+</dependency>
+```
+
+or via Gradle 
+```groovy
+compile 'com.squareup.okhttp3:logging-interceptor:(insert latest version)'
+```
+
+
+
+ [1]: https://github.com/square/okhttp/wiki/Interceptors
diff --git a/okhttp-logging-interceptor/pom.xml b/okhttp-logging-interceptor/pom.xml
new file mode 100644
index 0000000000..275570d467
--- /dev/null
+++ b/okhttp-logging-interceptor/pom.xml
@@ -0,0 +1,45 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp3</groupId>
+    <artifactId>parent</artifactId>
+    <version>3.10.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>logging-interceptor</artifactId>
+  <name>OkHttp Logging Interceptor</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
new file mode 100644
index 0000000000..2eb8100a45
--- /dev/null
+++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
@@ -0,0 +1,295 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.logging;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.nio.charset.Charset;
+import java.util.concurrent.TimeUnit;
+import okhttp3.Connection;
+import okhttp3.Headers;
+import okhttp3.Interceptor;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.http.HttpHeaders;
+import okhttp3.internal.platform.Platform;
+import okio.Buffer;
+import okio.BufferedSource;
+
+import static okhttp3.internal.platform.Platform.INFO;
+
+/**
+ * An OkHttp interceptor which logs request and response information. Can be applied as an
+ * {@linkplain OkHttpClient#interceptors() application interceptor} or as a {@linkplain
+ * OkHttpClient#networkInterceptors() network interceptor}. <p> The format of the logs created by
+ * this class should not be considered stable and may change slightly between releases. If you need
+ * a stable logging format, use your own interceptor.
+ */
+public final class HttpLoggingInterceptor implements Interceptor {
+  private static final Charset UTF8 = Charset.forName("UTF-8");
+
+  public enum Level {
+    /** No logs. */
+    NONE,
+    /**
+     * Logs request and response lines.
+     *
+     * <p>Example:
+     * <pre>{@code
+     * --> POST /greeting http/1.1 (3-byte body)
+     *
+     * <-- 200 OK (22ms, 6-byte body)
+     * }</pre>
+     */
+    BASIC,
+    /**
+     * Logs request and response lines and their respective headers.
+     *
+     * <p>Example:
+     * <pre>{@code
+     * --> POST /greeting http/1.1
+     * Host: example.com
+     * Content-Type: plain/text
+     * Content-Length: 3
+     * --> END POST
+     *
+     * <-- 200 OK (22ms)
+     * Content-Type: plain/text
+     * Content-Length: 6
+     * <-- END HTTP
+     * }</pre>
+     */
+    HEADERS,
+    /**
+     * Logs request and response lines and their respective headers and bodies (if present).
+     *
+     * <p>Example:
+     * <pre>{@code
+     * --> POST /greeting http/1.1
+     * Host: example.com
+     * Content-Type: plain/text
+     * Content-Length: 3
+     *
+     * Hi?
+     * --> END POST
+     *
+     * <-- 200 OK (22ms)
+     * Content-Type: plain/text
+     * Content-Length: 6
+     *
+     * Hello!
+     * <-- END HTTP
+     * }</pre>
+     */
+    BODY
+  }
+
+  public interface Logger {
+    void log(String message);
+
+    /** A {@link Logger} defaults output appropriate for the current platform. */
+    Logger DEFAULT = new Logger() {
+      @Override public void log(String message) {
+        Platform.get().log(INFO, message, null);
+      }
+    };
+  }
+
+  public HttpLoggingInterceptor() {
+    this(Logger.DEFAULT);
+  }
+
+  public HttpLoggingInterceptor(Logger logger) {
+    this.logger = logger;
+  }
+
+  private final Logger logger;
+
+  private volatile Level level = Level.NONE;
+
+  /** Change the level at which this interceptor logs. */
+  public HttpLoggingInterceptor setLevel(Level level) {
+    if (level == null) throw new NullPointerException("level == null. Use Level.NONE instead.");
+    this.level = level;
+    return this;
+  }
+
+  public Level getLevel() {
+    return level;
+  }
+
+  @Override public Response intercept(Chain chain) throws IOException {
+    Level level = this.level;
+
+    Request request = chain.request();
+    if (level == Level.NONE) {
+      return chain.proceed(request);
+    }
+
+    boolean logBody = level == Level.BODY;
+    boolean logHeaders = logBody || level == Level.HEADERS;
+
+    RequestBody requestBody = request.body();
+    boolean hasRequestBody = requestBody != null;
+
+    Connection connection = chain.connection();
+    String requestStartMessage = "--> "
+        + request.method()
+        + ' ' + request.url()
+        + (connection != null ? " " + connection.protocol() : "");
+    if (!logHeaders && hasRequestBody) {
+      requestStartMessage += " (" + requestBody.contentLength() + "-byte body)";
+    }
+    logger.log(requestStartMessage);
+
+    if (logHeaders) {
+      if (hasRequestBody) {
+        // Request body headers are only present when installed as a network interceptor. Force
+        // them to be included (when available) so there values are known.
+        if (requestBody.contentType() != null) {
+          logger.log("Content-Type: " + requestBody.contentType());
+        }
+        if (requestBody.contentLength() != -1) {
+          logger.log("Content-Length: " + requestBody.contentLength());
+        }
+      }
+
+      Headers headers = request.headers();
+      for (int i = 0, count = headers.size(); i < count; i++) {
+        String name = headers.name(i);
+        // Skip headers from the request body as they are explicitly logged above.
+        if (!"Content-Type".equalsIgnoreCase(name) && !"Content-Length".equalsIgnoreCase(name)) {
+          logger.log(name + ": " + headers.value(i));
+        }
+      }
+
+      if (!logBody || !hasRequestBody) {
+        logger.log("--> END " + request.method());
+      } else if (bodyEncoded(request.headers())) {
+        logger.log("--> END " + request.method() + " (encoded body omitted)");
+      } else {
+        Buffer buffer = new Buffer();
+        requestBody.writeTo(buffer);
+
+        Charset charset = UTF8;
+        MediaType contentType = requestBody.contentType();
+        if (contentType != null) {
+          charset = contentType.charset(UTF8);
+        }
+
+        logger.log("");
+        if (isPlaintext(buffer)) {
+          logger.log(buffer.readString(charset));
+          logger.log("--> END " + request.method()
+              + " (" + requestBody.contentLength() + "-byte body)");
+        } else {
+          logger.log("--> END " + request.method() + " (binary "
+              + requestBody.contentLength() + "-byte body omitted)");
+        }
+      }
+    }
+
+    long startNs = System.nanoTime();
+    Response response;
+    try {
+      response = chain.proceed(request);
+    } catch (Exception e) {
+      logger.log("<-- HTTP FAILED: " + e);
+      throw e;
+    }
+    long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNs);
+
+    ResponseBody responseBody = response.body();
+    long contentLength = responseBody.contentLength();
+    String bodySize = contentLength != -1 ? contentLength + "-byte" : "unknown-length";
+    logger.log("<-- "
+        + response.code()
+        + (response.message().isEmpty() ? "" : ' ' + response.message())
+        + ' ' + response.request().url()
+        + " (" + tookMs + "ms" + (!logHeaders ? ", " + bodySize + " body" : "") + ')');
+
+    if (logHeaders) {
+      Headers headers = response.headers();
+      for (int i = 0, count = headers.size(); i < count; i++) {
+        logger.log(headers.name(i) + ": " + headers.value(i));
+      }
+
+      if (!logBody || !HttpHeaders.hasBody(response)) {
+        logger.log("<-- END HTTP");
+      } else if (bodyEncoded(response.headers())) {
+        logger.log("<-- END HTTP (encoded body omitted)");
+      } else {
+        BufferedSource source = responseBody.source();
+        source.request(Long.MAX_VALUE); // Buffer the entire body.
+        Buffer buffer = source.buffer();
+
+        Charset charset = UTF8;
+        MediaType contentType = responseBody.contentType();
+        if (contentType != null) {
+          charset = contentType.charset(UTF8);
+        }
+
+        if (!isPlaintext(buffer)) {
+          logger.log("");
+          logger.log("<-- END HTTP (binary " + buffer.size() + "-byte body omitted)");
+          return response;
+        }
+
+        if (contentLength != 0) {
+          logger.log("");
+          logger.log(buffer.clone().readString(charset));
+        }
+
+        logger.log("<-- END HTTP (" + buffer.size() + "-byte body)");
+      }
+    }
+
+    return response;
+  }
+
+  /**
+   * Returns true if the body in question probably contains human readable text. Uses a small sample
+   * of code points to detect unicode control characters commonly used in binary file signatures.
+   */
+  static boolean isPlaintext(Buffer buffer) {
+    try {
+      Buffer prefix = new Buffer();
+      long byteCount = buffer.size() < 64 ? buffer.size() : 64;
+      buffer.copyTo(prefix, 0, byteCount);
+      for (int i = 0; i < 16; i++) {
+        if (prefix.exhausted()) {
+          break;
+        }
+        int codePoint = prefix.readUtf8CodePoint();
+        if (Character.isISOControl(codePoint) && !Character.isWhitespace(codePoint)) {
+          return false;
+        }
+      }
+      return true;
+    } catch (EOFException e) {
+      return false; // Truncated UTF-8 sequence.
+    }
+  }
+
+  private boolean bodyEncoded(Headers headers) {
+    String contentEncoding = headers.get("Content-Encoding");
+    return contentEncoding != null && !contentEncoding.equalsIgnoreCase("identity");
+  }
+}
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/package-info.java b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/package-info.java
new file mode 100644
index 0000000000..39904701cf
--- /dev/null
+++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/package-info.java
@@ -0,0 +1,3 @@
+/** An OkHttp interceptor which logs HTTP request and response data. */
+@javax.annotation.ParametersAreNonnullByDefault
+package okhttp3.logging;
diff --git a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
new file mode 100644
index 0000000000..108ab18a7d
--- /dev/null
+++ b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
@@ -0,0 +1,734 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.logging;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.regex.Pattern;
+import javax.net.ssl.HostnameVerifier;
+import okhttp3.Dns;
+import okhttp3.HttpUrl;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.RecordingHostnameVerifier;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.internal.tls.SslClient;
+import okhttp3.logging.HttpLoggingInterceptor.Level;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.ByteString;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static org.hamcrest.CoreMatchers.equalTo;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeThat;
+
+public final class HttpLoggingInterceptorTest {
+  private static final MediaType PLAIN = MediaType.parse("text/plain; charset=utf-8");
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private SslClient sslClient = SslClient.localhost();
+  private HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+  private OkHttpClient client;
+  private String host;
+  private HttpUrl url;
+
+  private final LogRecorder networkLogs = new LogRecorder();
+  private final HttpLoggingInterceptor networkInterceptor =
+      new HttpLoggingInterceptor(networkLogs);
+
+  private final LogRecorder applicationLogs = new LogRecorder();
+  private final HttpLoggingInterceptor applicationInterceptor =
+      new HttpLoggingInterceptor(applicationLogs);
+
+  private void setLevel(Level level) {
+    networkInterceptor.setLevel(level);
+    applicationInterceptor.setLevel(level);
+  }
+
+  @Before public void setUp() {
+    client = new OkHttpClient.Builder()
+        .addNetworkInterceptor(networkInterceptor)
+        .addInterceptor(applicationInterceptor)
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(hostnameVerifier)
+        .build();
+
+    host = server.getHostName() + ":" + server.getPort();
+    url = server.url("/");
+  }
+
+  @Test public void levelGetter() {
+    // The default is NONE.
+    Assert.assertEquals(Level.NONE, applicationInterceptor.getLevel());
+
+    for (Level level : Level.values()) {
+      applicationInterceptor.setLevel(level);
+      assertEquals(level, applicationInterceptor.getLevel());
+    }
+  }
+
+  @Test public void setLevelShouldPreventNullValue() {
+    try {
+      applicationInterceptor.setLevel(null);
+      fail();
+    } catch (NullPointerException expected) {
+      assertEquals("level == null. Use Level.NONE instead.", expected.getMessage());
+    }
+  }
+
+  @Test public void setLevelShouldReturnSameInstanceOfInterceptor() {
+    for (Level level : Level.values()) {
+      assertSame(applicationInterceptor, applicationInterceptor.setLevel(level));
+    }
+  }
+
+  @Test public void none() throws IOException {
+    server.enqueue(new MockResponse());
+    client.newCall(request().build()).execute();
+
+    applicationLogs.assertNoMoreLogs();
+    networkLogs.assertNoMoreLogs();
+  }
+
+  @Test public void basicGet() throws IOException {
+    setLevel(Level.BASIC);
+
+    server.enqueue(new MockResponse());
+    client.newCall(request().build()).execute();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url)
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 0-byte body\\)")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 0-byte body\\)")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void basicPost() throws IOException {
+    setLevel(Level.BASIC);
+
+    server.enqueue(new MockResponse());
+    client.newCall(request().post(RequestBody.create(PLAIN, "Hi?")).build()).execute();
+
+    applicationLogs
+        .assertLogEqual("--> POST " + url + " (3-byte body)")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 0-byte body\\)")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> POST " + url + " http/1.1 (3-byte body)")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 0-byte body\\)")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void basicResponseBody() throws IOException {
+    setLevel(Level.BASIC);
+
+    server.enqueue(new MockResponse()
+        .setBody("Hello!")
+        .setHeader("Content-Type", PLAIN));
+    Response response = client.newCall(request().build()).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url)
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 6-byte body\\)")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 6-byte body\\)")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void basicChunkedResponseBody() throws IOException {
+    setLevel(Level.BASIC);
+
+    server.enqueue(new MockResponse()
+        .setChunkedBody("Hello!", 2)
+        .setHeader("Content-Type", PLAIN));
+    Response response = client.newCall(request().build()).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url)
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, unknown-length body\\)")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, unknown-length body\\)")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void headersGet() throws IOException {
+    setLevel(Level.HEADERS);
+
+    server.enqueue(new MockResponse());
+    Response response = client.newCall(request().build()).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url)
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void headersPost() throws IOException {
+    setLevel(Level.HEADERS);
+
+    server.enqueue(new MockResponse());
+    Request request = request().post(RequestBody.create(PLAIN, "Hi?")).build();
+    Response response = client.newCall(request).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> POST " + url)
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogEqual("Content-Length: 3")
+        .assertLogEqual("--> END POST")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> POST " + url + " http/1.1")
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogEqual("Content-Length: 3")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END POST")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void headersPostNoContentType() throws IOException {
+    setLevel(Level.HEADERS);
+
+    server.enqueue(new MockResponse());
+    Request request = request().post(RequestBody.create(null, "Hi?")).build();
+    Response response = client.newCall(request).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> POST " + url)
+        .assertLogEqual("Content-Length: 3")
+        .assertLogEqual("--> END POST")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> POST " + url + " http/1.1")
+        .assertLogEqual("Content-Length: 3")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END POST")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void headersPostNoLength() throws IOException {
+    setLevel(Level.HEADERS);
+
+    server.enqueue(new MockResponse());
+    RequestBody body = new RequestBody() {
+      @Override public MediaType contentType() {
+        return PLAIN;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.writeUtf8("Hi!");
+      }
+    };
+    Response response = client.newCall(request().post(body).build()).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> POST " + url)
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogEqual("--> END POST")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> POST " + url + " http/1.1")
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogEqual("Transfer-Encoding: chunked")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END POST")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void headersResponseBody() throws IOException {
+    setLevel(Level.HEADERS);
+
+    server.enqueue(new MockResponse()
+        .setBody("Hello!")
+        .setHeader("Content-Type", PLAIN));
+    Response response = client.newCall(request().build()).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url)
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 6")
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 6")
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void bodyGet() throws IOException {
+    setLevel(Level.BODY);
+
+    server.enqueue(new MockResponse());
+    Response response = client.newCall(request().build()).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url)
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP (0-byte body)")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP (0-byte body)")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void bodyGet204() throws IOException {
+    setLevel(Level.BODY);
+    bodyGetNoBody(204);
+  }
+
+  @Test public void bodyGet205() throws IOException {
+    setLevel(Level.BODY);
+    bodyGetNoBody(205);
+  }
+
+  private void bodyGetNoBody(int code) throws IOException {
+    server.enqueue(new MockResponse()
+        .setStatus("HTTP/1.1 " + code + " No Content"));
+    Response response = client.newCall(request().build()).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url)
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- " + code + " No Content " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP (0-byte body)")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- " + code + " No Content " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP (0-byte body)")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void bodyPost() throws IOException {
+    setLevel(Level.BODY);
+
+    server.enqueue(new MockResponse());
+    Request request = request().post(RequestBody.create(PLAIN, "Hi?")).build();
+    Response response = client.newCall(request).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> POST " + url)
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogEqual("Content-Length: 3")
+        .assertLogEqual("")
+        .assertLogEqual("Hi?")
+        .assertLogEqual("--> END POST (3-byte body)")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP (0-byte body)")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> POST " + url + " http/1.1")
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogEqual("Content-Length: 3")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("")
+        .assertLogEqual("Hi?")
+        .assertLogEqual("--> END POST (3-byte body)")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP (0-byte body)")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void bodyResponseBody() throws IOException {
+    setLevel(Level.BODY);
+
+    server.enqueue(new MockResponse()
+        .setBody("Hello!")
+        .setHeader("Content-Type", PLAIN));
+    Response response = client.newCall(request().build()).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url)
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 6")
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogEqual("")
+        .assertLogEqual("Hello!")
+        .assertLogEqual("<-- END HTTP (6-byte body)")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 6")
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogEqual("")
+        .assertLogEqual("Hello!")
+        .assertLogEqual("<-- END HTTP (6-byte body)")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void bodyResponseBodyChunked() throws IOException {
+    setLevel(Level.BODY);
+
+    server.enqueue(new MockResponse()
+        .setChunkedBody("Hello!", 2)
+        .setHeader("Content-Type", PLAIN));
+    Response response = client.newCall(request().build()).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url)
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Transfer-encoding: chunked")
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogEqual("")
+        .assertLogEqual("Hello!")
+        .assertLogEqual("<-- END HTTP (6-byte body)")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Transfer-encoding: chunked")
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogEqual("")
+        .assertLogEqual("Hello!")
+        .assertLogEqual("<-- END HTTP (6-byte body)")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void bodyResponseNotIdentityEncoded() throws IOException {
+    setLevel(Level.BODY);
+
+    server.enqueue(new MockResponse()
+        .setHeader("Content-Encoding", "gzip")
+        .setHeader("Content-Type", PLAIN)
+        .setBody(new Buffer().write(ByteString.decodeBase64(
+            "H4sIAAAAAAAAAPNIzcnJ11HwQKIAdyO+9hMAAAA="))));
+    Response response = client.newCall(request().build()).execute();
+    response.body().close();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Encoding: gzip")
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogMatch("Content-Length: \\d+")
+        .assertLogEqual("<-- END HTTP (encoded body omitted)")
+        .assertNoMoreLogs();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url)
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogEqual("")
+        .assertLogEqual("Hello, Hello, Hello")
+        .assertLogEqual("<-- END HTTP (19-byte body)")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void bodyGetMalformedCharset() throws IOException {
+    setLevel(Level.BODY);
+
+    server.enqueue(new MockResponse()
+        .setHeader("Content-Type", "text/html; charset=0")
+        .setBody("Body with unknown charset"));
+    Response response = client.newCall(request().build()).execute();
+    response.body().close();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Type: text/html; charset=0")
+        .assertLogMatch("Content-Length: \\d+")
+        .assertLogMatch("")
+        .assertLogEqual("Body with unknown charset")
+        .assertLogEqual("<-- END HTTP (25-byte body)")
+        .assertNoMoreLogs();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url)
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Type: text/html; charset=0")
+        .assertLogMatch("Content-Length: \\d+")
+        .assertLogEqual("")
+        .assertLogEqual("Body with unknown charset")
+        .assertLogEqual("<-- END HTTP (25-byte body)")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void isPlaintext() throws IOException {
+    assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer()));
+    assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer().writeUtf8("abc")));
+    assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer().writeUtf8("new\r\nlines")));
+    assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer().writeUtf8("white\t space")));
+    assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer().writeByte(0x80)));
+    assertFalse(HttpLoggingInterceptor.isPlaintext(new Buffer().writeByte(0x00)));
+    assertFalse(HttpLoggingInterceptor.isPlaintext(new Buffer().writeByte(0xc0)));
+  }
+
+  @Test public void responseBodyIsBinary() throws IOException {
+    setLevel(Level.BODY);
+    Buffer buffer = new Buffer();
+    buffer.writeUtf8CodePoint(0x89);
+    buffer.writeUtf8CodePoint(0x50);
+    buffer.writeUtf8CodePoint(0x4e);
+    buffer.writeUtf8CodePoint(0x47);
+    buffer.writeUtf8CodePoint(0x0d);
+    buffer.writeUtf8CodePoint(0x0a);
+    buffer.writeUtf8CodePoint(0x1a);
+    buffer.writeUtf8CodePoint(0x0a);
+    server.enqueue(new MockResponse()
+        .setBody(buffer)
+        .setHeader("Content-Type", "image/png; charset=utf-8"));
+    Response response = client.newCall(request().build()).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url)
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 9")
+        .assertLogEqual("Content-Type: image/png; charset=utf-8")
+        .assertLogEqual("")
+        .assertLogEqual("<-- END HTTP (binary 9-byte body omitted)")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 9")
+        .assertLogEqual("Content-Type: image/png; charset=utf-8")
+        .assertLogEqual("")
+        .assertLogEqual("<-- END HTTP (binary 9-byte body omitted)")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void connectFail() throws IOException {
+    setLevel(Level.BASIC);
+    client = new OkHttpClient.Builder()
+        .dns(new Dns() {
+          @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
+            throw new UnknownHostException("reason");
+          }
+        })
+        .addInterceptor(applicationInterceptor)
+        .build();
+
+    try {
+      client.newCall(request().build()).execute();
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url)
+        .assertLogEqual("<-- HTTP FAILED: java.net.UnknownHostException: reason")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void http2() throws Exception {
+    server.useHttps(sslClient.socketFactory, false);
+    url = server.url("/");
+
+    setLevel(Level.BASIC);
+
+    server.enqueue(new MockResponse());
+    Response response = client.newCall(request().build()).execute();
+    assumeThat(response.protocol(), equalTo(Protocol.HTTP_2));
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url)
+        .assertLogMatch("<-- 200 " + url + " \\(\\d+ms, 0-byte body\\)")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " h2")
+        .assertLogMatch("<-- 200 " + url + " \\(\\d+ms, 0-byte body\\)")
+        .assertNoMoreLogs();
+  }
+
+  private Request.Builder request() {
+    return new Request.Builder().url(url);
+  }
+
+  private static class LogRecorder implements HttpLoggingInterceptor.Logger {
+    private final List<String> logs = new ArrayList<>();
+    private int index;
+
+    LogRecorder assertLogEqual(String expected) {
+      assertTrue("No more messages found", index < logs.size());
+      String actual = logs.get(index++);
+      assertEquals(expected, actual);
+      return this;
+    }
+
+    LogRecorder assertLogMatch(String pattern) {
+      assertTrue("No more messages found", index < logs.size());
+      String actual = logs.get(index++);
+      assertTrue("<" + actual + "> did not match pattern <" + pattern + ">",
+          Pattern.matches(pattern, actual));
+      return this;
+    }
+
+    void assertNoMoreLogs() {
+      assertTrue("More messages remain: " + logs.subList(index, logs.size()), index == logs.size());
+    }
+
+    @Override public void log(String message) {
+      logs.add(message);
+    }
+  }
+}
diff --git a/okhttp-testing-support/pom.xml b/okhttp-testing-support/pom.xml
new file mode 100644
index 0000000000..3605a66add
--- /dev/null
+++ b/okhttp-testing-support/pom.xml
@@ -0,0 +1,32 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp3</groupId>
+    <artifactId>parent</artifactId>
+    <version>3.10.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>okhttp-testing-support</artifactId>
+  <name>OkHttp test support classes</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <optional>true</optional>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java b/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java
new file mode 100644
index 0000000000..e12ea9c622
--- /dev/null
+++ b/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+
+import static org.junit.Assert.assertEquals;
+
+public final class FakeDns implements Dns {
+  private final Map<String, List<InetAddress>> hostAddresses = new LinkedHashMap<>();
+  private final List<String> requestedHosts = new ArrayList<>();
+  private int nextAddress = 100;
+
+  /** Sets the results for {@code hostname}. */
+  public FakeDns set(String hostname, List<InetAddress> addresses) {
+    hostAddresses.put(hostname, addresses);
+    return this;
+  }
+
+  /** Clears the results for {@code hostname}. */
+  public FakeDns clear(String hostname) {
+    hostAddresses.remove(hostname);
+    return this;
+  }
+
+  public InetAddress lookup(String hostname, int index) throws UnknownHostException {
+    return hostAddresses.get(hostname).get(index);
+  }
+
+  @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
+    requestedHosts.add(hostname);
+
+    List<InetAddress> result = hostAddresses.get(hostname);
+    if (result != null) return result;
+
+    throw new UnknownHostException();
+  }
+
+  public void assertRequests(String... expectedHosts) {
+    assertEquals(Arrays.asList(expectedHosts), requestedHosts);
+    requestedHosts.clear();
+  }
+
+  /** Allocates and returns {@code count} fake addresses like [255.0.0.100, 255.0.0.101]. */
+  public List<InetAddress> allocate(int count) {
+    try {
+      List<InetAddress> result = new ArrayList<>();
+      for (int i = 0; i < count; i++) {
+        if (nextAddress > 255) {
+          throw new AssertionError("too many addresses allocated");
+        }
+        result.add(InetAddress.getByAddress(
+            new byte[] {(byte) 255, (byte) 0, (byte) 0, (byte) nextAddress++}));
+      }
+      return result;
+    } catch (UnknownHostException e) {
+      throw new AssertionError();
+    }
+  }
+}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/FakeProxySelector.java b/okhttp-testing-support/src/main/java/okhttp3/FakeProxySelector.java
new file mode 100644
index 0000000000..c7d37f57ea
--- /dev/null
+++ b/okhttp-testing-support/src/main/java/okhttp3/FakeProxySelector.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.Proxy;
+import java.net.ProxySelector;
+import java.net.SocketAddress;
+import java.net.URI;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+public final class FakeProxySelector extends ProxySelector {
+  public final List<Proxy> proxies = new ArrayList<>();
+
+  public FakeProxySelector addProxy(Proxy proxy) {
+    proxies.add(proxy);
+    return this;
+  }
+
+  @Override public List<Proxy> select(URI uri) {
+    // Don't handle 'socket' schemes, which the RI's Socket class may request (for SOCKS).
+    return uri.getScheme().equals("http") || uri.getScheme().equals("https") ? proxies
+        : Collections.singletonList(Proxy.NO_PROXY);
+  }
+
+  @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
+  }
+}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/FakeSSLSession.java b/okhttp-testing-support/src/main/java/okhttp3/FakeSSLSession.java
new file mode 100644
index 0000000000..ab67a9f06e
--- /dev/null
+++ b/okhttp-testing-support/src/main/java/okhttp3/FakeSSLSession.java
@@ -0,0 +1,120 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with this
+ * work for additional information regarding copyright ownership. The ASF
+ * licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package okhttp3;
+
+import java.security.Principal;
+import java.security.cert.Certificate;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSession;
+import javax.net.ssl.SSLSessionContext;
+import javax.security.cert.X509Certificate;
+
+public final class FakeSSLSession implements SSLSession {
+  private final Certificate[] certificates;
+
+  public FakeSSLSession(Certificate... certificates) throws Exception {
+    this.certificates = certificates;
+  }
+
+  public int getApplicationBufferSize() {
+    throw new UnsupportedOperationException();
+  }
+
+  public String getCipherSuite() {
+    throw new UnsupportedOperationException();
+  }
+
+  public long getCreationTime() {
+    throw new UnsupportedOperationException();
+  }
+
+  public byte[] getId() {
+    throw new UnsupportedOperationException();
+  }
+
+  public long getLastAccessedTime() {
+    throw new UnsupportedOperationException();
+  }
+
+  public Certificate[] getLocalCertificates() {
+    throw new UnsupportedOperationException();
+  }
+
+  public Principal getLocalPrincipal() {
+    throw new UnsupportedOperationException();
+  }
+
+  public int getPacketBufferSize() {
+    throw new UnsupportedOperationException();
+  }
+
+  public Certificate[] getPeerCertificates() throws SSLPeerUnverifiedException {
+    if (certificates.length == 0) {
+      throw new SSLPeerUnverifiedException("peer not authenticated");
+    } else {
+      return certificates;
+    }
+  }
+
+  public X509Certificate[] getPeerCertificateChain() throws SSLPeerUnverifiedException {
+    throw new UnsupportedOperationException();
+  }
+
+  public String getPeerHost() {
+    throw new UnsupportedOperationException();
+  }
+
+  public int getPeerPort() {
+    throw new UnsupportedOperationException();
+  }
+
+  public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
+    throw new UnsupportedOperationException();
+  }
+
+  public String getProtocol() {
+    throw new UnsupportedOperationException();
+  }
+
+  public SSLSessionContext getSessionContext() {
+    throw new UnsupportedOperationException();
+  }
+
+  public void putValue(String s, Object obj) {
+    throw new UnsupportedOperationException();
+  }
+
+  public void removeValue(String s) {
+    throw new UnsupportedOperationException();
+  }
+
+  public Object getValue(String s) {
+    throw new UnsupportedOperationException();
+  }
+
+  public String[] getValueNames() {
+    throw new UnsupportedOperationException();
+  }
+
+  public void invalidate() {
+    throw new UnsupportedOperationException();
+  }
+
+  public boolean isValid() {
+    throw new UnsupportedOperationException();
+  }
+}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/RecordingCookieJar.java b/okhttp-testing-support/src/main/java/okhttp3/RecordingCookieJar.java
new file mode 100644
index 0000000000..bd4f9be142
--- /dev/null
+++ b/okhttp-testing-support/src/main/java/okhttp3/RecordingCookieJar.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Deque;
+import java.util.List;
+
+import static org.junit.Assert.assertEquals;
+
+public final class RecordingCookieJar implements CookieJar {
+  private final Deque<List<Cookie>> requestCookies = new ArrayDeque<>();
+  private final Deque<List<Cookie>> responseCookies = new ArrayDeque<>();
+
+  public void enqueueRequestCookies(Cookie... cookies) {
+    requestCookies.add(Arrays.asList(cookies));
+  }
+
+  public List<Cookie> takeResponseCookies() {
+    return responseCookies.removeFirst();
+  }
+
+  public void assertResponseCookies(String... cookies) {
+    List<Cookie> actualCookies = takeResponseCookies();
+    List<String> actualCookieStrings = new ArrayList<>();
+    for (Cookie cookie : actualCookies) {
+      actualCookieStrings.add(cookie.toString());
+    }
+    assertEquals(Arrays.asList(cookies), actualCookieStrings);
+  }
+
+  @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {
+    responseCookies.add(cookies);
+  }
+
+  @Override public List<Cookie> loadForRequest(HttpUrl url) {
+    if (requestCookies.isEmpty()) return Collections.emptyList();
+    return requestCookies.removeFirst();
+  }
+}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/RecordingHostnameVerifier.java b/okhttp-testing-support/src/main/java/okhttp3/RecordingHostnameVerifier.java
new file mode 100644
index 0000000000..568b7c518c
--- /dev/null
+++ b/okhttp-testing-support/src/main/java/okhttp3/RecordingHostnameVerifier.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2013 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.util.ArrayList;
+import java.util.List;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLSession;
+
+public final class RecordingHostnameVerifier implements HostnameVerifier {
+  public final List<String> calls = new ArrayList<>();
+
+  public boolean verify(String hostname, SSLSession session) {
+    calls.add("verify " + hostname);
+    return true;
+  }
+}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/internal/io/InMemoryFileSystem.java b/okhttp-testing-support/src/main/java/okhttp3/internal/io/InMemoryFileSystem.java
new file mode 100644
index 0000000000..bb6f519092
--- /dev/null
+++ b/okhttp-testing-support/src/main/java/okhttp3/internal/io/InMemoryFileSystem.java
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.io;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.IdentityHashMap;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import okio.Buffer;
+import okio.ForwardingSink;
+import okio.ForwardingSource;
+import okio.Sink;
+import okio.Source;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+/** A simple file system where all files are held in memory. Not safe for concurrent use. */
+public final class InMemoryFileSystem implements FileSystem, TestRule {
+  private final Map<File, Buffer> files = new LinkedHashMap<>();
+  private final Map<Source, File> openSources = new IdentityHashMap<>();
+  private final Map<Sink, File> openSinks = new IdentityHashMap<>();
+
+  @Override public Statement apply(final Statement base, Description description) {
+    return new Statement() {
+      @Override public void evaluate() throws Throwable {
+        base.evaluate();
+        ensureResourcesClosed();
+      }
+    };
+  }
+
+  public void ensureResourcesClosed() {
+    List<String> openResources = new ArrayList<>();
+    for (File file : openSources.values()) {
+      openResources.add("Source for " + file);
+    }
+    for (File file : openSinks.values()) {
+      openResources.add("Sink for " + file);
+    }
+    if (!openResources.isEmpty()) {
+      StringBuilder builder = new StringBuilder("Resources acquired but not closed:");
+      for (String resource : openResources) {
+        builder.append("\n * ").append(resource);
+      }
+      throw new IllegalStateException(builder.toString());
+    }
+  }
+
+  @Override public Source source(File file) throws FileNotFoundException {
+    Buffer result = files.get(file);
+    if (result == null) throw new FileNotFoundException();
+
+    final Source source = result.clone();
+    openSources.put(source, file);
+
+    return new ForwardingSource(source) {
+      @Override public void close() throws IOException {
+        openSources.remove(source);
+        super.close();
+      }
+    };
+  }
+
+  @Override public Sink sink(File file) throws FileNotFoundException {
+    return sink(file, false);
+  }
+
+  @Override public Sink appendingSink(File file) throws FileNotFoundException {
+    return sink(file, true);
+  }
+
+  private Sink sink(File file, boolean appending) {
+    Buffer result = null;
+    if (appending) {
+      result = files.get(file);
+    }
+    if (result == null) {
+      result = new Buffer();
+    }
+    files.put(file, result);
+
+    final Sink sink = result;
+    openSinks.put(sink, file);
+
+    return new ForwardingSink(sink) {
+      @Override public void close() throws IOException {
+        openSinks.remove(sink);
+        super.close();
+      }
+    };
+  }
+
+  @Override public void delete(File file) throws IOException {
+    files.remove(file);
+  }
+
+  @Override public boolean exists(File file) {
+    return files.containsKey(file);
+  }
+
+  @Override public long size(File file) {
+    Buffer buffer = files.get(file);
+    return buffer != null ? buffer.size() : 0L;
+  }
+
+  @Override public void rename(File from, File to) throws IOException {
+    Buffer buffer = files.remove(from);
+    if (buffer == null) throw new FileNotFoundException();
+    files.put(to, buffer);
+  }
+
+  @Override public void deleteContents(File directory) throws IOException {
+    String prefix = directory.toString() + "/";
+    for (Iterator<File> i = files.keySet().iterator(); i.hasNext(); ) {
+      File file = i.next();
+      if (file.toString().startsWith(prefix)) i.remove();
+    }
+  }
+}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/testing/InstallUncaughtExceptionHandlerListener.java b/okhttp-testing-support/src/main/java/okhttp3/testing/InstallUncaughtExceptionHandlerListener.java
new file mode 100644
index 0000000000..38652c07de
--- /dev/null
+++ b/okhttp-testing-support/src/main/java/okhttp3/testing/InstallUncaughtExceptionHandlerListener.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.testing;
+
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import org.junit.runner.Description;
+import org.junit.runner.Result;
+import org.junit.runner.notification.RunListener;
+
+/**
+ * A {@link org.junit.runner.notification.RunListener} used to install an aggressive default {@link
+ * java.lang.Thread.UncaughtExceptionHandler} similar to the one found on Android. No exceptions
+ * should escape from OkHttp that might cause apps to be killed or tests to fail on Android.
+ */
+public class InstallUncaughtExceptionHandlerListener extends RunListener {
+
+  private Thread.UncaughtExceptionHandler oldDefaultUncaughtExceptionHandler;
+  private Description lastTestStarted;
+
+  @Override public void testRunStarted(Description description) throws Exception {
+    System.err.println("Installing aggressive uncaught exception handler");
+    oldDefaultUncaughtExceptionHandler = Thread.getDefaultUncaughtExceptionHandler();
+    Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
+      @Override public void uncaughtException(Thread thread, Throwable throwable) {
+        StringWriter errorText = new StringWriter(256);
+        errorText.append("Uncaught exception in OkHttp thread \"");
+        errorText.append(thread.getName());
+        errorText.append("\"\n");
+        throwable.printStackTrace(new PrintWriter(errorText));
+        errorText.append("\n");
+        if (lastTestStarted != null) {
+          errorText.append("Last test to start was: ");
+          errorText.append(lastTestStarted.getDisplayName());
+          errorText.append("\n");
+        }
+        System.err.print(errorText.toString());
+        System.exit(-1);
+      }
+    });
+  }
+
+  @Override public void testStarted(Description description) throws Exception {
+    lastTestStarted = description;
+  }
+
+  @Override public void testRunFinished(Result result) throws Exception {
+    Thread.setDefaultUncaughtExceptionHandler(oldDefaultUncaughtExceptionHandler);
+    System.err.println("Uninstalled aggressive uncaught exception handler");
+  }
+}
diff --git a/okhttp-tests/fuzzingserver-config.json b/okhttp-tests/fuzzingserver-config.json
new file mode 100644
index 0000000000..f9a3e1f597
--- /dev/null
+++ b/okhttp-tests/fuzzingserver-config.json
@@ -0,0 +1,153 @@
+{
+  "url": "ws://127.0.0.1:9099",
+  "outdir": "./target/fuzzingserver-report",
+  "cases": ["*"],
+  "exclude-cases": [
+    "6.1.1",
+    "6.1.2",
+    "6.1.3",
+    "6.2.1",
+    "6.2.2",
+    "6.2.3",
+    "6.2.4",
+    "6.3.1",
+    "6.3.2",
+    "6.4.1",
+    "6.4.2",
+    "6.4.3",
+    "6.4.4",
+    "6.5.1",
+    "6.5.2",
+    "6.5.3",
+    "6.5.4",
+    "6.5.5",
+    "6.6.1",
+    "6.6.2",
+    "6.6.3",
+    "6.6.4",
+    "6.6.5",
+    "6.6.6",
+    "6.6.7",
+    "6.6.8",
+    "6.6.9",
+    "6.6.10",
+    "6.6.11",
+    "6.7.1",
+    "6.7.2",
+    "6.7.3",
+    "6.7.4",
+    "6.8.1",
+    "6.8.2",
+    "6.9.1",
+    "6.9.2",
+    "6.9.3",
+    "6.9.4",
+    "6.10.1",
+    "6.10.2",
+    "6.10.3",
+    "6.11.1",
+    "6.11.2",
+    "6.11.3",
+    "6.11.4",
+    "6.11.5",
+    "6.12.1",
+    "6.12.2",
+    "6.12.3",
+    "6.12.4",
+    "6.12.5",
+    "6.12.6",
+    "6.12.7",
+    "6.12.8",
+    "6.13.1",
+    "6.13.2",
+    "6.13.3",
+    "6.13.4",
+    "6.13.5",
+    "6.14.1",
+    "6.14.2",
+    "6.14.3",
+    "6.14.4",
+    "6.14.5",
+    "6.14.6",
+    "6.14.7",
+    "6.14.8",
+    "6.14.9",
+    "6.14.10",
+    "6.15.1",
+    "6.16.1",
+    "6.16.2",
+    "6.16.3",
+    "6.17.1",
+    "6.17.2",
+    "6.17.3",
+    "6.17.4",
+    "6.17.5",
+    "6.18.1",
+    "6.18.2",
+    "6.18.3",
+    "6.18.4",
+    "6.18.5",
+    "6.19.1",
+    "6.19.2",
+    "6.19.3",
+    "6.19.4",
+    "6.19.5",
+    "6.20.1",
+    "6.20.2",
+    "6.20.3",
+    "6.20.4",
+    "6.20.5",
+    "6.20.6",
+    "6.20.7",
+    "6.21.1",
+    "6.21.2",
+    "6.21.3",
+    "6.21.4",
+    "6.21.5",
+    "6.21.6",
+    "6.21.7",
+    "6.21.8",
+    "6.22.1",
+    "6.22.2",
+    "6.22.3",
+    "6.22.4",
+    "6.22.5",
+    "6.22.6",
+    "6.22.7",
+    "6.22.8",
+    "6.22.9",
+    "6.22.10",
+    "6.22.11",
+    "6.22.12",
+    "6.22.13",
+    "6.22.14",
+    "6.22.15",
+    "6.22.16",
+    "6.22.17",
+    "6.22.18",
+    "6.22.19",
+    "6.22.20",
+    "6.22.21",
+    "6.22.22",
+    "6.22.23",
+    "6.22.24",
+    "6.22.25",
+    "6.22.26",
+    "6.22.27",
+    "6.22.28",
+    "6.22.29",
+    "6.22.30",
+    "6.22.31",
+    "6.22.32",
+    "6.22.33",
+    "6.22.34",
+    "6.23.1",
+    "6.23.2",
+    "6.23.3",
+    "6.23.4",
+    "6.23.5",
+    "6.23.6",
+    "6.23.7"
+  ],
+  "exclude-agent-cases": {}
+}
diff --git a/okhttp-tests/fuzzingserver-expected.txt b/okhttp-tests/fuzzingserver-expected.txt
new file mode 100644
index 0000000000..f0f6ed0bbd
--- /dev/null
+++ b/okhttp-tests/fuzzingserver-expected.txt
@@ -0,0 +1,376 @@
+"1.1.1 OK"
+"1.1.2 OK"
+"1.1.3 OK"
+"1.1.4 OK"
+"1.1.5 OK"
+"1.1.6 OK"
+"1.1.7 OK"
+"1.1.8 OK"
+"1.2.1 OK"
+"1.2.2 OK"
+"1.2.3 OK"
+"1.2.4 OK"
+"1.2.5 OK"
+"1.2.6 OK"
+"1.2.7 OK"
+"1.2.8 OK"
+"10.1.1 OK"
+"12.1.1 UNIMPLEMENTED"
+"12.1.10 UNIMPLEMENTED"
+"12.1.11 UNIMPLEMENTED"
+"12.1.12 UNIMPLEMENTED"
+"12.1.13 UNIMPLEMENTED"
+"12.1.14 UNIMPLEMENTED"
+"12.1.15 UNIMPLEMENTED"
+"12.1.16 UNIMPLEMENTED"
+"12.1.17 UNIMPLEMENTED"
+"12.1.18 UNIMPLEMENTED"
+"12.1.2 UNIMPLEMENTED"
+"12.1.3 UNIMPLEMENTED"
+"12.1.4 UNIMPLEMENTED"
+"12.1.5 UNIMPLEMENTED"
+"12.1.6 UNIMPLEMENTED"
+"12.1.7 UNIMPLEMENTED"
+"12.1.8 UNIMPLEMENTED"
+"12.1.9 UNIMPLEMENTED"
+"12.2.1 UNIMPLEMENTED"
+"12.2.10 UNIMPLEMENTED"
+"12.2.11 UNIMPLEMENTED"
+"12.2.12 UNIMPLEMENTED"
+"12.2.13 UNIMPLEMENTED"
+"12.2.14 UNIMPLEMENTED"
+"12.2.15 UNIMPLEMENTED"
+"12.2.16 UNIMPLEMENTED"
+"12.2.17 UNIMPLEMENTED"
+"12.2.18 UNIMPLEMENTED"
+"12.2.2 UNIMPLEMENTED"
+"12.2.3 UNIMPLEMENTED"
+"12.2.4 UNIMPLEMENTED"
+"12.2.5 UNIMPLEMENTED"
+"12.2.6 UNIMPLEMENTED"
+"12.2.7 UNIMPLEMENTED"
+"12.2.8 UNIMPLEMENTED"
+"12.2.9 UNIMPLEMENTED"
+"12.3.1 UNIMPLEMENTED"
+"12.3.10 UNIMPLEMENTED"
+"12.3.11 UNIMPLEMENTED"
+"12.3.12 UNIMPLEMENTED"
+"12.3.13 UNIMPLEMENTED"
+"12.3.14 UNIMPLEMENTED"
+"12.3.15 UNIMPLEMENTED"
+"12.3.16 UNIMPLEMENTED"
+"12.3.17 UNIMPLEMENTED"
+"12.3.18 UNIMPLEMENTED"
+"12.3.2 UNIMPLEMENTED"
+"12.3.3 UNIMPLEMENTED"
+"12.3.4 UNIMPLEMENTED"
+"12.3.5 UNIMPLEMENTED"
+"12.3.6 UNIMPLEMENTED"
+"12.3.7 UNIMPLEMENTED"
+"12.3.8 UNIMPLEMENTED"
+"12.3.9 UNIMPLEMENTED"
+"12.4.1 UNIMPLEMENTED"
+"12.4.10 UNIMPLEMENTED"
+"12.4.11 UNIMPLEMENTED"
+"12.4.12 UNIMPLEMENTED"
+"12.4.13 UNIMPLEMENTED"
+"12.4.14 UNIMPLEMENTED"
+"12.4.15 UNIMPLEMENTED"
+"12.4.16 UNIMPLEMENTED"
+"12.4.17 UNIMPLEMENTED"
+"12.4.18 UNIMPLEMENTED"
+"12.4.2 UNIMPLEMENTED"
+"12.4.3 UNIMPLEMENTED"
+"12.4.4 UNIMPLEMENTED"
+"12.4.5 UNIMPLEMENTED"
+"12.4.6 UNIMPLEMENTED"
+"12.4.7 UNIMPLEMENTED"
+"12.4.8 UNIMPLEMENTED"
+"12.4.9 UNIMPLEMENTED"
+"12.5.1 UNIMPLEMENTED"
+"12.5.10 UNIMPLEMENTED"
+"12.5.11 UNIMPLEMENTED"
+"12.5.12 UNIMPLEMENTED"
+"12.5.13 UNIMPLEMENTED"
+"12.5.14 UNIMPLEMENTED"
+"12.5.15 UNIMPLEMENTED"
+"12.5.16 UNIMPLEMENTED"
+"12.5.17 UNIMPLEMENTED"
+"12.5.18 UNIMPLEMENTED"
+"12.5.2 UNIMPLEMENTED"
+"12.5.3 UNIMPLEMENTED"
+"12.5.4 UNIMPLEMENTED"
+"12.5.5 UNIMPLEMENTED"
+"12.5.6 UNIMPLEMENTED"
+"12.5.7 UNIMPLEMENTED"
+"12.5.8 UNIMPLEMENTED"
+"12.5.9 UNIMPLEMENTED"
+"13.1.1 UNIMPLEMENTED"
+"13.1.10 UNIMPLEMENTED"
+"13.1.11 UNIMPLEMENTED"
+"13.1.12 UNIMPLEMENTED"
+"13.1.13 UNIMPLEMENTED"
+"13.1.14 UNIMPLEMENTED"
+"13.1.15 UNIMPLEMENTED"
+"13.1.16 UNIMPLEMENTED"
+"13.1.17 UNIMPLEMENTED"
+"13.1.18 UNIMPLEMENTED"
+"13.1.2 UNIMPLEMENTED"
+"13.1.3 UNIMPLEMENTED"
+"13.1.4 UNIMPLEMENTED"
+"13.1.5 UNIMPLEMENTED"
+"13.1.6 UNIMPLEMENTED"
+"13.1.7 UNIMPLEMENTED"
+"13.1.8 UNIMPLEMENTED"
+"13.1.9 UNIMPLEMENTED"
+"13.2.1 UNIMPLEMENTED"
+"13.2.10 UNIMPLEMENTED"
+"13.2.11 UNIMPLEMENTED"
+"13.2.12 UNIMPLEMENTED"
+"13.2.13 UNIMPLEMENTED"
+"13.2.14 UNIMPLEMENTED"
+"13.2.15 UNIMPLEMENTED"
+"13.2.16 UNIMPLEMENTED"
+"13.2.17 UNIMPLEMENTED"
+"13.2.18 UNIMPLEMENTED"
+"13.2.2 UNIMPLEMENTED"
+"13.2.3 UNIMPLEMENTED"
+"13.2.4 UNIMPLEMENTED"
+"13.2.5 UNIMPLEMENTED"
+"13.2.6 UNIMPLEMENTED"
+"13.2.7 UNIMPLEMENTED"
+"13.2.8 UNIMPLEMENTED"
+"13.2.9 UNIMPLEMENTED"
+"13.3.1 UNIMPLEMENTED"
+"13.3.10 UNIMPLEMENTED"
+"13.3.11 UNIMPLEMENTED"
+"13.3.12 UNIMPLEMENTED"
+"13.3.13 UNIMPLEMENTED"
+"13.3.14 UNIMPLEMENTED"
+"13.3.15 UNIMPLEMENTED"
+"13.3.16 UNIMPLEMENTED"
+"13.3.17 UNIMPLEMENTED"
+"13.3.18 UNIMPLEMENTED"
+"13.3.2 UNIMPLEMENTED"
+"13.3.3 UNIMPLEMENTED"
+"13.3.4 UNIMPLEMENTED"
+"13.3.5 UNIMPLEMENTED"
+"13.3.6 UNIMPLEMENTED"
+"13.3.7 UNIMPLEMENTED"
+"13.3.8 UNIMPLEMENTED"
+"13.3.9 UNIMPLEMENTED"
+"13.4.1 UNIMPLEMENTED"
+"13.4.10 UNIMPLEMENTED"
+"13.4.11 UNIMPLEMENTED"
+"13.4.12 UNIMPLEMENTED"
+"13.4.13 UNIMPLEMENTED"
+"13.4.14 UNIMPLEMENTED"
+"13.4.15 UNIMPLEMENTED"
+"13.4.16 UNIMPLEMENTED"
+"13.4.17 UNIMPLEMENTED"
+"13.4.18 UNIMPLEMENTED"
+"13.4.2 UNIMPLEMENTED"
+"13.4.3 UNIMPLEMENTED"
+"13.4.4 UNIMPLEMENTED"
+"13.4.5 UNIMPLEMENTED"
+"13.4.6 UNIMPLEMENTED"
+"13.4.7 UNIMPLEMENTED"
+"13.4.8 UNIMPLEMENTED"
+"13.4.9 UNIMPLEMENTED"
+"13.5.1 UNIMPLEMENTED"
+"13.5.10 UNIMPLEMENTED"
+"13.5.11 UNIMPLEMENTED"
+"13.5.12 UNIMPLEMENTED"
+"13.5.13 UNIMPLEMENTED"
+"13.5.14 UNIMPLEMENTED"
+"13.5.15 UNIMPLEMENTED"
+"13.5.16 UNIMPLEMENTED"
+"13.5.17 UNIMPLEMENTED"
+"13.5.18 UNIMPLEMENTED"
+"13.5.2 UNIMPLEMENTED"
+"13.5.3 UNIMPLEMENTED"
+"13.5.4 UNIMPLEMENTED"
+"13.5.5 UNIMPLEMENTED"
+"13.5.6 UNIMPLEMENTED"
+"13.5.7 UNIMPLEMENTED"
+"13.5.8 UNIMPLEMENTED"
+"13.5.9 UNIMPLEMENTED"
+"13.6.1 UNIMPLEMENTED"
+"13.6.10 UNIMPLEMENTED"
+"13.6.11 UNIMPLEMENTED"
+"13.6.12 UNIMPLEMENTED"
+"13.6.13 UNIMPLEMENTED"
+"13.6.14 UNIMPLEMENTED"
+"13.6.15 UNIMPLEMENTED"
+"13.6.16 UNIMPLEMENTED"
+"13.6.17 UNIMPLEMENTED"
+"13.6.18 UNIMPLEMENTED"
+"13.6.2 UNIMPLEMENTED"
+"13.6.3 UNIMPLEMENTED"
+"13.6.4 UNIMPLEMENTED"
+"13.6.5 UNIMPLEMENTED"
+"13.6.6 UNIMPLEMENTED"
+"13.6.7 UNIMPLEMENTED"
+"13.6.8 UNIMPLEMENTED"
+"13.6.9 UNIMPLEMENTED"
+"13.7.1 UNIMPLEMENTED"
+"13.7.10 UNIMPLEMENTED"
+"13.7.11 UNIMPLEMENTED"
+"13.7.12 UNIMPLEMENTED"
+"13.7.13 UNIMPLEMENTED"
+"13.7.14 UNIMPLEMENTED"
+"13.7.15 UNIMPLEMENTED"
+"13.7.16 UNIMPLEMENTED"
+"13.7.17 UNIMPLEMENTED"
+"13.7.18 UNIMPLEMENTED"
+"13.7.2 UNIMPLEMENTED"
+"13.7.3 UNIMPLEMENTED"
+"13.7.4 UNIMPLEMENTED"
+"13.7.5 UNIMPLEMENTED"
+"13.7.6 UNIMPLEMENTED"
+"13.7.7 UNIMPLEMENTED"
+"13.7.8 UNIMPLEMENTED"
+"13.7.9 UNIMPLEMENTED"
+"2.1 OK"
+"2.10 OK"
+"2.11 OK"
+"2.2 OK"
+"2.3 OK"
+"2.4 OK"
+"2.5 OK"
+"2.6 OK"
+"2.7 OK"
+"2.8 OK"
+"2.9 OK"
+"3.1 OK"
+"3.2 NON-STRICT"
+"3.3 NON-STRICT"
+"3.4 NON-STRICT"
+"3.5 OK"
+"3.6 OK"
+"3.7 OK"
+"4.1.1 OK"
+"4.1.2 OK"
+"4.1.3 NON-STRICT"
+"4.1.4 NON-STRICT"
+"4.1.5 OK"
+"4.2.1 OK"
+"4.2.2 OK"
+"4.2.3 NON-STRICT"
+"4.2.4 OK"
+"4.2.5 OK"
+"5.1 OK"
+"5.10 OK"
+"5.11 OK"
+"5.12 OK"
+"5.13 OK"
+"5.14 OK"
+"5.15 OK"
+"5.16 OK"
+"5.17 OK"
+"5.18 OK"
+"5.19 OK"
+"5.2 OK"
+"5.20 OK"
+"5.3 OK"
+"5.4 OK"
+"5.5 OK"
+"5.6 OK"
+"5.7 OK"
+"5.8 OK"
+"5.9 OK"
+"7.1.1 OK"
+"7.1.2 OK"
+"7.1.3 OK"
+"7.1.4 OK"
+"7.1.5 OK"
+"7.1.6 INFORMATIONAL"
+"7.13.1 INFORMATIONAL"
+"7.13.2 INFORMATIONAL"
+"7.3.1 OK"
+"7.3.2 OK"
+"7.3.3 OK"
+"7.3.4 OK"
+"7.3.5 OK"
+"7.3.6 OK"
+"7.5.1 FAILED"
+"7.7.1 OK"
+"7.7.10 OK"
+"7.7.11 OK"
+"7.7.12 OK"
+"7.7.13 OK"
+"7.7.2 OK"
+"7.7.3 OK"
+"7.7.4 OK"
+"7.7.5 OK"
+"7.7.6 OK"
+"7.7.7 OK"
+"7.7.8 OK"
+"7.7.9 OK"
+"7.9.1 OK"
+"7.9.10 OK"
+"7.9.11 OK"
+"7.9.12 OK"
+"7.9.13 OK"
+"7.9.2 OK"
+"7.9.3 OK"
+"7.9.4 OK"
+"7.9.5 OK"
+"7.9.6 OK"
+"7.9.7 OK"
+"7.9.8 OK"
+"7.9.9 OK"
+"9.1.1 OK"
+"9.1.2 OK"
+"9.1.3 OK"
+"9.1.4 OK"
+"9.1.5 OK"
+"9.1.6 OK"
+"9.2.1 OK"
+"9.2.2 OK"
+"9.2.3 OK"
+"9.2.4 OK"
+"9.2.5 OK"
+"9.2.6 OK"
+"9.3.1 OK"
+"9.3.2 OK"
+"9.3.3 OK"
+"9.3.4 OK"
+"9.3.5 OK"
+"9.3.6 OK"
+"9.3.7 OK"
+"9.3.8 OK"
+"9.3.9 OK"
+"9.4.1 OK"
+"9.4.2 OK"
+"9.4.3 OK"
+"9.4.4 OK"
+"9.4.5 OK"
+"9.4.6 OK"
+"9.4.7 OK"
+"9.4.8 OK"
+"9.4.9 OK"
+"9.5.1 OK"
+"9.5.2 OK"
+"9.5.3 OK"
+"9.5.4 OK"
+"9.5.5 OK"
+"9.5.6 OK"
+"9.6.1 OK"
+"9.6.2 OK"
+"9.6.3 OK"
+"9.6.4 OK"
+"9.6.5 OK"
+"9.6.6 OK"
+"9.7.1 OK"
+"9.7.2 OK"
+"9.7.3 OK"
+"9.7.4 OK"
+"9.7.5 OK"
+"9.7.6 OK"
+"9.8.1 OK"
+"9.8.2 OK"
+"9.8.3 OK"
+"9.8.4 OK"
+"9.8.5 OK"
+"9.8.6 OK"
diff --git a/okhttp-tests/fuzzingserver-test.sh b/okhttp-tests/fuzzingserver-test.sh
new file mode 100755
index 0000000000..78ad71f59e
--- /dev/null
+++ b/okhttp-tests/fuzzingserver-test.sh
@@ -0,0 +1,28 @@
+#!/usr/bin/env bash
+
+SCRIPT_DIR="$( cd "$( dirname "$0" )" && pwd )"
+cd "$SCRIPT_DIR"
+
+which wstest
+if [ $? != 0 ]; then
+  echo "Run 'pip install autobahntestsuite', maybe with 'sudo'."
+  exit 1
+fi
+which jq
+if [ $? != 0 ]; then
+  echo "Run 'brew install jq'"
+  exit 1
+fi
+
+trap 'kill $(jobs -pr)' SIGINT SIGTERM EXIT
+
+set -ex
+
+wstest -m fuzzingserver -s fuzzingserver-config.json &
+sleep 2 # wait for wstest to start
+
+java -jar target/okhttp-tests-*-jar-with-dependencies.jar
+
+jq '.[] as $in | $in | keys[] | . + " " + $in[.].behavior' target/fuzzingserver-report/index.json > target/fuzzingserver-actual.txt
+
+diff fuzzingserver-expected.txt target/fuzzingserver-actual.txt
diff --git a/okhttp-tests/fuzzingserver-update-expected.sh b/okhttp-tests/fuzzingserver-update-expected.sh
new file mode 100755
index 0000000000..56592c95fe
--- /dev/null
+++ b/okhttp-tests/fuzzingserver-update-expected.sh
@@ -0,0 +1,11 @@
+#!/usr/bin/env bash
+
+SCRIPT_DIR="$( cd "$( dirname "$0" )" && pwd )"
+cd "$SCRIPT_DIR"
+
+if [ ! -f target/fuzzingserver-actual.txt ]; then
+  echo "File not found. Did you run the Autobahn test script?"
+  exit 1
+fi
+
+cp target/fuzzingserver-actual.txt fuzzingserver-expected.txt
diff --git a/okhttp-tests/pom.xml b/okhttp-tests/pom.xml
new file mode 100644
index 0000000000..6959cd9a07
--- /dev/null
+++ b/okhttp-tests/pom.xml
@@ -0,0 +1,89 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp3</groupId>
+    <artifactId>parent</artifactId>
+    <version>3.10.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>okhttp-tests</artifactId>
+  <name>OkHttp Tests</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.okio</groupId>
+      <artifactId>okio</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-urlconnection</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-assembly-plugin</artifactId>
+        <configuration>
+          <descriptorRefs>
+            <descriptorRef>jar-with-dependencies</descriptorRef>
+          </descriptorRefs>
+          <archive>
+            <manifest>
+              <mainClass>okhttp3.AutobahnTester</mainClass>
+            </manifest>
+          </archive>
+        </configuration>
+        <executions>
+          <execution>
+            <phase>package</phase>
+            <goals>
+              <goal>single</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
+      <!-- Do not deploy this as an artifact to Maven central. -->
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-deploy-plugin</artifactId>
+        <configuration>
+          <skip>true</skip>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/okhttp-tests/src/main/java/okhttp3/AutobahnTester.java b/okhttp-tests/src/main/java/okhttp3/AutobahnTester.java
new file mode 100644
index 0000000000..ab7b9c771d
--- /dev/null
+++ b/okhttp-tests/src/main/java/okhttp3/AutobahnTester.java
@@ -0,0 +1,152 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.internal.Version;
+import okio.ByteString;
+
+/**
+ * Exercises the web socket implementation against the <a
+ * href="http://autobahn.ws/testsuite/">Autobahn Testsuite</a>.
+ */
+public final class AutobahnTester {
+  private static final String HOST = "ws://localhost:9099";
+
+  public static void main(String... args) throws IOException {
+    new AutobahnTester().run();
+  }
+
+  final OkHttpClient client = new OkHttpClient();
+
+  private WebSocket newWebSocket(String path, WebSocketListener listener) {
+    Request request = new Request.Builder().url(HOST + path).build();
+    return client.newWebSocket(request, listener);
+  }
+
+  public void run() throws IOException {
+    try {
+      long count = getTestCount();
+      System.out.println("Test count: " + count);
+
+      for (long number = 1; number <= count; number++) {
+        runTest(number, count);
+      }
+
+      updateReports();
+    } finally {
+      client.dispatcher().executorService().shutdown();
+    }
+  }
+
+  private void runTest(final long number, final long count) {
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicLong startNanos = new AtomicLong();
+    newWebSocket("/runCase?case=" + number + "&agent=okhttp", new WebSocketListener() {
+      @Override public void onOpen(WebSocket webSocket, Response response) {
+        System.out.println("Executing test case " + number + "/" + count);
+        startNanos.set(System.nanoTime());
+      }
+
+      @Override public void onMessage(final WebSocket webSocket, final ByteString bytes) {
+        webSocket.send(bytes);
+      }
+
+      @Override public void onMessage(final WebSocket webSocket, final String text) {
+        webSocket.send(text);
+      }
+
+      @Override public void onClosing(WebSocket webSocket, int code, String reason) {
+        webSocket.close(1000, null);
+        latch.countDown();
+      }
+
+      @Override public void onFailure(WebSocket webSocket, Throwable t, Response response) {
+        t.printStackTrace(System.out);
+        latch.countDown();
+      }
+    });
+    try {
+      if (!latch.await(30, TimeUnit.SECONDS)) {
+        throw new IllegalStateException("Timed out waiting for test " + number + " to finish.");
+      }
+    } catch (InterruptedException e) {
+      throw new AssertionError();
+    }
+
+    long endNanos = System.nanoTime();
+    long tookMs = TimeUnit.NANOSECONDS.toMillis(endNanos - startNanos.get());
+    System.out.println("Took " + tookMs + "ms");
+  }
+
+  private long getTestCount() throws IOException {
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicLong countRef = new AtomicLong();
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    newWebSocket("/getCaseCount", new WebSocketListener() {
+      @Override public void onMessage(WebSocket webSocket, String text) {
+        countRef.set(Long.parseLong(text));
+      }
+
+      @Override public void onClosing(WebSocket webSocket, int code, String reason) {
+        webSocket.close(1000, null);
+        latch.countDown();
+      }
+
+      @Override public void onFailure(WebSocket webSocket, Throwable t, Response response) {
+        failureRef.set(t);
+        latch.countDown();
+      }
+    });
+    try {
+      if (!latch.await(10, TimeUnit.SECONDS)) {
+        throw new IllegalStateException("Timed out waiting for count.");
+      }
+    } catch (InterruptedException e) {
+      throw new AssertionError();
+    }
+    Throwable failure = failureRef.get();
+    if (failure != null) {
+      throw new RuntimeException(failure);
+    }
+    return countRef.get();
+  }
+
+  private void updateReports() {
+    final CountDownLatch latch = new CountDownLatch(1);
+    newWebSocket("/updateReports?agent=" + Version.userAgent(), new WebSocketListener() {
+      @Override public void onClosing(WebSocket webSocket, int code, String reason) {
+        webSocket.close(1000, null);
+        latch.countDown();
+      }
+
+      @Override public void onFailure(WebSocket webSocket, Throwable t, Response response) {
+        latch.countDown();
+      }
+    });
+    try {
+      if (!latch.await(10, TimeUnit.SECONDS)) {
+        throw new IllegalStateException("Timed out waiting for count.");
+      }
+    } catch (InterruptedException e) {
+      throw new AssertionError();
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/AddressTest.java b/okhttp-tests/src/test/java/okhttp3/AddressTest.java
new file mode 100644
index 0000000000..ad07b78241
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/AddressTest.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.net.Proxy;
+import java.util.List;
+import javax.net.SocketFactory;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.RecordingProxySelector;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+
+public final class AddressTest {
+  private Dns dns = Dns.SYSTEM;
+  private SocketFactory socketFactory = SocketFactory.getDefault();
+  private Authenticator authenticator = Authenticator.NONE;
+  private List<Protocol> protocols = Util.immutableList(Protocol.HTTP_1_1);
+  private List<ConnectionSpec> connectionSpecs = Util.immutableList(ConnectionSpec.MODERN_TLS);
+  private RecordingProxySelector proxySelector = new RecordingProxySelector();
+
+  @Test public void equalsAndHashcode() throws Exception {
+    Address a = new Address("square.com", 80, dns, socketFactory, null, null, null,
+        authenticator, null, protocols, connectionSpecs, proxySelector);
+    Address b = new Address("square.com", 80, dns, socketFactory, null, null, null,
+        authenticator, null, protocols, connectionSpecs, proxySelector);
+    assertEquals(a, b);
+    assertEquals(a.hashCode(), b.hashCode());
+  }
+
+  @Test public void differentProxySelectorsAreDifferent() throws Exception {
+    Address a = new Address("square.com", 80, dns, socketFactory, null, null, null,
+        authenticator, null, protocols, connectionSpecs, new RecordingProxySelector());
+    Address b = new Address("square.com", 80, dns, socketFactory, null, null, null,
+        authenticator, null, protocols, connectionSpecs, new RecordingProxySelector());
+    assertFalse(a.equals(b));
+  }
+
+  @Test public void addressToString() throws Exception {
+    Address address = new Address("square.com", 80, dns, socketFactory, null, null, null,
+        authenticator, null, protocols, connectionSpecs, proxySelector);
+    assertEquals("Address{square.com:80, proxySelector=RecordingProxySelector}",
+        address.toString());
+  }
+
+  @Test public void addressWithProxyToString() throws Exception {
+    Address address = new Address("square.com", 80, dns, socketFactory, null, null, null,
+        authenticator, Proxy.NO_PROXY, protocols, connectionSpecs, proxySelector);
+    assertEquals("Address{square.com:80, proxy=" + Proxy.NO_PROXY + "}", address.toString());
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/CacheControlTest.java b/okhttp-tests/src/test/java/okhttp3/CacheControlTest.java
new file mode 100644
index 0000000000..356f96ab46
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/CacheControlTest.java
@@ -0,0 +1,197 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.util.concurrent.TimeUnit;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class CacheControlTest {
+  @Test public void emptyBuilderIsEmpty() throws Exception {
+    CacheControl cacheControl = new CacheControl.Builder().build();
+    assertEquals("", cacheControl.toString());
+    assertFalse(cacheControl.noCache());
+    assertFalse(cacheControl.noStore());
+    assertEquals(-1, cacheControl.maxAgeSeconds());
+    assertEquals(-1, cacheControl.sMaxAgeSeconds());
+    assertFalse(cacheControl.isPrivate());
+    assertFalse(cacheControl.isPublic());
+    assertFalse(cacheControl.mustRevalidate());
+    assertEquals(-1, cacheControl.maxStaleSeconds());
+    assertEquals(-1, cacheControl.minFreshSeconds());
+    assertFalse(cacheControl.onlyIfCached());
+    assertFalse(cacheControl.mustRevalidate());
+  }
+
+  @Test public void completeBuilder() throws Exception {
+    CacheControl cacheControl = new CacheControl.Builder()
+        .noCache()
+        .noStore()
+        .maxAge(1, TimeUnit.SECONDS)
+        .maxStale(2, TimeUnit.SECONDS)
+        .minFresh(3, TimeUnit.SECONDS)
+        .onlyIfCached()
+        .noTransform()
+        .immutable()
+        .build();
+    assertEquals("no-cache, no-store, max-age=1, max-stale=2, min-fresh=3, only-if-cached, "
+        + "no-transform, immutable", cacheControl.toString());
+    assertTrue(cacheControl.noCache());
+    assertTrue(cacheControl.noStore());
+    assertEquals(1, cacheControl.maxAgeSeconds());
+    assertEquals(2, cacheControl.maxStaleSeconds());
+    assertEquals(3, cacheControl.minFreshSeconds());
+    assertTrue(cacheControl.onlyIfCached());
+    assertTrue(cacheControl.noTransform());
+    assertTrue(cacheControl.immutable());
+
+    // These members are accessible to response headers only.
+    assertEquals(-1, cacheControl.sMaxAgeSeconds());
+    assertFalse(cacheControl.isPrivate());
+    assertFalse(cacheControl.isPublic());
+    assertFalse(cacheControl.mustRevalidate());
+  }
+
+  @Test public void parseEmpty() throws Exception {
+    CacheControl cacheControl = CacheControl.parse(
+        new Headers.Builder().set("Cache-Control", "").build());
+    assertEquals("", cacheControl.toString());
+    assertFalse(cacheControl.noCache());
+    assertFalse(cacheControl.noStore());
+    assertEquals(-1, cacheControl.maxAgeSeconds());
+    assertEquals(-1, cacheControl.sMaxAgeSeconds());
+    assertFalse(cacheControl.isPublic());
+    assertFalse(cacheControl.mustRevalidate());
+    assertEquals(-1, cacheControl.maxStaleSeconds());
+    assertEquals(-1, cacheControl.minFreshSeconds());
+    assertFalse(cacheControl.onlyIfCached());
+    assertFalse(cacheControl.mustRevalidate());
+  }
+
+  @Test public void parse() throws Exception {
+    String header = "no-cache, no-store, max-age=1, s-maxage=2, private, public, must-revalidate, "
+        + "max-stale=3, min-fresh=4, only-if-cached, no-transform";
+    CacheControl cacheControl = CacheControl.parse(new Headers.Builder()
+        .set("Cache-Control", header)
+        .build());
+    assertTrue(cacheControl.noCache());
+    assertTrue(cacheControl.noStore());
+    assertEquals(1, cacheControl.maxAgeSeconds());
+    assertEquals(2, cacheControl.sMaxAgeSeconds());
+    assertTrue(cacheControl.isPrivate());
+    assertTrue(cacheControl.isPublic());
+    assertTrue(cacheControl.mustRevalidate());
+    assertEquals(3, cacheControl.maxStaleSeconds());
+    assertEquals(4, cacheControl.minFreshSeconds());
+    assertTrue(cacheControl.onlyIfCached());
+    assertTrue(cacheControl.noTransform());
+    assertEquals(header, cacheControl.toString());
+  }
+
+  @Test public void parseIgnoreCacheControlExtensions() throws Exception {
+    // Example from http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9.6
+    String header = "private, community=\"UCI\"";
+    CacheControl cacheControl = CacheControl.parse(new Headers.Builder()
+        .set("Cache-Control", header)
+        .build());
+    assertFalse(cacheControl.noCache());
+    assertFalse(cacheControl.noStore());
+    assertEquals(-1, cacheControl.maxAgeSeconds());
+    assertEquals(-1, cacheControl.sMaxAgeSeconds());
+    assertTrue(cacheControl.isPrivate());
+    assertFalse(cacheControl.isPublic());
+    assertFalse(cacheControl.mustRevalidate());
+    assertEquals(-1, cacheControl.maxStaleSeconds());
+    assertEquals(-1, cacheControl.minFreshSeconds());
+    assertFalse(cacheControl.onlyIfCached());
+    assertFalse(cacheControl.noTransform());
+    assertFalse(cacheControl.immutable());
+    assertEquals(header, cacheControl.toString());
+  }
+
+  @Test public void parseCacheControlAndPragmaAreCombined() {
+    Headers headers =
+        Headers.of("Cache-Control", "max-age=12", "Pragma", "must-revalidate", "Pragma", "public");
+    CacheControl cacheControl = CacheControl.parse(headers);
+    assertEquals("max-age=12, public, must-revalidate", cacheControl.toString());
+  }
+
+  @SuppressWarnings("RedundantStringConstructorCall") // Testing instance equality.
+  @Test public void parseCacheControlHeaderValueIsRetained() {
+    String value = new String("max-age=12");
+    Headers headers = Headers.of("Cache-Control", value);
+    CacheControl cacheControl = CacheControl.parse(headers);
+    assertSame(value, cacheControl.toString());
+  }
+
+  @Test public void parseCacheControlHeaderValueInvalidatedByPragma() {
+    Headers headers = Headers.of("Cache-Control", "max-age=12", "Pragma", "must-revalidate");
+    CacheControl cacheControl = CacheControl.parse(headers);
+    assertNull(cacheControl.headerValue);
+  }
+
+  @Test public void parseCacheControlHeaderValueInvalidatedByTwoValues() {
+    Headers headers = Headers.of("Cache-Control", "max-age=12", "Cache-Control", "must-revalidate");
+    CacheControl cacheControl = CacheControl.parse(headers);
+    assertNull(cacheControl.headerValue);
+  }
+
+  @Test public void parsePragmaHeaderValueIsNotRetained() {
+    Headers headers = Headers.of("Pragma", "must-revalidate");
+    CacheControl cacheControl = CacheControl.parse(headers);
+    assertNull(cacheControl.headerValue);
+  }
+
+  @Test public void computedHeaderValueIsCached() {
+    CacheControl cacheControl = new CacheControl.Builder()
+        .maxAge(2, TimeUnit.DAYS)
+        .build();
+    assertNull(cacheControl.headerValue);
+    assertEquals("max-age=172800", cacheControl.toString());
+    assertEquals("max-age=172800", cacheControl.headerValue);
+    cacheControl.headerValue = "Hi";
+    assertEquals("Hi", cacheControl.toString());
+  }
+
+  @Test public void timeDurationTruncatedToMaxValue() throws Exception {
+    CacheControl cacheControl = new CacheControl.Builder()
+        .maxAge(365 * 100, TimeUnit.DAYS) // Longer than Integer.MAX_VALUE seconds.
+        .build();
+    assertEquals(Integer.MAX_VALUE, cacheControl.maxAgeSeconds());
+  }
+
+  @Test public void secondsMustBeNonNegative() throws Exception {
+    CacheControl.Builder builder = new CacheControl.Builder();
+    try {
+      builder.maxAge(-1, TimeUnit.SECONDS);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void timePrecisionIsTruncatedToSeconds() throws Exception {
+    CacheControl cacheControl = new CacheControl.Builder()
+        .maxAge(4999, TimeUnit.MILLISECONDS)
+        .build();
+    assertEquals(4, cacheControl.maxAgeSeconds());
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/CacheTest.java b/okhttp-tests/src/test/java/okhttp3/CacheTest.java
new file mode 100644
index 0000000000..09b480c647
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/CacheTest.java
@@ -0,0 +1,2568 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package okhttp3;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.CookieManager;
+import java.net.HttpURLConnection;
+import java.net.ResponseCache;
+import java.security.Principal;
+import java.security.cert.Certificate;
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Locale;
+import java.util.NoSuchElementException;
+import java.util.TimeZone;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLSession;
+import okhttp3.internal.Internal;
+import okhttp3.internal.io.InMemoryFileSystem;
+import okhttp3.internal.platform.Platform;
+import okhttp3.internal.tls.SslClient;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.GzipSink;
+import okio.Okio;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static okhttp3.TestUtil.defaultClient;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class CacheTest {
+  private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = new HostnameVerifier() {
+    @Override public boolean verify(String s, SSLSession sslSession) {
+      return true;
+    }
+  };
+
+  @Rule public MockWebServer server = new MockWebServer();
+  @Rule public MockWebServer server2 = new MockWebServer();
+  @Rule public InMemoryFileSystem fileSystem = new InMemoryFileSystem();
+
+  private final SslClient sslClient = SslClient.localhost();
+  private OkHttpClient client;
+  private Cache cache;
+  private final CookieManager cookieManager = new CookieManager();
+
+  @Before public void setUp() throws Exception {
+    server.setProtocolNegotiationEnabled(false);
+    cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
+    client = defaultClient().newBuilder()
+        .cache(cache)
+        .cookieJar(new JavaNetCookieJar(cookieManager))
+        .build();
+  }
+
+  @After public void tearDown() throws Exception {
+    ResponseCache.setDefault(null);
+    cache.delete();
+  }
+
+  /**
+   * Test that response caching is consistent with the RI and the spec.
+   * http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.4
+   */
+  @Test public void responseCachingByResponseCode() throws Exception {
+    // Test each documented HTTP/1.1 code, plus the first unused value in each range.
+    // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
+
+    // We can't test 100 because it's not really a response.
+    // assertCached(false, 100);
+    assertCached(false, 101);
+    assertCached(false, 102);
+    assertCached(true, 200);
+    assertCached(false, 201);
+    assertCached(false, 202);
+    assertCached(true, 203);
+    assertCached(true, 204);
+    assertCached(false, 205);
+    assertCached(false, 206); //Electing to not cache partial responses
+    assertCached(false, 207);
+    assertCached(true, 300);
+    assertCached(true, 301);
+    assertCached(true, 302);
+    assertCached(false, 303);
+    assertCached(false, 304);
+    assertCached(false, 305);
+    assertCached(false, 306);
+    assertCached(true, 307);
+    assertCached(true, 308);
+    assertCached(false, 400);
+    assertCached(false, 401);
+    assertCached(false, 402);
+    assertCached(false, 403);
+    assertCached(true, 404);
+    assertCached(true, 405);
+    assertCached(false, 406);
+    assertCached(false, 408);
+    assertCached(false, 409);
+    // the HTTP spec permits caching 410s, but the RI doesn't.
+    assertCached(true, 410);
+    assertCached(false, 411);
+    assertCached(false, 412);
+    assertCached(false, 413);
+    assertCached(true, 414);
+    assertCached(false, 415);
+    assertCached(false, 416);
+    assertCached(false, 417);
+    assertCached(false, 418);
+
+    assertCached(false, 500);
+    assertCached(true, 501);
+    assertCached(false, 502);
+    assertCached(false, 503);
+    assertCached(false, 504);
+    assertCached(false, 505);
+    assertCached(false, 506);
+  }
+
+  private void assertCached(boolean shouldPut, int responseCode) throws Exception {
+    int expectedResponseCode = responseCode;
+
+    server = new MockWebServer();
+    MockResponse mockResponse = new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setResponseCode(responseCode)
+        .setBody("ABCDE")
+        .addHeader("WWW-Authenticate: challenge");
+    if (responseCode == HttpURLConnection.HTTP_PROXY_AUTH) {
+      mockResponse.addHeader("Proxy-Authenticate: Basic realm=\"protected area\"");
+    } else if (responseCode == HttpURLConnection.HTTP_UNAUTHORIZED) {
+      mockResponse.addHeader("WWW-Authenticate: Basic realm=\"protected area\"");
+    } else if (responseCode == HttpURLConnection.HTTP_NO_CONTENT
+        || responseCode == HttpURLConnection.HTTP_RESET) {
+      mockResponse.setBody(""); // We forbid bodies for 204 and 205.
+    }
+    server.enqueue(mockResponse);
+
+    if (responseCode == HttpURLConnection.HTTP_CLIENT_TIMEOUT) {
+      // 408's are a bit of an outlier because we may repeat the request if we encounter this
+      // response code. In this scenario, there are 2 responses: the initial 408 and then the 200
+      // because of the retry. We just want to ensure the initial 408 isn't cached.
+      expectedResponseCode = 200;
+      server.enqueue(new MockResponse()
+          .setHeader("Cache-Control", "no-store")
+          .setBody("FGHIJ"));
+    }
+
+    server.start();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals(expectedResponseCode, response.code());
+
+    // Exhaust the content stream.
+    response.body().string();
+
+    Response cached = cache.get(request);
+    if (shouldPut) {
+      assertNotNull(Integer.toString(responseCode), cached);
+      cached.body().close();
+    } else {
+      assertNull(Integer.toString(responseCode), cached);
+    }
+    server.shutdown(); // tearDown() isn't sufficient; this test starts multiple servers
+  }
+
+  @Test public void responseCachingAndInputStreamSkipWithFixedLength() throws IOException {
+    testResponseCaching(TransferKind.FIXED_LENGTH);
+  }
+
+  @Test public void responseCachingAndInputStreamSkipWithChunkedEncoding() throws IOException {
+    testResponseCaching(TransferKind.CHUNKED);
+  }
+
+  @Test public void responseCachingAndInputStreamSkipWithNoLengthHeaders() throws IOException {
+    testResponseCaching(TransferKind.END_OF_STREAM);
+  }
+
+  /**
+   * Skipping bytes in the input stream caused ResponseCache corruption.
+   * http://code.google.com/p/android/issues/detail?id=8175
+   */
+  private void testResponseCaching(TransferKind transferKind) throws IOException {
+    MockResponse mockResponse = new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setStatus("HTTP/1.1 200 Fantastic");
+    transferKind.setBody(mockResponse, "I love puppies but hate spiders", 1);
+    server.enqueue(mockResponse);
+
+    // Make sure that calling skip() doesn't omit bytes from the cache.
+    Request request = new Request.Builder().url(server.url("/")).build();
+    Response response1 = client.newCall(request).execute();
+
+    BufferedSource in1 = response1.body().source();
+    assertEquals("I love ", in1.readUtf8("I love ".length()));
+    in1.skip("puppies but hate ".length());
+    assertEquals("spiders", in1.readUtf8("spiders".length()));
+    assertTrue(in1.exhausted());
+    in1.close();
+    assertEquals(1, cache.writeSuccessCount());
+    assertEquals(0, cache.writeAbortCount());
+
+    Response response2 = client.newCall(request).execute();
+    BufferedSource in2 = response2.body().source();
+    assertEquals("I love puppies but hate spiders",
+        in2.readUtf8("I love puppies but hate spiders".length()));
+    assertEquals(200, response2.code());
+    assertEquals("Fantastic", response2.message());
+
+    assertTrue(in2.exhausted());
+    in2.close();
+    assertEquals(1, cache.writeSuccessCount());
+    assertEquals(0, cache.writeAbortCount());
+    assertEquals(2, cache.requestCount());
+    assertEquals(1, cache.hitCount());
+  }
+
+  @Test public void secureResponseCaching() throws IOException {
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setBody("ABC"));
+
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
+        .build();
+
+    Request request = new Request.Builder().url(server.url("/")).build();
+    Response response1 = client.newCall(request).execute();
+    BufferedSource in = response1.body().source();
+    assertEquals("ABC", in.readUtf8());
+
+    // OpenJDK 6 fails on this line, complaining that the connection isn't open yet
+    CipherSuite cipherSuite = response1.handshake().cipherSuite();
+    List<Certificate> localCerts = response1.handshake().localCertificates();
+    List<Certificate> serverCerts = response1.handshake().peerCertificates();
+    Principal peerPrincipal = response1.handshake().peerPrincipal();
+    Principal localPrincipal = response1.handshake().localPrincipal();
+
+    Response response2 = client.newCall(request).execute(); // Cached!
+    assertEquals("ABC", response2.body().string());
+
+    assertEquals(2, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(1, cache.hitCount());
+
+    assertEquals(cipherSuite, response2.handshake().cipherSuite());
+    assertEquals(localCerts, response2.handshake().localCertificates());
+    assertEquals(serverCerts, response2.handshake().peerCertificates());
+    assertEquals(peerPrincipal, response2.handshake().peerPrincipal());
+    assertEquals(localPrincipal, response2.handshake().localPrincipal());
+  }
+
+  @Test public void responseCachingAndRedirects() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
+        .addHeader("Location: /foo"));
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setBody("ABC"));
+    server.enqueue(new MockResponse()
+        .setBody("DEF"));
+
+    Request request = new Request.Builder().url(server.url("/")).build();
+    Response response1 = client.newCall(request).execute();
+    assertEquals("ABC", response1.body().string());
+
+    Response response2 = client.newCall(request).execute(); // Cached!
+    assertEquals("ABC", response2.body().string());
+
+    assertEquals(4, cache.requestCount()); // 2 requests + 2 redirects
+    assertEquals(2, cache.networkCount());
+    assertEquals(2, cache.hitCount());
+  }
+
+  @Test public void redirectToCachedResult() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("ABC"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
+        .addHeader("Location: /foo"));
+    server.enqueue(new MockResponse()
+        .setBody("DEF"));
+
+    Request request1 = new Request.Builder().url(server.url("/foo")).build();
+    Response response1 = client.newCall(request1).execute();
+    assertEquals("ABC", response1.body().string());
+    RecordedRequest recordedRequest1 = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", recordedRequest1.getRequestLine());
+    assertEquals(0, recordedRequest1.getSequenceNumber());
+
+    Request request2 = new Request.Builder().url(server.url("/bar")).build();
+    Response response2 = client.newCall(request2).execute();
+    assertEquals("ABC", response2.body().string());
+    RecordedRequest recordedRequest2 = server.takeRequest();
+    assertEquals("GET /bar HTTP/1.1", recordedRequest2.getRequestLine());
+    assertEquals(1, recordedRequest2.getSequenceNumber());
+
+    // an unrelated request should reuse the pooled connection
+    Request request3 = new Request.Builder().url(server.url("/baz")).build();
+    Response response3 = client.newCall(request3).execute();
+    assertEquals("DEF", response3.body().string());
+    RecordedRequest recordedRequest3 = server.takeRequest();
+    assertEquals("GET /baz HTTP/1.1", recordedRequest3.getRequestLine());
+    assertEquals(2, recordedRequest3.getSequenceNumber());
+  }
+
+  @Test public void secureResponseCachingAndRedirects() throws IOException {
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
+        .addHeader("Location: /foo"));
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setBody("ABC"));
+    server.enqueue(new MockResponse()
+        .setBody("DEF"));
+
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
+        .build();
+
+    Response response1 = get(server.url("/"));
+    assertEquals("ABC", response1.body().string());
+    assertNotNull(response1.handshake().cipherSuite());
+
+    // Cached!
+    Response response2 = get(server.url("/"));
+    assertEquals("ABC", response2.body().string());
+    assertNotNull(response2.handshake().cipherSuite());
+
+    assertEquals(4, cache.requestCount()); // 2 direct + 2 redirect = 4
+    assertEquals(2, cache.hitCount());
+    assertEquals(response1.handshake().cipherSuite(), response2.handshake().cipherSuite());
+  }
+
+  /**
+   * We've had bugs where caching and cross-protocol redirects yield class cast exceptions internal
+   * to the cache because we incorrectly assumed that HttpsURLConnection was always HTTPS and
+   * HttpURLConnection was always HTTP; in practice redirects mean that each can do either.
+   *
+   * https://github.com/square/okhttp/issues/214
+   */
+  @Test public void secureResponseCachingAndProtocolRedirects() throws IOException {
+    server2.useHttps(sslClient.socketFactory, false);
+    server2.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setBody("ABC"));
+    server2.enqueue(new MockResponse()
+        .setBody("DEF"));
+
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
+        .addHeader("Location: " + server2.url("/")));
+
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
+        .build();
+
+    Response response1 = get(server.url("/"));
+    assertEquals("ABC", response1.body().string());
+
+    // Cached!
+    Response response2 = get(server.url("/"));
+    assertEquals("ABC", response2.body().string());
+
+    assertEquals(4, cache.requestCount()); // 2 direct + 2 redirect = 4
+    assertEquals(2, cache.hitCount());
+  }
+
+  @Test public void foundCachedWithExpiresHeader() throws Exception {
+    temporaryRedirectCachedWithCachingHeader(302, "Expires", formatDate(1, TimeUnit.HOURS));
+  }
+
+  @Test public void foundCachedWithCacheControlHeader() throws Exception {
+    temporaryRedirectCachedWithCachingHeader(302, "Cache-Control", "max-age=60");
+  }
+
+  @Test public void temporaryRedirectCachedWithExpiresHeader() throws Exception {
+    temporaryRedirectCachedWithCachingHeader(307, "Expires", formatDate(1, TimeUnit.HOURS));
+  }
+
+  @Test public void temporaryRedirectCachedWithCacheControlHeader() throws Exception {
+    temporaryRedirectCachedWithCachingHeader(307, "Cache-Control", "max-age=60");
+  }
+
+  @Test public void foundNotCachedWithoutCacheHeader() throws Exception {
+    temporaryRedirectNotCachedWithoutCachingHeader(302);
+  }
+
+  @Test public void temporaryRedirectNotCachedWithoutCacheHeader() throws Exception {
+    temporaryRedirectNotCachedWithoutCachingHeader(307);
+  }
+
+  private void temporaryRedirectCachedWithCachingHeader(
+      int responseCode, String headerName, String headerValue) throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(responseCode)
+        .addHeader(headerName, headerValue)
+        .addHeader("Location", "/a"));
+    server.enqueue(new MockResponse()
+        .addHeader(headerName, headerValue)
+        .setBody("a"));
+    server.enqueue(new MockResponse()
+        .setBody("b"));
+    server.enqueue(new MockResponse()
+        .setBody("c"));
+
+    HttpUrl url = server.url("/");
+    assertEquals("a", get(url).body().string());
+    assertEquals("a", get(url).body().string());
+  }
+
+  private void temporaryRedirectNotCachedWithoutCachingHeader(int responseCode) throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(responseCode)
+        .addHeader("Location", "/a"));
+    server.enqueue(new MockResponse()
+        .setBody("a"));
+    server.enqueue(new MockResponse()
+        .setBody("b"));
+
+    HttpUrl url = server.url("/");
+    assertEquals("a", get(url).body().string());
+    assertEquals("b", get(url).body().string());
+  }
+
+  /** https://github.com/square/okhttp/issues/2198 */
+  @Test public void cachedRedirect() throws IOException {
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Location: /bar"));
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+
+    Request request1 = new Request.Builder().url(server.url("/")).build();
+    Response response1 = client.newCall(request1).execute();
+    assertEquals("ABC", response1.body().string());
+
+    Request request2 = new Request.Builder().url(server.url("/")).build();
+    Response response2 = client.newCall(request2).execute();
+    assertEquals("ABC", response2.body().string());
+  }
+
+  @Test public void serverDisconnectsPrematurelyWithContentLengthHeader() throws IOException {
+    testServerPrematureDisconnect(TransferKind.FIXED_LENGTH);
+  }
+
+  @Test public void serverDisconnectsPrematurelyWithChunkedEncoding() throws IOException {
+    testServerPrematureDisconnect(TransferKind.CHUNKED);
+  }
+
+  @Test public void serverDisconnectsPrematurelyWithNoLengthHeaders() throws IOException {
+    // Intentionally empty. This case doesn't make sense because there's no
+    // such thing as a premature disconnect when the disconnect itself
+    // indicates the end of the data stream.
+  }
+
+  private void testServerPrematureDisconnect(TransferKind transferKind) throws IOException {
+    MockResponse mockResponse = new MockResponse();
+    transferKind.setBody(mockResponse, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 16);
+    server.enqueue(truncateViolently(mockResponse, 16));
+    server.enqueue(new MockResponse()
+        .setBody("Request #2"));
+
+    BufferedSource bodySource = get(server.url("/")).body().source();
+    assertEquals("ABCDE", bodySource.readUtf8Line());
+    try {
+      bodySource.readUtf8Line();
+      fail("This implementation silently ignored a truncated HTTP body.");
+    } catch (IOException expected) {
+    } finally {
+      bodySource.close();
+    }
+
+    assertEquals(1, cache.writeAbortCount());
+    assertEquals(0, cache.writeSuccessCount());
+    Response response = get(server.url("/"));
+    assertEquals("Request #2", response.body().string());
+    assertEquals(1, cache.writeAbortCount());
+    assertEquals(1, cache.writeSuccessCount());
+  }
+
+  @Test public void clientPrematureDisconnectWithContentLengthHeader() throws IOException {
+    testClientPrematureDisconnect(TransferKind.FIXED_LENGTH);
+  }
+
+  @Test public void clientPrematureDisconnectWithChunkedEncoding() throws IOException {
+    testClientPrematureDisconnect(TransferKind.CHUNKED);
+  }
+
+  @Test public void clientPrematureDisconnectWithNoLengthHeaders() throws IOException {
+    testClientPrematureDisconnect(TransferKind.END_OF_STREAM);
+  }
+
+  private void testClientPrematureDisconnect(TransferKind transferKind) throws IOException {
+    // Setting a low transfer speed ensures that stream discarding will time out.
+    MockResponse mockResponse = new MockResponse()
+        .throttleBody(6, 1, TimeUnit.SECONDS);
+    transferKind.setBody(mockResponse, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 1024);
+    server.enqueue(mockResponse);
+    server.enqueue(new MockResponse()
+        .setBody("Request #2"));
+
+    Response response1 = get(server.url("/"));
+    BufferedSource in = response1.body().source();
+    assertEquals("ABCDE", in.readUtf8(5));
+    in.close();
+    try {
+      in.readByte();
+      fail("Expected an IllegalStateException because the source is closed.");
+    } catch (IllegalStateException expected) {
+    }
+
+    assertEquals(1, cache.writeAbortCount());
+    assertEquals(0, cache.writeSuccessCount());
+    Response response2 = get(server.url("/"));
+    assertEquals("Request #2", response2.body().string());
+    assertEquals(1, cache.writeAbortCount());
+    assertEquals(1, cache.writeSuccessCount());
+  }
+
+  @Test public void defaultExpirationDateFullyCachedForLessThan24Hours() throws Exception {
+    //      last modified: 105 seconds ago
+    //             served:   5 seconds ago
+    //   default lifetime: (105 - 5) / 10 = 10 seconds
+    //            expires:  10 seconds from served date = 5 seconds from now
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
+        .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
+        .setBody("A"));
+
+    HttpUrl url = server.url("/");
+    Response response1 = get(url);
+    assertEquals("A", response1.body().string());
+
+    Response response2 = get(url);
+    assertEquals("A", response2.body().string());
+    assertNull(response2.header("Warning"));
+  }
+
+  @Test public void defaultExpirationDateConditionallyCached() throws Exception {
+    //      last modified: 115 seconds ago
+    //             served:  15 seconds ago
+    //   default lifetime: (115 - 15) / 10 = 10 seconds
+    //            expires:  10 seconds from served date = 5 seconds ago
+    String lastModifiedDate = formatDate(-115, TimeUnit.SECONDS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
+        .addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Date: " + formatDate(-15, TimeUnit.SECONDS)));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+  }
+
+  @Test public void defaultExpirationDateFullyCachedForMoreThan24Hours() throws Exception {
+    //      last modified: 105 days ago
+    //             served:   5 days ago
+    //   default lifetime: (105 - 5) / 10 = 10 days
+    //            expires:  10 days from served date = 5 days from now
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-105, TimeUnit.DAYS))
+        .addHeader("Date: " + formatDate(-5, TimeUnit.DAYS))
+        .setBody("A"));
+
+    assertEquals("A", get(server.url("/")).body().string());
+    Response response = get(server.url("/"));
+    assertEquals("A", response.body().string());
+    assertEquals("113 HttpURLConnection \"Heuristic expiration\"", response.header("Warning"));
+  }
+
+  @Test public void noDefaultExpirationForUrlsWithQueryString() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
+        .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    HttpUrl url = server.url("/").newBuilder().addQueryParameter("foo", "bar").build();
+    assertEquals("A", get(url).body().string());
+    assertEquals("B", get(url).body().string());
+  }
+
+  @Test public void expirationDateInThePastWithLastModifiedHeader() throws Exception {
+    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
+        .addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+  }
+
+  @Test public void expirationDateInThePastWithNoLastModifiedHeader() throws Exception {
+    assertNotCached(new MockResponse()
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+  }
+
+  @Test public void expirationDateInTheFuture() throws Exception {
+    assertFullyCached(new MockResponse()
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+  }
+
+  @Test public void maxAgePreferredWithMaxAgeAndExpires() throws Exception {
+    assertFullyCached(new MockResponse()
+        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgeInThePastWithDateAndLastModifiedHeaders() throws Exception {
+    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
+        .addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
+        .addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Cache-Control: max-age=60"));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+  }
+
+  @Test public void maxAgeInThePastWithDateHeaderButNoLastModifiedHeader() throws Exception {
+    // Chrome interprets max-age relative to the local clock. Both our cache
+    // and Firefox both use the earlier of the local and server's clock.
+    assertNotCached(new MockResponse()
+        .addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgeInTheFutureWithDateHeader() throws Exception {
+    assertFullyCached(new MockResponse()
+        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgeInTheFutureWithNoDateHeader() throws Exception {
+    assertFullyCached(new MockResponse()
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgeWithLastModifiedButNoServedDate() throws Exception {
+    assertFullyCached(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgeInTheFutureWithDateAndLastModifiedHeaders() throws Exception {
+    assertFullyCached(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
+        .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgePreferredOverLowerSharedMaxAge() throws Exception {
+    assertFullyCached(new MockResponse()
+        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
+        .addHeader("Cache-Control: s-maxage=60")
+        .addHeader("Cache-Control: max-age=180"));
+  }
+
+  @Test public void maxAgePreferredOverHigherMaxAge() throws Exception {
+    assertNotCached(new MockResponse()
+        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
+        .addHeader("Cache-Control: s-maxage=180")
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void requestMethodOptionsIsNotCached() throws Exception {
+    testRequestMethod("OPTIONS", false);
+  }
+
+  @Test public void requestMethodGetIsCached() throws Exception {
+    testRequestMethod("GET", true);
+  }
+
+  @Test public void requestMethodHeadIsNotCached() throws Exception {
+    // We could support this but choose not to for implementation simplicity
+    testRequestMethod("HEAD", false);
+  }
+
+  @Test public void requestMethodPostIsNotCached() throws Exception {
+    // We could support this but choose not to for implementation simplicity
+    testRequestMethod("POST", false);
+  }
+
+  @Test public void requestMethodPutIsNotCached() throws Exception {
+    testRequestMethod("PUT", false);
+  }
+
+  @Test public void requestMethodDeleteIsNotCached() throws Exception {
+    testRequestMethod("DELETE", false);
+  }
+
+  @Test public void requestMethodTraceIsNotCached() throws Exception {
+    testRequestMethod("TRACE", false);
+  }
+
+  private void testRequestMethod(String requestMethod, boolean expectCached) throws Exception {
+    // 1. Seed the cache (potentially).
+    // 2. Expect a cache hit or miss.
+    server.enqueue(new MockResponse()
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .addHeader("X-Response-ID: 1"));
+    server.enqueue(new MockResponse()
+        .addHeader("X-Response-ID: 2"));
+
+    HttpUrl url = server.url("/");
+
+    Request request = new Request.Builder()
+        .url(url)
+        .method(requestMethod, requestBodyOrNull(requestMethod))
+        .build();
+    Response response1 = client.newCall(request).execute();
+    response1.body().close();
+    assertEquals("1", response1.header("X-Response-ID"));
+
+    Response response2 = get(url);
+    response2.body().close();
+    if (expectCached) {
+      assertEquals("1", response2.header("X-Response-ID"));
+    } else {
+      assertEquals("2", response2.header("X-Response-ID"));
+    }
+  }
+
+  private RequestBody requestBodyOrNull(String requestMethod) {
+    return (requestMethod.equals("POST") || requestMethod.equals("PUT"))
+        ? RequestBody.create(MediaType.parse("text/plain"), "foo")
+        : null;
+  }
+
+  @Test public void postInvalidatesCache() throws Exception {
+    testMethodInvalidates("POST");
+  }
+
+  @Test public void putInvalidatesCache() throws Exception {
+    testMethodInvalidates("PUT");
+  }
+
+  @Test public void deleteMethodInvalidatesCache() throws Exception {
+    testMethodInvalidates("DELETE");
+  }
+
+  private void testMethodInvalidates(String requestMethod) throws Exception {
+    // 1. Seed the cache.
+    // 2. Invalidate it.
+    // 3. Expect a cache miss.
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+    server.enqueue(new MockResponse()
+        .setBody("C"));
+
+    HttpUrl url = server.url("/");
+
+    assertEquals("A", get(url).body().string());
+
+    Request request = new Request.Builder()
+        .url(url)
+        .method(requestMethod, requestBodyOrNull(requestMethod))
+        .build();
+    Response invalidate = client.newCall(request).execute();
+    assertEquals("B", invalidate.body().string());
+
+    assertEquals("C", get(url).body().string());
+  }
+
+  @Test public void postInvalidatesCacheWithUncacheableResponse() throws Exception {
+    // 1. Seed the cache.
+    // 2. Invalidate it with an uncacheable response.
+    // 3. Expect a cache miss.
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse()
+        .setBody("B")
+        .setResponseCode(500));
+    server.enqueue(new MockResponse()
+        .setBody("C"));
+
+    HttpUrl url = server.url("/");
+
+    assertEquals("A", get(url).body().string());
+
+    Request request = new Request.Builder()
+        .url(url)
+        .method("POST", requestBodyOrNull("POST"))
+        .build();
+    Response invalidate = client.newCall(request).execute();
+    assertEquals("B", invalidate.body().string());
+
+    assertEquals("C", get(url).body().string());
+  }
+
+  @Test public void putInvalidatesWithNoContentResponse() throws Exception {
+    // 1. Seed the cache.
+    // 2. Invalidate it.
+    // 3. Expect a cache miss.
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .setResponseCode(HttpURLConnection.HTTP_NO_CONTENT));
+    server.enqueue(new MockResponse()
+        .setBody("C"));
+
+    HttpUrl url = server.url("/");
+
+    assertEquals("A", get(url).body().string());
+
+    Request request = new Request.Builder()
+        .url(url)
+        .put(RequestBody.create(MediaType.parse("text/plain"), "foo"))
+        .build();
+    Response invalidate = client.newCall(request).execute();
+    assertEquals("", invalidate.body().string());
+
+    assertEquals("C", get(url).body().string());
+  }
+
+  @Test public void etag() throws Exception {
+    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
+        .addHeader("ETag: v1"));
+    assertEquals("v1", conditionalRequest.getHeader("If-None-Match"));
+  }
+
+  /** If both If-Modified-Since and If-None-Match conditions apply, send only If-None-Match. */
+  @Test public void etagAndExpirationDateInThePast() throws Exception {
+    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
+        .addHeader("ETag: v1")
+        .addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    assertEquals("v1", conditionalRequest.getHeader("If-None-Match"));
+    assertNull(conditionalRequest.getHeader("If-Modified-Since"));
+  }
+
+  @Test public void etagAndExpirationDateInTheFuture() throws Exception {
+    assertFullyCached(new MockResponse()
+        .addHeader("ETag: v1")
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+  }
+
+  @Test public void cacheControlNoCache() throws Exception {
+    assertNotCached(new MockResponse()
+        .addHeader("Cache-Control: no-cache"));
+  }
+
+  @Test public void cacheControlNoCacheAndExpirationDateInTheFuture() throws Exception {
+    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
+        .addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: no-cache"));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+  }
+
+  @Test public void pragmaNoCache() throws Exception {
+    assertNotCached(new MockResponse()
+        .addHeader("Pragma: no-cache"));
+  }
+
+  @Test public void pragmaNoCacheAndExpirationDateInTheFuture() throws Exception {
+    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
+        .addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .addHeader("Pragma: no-cache"));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+  }
+
+  @Test public void cacheControlNoStore() throws Exception {
+    assertNotCached(new MockResponse()
+        .addHeader("Cache-Control: no-store"));
+  }
+
+  @Test public void cacheControlNoStoreAndExpirationDateInTheFuture() throws Exception {
+    assertNotCached(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: no-store"));
+  }
+
+  @Test public void partialRangeResponsesDoNotCorruptCache() throws Exception {
+    // 1. Request a range.
+    // 2. Request a full document, expecting a cache miss.
+    server.enqueue(new MockResponse()
+        .setBody("AA")
+        .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .addHeader("Content-Range: bytes 1000-1001/2000"));
+    server.enqueue(new MockResponse()
+        .setBody("BB"));
+
+    HttpUrl url = server.url("/");
+
+    Request request = new Request.Builder()
+        .url(url)
+        .header("Range", "bytes=1000-1001")
+        .build();
+    Response range = client.newCall(request).execute();
+    assertEquals("AA", range.body().string());
+
+    assertEquals("BB", get(url).body().string());
+  }
+
+  /**
+   * When the server returns a full response body we will store it and return it regardless of what
+   * its Last-Modified date is. This behavior was different prior to OkHttp 3.5 when we would prefer
+   * the response with the later Last-Modified date.
+   *
+   * https://github.com/square/okhttp/issues/2886
+   */
+  @Test public void serverReturnsDocumentOlderThanCache() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse()
+        .setBody("B")
+        .addHeader("Last-Modified: " + formatDate(-4, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    HttpUrl url = server.url("/");
+
+    assertEquals("A", get(url).body().string());
+    assertEquals("B", get(url).body().string());
+    assertEquals("B", get(url).body().string());
+  }
+
+  @Test public void clientSideNoStore() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("B"));
+
+    Request request1 = new Request.Builder()
+        .url(server.url("/"))
+        .cacheControl(new CacheControl.Builder().noStore().build())
+        .build();
+    Response response1 = client.newCall(request1).execute();
+    assertEquals("A", response1.body().string());
+
+    Request request2 = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Response response2 = client.newCall(request2).execute();
+    assertEquals("B", response2.body().string());
+  }
+
+  @Test public void nonIdentityEncodingAndConditionalCache() throws Exception {
+    assertNonIdentityEncodingCached(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+  }
+
+  @Test public void nonIdentityEncodingAndFullCache() throws Exception {
+    assertNonIdentityEncodingCached(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+  }
+
+  private void assertNonIdentityEncodingCached(MockResponse response) throws Exception {
+    server.enqueue(response
+        .setBody(gzip("ABCABCABC"))
+        .addHeader("Content-Encoding: gzip"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    // At least three request/response pairs are required because after the first request is cached
+    // a different execution path might be taken. Thus modifications to the cache applied during
+    // the second request might not be visible until another request is performed.
+    assertEquals("ABCABCABC", get(server.url("/")).body().string());
+    assertEquals("ABCABCABC", get(server.url("/")).body().string());
+    assertEquals("ABCABCABC", get(server.url("/")).body().string());
+  }
+
+  @Test public void notModifiedSpecifiesEncoding() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(gzip("ABCABCABC"))
+        .addHeader("Content-Encoding: gzip")
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
+        .addHeader("Content-Encoding: gzip"));
+    server.enqueue(new MockResponse()
+        .setBody("DEFDEFDEF"));
+
+    assertEquals("ABCABCABC", get(server.url("/")).body().string());
+    assertEquals("ABCABCABC", get(server.url("/")).body().string());
+    assertEquals("DEFDEFDEF", get(server.url("/")).body().string());
+  }
+
+  /** https://github.com/square/okhttp/issues/947 */
+  @Test public void gzipAndVaryOnAcceptEncoding() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(gzip("ABCABCABC"))
+        .addHeader("Content-Encoding: gzip")
+        .addHeader("Vary: Accept-Encoding")
+        .addHeader("Cache-Control: max-age=60"));
+    server.enqueue(new MockResponse()
+        .setBody("FAIL"));
+
+    assertEquals("ABCABCABC", get(server.url("/")).body().string());
+    assertEquals("ABCABCABC", get(server.url("/")).body().string());
+  }
+
+  @Test public void conditionalCacheHitIsNotDoublePooled() throws Exception {
+    // Ensure that the (shared) connection pool is in a consistent state.
+    client.connectionPool().evictAll();
+    assertEquals(0, client.connectionPool().idleConnectionCount());
+
+    server.enqueue(new MockResponse()
+        .addHeader("ETag: v1")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    assertEquals("A", get(server.url("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
+    assertEquals(1, client.connectionPool().idleConnectionCount());
+  }
+
+  @Test public void expiresDateBeforeModifiedDate() throws Exception {
+    assertConditionallyCached(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(-2, TimeUnit.HOURS)));
+  }
+
+  @Test public void requestMaxAge() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", get(server.url("/")).body().string());
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .header("Cache-Control", "max-age=30")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("B", response.body().string());
+  }
+
+  @Test public void requestMinFresh() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", get(server.url("/")).body().string());
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .header("Cache-Control", "min-fresh=120")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("B", response.body().string());
+  }
+
+  @Test public void requestMaxStale() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Cache-Control: max-age=120")
+        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", get(server.url("/")).body().string());
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .header("Cache-Control", "max-stale=180")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("A", response.body().string());
+    assertEquals("110 HttpURLConnection \"Response is stale\"", response.header("Warning"));
+  }
+
+  @Test public void requestMaxStaleDirectiveWithNoValue() throws IOException {
+    // Add a stale response to the cache.
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Cache-Control: max-age=120")
+        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", get(server.url("/")).body().string());
+
+    // With max-stale, we'll return that stale response.
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .header("Cache-Control", "max-stale")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("A", response.body().string());
+    assertEquals("110 HttpURLConnection \"Response is stale\"", response.header("Warning"));
+  }
+
+  @Test public void requestMaxStaleNotHonoredWithMustRevalidate() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Cache-Control: max-age=120, must-revalidate")
+        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", get(server.url("/")).body().string());
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .header("Cache-Control", "max-stale=180")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("B", response.body().string());
+  }
+
+  @Test public void requestOnlyIfCachedWithNoResponseCached() throws IOException {
+    // (no responses enqueued)
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .header("Cache-Control", "only-if-cached")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertTrue(response.body().source().exhausted());
+    assertEquals(504, response.code());
+    assertEquals(1, cache.requestCount());
+    assertEquals(0, cache.networkCount());
+    assertEquals(0, cache.hitCount());
+  }
+
+  @Test public void requestOnlyIfCachedWithFullResponseCached() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+
+    assertEquals("A", get(server.url("/")).body().string());
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .header("Cache-Control", "only-if-cached")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("A", response.body().string());
+    assertEquals(2, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(1, cache.hitCount());
+  }
+
+  @Test public void requestOnlyIfCachedWithConditionalResponseCached() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES)));
+
+    assertEquals("A", get(server.url("/")).body().string());
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .header("Cache-Control", "only-if-cached")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertTrue(response.body().source().exhausted());
+    assertEquals(504, response.code());
+    assertEquals(2, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
+  }
+
+  @Test public void requestOnlyIfCachedWithUnhelpfulResponseCached() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A"));
+
+    assertEquals("A", get(server.url("/")).body().string());
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .header("Cache-Control", "only-if-cached")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertTrue(response.body().source().exhausted());
+    assertEquals(504, response.code());
+    assertEquals(2, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
+  }
+
+  @Test public void requestCacheControlNoCache() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
+        .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    HttpUrl url = server.url("/");
+    assertEquals("A", get(url).body().string());
+    Request request = new Request.Builder()
+        .url(url)
+        .header("Cache-Control", "no-cache")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("B", response.body().string());
+  }
+
+  @Test public void requestPragmaNoCache() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
+        .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    HttpUrl url = server.url("/");
+    assertEquals("A", get(url).body().string());
+    Request request = new Request.Builder()
+        .url(url)
+        .header("Pragma", "no-cache")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("B", response.body().string());
+  }
+
+  @Test public void clientSuppliedIfModifiedSinceWithCachedResult() throws Exception {
+    MockResponse response = new MockResponse()
+        .addHeader("ETag: v3")
+        .addHeader("Cache-Control: max-age=0");
+    String ifModifiedSinceDate = formatDate(-24, TimeUnit.HOURS);
+    RecordedRequest request =
+        assertClientSuppliedCondition(response, "If-Modified-Since", ifModifiedSinceDate);
+    assertEquals(ifModifiedSinceDate, request.getHeader("If-Modified-Since"));
+    assertNull(request.getHeader("If-None-Match"));
+  }
+
+  @Test public void clientSuppliedIfNoneMatchSinceWithCachedResult() throws Exception {
+    String lastModifiedDate = formatDate(-3, TimeUnit.MINUTES);
+    MockResponse response = new MockResponse()
+        .addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
+        .addHeader("Cache-Control: max-age=0");
+    RecordedRequest request = assertClientSuppliedCondition(response, "If-None-Match", "v1");
+    assertEquals("v1", request.getHeader("If-None-Match"));
+    assertNull(request.getHeader("If-Modified-Since"));
+  }
+
+  private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String conditionName,
+      String conditionValue) throws Exception {
+    server.enqueue(seed.setBody("A"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    HttpUrl url = server.url("/");
+    assertEquals("A", get(url).body().string());
+
+    Request request = new Request.Builder()
+        .url(url)
+        .header(conditionName, conditionValue)
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, response.code());
+    assertEquals("", response.body().string());
+
+    server.takeRequest(); // seed
+    return server.takeRequest();
+  }
+
+  /**
+   * For Last-Modified and Date headers, we should echo the date back in the exact format we were
+   * served.
+   */
+  @Test public void retainServedDateFormat() throws Exception {
+    // Serve a response with a non-standard date format that OkHttp supports.
+    Date lastModifiedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-1));
+    Date servedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-2));
+    DateFormat dateFormat = new SimpleDateFormat("EEE dd-MMM-yyyy HH:mm:ss z", Locale.US);
+    dateFormat.setTimeZone(TimeZone.getTimeZone("EDT"));
+    String lastModifiedString = dateFormat.format(lastModifiedDate);
+    String servedString = dateFormat.format(servedDate);
+
+    // This response should be conditionally cached.
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + lastModifiedString)
+        .addHeader("Expires: " + servedString)
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    assertEquals("A", get(server.url("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
+
+    // The first request has no conditions.
+    RecordedRequest request1 = server.takeRequest();
+    assertNull(request1.getHeader("If-Modified-Since"));
+
+    // The 2nd request uses the server's date format.
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals(lastModifiedString, request2.getHeader("If-Modified-Since"));
+  }
+
+  @Test public void clientSuppliedConditionWithoutCachedResult() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .header("If-Modified-Since", formatDate(-24, TimeUnit.HOURS))
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, response.code());
+    assertEquals("", response.body().string());
+  }
+
+  @Test public void authorizationRequestFullyCached() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    HttpUrl url = server.url("/");
+    Request request = new Request.Builder()
+        .url(url)
+        .header("Authorization", "password")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("A", response.body().string());
+    assertEquals("A", get(url).body().string());
+  }
+
+  @Test public void contentLocationDoesNotPopulateCache() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Content-Location: /bar")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", get(server.url("/foo")).body().string());
+    assertEquals("B", get(server.url("/bar")).body().string());
+  }
+
+  @Test public void connectionIsReturnedToPoolAfterConditionalSuccess() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", get(server.url("/a")).body().string());
+    assertEquals("A", get(server.url("/a")).body().string());
+    assertEquals("B", get(server.url("/b")).body().string());
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertEquals(2, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void statisticsConditionalCacheMiss() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+    server.enqueue(new MockResponse()
+        .setBody("C"));
+
+    assertEquals("A", get(server.url("/")).body().string());
+    assertEquals(1, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
+    assertEquals("B", get(server.url("/")).body().string());
+    assertEquals("C", get(server.url("/")).body().string());
+    assertEquals(3, cache.requestCount());
+    assertEquals(3, cache.networkCount());
+    assertEquals(0, cache.hitCount());
+  }
+
+  @Test public void statisticsConditionalCacheHit() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    assertEquals("A", get(server.url("/")).body().string());
+    assertEquals(1, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
+    assertEquals("A", get(server.url("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
+    assertEquals(3, cache.requestCount());
+    assertEquals(3, cache.networkCount());
+    assertEquals(2, cache.hitCount());
+  }
+
+  @Test public void statisticsFullCacheHit() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
+
+    assertEquals("A", get(server.url("/")).body().string());
+    assertEquals(1, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
+    assertEquals("A", get(server.url("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
+    assertEquals(3, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(2, cache.hitCount());
+  }
+
+  @Test public void varyMatchesChangedRequestHeaderField() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    HttpUrl url = server.url("/");
+    Request frRequest = new Request.Builder()
+        .url(url)
+        .header("Accept-Language", "fr-CA")
+        .build();
+    Response frResponse = client.newCall(frRequest).execute();
+    assertEquals("A", frResponse.body().string());
+
+    Request enRequest = new Request.Builder()
+        .url(url)
+        .header("Accept-Language", "en-US")
+        .build();
+    Response enResponse = client.newCall(enRequest).execute();
+    assertEquals("B", enResponse.body().string());
+  }
+
+  @Test public void varyMatchesUnchangedRequestHeaderField() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    HttpUrl url = server.url("/");
+    Request request = new Request.Builder()
+        .url(url)
+        .header("Accept-Language", "fr-CA")
+        .build();
+    Response response1 = client.newCall(request).execute();
+    assertEquals("A", response1.body().string());
+    Request request1 = new Request.Builder()
+        .url(url)
+        .header("Accept-Language", "fr-CA")
+        .build();
+    Response response2 = client.newCall(request1).execute();
+    assertEquals("A", response2.body().string());
+  }
+
+  @Test public void varyMatchesAbsentRequestHeaderField() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Foo")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", get(server.url("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
+  }
+
+  @Test public void varyMatchesAddedRequestHeaderField() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Foo")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", get(server.url("/")).body().string());
+    Request request = new Request.Builder()
+        .url(server.url("/")).header("Foo", "bar")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("B", response.body().string());
+  }
+
+  @Test public void varyMatchesRemovedRequestHeaderField() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Foo")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/")).header("Foo", "bar")
+        .build();
+    Response fooresponse = client.newCall(request).execute();
+    assertEquals("A", fooresponse.body().string());
+    assertEquals("B", get(server.url("/")).body().string());
+  }
+
+  @Test public void varyFieldsAreCaseInsensitive() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: ACCEPT-LANGUAGE")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    HttpUrl url = server.url("/");
+    Request request = new Request.Builder()
+        .url(url)
+        .header("Accept-Language", "fr-CA")
+        .build();
+    Response response1 = client.newCall(request).execute();
+    assertEquals("A", response1.body().string());
+    Request request1 = new Request.Builder()
+        .url(url)
+        .header("accept-language", "fr-CA")
+        .build();
+    Response response2 = client.newCall(request1).execute();
+    assertEquals("A", response2.body().string());
+  }
+
+  @Test public void varyMultipleFieldsWithMatch() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language, Accept-Charset")
+        .addHeader("Vary: Accept-Encoding")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    HttpUrl url = server.url("/");
+    Request request = new Request.Builder()
+        .url(url)
+        .header("Accept-Language", "fr-CA")
+        .header("Accept-Charset", "UTF-8")
+        .header("Accept-Encoding", "identity")
+        .build();
+    Response response1 = client.newCall(request).execute();
+    assertEquals("A", response1.body().string());
+    Request request1 = new Request.Builder()
+        .url(url)
+        .header("Accept-Language", "fr-CA")
+        .header("Accept-Charset", "UTF-8")
+        .header("Accept-Encoding", "identity")
+        .build();
+    Response response2 = client.newCall(request1).execute();
+    assertEquals("A", response2.body().string());
+  }
+
+  @Test public void varyMultipleFieldsWithNoMatch() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language, Accept-Charset")
+        .addHeader("Vary: Accept-Encoding")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    HttpUrl url = server.url("/");
+    Request frRequest = new Request.Builder()
+        .url(url)
+        .header("Accept-Language", "fr-CA")
+        .header("Accept-Charset", "UTF-8")
+        .header("Accept-Encoding", "identity")
+        .build();
+    Response frResponse = client.newCall(frRequest).execute();
+    assertEquals("A", frResponse.body().string());
+    Request enRequest = new Request.Builder()
+        .url(url)
+        .header("Accept-Language", "en-CA")
+        .header("Accept-Charset", "UTF-8")
+        .header("Accept-Encoding", "identity")
+        .build();
+    Response enResponse = client.newCall(enRequest).execute();
+    assertEquals("B", enResponse.body().string());
+  }
+
+  @Test public void varyMultipleFieldValuesWithMatch() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    HttpUrl url = server.url("/");
+    Request request1 = new Request.Builder()
+        .url(url)
+        .addHeader("Accept-Language", "fr-CA, fr-FR")
+        .addHeader("Accept-Language", "en-US")
+        .build();
+    Response response1 = client.newCall(request1).execute();
+    assertEquals("A", response1.body().string());
+
+    Request request2 = new Request.Builder()
+        .url(url)
+        .addHeader("Accept-Language", "fr-CA, fr-FR")
+        .addHeader("Accept-Language", "en-US")
+        .build();
+    Response response2 = client.newCall(request2).execute();
+    assertEquals("A", response2.body().string());
+  }
+
+  @Test public void varyMultipleFieldValuesWithNoMatch() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    HttpUrl url = server.url("/");
+    Request request1 = new Request.Builder()
+        .url(url)
+        .addHeader("Accept-Language", "fr-CA, fr-FR")
+        .addHeader("Accept-Language", "en-US")
+        .build();
+    Response response1 = client.newCall(request1).execute();
+    assertEquals("A", response1.body().string());
+
+    Request request2 = new Request.Builder()
+        .url(url)
+        .addHeader("Accept-Language", "fr-CA")
+        .addHeader("Accept-Language", "en-US")
+        .build();
+    Response response2 = client.newCall(request2).execute();
+    assertEquals("B", response2.body().string());
+  }
+
+  @Test public void varyAsterisk() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: *")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", get(server.url("/")).body().string());
+    assertEquals("B", get(server.url("/")).body().string());
+  }
+
+  @Test public void varyAndHttps() throws Exception {
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
+        .build();
+
+    HttpUrl url = server.url("/");
+    Request request1 = new Request.Builder()
+        .url(url)
+        .header("Accept-Language", "en-US")
+        .build();
+    Response response1 = client.newCall(request1).execute();
+    assertEquals("A", response1.body().string());
+
+    Request request2 = new Request.Builder()
+        .url(url)
+        .header("Accept-Language", "en-US")
+        .build();
+    Response response2 = client.newCall(request2).execute();
+    assertEquals("A", response2.body().string());
+  }
+
+  @Test public void cachePlusCookies() throws Exception {
+    RecordingCookieJar cookieJar = new RecordingCookieJar();
+    client = client.newBuilder()
+        .cookieJar(cookieJar)
+        .build();
+
+    server.enqueue(new MockResponse()
+        .addHeader("Set-Cookie: a=FIRST")
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .addHeader("Set-Cookie: a=SECOND")
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    HttpUrl url = server.url("/");
+    assertEquals("A", get(url).body().string());
+    cookieJar.assertResponseCookies("a=FIRST; path=/");
+    assertEquals("A", get(url).body().string());
+    cookieJar.assertResponseCookies("a=SECOND; path=/");
+  }
+
+  @Test public void getHeadersReturnsNetworkEndToEndHeaders() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Allow: GET, HEAD")
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .addHeader("Allow: GET, HEAD, PUT")
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    Response response1 = get(server.url("/"));
+    assertEquals("A", response1.body().string());
+    assertEquals("GET, HEAD", response1.header("Allow"));
+
+    Response response2 = get(server.url("/"));
+    assertEquals("A", response2.body().string());
+    assertEquals("GET, HEAD, PUT", response2.header("Allow"));
+  }
+
+  @Test public void getHeadersReturnsCachedHopByHopHeaders() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Transfer-Encoding: identity")
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .addHeader("Transfer-Encoding: none")
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    Response response1 = get(server.url("/"));
+    assertEquals("A", response1.body().string());
+    assertEquals("identity", response1.header("Transfer-Encoding"));
+
+    Response response2 = get(server.url("/"));
+    assertEquals("A", response2.body().string());
+    assertEquals("identity", response2.header("Transfer-Encoding"));
+  }
+
+  @Test public void getHeadersDeletesCached100LevelWarnings() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Warning: 199 test danger")
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    Response response1 = get(server.url("/"));
+    assertEquals("A", response1.body().string());
+    assertEquals("199 test danger", response1.header("Warning"));
+
+    Response response2 = get(server.url("/"));
+    assertEquals("A", response2.body().string());
+    assertEquals(null, response2.header("Warning"));
+  }
+
+  @Test public void getHeadersRetainsCached200LevelWarnings() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Warning: 299 test danger")
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    Response response1 = get(server.url("/"));
+    assertEquals("A", response1.body().string());
+    assertEquals("299 test danger", response1.header("Warning"));
+
+    Response response2 = get(server.url("/"));
+    assertEquals("A", response2.body().string());
+    assertEquals("299 test danger", response2.header("Warning"));
+  }
+
+  @Test public void doNotCachePartialResponse() throws Exception {
+    assertNotCached(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
+        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
+        .addHeader("Content-Range: bytes 100-100/200")
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void conditionalHitUpdatesCache() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(0, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Allow: GET, HEAD")
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    // A cache miss writes the cache.
+    long t0 = System.currentTimeMillis();
+    Response response1 = get(server.url("/a"));
+    assertEquals("A", response1.body().string());
+    assertEquals(null, response1.header("Allow"));
+    assertEquals(0, response1.receivedResponseAtMillis() - t0, 250.0);
+
+    // A conditional cache hit updates the cache.
+    Thread.sleep(500); // Make sure t0 and t1 are distinct.
+    long t1 = System.currentTimeMillis();
+    Response response2 = get(server.url("/a"));
+    assertEquals(HttpURLConnection.HTTP_OK, response2.code());
+    assertEquals("A", response2.body().string());
+    assertEquals("GET, HEAD", response2.header("Allow"));
+    assertEquals(0, response2.receivedResponseAtMillis() - t1, 250.0);
+
+    // A full cache hit reads the cache.
+    Thread.sleep(500); // Make sure t1 and t2 are distinct.
+    long t2 = System.currentTimeMillis();
+    Response response3 = get(server.url("/a"));
+    assertEquals("A", response3.body().string());
+    assertEquals("GET, HEAD", response3.header("Allow"));
+    assertEquals(0, response3.receivedResponseAtMillis() - t1, 250.0);
+
+    assertEquals(2, server.getRequestCount());
+  }
+
+  @Test public void responseSourceHeaderCached() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+
+    assertEquals("A", get(server.url("/")).body().string());
+    Request request = new Request.Builder()
+        .url(server.url("/")).header("Cache-Control", "only-if-cached")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("A", response.body().string());
+  }
+
+  @Test public void responseSourceHeaderConditionalCacheFetched() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Date: " + formatDate(-31, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse()
+        .setBody("B")
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+
+    assertEquals("A", get(server.url("/")).body().string());
+    Response response = get(server.url("/"));
+    assertEquals("B", response.body().string());
+  }
+
+  @Test public void responseSourceHeaderConditionalCacheNotFetched() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Cache-Control: max-age=0")
+        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse()
+        .setResponseCode(304));
+
+    assertEquals("A", get(server.url("/")).body().string());
+    Response response = get(server.url("/"));
+    assertEquals("A", response.body().string());
+  }
+
+  @Test public void responseSourceHeaderFetched() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A"));
+
+    Response response = get(server.url("/"));
+    assertEquals("A", response.body().string());
+  }
+
+  @Test public void emptyResponseHeaderNameFromCacheIsLenient() throws Exception {
+    Headers.Builder headers = new Headers.Builder()
+        .add("Cache-Control: max-age=120");
+    Internal.instance.addLenient(headers, ": A");
+    server.enqueue(new MockResponse()
+        .setHeaders(headers.build())
+        .setBody("body"));
+
+    Response response = get(server.url("/"));
+    assertEquals("A", response.header(""));
+    assertEquals("body", response.body().string());
+  }
+
+  /**
+   * Old implementations of OkHttp's response cache wrote header fields like ":status: 200 OK". This
+   * broke our cached response parser because it split on the first colon. This regression test
+   * exists to help us read these old bad cache entries.
+   *
+   * https://github.com/square/okhttp/issues/227
+   */
+  @Test public void testGoldenCacheResponse() throws Exception {
+    cache.close();
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    HttpUrl url = server.url("/");
+    String urlKey = Cache.key(url);
+    String entryMetadata = ""
+        + "" + url + "\n"
+        + "GET\n"
+        + "0\n"
+        + "HTTP/1.1 200 OK\n"
+        + "7\n"
+        + ":status: 200 OK\n"
+        + ":version: HTTP/1.1\n"
+        + "etag: foo\n"
+        + "content-length: 3\n"
+        + "OkHttp-Received-Millis: " + System.currentTimeMillis() + "\n"
+        + "X-Android-Response-Source: NETWORK 200\n"
+        + "OkHttp-Sent-Millis: " + System.currentTimeMillis() + "\n"
+        + "\n"
+        + "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\n"
+        + "1\n"
+        + "MIIBpDCCAQ2gAwIBAgIBATANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDEw1qd2lsc29uLmxvY2FsMB4XDTEzMDgy"
+        + "OTA1MDE1OVoXDTEzMDgzMDA1MDE1OVowGDEWMBQGA1UEAxMNandpbHNvbi5sb2NhbDCBnzANBgkqhkiG9w0BAQEF"
+        + "AAOBjQAwgYkCgYEAlFW+rGo/YikCcRghOyKkJanmVmJSce/p2/jH1QvNIFKizZdh8AKNwojt3ywRWaDULA/RlCUc"
+        + "ltF3HGNsCyjQI/+Lf40x7JpxXF8oim1E6EtDoYtGWAseelawus3IQ13nmo6nWzfyCA55KhAWf4VipelEy8DjcuFK"
+        + "v6L0xwXnI0ECAwEAATANBgkqhkiG9w0BAQsFAAOBgQAuluNyPo1HksU3+Mr/PyRQIQS4BI7pRXN8mcejXmqyscdP"
+        + "7S6J21FBFeRR8/XNjVOp4HT9uSc2hrRtTEHEZCmpyoxixbnM706ikTmC7SN/GgM+SmcoJ1ipJcNcl8N0X6zym4dm"
+        + "yFfXKHu2PkTo7QFdpOJFvP3lIigcSZXozfmEDg==\n"
+        + "-1\n";
+    String entryBody = "abc";
+    String journalBody = ""
+        + "libcore.io.DiskLruCache\n"
+        + "1\n"
+        + "201105\n"
+        + "2\n"
+        + "\n"
+        + "CLEAN " + urlKey + " " + entryMetadata.length() + " " + entryBody.length() + "\n";
+    writeFile(cache.directory(), urlKey + ".0", entryMetadata);
+    writeFile(cache.directory(), urlKey + ".1", entryBody);
+    writeFile(cache.directory(), "journal", journalBody);
+    cache = new Cache(cache.directory(), Integer.MAX_VALUE, fileSystem);
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    Response response = get(url);
+    assertEquals(entryBody, response.body().string());
+    assertEquals("3", response.header("Content-Length"));
+    assertEquals("foo", response.header("etag"));
+  }
+
+  /** Exercise the cache format in OkHttp 2.7 and all earlier releases. */
+  @Test public void testGoldenCacheHttpsResponseOkHttp27() throws Exception {
+    HttpUrl url = server.url("/");
+    String urlKey = Cache.key(url);
+    String prefix = Platform.get().getPrefix();
+    String entryMetadata = ""
+        + "" + url + "\n"
+        + "GET\n"
+        + "0\n"
+        + "HTTP/1.1 200 OK\n"
+        + "4\n"
+        + "Content-Length: 3\n"
+        + prefix + "-Received-Millis: " + System.currentTimeMillis() + "\n"
+        + prefix + "-Sent-Millis: " + System.currentTimeMillis() + "\n"
+        + "Cache-Control: max-age=60\n"
+        + "\n"
+        + "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\n"
+        + "1\n"
+        + "MIIBnDCCAQWgAwIBAgIBATANBgkqhkiG9w0BAQsFADAUMRIwEAYDVQQDEwlsb2NhbGhvc3QwHhcNMTUxMjIyMDEx"
+        + "MTQwWhcNMTUxMjIzMDExMTQwWjAUMRIwEAYDVQQDEwlsb2NhbGhvc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJ"
+        + "AoGBAJTn2Dh8xYmegvpOSmsKb2Os6Cxf1L4fYbnHr/turInUD5r1P7ZAuxurY880q3GT5bUDoirS3IfucddrT1Ac"
+        + "AmUzEmk/FDjggiP8DlxFkY/XwXBlhRDVIp/mRuASPMGInckc0ZaixOkRFyrxADj+r1eaSmXCIvV5yTY6IaIokLj1"
+        + "AgMBAAEwDQYJKoZIhvcNAQELBQADgYEAFblnedqtfRqI9j2WDyPPoG0NTZf9xwjeUu+ju+Ktty8u9k7Lgrrd/DH2"
+        + "mQEtBD1Ctvp91MJfAClNg3faZzwClUyu5pd0QXRZEUwSwZQNen2QWDHRlVsItclBJ4t+AJLqTbwofWi4m4K8REOl"
+        + "593hD55E4+lY22JZiVQyjsQhe6I=\n"
+        + "0\n";
+    String entryBody = "abc";
+    String journalBody = ""
+        + "libcore.io.DiskLruCache\n"
+        + "1\n"
+        + "201105\n"
+        + "2\n"
+        + "\n"
+        + "DIRTY " + urlKey + "\n"
+        + "CLEAN " + urlKey + " " + entryMetadata.length() + " " + entryBody.length() + "\n";
+    writeFile(cache.directory(), urlKey + ".0", entryMetadata);
+    writeFile(cache.directory(), urlKey + ".1", entryBody);
+    writeFile(cache.directory(), "journal", journalBody);
+    cache.close();
+    cache = new Cache(cache.directory(), Integer.MAX_VALUE, fileSystem);
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    Response response = get(url);
+    assertEquals(entryBody, response.body().string());
+    assertEquals("3", response.header("Content-Length"));
+  }
+
+  /** The TLS version is present in OkHttp 3.0 and beyond. */
+  @Test public void testGoldenCacheHttpsResponseOkHttp30() throws Exception {
+    HttpUrl url = server.url("/");
+    String urlKey = Cache.key(url);
+    String prefix = Platform.get().getPrefix();
+    String entryMetadata = ""
+        + "" + url + "\n"
+        + "GET\n"
+        + "0\n"
+        + "HTTP/1.1 200 OK\n"
+        + "4\n"
+        + "Content-Length: 3\n"
+        + prefix + "-Received-Millis: " + System.currentTimeMillis() + "\n"
+        + prefix + "-Sent-Millis: " + System.currentTimeMillis() + "\n"
+        + "Cache-Control: max-age=60\n"
+        + "\n"
+        + "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\n"
+        + "1\n"
+        + "MIIBnDCCAQWgAwIBAgIBATANBgkqhkiG9w0BAQsFADAUMRIwEAYDVQQDEwlsb2NhbGhvc3QwHhcNMTUxMjIyMDEx"
+        + "MTQwWhcNMTUxMjIzMDExMTQwWjAUMRIwEAYDVQQDEwlsb2NhbGhvc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJ"
+        + "AoGBAJTn2Dh8xYmegvpOSmsKb2Os6Cxf1L4fYbnHr/turInUD5r1P7ZAuxurY880q3GT5bUDoirS3IfucddrT1Ac"
+        + "AmUzEmk/FDjggiP8DlxFkY/XwXBlhRDVIp/mRuASPMGInckc0ZaixOkRFyrxADj+r1eaSmXCIvV5yTY6IaIokLj1"
+        + "AgMBAAEwDQYJKoZIhvcNAQELBQADgYEAFblnedqtfRqI9j2WDyPPoG0NTZf9xwjeUu+ju+Ktty8u9k7Lgrrd/DH2"
+        + "mQEtBD1Ctvp91MJfAClNg3faZzwClUyu5pd0QXRZEUwSwZQNen2QWDHRlVsItclBJ4t+AJLqTbwofWi4m4K8REOl"
+        + "593hD55E4+lY22JZiVQyjsQhe6I=\n"
+        + "0\n"
+        + "TLSv1.2\n";
+    String entryBody = "abc";
+    String journalBody = ""
+        + "libcore.io.DiskLruCache\n"
+        + "1\n"
+        + "201105\n"
+        + "2\n"
+        + "\n"
+        + "DIRTY " + urlKey + "\n"
+        + "CLEAN " + urlKey + " " + entryMetadata.length() + " " + entryBody.length() + "\n";
+    writeFile(cache.directory(), urlKey + ".0", entryMetadata);
+    writeFile(cache.directory(), urlKey + ".1", entryBody);
+    writeFile(cache.directory(), "journal", journalBody);
+    cache.close();
+    cache = new Cache(cache.directory(), Integer.MAX_VALUE, fileSystem);
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    Response response = get(url);
+    assertEquals(entryBody, response.body().string());
+    assertEquals("3", response.header("Content-Length"));
+  }
+
+  @Test public void testGoldenCacheHttpResponseOkHttp30() throws Exception {
+    HttpUrl url = server.url("/");
+    String urlKey = Cache.key(url);
+    String prefix = Platform.get().getPrefix();
+    String entryMetadata = ""
+        + "" + url + "\n"
+        + "GET\n"
+        + "0\n"
+        + "HTTP/1.1 200 OK\n"
+        + "4\n"
+        + "Cache-Control: max-age=60\n"
+        + "Content-Length: 3\n"
+        + prefix + "-Received-Millis: " + System.currentTimeMillis() + "\n"
+        + prefix + "-Sent-Millis: " + System.currentTimeMillis() + "\n";
+    String entryBody = "abc";
+    String journalBody = ""
+        + "libcore.io.DiskLruCache\n"
+        + "1\n"
+        + "201105\n"
+        + "2\n"
+        + "\n"
+        + "DIRTY " + urlKey + "\n"
+        + "CLEAN " + urlKey + " " + entryMetadata.length() + " " + entryBody.length() + "\n";
+    writeFile(cache.directory(), urlKey + ".0", entryMetadata);
+    writeFile(cache.directory(), urlKey + ".1", entryBody);
+    writeFile(cache.directory(), "journal", journalBody);
+    cache.close();
+    cache = new Cache(cache.directory(), Integer.MAX_VALUE, fileSystem);
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    Response response = get(url);
+    assertEquals(entryBody, response.body().string());
+    assertEquals("3", response.header("Content-Length"));
+  }
+
+  @Test public void evictAll() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    HttpUrl url = server.url("/");
+    assertEquals("A", get(url).body().string());
+    client.cache().evictAll();
+    assertEquals(0, client.cache().size());
+    assertEquals("B", get(url).body().string());
+  }
+
+  @Test public void networkInterceptorInvokedForConditionalGet() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("ETag: v1")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    // Seed the cache.
+    HttpUrl url = server.url("/");
+    assertEquals("A", get(url).body().string());
+
+    final AtomicReference<String> ifNoneMatch = new AtomicReference<>();
+    client = client.newBuilder()
+        .addNetworkInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            ifNoneMatch.compareAndSet(null, chain.request().header("If-None-Match"));
+            return chain.proceed(chain.request());
+          }
+        }).build();
+
+    // Confirm the value is cached and intercepted.
+    assertEquals("A", get(url).body().string());
+    assertEquals("v1", ifNoneMatch.get());
+  }
+
+  @Test public void networkInterceptorNotInvokedForFullyCached() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
+
+    // Seed the cache.
+    HttpUrl url = server.url("/");
+    assertEquals("A", get(url).body().string());
+
+    // Confirm the interceptor isn't exercised.
+    client = client.newBuilder()
+        .addNetworkInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            throw new AssertionError();
+          }
+        }).build();
+    assertEquals("A", get(url).body().string());
+  }
+
+  @Test public void iterateCache() throws Exception {
+    // Put some responses in the cache.
+    server.enqueue(new MockResponse()
+        .setBody("a"));
+    HttpUrl urlA = server.url("/a");
+    assertEquals("a", get(urlA).body().string());
+
+    server.enqueue(new MockResponse()
+        .setBody("b"));
+    HttpUrl urlB = server.url("/b");
+    assertEquals("b", get(urlB).body().string());
+
+    server.enqueue(new MockResponse()
+        .setBody("c"));
+    HttpUrl urlC = server.url("/c");
+    assertEquals("c", get(urlC).body().string());
+
+    // Confirm the iterator returns those responses...
+    Iterator<String> i = cache.urls();
+    assertTrue(i.hasNext());
+    assertEquals(urlA.toString(), i.next());
+    assertTrue(i.hasNext());
+    assertEquals(urlB.toString(), i.next());
+    assertTrue(i.hasNext());
+    assertEquals(urlC.toString(), i.next());
+
+    // ... and nothing else.
+    assertFalse(i.hasNext());
+    try {
+      i.next();
+      fail();
+    } catch (NoSuchElementException expected) {
+    }
+  }
+
+  @Test public void iteratorRemoveFromCache() throws Exception {
+    // Put a response in the cache.
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("a"));
+    HttpUrl url = server.url("/a");
+    assertEquals("a", get(url).body().string());
+
+    // Remove it with iteration.
+    Iterator<String> i = cache.urls();
+    assertEquals(url.toString(), i.next());
+    i.remove();
+
+    // Confirm that subsequent requests suffer a cache miss.
+    server.enqueue(new MockResponse()
+        .setBody("b"));
+    assertEquals("b", get(url).body().string());
+  }
+
+  @Test public void iteratorRemoveWithoutNextThrows() throws Exception {
+    // Put a response in the cache.
+    server.enqueue(new MockResponse()
+        .setBody("a"));
+    HttpUrl url = server.url("/a");
+    assertEquals("a", get(url).body().string());
+
+    Iterator<String> i = cache.urls();
+    assertTrue(i.hasNext());
+    try {
+      i.remove();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  @Test public void iteratorRemoveOncePerCallToNext() throws Exception {
+    // Put a response in the cache.
+    server.enqueue(new MockResponse()
+        .setBody("a"));
+    HttpUrl url = server.url("/a");
+    assertEquals("a", get(url).body().string());
+
+    Iterator<String> i = cache.urls();
+    assertEquals(url.toString(), i.next());
+    i.remove();
+
+    // Too many calls to remove().
+    try {
+      i.remove();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  @Test public void elementEvictedBetweenHasNextAndNext() throws Exception {
+    // Put a response in the cache.
+    server.enqueue(new MockResponse()
+        .setBody("a"));
+    HttpUrl url = server.url("/a");
+    assertEquals("a", get(url).body().string());
+
+    // The URL will remain available if hasNext() returned true...
+    Iterator<String> i = cache.urls();
+    assertTrue(i.hasNext());
+
+    // ...so even when we evict the element, we still get something back.
+    cache.evictAll();
+    assertEquals(url.toString(), i.next());
+
+    // Remove does nothing. But most importantly, it doesn't throw!
+    i.remove();
+  }
+
+  @Test public void elementEvictedBeforeHasNextIsOmitted() throws Exception {
+    // Put a response in the cache.
+    server.enqueue(new MockResponse()
+        .setBody("a"));
+    HttpUrl url = server.url("/a");
+    assertEquals("a", get(url).body().string());
+
+    Iterator<String> i = cache.urls();
+    cache.evictAll();
+
+    // The URL was evicted before hasNext() made any promises.
+    assertFalse(i.hasNext());
+    try {
+      i.next();
+      fail();
+    } catch (NoSuchElementException expected) {
+    }
+  }
+
+  /** Test https://github.com/square/okhttp/issues/1712. */
+  @Test public void conditionalMissUpdatesCache() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("ETag: v1")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.enqueue(new MockResponse()
+        .addHeader("ETag: v2")
+        .setBody("B"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    HttpUrl url = server.url("/");
+    assertEquals("A", get(url).body().string());
+    assertEquals("A", get(url).body().string());
+    assertEquals("B", get(url).body().string());
+    assertEquals("B", get(url).body().string());
+
+    assertEquals(null, server.takeRequest().getHeader("If-None-Match"));
+    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
+    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
+    assertEquals("v2", server.takeRequest().getHeader("If-None-Match"));
+  }
+
+  @Test public void combinedCacheHeadersCanBeNonAscii() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .addHeaderLenient("Alpha", "α")
+        .addHeaderLenient("β", "Beta")
+        .setBody("abcd"));
+    server.enqueue(new MockResponse()
+        .addHeader("Transfer-Encoding: none")
+        .addHeaderLenient("Gamma", "Γ")
+        .addHeaderLenient("Δ", "Delta")
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    Response response1 = get(server.url("/"));
+    assertEquals("α", response1.header("Alpha"));
+    assertEquals("Beta", response1.header("β"));
+    assertEquals("abcd", response1.body().string());
+
+    Response response2 = get(server.url("/"));
+    assertEquals("α", response2.header("Alpha"));
+    assertEquals("Beta", response2.header("β"));
+    assertEquals("Γ", response2.header("Gamma"));
+    assertEquals("Delta", response2.header("Δ"));
+    assertEquals("abcd", response2.body().string());
+  }
+
+  @Test public void etagConditionCanBeNonAscii() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeaderLenient("Etag", "α")
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("abcd"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    Response response1 = get(server.url("/"));
+    assertEquals("abcd", response1.body().string());
+
+    Response response2 = get(server.url("/"));
+    assertEquals("abcd", response2.body().string());
+
+    assertEquals(null, server.takeRequest().getHeader("If-None-Match"));
+    assertEquals("α", server.takeRequest().getHeader("If-None-Match"));
+  }
+
+  private Response get(HttpUrl url) throws IOException {
+    Request request = new Request.Builder()
+        .url(url)
+        .build();
+    return client.newCall(request).execute();
+  }
+
+  private void writeFile(File directory, String file, String content) throws IOException {
+    BufferedSink sink = Okio.buffer(fileSystem.sink(new File(directory, file)));
+    sink.writeUtf8(content);
+    sink.close();
+  }
+
+  /**
+   * @param delta the offset from the current date to use. Negative values yield dates in the past;
+   * positive values yield dates in the future.
+   */
+  private String formatDate(long delta, TimeUnit timeUnit) {
+    return formatDate(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
+  }
+
+  private String formatDate(Date date) {
+    DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
+    rfc1123.setTimeZone(TimeZone.getTimeZone("GMT"));
+    return rfc1123.format(date);
+  }
+
+  private void assertNotCached(MockResponse response) throws Exception {
+    server.enqueue(response.setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    HttpUrl url = server.url("/");
+    assertEquals("A", get(url).body().string());
+    assertEquals("B", get(url).body().string());
+  }
+
+  /** @return the request with the conditional get headers. */
+  private RecordedRequest assertConditionallyCached(MockResponse response) throws Exception {
+    // scenario 1: condition succeeds
+    server.enqueue(response.setBody("A").setStatus("HTTP/1.1 200 A-OK"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    // scenario 2: condition fails
+    server.enqueue(response.setBody("B")
+        .setStatus("HTTP/1.1 200 B-OK"));
+    server.enqueue(new MockResponse()
+        .setStatus("HTTP/1.1 200 C-OK")
+        .setBody("C"));
+
+    HttpUrl valid = server.url("/valid");
+    Response response1 = get(valid);
+    assertEquals("A", response1.body().string());
+    assertEquals(HttpURLConnection.HTTP_OK, response1.code());
+    assertEquals("A-OK", response1.message());
+    Response response2 = get(valid);
+    assertEquals("A", response2.body().string());
+    assertEquals(HttpURLConnection.HTTP_OK, response2.code());
+    assertEquals("A-OK", response2.message());
+
+    HttpUrl invalid = server.url("/invalid");
+    Response response3 = get(invalid);
+    assertEquals("B", response3.body().string());
+    assertEquals(HttpURLConnection.HTTP_OK, response3.code());
+    assertEquals("B-OK", response3.message());
+    Response response4 = get(invalid);
+    assertEquals("C", response4.body().string());
+    assertEquals(HttpURLConnection.HTTP_OK, response4.code());
+    assertEquals("C-OK", response4.message());
+
+    server.takeRequest(); // regular get
+    return server.takeRequest(); // conditional get
+  }
+
+  @Test public void immutableIsCached() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control", "immutable")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    HttpUrl url = server.url("/");
+    assertEquals("A", get(url).body().string());
+    assertEquals("A", get(url).body().string());
+  }
+
+  @Test public void immutableIsCachedAfterMultipleCalls() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control", "immutable")
+        .setBody("B"));
+    server.enqueue(new MockResponse()
+        .setBody("C"));
+
+    HttpUrl url = server.url("/");
+    assertEquals("A", get(url).body().string());
+    assertEquals("B", get(url).body().string());
+    assertEquals("B", get(url).body().string());
+  }
+
+  private void assertFullyCached(MockResponse response) throws Exception {
+    server.enqueue(response.setBody("A"));
+    server.enqueue(response.setBody("B"));
+
+    HttpUrl url = server.url("/");
+    assertEquals("A", get(url).body().string());
+    assertEquals("A", get(url).body().string());
+  }
+
+  /**
+   * Shortens the body of {@code response} but not the corresponding headers. Only useful to test
+   * how clients respond to the premature conclusion of the HTTP body.
+   */
+  private MockResponse truncateViolently(MockResponse response, int numBytesToKeep) {
+    response.setSocketPolicy(DISCONNECT_AT_END);
+    Headers headers = response.getHeaders();
+    Buffer truncatedBody = new Buffer();
+    truncatedBody.write(response.getBody(), numBytesToKeep);
+    response.setBody(truncatedBody);
+    response.setHeaders(headers);
+    return response;
+  }
+
+  enum TransferKind {
+    CHUNKED() {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize)
+          throws IOException {
+        response.setChunkedBody(content, chunkSize);
+      }
+    },
+    FIXED_LENGTH() {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
+        response.setBody(content);
+      }
+    },
+    END_OF_STREAM() {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
+        response.setBody(content);
+        response.setSocketPolicy(DISCONNECT_AT_END);
+        response.removeHeader("Content-Length");
+      }
+    };
+
+    abstract void setBody(MockResponse response, Buffer content, int chunkSize) throws IOException;
+
+    void setBody(MockResponse response, String content, int chunkSize) throws IOException {
+      setBody(response, new Buffer().writeUtf8(content), chunkSize);
+    }
+  }
+
+  /** Returns a gzipped copy of {@code bytes}. */
+  public Buffer gzip(String data) throws IOException {
+    Buffer result = new Buffer();
+    BufferedSink sink = Okio.buffer(new GzipSink(result));
+    sink.writeUtf8(data);
+    sink.close();
+    return result;
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/CallTest.java b/okhttp-tests/src/test/java/okhttp3/CallTest.java
new file mode 100644
index 0000000000..31f5062305
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/CallTest.java
@@ -0,0 +1,3155 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InterruptedIOException;
+import java.net.CookieManager;
+import java.net.HttpCookie;
+import java.net.HttpURLConnection;
+import java.net.InetAddress;
+import java.net.ProtocolException;
+import java.net.Proxy;
+import java.net.SocketTimeoutException;
+import java.net.UnknownHostException;
+import java.net.UnknownServiceException;
+import java.security.cert.Certificate;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.SynchronousQueue;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import java.util.logging.SimpleFormatter;
+import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLProtocolException;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import okhttp3.internal.DoubleInetAddressDns;
+import okhttp3.internal.RecordingOkAuthenticator;
+import okhttp3.internal.SingleInetAddressDns;
+import okhttp3.internal.Util;
+import okhttp3.internal.Version;
+import okhttp3.internal.http.RecordingProxySelector;
+import okhttp3.internal.io.InMemoryFileSystem;
+import okhttp3.internal.tls.HeldCertificate;
+import okhttp3.internal.tls.SslClient;
+import okhttp3.mockwebserver.Dispatcher;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.mockwebserver.SocketPolicy;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.GzipSink;
+import okio.Okio;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import org.junit.rules.Timeout;
+
+import static java.net.CookiePolicy.ACCEPT_ORIGINAL_SERVER;
+import static okhttp3.TestUtil.awaitGarbageCollection;
+import static okhttp3.TestUtil.defaultClient;
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class CallTest {
+  @Rule public final TestRule timeout = new Timeout(30_000, TimeUnit.MILLISECONDS);
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final MockWebServer server2 = new MockWebServer();
+  @Rule public final InMemoryFileSystem fileSystem = new InMemoryFileSystem();
+
+  private SslClient sslClient = SslClient.localhost();
+  private OkHttpClient client = defaultClient();
+  private RecordingCallback callback = new RecordingCallback();
+  private TestLogHandler logHandler = new TestLogHandler();
+  private Cache cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
+  private NullServer nullServer = new NullServer();
+  private Logger logger = Logger.getLogger(OkHttpClient.class.getName());
+
+  @Before public void setUp() throws Exception {
+    logger.addHandler(logHandler);
+  }
+
+  @After public void tearDown() throws Exception {
+    cache.delete();
+    nullServer.shutdown();
+    logger.removeHandler(logHandler);
+  }
+
+  @Test public void get() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .clearHeaders()
+        .addHeader("content-type: text/plain")
+        .addHeader("content-length", "3"));
+
+    long sentAt = System.currentTimeMillis();
+    RecordedResponse recordedResponse = executeSynchronously("/", "User-Agent", "SyncApiTest");
+    long receivedAt = System.currentTimeMillis();
+
+    recordedResponse.assertCode(200)
+        .assertSuccessful()
+        .assertHeaders(new Headers.Builder()
+            .add("content-type", "text/plain")
+            .add("content-length", "3")
+            .build())
+        .assertBody("abc")
+        .assertSentRequestAtMillis(sentAt, receivedAt)
+        .assertReceivedResponseAtMillis(sentAt, receivedAt);
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("GET", recordedRequest.getMethod());
+    assertEquals("SyncApiTest", recordedRequest.getHeader("User-Agent"));
+    assertEquals(0, recordedRequest.getBody().size());
+    assertNull(recordedRequest.getHeader("Content-Length"));
+  }
+
+  @Test public void buildRequestUsingHttpUrl() throws Exception {
+    server.enqueue(new MockResponse());
+    executeSynchronously("/").assertSuccessful();
+  }
+
+  @Test public void invalidScheme() throws Exception {
+    Request.Builder requestBuilder = new Request.Builder();
+    try {
+      requestBuilder.url("ftp://hostname/path");
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals(expected.getMessage(), "unexpected url: ftp://hostname/path");
+    }
+  }
+
+  @Test public void invalidPort() throws Exception {
+    Request.Builder requestBuilder = new Request.Builder();
+    try {
+      requestBuilder.url("http://localhost:65536/");
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals(expected.getMessage(), "unexpected url: http://localhost:65536/");
+    }
+  }
+
+  @Test public void getReturns500() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(500));
+    executeSynchronously("/")
+        .assertCode(500)
+        .assertNotSuccessful();
+  }
+
+  @Test public void get_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    get();
+  }
+
+  @Test public void get_HTTPS() throws Exception {
+    enableTls();
+    get();
+  }
+
+  @Test public void repeatedHeaderNames() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("B", "123")
+        .addHeader("B", "234"));
+
+    executeSynchronously("/", "A", "345", "A", "456")
+        .assertCode(200)
+        .assertHeader("B", "123", "234");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals(Arrays.asList("345", "456"), recordedRequest.getHeaders().values("A"));
+  }
+
+  @Test public void repeatedHeaderNames_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    repeatedHeaderNames();
+  }
+
+  @Test public void getWithRequestBody() throws Exception {
+    server.enqueue(new MockResponse());
+
+    try {
+      new Request.Builder().method("GET", RequestBody.create(MediaType.parse("text/plain"), "abc"));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void head() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Content-Type: text/plain"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .head()
+        .header("User-Agent", "SyncApiTest")
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertHeader("Content-Type", "text/plain");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("HEAD", recordedRequest.getMethod());
+    assertEquals("SyncApiTest", recordedRequest.getHeader("User-Agent"));
+    assertEquals(0, recordedRequest.getBody().size());
+    assertNull(recordedRequest.getHeader("Content-Length"));
+  }
+
+  @Test public void headResponseContentLengthIsIgnored() throws Exception {
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .addHeader("Content-Length", "100"));
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    Request headRequest = new Request.Builder()
+        .url(server.url("/"))
+        .head()
+        .build();
+    Response response = client.newCall(headRequest).execute();
+    assertEquals(200, response.code());
+    assertArrayEquals(new byte[0], response.body().bytes());
+
+    Request getRequest = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    executeSynchronously(getRequest)
+        .assertCode(200)
+        .assertBody("abc");
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void headResponseContentEncodingIsIgnored() throws Exception {
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .addHeader("Content-Encoding", "chunked"));
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    Request headRequest = new Request.Builder()
+        .url(server.url("/"))
+        .head()
+        .build();
+    executeSynchronously(headRequest)
+        .assertCode(200)
+        .assertHeader("Content-Encoding", "chunked")
+        .assertBody("");
+
+    Request getRequest = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    executeSynchronously(getRequest)
+        .assertCode(200)
+        .assertBody("abc");
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void head_HTTPS() throws Exception {
+    enableTls();
+    head();
+  }
+
+  @Test public void head_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    head();
+  }
+
+  @Test public void post() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertBody("abc");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("POST", recordedRequest.getMethod());
+    assertEquals("def", recordedRequest.getBody().readUtf8());
+    assertEquals("3", recordedRequest.getHeader("Content-Length"));
+    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
+  }
+
+  @Test public void post_HTTPS() throws Exception {
+    enableTls();
+    post();
+  }
+
+  @Test public void post_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    post();
+  }
+
+  @Test public void postZeroLength() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .method("POST", RequestBody.create(null, new byte[0]))
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertBody("abc");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("POST", recordedRequest.getMethod());
+    assertEquals(0, recordedRequest.getBody().size());
+    assertEquals("0", recordedRequest.getHeader("Content-Length"));
+    assertEquals(null, recordedRequest.getHeader("Content-Type"));
+  }
+
+  @Test public void postZerolength_HTTPS() throws Exception {
+    enableTls();
+    postZeroLength();
+  }
+
+  @Test public void postZerolength_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    postZeroLength();
+  }
+
+  @Test public void postBodyRetransmittedAfterAuthorizationFail() throws Exception {
+    postBodyRetransmittedAfterAuthorizationFail("abc");
+  }
+
+  @Test public void postBodyRetransmittedAfterAuthorizationFail_HTTPS() throws Exception {
+    enableTls();
+    postBodyRetransmittedAfterAuthorizationFail("abc");
+  }
+
+  @Test public void postBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    postBodyRetransmittedAfterAuthorizationFail("abc");
+  }
+
+  /** Don't explode when resending an empty post. https://github.com/square/okhttp/issues/1131 */
+  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail() throws Exception {
+    postBodyRetransmittedAfterAuthorizationFail("");
+  }
+
+  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_HTTPS() throws Exception {
+    enableTls();
+    postBodyRetransmittedAfterAuthorizationFail("");
+  }
+
+  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    postBodyRetransmittedAfterAuthorizationFail("");
+  }
+
+  private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(401));
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .method("POST", RequestBody.create(null, body))
+        .build();
+
+    String credential = Credentials.basic("jesse", "secret");
+    client = client.newBuilder()
+        .authenticator(new RecordingOkAuthenticator(credential))
+        .build();
+
+    Response response = client.newCall(request).execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    RecordedRequest recordedRequest1 = server.takeRequest();
+    assertEquals("POST", recordedRequest1.getMethod());
+    assertEquals(body, recordedRequest1.getBody().readUtf8());
+    assertNull(recordedRequest1.getHeader("Authorization"));
+
+    RecordedRequest recordedRequest2 = server.takeRequest();
+    assertEquals("POST", recordedRequest2.getMethod());
+    assertEquals(body, recordedRequest2.getBody().readUtf8());
+    assertEquals(credential, recordedRequest2.getHeader("Authorization"));
+  }
+
+  @Test public void attemptAuthorization20Times() throws Exception {
+    for (int i = 0; i < 20; i++) {
+      server.enqueue(new MockResponse().setResponseCode(401));
+    }
+    server.enqueue(new MockResponse().setBody("Success!"));
+
+    String credential = Credentials.basic("jesse", "secret");
+    client = client.newBuilder()
+        .authenticator(new RecordingOkAuthenticator(credential))
+        .build();
+
+    executeSynchronously("/")
+        .assertCode(200)
+        .assertBody("Success!");
+  }
+
+  @Test public void doesNotAttemptAuthorization21Times() throws Exception {
+    for (int i = 0; i < 21; i++) {
+      server.enqueue(new MockResponse().setResponseCode(401));
+    }
+
+    String credential = Credentials.basic("jesse", "secret");
+    client = client.newBuilder()
+        .authenticator(new RecordingOkAuthenticator(credential))
+        .build();
+
+    try {
+      client.newCall(new Request.Builder().url(server.url("/0")).build()).execute();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("Too many follow-up requests: 21", expected.getMessage());
+    }
+  }
+
+  @Test public void delete() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .delete()
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertBody("abc");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("DELETE", recordedRequest.getMethod());
+    assertEquals(0, recordedRequest.getBody().size());
+    assertEquals("0", recordedRequest.getHeader("Content-Length"));
+    assertEquals(null, recordedRequest.getHeader("Content-Type"));
+  }
+
+  @Test public void delete_HTTPS() throws Exception {
+    enableTls();
+    delete();
+  }
+
+  @Test public void delete_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    delete();
+  }
+
+  @Test public void deleteWithRequestBody() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .method("DELETE", RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertBody("abc");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("DELETE", recordedRequest.getMethod());
+    assertEquals("def", recordedRequest.getBody().readUtf8());
+  }
+
+  @Test public void put() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .put(RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertBody("abc");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("PUT", recordedRequest.getMethod());
+    assertEquals("def", recordedRequest.getBody().readUtf8());
+    assertEquals("3", recordedRequest.getHeader("Content-Length"));
+    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
+  }
+
+  @Test public void put_HTTPS() throws Exception {
+    enableTls();
+    put();
+  }
+
+  @Test public void put_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    put();
+  }
+
+  @Test public void patch() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .patch(RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertBody("abc");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("PATCH", recordedRequest.getMethod());
+    assertEquals("def", recordedRequest.getBody().readUtf8());
+    assertEquals("3", recordedRequest.getHeader("Content-Length"));
+    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
+  }
+
+  @Test public void patch_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    patch();
+  }
+
+  @Test public void patch_HTTPS() throws Exception {
+    enableTls();
+    patch();
+  }
+
+  @Test public void unspecifiedRequestBodyContentTypeDoesNotGetDefault() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .method("POST", RequestBody.create(null, "abc"))
+        .build();
+
+    executeSynchronously(request).assertCode(200);
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals(null, recordedRequest.getHeader("Content-Type"));
+    assertEquals("3", recordedRequest.getHeader("Content-Length"));
+    assertEquals("abc", recordedRequest.getBody().readUtf8());
+  }
+
+  @Test public void illegalToExecuteTwice() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .addHeader("Content-Type: text/plain"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .header("User-Agent", "SyncApiTest")
+        .build();
+
+    Call call = client.newCall(request);
+    Response response = call.execute();
+    response.body().close();
+
+    try {
+      call.execute();
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals("Already Executed", e.getMessage());
+    }
+
+    try {
+      call.enqueue(callback);
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals("Already Executed", e.getMessage());
+    }
+
+    assertEquals("SyncApiTest", server.takeRequest().getHeader("User-Agent"));
+  }
+
+  @Test public void illegalToExecuteTwice_Async() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .addHeader("Content-Type: text/plain"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .header("User-Agent", "SyncApiTest")
+        .build();
+
+    Call call = client.newCall(request);
+    call.enqueue(callback);
+
+    try {
+      call.execute();
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals("Already Executed", e.getMessage());
+    }
+
+    try {
+      call.enqueue(callback);
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals("Already Executed", e.getMessage());
+    }
+
+    assertEquals("SyncApiTest", server.takeRequest().getHeader("User-Agent"));
+  }
+
+  @Test public void legalToExecuteTwiceCloning() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Call call = client.newCall(request);
+    Response response1 = call.execute();
+
+    Call cloned = call.clone();
+    Response response2 = cloned.execute();
+
+    assertEquals(response1.body().string(), "abc");
+    assertEquals(response2.body().string(), "def");
+  }
+
+  @Test public void legalToExecuteTwiceCloning_Async() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Call call = client.newCall(request);
+    call.enqueue(callback);
+
+    Call cloned = call.clone();
+    cloned.enqueue(callback);
+
+    RecordedResponse firstResponse = callback.await(request.url()).assertSuccessful();
+    RecordedResponse secondResponse = callback.await(request.url()).assertSuccessful();
+
+    Set<String> bodies = new LinkedHashSet<>();
+    bodies.add(firstResponse.getBody());
+    bodies.add(secondResponse.getBody());
+
+    assertTrue(bodies.contains("abc"));
+    assertTrue(bodies.contains("def"));
+  }
+
+  @Test public void get_Async() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .addHeader("Content-Type: text/plain"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .header("User-Agent", "AsyncApiTest")
+        .build();
+    client.newCall(request).enqueue(callback);
+
+    callback.await(request.url())
+        .assertCode(200)
+        .assertHeader("Content-Type", "text/plain")
+        .assertBody("abc");
+
+    assertEquals("AsyncApiTest", server.takeRequest().getHeader("User-Agent"));
+  }
+
+  @Test public void exceptionThrownByOnResponseIsRedactedAndLogged() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.url("/secret"))
+        .build();
+
+    client.newCall(request).enqueue(new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+        fail();
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        throw new IOException("a");
+      }
+    });
+
+    assertEquals("INFO: Callback failure for call to " + server.url("/") + "...",
+        logHandler.take());
+  }
+
+  @Test public void connectionPooling() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+    server.enqueue(new MockResponse().setBody("ghi"));
+
+    executeSynchronously("/a").assertBody("abc");
+    executeSynchronously("/b").assertBody("def");
+    executeSynchronously("/c").assertBody("ghi");
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertEquals(2, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void connectionPooling_Async() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+    server.enqueue(new MockResponse().setBody("ghi"));
+
+    client.newCall(new Request.Builder().url(server.url("/a")).build()).enqueue(callback);
+    callback.await(server.url("/a")).assertBody("abc");
+
+    client.newCall(new Request.Builder().url(server.url("/b")).build()).enqueue(callback);
+    callback.await(server.url("/b")).assertBody("def");
+
+    client.newCall(new Request.Builder().url(server.url("/c")).build()).enqueue(callback);
+    callback.await(server.url("/c")).assertBody("ghi");
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertEquals(2, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void connectionReuseWhenResponseBodyConsumed_Async() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+
+    Request request = new Request.Builder().url(server.url("/a")).build();
+    client.newCall(request).enqueue(new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+        throw new AssertionError();
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        InputStream bytes = response.body().byteStream();
+        assertEquals('a', bytes.read());
+        assertEquals('b', bytes.read());
+        assertEquals('c', bytes.read());
+
+        // This request will share a connection with 'A' cause it's all done.
+        client.newCall(new Request.Builder().url(server.url("/b")).build()).enqueue(callback);
+      }
+    });
+
+    callback.await(server.url("/b")).assertCode(200).assertBody("def");
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reuse!
+  }
+
+  @Test public void timeoutsUpdatedOnReusedConnections() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def").throttleBody(1, 750, TimeUnit.MILLISECONDS));
+
+    // First request: time out after 1000ms.
+    client = client.newBuilder()
+        .readTimeout(1000, TimeUnit.MILLISECONDS)
+        .build();
+    executeSynchronously("/a").assertBody("abc");
+
+    // Second request: time out after 250ms.
+    client = client.newBuilder()
+        .readTimeout(250, TimeUnit.MILLISECONDS)
+        .build();
+    Request request = new Request.Builder().url(server.url("/b")).build();
+    Response response = client.newCall(request).execute();
+    BufferedSource bodySource = response.body().source();
+    assertEquals('d', bodySource.readByte());
+
+    // The second byte of this request will be delayed by 750ms so we should time out after 250ms.
+    long startNanos = System.nanoTime();
+    try {
+      bodySource.readByte();
+      fail();
+    } catch (IOException expected) {
+      // Timed out as expected.
+      long elapsedNanos = System.nanoTime() - startNanos;
+      long elapsedMillis = TimeUnit.NANOSECONDS.toMillis(elapsedNanos);
+      assertTrue(Util.format("Timed out: %sms", elapsedMillis), elapsedMillis < 500);
+    } finally {
+      bodySource.close();
+    }
+  }
+
+  /** https://github.com/square/okhttp/issues/442 */
+  @Test public void tlsTimeoutsNotRetried() throws Exception {
+    enableTls();
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.NO_RESPONSE));
+    server.enqueue(new MockResponse()
+        .setBody("unreachable!"));
+
+    client = client.newBuilder()
+        .readTimeout(100, TimeUnit.MILLISECONDS)
+        .build();
+
+    Request request = new Request.Builder().url(server.url("/")).build();
+    try {
+      // If this succeeds, too many requests were made.
+      client.newCall(request).execute();
+      fail();
+    } catch (InterruptedIOException expected) {
+    }
+  }
+
+  /**
+   * Make a request with two routes. The first route will time out because it's connecting to a
+   * special address that never connects. The automatic retry will succeed.
+   */
+  @Test public void connectTimeoutsAttemptsAlternateRoute() throws Exception {
+    RecordingProxySelector proxySelector = new RecordingProxySelector();
+    proxySelector.proxies.add(new Proxy(Proxy.Type.HTTP, TestUtil.UNREACHABLE_ADDRESS));
+    proxySelector.proxies.add(server.toProxyAddress());
+
+    server.enqueue(new MockResponse()
+        .setBody("success!"));
+
+    client = client.newBuilder()
+        .proxySelector(proxySelector)
+        .readTimeout(100, TimeUnit.MILLISECONDS)
+        .connectTimeout(100, TimeUnit.MILLISECONDS)
+        .build();
+
+    Request request = new Request.Builder().url("http://android.com/").build();
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertBody("success!");
+  }
+
+  /**
+   * Make a request with two routes. The first route will fail because the null server connects but
+   * never responds. The manual retry will succeed.
+   */
+  @Test public void readTimeoutFails() throws Exception {
+    nullServer.start();
+
+    RecordingProxySelector proxySelector = new RecordingProxySelector();
+    proxySelector.proxies.add(new Proxy(Proxy.Type.HTTP, nullServer.address()));
+    proxySelector.proxies.add(server.toProxyAddress());
+
+    server.enqueue(new MockResponse()
+        .setBody("success!"));
+
+    client = client.newBuilder()
+        .proxySelector(proxySelector)
+        .readTimeout(100, TimeUnit.MILLISECONDS)
+        .build();
+
+    Request request = new Request.Builder().url("http://android.com/").build();
+    executeSynchronously(request)
+        .assertFailure(SocketTimeoutException.class);
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertBody("success!");
+  }
+
+  /** https://github.com/square/okhttp/issues/1801 */
+  @Test public void asyncCallEngineInitialized() throws Exception {
+    OkHttpClient c = defaultClient().newBuilder()
+        .addInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            throw new IOException();
+          }
+        })
+        .build();
+    Request request = new Request.Builder().url(server.url("/")).build();
+    c.newCall(request).enqueue(callback);
+    RecordedResponse response = callback.await(request.url());
+    assertEquals(request, response.request);
+  }
+
+  @Test public void reusedSinksGetIndependentTimeoutInstances() throws Exception {
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+
+    // Call 1: set a deadline on the request body.
+    RequestBody requestBody1 = new RequestBody() {
+      @Override public MediaType contentType() {
+        return MediaType.parse("text/plain");
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.writeUtf8("abc");
+        sink.timeout().deadline(5, TimeUnit.SECONDS);
+      }
+    };
+    Request request1 = new Request.Builder()
+        .url(server.url("/"))
+        .method("POST", requestBody1)
+        .build();
+    Response response1 = client.newCall(request1).execute();
+    assertEquals(200, response1.code());
+
+    // Call 2: check for the absence of a deadline on the request body.
+    RequestBody requestBody2 = new RequestBody() {
+      @Override public MediaType contentType() {
+        return MediaType.parse("text/plain");
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        assertFalse(sink.timeout().hasDeadline());
+        sink.writeUtf8("def");
+      }
+    };
+    Request request2 = new Request.Builder()
+        .url(server.url("/"))
+        .method("POST", requestBody2)
+        .build();
+    Response response2 = client.newCall(request2).execute();
+    assertEquals(200, response2.code());
+
+    // Use sequence numbers to confirm the connection was pooled.
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void reusedSourcesGetIndependentTimeoutInstances() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+
+    // Call 1: set a deadline on the response body.
+    Request request1 = new Request.Builder().url(server.url("/")).build();
+    Response response1 = client.newCall(request1).execute();
+    BufferedSource body1 = response1.body().source();
+    assertEquals("abc", body1.readUtf8());
+    body1.timeout().deadline(5, TimeUnit.SECONDS);
+
+    // Call 2: check for the absence of a deadline on the request body.
+    Request request2 = new Request.Builder().url(server.url("/")).build();
+    Response response2 = client.newCall(request2).execute();
+    BufferedSource body2 = response2.body().source();
+    assertEquals("def", body2.readUtf8());
+    assertFalse(body2.timeout().hasDeadline());
+
+    // Use sequence numbers to confirm the connection was pooled.
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void tls() throws Exception {
+    enableTls();
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .addHeader("Content-Type: text/plain"));
+
+    executeSynchronously("/").assertHandshake();
+  }
+
+  @Test public void tls_Async() throws Exception {
+    enableTls();
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .addHeader("Content-Type: text/plain"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    client.newCall(request).enqueue(callback);
+
+    callback.await(request.url()).assertHandshake();
+  }
+
+  @Test public void recoverWhenRetryOnConnectionFailureIsTrue() throws Exception {
+    server.enqueue(new MockResponse().setBody("seed connection pool"));
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
+    server.enqueue(new MockResponse().setBody("retry success"));
+
+    client = client.newBuilder()
+        .dns(new DoubleInetAddressDns())
+        .build();
+    assertTrue(client.retryOnConnectionFailure());
+
+    executeSynchronously("/").assertBody("seed connection pool");
+    executeSynchronously("/").assertBody("retry success");
+  }
+
+  @Test public void recoverWhenRetryOnConnectionFailureIsTrue_HTTP2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    recoverWhenRetryOnConnectionFailureIsTrue();
+  }
+
+  @Test public void noRecoverWhenRetryOnConnectionFailureIsFalse() throws Exception {
+    server.enqueue(new MockResponse().setBody("seed connection pool"));
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
+    server.enqueue(new MockResponse().setBody("unreachable!"));
+
+    client = client.newBuilder()
+        .dns(new DoubleInetAddressDns())
+        .retryOnConnectionFailure(false)
+        .build();
+
+    executeSynchronously("/").assertBody("seed connection pool");
+
+    // If this succeeds, too many requests were made.
+    executeSynchronously("/")
+        .assertFailure(IOException.class)
+        .assertFailureMatches("stream was reset: CANCEL",
+            "unexpected end of stream on Connection.*"
+                + server.getHostName() + ":" + server.getPort() + ".*");
+  }
+
+  @Test public void recoverWhenRetryOnConnectionFailureIsFalse_HTTP2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    noRecoverWhenRetryOnConnectionFailureIsFalse();
+  }
+
+  @Test public void tlsHandshakeFailure_noFallbackByDefault() throws Exception {
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse().setBody("response that will never be received"));
+    RecordedResponse response = executeSynchronously("/");
+    response.assertFailure(
+            SSLProtocolException.class, // RI response to the FAIL_HANDSHAKE
+            SSLHandshakeException.class // Android's response to the FAIL_HANDSHAKE
+    );
+    assertFalse(client.connectionSpecs().contains(ConnectionSpec.COMPATIBLE_TLS));
+  }
+
+  @Test public void recoverFromTlsHandshakeFailure() throws Exception {
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    client = client.newBuilder()
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .dns(new SingleInetAddressDns())
+        // opt-in to fallback to COMPATIBLE_TLS
+        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
+        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
+        .build();
+
+    executeSynchronously("/").assertBody("abc");
+  }
+
+  @Test public void recoverFromTlsHandshakeFailure_tlsFallbackScsvEnabled() throws Exception {
+    final String tlsFallbackScsv = "TLS_FALLBACK_SCSV";
+    List<String> supportedCiphers =
+        Arrays.asList(sslClient.socketFactory.getSupportedCipherSuites());
+    if (!supportedCiphers.contains(tlsFallbackScsv)) {
+      // This only works if the client socket supports TLS_FALLBACK_SCSV.
+      return;
+    }
+
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+
+    RecordingSSLSocketFactory clientSocketFactory =
+        new RecordingSSLSocketFactory(sslClient.socketFactory);
+    client = client.newBuilder()
+        .sslSocketFactory(clientSocketFactory, sslClient.trustManager)
+        // opt-in to fallback to COMPATIBLE_TLS
+        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .dns(new SingleInetAddressDns())
+        .build();
+
+    Request request = new Request.Builder().url(server.url("/")).build();
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (SSLHandshakeException expected) {
+    }
+
+    List<SSLSocket> clientSockets = clientSocketFactory.getSocketsCreated();
+    SSLSocket firstSocket = clientSockets.get(0);
+    assertFalse(Arrays.asList(firstSocket.getEnabledCipherSuites()).contains(tlsFallbackScsv));
+    SSLSocket secondSocket = clientSockets.get(1);
+    assertTrue(Arrays.asList(secondSocket.getEnabledCipherSuites()).contains(tlsFallbackScsv));
+  }
+
+  @Test public void recoverFromTlsHandshakeFailure_Async() throws Exception {
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    client = client.newBuilder()
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
+        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    client.newCall(request).enqueue(callback);
+
+    callback.await(request.url()).assertBody("abc");
+  }
+
+  @Test public void noRecoveryFromTlsHandshakeFailureWhenTlsFallbackIsDisabled() throws Exception {
+    client = client.newBuilder()
+        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT))
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .dns(new SingleInetAddressDns())
+        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
+        .build();
+
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+
+    Request request = new Request.Builder().url(server.url("/")).build();
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (SSLProtocolException expected) {
+      // RI response to the FAIL_HANDSHAKE
+    } catch (SSLHandshakeException expected) {
+      // Android's response to the FAIL_HANDSHAKE
+    }
+  }
+
+  @Test public void cleartextCallsFailWhenCleartextIsDisabled() throws Exception {
+    // Configure the client with only TLS configurations. No cleartext!
+    client = client.newBuilder()
+        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
+        .build();
+
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder().url(server.url("/")).build();
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (UnknownServiceException expected) {
+      assertEquals("CLEARTEXT communication not enabled for client", expected.getMessage());
+    }
+  }
+
+  @Test public void setFollowSslRedirectsFalse() throws Exception {
+    enableTls();
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location: http://square.com"));
+
+    client = client.newBuilder()
+        .followSslRedirects(false)
+        .build();
+
+    Request request = new Request.Builder().url(server.url("/")).build();
+    Response response = client.newCall(request).execute();
+    assertEquals(301, response.code());
+    response.body().close();
+  }
+
+  @Test public void matchingPinnedCertificate() throws Exception {
+    enableTls();
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+
+    // Make a first request without certificate pinning. Use it to collect certificates to pin.
+    Request request1 = new Request.Builder().url(server.url("/")).build();
+    Response response1 = client.newCall(request1).execute();
+    CertificatePinner.Builder certificatePinnerBuilder = new CertificatePinner.Builder();
+    for (Certificate certificate : response1.handshake().peerCertificates()) {
+      certificatePinnerBuilder.add(server.getHostName(), CertificatePinner.pin(certificate));
+    }
+    response1.body().close();
+
+    // Make another request with certificate pinning. It should complete normally.
+    client = client.newBuilder()
+        .certificatePinner(certificatePinnerBuilder.build())
+        .build();
+    Request request2 = new Request.Builder().url(server.url("/")).build();
+    Response response2 = client.newCall(request2).execute();
+    assertNotSame(response2.handshake(), response1.handshake());
+    response2.body().close();
+  }
+
+  @Test public void unmatchingPinnedCertificate() throws Exception {
+    enableTls();
+    server.enqueue(new MockResponse());
+
+    // Pin publicobject.com's cert.
+    client = client.newBuilder()
+        .certificatePinner(new CertificatePinner.Builder()
+            .add(server.getHostName(), "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=")
+            .build())
+        .build();
+
+    // When we pin the wrong certificate, connectivity fails.
+    Request request = new Request.Builder().url(server.url("/")).build();
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (SSLPeerUnverifiedException expected) {
+      assertTrue(expected.getMessage().startsWith("Certificate pinning failure!"));
+    }
+  }
+
+  @Test public void post_Async() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .build();
+    client.newCall(request).enqueue(callback);
+
+    callback.await(request.url())
+        .assertCode(200)
+        .assertBody("abc");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("def", recordedRequest.getBody().readUtf8());
+    assertEquals("3", recordedRequest.getHeader("Content-Length"));
+    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
+  }
+
+  @Test public void postBodyRetransmittedOnFailureRecovery() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
+    server.enqueue(new MockResponse().setBody("def"));
+
+    // Seed the connection pool so we have something that can fail.
+    Request request1 = new Request.Builder().url(server.url("/")).build();
+    Response response1 = client.newCall(request1).execute();
+    assertEquals("abc", response1.body().string());
+
+    Request request2 = new Request.Builder()
+        .url(server.url("/"))
+        .post(RequestBody.create(MediaType.parse("text/plain"), "body!"))
+        .build();
+    Response response2 = client.newCall(request2).execute();
+    assertEquals("def", response2.body().string());
+
+    RecordedRequest get = server.takeRequest();
+    assertEquals(0, get.getSequenceNumber());
+
+    RecordedRequest post1 = server.takeRequest();
+    assertEquals("body!", post1.getBody().readUtf8());
+    assertEquals(1, post1.getSequenceNumber());
+
+    RecordedRequest post2 = server.takeRequest();
+    assertEquals("body!", post2.getBody().readUtf8());
+    assertEquals(0, post2.getSequenceNumber());
+  }
+
+  @Test public void postBodyRetransmittedOnFailureRecovery_HTTP2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    postBodyRetransmittedOnFailureRecovery();
+  }
+
+  @Test public void cacheHit() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("ETag: v1")
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Charset")
+        .setBody("A"));
+
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    // Store a response in the cache.
+    HttpUrl url = server.url("/");
+    long request1SentAt = System.currentTimeMillis();
+    executeSynchronously("/", "Accept-Language", "fr-CA", "Accept-Charset", "UTF-8")
+        .assertCode(200)
+        .assertBody("A");
+    long request1ReceivedAt = System.currentTimeMillis();
+    assertNull(server.takeRequest().getHeader("If-None-Match"));
+
+    // Hit that stored response. It's different, but Vary says it doesn't matter.
+    Thread.sleep(10); // Make sure the timestamps are unique.
+    RecordedResponse cacheHit = executeSynchronously(
+        "/", "Accept-Language", "en-US", "Accept-Charset", "UTF-8");
+
+    // Check the merged response. The request is the application's original request.
+    cacheHit.assertCode(200)
+        .assertBody("A")
+        .assertHeaders(new Headers.Builder()
+            .add("ETag", "v1")
+            .add("Cache-Control", "max-age=60")
+            .add("Vary", "Accept-Charset")
+            .add("Content-Length", "1")
+            .build())
+        .assertRequestUrl(url)
+        .assertRequestHeader("Accept-Language", "en-US")
+        .assertRequestHeader("Accept-Charset", "UTF-8")
+        .assertSentRequestAtMillis(request1SentAt, request1ReceivedAt)
+        .assertReceivedResponseAtMillis(request1SentAt, request1ReceivedAt);
+
+    // Check the cached response. Its request contains only the saved Vary headers.
+    cacheHit.cacheResponse()
+        .assertCode(200)
+        .assertHeaders(new Headers.Builder()
+            .add("ETag", "v1")
+            .add("Cache-Control", "max-age=60")
+            .add("Vary", "Accept-Charset")
+            .add("Content-Length", "1")
+            .build())
+        .assertRequestMethod("GET")
+        .assertRequestUrl(url)
+        .assertRequestHeader("Accept-Language")
+        .assertRequestHeader("Accept-Charset", "UTF-8")
+        .assertSentRequestAtMillis(request1SentAt, request1ReceivedAt)
+        .assertReceivedResponseAtMillis(request1SentAt, request1ReceivedAt);
+
+    cacheHit.assertNoNetworkResponse();
+  }
+
+  @Test public void conditionalCacheHit() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("ETag: v1")
+        .addHeader("Vary: Accept-Charset")
+        .addHeader("Donut: a")
+        .setBody("A"));
+    server.enqueue(new MockResponse().clearHeaders()
+        .addHeader("Donut: b")
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    // Store a response in the cache.
+    long request1SentAt = System.currentTimeMillis();
+    executeSynchronously("/", "Accept-Language", "fr-CA", "Accept-Charset", "UTF-8")
+        .assertCode(200)
+        .assertHeader("Donut", "a")
+        .assertBody("A");
+    long request1ReceivedAt = System.currentTimeMillis();
+    assertNull(server.takeRequest().getHeader("If-None-Match"));
+
+    // Hit that stored response. It's different, but Vary says it doesn't matter.
+    Thread.sleep(10); // Make sure the timestamps are unique.
+    long request2SentAt = System.currentTimeMillis();
+    RecordedResponse cacheHit = executeSynchronously(
+        "/", "Accept-Language", "en-US", "Accept-Charset", "UTF-8");
+    long request2ReceivedAt = System.currentTimeMillis();
+    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
+
+    // Check the merged response. The request is the application's original request.
+    cacheHit.assertCode(200)
+        .assertBody("A")
+        .assertHeader("Donut", "b")
+        .assertRequestUrl(server.url("/"))
+        .assertRequestHeader("Accept-Language", "en-US")
+        .assertRequestHeader("Accept-Charset", "UTF-8")
+        .assertRequestHeader("If-None-Match") // No If-None-Match on the user's request.
+        .assertSentRequestAtMillis(request2SentAt, request2ReceivedAt)
+        .assertReceivedResponseAtMillis(request2SentAt, request2ReceivedAt);
+
+    // Check the cached response. Its request contains only the saved Vary headers.
+    cacheHit.cacheResponse()
+        .assertCode(200)
+        .assertHeader("Donut", "a")
+        .assertHeader("ETag", "v1")
+        .assertRequestUrl(server.url("/"))
+        .assertRequestHeader("Accept-Language") // No Vary on Accept-Language.
+        .assertRequestHeader("Accept-Charset", "UTF-8") // Because of Vary on Accept-Charset.
+        .assertRequestHeader("If-None-Match") // This wasn't present in the original request.
+        .assertSentRequestAtMillis(request1SentAt, request1ReceivedAt)
+        .assertReceivedResponseAtMillis(request1SentAt, request1ReceivedAt);
+
+    // Check the network response. It has the caller's request, plus some caching headers.
+    cacheHit.networkResponse()
+        .assertCode(304)
+        .assertHeader("Donut", "b")
+        .assertRequestHeader("Accept-Language", "en-US")
+        .assertRequestHeader("Accept-Charset", "UTF-8")
+        .assertRequestHeader("If-None-Match", "v1") // If-None-Match in the validation request.
+        .assertSentRequestAtMillis(request2SentAt, request2ReceivedAt)
+        .assertReceivedResponseAtMillis(request2SentAt, request2ReceivedAt);
+  }
+
+  @Test public void conditionalCacheHit_Async() throws Exception {
+    server.enqueue(new MockResponse().setBody("A").addHeader("ETag: v1"));
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    Request request1 = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    client.newCall(request1).enqueue(callback);
+    callback.await(request1.url()).assertCode(200).assertBody("A");
+    assertNull(server.takeRequest().getHeader("If-None-Match"));
+
+    Request request2 = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    client.newCall(request2).enqueue(callback);
+    callback.await(request2.url()).assertCode(200).assertBody("A");
+    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
+  }
+
+  @Test public void conditionalCacheMiss() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("ETag: v1")
+        .addHeader("Vary: Accept-Charset")
+        .addHeader("Donut: a")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .addHeader("Donut: b")
+        .setBody("B"));
+
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    long request1SentAt = System.currentTimeMillis();
+    executeSynchronously("/", "Accept-Language", "fr-CA", "Accept-Charset", "UTF-8")
+        .assertCode(200)
+        .assertBody("A");
+    long request1ReceivedAt = System.currentTimeMillis();
+    assertNull(server.takeRequest().getHeader("If-None-Match"));
+
+    // Different request, but Vary says it doesn't matter.
+    Thread.sleep(10); // Make sure the timestamps are unique.
+    long request2SentAt = System.currentTimeMillis();
+    RecordedResponse cacheMiss = executeSynchronously(
+        "/", "Accept-Language", "en-US", "Accept-Charset", "UTF-8");
+    long request2ReceivedAt = System.currentTimeMillis();
+    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
+
+    // Check the user response. It has the application's original request.
+    cacheMiss.assertCode(200)
+        .assertBody("B")
+        .assertHeader("Donut", "b")
+        .assertRequestUrl(server.url("/"))
+        .assertSentRequestAtMillis(request2SentAt, request2ReceivedAt)
+        .assertReceivedResponseAtMillis(request2SentAt, request2ReceivedAt);
+
+    // Check the cache response. Even though it's a miss, we used the cache.
+    cacheMiss.cacheResponse()
+        .assertCode(200)
+        .assertHeader("Donut", "a")
+        .assertHeader("ETag", "v1")
+        .assertRequestUrl(server.url("/"))
+        .assertSentRequestAtMillis(request1SentAt, request1ReceivedAt)
+        .assertReceivedResponseAtMillis(request1SentAt, request1ReceivedAt);
+
+    // Check the network response. It has the network request, plus caching headers.
+    cacheMiss.networkResponse()
+        .assertCode(200)
+        .assertHeader("Donut", "b")
+        .assertRequestHeader("If-None-Match", "v1")  // If-None-Match in the validation request.
+        .assertRequestUrl(server.url("/"))
+        .assertSentRequestAtMillis(request2SentAt, request2ReceivedAt)
+        .assertReceivedResponseAtMillis(request2SentAt, request2ReceivedAt);
+  }
+
+  @Test public void conditionalCacheMiss_Async() throws Exception {
+    server.enqueue(new MockResponse().setBody("A").addHeader("ETag: v1"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    Request request1 = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    client.newCall(request1).enqueue(callback);
+    callback.await(request1.url()).assertCode(200).assertBody("A");
+    assertNull(server.takeRequest().getHeader("If-None-Match"));
+
+    Request request2 = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    client.newCall(request2).enqueue(callback);
+    callback.await(request2.url()).assertCode(200).assertBody("B");
+    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
+  }
+
+  @Test public void onlyIfCachedReturns504WhenNotCached() throws Exception {
+    executeSynchronously("/", "Cache-Control", "only-if-cached")
+        .assertCode(504)
+        .assertBody("")
+        .assertNoNetworkResponse()
+        .assertNoCacheResponse();
+  }
+
+  @Test public void networkDropsOnConditionalGet() throws IOException {
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    // Seed the cache.
+    server.enqueue(new MockResponse()
+        .addHeader("ETag: v1")
+        .setBody("A"));
+    executeSynchronously("/")
+        .assertCode(200)
+        .assertBody("A");
+
+    // Attempt conditional cache validation and a DNS miss.
+    client.connectionPool().evictAll();
+    client = client.newBuilder()
+        .dns(new FakeDns())
+        .build();
+    executeSynchronously("/").assertFailure(UnknownHostException.class);
+  }
+
+  @Test public void redirect() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location: /b")
+        .addHeader("Test", "Redirect from /a to /b")
+        .setBody("/a has moved!"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: /c")
+        .addHeader("Test", "Redirect from /b to /c")
+        .setBody("/b has moved!"));
+    server.enqueue(new MockResponse().setBody("C"));
+
+    executeSynchronously("/a")
+        .assertCode(200)
+        .assertBody("C")
+        .priorResponse()
+        .assertCode(302)
+        .assertHeader("Test", "Redirect from /b to /c")
+        .priorResponse()
+        .assertCode(301)
+        .assertHeader("Test", "Redirect from /a to /b");
+
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reused.
+    assertEquals(2, server.takeRequest().getSequenceNumber()); // Connection reused again!
+  }
+
+  @Test public void postRedirectsToGet() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: /page2")
+        .setBody("This page has moved!"));
+    server.enqueue(new MockResponse().setBody("Page 2"));
+
+    Response response = client.newCall(new Request.Builder()
+        .url(server.url("/page1"))
+        .post(RequestBody.create(MediaType.parse("text/plain"), "Request Body"))
+        .build()).execute();
+    assertEquals("Page 2", response.body().string());
+
+    RecordedRequest page1 = server.takeRequest();
+    assertEquals("POST /page1 HTTP/1.1", page1.getRequestLine());
+    assertEquals("Request Body", page1.getBody().readUtf8());
+
+    RecordedRequest page2 = server.takeRequest();
+    assertEquals("GET /page2 HTTP/1.1", page2.getRequestLine());
+  }
+
+  @Test public void getClientRequestTimeout() throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setResponseCode(408)
+        .setHeader("Connection", "Close")
+        .setBody("You took too long!"));
+    server.enqueue(new MockResponse().setBody("Body"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Response response = client.newCall(request).execute();
+
+    assertEquals("Body", response.body().string());
+  }
+
+  @Test public void requestBodyRetransmittedOnClientRequestTimeout() throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setResponseCode(408)
+        .setHeader("Connection", "Close")
+        .setBody("You took too long!"));
+    server.enqueue(new MockResponse().setBody("Body"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(RequestBody.create(MediaType.parse("text/plain"), "Hello"))
+        .build();
+    Response response = client.newCall(request).execute();
+
+    assertEquals("Body", response.body().string());
+
+    RecordedRequest request1 = server.takeRequest();
+    assertEquals("Hello", request1.getBody().readUtf8());
+
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals("Hello", request2.getBody().readUtf8());
+  }
+
+  @Test public void disableClientRequestTimeoutRetry() throws IOException {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setResponseCode(408)
+        .setHeader("Connection", "Close")
+        .setBody("You took too long!"));
+
+    client = client.newBuilder()
+        .retryOnConnectionFailure(false)
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Response response = client.newCall(request).execute();
+
+    assertEquals(408, response.code());
+    assertEquals("You took too long!", response.body().string());
+  }
+
+  @Test public void maxClientRequestTimeoutRetries() throws IOException {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setResponseCode(408)
+        .setHeader("Connection", "Close")
+        .setBody("You took too long!"));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setResponseCode(408)
+        .setHeader("Connection", "Close")
+        .setBody("You took too long!"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Response response = client.newCall(request).execute();
+
+    assertEquals(408, response.code());
+    assertEquals("You took too long!", response.body().string());
+
+    assertEquals(2, server.getRequestCount());
+  }
+
+  @Test public void propfindRedirectsToPropfindAndMaintainsRequestBody() throws Exception {
+    // given
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: /page2")
+        .setBody("This page has moved!"));
+    server.enqueue(new MockResponse().setBody("Page 2"));
+
+    // when
+    Response response = client.newCall(new Request.Builder()
+        .url(server.url("/page1"))
+        .method("PROPFIND", RequestBody.create(MediaType.parse("text/plain"), "Request Body"))
+        .build()).execute();
+
+    // then
+    assertEquals("Page 2", response.body().string());
+
+    RecordedRequest page1 = server.takeRequest();
+    assertEquals("PROPFIND /page1 HTTP/1.1", page1.getRequestLine());
+    assertEquals("Request Body", page1.getBody().readUtf8());
+
+    RecordedRequest page2 = server.takeRequest();
+    assertEquals("PROPFIND /page2 HTTP/1.1", page2.getRequestLine());
+    assertEquals("Request Body", page2.getBody().readUtf8());
+  }
+
+  @Test public void responseCookies() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Set-Cookie", "a=b; Expires=Thu, 01 Jan 1970 00:00:00 GMT")
+        .addHeader("Set-Cookie", "c=d; Expires=Fri, 02 Jan 1970 23:59:59 GMT; path=/bar; secure"));
+
+    RecordingCookieJar cookieJar = new RecordingCookieJar();
+    client = client.newBuilder()
+        .cookieJar(cookieJar)
+        .build();
+
+    executeSynchronously("/").assertCode(200);
+
+    List<Cookie> responseCookies = cookieJar.takeResponseCookies();
+    assertEquals(2, responseCookies.size());
+    assertEquals("a=b; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/",
+        responseCookies.get(0).toString());
+    assertEquals("c=d; expires=Fri, 02 Jan 1970 23:59:59 GMT; path=/bar; secure",
+        responseCookies.get(1).toString());
+  }
+
+  @Test public void requestCookies() throws Exception {
+    server.enqueue(new MockResponse());
+
+    RecordingCookieJar cookieJar = new RecordingCookieJar();
+
+    cookieJar.enqueueRequestCookies(
+        new Cookie.Builder().name("a").value("b").domain(server.getHostName()).build(),
+        new Cookie.Builder().name("c").value("d").domain(server.getHostName()).build());
+    client = client.newBuilder()
+        .cookieJar(cookieJar)
+        .build();
+
+    executeSynchronously("/").assertCode(200);
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("a=b; c=d", recordedRequest.getHeader("Cookie"));
+  }
+
+  @Test public void redirectsDoNotIncludeTooManyCookies() throws Exception {
+    server2.enqueue(new MockResponse().setBody("Page 2"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: " + server2.url("/")));
+
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    HttpCookie cookie = new HttpCookie("c", "cookie");
+    cookie.setDomain(server.getHostName());
+    cookie.setPath("/");
+    String portList = Integer.toString(server.getPort());
+    cookie.setPortlist(portList);
+    cookieManager.getCookieStore().add(server.url("/").uri(), cookie);
+    client = client.newBuilder()
+        .cookieJar(new JavaNetCookieJar(cookieManager))
+        .build();
+
+    Response response = client.newCall(new Request.Builder()
+        .url(server.url("/page1"))
+        .build()).execute();
+    assertEquals("Page 2", response.body().string());
+
+    RecordedRequest request1 = server.takeRequest();
+    assertEquals("c=cookie", request1.getHeader("Cookie"));
+
+    RecordedRequest request2 = server2.takeRequest();
+    assertNull(request2.getHeader("Cookie"));
+  }
+
+  @Test public void redirectsDoNotIncludeTooManyAuthHeaders() throws Exception {
+    server2.enqueue(new MockResponse().setBody("Page 2"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(401));
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: " + server2.url("/b")));
+
+    client = client.newBuilder()
+        .authenticator(new RecordingOkAuthenticator(Credentials.basic("jesse", "secret")))
+        .build();
+
+    Request request = new Request.Builder().url(server.url("/a")).build();
+    Response response = client.newCall(request).execute();
+    assertEquals("Page 2", response.body().string());
+
+    RecordedRequest redirectRequest = server2.takeRequest();
+    assertNull(redirectRequest.getHeader("Authorization"));
+    assertEquals("/b", redirectRequest.getPath());
+  }
+
+  @Test public void redirect_Async() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location: /b")
+        .addHeader("Test", "Redirect from /a to /b")
+        .setBody("/a has moved!"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: /c")
+        .addHeader("Test", "Redirect from /b to /c")
+        .setBody("/b has moved!"));
+    server.enqueue(new MockResponse().setBody("C"));
+
+    Request request = new Request.Builder().url(server.url("/a")).build();
+    client.newCall(request).enqueue(callback);
+
+    callback.await(server.url("/a"))
+        .assertCode(200)
+        .assertBody("C")
+        .priorResponse()
+        .assertCode(302)
+        .assertHeader("Test", "Redirect from /b to /c")
+        .priorResponse()
+        .assertCode(301)
+        .assertHeader("Test", "Redirect from /a to /b");
+
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reused.
+    assertEquals(2, server.takeRequest().getSequenceNumber()); // Connection reused again!
+  }
+
+  @Test public void follow20Redirects() throws Exception {
+    for (int i = 0; i < 20; i++) {
+      server.enqueue(new MockResponse()
+          .setResponseCode(301)
+          .addHeader("Location: /" + (i + 1))
+          .setBody("Redirecting to /" + (i + 1)));
+    }
+    server.enqueue(new MockResponse().setBody("Success!"));
+
+    executeSynchronously("/0")
+        .assertCode(200)
+        .assertBody("Success!");
+  }
+
+  @Test public void follow20Redirects_Async() throws Exception {
+    for (int i = 0; i < 20; i++) {
+      server.enqueue(new MockResponse()
+          .setResponseCode(301)
+          .addHeader("Location: /" + (i + 1))
+          .setBody("Redirecting to /" + (i + 1)));
+    }
+    server.enqueue(new MockResponse().setBody("Success!"));
+
+    Request request = new Request.Builder().url(server.url("/0")).build();
+    client.newCall(request).enqueue(callback);
+    callback.await(server.url("/0"))
+        .assertCode(200)
+        .assertBody("Success!");
+  }
+
+  @Test public void doesNotFollow21Redirects() throws Exception {
+    for (int i = 0; i < 21; i++) {
+      server.enqueue(new MockResponse()
+          .setResponseCode(301)
+          .addHeader("Location: /" + (i + 1))
+          .setBody("Redirecting to /" + (i + 1)));
+    }
+
+    try {
+      client.newCall(new Request.Builder().url(server.url("/0")).build()).execute();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("Too many follow-up requests: 21", expected.getMessage());
+    }
+  }
+
+  @Test public void doesNotFollow21Redirects_Async() throws Exception {
+    for (int i = 0; i < 21; i++) {
+      server.enqueue(new MockResponse()
+          .setResponseCode(301)
+          .addHeader("Location: /" + (i + 1))
+          .setBody("Redirecting to /" + (i + 1)));
+    }
+
+    Request request = new Request.Builder().url(server.url("/0")).build();
+    client.newCall(request).enqueue(callback);
+    callback.await(server.url("/0")).assertFailure("Too many follow-up requests: 21");
+  }
+
+  @Test public void http204WithBodyDisallowed() throws IOException {
+    server.enqueue(new MockResponse()
+        .setResponseCode(204)
+        .setBody("I'm not even supposed to be here today."));
+
+    executeSynchronously("/")
+        .assertFailure("HTTP 204 had non-zero Content-Length: 39");
+  }
+
+  @Test public void http205WithBodyDisallowed() throws IOException {
+    server.enqueue(new MockResponse()
+        .setResponseCode(205)
+        .setBody("I'm not even supposed to be here today."));
+
+    executeSynchronously("/")
+        .assertFailure("HTTP 205 had non-zero Content-Length: 39");
+  }
+
+  @Test public void httpWithExcessiveHeaders() throws IOException {
+    String longLine = "HTTP/1.1 200 " + stringFill('O', 256 * 1024) + "K";
+
+    server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
+
+    server.enqueue(new MockResponse()
+        .setStatus(longLine)
+        .setBody("I'm not even supposed to be here today."));
+
+    executeSynchronously("/")
+        .assertFailureMatches(".*unexpected end of stream on Connection.*");
+  }
+
+  private String stringFill(char fillChar, int length) {
+    char[] value = new char[length];
+    Arrays.fill(value, fillChar);
+    return new String(value);
+  }
+
+  @Test public void canceledBeforeExecute() throws Exception {
+    Call call = client.newCall(new Request.Builder().url(server.url("/a")).build());
+    call.cancel();
+
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+    assertEquals(0, server.getRequestCount());
+  }
+
+  @Test public void cancelDuringHttpConnect() throws Exception {
+    cancelDuringConnect("http");
+  }
+
+  @Test public void cancelDuringHttpsConnect() throws Exception {
+    cancelDuringConnect("https");
+  }
+
+  /** Cancel a call that's waiting for connect to complete. */
+  private void cancelDuringConnect(String scheme) throws Exception {
+    nullServer.start();
+
+    long cancelDelayMillis = 300L;
+    Call call = client.newCall(new Request.Builder()
+        .url(nullServer.url(scheme))
+        .build());
+    cancelLater(call, cancelDelayMillis);
+
+    long startNanos = System.nanoTime();
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+    long elapsedNanos = System.nanoTime() - startNanos;
+    assertEquals(cancelDelayMillis, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 100f);
+  }
+
+  @Test public void cancelImmediatelyAfterEnqueue() throws Exception {
+    server.enqueue(new MockResponse());
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/a"))
+        .build());
+    call.enqueue(callback);
+    call.cancel();
+    callback.await(server.url("/a")).assertFailure("Canceled", "Socket closed");
+  }
+
+  @Test public void cancelAll() throws Exception {
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    call.enqueue(callback);
+    client.dispatcher().cancelAll();
+    callback.await(server.url("/")).assertFailure("Canceled", "Socket closed");
+  }
+
+  @Test public void cancelBeforeBodyIsRead() throws Exception {
+    server.enqueue(new MockResponse().setBody("def").throttleBody(1, 750, TimeUnit.MILLISECONDS));
+
+    final Call call = client.newCall(new Request.Builder().url(server.url("/a")).build());
+    ExecutorService executor = Executors.newSingleThreadExecutor();
+    Future<Response> result = executor.submit(new Callable<Response>() {
+      @Override public Response call() throws Exception {
+        return call.execute();
+      }
+    });
+
+    Thread.sleep(100); // wait for it to go in flight.
+
+    call.cancel();
+    try {
+      result.get().body().bytes();
+      fail();
+    } catch (IOException expected) {
+    }
+    assertEquals(1, server.getRequestCount());
+  }
+
+  @Test public void cancelInFlightBeforeResponseReadThrowsIOE() throws Exception {
+    Request request = new Request.Builder().url(server.url("/a")).build();
+    final Call call = client.newCall(request);
+
+    server.setDispatcher(new Dispatcher() {
+      @Override public MockResponse dispatch(RecordedRequest request) {
+        call.cancel();
+        return new MockResponse().setBody("A");
+      }
+    });
+
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void cancelInFlightBeforeResponseReadThrowsIOE_HTTPS() throws Exception {
+    enableTls();
+    cancelInFlightBeforeResponseReadThrowsIOE();
+  }
+
+  @Test public void cancelInFlightBeforeResponseReadThrowsIOE_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    cancelInFlightBeforeResponseReadThrowsIOE();
+  }
+
+  /**
+   * This test puts a request in front of one that is to be canceled, so that it is canceled before
+   * I/O takes place.
+   */
+  @Test public void canceledBeforeIOSignalsOnFailure() throws Exception {
+    // Force requests to be executed serially.
+    okhttp3.Dispatcher dispatcher = new okhttp3.Dispatcher(client.dispatcher().executorService());
+    dispatcher.setMaxRequests(1);
+    client = client.newBuilder()
+        .dispatcher(dispatcher)
+        .build();
+
+    Request requestA = new Request.Builder().url(server.url("/a")).build();
+    Request requestB = new Request.Builder().url(server.url("/b")).build();
+    final Call callA = client.newCall(requestA);
+    final Call callB = client.newCall(requestB);
+
+    server.setDispatcher(new Dispatcher() {
+      char nextResponse = 'A';
+
+      @Override public MockResponse dispatch(RecordedRequest request) {
+        callB.cancel();
+        return new MockResponse().setBody(Character.toString(nextResponse++));
+      }
+    });
+
+    callA.enqueue(callback);
+    callB.enqueue(callback);
+    assertEquals("/a", server.takeRequest().getPath());
+
+    callback.await(requestA.url()).assertBody("A");
+    // At this point we know the callback is ready, and that it will receive a cancel failure.
+    callback.await(requestB.url()).assertFailure("Canceled", "Socket closed");
+  }
+
+  @Test public void canceledBeforeIOSignalsOnFailure_HTTPS() throws Exception {
+    enableTls();
+    canceledBeforeIOSignalsOnFailure();
+  }
+
+  @Test public void canceledBeforeIOSignalsOnFailure_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    canceledBeforeIOSignalsOnFailure();
+  }
+
+  @Test public void canceledBeforeResponseReadSignalsOnFailure() throws Exception {
+    Request requestA = new Request.Builder().url(server.url("/a")).build();
+    final Call call = client.newCall(requestA);
+    server.setDispatcher(new Dispatcher() {
+      @Override public MockResponse dispatch(RecordedRequest request) {
+        call.cancel();
+        return new MockResponse().setBody("A");
+      }
+    });
+
+    call.enqueue(callback);
+    assertEquals("/a", server.takeRequest().getPath());
+
+    callback.await(requestA.url()).assertFailure("Canceled", "stream was reset: CANCEL",
+        "Socket closed");
+  }
+
+  @Test public void canceledBeforeResponseReadSignalsOnFailure_HTTPS() throws Exception {
+    enableTls();
+    canceledBeforeResponseReadSignalsOnFailure();
+  }
+
+  @Test public void canceledBeforeResponseReadSignalsOnFailure_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    canceledBeforeResponseReadSignalsOnFailure();
+  }
+
+  /**
+   * There's a race condition where the cancel may apply after the stream has already been
+   * processed.
+   */
+  @Test public void canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce() throws Exception {
+    server.enqueue(new MockResponse().setBody("A"));
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<String> bodyRef = new AtomicReference<>();
+    final AtomicBoolean failureRef = new AtomicBoolean();
+
+    Request request = new Request.Builder().url(server.url("/a")).build();
+    final Call call = client.newCall(request);
+    call.enqueue(new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+        failureRef.set(true);
+        latch.countDown();
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        call.cancel();
+        try {
+          bodyRef.set(response.body().string());
+        } catch (IOException e) { // It is ok if this broke the stream.
+          bodyRef.set("A");
+          throw e; // We expect to not loop into onFailure in this case.
+        } finally {
+          latch.countDown();
+        }
+      }
+    });
+
+    latch.await();
+    assertEquals("A", bodyRef.get());
+    assertFalse(failureRef.get());
+  }
+
+  @Test public void canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce_HTTPS()
+      throws Exception {
+    enableTls();
+    canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce();
+  }
+
+  @Test public void canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce_HTTP_2()
+      throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce();
+  }
+
+  @Test public void cancelWithInterceptor() throws Exception {
+    client = client.newBuilder()
+        .addInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            chain.proceed(chain.request());
+            throw new AssertionError(); // We expect an exception.
+          }
+        }).build();
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/a")).build());
+    call.cancel();
+
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+    assertEquals(0, server.getRequestCount());
+  }
+
+  @Test public void gzip() throws Exception {
+    Buffer gzippedBody = gzip("abcabcabc");
+    String bodySize = Long.toString(gzippedBody.size());
+
+    server.enqueue(new MockResponse()
+        .setBody(gzippedBody)
+        .addHeader("Content-Encoding: gzip"));
+
+    // Confirm that the user request doesn't have Accept-Encoding, and the user
+    // response doesn't have a Content-Encoding or Content-Length.
+    RecordedResponse userResponse = executeSynchronously("/");
+    userResponse.assertCode(200)
+        .assertRequestHeader("Accept-Encoding")
+        .assertHeader("Content-Encoding")
+        .assertHeader("Content-Length")
+        .assertBody("abcabcabc");
+
+    // But the network request doesn't lie. OkHttp used gzip for this call.
+    userResponse.networkResponse()
+        .assertHeader("Content-Encoding", "gzip")
+        .assertHeader("Content-Length", bodySize)
+        .assertRequestHeader("Accept-Encoding", "gzip");
+  }
+
+  /** https://github.com/square/okhttp/issues/1927 */
+  @Test public void gzipResponseAfterAuthenticationChallenge() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(401));
+    server.enqueue(new MockResponse()
+        .setBody(gzip("abcabcabc"))
+        .addHeader("Content-Encoding: gzip"));
+    client = client.newBuilder()
+        .authenticator(new RecordingOkAuthenticator("password"))
+        .build();
+
+    executeSynchronously("/").assertBody("abcabcabc");
+  }
+
+  @Test public void rangeHeaderPreventsAutomaticGzip() throws Exception {
+    Buffer gzippedBody = gzip("abcabcabc");
+
+    // Enqueue a gzipped response. Our request isn't expecting it, but that's okay.
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
+        .setBody(gzippedBody)
+        .addHeader("Content-Encoding: gzip")
+        .addHeader("Content-Range: bytes 0-" + (gzippedBody.size() - 1)));
+
+    // Make a range request.
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .header("Range", "bytes=0-")
+        .build();
+    Call call = client.newCall(request);
+
+    // The response is not decompressed.
+    Response response = call.execute();
+    assertEquals("gzip", response.header("Content-Encoding"));
+    assertEquals(gzippedBody.snapshot(), response.body().source().readByteString());
+
+    // The request did not offer gzip support.
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertNull(recordedRequest.getHeader("Accept-Encoding"));
+  }
+
+  @Test public void asyncResponseCanBeConsumedLater() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .header("User-Agent", "SyncApiTest")
+        .build();
+
+    final BlockingQueue<Response> responseRef = new SynchronousQueue<>();
+    client.newCall(request).enqueue(new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+        throw new AssertionError();
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        try {
+          responseRef.put(response);
+        } catch (InterruptedException e) {
+          throw new AssertionError();
+        }
+      }
+    });
+
+    Response response = responseRef.take();
+    assertEquals(200, response.code());
+    assertEquals("abc", response.body().string());
+
+    // Make another request just to confirm that that connection can be reused...
+    executeSynchronously("/").assertBody("def");
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reused.
+
+    // ... even before we close the response body!
+    response.body().close();
+  }
+
+  @Test public void userAgentIsIncludedByDefault() throws Exception {
+    server.enqueue(new MockResponse());
+
+    executeSynchronously("/");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertTrue(recordedRequest.getHeader("User-Agent")
+        .matches(Version.userAgent()));
+  }
+
+  @Test public void setFollowRedirectsFalse() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: /b")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    client = client.newBuilder()
+        .followRedirects(false)
+        .build();
+    executeSynchronously("/a")
+        .assertBody("A")
+        .assertCode(302);
+  }
+
+  @Test public void expect100ContinueNonEmptyRequestBody() throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.EXPECT_CONTINUE));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .header("Expect", "100-continue")
+        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertSuccessful();
+
+    assertEquals("abc", server.takeRequest().getBody().readUtf8());
+  }
+
+  @Test public void expect100ContinueEmptyRequestBody() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .header("Expect", "100-continue")
+        .post(RequestBody.create(MediaType.parse("text/plain"), ""))
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertSuccessful();
+  }
+
+  @Test public void expect100ContinueEmptyRequestBody_HTTP2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    expect100ContinueEmptyRequestBody();
+  }
+
+  @Test public void expect100ContinueTimesOutWithoutContinue() throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.NO_RESPONSE));
+
+    client = client.newBuilder()
+        .readTimeout(500, TimeUnit.MILLISECONDS)
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .header("Expect", "100-continue")
+        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .build();
+
+    Call call = client.newCall(request);
+    try {
+      call.execute();
+      fail();
+    } catch (SocketTimeoutException expected) {
+    }
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("", recordedRequest.getBody().readUtf8());
+  }
+
+  @Test public void expect100ContinueTimesOutWithoutContinue_HTTP2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    expect100ContinueTimesOutWithoutContinue();
+  }
+
+  @Test public void serverRespondsWithUnsolicited100Continue() throws Exception {
+    server.enqueue(new MockResponse()
+        .setStatus("HTTP/1.1 100 Continue"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .build();
+
+    Call call = client.newCall(request);
+    Response response = call.execute();
+    assertEquals(100, response.code());
+    assertEquals("", response.body().string());
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("abc", recordedRequest.getBody().readUtf8());
+  }
+
+  @Test public void serverRespondsWithUnsolicited100Continue_HTTP2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    serverRespondsWithUnsolicited100Continue();
+  }
+
+  @Test public void successfulExpectContinuePermitsConnectionReuse() throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.EXPECT_CONTINUE));
+    server.enqueue(new MockResponse());
+
+    executeSynchronously(new Request.Builder()
+        .url(server.url("/"))
+        .header("Expect", "100-continue")
+        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .build());
+    executeSynchronously(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void successfulExpectContinuePermitsConnectionReuseWithHttp2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    successfulExpectContinuePermitsConnectionReuse();
+  }
+
+  @Test public void unsuccessfulExpectContinuePreventsConnectionReuse() throws Exception {
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+
+    executeSynchronously(new Request.Builder()
+        .url(server.url("/"))
+        .header("Expect", "100-continue")
+        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .build());
+    executeSynchronously(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void unsuccessfulExpectContinuePermitsConnectionReuseWithHttp2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+
+    executeSynchronously(new Request.Builder()
+        .url(server.url("/"))
+        .header("Expect", "100-continue")
+        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .build());
+    executeSynchronously(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
+  /** We forbid non-ASCII characters in outgoing request headers, but accept UTF-8. */
+  @Test public void responseHeaderParsingIsLenient() throws Exception {
+    Headers headers = new Headers.Builder()
+        .add("Content-Length", "0")
+        .addLenient("a\tb: c\u007fd")
+        .addLenient(": ef")
+        .addLenient("\ud83c\udf69: \u2615\ufe0f")
+        .build();
+    server.enqueue(new MockResponse().setHeaders(headers));
+
+    executeSynchronously("/")
+        .assertHeader("a\tb", "c\u007fd")
+        .assertHeader("\ud83c\udf69", "\u2615\ufe0f")
+        .assertHeader("", "ef");
+  }
+
+  @Test public void customDns() throws Exception {
+    // Configure a DNS that returns our local MockWebServer for android.com.
+    FakeDns dns = new FakeDns();
+    dns.set("android.com", Dns.SYSTEM.lookup(server.url("/").host()));
+    client = client.newBuilder()
+        .dns(dns)
+        .build();
+
+    server.enqueue(new MockResponse());
+    Request request = new Request.Builder()
+        .url(server.url("/").newBuilder().host("android.com").build())
+        .build();
+    executeSynchronously(request).assertCode(200);
+
+    dns.assertRequests("android.com");
+  }
+  @Test public void dnsReturnsZeroIpAddresses() throws Exception {
+    // Configure a DNS that returns our local MockWebServer for android.com.
+    FakeDns dns = new FakeDns();
+    List<InetAddress> ipAddresses = new ArrayList<>();
+    dns.set("android.com", ipAddresses);
+    client = client.newBuilder()
+        .dns(dns)
+        .build();
+
+    server.enqueue(new MockResponse());
+    Request request = new Request.Builder()
+        .url(server.url("/").newBuilder().host("android.com").build())
+        .build();
+    executeSynchronously(request).assertFailure(dns + " returned no addresses for android.com");
+
+    dns.assertRequests("android.com");
+  }
+
+  /** We had a bug where failed HTTP/2 calls could break the entire connection. */
+  @Test public void failingCallsDoNotInterfereWithConnection() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+
+    server.enqueue(new MockResponse().setBody("Response 1"));
+    server.enqueue(new MockResponse().setBody("Response 2"));
+
+    RequestBody requestBody = new RequestBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.writeUtf8("abc");
+        sink.flush();
+
+        makeFailingCall();
+
+        sink.writeUtf8("def");
+        sink.flush();
+      }
+    };
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .post(requestBody)
+        .build());
+    assertEquals("Response 1", call.execute().body().string());
+  }
+
+  /** Test which headers are sent unencrypted to the HTTP proxy. */
+  @Test public void proxyConnectOmitsApplicationHeaders() throws Exception {
+    server.useHttps(sslClient.socketFactory, true);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    server.enqueue(new MockResponse()
+        .setBody("encrypted response from the origin server"));
+
+    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .proxy(server.toProxyAddress())
+        .hostnameVerifier(hostnameVerifier)
+        .build();
+
+    Request request = new Request.Builder()
+        .url("https://android.com/foo")
+        .header("Private", "Secret")
+        .header("User-Agent", "App 1.0")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("encrypted response from the origin server", response.body().string());
+
+    RecordedRequest connect = server.takeRequest();
+    assertNull(connect.getHeader("Private"));
+    assertEquals(Version.userAgent(), connect.getHeader("User-Agent"));
+    assertEquals("Keep-Alive", connect.getHeader("Proxy-Connection"));
+    assertEquals("android.com:443", connect.getHeader("Host"));
+
+    RecordedRequest get = server.takeRequest();
+    assertEquals("Secret", get.getHeader("Private"));
+    assertEquals("App 1.0", get.getHeader("User-Agent"));
+
+    assertEquals(Arrays.asList("verify android.com"), hostnameVerifier.calls);
+  }
+
+  /** Respond to a proxy authorization challenge. */
+  @Test public void proxyAuthenticateOnConnect() throws Exception {
+    server.useHttps(sslClient.socketFactory, true);
+    server.enqueue(new MockResponse()
+        .setResponseCode(407)
+        .addHeader("Proxy-Authenticate: Basic realm=\"localhost\""));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    server.enqueue(new MockResponse()
+        .setBody("response body"));
+
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .proxy(server.toProxyAddress())
+        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+
+    Request request = new Request.Builder()
+        .url("https://android.com/foo")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("response body", response.body().string());
+
+    RecordedRequest connect1 = server.takeRequest();
+    assertEquals("CONNECT android.com:443 HTTP/1.1", connect1.getRequestLine());
+    assertNull(connect1.getHeader("Proxy-Authorization"));
+
+    RecordedRequest connect2 = server.takeRequest();
+    assertEquals("CONNECT android.com:443 HTTP/1.1", connect2.getRequestLine());
+    assertEquals("password", connect2.getHeader("Proxy-Authorization"));
+
+    RecordedRequest get = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", get.getRequestLine());
+    assertNull(get.getHeader("Proxy-Authorization"));
+  }
+
+  /** Confirm that the proxy authenticator works for unencrypted HTTP proxies. */
+  @Test public void httpProxyAuthenticate() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(407)
+        .addHeader("Proxy-Authenticate: Basic realm=\"localhost\""));
+    server.enqueue(new MockResponse()
+        .setBody("response body"));
+
+    client = client.newBuilder()
+        .proxy(server.toProxyAddress())
+        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
+        .build();
+
+    Request request = new Request.Builder()
+        .url("http://android.com/foo")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("response body", response.body().string());
+
+    RecordedRequest get1 = server.takeRequest();
+    assertEquals("GET http://android.com/foo HTTP/1.1", get1.getRequestLine());
+    assertNull(get1.getHeader("Proxy-Authorization"));
+
+    RecordedRequest get2 = server.takeRequest();
+    assertEquals("GET http://android.com/foo HTTP/1.1", get2.getRequestLine());
+    assertEquals("password", get2.getHeader("Proxy-Authorization"));
+  }
+
+  /**
+   * OkHttp has a bug where a `Connection: close` response header is not honored when establishing a
+   * TLS tunnel. https://github.com/square/okhttp/issues/2426
+   */
+  @Test public void proxyAuthenticateOnConnectWithConnectionClose() throws Exception {
+    server.useHttps(sslClient.socketFactory, true);
+    server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
+    server.enqueue(new MockResponse()
+        .setResponseCode(407)
+        .addHeader("Proxy-Authenticate: Basic realm=\"localhost\"")
+        .addHeader("Connection: close"));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    server.enqueue(new MockResponse()
+        .setBody("response body"));
+
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .proxy(server.toProxyAddress())
+        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+
+    Request request = new Request.Builder()
+        .url("https://android.com/foo")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("response body", response.body().string());
+
+    // First CONNECT call needs a new connection.
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+
+    // Second CONNECT call needs a new connection.
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+
+    // GET reuses the connection from the second connect.
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void tooManyProxyAuthFailuresWithConnectionClose() throws IOException {
+    server.useHttps(sslClient.socketFactory, true);
+    server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
+    for (int i = 0; i < 21; i++) {
+      server.enqueue(new MockResponse()
+          .setResponseCode(407)
+          .addHeader("Proxy-Authenticate: Basic realm=\"localhost\"")
+          .addHeader("Connection: close"));
+    }
+
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .proxy(server.toProxyAddress())
+        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+
+    Request request = new Request.Builder()
+        .url("https://android.com/foo")
+        .build();
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (ProtocolException expected) {
+    }
+  }
+
+  /**
+   * Confirm that we don't send the Proxy-Authorization header from the request to the proxy server.
+   * We used to have that behavior but it is problematic because unrelated requests end up sharing
+   * credentials. Worse, that approach leaks proxy credentials to the origin server.
+   */
+  @Test public void noProactiveProxyAuthorization() throws Exception {
+    server.useHttps(sslClient.socketFactory, true);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    server.enqueue(new MockResponse()
+        .setBody("response body"));
+
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .proxy(server.toProxyAddress())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+
+    Request request = new Request.Builder()
+        .url("https://android.com/foo")
+        .header("Proxy-Authorization", "password")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("response body", response.body().string());
+
+    RecordedRequest connect = server.takeRequest();
+    assertNull(connect.getHeader("Proxy-Authorization"));
+
+    RecordedRequest get = server.takeRequest();
+    assertEquals("password", get.getHeader("Proxy-Authorization"));
+  }
+
+  @Test public void interceptorGetsHttp2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+
+    // Capture the protocol as it is observed by the interceptor.
+    final AtomicReference<Protocol> protocolRef = new AtomicReference<>();
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        protocolRef.set(chain.connection().protocol());
+        return chain.proceed(chain.request());
+      }
+    };
+    client = client.newBuilder()
+        .addNetworkInterceptor(interceptor)
+        .build();
+
+    // Make an HTTP/2 request and confirm that the protocol matches.
+    server.enqueue(new MockResponse());
+    executeSynchronously("/");
+    assertEquals(Protocol.HTTP_2, protocolRef.get());
+  }
+
+  @Test public void serverSendsInvalidResponseHeaders() throws Exception {
+    server.enqueue(new MockResponse()
+        .setStatus("HTP/1.1 200 OK"));
+
+    executeSynchronously("/")
+        .assertFailure("Unexpected status line: HTP/1.1 200 OK");
+  }
+
+  @Test public void serverSendsInvalidCodeTooLarge() throws Exception {
+    server.enqueue(new MockResponse()
+        .setStatus("HTTP/1.1 2147483648 OK"));
+
+    executeSynchronously("/")
+        .assertFailure("Unexpected status line: HTTP/1.1 2147483648 OK");
+  }
+
+  @Test public void serverSendsInvalidCodeNotANumber() throws Exception {
+    server.enqueue(new MockResponse()
+        .setStatus("HTTP/1.1 00a OK"));
+
+    executeSynchronously("/")
+        .assertFailure("Unexpected status line: HTTP/1.1 00a OK");
+  }
+
+  @Test public void serverSendsUnnecessaryWhitespace() throws Exception {
+    server.enqueue(new MockResponse()
+        .setStatus(" HTTP/1.1 200 OK"));
+
+    executeSynchronously("/")
+        .assertFailure("Unexpected status line:  HTTP/1.1 200 OK");
+  }
+
+  @Test public void requestHeaderNameWithSpaceForbidden() throws Exception {
+    try {
+      new Request.Builder().addHeader("a b", "c");
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals("Unexpected char 0x20 at 1 in header name: a b", expected.getMessage());
+    }
+  }
+
+  @Test public void requestHeaderNameWithTabForbidden() throws Exception {
+    try {
+      new Request.Builder().addHeader("a\tb", "c");
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals("Unexpected char 0x09 at 1 in header name: a\tb", expected.getMessage());
+    }
+  }
+
+  @Test public void responseHeaderNameWithSpacePermitted() throws Exception {
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .addHeader("content-length: 0")
+        .addHeaderLenient("a b", "c"));
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
+    Response response = call.execute();
+    assertEquals("c", response.header("a b"));
+  }
+
+  @Test public void responseHeaderNameWithTabPermitted() throws Exception {
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .addHeader("content-length: 0")
+        .addHeaderLenient("a\tb", "c"));
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
+    Response response = call.execute();
+    assertEquals("c", response.header("a\tb"));
+  }
+
+  @Test public void connectFails() throws Exception {
+    server.shutdown();
+
+    executeSynchronously("/")
+        .assertFailure(IOException.class);
+  }
+
+  @Test public void requestBodySurvivesRetries() throws Exception {
+    server.enqueue(new MockResponse());
+
+    // Enable a misconfigured proxy selector to guarantee that the request is retried.
+    client = client.newBuilder()
+        .proxySelector(new FakeProxySelector()
+            .addProxy(server2.toProxyAddress())
+            .addProxy(Proxy.NO_PROXY))
+        .build();
+    server2.shutdown();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .build();
+
+    executeSynchronously(request);
+    assertEquals("abc", server.takeRequest().getBody().readUtf8());
+  }
+
+  @Ignore // This may fail in DNS lookup, which we don't have timeouts for.
+  @Test public void invalidHost() throws Exception {
+    Request request = new Request.Builder()
+        .url(HttpUrl.parse("http://1234.1.1.1/"))
+        .build();
+
+    executeSynchronously(request)
+        .assertFailure(UnknownHostException.class);
+  }
+
+  @Test public void uploadBodySmallChunkedEncoding() throws Exception {
+    upload(true, 1048576, 256);
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals(1048576, recordedRequest.getBodySize());
+    assertFalse(recordedRequest.getChunkSizes().isEmpty());
+  }
+
+  @Test public void uploadBodyLargeChunkedEncoding() throws Exception {
+    upload(true, 1048576, 65536);
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals(1048576, recordedRequest.getBodySize());
+    assertFalse(recordedRequest.getChunkSizes().isEmpty());
+  }
+
+  @Test public void uploadBodySmallFixedLength() throws Exception {
+    upload(false, 1048576, 256);
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals(1048576, recordedRequest.getBodySize());
+    assertTrue(recordedRequest.getChunkSizes().isEmpty());
+  }
+
+  @Test public void uploadBodyLargeFixedLength() throws Exception {
+    upload(false, 1048576, 65536);
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals(1048576, recordedRequest.getBodySize());
+    assertTrue(recordedRequest.getChunkSizes().isEmpty());
+  }
+
+  private void upload(
+      final boolean chunked, final int size, final int writeSize) throws Exception {
+    server.enqueue(new MockResponse());
+    executeSynchronously(new Request.Builder()
+        .url(server.url("/"))
+        .post(requestBody(chunked, size, writeSize))
+        .build());
+  }
+
+  /** https://github.com/square/okhttp/issues/2344 */
+  @Test public void ipv6HostHasSquareBraces() throws Exception {
+    // Use a proxy to fake IPv6 connectivity, even if localhost doesn't have IPv6.
+    server.useHttps(sslClient.socketFactory, true);
+    server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    server.enqueue(new MockResponse()
+        .setBody("response body"));
+
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .proxy(server.toProxyAddress())
+        .build();
+
+    Request request = new Request.Builder()
+        .url("https://[::1]/")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("response body", response.body().string());
+
+    RecordedRequest connect = server.takeRequest();
+    assertEquals("CONNECT [::1]:443 HTTP/1.1", connect.getRequestLine());
+    assertEquals("[::1]:443", connect.getHeader("Host"));
+
+    RecordedRequest get = server.takeRequest();
+    assertEquals("GET / HTTP/1.1", get.getRequestLine());
+    assertEquals("[::1]", get.getHeader("Host"));
+  }
+
+  private RequestBody requestBody(final boolean chunked, final long size, final int writeSize) {
+    final byte[] buffer = new byte[writeSize];
+    Arrays.fill(buffer, (byte) 'x');
+
+    return new RequestBody() {
+      @Override public MediaType contentType() {
+        return MediaType.parse("text/plain; charset=utf-8");
+      }
+
+      @Override public long contentLength() throws IOException {
+        return chunked ? -1L : size;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        for (int count = 0; count < size; count += writeSize) {
+          sink.write(buffer, 0, (int) Math.min(size - count, writeSize));
+        }
+      }
+    };
+  }
+
+  @Test public void emptyResponseBody() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("abc", "def"));
+    executeSynchronously("/")
+        .assertCode(200)
+        .assertHeader("abc", "def")
+        .assertBody("");
+  }
+
+  @Test public void leakedResponseBodyLogsStackTrace() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("This gets leaked."));
+
+    client = defaultClient().newBuilder()
+        .connectionPool(new ConnectionPool(0, 10, TimeUnit.MILLISECONDS))
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Level original = logger.getLevel();
+    logger.setLevel(Level.FINE);
+    logHandler.setFormatter(new SimpleFormatter());
+    try {
+      client.newCall(request).execute(); // Ignore the response so it gets leaked then GC'd.
+      awaitGarbageCollection();
+
+      String message = logHandler.take();
+      assertTrue(message.contains("A connection to " + server.url("/") + " was leaked."
+          + " Did you forget to close a response body?"));
+      assertTrue(message.contains("okhttp3.RealCall.execute("));
+      assertTrue(message.contains("okhttp3.CallTest.leakedResponseBodyLogsStackTrace("));
+    } finally {
+      logger.setLevel(original);
+    }
+  }
+
+  @Test public void asyncLeakedResponseBodyLogsStackTrace() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("This gets leaked."));
+
+    client = defaultClient().newBuilder()
+        .connectionPool(new ConnectionPool(0, 10, TimeUnit.MILLISECONDS))
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Level original = logger.getLevel();
+    logger.setLevel(Level.FINE);
+    logHandler.setFormatter(new SimpleFormatter());
+    try {
+      final CountDownLatch latch = new CountDownLatch(1);
+      client.newCall(request).enqueue(new Callback() {
+        @Override public void onFailure(Call call, IOException e) {
+          fail();
+        }
+
+        @Override public void onResponse(Call call, Response response) throws IOException {
+          // Ignore the response so it gets leaked then GC'd.
+          latch.countDown();
+        }
+      });
+      latch.await();
+      // There's some flakiness when triggering a GC for objects in a separate thread. Adding a
+      // small delay appears to ensure the objects will get GC'd.
+      Thread.sleep(200);
+      awaitGarbageCollection();
+
+      String message = logHandler.take();
+      assertTrue(message.contains("A connection to " + server.url("/") + " was leaked."
+          + " Did you forget to close a response body?"));
+      assertTrue(message.contains("okhttp3.RealCall.enqueue("));
+      assertTrue(message.contains("okhttp3.CallTest.asyncLeakedResponseBodyLogsStackTrace("));
+    } finally {
+      logger.setLevel(original);
+    }
+  }
+
+  @Test public void httpsWithIpAddress() throws Exception {
+    String localIpAddress = InetAddress.getLoopbackAddress().getHostAddress();
+
+    // Create a certificate with an IP address in the subject alt name.
+    HeldCertificate heldCertificate = new HeldCertificate.Builder()
+        .commonName("example.com")
+        .subjectAlternativeName(localIpAddress)
+        .build();
+    SslClient sslClient = new SslClient.Builder()
+        .certificateChain(heldCertificate.keyPair, heldCertificate.certificate)
+        .addTrustedCertificate(heldCertificate.certificate)
+        .build();
+
+    // Use that certificate on the server and trust it on the client.
+    server.useHttps(sslClient.socketFactory, false);
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .protocols(Collections.singletonList(Protocol.HTTP_1_1))
+        .build();
+
+    // Make a request.
+    server.enqueue(new MockResponse());
+    HttpUrl url = server.url("/").newBuilder()
+        .host(localIpAddress)
+        .build();
+    Request request = new Request.Builder()
+        .url(url)
+        .build();
+    executeSynchronously(request)
+        .assertCode(200);
+
+    // Confirm that the IP address was used in the host header.
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals(localIpAddress + ":" + server.getPort(), recordedRequest.getHeader("Host"));
+  }
+
+  private void makeFailingCall() {
+    RequestBody requestBody = new RequestBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() throws IOException {
+        return 1;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        throw new IOException("write body fail!");
+      }
+    };
+    OkHttpClient nonRetryingClient = client.newBuilder()
+        .retryOnConnectionFailure(false)
+        .build();
+    Call call = nonRetryingClient.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .post(requestBody)
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("write body fail!", expected.getMessage());
+    }
+  }
+
+  private RecordedResponse executeSynchronously(String path, String... headers) throws IOException {
+    Request.Builder builder = new Request.Builder();
+    builder.url(server.url(path));
+    for (int i = 0, size = headers.length; i < size; i += 2) {
+      builder.addHeader(headers[i], headers[i + 1]);
+    }
+    return executeSynchronously(builder.build());
+  }
+
+  private RecordedResponse executeSynchronously(Request request) throws IOException {
+    Call call = client.newCall(request);
+    try {
+      Response response = call.execute();
+      String bodyString = response.body().string();
+      return new RecordedResponse(request, response, null, bodyString, null);
+    } catch (IOException e) {
+      return new RecordedResponse(request, null, null, null, e);
+    }
+  }
+
+  /**
+   * Tests that use this will fail unless boot classpath is set. Ex. {@code
+   * -Xbootclasspath/p:/tmp/alpn-boot-8.0.0.v20140317}
+   */
+  private void enableProtocol(Protocol protocol) {
+    enableTls();
+    client = client.newBuilder()
+        .protocols(Arrays.asList(protocol, Protocol.HTTP_1_1))
+        .build();
+    server.setProtocols(client.protocols());
+  }
+
+  private void enableTls() {
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+    server.useHttps(sslClient.socketFactory, false);
+  }
+
+  private Buffer gzip(String data) throws IOException {
+    Buffer result = new Buffer();
+    BufferedSink sink = Okio.buffer(new GzipSink(result));
+    sink.writeUtf8(data);
+    sink.close();
+    return result;
+  }
+
+  private void cancelLater(final Call call, final long delay) {
+    new Thread("canceler") {
+      @Override public void run() {
+        try {
+          Thread.sleep(delay);
+        } catch (InterruptedException e) {
+          throw new AssertionError();
+        }
+        call.cancel();
+      }
+    }.start();
+  }
+
+  private static class RecordingSSLSocketFactory extends DelegatingSSLSocketFactory {
+
+    private List<SSLSocket> socketsCreated = new ArrayList<>();
+
+    public RecordingSSLSocketFactory(SSLSocketFactory delegate) {
+      super(delegate);
+    }
+
+    @Override
+    protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
+      socketsCreated.add(sslSocket);
+      return sslSocket;
+    }
+
+    public List<SSLSocket> getSocketsCreated() {
+      return socketsCreated;
+    }
+  }
+
+  /**
+   * Used during tests that involve TLS connection fallback attempts. OkHttp includes the
+   * TLS_FALLBACK_SCSV cipher on fallback connections. See {@link FallbackTestClientSocketFactory}
+   * for details.
+   */
+  private FallbackTestClientSocketFactory suppressTlsFallbackClientSocketFactory() {
+    return new FallbackTestClientSocketFactory(sslClient.socketFactory);
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java b/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
new file mode 100644
index 0000000000..3c5267bcc9
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
@@ -0,0 +1,276 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.security.GeneralSecurityException;
+import java.security.cert.Certificate;
+import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.List;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.internal.platform.Platform;
+import okhttp3.internal.tls.CertificateChainCleaner;
+import okhttp3.internal.tls.HeldCertificate;
+import okhttp3.internal.tls.SslClient;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class CertificateChainCleanerTest {
+  @Test public void equalsFromCertificate() throws Exception {
+    HeldCertificate rootA = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .build();
+    HeldCertificate rootB = new HeldCertificate.Builder()
+        .serialNumber("2")
+        .build();
+    assertEquals(
+        CertificateChainCleaner.get(rootA.certificate, rootB.certificate),
+        CertificateChainCleaner.get(rootB.certificate, rootA.certificate));
+  }
+
+  @Test public void equalsFromTrustManager() throws Exception {
+    SslClient client = new SslClient.Builder().build();
+    X509TrustManager x509TrustManager = client.trustManager;
+    assertEquals(
+        CertificateChainCleaner.get(x509TrustManager),
+        CertificateChainCleaner.get(x509TrustManager));
+  }
+
+  @Test public void normalizeSingleSelfSignedCertificate() throws Exception {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .build();
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    assertEquals(list(root), cleaner.clean(list(root), "hostname"));
+  }
+
+  @Test public void normalizeUnknownSelfSignedCertificate() throws Exception {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .build();
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get();
+
+    try {
+      cleaner.clean(list(root), "hostname");
+      fail();
+    } catch (SSLPeerUnverifiedException expected) {
+    }
+  }
+
+  @Test public void orderedChainOfCertificatesWithRoot() throws Exception {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .build();
+    HeldCertificate certA = new HeldCertificate.Builder()
+        .serialNumber("2")
+        .issuedBy(root)
+        .build();
+    HeldCertificate certB = new HeldCertificate.Builder()
+        .serialNumber("3")
+        .issuedBy(certA)
+        .build();
+
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    assertEquals(list(certB, certA, root), cleaner.clean(list(certB, certA, root), "hostname"));
+  }
+
+  @Test public void orderedChainOfCertificatesWithoutRoot() throws Exception {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .build();
+    HeldCertificate certA = new HeldCertificate.Builder()
+        .serialNumber("2")
+        .issuedBy(root)
+        .build();
+    HeldCertificate certB = new HeldCertificate.Builder()
+        .serialNumber("3")
+        .issuedBy(certA)
+        .build();
+
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    assertEquals(list(certB, certA, root),
+        cleaner.clean(list(certB, certA), "hostname")); // Root is added!
+  }
+
+  @Test public void unorderedChainOfCertificatesWithRoot() throws Exception {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .build();
+    HeldCertificate certA = new HeldCertificate.Builder()
+        .serialNumber("2")
+        .issuedBy(root)
+        .build();
+    HeldCertificate certB = new HeldCertificate.Builder()
+        .serialNumber("3")
+        .issuedBy(certA)
+        .build();
+    HeldCertificate certC = new HeldCertificate.Builder()
+        .serialNumber("4")
+        .issuedBy(certB)
+        .build();
+
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    assertEquals(list(certC, certB, certA, root),
+        cleaner.clean(list(certC, certA, root, certB), "hostname"));
+  }
+
+  @Test public void unorderedChainOfCertificatesWithoutRoot() throws Exception {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .build();
+    HeldCertificate certA = new HeldCertificate.Builder()
+        .serialNumber("2")
+        .issuedBy(root)
+        .build();
+    HeldCertificate certB = new HeldCertificate.Builder()
+        .serialNumber("3")
+        .issuedBy(certA)
+        .build();
+    HeldCertificate certC = new HeldCertificate.Builder()
+        .serialNumber("4")
+        .issuedBy(certB)
+        .build();
+
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    assertEquals(list(certC, certB, certA, root),
+        cleaner.clean(list(certC, certA, certB), "hostname"));
+  }
+
+  @Test public void unrelatedCertificatesAreOmitted() throws Exception {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .build();
+    HeldCertificate certA = new HeldCertificate.Builder()
+        .serialNumber("2")
+        .issuedBy(root)
+        .build();
+    HeldCertificate certB = new HeldCertificate.Builder()
+        .serialNumber("3")
+        .issuedBy(certA)
+        .build();
+    HeldCertificate certUnnecessary = new HeldCertificate.Builder()
+        .serialNumber("4")
+        .build();
+
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    assertEquals(list(certB, certA, root),
+        cleaner.clean(list(certB, certUnnecessary, certA, root), "hostname"));
+  }
+
+  @Test public void chainGoesAllTheWayToSelfSignedRoot() throws Exception {
+    HeldCertificate selfSigned = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .build();
+    HeldCertificate trusted = new HeldCertificate.Builder()
+        .serialNumber("2")
+        .issuedBy(selfSigned)
+        .build();
+    HeldCertificate certA = new HeldCertificate.Builder()
+        .serialNumber("3")
+        .issuedBy(trusted)
+        .build();
+    HeldCertificate certB = new HeldCertificate.Builder()
+        .serialNumber("4")
+        .issuedBy(certA)
+        .build();
+
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(
+        selfSigned.certificate, trusted.certificate);
+    assertEquals(list(certB, certA, trusted, selfSigned),
+        cleaner.clean(list(certB, certA), "hostname"));
+    assertEquals(list(certB, certA, trusted, selfSigned),
+        cleaner.clean(list(certB, certA, trusted), "hostname"));
+    assertEquals(list(certB, certA, trusted, selfSigned),
+        cleaner.clean(list(certB, certA, trusted, selfSigned), "hostname"));
+  }
+
+  @Test public void trustedRootNotSelfSigned() throws Exception {
+    HeldCertificate unknownSigner = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .build();
+    HeldCertificate trusted = new HeldCertificate.Builder()
+        .issuedBy(unknownSigner)
+        .serialNumber("2")
+        .build();
+    HeldCertificate intermediateCa = new HeldCertificate.Builder()
+        .issuedBy(trusted)
+        .serialNumber("3")
+        .build();
+    HeldCertificate certificate = new HeldCertificate.Builder()
+        .issuedBy(intermediateCa)
+        .serialNumber("4")
+        .build();
+
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(trusted.certificate);
+    assertEquals(list(certificate, intermediateCa, trusted),
+        cleaner.clean(list(certificate, intermediateCa), "hostname"));
+    assertEquals(list(certificate, intermediateCa, trusted),
+        cleaner.clean(list(certificate, intermediateCa, trusted), "hostname"));
+  }
+
+  @Test public void chainMaxLength() throws Exception {
+    List<HeldCertificate> heldCertificates = chainOfLength(10);
+    List<Certificate> certificates = new ArrayList<>();
+    for (HeldCertificate heldCertificate : heldCertificates) {
+      certificates.add(heldCertificate.certificate);
+    }
+
+    X509Certificate root = heldCertificates.get(heldCertificates.size() - 1).certificate;
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root);
+    assertEquals(certificates, cleaner.clean(certificates, "hostname"));
+    assertEquals(certificates, cleaner.clean(certificates.subList(0, 9), "hostname"));
+  }
+
+  @Test public void chainTooLong() throws Exception {
+    List<HeldCertificate> heldCertificates = chainOfLength(11);
+    List<Certificate> certificates = new ArrayList<>();
+    for (HeldCertificate heldCertificate : heldCertificates) {
+      certificates.add(heldCertificate.certificate);
+    }
+
+    X509Certificate root = heldCertificates.get(heldCertificates.size() - 1).certificate;
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root);
+    try {
+      cleaner.clean(certificates, "hostname");
+      fail();
+    } catch (SSLPeerUnverifiedException expected) {
+    }
+  }
+
+  /** Returns a chain starting at the leaf certificate and progressing to the root. */
+  private List<HeldCertificate> chainOfLength(int length) throws GeneralSecurityException {
+    List<HeldCertificate> result = new ArrayList<>();
+    for (int i = 1; i <= length; i++) {
+      result.add(0, new HeldCertificate.Builder()
+          .issuedBy(!result.isEmpty() ? result.get(0) : null)
+          .serialNumber(Integer.toString(i))
+          .build());
+    }
+    return result;
+  }
+
+  private List<Certificate> list(HeldCertificate... heldCertificates) {
+    List<Certificate> result = new ArrayList<>();
+    for (HeldCertificate heldCertificate : heldCertificates) {
+      result.add(heldCertificate.certificate);
+    }
+    return result;
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java b/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
new file mode 100644
index 0000000000..0745982fb2
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
@@ -0,0 +1,306 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.security.GeneralSecurityException;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import okhttp3.CertificatePinner.Pin;
+import okhttp3.internal.tls.HeldCertificate;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class CertificatePinnerTest {
+  static HeldCertificate certA1;
+  static String certA1Sha256Pin;
+
+  static HeldCertificate certB1;
+  static String certB1Sha256Pin;
+
+  static HeldCertificate certC1;
+  static String certC1Sha256Pin;
+
+  static {
+    try {
+      certA1 = new HeldCertificate.Builder()
+          .serialNumber("100")
+          .build();
+      certA1Sha256Pin = "sha256/" + CertificatePinner.sha256(certA1.certificate).base64();
+
+      certB1 = new HeldCertificate.Builder()
+          .serialNumber("200")
+          .build();
+      certB1Sha256Pin = "sha256/" + CertificatePinner.sha256(certB1.certificate).base64();
+
+      certC1 = new HeldCertificate.Builder()
+          .serialNumber("300")
+          .build();
+      certC1Sha256Pin = "sha256/" + CertificatePinner.sha256(certC1.certificate).base64();
+    } catch (GeneralSecurityException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  @Test public void malformedPin() throws Exception {
+    CertificatePinner.Builder builder = new CertificatePinner.Builder();
+    try {
+      builder.add("example.com", "md5/DmxUShsZuNiqPQsX2Oi9uv2sCnw=");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void malformedBase64() throws Exception {
+    CertificatePinner.Builder builder = new CertificatePinner.Builder();
+    try {
+      builder.add("example.com", "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw*");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  /** Multiple certificates generated from the same keypair have the same pin. */
+  @Test public void sameKeypairSamePin() throws Exception {
+    HeldCertificate heldCertificateA2 = new HeldCertificate.Builder()
+        .keyPair(certA1.keyPair)
+        .serialNumber("101")
+        .build();
+    String keypairACertificate2Pin = CertificatePinner.pin(heldCertificateA2.certificate);
+
+    HeldCertificate heldCertificateB2 = new HeldCertificate.Builder()
+        .keyPair(certB1.keyPair)
+        .serialNumber("201")
+        .build();
+    String keypairBCertificate2Pin = CertificatePinner.pin(heldCertificateB2.certificate);
+
+    assertTrue(certA1Sha256Pin.equals(keypairACertificate2Pin));
+    assertTrue(certB1Sha256Pin.equals(keypairBCertificate2Pin));
+    assertFalse(certA1Sha256Pin.equals(certB1Sha256Pin));
+  }
+
+  @Test public void successfulCheck() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("example.com", certA1Sha256Pin)
+        .build();
+
+    certificatePinner.check("example.com", certA1.certificate);
+  }
+
+  @Test public void successfulCheckSha1Pin() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("example.com", "sha1/" + CertificatePinner.sha1(certA1.certificate).base64())
+        .build();
+
+    certificatePinner.check("example.com", certA1.certificate);
+  }
+
+  @Test public void successfulMatchAcceptsAnyMatchingCertificate() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("example.com", certB1Sha256Pin)
+        .build();
+
+    certificatePinner.check("example.com", certA1.certificate, certB1.certificate);
+  }
+
+  @Test public void unsuccessfulCheck() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("example.com", certA1Sha256Pin)
+        .build();
+
+    try {
+      certificatePinner.check("example.com", certB1.certificate);
+      fail();
+    } catch (SSLPeerUnverifiedException expected) {
+    }
+  }
+
+  @Test public void multipleCertificatesForOneHostname() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("example.com", certA1Sha256Pin, certB1Sha256Pin)
+        .build();
+
+    certificatePinner.check("example.com", certA1.certificate);
+    certificatePinner.check("example.com", certB1.certificate);
+  }
+
+  @Test public void multipleHostnamesForOneCertificate() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("example.com", certA1Sha256Pin)
+        .add("www.example.com", certA1Sha256Pin)
+        .build();
+
+    certificatePinner.check("example.com", certA1.certificate);
+    certificatePinner.check("www.example.com", certA1.certificate);
+  }
+
+  @Test public void absentHostnameMatches() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder().build();
+    certificatePinner.check("example.com", certA1.certificate);
+  }
+
+  @Test public void successfulCheckForWildcardHostname() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", certA1Sha256Pin)
+        .build();
+
+    certificatePinner.check("a.example.com", certA1.certificate);
+  }
+
+  @Test public void successfulMatchAcceptsAnyMatchingCertificateForWildcardHostname()
+      throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", certB1Sha256Pin)
+        .build();
+
+    certificatePinner.check("a.example.com", certA1.certificate, certB1.certificate);
+  }
+
+  @Test public void unsuccessfulCheckForWildcardHostname() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", certA1Sha256Pin)
+        .build();
+
+    try {
+      certificatePinner.check("a.example.com", certB1.certificate);
+      fail();
+    } catch (SSLPeerUnverifiedException expected) {
+    }
+  }
+
+  @Test public void multipleCertificatesForOneWildcardHostname() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", certA1Sha256Pin, certB1Sha256Pin)
+        .build();
+
+    certificatePinner.check("a.example.com", certA1.certificate);
+    certificatePinner.check("a.example.com", certB1.certificate);
+  }
+
+  @Test public void successfulCheckForOneHostnameWithWildcardAndDirectCertificate()
+      throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", certA1Sha256Pin)
+        .add("a.example.com", certB1Sha256Pin)
+        .build();
+
+    certificatePinner.check("a.example.com", certA1.certificate);
+    certificatePinner.check("a.example.com", certB1.certificate);
+  }
+
+  @Test public void unsuccessfulCheckForOneHostnameWithWildcardAndDirectCertificate()
+      throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", certA1Sha256Pin)
+        .add("a.example.com", certB1Sha256Pin)
+        .build();
+
+    try {
+      certificatePinner.check("a.example.com", certC1.certificate);
+      fail();
+    } catch (SSLPeerUnverifiedException expected) {
+    }
+  }
+
+  @Test public void successfulFindMatchingPins() {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("first.com", certA1Sha256Pin, certB1Sha256Pin)
+        .add("second.com", certC1Sha256Pin)
+        .build();
+
+    List<Pin> expectedPins = Arrays.asList(
+        new Pin("first.com", certA1Sha256Pin),
+        new Pin("first.com", certB1Sha256Pin));
+    assertEquals(expectedPins, certificatePinner.findMatchingPins("first.com"));
+  }
+
+  @Test public void successfulFindMatchingPinsForWildcardAndDirectCertificates() {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", certA1Sha256Pin)
+        .add("a.example.com", certB1Sha256Pin)
+        .add("b.example.com", certC1Sha256Pin)
+        .build();
+
+    List<Pin> expectedPins = Arrays.asList(
+        new Pin("*.example.com", certA1Sha256Pin),
+        new Pin("a.example.com", certB1Sha256Pin));
+    assertEquals(expectedPins, certificatePinner.findMatchingPins("a.example.com"));
+  }
+
+  @Test public void wildcardHostnameShouldNotMatchThroughDot() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", certA1Sha256Pin)
+        .build();
+
+    assertEquals(Collections.emptyList(), certificatePinner.findMatchingPins("example.com"));
+    assertEquals(Collections.emptyList(), certificatePinner.findMatchingPins("a.b.example.com"));
+  }
+
+  @Test public void successfulFindMatchingPinsIgnoresCase() {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("EXAMPLE.com", certA1Sha256Pin)
+        .add("*.MyExample.Com", certB1Sha256Pin)
+        .build();
+
+    List<Pin> expectedPin1 = Arrays.asList(new Pin("EXAMPLE.com", certA1Sha256Pin));
+    assertEquals(expectedPin1, certificatePinner.findMatchingPins("example.com"));
+
+    List<Pin> expectedPin2 = Arrays.asList(new Pin("*.MyExample.Com", certB1Sha256Pin));
+    assertEquals(expectedPin2, certificatePinner.findMatchingPins("a.myexample.com"));
+  }
+
+  @Test public void successfulFindMatchingPinPunycode() {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("σkhttp.com", certA1Sha256Pin)
+        .build();
+
+    List<Pin> expectedPin = Arrays.asList(new Pin("σkhttp.com", certA1Sha256Pin));
+    assertEquals(expectedPin, certificatePinner.findMatchingPins("xn--khttp-fde.com"));
+  }
+
+  /** https://github.com/square/okhttp/issues/3324 */
+  @Test public void checkSubstringMatch() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", certA1Sha256Pin)
+        .build();
+
+    assertEquals(Collections.emptyList(),
+        certificatePinner.findMatchingPins("a.example.com.notexample.com"));
+    assertEquals(Collections.emptyList(),
+        certificatePinner.findMatchingPins("example.com.notexample.com"));
+    assertEquals(Collections.emptyList(),
+        certificatePinner.findMatchingPins("notexample.com"));
+    assertEquals(Collections.emptyList(),
+        certificatePinner.findMatchingPins("example.com"));
+    assertEquals(Collections.emptyList(),
+        certificatePinner.findMatchingPins("a.b.example.com"));
+    assertEquals(Collections.emptyList(),
+        certificatePinner.findMatchingPins("ple.com"));
+    assertEquals(Collections.emptyList(),
+        certificatePinner.findMatchingPins("com"));
+
+    Pin expectedPin = new Pin("*.example.com", certA1Sha256Pin);
+    assertEquals(Collections.singletonList(expectedPin),
+        certificatePinner.findMatchingPins("a.example.com"));
+    assertEquals(Collections.singletonList(expectedPin),
+        certificatePinner.findMatchingPins("example.example.com"));
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/CipherSuiteTest.java b/okhttp-tests/src/test/java/okhttp3/CipherSuiteTest.java
new file mode 100644
index 0000000000..63b3023253
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/CipherSuiteTest.java
@@ -0,0 +1,220 @@
+/*
+ * Copyright (C) 2016 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import org.junit.Test;
+
+import static okhttp3.CipherSuite.TLS_KRB5_WITH_DES_CBC_MD5;
+import static okhttp3.CipherSuite.TLS_RSA_EXPORT_WITH_RC4_40_MD5;
+import static okhttp3.CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA256;
+import static okhttp3.CipherSuite.forJavaName;
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.fail;
+
+public class CipherSuiteTest {
+  @Test public void nullCipherName() {
+    try {
+      forJavaName(null);
+      fail("Should have thrown");
+    } catch (NullPointerException expected) {
+    }
+  }
+
+  @Test public void hashCode_usesIdentityHashCode_legacyCase() {
+    CipherSuite cs = TLS_RSA_EXPORT_WITH_RC4_40_MD5; // This one's javaName starts with "SSL_".
+    assertEquals(cs.toString(), System.identityHashCode(cs), cs.hashCode());
+  }
+
+  @Test public void hashCode_usesIdentityHashCode_regularCase() {
+    CipherSuite cs = TLS_RSA_WITH_AES_128_CBC_SHA256; // This one's javaName matches the identifier.
+    assertEquals(cs.toString(), System.identityHashCode(cs), cs.hashCode());
+  }
+
+  @Test public void instancesAreInterned() {
+    assertSame(forJavaName("TestCipherSuite"), forJavaName("TestCipherSuite"));
+    assertSame(CipherSuite.TLS_KRB5_WITH_DES_CBC_MD5,
+        forJavaName(TLS_KRB5_WITH_DES_CBC_MD5.javaName()));
+  }
+
+  /**
+   * Tests that interned CipherSuite instances remain the case across garbage collections, even if
+   * the String used to construct them is no longer strongly referenced outside of the CipherSuite.
+   */
+  @SuppressWarnings("RedundantStringConstructorCall")
+  @Test public void instancesAreInterned_survivesGarbageCollection() {
+    // We're not holding onto a reference to this String instance outside of the CipherSuite...
+    CipherSuite cs = forJavaName(new String("FakeCipherSuite_instancesAreInterned"));
+    System.gc(); // Unless cs references the String instance, it may now be garbage collected.
+    assertSame(cs, forJavaName(new String(cs.javaName())));
+  }
+
+  @Test public void equals() {
+    assertEquals(forJavaName("cipher"), forJavaName("cipher"));
+    assertNotEquals(forJavaName("cipherA"), forJavaName("cipherB"));
+    assertEquals(forJavaName("SSL_RSA_EXPORT_WITH_RC4_40_MD5"), TLS_RSA_EXPORT_WITH_RC4_40_MD5);
+    assertNotEquals(TLS_RSA_EXPORT_WITH_RC4_40_MD5, TLS_RSA_WITH_AES_128_CBC_SHA256);
+  }
+
+  @Test public void forJavaName_acceptsArbitraryStrings() {
+    // Shouldn't throw.
+    forJavaName("example CipherSuite name that is not in the whitelist");
+  }
+
+  @Test public void javaName_examples() {
+    assertEquals("SSL_RSA_EXPORT_WITH_RC4_40_MD5", TLS_RSA_EXPORT_WITH_RC4_40_MD5.javaName());
+    assertEquals("TLS_RSA_WITH_AES_128_CBC_SHA256", TLS_RSA_WITH_AES_128_CBC_SHA256.javaName());
+    assertEquals("TestCipherSuite", forJavaName("TestCipherSuite").javaName());
+  }
+
+  @Test public void javaName_equalsToString() {
+    assertEquals(TLS_RSA_EXPORT_WITH_RC4_40_MD5.javaName,
+        TLS_RSA_EXPORT_WITH_RC4_40_MD5.toString());
+    assertEquals(TLS_RSA_WITH_AES_128_CBC_SHA256.javaName,
+        TLS_RSA_WITH_AES_128_CBC_SHA256.toString());
+  }
+
+  /**
+   * On the Oracle JVM some older cipher suites have the "SSL_" prefix and others have the "TLS_"
+   * prefix. On the IBM JVM all cipher suites have the "SSL_" prefix.
+   *
+   * <p>Prior to OkHttp 3.3.1 we accepted either form and consider them equivalent. And since OkHttp
+   * 3.7.0 this is also true. But OkHttp 3.3.1 through 3.6.0 treated these as different.
+   */
+  @Test public void forJavaName_fromLegacyEnumName() {
+    // These would have been considered equal in OkHttp 3.3.1, but now aren't.
+    assertEquals(
+        forJavaName("TLS_RSA_EXPORT_WITH_RC4_40_MD5"),
+        forJavaName("SSL_RSA_EXPORT_WITH_RC4_40_MD5"));
+    assertEquals(
+        forJavaName("TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA"),
+        forJavaName("SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA"));
+    assertEquals(
+        forJavaName("TLS_FAKE_NEW_CIPHER"),
+        forJavaName("SSL_FAKE_NEW_CIPHER"));
+  }
+
+  @Test public void applyIntersectionRetainsSslPrefixes() throws Exception {
+    FakeSslSocket socket = new FakeSslSocket();
+    socket.setEnabledProtocols(new String[] { "TLSv1" });
+    socket.setSupportedCipherSuites(new String[] { "SSL_A", "SSL_B", "SSL_C", "SSL_D", "SSL_E" });
+    socket.setEnabledCipherSuites(new String[] { "SSL_A", "SSL_B", "SSL_C" });
+
+    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(true)
+        .tlsVersions(TlsVersion.TLS_1_0)
+        .cipherSuites("TLS_A", "TLS_C", "TLS_E")
+        .build();
+    connectionSpec.apply(socket, false);
+
+    assertArrayEquals(new String[] { "SSL_A", "SSL_C" }, socket.enabledCipherSuites);
+  }
+
+  @Test public void applyIntersectionRetainsTlsPrefixes() throws Exception {
+    FakeSslSocket socket = new FakeSslSocket();
+    socket.setEnabledProtocols(new String[] { "TLSv1" });
+    socket.setSupportedCipherSuites(new String[] { "TLS_A", "TLS_B", "TLS_C", "TLS_D", "TLS_E" });
+    socket.setEnabledCipherSuites(new String[] { "TLS_A", "TLS_B", "TLS_C" });
+
+    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(true)
+        .tlsVersions(TlsVersion.TLS_1_0)
+        .cipherSuites("SSL_A", "SSL_C", "SSL_E")
+        .build();
+    connectionSpec.apply(socket, false);
+
+    assertArrayEquals(new String[] { "TLS_A", "TLS_C" }, socket.enabledCipherSuites);
+  }
+
+  @Test public void applyIntersectionAddsSslScsvForFallback() throws Exception {
+    FakeSslSocket socket = new FakeSslSocket();
+    socket.setEnabledProtocols(new String[] { "TLSv1" });
+    socket.setSupportedCipherSuites(new String[] { "SSL_A", "SSL_FALLBACK_SCSV" });
+    socket.setEnabledCipherSuites(new String[] { "SSL_A" });
+
+    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(true)
+        .tlsVersions(TlsVersion.TLS_1_0)
+        .cipherSuites("SSL_A")
+        .build();
+    connectionSpec.apply(socket, true);
+
+    assertArrayEquals(new String[] { "SSL_A", "SSL_FALLBACK_SCSV" }, socket.enabledCipherSuites);
+  }
+
+  @Test public void applyIntersectionAddsTlsScsvForFallback() throws Exception {
+    FakeSslSocket socket = new FakeSslSocket();
+    socket.setEnabledProtocols(new String[] { "TLSv1" });
+    socket.setSupportedCipherSuites(new String[] { "TLS_A", "TLS_FALLBACK_SCSV" });
+    socket.setEnabledCipherSuites(new String[] { "TLS_A" });
+
+    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(true)
+        .tlsVersions(TlsVersion.TLS_1_0)
+        .cipherSuites("TLS_A")
+        .build();
+    connectionSpec.apply(socket, true);
+
+    assertArrayEquals(new String[] { "TLS_A", "TLS_FALLBACK_SCSV" }, socket.enabledCipherSuites);
+  }
+
+  @Test public void applyIntersectionToProtocolVersion() throws Exception {
+    FakeSslSocket socket = new FakeSslSocket();
+    socket.setEnabledProtocols(new String[] { "TLSv1", "TLSv1.1", "TLSv1.2" });
+    socket.setSupportedCipherSuites(new String[] { "TLS_A" });
+    socket.setEnabledCipherSuites(new String[] { "TLS_A" });
+
+    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(true)
+        .tlsVersions(TlsVersion.TLS_1_1, TlsVersion.TLS_1_2, TlsVersion.TLS_1_3)
+        .cipherSuites("TLS_A")
+        .build();
+    connectionSpec.apply(socket, false);
+
+    assertArrayEquals(new String[] { "TLSv1.1", "TLSv1.2" }, socket.enabledProtocols);
+  }
+
+  static final class FakeSslSocket extends DelegatingSSLSocket {
+    private String[] enabledProtocols;
+    private String[] supportedCipherSuites;
+    private String[] enabledCipherSuites;
+
+    FakeSslSocket() {
+      super(null);
+    }
+
+    @Override public String[] getEnabledProtocols() {
+      return enabledProtocols;
+    }
+
+    @Override public void setEnabledProtocols(String[] enabledProtocols) {
+      this.enabledProtocols = enabledProtocols;
+    }
+
+    @Override public String[] getSupportedCipherSuites() {
+      return supportedCipherSuites;
+    }
+
+    public void setSupportedCipherSuites(String[] supportedCipherSuites) {
+      this.supportedCipherSuites = supportedCipherSuites;
+    }
+
+    @Override public String[] getEnabledCipherSuites() {
+      return enabledCipherSuites;
+    }
+
+    @Override public void setEnabledCipherSuites(String[] enabledCipherSuites) {
+      this.enabledCipherSuites = enabledCipherSuites;
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionCoalescingTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionCoalescingTest.java
new file mode 100644
index 0000000000..684a77fa18
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/ConnectionCoalescingTest.java
@@ -0,0 +1,335 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLSession;
+import okhttp3.internal.tls.HeldCertificate;
+import okhttp3.internal.tls.SslClient;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class ConnectionCoalescingTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private OkHttpClient client;
+
+  private HeldCertificate rootCa;
+  private HeldCertificate certificate;
+  private FakeDns dns = new FakeDns();
+  private HttpUrl url;
+  private List<InetAddress> serverIps;
+
+  @Before public void setUp() throws Exception {
+    rootCa = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .ca(3)
+        .commonName("root")
+        .build();
+    certificate = new HeldCertificate.Builder()
+        .issuedBy(rootCa)
+        .serialNumber("2")
+        .commonName(server.getHostName())
+        .subjectAlternativeName(server.getHostName())
+        .subjectAlternativeName("san.com")
+        .subjectAlternativeName("*.wildcard.com")
+        .subjectAlternativeName("differentdns.com")
+        .build();
+
+    serverIps = Dns.SYSTEM.lookup(server.getHostName());
+
+    dns.set(server.getHostName(), serverIps);
+    dns.set("san.com", serverIps);
+    dns.set("nonsan.com", serverIps);
+    dns.set("www.wildcard.com", serverIps);
+    dns.set("differentdns.com", Collections.<InetAddress>emptyList());
+
+    SslClient sslClient = new SslClient.Builder()
+        .addTrustedCertificate(rootCa.certificate)
+        .build();
+
+    client = new OkHttpClient.Builder().dns(dns)
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .build();
+
+    SslClient serverSslClient = new SslClient.Builder()
+        .certificateChain(certificate, rootCa)
+        .build();
+    server.useHttps(serverSslClient.socketFactory, false);
+
+    url = server.url("/robots.txt");
+  }
+
+  /**
+   * Test connecting to the main host then an alternative, although only subject alternative names
+   * are used if present no special consideration of common name.
+   */
+  @Test public void commonThenAlternative() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(200));
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
+    assert200Http2Response(execute(sanUrl), "san.com");
+
+    assertEquals(1, client.connectionPool().connectionCount());
+  }
+
+  /**
+   * Test connecting to an alternative host then common name, although only subject alternative
+   * names are used if present no special consideration of common name.
+   */
+  @Test public void alternativeThenCommon() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(200));
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
+    assert200Http2Response(execute(sanUrl), "san.com");
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    assertEquals(1, client.connectionPool().connectionCount());
+  }
+
+  /** Test a previously coalesced connection that's no longer healthy. */
+  @Test public void staleCoalescedConnection() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(200));
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    final AtomicReference<Connection> connection = new AtomicReference<>();
+    client = client.newBuilder()
+        .addNetworkInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            connection.set(chain.connection());
+            return chain.proceed(chain.request());
+          }
+        })
+        .build();
+    dns.set("san.com", Dns.SYSTEM.lookup(server.getHostName()).subList(0, 1));
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    // Simulate a stale connection in the pool.
+    connection.get().socket().close();
+
+    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
+    assert200Http2Response(execute(sanUrl), "san.com");
+
+    assertEquals(1, client.connectionPool().connectionCount());
+  }
+
+  /** If the existing connection matches a SAN but not a match for DNS then skip. */
+  @Test public void skipsWhenDnsDontMatch() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    HttpUrl differentDnsUrl = url.newBuilder().host("differentdns.com").build();
+    try {
+      execute(differentDnsUrl);
+      fail("expected a failed attempt to connect");
+    } catch (IOException expected) {
+    }
+  }
+
+  /** Not in the certificate SAN. */
+  @Test public void skipsWhenNotSubjectAltName() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    HttpUrl nonsanUrl = url.newBuilder().host("nonsan.com").build();
+
+    try {
+      execute(nonsanUrl);
+      fail("expected a failed attempt to connect");
+    } catch (IOException expected) {
+    }
+  }
+
+  /** Can still coalesce when pinning is used if pins match. */
+  @Test public void coalescesWhenCertificatePinsMatch() throws Exception {
+    CertificatePinner pinner = new CertificatePinner.Builder()
+        .add("san.com", "sha1/" + CertificatePinner.sha1(certificate.certificate).base64())
+        .build();
+    client = client.newBuilder().certificatePinner(pinner).build();
+
+    server.enqueue(new MockResponse().setResponseCode(200));
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
+
+    assert200Http2Response(execute(sanUrl), "san.com");
+
+    assertEquals(1, client.connectionPool().connectionCount());
+  }
+
+  /** Certificate pinning used and not a match will avoid coalescing and try to connect. */
+  @Test public void skipsWhenCertificatePinningFails() throws Exception {
+    CertificatePinner pinner = new CertificatePinner.Builder()
+        .add("san.com", "sha1/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
+        .build();
+    client = client.newBuilder().certificatePinner(pinner).build();
+
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
+
+    try {
+      execute(sanUrl);
+      fail("expected a failed attempt to connect");
+    } catch (IOException expected) {
+    }
+  }
+
+  /**
+   * Skips coalescing when hostname verifier is overridden since the intention of the hostname
+   * verification is a black box.
+   */
+  @Test public void skipsWhenHostnameVerifierUsed() throws Exception {
+    HostnameVerifier verifier = new HostnameVerifier() {
+      @Override public boolean verify(String s, SSLSession sslSession) {
+        return true;
+      }
+    };
+    client = client.newBuilder().hostnameVerifier(verifier).build();
+
+    server.enqueue(new MockResponse().setResponseCode(200));
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
+
+    assert200Http2Response(execute(sanUrl), "san.com");
+
+    assertEquals(2, client.connectionPool().connectionCount());
+  }
+
+  /**
+   * Check we would use an existing connection to a later DNS result instead of connecting to the
+   * first DNS result for the first time.
+   */
+  @Test public void prefersExistingCompatible() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(200));
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    final AtomicInteger connectCount = new AtomicInteger();
+    EventListener listener = new EventListener() {
+      @Override public void connectStart(Call call, InetSocketAddress inetSocketAddress,
+          Proxy proxy) {
+        connectCount.getAndIncrement();
+      }
+    };
+    client = client.newBuilder()
+        .eventListener(listener)
+        .build();
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
+    dns.set("san.com",
+        Arrays.asList(InetAddress.getByAddress("san.com", new byte[] {0, 0, 0, 0}),
+            serverIps.get(0)));
+    assert200Http2Response(execute(sanUrl), "san.com");
+
+    assertEquals(1, client.connectionPool().connectionCount());
+    assertEquals(1, connectCount.get());
+  }
+
+  /** Check that wildcard SANs are supported. */
+  @Test public void commonThenWildcard() throws Exception {
+
+    server.enqueue(new MockResponse().setResponseCode(200));
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    HttpUrl sanUrl = url.newBuilder().host("www.wildcard.com").build();
+    assert200Http2Response(execute(sanUrl), "www.wildcard.com");
+
+    assertEquals(1, client.connectionPool().connectionCount());
+  }
+
+  /** Network interceptors check for changes to target. */
+  @Test public void worksWithNetworkInterceptors() throws Exception {
+    client = client.newBuilder().addNetworkInterceptor(new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        return chain.proceed(chain.request());
+      }
+    }).build();
+
+    server.enqueue(new MockResponse().setResponseCode(200));
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
+    assert200Http2Response(execute(sanUrl), "san.com");
+
+    assertEquals(1, client.connectionPool().connectionCount());
+  }
+
+  /** Run against public external sites, doesn't run by default. */
+  @Ignore
+  @Test public void coalescesConnectionsToRealSites() throws IOException {
+    client = new OkHttpClient();
+
+    assert200Http2Response(execute("https://graph.facebook.com/robots.txt"), "graph.facebook.com");
+    assert200Http2Response(execute("https://www.facebook.com/robots.txt"), "m.facebook.com");
+    assert200Http2Response(execute("https://fb.com/robots.txt"), "m.facebook.com");
+    assert200Http2Response(execute("https://messenger.com/robots.txt"), "messenger.com");
+    assert200Http2Response(execute("https://m.facebook.com/robots.txt"), "m.facebook.com");
+
+    assertEquals(3, client.connectionPool().connectionCount());
+  }
+
+  private Response execute(String url) throws IOException {
+    return execute(HttpUrl.parse(url));
+  }
+
+  private Response execute(HttpUrl url) throws IOException {
+    return client.newCall(new Request.Builder().url(url).build()).execute();
+  }
+
+  private void assert200Http2Response(Response response, String expectedHost) {
+    assertEquals(200, response.code());
+    assertEquals(expectedHost, response.request().url().host());
+    assertEquals(Protocol.HTTP_2, response.protocol());
+    response.body().close();
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java
new file mode 100644
index 0000000000..ae8b0a2f6c
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java
@@ -0,0 +1,205 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.net.ProxySelector;
+import java.net.Socket;
+import java.util.Collections;
+import java.util.concurrent.TimeUnit;
+import javax.net.SocketFactory;
+import okhttp3.internal.Internal;
+import okhttp3.internal.RecordingOkAuthenticator;
+import okhttp3.internal.connection.RealConnection;
+import okhttp3.internal.connection.StreamAllocation;
+import org.junit.Test;
+
+import static okhttp3.TestUtil.awaitGarbageCollection;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public final class ConnectionPoolTest {
+  private final Address addressA = newAddress("a");
+  private final Route routeA1 = newRoute(addressA);
+  private final Address addressB = newAddress("b");
+  private final Route routeB1 = newRoute(addressB);
+  private final Address addressC = newAddress("c");
+  private final Route routeC1 = newRoute(addressC);
+
+  static {
+    Internal.initializeInstanceForTests();
+  }
+
+  @Test public void connectionsEvictedWhenIdleLongEnough() throws Exception {
+    ConnectionPool pool = new ConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
+    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
+
+    RealConnection c1 = newConnection(pool, routeA1, 50L);
+
+    // Running at time 50, the pool returns that nothing can be evicted until time 150.
+    assertEquals(100L, pool.cleanup(50L));
+    assertEquals(1, pool.connectionCount());
+    assertFalse(c1.socket().isClosed());
+
+    // Running at time 60, the pool returns that nothing can be evicted until time 150.
+    assertEquals(90L, pool.cleanup(60L));
+    assertEquals(1, pool.connectionCount());
+    assertFalse(c1.socket().isClosed());
+
+    // Running at time 149, the pool returns that nothing can be evicted until time 150.
+    assertEquals(1L, pool.cleanup(149L));
+    assertEquals(1, pool.connectionCount());
+    assertFalse(c1.socket().isClosed());
+
+    // Running at time 150, the pool evicts.
+    assertEquals(0, pool.cleanup(150L));
+    assertEquals(0, pool.connectionCount());
+    assertTrue(c1.socket().isClosed());
+
+    // Running again, the pool reports that no further runs are necessary.
+    assertEquals(-1, pool.cleanup(150L));
+    assertEquals(0, pool.connectionCount());
+    assertTrue(c1.socket().isClosed());
+  }
+
+  @Test public void inUseConnectionsNotEvicted() throws Exception {
+    ConnectionPool pool = new ConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
+    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
+
+    RealConnection c1 = newConnection(pool, routeA1, 50L);
+    synchronized (pool) {
+      StreamAllocation streamAllocation = new StreamAllocation(pool, addressA, null,
+          EventListener.NONE, null);
+      streamAllocation.acquire(c1, true);
+    }
+
+    // Running at time 50, the pool returns that nothing can be evicted until time 150.
+    assertEquals(100L, pool.cleanup(50L));
+    assertEquals(1, pool.connectionCount());
+    assertFalse(c1.socket().isClosed());
+
+    // Running at time 60, the pool returns that nothing can be evicted until time 160.
+    assertEquals(100L, pool.cleanup(60L));
+    assertEquals(1, pool.connectionCount());
+    assertFalse(c1.socket().isClosed());
+
+    // Running at time 160, the pool returns that nothing can be evicted until time 260.
+    assertEquals(100L, pool.cleanup(160L));
+    assertEquals(1, pool.connectionCount());
+    assertFalse(c1.socket().isClosed());
+  }
+
+  @Test public void cleanupPrioritizesEarliestEviction() throws Exception {
+    ConnectionPool pool = new ConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
+    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
+
+    RealConnection c1 = newConnection(pool, routeA1, 75L);
+    RealConnection c2 = newConnection(pool, routeB1, 50L);
+
+    // Running at time 75, the pool returns that nothing can be evicted until time 150.
+    assertEquals(75L, pool.cleanup(75L));
+    assertEquals(2, pool.connectionCount());
+
+    // Running at time 149, the pool returns that nothing can be evicted until time 150.
+    assertEquals(1L, pool.cleanup(149L));
+    assertEquals(2, pool.connectionCount());
+
+    // Running at time 150, the pool evicts c2.
+    assertEquals(0L, pool.cleanup(150L));
+    assertEquals(1, pool.connectionCount());
+    assertFalse(c1.socket().isClosed());
+    assertTrue(c2.socket().isClosed());
+
+    // Running at time 150, the pool returns that nothing can be evicted until time 175.
+    assertEquals(25L, pool.cleanup(150L));
+    assertEquals(1, pool.connectionCount());
+
+    // Running at time 175, the pool evicts c1.
+    assertEquals(0L, pool.cleanup(175L));
+    assertEquals(0, pool.connectionCount());
+    assertTrue(c1.socket().isClosed());
+    assertTrue(c2.socket().isClosed());
+  }
+
+  @Test public void oldestConnectionsEvictedIfIdleLimitExceeded() throws Exception {
+    ConnectionPool pool = new ConnectionPool(2, 100L, TimeUnit.NANOSECONDS);
+    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
+
+    RealConnection c1 = newConnection(pool, routeA1, 50L);
+    RealConnection c2 = newConnection(pool, routeB1, 75L);
+
+    // With 2 connections, there's no need to evict until the connections time out.
+    assertEquals(50L, pool.cleanup(100L));
+    assertEquals(2, pool.connectionCount());
+    assertFalse(c1.socket().isClosed());
+    assertFalse(c2.socket().isClosed());
+
+    // Add a third connection
+    RealConnection c3 = newConnection(pool, routeC1, 75L);
+
+    // The third connection bounces the first.
+    assertEquals(0L, pool.cleanup(100L));
+    assertEquals(2, pool.connectionCount());
+    assertTrue(c1.socket().isClosed());
+    assertFalse(c2.socket().isClosed());
+    assertFalse(c3.socket().isClosed());
+  }
+
+  @Test public void leakedAllocation() throws Exception {
+    ConnectionPool pool = new ConnectionPool(2, 100L, TimeUnit.NANOSECONDS);
+    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
+
+    RealConnection c1 = newConnection(pool, routeA1, 0L);
+    allocateAndLeakAllocation(pool, c1);
+
+    awaitGarbageCollection();
+    assertEquals(0L, pool.cleanup(100L));
+    assertEquals(Collections.emptyList(), c1.allocations);
+
+    assertTrue(c1.noNewStreams); // Can't allocate once a leak has been detected.
+  }
+
+  /** Use a helper method so there's no hidden reference remaining on the stack. */
+  private void allocateAndLeakAllocation(ConnectionPool pool, RealConnection connection) {
+    synchronized (pool) {
+      StreamAllocation leak = new StreamAllocation(pool, connection.route().address(), null,
+          EventListener.NONE, null);
+      leak.acquire(connection, true);
+    }
+  }
+
+  private RealConnection newConnection(ConnectionPool pool, Route route, long idleAtNanos) {
+    RealConnection result = RealConnection.testConnection(pool, route, new Socket(), idleAtNanos);
+    synchronized (pool) {
+      pool.put(result);
+    }
+    return result;
+  }
+
+  private Address newAddress(String name) {
+    return new Address(name, 1, Dns.SYSTEM, SocketFactory.getDefault(), null, null, null,
+        new RecordingOkAuthenticator("password"), null, Collections.<Protocol>emptyList(),
+        Collections.<ConnectionSpec>emptyList(),
+        ProxySelector.getDefault());
+  }
+
+  private Route newRoute(Address address) {
+    return new Route(address, Proxy.NO_PROXY,
+        InetSocketAddress.createUnresolved(address.url().host(), address.url().port()));
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java
new file mode 100644
index 0000000000..533d8ab352
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java
@@ -0,0 +1,365 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
+import javax.net.ssl.SSLException;
+import okhttp3.internal.tls.SslClient;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.SocketPolicy;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import org.junit.rules.Timeout;
+
+import static okhttp3.TestUtil.defaultClient;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class ConnectionReuseTest {
+  @Rule public final TestRule timeout = new Timeout(30_000);
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private SslClient sslClient = SslClient.localhost();
+  private OkHttpClient client = defaultClient();
+
+  @Test public void connectionsAreReused() throws Exception {
+    server.enqueue(new MockResponse().setBody("a"));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    assertConnectionReused(request, request);
+  }
+
+  @Test public void connectionsAreReusedWithHttp2() throws Exception {
+    enableHttp2();
+    server.enqueue(new MockResponse().setBody("a"));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    assertConnectionReused(request, request);
+  }
+
+  @Test public void connectionsAreNotReusedWithRequestConnectionClose() throws Exception {
+    server.enqueue(new MockResponse().setBody("a"));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    Request requestA = new Request.Builder()
+        .url(server.url("/"))
+        .header("Connection", "close")
+        .build();
+    Request requestB = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    assertConnectionNotReused(requestA, requestB);
+  }
+
+  @Test public void connectionsAreNotReusedWithResponseConnectionClose() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Connection", "close")
+        .setBody("a"));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    Request requestA = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Request requestB = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    assertConnectionNotReused(requestA, requestB);
+  }
+
+  @Test public void connectionsAreNotReusedWithUnknownLengthResponseBody() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("a")
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .clearHeaders());
+    server.enqueue(new MockResponse().setBody("b"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    assertConnectionNotReused(request, request);
+  }
+
+  @Test public void connectionsAreNotReusedIfPoolIsSizeZero() throws Exception {
+    client = client.newBuilder()
+        .connectionPool(new ConnectionPool(0, 5, TimeUnit.SECONDS))
+        .build();
+    server.enqueue(new MockResponse().setBody("a"));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    assertConnectionNotReused(request, request);
+  }
+
+  @Test public void connectionsReusedWithRedirectEvenIfPoolIsSizeZero() throws Exception {
+    client = client.newBuilder()
+        .connectionPool(new ConnectionPool(0, 5, TimeUnit.SECONDS))
+        .build();
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location: /b")
+        .setBody("a"));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("b", response.body().string());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void connectionsNotReusedWithRedirectIfDiscardingResponseIsSlow() throws Exception {
+    client = client.newBuilder()
+        .connectionPool(new ConnectionPool(0, 5, TimeUnit.SECONDS))
+        .build();
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location: /b")
+        .setBodyDelay(1, TimeUnit.SECONDS)
+        .setBody("a"));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("b", response.body().string());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void silentRetryWhenIdempotentRequestFailsOnReusedConnection() throws Exception {
+    server.enqueue(new MockResponse().setBody("a"));
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Response responseA = client.newCall(request).execute();
+    assertEquals("a", responseA.body().string());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+
+    Response responseB = client.newCall(request).execute();
+    assertEquals("b", responseB.body().string());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void staleConnectionNotReusedForNonIdempotentRequest() throws Exception {
+    server.enqueue(new MockResponse().setBody("a")
+        .setSocketPolicy(SocketPolicy.SHUTDOWN_OUTPUT_AT_END));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    Request requestA = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Response responseA = client.newCall(requestA).execute();
+    assertEquals("a", responseA.body().string());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+
+    // Give the socket a chance to become stale.
+    Thread.sleep(250);
+
+    Request requestB = new Request.Builder()
+        .url(server.url("/"))
+        .post(RequestBody.create(MediaType.parse("text/plain"), "b"))
+        .build();
+    Response responseB = client.newCall(requestB).execute();
+    assertEquals("b", responseB.body().string());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void http2ConnectionsAreSharedBeforeResponseIsConsumed() throws Exception {
+    enableHttp2();
+    server.enqueue(new MockResponse().setBody("a"));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Response response1 = client.newCall(request).execute();
+    Response response2 = client.newCall(request).execute();
+    response1.body().string(); // Discard the response body.
+    response2.body().string(); // Discard the response body.
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void connectionsAreEvicted() throws Exception {
+    server.enqueue(new MockResponse().setBody("a"));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    client = client.newBuilder()
+        .connectionPool(new ConnectionPool(5, 250, TimeUnit.MILLISECONDS))
+        .build();
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Response response1 = client.newCall(request).execute();
+    assertEquals("a", response1.body().string());
+
+    // Give the thread pool a chance to evict.
+    Thread.sleep(500);
+
+    Response response2 = client.newCall(request).execute();
+    assertEquals("b", response2.body().string());
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void connectionsAreNotReusedIfSslSocketFactoryChanges() throws Exception {
+    enableHttps();
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Response response = client.newCall(request).execute();
+    response.body().close();
+
+    // This client shares a connection pool but has a different SSL socket factory.
+    SslClient sslClient2 = new SslClient.Builder().build();
+    OkHttpClient anotherClient = client.newBuilder()
+        .sslSocketFactory(sslClient2.socketFactory, sslClient2.trustManager)
+        .build();
+
+    // This client fails to connect because the new SSL socket factory refuses.
+    try {
+      anotherClient.newCall(request).execute();
+      fail();
+    } catch (SSLException expected) {
+    }
+  }
+
+  @Test public void connectionsAreNotReusedIfHostnameVerifierChanges() throws Exception {
+    enableHttps();
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Response response1 = client.newCall(request).execute();
+    response1.body().close();
+
+    // This client shares a connection pool but has a different SSL socket factory.
+    OkHttpClient anotherClient = client.newBuilder()
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+
+    Response response2 = anotherClient.newCall(request).execute();
+    response2.body().close();
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+  }
+
+  /**
+   * Regression test for an edge case where closing response body in the HTTP engine doesn't release
+   * the corresponding stream allocation. This test keeps those response bodies alive and reads
+   * them after the redirect has completed. This forces a connection to not be reused where it would
+   * be otherwise.
+   *
+   * <p>This test leaks a response body by not closing it.
+   *
+   * https://github.com/square/okhttp/issues/2409
+   */
+  @Test public void connectionsAreNotReusedIfNetworkInterceptorInterferes() throws Exception {
+    client = client.newBuilder().addNetworkInterceptor(new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        Response response = chain.proceed(chain.request());
+        return response.newBuilder()
+            .body(ResponseBody.create(null, "unrelated response body!"))
+            .build();
+      }
+    }).build();
+
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location: /b")
+        .setBody("/a has moved!"));
+    server.enqueue(new MockResponse()
+        .setBody("/b is here"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Call call = client.newCall(request);
+    try {
+      call.execute();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertTrue(expected.getMessage().startsWith("Closing the body of"));
+    }
+  }
+
+  private void enableHttps() {
+    enableHttpsAndAlpn(Protocol.HTTP_1_1);
+  }
+
+  private void enableHttp2() {
+    enableHttpsAndAlpn(Protocol.HTTP_2, Protocol.HTTP_1_1);
+  }
+
+  private void enableHttpsAndAlpn(Protocol... protocols) {
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .protocols(Arrays.asList(protocols))
+        .build();
+    server.useHttps(sslClient.socketFactory, false);
+    server.setProtocols(client.protocols());
+  }
+
+  private void assertConnectionReused(Request... requests) throws Exception {
+    for (int i = 0; i < requests.length; i++) {
+      Response response = client.newCall(requests[i]).execute();
+      response.body().string(); // Discard the response body.
+      assertEquals(i, server.takeRequest().getSequenceNumber());
+    }
+  }
+
+  private void assertConnectionNotReused(Request... requests) throws Exception {
+    for (Request request : requests) {
+      Response response = client.newCall(request).execute();
+      response.body().string(); // Discard the response body.
+      assertEquals(0, server.takeRequest().getSequenceNumber());
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionSpecTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionSpecTest.java
new file mode 100644
index 0000000000..c74a6b314c
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/ConnectionSpecTest.java
@@ -0,0 +1,303 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.util.Arrays;
+import java.util.LinkedHashSet;
+import java.util.Set;
+import java.util.concurrent.CopyOnWriteArraySet;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class ConnectionSpecTest {
+  @Test public void noTlsVersions() throws Exception {
+    try {
+      new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+          .tlsVersions(new TlsVersion[0])
+          .build();
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals("At least one TLS version is required", expected.getMessage());
+    }
+  }
+
+  @Test public void noCipherSuites() throws Exception {
+    try {
+      new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+          .cipherSuites(new CipherSuite[0])
+          .build();
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals("At least one cipher suite is required", expected.getMessage());
+    }
+  }
+
+  @Test public void cleartextBuilder() throws Exception {
+    ConnectionSpec cleartextSpec = new ConnectionSpec.Builder(false).build();
+    assertFalse(cleartextSpec.isTls());
+  }
+
+  @Test public void tlsBuilder_explicitCiphers() throws Exception {
+    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
+        .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
+        .tlsVersions(TlsVersion.TLS_1_2)
+        .supportsTlsExtensions(true)
+        .build();
+    assertEquals(Arrays.asList(CipherSuite.TLS_RSA_WITH_RC4_128_MD5), tlsSpec.cipherSuites());
+    assertEquals(Arrays.asList(TlsVersion.TLS_1_2), tlsSpec.tlsVersions());
+    assertTrue(tlsSpec.supportsTlsExtensions());
+  }
+
+  @Test public void tlsBuilder_defaultCiphers() throws Exception {
+    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
+        .tlsVersions(TlsVersion.TLS_1_2)
+        .supportsTlsExtensions(true)
+        .build();
+    assertNull(tlsSpec.cipherSuites());
+    assertEquals(Arrays.asList(TlsVersion.TLS_1_2), tlsSpec.tlsVersions());
+    assertTrue(tlsSpec.supportsTlsExtensions());
+  }
+
+  @Test public void tls_defaultCiphers_noFallbackIndicator() throws Exception {
+    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
+        .tlsVersions(TlsVersion.TLS_1_2)
+        .supportsTlsExtensions(false)
+        .build();
+
+    SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
+    socket.setEnabledCipherSuites(new String[] {
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
+    });
+    socket.setEnabledProtocols(new String[] {
+        TlsVersion.TLS_1_2.javaName,
+        TlsVersion.TLS_1_1.javaName,
+    });
+
+    assertTrue(tlsSpec.isCompatible(socket));
+    tlsSpec.apply(socket, false /* isFallback */);
+
+    assertEquals(set(TlsVersion.TLS_1_2.javaName), set(socket.getEnabledProtocols()));
+
+    Set<String> expectedCipherSet =
+        set(
+            CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
+            CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName);
+    assertEquals(expectedCipherSet, expectedCipherSet);
+  }
+
+  @Test public void tls_defaultCiphers_withFallbackIndicator() throws Exception {
+    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
+        .tlsVersions(TlsVersion.TLS_1_2)
+        .supportsTlsExtensions(false)
+        .build();
+
+    SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
+    socket.setEnabledCipherSuites(new String[] {
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
+    });
+    socket.setEnabledProtocols(new String[] {
+        TlsVersion.TLS_1_2.javaName,
+        TlsVersion.TLS_1_1.javaName,
+    });
+
+    assertTrue(tlsSpec.isCompatible(socket));
+    tlsSpec.apply(socket, true /* isFallback */);
+
+    assertEquals(set(TlsVersion.TLS_1_2.javaName), set(socket.getEnabledProtocols()));
+
+    Set<String> expectedCipherSet =
+        set(
+            CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
+            CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName);
+    if (Arrays.asList(socket.getSupportedCipherSuites()).contains("TLS_FALLBACK_SCSV")) {
+      expectedCipherSet.add("TLS_FALLBACK_SCSV");
+    }
+    assertEquals(expectedCipherSet, expectedCipherSet);
+  }
+
+  @Test public void tls_explicitCiphers() throws Exception {
+    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
+        .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
+        .tlsVersions(TlsVersion.TLS_1_2)
+        .supportsTlsExtensions(false)
+        .build();
+
+    SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
+    socket.setEnabledCipherSuites(new String[] {
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
+    });
+    socket.setEnabledProtocols(new String[] {
+        TlsVersion.TLS_1_2.javaName,
+        TlsVersion.TLS_1_1.javaName,
+    });
+
+    assertTrue(tlsSpec.isCompatible(socket));
+    tlsSpec.apply(socket, true /* isFallback */);
+
+    assertEquals(set(TlsVersion.TLS_1_2.javaName), set(socket.getEnabledProtocols()));
+
+    Set<String> expectedCipherSet = set(CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName);
+    if (Arrays.asList(socket.getSupportedCipherSuites()).contains("TLS_FALLBACK_SCSV")) {
+      expectedCipherSet.add("TLS_FALLBACK_SCSV");
+    }
+    assertEquals(expectedCipherSet, expectedCipherSet);
+  }
+
+  @Test public void tls_stringCiphersAndVersions() throws Exception {
+    // Supporting arbitrary input strings allows users to enable suites and versions that are not
+    // yet known to the library, but are supported by the platform.
+    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+        .cipherSuites("MAGIC-CIPHER")
+        .tlsVersions("TLS9k")
+        .build();
+  }
+
+  @Test public void tls_missingRequiredCipher() throws Exception {
+    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
+        .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
+        .tlsVersions(TlsVersion.TLS_1_2)
+        .supportsTlsExtensions(false)
+        .build();
+
+    SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
+    socket.setEnabledProtocols(new String[] {
+        TlsVersion.TLS_1_2.javaName,
+        TlsVersion.TLS_1_1.javaName,
+    });
+
+    socket.setEnabledCipherSuites(new String[] {
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
+    });
+    assertTrue(tlsSpec.isCompatible(socket));
+
+    socket.setEnabledCipherSuites(new String[] {
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
+    });
+    assertFalse(tlsSpec.isCompatible(socket));
+  }
+
+  @Test public void allEnabledCipherSuites() throws Exception {
+    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+        .allEnabledCipherSuites()
+        .build();
+    assertNull(tlsSpec.cipherSuites());
+
+    SSLSocket sslSocket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
+    sslSocket.setEnabledCipherSuites(new String[] {
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
+    });
+
+    tlsSpec.apply(sslSocket, false);
+    assertEquals(Arrays.asList(
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName),
+        Arrays.asList(sslSocket.getEnabledCipherSuites()));
+  }
+
+  @Test public void allEnabledTlsVersions() throws Exception {
+    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+        .allEnabledTlsVersions()
+        .build();
+    assertNull(tlsSpec.tlsVersions());
+
+    SSLSocket sslSocket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
+    sslSocket.setEnabledProtocols(new String[] {
+        TlsVersion.SSL_3_0.javaName(),
+        TlsVersion.TLS_1_1.javaName()
+    });
+
+    tlsSpec.apply(sslSocket, false);
+    assertEquals(Arrays.asList(TlsVersion.SSL_3_0.javaName(), TlsVersion.TLS_1_1.javaName()),
+        Arrays.asList(sslSocket.getEnabledProtocols()));
+  }
+
+  @Test public void tls_missingTlsVersion() throws Exception {
+    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
+        .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
+        .tlsVersions(TlsVersion.TLS_1_2)
+        .supportsTlsExtensions(false)
+        .build();
+
+    SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
+    socket.setEnabledCipherSuites(new String[] {
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
+    });
+
+    socket.setEnabledProtocols(
+        new String[] {TlsVersion.TLS_1_2.javaName, TlsVersion.TLS_1_1.javaName});
+    assertTrue(tlsSpec.isCompatible(socket));
+
+    socket.setEnabledProtocols(new String[] {TlsVersion.TLS_1_1.javaName});
+    assertFalse(tlsSpec.isCompatible(socket));
+  }
+
+  @Test public void equalsAndHashCode() throws Exception {
+    ConnectionSpec allCipherSuites = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+        .allEnabledCipherSuites()
+        .build();
+    ConnectionSpec allTlsVersions = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+        .allEnabledTlsVersions()
+        .build();
+
+    Set<Object> set = new CopyOnWriteArraySet<>();
+    assertTrue(set.add(ConnectionSpec.MODERN_TLS));
+    assertTrue(set.add(ConnectionSpec.COMPATIBLE_TLS));
+    assertTrue(set.add(ConnectionSpec.CLEARTEXT));
+    assertTrue(set.add(allTlsVersions));
+    assertTrue(set.add(allCipherSuites));
+
+    assertTrue(set.remove(ConnectionSpec.MODERN_TLS));
+    assertTrue(set.remove(ConnectionSpec.COMPATIBLE_TLS));
+    assertTrue(set.remove(ConnectionSpec.CLEARTEXT));
+    assertTrue(set.remove(allTlsVersions));
+    assertTrue(set.remove(allCipherSuites));
+    assertTrue(set.isEmpty());
+  }
+
+  @Test public void allEnabledToString() throws Exception {
+    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+        .allEnabledTlsVersions()
+        .allEnabledCipherSuites()
+        .build();
+    assertEquals("ConnectionSpec(cipherSuites=[all enabled], tlsVersions=[all enabled], "
+        + "supportsTlsExtensions=true)", connectionSpec.toString());
+  }
+
+  @Test public void simpleToString() throws Exception {
+    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+        .tlsVersions(TlsVersion.TLS_1_2)
+        .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
+        .build();
+    assertEquals("ConnectionSpec(cipherSuites=[SSL_RSA_WITH_RC4_128_MD5], tlsVersions=[TLS_1_2], "
+        + "supportsTlsExtensions=true)", connectionSpec.toString());
+  }
+
+  private static <T> Set<T> set(T... values) {
+    return new LinkedHashSet<>(Arrays.asList(values));
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/CookieTest.java b/okhttp-tests/src/test/java/okhttp3/CookieTest.java
new file mode 100644
index 0000000000..12f543fac0
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/CookieTest.java
@@ -0,0 +1,579 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.List;
+import java.util.Objects;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.HttpDate;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class CookieTest {
+  HttpUrl url = HttpUrl.parse("https://example.com/");
+
+  @Test public void simpleCookie() throws Exception {
+    Cookie cookie = Cookie.parse(url, "SID=31d4d96e407aad42");
+    assertEquals("SID=31d4d96e407aad42; path=/", cookie.toString());
+  }
+
+  @Test public void noEqualsSign() throws Exception {
+    assertNull(Cookie.parse(url, "foo"));
+    assertNull(Cookie.parse(url, "foo; Path=/"));
+  }
+
+  @Test public void emptyName() throws Exception {
+    assertNull(Cookie.parse(url, "=b"));
+    assertNull(Cookie.parse(url, " =b"));
+    assertNull(Cookie.parse(url, "\r\t \n=b"));
+  }
+
+  @Test public void spaceInName() throws Exception {
+    assertEquals("a b", Cookie.parse(url, "a b=cd").name());
+  }
+
+  @Test public void spaceInValue() throws Exception {
+    assertEquals("c d", Cookie.parse(url, "ab=c d").value());
+  }
+
+  @Test public void trimLeadingAndTrailingWhitespaceFromName() throws Exception {
+    assertEquals("a", Cookie.parse(url, " a=b").name());
+    assertEquals("a", Cookie.parse(url, "a =b").name());
+    assertEquals("a", Cookie.parse(url, "\r\t \na\n\t \n=b").name());
+  }
+
+  @Test public void emptyValue() throws Exception {
+    assertEquals("", Cookie.parse(url, "a=").value());
+    assertEquals("", Cookie.parse(url, "a= ").value());
+    assertEquals("", Cookie.parse(url, "a=\r\t \n").value());
+  }
+
+  @Test public void trimLeadingAndTrailingWhitespaceFromValue() throws Exception {
+    assertEquals("", Cookie.parse(url, "a= ").value());
+    assertEquals("b", Cookie.parse(url, "a= b").value());
+    assertEquals("b", Cookie.parse(url, "a=b ").value());
+    assertEquals("b", Cookie.parse(url, "a=\r\t \nb\n\t \n").value());
+  }
+
+  @Test public void invalidCharacters() throws Exception {
+    assertEquals(null, Cookie.parse(url, "a\u0000b=cd"));
+    assertEquals(null, Cookie.parse(url, "ab=c\u0000d"));
+    assertEquals(null, Cookie.parse(url, "a\u0001b=cd"));
+    assertEquals(null, Cookie.parse(url, "ab=c\u0001d"));
+    assertEquals(null, Cookie.parse(url, "a\u0009b=cd"));
+    assertEquals(null, Cookie.parse(url, "ab=c\u0009d"));
+    assertEquals(null, Cookie.parse(url, "a\u001fb=cd"));
+    assertEquals(null, Cookie.parse(url, "ab=c\u001fd"));
+    assertEquals(null, Cookie.parse(url, "a\u007fb=cd"));
+    assertEquals(null, Cookie.parse(url, "ab=c\u007fd"));
+    assertEquals(null, Cookie.parse(url, "a\u0080b=cd"));
+    assertEquals(null, Cookie.parse(url, "ab=c\u0080d"));
+    assertEquals(null, Cookie.parse(url, "a\u00ffb=cd"));
+    assertEquals(null, Cookie.parse(url, "ab=c\u00ffd"));
+  }
+
+  @Test public void maxAge() throws Exception {
+    assertEquals(51000L,
+        Cookie.parse(50000L, url, "a=b; Max-Age=1").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(50000L, url, "a=b; Max-Age=9223372036854724").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(50000L, url, "a=b; Max-Age=9223372036854725").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(50000L, url, "a=b; Max-Age=9223372036854726").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(9223372036854773807L, url, "a=b; Max-Age=1").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(9223372036854773807L, url, "a=b; Max-Age=2").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(9223372036854773807L, url, "a=b; Max-Age=3").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(50000L, url, "a=b; Max-Age=10000000000000000000").expiresAt());
+  }
+
+  @Test public void maxAgeNonPositive() throws Exception {
+    assertEquals(Long.MIN_VALUE,
+        Cookie.parse(50000L, url, "a=b; Max-Age=-1").expiresAt());
+    assertEquals(Long.MIN_VALUE,
+        Cookie.parse(50000L, url, "a=b; Max-Age=0").expiresAt());
+    assertEquals(Long.MIN_VALUE,
+        Cookie.parse(50000L, url, "a=b; Max-Age=-9223372036854775808").expiresAt());
+    assertEquals(Long.MIN_VALUE,
+        Cookie.parse(50000L, url, "a=b; Max-Age=-9223372036854775809").expiresAt());
+    assertEquals(Long.MIN_VALUE,
+        Cookie.parse(50000L, url, "a=b; Max-Age=-10000000000000000000").expiresAt());
+  }
+
+  @Test public void domainAndPath() throws Exception {
+    Cookie cookie = Cookie.parse(url, "SID=31d4d96e407aad42; Path=/; Domain=example.com");
+    assertEquals("example.com", cookie.domain());
+    assertEquals("/", cookie.path());
+    assertFalse(cookie.hostOnly());
+    assertEquals("SID=31d4d96e407aad42; domain=example.com; path=/", cookie.toString());
+  }
+
+  @Test public void secureAndHttpOnly() throws Exception {
+    Cookie cookie = Cookie.parse(url, "SID=31d4d96e407aad42; Path=/; Secure; HttpOnly");
+    assertTrue(cookie.secure());
+    assertTrue(cookie.httpOnly());
+    assertEquals("SID=31d4d96e407aad42; path=/; secure; httponly", cookie.toString());
+  }
+
+  @Test public void expiresDate() throws Exception {
+    assertEquals(date("1970-01-01T00:00:00.000+0000"), new Date(
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:00:00 GMT").expiresAt()));
+    assertEquals(date("2021-06-09T10:18:14.000+0000"), new Date(
+        Cookie.parse(url, "a=b; Expires=Wed, 09 Jun 2021 10:18:14 GMT").expiresAt()));
+    assertEquals(date("1994-11-06T08:49:37.000+0000"), new Date(
+        Cookie.parse(url, "a=b; Expires=Sun, 06 Nov 1994 08:49:37 GMT").expiresAt()));
+  }
+
+  @Test public void awkwardDates() throws Exception {
+    assertEquals(0L,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 70 00:00:00 GMT").expiresAt());
+    assertEquals(0L,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 January 1970 00:00:00 GMT").expiresAt());
+    assertEquals(0L,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Janucember 1970 00:00:00 GMT").expiresAt());
+    assertEquals(0L,
+        Cookie.parse(url, "a=b; Expires=Thu, 1 Jan 1970 00:00:00 GMT").expiresAt());
+    assertEquals(0L,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 0:00:00 GMT").expiresAt());
+    assertEquals(0L,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:0:00 GMT").expiresAt());
+    assertEquals(0L,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:00:0 GMT").expiresAt());
+    assertEquals(0L,
+        Cookie.parse(url, "a=b; Expires=00:00:00 Thu, 01 Jan 1970 GMT").expiresAt());
+    assertEquals(0L,
+        Cookie.parse(url, "a=b; Expires=00:00:00 1970 Jan 01").expiresAt());
+    assertEquals(0L,
+        Cookie.parse(url, "a=b; Expires=00:00:00 1970 Jan 1").expiresAt());
+  }
+
+  @Test public void invalidYear() throws Exception {
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1600 00:00:00 GMT").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 19999 00:00:00 GMT").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 00:00:00 GMT").expiresAt());
+  }
+
+  @Test public void invalidMonth() throws Exception {
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Foo 1970 00:00:00 GMT").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Foocember 1970 00:00:00 GMT").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 1970 00:00:00 GMT").expiresAt());
+  }
+
+  @Test public void invalidDayOfMonth() throws Exception {
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, 32 Jan 1970 00:00:00 GMT").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, Jan 1970 00:00:00 GMT").expiresAt());
+  }
+
+  @Test public void invalidHour() throws Exception {
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 24:00:00 GMT").expiresAt());
+  }
+
+  @Test public void invalidMinute() throws Exception {
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:60:00 GMT").expiresAt());
+  }
+
+  @Test public void invalidSecond() throws Exception {
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:00:60 GMT").expiresAt());
+  }
+
+  @Test public void domainMatches() throws Exception {
+    Cookie cookie = Cookie.parse(url, "a=b; domain=example.com");
+    assertTrue(cookie.matches(HttpUrl.parse("http://example.com")));
+    assertTrue(cookie.matches(HttpUrl.parse("http://www.example.com")));
+    assertFalse(cookie.matches(HttpUrl.parse("http://square.com")));
+  }
+
+  /** If no domain is present, match only the origin domain. */
+  @Test public void domainMatchesNoDomain() throws Exception {
+    Cookie cookie = Cookie.parse(url, "a=b");
+    assertTrue(cookie.matches(HttpUrl.parse("http://example.com")));
+    assertFalse(cookie.matches(HttpUrl.parse("http://www.example.com")));
+    assertFalse(cookie.matches(HttpUrl.parse("http://square.com")));
+  }
+
+  /** Ignore an optional leading `.` in the domain. */
+  @Test public void domainMatchesIgnoresLeadingDot() throws Exception {
+    Cookie cookie = Cookie.parse(url, "a=b; domain=.example.com");
+    assertTrue(cookie.matches(HttpUrl.parse("http://example.com")));
+    assertTrue(cookie.matches(HttpUrl.parse("http://www.example.com")));
+    assertFalse(cookie.matches(HttpUrl.parse("http://square.com")));
+  }
+
+  /** Ignore the entire attribute if the domain ends with `.`. */
+  @Test public void domainIgnoredWithTrailingDot() throws Exception {
+    Cookie cookie = Cookie.parse(url, "a=b; domain=example.com.");
+    assertTrue(cookie.matches(HttpUrl.parse("http://example.com")));
+    assertFalse(cookie.matches(HttpUrl.parse("http://www.example.com")));
+    assertFalse(cookie.matches(HttpUrl.parse("http://square.com")));
+  }
+
+  @Test public void idnDomainMatches() throws Exception {
+    Cookie cookie = Cookie.parse(HttpUrl.parse("http://☃.net/"), "a=b; domain=☃.net");
+    assertTrue(cookie.matches(HttpUrl.parse("http://☃.net/")));
+    assertTrue(cookie.matches(HttpUrl.parse("http://xn--n3h.net/")));
+    assertTrue(cookie.matches(HttpUrl.parse("http://www.☃.net/")));
+    assertTrue(cookie.matches(HttpUrl.parse("http://www.xn--n3h.net/")));
+  }
+
+  @Test public void punycodeDomainMatches() throws Exception {
+    Cookie cookie = Cookie.parse(HttpUrl.parse("http://xn--n3h.net/"), "a=b; domain=xn--n3h.net");
+    assertTrue(cookie.matches(HttpUrl.parse("http://☃.net/")));
+    assertTrue(cookie.matches(HttpUrl.parse("http://xn--n3h.net/")));
+    assertTrue(cookie.matches(HttpUrl.parse("http://www.☃.net/")));
+    assertTrue(cookie.matches(HttpUrl.parse("http://www.xn--n3h.net/")));
+  }
+
+  @Test public void domainMatchesIpAddress() throws Exception {
+    HttpUrl urlWithIp = HttpUrl.parse("http://123.45.234.56/");
+    assertNull(Cookie.parse(urlWithIp, "a=b; domain=234.56"));
+    assertEquals("123.45.234.56", Cookie.parse(urlWithIp, "a=b; domain=123.45.234.56").domain());
+  }
+
+  @Test public void domainMatchesIpv6Address() throws Exception {
+    Cookie cookie = Cookie.parse(HttpUrl.parse("http://[::1]/"), "a=b; domain=::1");
+    assertEquals("::1", cookie.domain());
+    assertTrue(cookie.matches(HttpUrl.parse("http://[::1]/")));
+  }
+
+  @Test public void domainMatchesIpv6AddressWithCompression() throws Exception {
+    Cookie cookie = Cookie.parse(HttpUrl.parse("http://[0001:0000::]/"), "a=b; domain=0001:0000::");
+    assertEquals("1::", cookie.domain());
+    assertTrue(cookie.matches(HttpUrl.parse("http://[1::]/")));
+  }
+
+  @Test public void domainMatchesIpv6AddressWithIpv4Suffix() throws Exception {
+    Cookie cookie = Cookie.parse(
+        HttpUrl.parse("http://[::1:ffff:ffff]/"), "a=b; domain=::1:255.255.255.255");
+    assertEquals("::1:ffff:ffff", cookie.domain());
+    assertTrue(cookie.matches(HttpUrl.parse("http://[::1:ffff:ffff]/")));
+  }
+
+  @Test public void ipv6AddressDoesntMatch() throws Exception {
+    Cookie cookie = Cookie.parse(HttpUrl.parse("http://[::1]/"), "a=b; domain=::2");
+    assertNull(cookie);
+  }
+
+  @Test public void ipv6AddressMalformed() throws Exception {
+    Cookie cookie = Cookie.parse(HttpUrl.parse("http://[::1]/"), "a=b; domain=::2::2");
+    assertEquals("::1", cookie.domain());
+  }
+
+  /**
+   * These public suffixes were selected by inspecting the publicsuffix.org list. It's possible they
+   * may change in the future. If this test begins to fail, please double check they are still
+   * present in the public suffix list.
+   */
+  @Test public void domainIsPublicSuffix() {
+    HttpUrl ascii = HttpUrl.parse("https://foo1.foo.bar.elb.amazonaws.com");
+    assertNotNull(Cookie.parse(ascii, "a=b; domain=foo.bar.elb.amazonaws.com"));
+    assertNull(Cookie.parse(ascii, "a=b; domain=bar.elb.amazonaws.com"));
+    assertNull(Cookie.parse(ascii, "a=b; domain=com"));
+
+    HttpUrl unicode = HttpUrl.parse("https://長.長.長崎.jp");
+    assertNotNull(Cookie.parse(unicode, "a=b; domain=長.長崎.jp"));
+    assertNull(Cookie.parse(unicode, "a=b; domain=長崎.jp"));
+
+    HttpUrl punycode = HttpUrl.parse("https://xn--ue5a.xn--ue5a.xn--8ltr62k.jp");
+    assertNotNull(Cookie.parse(punycode, "a=b; domain=xn--ue5a.xn--8ltr62k.jp"));
+    assertNull(Cookie.parse(punycode, "a=b; domain=xn--8ltr62k.jp"));
+  }
+
+  @Test public void hostOnly() throws Exception {
+    assertTrue(Cookie.parse(url, "a=b").hostOnly());
+    assertFalse(Cookie.parse(url, "a=b; domain=example.com").hostOnly());
+  }
+
+  @Test public void defaultPath() throws Exception {
+    assertEquals("/foo", Cookie.parse(HttpUrl.parse("http://example.com/foo/bar"), "a=b").path());
+    assertEquals("/foo", Cookie.parse(HttpUrl.parse("http://example.com/foo/"), "a=b").path());
+    assertEquals("/", Cookie.parse(HttpUrl.parse("http://example.com/foo"), "a=b").path());
+    assertEquals("/", Cookie.parse(HttpUrl.parse("http://example.com/"), "a=b").path());
+  }
+
+  @Test public void defaultPathIsUsedIfPathDoesntHaveLeadingSlash() throws Exception {
+    assertEquals("/foo", Cookie.parse(HttpUrl.parse("http://example.com/foo/bar"),
+        "a=b; path=quux").path());
+    assertEquals("/foo", Cookie.parse(HttpUrl.parse("http://example.com/foo/bar"),
+        "a=b; path=").path());
+  }
+
+  @Test public void pathAttributeDoesntNeedToMatch() throws Exception {
+    assertEquals("/quux", Cookie.parse(HttpUrl.parse("http://example.com/"),
+        "a=b; path=/quux").path());
+    assertEquals("/quux", Cookie.parse(HttpUrl.parse("http://example.com/foo/bar"),
+        "a=b; path=/quux").path());
+  }
+
+  @Test public void httpOnly() throws Exception {
+    assertFalse(Cookie.parse(url, "a=b").httpOnly());
+    assertTrue(Cookie.parse(url, "a=b; HttpOnly").httpOnly());
+  }
+
+  @Test public void secure() throws Exception {
+    assertFalse(Cookie.parse(url, "a=b").secure());
+    assertTrue(Cookie.parse(url, "a=b; Secure").secure());
+  }
+
+  @Test public void maxAgeTakesPrecedenceOverExpires() throws Exception {
+    // Max-Age = 1, Expires = 2. In either order.
+    assertEquals(1000L, Cookie.parse(
+        0L, url, "a=b; Max-Age=1; Expires=Thu, 01 Jan 1970 00:00:02 GMT").expiresAt());
+    assertEquals(1000L, Cookie.parse(
+        0L, url, "a=b; Expires=Thu, 01 Jan 1970 00:00:02 GMT; Max-Age=1").expiresAt());
+    // Max-Age = 2, Expires = 1. In either order.
+    assertEquals(2000L, Cookie.parse(
+        0L, url, "a=b; Max-Age=2; Expires=Thu, 01 Jan 1970 00:00:01 GMT").expiresAt());
+    assertEquals(2000L, Cookie.parse(
+        0L, url, "a=b; Expires=Thu, 01 Jan 1970 00:00:01 GMT; Max-Age=2").expiresAt());
+  }
+
+  /** If a cookie incorrectly defines multiple 'Max-Age' attributes, the last one defined wins. */
+  @Test public void lastMaxAgeWins() throws Exception {
+    assertEquals(3000L, Cookie.parse(
+        0L, url, "a=b; Max-Age=2; Max-Age=4; Max-Age=1; Max-Age=3").expiresAt());
+  }
+
+  /** If a cookie incorrectly defines multiple 'Expires' attributes, the last one defined wins. */
+  @Test public void lastExpiresAtWins() throws Exception {
+    assertEquals(3000L, Cookie.parse(0L, url, "a=b; "
+        + "Expires=Thu, 01 Jan 1970 00:00:02 GMT; "
+        + "Expires=Thu, 01 Jan 1970 00:00:04 GMT; "
+        + "Expires=Thu, 01 Jan 1970 00:00:01 GMT; "
+        + "Expires=Thu, 01 Jan 1970 00:00:03 GMT").expiresAt());
+  }
+
+  @Test public void maxAgeOrExpiresMakesCookiePersistent() throws Exception {
+    assertFalse(Cookie.parse(0L, url, "a=b").persistent());
+    assertTrue(Cookie.parse(0L, url, "a=b; Max-Age=1").persistent());
+    assertTrue(Cookie.parse(0L, url, "a=b; Expires=Thu, 01 Jan 1970 00:00:01 GMT").persistent());
+  }
+
+  @Test public void parseAll() throws Exception {
+    Headers headers = new Headers.Builder()
+        .add("Set-Cookie: a=b")
+        .add("Set-Cookie: c=d")
+        .build();
+    List<Cookie> cookies = Cookie.parseAll(url, headers);
+    assertEquals(2, cookies.size());
+    assertEquals("a=b; path=/", cookies.get(0).toString());
+    assertEquals("c=d; path=/", cookies.get(1).toString());
+  }
+
+  @Test public void builder() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .domain("example.com")
+        .build();
+    assertEquals("a", cookie.name());
+    assertEquals("b", cookie.value());
+    assertEquals(HttpDate.MAX_DATE, cookie.expiresAt());
+    assertEquals("example.com", cookie.domain());
+    assertEquals("/", cookie.path());
+    assertFalse(cookie.secure());
+    assertFalse(cookie.httpOnly());
+    assertFalse(cookie.persistent());
+    assertFalse(cookie.hostOnly());
+  }
+
+  @Test public void builderNameValidation() throws Exception {
+    try {
+      new Cookie.Builder().name(null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+    try {
+      new Cookie.Builder().name(" a ");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void builderValueValidation() throws Exception {
+    try {
+      new Cookie.Builder().value(null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+    try {
+      new Cookie.Builder().value(" b ");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void builderClampsMaxDate() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("example.com")
+        .expiresAt(Long.MAX_VALUE)
+        .build();
+    assertEquals("a=b; expires=Fri, 31 Dec 9999 23:59:59 GMT; path=/", cookie.toString());
+  }
+
+  @Test public void builderExpiresAt() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("example.com")
+        .expiresAt(date("1970-01-01T00:00:01.000+0000").getTime())
+        .build();
+    assertEquals("a=b; expires=Thu, 01 Jan 1970 00:00:01 GMT; path=/", cookie.toString());
+  }
+
+  @Test public void builderClampsMinDate() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("example.com")
+        .expiresAt(date("1970-01-01T00:00:00.000+0000").getTime())
+        .build();
+    assertEquals("a=b; max-age=0; path=/", cookie.toString());
+  }
+
+  @Test public void builderDomainValidation() throws Exception {
+    try {
+      new Cookie.Builder().hostOnlyDomain(null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+    try {
+      new Cookie.Builder().hostOnlyDomain("a/b");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void builderDomain() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("squareup.com")
+        .build();
+    assertEquals("squareup.com", cookie.domain());
+    assertTrue(cookie.hostOnly());
+  }
+
+  @Test public void builderPath() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("example.com")
+        .path("/foo")
+        .build();
+    assertEquals("/foo", cookie.path());
+  }
+
+  @Test public void builderPathValidation() throws Exception {
+    try {
+      new Cookie.Builder().path(null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+    try {
+      new Cookie.Builder().path("foo");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void builderSecure() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("example.com")
+        .secure()
+        .build();
+    assertEquals(true, cookie.secure());
+  }
+
+  @Test public void builderHttpOnly() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("example.com")
+        .httpOnly()
+        .build();
+    assertEquals(true, cookie.httpOnly());
+  }
+
+  @Test public void builderIpv6() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .domain("0:0:0:0:0:0:0:1")
+        .build();
+    assertEquals("::1", cookie.domain());
+  }
+
+  @Test public void equalsAndHashCode() throws Exception {
+    List<String> cookieStrings = Arrays.asList(
+        "a=b; Path=/c; Domain=example.com; Max-Age=5; Secure; HttpOnly",
+        "a= ; Path=/c; Domain=example.com; Max-Age=5; Secure; HttpOnly",
+        "a=b;          Domain=example.com; Max-Age=5; Secure; HttpOnly",
+        "a=b; Path=/c;                     Max-Age=5; Secure; HttpOnly",
+        "a=b; Path=/c; Domain=example.com;            Secure; HttpOnly",
+        "a=b; Path=/c; Domain=example.com; Max-Age=5;         HttpOnly",
+        "a=b; Path=/c; Domain=example.com; Max-Age=5; Secure;         "
+    );
+    for (String stringA : cookieStrings) {
+      Cookie cookieA = Cookie.parse(0, url, stringA);
+      for (String stringB : cookieStrings) {
+        Cookie cookieB = Cookie.parse(0, url, stringB);
+        if (Objects.equals(stringA, stringB)) {
+          assertEquals(cookieA.hashCode(), cookieB.hashCode());
+          assertEquals(cookieA, cookieB);
+        } else {
+          assertFalse(cookieA.hashCode() == cookieB.hashCode());
+          assertFalse(cookieA.equals(cookieB));
+        }
+      }
+      assertFalse(cookieA.equals(null));
+    }
+  }
+
+  private Date date(String s) throws ParseException {
+    SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ");
+    format.setTimeZone(Util.UTC);
+    return format.parse(s);
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/CookiesTest.java b/okhttp-tests/src/test/java/okhttp3/CookiesTest.java
new file mode 100644
index 0000000000..ab2a955273
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/CookiesTest.java
@@ -0,0 +1,341 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package okhttp3;
+
+import java.io.IOException;
+import java.net.CookieHandler;
+import java.net.CookieManager;
+import java.net.HttpCookie;
+import java.net.HttpURLConnection;
+import java.net.InetAddress;
+import java.net.URI;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import org.junit.Test;
+
+import static java.net.CookiePolicy.ACCEPT_ORIGINAL_SERVER;
+import static okhttp3.TestUtil.defaultClient;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+/** Derived from Android's CookiesTest. */
+public class CookiesTest {
+  private OkHttpClient client = defaultClient();
+
+  @Test
+  public void testNetscapeResponse() throws Exception {
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    client = client.newBuilder()
+        .cookieJar(new JavaNetCookieJar(cookieManager))
+        .build();
+    MockWebServer server = new MockWebServer();
+    server.start();
+
+    HttpUrl urlWithIpAddress = urlWithIpAddress(server, "/path/foo");
+    server.enqueue(new MockResponse().addHeader("Set-Cookie: a=android; "
+        + "expires=Fri, 31-Dec-9999 23:59:59 GMT; "
+        + "path=/path; "
+        + "domain=" + urlWithIpAddress.host() + "; "
+        + "secure"));
+    get(urlWithIpAddress);
+
+    List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
+    assertEquals(1, cookies.size());
+    HttpCookie cookie = cookies.get(0);
+    assertEquals("a", cookie.getName());
+    assertEquals("android", cookie.getValue());
+    assertEquals(null, cookie.getComment());
+    assertEquals(null, cookie.getCommentURL());
+    assertEquals(false, cookie.getDiscard());
+    assertTrue(cookie.getMaxAge() > 100000000000L);
+    assertEquals("/path", cookie.getPath());
+    assertEquals(true, cookie.getSecure());
+    assertEquals(0, cookie.getVersion());
+  }
+
+  @Test public void testRfc2109Response() throws Exception {
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    client = client.newBuilder()
+        .cookieJar(new JavaNetCookieJar(cookieManager))
+        .build();
+    MockWebServer server = new MockWebServer();
+    server.start();
+
+    HttpUrl urlWithIpAddress = urlWithIpAddress(server, "/path/foo");
+    server.enqueue(new MockResponse().addHeader("Set-Cookie: a=android; "
+        + "Comment=this cookie is delicious; "
+        + "Domain=" + urlWithIpAddress.host() + "; "
+        + "Max-Age=60; "
+        + "Path=/path; "
+        + "Secure; "
+        + "Version=1"));
+    get(urlWithIpAddress);
+
+    List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
+    assertEquals(1, cookies.size());
+    HttpCookie cookie = cookies.get(0);
+    assertEquals("a", cookie.getName());
+    assertEquals("android", cookie.getValue());
+    assertEquals(null, cookie.getCommentURL());
+    assertEquals(false, cookie.getDiscard());
+    assertEquals(60.0, cookie.getMaxAge(), 1.0); // Converting to a fixed date can cause rounding!
+    assertEquals("/path", cookie.getPath());
+    assertEquals(true, cookie.getSecure());
+  }
+
+  @Test public void testQuotedAttributeValues() throws Exception {
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    client = client.newBuilder()
+        .cookieJar(new JavaNetCookieJar(cookieManager))
+        .build();
+    MockWebServer server = new MockWebServer();
+    server.start();
+
+    HttpUrl urlWithIpAddress = urlWithIpAddress(server, "/path/foo");
+    server.enqueue(new MockResponse().addHeader("Set-Cookie: a=\"android\"; "
+        + "Comment=\"this cookie is delicious\"; "
+        + "CommentURL=\"http://google.com/\"; "
+        + "Discard; "
+        + "Domain=" + urlWithIpAddress.host() + "; "
+        + "Max-Age=60; "
+        + "Path=\"/path\"; "
+        + "Port=\"80,443," + server.getPort() + "\"; "
+        + "Secure; "
+        + "Version=\"1\""));
+    get(urlWithIpAddress);
+
+    List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
+    assertEquals(1, cookies.size());
+    HttpCookie cookie = cookies.get(0);
+    assertEquals("a", cookie.getName());
+    assertEquals("android", cookie.getValue());
+    assertEquals(60.0, cookie.getMaxAge(), 1.0); // Converting to a fixed date can cause rounding!
+    assertEquals("/path", cookie.getPath());
+    assertEquals(true, cookie.getSecure());
+  }
+
+  @Test public void testSendingCookiesFromStore() throws Exception {
+    MockWebServer server = new MockWebServer();
+    server.enqueue(new MockResponse());
+    server.start();
+    HttpUrl serverUrl = urlWithIpAddress(server, "/");
+
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    HttpCookie cookieA = new HttpCookie("a", "android");
+    cookieA.setDomain(serverUrl.host());
+    cookieA.setPath("/");
+    cookieManager.getCookieStore().add(serverUrl.uri(), cookieA);
+    HttpCookie cookieB = new HttpCookie("b", "banana");
+    cookieB.setDomain(serverUrl.host());
+    cookieB.setPath("/");
+    cookieManager.getCookieStore().add(serverUrl.uri(), cookieB);
+    client = client.newBuilder()
+        .cookieJar(new JavaNetCookieJar(cookieManager))
+        .build();
+
+    get(serverUrl);
+    RecordedRequest request = server.takeRequest();
+
+    assertEquals("a=android; b=banana", request.getHeader("Cookie"));
+  }
+
+  @Test public void cookieHandlerLikeAndroid() throws Exception {
+    final MockWebServer server = new MockWebServer();
+    server.enqueue(new MockResponse());
+    server.start();
+    final HttpUrl serverUrl = urlWithIpAddress(server, "/");
+
+    CookieHandler androidCookieHandler = new CookieHandler() {
+      @Override public Map<String, List<String>> get(URI uri, Map<String, List<String>> map)
+          throws IOException {
+        return Collections.singletonMap("Cookie", Collections.singletonList("$Version=\"1\"; "
+            + "a=\"android\";$Path=\"/\";$Domain=\"" + serverUrl.host() + "\"; "
+            + "b=\"banana\";$Path=\"/\";$Domain=\"" + serverUrl.host() + "\""));
+      }
+
+      @Override public void put(URI uri, Map<String, List<String>> map) throws IOException {
+      }
+    };
+
+    client = client.newBuilder()
+        .cookieJar(new JavaNetCookieJar(androidCookieHandler))
+        .build();
+
+    get(serverUrl);
+    RecordedRequest request = server.takeRequest();
+
+    assertEquals("a=android; b=banana", request.getHeader("Cookie"));
+  }
+
+  @Test public void receiveAndSendMultipleCookies() throws Exception {
+    MockWebServer server = new MockWebServer();
+    server.enqueue(new MockResponse()
+        .addHeader("Set-Cookie", "a=android")
+        .addHeader("Set-Cookie", "b=banana"));
+    server.enqueue(new MockResponse());
+    server.start();
+
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    client = client.newBuilder()
+        .cookieJar(new JavaNetCookieJar(cookieManager))
+        .build();
+
+    get(urlWithIpAddress(server, "/"));
+    RecordedRequest request1 = server.takeRequest();
+    assertNull(request1.getHeader("Cookie"));
+
+    get(urlWithIpAddress(server, "/"));
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals("a=android; b=banana", request2.getHeader("Cookie"));
+  }
+
+  @Test public void testRedirectsDoNotIncludeTooManyCookies() throws Exception {
+    MockWebServer redirectTarget = new MockWebServer();
+    redirectTarget.enqueue(new MockResponse().setBody("A"));
+    redirectTarget.start();
+    HttpUrl redirectTargetUrl = urlWithIpAddress(redirectTarget, "/");
+
+    MockWebServer redirectSource = new MockWebServer();
+    redirectSource.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: " + redirectTargetUrl));
+    redirectSource.start();
+    HttpUrl redirectSourceUrl = urlWithIpAddress(redirectSource, "/");
+
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    HttpCookie cookie = new HttpCookie("c", "cookie");
+    cookie.setDomain(redirectSourceUrl.host());
+    cookie.setPath("/");
+    String portList = Integer.toString(redirectSource.getPort());
+    cookie.setPortlist(portList);
+    cookieManager.getCookieStore().add(redirectSourceUrl.uri(), cookie);
+    client = client.newBuilder()
+        .cookieJar(new JavaNetCookieJar(cookieManager))
+        .build();
+
+    get(redirectSourceUrl);
+    RecordedRequest request = redirectSource.takeRequest();
+
+    assertEquals("c=cookie", request.getHeader("Cookie"));
+
+    for (String header : redirectTarget.takeRequest().getHeaders().names()) {
+      if (header.startsWith("Cookie")) {
+        fail(header);
+      }
+    }
+  }
+
+  @Test public void testCookiesSentIgnoresCase() throws Exception {
+    client = client.newBuilder()
+        .cookieJar(new JavaNetCookieJar(new CookieManager() {
+          @Override public Map<String, List<String>> get(URI uri,
+              Map<String, List<String>> requestHeaders) throws IOException {
+            Map<String, List<String>> result = new LinkedHashMap<>();
+            result.put("COOKIE", Collections.singletonList("Bar=bar"));
+            result.put("cooKIE2", Collections.singletonList("Baz=baz"));
+            return result;
+          }
+        }))
+        .build();
+
+    MockWebServer server = new MockWebServer();
+    server.enqueue(new MockResponse());
+    server.start();
+
+    get(server.url("/"));
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("Bar=bar; Baz=baz", request.getHeader("Cookie"));
+    assertNull(request.getHeader("Cookie2"));
+    assertNull(request.getHeader("Quux"));
+  }
+
+  @Test public void acceptOriginalServerMatchesSubdomain() throws Exception {
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
+
+    HttpUrl url = HttpUrl.parse("https://www.squareup.com/");
+    cookieJar.saveFromResponse(url, Arrays.asList(
+        Cookie.parse(url, "a=android; Domain=squareup.com")));
+    List<Cookie> actualCookies = cookieJar.loadForRequest(url);
+    assertEquals(1, actualCookies.size());
+    assertEquals("a", actualCookies.get(0).name());
+    assertEquals("android", actualCookies.get(0).value());
+  }
+
+  @Test public void acceptOriginalServerMatchesRfc2965Dot() throws Exception {
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
+
+    HttpUrl url = HttpUrl.parse("https://www.squareup.com/");
+    cookieJar.saveFromResponse(url, Arrays.asList(
+        Cookie.parse(url, "a=android; Domain=.squareup.com")));
+    List<Cookie> actualCookies = cookieJar.loadForRequest(url);
+    assertEquals(1, actualCookies.size());
+    assertEquals("a", actualCookies.get(0).name());
+    assertEquals("android", actualCookies.get(0).value());
+  }
+
+  @Test public void acceptOriginalServerMatchesExactly() throws Exception {
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
+
+    HttpUrl url = HttpUrl.parse("https://squareup.com/");
+    cookieJar.saveFromResponse(url, Arrays.asList(
+        Cookie.parse(url, "a=android; Domain=squareup.com")));
+    List<Cookie> actualCookies = cookieJar.loadForRequest(url);
+    assertEquals(1, actualCookies.size());
+    assertEquals("a", actualCookies.get(0).name());
+    assertEquals("android", actualCookies.get(0).value());
+  }
+
+  @Test public void acceptOriginalServerDoesNotMatchDifferentServer() throws Exception {
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
+
+    HttpUrl url1 = HttpUrl.parse("https://api.squareup.com/");
+    cookieJar.saveFromResponse(url1, Arrays.asList(
+        Cookie.parse(url1, "a=android; Domain=api.squareup.com")));
+
+    HttpUrl url2 = HttpUrl.parse("https://www.squareup.com/");
+    List<Cookie> actualCookies = cookieJar.loadForRequest(url2);
+    assertEquals(Collections.<Cookie>emptyList(), actualCookies);
+  }
+
+  private HttpUrl urlWithIpAddress(MockWebServer server, String path) throws Exception {
+    return server.url(path)
+        .newBuilder()
+        .host(InetAddress.getByName(server.getHostName()).getHostAddress())
+        .build();
+  }
+
+  private void get(HttpUrl url) throws Exception {
+    Call call = client.newCall(new Request.Builder()
+        .url(url)
+        .build());
+    Response response = call.execute();
+    response.body().close();
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocket.java b/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocket.java
new file mode 100644
index 0000000000..fc863c2022
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocket.java
@@ -0,0 +1,338 @@
+/*
+ * Copyright 2014 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.lang.reflect.InvocationTargetException;
+import java.net.InetAddress;
+import java.net.Socket;
+import java.net.SocketAddress;
+import java.net.SocketException;
+import java.net.SocketOption;
+import java.nio.channels.SocketChannel;
+import java.util.Set;
+import javax.net.ssl.HandshakeCompletedListener;
+import javax.net.ssl.SSLParameters;
+import javax.net.ssl.SSLSession;
+import javax.net.ssl.SSLSocket;
+
+/**
+ * An {@link javax.net.ssl.SSLSocket} that delegates all calls.
+ */
+public abstract class DelegatingSSLSocket extends SSLSocket {
+  protected final SSLSocket delegate;
+
+  public DelegatingSSLSocket(SSLSocket delegate) {
+    this.delegate = delegate;
+  }
+
+  @Override public void shutdownInput() throws IOException {
+    delegate.shutdownInput();
+  }
+
+  @Override public void shutdownOutput() throws IOException {
+    delegate.shutdownOutput();
+  }
+
+  @Override public String[] getSupportedCipherSuites() {
+    return delegate.getSupportedCipherSuites();
+  }
+
+  @Override public String[] getEnabledCipherSuites() {
+    return delegate.getEnabledCipherSuites();
+  }
+
+  @Override public void setEnabledCipherSuites(String[] suites) {
+    delegate.setEnabledCipherSuites(suites);
+  }
+
+  @Override public String[] getSupportedProtocols() {
+    return delegate.getSupportedProtocols();
+  }
+
+  @Override public String[] getEnabledProtocols() {
+    return delegate.getEnabledProtocols();
+  }
+
+  @Override public void setEnabledProtocols(String[] protocols) {
+    delegate.setEnabledProtocols(protocols);
+  }
+
+  @Override public SSLSession getSession() {
+    return delegate.getSession();
+  }
+
+  @Override public void addHandshakeCompletedListener(HandshakeCompletedListener listener) {
+    delegate.addHandshakeCompletedListener(listener);
+  }
+
+  @Override public void removeHandshakeCompletedListener(HandshakeCompletedListener listener) {
+    delegate.removeHandshakeCompletedListener(listener);
+  }
+
+  @Override public void startHandshake() throws IOException {
+    delegate.startHandshake();
+  }
+
+  @Override public void setUseClientMode(boolean mode) {
+    delegate.setUseClientMode(mode);
+  }
+
+  @Override public boolean getUseClientMode() {
+    return delegate.getUseClientMode();
+  }
+
+  @Override public void setNeedClientAuth(boolean need) {
+    delegate.setNeedClientAuth(need);
+  }
+
+  @Override public void setWantClientAuth(boolean want) {
+    delegate.setWantClientAuth(want);
+  }
+
+  @Override public boolean getNeedClientAuth() {
+    return delegate.getNeedClientAuth();
+  }
+
+  @Override public boolean getWantClientAuth() {
+    return delegate.getWantClientAuth();
+  }
+
+  @Override public void setEnableSessionCreation(boolean flag) {
+    delegate.setEnableSessionCreation(flag);
+  }
+
+  @Override public boolean getEnableSessionCreation() {
+    return delegate.getEnableSessionCreation();
+  }
+
+  @Override public SSLParameters getSSLParameters() {
+    return delegate.getSSLParameters();
+  }
+
+  @Override public void setSSLParameters(SSLParameters p) {
+    delegate.setSSLParameters(p);
+  }
+
+  @Override public void close() throws IOException {
+    delegate.close();
+  }
+
+  @Override public InetAddress getInetAddress() {
+    return delegate.getInetAddress();
+  }
+
+  @Override public InputStream getInputStream() throws IOException {
+    return delegate.getInputStream();
+  }
+
+  @Override public boolean getKeepAlive() throws SocketException {
+    return delegate.getKeepAlive();
+  }
+
+  @Override public InetAddress getLocalAddress() {
+    return delegate.getLocalAddress();
+  }
+
+  @Override public int getLocalPort() {
+    return delegate.getLocalPort();
+  }
+
+  @Override public OutputStream getOutputStream() throws IOException {
+    return delegate.getOutputStream();
+  }
+
+  @Override public int getPort() {
+    return delegate.getPort();
+  }
+
+  @Override public int getSoLinger() throws SocketException {
+    return delegate.getSoLinger();
+  }
+
+  @Override public int getReceiveBufferSize() throws SocketException {
+    return delegate.getReceiveBufferSize();
+  }
+
+  @Override public int getSendBufferSize() throws SocketException {
+    return delegate.getSendBufferSize();
+  }
+
+  @Override public int getSoTimeout() throws SocketException {
+    return delegate.getSoTimeout();
+  }
+
+  @Override public boolean getTcpNoDelay() throws SocketException {
+    return delegate.getTcpNoDelay();
+  }
+
+  @Override public void setKeepAlive(boolean keepAlive) throws SocketException {
+    delegate.setKeepAlive(keepAlive);
+  }
+
+  @Override public void setSendBufferSize(int size) throws SocketException {
+    delegate.setSendBufferSize(size);
+  }
+
+  @Override public void setReceiveBufferSize(int size) throws SocketException {
+    delegate.setReceiveBufferSize(size);
+  }
+
+  @Override public void setSoLinger(boolean on, int timeout) throws SocketException {
+    delegate.setSoLinger(on, timeout);
+  }
+
+  @Override public void setSoTimeout(int timeout) throws SocketException {
+    delegate.setSoTimeout(timeout);
+  }
+
+  @Override public void setTcpNoDelay(boolean on) throws SocketException {
+    delegate.setTcpNoDelay(on);
+  }
+
+  @Override public String toString() {
+    return delegate.toString();
+  }
+
+  @Override public SocketAddress getLocalSocketAddress() {
+    return delegate.getLocalSocketAddress();
+  }
+
+  @Override public SocketAddress getRemoteSocketAddress() {
+    return delegate.getRemoteSocketAddress();
+  }
+
+  @Override public boolean isBound() {
+    return delegate.isBound();
+  }
+
+  @Override public boolean isConnected() {
+    return delegate.isConnected();
+  }
+
+  @Override public boolean isClosed() {
+    return delegate.isClosed();
+  }
+
+  @Override public void bind(SocketAddress localAddr) throws IOException {
+    delegate.bind(localAddr);
+  }
+
+  @Override public void connect(SocketAddress remoteAddr) throws IOException {
+    delegate.connect(remoteAddr);
+  }
+
+  @Override public void connect(SocketAddress remoteAddr, int timeout) throws IOException {
+    delegate.connect(remoteAddr, timeout);
+  }
+
+  @Override public boolean isInputShutdown() {
+    return delegate.isInputShutdown();
+  }
+
+  @Override public boolean isOutputShutdown() {
+    return delegate.isOutputShutdown();
+  }
+
+  @Override public void setReuseAddress(boolean reuse) throws SocketException {
+    delegate.setReuseAddress(reuse);
+  }
+
+  @Override public boolean getReuseAddress() throws SocketException {
+    return delegate.getReuseAddress();
+  }
+
+  @Override public void setOOBInline(boolean oobinline) throws SocketException {
+    delegate.setOOBInline(oobinline);
+  }
+
+  @Override public boolean getOOBInline() throws SocketException {
+    return delegate.getOOBInline();
+  }
+
+  @Override public void setTrafficClass(int value) throws SocketException {
+    delegate.setTrafficClass(value);
+  }
+
+  @Override public int getTrafficClass() throws SocketException {
+    return delegate.getTrafficClass();
+  }
+
+  @Override public void sendUrgentData(int value) throws IOException {
+    delegate.sendUrgentData(value);
+  }
+
+  @Override public SocketChannel getChannel() {
+    return delegate.getChannel();
+  }
+
+  @Override public void setPerformancePreferences(int connectionTime, int latency, int bandwidth) {
+    delegate.setPerformancePreferences(connectionTime, latency, bandwidth);
+  }
+
+  // Java 9 methods.
+
+  public SSLSession getHandshakeSession() {
+    try {
+      return (SSLSession) SSLSocket.class.getMethod("getHandshakeSession").invoke(delegate);
+    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
+      throw new AssertionError();
+    }
+  }
+
+  public String getApplicationProtocol() {
+    try {
+      return (String) SSLSocket.class.getMethod("getApplicationProtocol").invoke(delegate);
+    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
+      throw new AssertionError();
+    }
+  }
+
+  public String getHandshakeApplicationProtocol() {
+    try {
+      return (String) SSLSocket.class.getMethod("getHandshakeApplicationProtocol").invoke(delegate);
+    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
+      throw new AssertionError();
+    }
+  }
+
+  public <T> Socket setOption(SocketOption<T> name, T value) throws IOException {
+    try {
+      SSLSocket.class.getMethod("setOption", SocketOption.class, Object.class).invoke(delegate, name, value);
+      return this;
+    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
+      throw new AssertionError();
+    }
+  }
+
+  public <T> T getOption(SocketOption<T> name) throws IOException {
+    try {
+      return (T) SSLSocket.class.getMethod("getOption", SocketOption.class).invoke(delegate, name);
+    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
+      throw new AssertionError();
+    }
+  }
+
+  public Set<SocketOption<?>> supportedOptions() {
+    try {
+      return (Set<SocketOption<?>>) SSLSocket.class.getMethod("supportedOptions").invoke(delegate);
+    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
+      throw new AssertionError();
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocketFactory.java b/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocketFactory.java
new file mode 100644
index 0000000000..5a5a3dc20a
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocketFactory.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.Socket;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+
+/**
+ * A {@link SSLSocketFactory} that delegates calls. Sockets can be configured after creation by
+ * overriding {@link #configureSocket(javax.net.ssl.SSLSocket)}.
+ */
+public class DelegatingSSLSocketFactory extends SSLSocketFactory {
+
+  private final SSLSocketFactory delegate;
+
+  public DelegatingSSLSocketFactory(SSLSocketFactory delegate) {
+    this.delegate = delegate;
+  }
+
+  @Override public SSLSocket createSocket() throws IOException {
+    SSLSocket sslSocket = (SSLSocket) delegate.createSocket();
+    return configureSocket(sslSocket);
+  }
+
+  @Override public SSLSocket createSocket(String host, int port) throws IOException {
+    SSLSocket sslSocket = (SSLSocket) delegate.createSocket(host, port);
+    return configureSocket(sslSocket);
+  }
+
+  @Override public SSLSocket createSocket(
+      String host, int port, InetAddress localAddress, int localPort) throws IOException {
+    SSLSocket sslSocket = (SSLSocket) delegate.createSocket(host, port, localAddress, localPort);
+    return configureSocket(sslSocket);
+  }
+
+  @Override public SSLSocket createSocket(InetAddress host, int port) throws IOException {
+    SSLSocket sslSocket = (SSLSocket) delegate.createSocket(host, port);
+    return configureSocket(sslSocket);
+  }
+
+  @Override public SSLSocket createSocket(
+      InetAddress host, int port, InetAddress localAddress, int localPort) throws IOException {
+    SSLSocket sslSocket = (SSLSocket) delegate.createSocket(host, port, localAddress, localPort);
+    return configureSocket(sslSocket);
+  }
+
+  @Override public String[] getDefaultCipherSuites() {
+    return delegate.getDefaultCipherSuites();
+  }
+
+  @Override public String[] getSupportedCipherSuites() {
+    return delegate.getSupportedCipherSuites();
+  }
+
+  @Override public SSLSocket createSocket(
+      Socket socket, String host, int port, boolean autoClose) throws IOException {
+    SSLSocket sslSocket = (SSLSocket) delegate.createSocket(socket, host, port, autoClose);
+    return configureSocket(sslSocket);
+  }
+
+  protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
+    // No-op by default.
+    return sslSocket;
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/DelegatingServerSocketFactory.java b/okhttp-tests/src/test/java/okhttp3/DelegatingServerSocketFactory.java
new file mode 100644
index 0000000000..09b3a25d09
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/DelegatingServerSocketFactory.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.ServerSocket;
+import javax.net.ServerSocketFactory;
+
+/**
+ * A {@link ServerSocketFactory} that delegates calls. Sockets can be configured after creation by
+ * overriding {@link #configureServerSocket(java.net.ServerSocket)}.
+ */
+public class DelegatingServerSocketFactory extends ServerSocketFactory {
+
+  private final ServerSocketFactory delegate;
+
+  public DelegatingServerSocketFactory(ServerSocketFactory delegate) {
+    this.delegate = delegate;
+  }
+
+  @Override
+  public ServerSocket createServerSocket() throws IOException {
+    ServerSocket serverSocket = delegate.createServerSocket();
+    return configureServerSocket(serverSocket);
+  }
+
+  @Override
+  public ServerSocket createServerSocket(int port) throws IOException {
+    ServerSocket serverSocket = delegate.createServerSocket(port);
+    return configureServerSocket(serverSocket);
+  }
+
+  @Override
+  public ServerSocket createServerSocket(int port, int backlog) throws IOException {
+    ServerSocket serverSocket = delegate.createServerSocket(port, backlog);
+    return configureServerSocket(serverSocket);
+  }
+
+  @Override
+  public ServerSocket createServerSocket(int port, int backlog, InetAddress ifAddress)
+      throws IOException {
+    ServerSocket serverSocket = delegate.createServerSocket(port, backlog, ifAddress);
+    return configureServerSocket(serverSocket);
+  }
+
+  protected ServerSocket configureServerSocket(ServerSocket serverSocket) throws IOException {
+    // No-op by default.
+    return serverSocket;
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/DelegatingSocketFactory.java b/okhttp-tests/src/test/java/okhttp3/DelegatingSocketFactory.java
new file mode 100644
index 0000000000..33ac2f4e1a
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/DelegatingSocketFactory.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.Socket;
+import javax.net.SocketFactory;
+
+/**
+ * A {@link SocketFactory} that delegates calls. Sockets can be configured after creation by
+ * overriding {@link #configureSocket(java.net.Socket)}.
+ */
+public class DelegatingSocketFactory extends SocketFactory {
+  private final SocketFactory delegate;
+
+  public DelegatingSocketFactory(SocketFactory delegate) {
+    this.delegate = delegate;
+  }
+
+  @Override public Socket createSocket() throws IOException {
+    Socket socket = delegate.createSocket();
+    return configureSocket(socket);
+  }
+
+  @Override public Socket createSocket(String host, int port) throws IOException {
+    Socket socket = delegate.createSocket(host, port);
+    return configureSocket(socket);
+  }
+
+  @Override public Socket createSocket(String host, int port, InetAddress localAddress,
+      int localPort) throws IOException {
+    Socket socket = delegate.createSocket(host, port, localAddress, localPort);
+    return configureSocket(socket);
+  }
+
+  @Override public Socket createSocket(InetAddress host, int port) throws IOException {
+    Socket socket = delegate.createSocket(host, port);
+    return configureSocket(socket);
+  }
+
+  @Override public Socket createSocket(InetAddress host, int port, InetAddress localAddress,
+      int localPort) throws IOException {
+    Socket socket = delegate.createSocket(host, port, localAddress, localPort);
+    return configureSocket(socket);
+  }
+
+  protected Socket configureSocket(Socket socket) throws IOException {
+    // No-op by default.
+    return socket;
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java b/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
new file mode 100644
index 0000000000..e4896a94d1
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
@@ -0,0 +1,336 @@
+package okhttp3;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.AbstractExecutorService;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import okhttp3.RealCall.AsyncCall;
+import org.junit.Before;
+import org.junit.Test;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static okhttp3.TestUtil.defaultClient;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class DispatcherTest {
+  RecordingExecutor executor = new RecordingExecutor();
+  RecordingCallback callback = new RecordingCallback();
+  Dispatcher dispatcher = new Dispatcher(executor);
+  OkHttpClient client = defaultClient().newBuilder()
+      .dispatcher(dispatcher)
+      .build();
+
+  @Before public void setUp() throws Exception {
+    dispatcher.setMaxRequests(20);
+    dispatcher.setMaxRequestsPerHost(10);
+  }
+
+  @Test public void maxRequestsZero() throws Exception {
+    try {
+      dispatcher.setMaxRequests(0);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void maxPerHostZero() throws Exception {
+    try {
+      dispatcher.setMaxRequestsPerHost(0);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void enqueuedJobsRunImmediately() throws Exception {
+    client.newCall(newRequest("http://a/1")).enqueue(callback);
+    executor.assertJobs("http://a/1");
+  }
+
+  @Test public void maxRequestsEnforced() throws Exception {
+    dispatcher.setMaxRequests(3);
+    client.newCall(newRequest("http://a/1")).enqueue(callback);
+    client.newCall(newRequest("http://a/2")).enqueue(callback);
+    client.newCall(newRequest("http://b/1")).enqueue(callback);
+    client.newCall(newRequest("http://b/2")).enqueue(callback);
+    executor.assertJobs("http://a/1", "http://a/2", "http://b/1");
+  }
+
+  @Test public void maxPerHostEnforced() throws Exception {
+    dispatcher.setMaxRequestsPerHost(2);
+    client.newCall(newRequest("http://a/1")).enqueue(callback);
+    client.newCall(newRequest("http://a/2")).enqueue(callback);
+    client.newCall(newRequest("http://a/3")).enqueue(callback);
+    executor.assertJobs("http://a/1", "http://a/2");
+  }
+
+  @Test public void increasingMaxRequestsPromotesJobsImmediately() throws Exception {
+    dispatcher.setMaxRequests(2);
+    client.newCall(newRequest("http://a/1")).enqueue(callback);
+    client.newCall(newRequest("http://b/1")).enqueue(callback);
+    client.newCall(newRequest("http://c/1")).enqueue(callback);
+    client.newCall(newRequest("http://a/2")).enqueue(callback);
+    client.newCall(newRequest("http://b/2")).enqueue(callback);
+    dispatcher.setMaxRequests(4);
+    executor.assertJobs("http://a/1", "http://b/1", "http://c/1", "http://a/2");
+  }
+
+  @Test public void increasingMaxPerHostPromotesJobsImmediately() throws Exception {
+    dispatcher.setMaxRequestsPerHost(2);
+    client.newCall(newRequest("http://a/1")).enqueue(callback);
+    client.newCall(newRequest("http://a/2")).enqueue(callback);
+    client.newCall(newRequest("http://a/3")).enqueue(callback);
+    client.newCall(newRequest("http://a/4")).enqueue(callback);
+    client.newCall(newRequest("http://a/5")).enqueue(callback);
+    dispatcher.setMaxRequestsPerHost(4);
+    executor.assertJobs("http://a/1", "http://a/2", "http://a/3", "http://a/4");
+  }
+
+  @Test public void oldJobFinishesNewJobCanRunDifferentHost() throws Exception {
+    dispatcher.setMaxRequests(1);
+    client.newCall(newRequest("http://a/1")).enqueue(callback);
+    client.newCall(newRequest("http://b/1")).enqueue(callback);
+    executor.finishJob("http://a/1");
+    executor.assertJobs("http://b/1");
+  }
+
+  @Test public void oldJobFinishesNewJobWithSameHostStarts() throws Exception {
+    dispatcher.setMaxRequests(2);
+    dispatcher.setMaxRequestsPerHost(1);
+    client.newCall(newRequest("http://a/1")).enqueue(callback);
+    client.newCall(newRequest("http://b/1")).enqueue(callback);
+    client.newCall(newRequest("http://b/2")).enqueue(callback);
+    client.newCall(newRequest("http://a/2")).enqueue(callback);
+    executor.finishJob("http://a/1");
+    executor.assertJobs("http://b/1", "http://a/2");
+  }
+
+  @Test public void oldJobFinishesNewJobCantRunDueToHostLimit() throws Exception {
+    dispatcher.setMaxRequestsPerHost(1);
+    client.newCall(newRequest("http://a/1")).enqueue(callback);
+    client.newCall(newRequest("http://b/1")).enqueue(callback);
+    client.newCall(newRequest("http://a/2")).enqueue(callback);
+    executor.finishJob("http://b/1");
+    executor.assertJobs("http://a/1");
+  }
+
+  @Test public void cancelingRunningJobTakesNoEffectUntilJobFinishes() throws Exception {
+    dispatcher.setMaxRequests(1);
+    Call c1 = client.newCall(newRequest("http://a/1", "tag1"));
+    Call c2 = client.newCall(newRequest("http://a/2"));
+    c1.enqueue(callback);
+    c2.enqueue(callback);
+    c1.cancel();
+    executor.assertJobs("http://a/1");
+    executor.finishJob("http://a/1");
+    executor.assertJobs("http://a/2");
+  }
+
+  @Test public void asyncCallAccessors() throws Exception {
+    dispatcher.setMaxRequests(3);
+    Call a1 = client.newCall(newRequest("http://a/1"));
+    Call a2 = client.newCall(newRequest("http://a/2"));
+    Call a3 = client.newCall(newRequest("http://a/3"));
+    Call a4 = client.newCall(newRequest("http://a/4"));
+    Call a5 = client.newCall(newRequest("http://a/5"));
+    a1.enqueue(callback);
+    a2.enqueue(callback);
+    a3.enqueue(callback);
+    a4.enqueue(callback);
+    a5.enqueue(callback);
+    assertEquals(3, dispatcher.runningCallsCount());
+    assertEquals(2, dispatcher.queuedCallsCount());
+    assertEquals(set(a1, a2, a3), set(dispatcher.runningCalls()));
+    assertEquals(set(a4, a5), set(dispatcher.queuedCalls()));
+  }
+
+  @Test public void synchronousCallAccessors() throws Exception {
+    final CountDownLatch ready = new CountDownLatch(2);
+    final CountDownLatch waiting = new CountDownLatch(1);
+    client = client.newBuilder()
+        .addInterceptor(
+            new Interceptor() {
+              @Override public Response intercept(Chain chain) throws IOException {
+                try {
+                  ready.countDown();
+                  waiting.await();
+                } catch (InterruptedException e) {
+                  throw new AssertionError();
+                }
+                throw new IOException();
+              }
+            })
+        .build();
+
+    Call a1 = client.newCall(newRequest("http://a/1"));
+    Call a2 = client.newCall(newRequest("http://a/2"));
+    Call a3 = client.newCall(newRequest("http://a/3"));
+    Call a4 = client.newCall(newRequest("http://a/4"));
+    Thread t1 = makeSynchronousCall(a1);
+    Thread t2 = makeSynchronousCall(a2);
+
+    // We created 4 calls and started 2 of them. That's 2 running calls and 0 queued.
+    ready.await();
+    assertEquals(2, dispatcher.runningCallsCount());
+    assertEquals(0, dispatcher.queuedCallsCount());
+    assertEquals(set(a1, a2), set(dispatcher.runningCalls()));
+    assertEquals(Collections.emptyList(), dispatcher.queuedCalls());
+
+    // Cancel some calls. That doesn't impact running or queued.
+    a2.cancel();
+    a3.cancel();
+    assertEquals(set(a1, a2), set(dispatcher.runningCalls()));
+    assertEquals(Collections.emptyList(), dispatcher.queuedCalls());
+
+    // Let the calls finish.
+    waiting.countDown();
+    t1.join();
+    t2.join();
+
+    // Now we should have 0 running calls and 0 queued calls.
+    assertEquals(0, dispatcher.runningCallsCount());
+    assertEquals(0, dispatcher.queuedCallsCount());
+    assertEquals(Collections.emptyList(), dispatcher.runningCalls());
+    assertEquals(Collections.emptyList(), dispatcher.queuedCalls());
+
+    assertTrue(a1.isExecuted());
+    assertFalse(a1.isCanceled());
+
+    assertTrue(a2.isExecuted());
+    assertTrue(a2.isCanceled());
+
+    assertFalse(a3.isExecuted());
+    assertTrue(a3.isCanceled());
+
+    assertFalse(a4.isExecuted());
+    assertFalse(a4.isCanceled());
+  }
+
+  @Test public void idleCallbackInvokedWhenIdle() throws InterruptedException {
+    final AtomicBoolean idle = new AtomicBoolean();
+    dispatcher.setIdleCallback(new Runnable() {
+      @Override public void run() {
+        idle.set(true);
+      }
+    });
+
+    client.newCall(newRequest("http://a/1")).enqueue(callback);
+    client.newCall(newRequest("http://a/2")).enqueue(callback);
+    executor.finishJob("http://a/1");
+    assertFalse(idle.get());
+
+    final CountDownLatch ready = new CountDownLatch(1);
+    final CountDownLatch proceed = new CountDownLatch(1);
+    client = client.newBuilder()
+        .addInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            ready.countDown();
+            try {
+              proceed.await(5, SECONDS);
+            } catch (InterruptedException e) {
+              throw new RuntimeException(e);
+            }
+            return chain.proceed(chain.request());
+          }
+        })
+        .build();
+
+    Thread t1 = makeSynchronousCall(client.newCall(newRequest("http://a/3")));
+    ready.await(5, SECONDS);
+    executor.finishJob("http://a/2");
+    assertFalse(idle.get());
+
+    proceed.countDown();
+    t1.join();
+    assertTrue(idle.get());
+  }
+
+  private <T> Set<T> set(T... values) {
+    return set(Arrays.asList(values));
+  }
+
+  private <T> Set<T> set(List<T> list) {
+    return new LinkedHashSet<>(list);
+  }
+
+  private Thread makeSynchronousCall(final Call call) {
+    Thread thread = new Thread() {
+      @Override public void run() {
+        try {
+          call.execute();
+          throw new AssertionError();
+        } catch (IOException expected) {
+        }
+      }
+    };
+    thread.start();
+    return thread;
+  }
+
+  class RecordingExecutor extends AbstractExecutorService {
+    private List<AsyncCall> calls = new ArrayList<>();
+
+    @Override public void execute(Runnable command) {
+      calls.add((AsyncCall) command);
+    }
+
+    public void assertJobs(String... expectedUrls) {
+      List<String> actualUrls = new ArrayList<>();
+      for (AsyncCall call : calls) {
+        actualUrls.add(call.request().url().toString());
+      }
+      assertEquals(Arrays.asList(expectedUrls), actualUrls);
+    }
+
+    public void finishJob(String url) {
+      for (Iterator<AsyncCall> i = calls.iterator(); i.hasNext(); ) {
+        AsyncCall call = i.next();
+        if (call.request().url().toString().equals(url)) {
+          i.remove();
+          dispatcher.finished(call);
+          return;
+        }
+      }
+      throw new AssertionError("No such job: " + url);
+    }
+
+    @Override public void shutdown() {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override public List<Runnable> shutdownNow() {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override public boolean isShutdown() {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override public boolean isTerminated() {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override public boolean awaitTermination(long timeout, TimeUnit unit)
+        throws InterruptedException {
+      throw new UnsupportedOperationException();
+    }
+  }
+
+  private Request newRequest(String url) {
+    return new Request.Builder().url(url).build();
+  }
+
+  private Request newRequest(String url, String tag) {
+    return new Request.Builder().url(url).tag(tag).build();
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java b/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
new file mode 100644
index 0000000000..07f0ca694c
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
@@ -0,0 +1,1034 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.net.UnknownHostException;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
+import okhttp3.RecordingEventListener.CallEnd;
+import okhttp3.RecordingEventListener.CallFailed;
+import okhttp3.RecordingEventListener.ConnectEnd;
+import okhttp3.RecordingEventListener.ConnectFailed;
+import okhttp3.RecordingEventListener.ConnectStart;
+import okhttp3.RecordingEventListener.ConnectionAcquired;
+import okhttp3.RecordingEventListener.DnsEnd;
+import okhttp3.RecordingEventListener.DnsStart;
+import okhttp3.RecordingEventListener.RequestBodyEnd;
+import okhttp3.RecordingEventListener.RequestHeadersEnd;
+import okhttp3.RecordingEventListener.ResponseBodyEnd;
+import okhttp3.RecordingEventListener.ResponseHeadersEnd;
+import okhttp3.RecordingEventListener.SecureConnectEnd;
+import okhttp3.RecordingEventListener.SecureConnectStart;
+import okhttp3.internal.DoubleInetAddressDns;
+import okhttp3.internal.RecordingOkAuthenticator;
+import okhttp3.internal.SingleInetAddressDns;
+import okhttp3.internal.tls.SslClient;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.SocketPolicy;
+import okio.Buffer;
+import okio.BufferedSink;
+import org.hamcrest.BaseMatcher;
+import org.hamcrest.CoreMatchers;
+import org.hamcrest.Description;
+import org.hamcrest.Matcher;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static java.util.Arrays.asList;
+import static okhttp3.TestUtil.defaultClient;
+import static org.hamcrest.CoreMatchers.any;
+import static org.hamcrest.CoreMatchers.either;
+import static org.hamcrest.CoreMatchers.equalTo;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertThat;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeThat;
+
+public final class EventListenerTest {
+  public static final Matcher<Response> anyResponse = CoreMatchers.any(Response.class);
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private final SingleInetAddressDns singleDns = new SingleInetAddressDns();
+  private final RecordingEventListener listener = new RecordingEventListener();
+  private final SslClient sslClient = SslClient.localhost();
+
+  private OkHttpClient client;
+  private SocksProxy socksProxy;
+
+  @Before public void setUp() throws IOException {
+    client = defaultClient().newBuilder()
+        .dns(singleDns)
+        .eventListener(listener)
+        .build();
+
+    listener.forbidLock(client.connectionPool());
+    listener.forbidLock(client.dispatcher());
+  }
+
+  @After public void tearDown() throws Exception {
+    if (socksProxy != null) {
+      socksProxy.shutdown();
+    }
+  }
+
+  @Test public void successfulCallEventSequence() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    assertEquals("abc", response.body().string());
+    response.body().close();
+
+    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
+        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
+        "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
+  @Test public void successfulCallEventSequenceForEnqueue() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    final CountDownLatch completionLatch = new CountDownLatch(1);
+    Callback callback = new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+        completionLatch.countDown();
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        response.close();
+        completionLatch.countDown();
+      }
+    };
+
+    call.enqueue(callback);
+
+    completionLatch.await();
+
+    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
+        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
+        "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
+  @Test public void failedCallEventSequence() throws IOException {
+    server.enqueue(new MockResponse().setBodyDelay(2, TimeUnit.SECONDS));
+
+    client = client.newBuilder().readTimeout(250, TimeUnit.MILLISECONDS).build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+      assertThat(expected.getMessage(), either(equalTo("timeout")).or(equalTo("Read timed out")));
+    }
+
+    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
+        "RequestHeadersEnd", "ResponseHeadersStart", "ConnectionReleased", "CallFailed");
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
+  @Test public void canceledCallEventSequence() throws IOException {
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    call.cancel();
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("Canceled", expected.getMessage());
+    }
+
+    List<String> expectedEvents = Arrays.asList("CallStart", "CallFailed");
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
+  private void assertSuccessfulEventOrder(Matcher<Response> responseMatcher) throws IOException {
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().string();
+    response.body().close();
+
+    assumeThat(response, responseMatcher);
+
+    List<String> expectedEvents = asList("CallStart", "DnsStart", "DnsEnd", "ConnectStart",
+        "SecureConnectStart", "SecureConnectEnd", "ConnectEnd", "ConnectionAcquired",
+        "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd",
+        "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
+
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
+  @Test public void secondCallEventSequence() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+
+    client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build()).execute().close();
+
+    listener.removeUpToEvent(CallEnd.class);
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    response.close();
+
+    List<String> expectedEvents = asList("CallStart", "ConnectionAcquired",
+        "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd",
+        "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
+
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
+  private void assertBytesReadWritten(RecordingEventListener listener,
+      @Nullable Matcher<Long> requestHeaderLength, @Nullable Matcher<Long> requestBodyBytes,
+      @Nullable Matcher<Long> responseHeaderLength, @Nullable Matcher<Long> responseBodyBytes) {
+
+    if (requestHeaderLength != null) {
+      RequestHeadersEnd responseHeadersEnd = listener.removeUpToEvent(RequestHeadersEnd.class);
+      assertThat("request header length", responseHeadersEnd.headerLength, requestHeaderLength);
+    } else {
+      assertFalse("Found RequestHeadersEnd",
+          listener.recordedEventTypes().contains("RequestHeadersEnd"));
+    }
+
+    if (requestBodyBytes != null) {
+      RequestBodyEnd responseBodyEnd = listener.removeUpToEvent(RequestBodyEnd.class);
+      assertThat("request body bytes", responseBodyEnd.bytesWritten, requestBodyBytes);
+    } else {
+      assertFalse("Found RequestBodyEnd", listener.recordedEventTypes().contains("RequestBodyEnd"));
+    }
+
+    if (responseHeaderLength != null) {
+      ResponseHeadersEnd responseHeadersEnd = listener.removeUpToEvent(ResponseHeadersEnd.class);
+      assertThat("response header length", responseHeadersEnd.headerLength, responseHeaderLength);
+    } else {
+      assertFalse("Found ResponseHeadersEnd",
+          listener.recordedEventTypes().contains("ResponseHeadersEnd"));
+    }
+
+    if (responseBodyBytes != null) {
+      ResponseBodyEnd responseBodyEnd = listener.removeUpToEvent(ResponseBodyEnd.class);
+      assertThat("response body bytes", responseBodyEnd.bytesRead, responseBodyBytes);
+    } else {
+      assertFalse("Found ResponseBodyEnd",
+          listener.recordedEventTypes().contains("ResponseBodyEnd"));
+    }
+  }
+
+  private Matcher<Long> greaterThan(final long value) {
+    return new BaseMatcher<Long>() {
+      @Override public void describeTo(Description description) {
+        description.appendText("> " + value);
+      }
+
+      @Override public boolean matches(Object o) {
+        return ((Long)o) > value;
+      }
+    };
+  }
+
+  private Matcher<Long> lessThan(final long value) {
+    return new BaseMatcher<Long>() {
+      @Override public void describeTo(Description description) {
+        description.appendText("< " + value);
+      }
+
+      @Override public boolean matches(Object o) {
+        return ((Long)o) < value;
+      }
+    };
+  }
+
+  private Matcher<Response> matchesProtocol(final Protocol protocol) {
+    return new BaseMatcher<Response>() {
+      @Override public void describeTo(Description description) {
+        description.appendText("is HTTP/2");
+      }
+
+      @Override public boolean matches(Object o) {
+        return ((Response)o).protocol == protocol;
+      }
+    };
+  }
+
+  @Test public void successfulEmptyH2CallEventSequence() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+    server.enqueue(new MockResponse());
+
+    assertSuccessfulEventOrder(matchesProtocol(Protocol.HTTP_2));
+
+    assertBytesReadWritten(listener, any(Long.class), null, greaterThan(0L),
+        equalTo(0L));
+  }
+
+  @Test public void successfulEmptyHttpsCallEventSequence() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_1_1));
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    assertSuccessfulEventOrder(anyResponse);
+
+    assertBytesReadWritten(listener, any(Long.class), null, greaterThan(0L),
+        equalTo(3L));
+  }
+
+  @Test public void successfulChunkedHttpsCallEventSequence() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_1_1));
+    server.enqueue(
+        new MockResponse().setBodyDelay(100, TimeUnit.MILLISECONDS).setChunkedBody("Hello!", 2));
+
+    assertSuccessfulEventOrder(anyResponse);
+
+    assertBytesReadWritten(listener, any(Long.class), null, greaterThan(0L),
+        equalTo(6L));
+  }
+
+  @Test public void successfulChunkedH2CallEventSequence() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+    server.enqueue(
+        new MockResponse().setBodyDelay(100, TimeUnit.MILLISECONDS).setChunkedBody("Hello!", 2));
+
+    assertSuccessfulEventOrder(matchesProtocol(Protocol.HTTP_2));
+
+    assertBytesReadWritten(listener, any(Long.class), null, equalTo(0L),
+        greaterThan(6L));
+  }
+
+  @Test public void successfulDnsLookup() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    DnsStart dnsStart = listener.removeUpToEvent(DnsStart.class);
+    assertSame(call, dnsStart.call);
+    assertEquals(server.getHostName(), dnsStart.domainName);
+
+    DnsEnd dnsEnd = listener.removeUpToEvent(DnsEnd.class);
+    assertSame(call, dnsEnd.call);
+    assertEquals(server.getHostName(), dnsEnd.domainName);
+    assertEquals(1, dnsEnd.inetAddressList.size());
+  }
+
+  @Test public void noDnsLookupOnPooledConnection() throws IOException {
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+
+    // Seed the pool.
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+    assertEquals(200, response1.code());
+    response1.body().close();
+
+    listener.clearAllEvents();
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals(200, response2.code());
+    response2.body().close();
+
+    List<String> recordedEvents = listener.recordedEventTypes();
+    assertFalse(recordedEvents.contains("DnsStart"));
+    assertFalse(recordedEvents.contains("DnsEnd"));
+  }
+
+  @Test public void multipleDnsLookupsForSingleCall() throws IOException {
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .setHeader("Location", "http://www.fakeurl:" + server.getPort()));
+    server.enqueue(new MockResponse());
+
+    FakeDns dns = new FakeDns();
+    dns.set("fakeurl", singleDns.lookup(server.getHostName()));
+    dns.set("www.fakeurl", singleDns.lookup(server.getHostName()));
+
+    client = client.newBuilder()
+        .dns(dns)
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url("http://fakeurl:" + server.getPort())
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    listener.removeUpToEvent(DnsStart.class);
+    listener.removeUpToEvent(DnsEnd.class);
+    listener.removeUpToEvent(DnsStart.class);
+    listener.removeUpToEvent(DnsEnd.class);
+  }
+
+  @Test public void failedDnsLookup() {
+    client = client.newBuilder()
+        .dns(new FakeDns())
+        .build();
+    Call call = client.newCall(new Request.Builder()
+        .url("http://fakeurl/")
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    listener.removeUpToEvent(DnsStart.class);
+
+    CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
+    assertSame(call, callFailed.call);
+    assertTrue(callFailed.ioe instanceof UnknownHostException);
+  }
+
+  @Test public void emptyDnsLookup() {
+    Dns emptyDns = new Dns() {
+      @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
+        return Collections.emptyList();
+      }
+    };
+
+    client = client.newBuilder()
+        .dns(emptyDns)
+        .build();
+    Call call = client.newCall(new Request.Builder()
+        .url("http://fakeurl/")
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    listener.removeUpToEvent(DnsStart.class);
+
+    CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
+    assertSame(call, callFailed.call);
+    assertTrue(callFailed.ioe instanceof UnknownHostException);
+  }
+
+  @Test public void successfulConnect() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    InetAddress address = singleDns.lookup(server.getHostName()).get(0);
+    InetSocketAddress expectedAddress = new InetSocketAddress(address, server.getPort());
+
+    ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
+    assertSame(call, connectStart.call);
+    assertEquals(expectedAddress, connectStart.inetSocketAddress);
+    assertEquals(Proxy.NO_PROXY, connectStart.proxy);
+
+    ConnectEnd connectEnd = listener.removeUpToEvent(ConnectEnd.class);
+    assertSame(call, connectEnd.call);
+    assertEquals(expectedAddress, connectEnd.inetSocketAddress);
+    assertEquals(Protocol.HTTP_1_1, connectEnd.protocol);
+  }
+
+  @Test public void failedConnect() throws UnknownHostException {
+    enableTlsWithTunnel(false);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    InetAddress address = singleDns.lookup(server.getHostName()).get(0);
+    InetSocketAddress expectedAddress = new InetSocketAddress(address, server.getPort());
+
+    ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
+    assertSame(call, connectStart.call);
+    assertEquals(expectedAddress, connectStart.inetSocketAddress);
+    assertEquals(Proxy.NO_PROXY, connectStart.proxy);
+
+    ConnectFailed connectFailed = listener.removeUpToEvent(ConnectFailed.class);
+    assertSame(call, connectFailed.call);
+    assertEquals(expectedAddress, connectFailed.inetSocketAddress);
+    assertNull(connectFailed.protocol);
+    assertNotNull(connectFailed.ioe);
+  }
+
+  @Test public void multipleConnectsForSingleCall() throws IOException {
+    enableTlsWithTunnel(false);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse());
+
+    client = client.newBuilder()
+        .dns(new DoubleInetAddressDns())
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    listener.removeUpToEvent(ConnectStart.class);
+    listener.removeUpToEvent(ConnectFailed.class);
+    listener.removeUpToEvent(ConnectStart.class);
+    listener.removeUpToEvent(ConnectEnd.class);
+  }
+
+  @Test public void successfulHttpProxyConnect() throws IOException {
+    server.enqueue(new MockResponse());
+
+    client = client.newBuilder()
+        .proxy(server.toProxyAddress())
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url("http://www.fakeurl")
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    InetAddress address = singleDns.lookup(server.getHostName()).get(0);
+    InetSocketAddress expectedAddress = new InetSocketAddress(address, server.getPort());
+
+    ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
+    assertSame(call, connectStart.call);
+    assertEquals(expectedAddress, connectStart.inetSocketAddress);
+    assertEquals(server.toProxyAddress(), connectStart.proxy);
+
+    ConnectEnd connectEnd = listener.removeUpToEvent(ConnectEnd.class);
+    assertSame(call, connectEnd.call);
+    assertEquals(expectedAddress, connectEnd.inetSocketAddress);
+    assertEquals(Protocol.HTTP_1_1, connectEnd.protocol);
+  }
+
+  @Test public void successfulSocksProxyConnect() throws Exception {
+    server.enqueue(new MockResponse());
+
+    socksProxy = new SocksProxy();
+    socksProxy.play();
+    Proxy proxy = socksProxy.proxy();
+
+    client = client.newBuilder()
+        .proxy(proxy)
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url("http://" + SocksProxy.HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS + ":" + server.getPort())
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    InetSocketAddress expectedAddress = InetSocketAddress.createUnresolved(
+        SocksProxy.HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS, server.getPort());
+
+    ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
+    assertSame(call, connectStart.call);
+    assertEquals(expectedAddress, connectStart.inetSocketAddress);
+    assertEquals(proxy, connectStart.proxy);
+
+    ConnectEnd connectEnd = listener.removeUpToEvent(ConnectEnd.class);
+    assertSame(call, connectEnd.call);
+    assertEquals(expectedAddress, connectEnd.inetSocketAddress);
+    assertEquals(Protocol.HTTP_1_1, connectEnd.protocol);
+  }
+
+  @Test public void authenticatingTunnelProxyConnect() throws IOException {
+    enableTlsWithTunnel(true);
+    server.enqueue(new MockResponse()
+        .setResponseCode(407)
+        .addHeader("Proxy-Authenticate: Basic realm=\"localhost\"")
+        .addHeader("Connection: close"));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END));
+    server.enqueue(new MockResponse());
+
+    client = client.newBuilder()
+        .proxy(server.toProxyAddress())
+        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    listener.removeUpToEvent(ConnectStart.class);
+
+    ConnectEnd connectEnd = listener.removeUpToEvent(ConnectEnd.class);
+    assertNull(connectEnd.protocol);
+
+    listener.removeUpToEvent(ConnectStart.class);
+    listener.removeUpToEvent(ConnectEnd.class);
+  }
+
+  @Test public void successfulSecureConnect() throws IOException {
+    enableTlsWithTunnel(false);
+    server.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    SecureConnectStart secureStart = listener.removeUpToEvent(SecureConnectStart.class);
+    assertSame(call, secureStart.call);
+
+    SecureConnectEnd secureEnd = listener.removeUpToEvent(SecureConnectEnd.class);
+    assertSame(call, secureEnd.call);
+    assertNotNull(secureEnd.handshake);
+  }
+
+  @Test public void failedSecureConnect() {
+    enableTlsWithTunnel(false);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    SecureConnectStart secureStart = listener.removeUpToEvent(SecureConnectStart.class);
+    assertSame(call, secureStart.call);
+
+    CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
+    assertSame(call, callFailed.call);
+    assertNotNull(callFailed.ioe);
+  }
+
+  @Test public void secureConnectWithTunnel() throws IOException {
+    enableTlsWithTunnel(true);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END));
+    server.enqueue(new MockResponse());
+
+    client = client.newBuilder()
+        .proxy(server.toProxyAddress())
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    SecureConnectStart secureStart = listener.removeUpToEvent(SecureConnectStart.class);
+    assertSame(call, secureStart.call);
+
+    SecureConnectEnd secureEnd = listener.removeUpToEvent(SecureConnectEnd.class);
+    assertSame(call, secureEnd.call);
+    assertNotNull(secureEnd.handshake);
+  }
+
+  @Test public void multipleSecureConnectsForSingleCall() throws IOException {
+    enableTlsWithTunnel(false);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse());
+
+    client = client.newBuilder()
+        .dns(new DoubleInetAddressDns())
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    listener.removeUpToEvent(SecureConnectStart.class);
+    listener.removeUpToEvent(ConnectFailed.class);
+
+    listener.removeUpToEvent(SecureConnectStart.class);
+    listener.removeUpToEvent(SecureConnectEnd.class);
+  }
+
+  @Test public void noSecureConnectsOnPooledConnection() throws IOException {
+    enableTlsWithTunnel(false);
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+
+    client = client.newBuilder()
+        .dns(new DoubleInetAddressDns())
+        .build();
+
+    // Seed the pool.
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+    assertEquals(200, response1.code());
+    response1.body().close();
+
+    listener.clearAllEvents();
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals(200, response2.code());
+    response2.body().close();
+
+    List<String> recordedEvents = listener.recordedEventTypes();
+    assertFalse(recordedEvents.contains("SecureConnectStart"));
+    assertFalse(recordedEvents.contains("SecureConnectEnd"));
+  }
+
+  @Test public void successfulConnectionFound() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    ConnectionAcquired connectionAcquired = listener.removeUpToEvent(ConnectionAcquired.class);
+    assertSame(call, connectionAcquired.call);
+    assertNotNull(connectionAcquired.connection);
+  }
+
+  @Test public void noConnectionFoundOnFollowUp() throws IOException {
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location", "/foo"));
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("ABC", response.body().string());
+
+    listener.removeUpToEvent(ConnectionAcquired.class);
+
+    List<String> remainingEvents = listener.recordedEventTypes();
+    assertFalse(remainingEvents.contains("ConnectionAcquired"));
+  }
+
+  @Test public void pooledConnectionFound() throws IOException {
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+
+    // Seed the pool.
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+    assertEquals(200, response1.code());
+    response1.body().close();
+
+    ConnectionAcquired connectionAcquired1 = listener.removeUpToEvent(ConnectionAcquired.class);
+    listener.clearAllEvents();
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals(200, response2.code());
+    response2.body().close();
+
+    ConnectionAcquired connectionAcquired2 = listener.removeUpToEvent(ConnectionAcquired.class);
+    assertSame(connectionAcquired1.connection, connectionAcquired2.connection);
+  }
+
+  @Test public void multipleConnectionsFoundForSingleCall() throws IOException {
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location", "/foo")
+        .addHeader("Connection", "Close"));
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("ABC", response.body().string());
+
+    listener.removeUpToEvent(ConnectionAcquired.class);
+    listener.removeUpToEvent(ConnectionAcquired.class);
+  }
+
+  @Test public void responseBodyFailHttp1OverHttps() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_1_1));
+    responseBodyFail(Protocol.HTTP_1_1);
+  }
+
+  @Test public void responseBodyFailHttp2OverHttps() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+    responseBodyFail(Protocol.HTTP_2);
+  }
+
+  @Test public void responseBodyFailHttp() throws IOException {
+    responseBodyFail(Protocol.HTTP_1_1);
+  }
+
+  private void responseBodyFail(Protocol expectedProtocol) throws IOException {
+    // Use a 2 MiB body so the disconnect won't happen until the client has read some data.
+    int responseBodySize = 2 * 1024 * 1024; // 2 MiB
+    server.enqueue(new MockResponse()
+        .setBody(new Buffer().write(new byte[responseBodySize]))
+        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    if (expectedProtocol == Protocol.HTTP_2) {
+      // soft failure since client may not support depending on Platform
+      assumeThat(response, matchesProtocol(Protocol.HTTP_2));
+    }
+    assertEquals(expectedProtocol, response.protocol());
+    try {
+      response.body.string();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
+    assertNotNull(callFailed.ioe);
+  }
+
+  @Ignore("the CallEnd event is omitted")
+  @Test public void emptyResponseBody() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("")
+        .setBodyDelay(1, TimeUnit.SECONDS)
+        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    response.body().close();
+
+    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
+        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
+        "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
+  @Ignore("this reports CallFailed not CallEnd")
+  @Test public void responseBodyClosedClosedWithoutReadingAllData() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .setBodyDelay(1, TimeUnit.SECONDS)
+        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    response.body().close();
+
+    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
+        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
+        "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
+  @Test public void requestBodyFailHttp1OverHttps() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_1_1));
+    requestBodyFail();
+  }
+
+  @Test public void requestBodyFailHttp2OverHttps() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+    requestBodyFail();
+  }
+
+  @Test public void requestBodyFailHttp() throws IOException {
+    requestBodyFail();
+  }
+
+  private void requestBodyFail() throws IOException {
+    // Stream a 8 MiB body so the disconnect will happen before the server has read everything.
+    RequestBody requestBody = new RequestBody() {
+      @Override public MediaType contentType() {
+        return MediaType.parse("text/plain");
+      }
+
+      @Override public long contentLength() throws IOException {
+        return 1024 * 8192;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        for (int i = 0; i < 1024; i++) {
+          sink.write(new byte[8192]);
+          sink.flush();
+        }
+      }
+    };
+
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_REQUEST_BODY));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .post(requestBody)
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
+    assertNotNull(callFailed.ioe);
+  }
+
+  @Test public void requestBodySuccessHttp1OverHttps() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_1_1));
+    requestBodySuccess(RequestBody.create(MediaType.parse("text/plain"), "Hello"), equalTo(5L),
+        equalTo(19L));
+  }
+
+  @Test public void requestBodySuccessHttp2OverHttps() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+    requestBodySuccess(RequestBody.create(MediaType.parse("text/plain"), "Hello"), equalTo(5L),
+        equalTo(19L));
+  }
+
+  @Test public void requestBodySuccessHttp() throws IOException {
+    requestBodySuccess(RequestBody.create(MediaType.parse("text/plain"), "Hello"), equalTo(5L),
+        equalTo(19L));
+  }
+
+  @Test public void requestBodySuccessStreaming() throws IOException {
+    RequestBody requestBody = new RequestBody() {
+      @Override public MediaType contentType() {
+        return MediaType.parse("text/plain");
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.write(new byte[8192]);
+        sink.flush();
+      }
+    };
+
+    requestBodySuccess(requestBody, equalTo(8192L), equalTo(19L));
+  }
+
+  @Test public void requestBodySuccessEmpty() throws IOException {
+    requestBodySuccess(RequestBody.create(MediaType.parse("text/plain"), ""), equalTo(0L),
+        equalTo(19L));
+  }
+
+  private void requestBodySuccess(RequestBody body, Matcher<Long> requestBodyBytes,
+      Matcher<Long> responseHeaderLength) throws IOException {
+    server.enqueue(new MockResponse().setResponseCode(200).setBody("World!"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .post(body)
+        .build());
+    Response response = call.execute();
+    assertEquals("World!", response.body().string());
+
+    assertBytesReadWritten(listener, any(Long.class), requestBodyBytes, responseHeaderLength,
+        equalTo(6L));
+  }
+
+  private void enableTlsWithTunnel(boolean tunnelProxy) {
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+    server.useHttps(sslClient.socketFactory, tunnelProxy);
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/FallbackTestClientSocketFactory.java b/okhttp-tests/src/test/java/okhttp3/FallbackTestClientSocketFactory.java
new file mode 100644
index 0000000000..d829566e20
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/FallbackTestClientSocketFactory.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2014 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+
+/**
+ * An SSLSocketFactory that delegates calls. Sockets created by the delegate are wrapped with ones
+ * that will not accept the {@link #TLS_FALLBACK_SCSV} cipher, thus bypassing server-side fallback
+ * checks on platforms that support it. Unfortunately this wrapping will disable any
+ * reflection-based calls to SSLSocket from Platform.
+ */
+public class FallbackTestClientSocketFactory extends DelegatingSSLSocketFactory {
+  /**
+   * The cipher suite used during TLS connection fallback to indicate a fallback. See
+   * https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00
+   */
+  public static final String TLS_FALLBACK_SCSV = "TLS_FALLBACK_SCSV";
+
+  public FallbackTestClientSocketFactory(SSLSocketFactory delegate) {
+    super(delegate);
+  }
+
+  @Override protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
+    return new TlsFallbackScsvDisabledSSLSocket(sslSocket);
+  }
+
+  private static class TlsFallbackScsvDisabledSSLSocket extends DelegatingSSLSocket {
+
+    public TlsFallbackScsvDisabledSSLSocket(SSLSocket socket) {
+      super(socket);
+    }
+
+    @Override public void setEnabledCipherSuites(String[] suites) {
+      List<String> enabledCipherSuites = new ArrayList<>(suites.length);
+      for (String suite : suites) {
+        if (!suite.equals(TLS_FALLBACK_SCSV)) {
+          enabledCipherSuites.add(suite);
+        }
+      }
+      delegate.setEnabledCipherSuites(
+          enabledCipherSuites.toArray(new String[enabledCipherSuites.size()]));
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/FormBodyTest.java b/okhttp-tests/src/test/java/okhttp3/FormBodyTest.java
new file mode 100644
index 0000000000..b0cb8a6d0f
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/FormBodyTest.java
@@ -0,0 +1,213 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import okio.Buffer;
+import org.junit.Test;
+import java.nio.charset.Charset;
+
+import static org.junit.Assert.assertEquals;
+
+public final class FormBodyTest {
+  @Test public void urlEncoding() throws Exception {
+    FormBody body = new FormBody.Builder()
+        .add("a+=& b", "c+=& d")
+        .add("space, the", "final frontier")
+        .add("%25", "%25")
+        .build();
+
+    assertEquals(3, body.size());
+
+    assertEquals("a%2B%3D%26%20b", body.encodedName(0));
+    assertEquals("space%2C%20the", body.encodedName(1));
+    assertEquals("%2525", body.encodedName(2));
+
+    assertEquals("a+=& b", body.name(0));
+    assertEquals("space, the", body.name(1));
+    assertEquals("%25", body.name(2));
+
+    assertEquals("c%2B%3D%26%20d", body.encodedValue(0));
+    assertEquals("final%20frontier", body.encodedValue(1));
+    assertEquals("%2525", body.encodedValue(2));
+
+    assertEquals("c+=& d", body.value(0));
+    assertEquals("final frontier", body.value(1));
+    assertEquals("%25", body.value(2));
+
+    assertEquals("application/x-www-form-urlencoded", body.contentType().toString());
+
+    String expected = "a%2B%3D%26%20b=c%2B%3D%26%20d&space%2C%20the=final%20frontier&%2525=%2525";
+    assertEquals(expected.length(), body.contentLength());
+
+    Buffer out = new Buffer();
+    body.writeTo(out);
+    assertEquals(expected, out.readUtf8());
+  }
+
+  @Test public void addEncoded() throws Exception {
+    FormBody body = new FormBody.Builder()
+        .addEncoded("a+=& b", "c+=& d")
+        .addEncoded("e+=& f", "g+=& h")
+        .addEncoded("%25", "%25")
+        .build();
+
+    String expected = "a+%3D%26%20b=c+%3D%26%20d&e+%3D%26%20f=g+%3D%26%20h&%25=%25";
+    Buffer out = new Buffer();
+    body.writeTo(out);
+    assertEquals(expected, out.readUtf8());
+  }
+
+  @Test public void encodedPair() throws Exception {
+    FormBody body = new FormBody.Builder()
+        .add("sim", "ple")
+        .build();
+
+    String expected = "sim=ple";
+    assertEquals(expected.length(), body.contentLength());
+
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    assertEquals(expected, buffer.readUtf8());
+  }
+
+  @Test public void encodeMultiplePairs() throws Exception {
+    FormBody body = new FormBody.Builder()
+        .add("sim", "ple")
+        .add("hey", "there")
+        .add("help", "me")
+        .build();
+
+    String expected = "sim=ple&hey=there&help=me";
+    assertEquals(expected.length(), body.contentLength());
+
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    assertEquals(expected, buffer.readUtf8());
+  }
+
+  @Test public void buildEmptyForm() throws Exception {
+    FormBody body = new FormBody.Builder().build();
+
+    String expected = "";
+    assertEquals(expected.length(), body.contentLength());
+
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    assertEquals(expected, buffer.readUtf8());
+  }
+
+  @Test public void characterEncoding() throws Exception {
+    assertEquals("%00", formEncode(0)); // Browsers convert '\u0000' to '%EF%BF%BD'.
+    assertEquals("%01", formEncode(1));
+    assertEquals("%02", formEncode(2));
+    assertEquals("%03", formEncode(3));
+    assertEquals("%04", formEncode(4));
+    assertEquals("%05", formEncode(5));
+    assertEquals("%06", formEncode(6));
+    assertEquals("%07", formEncode(7));
+    assertEquals("%08", formEncode(8));
+    assertEquals("%09", formEncode(9));
+    assertEquals("%0A", formEncode(10)); // Browsers convert '\n' to '\r\n'
+    assertEquals("%0B", formEncode(11));
+    assertEquals("%0C", formEncode(12));
+    assertEquals("%0D", formEncode(13)); // Browsers convert '\r' to '\r\n'
+    assertEquals("%0E", formEncode(14));
+    assertEquals("%0F", formEncode(15));
+    assertEquals("%10", formEncode(16));
+    assertEquals("%11", formEncode(17));
+    assertEquals("%12", formEncode(18));
+    assertEquals("%13", formEncode(19));
+    assertEquals("%14", formEncode(20));
+    assertEquals("%15", formEncode(21));
+    assertEquals("%16", formEncode(22));
+    assertEquals("%17", formEncode(23));
+    assertEquals("%18", formEncode(24));
+    assertEquals("%19", formEncode(25));
+    assertEquals("%1A", formEncode(26));
+    assertEquals("%1B", formEncode(27));
+    assertEquals("%1C", formEncode(28));
+    assertEquals("%1D", formEncode(29));
+    assertEquals("%1E", formEncode(30));
+    assertEquals("%1F", formEncode(31));
+    assertEquals("%20", formEncode(32)); // Browsers use '+' for space.
+    assertEquals("%21", formEncode(33));
+    assertEquals("%22", formEncode(34));
+    assertEquals("%23", formEncode(35));
+    assertEquals("%24", formEncode(36));
+    assertEquals("%25", formEncode(37));
+    assertEquals("%26", formEncode(38));
+    assertEquals("%27", formEncode(39));
+    assertEquals("%28", formEncode(40));
+    assertEquals("%29", formEncode(41));
+    assertEquals("*", formEncode(42));
+    assertEquals("%2B", formEncode(43));
+    assertEquals("%2C", formEncode(44));
+    assertEquals("-", formEncode(45));
+    assertEquals(".", formEncode(46));
+    assertEquals("%2F", formEncode(47));
+    assertEquals("0", formEncode(48));
+    assertEquals("9", formEncode(57));
+    assertEquals("%3A", formEncode(58));
+    assertEquals("%3B", formEncode(59));
+    assertEquals("%3C", formEncode(60));
+    assertEquals("%3D", formEncode(61));
+    assertEquals("%3E", formEncode(62));
+    assertEquals("%3F", formEncode(63));
+    assertEquals("%40", formEncode(64));
+    assertEquals("A", formEncode(65));
+    assertEquals("Z", formEncode(90));
+    assertEquals("%5B", formEncode(91));
+    assertEquals("%5C", formEncode(92));
+    assertEquals("%5D", formEncode(93));
+    assertEquals("%5E", formEncode(94));
+    assertEquals("_", formEncode(95));
+    assertEquals("%60", formEncode(96));
+    assertEquals("a", formEncode(97));
+    assertEquals("z", formEncode(122));
+    assertEquals("%7B", formEncode(123));
+    assertEquals("%7C", formEncode(124));
+    assertEquals("%7D", formEncode(125));
+    assertEquals("%7E", formEncode(126));
+    assertEquals("%7F", formEncode(127));
+    assertEquals("%C2%80", formEncode(128));
+    assertEquals("%C3%BF", formEncode(255));
+  }
+
+  private String formEncode(int codePoint) throws IOException {
+    // Wrap the codepoint with regular printable characters to prevent trimming.
+    FormBody body = new FormBody.Builder()
+        .add("a", new String(new int[] {'b', codePoint, 'c'}, 0, 3))
+        .build();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    buffer.skip(3); // Skip "a=b" prefix.
+    return buffer.readUtf8(buffer.size() - 1); // Skip the "c" suffix.
+  }
+
+  @Test public void manualCharset() throws Exception {
+    FormBody body = new FormBody.Builder(Charset.forName("ISO-8859-1"))
+        .add("name", "Nicolás")
+        .build();
+
+    String expected = "name=Nicol%E1s";
+    assertEquals(expected.length(), body.contentLength());
+
+    Buffer out = new Buffer();
+    body.writeTo(out);
+    assertEquals(expected, out.readUtf8());
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/HeadersTest.java b/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
new file mode 100644
index 0000000000..24dfe878d1
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
@@ -0,0 +1,474 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import okhttp3.internal.Internal;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.HttpHeaders;
+import okhttp3.internal.http2.Header;
+import okhttp3.internal.http2.Http2Codec;
+import org.junit.Test;
+
+import static okhttp3.TestUtil.headerEntries;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class HeadersTest {
+  static {
+    Internal.initializeInstanceForTests();
+  }
+
+  @Test public void readNameValueBlockDropsForbiddenHeadersHttp2() throws IOException {
+    List<Header> headerBlock = headerEntries(
+        ":status", "200 OK",
+        ":version", "HTTP/1.1",
+        "connection", "close");
+    Request request = new Request.Builder().url("http://square.com/").build();
+    Response response = Http2Codec.readHttp2HeadersList(headerBlock).request(request).build();
+    Headers headers = response.headers();
+    assertEquals(1, headers.size());
+    assertEquals(":version", headers.name(0));
+    assertEquals("HTTP/1.1", headers.value(0));
+  }
+
+  @Test public void http2HeadersListDropsForbiddenHeadersHttp2() {
+    Request request = new Request.Builder()
+        .url("http://square.com/")
+        .header("Connection", "upgrade")
+        .header("Upgrade", "websocket")
+        .header("Host", "square.com")
+        .build();
+    List<Header> expected = headerEntries(
+        ":method", "GET",
+        ":path", "/",
+        ":authority", "square.com",
+        ":scheme", "http");
+    assertEquals(expected, Http2Codec.http2HeadersList(request));
+  }
+
+  @Test public void ofTrims() {
+    Headers headers = Headers.of("\t User-Agent \n", " \r OkHttp ");
+    assertEquals("User-Agent", headers.name(0));
+    assertEquals("OkHttp", headers.value(0));
+  }
+
+  @Test public void addParsing() {
+    Headers headers = new Headers.Builder()
+        .add("foo: bar")
+        .add(" foo: baz") // Name leading whitespace is trimmed.
+        .add("foo : bak") // Name trailing whitespace is trimmed.
+        .add("\tkey\t:\tvalue\t") // '\t' also counts as whitespace
+        .add("ping:  pong  ") // Value whitespace is trimmed.
+        .add("kit:kat") // Space after colon is not required.
+        .build();
+    assertEquals(Arrays.asList("bar", "baz", "bak"), headers.values("foo"));
+    assertEquals(Arrays.asList("value"), headers.values("key"));
+    assertEquals(Arrays.asList("pong"), headers.values("ping"));
+    assertEquals(Arrays.asList("kat"), headers.values("kit"));
+  }
+
+  @Test public void addThrowsOnEmptyName() {
+    try {
+      new Headers.Builder().add(": bar");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      new Headers.Builder().add(" : bar");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void addThrowsOnNoColon() {
+    try {
+      new Headers.Builder().add("foo bar");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void addThrowsOnMultiColon() {
+    try {
+      new Headers.Builder().add(":status: 200 OK");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void ofThrowsOddNumberOfHeaders() {
+    try {
+      Headers.of("User-Agent", "OkHttp", "Content-Length");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void ofThrowsOnNull() {
+    try {
+      Headers.of("User-Agent", null);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void ofThrowsOnEmptyName() {
+    try {
+      Headers.of("", "OkHttp");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void ofAcceptsEmptyValue() {
+    Headers headers = Headers.of("User-Agent", "");
+    assertEquals("", headers.value(0));
+  }
+
+  @Test public void ofMakesDefensiveCopy() {
+    String[] namesAndValues = {
+        "User-Agent",
+        "OkHttp"
+    };
+    Headers headers = Headers.of(namesAndValues);
+    namesAndValues[1] = "Chrome";
+    assertEquals("OkHttp", headers.value(0));
+  }
+
+  @Test public void ofRejectsNulChar() {
+    try {
+      Headers.of("User-Agent", "Square\u0000OkHttp");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void ofMapThrowsOnNull() {
+    try {
+      Headers.of(Collections.<String, String>singletonMap("User-Agent", null));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void ofMapThrowsOnEmptyName() {
+    try {
+      Headers.of(Collections.singletonMap("", "OkHttp"));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void ofMapThrowsOnBlankName() {
+    try {
+      Headers.of(Collections.singletonMap(" ", "OkHttp"));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void ofMapAcceptsEmptyValue() {
+    Headers headers = Headers.of(Collections.singletonMap("User-Agent", ""));
+    assertEquals("", headers.value(0));
+  }
+
+  @Test public void ofMapTrimsKey() {
+    Headers headers = Headers.of(Collections.singletonMap(" User-Agent ", "OkHttp"));
+    assertEquals("User-Agent", headers.name(0));
+  }
+
+  @Test public void ofMapTrimsValue() {
+    Headers headers = Headers.of(Collections.singletonMap("User-Agent", " OkHttp "));
+    assertEquals("OkHttp", headers.value(0));
+  }
+
+  @Test public void ofMapMakesDefensiveCopy() {
+    Map<String, String> namesAndValues = new LinkedHashMap<>();
+    namesAndValues.put("User-Agent", "OkHttp");
+
+    Headers headers = Headers.of(namesAndValues);
+    namesAndValues.put("User-Agent", "Chrome");
+    assertEquals("OkHttp", headers.value(0));
+  }
+
+  @Test public void ofMapRejectsNulCharInName() {
+    try {
+      Headers.of(Collections.singletonMap("User-Agent", "Square\u0000OkHttp"));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void ofMapRejectsNulCharInValue() {
+    try {
+      Headers.of(Collections.singletonMap("User-\u0000Agent", "OkHttp"));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void toMultimapGroupsHeaders() {
+    Headers headers = Headers.of(
+        "cache-control", "no-cache",
+        "cache-control", "no-store",
+        "user-agent", "OkHttp");
+    Map<String, List<String>> headerMap = headers.toMultimap();
+    assertEquals(2, headerMap.get("cache-control").size());
+    assertEquals(1, headerMap.get("user-agent").size());
+  }
+
+  @Test public void toMultimapUsesCanonicalCase() {
+    Headers headers = Headers.of(
+        "cache-control", "no-store",
+        "Cache-Control", "no-cache",
+        "User-Agent", "OkHttp");
+    Map<String, List<String>> headerMap = headers.toMultimap();
+    assertEquals(2, headerMap.get("cache-control").size());
+    assertEquals(1, headerMap.get("user-agent").size());
+  }
+
+  @Test public void toMultimapAllowsCaseInsensitiveGet() {
+    Headers headers = Headers.of(
+            "cache-control", "no-store",
+            "Cache-Control", "no-cache");
+    Map<String, List<String>> headerMap = headers.toMultimap();
+    assertEquals(2, headerMap.get("cache-control").size());
+    assertEquals(2, headerMap.get("Cache-Control").size());
+  }
+
+  @Test public void nameIndexesAreStrict() {
+    Headers headers = Headers.of("a", "b", "c", "d");
+    try {
+      headers.name(-1);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+    assertEquals("a", headers.name(0));
+    assertEquals("c", headers.name(1));
+    try {
+      headers.name(2);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+  }
+
+  @Test public void valueIndexesAreStrict() {
+    Headers headers = Headers.of("a", "b", "c", "d");
+    try {
+      headers.value(-1);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+    assertEquals("b", headers.value(0));
+    assertEquals("d", headers.value(1));
+    try {
+      headers.value(2);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+  }
+
+  @Test public void builderRejectsUnicodeInHeaderName() {
+    try {
+      new Headers.Builder().add("héader1", "value1");
+      fail("Should have complained about invalid name");
+    } catch (IllegalArgumentException expected) {
+      assertEquals("Unexpected char 0xe9 at 1 in header name: héader1",
+          expected.getMessage());
+    }
+  }
+
+  @Test public void builderRejectsUnicodeInHeaderValue() {
+    try {
+      new Headers.Builder().add("header1", "valué1");
+      fail("Should have complained about invalid value");
+    } catch (IllegalArgumentException expected) {
+      assertEquals("Unexpected char 0xe9 at 4 in header1 value: valué1",
+          expected.getMessage());
+    }
+  }
+
+  @Test public void headersEquals() {
+    Headers headers1 = new Headers.Builder()
+        .add("Connection", "close")
+        .add("Transfer-Encoding", "chunked")
+        .build();
+    Headers headers2 = new Headers.Builder()
+        .add("Connection", "close")
+        .add("Transfer-Encoding", "chunked")
+        .build();
+    assertTrue(headers1.equals(headers2));
+    assertEquals(headers1.hashCode(), headers2.hashCode());
+  }
+
+  @Test public void headersNotEquals() {
+    Headers headers1 = new Headers.Builder()
+        .add("Connection", "close")
+        .add("Transfer-Encoding", "chunked")
+        .build();
+    Headers headers2 = new Headers.Builder()
+        .add("Connection", "keep-alive")
+        .add("Transfer-Encoding", "chunked")
+        .build();
+    assertFalse(headers1.equals(headers2));
+    assertFalse(headers1.hashCode() == headers2.hashCode());
+  }
+
+  @Test public void headersToString() {
+    Headers headers = new Headers.Builder()
+        .add("A", "a")
+        .add("B", "bb")
+        .build();
+    assertEquals("A: a\nB: bb\n", headers.toString());
+  }
+
+  /** See https://github.com/square/okhttp/issues/2780. */
+  @Test public void testDigestChallenges() {
+    // Strict RFC 2617 header.
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest realm=\"myrealm\", nonce=\"fjalskdflwejrlaskdfjlaskdjflaks"
+            + "jdflkasdf\", qop=\"auth\", stale=\"FALSE\"")
+        .build();
+    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    assertEquals(1, challenges.size());
+    assertEquals("Digest", challenges.get(0).scheme());
+    assertEquals("myrealm", challenges.get(0).realm());
+
+    // Not strict RFC 2617 header.
+    headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest qop=\"auth\", realm=\"myrealm\", nonce=\"fjalskdflwejrlask"
+            + "dfjlaskdjflaksjdflkasdf\", stale=\"FALSE\"")
+        .build();
+    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    assertEquals(1, challenges.size());
+    assertEquals("Digest", challenges.get(0).scheme());
+    assertEquals("myrealm", challenges.get(0).realm());
+
+    // Not strict RFC 2617 header #2.
+    headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest qop=\"auth\", nonce=\"fjalskdflwejrlaskdfjlaskdjflaksjdflk"
+            + "asdf\", realm=\"myrealm\", stale=\"FALSE\"")
+        .build();
+    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    assertEquals(1, challenges.size());
+    assertEquals("Digest", challenges.get(0).scheme());
+    assertEquals("myrealm", challenges.get(0).realm());
+
+    // Wrong header.
+    headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest qop=\"auth\", underrealm=\"myrealm\", nonce=\"fjalskdflwej"
+            + "rlaskdfjlaskdjflaksjdflkasdf\", stale=\"FALSE\"")
+        .build();
+    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    assertEquals(0, challenges.size());
+
+    // Not strict RFC 2617 header with some spaces.
+    headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest qop=\"auth\",    realm=\"myrealm\", nonce=\"fjalskdflwejrl"
+            + "askdfjlaskdjflaksjdflkasdf\", stale=\"FALSE\"")
+        .build();
+    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    assertEquals(1, challenges.size());
+    assertEquals("Digest", challenges.get(0).scheme());
+    assertEquals("myrealm", challenges.get(0).realm());
+
+    // Strict RFC 2617 header with some spaces.
+    headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest    realm=\"myrealm\", nonce=\"fjalskdflwejrlaskdfjlaskdjfl"
+            + "aksjdflkasdf\", qop=\"auth\", stale=\"FALSE\"")
+        .build();
+    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    assertEquals(1, challenges.size());
+    assertEquals("Digest", challenges.get(0).scheme());
+    assertEquals("myrealm", challenges.get(0).realm());
+
+    // Not strict RFC 2617 camelcased.
+    headers = new Headers.Builder()
+        .add("WWW-Authenticate", "DiGeSt qop=\"auth\", rEaLm=\"myrealm\", nonce=\"fjalskdflwejrlask"
+            + "dfjlaskdjflaksjdflkasdf\", stale=\"FALSE\"")
+        .build();
+    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    assertEquals(1, challenges.size());
+    assertEquals("DiGeSt", challenges.get(0).scheme());
+    assertEquals("myrealm", challenges.get(0).realm());
+
+    // Strict RFC 2617 camelcased.
+    headers = new Headers.Builder()
+        .add("WWW-Authenticate", "DIgEsT rEaLm=\"myrealm\", nonce=\"fjalskdflwejrlaskdfjlaskdjflaks"
+            + "jdflkasdf\", qop=\"auth\", stale=\"FALSE\"")
+        .build();
+    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    assertEquals(1, challenges.size());
+    assertEquals("DIgEsT", challenges.get(0).scheme());
+    assertEquals("myrealm", challenges.get(0).realm());
+
+    // Unquoted.
+    headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest realm=myrealm").build();
+    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    assertEquals(0, challenges.size());
+
+    // Scheme only.
+    headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest").build();
+    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    assertEquals(0, challenges.size());
+  }
+
+  @Test public void basicChallenge() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate: Basic realm=\"protected area\"")
+        .build();
+    assertEquals(Arrays.asList(new Challenge("Basic", "protected area")),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void basicChallengeWithCharset() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate: Basic realm=\"protected area\", charset=\"UTF-8\"")
+        .build();
+    assertEquals(Arrays.asList(new Challenge("Basic", "protected area").withCharset(Util.UTF_8)),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void basicChallengeWithUnexpectedCharset() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate: Basic realm=\"protected area\", charset=\"US-ASCII\"")
+        .build();
+    assertEquals(Collections.emptyList(), HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void byteCount() {
+    assertEquals(0L, new Headers.Builder().build().byteCount());
+    assertEquals(10L, new Headers.Builder()
+        .add("abc", "def")
+        .build()
+        .byteCount());
+    assertEquals(20L, new Headers.Builder()
+        .add("abc", "def")
+        .add("ghi", "jkl")
+        .build()
+        .byteCount());
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java b/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
new file mode 100644
index 0000000000..a51830e78c
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
@@ -0,0 +1,1517 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.net.MalformedURLException;
+import java.net.URI;
+import java.net.URL;
+import java.net.UnknownHostException;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.LinkedHashSet;
+import okhttp3.UrlComponentEncodingTester.Component;
+import okhttp3.UrlComponentEncodingTester.Encoding;
+import org.junit.Ignore;
+import org.junit.Test;
+
+import static java.util.Collections.singletonList;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.fail;
+
+public final class HttpUrlTest {
+  @Test public void parseTrimsAsciiWhitespace() throws Exception {
+    HttpUrl expected = HttpUrl.parse("http://host/");
+    assertEquals(expected, HttpUrl.parse("http://host/\f\n\t \r")); // Leading.
+    assertEquals(expected, HttpUrl.parse("\r\n\f \thttp://host/")); // Trailing.
+    assertEquals(expected, HttpUrl.parse(" http://host/ ")); // Both.
+    assertEquals(expected, HttpUrl.parse("    http://host/    ")); // Both.
+    assertEquals(expected, HttpUrl.parse("http://host/").resolve("   "));
+    assertEquals(expected, HttpUrl.parse("http://host/").resolve("  .  "));
+  }
+
+  @Test public void parseHostAsciiNonPrintable() throws Exception {
+    String host = "host\u0001";
+    assertNull(HttpUrl.parse("http://" + host + "/"));
+  }
+
+  @Test public void parseDoesNotTrimOtherWhitespaceCharacters() throws Exception {
+    // Whitespace characters list from Google's Guava team: http://goo.gl/IcR9RD
+    assertEquals("/%0B", HttpUrl.parse("http://h/\u000b").encodedPath()); // line tabulation
+    assertEquals("/%1C", HttpUrl.parse("http://h/\u001c").encodedPath()); // information separator 4
+    assertEquals("/%1D", HttpUrl.parse("http://h/\u001d").encodedPath()); // information separator 3
+    assertEquals("/%1E", HttpUrl.parse("http://h/\u001e").encodedPath()); // information separator 2
+    assertEquals("/%1F", HttpUrl.parse("http://h/\u001f").encodedPath()); // information separator 1
+    assertEquals("/%C2%85", HttpUrl.parse("http://h/\u0085").encodedPath()); // next line
+    assertEquals("/%C2%A0", HttpUrl.parse("http://h/\u00a0").encodedPath()); // non-breaking space
+    assertEquals("/%E1%9A%80", HttpUrl.parse("http://h/\u1680").encodedPath()); // ogham space mark
+    assertEquals("/%E1%A0%8E", HttpUrl.parse("http://h/\u180e").encodedPath()); // mongolian vowel separator
+    assertEquals("/%E2%80%80", HttpUrl.parse("http://h/\u2000").encodedPath()); // en quad
+    assertEquals("/%E2%80%81", HttpUrl.parse("http://h/\u2001").encodedPath()); // em quad
+    assertEquals("/%E2%80%82", HttpUrl.parse("http://h/\u2002").encodedPath()); // en space
+    assertEquals("/%E2%80%83", HttpUrl.parse("http://h/\u2003").encodedPath()); // em space
+    assertEquals("/%E2%80%84", HttpUrl.parse("http://h/\u2004").encodedPath()); // three-per-em space
+    assertEquals("/%E2%80%85", HttpUrl.parse("http://h/\u2005").encodedPath()); // four-per-em space
+    assertEquals("/%E2%80%86", HttpUrl.parse("http://h/\u2006").encodedPath()); // six-per-em space
+    assertEquals("/%E2%80%87", HttpUrl.parse("http://h/\u2007").encodedPath()); // figure space
+    assertEquals("/%E2%80%88", HttpUrl.parse("http://h/\u2008").encodedPath()); // punctuation space
+    assertEquals("/%E2%80%89", HttpUrl.parse("http://h/\u2009").encodedPath()); // thin space
+    assertEquals("/%E2%80%8A", HttpUrl.parse("http://h/\u200a").encodedPath()); // hair space
+    assertEquals("/%E2%80%8B", HttpUrl.parse("http://h/\u200b").encodedPath()); // zero-width space
+    assertEquals("/%E2%80%8C", HttpUrl.parse("http://h/\u200c").encodedPath()); // zero-width non-joiner
+    assertEquals("/%E2%80%8D", HttpUrl.parse("http://h/\u200d").encodedPath()); // zero-width joiner
+    assertEquals("/%E2%80%8E", HttpUrl.parse("http://h/\u200e").encodedPath()); // left-to-right mark
+    assertEquals("/%E2%80%8F", HttpUrl.parse("http://h/\u200f").encodedPath()); // right-to-left mark
+    assertEquals("/%E2%80%A8", HttpUrl.parse("http://h/\u2028").encodedPath()); // line separator
+    assertEquals("/%E2%80%A9", HttpUrl.parse("http://h/\u2029").encodedPath()); // paragraph separator
+    assertEquals("/%E2%80%AF", HttpUrl.parse("http://h/\u202f").encodedPath()); // narrow non-breaking space
+    assertEquals("/%E2%81%9F", HttpUrl.parse("http://h/\u205f").encodedPath()); // medium mathematical space
+    assertEquals("/%E3%80%80", HttpUrl.parse("http://h/\u3000").encodedPath()); // ideographic space
+  }
+
+  @Test public void scheme() throws Exception {
+    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("http://host/"));
+    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("Http://host/"));
+    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("http://host/"));
+    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("HTTP://host/"));
+    assertEquals(HttpUrl.parse("https://host/"), HttpUrl.parse("https://host/"));
+    assertEquals(HttpUrl.parse("https://host/"), HttpUrl.parse("HTTPS://host/"));
+    assertEquals(HttpUrl.Builder.ParseResult.UNSUPPORTED_SCHEME,
+        new HttpUrl.Builder().parse(null, "image640://480.png"));
+    assertEquals(null, HttpUrl.parse("httpp://host/"));
+    assertEquals(null, HttpUrl.parse("0ttp://host/"));
+    assertEquals(null, HttpUrl.parse("ht+tp://host/"));
+    assertEquals(null, HttpUrl.parse("ht.tp://host/"));
+    assertEquals(null, HttpUrl.parse("ht-tp://host/"));
+    assertEquals(null, HttpUrl.parse("ht1tp://host/"));
+    assertEquals(null, HttpUrl.parse("httpss://host/"));
+  }
+
+  @Test public void parseNoScheme() throws Exception {
+    assertEquals(null, HttpUrl.parse("//host"));
+    assertEquals(null, HttpUrl.parse("/path"));
+    assertEquals(null, HttpUrl.parse("path"));
+    assertEquals(null, HttpUrl.parse("?query"));
+    assertEquals(null, HttpUrl.parse("#fragment"));
+  }
+
+  @Test public void newBuilderResolve() throws Exception {
+    // Non-exhaustive tests because implementation is the same as resolve.
+    HttpUrl base = HttpUrl.parse("http://host/a/b");
+    assertEquals(HttpUrl.parse("https://host2/"), base.newBuilder("https://host2").build());
+    assertEquals(HttpUrl.parse("http://host2/"), base.newBuilder("//host2").build());
+    assertEquals(HttpUrl.parse("http://host/path"), base.newBuilder("/path").build());
+    assertEquals(HttpUrl.parse("http://host/a/path"), base.newBuilder("path").build());
+    assertEquals(HttpUrl.parse("http://host/a/b?query"), base.newBuilder("?query").build());
+    assertEquals(HttpUrl.parse("http://host/a/b#fragment"), base.newBuilder("#fragment").build());
+    assertEquals(HttpUrl.parse("http://host/a/b"), base.newBuilder("").build());
+    assertEquals(null, base.newBuilder("ftp://b"));
+    assertEquals(null, base.newBuilder("ht+tp://b"));
+    assertEquals(null, base.newBuilder("ht-tp://b"));
+    assertEquals(null, base.newBuilder("ht.tp://b"));
+  }
+
+  @Test public void redactedUrl() {
+    HttpUrl baseWithPasswordAndUsername = HttpUrl.parse("http://username:password@host/a/b#fragment");
+    HttpUrl baseWithUsernameOnly = HttpUrl.parse("http://username@host/a/b#fragment");
+    HttpUrl baseWithPasswordOnly = HttpUrl.parse("http://password@host/a/b#fragment");
+    assertEquals("http://host/...", baseWithPasswordAndUsername.redact());
+    assertEquals("http://host/...", baseWithUsernameOnly.redact());
+    assertEquals("http://host/...", baseWithPasswordOnly.redact());
+  }
+
+  @Test public void resolveNoScheme() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b");
+    assertEquals(HttpUrl.parse("http://host2/"), base.resolve("//host2"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("/path"));
+    assertEquals(HttpUrl.parse("http://host/a/path"), base.resolve("path"));
+    assertEquals(HttpUrl.parse("http://host/a/b?query"), base.resolve("?query"));
+    assertEquals(HttpUrl.parse("http://host/a/b#fragment"), base.resolve("#fragment"));
+    assertEquals(HttpUrl.parse("http://host/a/b"), base.resolve(""));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("\\path"));
+  }
+
+  @Test public void resolveUnsupportedScheme() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://a/");
+    assertEquals(null, base.resolve("ftp://b"));
+    assertEquals(null, base.resolve("ht+tp://b"));
+    assertEquals(null, base.resolve("ht-tp://b"));
+    assertEquals(null, base.resolve("ht.tp://b"));
+  }
+
+  @Test public void resolveSchemeLikePath() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://a/");
+    assertEquals(HttpUrl.parse("http://a/http//b/"), base.resolve("http//b/"));
+    assertEquals(HttpUrl.parse("http://a/ht+tp//b/"), base.resolve("ht+tp//b/"));
+    assertEquals(HttpUrl.parse("http://a/ht-tp//b/"), base.resolve("ht-tp//b/"));
+    assertEquals(HttpUrl.parse("http://a/ht.tp//b/"), base.resolve("ht.tp//b/"));
+  }
+
+  /** https://tools.ietf.org/html/rfc3986#section-5.4.1 */
+  @Test public void rfc3886NormalExamples() {
+    HttpUrl url = HttpUrl.parse("http://a/b/c/d;p?q");
+    assertEquals(null, url.resolve("g:h")); // No 'g:' scheme in HttpUrl.
+    assertEquals(HttpUrl.parse("http://a/b/c/g"), url.resolve("g"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g"), url.resolve("./g"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g/"), url.resolve("g/"));
+    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("/g"));
+    assertEquals(HttpUrl.parse("http://g"), url.resolve("//g"));
+    assertEquals(HttpUrl.parse("http://a/b/c/d;p?y"), url.resolve("?y"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g?y"), url.resolve("g?y"));
+    assertEquals(HttpUrl.parse("http://a/b/c/d;p?q#s"), url.resolve("#s"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g#s"), url.resolve("g#s"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g?y#s"), url.resolve("g?y#s"));
+    assertEquals(HttpUrl.parse("http://a/b/c/;x"), url.resolve(";x"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g;x"), url.resolve("g;x"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g;x?y#s"), url.resolve("g;x?y#s"));
+    assertEquals(HttpUrl.parse("http://a/b/c/d;p?q"), url.resolve(""));
+    assertEquals(HttpUrl.parse("http://a/b/c/"), url.resolve("."));
+    assertEquals(HttpUrl.parse("http://a/b/c/"), url.resolve("./"));
+    assertEquals(HttpUrl.parse("http://a/b/"), url.resolve(".."));
+    assertEquals(HttpUrl.parse("http://a/b/"), url.resolve("../"));
+    assertEquals(HttpUrl.parse("http://a/b/g"), url.resolve("../g"));
+    assertEquals(HttpUrl.parse("http://a/"), url.resolve("../.."));
+    assertEquals(HttpUrl.parse("http://a/"), url.resolve("../../"));
+    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("../../g"));
+  }
+
+  /** https://tools.ietf.org/html/rfc3986#section-5.4.2 */
+  @Test public void rfc3886AbnormalExamples() {
+    HttpUrl url = HttpUrl.parse("http://a/b/c/d;p?q");
+    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("../../../g"));
+    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("../../../../g"));
+    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("/./g"));
+    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("/../g"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g."), url.resolve("g."));
+    assertEquals(HttpUrl.parse("http://a/b/c/.g"), url.resolve(".g"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g.."), url.resolve("g.."));
+    assertEquals(HttpUrl.parse("http://a/b/c/..g"), url.resolve("..g"));
+    assertEquals(HttpUrl.parse("http://a/b/g"), url.resolve("./../g"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g/"), url.resolve("./g/."));
+    assertEquals(HttpUrl.parse("http://a/b/c/g/h"), url.resolve("g/./h"));
+    assertEquals(HttpUrl.parse("http://a/b/c/h"), url.resolve("g/../h"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g;x=1/y"), url.resolve("g;x=1/./y"));
+    assertEquals(HttpUrl.parse("http://a/b/c/y"), url.resolve("g;x=1/../y"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g?y/./x"), url.resolve("g?y/./x"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g?y/../x"), url.resolve("g?y/../x"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g#s/./x"), url.resolve("g#s/./x"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g#s/../x"), url.resolve("g#s/../x"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g"), url.resolve("http:g")); // "http:g" also okay.
+  }
+
+  @Test public void parseAuthoritySlashCountDoesntMatter() throws Exception {
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:/host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http://host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\/host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:/\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:///host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\//host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:/\\/host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http://\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\\\/host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:/\\\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\\\\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:////host/path"));
+  }
+
+  @Test public void resolveAuthoritySlashCountDoesntMatterWithDifferentScheme() throws Exception {
+    HttpUrl base = HttpUrl.parse("https://a/b/c");
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http://host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\/host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:///host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\//host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\/host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http://\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\/host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:////host/path"));
+  }
+
+  @Test public void resolveAuthoritySlashCountMattersWithSameScheme() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://a/b/c");
+    assertEquals(HttpUrl.parse("http://a/b/host/path"), base.resolve("http:host/path"));
+    assertEquals(HttpUrl.parse("http://a/host/path"), base.resolve("http:/host/path"));
+    assertEquals(HttpUrl.parse("http://a/host/path"), base.resolve("http:\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http://host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\/host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:///host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\//host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\/host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http://\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\/host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:////host/path"));
+  }
+
+  @Test public void username() throws Exception {
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http://@host/path"));
+    assertEquals(HttpUrl.parse("http://user@host/path"), HttpUrl.parse("http://user@host/path"));
+  }
+
+  /** Given multiple '@' characters, the last one is the delimiter. */
+  @Test public void authorityWithMultipleAtSigns() throws Exception {
+    HttpUrl httpUrl = HttpUrl.parse("http://foo@bar@baz/path");
+    assertEquals("foo@bar", httpUrl.username());
+    assertEquals("", httpUrl.password());
+    assertEquals(HttpUrl.parse("http://foo%40bar@baz/path"), httpUrl);
+  }
+
+  /** Given multiple ':' characters, the first one is the delimiter. */
+  @Test public void authorityWithMultipleColons() throws Exception {
+    HttpUrl httpUrl = HttpUrl.parse("http://foo:pass1@bar:pass2@baz/path");
+    assertEquals("foo", httpUrl.username());
+    assertEquals("pass1@bar:pass2", httpUrl.password());
+    assertEquals(HttpUrl.parse("http://foo:pass1%40bar%3Apass2@baz/path"), httpUrl);
+  }
+
+  @Test public void usernameAndPassword() throws Exception {
+    assertEquals(HttpUrl.parse("http://username:password@host/path"),
+        HttpUrl.parse("http://username:password@host/path"));
+    assertEquals(HttpUrl.parse("http://username@host/path"),
+        HttpUrl.parse("http://username:@host/path"));
+  }
+
+  @Test public void passwordWithEmptyUsername() throws Exception {
+    // Chrome doesn't mind, but Firefox rejects URLs with empty usernames and non-empty passwords.
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http://:@host/path"));
+    assertEquals("password%40", HttpUrl.parse("http://:password@@host/path").encodedPassword());
+  }
+
+  @Test public void unprintableCharactersArePercentEncoded() throws Exception {
+    assertEquals("/%00", HttpUrl.parse("http://host/\u0000").encodedPath());
+    assertEquals("/%08", HttpUrl.parse("http://host/\u0008").encodedPath());
+    assertEquals("/%EF%BF%BD", HttpUrl.parse("http://host/\ufffd").encodedPath());
+  }
+
+  @Test public void usernameCharacters() throws Exception {
+    new UrlComponentEncodingTester()
+        .override(Encoding.PERCENT, '[', ']', '{', '}', '|', '^', '\'', ';', '=', '@')
+        .override(Encoding.SKIP, ':', '/', '\\', '?', '#')
+        .skipForUri('%')
+        .test(Component.USER);
+  }
+
+  @Test public void passwordCharacters() throws Exception {
+    new UrlComponentEncodingTester()
+        .override(Encoding.PERCENT, '[', ']', '{', '}', '|', '^', '\'', ':', ';', '=', '@')
+        .override(Encoding.SKIP, '/', '\\', '?', '#')
+        .skipForUri('%')
+        .test(Component.PASSWORD);
+  }
+
+  @Test public void hostContainsIllegalCharacter() throws Exception {
+    assertEquals(null, HttpUrl.parse("http://\n/"));
+    assertEquals(null, HttpUrl.parse("http:// /"));
+    assertEquals(null, HttpUrl.parse("http://%20/"));
+  }
+
+  @Test public void hostnameLowercaseCharactersMappedDirectly() throws Exception {
+    assertEquals("abcd", HttpUrl.parse("http://abcd").host());
+    assertEquals("xn--4xa", HttpUrl.parse("http://σ").host());
+  }
+
+  @Test public void hostnameUppercaseCharactersConvertedToLowercase() throws Exception {
+    assertEquals("abcd", HttpUrl.parse("http://ABCD").host());
+    assertEquals("xn--4xa", HttpUrl.parse("http://Σ").host());
+  }
+
+  @Test public void hostnameIgnoredCharacters() throws Exception {
+    // The soft hyphen (­) should be ignored.
+    assertEquals("abcd", HttpUrl.parse("http://AB\u00adCD").host());
+  }
+
+  @Test public void hostnameMultipleCharacterMapping() throws Exception {
+    // Map the single character telephone symbol (℡) to the string "tel".
+    assertEquals("tel", HttpUrl.parse("http://\u2121").host());
+  }
+
+  @Test public void hostnameMappingLastMappedCodePoint() throws Exception {
+    assertEquals("xn--pu5l", HttpUrl.parse("http://\uD87E\uDE1D").host());
+  }
+
+  @Ignore("The java.net.IDN implementation doesn't ignore characters that it should.")
+  @Test public void hostnameMappingLastIgnoredCodePoint() throws Exception {
+    assertEquals("abcd", HttpUrl.parse("http://ab\uDB40\uDDEFcd").host());
+  }
+
+  @Test public void hostnameMappingLastDisallowedCodePoint() throws Exception {
+    assertEquals(null, HttpUrl.parse("http://\uDBFF\uDFFF"));
+  }
+
+  @Test public void hostIpv6() throws Exception {
+    // Square braces are absent from host()...
+    assertEquals("::1", HttpUrl.parse("http://[::1]/").host());
+
+    // ... but they're included in toString().
+    assertEquals("http://[::1]/", HttpUrl.parse("http://[::1]/").toString());
+
+    // IPv6 colons don't interfere with port numbers or passwords.
+    assertEquals(8080, HttpUrl.parse("http://[::1]:8080/").port());
+    assertEquals("password", HttpUrl.parse("http://user:password@[::1]/").password());
+    assertEquals("::1", HttpUrl.parse("http://user:password@[::1]:8080/").host());
+
+    // Permit the contents of IPv6 addresses to be percent-encoded...
+    assertEquals("::1", HttpUrl.parse("http://[%3A%3A%31]/").host());
+
+    // Including the Square braces themselves! (This is what Chrome does.)
+    assertEquals("::1", HttpUrl.parse("http://%5B%3A%3A1%5D/").host());
+  }
+
+  @Test public void hostIpv6AddressDifferentFormats() throws Exception {
+    // Multiple representations of the same address; see http://tools.ietf.org/html/rfc5952.
+    String a3 = "2001:db8::1:0:0:1";
+    assertEquals(a3, HttpUrl.parse("http://[2001:db8:0:0:1:0:0:1]").host());
+    assertEquals(a3, HttpUrl.parse("http://[2001:0db8:0:0:1:0:0:1]").host());
+    assertEquals(a3, HttpUrl.parse("http://[2001:db8::1:0:0:1]").host());
+    assertEquals(a3, HttpUrl.parse("http://[2001:db8::0:1:0:0:1]").host());
+    assertEquals(a3, HttpUrl.parse("http://[2001:0db8::1:0:0:1]").host());
+    assertEquals(a3, HttpUrl.parse("http://[2001:db8:0:0:1::1]").host());
+    assertEquals(a3, HttpUrl.parse("http://[2001:db8:0000:0:1::1]").host());
+    assertEquals(a3, HttpUrl.parse("http://[2001:DB8:0:0:1::1]").host());
+  }
+
+  @Test public void hostIpv6AddressLeadingCompression() throws Exception {
+    assertEquals("::1", HttpUrl.parse("http://[::0001]").host());
+    assertEquals("::1", HttpUrl.parse("http://[0000::0001]").host());
+    assertEquals("::1", HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0000:0001]").host());
+    assertEquals("::1", HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000::0001]").host());
+  }
+
+  @Test public void hostIpv6AddressTrailingCompression() throws Exception {
+    assertEquals("1::", HttpUrl.parse("http://[0001:0000::]").host());
+    assertEquals("1::", HttpUrl.parse("http://[0001::0000]").host());
+    assertEquals("1::", HttpUrl.parse("http://[0001::]").host());
+    assertEquals("1::", HttpUrl.parse("http://[1::]").host());
+  }
+
+  @Test public void hostIpv6AddressTooManyDigitsInGroup() throws Exception {
+    assertEquals(null, HttpUrl.parse("http://[00000:0000:0000:0000:0000:0000:0000:0001]"));
+    assertEquals(null, HttpUrl.parse("http://[::00001]"));
+  }
+
+  @Test public void hostIpv6AddressMisplacedColons() throws Exception {
+    assertEquals(null, HttpUrl.parse("http://[:0000:0000:0000:0000:0000:0000:0000:0001]"));
+    assertEquals(null, HttpUrl.parse("http://[:::0000:0000:0000:0000:0000:0000:0000:0001]"));
+    assertEquals(null, HttpUrl.parse("http://[:1]"));
+    assertEquals(null, HttpUrl.parse("http://[:::1]"));
+    assertEquals(null, HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0001:]"));
+    assertEquals(null, HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0000:0001:]"));
+    assertEquals(null, HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0000:0001::]"));
+    assertEquals(null, HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0000:0001:::]"));
+    assertEquals(null, HttpUrl.parse("http://[1:]"));
+    assertEquals(null, HttpUrl.parse("http://[1:::]"));
+    assertEquals(null, HttpUrl.parse("http://[1:::1]"));
+    assertEquals(null, HttpUrl.parse("http://[0000:0000:0000:0000::0000:0000:0000:0001]"));
+  }
+
+  @Test public void hostIpv6AddressTooManyGroups() throws Exception {
+    assertEquals(null, HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0000:0000:0001]"));
+  }
+
+  @Test public void hostIpv6AddressTooMuchCompression() throws Exception {
+    assertEquals(null, HttpUrl.parse("http://[0000::0000:0000:0000:0000::0001]"));
+    assertEquals(null, HttpUrl.parse("http://[::0000:0000:0000:0000::0001]"));
+  }
+
+  @Test public void hostIpv6ScopedAddress() throws Exception {
+    // java.net.InetAddress parses scoped addresses. These aren't valid in URLs.
+    assertEquals(null, HttpUrl.parse("http://[::1%2544]"));
+  }
+
+  @Test public void hostIpv6WithIpv4Suffix() throws Exception {
+    assertEquals("::1:ffff:ffff", HttpUrl.parse("http://[::1:255.255.255.255]/").host());
+    assertEquals("::1:0:0", HttpUrl.parse("http://[0:0:0:0:0:1:0.0.0.0]/").host());
+  }
+
+  @Test public void hostIpv6WithIpv4SuffixWithOctalPrefix() throws Exception {
+    // Chrome interprets a leading '0' as octal; Firefox rejects them. (We reject them.)
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.0.0.000000]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.010.0.010]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.0.0.000001]/"));
+  }
+
+  @Test public void hostIpv6WithIpv4SuffixWithHexadecimalPrefix() throws Exception {
+    // Chrome interprets a leading '0x' as hexadecimal; Firefox rejects them. (We reject them.)
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.0x10.0.0x10]/"));
+  }
+
+  @Test public void hostIpv6WithMalformedIpv4Suffix() throws Exception {
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.0:0.0]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.0-0.0]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:.255.255.255]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:255..255.255]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:255.255..255]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:0:1:255.255]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:256.255.255.255]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:ff.255.255.255]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:0:1:255.255.255.255]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:1:255.255.255.255]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:1:0.0.0.0:1]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0.0.0.0:1:0:0:0:0:1]/"));
+    assertEquals(null, HttpUrl.parse("http://[0.0.0.0:0:0:0:0:0:1]/"));
+  }
+
+  @Test public void hostIpv6WithIncompleteIpv4Suffix() throws Exception {
+    // To Chrome & Safari these are well-formed; Firefox disagrees. (We're consistent with Firefox).
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:255.255.255.]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:255.255.255]/"));
+  }
+
+  @Test public void hostIpv6CanonicalForm() throws Exception {
+    assertEquals("abcd:ef01:2345:6789:abcd:ef01:2345:6789",
+        HttpUrl.parse("http://[abcd:ef01:2345:6789:abcd:ef01:2345:6789]/").host());
+    assertEquals("a::b:0:0:0", HttpUrl.parse("http://[a:0:0:0:b:0:0:0]/").host());
+    assertEquals("a:b:0:0:c::", HttpUrl.parse("http://[a:b:0:0:c:0:0:0]/").host());
+    assertEquals("a:b::c:0:0", HttpUrl.parse("http://[a:b:0:0:0:c:0:0]/").host());
+    assertEquals("a::b:0:0:0", HttpUrl.parse("http://[a:0:0:0:b:0:0:0]/").host());
+    assertEquals("::a:b:0:0:0", HttpUrl.parse("http://[0:0:0:a:b:0:0:0]/").host());
+    assertEquals("::a:0:0:0:b", HttpUrl.parse("http://[0:0:0:a:0:0:0:b]/").host());
+    assertEquals("0:a:b:c:d:e:f:1", HttpUrl.parse("http://[0:a:b:c:d:e:f:1]/").host());
+    assertEquals("a:b:c:d:e:f:1:0", HttpUrl.parse("http://[a:b:c:d:e:f:1:0]/").host());
+    assertEquals("ff01::101", HttpUrl.parse("http://[FF01:0:0:0:0:0:0:101]/").host());
+    assertEquals("2001:db8::1", HttpUrl.parse("http://[2001:db8::1]/").host());
+    assertEquals("2001:db8::2:1", HttpUrl.parse("http://[2001:db8:0:0:0:0:2:1]/").host());
+    assertEquals("2001:db8:0:1:1:1:1:1", HttpUrl.parse("http://[2001:db8:0:1:1:1:1:1]/").host());
+    assertEquals("2001:db8::1:0:0:1", HttpUrl.parse("http://[2001:db8:0:0:1:0:0:1]/").host());
+    assertEquals("2001:0:0:1::1", HttpUrl.parse("http://[2001:0:0:1:0:0:0:1]/").host());
+    assertEquals("1::", HttpUrl.parse("http://[1:0:0:0:0:0:0:0]/").host());
+    assertEquals("::1", HttpUrl.parse("http://[0:0:0:0:0:0:0:1]/").host());
+    assertEquals("::", HttpUrl.parse("http://[0:0:0:0:0:0:0:0]/").host());
+  }
+
+  /** The builder permits square braces but does not require them. */
+  @Test public void hostIPv6Builder() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://example.com/");
+    assertEquals("http://[::1]/", base.newBuilder().host("[::1]").build().toString());
+    assertEquals("http://[::1]/", base.newBuilder().host("[::0001]").build().toString());
+    assertEquals("http://[::1]/", base.newBuilder().host("::1").build().toString());
+    assertEquals("http://[::1]/", base.newBuilder().host("::0001").build().toString());
+  }
+
+  @Test public void hostIpv4CanonicalForm() throws Exception {
+    assertEquals("255.255.255.255", HttpUrl.parse("http://255.255.255.255/").host());
+    assertEquals("1.2.3.4", HttpUrl.parse("http://1.2.3.4/").host());
+    assertEquals("0.0.0.0", HttpUrl.parse("http://0.0.0.0/").host());
+  }
+
+  @Ignore("java.net.IDN strips trailing trailing dots on Java 7, but not on Java 8.")
+  @Test public void hostWithTrailingDot() throws Exception {
+    assertEquals("host.", HttpUrl.parse("http://host./").host());
+  }
+
+  @Test public void port() throws Exception {
+    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("http://host:80/"));
+    assertEquals(HttpUrl.parse("http://host:99/"), HttpUrl.parse("http://host:99/"));
+    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("http://host:/"));
+    assertEquals(65535, HttpUrl.parse("http://host:65535/").port());
+    assertEquals(null, HttpUrl.parse("http://host:0/"));
+    assertEquals(null, HttpUrl.parse("http://host:65536/"));
+    assertEquals(null, HttpUrl.parse("http://host:-1/"));
+    assertEquals(null, HttpUrl.parse("http://host:a/"));
+    assertEquals(null, HttpUrl.parse("http://host:%39%39/"));
+  }
+
+  @Test public void pathCharacters() throws Exception {
+    new UrlComponentEncodingTester()
+        .override(Encoding.PERCENT, '^', '{', '}', '|')
+        .override(Encoding.SKIP, '\\', '?', '#')
+        .skipForUri('%', '[', ']')
+        .test(Component.PATH);
+  }
+
+  @Test public void queryCharacters() throws Exception {
+    new UrlComponentEncodingTester()
+        .override(Encoding.IDENTITY, '?', '`')
+        .override(Encoding.PERCENT, '\'')
+        .override(Encoding.SKIP, '#', '+')
+        .skipForUri('%', '\\', '^', '`', '{', '|', '}')
+        .test(Component.QUERY);
+  }
+
+  @Test public void fragmentCharacters() throws Exception {
+    new UrlComponentEncodingTester()
+        .override(Encoding.IDENTITY, ' ', '"', '#', '<', '>', '?', '`')
+        .skipForUri('%', ' ', '"', '#', '<', '>', '\\', '^', '`', '{', '|', '}')
+        .identityForNonAscii()
+        .test(Component.FRAGMENT);
+  }
+
+  @Test public void fragmentNonAscii() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/#Σ");
+    assertEquals("http://host/#Σ", url.toString());
+    assertEquals("Σ", url.fragment());
+    assertEquals("Σ", url.encodedFragment());
+    assertEquals("http://host/#Σ", url.uri().toString());
+  }
+
+  @Test public void fragmentNonAsciiThatOffendsJavaNetUri() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/#\u0080");
+    assertEquals("http://host/#\u0080", url.toString());
+    assertEquals("\u0080", url.fragment());
+    assertEquals("\u0080", url.encodedFragment());
+    assertEquals(new URI("http://host/#"), url.uri()); // Control characters may be stripped!
+  }
+
+  @Test public void fragmentPercentEncodedNonAscii() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/#%C2%80");
+    assertEquals("http://host/#%C2%80", url.toString());
+    assertEquals("\u0080", url.fragment());
+    assertEquals("%C2%80", url.encodedFragment());
+    assertEquals("http://host/#%C2%80", url.uri().toString());
+  }
+
+  @Test public void fragmentPercentEncodedPartialCodePoint() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/#%80");
+    assertEquals("http://host/#%80", url.toString());
+    assertEquals("\ufffd", url.fragment()); // Unicode replacement character.
+    assertEquals("%80", url.encodedFragment());
+    assertEquals("http://host/#%80", url.uri().toString());
+  }
+
+  @Test public void relativePath() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals(HttpUrl.parse("http://host/a/b/d/e/f"), base.resolve("d/e/f"));
+    assertEquals(HttpUrl.parse("http://host/d/e/f"), base.resolve("../../d/e/f"));
+    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve(".."));
+    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../.."));
+    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../.."));
+    assertEquals(HttpUrl.parse("http://host/a/b/"), base.resolve("."));
+    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("././.."));
+    assertEquals(HttpUrl.parse("http://host/a/b/c/"), base.resolve("c/d/../e/../"));
+    assertEquals(HttpUrl.parse("http://host/a/b/..e/"), base.resolve("..e/"));
+    assertEquals(HttpUrl.parse("http://host/a/b/e/f../"), base.resolve("e/f../"));
+    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("%2E."));
+    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve(".%2E"));
+    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("%2E%2E"));
+    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("%2e."));
+    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve(".%2e"));
+    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("%2e%2e"));
+    assertEquals(HttpUrl.parse("http://host/a/b/"), base.resolve("%2E"));
+    assertEquals(HttpUrl.parse("http://host/a/b/"), base.resolve("%2e"));
+  }
+
+  @Test public void relativePathWithTrailingSlash() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c/");
+    assertEquals(HttpUrl.parse("http://host/a/b/"), base.resolve(".."));
+    assertEquals(HttpUrl.parse("http://host/a/b/"), base.resolve("../"));
+    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("../.."));
+    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("../../"));
+    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../.."));
+    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../../"));
+    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../../.."));
+    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../../../"));
+    assertEquals(HttpUrl.parse("http://host/a"), base.resolve("../../../../a"));
+    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../../../a/.."));
+    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("../../../../a/b/.."));
+  }
+
+  @Test public void pathWithBackslash() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals(HttpUrl.parse("http://host/a/b/d/e/f"), base.resolve("d\\e\\f"));
+    assertEquals(HttpUrl.parse("http://host/d/e/f"), base.resolve("../..\\d\\e\\f"));
+    assertEquals(HttpUrl.parse("http://host/"), base.resolve("..\\.."));
+  }
+
+  @Test public void relativePathWithSameScheme() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals(HttpUrl.parse("http://host/a/b/d/e/f"), base.resolve("http:d/e/f"));
+    assertEquals(HttpUrl.parse("http://host/d/e/f"), base.resolve("http:../../d/e/f"));
+  }
+
+  @Test public void decodeUsername() {
+    assertEquals("user", HttpUrl.parse("http://user@host/").username());
+    assertEquals("\uD83C\uDF69", HttpUrl.parse("http://%F0%9F%8D%A9@host/").username());
+  }
+
+  @Test public void decodePassword() {
+    assertEquals("password", HttpUrl.parse("http://user:password@host/").password());
+    assertEquals("", HttpUrl.parse("http://user:@host/").password());
+    assertEquals("\uD83C\uDF69", HttpUrl.parse("http://user:%F0%9F%8D%A9@host/").password());
+  }
+
+  @Test public void decodeSlashCharacterInDecodedPathSegment() {
+    assertEquals(Arrays.asList("a/b/c"),
+        HttpUrl.parse("http://host/a%2Fb%2Fc").pathSegments());
+  }
+
+  @Test public void decodeEmptyPathSegments() {
+    assertEquals(Arrays.asList(""),
+        HttpUrl.parse("http://host/").pathSegments());
+  }
+
+  @Test public void percentDecode() throws Exception {
+    assertEquals(Arrays.asList("\u0000"),
+        HttpUrl.parse("http://host/%00").pathSegments());
+    assertEquals(Arrays.asList("a", "\u2603", "c"),
+        HttpUrl.parse("http://host/a/%E2%98%83/c").pathSegments());
+    assertEquals(Arrays.asList("a", "\uD83C\uDF69", "c"),
+        HttpUrl.parse("http://host/a/%F0%9F%8D%A9/c").pathSegments());
+    assertEquals(Arrays.asList("a", "b", "c"),
+        HttpUrl.parse("http://host/a/%62/c").pathSegments());
+    assertEquals(Arrays.asList("a", "z", "c"),
+        HttpUrl.parse("http://host/a/%7A/c").pathSegments());
+    assertEquals(Arrays.asList("a", "z", "c"),
+        HttpUrl.parse("http://host/a/%7a/c").pathSegments());
+  }
+
+  @Test public void malformedPercentEncoding() {
+    assertEquals(Arrays.asList("a%f", "b"),
+        HttpUrl.parse("http://host/a%f/b").pathSegments());
+    assertEquals(Arrays.asList("%", "b"),
+        HttpUrl.parse("http://host/%/b").pathSegments());
+    assertEquals(Arrays.asList("%"),
+        HttpUrl.parse("http://host/%").pathSegments());
+    assertEquals(Arrays.asList("%00"),
+        HttpUrl.parse("http://github.com/%%30%30").pathSegments());
+  }
+
+  @Test public void malformedUtf8Encoding() {
+    // Replace a partial UTF-8 sequence with the Unicode replacement character.
+    assertEquals(Arrays.asList("a", "\ufffdx", "c"),
+        HttpUrl.parse("http://host/a/%E2%98x/c").pathSegments());
+  }
+
+  @Test public void incompleteUrlComposition() throws Exception {
+    try {
+      new HttpUrl.Builder().scheme("http").build();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals("host == null", expected.getMessage());
+    }
+    try {
+      new HttpUrl.Builder().host("host").build();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals("scheme == null", expected.getMessage());
+    }
+  }
+
+  @Test public void minimalUrlComposition() throws Exception {
+    HttpUrl url = new HttpUrl.Builder().scheme("http").host("host").build();
+    assertEquals("http://host/", url.toString());
+    assertEquals("http", url.scheme());
+    assertEquals("", url.username());
+    assertEquals("", url.password());
+    assertEquals("host", url.host());
+    assertEquals(80, url.port());
+    assertEquals("/", url.encodedPath());
+    assertEquals(null, url.query());
+    assertEquals(null, url.fragment());
+  }
+
+  @Test public void fullUrlComposition() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .username("username")
+        .password("password")
+        .host("host")
+        .port(8080)
+        .addPathSegment("path")
+        .query("query")
+        .fragment("fragment")
+        .build();
+    assertEquals("http://username:password@host:8080/path?query#fragment", url.toString());
+    assertEquals("http", url.scheme());
+    assertEquals("username", url.username());
+    assertEquals("password", url.password());
+    assertEquals("host", url.host());
+    assertEquals(8080, url.port());
+    assertEquals("/path", url.encodedPath());
+    assertEquals("query", url.query());
+    assertEquals("fragment", url.fragment());
+  }
+
+  @Test public void changingSchemeChangesDefaultPort() throws Exception {
+    assertEquals(443, HttpUrl.parse("http://example.com")
+        .newBuilder()
+        .scheme("https")
+        .build().port());
+
+    assertEquals(80, HttpUrl.parse("https://example.com")
+        .newBuilder()
+        .scheme("http")
+        .build().port());
+
+    assertEquals(1234, HttpUrl.parse("https://example.com:1234")
+        .newBuilder()
+        .scheme("http")
+        .build().port());
+  }
+
+  @Test public void composeEncodesWhitespace() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .username("a\r\n\f\t b")
+        .password("c\r\n\f\t d")
+        .host("host")
+        .addPathSegment("e\r\n\f\t f")
+        .query("g\r\n\f\t h")
+        .fragment("i\r\n\f\t j")
+        .build();
+    assertEquals("http://a%0D%0A%0C%09%20b:c%0D%0A%0C%09%20d@host"
+        + "/e%0D%0A%0C%09%20f?g%0D%0A%0C%09%20h#i%0D%0A%0C%09 j", url.toString());
+    assertEquals("a\r\n\f\t b", url.username());
+    assertEquals("c\r\n\f\t d", url.password());
+    assertEquals("e\r\n\f\t f", url.pathSegments().get(0));
+    assertEquals("g\r\n\f\t h", url.query());
+    assertEquals("i\r\n\f\t j", url.fragment());
+  }
+
+  @Test public void composeFromUnencodedComponents() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .username("a:\u0001@/\\?#%b")
+        .password("c:\u0001@/\\?#%d")
+        .host("ef")
+        .port(8080)
+        .addPathSegment("g:\u0001@/\\?#%h")
+        .query("i:\u0001@/\\?#%j")
+        .fragment("k:\u0001@/\\?#%l")
+        .build();
+    assertEquals("http://a%3A%01%40%2F%5C%3F%23%25b:c%3A%01%40%2F%5C%3F%23%25d@ef:8080/"
+        + "g:%01@%2F%5C%3F%23%25h?i:%01@/\\?%23%25j#k:%01@/\\?#%25l", url.toString());
+    assertEquals("http", url.scheme());
+    assertEquals("a:\u0001@/\\?#%b", url.username());
+    assertEquals("c:\u0001@/\\?#%d", url.password());
+    assertEquals(Arrays.asList("g:\u0001@/\\?#%h"), url.pathSegments());
+    assertEquals("i:\u0001@/\\?#%j", url.query());
+    assertEquals("k:\u0001@/\\?#%l", url.fragment());
+    assertEquals("a%3A%01%40%2F%5C%3F%23%25b", url.encodedUsername());
+    assertEquals("c%3A%01%40%2F%5C%3F%23%25d", url.encodedPassword());
+    assertEquals("/g:%01@%2F%5C%3F%23%25h", url.encodedPath());
+    assertEquals("i:%01@/\\?%23%25j", url.encodedQuery());
+    assertEquals("k:%01@/\\?#%25l", url.encodedFragment());
+  }
+
+  @Test public void composeFromEncodedComponents() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .encodedUsername("a:\u0001@/\\?#%25b")
+        .encodedPassword("c:\u0001@/\\?#%25d")
+        .host("ef")
+        .port(8080)
+        .addEncodedPathSegment("g:\u0001@/\\?#%25h")
+        .encodedQuery("i:\u0001@/\\?#%25j")
+        .encodedFragment("k:\u0001@/\\?#%25l")
+        .build();
+    assertEquals("http://a%3A%01%40%2F%5C%3F%23%25b:c%3A%01%40%2F%5C%3F%23%25d@ef:8080/"
+        + "g:%01@%2F%5C%3F%23%25h?i:%01@/\\?%23%25j#k:%01@/\\?#%25l", url.toString());
+    assertEquals("http", url.scheme());
+    assertEquals("a:\u0001@/\\?#%b", url.username());
+    assertEquals("c:\u0001@/\\?#%d", url.password());
+    assertEquals(Arrays.asList("g:\u0001@/\\?#%h"), url.pathSegments());
+    assertEquals("i:\u0001@/\\?#%j", url.query());
+    assertEquals("k:\u0001@/\\?#%l", url.fragment());
+    assertEquals("a%3A%01%40%2F%5C%3F%23%25b", url.encodedUsername());
+    assertEquals("c%3A%01%40%2F%5C%3F%23%25d", url.encodedPassword());
+    assertEquals("/g:%01@%2F%5C%3F%23%25h", url.encodedPath());
+    assertEquals("i:%01@/\\?%23%25j", url.encodedQuery());
+    assertEquals("k:%01@/\\?#%25l", url.encodedFragment());
+  }
+
+  @Test public void composeWithEncodedPath() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .encodedPath("/a%2Fb/c")
+        .build();
+    assertEquals("http://host/a%2Fb/c", url.toString());
+    assertEquals("/a%2Fb/c", url.encodedPath());
+    assertEquals(Arrays.asList("a/b", "c"), url.pathSegments());
+  }
+
+  @Test public void composeMixingPathSegments() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .encodedPath("/a%2fb/c")
+        .addPathSegment("d%25e")
+        .addEncodedPathSegment("f%25g")
+        .build();
+    assertEquals("http://host/a%2fb/c/d%2525e/f%25g", url.toString());
+    assertEquals("/a%2fb/c/d%2525e/f%25g", url.encodedPath());
+    assertEquals(Arrays.asList("a%2fb", "c", "d%2525e", "f%25g"), url.encodedPathSegments());
+    assertEquals(Arrays.asList("a/b", "c", "d%25e", "f%g"), url.pathSegments());
+  }
+
+  @Test public void composeWithAddSegment() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("/a/b/c/", base.newBuilder().addPathSegment("").build().encodedPath());
+    assertEquals("/a/b/c/d",
+        base.newBuilder().addPathSegment("").addPathSegment("d").build().encodedPath());
+    assertEquals("/a/b/", base.newBuilder().addPathSegment("..").build().encodedPath());
+    assertEquals("/a/b/", base.newBuilder().addPathSegment("").addPathSegment("..").build()
+        .encodedPath());
+    assertEquals("/a/b/c/", base.newBuilder().addPathSegment("").addPathSegment("").build()
+        .encodedPath());
+  }
+
+  @Test public void pathSize() throws Exception {
+    assertEquals(1, HttpUrl.parse("http://host/").pathSize());
+    assertEquals(3, HttpUrl.parse("http://host/a/b/c").pathSize());
+  }
+
+  @Test public void addPathSegments() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+
+    // Add a string with zero slashes: resulting URL gains one slash.
+    assertEquals("/a/b/c/", base.newBuilder().addPathSegments("").build().encodedPath());
+    assertEquals("/a/b/c/d", base.newBuilder().addPathSegments("d").build().encodedPath());
+
+    // Add a string with one slash: resulting URL gains two slashes.
+    assertEquals("/a/b/c//", base.newBuilder().addPathSegments("/").build().encodedPath());
+    assertEquals("/a/b/c/d/", base.newBuilder().addPathSegments("d/").build().encodedPath());
+    assertEquals("/a/b/c//d", base.newBuilder().addPathSegments("/d").build().encodedPath());
+
+    // Add a string with two slashes: resulting URL gains three slashes.
+    assertEquals("/a/b/c///", base.newBuilder().addPathSegments("//").build().encodedPath());
+    assertEquals("/a/b/c//d/", base.newBuilder().addPathSegments("/d/").build().encodedPath());
+    assertEquals("/a/b/c/d//", base.newBuilder().addPathSegments("d//").build().encodedPath());
+    assertEquals("/a/b/c///d", base.newBuilder().addPathSegments("//d").build().encodedPath());
+    assertEquals("/a/b/c/d/e/f", base.newBuilder().addPathSegments("d/e/f").build().encodedPath());
+  }
+
+  @Test public void addPathSegmentsOntoTrailingSlash() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c/");
+
+    // Add a string with zero slashes: resulting URL gains zero slashes.
+    assertEquals("/a/b/c/", base.newBuilder().addPathSegments("").build().encodedPath());
+    assertEquals("/a/b/c/d", base.newBuilder().addPathSegments("d").build().encodedPath());
+
+    // Add a string with one slash: resulting URL gains one slash.
+    assertEquals("/a/b/c//", base.newBuilder().addPathSegments("/").build().encodedPath());
+    assertEquals("/a/b/c/d/", base.newBuilder().addPathSegments("d/").build().encodedPath());
+    assertEquals("/a/b/c//d", base.newBuilder().addPathSegments("/d").build().encodedPath());
+
+    // Add a string with two slashes: resulting URL gains two slashes.
+    assertEquals("/a/b/c///", base.newBuilder().addPathSegments("//").build().encodedPath());
+    assertEquals("/a/b/c//d/", base.newBuilder().addPathSegments("/d/").build().encodedPath());
+    assertEquals("/a/b/c/d//", base.newBuilder().addPathSegments("d//").build().encodedPath());
+    assertEquals("/a/b/c///d", base.newBuilder().addPathSegments("//d").build().encodedPath());
+    assertEquals("/a/b/c/d/e/f", base.newBuilder().addPathSegments("d/e/f").build().encodedPath());
+  }
+
+  @Test public void addPathSegmentsWithBackslash() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/");
+    assertEquals("/d/e", base.newBuilder().addPathSegments("d\\e").build().encodedPath());
+    assertEquals("/d/e", base.newBuilder().addEncodedPathSegments("d\\e").build().encodedPath());
+  }
+
+  @Test public void addPathSegmentsWithEmptyPaths() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("/a/b/c//d/e///f",
+        base.newBuilder().addPathSegments("/d/e///f").build().encodedPath());
+  }
+
+  @Test public void addEncodedPathSegments() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("/a/b/c/d/e/%20/",
+        base.newBuilder().addEncodedPathSegments("d/e/%20/\n").build().encodedPath());
+  }
+
+  @Test public void addPathSegmentDotDoesNothing() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("/a/b/c", base.newBuilder().addPathSegment(".").build().encodedPath());
+  }
+
+  @Test public void addPathSegmentEncodes() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("/a/b/c/%252e",
+        base.newBuilder().addPathSegment("%2e").build().encodedPath());
+    assertEquals("/a/b/c/%252e%252e",
+        base.newBuilder().addPathSegment("%2e%2e").build().encodedPath());
+  }
+
+  @Test public void addPathSegmentDotDotPopsDirectory() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("/a/b/", base.newBuilder().addPathSegment("..").build().encodedPath());
+  }
+
+  @Test public void addPathSegmentDotAndIgnoredCharacter() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("/a/b/c/.%0A", base.newBuilder().addPathSegment(".\n").build().encodedPath());
+  }
+
+  @Test public void addEncodedPathSegmentDotAndIgnoredCharacter() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("/a/b/c", base.newBuilder().addEncodedPathSegment(".\n").build().encodedPath());
+  }
+
+  @Test public void addEncodedPathSegmentDotDotAndIgnoredCharacter() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("/a/b/", base.newBuilder().addEncodedPathSegment("..\n").build().encodedPath());
+  }
+
+  @Test public void setPathSegment() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("/d/b/c", base.newBuilder().setPathSegment(0, "d").build().encodedPath());
+    assertEquals("/a/d/c", base.newBuilder().setPathSegment(1, "d").build().encodedPath());
+    assertEquals("/a/b/d", base.newBuilder().setPathSegment(2, "d").build().encodedPath());
+  }
+
+  @Test public void setPathSegmentEncodes() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("/%2525/b/c", base.newBuilder().setPathSegment(0, "%25").build().encodedPath());
+    assertEquals("/.%0A/b/c", base.newBuilder().setPathSegment(0, ".\n").build().encodedPath());
+    assertEquals("/%252e/b/c", base.newBuilder().setPathSegment(0, "%2e").build().encodedPath());
+  }
+
+  @Test public void setPathSegmentAcceptsEmpty() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("//b/c", base.newBuilder().setPathSegment(0, "").build().encodedPath());
+    assertEquals("/a/b/", base.newBuilder().setPathSegment(2, "").build().encodedPath());
+  }
+
+  @Test public void setPathSegmentRejectsDot() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    try {
+      base.newBuilder().setPathSegment(0, ".");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void setPathSegmentRejectsDotDot() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    try {
+      base.newBuilder().setPathSegment(0, "..");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void setPathSegmentWithSlash() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl url = base.newBuilder().setPathSegment(1, "/").build();
+    assertEquals("/a/%2F/c", url.encodedPath());
+  }
+
+  @Test public void setPathSegmentOutOfBounds() throws Exception {
+    try {
+      new HttpUrl.Builder().setPathSegment(1, "a");
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+  }
+
+  @Test public void setEncodedPathSegmentEncodes() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("/%25/b/c",
+        base.newBuilder().setEncodedPathSegment(0, "%25").build().encodedPath());
+  }
+
+  @Test public void setEncodedPathSegmentRejectsDot() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    try {
+      base.newBuilder().setEncodedPathSegment(0, ".");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void setEncodedPathSegmentRejectsDotAndIgnoredCharacter() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    try {
+      base.newBuilder().setEncodedPathSegment(0, ".\n");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void setEncodedPathSegmentRejectsDotDot() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    try {
+      base.newBuilder().setEncodedPathSegment(0, "..");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void setEncodedPathSegmentRejectsDotDotAndIgnoredCharacter() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    try {
+      base.newBuilder().setEncodedPathSegment(0, "..\n");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void setEncodedPathSegmentWithSlash() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl url = base.newBuilder().setEncodedPathSegment(1, "/").build();
+    assertEquals("/a/%2F/c", url.encodedPath());
+  }
+
+  @Test public void setEncodedPathSegmentOutOfBounds() throws Exception {
+    try {
+      new HttpUrl.Builder().setEncodedPathSegment(1, "a");
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+  }
+
+  @Test public void removePathSegment() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl url = base.newBuilder()
+        .removePathSegment(0)
+        .build();
+    assertEquals("/b/c", url.encodedPath());
+  }
+
+  @Test public void removePathSegmentDoesntRemovePath() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl url = base.newBuilder()
+        .removePathSegment(0)
+        .removePathSegment(0)
+        .removePathSegment(0)
+        .build();
+    assertEquals(Arrays.asList(""), url.pathSegments());
+    assertEquals("/", url.encodedPath());
+  }
+
+  @Test public void removePathSegmentOutOfBounds() throws Exception {
+    try {
+      new HttpUrl.Builder().removePathSegment(1);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+  }
+
+  @Test public void toJavaNetUrl() throws Exception {
+    HttpUrl httpUrl = HttpUrl.parse("http://username:password@host/path?query#fragment");
+    URL javaNetUrl = httpUrl.url();
+    assertEquals("http://username:password@host/path?query#fragment", javaNetUrl.toString());
+  }
+
+  @Test public void toUri() throws Exception {
+    HttpUrl httpUrl = HttpUrl.parse("http://username:password@host/path?query#fragment");
+    URI uri = httpUrl.uri();
+    assertEquals("http://username:password@host/path?query#fragment", uri.toString());
+  }
+
+  @Test public void toUriSpecialQueryCharacters() throws Exception {
+    HttpUrl httpUrl = HttpUrl.parse("http://host/?d=abc!@[]^`{}|\\");
+    URI uri = httpUrl.uri();
+    assertEquals("http://host/?d=abc!@[]%5E%60%7B%7D%7C%5C", uri.toString());
+  }
+
+  @Test public void toUriWithUsernameNoPassword() throws Exception {
+    HttpUrl httpUrl = new HttpUrl.Builder()
+        .scheme("http")
+        .username("user")
+        .host("host")
+        .build();
+    assertEquals("http://user@host/", httpUrl.toString());
+    assertEquals("http://user@host/", httpUrl.uri().toString());
+  }
+
+  @Test public void toUriUsernameSpecialCharacters() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .username("=[]:;\"~|?#@^/$%*")
+        .build();
+    assertEquals("http://%3D%5B%5D%3A%3B%22~%7C%3F%23%40%5E%2F$%25*@host/", url.toString());
+    assertEquals("http://%3D%5B%5D%3A%3B%22~%7C%3F%23%40%5E%2F$%25*@host/", url.uri().toString());
+  }
+
+  @Test public void toUriPasswordSpecialCharacters() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .username("user")
+        .password("=[]:;\"~|?#@^/$%*")
+        .build();
+    assertEquals("http://user:%3D%5B%5D%3A%3B%22~%7C%3F%23%40%5E%2F$%25*@host/", url.toString());
+    assertEquals("http://user:%3D%5B%5D%3A%3B%22~%7C%3F%23%40%5E%2F$%25*@host/",
+        url.uri().toString());
+  }
+
+  @Test public void toUriPathSpecialCharacters() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .addPathSegment("=[]:;\"~|?#@^/$%*")
+        .build();
+    assertEquals("http://host/=[]:;%22~%7C%3F%23@%5E%2F$%25*", url.toString());
+    assertEquals("http://host/=%5B%5D:;%22~%7C%3F%23@%5E%2F$%25*", url.uri().toString());
+  }
+
+  @Test public void toUriQueryParameterNameSpecialCharacters() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .addQueryParameter("=[]:;\"~|?#@^/$%*", "a")
+        .build();
+    assertEquals("http://host/?%3D[]:;%22~|?%23@^/$%25*=a", url.toString());
+    assertEquals("http://host/?%3D[]:;%22~%7C?%23@%5E/$%25*=a", url.uri().toString());
+  }
+
+  @Test public void toUriQueryParameterValueSpecialCharacters() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .addQueryParameter("a", "=[]:;\"~|?#@^/$%*")
+        .build();
+    assertEquals("http://host/?a=%3D[]:;%22~|?%23@^/$%25*", url.toString());
+    assertEquals("http://host/?a=%3D[]:;%22~%7C?%23@%5E/$%25*", url.uri().toString());
+  }
+
+  @Test public void toUriQueryValueSpecialCharacters() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .query("=[]:;\"~|?#@^/$%*")
+        .build();
+    assertEquals("http://host/?=[]:;%22~|?%23@^/$%25*", url.toString());
+    assertEquals("http://host/?=[]:;%22~%7C?%23@%5E/$%25*", url.uri().toString());
+  }
+
+  @Test public void toUriFragmentSpecialCharacters() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .fragment("=[]:;\"~|?#@^/$%*")
+        .build();
+    assertEquals("http://host/#=[]:;\"~|?#@^/$%25*", url.toString());
+    assertEquals("http://host/#=[]:;%22~%7C?%23@%5E/$%25*", url.uri().toString());
+  }
+
+  @Test public void toUriWithControlCharacters() throws Exception {
+    // Percent-encoded in the path.
+    assertEquals(new URI("http://host/a%00b"), HttpUrl.parse("http://host/a\u0000b").uri());
+    assertEquals(new URI("http://host/a%C2%80b"), HttpUrl.parse("http://host/a\u0080b").uri());
+    assertEquals(new URI("http://host/a%C2%9Fb"), HttpUrl.parse("http://host/a\u009fb").uri());
+    // Percent-encoded in the query.
+    assertEquals(new URI("http://host/?a%00b"), HttpUrl.parse("http://host/?a\u0000b").uri());
+    assertEquals(new URI("http://host/?a%C2%80b"), HttpUrl.parse("http://host/?a\u0080b").uri());
+    assertEquals(new URI("http://host/?a%C2%9Fb"), HttpUrl.parse("http://host/?a\u009fb").uri());
+    // Stripped from the fragment.
+    assertEquals(new URI("http://host/#a%00b"), HttpUrl.parse("http://host/#a\u0000b").uri());
+    assertEquals(new URI("http://host/#ab"), HttpUrl.parse("http://host/#a\u0080b").uri());
+    assertEquals(new URI("http://host/#ab"), HttpUrl.parse("http://host/#a\u009fb").uri());
+  }
+
+  @Test public void toUriWithSpaceCharacters() throws Exception {
+    // Percent-encoded in the path.
+    assertEquals(new URI("http://host/a%0Bb"), HttpUrl.parse("http://host/a\u000bb").uri());
+    assertEquals(new URI("http://host/a%20b"), HttpUrl.parse("http://host/a b").uri());
+    assertEquals(new URI("http://host/a%E2%80%89b"), HttpUrl.parse("http://host/a\u2009b").uri());
+    assertEquals(new URI("http://host/a%E3%80%80b"), HttpUrl.parse("http://host/a\u3000b").uri());
+    // Percent-encoded in the query.
+    assertEquals(new URI("http://host/?a%0Bb"), HttpUrl.parse("http://host/?a\u000bb").uri());
+    assertEquals(new URI("http://host/?a%20b"), HttpUrl.parse("http://host/?a b").uri());
+    assertEquals(new URI("http://host/?a%E2%80%89b"), HttpUrl.parse("http://host/?a\u2009b").uri());
+    assertEquals(new URI("http://host/?a%E3%80%80b"), HttpUrl.parse("http://host/?a\u3000b").uri());
+    // Stripped from the fragment.
+    assertEquals(new URI("http://host/#a%0Bb"), HttpUrl.parse("http://host/#a\u000bb").uri());
+    assertEquals(new URI("http://host/#a%20b"), HttpUrl.parse("http://host/#a b").uri());
+    assertEquals(new URI("http://host/#ab"), HttpUrl.parse("http://host/#a\u2009b").uri());
+    assertEquals(new URI("http://host/#ab"), HttpUrl.parse("http://host/#a\u3000b").uri());
+  }
+
+  @Test public void toUriWithNonHexPercentEscape() throws Exception {
+    assertEquals(new URI("http://host/%25xx"), HttpUrl.parse("http://host/%xx").uri());
+  }
+
+  @Test public void toUriWithTruncatedPercentEscape() throws Exception {
+    assertEquals(new URI("http://host/%25a"), HttpUrl.parse("http://host/%a").uri());
+    assertEquals(new URI("http://host/%25"), HttpUrl.parse("http://host/%").uri());
+  }
+
+  @Test public void fromJavaNetUrl() throws Exception {
+    URL javaNetUrl = new URL("http://username:password@host/path?query#fragment");
+    HttpUrl httpUrl = HttpUrl.get(javaNetUrl);
+    assertEquals("http://username:password@host/path?query#fragment", httpUrl.toString());
+  }
+
+  @Test public void fromJavaNetUrlUnsupportedScheme() throws Exception {
+    URL javaNetUrl = new URL("mailto:user@example.com");
+    assertEquals(null, HttpUrl.get(javaNetUrl));
+  }
+
+  @Test public void fromUri() throws Exception {
+    URI uri = new URI("http://username:password@host/path?query#fragment");
+    HttpUrl httpUrl = HttpUrl.get(uri);
+    assertEquals("http://username:password@host/path?query#fragment", httpUrl.toString());
+  }
+
+  @Test public void fromUriUnsupportedScheme() throws Exception {
+    URI uri = new URI("mailto:user@example.com");
+    assertEquals(null, HttpUrl.get(uri));
+  }
+
+  @Test public void fromUriPartial() throws Exception {
+    URI uri = new URI("/path");
+    assertEquals(null, HttpUrl.get(uri));
+  }
+
+  @Test public void fromJavaNetUrl_checked() throws Exception {
+    HttpUrl httpUrl = HttpUrl.getChecked("http://username:password@host/path?query#fragment");
+    assertEquals("http://username:password@host/path?query#fragment", httpUrl.toString());
+  }
+
+  @Test public void fromJavaNetUrlUnsupportedScheme_checked() throws Exception {
+    try {
+      HttpUrl.getChecked("mailto:user@example.com");
+      fail();
+    } catch (MalformedURLException e) {
+    }
+  }
+
+  @Test public void fromJavaNetUrlBadHost_checked() throws Exception {
+    try {
+      HttpUrl.getChecked("http://hostw ithspace/");
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+  }
+
+  @Test public void composeQueryWithComponents() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/");
+    HttpUrl url = base.newBuilder().addQueryParameter("a+=& b", "c+=& d").build();
+    assertEquals("http://host/?a%2B%3D%26%20b=c%2B%3D%26%20d", url.toString());
+    assertEquals("c+=& d", url.queryParameterValue(0));
+    assertEquals("a+=& b", url.queryParameterName(0));
+    assertEquals("c+=& d", url.queryParameter("a+=& b"));
+    assertEquals(Collections.singleton("a+=& b"), url.queryParameterNames());
+    assertEquals(singletonList("c+=& d"), url.queryParameterValues("a+=& b"));
+    assertEquals(1, url.querySize());
+    assertEquals("a+=& b=c+=& d", url.query()); // Ambiguous! (Though working as designed.)
+    assertEquals("a%2B%3D%26%20b=c%2B%3D%26%20d", url.encodedQuery());
+  }
+
+  @Test public void composeQueryWithEncodedComponents() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/");
+    HttpUrl url = base.newBuilder().addEncodedQueryParameter("a+=& b", "c+=& d").build();
+    assertEquals("http://host/?a+%3D%26%20b=c+%3D%26%20d", url.toString());
+    assertEquals("c =& d", url.queryParameter("a =& b"));
+  }
+
+  @Test public void composeQueryRemoveQueryParameter() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+        .addQueryParameter("a+=& b", "c+=& d")
+        .removeAllQueryParameters("a+=& b")
+        .build();
+    assertEquals("http://host/", url.toString());
+    assertEquals(null, url.queryParameter("a+=& b"));
+  }
+
+  @Test public void composeQueryRemoveEncodedQueryParameter() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+        .addEncodedQueryParameter("a+=& b", "c+=& d")
+        .removeAllEncodedQueryParameters("a+=& b")
+        .build();
+    assertEquals("http://host/", url.toString());
+    assertEquals(null, url.queryParameter("a =& b"));
+  }
+
+  @Test public void composeQuerySetQueryParameter() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+        .addQueryParameter("a+=& b", "c+=& d")
+        .setQueryParameter("a+=& b", "ef")
+        .build();
+    assertEquals("http://host/?a%2B%3D%26%20b=ef", url.toString());
+    assertEquals("ef", url.queryParameter("a+=& b"));
+  }
+
+  @Test public void composeQuerySetEncodedQueryParameter() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+        .addEncodedQueryParameter("a+=& b", "c+=& d")
+        .setEncodedQueryParameter("a+=& b", "ef")
+        .build();
+    assertEquals("http://host/?a+%3D%26%20b=ef", url.toString());
+    assertEquals("ef", url.queryParameter("a =& b"));
+  }
+
+  @Test public void composeQueryMultipleEncodedValuesForParameter() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+        .addQueryParameter("a+=& b", "c+=& d")
+        .addQueryParameter("a+=& b", "e+=& f")
+        .build();
+    assertEquals("http://host/?a%2B%3D%26%20b=c%2B%3D%26%20d&a%2B%3D%26%20b=e%2B%3D%26%20f",
+        url.toString());
+    assertEquals(2, url.querySize());
+    assertEquals(Collections.singleton("a+=& b"), url.queryParameterNames());
+    assertEquals(Arrays.asList("c+=& d", "e+=& f"), url.queryParameterValues("a+=& b"));
+  }
+
+  @Test public void absentQueryIsZeroNameValuePairs() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+        .query(null)
+        .build();
+    assertEquals(0, url.querySize());
+  }
+
+  @Test public void emptyQueryIsSingleNameValuePairWithEmptyKey() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+        .query("")
+        .build();
+    assertEquals(1, url.querySize());
+    assertEquals("", url.queryParameterName(0));
+    assertEquals(null, url.queryParameterValue(0));
+  }
+
+  @Test public void ampersandQueryIsTwoNameValuePairsWithEmptyKeys() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+        .query("&")
+        .build();
+    assertEquals(2, url.querySize());
+    assertEquals("", url.queryParameterName(0));
+    assertEquals(null, url.queryParameterValue(0));
+    assertEquals("", url.queryParameterName(1));
+    assertEquals(null, url.queryParameterValue(1));
+  }
+
+  @Test public void removeAllDoesNotRemoveQueryIfNoParametersWereRemoved() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+        .query("")
+        .removeAllQueryParameters("a")
+        .build();
+    assertEquals("http://host/?", url.toString());
+  }
+
+  @Test public void queryParametersWithoutValues() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/?foo&bar&baz");
+    assertEquals(3, url.querySize());
+    assertEquals(new LinkedHashSet<>(Arrays.asList("foo", "bar", "baz")),
+        url.queryParameterNames());
+    assertEquals(null, url.queryParameterValue(0));
+    assertEquals(null, url.queryParameterValue(1));
+    assertEquals(null, url.queryParameterValue(2));
+    assertEquals(singletonList((String) null), url.queryParameterValues("foo"));
+    assertEquals(singletonList((String) null), url.queryParameterValues("bar"));
+    assertEquals(singletonList((String) null), url.queryParameterValues("baz"));
+  }
+
+  @Test public void queryParametersWithEmptyValues() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/?foo=&bar=&baz=");
+    assertEquals(3, url.querySize());
+    assertEquals(new LinkedHashSet<>(Arrays.asList("foo", "bar", "baz")),
+        url.queryParameterNames());
+    assertEquals("", url.queryParameterValue(0));
+    assertEquals("", url.queryParameterValue(1));
+    assertEquals("", url.queryParameterValue(2));
+    assertEquals(singletonList(""), url.queryParameterValues("foo"));
+    assertEquals(singletonList(""), url.queryParameterValues("bar"));
+    assertEquals(singletonList(""), url.queryParameterValues("baz"));
+  }
+
+  @Test public void queryParametersWithRepeatedName() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/?foo[]=1&foo[]=2&foo[]=3");
+    assertEquals(3, url.querySize());
+    assertEquals(Collections.singleton("foo[]"), url.queryParameterNames());
+    assertEquals("1", url.queryParameterValue(0));
+    assertEquals("2", url.queryParameterValue(1));
+    assertEquals("3", url.queryParameterValue(2));
+    assertEquals(Arrays.asList("1", "2", "3"), url.queryParameterValues("foo[]"));
+  }
+
+  @Test public void queryParameterLookupWithNonCanonicalEncoding() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/?%6d=m&+=%20");
+    assertEquals("m", url.queryParameterName(0));
+    assertEquals(" ", url.queryParameterName(1));
+    assertEquals("m", url.queryParameter("m"));
+    assertEquals(" ", url.queryParameter(" "));
+  }
+
+  @Test public void parsedQueryDoesntIncludeFragment() {
+    HttpUrl url = HttpUrl.parse("http://host/?#fragment");
+    assertEquals("fragment", url.fragment());
+    assertEquals("", url.query());
+    assertEquals("", url.encodedQuery());
+  }
+
+  @Test public void roundTripBuilder() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .username("%")
+        .password("%")
+        .host("host")
+        .addPathSegment("%")
+        .query("%")
+        .fragment("%")
+        .build();
+    assertEquals("http://%25:%25@host/%25?%25#%25", url.toString());
+    assertEquals("http://%25:%25@host/%25?%25#%25", url.newBuilder().build().toString());
+    assertEquals("http://%25:%25@host/%25?%25", url.resolve("").toString());
+  }
+
+  /**
+   * Although HttpUrl prefers percent-encodings in uppercase, it should preserve the exact structure
+   * of the original encoding.
+   */
+  @Test public void rawEncodingRetained() throws Exception {
+    String urlString = "http://%6d%6D:%6d%6D@host/%6d%6D?%6d%6D#%6d%6D";
+    HttpUrl url = HttpUrl.parse(urlString);
+    assertEquals("%6d%6D", url.encodedUsername());
+    assertEquals("%6d%6D", url.encodedPassword());
+    assertEquals("/%6d%6D", url.encodedPath());
+    assertEquals(Arrays.asList("%6d%6D"), url.encodedPathSegments());
+    assertEquals("%6d%6D", url.encodedQuery());
+    assertEquals("%6d%6D", url.encodedFragment());
+    assertEquals(urlString, url.toString());
+    assertEquals(urlString, url.newBuilder().build().toString());
+    assertEquals("http://%6d%6D:%6d%6D@host/%6d%6D?%6d%6D", url.resolve("").toString());
+  }
+
+  @Test public void clearFragment() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/#fragment")
+        .newBuilder()
+        .fragment(null)
+        .build();
+    assertEquals("http://host/", url.toString());
+    assertEquals(null, url.fragment());
+    assertEquals(null, url.encodedFragment());
+  }
+
+  @Test public void clearEncodedFragment() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/#fragment")
+        .newBuilder()
+        .encodedFragment(null)
+        .build();
+    assertEquals("http://host/", url.toString());
+    assertEquals(null, url.fragment());
+    assertEquals(null, url.encodedFragment());
+  }
+
+  @Test public void topPrivateDomain() {
+    assertEquals("google.com", HttpUrl.parse("https://google.com").topPrivateDomain());
+    assertEquals("google.co.uk", HttpUrl.parse("https://adwords.google.co.uk").topPrivateDomain());
+    assertEquals("xn--ewv.xn--4pvxs.jp", HttpUrl.parse("https://栃.栃木.jp").topPrivateDomain());
+    assertEquals("xn--ewv.xn--4pvxs.jp",
+        HttpUrl.parse("https://xn--ewv.xn--4pvxs.jp").topPrivateDomain());
+
+    assertNull(HttpUrl.parse("https://co.uk").topPrivateDomain());
+    assertNull(HttpUrl.parse("https://square").topPrivateDomain());
+    assertNull(HttpUrl.parse("https://栃木.jp").topPrivateDomain());
+    assertNull(HttpUrl.parse("https://xn--4pvxs.jp").topPrivateDomain());
+    assertNull(HttpUrl.parse("https://localhost").topPrivateDomain());
+    assertNull(HttpUrl.parse("https://127.0.0.1").topPrivateDomain());
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java b/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
new file mode 100644
index 0000000000..e01a360b9b
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
@@ -0,0 +1,951 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.SocketTimeoutException;
+import java.util.Arrays;
+import java.util.Locale;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.SynchronousQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.mockwebserver.SocketPolicy;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.ForwardingSink;
+import okio.ForwardingSource;
+import okio.GzipSink;
+import okio.Okio;
+import okio.Sink;
+import okio.Source;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static okhttp3.TestUtil.defaultClient;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class InterceptorTest {
+  @Rule public MockWebServer server = new MockWebServer();
+
+  private OkHttpClient client = defaultClient();
+  private RecordingCallback callback = new RecordingCallback();
+
+  @Test public void applicationInterceptorsCanShortCircuitResponses() throws Exception {
+    server.shutdown(); // Accept no connections.
+
+    Request request = new Request.Builder()
+        .url("https://localhost:1/")
+        .build();
+
+    final Response interceptorResponse = new Response.Builder()
+        .request(request)
+        .protocol(Protocol.HTTP_1_1)
+        .code(200)
+        .message("Intercepted!")
+        .body(ResponseBody.create(MediaType.parse("text/plain; charset=utf-8"), "abc"))
+        .build();
+
+    client = client.newBuilder()
+        .addInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            return interceptorResponse;
+          }
+        }).build();
+
+    Response response = client.newCall(request).execute();
+    assertSame(interceptorResponse, response);
+  }
+
+  @Test public void networkInterceptorsCannotShortCircuitResponses() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(500));
+
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        return new Response.Builder()
+            .request(chain.request())
+            .protocol(Protocol.HTTP_1_1)
+            .code(200)
+            .message("Intercepted!")
+            .body(ResponseBody.create(MediaType.parse("text/plain; charset=utf-8"), "abc"))
+            .build();
+      }
+    };
+    client = client.newBuilder()
+        .addNetworkInterceptor(interceptor)
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals("network interceptor " + interceptor + " must call proceed() exactly once",
+          expected.getMessage());
+    }
+  }
+
+  @Test public void networkInterceptorsCannotCallProceedMultipleTimes() throws Exception {
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        chain.proceed(chain.request());
+        return chain.proceed(chain.request());
+      }
+    };
+    client = client.newBuilder()
+        .addNetworkInterceptor(interceptor)
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals("network interceptor " + interceptor + " must call proceed() exactly once",
+          expected.getMessage());
+    }
+  }
+
+  @Test public void networkInterceptorsCannotChangeServerAddress() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(500));
+
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        Address address = chain.connection().route().address();
+        String sameHost = address.url().host();
+        int differentPort = address.url().port() + 1;
+        return chain.proceed(chain.request().newBuilder()
+            .url(HttpUrl.parse("http://" + sameHost + ":" + differentPort + "/"))
+            .build());
+      }
+    };
+    client = client.newBuilder()
+        .addNetworkInterceptor(interceptor)
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals("network interceptor " + interceptor + " must retain the same host and port",
+          expected.getMessage());
+    }
+  }
+
+  @Test public void networkInterceptorsHaveConnectionAccess() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        Connection connection = chain.connection();
+        assertNotNull(connection);
+        return chain.proceed(chain.request());
+      }
+    };
+    client = client.newBuilder()
+        .addNetworkInterceptor(interceptor)
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    client.newCall(request).execute();
+  }
+
+  @Test public void networkInterceptorsObserveNetworkHeaders() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(gzip("abcabcabc"))
+        .addHeader("Content-Encoding: gzip"));
+
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        // The network request has everything: User-Agent, Host, Accept-Encoding.
+        Request networkRequest = chain.request();
+        assertNotNull(networkRequest.header("User-Agent"));
+        assertEquals(server.getHostName() + ":" + server.getPort(),
+            networkRequest.header("Host"));
+        assertNotNull(networkRequest.header("Accept-Encoding"));
+
+        // The network response also has everything, including the raw gzipped content.
+        Response networkResponse = chain.proceed(networkRequest);
+        assertEquals("gzip", networkResponse.header("Content-Encoding"));
+        return networkResponse;
+      }
+    };
+    client = client.newBuilder()
+        .addNetworkInterceptor(interceptor)
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    // No extra headers in the application's request.
+    assertNull(request.header("User-Agent"));
+    assertNull(request.header("Host"));
+    assertNull(request.header("Accept-Encoding"));
+
+    // No extra headers in the application's response.
+    Response response = client.newCall(request).execute();
+    assertNull(request.header("Content-Encoding"));
+    assertEquals("abcabcabc", response.body().string());
+  }
+
+  @Test public void networkInterceptorsCanChangeRequestMethodFromGetToPost() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        Request originalRequest = chain.request();
+        MediaType mediaType = MediaType.parse("text/plain");
+        RequestBody body = RequestBody.create(mediaType, "abc");
+        return chain.proceed(originalRequest.newBuilder()
+            .method("POST", body)
+            .header("Content-Type", mediaType.toString())
+            .header("Content-Length", Long.toString(body.contentLength()))
+            .build());
+      }
+    };
+    client = client.newBuilder()
+        .addNetworkInterceptor(interceptor)
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .get()
+        .build();
+
+    client.newCall(request).execute();
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("POST", recordedRequest.getMethod());
+    assertEquals("abc", recordedRequest.getBody().readUtf8());
+  }
+
+  @Test public void applicationInterceptorsRewriteRequestToServer() throws Exception {
+    rewriteRequestToServer(false);
+  }
+
+  @Test public void networkInterceptorsRewriteRequestToServer() throws Exception {
+    rewriteRequestToServer(true);
+  }
+
+  private void rewriteRequestToServer(boolean network) throws Exception {
+    server.enqueue(new MockResponse());
+
+    addInterceptor(network, new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        Request originalRequest = chain.request();
+        return chain.proceed(originalRequest.newBuilder()
+            .method("POST", uppercase(originalRequest.body()))
+            .addHeader("OkHttp-Intercepted", "yep")
+            .build());
+      }
+    });
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .addHeader("Original-Header", "foo")
+        .method("PUT", RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .build();
+
+    client.newCall(request).execute();
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("ABC", recordedRequest.getBody().readUtf8());
+    assertEquals("foo", recordedRequest.getHeader("Original-Header"));
+    assertEquals("yep", recordedRequest.getHeader("OkHttp-Intercepted"));
+    assertEquals("POST", recordedRequest.getMethod());
+  }
+
+  @Test public void applicationInterceptorsRewriteResponseFromServer() throws Exception {
+    rewriteResponseFromServer(false);
+  }
+
+  @Test public void networkInterceptorsRewriteResponseFromServer() throws Exception {
+    rewriteResponseFromServer(true);
+  }
+
+  private void rewriteResponseFromServer(boolean network) throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Original-Header: foo")
+        .setBody("abc"));
+
+    addInterceptor(network, new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        Response originalResponse = chain.proceed(chain.request());
+        return originalResponse.newBuilder()
+            .body(uppercase(originalResponse.body()))
+            .addHeader("OkHttp-Intercepted", "yep")
+            .build();
+      }
+    });
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Response response = client.newCall(request).execute();
+    assertEquals("ABC", response.body().string());
+    assertEquals("yep", response.header("OkHttp-Intercepted"));
+    assertEquals("foo", response.header("Original-Header"));
+  }
+
+  @Test public void multipleApplicationInterceptors() throws Exception {
+    multipleInterceptors(false);
+  }
+
+  @Test public void multipleNetworkInterceptors() throws Exception {
+    multipleInterceptors(true);
+  }
+
+  private void multipleInterceptors(boolean network) throws Exception {
+    server.enqueue(new MockResponse());
+
+    addInterceptor(network, new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        Request originalRequest = chain.request();
+        Response originalResponse = chain.proceed(originalRequest.newBuilder()
+            .addHeader("Request-Interceptor", "Android") // 1. Added first.
+            .build());
+        return originalResponse.newBuilder()
+            .addHeader("Response-Interceptor", "Donut") // 4. Added last.
+            .build();
+      }
+    });
+    addInterceptor(network, new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        Request originalRequest = chain.request();
+        Response originalResponse = chain.proceed(originalRequest.newBuilder()
+            .addHeader("Request-Interceptor", "Bob") // 2. Added second.
+            .build());
+        return originalResponse.newBuilder()
+            .addHeader("Response-Interceptor", "Cupcake") // 3. Added third.
+            .build();
+      }
+    });
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Response response = client.newCall(request).execute();
+    assertEquals(Arrays.asList("Cupcake", "Donut"),
+        response.headers("Response-Interceptor"));
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals(Arrays.asList("Android", "Bob"),
+        recordedRequest.getHeaders().values("Request-Interceptor"));
+  }
+
+  @Test public void asyncApplicationInterceptors() throws Exception {
+    asyncInterceptors(false);
+  }
+
+  @Test public void asyncNetworkInterceptors() throws Exception {
+    asyncInterceptors(true);
+  }
+
+  private void asyncInterceptors(boolean network) throws Exception {
+    server.enqueue(new MockResponse());
+
+    addInterceptor(network, new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        Response originalResponse = chain.proceed(chain.request());
+        return originalResponse.newBuilder()
+            .addHeader("OkHttp-Intercepted", "yep")
+            .build();
+      }
+    });
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    client.newCall(request).enqueue(callback);
+
+    callback.await(request.url())
+        .assertCode(200)
+        .assertHeader("OkHttp-Intercepted", "yep");
+  }
+
+  @Test public void applicationInterceptorsCanMakeMultipleRequestsToServer() throws Exception {
+    server.enqueue(new MockResponse().setBody("a"));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    client = client.newBuilder()
+        .addInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            Response response1 = chain.proceed(chain.request());
+            response1.body().close();
+            return chain.proceed(chain.request());
+          }
+        }).build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Response response = client.newCall(request).execute();
+    assertEquals(response.body().string(), "b");
+  }
+
+  /** Make sure interceptors can interact with the OkHttp client. */
+  @Test public void interceptorMakesAnUnrelatedRequest() throws Exception {
+    server.enqueue(new MockResponse().setBody("a")); // Fetched by interceptor.
+    server.enqueue(new MockResponse().setBody("b")); // Fetched directly.
+
+    client = client.newBuilder()
+        .addInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            if (chain.request().url().encodedPath().equals("/b")) {
+              Request requestA = new Request.Builder()
+                  .url(server.url("/a"))
+                  .build();
+              Response responseA = client.newCall(requestA).execute();
+              assertEquals("a", responseA.body().string());
+            }
+
+            return chain.proceed(chain.request());
+          }
+        }).build();
+
+    Request requestB = new Request.Builder()
+        .url(server.url("/b"))
+        .build();
+    Response responseB = client.newCall(requestB).execute();
+    assertEquals("b", responseB.body().string());
+  }
+
+  /** Make sure interceptors can interact with the OkHttp client asynchronously. */
+  @Test public void interceptorMakesAnUnrelatedAsyncRequest() throws Exception {
+    server.enqueue(new MockResponse().setBody("a")); // Fetched by interceptor.
+    server.enqueue(new MockResponse().setBody("b")); // Fetched directly.
+
+    client = client.newBuilder()
+        .addInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            if (chain.request().url().encodedPath().equals("/b")) {
+              Request requestA = new Request.Builder()
+                  .url(server.url("/a"))
+                  .build();
+
+              try {
+                RecordingCallback callbackA = new RecordingCallback();
+                client.newCall(requestA).enqueue(callbackA);
+                callbackA.await(requestA.url()).assertBody("a");
+              } catch (Exception e) {
+                throw new RuntimeException(e);
+              }
+            }
+
+            return chain.proceed(chain.request());
+          }
+        }).build();
+
+    Request requestB = new Request.Builder()
+        .url(server.url("/b"))
+        .build();
+    RecordingCallback callbackB = new RecordingCallback();
+    client.newCall(requestB).enqueue(callbackB);
+    callbackB.await(requestB.url()).assertBody("b");
+  }
+
+  @Test public void applicationInterceptorThrowsRuntimeExceptionSynchronous() throws Exception {
+    interceptorThrowsRuntimeExceptionSynchronous(false);
+  }
+
+  @Test public void networkInterceptorThrowsRuntimeExceptionSynchronous() throws Exception {
+    interceptorThrowsRuntimeExceptionSynchronous(true);
+  }
+
+  /**
+   * When an interceptor throws an unexpected exception, synchronous callers can catch it and deal
+   * with it.
+   */
+  private void interceptorThrowsRuntimeExceptionSynchronous(boolean network) throws Exception {
+    addInterceptor(network, new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        throw new RuntimeException("boom!");
+      }
+    });
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (RuntimeException expected) {
+      assertEquals("boom!", expected.getMessage());
+    }
+  }
+
+  @Test public void networkInterceptorModifiedRequestIsReturned() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Interceptor modifyHeaderInterceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        return chain.proceed(chain.request().newBuilder()
+            .header("User-Agent", "intercepted request")
+            .build());
+      }
+    };
+
+    client = client.newBuilder()
+        .addNetworkInterceptor(modifyHeaderInterceptor)
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .header("User-Agent", "user request")
+        .build();
+
+    Response response = client.newCall(request).execute();
+    assertNotNull(response.request().header("User-Agent"));
+    assertEquals("user request", response.request().header("User-Agent"));
+    assertEquals("intercepted request", response.networkResponse().request().header("User-Agent"));
+  }
+
+  @Test public void applicationInterceptorThrowsRuntimeExceptionAsynchronous() throws Exception {
+    interceptorThrowsRuntimeExceptionAsynchronous(false);
+  }
+
+  @Test public void networkInterceptorThrowsRuntimeExceptionAsynchronous() throws Exception {
+    interceptorThrowsRuntimeExceptionAsynchronous(true);
+  }
+
+  /**
+   * When an interceptor throws an unexpected exception, asynchronous callers are left hanging. The
+   * exception goes to the uncaught exception handler.
+   */
+  private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) throws Exception {
+    addInterceptor(network, new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        throw new RuntimeException("boom!");
+      }
+    });
+
+    ExceptionCatchingExecutor executor = new ExceptionCatchingExecutor();
+    client = client.newBuilder()
+        .dispatcher(new Dispatcher(executor))
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    client.newCall(request).enqueue(callback);
+
+    assertEquals("boom!", executor.takeException().getMessage());
+  }
+
+  @Test public void applicationInterceptorReturnsNull() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        chain.proceed(chain.request());
+        return null;
+      }
+    };
+    client = client.newBuilder()
+        .addInterceptor(interceptor)
+        .build();
+
+    ExceptionCatchingExecutor executor = new ExceptionCatchingExecutor();
+    client = client.newBuilder()
+        .dispatcher(new Dispatcher(executor))
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (NullPointerException expected) {
+      assertEquals("interceptor " + interceptor + " returned null", expected.getMessage());
+    }
+  }
+
+  @Test public void networkInterceptorReturnsNull() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        chain.proceed(chain.request());
+        return null;
+      }
+    };
+    client = client.newBuilder()
+        .addNetworkInterceptor(interceptor)
+        .build();
+
+    ExceptionCatchingExecutor executor = new ExceptionCatchingExecutor();
+    client = client.newBuilder()
+        .dispatcher(new Dispatcher(executor))
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (NullPointerException expected) {
+      assertEquals("interceptor " + interceptor + " returned null", expected.getMessage());
+    }
+  }
+
+  @Test public void networkInterceptorReturnsConnectionOnEmptyBody() throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .addHeader("Connection", "Close"));
+
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        Response response = chain.proceed(chain.request());
+        assertNotNull(chain.connection());
+        return response;
+      }
+    };
+
+    client = client.newBuilder()
+        .addNetworkInterceptor(interceptor)
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Response response = client.newCall(request).execute();
+    response.body().close();
+  }
+
+  @Test public void applicationInterceptorResponseMustHaveBody() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        return chain.proceed(chain.request()).newBuilder().body(null).build();
+      }
+    };
+    client = client.newBuilder()
+        .addInterceptor(interceptor)
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals("interceptor " + interceptor + " returned a response with no body",
+          expected.getMessage());
+    }
+  }
+
+  @Test public void networkInterceptorResponseMustHaveBody() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        return chain.proceed(chain.request()).newBuilder().body(null).build();
+      }
+    };
+    client = client.newBuilder()
+        .addNetworkInterceptor(interceptor)
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals("interceptor " + interceptor + " returned a response with no body",
+          expected.getMessage());
+    }
+  }
+
+  @Test public void connectTimeout() throws Exception {
+    Interceptor interceptor1 = new Interceptor() {
+      @Override public Response intercept(Chain chainA) throws IOException {
+        assertEquals(5000, chainA.connectTimeoutMillis());
+
+        Chain chainB = chainA.withConnectTimeout(100, TimeUnit.MILLISECONDS);
+        assertEquals(100, chainB.connectTimeoutMillis());
+
+        return chainB.proceed(chainA.request());
+      }
+    };
+
+    Interceptor interceptor2 = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        assertEquals(100, chain.connectTimeoutMillis());
+        return chain.proceed(chain.request());
+      }
+    };
+
+    client = client.newBuilder()
+        .connectTimeout(5, TimeUnit.SECONDS)
+        .addInterceptor(interceptor1)
+        .addInterceptor(interceptor2)
+        .build();
+
+    Request request1 = new Request.Builder()
+        .url("http://" + TestUtil.UNREACHABLE_ADDRESS)
+        .build();
+    Call call = client.newCall(request1);
+
+    try {
+      call.execute();
+      fail();
+    } catch (SocketTimeoutException expected) {
+    }
+  }
+
+  @Test public void chainWithReadTimeout() throws Exception {
+    Interceptor interceptor1 = new Interceptor() {
+      @Override public Response intercept(Chain chainA) throws IOException {
+        assertEquals(5000, chainA.readTimeoutMillis());
+
+        Chain chainB = chainA.withReadTimeout(100, TimeUnit.MILLISECONDS);
+        assertEquals(100, chainB.readTimeoutMillis());
+
+        return chainB.proceed(chainA.request());
+      }
+    };
+
+    Interceptor interceptor2 = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        assertEquals(100, chain.readTimeoutMillis());
+        return chain.proceed(chain.request());
+      }
+    };
+
+    client = client.newBuilder()
+        .readTimeout(5, TimeUnit.SECONDS)
+        .addInterceptor(interceptor1)
+        .addInterceptor(interceptor2)
+        .build();
+
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .throttleBody(1, 1, TimeUnit.SECONDS));
+
+    Request request1 = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Call call = client.newCall(request1);
+    Response response = call.execute();
+    ResponseBody body = response.body();
+    try {
+      body.string();
+      fail();
+    } catch (SocketTimeoutException expected) {
+    }
+  }
+
+  @Test public void chainWithWriteTimeout() throws Exception {
+    Interceptor interceptor1 = new Interceptor() {
+      @Override public Response intercept(Chain chainA) throws IOException {
+        assertEquals(5000, chainA.writeTimeoutMillis());
+
+        Chain chainB = chainA.withWriteTimeout(100, TimeUnit.MILLISECONDS);
+        assertEquals(100, chainB.writeTimeoutMillis());
+
+        return chainB.proceed(chainA.request());
+      }
+    };
+
+    Interceptor interceptor2 = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        assertEquals(100, chain.writeTimeoutMillis());
+        return chain.proceed(chain.request());
+      }
+    };
+
+    client = client.newBuilder()
+        .writeTimeout(5, TimeUnit.SECONDS)
+        .addInterceptor(interceptor1)
+        .addInterceptor(interceptor2)
+        .build();
+
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .throttleBody(1, 1, TimeUnit.SECONDS));
+
+    byte[] data = new byte[2 * 1024 * 1024]; // 2 MiB.
+    Request request1 = new Request.Builder()
+        .url(server.url("/"))
+        .post(RequestBody.create(MediaType.parse("text/plain"), data))
+        .build();
+    Call call = client.newCall(request1);
+
+    try {
+      call.execute(); // we want this call to throw a SocketTimeoutException
+      fail();
+    } catch (SocketTimeoutException expected) {
+    }
+  }
+
+  @Test public void chainCanCancelCall() throws Exception {
+    final AtomicReference<Call> callRef = new AtomicReference<>();
+
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        Call call = chain.call();
+        callRef.set(call);
+
+        assertFalse(call.isCanceled());
+        call.cancel();
+        assertTrue(call.isCanceled());
+
+        return chain.proceed(chain.request());
+      }
+    };
+
+    client = client.newBuilder()
+        .addInterceptor(interceptor)
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Call call = client.newCall(request);
+
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    assertSame(call, callRef.get());
+  }
+
+  private RequestBody uppercase(final RequestBody original) {
+    return new RequestBody() {
+      @Override public MediaType contentType() {
+        return original.contentType();
+      }
+
+      @Override public long contentLength() throws IOException {
+        return original.contentLength();
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        Sink uppercase = uppercase(sink);
+        BufferedSink bufferedSink = Okio.buffer(uppercase);
+        original.writeTo(bufferedSink);
+        bufferedSink.emit();
+      }
+    };
+  }
+
+  private Sink uppercase(final BufferedSink original) {
+    return new ForwardingSink(original) {
+      @Override public void write(Buffer source, long byteCount) throws IOException {
+        original.writeUtf8(source.readUtf8(byteCount).toUpperCase(Locale.US));
+      }
+    };
+  }
+
+  static ResponseBody uppercase(ResponseBody original) throws IOException {
+    return ResponseBody.create(original.contentType(), original.contentLength(),
+        Okio.buffer(uppercase(original.source())));
+  }
+
+  private static Source uppercase(final Source original) {
+    return new ForwardingSource(original) {
+      @Override public long read(Buffer sink, long byteCount) throws IOException {
+        Buffer mixedCase = new Buffer();
+        long count = original.read(mixedCase, byteCount);
+        sink.writeUtf8(mixedCase.readUtf8().toUpperCase(Locale.US));
+        return count;
+      }
+    };
+  }
+
+  private Buffer gzip(String data) throws IOException {
+    Buffer result = new Buffer();
+    BufferedSink sink = Okio.buffer(new GzipSink(result));
+    sink.writeUtf8(data);
+    sink.close();
+    return result;
+  }
+
+  private void addInterceptor(boolean network, Interceptor interceptor) {
+    OkHttpClient.Builder builder = client.newBuilder();
+    if (network) {
+      builder.addNetworkInterceptor(interceptor);
+    } else {
+      builder.addInterceptor(interceptor);
+    }
+    client = builder.build();
+  }
+
+  /** Catches exceptions that are otherwise headed for the uncaught exception handler. */
+  private static class ExceptionCatchingExecutor extends ThreadPoolExecutor {
+    private final BlockingQueue<Exception> exceptions = new LinkedBlockingQueue<>();
+
+    public ExceptionCatchingExecutor() {
+      super(1, 1, 0, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());
+    }
+
+    @Override public void execute(final Runnable runnable) {
+      super.execute(new Runnable() {
+        @Override public void run() {
+          try {
+            runnable.run();
+          } catch (Exception e) {
+            exceptions.add(e);
+          }
+        }
+      });
+    }
+
+    public Exception takeException() throws InterruptedException {
+      return exceptions.take();
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java b/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java
new file mode 100644
index 0000000000..b2d3f396fa
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java
@@ -0,0 +1,181 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2011 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.nio.charset.Charset;
+import okhttp3.internal.Util;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+/**
+ * Test MediaType API and parsing.
+ *
+ * <p>This test includes tests from <a href="https://code.google.com/p/guava-libraries/">Guava's</a>
+ * MediaTypeTest.
+ */
+public class MediaTypeTest {
+  @Test public void testParse() throws Exception {
+    MediaType mediaType = MediaType.parse("text/plain;boundary=foo;charset=utf-8");
+    assertEquals("text", mediaType.type());
+    assertEquals("plain", mediaType.subtype());
+    assertEquals("UTF-8", mediaType.charset().name());
+    assertEquals("text/plain;boundary=foo;charset=utf-8", mediaType.toString());
+    assertTrue(mediaType.equals(MediaType.parse("text/plain;boundary=foo;charset=utf-8")));
+    assertEquals(mediaType.hashCode(),
+        MediaType.parse("text/plain;boundary=foo;charset=utf-8").hashCode());
+  }
+
+  @Test public void testValidParse() throws Exception {
+    assertMediaType("text/plain");
+    assertMediaType("application/atom+xml; charset=utf-8");
+    assertMediaType("application/atom+xml; a=1; a=2; b=3");
+    assertMediaType("image/gif; foo=bar");
+    assertMediaType("text/plain; a=1");
+    assertMediaType("text/plain; a=1; a=2; b=3");
+    assertMediaType("text/plain; charset=utf-16");
+    assertMediaType("text/plain; \t \n \r a=b");
+    assertMediaType("text/plain;");
+    assertMediaType("text/plain; ");
+    assertMediaType("text/plain; a=1;");
+    assertMediaType("text/plain; a=1; ");
+    assertMediaType("text/plain; a=1;; b=2");
+    assertMediaType("text/plain;;");
+    assertMediaType("text/plain; ;");
+  }
+
+  @Test public void testInvalidParse() throws Exception {
+    assertInvalid("");
+    assertInvalid("/");
+    assertInvalid("/");
+    assertInvalid("text");
+    assertInvalid("text/");
+    assertInvalid("te<t/plain");
+    assertInvalid("text/pl@in");
+    assertInvalid("text/plain; a");
+    assertInvalid("text/plain; a=");
+    assertInvalid("text/plain; a=@");
+    assertInvalid("text/plain; a=\"@");
+    assertInvalid("text/plain; a=1; b");
+    assertInvalid("text/plain; a=1; b=");
+    assertInvalid("text/plain; a=\u2025");
+    assertInvalid(" text/plain");
+    assertInvalid("te xt/plain");
+    assertInvalid("text /plain");
+    assertInvalid("text/ plain");
+    assertInvalid("text/pl ain");
+    assertInvalid("text/plain ");
+    assertInvalid("text/plain ; a=1");
+  }
+
+  @Test public void testDoubleQuotesAreSpecial() throws Exception {
+    MediaType mediaType = MediaType.parse("text/plain;a=\";charset=utf-8;b=\"");
+    assertNull(mediaType.charset());
+  }
+
+  @Test public void testSingleQuotesAreNotSpecial() throws Exception {
+    MediaType mediaType = MediaType.parse("text/plain;a=';charset=utf-8;b='");
+    assertEquals("UTF-8", mediaType.charset().name());
+  }
+
+  @Test public void testParseWithSpecialCharacters() throws Exception {
+    MediaType mediaType = MediaType.parse(
+        "!#$%&'*+-.{|}~/!#$%&'*+-.{|}~; !#$%&'*+-.{|}~=!#$%&'*+-.{|}~");
+    assertEquals("!#$%&'*+-.{|}~", mediaType.type());
+    assertEquals("!#$%&'*+-.{|}~", mediaType.subtype());
+  }
+
+  @Test public void testCharsetIsOneOfManyParameters() throws Exception {
+    MediaType mediaType = MediaType.parse("text/plain;a=1;b=2;charset=utf-8;c=3");
+    assertEquals("text", mediaType.type());
+    assertEquals("plain", mediaType.subtype());
+    assertEquals("UTF-8", mediaType.charset().name());
+  }
+
+  @Test public void testCharsetAndQuoting() throws Exception {
+    MediaType mediaType = MediaType.parse(
+        "text/plain;a=\";charset=us-ascii\";charset=\"utf-8\";b=\"iso-8859-1\"");
+    assertEquals("UTF-8", mediaType.charset().name());
+  }
+
+  @Test public void testDuplicatedCharsets() {
+    MediaType mediaType = MediaType.parse("text/plain; charset=utf-8; charset=UTF-8");
+    assertEquals("UTF-8", mediaType.charset().name());
+  }
+
+  @Test public void testMultipleCharsets() {
+    assertNull(MediaType.parse("text/plain; charset=utf-8; charset=utf-16"));
+  }
+
+  @Test public void testIllegalCharsetName() {
+    MediaType mediaType = MediaType.parse("text/plain; charset=\"!@#$%^&*()\"");
+    assertNull(mediaType.charset());
+  }
+
+  @Test public void testUnsupportedCharset() {
+    MediaType mediaType = MediaType.parse("text/plain; charset=utf-wtf");
+    assertNull(mediaType.charset());
+  }
+
+  /**
+   * This is invalid according to RFC 822. But it's what Chrome does and it avoids a potentially
+   * unpleasant IllegalCharsetNameException.
+   */
+  @Test public void testCharsetNameIsSingleQuoted() throws Exception {
+    MediaType mediaType = MediaType.parse("text/plain;charset='utf-8'");
+    assertEquals("UTF-8", mediaType.charset().name());
+  }
+
+  @Test public void testCharsetNameIsDoubleQuotedAndSingleQuoted() throws Exception {
+    MediaType mediaType = MediaType.parse("text/plain;charset=\"'utf-8'\"");
+    assertNull(mediaType.charset());
+  }
+
+  @Test public void testCharsetNameIsDoubleQuotedSingleQuote() throws Exception {
+    MediaType mediaType = MediaType.parse("text/plain;charset=\"'\"");
+    assertNull(mediaType.charset());
+  }
+
+  @Test public void testDefaultCharset() throws Exception {
+    MediaType noCharset = MediaType.parse("text/plain");
+    assertEquals("UTF-8", noCharset.charset(Util.UTF_8).name());
+    assertEquals("US-ASCII", noCharset.charset(Charset.forName("US-ASCII")).name());
+
+    MediaType charset = MediaType.parse("text/plain; charset=iso-8859-1");
+    assertEquals("ISO-8859-1", charset.charset(Util.UTF_8).name());
+    assertEquals("ISO-8859-1", charset.charset(Charset.forName("US-ASCII")).name());
+  }
+
+  @Test public void testParseDanglingSemicolon() throws Exception {
+    MediaType mediaType = MediaType.parse("text/plain;");
+    assertEquals("text", mediaType.type());
+    assertEquals("plain", mediaType.subtype());
+    assertNull(mediaType.charset());
+    assertEquals("text/plain;", mediaType.toString());
+  }
+
+  private void assertMediaType(String string) {
+    MediaType mediaType = MediaType.parse(string);
+    assertEquals(string, mediaType.toString());
+  }
+
+  private void assertInvalid(String string) {
+    assertNull(string, MediaType.parse(string));
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java b/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java
new file mode 100644
index 0000000000..35d2f67906
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java
@@ -0,0 +1,274 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import okio.Buffer;
+import okio.BufferedSink;
+import org.junit.Test;
+
+import static okhttp3.internal.Util.UTF_8;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class MultipartBodyTest {
+  @Test public void onePartRequired() throws Exception {
+    try {
+      new MultipartBody.Builder().build();
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals("Multipart body must have at least one part.", e.getMessage());
+    }
+  }
+
+  @Test public void singlePart() throws Exception {
+    String expected = ""
+        + "--123\r\n"
+        + "Content-Length: 13\r\n"
+        + "\r\n"
+        + "Hello, World!\r\n"
+        + "--123--\r\n";
+
+    MultipartBody body = new MultipartBody.Builder("123")
+        .addPart(RequestBody.create(null, "Hello, World!"))
+        .build();
+
+    assertEquals("123", body.boundary());
+    assertEquals(MultipartBody.MIXED, body.type());
+    assertEquals("multipart/mixed; boundary=123", body.contentType().toString());
+    assertEquals(1, body.parts().size());
+    assertEquals(53, body.contentLength());
+
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    assertEquals(buffer.size(), body.contentLength());
+    assertEquals(expected, buffer.readUtf8());
+  }
+
+  @Test public void threeParts() throws Exception {
+    String expected = ""
+        + "--123\r\n"
+        + "Content-Length: 5\r\n"
+        + "\r\n"
+        + "Quick\r\n"
+        + "--123\r\n"
+        + "Content-Length: 5\r\n"
+        + "\r\n"
+        + "Brown\r\n"
+        + "--123\r\n"
+        + "Content-Length: 3\r\n"
+        + "\r\n"
+        + "Fox\r\n"
+        + "--123--\r\n";
+
+    MultipartBody body = new MultipartBody.Builder("123")
+        .addPart(RequestBody.create(null, "Quick"))
+        .addPart(RequestBody.create(null, "Brown"))
+        .addPart(RequestBody.create(null, "Fox"))
+        .build();
+
+    assertEquals("123", body.boundary());
+    assertEquals(MultipartBody.MIXED, body.type());
+    assertEquals("multipart/mixed; boundary=123", body.contentType().toString());
+    assertEquals(3, body.parts().size());
+    assertEquals(112, body.contentLength());
+
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    assertEquals(buffer.size(), body.contentLength());
+    assertEquals(expected, buffer.readUtf8());
+  }
+
+  @Test public void fieldAndTwoFiles() throws Exception {
+    String expected = ""
+        + "--AaB03x\r\n"
+        + "Content-Disposition: form-data; name=\"submit-name\"\r\n"
+        + "Content-Length: 5\r\n"
+        + "\r\n"
+        + "Larry\r\n"
+        + "--AaB03x\r\n"
+        + "Content-Disposition: form-data; name=\"files\"\r\n"
+        + "Content-Type: multipart/mixed; boundary=BbC04y\r\n"
+        + "Content-Length: 337\r\n"
+        + "\r\n"
+        + "--BbC04y\r\n"
+        + "Content-Disposition: file; filename=\"file1.txt\"\r\n"
+        + "Content-Type: text/plain; charset=utf-8\r\n"
+        + "Content-Length: 29\r\n"
+        + "\r\n"
+        + "... contents of file1.txt ...\r\n"
+        + "--BbC04y\r\n"
+        + "Content-Disposition: file; filename=\"file2.gif\"\r\n"
+        + "Content-Transfer-Encoding: binary\r\n"
+        + "Content-Type: image/gif\r\n"
+        + "Content-Length: 29\r\n"
+        + "\r\n"
+        + "... contents of file2.gif ...\r\n"
+        + "--BbC04y--\r\n"
+        + "\r\n"
+        + "--AaB03x--\r\n";
+
+    MultipartBody body = new MultipartBody.Builder("AaB03x")
+        .setType(MultipartBody.FORM)
+        .addFormDataPart("submit-name", "Larry")
+        .addFormDataPart("files", null,
+            new MultipartBody.Builder("BbC04y")
+                .addPart(
+                    Headers.of("Content-Disposition", "file; filename=\"file1.txt\""),
+                    RequestBody.create(
+                        MediaType.parse("text/plain"), "... contents of file1.txt ..."))
+                .addPart(
+                    Headers.of(
+                        "Content-Disposition", "file; filename=\"file2.gif\"",
+                        "Content-Transfer-Encoding", "binary"),
+                    RequestBody.create(
+                        MediaType.parse("image/gif"),
+                        "... contents of file2.gif ...".getBytes(UTF_8)))
+                .build())
+        .build();
+
+    assertEquals("AaB03x", body.boundary());
+    assertEquals(MultipartBody.FORM, body.type());
+    assertEquals("multipart/form-data; boundary=AaB03x", body.contentType().toString());
+    assertEquals(2, body.parts().size());
+    assertEquals(568, body.contentLength());
+
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    assertEquals(buffer.size(), body.contentLength());
+    assertEquals(expected, buffer.readUtf8());
+  }
+
+  @Test public void stringEscapingIsWeird() throws Exception {
+    String expected = ""
+        + "--AaB03x\r\n"
+        + "Content-Disposition: form-data; name=\"field with spaces\"; filename=\"filename with spaces.txt\"\r\n"
+        + "Content-Type: text/plain; charset=utf-8\r\n"
+        + "Content-Length: 4\r\n"
+        + "\r\n"
+        + "okay\r\n"
+        + "--AaB03x\r\n"
+        + "Content-Disposition: form-data; name=\"field with %22\"\r\n"
+        + "Content-Length: 1\r\n"
+        + "\r\n"
+        + "\"\r\n"
+        + "--AaB03x\r\n"
+        + "Content-Disposition: form-data; name=\"field with %22\"\r\n"
+        + "Content-Length: 3\r\n"
+        + "\r\n"
+        + "%22\r\n"
+        + "--AaB03x\r\n"
+        + "Content-Disposition: form-data; name=\"field with \u0391\"\r\n"
+        + "Content-Length: 5\r\n"
+        + "\r\n"
+        + "Alpha\r\n"
+        + "--AaB03x--\r\n";
+
+    MultipartBody body = new MultipartBody.Builder("AaB03x")
+        .setType(MultipartBody.FORM)
+        .addFormDataPart("field with spaces", "filename with spaces.txt",
+            RequestBody.create(MediaType.parse("text/plain; charset=utf-8"), "okay"))
+        .addFormDataPart("field with \"", "\"")
+        .addFormDataPart("field with %22", "%22")
+        .addFormDataPart("field with \u0391", "Alpha")
+        .build();
+
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    assertEquals(expected, buffer.readUtf8());
+  }
+
+  @Test public void streamingPartHasNoLength() throws Exception {
+    class StreamingBody extends RequestBody {
+      private final String body;
+
+      StreamingBody(String body) {
+        this.body = body;
+      }
+
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.writeUtf8(body);
+      }
+    }
+
+    String expected = ""
+        + "--123\r\n"
+        + "Content-Length: 5\r\n"
+        + "\r\n"
+        + "Quick\r\n"
+        + "--123\r\n"
+        + "\r\n"
+        + "Brown\r\n"
+        + "--123\r\n"
+        + "Content-Length: 3\r\n"
+        + "\r\n"
+        + "Fox\r\n"
+        + "--123--\r\n";
+
+    MultipartBody body = new MultipartBody.Builder("123")
+        .addPart(RequestBody.create(null, "Quick"))
+        .addPart(new StreamingBody("Brown"))
+        .addPart(RequestBody.create(null, "Fox"))
+        .build();
+
+    assertEquals("123", body.boundary());
+    assertEquals(MultipartBody.MIXED, body.type());
+    assertEquals("multipart/mixed; boundary=123", body.contentType().toString());
+    assertEquals(3, body.parts().size());
+    assertEquals(-1, body.contentLength());
+
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    assertEquals(expected, buffer.readUtf8());
+  }
+
+  @Test public void contentTypeHeaderIsForbidden() throws Exception {
+    MultipartBody.Builder multipart = new MultipartBody.Builder();
+    try {
+      multipart.addPart(Headers.of("Content-Type", "text/plain"),
+          RequestBody.create(null, "Hello, World!"));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void contentLengthHeaderIsForbidden() throws Exception {
+    MultipartBody.Builder multipart = new MultipartBody.Builder();
+    try {
+      multipart.addPart(Headers.of("Content-Length", "13"),
+          RequestBody.create(null, "Hello, World!"));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void partAccessors() throws IOException {
+    MultipartBody body = new MultipartBody.Builder()
+        .addPart(Headers.of("Foo", "Bar"), RequestBody.create(null, "Baz"))
+        .build();
+    assertEquals(1, body.parts().size());
+
+    Buffer part1Buffer = new Buffer();
+    MultipartBody.Part part1 = body.part(0);
+    part1.body().writeTo(part1Buffer);
+    assertEquals(Headers.of("Foo", "Bar"), part1.headers());
+    assertEquals("Baz", part1Buffer.readUtf8());
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/NullServer.java b/okhttp-tests/src/test/java/okhttp3/NullServer.java
new file mode 100644
index 0000000000..30a84f8ead
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/NullServer.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.ServerSocket;
+import javax.net.ServerSocketFactory;
+import okhttp3.internal.Util;
+
+public final class NullServer {
+  private InetSocketAddress address;
+  private ServerSocket nullServer;
+
+  public void start() throws Exception {
+    nullServer = ServerSocketFactory.getDefault().createServerSocket();
+    nullServer.bind(address, 0);
+    address = new InetSocketAddress(InetAddress.getByName("localhost"), nullServer.getLocalPort());
+  }
+
+  public void shutdown() {
+    Util.closeQuietly(nullServer);
+  }
+
+  public HttpUrl url(String scheme) {
+    return new HttpUrl.Builder()
+        .scheme(scheme)
+        .host(address.getHostName())
+        .port(nullServer.getLocalPort())
+        .build();
+  }
+
+  public InetSocketAddress address() {
+    return address;
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java b/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
new file mode 100644
index 0000000000..5582f3ce83
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
@@ -0,0 +1,172 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.CookieHandler;
+import java.net.CookieManager;
+import java.net.ProxySelector;
+import java.net.ResponseCache;
+import java.util.Arrays;
+import java.util.concurrent.TimeUnit;
+import org.junit.After;
+import org.junit.Test;
+
+import static okhttp3.TestUtil.defaultClient;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.fail;
+
+public final class OkHttpClientTest {
+  private static final ProxySelector DEFAULT_PROXY_SELECTOR = ProxySelector.getDefault();
+  private static final CookieHandler DEFAULT_COOKIE_HANDLER = CookieManager.getDefault();
+  private static final ResponseCache DEFAULT_RESPONSE_CACHE = ResponseCache.getDefault();
+
+  @After public void tearDown() throws Exception {
+    ProxySelector.setDefault(DEFAULT_PROXY_SELECTOR);
+    CookieManager.setDefault(DEFAULT_COOKIE_HANDLER);
+    ResponseCache.setDefault(DEFAULT_RESPONSE_CACHE);
+  }
+
+  @Test public void durationDefaults() {
+    OkHttpClient client = defaultClient();
+    assertEquals(10_000, client.connectTimeoutMillis());
+    assertEquals(10_000, client.readTimeoutMillis());
+    assertEquals(10_000, client.writeTimeoutMillis());
+    assertEquals(0, client.pingIntervalMillis());
+  }
+
+  @Test public void timeoutValidRange() {
+    OkHttpClient.Builder builder = new OkHttpClient.Builder();
+    try {
+      builder.connectTimeout(1, TimeUnit.NANOSECONDS);
+    } catch (IllegalArgumentException ignored) {
+    }
+    try {
+      builder.writeTimeout(1, TimeUnit.NANOSECONDS);
+    } catch (IllegalArgumentException ignored) {
+    }
+    try {
+      builder.readTimeout(1, TimeUnit.NANOSECONDS);
+    } catch (IllegalArgumentException ignored) {
+    }
+    try {
+      builder.connectTimeout(365, TimeUnit.DAYS);
+    } catch (IllegalArgumentException ignored) {
+    }
+    try {
+      builder.writeTimeout(365, TimeUnit.DAYS);
+    } catch (IllegalArgumentException ignored) {
+    }
+    try {
+      builder.readTimeout(365, TimeUnit.DAYS);
+    } catch (IllegalArgumentException ignored) {
+    }
+  }
+
+  @Test public void clonedInterceptorsListsAreIndependent() throws Exception {
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        return chain.proceed(chain.request());
+      }
+    };
+    OkHttpClient original = defaultClient();
+    original.newBuilder()
+        .addInterceptor(interceptor)
+        .addNetworkInterceptor(interceptor)
+        .build();
+    assertEquals(0, original.interceptors().size());
+    assertEquals(0, original.networkInterceptors().size());
+  }
+
+  /**
+   * When copying the client, stateful things like the connection pool are shared across all
+   * clients.
+   */
+  @Test public void cloneSharesStatefulInstances() throws Exception {
+    OkHttpClient client = defaultClient();
+
+    // Values should be non-null.
+    OkHttpClient a = client.newBuilder().build();
+    assertNotNull(a.dispatcher());
+    assertNotNull(a.connectionPool());
+    assertNotNull(a.sslSocketFactory());
+
+    // Multiple clients share the instances.
+    OkHttpClient b = client.newBuilder().build();
+    assertSame(a.dispatcher(), b.dispatcher());
+    assertSame(a.connectionPool(), b.connectionPool());
+    assertSame(a.sslSocketFactory(), b.sslSocketFactory());
+  }
+
+  @Test public void setProtocolsRejectsHttp10() throws Exception {
+    OkHttpClient.Builder builder = new OkHttpClient.Builder();
+    try {
+      builder.protocols(Arrays.asList(Protocol.HTTP_1_0, Protocol.HTTP_1_1));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void certificatePinnerEquality() {
+    OkHttpClient clientA = TestUtil.defaultClient();
+    OkHttpClient clientB = TestUtil.defaultClient();
+    assertEquals(clientA.certificatePinner(), clientB.certificatePinner());
+  }
+
+  @Test public void nullInterceptor() {
+    OkHttpClient.Builder builder = new OkHttpClient.Builder();
+    try {
+      builder.addInterceptor(null);
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals("interceptor == null", expected.getMessage());
+    }
+  }
+
+  @Test public void nullNetworkInterceptor() {
+    OkHttpClient.Builder builder = new OkHttpClient.Builder();
+    try {
+      builder.addNetworkInterceptor(null);
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals("interceptor == null", expected.getMessage());
+    }
+  }
+
+  @Test public void nullInterceptorInList() {
+    OkHttpClient.Builder builder = new OkHttpClient.Builder();
+    builder.interceptors().add(null);
+    try {
+      builder.build();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals("Null interceptor: [null]", expected.getMessage());
+    }
+  }
+
+  @Test public void nullNetworkInterceptorInList() {
+    OkHttpClient.Builder builder = new OkHttpClient.Builder();
+    builder.networkInterceptors().add(null);
+    try {
+      builder.build();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals("Null network interceptor: [null]", expected.getMessage());
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java b/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
new file mode 100644
index 0000000000..d34380cc4f
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
@@ -0,0 +1,195 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.text.SimpleDateFormat;
+import java.util.Arrays;
+import java.util.Date;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+/**
+ * A received response or failure recorded by the response recorder.
+ */
+public final class RecordedResponse {
+  public final Request request;
+  public final Response response;
+  public final WebSocket webSocket;
+  public final String body;
+  public final IOException failure;
+
+  public RecordedResponse(Request request, Response response, WebSocket webSocket, String body,
+      IOException failure) {
+    this.request = request;
+    this.response = response;
+    this.webSocket = webSocket;
+    this.body = body;
+    this.failure = failure;
+  }
+
+  public RecordedResponse assertRequestUrl(HttpUrl url) {
+    assertEquals(url, request.url());
+    return this;
+  }
+
+  public RecordedResponse assertRequestMethod(String method) {
+    assertEquals(method, request.method());
+    return this;
+  }
+
+  public RecordedResponse assertRequestHeader(String name, String... values) {
+    assertEquals(Arrays.asList(values), request.headers(name));
+    return this;
+  }
+
+  public RecordedResponse assertCode(int expectedCode) {
+    assertEquals(expectedCode, response.code());
+    return this;
+  }
+
+  public RecordedResponse assertSuccessful() {
+    assertTrue(response.isSuccessful());
+    return this;
+  }
+
+  public RecordedResponse assertNotSuccessful() {
+    assertFalse(response.isSuccessful());
+    return this;
+  }
+
+  public RecordedResponse assertHeader(String name, String... values) {
+    assertEquals(Arrays.asList(values), response.headers(name));
+    return this;
+  }
+
+  public RecordedResponse assertHeaders(Headers headers) {
+    assertEquals(headers, response.headers());
+    return this;
+  }
+
+  public RecordedResponse assertBody(String expectedBody) {
+    assertEquals(expectedBody, body);
+    return this;
+  }
+
+  public RecordedResponse assertHandshake() {
+    Handshake handshake = response.handshake();
+    assertNotNull(handshake.tlsVersion());
+    assertNotNull(handshake.cipherSuite());
+    assertNotNull(handshake.peerPrincipal());
+    assertEquals(1, handshake.peerCertificates().size());
+    assertNull(handshake.localPrincipal());
+    assertEquals(0, handshake.localCertificates().size());
+    return this;
+  }
+
+  /**
+   * Asserts that the current response was redirected and returns the prior response.
+   */
+  public RecordedResponse priorResponse() {
+    Response priorResponse = response.priorResponse();
+    assertNotNull(priorResponse);
+    assertNull(priorResponse.body());
+    return new RecordedResponse(priorResponse.request(), priorResponse, null, null, null);
+  }
+
+  /**
+   * Asserts that the current response used the network and returns the network response.
+   */
+  public RecordedResponse networkResponse() {
+    Response networkResponse = response.networkResponse();
+    assertNotNull(networkResponse);
+    assertNull(networkResponse.body());
+    return new RecordedResponse(networkResponse.request(), networkResponse, null, null, null);
+  }
+
+  /** Asserts that the current response didn't use the network. */
+  public RecordedResponse assertNoNetworkResponse() {
+    assertNull(response.networkResponse());
+    return this;
+  }
+
+  /** Asserts that the current response didn't use the cache. */
+  public RecordedResponse assertNoCacheResponse() {
+    assertNull(response.cacheResponse());
+    return this;
+  }
+
+  /**
+   * Asserts that the current response used the cache and returns the cache response.
+   */
+  public RecordedResponse cacheResponse() {
+    Response cacheResponse = response.cacheResponse();
+    assertNotNull(cacheResponse);
+    assertNull(cacheResponse.body());
+    return new RecordedResponse(cacheResponse.request(), cacheResponse, null, null, null);
+  }
+
+  public RecordedResponse assertFailure(Class<?>... allowedExceptionTypes) {
+    boolean found = false;
+    for (Class expectedClass : allowedExceptionTypes) {
+      if (expectedClass.isInstance(failure)) {
+        found = true;
+        break;
+      }
+    }
+    assertTrue("Expected exception type among " + Arrays.toString(allowedExceptionTypes)
+            + ", got " + failure, found);
+    return this;
+  }
+
+  public RecordedResponse assertFailure(String... messages) {
+    assertNotNull("No failure found", failure);
+    assertTrue(failure.getMessage(), Arrays.asList(messages).contains(failure.getMessage()));
+    return this;
+  }
+
+  public RecordedResponse assertFailureMatches(String... patterns) {
+    assertNotNull(failure);
+    for (String pattern : patterns) {
+      if (failure.getMessage().matches(pattern)) return this;
+    }
+    throw new AssertionError(failure.getMessage());
+  }
+
+  public RecordedResponse assertSentRequestAtMillis(long minimum, long maximum) {
+    assertDateInRange(minimum, response.sentRequestAtMillis(), maximum);
+    return this;
+  }
+
+  public RecordedResponse assertReceivedResponseAtMillis(long minimum, long maximum) {
+    assertDateInRange(minimum, response.receivedResponseAtMillis(), maximum);
+    return this;
+  }
+
+  private void assertDateInRange(long minimum, long actual, long maximum) {
+    assertTrue("actual " + format(actual) + " < minimum " + format(maximum), actual >= minimum);
+    assertTrue("actual " + format(actual) + " > maximum " + format(minimum), actual <= maximum);
+  }
+
+  private String format(long time) {
+    return new SimpleDateFormat("HH:mm:ss.SSS").format(new Date(time));
+  }
+
+  public String getBody() {
+    return body;
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/RecordingCallback.java b/okhttp-tests/src/test/java/okhttp3/RecordingCallback.java
new file mode 100644
index 0000000000..56a1d7e003
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/RecordingCallback.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Records received HTTP responses so they can be later retrieved by tests.
+ */
+public class RecordingCallback implements Callback {
+  public static final long TIMEOUT_MILLIS = TimeUnit.SECONDS.toMillis(10);
+
+  private final List<RecordedResponse> responses = new ArrayList<>();
+
+  @Override public synchronized void onFailure(Call call, IOException e) {
+    responses.add(new RecordedResponse(call.request(), null, null, null, e));
+    notifyAll();
+  }
+
+  @Override public synchronized void onResponse(Call call, Response response) throws IOException {
+    String body = response.body().string();
+    responses.add(new RecordedResponse(call.request(), response, null, body, null));
+    notifyAll();
+  }
+
+  /**
+   * Returns the recorded response triggered by {@code request}. Throws if the response isn't
+   * enqueued before the timeout.
+   */
+  public synchronized RecordedResponse await(HttpUrl url) throws Exception {
+    long timeoutMillis = TimeUnit.NANOSECONDS.toMillis(System.nanoTime()) + TIMEOUT_MILLIS;
+    while (true) {
+      for (Iterator<RecordedResponse> i = responses.iterator(); i.hasNext(); ) {
+        RecordedResponse recordedResponse = i.next();
+        if (recordedResponse.request.url().equals(url)) {
+          i.remove();
+          return recordedResponse;
+        }
+      }
+
+      long nowMillis = TimeUnit.NANOSECONDS.toMillis(System.nanoTime());
+      if (nowMillis >= timeoutMillis) break;
+      wait(timeoutMillis - nowMillis);
+    }
+
+    throw new AssertionError("Timed out waiting for response to " + url);
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/RecordingEventListener.java b/okhttp-tests/src/test/java/okhttp3/RecordingEventListener.java
new file mode 100644
index 0000000000..c945b7addd
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/RecordingEventListener.java
@@ -0,0 +1,414 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Deque;
+import java.util.List;
+import javax.annotation.Nullable;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public final class RecordingEventListener extends EventListener {
+  final Deque<CallEvent> eventSequence = new ArrayDeque<>();
+
+  final List<Object> forbiddenLocks = new ArrayList<>();
+
+  /** Confirm that the thread does not hold a lock on {@code lock} during the callback. */
+  public void forbidLock(Object lock) {
+    forbiddenLocks.add(lock);
+  }
+
+  /**
+   * Removes recorded events up to (and including) an event is found whose class equals
+   * {@code eventClass} and returns it.
+   */
+  public <T> T removeUpToEvent(Class<T> eventClass) {
+    Object event = eventSequence.poll();
+    while (event != null && !eventClass.isInstance(event)) {
+      event = eventSequence.poll();
+    }
+    if (event == null) throw new AssertionError();
+    return eventClass.cast(event);
+  }
+
+  public List<String> recordedEventTypes() {
+    List<String> eventTypes = new ArrayList<>();
+    for (CallEvent event : eventSequence) {
+      eventTypes.add(event.getName());
+    }
+    return eventTypes;
+  }
+
+  public void clearAllEvents() {
+    eventSequence.clear();
+  }
+
+  private void logEvent(CallEvent e) {
+    for (Object lock : forbiddenLocks) {
+      assertFalse(lock.toString(), Thread.holdsLock(lock));
+    }
+
+    CallEvent startEvent = e.closes();
+
+    if (startEvent != null) {
+      assertTrue(e.getName() + " without matching " + startEvent.getName(),
+          eventSequence.contains(startEvent));
+    }
+
+    eventSequence.offer(e);
+  }
+
+  @Override public void dnsStart(Call call, String domainName) {
+    logEvent(new DnsStart(call, domainName));
+  }
+
+  @Override public void dnsEnd(Call call, String domainName, List<InetAddress> inetAddressList) {
+    logEvent(new DnsEnd(call, domainName, inetAddressList));
+  }
+
+  @Override public void connectStart(Call call, InetSocketAddress inetSocketAddress,
+      Proxy proxy) {
+    logEvent(new ConnectStart(call, inetSocketAddress, proxy));
+  }
+
+  @Override public void secureConnectStart(Call call) {
+    logEvent(new SecureConnectStart(call));
+  }
+
+  @Override public void secureConnectEnd(Call call, Handshake handshake) {
+    logEvent(new SecureConnectEnd(call, handshake));
+  }
+
+  @Override public void connectEnd(Call call, InetSocketAddress inetSocketAddress,
+      @Nullable Proxy proxy, Protocol protocol) {
+    logEvent(new ConnectEnd(call, inetSocketAddress, proxy, protocol));
+  }
+
+  @Override public void connectFailed(Call call, InetSocketAddress inetSocketAddress,
+      @Nullable Proxy proxy, @Nullable Protocol protocol, @Nullable IOException ioe) {
+    logEvent(new ConnectFailed(call, inetSocketAddress, proxy, protocol, ioe));
+  }
+
+  @Override public void connectionAcquired(Call call, Connection connection) {
+    logEvent(new ConnectionAcquired(call, connection));
+  }
+
+  @Override public void connectionReleased(Call call, Connection connection) {
+    logEvent(new ConnectionReleased(call, connection));
+  }
+
+  @Override public void callStart(Call call) {
+    logEvent(new CallStart(call));
+  }
+
+  @Override public void requestHeadersStart(Call call) {
+    logEvent(new RequestHeadersStart(call));
+  }
+
+  @Override public void requestHeadersEnd(Call call, Request request) {
+    logEvent(new RequestHeadersEnd(call, request.headers.byteCount()));
+  }
+
+  @Override public void requestBodyStart(Call call) {
+    logEvent(new RequestBodyStart(call));
+  }
+
+  @Override public void requestBodyEnd(Call call, long byteCount) {
+    logEvent(new RequestBodyEnd(call, byteCount));
+  }
+
+  @Override public void responseHeadersStart(Call call) {
+    logEvent(new ResponseHeadersStart(call));
+  }
+
+  @Override public void responseHeadersEnd(Call call, Response response) {
+    logEvent(new ResponseHeadersEnd(call, response.headers.byteCount()));
+  }
+
+  @Override public void responseBodyStart(Call call) {
+    logEvent(new ResponseBodyStart(call));
+  }
+
+  @Override public void responseBodyEnd(Call call, long byteCount) {
+    logEvent(new ResponseBodyEnd(call, byteCount));
+  }
+
+  @Override public void callEnd(Call call) {
+    logEvent(new CallEnd(call));
+  }
+
+  @Override public void callFailed(Call call, IOException ioe) {
+    logEvent(new CallFailed(call, ioe));
+  }
+
+  static class CallEvent {
+    final Call call;
+    final List<Object> params;
+
+    CallEvent(Call call, Object... params) {
+      this.call = call;
+      this.params = Arrays.asList(params);
+    }
+
+    public String getName() {
+      return getClass().getSimpleName();
+    }
+
+    @Override public boolean equals(Object o) {
+      if (this == o) return true;
+      if (!(o instanceof CallEvent)) return false;
+
+      CallEvent callEvent = (CallEvent) o;
+
+      if (!getName().equals(callEvent.getName())) return false;
+      if (!call.equals(callEvent.call)) return false;
+      return params.equals(callEvent.params);
+    }
+
+    @Override public int hashCode() {
+      int result = call.hashCode();
+      result = 31 * result + getName().hashCode();
+      result = 31 * result + params.hashCode();
+      return result;
+    }
+
+    public @Nullable CallEvent closes() {
+      return null;
+    }
+  }
+
+  static final class DnsStart extends CallEvent {
+    final String domainName;
+
+    DnsStart(Call call, String domainName) {
+      super(call, domainName);
+      this.domainName = domainName;
+    }
+  }
+
+  static final class DnsEnd extends CallEvent {
+    final String domainName;
+    final List<InetAddress> inetAddressList;
+
+    DnsEnd(Call call, String domainName, List<InetAddress> inetAddressList) {
+      super(call, domainName, inetAddressList);
+      this.domainName = domainName;
+      this.inetAddressList = inetAddressList;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new DnsStart(call, domainName);
+    }
+  }
+
+  static final class ConnectStart extends CallEvent {
+    final InetSocketAddress inetSocketAddress;
+    final Proxy proxy;
+
+    ConnectStart(Call call, InetSocketAddress inetSocketAddress, Proxy proxy) {
+      super(call, inetSocketAddress, proxy);
+      this.inetSocketAddress = inetSocketAddress;
+      this.proxy = proxy;
+    }
+  }
+
+  static final class ConnectEnd extends CallEvent {
+    final InetSocketAddress inetSocketAddress;
+    final Protocol protocol;
+    final Proxy proxy;
+
+    ConnectEnd(Call call, InetSocketAddress inetSocketAddress, Proxy proxy, Protocol protocol) {
+      super(call, inetSocketAddress, proxy, protocol);
+      this.inetSocketAddress = inetSocketAddress;
+      this.proxy = proxy;
+      this.protocol = protocol;
+    }
+
+    @Override public CallEvent closes() {
+      return new ConnectStart(call, inetSocketAddress, proxy);
+    }
+  }
+
+  static final class ConnectFailed extends CallEvent {
+    final InetSocketAddress inetSocketAddress;
+    final Protocol protocol;
+    final Proxy proxy;
+    final IOException ioe;
+
+    ConnectFailed(Call call, InetSocketAddress inetSocketAddress, Proxy proxy, Protocol protocol,
+        IOException ioe) {
+      super(call, inetSocketAddress, proxy, protocol, ioe);
+      this.inetSocketAddress = inetSocketAddress;
+      this.proxy = proxy;
+      this.protocol = protocol;
+      this.ioe = ioe;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new ConnectStart(call, inetSocketAddress, proxy);
+    }
+  }
+
+  static final class SecureConnectStart extends CallEvent {
+    SecureConnectStart(Call call) {
+      super(call);
+    }
+  }
+
+  static final class SecureConnectEnd extends CallEvent {
+    final Handshake handshake;
+
+    SecureConnectEnd(Call call, Handshake handshake) {
+      super(call, handshake);
+      this.handshake = handshake;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new SecureConnectStart(call);
+    }
+  }
+
+  static final class ConnectionAcquired extends CallEvent {
+    final Connection connection;
+
+    ConnectionAcquired(Call call, Connection connection) {
+      super(call, connection);
+      this.connection = connection;
+    }
+  }
+
+  static final class ConnectionReleased extends CallEvent {
+    final Connection connection;
+
+    ConnectionReleased(Call call, Connection connection) {
+      super(call, connection);
+      this.connection = connection;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new ConnectionAcquired(call, connection);
+    }
+  }
+
+  static final class CallStart extends CallEvent {
+    CallStart(Call call) {
+      super(call);
+    }
+  }
+
+  static final class CallEnd extends CallEvent {
+    CallEnd(Call call) {
+      super(call);
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new CallStart(call);
+    }
+  }
+
+  static final class CallFailed extends CallEvent {
+    final IOException ioe;
+
+    CallFailed(Call call, IOException ioe) {
+      super(call, ioe);
+      this.ioe = ioe;
+    }
+  }
+
+  static final class RequestHeadersStart extends CallEvent {
+    RequestHeadersStart(Call call) {
+      super(call);
+    }
+  }
+
+  static final class RequestHeadersEnd extends CallEvent {
+    final long headerLength;
+
+    RequestHeadersEnd(Call call, long headerLength) {
+      super(call, headerLength);
+      this.headerLength = headerLength;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new RequestHeadersStart(call);
+    }
+  }
+
+  static final class RequestBodyStart extends CallEvent {
+    RequestBodyStart(Call call) {
+      super(call);
+    }
+  }
+
+  static final class RequestBodyEnd extends CallEvent {
+    final long bytesWritten;
+
+    RequestBodyEnd(Call call, long bytesWritten) {
+      super(call, bytesWritten);
+      this.bytesWritten = bytesWritten;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new RequestBodyStart(call);
+    }
+  }
+
+  static final class ResponseHeadersStart extends CallEvent {
+    ResponseHeadersStart(Call call) {
+      super(call);
+    }
+  }
+
+  static final class ResponseHeadersEnd extends CallEvent {
+    final long headerLength;
+
+    ResponseHeadersEnd(Call call, long headerLength) {
+      super(call, headerLength);
+      this.headerLength = headerLength;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new RequestHeadersStart(call);
+    }
+  }
+
+  static final class ResponseBodyStart extends CallEvent {
+    ResponseBodyStart(Call call) {
+      super(call);
+    }
+  }
+
+  static final class ResponseBodyEnd extends CallEvent {
+    final long bytesRead;
+
+    ResponseBodyEnd(Call call, long bytesRead) {
+      super(call, bytesRead);
+      this.bytesRead = bytesRead;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new ResponseBodyStart(call);
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/RequestTest.java b/okhttp-tests/src/test/java/okhttp3/RequestTest.java
new file mode 100644
index 0000000000..5c205d7031
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/RequestTest.java
@@ -0,0 +1,250 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.net.URI;
+import java.util.Arrays;
+import java.util.Collections;
+import okhttp3.internal.Util;
+import okio.Buffer;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.fail;
+
+public final class RequestTest {
+  @Test public void string() throws Exception {
+    MediaType contentType = MediaType.parse("text/plain; charset=utf-8");
+    RequestBody body = RequestBody.create(contentType, "abc".getBytes(Util.UTF_8));
+    assertEquals(contentType, body.contentType());
+    assertEquals(3, body.contentLength());
+    assertEquals("616263", bodyToHex(body));
+    assertEquals("Retransmit body", "616263", bodyToHex(body));
+  }
+
+  @Test public void stringWithDefaultCharsetAdded() throws Exception {
+    MediaType contentType = MediaType.parse("text/plain");
+    RequestBody body = RequestBody.create(contentType, "\u0800");
+    assertEquals(MediaType.parse("text/plain; charset=utf-8"), body.contentType());
+    assertEquals(3, body.contentLength());
+    assertEquals("e0a080", bodyToHex(body));
+  }
+
+  @Test public void stringWithNonDefaultCharsetSpecified() throws Exception {
+    MediaType contentType = MediaType.parse("text/plain; charset=utf-16be");
+    RequestBody body = RequestBody.create(contentType, "\u0800");
+    assertEquals(contentType, body.contentType());
+    assertEquals(2, body.contentLength());
+    assertEquals("0800", bodyToHex(body));
+  }
+
+  @Test public void byteArray() throws Exception {
+    MediaType contentType = MediaType.parse("text/plain");
+    RequestBody body = RequestBody.create(contentType, "abc".getBytes(Util.UTF_8));
+    assertEquals(contentType, body.contentType());
+    assertEquals(3, body.contentLength());
+    assertEquals("616263", bodyToHex(body));
+    assertEquals("Retransmit body", "616263", bodyToHex(body));
+  }
+
+  @Test public void byteArrayRange() throws Exception {
+    MediaType contentType = MediaType.parse("text/plain");
+    RequestBody body = RequestBody.create(contentType, ".abcd".getBytes(Util.UTF_8), 1, 3);
+    assertEquals(contentType, body.contentType());
+    assertEquals(3, body.contentLength());
+    assertEquals("616263", bodyToHex(body));
+    assertEquals("Retransmit body", "616263", bodyToHex(body));
+  }
+
+  @Test public void file() throws Exception {
+    File file = File.createTempFile("RequestTest", "tmp");
+    FileWriter writer = new FileWriter(file);
+    writer.write("abc");
+    writer.close();
+
+    MediaType contentType = MediaType.parse("text/plain");
+    RequestBody body = RequestBody.create(contentType, file);
+    assertEquals(contentType, body.contentType());
+    assertEquals(3, body.contentLength());
+    assertEquals("616263", bodyToHex(body));
+    assertEquals("Retransmit body", "616263", bodyToHex(body));
+  }
+
+  /** Common verbs used for apis such as GitHub, AWS, and Google Cloud. */
+  @Test public void crudVerbs() throws IOException {
+    MediaType contentType = MediaType.parse("application/json");
+    RequestBody body = RequestBody.create(contentType, "{}");
+
+    Request get = new Request.Builder().url("http://localhost/api").get().build();
+    assertEquals("GET", get.method());
+    assertNull(get.body());
+
+    Request head = new Request.Builder().url("http://localhost/api").head().build();
+    assertEquals("HEAD", head.method());
+    assertNull(head.body());
+
+    Request delete = new Request.Builder().url("http://localhost/api").delete().build();
+    assertEquals("DELETE", delete.method());
+    assertEquals(0L, delete.body().contentLength());
+
+    Request post = new Request.Builder().url("http://localhost/api").post(body).build();
+    assertEquals("POST", post.method());
+    assertEquals(body, post.body());
+
+    Request put = new Request.Builder().url("http://localhost/api").put(body).build();
+    assertEquals("PUT", put.method());
+    assertEquals(body, put.body());
+
+    Request patch = new Request.Builder().url("http://localhost/api").patch(body).build();
+    assertEquals("PATCH", patch.method());
+    assertEquals(body, patch.body());
+  }
+
+  @Test public void uninitializedURI() throws Exception {
+    Request request = new Request.Builder().url("http://localhost/api").build();
+    assertEquals(new URI("http://localhost/api"), request.url().uri());
+    assertEquals(HttpUrl.parse("http://localhost/api"), request.url());
+  }
+
+  @Test public void newBuilderUrlResetsUrl() throws Exception {
+    Request requestWithoutCache = new Request.Builder().url("http://localhost/api").build();
+    Request builtRequestWithoutCache =
+        requestWithoutCache.newBuilder().url("http://localhost/api/foo").build();
+    assertEquals(HttpUrl.parse("http://localhost/api/foo"), builtRequestWithoutCache.url());
+
+    Request requestWithCache = new Request.Builder().url("http://localhost/api").build();
+    // cache url object
+    requestWithCache.url();
+    Request builtRequestWithCache = requestWithCache.newBuilder().url(
+        "http://localhost/api/foo").build();
+    assertEquals(HttpUrl.parse("http://localhost/api/foo"), builtRequestWithCache.url());
+  }
+
+  @Test public void cacheControl() throws Exception {
+    Request request = new Request.Builder()
+        .cacheControl(new CacheControl.Builder().noCache().build())
+        .url("https://square.com")
+        .build();
+    assertEquals(Arrays.asList("no-cache"), request.headers("Cache-Control"));
+  }
+
+  @Test public void emptyCacheControlClearsAllCacheControlHeaders() throws Exception {
+    Request request = new Request.Builder()
+        .header("Cache-Control", "foo")
+        .cacheControl(new CacheControl.Builder().build())
+        .url("https://square.com")
+        .build();
+    assertEquals(Collections.<String>emptyList(), request.headers("Cache-Control"));
+  }
+
+  @Test public void headerAcceptsPermittedCharacters() throws Exception {
+    Request.Builder builder = new Request.Builder();
+    builder.header("AZab09~", "AZab09 ~");
+    builder.addHeader("AZab09~", "AZab09 ~");
+  }
+
+  @Test public void emptyNameForbidden() throws Exception {
+    Request.Builder builder = new Request.Builder();
+    try {
+      builder.header("", "Value");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      builder.addHeader("", "Value");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void headerForbidsNullArguments() throws Exception {
+    Request.Builder builder = new Request.Builder();
+    try {
+      builder.header(null, "Value");
+      fail();
+    } catch (NullPointerException expected) {
+    }
+    try {
+      builder.addHeader(null, "Value");
+      fail();
+    } catch (NullPointerException expected) {
+    }
+    try {
+      builder.header("Name", null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+    try {
+      builder.addHeader("Name", null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+  }
+
+  @Test public void headerAllowsTabOnlyInValues() throws Exception {
+    Request.Builder builder = new Request.Builder();
+    builder.header("key", "sample\tvalue");
+    try {
+      builder.header("sample\tkey", "value");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void headerForbidsControlCharacters() throws Exception {
+    assertForbiddenHeader("\u0000");
+    assertForbiddenHeader("\r");
+    assertForbiddenHeader("\n");
+    assertForbiddenHeader("\u001f");
+    assertForbiddenHeader("\u007f");
+    assertForbiddenHeader("\u0080");
+    assertForbiddenHeader("\ud83c\udf69");
+  }
+
+  private void assertForbiddenHeader(String s) {
+    Request.Builder builder = new Request.Builder();
+    try {
+      builder.header(s, "Value");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      builder.addHeader(s, "Value");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      builder.header("Name", s);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      builder.addHeader("Name", s);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  private String bodyToHex(RequestBody body) throws IOException {
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    return buffer.readByteString().hex();
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java b/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java
new file mode 100644
index 0000000000..47feecacb6
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java
@@ -0,0 +1,412 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.Reader;
+import java.util.concurrent.atomic.AtomicBoolean;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.ForwardingSource;
+import okio.Okio;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class ResponseBodyTest {
+  @Test public void stringEmpty() throws IOException {
+    ResponseBody body = body("");
+    assertEquals("", body.string());
+  }
+
+  @Test public void stringLooksLikeBomButTooShort() throws IOException {
+    ResponseBody body = body("000048");
+    assertEquals("\0\0H", body.string());
+  }
+
+  @Test public void stringDefaultsToUtf8() throws IOException {
+    ResponseBody body = body("68656c6c6f");
+    assertEquals("hello", body.string());
+  }
+
+  @Test public void stringExplicitCharset() throws IOException {
+    ResponseBody body = body("00000068000000650000006c0000006c0000006f", "utf-32be");
+    assertEquals("hello", body.string());
+  }
+
+  @Test public void stringBomOverridesExplicitCharset() throws IOException {
+    ResponseBody body = body("0000ffff00000068000000650000006c0000006c0000006f", "utf-8");
+    assertEquals("hello", body.string());
+  }
+
+  @Test public void stringBomUtf8() throws IOException {
+    ResponseBody body = body("efbbbf68656c6c6f");
+    assertEquals("hello", body.string());
+  }
+
+  @Test public void stringBomUtf16Be() throws IOException {
+    ResponseBody body = body("feff00680065006c006c006f");
+    assertEquals("hello", body.string());
+  }
+
+  @Test public void stringBomUtf16Le() throws IOException {
+    ResponseBody body = body("fffe680065006c006c006f00");
+    assertEquals("hello", body.string());
+  }
+
+  @Test public void stringBomUtf32Be() throws IOException {
+    ResponseBody body = body("0000ffff00000068000000650000006c0000006c0000006f");
+    assertEquals("hello", body.string());
+  }
+
+  @Test public void stringBomUtf32Le() throws IOException {
+    ResponseBody body = body("ffff000068000000650000006c0000006c0000006f000000");
+    assertEquals("hello", body.string());
+  }
+
+  @Test public void stringClosesUnderlyingSource() throws IOException {
+    final AtomicBoolean closed = new AtomicBoolean();
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return 5;
+      }
+
+      @Override public BufferedSource source() {
+        Buffer source = new Buffer().writeUtf8("hello");
+        return Okio.buffer(new ForwardingSource(source) {
+          @Override public void close() throws IOException {
+            closed.set(true);
+            super.close();
+          }
+        });
+      }
+    };
+    assertEquals("hello", body.string());
+    assertTrue(closed.get());
+  }
+
+  @Test public void readerEmpty() throws IOException {
+    ResponseBody body = body("");
+    assertEquals("", exhaust(body.charStream()));
+  }
+
+  @Test public void readerLooksLikeBomButTooShort() throws IOException {
+    ResponseBody body = body("000048");
+    assertEquals("\0\0H", exhaust(body.charStream()));
+  }
+
+  @Test public void readerDefaultsToUtf8() throws IOException {
+    ResponseBody body = body("68656c6c6f");
+    assertEquals("hello", exhaust(body.charStream()));
+  }
+
+  @Test public void readerExplicitCharset() throws IOException {
+    ResponseBody body = body("00000068000000650000006c0000006c0000006f", "utf-32be");
+    assertEquals("hello", exhaust(body.charStream()));
+  }
+
+  @Test public void readerBomUtf8() throws IOException {
+    ResponseBody body = body("efbbbf68656c6c6f");
+    assertEquals("hello", exhaust(body.charStream()));
+  }
+
+  @Test public void readerBomUtf16Be() throws IOException {
+    ResponseBody body = body("feff00680065006c006c006f");
+    assertEquals("hello", exhaust(body.charStream()));
+  }
+
+  @Test public void readerBomUtf16Le() throws IOException {
+    ResponseBody body = body("fffe680065006c006c006f00");
+    assertEquals("hello", exhaust(body.charStream()));
+  }
+
+  @Test public void readerBomUtf32Be() throws IOException {
+    ResponseBody body = body("0000ffff00000068000000650000006c0000006c0000006f");
+    assertEquals("hello", exhaust(body.charStream()));
+  }
+
+  @Test public void readerBomUtf32Le() throws IOException {
+    ResponseBody body = body("ffff000068000000650000006c0000006c0000006f000000");
+    assertEquals("hello", exhaust(body.charStream()));
+  }
+
+  @Test public void readerClosedBeforeBomClosesUnderlyingSource() throws IOException {
+    final AtomicBoolean closed = new AtomicBoolean();
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return 5;
+      }
+
+      @Override public BufferedSource source() {
+        ResponseBody body = body("fffe680065006c006c006f00");
+        return Okio.buffer(new ForwardingSource(body.source()) {
+          @Override public void close() throws IOException {
+            closed.set(true);
+            super.close();
+          }
+        });
+      }
+    };
+    body.charStream().close();
+    assertTrue(closed.get());
+  }
+
+  @Test public void readerClosedAfterBomClosesUnderlyingSource() throws IOException {
+    final AtomicBoolean closed = new AtomicBoolean();
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return 5;
+      }
+
+      @Override public BufferedSource source() {
+        ResponseBody body = body("fffe680065006c006c006f00");
+        return Okio.buffer(new ForwardingSource(body.source()) {
+          @Override public void close() throws IOException {
+            closed.set(true);
+            super.close();
+          }
+        });
+      }
+    };
+    Reader reader = body.charStream();
+    assertEquals('h', reader.read());
+    reader.close();
+    assertTrue(closed.get());
+  }
+
+  @Test public void sourceEmpty() throws IOException {
+    ResponseBody body = body("");
+    BufferedSource source = body.source();
+    assertTrue(source.exhausted());
+    assertEquals("", source.readUtf8());
+  }
+
+  @Test public void sourceSeesBom() throws IOException {
+    ResponseBody body = body("efbbbf68656c6c6f");
+    BufferedSource source = body.source();
+    assertEquals(0xef, source.readByte() & 0xff);
+    assertEquals(0xbb, source.readByte() & 0xff);
+    assertEquals(0xbf, source.readByte() & 0xff);
+    assertEquals("hello", source.readUtf8());
+  }
+
+  @Test public void sourceClosesUnderlyingSource() throws IOException {
+    final AtomicBoolean closed = new AtomicBoolean();
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return 5;
+      }
+
+      @Override public BufferedSource source() {
+        Buffer source = new Buffer().writeUtf8("hello");
+        return Okio.buffer(new ForwardingSource(source) {
+          @Override public void close() throws IOException {
+            closed.set(true);
+            super.close();
+          }
+        });
+      }
+    };
+    body.source().close();
+    assertTrue(closed.get());
+  }
+
+  @Test public void bytesEmpty() throws IOException {
+    ResponseBody body = body("");
+    assertEquals(0, body.bytes().length);
+  }
+
+  @Test public void bytesSeesBom() throws IOException {
+    ResponseBody body = body("efbbbf68656c6c6f");
+    byte[] bytes = body.bytes();
+    assertEquals(0xef, bytes[0] & 0xff);
+    assertEquals(0xbb, bytes[1] & 0xff);
+    assertEquals(0xbf, bytes[2] & 0xff);
+    assertEquals("hello", new String(bytes, 3, 5, "UTF-8"));
+  }
+
+  @Test public void bytesClosesUnderlyingSource() throws IOException {
+    final AtomicBoolean closed = new AtomicBoolean();
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return 5;
+      }
+
+      @Override public BufferedSource source() {
+        Buffer source = new Buffer().writeUtf8("hello");
+        return Okio.buffer(new ForwardingSource(source) {
+          @Override public void close() throws IOException {
+            closed.set(true);
+            super.close();
+          }
+        });
+      }
+    };
+    assertEquals(5, body.bytes().length);
+    assertTrue(closed.get());
+  }
+
+  @Test public void bytesThrowsWhenLengthsDisagree() {
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return 10;
+      }
+
+      @Override public BufferedSource source() {
+        return new Buffer().writeUtf8("hello");
+      }
+    };
+    try {
+      body.bytes();
+      fail();
+    } catch (IOException e) {
+      assertEquals("Content-Length (10) and stream length (5) disagree", e.getMessage());
+    }
+  }
+
+  @Test public void bytesThrowsMoreThanIntMaxValue() {
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return Integer.MAX_VALUE + 1L;
+      }
+
+      @Override public BufferedSource source() {
+        throw new AssertionError();
+      }
+    };
+    try {
+      body.bytes();
+      fail();
+    } catch (IOException e) {
+      assertEquals("Cannot buffer entire body for content length: 2147483648", e.getMessage());
+    }
+  }
+
+  @Test public void byteStreamEmpty() throws IOException {
+    ResponseBody body = body("");
+    InputStream bytes = body.byteStream();
+    assertEquals(-1, bytes.read());
+  }
+
+  @Test public void byteStreamSeesBom() throws IOException {
+    ResponseBody body = body("efbbbf68656c6c6f");
+    InputStream bytes = body.byteStream();
+    assertEquals(0xef, bytes.read());
+    assertEquals(0xbb, bytes.read());
+    assertEquals(0xbf, bytes.read());
+    assertEquals("hello", exhaust(new InputStreamReader(bytes, "utf-8")));
+  }
+
+  @Test public void byteStreamClosesUnderlyingSource() throws IOException {
+    final AtomicBoolean closed = new AtomicBoolean();
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return 5;
+      }
+
+      @Override public BufferedSource source() {
+        Buffer source = new Buffer().writeUtf8("hello");
+        return Okio.buffer(new ForwardingSource(source) {
+          @Override public void close() throws IOException {
+            closed.set(true);
+            super.close();
+          }
+        });
+      }
+    };
+    body.byteStream().close();
+    assertTrue(closed.get());
+  }
+
+  @Test public void throwingUnderlyingSourceClosesQuietly() throws IOException {
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return 5;
+      }
+
+      @Override public BufferedSource source() {
+        Buffer source = new Buffer().writeUtf8("hello");
+        return Okio.buffer(new ForwardingSource(source) {
+          @Override public void close() throws IOException {
+            throw new IOException("Broken!");
+          }
+        });
+      }
+    };
+    assertEquals("hello", body.source().readUtf8());
+    body.close();
+  }
+
+  static ResponseBody body(String hex) {
+    return body(hex, null);
+  }
+
+  static ResponseBody body(String hex, String charset) {
+    MediaType mediaType = charset == null ? null : MediaType.parse("any/thing; charset=" + charset);
+    return ResponseBody.create(mediaType, ByteString.decodeHex(hex).toByteArray());
+  }
+
+  static String exhaust(Reader reader) throws IOException {
+    StringBuilder builder = new StringBuilder();
+    char[] buf = new char[10];
+    int read;
+    while ((read = reader.read(buf)) != -1) {
+      builder.append(buf, 0, read);
+    }
+    return builder.toString();
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/ResponseTest.java b/okhttp-tests/src/test/java/okhttp3/ResponseTest.java
new file mode 100644
index 0000000000..5d77a02a26
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/ResponseTest.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.Okio;
+import okio.Source;
+import okio.Timeout;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class ResponseTest {
+  @Test public void peekShorterThanResponse() throws Exception {
+    Response response = newResponse(responseBody("abcdef"));
+    ResponseBody peekedBody = response.peekBody(3);
+    assertEquals("abc", peekedBody.string());
+    assertEquals("abcdef", response.body().string());
+  }
+
+  @Test public void peekLongerThanResponse() throws Exception {
+    Response response = newResponse(responseBody("abc"));
+    ResponseBody peekedBody = response.peekBody(6);
+    assertEquals("abc", peekedBody.string());
+    assertEquals("abc", response.body().string());
+  }
+
+  @Test public void peekAfterReadingResponse() throws Exception {
+    Response response = newResponse(responseBody("abc"));
+    assertEquals("abc", response.body().string());
+
+    try {
+      response.peekBody(3);
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  @Test public void eachPeakIsIndependent() throws Exception {
+    Response response = newResponse(responseBody("abcdef"));
+    ResponseBody p1 = response.peekBody(4);
+    ResponseBody p2 = response.peekBody(2);
+    assertEquals("abcdef", response.body().string());
+    assertEquals("abcd", p1.string());
+    assertEquals("ab", p2.string());
+  }
+
+  /**
+   * Returns a new response body that refuses to be read once it has been closed. This is true of
+   * most {@link BufferedSource} instances, but not of {@link Buffer}.
+   */
+  private ResponseBody responseBody(String content) {
+    final Buffer data = new Buffer().writeUtf8(content);
+
+    Source source = new Source() {
+      boolean closed;
+
+      @Override public void close() throws IOException {
+        closed = true;
+      }
+
+      @Override public long read(Buffer sink, long byteCount) throws IOException {
+        if (closed) throw new IllegalStateException();
+        return data.read(sink, byteCount);
+      }
+
+      @Override public Timeout timeout() {
+        return Timeout.NONE;
+      }
+    };
+
+    return ResponseBody.create(null, -1, Okio.buffer(source));
+  }
+
+  private Response newResponse(ResponseBody responseBody) {
+    return new Response.Builder()
+        .request(new Request.Builder()
+            .url("https://example.com/")
+            .build())
+        .protocol(Protocol.HTTP_1_1)
+        .code(200)
+        .message("OK")
+        .body(responseBody)
+        .build();
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/SocksProxy.java b/okhttp-tests/src/test/java/okhttp3/SocksProxy.java
new file mode 100644
index 0000000000..d56241ac91
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/SocksProxy.java
@@ -0,0 +1,248 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.ProtocolException;
+import java.net.Proxy;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.net.SocketException;
+import java.util.Collections;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import okhttp3.internal.NamedRunnable;
+import okhttp3.internal.Util;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.Okio;
+
+/**
+ * A limited implementation of SOCKS Protocol Version 5, intended to be similar to MockWebServer.
+ * See <a href="https://www.ietf.org/rfc/rfc1928.txt">RFC 1928</a>.
+ */
+public final class SocksProxy {
+  public static final String HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS = "onlyProxyCanResolveMe.org";
+
+  private static final int VERSION_5 = 5;
+  private static final int METHOD_NONE = 0xff;
+  private static final int METHOD_NO_AUTHENTICATION_REQUIRED = 0;
+  private static final int ADDRESS_TYPE_IPV4 = 1;
+  private static final int ADDRESS_TYPE_DOMAIN_NAME = 3;
+  private static final int COMMAND_CONNECT = 1;
+  private static final int REPLY_SUCCEEDED = 0;
+
+  private static final Logger logger = Logger.getLogger(SocksProxy.class.getName());
+
+  private final ExecutorService executor = Executors.newCachedThreadPool(
+      Util.threadFactory("SocksProxy", false));
+
+  private ServerSocket serverSocket;
+  private AtomicInteger connectionCount = new AtomicInteger();
+  private final Set<Socket> openSockets =
+      Collections.newSetFromMap(new ConcurrentHashMap<Socket, Boolean>());
+
+  public void play() throws IOException {
+    serverSocket = new ServerSocket(0);
+    executor.execute(new NamedRunnable("SocksProxy %s", serverSocket.getLocalPort()) {
+      @Override protected void execute() {
+        try {
+          while (true) {
+            Socket socket = serverSocket.accept();
+            connectionCount.incrementAndGet();
+            service(socket);
+          }
+        } catch (SocketException e) {
+          logger.info(name + " done accepting connections: " + e.getMessage());
+        } catch (IOException e) {
+          logger.log(Level.WARNING, name + " failed unexpectedly", e);
+        } finally {
+          for (Socket socket : openSockets) {
+            Util.closeQuietly(socket);
+          }
+        }
+      }
+    });
+  }
+
+  public Proxy proxy() {
+    return new Proxy(Proxy.Type.SOCKS, InetSocketAddress.createUnresolved(
+        "localhost", serverSocket.getLocalPort()));
+  }
+
+  public int connectionCount() {
+    return connectionCount.get();
+  }
+
+  public void shutdown() throws Exception {
+    serverSocket.close();
+    executor.shutdown();
+    if (!executor.awaitTermination(5, TimeUnit.SECONDS)) {
+      throw new IOException("Gave up waiting for executor to shut down");
+    }
+  }
+
+  private void service(final Socket from) {
+    executor.execute(new NamedRunnable("SocksProxy %s", from.getRemoteSocketAddress()) {
+      @Override protected void execute() {
+        try {
+          BufferedSource fromSource = Okio.buffer(Okio.source(from));
+          BufferedSink fromSink = Okio.buffer(Okio.sink(from));
+          hello(fromSource, fromSink);
+          acceptCommand(from.getInetAddress(), fromSource, fromSink);
+          openSockets.add(from);
+        } catch (IOException e) {
+          logger.log(Level.WARNING, name + " failed", e);
+          Util.closeQuietly(from);
+        }
+      }
+    });
+  }
+
+  private void hello(BufferedSource fromSource, BufferedSink fromSink) throws IOException {
+    int version = fromSource.readByte() & 0xff;
+    int methodCount = fromSource.readByte() & 0xff;
+    int selectedMethod = METHOD_NONE;
+
+    if (version != VERSION_5) {
+      throw new ProtocolException("unsupported version: " + version);
+    }
+
+    for (int i = 0; i < methodCount; i++) {
+      int candidateMethod = fromSource.readByte() & 0xff;
+      if (candidateMethod == METHOD_NO_AUTHENTICATION_REQUIRED) {
+        selectedMethod = candidateMethod;
+      }
+    }
+
+    switch (selectedMethod) {
+      case METHOD_NO_AUTHENTICATION_REQUIRED:
+        fromSink.writeByte(VERSION_5);
+        fromSink.writeByte(selectedMethod);
+        fromSink.emit();
+        break;
+
+      default:
+        throw new ProtocolException("unsupported method: " + selectedMethod);
+    }
+  }
+
+  private void acceptCommand(InetAddress fromAddress, BufferedSource fromSource,
+      BufferedSink fromSink) throws IOException {
+    // Read the command.
+    int version = fromSource.readByte() & 0xff;
+    if (version != VERSION_5) throw new ProtocolException("unexpected version: " + version);
+    int command = fromSource.readByte() & 0xff;
+    int reserved = fromSource.readByte() & 0xff;
+    if (reserved != 0) throw new ProtocolException("unexpected reserved: " + reserved);
+
+    int addressType = fromSource.readByte() & 0xff;
+    InetAddress toAddress;
+    switch (addressType) {
+      case ADDRESS_TYPE_IPV4:
+        toAddress = InetAddress.getByAddress(fromSource.readByteArray(4L));
+        break;
+
+      case ADDRESS_TYPE_DOMAIN_NAME:
+        int domainNameLength = fromSource.readByte() & 0xff;
+        String domainName = fromSource.readUtf8(domainNameLength);
+        // Resolve HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS to localhost.
+        toAddress = domainName.equalsIgnoreCase(HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS)
+            ? InetAddress.getByName("localhost")
+            : InetAddress.getByName(domainName);
+        break;
+
+      default:
+        throw new ProtocolException("unsupported address type: " + addressType);
+    }
+
+    int port = fromSource.readShort() & 0xffff;
+
+    switch (command) {
+      case COMMAND_CONNECT:
+        Socket toSocket = new Socket(toAddress, port);
+        byte[] localAddress = toSocket.getLocalAddress().getAddress();
+        if (localAddress.length != 4) {
+          throw new ProtocolException("unexpected address: " + toSocket.getLocalAddress());
+        }
+
+        // Write the reply.
+        fromSink.writeByte(VERSION_5);
+        fromSink.writeByte(REPLY_SUCCEEDED);
+        fromSink.writeByte(0);
+        fromSink.writeByte(ADDRESS_TYPE_IPV4);
+        fromSink.write(localAddress);
+        fromSink.writeShort(toSocket.getLocalPort());
+        fromSink.emit();
+
+        logger.log(Level.INFO, "SocksProxy connected " + fromAddress + " to " + toAddress);
+
+        // Copy sources to sinks in both directions.
+        BufferedSource toSource = Okio.buffer(Okio.source(toSocket));
+        BufferedSink toSink = Okio.buffer(Okio.sink(toSocket));
+        openSockets.add(toSocket);
+
+        transfer(fromAddress, toAddress, fromSource, toSink);
+        transfer(fromAddress, toAddress, toSource, fromSink);
+        break;
+
+      default:
+        throw new ProtocolException("unexpected command: " + command);
+    }
+  }
+
+  private void transfer(final InetAddress fromAddress, final InetAddress toAddress,
+      final BufferedSource source, final BufferedSink sink) {
+    executor.execute(new NamedRunnable("SocksProxy %s to %s", fromAddress, toAddress) {
+      @Override protected void execute() {
+        Buffer buffer = new Buffer();
+        try {
+          while (true) {
+            long byteCount = source.read(buffer, 8192L);
+            if (byteCount == -1L) break;
+            sink.write(buffer, byteCount);
+            sink.emit();
+          }
+        } catch (SocketException e) {
+          logger.info(name + " done: " + e.getMessage());
+        } catch (IOException e) {
+          logger.log(Level.WARNING, name + " failed", e);
+        }
+
+        try {
+          source.close();
+        } catch (IOException e) {
+          logger.log(Level.WARNING, name + " failed", e);
+        }
+
+        try {
+          sink.close();
+        } catch (IOException e) {
+          logger.log(Level.WARNING, name + " failed", e);
+        }
+      }
+    });
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/SocksProxyTest.java b/okhttp-tests/src/test/java/okhttp3/SocksProxyTest.java
new file mode 100644
index 0000000000..83a6617b90
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/SocksProxyTest.java
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.Proxy;
+import java.net.ProxySelector;
+import java.net.SocketAddress;
+import java.net.URI;
+import java.util.Collections;
+import java.util.List;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static okhttp3.TestUtil.defaultClient;
+import static org.junit.Assert.assertEquals;
+
+public final class SocksProxyTest {
+  private final SocksProxy socksProxy = new SocksProxy();
+  private final MockWebServer server = new MockWebServer();
+
+  @Before public void setUp() throws Exception {
+    server.start();
+    socksProxy.play();
+  }
+
+  @After public void tearDown() throws Exception {
+    server.shutdown();
+    socksProxy.shutdown();
+  }
+
+  @Test public void proxy() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+
+    OkHttpClient client = defaultClient().newBuilder()
+        .proxy(socksProxy.proxy())
+        .build();
+
+    Request request1 = new Request.Builder().url(server.url("/")).build();
+    Response response1 = client.newCall(request1).execute();
+    assertEquals("abc", response1.body().string());
+
+    Request request2 = new Request.Builder().url(server.url("/")).build();
+    Response response2 = client.newCall(request2).execute();
+    assertEquals("def", response2.body().string());
+
+    // The HTTP calls should share a single connection.
+    assertEquals(1, socksProxy.connectionCount());
+  }
+
+  @Test public void proxySelector() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    ProxySelector proxySelector = new ProxySelector() {
+      @Override public List<Proxy> select(URI uri) {
+        return Collections.singletonList(socksProxy.proxy());
+      }
+
+      @Override public void connectFailed(URI uri, SocketAddress socketAddress, IOException e) {
+        throw new AssertionError();
+      }
+    };
+
+    OkHttpClient client = defaultClient().newBuilder()
+        .proxySelector(proxySelector)
+        .build();
+
+    Request request = new Request.Builder().url(server.url("/")).build();
+    Response response = client.newCall(request).execute();
+    assertEquals("abc", response.body().string());
+
+    assertEquals(1, socksProxy.connectionCount());
+  }
+
+  @Test public void checkRemoteDNSResolve() throws Exception {
+    // This testcase will fail if the target is resolved locally instead of through the proxy.
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    OkHttpClient client = defaultClient().newBuilder()
+        .proxy(socksProxy.proxy())
+        .build();
+
+    HttpUrl url = server.url("/")
+        .newBuilder()
+        .host(SocksProxy.HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS)
+        .build();
+
+    Request request = new Request.Builder().url(url).build();
+    Response response1 = client.newCall(request).execute();
+    assertEquals("abc", response1.body().string());
+
+    assertEquals(1, socksProxy.connectionCount());
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java b/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java
new file mode 100644
index 0000000000..0ec9bc34fb
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
+import java.util.logging.Handler;
+import java.util.logging.LogRecord;
+
+/**
+ * A log handler that records which log messages were published so that a calling test can make
+ * assertions about them.
+ */
+public final class TestLogHandler extends Handler {
+  private final BlockingQueue<String> logs = new LinkedBlockingQueue<>();
+
+  @Override public void publish(LogRecord logRecord) {
+    if (getFormatter() == null) {
+      logs.add(logRecord.getLevel() + ": " + logRecord.getMessage());
+    } else {
+      logs.add(getFormatter().format(logRecord));
+    }
+  }
+
+  @Override public void flush() {
+  }
+
+  @Override public void close() {
+  }
+
+  public String take() throws InterruptedException {
+    String message = logs.poll(10, TimeUnit.SECONDS);
+    if (message == null) {
+      throw new AssertionError("Timed out waiting for log message.");
+    }
+    return message;
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/TestUtil.java b/okhttp-tests/src/test/java/okhttp3/TestUtil.java
new file mode 100644
index 0000000000..fa7435ffc3
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/TestUtil.java
@@ -0,0 +1,61 @@
+package okhttp3;
+
+import java.net.InetSocketAddress;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import okhttp3.internal.SingleInetAddressDns;
+import okhttp3.internal.http2.Header;
+
+public final class TestUtil {
+  public static final InetSocketAddress UNREACHABLE_ADDRESS
+      = new InetSocketAddress("198.51.100.1", 8080);
+
+  private TestUtil() {
+  }
+
+  private static final ConnectionPool connectionPool = new ConnectionPool();
+  private static final Dispatcher dispatcher = new Dispatcher();
+
+  /**
+   * Returns an OkHttpClient for all tests to use as a starting point.
+   *
+   * <p>The shared instance allows all tests to share a single connection pool, which prevents idle
+   * connections from consuming unnecessary resources while connections wait to be evicted.
+   *
+   * <p>This client is also configured to be slightly more deterministic, returning a single IP
+   * address for all hosts, regardless of the actual number of IP addresses reported by DNS.
+   */
+  public static OkHttpClient defaultClient() {
+    return new OkHttpClient.Builder()
+        .connectionPool(connectionPool)
+        .dispatcher(dispatcher)
+        .dns(new SingleInetAddressDns()) // Prevent unexpected fallback addresses.
+        .build();
+  }
+
+  public static List<Header> headerEntries(String... elements) {
+    List<Header> result = new ArrayList<>(elements.length / 2);
+    for (int i = 0; i < elements.length; i += 2) {
+      result.add(new Header(elements[i], elements[i + 1]));
+    }
+    return result;
+  }
+
+  public static String repeat(char c, int count) {
+    char[] array = new char[count];
+    Arrays.fill(array, c);
+    return new String(array);
+  }
+
+  /**
+   * See FinalizationTester for discussion on how to best trigger GC in tests.
+   * https://android.googlesource.com/platform/libcore/+/master/support/src/test/java/libcore/
+   * java/lang/ref/FinalizationTester.java
+   */
+  public static void awaitGarbageCollection() throws InterruptedException {
+    Runtime.getRuntime().gc();
+    Thread.sleep(100);
+    System.runFinalization();
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
new file mode 100644
index 0000000000..29558b123f
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
@@ -0,0 +1,3865 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.Authenticator;
+import java.net.ConnectException;
+import java.net.CookieManager;
+import java.net.HttpRetryException;
+import java.net.HttpURLConnection;
+import java.net.InetAddress;
+import java.net.PasswordAuthentication;
+import java.net.ProtocolException;
+import java.net.Proxy;
+import java.net.ProxySelector;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.net.SocketAddress;
+import java.net.SocketTimeoutException;
+import java.net.URI;
+import java.net.URL;
+import java.net.URLConnection;
+import java.net.UnknownHostException;
+import java.security.KeyStore;
+import java.security.cert.CertificateException;
+import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.EnumSet;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.zip.GZIPInputStream;
+import javax.net.ServerSocketFactory;
+import javax.net.SocketFactory;
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLException;
+import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLProtocolException;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.internal.DoubleInetAddressDns;
+import okhttp3.internal.Internal;
+import okhttp3.internal.RecordingAuthenticator;
+import okhttp3.internal.RecordingOkAuthenticator;
+import okhttp3.internal.SingleInetAddressDns;
+import okhttp3.internal.Util;
+import okhttp3.internal.Version;
+import okhttp3.internal.huc.OkHttpURLConnection;
+import okhttp3.internal.tls.SslClient;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.mockwebserver.SocketPolicy;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.GzipSink;
+import okio.Okio;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static java.util.concurrent.TimeUnit.NANOSECONDS;
+import static okhttp3.TestUtil.defaultClient;
+import static okhttp3.internal.Util.UTF_8;
+import static okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT;
+import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
+import static okhttp3.internal.huc.OkHttpURLConnection.SELECTED_PROTOCOL;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
+import static okhttp3.mockwebserver.SocketPolicy.FAIL_HANDSHAKE;
+import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
+import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END;
+import static okhttp3.mockwebserver.SocketPolicy.UPGRADE_TO_SSL_AT_END;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeTrue;
+
+/** Android's URLConnectionTest. */
+public final class URLConnectionTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final MockWebServer server2 = new MockWebServer();
+  @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
+
+  private SslClient sslClient = SslClient.localhost();
+  private OkUrlFactory urlFactory;
+  private HttpURLConnection connection;
+  private Cache cache;
+
+  @Before public void setUp() throws Exception {
+    server.setProtocolNegotiationEnabled(false);
+    urlFactory = new OkUrlFactory(defaultClient());
+  }
+
+  @After public void tearDown() throws Exception {
+    Authenticator.setDefault(null);
+    System.clearProperty("proxyHost");
+    System.clearProperty("proxyPort");
+    System.clearProperty("http.agent");
+    System.clearProperty("http.proxyHost");
+    System.clearProperty("http.proxyPort");
+    System.clearProperty("https.proxyHost");
+    System.clearProperty("https.proxyPort");
+    if (cache != null) {
+      cache.delete();
+    }
+  }
+
+  @Test public void requestHeaders() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse());
+
+    connection = urlFactory.open(server.url("/").url());
+    connection.addRequestProperty("D", "e");
+    connection.addRequestProperty("D", "f");
+    assertEquals("f", connection.getRequestProperty("D"));
+    assertEquals("f", connection.getRequestProperty("d"));
+    Map<String, List<String>> requestHeaders = connection.getRequestProperties();
+    assertEquals(newSet("e", "f"), new LinkedHashSet<>(requestHeaders.get("D")));
+    assertEquals(newSet("e", "f"), new LinkedHashSet<>(requestHeaders.get("d")));
+    try {
+      requestHeaders.put("G", Arrays.asList("h"));
+      fail("Modified an unmodifiable view.");
+    } catch (UnsupportedOperationException expected) {
+    }
+    try {
+      requestHeaders.get("D").add("i");
+      fail("Modified an unmodifiable view.");
+    } catch (UnsupportedOperationException expected) {
+    }
+    try {
+      connection.setRequestProperty(null, "j");
+      fail();
+    } catch (NullPointerException expected) {
+    }
+    try {
+      connection.addRequestProperty(null, "k");
+      fail();
+    } catch (NullPointerException expected) {
+    }
+    connection.setRequestProperty("NullValue", null);
+    assertNull(connection.getRequestProperty("NullValue"));
+    connection.addRequestProperty("AnotherNullValue", null);
+    assertNull(connection.getRequestProperty("AnotherNullValue"));
+
+    connection.getResponseCode();
+    RecordedRequest request = server.takeRequest();
+    assertEquals(Arrays.asList("e", "f"), request.getHeaders().values("D"));
+    assertNull(request.getHeader("NullValue"));
+    assertNull(request.getHeader("AnotherNullValue"));
+    assertNull(request.getHeader("G"));
+    assertNull(request.getHeader("null"));
+
+    try {
+      connection.addRequestProperty("N", "o");
+      fail("Set header after connect");
+    } catch (IllegalStateException expected) {
+    }
+    try {
+      connection.setRequestProperty("P", "q");
+      fail("Set header after connect");
+    } catch (IllegalStateException expected) {
+    }
+    try {
+      connection.getRequestProperties();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  @Test public void getRequestPropertyReturnsLastValue() throws Exception {
+    connection = urlFactory.open(server.url("/").url());
+    connection.addRequestProperty("A", "value1");
+    connection.addRequestProperty("A", "value2");
+    assertEquals("value2", connection.getRequestProperty("A"));
+  }
+
+  @Test public void responseHeaders() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setStatus("HTTP/1.0 200 Fantastic")
+        .addHeader("A: c")
+        .addHeader("B: d")
+        .addHeader("A: e")
+        .setChunkedBody("ABCDE\nFGHIJ\nKLMNO\nPQR", 8));
+
+    connection = urlFactory.open(server.url("/").url());
+    assertEquals(200, connection.getResponseCode());
+    assertEquals("Fantastic", connection.getResponseMessage());
+    assertEquals("HTTP/1.0 200 Fantastic", connection.getHeaderField(null));
+    Map<String, List<String>> responseHeaders = connection.getHeaderFields();
+    assertEquals(Arrays.asList("HTTP/1.0 200 Fantastic"), responseHeaders.get(null));
+    assertEquals(newSet("c", "e"), new LinkedHashSet<>(responseHeaders.get("A")));
+    assertEquals(newSet("c", "e"), new LinkedHashSet<>(responseHeaders.get("a")));
+    try {
+      responseHeaders.put("N", Arrays.asList("o"));
+      fail("Modified an unmodifiable view.");
+    } catch (UnsupportedOperationException expected) {
+    }
+    try {
+      responseHeaders.get("A").add("f");
+      fail("Modified an unmodifiable view.");
+    } catch (UnsupportedOperationException expected) {
+    }
+    assertEquals("A", connection.getHeaderFieldKey(0));
+    assertEquals("c", connection.getHeaderField(0));
+    assertEquals("B", connection.getHeaderFieldKey(1));
+    assertEquals("d", connection.getHeaderField(1));
+    assertEquals("A", connection.getHeaderFieldKey(2));
+    assertEquals("e", connection.getHeaderField(2));
+    connection.getInputStream().close();
+  }
+
+  @Test public void serverSendsInvalidResponseHeaders() throws Exception {
+    server.enqueue(new MockResponse().setStatus("HTP/1.1 200 OK"));
+
+    connection = urlFactory.open(server.url("/").url());
+    try {
+      connection.getResponseCode();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void serverSendsInvalidCodeTooLarge() throws Exception {
+    server.enqueue(new MockResponse().setStatus("HTTP/1.1 2147483648 OK"));
+
+    connection = urlFactory.open(server.url("/").url());
+    try {
+      connection.getResponseCode();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void serverSendsInvalidCodeNotANumber() throws Exception {
+    server.enqueue(new MockResponse().setStatus("HTTP/1.1 00a OK"));
+
+    connection = urlFactory.open(server.url("/").url());
+    try {
+      connection.getResponseCode();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void serverSendsUnnecessaryWhitespace() throws Exception {
+    server.enqueue(new MockResponse().setStatus(" HTTP/1.1 2147483648 OK"));
+
+    connection = urlFactory.open(server.url("/").url());
+    try {
+      connection.getResponseCode();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void connectRetriesUntilConnectedOrFailed() throws Exception {
+    URL url = server.url("/foo").url();
+    server.shutdown();
+
+    connection = urlFactory.open(url);
+    try {
+      connection.connect();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void requestBodySurvivesRetriesWithFixedLength() throws Exception {
+    testRequestBodySurvivesRetries(TransferKind.FIXED_LENGTH);
+  }
+
+  @Test public void requestBodySurvivesRetriesWithChunkedStreaming() throws Exception {
+    testRequestBodySurvivesRetries(TransferKind.CHUNKED);
+  }
+
+  @Test public void requestBodySurvivesRetriesWithBufferedBody() throws Exception {
+    testRequestBodySurvivesRetries(TransferKind.END_OF_STREAM);
+  }
+
+  private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    // Use a misconfigured proxy to guarantee that the request is retried.
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .proxySelector(new FakeProxySelector()
+            .addProxy(server2.toProxyAddress())
+            .addProxy(Proxy.NO_PROXY))
+        .build());
+    server2.shutdown();
+
+    connection = urlFactory.open(server.url("/def").url());
+    connection.setDoOutput(true);
+    transferKind.setForRequest(connection, 4);
+    connection.getOutputStream().write("body".getBytes("UTF-8"));
+    assertContent("abc", connection);
+
+    assertEquals("body", server.takeRequest().getBody().readUtf8());
+  }
+
+  @Test public void streamedBodyIsNotRetried() throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
+
+    urlFactory = new OkUrlFactory(defaultClient().newBuilder()
+        .dns(new DoubleInetAddressDns())
+        .build());
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
+    connection.setDoOutput(true);
+    connection.setChunkedStreamingMode(100);
+    OutputStream os = connection.getOutputStream();
+    os.write("OutputStream is no fun.".getBytes("UTF-8"));
+    os.close();
+
+    try {
+      connection.getResponseCode();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    assertEquals(1, server.getRequestCount());
+  }
+
+  @Test public void getErrorStreamOnSuccessfulRequest() throws Exception {
+    server.enqueue(new MockResponse().setBody("A"));
+    connection = urlFactory.open(server.url("/").url());
+    assertNull(connection.getErrorStream());
+    connection.getInputStream().close();
+  }
+
+  @Test public void getErrorStreamOnUnsuccessfulRequest() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(404).setBody("A"));
+    connection = urlFactory.open(server.url("/").url());
+    assertEquals("A", readAscii(connection.getErrorStream(), Integer.MAX_VALUE));
+  }
+
+  // Check that if we don't read to the end of a response, the next request on the
+  // recycled connection doesn't get the unread tail of the first request's response.
+  // http://code.google.com/p/android/issues/detail?id=2939
+  @Test public void bug2939() throws Exception {
+    MockResponse response = new MockResponse().setChunkedBody("ABCDE\nFGHIJ\nKLMNO\nPQR", 8);
+
+    server.enqueue(response);
+    server.enqueue(response);
+
+    HttpURLConnection c1 = urlFactory.open(server.url("/").url());
+    assertContent("ABCDE", c1, 5);
+    HttpURLConnection c2 = urlFactory.open(server.url("/").url());
+    assertContent("ABCDE", c2, 5);
+
+    c1.getInputStream().close();
+    c2.getInputStream().close();
+  }
+
+  // Check that we recognize a few basic mime types by extension.
+  // http://code.google.com/p/android/issues/detail?id=10100
+  @Test public void bug10100() throws Exception {
+    assertEquals("image/jpeg", URLConnection.guessContentTypeFromName("someFile.jpg"));
+    assertEquals("application/pdf", URLConnection.guessContentTypeFromName("stuff.pdf"));
+  }
+
+  @Test public void connectionsArePooled() throws Exception {
+    MockResponse response = new MockResponse().setBody("ABCDEFGHIJKLMNOPQR");
+
+    server.enqueue(response);
+    server.enqueue(response);
+    server.enqueue(response);
+
+    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/foo").url()));
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/bar?baz=quux").url()));
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/z").url()));
+    assertEquals(2, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void chunkedConnectionsArePooled() throws Exception {
+    MockResponse response = new MockResponse().setChunkedBody("ABCDEFGHIJKLMNOPQR", 5);
+
+    server.enqueue(response);
+    server.enqueue(response);
+    server.enqueue(response);
+
+    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/foo").url()));
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/bar?baz=quux").url()));
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/z").url()));
+    assertEquals(2, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void serverClosesSocket() throws Exception {
+    testServerClosesOutput(DISCONNECT_AT_END);
+  }
+
+  @Test public void serverShutdownInput() throws Exception {
+    testServerClosesOutput(SHUTDOWN_INPUT_AT_END);
+  }
+
+  @Test public void serverShutdownOutput() throws Exception {
+    testServerClosesOutput(SHUTDOWN_OUTPUT_AT_END);
+  }
+
+  @Test public void invalidHost() throws Exception {
+    // Note that 1234.1.1.1 is an invalid host in a URI, but URL isn't as strict.
+    URL url = new URL("http://1234.1.1.1/index.html");
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .dns(new FakeDns())
+        .build());
+    HttpURLConnection connection = urlFactory.open(url);
+    try {
+      connection.connect();
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+  }
+
+  private void testServerClosesOutput(SocketPolicy socketPolicy) throws Exception {
+    server.enqueue(new MockResponse().setBody("This connection won't pool properly")
+        .setSocketPolicy(socketPolicy));
+    MockResponse responseAfter = new MockResponse().setBody("This comes after a busted connection");
+    server.enqueue(responseAfter);
+    server.enqueue(responseAfter); // Enqueue 2x because the broken connection may be reused.
+
+    HttpURLConnection connection1 = urlFactory.open(server.url("/a").url());
+    connection1.setReadTimeout(100);
+    assertContent("This connection won't pool properly", connection1);
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+
+    // Give the server time to enact the socket policy if it's one that could happen after the
+    // client has received the response.
+    Thread.sleep(500);
+
+    HttpURLConnection connection2 = urlFactory.open(server.url("/b").url());
+    connection2.setReadTimeout(100);
+    assertContent("This comes after a busted connection", connection2);
+
+    // Check that a fresh connection was created, either immediately or after attempting reuse.
+    RecordedRequest requestAfter = server.takeRequest();
+    if (server.getRequestCount() == 3) {
+      requestAfter = server.takeRequest(); // The failure consumed a response.
+    }
+    // sequence number 0 means the HTTP socket connection was not reused
+    assertEquals(0, requestAfter.getSequenceNumber());
+  }
+
+  enum WriteKind {BYTE_BY_BYTE, SMALL_BUFFERS, LARGE_BUFFERS}
+
+  @Test public void chunkedUpload_byteByByte() throws Exception {
+    doUpload(TransferKind.CHUNKED, WriteKind.BYTE_BY_BYTE);
+  }
+
+  @Test public void chunkedUpload_smallBuffers() throws Exception {
+    doUpload(TransferKind.CHUNKED, WriteKind.SMALL_BUFFERS);
+  }
+
+  @Test public void chunkedUpload_largeBuffers() throws Exception {
+    doUpload(TransferKind.CHUNKED, WriteKind.LARGE_BUFFERS);
+  }
+
+  @Test public void fixedLengthUpload_byteByByte() throws Exception {
+    doUpload(TransferKind.FIXED_LENGTH, WriteKind.BYTE_BY_BYTE);
+  }
+
+  @Test public void fixedLengthUpload_smallBuffers() throws Exception {
+    doUpload(TransferKind.FIXED_LENGTH, WriteKind.SMALL_BUFFERS);
+  }
+
+  @Test public void fixedLengthUpload_largeBuffers() throws Exception {
+    doUpload(TransferKind.FIXED_LENGTH, WriteKind.LARGE_BUFFERS);
+  }
+
+  private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Exception {
+    int n = 512 * 1024;
+    server.setBodyLimit(0);
+    server.enqueue(new MockResponse());
+
+    HttpURLConnection conn = urlFactory.open(server.url("/").url());
+    conn.setDoOutput(true);
+    conn.setRequestMethod("POST");
+    if (uploadKind == TransferKind.CHUNKED) {
+      conn.setChunkedStreamingMode(-1);
+    } else {
+      conn.setFixedLengthStreamingMode(n);
+    }
+    OutputStream out = conn.getOutputStream();
+    if (writeKind == WriteKind.BYTE_BY_BYTE) {
+      for (int i = 0; i < n; ++i) {
+        out.write('x');
+      }
+    } else {
+      byte[] buf = new byte[writeKind == WriteKind.SMALL_BUFFERS ? 256 : 64 * 1024];
+      Arrays.fill(buf, (byte) 'x');
+      for (int i = 0; i < n; i += buf.length) {
+        out.write(buf, 0, Math.min(buf.length, n - i));
+      }
+    }
+    out.close();
+    assertEquals(200, conn.getResponseCode());
+    RecordedRequest request = server.takeRequest();
+    assertEquals(n, request.getBodySize());
+    if (uploadKind == TransferKind.CHUNKED) {
+      assertTrue(request.getChunkSizes().size() > 0);
+    } else {
+      assertTrue(request.getChunkSizes().isEmpty());
+    }
+  }
+
+  @Test public void getResponseCodeNoResponseBody() throws Exception {
+    server.enqueue(new MockResponse().addHeader("abc: def"));
+
+    URL url = server.url("/").url();
+    HttpURLConnection conn = urlFactory.open(url);
+    conn.setDoInput(false);
+    assertEquals("def", conn.getHeaderField("abc"));
+    assertEquals(200, conn.getResponseCode());
+    try {
+      conn.getInputStream();
+      fail();
+    } catch (ProtocolException expected) {
+    }
+  }
+
+  @Test public void connectViaHttps() throws Exception {
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
+
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build());
+    connection = urlFactory.open(server.url("/foo").url());
+
+    assertContent("this response comes via HTTPS", connection);
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
+  }
+
+  @Test public void inspectHandshakeThroughoutRequestLifecycle() throws Exception {
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse());
+
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build());
+
+    HttpsURLConnection httpsConnection
+        = (HttpsURLConnection) urlFactory.open(server.url("/foo").url());
+
+    // Prior to calling connect(), getting the cipher suite is forbidden.
+    try {
+      httpsConnection.getCipherSuite();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+
+    // Calling connect establishes a handshake...
+    httpsConnection.connect();
+    assertNotNull(httpsConnection.getCipherSuite());
+
+    // ...which remains after we read the response body...
+    assertContent("", httpsConnection);
+    assertNotNull(httpsConnection.getCipherSuite());
+
+    // ...and after we disconnect.
+    httpsConnection.disconnect();
+    assertNotNull(httpsConnection.getCipherSuite());
+  }
+
+  @Test public void connectViaHttpsReusingConnections() throws Exception {
+    connectViaHttpsReusingConnections(false);
+  }
+
+  @Test public void connectViaHttpsReusingConnectionsAfterRebuildingClient() throws Exception {
+    connectViaHttpsReusingConnections(true);
+  }
+
+  private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exception {
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
+    server.enqueue(new MockResponse().setBody("another response via HTTPS"));
+
+    // The pool will only reuse sockets if the SSL socket factories are the same.
+    SSLSocketFactory clientSocketFactory = sslClient.socketFactory;
+    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+
+    CookieJar cookieJar = new JavaNetCookieJar(new CookieManager());
+    ConnectionPool connectionPool = new ConnectionPool();
+
+    urlFactory.setClient(new OkHttpClient.Builder()
+        .cache(cache)
+        .connectionPool(connectionPool)
+        .cookieJar(cookieJar)
+        .sslSocketFactory(clientSocketFactory, sslClient.trustManager)
+        .hostnameVerifier(hostnameVerifier)
+        .build());
+    connection = urlFactory.open(server.url("/").url());
+    assertContent("this response comes via HTTPS", connection);
+
+    if (rebuildClient) {
+      urlFactory.setClient(new OkHttpClient.Builder()
+          .cache(cache)
+          .connectionPool(connectionPool)
+          .cookieJar(cookieJar)
+          .sslSocketFactory(clientSocketFactory, sslClient.trustManager)
+          .hostnameVerifier(hostnameVerifier)
+          .build());
+    }
+
+    connection = urlFactory.open(server.url("/").url());
+    assertContent("another response via HTTPS", connection);
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void connectViaHttpsReusingConnectionsDifferentFactories() throws Exception {
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
+    server.enqueue(new MockResponse().setBody("another response via HTTPS"));
+
+    // install a custom SSL socket factory so the server can be authorized
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build());
+    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
+    assertContent("this response comes via HTTPS", connection1);
+
+    SSLContext sslContext2 = SSLContext.getInstance("TLS");
+    sslContext2.init(null, null, null);
+    SSLSocketFactory sslSocketFactory2 = sslContext2.getSocketFactory();
+
+    TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+        TrustManagerFactory.getDefaultAlgorithm());
+    trustManagerFactory.init((KeyStore) null);
+    X509TrustManager trustManager = (X509TrustManager) trustManagerFactory.getTrustManagers()[0];
+
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslSocketFactory2, trustManager)
+        .build());
+    HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
+    try {
+      readAscii(connection2.getInputStream(), Integer.MAX_VALUE);
+      fail("without an SSL socket factory, the connection should fail");
+    } catch (SSLException expected) {
+    }
+  }
+
+  // TODO(jwilson): tests below this marker need to be migrated to OkHttp's request/response API.
+
+  @Test public void connectViaHttpsWithSSLFallback() throws Exception {
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse().setBody("this response comes via SSL"));
+
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
+        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
+        .build());
+    connection = urlFactory.open(server.url("/foo").url());
+
+    assertContent("this response comes via SSL", connection);
+
+    RecordedRequest failHandshakeRequest = server.takeRequest();
+    assertNull(failHandshakeRequest.getRequestLine());
+
+    RecordedRequest fallbackRequest = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", fallbackRequest.getRequestLine());
+    assertEquals(TlsVersion.TLS_1_0, fallbackRequest.getTlsVersion());
+  }
+
+  @Test public void connectViaHttpsWithSSLFallbackFailuresRecorded() throws Exception {
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
+
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .dns(new SingleInetAddressDns())
+        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
+        .build());
+    connection = urlFactory.open(server.url("/foo").url());
+
+    try {
+      connection.getResponseCode();
+      fail();
+    } catch (IOException expected) {
+      assertEquals(1, expected.getSuppressed().length);
+    }
+  }
+
+  /**
+   * When a pooled connection fails, don't blame the route. Otherwise pooled connection failures can
+   * cause unnecessary SSL fallbacks.
+   *
+   * https://github.com/square/okhttp/issues/515
+   */
+  @Test public void sslFallbackNotUsedWhenRecycledConnectionFails() throws Exception {
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .setSocketPolicy(DISCONNECT_AT_END));
+    server.enqueue(new MockResponse().setBody("def"));
+
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
+        .build());
+
+    assertContent("abc", urlFactory.open(server.url("/").url()));
+
+    // Give the server time to disconnect.
+    Thread.sleep(500);
+
+    assertContent("def", urlFactory.open(server.url("/").url()));
+
+    Set<TlsVersion> tlsVersions =
+        EnumSet.of(TlsVersion.TLS_1_0, TlsVersion.TLS_1_2); // v1.2 on OpenJDK 8.
+
+    RecordedRequest request1 = server.takeRequest();
+    assertTrue(tlsVersions.contains(request1.getTlsVersion()));
+
+    RecordedRequest request2 = server.takeRequest();
+    assertTrue(tlsVersions.contains(request2.getTlsVersion()));
+  }
+
+  /**
+   * Verify that we don't retry connections on certificate verification errors.
+   *
+   * http://code.google.com/p/android/issues/detail?id=13178
+   */
+  @Test public void connectViaHttpsToUntrustedServer() throws IOException, InterruptedException {
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse()); // unused
+
+    connection = urlFactory.open(server.url("/foo").url());
+    try {
+      connection.getInputStream();
+      fail();
+    } catch (SSLHandshakeException expected) {
+      assertTrue(expected.getCause() instanceof CertificateException);
+    }
+    assertEquals(0, server.getRequestCount());
+  }
+
+  @Test public void connectViaProxyUsingProxyArg() throws Exception {
+    testConnectViaProxy(ProxyConfig.CREATE_ARG);
+  }
+
+  @Test public void connectViaProxyUsingProxySystemProperty() throws Exception {
+    testConnectViaProxy(ProxyConfig.PROXY_SYSTEM_PROPERTY);
+  }
+
+  @Test public void connectViaProxyUsingHttpProxySystemProperty() throws Exception {
+    testConnectViaProxy(ProxyConfig.HTTP_PROXY_SYSTEM_PROPERTY);
+  }
+
+  private void testConnectViaProxy(ProxyConfig proxyConfig) throws Exception {
+    MockResponse mockResponse = new MockResponse().setBody("this response comes via a proxy");
+    server.enqueue(mockResponse);
+
+    URL url = new URL("http://android.com/foo");
+    connection = proxyConfig.connect(server, urlFactory, url);
+    assertContent("this response comes via a proxy", connection);
+    assertTrue(connection.usingProxy());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("GET http://android.com/foo HTTP/1.1", request.getRequestLine());
+    assertEquals("android.com", request.getHeader("Host"));
+  }
+
+  @Test public void contentDisagreesWithContentLengthHeaderBodyTooLong() throws IOException {
+    server.enqueue(new MockResponse().setBody("abc\r\nYOU SHOULD NOT SEE THIS")
+        .clearHeaders()
+        .addHeader("Content-Length: 3"));
+    assertContent("abc", urlFactory.open(server.url("/").url()));
+  }
+
+  @Test public void contentDisagreesWithContentLengthHeaderBodyTooShort() throws IOException {
+    server.enqueue(new MockResponse().setBody("abc")
+        .setHeader("Content-Length", "5")
+        .setSocketPolicy(DISCONNECT_AT_END));
+    try {
+      readAscii(urlFactory.open(server.url("/").url()).getInputStream(), 5);
+      fail();
+    } catch (ProtocolException expected) {
+    }
+  }
+
+  public void testConnectViaSocketFactory(boolean useHttps) throws IOException {
+    SocketFactory uselessSocketFactory = new SocketFactory() {
+      public Socket createSocket() {
+        throw new IllegalArgumentException("useless");
+      }
+
+      public Socket createSocket(InetAddress host, int port) {
+        return null;
+      }
+
+      public Socket createSocket(InetAddress address, int port, InetAddress localAddress,
+          int localPort) {
+        return null;
+      }
+
+      public Socket createSocket(String host, int port) {
+        return null;
+      }
+
+      public Socket createSocket(String host, int port, InetAddress localHost, int localPort) {
+        return null;
+      }
+    };
+
+    if (useHttps) {
+      server.useHttps(sslClient.socketFactory, false);
+      urlFactory.setClient(urlFactory.client().newBuilder()
+          .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+          .hostnameVerifier(new RecordingHostnameVerifier())
+          .build());
+    }
+
+    server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 OK"));
+
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .socketFactory(uselessSocketFactory)
+        .build());
+    connection = urlFactory.open(server.url("/").url());
+    try {
+      connection.getResponseCode();
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .socketFactory(SocketFactory.getDefault())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
+    assertEquals(200, connection.getResponseCode());
+  }
+
+  @Test public void connectHttpViaSocketFactory() throws Exception {
+    testConnectViaSocketFactory(false);
+  }
+
+  @Test public void connectHttpsViaSocketFactory() throws Exception {
+    testConnectViaSocketFactory(true);
+  }
+
+  @Test public void contentDisagreesWithChunkedHeaderBodyTooLong() throws IOException {
+    MockResponse mockResponse = new MockResponse();
+    mockResponse.setChunkedBody("abc", 3);
+    Buffer buffer = mockResponse.getBody();
+    buffer.writeUtf8("\r\nYOU SHOULD NOT SEE THIS");
+    mockResponse.setBody(buffer);
+    mockResponse.clearHeaders();
+    mockResponse.addHeader("Transfer-encoding: chunked");
+
+    server.enqueue(mockResponse);
+
+    assertContent("abc", urlFactory.open(server.url("/").url()));
+  }
+
+  @Test public void contentDisagreesWithChunkedHeaderBodyTooShort() throws IOException {
+    MockResponse mockResponse = new MockResponse();
+    mockResponse.setChunkedBody("abcde", 5);
+
+    Buffer truncatedBody = new Buffer();
+    Buffer fullBody = mockResponse.getBody();
+    truncatedBody.write(fullBody, fullBody.indexOf((byte) 'e'));
+    mockResponse.setBody(truncatedBody);
+
+    mockResponse.clearHeaders();
+    mockResponse.addHeader("Transfer-encoding: chunked");
+    mockResponse.setSocketPolicy(DISCONNECT_AT_END);
+
+    server.enqueue(mockResponse);
+
+    try {
+      readAscii(urlFactory.open(server.url("/").url()).getInputStream(), 5);
+      fail();
+    } catch (ProtocolException expected) {
+    }
+  }
+
+  @Test public void connectViaHttpProxyToHttpsUsingProxyArgWithNoProxy() throws Exception {
+    testConnectViaDirectProxyToHttps(ProxyConfig.NO_PROXY);
+  }
+
+  @Test public void connectViaHttpProxyToHttpsUsingHttpProxySystemProperty() throws Exception {
+    // https should not use http proxy
+    testConnectViaDirectProxyToHttps(ProxyConfig.HTTP_PROXY_SYSTEM_PROPERTY);
+  }
+
+  private void testConnectViaDirectProxyToHttps(ProxyConfig proxyConfig) throws Exception {
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
+
+    URL url = server.url("/foo").url();
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build());
+    connection = proxyConfig.connect(server, urlFactory, url);
+
+    assertContent("this response comes via HTTPS", connection);
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
+  }
+
+  @Test public void connectViaHttpProxyToHttpsUsingProxyArg() throws Exception {
+    testConnectViaHttpProxyToHttps(ProxyConfig.CREATE_ARG);
+  }
+
+  /**
+   * We weren't honoring all of the appropriate proxy system properties when connecting via HTTPS.
+   * http://b/3097518
+   */
+  @Test public void connectViaHttpProxyToHttpsUsingProxySystemProperty() throws Exception {
+    testConnectViaHttpProxyToHttps(ProxyConfig.PROXY_SYSTEM_PROPERTY);
+  }
+
+  @Test public void connectViaHttpProxyToHttpsUsingHttpsProxySystemProperty() throws Exception {
+    testConnectViaHttpProxyToHttps(ProxyConfig.HTTPS_PROXY_SYSTEM_PROPERTY);
+  }
+
+  /**
+   * We were verifying the wrong hostname when connecting to an HTTPS site through a proxy.
+   * http://b/3097277
+   */
+  private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exception {
+    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+
+    server.useHttps(sslClient.socketFactory, true);
+    server.enqueue(
+        new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
+    server.enqueue(new MockResponse().setBody("this response comes via a secure proxy"));
+
+    URL url = new URL("https://android.com/foo");
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(hostnameVerifier)
+        .build());
+    connection = proxyConfig.connect(server, urlFactory, url);
+
+    assertContent("this response comes via a secure proxy", connection);
+
+    RecordedRequest connect = server.takeRequest();
+    assertEquals("Connect line failure on proxy", "CONNECT android.com:443 HTTP/1.1",
+        connect.getRequestLine());
+    assertEquals("android.com:443", connect.getHeader("Host"));
+
+    RecordedRequest get = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", get.getRequestLine());
+    assertEquals("android.com", get.getHeader("Host"));
+    assertEquals(Arrays.asList("verify android.com"), hostnameVerifier.calls);
+  }
+
+  /** Tolerate bad https proxy response when using HttpResponseCache. Android bug 6754912. */
+  @Test public void connectViaHttpProxyToHttpsUsingBadProxyAndHttpResponseCache() throws Exception {
+    initResponseCache();
+
+    server.useHttps(sslClient.socketFactory, true);
+    // The inclusion of a body in the response to a CONNECT is key to reproducing b/6754912.
+    MockResponse badProxyResponse = new MockResponse()
+        .setSocketPolicy(UPGRADE_TO_SSL_AT_END)
+        .setBody("bogus proxy connect response content");
+    server.enqueue(badProxyResponse);
+    server.enqueue(new MockResponse().setBody("response"));
+
+    // Configure a single IP address for the host and a single configuration, so we only need one
+    // failure to fail permanently.
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .dns(new SingleInetAddressDns())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .connectionSpecs(Util.immutableList(ConnectionSpec.MODERN_TLS))
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .proxy(server.toProxyAddress())
+        .build());
+
+    URL url = new URL("https://android.com/foo");
+    connection = urlFactory.open(url);
+    assertContent("response", connection);
+
+    RecordedRequest connect = server.takeRequest();
+    assertEquals("CONNECT android.com:443 HTTP/1.1", connect.getRequestLine());
+    assertEquals("android.com:443", connect.getHeader("Host"));
+  }
+
+  private void initResponseCache() throws IOException {
+    cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .cache(cache)
+        .build());
+  }
+
+  /** Test which headers are sent unencrypted to the HTTP proxy. */
+  @Test public void proxyConnectIncludesProxyHeadersOnly()
+      throws IOException, InterruptedException {
+    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+
+    server.useHttps(sslClient.socketFactory, true);
+    server.enqueue(
+        new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
+    server.enqueue(new MockResponse().setBody("encrypted response from the origin server"));
+
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .proxy(server.toProxyAddress())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(hostnameVerifier)
+        .build());
+
+    URL url = new URL("https://android.com/foo");
+    connection = urlFactory.open(url);
+    connection.addRequestProperty("Private", "Secret");
+    connection.addRequestProperty("Proxy-Authorization", "bar");
+    connection.addRequestProperty("User-Agent", "baz");
+    assertContent("encrypted response from the origin server", connection);
+
+    RecordedRequest connect = server.takeRequest();
+    assertNull(connect.getHeader("Private"));
+    assertNull(connect.getHeader("Proxy-Authorization"));
+    assertEquals(Version.userAgent(), connect.getHeader("User-Agent"));
+    assertEquals("android.com:443", connect.getHeader("Host"));
+    assertEquals("Keep-Alive", connect.getHeader("Proxy-Connection"));
+
+    RecordedRequest get = server.takeRequest();
+    assertEquals("Secret", get.getHeader("Private"));
+    assertEquals(Arrays.asList("verify android.com"), hostnameVerifier.calls);
+  }
+
+  @Test public void proxyAuthenticateOnConnect() throws Exception {
+    Authenticator.setDefault(new RecordingAuthenticator());
+    server.useHttps(sslClient.socketFactory, true);
+    server.enqueue(new MockResponse().setResponseCode(407)
+        .addHeader("Proxy-Authenticate: Basic realm=\"localhost\""));
+    server.enqueue(
+        new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
+    server.enqueue(new MockResponse().setBody("A"));
+
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .proxyAuthenticator(new JavaNetAuthenticator())
+        .proxy(server.toProxyAddress())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build());
+
+    URL url = new URL("https://android.com/foo");
+    connection = urlFactory.open(url);
+    assertContent("A", connection);
+
+    RecordedRequest connect1 = server.takeRequest();
+    assertEquals("CONNECT android.com:443 HTTP/1.1", connect1.getRequestLine());
+    assertNull(connect1.getHeader("Proxy-Authorization"));
+
+    RecordedRequest connect2 = server.takeRequest();
+    assertEquals("CONNECT android.com:443 HTTP/1.1", connect2.getRequestLine());
+    assertEquals("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS,
+        connect2.getHeader("Proxy-Authorization"));
+
+    RecordedRequest get = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", get.getRequestLine());
+    assertNull(get.getHeader("Proxy-Authorization"));
+  }
+
+  // Don't disconnect after building a tunnel with CONNECT
+  // http://code.google.com/p/android/issues/detail?id=37221
+  @Test public void proxyWithConnectionClose() throws IOException {
+    server.useHttps(sslClient.socketFactory, true);
+    server.enqueue(
+        new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
+    server.enqueue(new MockResponse().setBody("this response comes via a proxy"));
+
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .proxy(server.toProxyAddress())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build());
+
+    URL url = new URL("https://android.com/foo");
+    connection = urlFactory.open(url);
+    connection.setRequestProperty("Connection", "close");
+
+    assertContent("this response comes via a proxy", connection);
+  }
+
+  @Test public void proxyWithConnectionReuse() throws IOException {
+    SSLSocketFactory socketFactory = sslClient.socketFactory;
+    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+
+    server.useHttps(socketFactory, true);
+    server.enqueue(
+        new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
+    server.enqueue(new MockResponse().setBody("response 1"));
+    server.enqueue(new MockResponse().setBody("response 2"));
+
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .proxy(server.toProxyAddress())
+        .sslSocketFactory(socketFactory, sslClient.trustManager)
+        .hostnameVerifier(hostnameVerifier)
+        .build());
+    URL url = new URL("https://android.com/foo");
+    assertContent("response 1", urlFactory.open(url));
+    assertContent("response 2", urlFactory.open(url));
+  }
+
+  @Test public void disconnectedConnection() throws IOException {
+    server.enqueue(new MockResponse()
+        .throttleBody(2, 100, TimeUnit.MILLISECONDS)
+        .setBody("ABCD"));
+
+    connection = urlFactory.open(server.url("/").url());
+    InputStream in = connection.getInputStream();
+    assertEquals('A', (char) in.read());
+    connection.disconnect();
+    try {
+      // Reading 'B' may succeed if it's buffered.
+      in.read();
+
+      // But 'C' shouldn't be buffered (the response is throttled) and this should fail.
+      in.read();
+      fail("Expected a connection closed exception");
+    } catch (IOException expected) {
+    }
+    in.close();
+  }
+
+  @Test public void disconnectDuringConnect_cookieJar() throws Exception {
+    final AtomicReference<HttpURLConnection> connectionHolder = new AtomicReference<>();
+    class DisconnectingCookieJar implements CookieJar {
+      @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) { }
+      @Override
+      public List<Cookie> loadForRequest(HttpUrl url) {
+        connectionHolder.get().disconnect();
+        return Collections.emptyList();
+      }
+    }
+    OkHttpClient client = new okhttp3.OkHttpClient.Builder()
+            .cookieJar(new DisconnectingCookieJar())
+            .build();
+
+    URL url = server.url("path that should never be accessed").url();
+    HttpURLConnection connection = new OkHttpURLConnection(url, client);
+    connectionHolder.set(connection);
+    try {
+      connection.getInputStream();
+      fail("Connection should not be established");
+    } catch (IOException expected) {
+      assertEquals("Canceled", expected.getMessage());
+    } finally {
+      connection.disconnect();
+    }
+  }
+
+  @Test public void disconnectBeforeConnect() throws IOException {
+    server.enqueue(new MockResponse().setBody("A"));
+
+    connection = urlFactory.open(server.url("/").url());
+    connection.disconnect();
+    assertContent("A", connection);
+    assertEquals(200, connection.getResponseCode());
+  }
+
+  @SuppressWarnings("deprecation") @Test public void defaultRequestProperty() throws Exception {
+    URLConnection.setDefaultRequestProperty("X-testSetDefaultRequestProperty", "A");
+    assertNull(URLConnection.getDefaultRequestProperty("X-setDefaultRequestProperty"));
+  }
+
+  /**
+   * Reads {@code count} characters from the stream. If the stream is exhausted before {@code count}
+   * characters can be read, the remaining characters are returned and the stream is closed.
+   */
+  private String readAscii(InputStream in, int count) throws IOException {
+    StringBuilder result = new StringBuilder();
+    for (int i = 0; i < count; i++) {
+      int value = in.read();
+      if (value == -1) {
+        in.close();
+        break;
+      }
+      result.append((char) value);
+    }
+    return result.toString();
+  }
+
+  @Test public void markAndResetWithContentLengthHeader() throws IOException {
+    testMarkAndReset(TransferKind.FIXED_LENGTH);
+  }
+
+  @Test public void markAndResetWithChunkedEncoding() throws IOException {
+    testMarkAndReset(TransferKind.CHUNKED);
+  }
+
+  @Test public void markAndResetWithNoLengthHeaders() throws IOException {
+    testMarkAndReset(TransferKind.END_OF_STREAM);
+  }
+
+  private void testMarkAndReset(TransferKind transferKind) throws IOException {
+    MockResponse response = new MockResponse();
+    transferKind.setBody(response, "ABCDEFGHIJKLMNOPQRSTUVWXYZ", 1024);
+    server.enqueue(response);
+    server.enqueue(response);
+
+    InputStream in = urlFactory.open(server.url("/").url()).getInputStream();
+    assertFalse("This implementation claims to support mark().", in.markSupported());
+    in.mark(5);
+    assertEquals("ABCDE", readAscii(in, 5));
+    try {
+      in.reset();
+      fail();
+    } catch (IOException expected) {
+    }
+    assertEquals("FGHIJKLMNOPQRSTUVWXYZ", readAscii(in, Integer.MAX_VALUE));
+    in.close();
+    assertContent("ABCDEFGHIJKLMNOPQRSTUVWXYZ", urlFactory.open(server.url("/").url()));
+  }
+
+  /**
+   * We've had a bug where we forget the HTTP response when we see response code 401. This causes a
+   * new HTTP request to be issued for every call into the URLConnection.
+   */
+  @Test public void unauthorizedResponseHandling() throws IOException {
+    MockResponse response = new MockResponse().addHeader("WWW-Authenticate: challenge")
+        .setResponseCode(401) // UNAUTHORIZED
+        .setBody("Unauthorized");
+    server.enqueue(response);
+    server.enqueue(response);
+    server.enqueue(response);
+
+    URL url = server.url("/").url();
+    HttpURLConnection conn = urlFactory.open(url);
+
+    assertEquals(401, conn.getResponseCode());
+    assertEquals(401, conn.getResponseCode());
+    assertEquals(401, conn.getResponseCode());
+    assertEquals(1, server.getRequestCount());
+    conn.getErrorStream().close();
+  }
+
+  @Test public void nonHexChunkSize() throws IOException {
+    server.enqueue(new MockResponse().setBody("5\r\nABCDE\r\nG\r\nFGHIJKLMNOPQRSTU\r\n0\r\n\r\n")
+        .clearHeaders()
+        .addHeader("Transfer-encoding: chunked"));
+
+    URLConnection connection = urlFactory.open(server.url("/").url());
+    try {
+      readAscii(connection.getInputStream(), Integer.MAX_VALUE);
+      fail();
+    } catch (IOException e) {
+    }
+    connection.getInputStream().close();
+  }
+
+  @Test public void malformedChunkSize() throws IOException {
+    server.enqueue(new MockResponse().setBody("5:x\r\nABCDE\r\n0\r\n\r\n")
+        .clearHeaders()
+        .addHeader("Transfer-encoding: chunked"));
+
+    URLConnection connection = urlFactory.open(server.url("/").url());
+    try {
+      readAscii(connection.getInputStream(), Integer.MAX_VALUE);
+      fail();
+    } catch (IOException e) {
+    } finally {
+      connection.getInputStream().close();
+    }
+  }
+
+  @Test public void extensionAfterChunkSize() throws IOException {
+    server.enqueue(new MockResponse().setBody("5;x\r\nABCDE\r\n0\r\n\r\n")
+        .clearHeaders()
+        .addHeader("Transfer-encoding: chunked"));
+
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
+    assertContent("ABCDE", connection);
+  }
+
+  @Test public void missingChunkBody() throws IOException {
+    server.enqueue(new MockResponse().setBody("5")
+        .clearHeaders()
+        .addHeader("Transfer-encoding: chunked")
+        .setSocketPolicy(DISCONNECT_AT_END));
+
+    URLConnection connection = urlFactory.open(server.url("/").url());
+    try {
+      readAscii(connection.getInputStream(), Integer.MAX_VALUE);
+      fail();
+    } catch (IOException e) {
+    } finally {
+      connection.getInputStream().close();
+    }
+  }
+
+  /**
+   * This test checks whether connections are gzipped by default. This behavior in not required by
+   * the API, so a failure of this test does not imply a bug in the implementation.
+   */
+  @Test public void gzipEncodingEnabledByDefault() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse()
+        .setBody(gzip("ABCABCABC"))
+        .addHeader("Content-Encoding: gzip"));
+
+    URLConnection connection = urlFactory.open(server.url("/").url());
+    assertEquals("ABCABCABC", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+    assertNull(connection.getContentEncoding());
+    assertEquals(-1, connection.getContentLength());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("gzip", request.getHeader("Accept-Encoding"));
+  }
+
+  @Test public void clientConfiguredGzipContentEncoding() throws Exception {
+    Buffer bodyBytes = gzip("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
+    server.enqueue(new MockResponse()
+        .setBody(bodyBytes)
+        .addHeader("Content-Encoding: gzip"));
+
+    URLConnection connection = urlFactory.open(server.url("/").url());
+    connection.addRequestProperty("Accept-Encoding", "gzip");
+    InputStream gunzippedIn = new GZIPInputStream(connection.getInputStream());
+    assertEquals("ABCDEFGHIJKLMNOPQRSTUVWXYZ", readAscii(gunzippedIn, Integer.MAX_VALUE));
+    assertEquals(bodyBytes.size(), connection.getContentLength());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("gzip", request.getHeader("Accept-Encoding"));
+  }
+
+  @Test public void gzipAndConnectionReuseWithFixedLength() throws Exception {
+    testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.FIXED_LENGTH, false);
+  }
+
+  @Test public void gzipAndConnectionReuseWithChunkedEncoding() throws Exception {
+    testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.CHUNKED, false);
+  }
+
+  @Test public void gzipAndConnectionReuseWithFixedLengthAndTls() throws Exception {
+    testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.FIXED_LENGTH, true);
+  }
+
+  @Test public void gzipAndConnectionReuseWithChunkedEncodingAndTls() throws Exception {
+    testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.CHUNKED, true);
+  }
+
+  @Test public void clientConfiguredCustomContentEncoding() throws Exception {
+    server.enqueue(new MockResponse().setBody("ABCDE").addHeader("Content-Encoding: custom"));
+
+    URLConnection connection = urlFactory.open(server.url("/").url());
+    connection.addRequestProperty("Accept-Encoding", "custom");
+    assertEquals("ABCDE", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("custom", request.getHeader("Accept-Encoding"));
+  }
+
+  /**
+   * Test a bug where gzip input streams weren't exhausting the input stream, which corrupted the
+   * request that followed or prevented connection reuse.
+   * http://code.google.com/p/android/issues/detail?id=7059
+   * http://code.google.com/p/android/issues/detail?id=38817
+   */
+  private void testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind transferKind,
+      boolean tls) throws Exception {
+    if (tls) {
+      SSLSocketFactory socketFactory = sslClient.socketFactory;
+      RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+      server.useHttps(socketFactory, false);
+      urlFactory.setClient(urlFactory.client().newBuilder()
+          .sslSocketFactory(socketFactory, sslClient.trustManager)
+          .hostnameVerifier(hostnameVerifier)
+          .build());
+    }
+
+    MockResponse responseOne = new MockResponse();
+    responseOne.addHeader("Content-Encoding: gzip");
+    transferKind.setBody(responseOne, gzip("one (gzipped)"), 5);
+    server.enqueue(responseOne);
+    MockResponse responseTwo = new MockResponse();
+    transferKind.setBody(responseTwo, "two (identity)", 5);
+    server.enqueue(responseTwo);
+
+    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
+    connection1.addRequestProperty("Accept-Encoding", "gzip");
+    InputStream gunzippedIn = new GZIPInputStream(connection1.getInputStream());
+    assertEquals("one (gzipped)", readAscii(gunzippedIn, Integer.MAX_VALUE));
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+
+    HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
+    assertEquals("two (identity)", readAscii(connection2.getInputStream(), Integer.MAX_VALUE));
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void transparentGzipWorksAfterExceptionRecovery() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("a")
+        .setSocketPolicy(SHUTDOWN_INPUT_AT_END));
+    server.enqueue(new MockResponse()
+        .addHeader("Content-Encoding: gzip")
+        .setBody(gzip("b")));
+
+    // Seed the pool with a bad connection.
+    assertContent("a", urlFactory.open(server.url("/").url()));
+
+    // Give the server time to disconnect.
+    Thread.sleep(500);
+
+    // This connection will need to be recovered. When it is, transparent gzip should still work!
+    assertContent("b", urlFactory.open(server.url("/").url()));
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // Connection is not pooled.
+  }
+
+  @Test public void endOfStreamResponseIsNotPooled() throws Exception {
+    urlFactory.client().connectionPool().evictAll();
+    server.enqueue(new MockResponse()
+        .setBody("{}")
+        .clearHeaders()
+        .setSocketPolicy(DISCONNECT_AT_END));
+
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
+    assertContent("{}", connection);
+    assertEquals(0, urlFactory.client().connectionPool().idleConnectionCount());
+  }
+
+  @Test public void earlyDisconnectDoesntHarmPoolingWithChunkedEncoding() throws Exception {
+    testEarlyDisconnectDoesntHarmPooling(TransferKind.CHUNKED);
+  }
+
+  @Test public void earlyDisconnectDoesntHarmPoolingWithFixedLengthEncoding() throws Exception {
+    testEarlyDisconnectDoesntHarmPooling(TransferKind.FIXED_LENGTH);
+  }
+
+  private void testEarlyDisconnectDoesntHarmPooling(TransferKind transferKind) throws Exception {
+    MockResponse response1 = new MockResponse();
+    transferKind.setBody(response1, "ABCDEFGHIJK", 1024);
+    server.enqueue(response1);
+
+    MockResponse response2 = new MockResponse();
+    transferKind.setBody(response2, "LMNOPQRSTUV", 1024);
+    server.enqueue(response2);
+
+    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
+    InputStream in1 = connection1.getInputStream();
+    assertEquals("ABCDE", readAscii(in1, 5));
+    in1.close();
+    connection1.disconnect();
+
+    HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
+    InputStream in2 = connection2.getInputStream();
+    assertEquals("LMNOP", readAscii(in2, 5));
+    in2.close();
+    connection2.disconnect();
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection is pooled!
+  }
+
+  @Test public void streamDiscardingIsTimely() throws Exception {
+    // This response takes at least a full second to serve: 10,000 bytes served 100 bytes at a time.
+    server.enqueue(new MockResponse()
+        .setBody(new Buffer().write(new byte[10000]))
+        .throttleBody(100, 10, MILLISECONDS));
+    server.enqueue(new MockResponse().setBody("A"));
+
+    long startNanos = System.nanoTime();
+    URLConnection connection1 = urlFactory.open(server.url("/").url());
+    InputStream in = connection1.getInputStream();
+    in.close();
+    long elapsedNanos = System.nanoTime() - startNanos;
+    long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
+
+    // If we're working correctly, this should be greater than 100ms, but less than double that.
+    // Previously we had a bug where we would download the entire response body as long as no
+    // individual read took longer than 100ms.
+    assertTrue(Util.format("Time to close: %sms", elapsedMillis), elapsedMillis < 500);
+
+    // Do another request to confirm that the discarded connection was not pooled.
+    assertContent("A", urlFactory.open(server.url("/").url()));
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // Connection is not pooled.
+  }
+
+  @Test public void setChunkedStreamingMode() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse());
+
+    String body = "ABCDEFGHIJKLMNOPQ";
+    connection = urlFactory.open(server.url("/").url());
+    connection.setChunkedStreamingMode(0); // OkHttp does not honor specific chunk sizes.
+    connection.setDoOutput(true);
+    OutputStream outputStream = connection.getOutputStream();
+    outputStream.write(body.getBytes("US-ASCII"));
+    assertEquals(200, connection.getResponseCode());
+    connection.getInputStream().close();
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals(body, request.getBody().readUtf8());
+    assertEquals(Arrays.asList(body.length()), request.getChunkSizes());
+  }
+
+  @Test public void authenticateWithFixedLengthStreaming() throws Exception {
+    testAuthenticateWithStreamingPost(StreamingMode.FIXED_LENGTH);
+  }
+
+  @Test public void authenticateWithChunkedStreaming() throws Exception {
+    testAuthenticateWithStreamingPost(StreamingMode.CHUNKED);
+  }
+
+  private void testAuthenticateWithStreamingPost(StreamingMode streamingMode) throws Exception {
+    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
+        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
+        .setBody("Please authenticate.");
+    server.enqueue(pleaseAuthenticate);
+
+    Authenticator.setDefault(new RecordingAuthenticator());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
+    connection.setDoOutput(true);
+    byte[] requestBody = {'A', 'B', 'C', 'D'};
+    if (streamingMode == StreamingMode.FIXED_LENGTH) {
+      connection.setFixedLengthStreamingMode(requestBody.length);
+    } else if (streamingMode == StreamingMode.CHUNKED) {
+      connection.setChunkedStreamingMode(0);
+    }
+    OutputStream outputStream = connection.getOutputStream();
+    outputStream.write(requestBody);
+    outputStream.close();
+    try {
+      connection.getInputStream();
+      fail();
+    } catch (HttpRetryException expected) {
+    }
+
+    // no authorization header for the request...
+    RecordedRequest request = server.takeRequest();
+    assertNull(request.getHeader("Authorization"));
+    assertEquals("ABCD", request.getBody().readUtf8());
+  }
+
+  @Test public void postBodyRetransmittedAfterAuthorizationFail() throws Exception {
+    postBodyRetransmittedAfterAuthorizationFail("abc");
+  }
+
+  @Test public void postBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    postBodyRetransmittedAfterAuthorizationFail("abc");
+  }
+
+  /** Don't explode when resending an empty post. https://github.com/square/okhttp/issues/1131 */
+  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail() throws Exception {
+    postBodyRetransmittedAfterAuthorizationFail("");
+  }
+
+  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    postBodyRetransmittedAfterAuthorizationFail("");
+  }
+
+  private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(401));
+    server.enqueue(new MockResponse());
+
+    String credential = Credentials.basic("jesse", "secret");
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new RecordingOkAuthenticator(credential))
+        .build());
+
+    connection = urlFactory.open(server.url("/").url());
+    connection.setDoOutput(true);
+    OutputStream outputStream = connection.getOutputStream();
+    outputStream.write(body.getBytes("UTF-8"));
+    outputStream.close();
+    assertEquals(200, connection.getResponseCode());
+    connection.getInputStream().close();
+
+    RecordedRequest recordedRequest1 = server.takeRequest();
+    assertEquals("POST", recordedRequest1.getMethod());
+    assertEquals(body, recordedRequest1.getBody().readUtf8());
+    assertNull(recordedRequest1.getHeader("Authorization"));
+
+    RecordedRequest recordedRequest2 = server.takeRequest();
+    assertEquals("POST", recordedRequest2.getMethod());
+    assertEquals(body, recordedRequest2.getBody().readUtf8());
+    assertEquals(credential, recordedRequest2.getHeader("Authorization"));
+  }
+
+  @Test public void nonStandardAuthenticationScheme() throws Exception {
+    List<String> calls = authCallsForHeader("WWW-Authenticate: Foo");
+    assertEquals(Collections.<String>emptyList(), calls);
+  }
+
+  @Test public void nonStandardAuthenticationSchemeWithRealm() throws Exception {
+    List<String> calls = authCallsForHeader("WWW-Authenticate: Foo realm=\"Bar\"");
+    assertEquals(0, calls.size());
+  }
+
+  // Digest auth is currently unsupported. Test that digest requests should fail reasonably.
+  // http://code.google.com/p/android/issues/detail?id=11140
+  @Test public void digestAuthentication() throws Exception {
+    List<String> calls = authCallsForHeader("WWW-Authenticate: Digest "
+        + "realm=\"testrealm@host.com\", qop=\"auth,auth-int\", "
+        + "nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", "
+        + "opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"");
+    assertEquals(0, calls.size());
+  }
+
+  @Test public void allAttributesSetInServerAuthenticationCallbacks() throws Exception {
+    List<String> calls = authCallsForHeader("WWW-Authenticate: Basic realm=\"Bar\"");
+    assertEquals(1, calls.size());
+    URL url = server.url("/").url();
+    String call = calls.get(0);
+    assertTrue(call, call.contains("host=" + url.getHost()));
+    assertTrue(call, call.contains("port=" + url.getPort()));
+    assertTrue(call, call.contains("site=" + url.getHost()));
+    assertTrue(call, call.contains("url=" + url));
+    assertTrue(call, call.contains("type=" + Authenticator.RequestorType.SERVER));
+    assertTrue(call, call.contains("prompt=Bar"));
+    assertTrue(call, call.contains("protocol=http"));
+    assertTrue(call, call.toLowerCase().contains("scheme=basic")); // lowercase for the RI.
+  }
+
+  @Test public void allAttributesSetInProxyAuthenticationCallbacks() throws Exception {
+    List<String> calls = authCallsForHeader("Proxy-Authenticate: Basic realm=\"Bar\"");
+    assertEquals(1, calls.size());
+    URL url = server.url("/").url();
+    String call = calls.get(0);
+    assertTrue(call, call.contains("host=" + url.getHost()));
+    assertTrue(call, call.contains("port=" + url.getPort()));
+    assertTrue(call, call.contains("site=" + url.getHost()));
+    assertTrue(call, call.contains("url=http://android.com"));
+    assertTrue(call, call.contains("type=" + Authenticator.RequestorType.PROXY));
+    assertTrue(call, call.contains("prompt=Bar"));
+    assertTrue(call, call.contains("protocol=http"));
+    assertTrue(call, call.toLowerCase().contains("scheme=basic")); // lowercase for the RI.
+  }
+
+  private List<String> authCallsForHeader(String authHeader) throws IOException {
+    boolean proxy = authHeader.startsWith("Proxy-");
+    int responseCode = proxy ? 407 : 401;
+    RecordingAuthenticator authenticator = new RecordingAuthenticator(null);
+    Authenticator.setDefault(authenticator);
+    MockResponse pleaseAuthenticate = new MockResponse()
+        .setResponseCode(responseCode)
+        .addHeader(authHeader)
+        .setBody("Please authenticate.");
+    server.enqueue(pleaseAuthenticate);
+
+    if (proxy) {
+      urlFactory.setClient(urlFactory.client().newBuilder()
+          .proxy(server.toProxyAddress())
+          .proxyAuthenticator(new JavaNetAuthenticator())
+          .build());
+      connection = urlFactory.open(new URL("http://android.com/"));
+    } else {
+      urlFactory.setClient(urlFactory.client().newBuilder()
+          .authenticator(new JavaNetAuthenticator())
+          .build());
+      connection = urlFactory.open(server.url("/").url());
+    }
+    assertEquals(responseCode, connection.getResponseCode());
+    connection.getErrorStream().close();
+    return authenticator.calls;
+  }
+
+  @Test public void setValidRequestMethod() throws Exception {
+    assertValidRequestMethod("GET");
+    assertValidRequestMethod("DELETE");
+    assertValidRequestMethod("HEAD");
+    assertValidRequestMethod("OPTIONS");
+    assertValidRequestMethod("POST");
+    assertValidRequestMethod("PUT");
+    assertValidRequestMethod("TRACE");
+    assertValidRequestMethod("PATCH");
+  }
+
+  private void assertValidRequestMethod(String requestMethod) throws Exception {
+    connection = urlFactory.open(server.url("/").url());
+    connection.setRequestMethod(requestMethod);
+    assertEquals(requestMethod, connection.getRequestMethod());
+  }
+
+  @Test public void setInvalidRequestMethodLowercase() throws Exception {
+    assertInvalidRequestMethod("get");
+  }
+
+  @Test public void setInvalidRequestMethodConnect() throws Exception {
+    assertInvalidRequestMethod("CONNECT");
+  }
+
+  private void assertInvalidRequestMethod(String requestMethod) throws Exception {
+    connection = urlFactory.open(server.url("/").url());
+    try {
+      connection.setRequestMethod(requestMethod);
+      fail();
+    } catch (ProtocolException expected) {
+    }
+  }
+
+  @Test public void shoutcast() throws Exception {
+    server.enqueue(new MockResponse().setStatus("ICY 200 OK")
+        // .addHeader("HTTP/1.0 200 OK")
+        .addHeader("Accept-Ranges: none")
+        .addHeader("Content-Type: audio/mpeg")
+        .addHeader("icy-br:128")
+        .addHeader("ice-audio-info: bitrate=128;samplerate=44100;channels=2")
+        .addHeader("icy-br:128")
+        .addHeader("icy-description:Rock")
+        .addHeader("icy-genre:riders")
+        .addHeader("icy-name:A2RRock")
+        .addHeader("icy-pub:1")
+        .addHeader("icy-url:http://www.A2Rradio.com")
+        .addHeader("Server: Icecast 2.3.3-kh8")
+        .addHeader("Cache-Control: no-cache")
+        .addHeader("Pragma: no-cache")
+        .addHeader("Expires: Mon, 26 Jul 1997 05:00:00 GMT")
+        .addHeader("icy-metaint:16000")
+        .setBody("mp3 data"));
+    connection = urlFactory.open(server.url("/").url());
+    assertEquals(200, connection.getResponseCode());
+    assertEquals("OK", connection.getResponseMessage());
+    assertContent("mp3 data", connection);
+  }
+
+  @Test public void cannotSetNegativeFixedLengthStreamingMode() throws Exception {
+    connection = urlFactory.open(server.url("/").url());
+    try {
+      connection.setFixedLengthStreamingMode(-2);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void canSetNegativeChunkedStreamingMode() throws Exception {
+    connection = urlFactory.open(server.url("/").url());
+    connection.setChunkedStreamingMode(-2);
+  }
+
+  @Test public void cannotSetFixedLengthStreamingModeAfterConnect() throws Exception {
+    server.enqueue(new MockResponse().setBody("A"));
+    connection = urlFactory.open(server.url("/").url());
+    assertEquals("A", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+    try {
+      connection.setFixedLengthStreamingMode(1);
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  @Test public void cannotSetChunkedStreamingModeAfterConnect() throws Exception {
+    server.enqueue(new MockResponse().setBody("A"));
+    connection = urlFactory.open(server.url("/").url());
+    assertEquals("A", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+    try {
+      connection.setChunkedStreamingMode(1);
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  @Test public void cannotSetFixedLengthStreamingModeAfterChunkedStreamingMode() throws Exception {
+    connection = urlFactory.open(server.url("/").url());
+    connection.setChunkedStreamingMode(1);
+    try {
+      connection.setFixedLengthStreamingMode(1);
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  @Test public void cannotSetChunkedStreamingModeAfterFixedLengthStreamingMode() throws Exception {
+    connection = urlFactory.open(server.url("/").url());
+    connection.setFixedLengthStreamingMode(1);
+    try {
+      connection.setChunkedStreamingMode(1);
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  @Test public void secureFixedLengthStreaming() throws Exception {
+    testSecureStreamingPost(StreamingMode.FIXED_LENGTH);
+  }
+
+  @Test public void secureChunkedStreaming() throws Exception {
+    testSecureStreamingPost(StreamingMode.CHUNKED);
+  }
+
+  /**
+   * Users have reported problems using HTTPS with streaming request bodies.
+   * http://code.google.com/p/android/issues/detail?id=12860
+   */
+  private void testSecureStreamingPost(StreamingMode streamingMode) throws Exception {
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse().setBody("Success!"));
+
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
+    connection.setDoOutput(true);
+    byte[] requestBody = {'A', 'B', 'C', 'D'};
+    if (streamingMode == StreamingMode.FIXED_LENGTH) {
+      connection.setFixedLengthStreamingMode(requestBody.length);
+    } else if (streamingMode == StreamingMode.CHUNKED) {
+      connection.setChunkedStreamingMode(0);
+    }
+    OutputStream outputStream = connection.getOutputStream();
+    outputStream.write(requestBody);
+    outputStream.close();
+    assertEquals("Success!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("POST / HTTP/1.1", request.getRequestLine());
+    if (streamingMode == StreamingMode.FIXED_LENGTH) {
+      assertEquals(Collections.<Integer>emptyList(), request.getChunkSizes());
+    } else if (streamingMode == StreamingMode.CHUNKED) {
+      assertEquals(Arrays.asList(4), request.getChunkSizes());
+    }
+    assertEquals("ABCD", request.getBody().readUtf8());
+  }
+
+  enum StreamingMode {
+    FIXED_LENGTH, CHUNKED
+  }
+
+  @Test public void authenticateWithPost() throws Exception {
+    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
+        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
+        .setBody("Please authenticate.");
+    // fail auth three times...
+    server.enqueue(pleaseAuthenticate);
+    server.enqueue(pleaseAuthenticate);
+    server.enqueue(pleaseAuthenticate);
+    // ...then succeed the fourth time
+    server.enqueue(new MockResponse().setBody("Successful auth!"));
+
+    Authenticator.setDefault(new RecordingAuthenticator());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
+    connection.setDoOutput(true);
+    byte[] requestBody = {'A', 'B', 'C', 'D'};
+    OutputStream outputStream = connection.getOutputStream();
+    outputStream.write(requestBody);
+    outputStream.close();
+    assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+
+    // no authorization header for the first request...
+    RecordedRequest request = server.takeRequest();
+    assertNull(request.getHeader("Authorization"));
+
+    // ...but the three requests that follow include an authorization header
+    for (int i = 0; i < 3; i++) {
+      request = server.takeRequest();
+      assertEquals("POST / HTTP/1.1", request.getRequestLine());
+      assertEquals("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS,
+          request.getHeader("Authorization"));
+      assertEquals("ABCD", request.getBody().readUtf8());
+    }
+  }
+
+  @Test public void authenticateWithGet() throws Exception {
+    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
+        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
+        .setBody("Please authenticate.");
+    // fail auth three times...
+    server.enqueue(pleaseAuthenticate);
+    server.enqueue(pleaseAuthenticate);
+    server.enqueue(pleaseAuthenticate);
+    // ...then succeed the fourth time
+    server.enqueue(new MockResponse().setBody("Successful auth!"));
+
+    Authenticator.setDefault(new RecordingAuthenticator());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
+    assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+
+    // no authorization header for the first request...
+    RecordedRequest request = server.takeRequest();
+    assertNull(request.getHeader("Authorization"));
+
+    // ...but the three requests that follow requests include an authorization header
+    for (int i = 0; i < 3; i++) {
+      request = server.takeRequest();
+      assertEquals("GET / HTTP/1.1", request.getRequestLine());
+      assertEquals("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS,
+          request.getHeader("Authorization"));
+    }
+  }
+
+  @Test public void authenticateWithCharset() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(401)
+        .addHeader("WWW-Authenticate: Basic realm=\"protected area\", charset=\"UTF-8\"")
+        .setBody("Please authenticate with UTF-8."));
+    server.enqueue(new MockResponse().setResponseCode(401)
+        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
+        .setBody("Please authenticate with ISO-8859-1."));
+    server.enqueue(new MockResponse()
+        .setBody("Successful auth!"));
+
+    Authenticator.setDefault(new RecordingAuthenticator(
+        new PasswordAuthentication("username", "mötorhead".toCharArray())));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
+    assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+
+    // No authorization header for the first request...
+    RecordedRequest request1 = server.takeRequest();
+    assertNull(request1.getHeader("Authorization"));
+
+    // UTF-8 encoding for the first credential.
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals("Basic dXNlcm5hbWU6bcO2dG9yaGVhZA==", request2.getHeader("Authorization"));
+
+    // ISO-8859-1 encoding for the second credential.
+    RecordedRequest request3 = server.takeRequest();
+    assertEquals("Basic dXNlcm5hbWU6bfZ0b3JoZWFk", request3.getHeader("Authorization"));
+  }
+
+  /** https://code.google.com/p/android/issues/detail?id=74026 */
+  @Test public void authenticateWithGetAndTransparentGzip() throws Exception {
+    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
+        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
+        .setBody("Please authenticate.");
+    // fail auth three times...
+    server.enqueue(pleaseAuthenticate);
+    server.enqueue(pleaseAuthenticate);
+    server.enqueue(pleaseAuthenticate);
+    // ...then succeed the fourth time
+    MockResponse successfulResponse = new MockResponse()
+        .addHeader("Content-Encoding", "gzip")
+        .setBody(gzip("Successful auth!"));
+    server.enqueue(successfulResponse);
+
+    Authenticator.setDefault(new RecordingAuthenticator());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
+    assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+
+    // no authorization header for the first request...
+    RecordedRequest request = server.takeRequest();
+    assertNull(request.getHeader("Authorization"));
+
+    // ...but the three requests that follow requests include an authorization header
+    for (int i = 0; i < 3; i++) {
+      request = server.takeRequest();
+      assertEquals("GET / HTTP/1.1", request.getRequestLine());
+      assertEquals("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS,
+          request.getHeader("Authorization"));
+    }
+  }
+
+  /** https://github.com/square/okhttp/issues/342 */
+  @Test public void authenticateRealmUppercase() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(401)
+        .addHeader("wWw-aUtHeNtIcAtE: bAsIc rEaLm=\"pRoTeCtEd aReA\"")
+        .setBody("Please authenticate."));
+    server.enqueue(new MockResponse().setBody("Successful auth!"));
+
+    Authenticator.setDefault(new RecordingAuthenticator());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
+    assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+  }
+
+  @Test public void redirectedWithChunkedEncoding() throws Exception {
+    testRedirected(TransferKind.CHUNKED, true);
+  }
+
+  @Test public void redirectedWithContentLengthHeader() throws Exception {
+    testRedirected(TransferKind.FIXED_LENGTH, true);
+  }
+
+  @Test public void redirectedWithNoLengthHeaders() throws Exception {
+    testRedirected(TransferKind.END_OF_STREAM, false);
+  }
+
+  private void testRedirected(TransferKind transferKind, boolean reuse) throws Exception {
+    MockResponse response = new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: /foo");
+    transferKind.setBody(response, "This page has moved!", 10);
+    server.enqueue(response);
+    server.enqueue(new MockResponse().setBody("This is the new location!"));
+
+    URLConnection connection = urlFactory.open(server.url("/").url());
+    assertEquals("This is the new location!",
+        readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+
+    RecordedRequest first = server.takeRequest();
+    assertEquals("GET / HTTP/1.1", first.getRequestLine());
+    RecordedRequest retry = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", retry.getRequestLine());
+    if (reuse) {
+      assertEquals("Expected connection reuse", 1, retry.getSequenceNumber());
+    }
+  }
+
+  @Test public void redirectedOnHttps() throws IOException, InterruptedException {
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: /foo")
+        .setBody("This page has moved!"));
+    server.enqueue(new MockResponse().setBody("This is the new location!"));
+
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
+    assertEquals("This is the new location!",
+        readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+
+    RecordedRequest first = server.takeRequest();
+    assertEquals("GET / HTTP/1.1", first.getRequestLine());
+    RecordedRequest retry = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", retry.getRequestLine());
+    assertEquals("Expected connection reuse", 1, retry.getSequenceNumber());
+  }
+
+  @Test public void notRedirectedFromHttpsToHttp() throws IOException, InterruptedException {
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: http://anyhost/foo")
+        .setBody("This page has moved!"));
+
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .followSslRedirects(false)
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
+    assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+  }
+
+  @Test public void notRedirectedFromHttpToHttps() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: https://anyhost/foo")
+        .setBody("This page has moved!"));
+
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .followSslRedirects(false)
+        .build());
+    connection = urlFactory.open(server.url("/").url());
+    assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+  }
+
+  @Test public void redirectedFromHttpsToHttpFollowingProtocolRedirects() throws Exception {
+    server2.enqueue(new MockResponse().setBody("This is insecure HTTP!"));
+
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: " + server2.url("/").url())
+        .setBody("This page has moved!"));
+
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .followSslRedirects(true)
+        .build());
+    HttpsURLConnection connection = (HttpsURLConnection) urlFactory.open(server.url("/").url());
+    assertContent("This is insecure HTTP!", connection);
+    assertNull(connection.getCipherSuite());
+    assertNull(connection.getLocalCertificates());
+    assertNull(connection.getServerCertificates());
+    assertNull(connection.getPeerPrincipal());
+    assertNull(connection.getLocalPrincipal());
+  }
+
+  @Test public void redirectedFromHttpToHttpsFollowingProtocolRedirects() throws Exception {
+    server2.useHttps(sslClient.socketFactory, false);
+    server2.enqueue(new MockResponse().setBody("This is secure HTTPS!"));
+
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: " + server2.url("/").url())
+        .setBody("This page has moved!"));
+
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .followSslRedirects(true)
+        .build());
+    connection = urlFactory.open(server.url("/").url());
+    assertContent("This is secure HTTPS!", connection);
+    assertFalse(connection instanceof HttpsURLConnection);
+  }
+
+  @Test public void redirectToAnotherOriginServer() throws Exception {
+    redirectToAnotherOriginServer(false);
+  }
+
+  @Test public void redirectToAnotherOriginServerWithHttps() throws Exception {
+    redirectToAnotherOriginServer(true);
+  }
+
+  private void redirectToAnotherOriginServer(boolean https) throws Exception {
+    if (https) {
+      server.useHttps(sslClient.socketFactory, false);
+      server2.useHttps(sslClient.socketFactory, false);
+      server2.setProtocolNegotiationEnabled(false);
+      urlFactory.setClient(urlFactory.client().newBuilder()
+          .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+          .hostnameVerifier(new RecordingHostnameVerifier())
+          .build());
+    }
+
+    server2.enqueue(new MockResponse().setBody("This is the 2nd server!"));
+    server2.enqueue(new MockResponse().setBody("This is the 2nd server, again!"));
+
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: " + server2.url("/").url().toString())
+        .setBody("This page has moved!"));
+    server.enqueue(new MockResponse().setBody("This is the first server again!"));
+
+    connection = urlFactory.open(server.url("/").url());
+    assertContent("This is the 2nd server!", connection);
+    assertEquals(server2.url("/").url(), connection.getURL());
+
+    // make sure the first server was careful to recycle the connection
+    assertContent("This is the first server again!", urlFactory.open(server.url("/").url()));
+    assertContent("This is the 2nd server, again!", urlFactory.open(server2.url("/").url()));
+
+    String server1Host = server.getHostName() + ":" + server.getPort();
+    String server2Host = server2.getHostName() + ":" + server2.getPort();
+    assertEquals(server1Host, server.takeRequest().getHeader("Host"));
+    assertEquals(server2Host, server2.takeRequest().getHeader("Host"));
+    assertEquals("Expected connection reuse", 1, server.takeRequest().getSequenceNumber());
+    assertEquals("Expected connection reuse", 1, server2.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void redirectWithProxySelector() throws Exception {
+    final List<URI> proxySelectionRequests = new ArrayList<>();
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .proxySelector(new ProxySelector() {
+          @Override public List<Proxy> select(URI uri) {
+            proxySelectionRequests.add(uri);
+            MockWebServer proxyServer = (uri.getPort() == server.getPort())
+                ? server
+                : server2;
+            return Arrays.asList(proxyServer.toProxyAddress());
+          }
+
+          @Override public void connectFailed(URI uri, SocketAddress address, IOException failure) {
+            throw new AssertionError();
+          }
+        })
+        .build());
+
+    server2.enqueue(new MockResponse().setBody("This is the 2nd server!"));
+
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: " + server2.url("/b").url().toString())
+        .setBody("This page has moved!"));
+
+    assertContent("This is the 2nd server!", urlFactory.open(server.url("/a").url()));
+
+    assertEquals(Arrays.asList(server.url("/").url().toURI(), server2.url("/").url().toURI()),
+        proxySelectionRequests);
+  }
+
+  @Test public void redirectWithAuthentication() throws Exception {
+    server2.enqueue(new MockResponse().setBody("Page 2"));
+
+    server.enqueue(new MockResponse().setResponseCode(401));
+    server.enqueue(new MockResponse().setResponseCode(302)
+        .addHeader("Location: " + server2.url("/b").url()));
+
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new RecordingOkAuthenticator(Credentials.basic("jesse", "secret")))
+        .build());
+    assertContent("Page 2", urlFactory.open(server.url("/a").url()));
+
+    RecordedRequest redirectRequest = server2.takeRequest();
+    assertNull(redirectRequest.getHeader("Authorization"));
+    assertEquals("/b", redirectRequest.getPath());
+  }
+
+  @Test public void response300MultipleChoiceWithPost() throws Exception {
+    // Chrome doesn't follow the redirect, but Firefox and the RI both do
+    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MULT_CHOICE, TransferKind.END_OF_STREAM);
+  }
+
+  @Test public void response301MovedPermanentlyWithPost() throws Exception {
+    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_PERM, TransferKind.END_OF_STREAM);
+  }
+
+  @Test public void response302MovedTemporarilyWithPost() throws Exception {
+    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_TEMP, TransferKind.END_OF_STREAM);
+  }
+
+  @Test public void response303SeeOtherWithPost() throws Exception {
+    testResponseRedirectedWithPost(HttpURLConnection.HTTP_SEE_OTHER, TransferKind.END_OF_STREAM);
+  }
+
+  @Test public void postRedirectToGetWithChunkedRequest() throws Exception {
+    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_TEMP, TransferKind.CHUNKED);
+  }
+
+  @Test public void postRedirectToGetWithStreamedRequest() throws Exception {
+    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_TEMP, TransferKind.FIXED_LENGTH);
+  }
+
+  private void testResponseRedirectedWithPost(int redirectCode, TransferKind transferKind)
+      throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(redirectCode)
+        .addHeader("Location: /page2")
+        .setBody("This page has moved!"));
+    server.enqueue(new MockResponse().setBody("Page 2"));
+
+    connection = urlFactory.open(server.url("/page1").url());
+    connection.setDoOutput(true);
+    transferKind.setForRequest(connection, 4);
+    byte[] requestBody = {'A', 'B', 'C', 'D'};
+    OutputStream outputStream = connection.getOutputStream();
+    outputStream.write(requestBody);
+    outputStream.close();
+    assertEquals("Page 2", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+    assertTrue(connection.getDoOutput());
+
+    RecordedRequest page1 = server.takeRequest();
+    assertEquals("POST /page1 HTTP/1.1", page1.getRequestLine());
+    assertEquals("ABCD", page1.getBody().readUtf8());
+
+    RecordedRequest page2 = server.takeRequest();
+    assertEquals("GET /page2 HTTP/1.1", page2.getRequestLine());
+  }
+
+  @Test public void redirectedPostStripsRequestBodyHeaders() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: /page2"));
+    server.enqueue(new MockResponse().setBody("Page 2"));
+
+    connection = urlFactory.open(server.url("/page1").url());
+    connection.setDoOutput(true);
+    connection.addRequestProperty("Content-Length", "4");
+    connection.addRequestProperty("Content-Type", "text/plain; charset=utf-8");
+    connection.addRequestProperty("Transfer-Encoding", "identity");
+    OutputStream outputStream = connection.getOutputStream();
+    outputStream.write("ABCD".getBytes("UTF-8"));
+    outputStream.close();
+    assertEquals("Page 2", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+
+    assertEquals("POST /page1 HTTP/1.1", server.takeRequest().getRequestLine());
+
+    RecordedRequest page2 = server.takeRequest();
+    assertEquals("GET /page2 HTTP/1.1", page2.getRequestLine());
+    assertNull(page2.getHeader("Content-Length"));
+    assertNull(page2.getHeader("Content-Type"));
+    assertNull(page2.getHeader("Transfer-Encoding"));
+  }
+
+  @Test public void response305UseProxy() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_USE_PROXY)
+        .addHeader("Location: " + server.url("/").url())
+        .setBody("This page has moved!"));
+    server.enqueue(new MockResponse().setBody("Proxy Response"));
+
+    connection = urlFactory.open(server.url("/foo").url());
+    // Fails on the RI, which gets "Proxy Response"
+    assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+
+    RecordedRequest page1 = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", page1.getRequestLine());
+    assertEquals(1, server.getRequestCount());
+  }
+
+  @Test public void response307WithGet() throws Exception {
+    testRedirect(true, "GET");
+  }
+
+  @Test public void response307WithHead() throws Exception {
+    testRedirect(true, "HEAD");
+  }
+
+  @Test public void response307WithOptions() throws Exception {
+    testRedirect(true, "OPTIONS");
+  }
+
+  @Test public void response307WithPost() throws Exception {
+    testRedirect(true, "POST");
+  }
+
+  @Test public void response308WithGet() throws Exception {
+    testRedirect(false, "GET");
+  }
+
+  @Test public void response308WithHead() throws Exception {
+    testRedirect(false, "HEAD");
+  }
+
+  @Test public void response308WithOptions() throws Exception {
+    testRedirect(false, "OPTIONS");
+  }
+
+  @Test public void response308WithPost() throws Exception {
+    testRedirect(false, "POST");
+  }
+
+  private void testRedirect(boolean temporary, String method) throws Exception {
+    MockResponse response1 = new MockResponse()
+        .setResponseCode(temporary ? HTTP_TEMP_REDIRECT : HTTP_PERM_REDIRECT)
+        .addHeader("Location: /page2");
+    if (!method.equals("HEAD")) {
+      response1.setBody("This page has moved!");
+    }
+    server.enqueue(response1);
+    server.enqueue(new MockResponse().setBody("Page 2"));
+
+    connection = urlFactory.open(server.url("/page1").url());
+    connection.setRequestMethod(method);
+    byte[] requestBody = {'A', 'B', 'C', 'D'};
+    if (method.equals("POST")) {
+      connection.setDoOutput(true);
+      OutputStream outputStream = connection.getOutputStream();
+      outputStream.write(requestBody);
+      outputStream.close();
+    }
+
+    String response = readAscii(connection.getInputStream(), Integer.MAX_VALUE);
+
+    RecordedRequest page1 = server.takeRequest();
+    assertEquals(method + " /page1 HTTP/1.1", page1.getRequestLine());
+
+    if (method.equals("GET")) {
+      assertEquals("Page 2", response);
+    } else if (method.equals("HEAD")) {
+      assertEquals("", response);
+    } else {
+      // Methods other than GET/HEAD shouldn't follow the redirect
+      if (method.equals("POST")) {
+        assertTrue(connection.getDoOutput());
+        assertEquals("ABCD", page1.getBody().readUtf8());
+      }
+      assertEquals(1, server.getRequestCount());
+      assertEquals("This page has moved!", response);
+      return;
+    }
+
+    // GET/HEAD requests should have followed the redirect with the same method
+    assertFalse(connection.getDoOutput());
+    assertEquals(2, server.getRequestCount());
+    RecordedRequest page2 = server.takeRequest();
+    assertEquals(method + " /page2 HTTP/1.1", page2.getRequestLine());
+  }
+
+  @Test public void follow20Redirects() throws Exception {
+    for (int i = 0; i < 20; i++) {
+      server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+          .addHeader("Location: /" + (i + 1))
+          .setBody("Redirecting to /" + (i + 1)));
+    }
+    server.enqueue(new MockResponse().setBody("Success!"));
+
+    connection = urlFactory.open(server.url("/0").url());
+    assertContent("Success!", connection);
+    assertEquals(server.url("/20").url(), connection.getURL());
+  }
+
+  @Test public void doesNotFollow21Redirects() throws Exception {
+    for (int i = 0; i < 21; i++) {
+      server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+          .addHeader("Location: /" + (i + 1))
+          .setBody("Redirecting to /" + (i + 1)));
+    }
+
+    connection = urlFactory.open(server.url("/0").url());
+    try {
+      connection.getInputStream();
+      fail();
+    } catch (ProtocolException expected) {
+      assertEquals(HttpURLConnection.HTTP_MOVED_TEMP, connection.getResponseCode());
+      assertEquals("Too many follow-up requests: 21", expected.getMessage());
+      assertEquals(server.url("/20").url(), connection.getURL());
+    }
+  }
+
+  @Test public void httpsWithCustomTrustManager() throws Exception {
+    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+    RecordingTrustManager trustManager = new RecordingTrustManager(sslClient.trustManager);
+    SSLContext sslContext = SSLContext.getInstance("TLS");
+    sslContext.init(null, new TrustManager[] { trustManager }, null);
+
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .hostnameVerifier(hostnameVerifier)
+        .sslSocketFactory(sslContext.getSocketFactory(), trustManager)
+        .build());
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse().setBody("ABC"));
+    server.enqueue(new MockResponse().setBody("DEF"));
+    server.enqueue(new MockResponse().setBody("GHI"));
+
+    URL url = server.url("/").url();
+    assertContent("ABC", urlFactory.open(url));
+    assertContent("DEF", urlFactory.open(url));
+    assertContent("GHI", urlFactory.open(url));
+
+    assertEquals(Arrays.asList("verify " + server.getHostName()), hostnameVerifier.calls);
+    assertEquals(Arrays.asList("checkServerTrusted [CN=" + server.getHostName() + " 1]"),
+        trustManager.calls);
+  }
+
+  @Test public void getClientRequestTimeout() throws Exception {
+    enqueueClientRequestTimeoutResponses();
+
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
+
+    assertEquals(200, connection.getResponseCode());
+    assertEquals("Body", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+  }
+
+  private void enqueueClientRequestTimeoutResponses() {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setResponseCode(HttpURLConnection.HTTP_CLIENT_TIMEOUT)
+        .setHeader("Connection", "Close")
+        .setBody("You took too long!"));
+    server.enqueue(new MockResponse().setBody("Body"));
+  }
+
+  @Test public void bufferedBodyWithClientRequestTimeout() throws Exception {
+    enqueueClientRequestTimeoutResponses();
+
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
+    connection.setRequestMethod("POST");
+    connection.getOutputStream().write("Hello".getBytes("UTF-8"));
+
+    assertEquals(200, connection.getResponseCode());
+    assertEquals("Body", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+
+    RecordedRequest request1 = server.takeRequest();
+    assertEquals("Hello", request1.getBody().readUtf8());
+
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals("Hello", request2.getBody().readUtf8());
+  }
+
+  @Test public void streamedBodyWithClientRequestTimeout() throws Exception {
+    enqueueClientRequestTimeoutResponses();
+
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
+    connection.setRequestMethod("POST");
+    connection.setChunkedStreamingMode(0);
+    connection.getOutputStream().write("Hello".getBytes("UTF-8"));
+
+    assertEquals(408, connection.getResponseCode());
+    assertEquals(1, server.getRequestCount());
+    connection.getErrorStream().close();
+  }
+
+  @Test public void readTimeouts() throws IOException {
+    // This relies on the fact that MockWebServer doesn't close the
+    // connection after a response has been sent. This causes the client to
+    // try to read more bytes than are sent, which results in a timeout.
+    MockResponse timeout =
+        new MockResponse().setBody("ABC").clearHeaders().addHeader("Content-Length: 4");
+    server.enqueue(timeout);
+    server.enqueue(new MockResponse().setBody("unused")); // to keep the server alive
+
+    URLConnection connection = urlFactory.open(server.url("/").url());
+    connection.setReadTimeout(1000);
+    InputStream in = connection.getInputStream();
+    assertEquals('A', in.read());
+    assertEquals('B', in.read());
+    assertEquals('C', in.read());
+    try {
+      in.read(); // if Content-Length was accurate, this would return -1 immediately
+      fail();
+    } catch (SocketTimeoutException expected) {
+    }
+    in.close();
+  }
+
+  /** Confirm that an unacknowledged write times out. */
+  @Test public void writeTimeouts() throws IOException {
+    MockWebServer server = new MockWebServer();
+    // Sockets on some platforms can have large buffers that mean writes do not block when
+    // required. These socket factories explicitly set the buffer sizes on sockets created.
+    final int SOCKET_BUFFER_SIZE = 4 * 1024;
+    server.setServerSocketFactory(
+        new DelegatingServerSocketFactory(ServerSocketFactory.getDefault()) {
+          @Override
+          protected ServerSocket configureServerSocket(ServerSocket serverSocket)
+              throws IOException {
+            serverSocket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
+            return serverSocket;
+          }
+        });
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .socketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
+          @Override protected Socket configureSocket(Socket socket) throws IOException {
+            socket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
+            socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
+            return socket;
+          }
+        })
+        .writeTimeout(500, TimeUnit.MILLISECONDS)
+        .build());
+
+    server.start();
+    server.enqueue(new MockResponse()
+        .throttleBody(1, 1, TimeUnit.SECONDS)); // Prevent the server from reading!
+
+    connection = urlFactory.open(server.url("/").url());
+    connection.setDoOutput(true);
+    connection.setChunkedStreamingMode(0);
+    OutputStream out = connection.getOutputStream();
+    try {
+      byte[] data = new byte[2 * 1024 * 1024]; // 2 MiB.
+      out.write(data);
+      fail();
+    } catch (SocketTimeoutException expected) {
+    }
+  }
+
+  @Test public void setChunkedEncodingAsRequestProperty() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse());
+
+    connection = urlFactory.open(server.url("/").url());
+    connection.setRequestProperty("Transfer-encoding", "chunked");
+    connection.setDoOutput(true);
+    connection.getOutputStream().write("ABC".getBytes("UTF-8"));
+    assertEquals(200, connection.getResponseCode());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("ABC", request.getBody().readUtf8());
+  }
+
+  @Test public void connectionCloseInRequest() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse()); // server doesn't honor the connection: close header!
+    server.enqueue(new MockResponse());
+
+    HttpURLConnection a = urlFactory.open(server.url("/").url());
+    a.setRequestProperty("Connection", "close");
+    assertEquals(200, a.getResponseCode());
+
+    HttpURLConnection b = urlFactory.open(server.url("/").url());
+    assertEquals(200, b.getResponseCode());
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals("When connection: close is used, each request should get its own connection", 0,
+        server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void connectionCloseInResponse() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().addHeader("Connection: close"));
+    server.enqueue(new MockResponse());
+
+    HttpURLConnection a = urlFactory.open(server.url("/").url());
+    assertEquals(200, a.getResponseCode());
+
+    HttpURLConnection b = urlFactory.open(server.url("/").url());
+    assertEquals(200, b.getResponseCode());
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals("When connection: close is used, each request should get its own connection", 0,
+        server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void connectionCloseWithRedirect() throws IOException, InterruptedException {
+    MockResponse response = new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: /foo")
+        .addHeader("Connection: close");
+    server.enqueue(response);
+    server.enqueue(new MockResponse()
+        .setBody("This is the new location!"));
+
+    URLConnection connection = urlFactory.open(server.url("/").url());
+    assertEquals("This is the new location!",
+        readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals("When connection: close is used, each request should get its own connection", 0,
+        server.takeRequest().getSequenceNumber());
+  }
+
+  /**
+   * Retry redirects if the socket is closed.
+   * https://code.google.com/p/android/issues/detail?id=41576
+   */
+  @Test public void sameConnectionRedirectAndReuse() throws Exception {
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .dns(new SingleInetAddressDns())
+        .build());
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .setSocketPolicy(SHUTDOWN_INPUT_AT_END)
+        .addHeader("Location: /foo"));
+    server.enqueue(new MockResponse()
+        .setBody("This is the new page!"));
+
+    assertContent("This is the new page!", urlFactory.open(server.url("/").url()));
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void responseCodeDisagreesWithHeaders() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NO_CONTENT)
+        .setBody("This body is not allowed!"));
+
+    URLConnection connection = urlFactory.open(server.url("/").url());
+    try {
+      connection.getInputStream();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("HTTP 204 had non-zero Content-Length: 25", expected.getMessage());
+    }
+  }
+
+  @Test public void singleByteReadIsSigned() throws IOException {
+    server.enqueue(new MockResponse().setBody(new Buffer().writeByte(-2).writeByte(-1)));
+
+    connection = urlFactory.open(server.url("/").url());
+    InputStream in = connection.getInputStream();
+    assertEquals(254, in.read());
+    assertEquals(255, in.read());
+    assertEquals(-1, in.read());
+  }
+
+  @Test public void flushAfterStreamTransmittedWithChunkedEncoding() throws IOException {
+    testFlushAfterStreamTransmitted(TransferKind.CHUNKED);
+  }
+
+  @Test public void flushAfterStreamTransmittedWithFixedLength() throws IOException {
+    testFlushAfterStreamTransmitted(TransferKind.FIXED_LENGTH);
+  }
+
+  @Test public void flushAfterStreamTransmittedWithNoLengthHeaders() throws IOException {
+    testFlushAfterStreamTransmitted(TransferKind.END_OF_STREAM);
+  }
+
+  /**
+   * We explicitly permit apps to close the upload stream even after it has been transmitted.  We
+   * also permit flush so that buffered streams can do a no-op flush when they are closed.
+   * http://b/3038470
+   */
+  private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws IOException {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    connection = urlFactory.open(server.url("/").url());
+    connection.setDoOutput(true);
+    byte[] upload = "def".getBytes("UTF-8");
+
+    if (transferKind == TransferKind.CHUNKED) {
+      connection.setChunkedStreamingMode(0);
+    } else if (transferKind == TransferKind.FIXED_LENGTH) {
+      connection.setFixedLengthStreamingMode(upload.length);
+    }
+
+    OutputStream out = connection.getOutputStream();
+    out.write(upload);
+    assertEquals("abc", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+
+    out.flush(); // Dubious but permitted.
+    try {
+      out.write("ghi".getBytes("UTF-8"));
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void getHeadersThrows() throws IOException {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AT_START));
+
+    connection = urlFactory.open(server.url("/").url());
+    try {
+      connection.getInputStream();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    try {
+      connection.getInputStream();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void dnsFailureThrowsIOException() throws IOException {
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .dns(new FakeDns())
+        .build());
+    connection = urlFactory.open(new URL("http://host.unlikelytld"));
+    try {
+      connection.connect();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void malformedUrlThrowsUnknownHostException() throws IOException {
+    connection = urlFactory.open(new URL("http://./foo.html"));
+    try {
+      connection.connect();
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+  }
+
+  @Test public void getKeepAlive() throws Exception {
+    server.enqueue(new MockResponse().setBody("ABC"));
+
+    // The request should work once and then fail
+    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
+    connection1.setReadTimeout(100);
+    InputStream input = connection1.getInputStream();
+    assertEquals("ABC", readAscii(input, Integer.MAX_VALUE));
+    server.shutdown();
+    try {
+      HttpURLConnection connection2 = urlFactory.open(server.url("").url());
+      connection2.setReadTimeout(100);
+      connection2.getInputStream();
+      fail();
+    } catch (ConnectException expected) {
+    }
+  }
+
+  /** http://code.google.com/p/android/issues/detail?id=14562 */
+  @Test public void readAfterLastByte() throws Exception {
+    server.enqueue(new MockResponse().setBody("ABC")
+        .clearHeaders()
+        .addHeader("Connection: close")
+        .setSocketPolicy(DISCONNECT_AT_END));
+
+    connection = urlFactory.open(server.url("/").url());
+    InputStream in = connection.getInputStream();
+    assertEquals("ABC", readAscii(in, 3));
+    assertEquals(-1, in.read());
+    assertEquals(-1, in.read()); // throws IOException in Gingerbread
+  }
+
+  @Test public void getContent() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("A"));
+    connection = urlFactory.open(server.url("/").url());
+    InputStream in = (InputStream) connection.getContent();
+    assertEquals("A", readAscii(in, Integer.MAX_VALUE));
+  }
+
+  @Test public void getContentOfType() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("A"));
+    connection = urlFactory.open(server.url("/").url());
+    try {
+      connection.getContent(null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+    try {
+      connection.getContent(new Class[] {null});
+      fail();
+    } catch (NullPointerException expected) {
+    }
+    assertNull(connection.getContent(new Class[] {getClass()}));
+    connection.getInputStream().close();
+  }
+
+  @Test public void getOutputStreamOnGetFails() throws Exception {
+    server.enqueue(new MockResponse());
+    connection = urlFactory.open(server.url("/").url());
+    try {
+      connection.getOutputStream();
+      fail();
+    } catch (ProtocolException expected) {
+    }
+    connection.getInputStream().close();
+  }
+
+  @Test public void getOutputAfterGetInputStreamFails() throws Exception {
+    server.enqueue(new MockResponse());
+    connection = urlFactory.open(server.url("/").url());
+    connection.setDoOutput(true);
+    try {
+      connection.getInputStream();
+      connection.getOutputStream();
+      fail();
+    } catch (ProtocolException expected) {
+    }
+  }
+
+  @Test public void setDoOutputOrDoInputAfterConnectFails() throws Exception {
+    server.enqueue(new MockResponse());
+    connection = urlFactory.open(server.url("/").url());
+    connection.connect();
+    try {
+      connection.setDoOutput(true);
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+    try {
+      connection.setDoInput(true);
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+    connection.getInputStream().close();
+  }
+
+  @Test public void clientSendsContentLength() throws Exception {
+    server.enqueue(new MockResponse().setBody("A"));
+    connection = urlFactory.open(server.url("/").url());
+    connection.setDoOutput(true);
+    OutputStream out = connection.getOutputStream();
+    out.write(new byte[] {'A', 'B', 'C'});
+    out.close();
+    assertEquals("A", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+    RecordedRequest request = server.takeRequest();
+    assertEquals("3", request.getHeader("Content-Length"));
+    connection.getInputStream().close();
+  }
+
+  @Test public void getContentLengthConnects() throws Exception {
+    server.enqueue(new MockResponse().setBody("ABC"));
+    connection = urlFactory.open(server.url("/").url());
+    assertEquals(3, connection.getContentLength());
+    connection.getInputStream().close();
+  }
+
+  @Test public void getContentTypeConnects() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("ABC"));
+    connection = urlFactory.open(server.url("/").url());
+    assertEquals("text/plain", connection.getContentType());
+    connection.getInputStream().close();
+  }
+
+  @Test public void getContentEncodingConnects() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Content-Encoding: identity").setBody("ABC"));
+    connection = urlFactory.open(server.url("/").url());
+    assertEquals("identity", connection.getContentEncoding());
+    connection.getInputStream().close();
+  }
+
+  // http://b/4361656
+  @Test public void urlContainsQueryButNoPath() throws Exception {
+    server.enqueue(new MockResponse().setBody("A"));
+
+    URL url = new URL("http", server.getHostName(), server.getPort(), "?query");
+    assertEquals("A", readAscii(urlFactory.open(url).getInputStream(), Integer.MAX_VALUE));
+    RecordedRequest request = server.takeRequest();
+    assertEquals("GET /?query HTTP/1.1", request.getRequestLine());
+  }
+
+  @Test public void doOutputForMethodThatDoesntSupportOutput() throws Exception {
+    connection = urlFactory.open(server.url("/").url());
+    connection.setRequestMethod("HEAD");
+    connection.setDoOutput(true);
+    try {
+      connection.connect();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  // http://code.google.com/p/android/issues/detail?id=20442
+  @Test public void inputStreamAvailableWithChunkedEncoding() throws Exception {
+    testInputStreamAvailable(TransferKind.CHUNKED);
+  }
+
+  @Test public void inputStreamAvailableWithContentLengthHeader() throws Exception {
+    testInputStreamAvailable(TransferKind.FIXED_LENGTH);
+  }
+
+  @Test public void inputStreamAvailableWithNoLengthHeaders() throws Exception {
+    testInputStreamAvailable(TransferKind.END_OF_STREAM);
+  }
+
+  private void testInputStreamAvailable(TransferKind transferKind) throws IOException {
+    String body = "ABCDEFGH";
+    MockResponse response = new MockResponse();
+    transferKind.setBody(response, body, 4);
+    server.enqueue(response);
+    connection = urlFactory.open(server.url("/").url());
+    InputStream in = connection.getInputStream();
+    for (int i = 0; i < body.length(); i++) {
+      assertTrue(in.available() >= 0);
+      assertEquals(body.charAt(i), in.read());
+    }
+    assertEquals(0, in.available());
+    assertEquals(-1, in.read());
+  }
+
+  @Test public void postFailsWithBufferedRequestForSmallRequest() throws Exception {
+    reusedConnectionFailsWithPost(TransferKind.END_OF_STREAM, 1024);
+  }
+
+  @Test public void postFailsWithBufferedRequestForLargeRequest() throws Exception {
+    reusedConnectionFailsWithPost(TransferKind.END_OF_STREAM, 16384);
+  }
+
+  @Test public void postFailsWithChunkedRequestForSmallRequest() throws Exception {
+    reusedConnectionFailsWithPost(TransferKind.CHUNKED, 1024);
+  }
+
+  @Test public void postFailsWithChunkedRequestForLargeRequest() throws Exception {
+    reusedConnectionFailsWithPost(TransferKind.CHUNKED, 16384);
+  }
+
+  @Test public void postFailsWithFixedLengthRequestForSmallRequest() throws Exception {
+    reusedConnectionFailsWithPost(TransferKind.FIXED_LENGTH, 1024);
+  }
+
+  @Test public void postFailsWithFixedLengthRequestForLargeRequest() throws Exception {
+    reusedConnectionFailsWithPost(TransferKind.FIXED_LENGTH, 16384);
+  }
+
+  private void reusedConnectionFailsWithPost(TransferKind transferKind, int requestSize)
+      throws Exception {
+    server.enqueue(new MockResponse().setBody("A").setSocketPolicy(DISCONNECT_AT_END));
+    server.enqueue(new MockResponse().setBody("B"));
+    server.enqueue(new MockResponse().setBody("C"));
+
+    assertContent("A", urlFactory.open(server.url("/a").url()));
+
+    // Give the server time to disconnect.
+    Thread.sleep(500);
+
+    // If the request body is larger than OkHttp's replay buffer, the failure may still occur.
+    byte[] requestBody = new byte[requestSize];
+    new Random(0).nextBytes(requestBody);
+
+    for (int j = 0; j < 2; j++) {
+      try {
+        connection = urlFactory.open(server.url("/b").url());
+        connection.setRequestMethod("POST");
+        transferKind.setForRequest(connection, requestBody.length);
+        for (int i = 0; i < requestBody.length; i += 1024) {
+          connection.getOutputStream().write(requestBody, i, 1024);
+        }
+        connection.getOutputStream().close();
+        assertContent("B", connection);
+        break;
+      } catch (IOException socketException) {
+        // If there's a socket exception, this must have a streamed request body.
+        assertEquals(0, j);
+        assertTrue(transferKind == TransferKind.CHUNKED
+            || transferKind == TransferKind.FIXED_LENGTH);
+      }
+    }
+
+    RecordedRequest requestA = server.takeRequest();
+    assertEquals("/a", requestA.getPath());
+    RecordedRequest requestB = server.takeRequest();
+    assertEquals("/b", requestB.getPath());
+    assertEquals(Arrays.toString(requestBody), Arrays.toString(requestB.getBody().readByteArray()));
+  }
+
+  @Test public void postBodyRetransmittedOnFailureRecovery() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+    server.enqueue(new MockResponse().setBody("def"));
+
+    // Seed the connection pool so we have something that can fail.
+    assertContent("abc", urlFactory.open(server.url("/").url()));
+
+    HttpURLConnection post = urlFactory.open(server.url("/").url());
+    post.setDoOutput(true);
+    post.getOutputStream().write("body!".getBytes(UTF_8));
+    assertContent("def", post);
+
+    RecordedRequest get = server.takeRequest();
+    assertEquals(0, get.getSequenceNumber());
+
+    RecordedRequest post1 = server.takeRequest();
+    assertEquals("body!", post1.getBody().readUtf8());
+    assertEquals(1, post1.getSequenceNumber());
+
+    RecordedRequest post2 = server.takeRequest();
+    assertEquals("body!", post2.getBody().readUtf8());
+    assertEquals(0, post2.getSequenceNumber());
+  }
+
+  @Test public void fullyBufferedPostIsTooShort() throws Exception {
+    server.enqueue(new MockResponse().setBody("A"));
+
+    connection = urlFactory.open(server.url("/b").url());
+    connection.setRequestProperty("Content-Length", "4");
+    connection.setRequestMethod("POST");
+    OutputStream out = connection.getOutputStream();
+    out.write('a');
+    out.write('b');
+    out.write('c');
+    try {
+      out.close();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void fullyBufferedPostIsTooLong() throws Exception {
+    server.enqueue(new MockResponse().setBody("A"));
+
+    connection = urlFactory.open(server.url("/b").url());
+    connection.setRequestProperty("Content-Length", "3");
+    connection.setRequestMethod("POST");
+    OutputStream out = connection.getOutputStream();
+    out.write('a');
+    out.write('b');
+    out.write('c');
+    try {
+      out.write('d');
+      out.flush();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test @Ignore public void testPooledConnectionsDetectHttp10() {
+    // TODO: write a test that shows pooled connections detect HTTP/1.0 (vs. HTTP/1.1)
+    fail("TODO");
+  }
+
+  @Test @Ignore public void postBodiesRetransmittedOnAuthProblems() {
+    fail("TODO");
+  }
+
+  @Test @Ignore public void cookiesAndTrailers() {
+    // Do cookie headers get processed too many times?
+    fail("TODO");
+  }
+
+  @Test public void emptyRequestHeaderValueIsAllowed() throws Exception {
+    server.enqueue(new MockResponse().setBody("body"));
+    connection = urlFactory.open(server.url("/").url());
+    connection.addRequestProperty("B", "");
+    assertContent("body", connection);
+    assertEquals("", connection.getRequestProperty("B"));
+  }
+
+  @Test public void emptyResponseHeaderValueIsAllowed() throws Exception {
+    server.enqueue(new MockResponse().addHeader("A:").setBody("body"));
+    connection = urlFactory.open(server.url("/").url());
+    assertContent("body", connection);
+    assertEquals("", connection.getHeaderField("A"));
+  }
+
+  @Test public void emptyRequestHeaderNameIsStrict() throws Exception {
+    server.enqueue(new MockResponse().setBody("body"));
+    connection = urlFactory.open(server.url("/").url());
+    try {
+      connection.setRequestProperty("", "A");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void emptyResponseHeaderNameIsLenient() throws Exception {
+    Headers.Builder headers = new Headers.Builder();
+    Internal.instance.addLenient(headers, ":A");
+    server.enqueue(new MockResponse().setHeaders(headers.build()).setBody("body"));
+    connection = urlFactory.open(server.url("/").url());
+    connection.getResponseCode();
+    assertEquals("A", connection.getHeaderField(""));
+    connection.getInputStream().close();
+  }
+
+  @Test public void requestHeaderValidationIsStrict() throws Exception {
+    connection = urlFactory.open(server.url("/").url());
+    try {
+      connection.addRequestProperty("a\tb", "Value");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      connection.addRequestProperty("Name", "c\u007fd");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      connection.addRequestProperty("", "Value");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      connection.addRequestProperty("\ud83c\udf69", "Value");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      connection.addRequestProperty("Name", "\u2615\ufe0f");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void responseHeaderParsingIsLenient() throws Exception {
+    Headers headers = new Headers.Builder()
+        .add("Content-Length", "0")
+        .addLenient("a\tb: c\u007fd")
+        .addLenient(": ef")
+        .addLenient("\ud83c\udf69: \u2615\ufe0f")
+        .build();
+    server.enqueue(new MockResponse().setHeaders(headers));
+
+    connection = urlFactory.open(server.url("/").url());
+    connection.getResponseCode();
+    assertEquals("c\u007fd", connection.getHeaderField("a\tb"));
+    assertEquals("\u2615\ufe0f", connection.getHeaderField("\ud83c\udf69"));
+    assertEquals("ef", connection.getHeaderField(""));
+  }
+
+  @Test @Ignore public void deflateCompression() {
+    fail("TODO");
+  }
+
+  @Test @Ignore public void postBodiesRetransmittedOnIpAddressProblems() {
+    fail("TODO");
+  }
+
+  @Test @Ignore public void pooledConnectionProblemsNotReportedToProxySelector() {
+    fail("TODO");
+  }
+
+  @Test public void customBasicAuthenticator() throws Exception {
+    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
+        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
+        .setBody("Please authenticate.");
+    server.enqueue(pleaseAuthenticate);
+    server.enqueue(new MockResponse().setBody("A"));
+
+    String credential = Credentials.basic("jesse", "peanutbutter");
+    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(credential);
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(authenticator)
+        .build());
+    assertContent("A", urlFactory.open(server.url("/private").url()));
+
+    assertNull(server.takeRequest().getHeader("Authorization"));
+    assertEquals(credential, server.takeRequest().getHeader("Authorization"));
+
+    assertEquals(Proxy.NO_PROXY, authenticator.onlyProxy());
+    Response response = authenticator.onlyResponse();
+    assertEquals("/private", response.request().url().url().getPath());
+    assertEquals(Arrays.asList(new Challenge("Basic", "protected area")), response.challenges());
+  }
+
+  @Test public void customTokenAuthenticator() throws Exception {
+    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
+        .addHeader("WWW-Authenticate: Bearer realm=\"oauthed\"")
+        .setBody("Please authenticate.");
+    server.enqueue(pleaseAuthenticate);
+    server.enqueue(new MockResponse().setBody("A"));
+
+    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator("oauthed abc123");
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(authenticator)
+        .build());
+    assertContent("A", urlFactory.open(server.url("/private").url()));
+
+    assertNull(server.takeRequest().getHeader("Authorization"));
+    assertEquals("oauthed abc123", server.takeRequest().getHeader("Authorization"));
+
+    Response response = authenticator.onlyResponse();
+    assertEquals("/private", response.request().url().url().getPath());
+    assertEquals(Arrays.asList(new Challenge("Bearer", "oauthed")), response.challenges());
+  }
+
+  @Test public void authenticateCallsTrackedAsRedirects() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: /b"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(401)
+        .addHeader("WWW-Authenticate: Basic realm=\"protected area\""));
+    server.enqueue(new MockResponse().setBody("c"));
+
+    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(
+        Credentials.basic("jesse", "peanutbutter"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(authenticator)
+        .build());
+    assertContent("c", urlFactory.open(server.url("/a").url()));
+
+    Response challengeResponse = authenticator.responses.get(0);
+    assertEquals("/b", challengeResponse.request().url().url().getPath());
+
+    Response redirectedBy = challengeResponse.priorResponse();
+    assertEquals("/a", redirectedBy.request().url().url().getPath());
+  }
+
+  @Test public void attemptAuthorization20Times() throws Exception {
+    for (int i = 0; i < 20; i++) {
+      server.enqueue(new MockResponse().setResponseCode(401));
+    }
+    server.enqueue(new MockResponse().setBody("Success!"));
+
+    String credential = Credentials.basic("jesse", "peanutbutter");
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new RecordingOkAuthenticator(credential))
+        .build());
+
+    connection = urlFactory.open(server.url("/0").url());
+    assertContent("Success!", connection);
+  }
+
+  @Test public void doesNotAttemptAuthorization21Times() throws Exception {
+    for (int i = 0; i < 21; i++) {
+      server.enqueue(new MockResponse().setResponseCode(401));
+    }
+
+    String credential = Credentials.basic("jesse", "peanutbutter");
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new RecordingOkAuthenticator(credential))
+        .build());
+
+    connection = urlFactory.open(server.url("/").url());
+    try {
+      connection.getInputStream();
+      fail();
+    } catch (ProtocolException expected) {
+      assertEquals(401, connection.getResponseCode());
+      assertEquals("Too many follow-up requests: 21", expected.getMessage());
+    }
+  }
+
+  @Test public void setsNegotiatedProtocolHeader_HTTP_2() throws Exception {
+    setsNegotiatedProtocolHeader(Protocol.HTTP_2);
+  }
+
+  private void setsNegotiatedProtocolHeader(Protocol protocol) throws IOException {
+    enableProtocol(protocol);
+    server.enqueue(new MockResponse().setBody("A"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .protocols(Arrays.asList(protocol, Protocol.HTTP_1_1))
+        .build());
+    connection = urlFactory.open(server.url("/").url());
+    List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
+    assertEquals(Arrays.asList(protocol.toString()), protocolValues);
+    assertContent("A", connection);
+  }
+
+  @Test public void http10SelectedProtocol() throws Exception {
+    server.enqueue(new MockResponse().setStatus("HTTP/1.0 200 OK"));
+    connection = urlFactory.open(server.url("/").url());
+    List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
+    assertEquals(Arrays.asList("http/1.0"), protocolValues);
+  }
+
+  @Test public void http11SelectedProtocol() throws Exception {
+    server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 OK"));
+    connection = urlFactory.open(server.url("/").url());
+    List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
+    assertEquals(Arrays.asList("http/1.1"), protocolValues);
+  }
+
+  /** For example, empty Protobuf RPC messages end up as a zero-length POST. */
+  @Test public void zeroLengthPost() throws IOException, InterruptedException {
+    zeroLengthPayload("POST");
+  }
+
+  @Test public void zeroLengthPost_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    zeroLengthPost();
+  }
+
+  /** For example, creating an Amazon S3 bucket ends up as a zero-length POST. */
+  @Test public void zeroLengthPut() throws IOException, InterruptedException {
+    zeroLengthPayload("PUT");
+  }
+
+  @Test public void zeroLengthPut_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    zeroLengthPut();
+  }
+
+  private void zeroLengthPayload(String method)
+      throws IOException, InterruptedException {
+    server.enqueue(new MockResponse());
+    connection = urlFactory.open(server.url("/").url());
+    connection.setRequestProperty("Content-Length", "0");
+    connection.setRequestMethod(method);
+    connection.setFixedLengthStreamingMode(0);
+    connection.setDoOutput(true);
+    assertContent("", connection);
+    RecordedRequest zeroLengthPayload = server.takeRequest();
+    assertEquals(method, zeroLengthPayload.getMethod());
+    assertEquals("0", zeroLengthPayload.getHeader("content-length"));
+    assertEquals(0L, zeroLengthPayload.getBodySize());
+  }
+
+  @Test public void unspecifiedRequestBodyContentTypeGetsDefault() throws Exception {
+    server.enqueue(new MockResponse());
+
+    connection = urlFactory.open(server.url("/").url());
+    connection.setDoOutput(true);
+    connection.getOutputStream().write("abc".getBytes(UTF_8));
+    assertEquals(200, connection.getResponseCode());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("application/x-www-form-urlencoded", request.getHeader("Content-Type"));
+    assertEquals("3", request.getHeader("Content-Length"));
+    assertEquals("abc", request.getBody().readUtf8());
+  }
+
+  @Test public void setProtocols() throws Exception {
+    server.enqueue(new MockResponse().setBody("A"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .protocols(Arrays.asList(Protocol.HTTP_1_1))
+        .build());
+    assertContent("A", urlFactory.open(server.url("/").url()));
+  }
+
+  @Test public void setProtocolsWithoutHttp11() throws Exception {
+    try {
+      new OkHttpClient.Builder().protocols(Arrays.asList(Protocol.HTTP_2));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void setProtocolsWithNull() throws Exception {
+    try {
+      new OkHttpClient.Builder().protocols(Arrays.asList(Protocol.HTTP_1_1, null));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void veryLargeFixedLengthRequest() throws Exception {
+    server.setBodyLimit(0);
+    server.enqueue(new MockResponse());
+
+    connection = urlFactory.open(server.url("/").url());
+    connection.setDoOutput(true);
+    long contentLength = Integer.MAX_VALUE + 1L;
+    connection.setFixedLengthStreamingMode(contentLength);
+    OutputStream out = connection.getOutputStream();
+    byte[] buffer = new byte[1024 * 1024];
+    for (long bytesWritten = 0; bytesWritten < contentLength; ) {
+      int byteCount = (int) Math.min(buffer.length, contentLength - bytesWritten);
+      out.write(buffer, 0, byteCount);
+      bytesWritten += byteCount;
+    }
+    assertContent("", connection);
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals(Long.toString(contentLength), request.getHeader("Content-Length"));
+  }
+
+  @Test public void testNoSslFallback() throws Exception {
+    server.useHttps(sslClient.socketFactory, false /* tunnelProxy */);
+    server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse().setBody("Response that would have needed fallbacks"));
+
+    HttpsURLConnection connection = (HttpsURLConnection) server.url("/").url().openConnection();
+    connection.setSSLSocketFactory(sslClient.socketFactory);
+    try {
+      connection.getInputStream();
+      fail();
+    } catch (SSLProtocolException expected) {
+      // RI response to the FAIL_HANDSHAKE
+    } catch (SSLHandshakeException expected) {
+      // Android's response to the FAIL_HANDSHAKE
+    }
+  }
+
+  /**
+   * We had a bug where we attempted to gunzip responses that didn't have a body. This only came up
+   * with 304s since that response code can include headers (like "Content-Encoding") without any
+   * content to go along with it. https://github.com/square/okhttp/issues/358
+   */
+  @Test public void noTransparentGzipFor304NotModified() throws Exception {
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
+        .addHeader("Content-Encoding: gzip"));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
+    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection1.getResponseCode());
+    assertContent("", connection1);
+
+    HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
+    assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
+    assertContent("b", connection2);
+
+    RecordedRequest requestA = server.takeRequest();
+    assertEquals(0, requestA.getSequenceNumber());
+
+    RecordedRequest requestB = server.takeRequest();
+    assertEquals(1, requestB.getSequenceNumber());
+  }
+
+  /**
+   * We had a bug where we weren't closing Gzip streams on redirects.
+   * https://github.com/square/okhttp/issues/441
+   */
+  @Test public void gzipWithRedirectAndConnectionReuse() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: /foo")
+        .addHeader("Content-Encoding: gzip")
+        .setBody(gzip("Moved! Moved! Moved!")));
+    server.enqueue(new MockResponse().setBody("This is the new page!"));
+
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
+    assertContent("This is the new page!", connection);
+
+    RecordedRequest requestA = server.takeRequest();
+    assertEquals(0, requestA.getSequenceNumber());
+
+    RecordedRequest requestB = server.takeRequest();
+    assertEquals(1, requestB.getSequenceNumber());
+  }
+
+  /**
+   * The RFC is unclear in this regard as it only specifies that this should invalidate the cache
+   * entry (if any).
+   */
+  @Test public void bodyPermittedOnDelete() throws Exception {
+    server.enqueue(new MockResponse());
+
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
+    connection.setRequestMethod("DELETE");
+    connection.setDoOutput(true);
+    connection.getOutputStream().write("BODY".getBytes(UTF_8));
+    assertEquals(200, connection.getResponseCode());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("DELETE", request.getMethod());
+    assertEquals("BODY", request.getBody().readUtf8());
+  }
+
+  @Test public void userAgentPicksUpHttpAgentSystemProperty() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    System.setProperty("http.agent", "foo");
+    assertContent("abc", urlFactory.open(server.url("/").url()));
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("foo", request.getHeader("User-Agent"));
+  }
+
+  /** https://github.com/square/okhttp/issues/891 */
+  @Test public void userAgentSystemPropertyIsNotAscii() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    System.setProperty("http.agent", "a\nb\ud83c\udf69c\ud83c\udf68d\u007fe");
+    assertContent("abc", urlFactory.open(server.url("/").url()));
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("a?b?c?d?e", request.getHeader("User-Agent"));
+  }
+
+  @Test public void userAgentDefaultsToOkHttpVersion() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    assertContent("abc", urlFactory.open(server.url("/").url()));
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals(Version.userAgent(), request.getHeader("User-Agent"));
+  }
+
+  @Test public void interceptorsNotInvoked() throws Exception {
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        throw new AssertionError();
+      }
+    };
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .addInterceptor(interceptor)
+        .addNetworkInterceptor(interceptor)
+        .build());
+
+    server.enqueue(new MockResponse().setBody("abc"));
+    assertContent("abc", urlFactory.open(server.url("/").url()));
+  }
+
+  @Test public void urlWithSpaceInHost() throws Exception {
+    URLConnection urlConnection = urlFactory.open(new URL("http://and roid.com/"));
+    try {
+      urlConnection.getInputStream();
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+  }
+
+  @Test public void urlWithSpaceInHostViaHttpProxy() throws Exception {
+    server.enqueue(new MockResponse());
+    URLConnection urlConnection =
+        urlFactory.open(new URL("http://and roid.com/"), server.toProxyAddress());
+
+    try {
+      // This test is to check that a NullPointerException is not thrown.
+      urlConnection.getInputStream();
+      fail(); // the RI makes a bogus proxy request for "GET http://and roid.com/ HTTP/1.1"
+    } catch (UnknownHostException expected) {
+    }
+  }
+
+  @Test public void urlHostWithNul() throws Exception {
+    URLConnection urlConnection = urlFactory.open(new URL("http://host\u0000/"));
+    try {
+      urlConnection.getInputStream();
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+  }
+
+  @Test public void urlRedirectToHostWithNul() throws Exception {
+    String redirectUrl = "http://host\u0000/";
+    server.enqueue(new MockResponse().setResponseCode(302)
+        .addHeaderLenient("Location", redirectUrl));
+
+    HttpURLConnection urlConnection = urlFactory.open(server.url("/").url());
+    assertEquals(302, urlConnection.getResponseCode());
+    assertEquals(redirectUrl, urlConnection.getHeaderField("Location"));
+  }
+
+  @Test public void urlWithBadAsciiHost() throws Exception {
+    URLConnection urlConnection = urlFactory.open(new URL("http://host\u0001/"));
+    try {
+      urlConnection.getInputStream();
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+  }
+
+  @Test public void instanceFollowsRedirects() throws Exception {
+    testInstanceFollowsRedirects("http://www.google.com/");
+    testInstanceFollowsRedirects("https://www.google.com/");
+  }
+
+  @Test public void setSslSocketFactoryFailsOnJdk9() throws Exception {
+    assumeTrue(getPlatform().equals("jdk9"));
+
+    enableProtocol(Protocol.HTTP_2);
+    URL url = server.url("/").url();
+    HttpsURLConnection connection = (HttpsURLConnection) urlFactory.open(url);
+    try {
+      connection.setSSLSocketFactory(sslClient.socketFactory);
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+  }
+
+  /** Confirm that runtime exceptions thrown inside of OkHttp propagate to the caller. */
+  @Test public void unexpectedExceptionSync() throws Exception {
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .dns(new Dns() {
+          @Override public List<InetAddress> lookup(String hostname) {
+            throw new RuntimeException("boom!");
+          }
+        })
+        .build());
+
+    server.enqueue(new MockResponse());
+
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
+    try {
+      connection.getResponseCode(); // Use the synchronous implementation.
+      fail();
+    } catch (RuntimeException expected) {
+      assertEquals("boom!", expected.getMessage());
+    }
+  }
+
+  /** Confirm that runtime exceptions thrown inside of OkHttp propagate to the caller. */
+  @Test public void unexpectedExceptionAsync() throws Exception {
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .dns(new Dns() {
+          @Override public List<InetAddress> lookup(String hostname) {
+            throw new RuntimeException("boom!");
+          }
+        })
+        .build());
+
+    server.enqueue(new MockResponse());
+
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
+    try {
+      connection.connect(); // Force the async implementation.
+      fail();
+    } catch (RuntimeException expected) {
+      assertEquals("boom!", expected.getMessage());
+    }
+  }
+
+  @Test public void callsNotManagedByDispatcher() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    Dispatcher dispatcher = urlFactory.client().dispatcher();
+    assertEquals(0, dispatcher.runningCallsCount());
+
+    connection = urlFactory.open(server.url("/").url());
+    assertEquals(0, dispatcher.runningCallsCount());
+
+    connection.connect();
+    assertEquals(0, dispatcher.runningCallsCount());
+
+    assertContent("abc", connection);
+    assertEquals(0, dispatcher.runningCallsCount());
+  }
+
+  @Test public void streamedBodyIsRetriedOnHttp2Shutdown() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setBody("abc"));
+    server.enqueue(new MockResponse()
+        .setBody("def"));
+
+    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
+    connection1.setChunkedStreamingMode(4096);
+    connection1.setRequestMethod("POST");
+    connection1.connect(); // Establish healthy HTTP/2 connection, but don't write yet.
+
+    // Send a separate request which will trigger a GOAWAY frame on the healthy connection.
+    HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
+    assertContent("abc", connection2);
+
+    // Ensure the GOAWAY frame has time to be read and processed.
+    Thread.sleep(500);
+
+    OutputStream os = connection1.getOutputStream();
+    os.write(new byte[] { '1', '2', '3' });
+    os.close();
+    assertContent("def", connection1);
+
+    RecordedRequest request1 = server.takeRequest();
+    assertEquals(0, request1.getSequenceNumber());
+
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals("123", request2.getBody().readUtf8());
+    assertEquals(0, request2.getSequenceNumber());
+  }
+
+  private void testInstanceFollowsRedirects(String spec) throws Exception {
+    URL url = new URL(spec);
+    HttpURLConnection urlConnection = urlFactory.open(url);
+    urlConnection.setInstanceFollowRedirects(true);
+    assertTrue(urlConnection.getInstanceFollowRedirects());
+    urlConnection.setInstanceFollowRedirects(false);
+    assertFalse(urlConnection.getInstanceFollowRedirects());
+  }
+
+  /** Returns a gzipped copy of {@code bytes}. */
+  public Buffer gzip(String data) throws IOException {
+    Buffer result = new Buffer();
+    BufferedSink gzipSink = Okio.buffer(new GzipSink(result));
+    gzipSink.writeUtf8(data);
+    gzipSink.close();
+    return result;
+  }
+
+  /**
+   * Reads at most {@code limit} characters from {@code in} and asserts that content equals {@code
+   * expected}.
+   */
+  private void assertContent(String expected, HttpURLConnection connection, int limit)
+      throws IOException {
+    connection.connect();
+    assertEquals(expected, readAscii(connection.getInputStream(), limit));
+  }
+
+  private void assertContent(String expected, HttpURLConnection connection) throws IOException {
+    assertContent(expected, connection, Integer.MAX_VALUE);
+  }
+
+  private Set<String> newSet(String... elements) {
+    return new LinkedHashSet<>(Arrays.asList(elements));
+  }
+
+  enum TransferKind {
+    CHUNKED() {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize)
+          throws IOException {
+        response.setChunkedBody(content, chunkSize);
+      }
+
+      @Override void setForRequest(HttpURLConnection connection, int contentLength) {
+        connection.setChunkedStreamingMode(5);
+      }
+    },
+    FIXED_LENGTH() {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
+        response.setBody(content);
+      }
+
+      @Override void setForRequest(HttpURLConnection connection, int contentLength) {
+        connection.setFixedLengthStreamingMode(contentLength);
+      }
+    },
+    END_OF_STREAM() {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
+        response.setBody(content);
+        response.setSocketPolicy(DISCONNECT_AT_END);
+        response.removeHeader("Content-Length");
+      }
+
+      @Override void setForRequest(HttpURLConnection connection, int contentLength) {
+      }
+    };
+
+    abstract void setBody(MockResponse response, Buffer content, int chunkSize) throws IOException;
+
+    abstract void setForRequest(HttpURLConnection connection, int contentLength);
+
+    void setBody(MockResponse response, String content, int chunkSize) throws IOException {
+      setBody(response, new Buffer().writeUtf8(content), chunkSize);
+    }
+  }
+
+  enum ProxyConfig {
+    NO_PROXY() {
+      @Override public HttpURLConnection connect(
+          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
+          throws IOException {
+        streamHandlerFactory.setClient(streamHandlerFactory.client().newBuilder()
+            .proxy(Proxy.NO_PROXY)
+            .build());
+        return streamHandlerFactory.open(url);
+      }
+    },
+
+    CREATE_ARG() {
+      @Override public HttpURLConnection connect(
+          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
+          throws IOException {
+        streamHandlerFactory.setClient(streamHandlerFactory.client().newBuilder()
+            .proxy(server.toProxyAddress())
+            .build());
+        return streamHandlerFactory.open(url);
+      }
+    },
+
+    PROXY_SYSTEM_PROPERTY() {
+      @Override public HttpURLConnection connect(
+          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
+          throws IOException {
+        System.setProperty("proxyHost", server.getHostName());
+        System.setProperty("proxyPort", Integer.toString(server.getPort()));
+        return streamHandlerFactory.open(url);
+      }
+    },
+
+    HTTP_PROXY_SYSTEM_PROPERTY() {
+      @Override public HttpURLConnection connect(
+          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
+          throws IOException {
+        System.setProperty("http.proxyHost", server.getHostName());
+        System.setProperty("http.proxyPort", Integer.toString(server.getPort()));
+        return streamHandlerFactory.open(url);
+      }
+    },
+
+    HTTPS_PROXY_SYSTEM_PROPERTY() {
+      @Override public HttpURLConnection connect(
+          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
+          throws IOException {
+        System.setProperty("https.proxyHost", server.getHostName());
+        System.setProperty("https.proxyPort", Integer.toString(server.getPort()));
+        return streamHandlerFactory.open(url);
+      }
+    };
+
+    public abstract HttpURLConnection connect(
+        MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
+        throws IOException;
+  }
+
+  private static class RecordingTrustManager implements X509TrustManager {
+    private final List<String> calls = new ArrayList<>();
+    private final X509TrustManager delegate;
+
+    public RecordingTrustManager(X509TrustManager delegate) {
+      this.delegate = delegate;
+    }
+
+    public X509Certificate[] getAcceptedIssuers() {
+      return delegate.getAcceptedIssuers();
+    }
+
+    public void checkClientTrusted(X509Certificate[] chain, String authType)
+        throws CertificateException {
+      calls.add("checkClientTrusted " + certificatesToString(chain));
+    }
+
+    public void checkServerTrusted(X509Certificate[] chain, String authType)
+        throws CertificateException {
+      calls.add("checkServerTrusted " + certificatesToString(chain));
+    }
+
+    private String certificatesToString(X509Certificate[] certificates) {
+      List<String> result = new ArrayList<>();
+      for (X509Certificate certificate : certificates) {
+        result.add(certificate.getSubjectDN() + " " + certificate.getSerialNumber());
+      }
+      return result.toString();
+    }
+  }
+
+  /**
+   * Tests that use this will fail unless boot classpath is set. Ex. {@code
+   * -Xbootclasspath/p:/tmp/alpn-boot-8.0.0.v20140317}
+   */
+  private void enableProtocol(Protocol protocol) {
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .protocols(Arrays.asList(protocol, Protocol.HTTP_1_1))
+        .build());
+    server.useHttps(sslClient.socketFactory, false);
+    server.setProtocolNegotiationEnabled(true);
+    server.setProtocols(urlFactory.client().protocols());
+  }
+
+  /**
+   * Used during tests that involve TLS connection fallback attempts. OkHttp includes the
+   * TLS_FALLBACK_SCSV cipher on fallback connections. See {@link FallbackTestClientSocketFactory}
+   * for details.
+   */
+  private FallbackTestClientSocketFactory suppressTlsFallbackClientSocketFactory() {
+    return new FallbackTestClientSocketFactory(sslClient.socketFactory);
+  }
+
+  private String getPlatform() {
+    return System.getProperty("okhttp.platform", "platform");
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java b/okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java
new file mode 100644
index 0000000000..56611be40a
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java
@@ -0,0 +1,433 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.net.URI;
+import java.net.URL;
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import okhttp3.internal.Util;
+import okio.Buffer;
+import okio.ByteString;
+
+import static org.junit.Assert.fail;
+
+/** Tests how each code point is encoded and decoded in the context of each URL component. */
+class UrlComponentEncodingTester {
+  private static final int UNICODE_2 = 0x07ff; // Arbitrary code point that's 2 bytes in UTF-8.
+  private static final int UNICODE_3 = 0xffff; // Arbitrary code point that's 3 bytes in UTF-8.
+  private static final int UNICODE_4 = 0x10ffff; // Arbitrary code point that's 4 bytes in UTF-8.
+
+  /**
+   * The default encode set for the ASCII range. The specific rules vary per-component: for example,
+   * '?' may be identity-encoded in a fragment, but must be percent-encoded in a path.
+   *
+   * See https://url.spec.whatwg.org/#percent-encoded-bytes
+   */
+  private static final Map<Integer, Encoding> defaultEncodings;
+
+  static {
+    Map<Integer, Encoding> map = new LinkedHashMap<>();
+    map.put(       0x0, Encoding.PERCENT); // Null character
+    map.put(       0x1, Encoding.PERCENT); // Start of Header
+    map.put(       0x2, Encoding.PERCENT); // Start of Text
+    map.put(       0x3, Encoding.PERCENT); // End of Text
+    map.put(       0x4, Encoding.PERCENT); // End of Transmission
+    map.put(       0x5, Encoding.PERCENT); // Enquiry
+    map.put(       0x6, Encoding.PERCENT); // Acknowledgment
+    map.put(       0x7, Encoding.PERCENT); // Bell
+    map.put((int) '\b', Encoding.PERCENT); // Backspace
+    map.put((int) '\t', Encoding.SKIP);    // Horizontal Tab
+    map.put((int) '\n', Encoding.SKIP);    // Line feed
+    map.put(       0xb, Encoding.PERCENT); // Vertical Tab
+    map.put((int) '\f', Encoding.SKIP);    // Form feed
+    map.put((int) '\r', Encoding.SKIP);    // Carriage return
+    map.put(       0xe, Encoding.PERCENT); // Shift Out
+    map.put(       0xf, Encoding.PERCENT); // Shift In
+    map.put(      0x10, Encoding.PERCENT); // Data Link Escape
+    map.put(      0x11, Encoding.PERCENT); // Device Control 1 (oft. XON)
+    map.put(      0x12, Encoding.PERCENT); // Device Control 2
+    map.put(      0x13, Encoding.PERCENT); // Device Control 3 (oft. XOFF)
+    map.put(      0x14, Encoding.PERCENT); // Device Control 4
+    map.put(      0x15, Encoding.PERCENT); // Negative Acknowledgment
+    map.put(      0x16, Encoding.PERCENT); // Synchronous idle
+    map.put(      0x17, Encoding.PERCENT); // End of Transmission Block
+    map.put(      0x18, Encoding.PERCENT); // Cancel
+    map.put(      0x19, Encoding.PERCENT); // End of Medium
+    map.put(      0x1a, Encoding.PERCENT); // Substitute
+    map.put(      0x1b, Encoding.PERCENT); // Escape
+    map.put(      0x1c, Encoding.PERCENT); // File Separator
+    map.put(      0x1d, Encoding.PERCENT); // Group Separator
+    map.put(      0x1e, Encoding.PERCENT); // Record Separator
+    map.put(      0x1f, Encoding.PERCENT); // Unit Separator
+    map.put((int)  ' ', Encoding.PERCENT);
+    map.put((int)  '!', Encoding.IDENTITY);
+    map.put((int)  '"', Encoding.PERCENT);
+    map.put((int)  '#', Encoding.PERCENT);
+    map.put((int)  '$', Encoding.IDENTITY);
+    map.put((int)  '%', Encoding.IDENTITY);
+    map.put((int)  '&', Encoding.IDENTITY);
+    map.put((int) '\'', Encoding.IDENTITY);
+    map.put((int)  '(', Encoding.IDENTITY);
+    map.put((int)  ')', Encoding.IDENTITY);
+    map.put((int)  '*', Encoding.IDENTITY);
+    map.put((int)  '+', Encoding.IDENTITY);
+    map.put((int)  ',', Encoding.IDENTITY);
+    map.put((int)  '-', Encoding.IDENTITY);
+    map.put((int)  '.', Encoding.IDENTITY);
+    map.put((int)  '/', Encoding.IDENTITY);
+    map.put((int)  '0', Encoding.IDENTITY);
+    map.put((int)  '1', Encoding.IDENTITY);
+    map.put((int)  '2', Encoding.IDENTITY);
+    map.put((int)  '3', Encoding.IDENTITY);
+    map.put((int)  '4', Encoding.IDENTITY);
+    map.put((int)  '5', Encoding.IDENTITY);
+    map.put((int)  '6', Encoding.IDENTITY);
+    map.put((int)  '7', Encoding.IDENTITY);
+    map.put((int)  '8', Encoding.IDENTITY);
+    map.put((int)  '9', Encoding.IDENTITY);
+    map.put((int)  ':', Encoding.IDENTITY);
+    map.put((int)  ';', Encoding.IDENTITY);
+    map.put((int)  '<', Encoding.PERCENT);
+    map.put((int)  '=', Encoding.IDENTITY);
+    map.put((int)  '>', Encoding.PERCENT);
+    map.put((int)  '?', Encoding.PERCENT);
+    map.put((int)  '@', Encoding.IDENTITY);
+    map.put((int)  'A', Encoding.IDENTITY);
+    map.put((int)  'B', Encoding.IDENTITY);
+    map.put((int)  'C', Encoding.IDENTITY);
+    map.put((int)  'D', Encoding.IDENTITY);
+    map.put((int)  'E', Encoding.IDENTITY);
+    map.put((int)  'F', Encoding.IDENTITY);
+    map.put((int)  'G', Encoding.IDENTITY);
+    map.put((int)  'H', Encoding.IDENTITY);
+    map.put((int)  'I', Encoding.IDENTITY);
+    map.put((int)  'J', Encoding.IDENTITY);
+    map.put((int)  'K', Encoding.IDENTITY);
+    map.put((int)  'L', Encoding.IDENTITY);
+    map.put((int)  'M', Encoding.IDENTITY);
+    map.put((int)  'N', Encoding.IDENTITY);
+    map.put((int)  'O', Encoding.IDENTITY);
+    map.put((int)  'P', Encoding.IDENTITY);
+    map.put((int)  'Q', Encoding.IDENTITY);
+    map.put((int)  'R', Encoding.IDENTITY);
+    map.put((int)  'S', Encoding.IDENTITY);
+    map.put((int)  'T', Encoding.IDENTITY);
+    map.put((int)  'U', Encoding.IDENTITY);
+    map.put((int)  'V', Encoding.IDENTITY);
+    map.put((int)  'W', Encoding.IDENTITY);
+    map.put((int)  'X', Encoding.IDENTITY);
+    map.put((int)  'Y', Encoding.IDENTITY);
+    map.put((int)  'Z', Encoding.IDENTITY);
+    map.put((int)  '[', Encoding.IDENTITY);
+    map.put((int) '\\', Encoding.IDENTITY);
+    map.put((int)  ']', Encoding.IDENTITY);
+    map.put((int)  '^', Encoding.IDENTITY);
+    map.put((int)  '_', Encoding.IDENTITY);
+    map.put((int)  '`', Encoding.PERCENT);
+    map.put((int)  'a', Encoding.IDENTITY);
+    map.put((int)  'b', Encoding.IDENTITY);
+    map.put((int)  'c', Encoding.IDENTITY);
+    map.put((int)  'd', Encoding.IDENTITY);
+    map.put((int)  'e', Encoding.IDENTITY);
+    map.put((int)  'f', Encoding.IDENTITY);
+    map.put((int)  'g', Encoding.IDENTITY);
+    map.put((int)  'h', Encoding.IDENTITY);
+    map.put((int)  'i', Encoding.IDENTITY);
+    map.put((int)  'j', Encoding.IDENTITY);
+    map.put((int)  'k', Encoding.IDENTITY);
+    map.put((int)  'l', Encoding.IDENTITY);
+    map.put((int)  'm', Encoding.IDENTITY);
+    map.put((int)  'n', Encoding.IDENTITY);
+    map.put((int)  'o', Encoding.IDENTITY);
+    map.put((int)  'p', Encoding.IDENTITY);
+    map.put((int)  'q', Encoding.IDENTITY);
+    map.put((int)  'r', Encoding.IDENTITY);
+    map.put((int)  's', Encoding.IDENTITY);
+    map.put((int)  't', Encoding.IDENTITY);
+    map.put((int)  'u', Encoding.IDENTITY);
+    map.put((int)  'v', Encoding.IDENTITY);
+    map.put((int)  'w', Encoding.IDENTITY);
+    map.put((int)  'x', Encoding.IDENTITY);
+    map.put((int)  'y', Encoding.IDENTITY);
+    map.put((int)  'z', Encoding.IDENTITY);
+    map.put((int)  '{', Encoding.IDENTITY);
+    map.put((int)  '|', Encoding.IDENTITY);
+    map.put((int)  '}', Encoding.IDENTITY);
+    map.put((int)  '~', Encoding.IDENTITY);
+    map.put(      0x7f, Encoding.PERCENT); // Delete
+    map.put( UNICODE_2, Encoding.PERCENT);
+    map.put( UNICODE_3, Encoding.PERCENT);
+    map.put( UNICODE_4, Encoding.PERCENT);
+    defaultEncodings = Collections.unmodifiableMap(map);
+  }
+
+  private final Map<Integer, Encoding> encodings;
+  private final StringBuilder uriEscapedCodePoints = new StringBuilder();
+
+  public UrlComponentEncodingTester() {
+    this.encodings = new LinkedHashMap<>(defaultEncodings);
+  }
+
+  public UrlComponentEncodingTester override(Encoding encoding, int... codePoints) {
+    for (int codePoint : codePoints) {
+      encodings.put(codePoint, encoding);
+    }
+    return this;
+  }
+
+  public UrlComponentEncodingTester identityForNonAscii() {
+    encodings.put(UNICODE_2, Encoding.IDENTITY);
+    encodings.put(UNICODE_3, Encoding.IDENTITY);
+    encodings.put(UNICODE_4, Encoding.IDENTITY);
+    return this;
+  }
+
+  /**
+   * Configure a character to be skipped but only for conversion to and from {@code java.net.URI}.
+   * That class is more strict than the others.
+   */
+  public UrlComponentEncodingTester skipForUri(int... codePoints) {
+    uriEscapedCodePoints.append(new String(codePoints, 0, codePoints.length));
+    return this;
+  }
+
+  public UrlComponentEncodingTester test(Component component) {
+    for (Map.Entry<Integer, Encoding> entry : encodings.entrySet()) {
+      Encoding encoding = entry.getValue();
+      int codePoint = entry.getKey();
+      testEncodeAndDecode(codePoint, component);
+      if (encoding == Encoding.SKIP) continue;
+
+      testParseOriginal(codePoint, encoding, component);
+      testParseAlreadyEncoded(codePoint, encoding, component);
+      testToUrl(codePoint, encoding, component);
+      testFromUrl(codePoint, encoding, component);
+
+      if (codePoint != '%') {
+        boolean uriEscaped = uriEscapedCodePoints.indexOf(
+            Encoding.IDENTITY.encode(codePoint)) != -1;
+        testUri(codePoint, encoding, component, uriEscaped);
+      }
+    }
+    return this;
+  }
+
+  private void testParseAlreadyEncoded(int codePoint, Encoding encoding, Component component) {
+    String encoded = encoding.encode(codePoint);
+    String urlString = component.urlString(encoded);
+    HttpUrl url = HttpUrl.parse(urlString);
+    if (!component.encodedValue(url).equals(encoded)) {
+      fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
+    }
+  }
+
+  private void testEncodeAndDecode(int codePoint, Component component) {
+    String expected = Encoding.IDENTITY.encode(codePoint);
+    HttpUrl.Builder builder = HttpUrl.parse("http://host/").newBuilder();
+    component.set(builder, expected);
+    HttpUrl url = builder.build();
+    String actual = component.get(url);
+    if (!expected.equals(actual)) {
+      fail(Util.format("Roundtrip %s %#x %s", component, codePoint, url));
+    }
+  }
+
+  private void testParseOriginal(int codePoint, Encoding encoding, Component component) {
+    String encoded = encoding.encode(codePoint);
+    if (encoding != Encoding.PERCENT) return;
+    String identity = Encoding.IDENTITY.encode(codePoint);
+    String urlString = component.urlString(identity);
+    HttpUrl url = HttpUrl.parse(urlString);
+
+    String s = component.encodedValue(url);
+    if (!s.equals(encoded)) {
+      fail(Util.format("Encoding %s %#02x using %s", component, codePoint, encoding));
+    }
+  }
+
+  private void testToUrl(int codePoint, Encoding encoding, Component component) {
+    String encoded = encoding.encode(codePoint);
+    HttpUrl httpUrl = HttpUrl.parse(component.urlString(encoded));
+    URL javaNetUrl = httpUrl.url();
+    if (!javaNetUrl.toString().equals(javaNetUrl.toString())) {
+      fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
+    }
+  }
+
+  private void testFromUrl(int codePoint, Encoding encoding, Component component) {
+    String encoded = encoding.encode(codePoint);
+    HttpUrl httpUrl = HttpUrl.parse(component.urlString(encoded));
+    HttpUrl toAndFromJavaNetUrl = HttpUrl.get(httpUrl.url());
+    if (!toAndFromJavaNetUrl.equals(httpUrl)) {
+      fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
+    }
+  }
+
+  private void testUri(
+      int codePoint, Encoding encoding, Component component, boolean uriEscaped) {
+    String string = new String(new int[] {codePoint}, 0, 1);
+    String encoded = encoding.encode(codePoint);
+    HttpUrl httpUrl = HttpUrl.parse(component.urlString(encoded));
+    URI uri = httpUrl.uri();
+    HttpUrl toAndFromUri = HttpUrl.get(uri);
+    if (uriEscaped) {
+      // The URI has more escaping than the HttpURL. Check that the decoded values still match.
+      if (uri.toString().equals(httpUrl.toString())) {
+        fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
+      }
+      if (!component.get(toAndFromUri).equals(string)) {
+        fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
+      }
+    } else {
+      // Check that the URI and HttpURL have the exact same escaping.
+      if (!toAndFromUri.equals(httpUrl)) {
+        fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
+      }
+      if (!uri.toString().equals(httpUrl.toString())) {
+        fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
+      }
+    }
+  }
+
+  public enum Encoding {
+    IDENTITY {
+      public String encode(int codePoint) {
+        return new String(new int[] {codePoint}, 0, 1);
+      }
+    },
+
+    PERCENT {
+      public String encode(int codePoint) {
+        ByteString utf8 = ByteString.encodeUtf8(IDENTITY.encode(codePoint));
+        Buffer percentEncoded = new Buffer();
+        for (int i = 0; i < utf8.size(); i++) {
+          percentEncoded.writeUtf8(Util.format("%%%02X", utf8.getByte(i) & 0xff));
+        }
+        return percentEncoded.readUtf8();
+      }
+    },
+
+    SKIP;
+
+    public String encode(int codePoint) {
+      throw new UnsupportedOperationException();
+    }
+  }
+
+  public enum Component {
+    USER {
+      @Override public String urlString(String value) {
+        return "http://" + value + "@example.com/";
+      }
+
+      @Override public String encodedValue(HttpUrl url) {
+        return url.encodedUsername();
+      }
+
+      @Override public void set(HttpUrl.Builder builder, String value) {
+        builder.username(value);
+      }
+
+      @Override public String get(HttpUrl url) {
+        return url.username();
+      }
+    },
+    PASSWORD {
+      @Override public String urlString(String value) {
+        return "http://:" + value + "@example.com/";
+      }
+
+      @Override public String encodedValue(HttpUrl url) {
+        return url.encodedPassword();
+      }
+
+      @Override public void set(HttpUrl.Builder builder, String value) {
+        builder.password(value);
+      }
+
+      @Override public String get(HttpUrl url) {
+        return url.password();
+      }
+    },
+    PATH {
+      @Override public String urlString(String value) {
+        return "http://example.com/a" + value + "z/";
+      }
+
+      @Override public String encodedValue(HttpUrl url) {
+        String path = url.encodedPath();
+        return path.substring(2, path.length() - 2);
+      }
+
+      @Override public void set(HttpUrl.Builder builder, String value) {
+        builder.addPathSegment("a" + value + "z");
+      }
+
+      @Override public String get(HttpUrl url) {
+        String pathSegment = url.pathSegments().get(0);
+        return pathSegment.substring(1, pathSegment.length() - 1);
+      }
+    },
+    QUERY {
+      @Override public String urlString(String value) {
+        return "http://example.com/?a" + value + "z";
+      }
+
+      @Override public String encodedValue(HttpUrl url) {
+        String query = url.encodedQuery();
+        return query.substring(1, query.length() - 1);
+      }
+
+      @Override public void set(HttpUrl.Builder builder, String value) {
+        builder.query("a" + value + "z");
+      }
+
+      @Override public String get(HttpUrl url) {
+        String query = url.query();
+        return query.substring(1, query.length() - 1);
+      }
+    },
+    FRAGMENT {
+      @Override public String urlString(String value) {
+        return "http://example.com/#a" + value + "z";
+      }
+
+      @Override public String encodedValue(HttpUrl url) {
+        String fragment = url.encodedFragment();
+        return fragment.substring(1, fragment.length() - 1);
+      }
+
+      @Override public void set(HttpUrl.Builder builder, String value) {
+        builder.fragment("a" + value + "z");
+      }
+
+      @Override public String get(HttpUrl url) {
+        String fragment = url.fragment();
+        return fragment.substring(1, fragment.length() - 1);
+      }
+    };
+
+    public abstract String urlString(String value);
+
+    public abstract String encodedValue(HttpUrl url);
+
+    public abstract void set(HttpUrl.Builder builder, String value);
+
+    public abstract String get(HttpUrl url);
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java b/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java
new file mode 100644
index 0000000000..a15c57ea35
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java
@@ -0,0 +1,131 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import okhttp3.internal.Util;
+import okio.BufferedSource;
+import okio.Okio;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameter;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+
+/** Runs the web platform URL tests against Java URL models. */
+@RunWith(Parameterized.class)
+public final class WebPlatformUrlTest {
+  @Parameterized.Parameters(name = "{0}")
+  public static List<Object[]> parameters() {
+    try {
+      List<Object[]> result = new ArrayList<>();
+      for (WebPlatformUrlTestData urlTestData : loadTests()) {
+        result.add(new Object[] {urlTestData});
+      }
+      return result;
+    } catch (IOException e) {
+      throw new AssertionError();
+    }
+  }
+
+  @Parameter(0)
+  public WebPlatformUrlTestData testData;
+
+  private static final List<String> HTTP_URL_SCHEMES
+      = Util.immutableList("http", "https");
+  private static final List<String> KNOWN_FAILURES = Util.immutableList(
+      "Parsing: <http://example\t.\norg> against <http://example.org/foo/bar>",
+      "Parsing: <http://f:0/c> against <http://example.org/foo/bar>",
+      "Parsing: <http://f:00000000000000/c> against <http://example.org/foo/bar>",
+      "Parsing: <http://f:\n/c> against <http://example.org/foo/bar>",
+      "Parsing: <http://f:999999/c> against <http://example.org/foo/bar>",
+      "Parsing: <http://192.0x00A80001> against <about:blank>",
+      // This test fails on Java 7 but passes on Java 8. See HttpUrlTest.hostWithTrailingDot().
+      "Parsing: <http://%30%78%63%30%2e%30%32%35%30.01%2e> against <http://other.com/>",
+      "Parsing: <http://%30%78%63%30%2e%30%32%35%30.01> against <http://other.com/>",
+      "Parsing: <http://192.168.0.257> against <http://other.com/>",
+      "Parsing: <http://０Ｘｃ０．０２５０．０１> against <http://other.com/>"
+  );
+
+  /** Test how {@link HttpUrl} does against the web platform test suite. */
+  @Test public void httpUrl() throws Exception {
+    if (!testData.scheme.isEmpty() && !HTTP_URL_SCHEMES.contains(testData.scheme)) {
+      System.err.println("Ignoring unsupported scheme " + testData.scheme);
+      return;
+    }
+    if (!testData.base.startsWith("https:")
+        && !testData.base.startsWith("http:")
+        && !testData.base.equals("about:blank")) {
+      System.err.println("Ignoring unsupported base " + testData.base);
+      return;
+    }
+
+    try {
+      testHttpUrl();
+      if (KNOWN_FAILURES.contains(testData.toString())) {
+        System.err.println("Expected failure but was success: " + testData);
+      }
+    } catch (Throwable e) {
+      if (KNOWN_FAILURES.contains(testData.toString())) {
+        System.err.println("Ignoring known failure: " + testData);
+        e.printStackTrace();
+      } else {
+        throw e;
+      }
+    }
+  }
+
+  private void testHttpUrl() {
+    HttpUrl url;
+    if (testData.base.equals("about:blank")) {
+      url = HttpUrl.parse(testData.input);
+    } else {
+      HttpUrl baseUrl = HttpUrl.parse(testData.base);
+      url = baseUrl.resolve(testData.input);
+    }
+
+    if (testData.expectParseFailure()) {
+      assertNull("Expected URL to fail parsing", url);
+    } else {
+      assertNotNull("Expected URL to parse successfully, but was null", url);
+      String effectivePort = url.port() != HttpUrl.defaultPort(url.scheme())
+          ? Integer.toString(url.port())
+          : "";
+      String effectiveQuery = url.encodedQuery() != null ? "?" + url.encodedQuery() : "";
+      String effectiveFragment = url.encodedFragment() != null ? "#" + url.encodedFragment() : "";
+      String effectiveHost = url.host().contains(":")
+          ? ("[" + url.host() + "]")
+          : url.host();
+      assertEquals("scheme", testData.scheme, url.scheme());
+      assertEquals("host", testData.host, effectiveHost);
+      assertEquals("port", testData.port, effectivePort);
+      assertEquals("path", testData.path, url.encodedPath());
+      assertEquals("query", testData.query, effectiveQuery);
+      assertEquals("fragment", testData.fragment, effectiveFragment);
+    }
+  }
+
+  private static List<WebPlatformUrlTestData> loadTests() throws IOException {
+    BufferedSource source = Okio.buffer(Okio.source(
+        WebPlatformUrlTest.class.getResourceAsStream("/web-platform-test-urltestdata.txt")));
+    return WebPlatformUrlTestData.load(source);
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTestData.java b/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTestData.java
new file mode 100644
index 0000000000..72f92f9abf
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTestData.java
@@ -0,0 +1,157 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import okhttp3.internal.Util;
+import okio.Buffer;
+import okio.BufferedSource;
+
+/**
+ * A test from the <a href="https://github.com/w3c/web-platform-tests/tree/master/url">Web Platform
+ * URL test suite</a>. Each test is a line of the file {@code urltestdata.txt}; the format is
+ * informally specified by its JavaScript parser {@code urltestparser.js}; with which this class
+ * attempts to be compatible.
+ *
+ * <p>Each line of the urltestdata.text file specifies a test. Lines look like this: <pre>   {@code
+ *
+ *   http://example\t.\norg http://example.org/foo/bar s:http h:example.org p:/
+ * }</pre>
+ */
+public final class WebPlatformUrlTestData {
+  String input;
+  String base;
+  String scheme = "";
+  String username = "";
+  String password = null;
+  String host = "";
+  String port = "";
+  String path = "";
+  String query = "";
+  String fragment = "";
+
+  public boolean expectParseFailure() {
+    return scheme.isEmpty();
+  }
+
+  private void set(String name, String value) {
+    switch (name) {
+      case "s":
+        scheme = value;
+        break;
+      case "u":
+        username = value;
+        break;
+      case "pass":
+        password = value;
+        break;
+      case "h":
+        host = value;
+        break;
+      case "port":
+        port = value;
+        break;
+      case "p":
+        path = value;
+        break;
+      case "q":
+        query = value;
+        break;
+      case "f":
+        fragment = value;
+        break;
+      default:
+        throw new IllegalArgumentException("unexpected attribute: " + value);
+    }
+  }
+
+  @Override public String toString() {
+    return Util.format("Parsing: <%s> against <%s>", input, base);
+  }
+
+  public static List<WebPlatformUrlTestData> load(BufferedSource source) throws IOException {
+    List<WebPlatformUrlTestData> list = new ArrayList<>();
+    for (String line; (line = source.readUtf8Line()) != null; ) {
+      if (line.isEmpty() || line.startsWith("#")) continue;
+
+      int i = 0;
+      String[] parts = line.split(" ");
+      WebPlatformUrlTestData element = new WebPlatformUrlTestData();
+      element.input = unescape(parts[i++]);
+
+      String base = i < parts.length ? parts[i++] : null;
+      element.base = (base == null || base.isEmpty())
+          ? list.get(list.size() - 1).base
+          : unescape(base);
+
+      for (; i < parts.length; i++) {
+        String piece = parts[i];
+        if (piece.startsWith("#")) continue;
+        String[] nameAndValue = piece.split(":", 2);
+        element.set(nameAndValue[0], unescape(nameAndValue[1]));
+      }
+
+      list.add(element);
+    }
+    return list;
+  }
+
+  private static String unescape(String s) throws EOFException {
+    Buffer in = new Buffer().writeUtf8(s);
+    StringBuilder result = new StringBuilder();
+    while (!in.exhausted()) {
+      int c = in.readUtf8CodePoint();
+      if (c != '\\') {
+        result.append((char) c);
+        continue;
+      }
+
+      switch (in.readUtf8CodePoint()) {
+        case '\\':
+          result.append('\\');
+          break;
+        case '#':
+          result.append('#');
+          break;
+        case 'n':
+          result.append('\n');
+          break;
+        case 'r':
+          result.append('\r');
+          break;
+        case 's':
+          result.append(' ');
+          break;
+        case 't':
+          result.append('\t');
+          break;
+        case 'f':
+          result.append('\f');
+          break;
+        case 'u':
+          result.append((char) Integer.parseInt(in.readUtf8(4), 16));
+          break;
+        default:
+          throw new IllegalArgumentException("unexpected escape character in " + s);
+      }
+    }
+
+    return result.toString();
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/DoubleInetAddressDns.java b/okhttp-tests/src/test/java/okhttp3/internal/DoubleInetAddressDns.java
new file mode 100644
index 0000000000..7811ff5d75
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/DoubleInetAddressDns.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.Arrays;
+import java.util.List;
+import okhttp3.Dns;
+
+/**
+ * A network that always resolves two IP addresses per host. Use this when testing route selection
+ * fallbacks to guarantee that a fallback address is available.
+ */
+public class DoubleInetAddressDns implements Dns {
+  @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
+    List<InetAddress> addresses = Dns.SYSTEM.lookup(hostname);
+    return Arrays.asList(addresses.get(0), addresses.get(0));
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/RecordingAuthenticator.java b/okhttp-tests/src/test/java/okhttp3/internal/RecordingAuthenticator.java
new file mode 100644
index 0000000000..aeb34f742f
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/RecordingAuthenticator.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2013 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import java.net.Authenticator;
+import java.net.PasswordAuthentication;
+import java.util.ArrayList;
+import java.util.List;
+
+public final class RecordingAuthenticator extends Authenticator {
+  /** base64("username:password") */
+  public static final String BASE_64_CREDENTIALS = "dXNlcm5hbWU6cGFzc3dvcmQ=";
+
+  public final List<String> calls = new ArrayList<>();
+  public final PasswordAuthentication authentication;
+
+  public RecordingAuthenticator(PasswordAuthentication authentication) {
+    this.authentication = authentication;
+  }
+
+  public RecordingAuthenticator() {
+    this(new PasswordAuthentication("username", "password".toCharArray()));
+  }
+
+  @Override protected PasswordAuthentication getPasswordAuthentication() {
+    this.calls.add("host=" + getRequestingHost()
+        + " port=" + getRequestingPort()
+        + " site=" + getRequestingSite().getHostName()
+        + " url=" + getRequestingURL()
+        + " type=" + getRequestorType()
+        + " prompt=" + getRequestingPrompt()
+        + " protocol=" + getRequestingProtocol()
+        + " scheme=" + getRequestingScheme());
+    return authentication;
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java b/okhttp-tests/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java
new file mode 100644
index 0000000000..7d9d2bfe6a
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import java.io.IOException;
+import java.net.Proxy;
+import java.util.ArrayList;
+import java.util.List;
+import okhttp3.Authenticator;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.Route;
+
+public final class RecordingOkAuthenticator implements Authenticator {
+  public final List<Response> responses = new ArrayList<>();
+  public final List<Proxy> proxies = new ArrayList<>();
+  public final String credential;
+
+  public RecordingOkAuthenticator(String credential) {
+    this.credential = credential;
+  }
+
+  public Response onlyResponse() {
+    if (responses.size() != 1) throw new IllegalStateException();
+    return responses.get(0);
+  }
+
+  public Proxy onlyProxy() {
+    if (proxies.size() != 1) throw new IllegalStateException();
+    return proxies.get(0);
+  }
+
+  @Override public Request authenticate(Route route, Response response) throws IOException {
+    responses.add(response);
+    proxies.add(route.proxy());
+    String header = response.code() == 407 ? "Proxy-Authorization" : "Authorization";
+    return response.request().newBuilder()
+        .addHeader(header, credential)
+        .build();
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/SingleInetAddressDns.java b/okhttp-tests/src/test/java/okhttp3/internal/SingleInetAddressDns.java
new file mode 100644
index 0000000000..03e8ce08e9
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/SingleInetAddressDns.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.Collections;
+import java.util.List;
+import okhttp3.Dns;
+
+/**
+ * A network that resolves only one IP address per host. Use this when testing route selection
+ * fallbacks to prevent the host machine's various IP addresses from interfering.
+ */
+public class SingleInetAddressDns implements Dns {
+  @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
+    List<InetAddress> addresses = Dns.SYSTEM.lookup(hostname);
+    return Collections.singletonList(addresses.get(0));
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/SocketRecorder.java b/okhttp-tests/src/test/java/okhttp3/internal/SocketRecorder.java
new file mode 100644
index 0000000000..ba3b84f91e
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/SocketRecorder.java
@@ -0,0 +1,206 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.net.Socket;
+import java.util.Deque;
+import java.util.concurrent.LinkedBlockingDeque;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import okhttp3.DelegatingSSLSocket;
+import okhttp3.DelegatingSSLSocketFactory;
+import okio.Buffer;
+import okio.ByteString;
+
+/** Records all bytes written and read from a socket and makes them available for inspection. */
+public final class SocketRecorder {
+  private final Deque<RecordedSocket> recordedSockets = new LinkedBlockingDeque<>();
+
+  /** Returns an SSLSocketFactory whose sockets will record all transmitted bytes. */
+  public SSLSocketFactory sslSocketFactory(SSLSocketFactory delegate) {
+    return new DelegatingSSLSocketFactory(delegate) {
+      @Override protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
+        RecordedSocket recordedSocket = new RecordedSocket();
+        recordedSockets.add(recordedSocket);
+        return new RecordingSSLSocket(sslSocket, recordedSocket);
+      }
+    };
+  }
+
+  public RecordedSocket takeSocket() {
+    return recordedSockets.remove();
+  }
+
+  /** A bidirectional transfer of unadulterated bytes over a socket. */
+  public static final class RecordedSocket {
+    private final Buffer bytesWritten = new Buffer();
+    private final Buffer bytesRead = new Buffer();
+
+    synchronized void byteWritten(int b) {
+      bytesWritten.writeByte(b);
+    }
+
+    synchronized void byteRead(int b) {
+      bytesRead.writeByte(b);
+    }
+
+    synchronized void bytesWritten(byte[] bytes, int offset, int length) {
+      bytesWritten.write(bytes, offset, length);
+    }
+
+    synchronized void bytesRead(byte[] bytes, int offset, int length) {
+      bytesRead.write(bytes, offset, length);
+    }
+
+    /** Returns all bytes that have been written to this socket. */
+    public synchronized ByteString bytesWritten() {
+      return bytesWritten.readByteString();
+    }
+
+    /** Returns all bytes that have been read from this socket. */
+    public synchronized ByteString bytesRead() {
+      return bytesRead.readByteString();
+    }
+  }
+
+  static final class RecordingInputStream extends InputStream {
+    private final Socket socket;
+    private final RecordedSocket recordedSocket;
+
+    RecordingInputStream(Socket socket, RecordedSocket recordedSocket) {
+      this.socket = socket;
+      this.recordedSocket = recordedSocket;
+    }
+
+    @Override public int read() throws IOException {
+      int b = socket.getInputStream().read();
+      if (b == -1) return -1;
+      recordedSocket.byteRead(b);
+      return b;
+    }
+
+    @Override public int read(byte[] b, int off, int len) throws IOException {
+      int read = socket.getInputStream().read(b, off, len);
+      if (read == -1) return -1;
+      recordedSocket.bytesRead(b, off, read);
+      return read;
+    }
+
+    @Override public void close() throws IOException {
+      socket.getInputStream().close();
+    }
+  }
+
+  static final class RecordingOutputStream extends OutputStream {
+    private final Socket socket;
+    private final RecordedSocket recordedSocket;
+
+    RecordingOutputStream(Socket socket, RecordedSocket recordedSocket) {
+      this.socket = socket;
+      this.recordedSocket = recordedSocket;
+    }
+
+    @Override public void write(int b) throws IOException {
+      socket.getOutputStream().write(b);
+      recordedSocket.byteWritten(b);
+    }
+
+    @Override public void write(byte[] b, int off, int len) throws IOException {
+      socket.getOutputStream().write(b, off, len);
+      recordedSocket.bytesWritten(b, off, len);
+    }
+
+    @Override public void close() throws IOException {
+      socket.getOutputStream().close();
+    }
+
+    @Override public void flush() throws IOException {
+      socket.getOutputStream().flush();
+    }
+  }
+
+  static final class RecordingSSLSocket extends DelegatingSSLSocket {
+    private final InputStream inputStream;
+    private final OutputStream outputStream;
+
+    RecordingSSLSocket(SSLSocket delegate, RecordedSocket recordedSocket) {
+      super(delegate);
+      inputStream = new RecordingInputStream(delegate, recordedSocket);
+      outputStream = new RecordingOutputStream(delegate, recordedSocket);
+    }
+
+    @Override public void startHandshake() throws IOException {
+      // Intercept the handshake to properly configure TLS extensions with Jetty ALPN. Jetty ALPN
+      // expects the real SSLSocket to be placed in the global map. Because we are wrapping the real
+      // SSLSocket, it confuses Jetty ALPN. This patches that up so things work as expected.
+      Class<?> alpn = null;
+      Class<?> provider = null;
+      try {
+        alpn = Class.forName("org.eclipse.jetty.alpn.ALPN");
+        provider = Class.forName("org.eclipse.jetty.alpn.ALPN$Provider");
+      } catch (ClassNotFoundException ignored) {
+      }
+
+      if (alpn == null || provider == null) {
+        // No Jetty, so nothing to worry about.
+        super.startHandshake();
+        return;
+      }
+
+      Object providerInstance = null;
+      Method putMethod = null;
+      try {
+        Method getMethod = alpn.getMethod("get", SSLSocket.class);
+        putMethod = alpn.getMethod("put", SSLSocket.class, provider);
+        providerInstance = getMethod.invoke(null, this);
+        if (providerInstance == null) {
+          // Jetty's on the classpath but TLS extensions weren't used.
+          super.startHandshake();
+          return;
+        }
+
+        // TLS extensions were used; replace with the real SSLSocket to make Jetty ALPN happy.
+        putMethod.invoke(null, delegate, providerInstance);
+        super.startHandshake();
+      } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
+        throw new AssertionError();
+      } finally {
+        // If we replaced the SSLSocket in the global map, we must put the original back for
+        // everything to work inside OkHttp.
+        if (providerInstance != null) {
+          try {
+            putMethod.invoke(null, this, providerInstance);
+          } catch (IllegalAccessException | InvocationTargetException e) {
+            throw new AssertionError();
+          }
+        }
+      }
+    }
+
+    @Override public InputStream getInputStream() throws IOException {
+      return inputStream;
+    }
+
+    @Override public OutputStream getOutputStream() throws IOException {
+      return outputStream;
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java b/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
new file mode 100644
index 0000000000..04ba57126b
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
@@ -0,0 +1,1815 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.cache;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Deque;
+import java.util.Iterator;
+import java.util.List;
+import java.util.NoSuchElementException;
+import java.util.concurrent.Executor;
+import okhttp3.internal.io.FaultyFileSystem;
+import okhttp3.internal.io.FileSystem;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.Okio;
+import okio.Source;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+import org.junit.rules.Timeout;
+
+import static okhttp3.internal.cache.DiskLruCache.JOURNAL_FILE;
+import static okhttp3.internal.cache.DiskLruCache.JOURNAL_FILE_BACKUP;
+import static okhttp3.internal.cache.DiskLruCache.MAGIC;
+import static okhttp3.internal.cache.DiskLruCache.VERSION_1;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class DiskLruCacheTest {
+  @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
+  @Rule public final Timeout timeout = new Timeout(60 * 1000);
+
+  private final FaultyFileSystem fileSystem = new FaultyFileSystem(FileSystem.SYSTEM);
+  private final int appVersion = 100;
+  private File cacheDir;
+  private File journalFile;
+  private File journalBkpFile;
+  private final TestExecutor executor = new TestExecutor();
+
+  private DiskLruCache cache;
+  private final Deque<DiskLruCache> toClose = new ArrayDeque<>();
+
+  private void createNewCache() throws IOException {
+    createNewCacheWithSize(Integer.MAX_VALUE);
+  }
+
+  private void createNewCacheWithSize(int maxSize) throws IOException {
+    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, maxSize, executor);
+    synchronized (cache) {
+      cache.initialize();
+    }
+    toClose.add(cache);
+  }
+
+  @Before public void setUp() throws Exception {
+    cacheDir = tempDir.getRoot();
+    journalFile = new File(cacheDir, JOURNAL_FILE);
+    journalBkpFile = new File(cacheDir, JOURNAL_FILE_BACKUP);
+    createNewCache();
+  }
+
+  @After public void tearDown() throws Exception {
+    while (!toClose.isEmpty()) {
+      toClose.pop().close();
+    }
+  }
+
+  @Test public void emptyCache() throws Exception {
+    cache.close();
+    assertJournalEquals();
+  }
+
+  @Test public void recoverFromInitializationFailure() throws IOException {
+    // Add an uncommitted entry. This will get detected on initialization, and the cache will
+    // attempt to delete the file. Do not explicitly close the cache here so the entry is left as
+    // incomplete.
+    DiskLruCache.Editor creator = cache.edit("k1");
+    BufferedSink sink = Okio.buffer(creator.newSink(0));
+    sink.writeUtf8("Hello");
+    sink.close();
+
+    // Simulate a severe filesystem failure on the first initialization.
+    fileSystem.setFaultyDelete(new File(cacheDir, "k1.0.tmp"), true);
+    fileSystem.setFaultyDelete(cacheDir, true);
+
+    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
+    toClose.add(cache);
+
+    try {
+      cache.get("k1");
+      fail();
+    } catch (IOException expected) {
+    }
+
+    // Now let it operate normally.
+    fileSystem.setFaultyDelete(new File(cacheDir, "k1.0.tmp"), false);
+    fileSystem.setFaultyDelete(cacheDir, false);
+
+    DiskLruCache.Snapshot snapshot = cache.get("k1");
+    assertNull(snapshot);
+  }
+
+  @Test public void validateKey() throws Exception {
+    String key = null;
+    try {
+      key = "has_space ";
+      cache.edit(key);
+      fail("Exepcting an IllegalArgumentException as the key was invalid.");
+    } catch (IllegalArgumentException iae) {
+      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
+    }
+    try {
+      key = "has_CR\r";
+      cache.edit(key);
+      fail("Exepcting an IllegalArgumentException as the key was invalid.");
+    } catch (IllegalArgumentException iae) {
+      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
+    }
+    try {
+      key = "has_LF\n";
+      cache.edit(key);
+      fail("Exepcting an IllegalArgumentException as the key was invalid.");
+    } catch (IllegalArgumentException iae) {
+      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
+    }
+    try {
+      key = "has_invalid/";
+      cache.edit(key);
+      fail("Exepcting an IllegalArgumentException as the key was invalid.");
+    } catch (IllegalArgumentException iae) {
+      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
+    }
+    try {
+      key = "has_invalid\u2603";
+      cache.edit(key);
+      fail("Exepcting an IllegalArgumentException as the key was invalid.");
+    } catch (IllegalArgumentException iae) {
+      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
+    }
+    try {
+      key = "this_is_way_too_long_this_is_way_too_long_this_is_way_too_long_"
+          + "this_is_way_too_long_this_is_way_too_long_this_is_way_too_long";
+      cache.edit(key);
+      fail("Exepcting an IllegalArgumentException as the key was too long.");
+    } catch (IllegalArgumentException iae) {
+      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
+    }
+
+    // Test valid cases.
+
+    // Exactly 120.
+    key = "0123456789012345678901234567890123456789012345678901234567890123456789"
+        + "01234567890123456789012345678901234567890123456789";
+    cache.edit(key).abort();
+    // Contains all valid characters.
+    key = "abcdefghijklmnopqrstuvwxyz_0123456789";
+    cache.edit(key).abort();
+    // Contains dash.
+    key = "-20384573948576";
+    cache.edit(key).abort();
+  }
+
+  @Test public void writeAndReadEntry() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    setString(creator, 0, "ABC");
+    setString(creator, 1, "DE");
+    assertNull(creator.newSource(0));
+    assertNull(creator.newSource(1));
+    creator.commit();
+
+    DiskLruCache.Snapshot snapshot = cache.get("k1");
+    assertSnapshotValue(snapshot, 0, "ABC");
+    assertSnapshotValue(snapshot, 1, "DE");
+  }
+
+  @Test public void readAndWriteEntryAcrossCacheOpenAndClose() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    setString(creator, 0, "A");
+    setString(creator, 1, "B");
+    creator.commit();
+    cache.close();
+
+    createNewCache();
+    DiskLruCache.Snapshot snapshot = cache.get("k1");
+    assertSnapshotValue(snapshot, 0, "A");
+    assertSnapshotValue(snapshot, 1, "B");
+    snapshot.close();
+  }
+
+  @Test public void readAndWriteEntryWithoutProperClose() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    setString(creator, 0, "A");
+    setString(creator, 1, "B");
+    creator.commit();
+
+    // Simulate a dirty close of 'cache' by opening the cache directory again.
+    createNewCache();
+    DiskLruCache.Snapshot snapshot = cache.get("k1");
+    assertSnapshotValue(snapshot, 0, "A");
+    assertSnapshotValue(snapshot, 1, "B");
+    snapshot.close();
+  }
+
+  @Test public void journalWithEditAndPublish() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    assertJournalEquals("DIRTY k1"); // DIRTY must always be flushed.
+    setString(creator, 0, "AB");
+    setString(creator, 1, "C");
+    creator.commit();
+    cache.close();
+    assertJournalEquals("DIRTY k1", "CLEAN k1 2 1");
+  }
+
+  @Test public void revertedNewFileIsRemoveInJournal() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    assertJournalEquals("DIRTY k1"); // DIRTY must always be flushed.
+    setString(creator, 0, "AB");
+    setString(creator, 1, "C");
+    creator.abort();
+    cache.close();
+    assertJournalEquals("DIRTY k1", "REMOVE k1");
+  }
+
+  @Test public void unterminatedEditIsRevertedOnClose() throws Exception {
+    cache.edit("k1");
+    cache.close();
+    assertJournalEquals("DIRTY k1", "REMOVE k1");
+  }
+
+  @Test public void journalDoesNotIncludeReadOfYetUnpublishedValue() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    assertNull(cache.get("k1"));
+    setString(creator, 0, "A");
+    setString(creator, 1, "BC");
+    creator.commit();
+    cache.close();
+    assertJournalEquals("DIRTY k1", "CLEAN k1 1 2");
+  }
+
+  @Test public void journalWithEditAndPublishAndRead() throws Exception {
+    DiskLruCache.Editor k1Creator = cache.edit("k1");
+    setString(k1Creator, 0, "AB");
+    setString(k1Creator, 1, "C");
+    k1Creator.commit();
+    DiskLruCache.Editor k2Creator = cache.edit("k2");
+    setString(k2Creator, 0, "DEF");
+    setString(k2Creator, 1, "G");
+    k2Creator.commit();
+    DiskLruCache.Snapshot k1Snapshot = cache.get("k1");
+    k1Snapshot.close();
+    cache.close();
+    assertJournalEquals("DIRTY k1", "CLEAN k1 2 1", "DIRTY k2", "CLEAN k2 3 1", "READ k1");
+  }
+
+  @Test public void cannotOperateOnEditAfterPublish() throws Exception {
+    DiskLruCache.Editor editor = cache.edit("k1");
+    setString(editor, 0, "A");
+    setString(editor, 1, "B");
+    editor.commit();
+    assertInoperable(editor);
+  }
+
+  @Test public void cannotOperateOnEditAfterRevert() throws Exception {
+    DiskLruCache.Editor editor = cache.edit("k1");
+    setString(editor, 0, "A");
+    setString(editor, 1, "B");
+    editor.abort();
+    assertInoperable(editor);
+  }
+
+  @Test public void explicitRemoveAppliedToDiskImmediately() throws Exception {
+    DiskLruCache.Editor editor = cache.edit("k1");
+    setString(editor, 0, "ABC");
+    setString(editor, 1, "B");
+    editor.commit();
+    File k1 = getCleanFile("k1", 0);
+    assertEquals("ABC", readFile(k1));
+    cache.remove("k1");
+    assertFalse(fileSystem.exists(k1));
+  }
+
+  @Test public void removePreventsActiveEditFromStoringAValue() throws Exception {
+    set("a", "a", "a");
+    DiskLruCache.Editor a = cache.edit("a");
+    setString(a, 0, "a1");
+    assertTrue(cache.remove("a"));
+    setString(a, 1, "a2");
+    a.commit();
+    assertAbsent("a");
+  }
+
+  /**
+   * Each read sees a snapshot of the file at the time read was called. This means that two reads of
+   * the same key can see different data.
+   */
+  @Test public void readAndWriteOverlapsMaintainConsistency() throws Exception {
+    DiskLruCache.Editor v1Creator = cache.edit("k1");
+    setString(v1Creator, 0, "AAaa");
+    setString(v1Creator, 1, "BBbb");
+    v1Creator.commit();
+
+    DiskLruCache.Snapshot snapshot1 = cache.get("k1");
+    BufferedSource inV1 = Okio.buffer(snapshot1.getSource(0));
+    assertEquals('A', inV1.readByte());
+    assertEquals('A', inV1.readByte());
+
+    DiskLruCache.Editor v1Updater = cache.edit("k1");
+    setString(v1Updater, 0, "CCcc");
+    setString(v1Updater, 1, "DDdd");
+    v1Updater.commit();
+
+    DiskLruCache.Snapshot snapshot2 = cache.get("k1");
+    assertSnapshotValue(snapshot2, 0, "CCcc");
+    assertSnapshotValue(snapshot2, 1, "DDdd");
+    snapshot2.close();
+
+    assertEquals('a', inV1.readByte());
+    assertEquals('a', inV1.readByte());
+    assertSnapshotValue(snapshot1, 1, "BBbb");
+    snapshot1.close();
+  }
+
+  @Test public void openWithDirtyKeyDeletesAllFilesForThatKey() throws Exception {
+    cache.close();
+    File cleanFile0 = getCleanFile("k1", 0);
+    File cleanFile1 = getCleanFile("k1", 1);
+    File dirtyFile0 = getDirtyFile("k1", 0);
+    File dirtyFile1 = getDirtyFile("k1", 1);
+    writeFile(cleanFile0, "A");
+    writeFile(cleanFile1, "B");
+    writeFile(dirtyFile0, "C");
+    writeFile(dirtyFile1, "D");
+    createJournal("CLEAN k1 1 1", "DIRTY   k1");
+    createNewCache();
+    assertFalse(fileSystem.exists(cleanFile0));
+    assertFalse(fileSystem.exists(cleanFile1));
+    assertFalse(fileSystem.exists(dirtyFile0));
+    assertFalse(fileSystem.exists(dirtyFile1));
+    assertNull(cache.get("k1"));
+  }
+
+  @Test public void openWithInvalidVersionClearsDirectory() throws Exception {
+    cache.close();
+    generateSomeGarbageFiles();
+    createJournalWithHeader(MAGIC, "0", "100", "2", "");
+    createNewCache();
+    assertGarbageFilesAllDeleted();
+  }
+
+  @Test public void openWithInvalidAppVersionClearsDirectory() throws Exception {
+    cache.close();
+    generateSomeGarbageFiles();
+    createJournalWithHeader(MAGIC, "1", "101", "2", "");
+    createNewCache();
+    assertGarbageFilesAllDeleted();
+  }
+
+  @Test public void openWithInvalidValueCountClearsDirectory() throws Exception {
+    cache.close();
+    generateSomeGarbageFiles();
+    createJournalWithHeader(MAGIC, "1", "100", "1", "");
+    createNewCache();
+    assertGarbageFilesAllDeleted();
+  }
+
+  @Test public void openWithInvalidBlankLineClearsDirectory() throws Exception {
+    cache.close();
+    generateSomeGarbageFiles();
+    createJournalWithHeader(MAGIC, "1", "100", "2", "x");
+    createNewCache();
+    assertGarbageFilesAllDeleted();
+  }
+
+  @Test public void openWithInvalidJournalLineClearsDirectory() throws Exception {
+    cache.close();
+    generateSomeGarbageFiles();
+    createJournal("CLEAN k1 1 1", "BOGUS");
+    createNewCache();
+    assertGarbageFilesAllDeleted();
+    assertNull(cache.get("k1"));
+  }
+
+  @Test public void openWithInvalidFileSizeClearsDirectory() throws Exception {
+    cache.close();
+    generateSomeGarbageFiles();
+    createJournal("CLEAN k1 0000x001 1");
+    createNewCache();
+    assertGarbageFilesAllDeleted();
+    assertNull(cache.get("k1"));
+  }
+
+  @Test public void openWithTruncatedLineDiscardsThatLine() throws Exception {
+    cache.close();
+    writeFile(getCleanFile("k1", 0), "A");
+    writeFile(getCleanFile("k1", 1), "B");
+
+    BufferedSink sink = Okio.buffer(fileSystem.sink(journalFile));
+    sink.writeUtf8(MAGIC + "\n" + VERSION_1 + "\n100\n2\n\nCLEAN k1 1 1"); // no trailing newline
+    sink.close();
+    createNewCache();
+    assertNull(cache.get("k1"));
+
+    // The journal is not corrupt when editing after a truncated line.
+    set("k1", "C", "D");
+
+    cache.close();
+    createNewCache();
+    assertValue("k1", "C", "D");
+  }
+
+  @Test public void openWithTooManyFileSizesClearsDirectory() throws Exception {
+    cache.close();
+    generateSomeGarbageFiles();
+    createJournal("CLEAN k1 1 1 1");
+    createNewCache();
+    assertGarbageFilesAllDeleted();
+    assertNull(cache.get("k1"));
+  }
+
+  @Test public void keyWithSpaceNotPermitted() throws Exception {
+    try {
+      cache.edit("my key");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void keyWithNewlineNotPermitted() throws Exception {
+    try {
+      cache.edit("my\nkey");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void keyWithCarriageReturnNotPermitted() throws Exception {
+    try {
+      cache.edit("my\rkey");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void nullKeyThrows() throws Exception {
+    try {
+      cache.edit(null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+  }
+
+  @Test public void createNewEntryWithTooFewValuesFails() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    setString(creator, 1, "A");
+    try {
+      creator.commit();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+
+    assertFalse(fileSystem.exists(getCleanFile("k1", 0)));
+    assertFalse(fileSystem.exists(getCleanFile("k1", 1)));
+    assertFalse(fileSystem.exists(getDirtyFile("k1", 0)));
+    assertFalse(fileSystem.exists(getDirtyFile("k1", 1)));
+    assertNull(cache.get("k1"));
+
+    DiskLruCache.Editor creator2 = cache.edit("k1");
+    setString(creator2, 0, "B");
+    setString(creator2, 1, "C");
+    creator2.commit();
+  }
+
+  @Test public void revertWithTooFewValues() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    setString(creator, 1, "A");
+    creator.abort();
+    assertFalse(fileSystem.exists(getCleanFile("k1", 0)));
+    assertFalse(fileSystem.exists(getCleanFile("k1", 1)));
+    assertFalse(fileSystem.exists(getDirtyFile("k1", 0)));
+    assertFalse(fileSystem.exists(getDirtyFile("k1", 1)));
+    assertNull(cache.get("k1"));
+  }
+
+  @Test public void updateExistingEntryWithTooFewValuesReusesPreviousValues() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    setString(creator, 0, "A");
+    setString(creator, 1, "B");
+    creator.commit();
+
+    DiskLruCache.Editor updater = cache.edit("k1");
+    setString(updater, 0, "C");
+    updater.commit();
+
+    DiskLruCache.Snapshot snapshot = cache.get("k1");
+    assertSnapshotValue(snapshot, 0, "C");
+    assertSnapshotValue(snapshot, 1, "B");
+    snapshot.close();
+  }
+
+  @Test public void growMaxSize() throws Exception {
+    cache.close();
+    createNewCacheWithSize(10);
+    set("a", "a", "aaa"); // size 4
+    set("b", "bb", "bbbb"); // size 6
+    cache.setMaxSize(20);
+    set("c", "c", "c"); // size 12
+    assertEquals(12, cache.size());
+  }
+
+  @Test public void shrinkMaxSizeEvicts() throws Exception {
+    cache.close();
+    createNewCacheWithSize(20);
+    set("a", "a", "aaa"); // size 4
+    set("b", "bb", "bbbb"); // size 6
+    set("c", "c", "c"); // size 12
+    cache.setMaxSize(10);
+    assertEquals(1, executor.jobs.size());
+  }
+
+  @Test public void evictOnInsert() throws Exception {
+    cache.close();
+    createNewCacheWithSize(10);
+
+    set("a", "a", "aaa"); // size 4
+    set("b", "bb", "bbbb"); // size 6
+    assertEquals(10, cache.size());
+
+    // Cause the size to grow to 12 should evict 'A'.
+    set("c", "c", "c");
+    cache.flush();
+    assertEquals(8, cache.size());
+    assertAbsent("a");
+    assertValue("b", "bb", "bbbb");
+    assertValue("c", "c", "c");
+
+    // Causing the size to grow to 10 should evict nothing.
+    set("d", "d", "d");
+    cache.flush();
+    assertEquals(10, cache.size());
+    assertAbsent("a");
+    assertValue("b", "bb", "bbbb");
+    assertValue("c", "c", "c");
+    assertValue("d", "d", "d");
+
+    // Causing the size to grow to 18 should evict 'B' and 'C'.
+    set("e", "eeee", "eeee");
+    cache.flush();
+    assertEquals(10, cache.size());
+    assertAbsent("a");
+    assertAbsent("b");
+    assertAbsent("c");
+    assertValue("d", "d", "d");
+    assertValue("e", "eeee", "eeee");
+  }
+
+  @Test public void evictOnUpdate() throws Exception {
+    cache.close();
+    createNewCacheWithSize(10);
+
+    set("a", "a", "aa"); // size 3
+    set("b", "b", "bb"); // size 3
+    set("c", "c", "cc"); // size 3
+    assertEquals(9, cache.size());
+
+    // Causing the size to grow to 11 should evict 'A'.
+    set("b", "b", "bbbb");
+    cache.flush();
+    assertEquals(8, cache.size());
+    assertAbsent("a");
+    assertValue("b", "b", "bbbb");
+    assertValue("c", "c", "cc");
+  }
+
+  @Test public void evictionHonorsLruFromCurrentSession() throws Exception {
+    cache.close();
+    createNewCacheWithSize(10);
+    set("a", "a", "a");
+    set("b", "b", "b");
+    set("c", "c", "c");
+    set("d", "d", "d");
+    set("e", "e", "e");
+    cache.get("b").close(); // 'B' is now least recently used.
+
+    // Causing the size to grow to 12 should evict 'A'.
+    set("f", "f", "f");
+    // Causing the size to grow to 12 should evict 'C'.
+    set("g", "g", "g");
+    cache.flush();
+    assertEquals(10, cache.size());
+    assertAbsent("a");
+    assertValue("b", "b", "b");
+    assertAbsent("c");
+    assertValue("d", "d", "d");
+    assertValue("e", "e", "e");
+    assertValue("f", "f", "f");
+  }
+
+  @Test public void evictionHonorsLruFromPreviousSession() throws Exception {
+    set("a", "a", "a");
+    set("b", "b", "b");
+    set("c", "c", "c");
+    set("d", "d", "d");
+    set("e", "e", "e");
+    set("f", "f", "f");
+    cache.get("b").close(); // 'B' is now least recently used.
+    assertEquals(12, cache.size());
+    cache.close();
+    createNewCacheWithSize(10);
+
+    set("g", "g", "g");
+    cache.flush();
+    assertEquals(10, cache.size());
+    assertAbsent("a");
+    assertValue("b", "b", "b");
+    assertAbsent("c");
+    assertValue("d", "d", "d");
+    assertValue("e", "e", "e");
+    assertValue("f", "f", "f");
+    assertValue("g", "g", "g");
+  }
+
+  @Test public void cacheSingleEntryOfSizeGreaterThanMaxSize() throws Exception {
+    cache.close();
+    createNewCacheWithSize(10);
+    set("a", "aaaaa", "aaaaaa"); // size=11
+    cache.flush();
+    assertAbsent("a");
+  }
+
+  @Test public void cacheSingleValueOfSizeGreaterThanMaxSize() throws Exception {
+    cache.close();
+    createNewCacheWithSize(10);
+    set("a", "aaaaaaaaaaa", "a"); // size=12
+    cache.flush();
+    assertAbsent("a");
+  }
+
+  @Test public void constructorDoesNotAllowZeroCacheSize() throws Exception {
+    try {
+      DiskLruCache.create(fileSystem, cacheDir, appVersion, 2, 0);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void constructorDoesNotAllowZeroValuesPerEntry() throws Exception {
+    try {
+      DiskLruCache.create(fileSystem, cacheDir, appVersion, 0, 10);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void removeAbsentElement() throws Exception {
+    cache.remove("a");
+  }
+
+  @Test public void readingTheSameStreamMultipleTimes() throws Exception {
+    set("a", "a", "b");
+    DiskLruCache.Snapshot snapshot = cache.get("a");
+    assertSame(snapshot.getSource(0), snapshot.getSource(0));
+    snapshot.close();
+  }
+
+  @Test public void rebuildJournalOnRepeatedReads() throws Exception {
+    set("a", "a", "a");
+    set("b", "b", "b");
+    while (executor.jobs.isEmpty()) {
+      assertValue("a", "a", "a");
+      assertValue("b", "b", "b");
+    }
+  }
+
+  @Test public void rebuildJournalOnRepeatedEdits() throws Exception {
+    while (executor.jobs.isEmpty()) {
+      set("a", "a", "a");
+      set("b", "b", "b");
+    }
+    executor.jobs.removeFirst().run();
+
+    // Sanity check that a rebuilt journal behaves normally.
+    assertValue("a", "a", "a");
+    assertValue("b", "b", "b");
+  }
+
+  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/28">Issue #28</a> */
+  @Test public void rebuildJournalOnRepeatedReadsWithOpenAndClose() throws Exception {
+    set("a", "a", "a");
+    set("b", "b", "b");
+    while (executor.jobs.isEmpty()) {
+      assertValue("a", "a", "a");
+      assertValue("b", "b", "b");
+      cache.close();
+      createNewCache();
+    }
+  }
+
+  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/28">Issue #28</a> */
+  @Test public void rebuildJournalOnRepeatedEditsWithOpenAndClose() throws Exception {
+    while (executor.jobs.isEmpty()) {
+      set("a", "a", "a");
+      set("b", "b", "b");
+      cache.close();
+      createNewCache();
+    }
+  }
+
+  @Test public void rebuildJournalFailurePreventsEditors() throws Exception {
+    while (executor.jobs.isEmpty()) {
+      set("a", "a", "a");
+      set("b", "b", "b");
+    }
+
+    // Cause the rebuild action to fail.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
+    executor.jobs.removeFirst().run();
+
+    // Don't allow edits under any circumstances.
+    assertNull(cache.edit("a"));
+    assertNull(cache.edit("c"));
+    DiskLruCache.Snapshot snapshot = cache.get("a");
+    assertNull(snapshot.edit());
+    snapshot.close();
+  }
+
+  @Test public void rebuildJournalFailureIsRetried() throws Exception {
+    while (executor.jobs.isEmpty()) {
+      set("a", "a", "a");
+      set("b", "b", "b");
+    }
+
+    // Cause the rebuild action to fail.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
+    executor.jobs.removeFirst().run();
+
+    // The rebuild is retried on cache hits and on cache edits.
+    DiskLruCache.Snapshot snapshot = cache.get("b");
+    snapshot.close();
+    assertNull(cache.edit("d"));
+    assertEquals(2, executor.jobs.size());
+
+    // On cache misses, no retry job is queued.
+    assertNull(cache.get("c"));
+    assertEquals(2, executor.jobs.size());
+
+    // Let the rebuild complete successfully.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), false);
+    executor.jobs.removeFirst().run();
+    assertJournalEquals("CLEAN a 1 1", "CLEAN b 1 1");
+  }
+
+  @Test public void rebuildJournalFailureWithInFlightEditors() throws Exception {
+    while (executor.jobs.isEmpty()) {
+      set("a", "a", "a");
+      set("b", "b", "b");
+    }
+    DiskLruCache.Editor commitEditor = cache.edit("c");
+    DiskLruCache.Editor abortEditor = cache.edit("d");
+    cache.edit("e"); // Grab an editor, but don't do anything with it.
+
+    // Cause the rebuild action to fail.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
+    executor.jobs.removeFirst().run();
+
+    // In-flight editors can commit and have their values retained.
+    setString(commitEditor, 0, "c");
+    setString(commitEditor, 1, "c");
+    commitEditor.commit();
+    assertValue("c", "c", "c");
+
+    abortEditor.abort();
+
+    // Let the rebuild complete successfully.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), false);
+    executor.jobs.removeFirst().run();
+    assertJournalEquals("CLEAN a 1 1", "CLEAN b 1 1", "DIRTY e", "CLEAN c 1 1");
+  }
+
+  @Test public void rebuildJournalFailureWithEditorsInFlightThenClose() throws Exception {
+    while (executor.jobs.isEmpty()) {
+      set("a", "a", "a");
+      set("b", "b", "b");
+    }
+    DiskLruCache.Editor commitEditor = cache.edit("c");
+    DiskLruCache.Editor abortEditor = cache.edit("d");
+    cache.edit("e"); // Grab an editor, but don't do anything with it.
+
+    // Cause the rebuild action to fail.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
+    executor.jobs.removeFirst().run();
+
+    setString(commitEditor, 0, "c");
+    setString(commitEditor, 1, "c");
+    commitEditor.commit();
+    assertValue("c", "c", "c");
+
+    abortEditor.abort();
+
+    cache.close();
+    createNewCache();
+
+    // Although 'c' successfully committed above, the journal wasn't available to issue a CLEAN op.
+    // Because the last state of 'c' was DIRTY before the journal failed, it should be removed
+    // entirely on a subsequent open.
+    assertEquals(4, cache.size());
+    assertAbsent("c");
+    assertAbsent("d");
+    assertAbsent("e");
+  }
+
+  @Test public void rebuildJournalFailureAllowsRemovals() throws Exception {
+    while (executor.jobs.isEmpty()) {
+      set("a", "a", "a");
+      set("b", "b", "b");
+    }
+
+    // Cause the rebuild action to fail.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
+    executor.jobs.removeFirst().run();
+
+    assertTrue(cache.remove("a"));
+    assertAbsent("a");
+
+    // Let the rebuild complete successfully.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), false);
+    executor.jobs.removeFirst().run();
+
+    assertJournalEquals("CLEAN b 1 1");
+  }
+
+  @Test public void rebuildJournalFailureWithRemovalThenClose() throws Exception {
+    while (executor.jobs.isEmpty()) {
+      set("a", "a", "a");
+      set("b", "b", "b");
+    }
+
+    // Cause the rebuild action to fail.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
+    executor.jobs.removeFirst().run();
+
+    assertTrue(cache.remove("a"));
+    assertAbsent("a");
+
+    cache.close();
+    createNewCache();
+
+    // The journal will have no record that 'a' was removed. It will have an entry for 'a', but when
+    // it tries to read the cache files, it will find they were deleted. Once it encounters an entry
+    // with missing cache files, it should remove it from the cache entirely.
+    assertEquals(4, cache.size());
+    assertNull(cache.get("a"));
+    assertEquals(2, cache.size());
+  }
+
+  @Test public void rebuildJournalFailureAllowsEvictAll() throws Exception {
+    while (executor.jobs.isEmpty()) {
+      set("a", "a", "a");
+      set("b", "b", "b");
+    }
+
+    // Cause the rebuild action to fail.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
+    executor.jobs.removeFirst().run();
+
+    cache.evictAll();
+
+    assertEquals(0, cache.size());
+    assertAbsent("a");
+    assertAbsent("b");
+
+    cache.close();
+    createNewCache();
+
+    // The journal has no record that 'a' and 'b' were removed. It will have an entry for both, but
+    // when it tries to read the cache files for either entry, it will discover the cache files are
+    // missing and remove the entries from the cache.
+    assertEquals(4, cache.size());
+    assertNull(cache.get("a"));
+    assertNull(cache.get("b"));
+    assertEquals(0, cache.size());
+  }
+
+  @Test public void rebuildJournalFailureWithCacheTrim() throws Exception {
+    while (executor.jobs.isEmpty()) {
+      set("a", "aa", "aa");
+      set("b", "bb", "bb");
+    }
+
+    // Cause the rebuild action to fail.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
+    executor.jobs.removeFirst().run();
+
+    // Trigger a job to trim the cache.
+    cache.setMaxSize(4);
+    executor.jobs.removeFirst().run();
+
+    assertAbsent("a");
+    assertValue("b", "bb", "bb");
+  }
+
+  @Test public void restoreBackupFile() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    setString(creator, 0, "ABC");
+    setString(creator, 1, "DE");
+    creator.commit();
+    cache.close();
+
+    fileSystem.rename(journalFile, journalBkpFile);
+    assertFalse(fileSystem.exists(journalFile));
+
+    createNewCache();
+
+    DiskLruCache.Snapshot snapshot = cache.get("k1");
+    assertSnapshotValue(snapshot, 0, "ABC");
+    assertSnapshotValue(snapshot, 1, "DE");
+
+    assertFalse(fileSystem.exists(journalBkpFile));
+    assertTrue(fileSystem.exists(journalFile));
+  }
+
+  @Test public void journalFileIsPreferredOverBackupFile() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    setString(creator, 0, "ABC");
+    setString(creator, 1, "DE");
+    creator.commit();
+    cache.flush();
+
+    copyFile(journalFile, journalBkpFile);
+
+    creator = cache.edit("k2");
+    setString(creator, 0, "F");
+    setString(creator, 1, "GH");
+    creator.commit();
+    cache.close();
+
+    assertTrue(fileSystem.exists(journalFile));
+    assertTrue(fileSystem.exists(journalBkpFile));
+
+    createNewCache();
+
+    DiskLruCache.Snapshot snapshotA = cache.get("k1");
+    assertSnapshotValue(snapshotA, 0, "ABC");
+    assertSnapshotValue(snapshotA, 1, "DE");
+
+    DiskLruCache.Snapshot snapshotB = cache.get("k2");
+    assertSnapshotValue(snapshotB, 0, "F");
+    assertSnapshotValue(snapshotB, 1, "GH");
+
+    assertFalse(fileSystem.exists(journalBkpFile));
+    assertTrue(fileSystem.exists(journalFile));
+  }
+
+  @Test public void openCreatesDirectoryIfNecessary() throws Exception {
+    cache.close();
+    File dir = tempDir.newFolder("testOpenCreatesDirectoryIfNecessary");
+    cache = DiskLruCache.create(fileSystem, dir, appVersion, 2, Integer.MAX_VALUE);
+    set("a", "a", "a");
+    assertTrue(fileSystem.exists(new File(dir, "a.0")));
+    assertTrue(fileSystem.exists(new File(dir, "a.1")));
+    assertTrue(fileSystem.exists(new File(dir, "journal")));
+  }
+
+  @Test public void fileDeletedExternally() throws Exception {
+    set("a", "a", "a");
+    fileSystem.delete(getCleanFile("a", 1));
+    assertNull(cache.get("a"));
+    assertEquals(0, cache.size());
+  }
+
+  @Test public void editSameVersion() throws Exception {
+    set("a", "a", "a");
+    DiskLruCache.Snapshot snapshot = cache.get("a");
+    DiskLruCache.Editor editor = snapshot.edit();
+    setString(editor, 1, "a2");
+    editor.commit();
+    assertValue("a", "a", "a2");
+  }
+
+  @Test public void editSnapshotAfterChangeAborted() throws Exception {
+    set("a", "a", "a");
+    DiskLruCache.Snapshot snapshot = cache.get("a");
+    DiskLruCache.Editor toAbort = snapshot.edit();
+    setString(toAbort, 0, "b");
+    toAbort.abort();
+    DiskLruCache.Editor editor = snapshot.edit();
+    setString(editor, 1, "a2");
+    editor.commit();
+    assertValue("a", "a", "a2");
+  }
+
+  @Test public void editSnapshotAfterChangeCommitted() throws Exception {
+    set("a", "a", "a");
+    DiskLruCache.Snapshot snapshot = cache.get("a");
+    DiskLruCache.Editor toAbort = snapshot.edit();
+    setString(toAbort, 0, "b");
+    toAbort.commit();
+    assertNull(snapshot.edit());
+  }
+
+  @Test public void editSinceEvicted() throws Exception {
+    cache.close();
+    createNewCacheWithSize(10);
+    set("a", "aa", "aaa"); // size 5
+    DiskLruCache.Snapshot snapshot = cache.get("a");
+    set("b", "bb", "bbb"); // size 5
+    set("c", "cc", "ccc"); // size 5; will evict 'A'
+    cache.flush();
+    assertNull(snapshot.edit());
+  }
+
+  @Test public void editSinceEvictedAndRecreated() throws Exception {
+    cache.close();
+    createNewCacheWithSize(10);
+    set("a", "aa", "aaa"); // size 5
+    DiskLruCache.Snapshot snapshot = cache.get("a");
+    set("b", "bb", "bbb"); // size 5
+    set("c", "cc", "ccc"); // size 5; will evict 'A'
+    set("a", "a", "aaaa"); // size 5; will evict 'B'
+    cache.flush();
+    assertNull(snapshot.edit());
+  }
+
+  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
+  @Test public void aggressiveClearingHandlesWrite() throws Exception {
+    fileSystem.deleteContents(tempDir.getRoot());
+    set("a", "a", "a");
+    assertValue("a", "a", "a");
+  }
+
+  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
+  @Test public void aggressiveClearingHandlesEdit() throws Exception {
+    set("a", "a", "a");
+    DiskLruCache.Editor a = cache.get("a").edit();
+    fileSystem.deleteContents(tempDir.getRoot());
+    setString(a, 1, "a2");
+    a.commit();
+  }
+
+  @Test public void removeHandlesMissingFile() throws Exception {
+    set("a", "a", "a");
+    getCleanFile("a", 0).delete();
+    cache.remove("a");
+  }
+
+  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
+  @Test public void aggressiveClearingHandlesPartialEdit() throws Exception {
+    set("a", "a", "a");
+    set("b", "b", "b");
+    DiskLruCache.Editor a = cache.get("a").edit();
+    setString(a, 0, "a1");
+    fileSystem.deleteContents(tempDir.getRoot());
+    setString(a, 1, "a2");
+    a.commit();
+    assertNull(cache.get("a"));
+  }
+
+  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
+  @Test public void aggressiveClearingHandlesRead() throws Exception {
+    fileSystem.deleteContents(tempDir.getRoot());
+    assertNull(cache.get("a"));
+  }
+
+  /**
+   * We had a long-lived bug where {@link DiskLruCache#trimToSize} could infinite loop if entries
+   * being edited required deletion for the operation to complete.
+   */
+  @Test public void trimToSizeWithActiveEdit() throws Exception {
+    set("a", "a1234", "a1234");
+    DiskLruCache.Editor a = cache.edit("a");
+    setString(a, 0, "a123");
+
+    cache.setMaxSize(8); // Smaller than the sum of active edits!
+    cache.flush(); // Force trimToSize().
+    assertEquals(0, cache.size());
+    assertNull(cache.get("a"));
+
+    // After the edit is completed, its entry is still gone.
+    setString(a, 1, "a1");
+    a.commit();
+    assertAbsent("a");
+    assertEquals(0, cache.size());
+  }
+
+  @Test public void evictAll() throws Exception {
+    set("a", "a", "a");
+    set("b", "b", "b");
+    cache.evictAll();
+    assertEquals(0, cache.size());
+    assertAbsent("a");
+    assertAbsent("b");
+  }
+
+  @Test public void evictAllWithPartialCreate() throws Exception {
+    DiskLruCache.Editor a = cache.edit("a");
+    setString(a, 0, "a1");
+    setString(a, 1, "a2");
+    cache.evictAll();
+    assertEquals(0, cache.size());
+    a.commit();
+    assertAbsent("a");
+  }
+
+  @Test public void evictAllWithPartialEditDoesNotStoreAValue() throws Exception {
+    set("a", "a", "a");
+    DiskLruCache.Editor a = cache.edit("a");
+    setString(a, 0, "a1");
+    setString(a, 1, "a2");
+    cache.evictAll();
+    assertEquals(0, cache.size());
+    a.commit();
+    assertAbsent("a");
+  }
+
+  @Test public void evictAllDoesntInterruptPartialRead() throws Exception {
+    set("a", "a", "a");
+    DiskLruCache.Snapshot a = cache.get("a");
+    assertSnapshotValue(a, 0, "a");
+    cache.evictAll();
+    assertEquals(0, cache.size());
+    assertAbsent("a");
+    assertSnapshotValue(a, 1, "a");
+    a.close();
+  }
+
+  @Test public void editSnapshotAfterEvictAllReturnsNullDueToStaleValue() throws Exception {
+    set("a", "a", "a");
+    DiskLruCache.Snapshot a = cache.get("a");
+    cache.evictAll();
+    assertEquals(0, cache.size());
+    assertAbsent("a");
+    assertNull(a.edit());
+    a.close();
+  }
+
+  @Test public void iterator() throws Exception {
+    set("a", "a1", "a2");
+    set("b", "b1", "b2");
+    set("c", "c1", "c2");
+    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
+
+    assertTrue(iterator.hasNext());
+    DiskLruCache.Snapshot a = iterator.next();
+    assertEquals("a", a.key());
+    assertSnapshotValue(a, 0, "a1");
+    assertSnapshotValue(a, 1, "a2");
+    a.close();
+
+    assertTrue(iterator.hasNext());
+    DiskLruCache.Snapshot b = iterator.next();
+    assertEquals("b", b.key());
+    assertSnapshotValue(b, 0, "b1");
+    assertSnapshotValue(b, 1, "b2");
+    b.close();
+
+    assertTrue(iterator.hasNext());
+    DiskLruCache.Snapshot c = iterator.next();
+    assertEquals("c", c.key());
+    assertSnapshotValue(c, 0, "c1");
+    assertSnapshotValue(c, 1, "c2");
+    c.close();
+
+    assertFalse(iterator.hasNext());
+    try {
+      iterator.next();
+      fail();
+    } catch (NoSuchElementException expected) {
+    }
+  }
+
+  @Test public void iteratorElementsAddedDuringIterationAreOmitted() throws Exception {
+    set("a", "a1", "a2");
+    set("b", "b1", "b2");
+    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
+
+    DiskLruCache.Snapshot a = iterator.next();
+    assertEquals("a", a.key());
+    a.close();
+
+    set("c", "c1", "c2");
+
+    DiskLruCache.Snapshot b = iterator.next();
+    assertEquals("b", b.key());
+    b.close();
+
+    assertFalse(iterator.hasNext());
+  }
+
+  @Test public void iteratorElementsUpdatedDuringIterationAreUpdated() throws Exception {
+    set("a", "a1", "a2");
+    set("b", "b1", "b2");
+    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
+
+    DiskLruCache.Snapshot a = iterator.next();
+    assertEquals("a", a.key());
+    a.close();
+
+    set("b", "b3", "b4");
+
+    DiskLruCache.Snapshot b = iterator.next();
+    assertEquals("b", b.key());
+    assertSnapshotValue(b, 0, "b3");
+    assertSnapshotValue(b, 1, "b4");
+    b.close();
+  }
+
+  @Test public void iteratorElementsRemovedDuringIterationAreOmitted() throws Exception {
+    set("a", "a1", "a2");
+    set("b", "b1", "b2");
+    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
+
+    cache.remove("b");
+
+    DiskLruCache.Snapshot a = iterator.next();
+    assertEquals("a", a.key());
+    a.close();
+
+    assertFalse(iterator.hasNext());
+  }
+
+  @Test public void iteratorRemove() throws Exception {
+    set("a", "a1", "a2");
+    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
+
+    DiskLruCache.Snapshot a = iterator.next();
+    a.close();
+    iterator.remove();
+
+    assertEquals(null, cache.get("a"));
+  }
+
+  @Test public void iteratorRemoveBeforeNext() throws Exception {
+    set("a", "a1", "a2");
+    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
+    try {
+      iterator.remove();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  @Test public void iteratorRemoveOncePerCallToNext() throws Exception {
+    set("a", "a1", "a2");
+    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
+
+    DiskLruCache.Snapshot a = iterator.next();
+    iterator.remove();
+    a.close();
+
+    try {
+      iterator.remove();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  @Test public void cacheClosedTruncatesIterator() throws Exception {
+    set("a", "a1", "a2");
+    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
+    cache.close();
+    assertFalse(iterator.hasNext());
+  }
+
+  @Test public void isClosed_uninitializedCache() throws Exception {
+    // Create an uninitialized cache.
+    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
+    toClose.add(cache);
+
+    assertFalse(cache.isClosed());
+    cache.close();
+    assertTrue(cache.isClosed());
+  }
+
+  @Test public void journalWriteFailsDuringEdit() throws Exception {
+    set("a", "a", "a");
+    set("b", "b", "b");
+
+    // We can't begin the edit if writing 'DIRTY' fails.
+    fileSystem.setFaultyWrite(journalFile, true);
+    assertNull(cache.edit("c"));
+
+    // Once the journal has a failure, subsequent writes aren't permitted.
+    fileSystem.setFaultyWrite(journalFile, false);
+    assertNull(cache.edit("d"));
+
+    // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
+    cache.close();
+    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
+    assertValue("a", "a", "a");
+    assertValue("b", "b", "b");
+    assertAbsent("c");
+    assertAbsent("d");
+  }
+
+  /**
+   * We had a bug where the cache was left in an inconsistent state after a journal write failed.
+   * https://github.com/square/okhttp/issues/1211
+   */
+  @Test public void journalWriteFailsDuringEditorCommit() throws Exception {
+    set("a", "a", "a");
+    set("b", "b", "b");
+
+    // Create an entry that fails to write to the journal during commit.
+    DiskLruCache.Editor editor = cache.edit("c");
+    setString(editor, 0, "c");
+    setString(editor, 1, "c");
+    fileSystem.setFaultyWrite(journalFile, true);
+    editor.commit();
+
+    // Once the journal has a failure, subsequent writes aren't permitted.
+    fileSystem.setFaultyWrite(journalFile, false);
+    assertNull(cache.edit("d"));
+
+    // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
+    cache.close();
+    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
+    assertValue("a", "a", "a");
+    assertValue("b", "b", "b");
+    assertAbsent("c");
+    assertAbsent("d");
+  }
+
+  @Test public void journalWriteFailsDuringEditorAbort() throws Exception {
+    set("a", "a", "a");
+    set("b", "b", "b");
+
+    // Create an entry that fails to write to the journal during abort.
+    DiskLruCache.Editor editor = cache.edit("c");
+    setString(editor, 0, "c");
+    setString(editor, 1, "c");
+    fileSystem.setFaultyWrite(journalFile, true);
+    editor.abort();
+
+    // Once the journal has a failure, subsequent writes aren't permitted.
+    fileSystem.setFaultyWrite(journalFile, false);
+    assertNull(cache.edit("d"));
+
+    // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
+    cache.close();
+    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
+    assertValue("a", "a", "a");
+    assertValue("b", "b", "b");
+    assertAbsent("c");
+    assertAbsent("d");
+  }
+
+  @Test public void journalWriteFailsDuringRemove() throws Exception {
+    set("a", "a", "a");
+    set("b", "b", "b");
+
+    // Remove, but the journal write will fail.
+    fileSystem.setFaultyWrite(journalFile, true);
+    assertTrue(cache.remove("a"));
+
+    // Confirm that the entry was still removed.
+    fileSystem.setFaultyWrite(journalFile, false);
+    cache.close();
+    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
+    assertAbsent("a");
+    assertValue("b", "b", "b");
+  }
+
+  @Test public void cleanupTrimFailurePreventsNewEditors() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aa");
+    set("b", "bb", "bbb");
+
+    // Cause the cache trim job to fail.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
+    executor.jobs.pop().run();
+
+    // Confirm that edits are prevented after a cache trim failure.
+    assertNull(cache.edit("a"));
+    assertNull(cache.edit("b"));
+    assertNull(cache.edit("c"));
+
+    // Allow the test to clean up.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
+  }
+
+  @Test public void cleanupTrimFailureRetriedOnEditors() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aa");
+    set("b", "bb", "bbb");
+
+    // Cause the cache trim job to fail.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
+    executor.jobs.pop().run();
+
+    // An edit should now add a job to clean up if the most recent trim failed.
+    assertNull(cache.edit("b"));
+    executor.jobs.pop().run();
+
+    // Confirm a successful cache trim now allows edits.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
+    assertNull(cache.edit("c"));
+    executor.jobs.pop().run();
+    set("c", "cc", "cc");
+    assertValue("c", "cc", "cc");
+  }
+
+  @Test public void cleanupTrimFailureWithInFlightEditor() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aaa");
+    set("b", "bb", "bb");
+    DiskLruCache.Editor inFlightEditor = cache.edit("c");
+
+    // Cause the cache trim job to fail.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
+    executor.jobs.pop().run();
+
+    // The in-flight editor can still write after a trim failure.
+    setString(inFlightEditor, 0, "cc");
+    setString(inFlightEditor, 1, "cc");
+    inFlightEditor.commit();
+
+    // Confirm the committed values are present after a successful cache trim.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
+    executor.jobs.pop().run();
+    assertValue("c", "cc", "cc");
+  }
+
+  @Test public void cleanupTrimFailureAllowsSnapshotReads() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aa");
+    set("b", "bb", "bbb");
+
+    // Cause the cache trim job to fail.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
+    executor.jobs.pop().run();
+
+    // Confirm we still allow snapshot reads after a trim failure.
+    assertValue("a", "aa", "aa");
+    assertValue("b", "bb", "bbb");
+
+    // Allow the test to clean up.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
+  }
+
+  @Test public void cleanupTrimFailurePreventsSnapshotWrites() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aa");
+    set("b", "bb", "bbb");
+
+    // Cause the cache trim job to fail.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
+    executor.jobs.pop().run();
+
+    // Confirm snapshot writes are prevented after a trim failure.
+    DiskLruCache.Snapshot snapshot1 = cache.get("a");
+    assertNull(snapshot1.edit());
+    snapshot1.close();
+    DiskLruCache.Snapshot snapshot2 = cache.get("b");
+    assertNull(snapshot2.edit());
+    snapshot2.close();
+
+    // Allow the test to clean up.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
+  }
+
+  @Test public void evictAllAfterCleanupTrimFailure() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aa");
+    set("b", "bb", "bbb");
+
+    // Cause the cache trim job to fail.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
+    executor.jobs.pop().run();
+
+    // Confirm we prevent edits after a trim failure.
+    assertNull(cache.edit("c"));
+
+    // A successful eviction should allow new writes.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
+    cache.evictAll();
+    set("c", "cc", "cc");
+    assertValue("c", "cc", "cc");
+  }
+
+  @Test public void manualRemovalAfterCleanupTrimFailure() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aa");
+    set("b", "bb", "bbb");
+
+    // Cause the cache trim job to fail.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
+    executor.jobs.pop().run();
+
+    // Confirm we prevent edits after a trim failure.
+    assertNull(cache.edit("c"));
+
+    // A successful removal which trims the cache should allow new writes.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
+    cache.remove("a");
+    set("c", "cc", "cc");
+    assertValue("c", "cc", "cc");
+  }
+
+  @Test public void flushingAfterCleanupTrimFailure() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aa");
+    set("b", "bb", "bbb");
+
+    // Cause the cache trim job to fail.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
+    executor.jobs.pop().run();
+
+    // Confirm we prevent edits after a trim failure.
+    assertNull(cache.edit("c"));
+
+    // A successful flush trims the cache and should allow new writes.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
+    cache.flush();
+    set("c", "cc", "cc");
+    assertValue("c", "cc", "cc");
+  }
+
+  @Test public void cleanupTrimFailureWithPartialSnapshot() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aa");
+    set("b", "bb", "bbb");
+
+    // Cause the cache trim to fail on the second value leaving a partial snapshot.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.1"), true);
+    executor.jobs.pop().run();
+
+    // Confirm the partial snapshot is not returned.
+    assertNull(cache.get("a"));
+
+    // Confirm we prevent edits after a trim failure.
+    assertNull(cache.edit("a"));
+
+    // Confirm the partial snapshot is not returned after a successful trim.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.1"), false);
+    executor.jobs.pop().run();
+    assertNull(cache.get("a"));
+  }
+
+  @Test public void noSizeCorruptionAfterCreatorDetached() throws Exception {
+    // Create an editor for k1. Detach it by clearing the cache.
+    DiskLruCache.Editor editor = cache.edit("k1");
+    setString(editor, 0, "a");
+    setString(editor, 1, "a");
+    cache.evictAll();
+
+    // Create a new value in its place.
+    set("k1", "bb", "bb");
+    assertEquals(4, cache.size());
+
+    // Committing the detached editor should not change the cache's size.
+    editor.commit();
+    assertEquals(4, cache.size());
+    assertValue("k1", "bb", "bb");
+  }
+
+  @Test public void noSizeCorruptionAfterEditorDetached() throws Exception {
+    set("k1", "a", "a");
+
+    // Create an editor for k1. Detach it by clearing the cache.
+    DiskLruCache.Editor editor = cache.edit("k1");
+    setString(editor, 0, "bb");
+    setString(editor, 1, "bb");
+    cache.evictAll();
+
+    // Create a new value in its place.
+    set("k1", "ccc", "ccc");
+    assertEquals(6, cache.size());
+
+    // Committing the detached editor should not change the cache's size.
+    editor.commit();
+    assertEquals(6, cache.size());
+    assertValue("k1", "ccc", "ccc");
+  }
+
+  @Test public void noNewSourceAfterEditorDetached() throws Exception {
+    set("k1", "a", "a");
+
+    DiskLruCache.Editor editor = cache.edit("k1");
+    cache.evictAll();
+
+    assertNull(editor.newSource(0));
+  }
+
+  @Test public void editsDiscardedAfterEditorDetached() throws Exception {
+    set("k1", "a", "a");
+
+    // Create an editor, then detach it.
+    DiskLruCache.Editor editor = cache.edit("k1");
+    BufferedSink sink = Okio.buffer(editor.newSink(0));
+    cache.evictAll();
+
+    // Create another value in its place.
+    set("k1", "ccc", "ccc");
+
+    // Complete the original edit. It goes into a black hole.
+    sink.writeUtf8("bb");
+    sink.close();
+
+    assertValue("k1", "ccc", "ccc");
+  }
+
+  @Test public void abortAfterDetach() throws Exception {
+    set("k1", "a", "a");
+
+    DiskLruCache.Editor editor = cache.edit("k1");
+    cache.evictAll();
+
+    editor.abort();
+    assertEquals(0, cache.size());
+    assertAbsent("k1");
+  }
+
+  private void assertJournalEquals(String... expectedBodyLines) throws Exception {
+    List<String> expectedLines = new ArrayList<>();
+    expectedLines.add(MAGIC);
+    expectedLines.add(VERSION_1);
+    expectedLines.add("100");
+    expectedLines.add("2");
+    expectedLines.add("");
+    expectedLines.addAll(Arrays.asList(expectedBodyLines));
+    assertEquals(expectedLines, readJournalLines());
+  }
+
+  private void createJournal(String... bodyLines) throws Exception {
+    createJournalWithHeader(MAGIC, VERSION_1, "100", "2", "", bodyLines);
+  }
+
+  private void createJournalWithHeader(String magic, String version, String appVersion,
+      String valueCount, String blank, String... bodyLines) throws Exception {
+    BufferedSink sink = Okio.buffer(fileSystem.sink(journalFile));
+    sink.writeUtf8(magic + "\n");
+    sink.writeUtf8(version + "\n");
+    sink.writeUtf8(appVersion + "\n");
+    sink.writeUtf8(valueCount + "\n");
+    sink.writeUtf8(blank + "\n");
+    for (String line : bodyLines) {
+      sink.writeUtf8(line);
+      sink.writeUtf8("\n");
+    }
+    sink.close();
+  }
+
+  private List<String> readJournalLines() throws Exception {
+    List<String> result = new ArrayList<>();
+    BufferedSource source = Okio.buffer(fileSystem.source(journalFile));
+    for (String line; (line = source.readUtf8Line()) != null; ) {
+      result.add(line);
+    }
+    source.close();
+    return result;
+  }
+
+  private File getCleanFile(String key, int index) {
+    return new File(cacheDir, key + "." + index);
+  }
+
+  private File getDirtyFile(String key, int index) {
+    return new File(cacheDir, key + "." + index + ".tmp");
+  }
+
+  private String readFile(File file) throws Exception {
+    BufferedSource source = Okio.buffer(fileSystem.source(file));
+    String result = source.readUtf8();
+    source.close();
+    return result;
+  }
+
+  public void writeFile(File file, String content) throws Exception {
+    BufferedSink sink = Okio.buffer(fileSystem.sink(file));
+    sink.writeUtf8(content);
+    sink.close();
+  }
+
+  private static void assertInoperable(DiskLruCache.Editor editor) throws Exception {
+    try {
+      setString(editor, 0, "A");
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+    try {
+      editor.newSource(0);
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+    try {
+      editor.newSink(0);
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+    try {
+      editor.commit();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+    try {
+      editor.abort();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  private void generateSomeGarbageFiles() throws Exception {
+    File dir1 = new File(cacheDir, "dir1");
+    File dir2 = new File(dir1, "dir2");
+    writeFile(getCleanFile("g1", 0), "A");
+    writeFile(getCleanFile("g1", 1), "B");
+    writeFile(getCleanFile("g2", 0), "C");
+    writeFile(getCleanFile("g2", 1), "D");
+    writeFile(getCleanFile("g2", 1), "D");
+    writeFile(new File(cacheDir, "otherFile0"), "E");
+    writeFile(new File(dir2, "otherFile1"), "F");
+  }
+
+  private void assertGarbageFilesAllDeleted() {
+    assertFalse(fileSystem.exists(getCleanFile("g1", 0)));
+    assertFalse(fileSystem.exists(getCleanFile("g1", 1)));
+    assertFalse(fileSystem.exists(getCleanFile("g2", 0)));
+    assertFalse(fileSystem.exists(getCleanFile("g2", 1)));
+    assertFalse(fileSystem.exists(new File(cacheDir, "otherFile0")));
+    assertFalse(fileSystem.exists(new File(cacheDir, "dir1")));
+  }
+
+  private void set(String key, String value0, String value1) throws Exception {
+    DiskLruCache.Editor editor = cache.edit(key);
+    setString(editor, 0, value0);
+    setString(editor, 1, value1);
+    editor.commit();
+  }
+
+  public static void setString(DiskLruCache.Editor editor, int index, String value)
+      throws IOException {
+    BufferedSink writer = Okio.buffer(editor.newSink(index));
+    writer.writeUtf8(value);
+    writer.close();
+  }
+
+  private void assertAbsent(String key) throws Exception {
+    DiskLruCache.Snapshot snapshot = cache.get(key);
+    if (snapshot != null) {
+      snapshot.close();
+      fail();
+    }
+    assertFalse(fileSystem.exists(getCleanFile(key, 0)));
+    assertFalse(fileSystem.exists(getCleanFile(key, 1)));
+    assertFalse(fileSystem.exists(getDirtyFile(key, 0)));
+    assertFalse(fileSystem.exists(getDirtyFile(key, 1)));
+  }
+
+  private void assertValue(String key, String value0, String value1) throws Exception {
+    DiskLruCache.Snapshot snapshot = cache.get(key);
+    assertSnapshotValue(snapshot, 0, value0);
+    assertSnapshotValue(snapshot, 1, value1);
+    assertTrue(fileSystem.exists(getCleanFile(key, 0)));
+    assertTrue(fileSystem.exists(getCleanFile(key, 1)));
+    snapshot.close();
+  }
+
+  private void assertSnapshotValue(DiskLruCache.Snapshot snapshot, int index, String value)
+      throws IOException {
+    assertEquals(value, sourceAsString(snapshot.getSource(index)));
+    assertEquals(value.length(), snapshot.getLength(index));
+  }
+
+  private String sourceAsString(Source source) throws IOException {
+    return source != null ? Okio.buffer(source).readUtf8() : null;
+  }
+
+  private void copyFile(File from, File to) throws IOException {
+    Source source = fileSystem.source(from);
+    BufferedSink sink = Okio.buffer(fileSystem.sink(to));
+    sink.writeAll(source);
+    source.close();
+    sink.close();
+  }
+
+  private static class TestExecutor implements Executor {
+    final Deque<Runnable> jobs = new ArrayDeque<>();
+
+    @Override public void execute(Runnable command) {
+      jobs.addLast(command);
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/cache2/FileOperatorTest.java b/okhttp-tests/src/test/java/okhttp3/internal/cache2/FileOperatorTest.java
new file mode 100644
index 0000000000..21bbd49358
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/cache2/FileOperatorTest.java
@@ -0,0 +1,200 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.cache2;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.RandomAccessFile;
+import java.util.Random;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.Okio;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class FileOperatorTest {
+  @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
+
+  private File file;
+  private RandomAccessFile randomAccessFile;
+
+  @Before public void setUp() throws Exception {
+    file = tempDir.newFile();
+    randomAccessFile = new RandomAccessFile(file, "rw");
+  }
+
+  @After public void tearDown() throws Exception {
+    randomAccessFile.close();
+  }
+
+  @Test public void read() throws Exception {
+    write(ByteString.encodeUtf8("Hello, World"));
+
+    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
+
+    Buffer buffer = new Buffer();
+    operator.read(0, buffer, 5);
+    assertEquals("Hello", buffer.readUtf8());
+
+    operator.read(4, buffer, 5);
+    assertEquals("o, Wo", buffer.readUtf8());
+  }
+
+  @Test public void write() throws Exception {
+    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
+
+    Buffer buffer1 = new Buffer().writeUtf8("Hello, World");
+    operator.write(0, buffer1, 5);
+    assertEquals(", World", buffer1.readUtf8());
+
+    Buffer buffer2 = new Buffer().writeUtf8("icopter!");
+    operator.write(3, buffer2, 7);
+    assertEquals("!", buffer2.readUtf8());
+
+    assertEquals(ByteString.encodeUtf8("Helicopter"), snapshot());
+  }
+
+  @Test public void readAndWrite() throws Exception {
+    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
+
+    write(ByteString.encodeUtf8("woman god creates dinosaurs destroys. "));
+    Buffer buffer = new Buffer();
+    operator.read(6, buffer, 21);
+    operator.read(36, buffer, 1);
+    operator.read(5, buffer, 5);
+    operator.read(28, buffer, 8);
+    operator.read(17, buffer, 10);
+    operator.read(36, buffer, 2);
+    operator.read(2, buffer, 4);
+    operator.write(0, buffer, buffer.size());
+    operator.read(0, buffer, 12);
+    operator.read(47, buffer, 3);
+    operator.read(45, buffer, 2);
+    operator.read(47, buffer, 3);
+    operator.read(26, buffer, 10);
+    operator.read(23, buffer, 3);
+    operator.write(47, buffer, buffer.size());
+    operator.read(62, buffer, 6);
+    operator.read(4, buffer, 19);
+    operator.write(80, buffer, buffer.size());
+
+    assertEquals(snapshot(), ByteString.encodeUtf8(""
+        + "god creates dinosaurs. "
+        + "god destroys dinosaurs. "
+        + "god creates man. "
+        + "man destroys god. "
+        + "man creates dinosaurs. "));
+  }
+
+  @Test public void multipleOperatorsShareOneFile() throws Exception {
+    FileOperator operatorA = new FileOperator(randomAccessFile.getChannel());
+    FileOperator operatorB = new FileOperator(randomAccessFile.getChannel());
+
+    Buffer bufferA = new Buffer();
+    Buffer bufferB = new Buffer();
+
+    bufferA.writeUtf8("Dodgson!\n");
+    operatorA.write(0, bufferA, 9);
+
+    bufferB.writeUtf8("You shouldn't use my name.\n");
+    operatorB.write(9, bufferB, 27);
+
+    bufferA.writeUtf8("Dodgson, we've got Dodgson here!\n");
+    operatorA.write(36, bufferA, 33);
+
+    operatorB.read(0, bufferB, 9);
+    assertEquals("Dodgson!\n", bufferB.readUtf8());
+
+    operatorA.read(9, bufferA, 27);
+    assertEquals("You shouldn't use my name.\n", bufferA.readUtf8());
+
+    operatorB.read(36, bufferB, 33);
+    assertEquals("Dodgson, we've got Dodgson here!\n", bufferB.readUtf8());
+  }
+
+  @Test public void largeRead() throws Exception {
+    ByteString data = randomByteString(1000000);
+    write(data);
+
+    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
+
+    Buffer buffer = new Buffer();
+    operator.read(0, buffer, data.size());
+    assertEquals(data, buffer.readByteString());
+  }
+
+  @Test public void largeWrite() throws Exception {
+    ByteString data = randomByteString(1000000);
+
+    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
+
+    Buffer buffer = new Buffer().write(data);
+    operator.write(0, buffer, data.size());
+
+    assertEquals(data, snapshot());
+  }
+
+  @Test public void readBounds() throws Exception {
+    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
+    Buffer buffer = new Buffer();
+    try {
+      operator.read(0, buffer, -1L);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+  }
+
+  @Test public void writeBounds() throws Exception {
+    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
+    Buffer buffer = new Buffer().writeUtf8("abc");
+    try {
+      operator.write(0, buffer, -1L);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+    try {
+      operator.write(0, buffer, 4L);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+  }
+
+  private ByteString randomByteString(int byteCount) {
+    byte[] bytes = new byte[byteCount];
+    new Random(0).nextBytes(bytes);
+    return ByteString.of(bytes);
+  }
+
+  private ByteString snapshot() throws IOException {
+    randomAccessFile.getChannel().force(false);
+    BufferedSource source = Okio.buffer(Okio.source(file));
+    return source.readByteString();
+  }
+
+  private void write(ByteString data) throws IOException {
+    BufferedSink sink = Okio.buffer(Okio.sink(file));
+    sink.write(data);
+    sink.close();
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/cache2/RelayTest.java b/okhttp-tests/src/test/java/okhttp3/internal/cache2/RelayTest.java
new file mode 100644
index 0000000000..cbffa87d09
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/cache2/RelayTest.java
@@ -0,0 +1,255 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.cache2;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.Okio;
+import okio.Pipe;
+import okio.Source;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class RelayTest {
+  @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
+
+  private ExecutorService executor = Executors.newCachedThreadPool();
+  private ByteString metadata = ByteString.encodeUtf8("great metadata!");
+  private File file;
+
+  @Before public void setUp() throws Exception {
+    file = tempDir.newFile();
+  }
+
+  @After public void tearDown() throws Exception {
+    executor.shutdown();
+  }
+
+  @Test public void singleSource() throws Exception {
+    Buffer upstream = new Buffer();
+    upstream.writeUtf8("abcdefghijklm");
+
+    Relay relay = Relay.edit(file, upstream, metadata, 1024);
+    Source source = relay.newSource();
+    Buffer sourceBuffer = new Buffer();
+
+    assertEquals(5, source.read(sourceBuffer, 5));
+    assertEquals("abcde", sourceBuffer.readUtf8());
+
+    assertEquals(8, source.read(sourceBuffer, 1024));
+    assertEquals("fghijklm", sourceBuffer.readUtf8());
+
+    assertEquals(-1, source.read(sourceBuffer, 1024));
+    assertEquals(0, sourceBuffer.size());
+
+    source.close();
+    assertTrue(relay.isClosed());
+    assertFile(Relay.PREFIX_CLEAN, 13L, metadata.size(), "abcdefghijklm", metadata);
+  }
+
+  @Test public void multipleSources() throws Exception {
+    Buffer upstream = new Buffer();
+    upstream.writeUtf8("abcdefghijklm");
+
+    Relay relay = Relay.edit(file, upstream, metadata, 1024);
+    BufferedSource source1 = Okio.buffer(relay.newSource());
+    BufferedSource source2 = Okio.buffer(relay.newSource());
+
+    assertEquals("abcdefghijklm", source1.readUtf8());
+    assertEquals("abcdefghijklm", source2.readUtf8());
+    source1.close();
+    source2.close();
+    assertTrue(relay.isClosed());
+
+    assertFile(Relay.PREFIX_CLEAN, 13L, metadata.size(), "abcdefghijklm", metadata);
+  }
+
+  @Test public void readFromBuffer() throws Exception {
+    Buffer upstream = new Buffer();
+    upstream.writeUtf8("abcdefghij");
+
+    Relay relay = Relay.edit(file, upstream, metadata, 5);
+    BufferedSource source1 = Okio.buffer(relay.newSource());
+    BufferedSource source2 = Okio.buffer(relay.newSource());
+
+    assertEquals("abcde", source1.readUtf8(5));
+    assertEquals("abcde", source2.readUtf8(5));
+    assertEquals("fghij", source2.readUtf8(5));
+    assertEquals("fghij", source1.readUtf8(5));
+    assertTrue(source1.exhausted());
+    assertTrue(source2.exhausted());
+    source1.close();
+    source2.close();
+    assertTrue(relay.isClosed());
+
+    assertFile(Relay.PREFIX_CLEAN, 10L, metadata.size(), "abcdefghij", metadata);
+  }
+
+  @Test public void readFromFile() throws Exception {
+    Buffer upstream = new Buffer();
+    upstream.writeUtf8("abcdefghijklmnopqrst");
+
+    Relay relay = Relay.edit(file, upstream, metadata, 5);
+    BufferedSource source1 = Okio.buffer(relay.newSource());
+    BufferedSource source2 = Okio.buffer(relay.newSource());
+
+    assertEquals("abcdefghij", source1.readUtf8(10));
+    assertEquals("abcdefghij", source2.readUtf8(10));
+    assertEquals("klmnopqrst", source2.readUtf8(10));
+    assertEquals("klmnopqrst", source1.readUtf8(10));
+    assertTrue(source1.exhausted());
+    assertTrue(source2.exhausted());
+    source1.close();
+    source2.close();
+    assertTrue(relay.isClosed());
+
+    assertFile(Relay.PREFIX_CLEAN, 20L, metadata.size(), "abcdefghijklmnopqrst", metadata);
+  }
+
+  @Test public void readAfterEdit() throws Exception {
+    Buffer upstream = new Buffer();
+    upstream.writeUtf8("abcdefghij");
+
+    Relay relay1 = Relay.edit(file, upstream, metadata, 5);
+    BufferedSource source1 = Okio.buffer(relay1.newSource());
+    assertEquals("abcdefghij", source1.readUtf8(10));
+    assertTrue(source1.exhausted());
+    source1.close();
+    assertTrue(relay1.isClosed());
+
+    // Since relay1 is closed, new sources cannot be created.
+    assertNull(relay1.newSource());
+
+    Relay relay2 = Relay.read(file);
+    assertEquals(metadata, relay2.metadata());
+    BufferedSource source2 = Okio.buffer(relay2.newSource());
+    assertEquals("abcdefghij", source2.readUtf8(10));
+    assertTrue(source2.exhausted());
+    source2.close();
+    assertTrue(relay2.isClosed());
+
+    // Since relay2 is closed, new sources cannot be created.
+    assertNull(relay2.newSource());
+
+    assertFile(Relay.PREFIX_CLEAN, 10L, metadata.size(), "abcdefghij", metadata);
+  }
+
+  @Test public void closeBeforeExhaustLeavesDirtyFile() throws Exception {
+    Buffer upstream = new Buffer();
+    upstream.writeUtf8("abcdefghij");
+
+    Relay relay1 = Relay.edit(file, upstream, metadata, 5);
+    BufferedSource source1 = Okio.buffer(relay1.newSource());
+    assertEquals("abcdefghij", source1.readUtf8(10));
+    source1.close(); // Not exhausted!
+    assertTrue(relay1.isClosed());
+
+    try {
+      Relay.read(file);
+      fail();
+    } catch (IOException expected) {
+      assertEquals("unreadable cache file", expected.getMessage());
+    }
+
+    assertFile(Relay.PREFIX_DIRTY, -1L, -1, null, null);
+  }
+
+  @Test public void redundantCallsToCloseAreIgnored() throws Exception {
+    Buffer upstream = new Buffer();
+    upstream.writeUtf8("abcde");
+
+    Relay relay = Relay.edit(file, upstream, metadata, 1024);
+    Source source1 = relay.newSource();
+    Source source2 = relay.newSource();
+
+    source1.close();
+    source1.close(); // Unnecessary. Shouldn't decrement the reference count.
+    assertFalse(relay.isClosed());
+
+    source2.close();
+    assertTrue(relay.isClosed());
+    assertFile(Relay.PREFIX_DIRTY, -1L, -1, null, null);
+  }
+
+  @Test public void racingReaders() throws Exception {
+    Pipe pipe = new Pipe(1024);
+    BufferedSink sink = Okio.buffer(pipe.sink());
+
+    Relay relay = Relay.edit(file, pipe.source(), metadata, 5);
+
+    Future<ByteString> future1 = executor.submit(sourceReader(relay.newSource()));
+    Future<ByteString> future2 = executor.submit(sourceReader(relay.newSource()));
+
+    Thread.sleep(500);
+    sink.writeUtf8("abcdefghij");
+
+    Thread.sleep(500);
+    sink.writeUtf8("klmnopqrst");
+    sink.close();
+
+    assertEquals(ByteString.encodeUtf8("abcdefghijklmnopqrst"), future1.get());
+    assertEquals(ByteString.encodeUtf8("abcdefghijklmnopqrst"), future2.get());
+
+    assertTrue(relay.isClosed());
+
+    assertFile(Relay.PREFIX_CLEAN, 20L, metadata.size(), "abcdefghijklmnopqrst", metadata);
+  }
+
+  /** Returns a callable that reads all of source, closes it, and returns the bytes. */
+  private Callable<ByteString> sourceReader(final Source source) {
+    return new Callable<ByteString>() {
+      @Override public ByteString call() throws Exception {
+        Buffer buffer = new Buffer();
+        while (source.read(buffer, 16384) != -1) {
+        }
+        source.close();
+        return buffer.readByteString();
+      }
+    };
+  }
+
+  private void assertFile(ByteString prefix, long upstreamSize, int metadataSize, String upstream,
+      ByteString metadata) throws IOException {
+    BufferedSource source = Okio.buffer(Okio.source(file));
+    assertEquals(prefix, source.readByteString(prefix.size()));
+    assertEquals(upstreamSize, source.readLong());
+    assertEquals(metadataSize, source.readLong());
+    if (upstream != null) {
+      assertEquals(upstream, source.readUtf8(upstreamSize));
+    }
+    if (metadata != null) {
+      assertEquals(metadata, source.readByteString(metadataSize));
+    }
+    source.close();
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java b/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java
new file mode 100644
index 0000000000..b0b06e9f87
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java
@@ -0,0 +1,142 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.connection;
+
+import java.io.IOException;
+import java.security.cert.CertificateException;
+import java.util.Arrays;
+import java.util.LinkedHashSet;
+import java.util.Set;
+import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLSocket;
+import okhttp3.ConnectionSpec;
+import okhttp3.TlsVersion;
+import okhttp3.internal.Internal;
+import okhttp3.internal.tls.SslClient;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public class ConnectionSpecSelectorTest {
+  static {
+    Internal.initializeInstanceForTests();
+  }
+
+  public static final SSLHandshakeException RETRYABLE_EXCEPTION = new SSLHandshakeException(
+      "Simulated handshake exception");
+
+  private SslClient sslClient = SslClient.localhost();
+
+  @Test
+  public void nonRetryableIOException() throws Exception {
+    ConnectionSpecSelector connectionSpecSelector =
+        createConnectionSpecSelector(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS);
+    SSLSocket socket = createSocketWithEnabledProtocols(TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
+    connectionSpecSelector.configureSecureSocket(socket);
+
+    boolean retry = connectionSpecSelector.connectionFailed(
+        new IOException("Non-handshake exception"));
+    assertFalse(retry);
+    socket.close();
+  }
+
+  @Test
+  public void nonRetryableSSLHandshakeException() throws Exception {
+    ConnectionSpecSelector connectionSpecSelector =
+        createConnectionSpecSelector(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS);
+    SSLSocket socket = createSocketWithEnabledProtocols(TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
+    connectionSpecSelector.configureSecureSocket(socket);
+
+    SSLHandshakeException trustIssueException =
+        new SSLHandshakeException("Certificate handshake exception");
+    trustIssueException.initCause(new CertificateException());
+    boolean retry = connectionSpecSelector.connectionFailed(trustIssueException);
+    assertFalse(retry);
+    socket.close();
+  }
+
+  @Test
+  public void retryableSSLHandshakeException() throws Exception {
+    ConnectionSpecSelector connectionSpecSelector =
+        createConnectionSpecSelector(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS);
+    SSLSocket socket = createSocketWithEnabledProtocols(TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
+    connectionSpecSelector.configureSecureSocket(socket);
+
+    boolean retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
+    assertTrue(retry);
+    socket.close();
+  }
+
+  @Test
+  public void someFallbacksSupported() throws Exception {
+    ConnectionSpec sslV3 =
+        new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+            .tlsVersions(TlsVersion.SSL_3_0)
+            .build();
+
+    ConnectionSpecSelector connectionSpecSelector = createConnectionSpecSelector(
+        ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS, sslV3);
+
+    TlsVersion[] enabledSocketTlsVersions = {TlsVersion.TLS_1_1, TlsVersion.TLS_1_0};
+    SSLSocket socket = createSocketWithEnabledProtocols(enabledSocketTlsVersions);
+
+    // MODERN_TLS is used here.
+    connectionSpecSelector.configureSecureSocket(socket);
+    assertEnabledProtocols(socket, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
+
+    boolean retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
+    assertTrue(retry);
+    socket.close();
+
+    // COMPATIBLE_TLS is used here.
+    socket = createSocketWithEnabledProtocols(enabledSocketTlsVersions);
+    connectionSpecSelector.configureSecureSocket(socket);
+    assertEnabledProtocols(socket, TlsVersion.TLS_1_0);
+
+    retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
+    assertFalse(retry);
+    socket.close();
+
+    // sslV3 is not used because SSLv3 is not enabled on the socket.
+  }
+
+  private static ConnectionSpecSelector createConnectionSpecSelector(
+      ConnectionSpec... connectionSpecs) {
+    return new ConnectionSpecSelector(Arrays.asList(connectionSpecs));
+  }
+
+  private SSLSocket createSocketWithEnabledProtocols(TlsVersion... tlsVersions) throws IOException {
+    SSLSocket socket = (SSLSocket) sslClient.socketFactory.createSocket();
+    socket.setEnabledProtocols(javaNames(tlsVersions));
+    return socket;
+  }
+
+  private static void assertEnabledProtocols(SSLSocket socket, TlsVersion... required) {
+    Set<String> actual = new LinkedHashSet<>(Arrays.asList(socket.getEnabledProtocols()));
+    Set<String> expected = new LinkedHashSet<>(Arrays.asList(javaNames(required)));
+    assertEquals(expected, actual);
+  }
+
+  private static String[] javaNames(TlsVersion... tlsVersions) {
+    String[] protocols = new String[tlsVersions.length];
+    for (int i = 0; i < tlsVersions.length; i++) {
+      protocols[i] = tlsVersions[i].javaName();
+    }
+    return protocols;
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteExceptionTest.java b/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteExceptionTest.java
new file mode 100644
index 0000000000..209d79d5c5
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteExceptionTest.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.connection;
+
+import java.io.IOException;
+import org.junit.Test;
+
+import static org.junit.Assert.assertSame;
+
+public class RouteExceptionTest {
+
+  @Test public void getConnectionIOException_single() {
+    IOException firstException = new IOException();
+    RouteException re = new RouteException(firstException);
+    assertSame(firstException, re.getLastConnectException());
+  }
+
+  @Test public void getConnectionIOException_multiple() {
+    IOException firstException = new IOException();
+    IOException secondException = new IOException();
+    IOException thirdException = new IOException();
+    RouteException re = new RouteException(firstException);
+    re.addConnectException(secondException);
+    re.addConnectException(thirdException);
+
+    IOException connectionIOException = re.getLastConnectException();
+    assertSame(thirdException, connectionIOException);
+    Throwable[] thirdSuppressedExceptions = thirdException.getSuppressed();
+    assertSame(secondException, thirdSuppressedExceptions[0]);
+
+    Throwable[] secondSuppressedException = secondException.getSuppressed();
+    assertSame(firstException, secondSuppressedException[0]);
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java b/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java
new file mode 100644
index 0000000000..9d81d30e91
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java
@@ -0,0 +1,460 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.connection;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.net.ProxySelector;
+import java.net.SocketAddress;
+import java.net.URI;
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.NoSuchElementException;
+import javax.net.SocketFactory;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLSocketFactory;
+import okhttp3.Address;
+import okhttp3.Authenticator;
+import okhttp3.ConnectionSpec;
+import okhttp3.EventListener;
+import okhttp3.FakeDns;
+import okhttp3.Protocol;
+import okhttp3.Route;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.RecordingProxySelector;
+import okhttp3.internal.tls.SslClient;
+import org.junit.Before;
+import org.junit.Test;
+
+import static java.net.Proxy.NO_PROXY;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class RouteSelectorTest {
+  public final List<ConnectionSpec> connectionSpecs = Util.immutableList(
+      ConnectionSpec.MODERN_TLS,
+      ConnectionSpec.COMPATIBLE_TLS,
+      ConnectionSpec.CLEARTEXT);
+
+  private static final int proxyAPort = 1001;
+  private static final String proxyAHost = "proxya";
+  private static final Proxy proxyA =
+      new Proxy(Proxy.Type.HTTP, InetSocketAddress.createUnresolved(proxyAHost, proxyAPort));
+  private static final int proxyBPort = 1002;
+  private static final String proxyBHost = "proxyb";
+  private static final Proxy proxyB =
+      new Proxy(Proxy.Type.HTTP, InetSocketAddress.createUnresolved(proxyBHost, proxyBPort));
+  private String uriHost = "hosta";
+  private int uriPort = 1003;
+
+  private SocketFactory socketFactory;
+  private final SslClient sslClient = SslClient.localhost();
+  private final SSLSocketFactory sslSocketFactory = sslClient.socketFactory;
+  private HostnameVerifier hostnameVerifier;
+
+  private final Authenticator authenticator = Authenticator.NONE;
+  private final List<Protocol> protocols = Arrays.asList(Protocol.HTTP_1_1);
+  private final FakeDns dns = new FakeDns();
+  private final RecordingProxySelector proxySelector = new RecordingProxySelector();
+  private RouteDatabase routeDatabase = new RouteDatabase();
+
+  @Before public void setUp() throws Exception {
+    socketFactory = SocketFactory.getDefault();
+    hostnameVerifier = HttpsURLConnection.getDefaultHostnameVerifier();
+  }
+
+  @Test public void singleRoute() throws Exception {
+    Address address = httpAddress();
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
+
+    assertTrue(routeSelector.hasNext());
+    dns.set(uriHost, dns.allocate(1));
+    RouteSelector.Selection selection = routeSelector.next();
+    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
+    dns.assertRequests(uriHost);
+    assertFalse(selection.hasNext());
+    try {
+      selection.next();
+      fail();
+    } catch (NoSuchElementException expected) {
+    }
+
+    assertFalse(routeSelector.hasNext());
+    try {
+      routeSelector.next();
+      fail();
+    } catch (NoSuchElementException expected) {
+    }
+  }
+
+  @Test public void singleRouteReturnsFailedRoute() throws Exception {
+    Address address = httpAddress();
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
+
+    assertTrue(routeSelector.hasNext());
+    dns.set(uriHost, dns.allocate(1));
+    RouteSelector.Selection selection = routeSelector.next();
+    Route route = selection.next();
+    routeDatabase.failed(route);
+    routeSelector = new RouteSelector(address, routeDatabase, null, EventListener.NONE);
+    selection = routeSelector.next();
+    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
+    assertFalse(selection.hasNext());
+
+    try {
+      selection.next();
+      fail();
+    } catch (NoSuchElementException expected) {
+    }
+
+    assertFalse(routeSelector.hasNext());
+    try {
+      routeSelector.next();
+      fail();
+    } catch (NoSuchElementException expected) {
+    }
+  }
+
+  @Test public void explicitProxyTriesThatProxysAddressesOnly() throws Exception {
+    Address address = new Address(uriHost, uriPort, dns, socketFactory, null, null, null,
+        authenticator, proxyA, protocols, connectionSpecs, proxySelector);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
+
+    assertTrue(routeSelector.hasNext());
+    dns.set(proxyAHost, dns.allocate(2));
+    RouteSelector.Selection selection = routeSelector.next();
+    assertRoute(selection.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
+    assertRoute(selection.next(), address, proxyA, dns.lookup(proxyAHost, 1), proxyAPort);
+
+    assertFalse(selection.hasNext());
+    assertFalse(routeSelector.hasNext());
+    dns.assertRequests(proxyAHost);
+    proxySelector.assertRequests(); // No proxy selector requests!
+  }
+
+  @Test public void explicitDirectProxy() throws Exception {
+    Address address = new Address(uriHost, uriPort, dns, socketFactory, null, null, null,
+        authenticator, NO_PROXY, protocols, connectionSpecs, proxySelector);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
+
+    assertTrue(routeSelector.hasNext());
+    dns.set(uriHost, dns.allocate(2));
+    RouteSelector.Selection selection = routeSelector.next();
+    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
+    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 1), uriPort);
+
+    assertFalse(selection.hasNext());
+    assertFalse(routeSelector.hasNext());
+    dns.assertRequests(uriHost);
+    proxySelector.assertRequests(); // No proxy selector requests!
+  }
+
+  @Test public void proxySelectorReturnsNull() throws Exception {
+    ProxySelector nullProxySelector = new ProxySelector() {
+      @Override public List<Proxy> select(URI uri) {
+        assertEquals(uriHost, uri.getHost());
+        return null;
+      }
+
+      @Override public void connectFailed(
+          URI uri, SocketAddress socketAddress, IOException e) {
+        throw new AssertionError();
+      }
+    };
+
+    Address address = new Address(uriHost, uriPort, dns, socketFactory, null, null, null,
+        authenticator, null, protocols, connectionSpecs, nullProxySelector);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
+    assertTrue(routeSelector.hasNext());
+    dns.set(uriHost, dns.allocate(1));
+    RouteSelector.Selection selection = routeSelector.next();
+    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
+    dns.assertRequests(uriHost);
+
+    assertFalse(selection.hasNext());
+    assertFalse(routeSelector.hasNext());
+  }
+
+  @Test public void proxySelectorReturnsNoProxies() throws Exception {
+    Address address = httpAddress();
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
+
+    assertTrue(routeSelector.hasNext());
+    dns.set(uriHost, dns.allocate(2));
+    RouteSelector.Selection selection = routeSelector.next();
+    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
+    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 1), uriPort);
+
+    assertFalse(selection.hasNext());
+    assertFalse(routeSelector.hasNext());
+    dns.assertRequests(uriHost);
+    proxySelector.assertRequests(address.url().uri());
+  }
+
+  @Test public void proxySelectorReturnsMultipleProxies() throws Exception {
+    Address address = httpAddress();
+
+    proxySelector.proxies.add(proxyA);
+    proxySelector.proxies.add(proxyB);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
+    proxySelector.assertRequests(address.url().uri());
+
+    // First try the IP addresses of the first proxy, in sequence.
+    assertTrue(routeSelector.hasNext());
+    dns.set(proxyAHost, dns.allocate(2));
+    RouteSelector.Selection selection1 = routeSelector.next();
+    assertRoute(selection1.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
+    assertRoute(selection1.next(), address, proxyA, dns.lookup(proxyAHost, 1), proxyAPort);
+    dns.assertRequests(proxyAHost);
+    assertFalse(selection1.hasNext());
+
+    // Next try the IP address of the second proxy.
+    assertTrue(routeSelector.hasNext());
+    dns.set(proxyBHost, dns.allocate(1));
+    RouteSelector.Selection selection2 = routeSelector.next();
+    assertRoute(selection2.next(), address, proxyB, dns.lookup(proxyBHost, 0), proxyBPort);
+    dns.assertRequests(proxyBHost);
+    assertFalse(selection2.hasNext());
+
+    // No more proxies to try.
+    assertFalse(routeSelector.hasNext());
+  }
+
+  @Test public void proxySelectorDirectConnectionsAreSkipped() throws Exception {
+    Address address = httpAddress();
+
+    proxySelector.proxies.add(NO_PROXY);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
+    proxySelector.assertRequests(address.url().uri());
+
+    // Only the origin server will be attempted.
+    assertTrue(routeSelector.hasNext());
+    dns.set(uriHost, dns.allocate(1));
+    RouteSelector.Selection selection = routeSelector.next();
+    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
+    dns.assertRequests(uriHost);
+
+    assertFalse(selection.hasNext());
+    assertFalse(routeSelector.hasNext());
+  }
+
+  @Test public void proxyDnsFailureContinuesToNextProxy() throws Exception {
+    Address address = httpAddress();
+
+    proxySelector.proxies.add(proxyA);
+    proxySelector.proxies.add(proxyB);
+    proxySelector.proxies.add(proxyA);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
+    proxySelector.assertRequests(address.url().uri());
+
+    assertTrue(routeSelector.hasNext());
+    dns.set(proxyAHost, dns.allocate(1));
+    RouteSelector.Selection selection1 = routeSelector.next();
+    assertRoute(selection1.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
+    dns.assertRequests(proxyAHost);
+    assertFalse(selection1.hasNext());
+
+    assertTrue(routeSelector.hasNext());
+    dns.clear(proxyBHost);
+    try {
+      routeSelector.next();
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+    dns.assertRequests(proxyBHost);
+
+    assertTrue(routeSelector.hasNext());
+    dns.set(proxyAHost, dns.allocate(1));
+    RouteSelector.Selection selection2 = routeSelector.next();
+    assertRoute(selection2.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
+    dns.assertRequests(proxyAHost);
+
+    assertFalse(selection2.hasNext());
+    assertFalse(routeSelector.hasNext());
+  }
+
+  @Test public void multipleProxiesMultipleInetAddressesMultipleConfigurations() throws Exception {
+    Address address = httpsAddress();
+    proxySelector.proxies.add(proxyA);
+    proxySelector.proxies.add(proxyB);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
+
+    // Proxy A
+    dns.set(proxyAHost, dns.allocate(2));
+    RouteSelector.Selection selection1 = routeSelector.next();
+    assertRoute(selection1.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
+    dns.assertRequests(proxyAHost);
+    assertRoute(selection1.next(), address, proxyA, dns.lookup(proxyAHost, 1), proxyAPort);
+    assertFalse(selection1.hasNext());
+
+    // Proxy B
+    dns.set(proxyBHost, dns.allocate(2));
+    RouteSelector.Selection selection2 = routeSelector.next();
+    assertRoute(selection2.next(), address, proxyB, dns.lookup(proxyBHost, 0), proxyBPort);
+    dns.assertRequests(proxyBHost);
+    assertRoute(selection2.next(), address, proxyB, dns.lookup(proxyBHost, 1), proxyBPort);
+    assertFalse(selection2.hasNext());
+
+    // No more proxies to attempt.
+    assertFalse(routeSelector.hasNext());
+  }
+
+  @Test public void failedRouteWithSingleProxy() throws Exception {
+    Address address = httpsAddress();
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
+
+    final int numberOfAddresses = 2;
+    dns.set(uriHost, dns.allocate(numberOfAddresses));
+
+    // Extract the regular sequence of routes from selector.
+    RouteSelector.Selection selection1 = routeSelector.next();
+    List<Route> regularRoutes = selection1.getAll();
+
+    // Check that we do indeed have more than one route.
+    assertEquals(numberOfAddresses, regularRoutes.size());
+    // Add first regular route as failed.
+    routeDatabase.failed(regularRoutes.get(0));
+    // Reset selector
+    routeSelector = new RouteSelector(address, routeDatabase, null, EventListener.NONE);
+
+    // The first selection prioritizes the non-failed routes.
+    RouteSelector.Selection selection2 = routeSelector.next();
+    assertEquals(regularRoutes.get(1), selection2.next());
+    assertFalse(selection2.hasNext());
+
+    // The second selection will contain all failed routes.
+    RouteSelector.Selection selection3 = routeSelector.next();
+    assertEquals(regularRoutes.get(0), selection3.next());
+    assertFalse(selection3.hasNext());
+
+    assertFalse(routeSelector.hasNext());
+  }
+
+  @Test public void failedRouteWithMultipleProxies() throws IOException {
+    Address address = httpsAddress();
+    proxySelector.proxies.add(proxyA);
+    proxySelector.proxies.add(proxyB);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
+
+    dns.set(proxyAHost, dns.allocate(1));
+    dns.set(proxyBHost, dns.allocate(1));
+
+    // Mark the ProxyA route as failed.
+    RouteSelector.Selection selection = routeSelector.next();
+    dns.assertRequests(proxyAHost);
+    Route route = selection.next();
+    assertRoute(route, address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
+    routeDatabase.failed(route);
+
+    routeSelector = new RouteSelector(address, routeDatabase, null, EventListener.NONE);
+
+    // Confirm we enumerate both proxies, giving preference to the route from ProxyB.
+    RouteSelector.Selection selection2 = routeSelector.next();
+    dns.assertRequests(proxyAHost, proxyBHost);
+    assertRoute(selection2.next(), address, proxyB, dns.lookup(proxyBHost, 0), proxyBPort);
+    assertFalse(selection2.hasNext());
+
+    // Confirm the last selection contains the postponed route from ProxyA.
+    RouteSelector.Selection selection3 = routeSelector.next();
+    dns.assertRequests();
+    assertRoute(selection3.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
+    assertFalse(selection3.hasNext());
+
+    assertFalse(routeSelector.hasNext());
+  }
+
+  @Test public void queryForAllSelectedRoutes() throws IOException {
+    Address address = httpAddress();
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
+
+    dns.set(uriHost, dns.allocate(2));
+    RouteSelector.Selection selection = routeSelector.next();
+    dns.assertRequests(uriHost);
+
+    List<Route> routes = selection.getAll();
+    assertRoute(routes.get(0), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
+    assertRoute(routes.get(1), address, NO_PROXY, dns.lookup(uriHost, 1), uriPort);
+
+    assertSame(routes.get(0), selection.next());
+    assertSame(routes.get(1), selection.next());
+    assertFalse(selection.hasNext());
+    assertFalse(routeSelector.hasNext());
+  }
+
+  @Test public void getHostString() throws Exception {
+    // Name proxy specification.
+    InetSocketAddress socketAddress = InetSocketAddress.createUnresolved("host", 1234);
+    assertEquals("host", RouteSelector.getHostString(socketAddress));
+    socketAddress = InetSocketAddress.createUnresolved("127.0.0.1", 1234);
+    assertEquals("127.0.0.1", RouteSelector.getHostString(socketAddress));
+
+    // InetAddress proxy specification.
+    socketAddress = new InetSocketAddress(InetAddress.getByName("localhost"), 1234);
+    assertEquals("127.0.0.1", RouteSelector.getHostString(socketAddress));
+    socketAddress = new InetSocketAddress(
+        InetAddress.getByAddress(new byte[] {127, 0, 0, 1}), 1234);
+    assertEquals("127.0.0.1", RouteSelector.getHostString(socketAddress));
+    socketAddress = new InetSocketAddress(
+        InetAddress.getByAddress("foobar", new byte[] {127, 0, 0, 1}), 1234);
+    assertEquals("127.0.0.1", RouteSelector.getHostString(socketAddress));
+  }
+
+  @Test public void routeToString() throws Exception {
+    Route route = new Route(httpAddress(), Proxy.NO_PROXY,
+        InetSocketAddress.createUnresolved("host", 1234));
+    assertEquals("Route{host:1234}", route.toString());
+  }
+
+  private void assertRoute(Route route, Address address, Proxy proxy, InetAddress socketAddress,
+      int socketPort) {
+    assertEquals(address, route.address());
+    assertEquals(proxy, route.proxy());
+    assertEquals(socketAddress, route.socketAddress().getAddress());
+    assertEquals(socketPort, route.socketAddress().getPort());
+  }
+
+  /** Returns an address that's without an SSL socket factory or hostname verifier. */
+  private Address httpAddress() {
+    return new Address(uriHost, uriPort, dns, socketFactory, null, null, null, authenticator, null,
+        protocols, connectionSpecs, proxySelector);
+  }
+
+  private Address httpsAddress() {
+    return new Address(uriHost, uriPort, dns, socketFactory, sslSocketFactory,
+        hostnameVerifier, null, authenticator, null, protocols, connectionSpecs, proxySelector);
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/DisconnectTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/DisconnectTest.java
new file mode 100644
index 0000000000..aad2bfc8dd
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/DisconnectTest.java
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.HttpURLConnection;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.util.concurrent.TimeUnit;
+import javax.net.ServerSocketFactory;
+import javax.net.SocketFactory;
+import okhttp3.DelegatingServerSocketFactory;
+import okhttp3.DelegatingSocketFactory;
+import okhttp3.OkHttpClient;
+import okhttp3.OkUrlFactory;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okio.Buffer;
+import org.junit.Before;
+import org.junit.Test;
+
+import static okhttp3.TestUtil.defaultClient;
+import static org.junit.Assert.fail;
+
+public final class DisconnectTest {
+
+  // The size of the socket buffers in bytes.
+  private static final int SOCKET_BUFFER_SIZE = 256 * 1024;
+
+  private MockWebServer server;
+  private OkHttpClient client;
+
+  @Before public void setUp() throws Exception {
+    // Sockets on some platforms can have large buffers that mean writes do not block when
+    // required. These socket factories explicitly set the buffer sizes on sockets created.
+    server = new MockWebServer();
+    server.setServerSocketFactory(
+        new DelegatingServerSocketFactory(ServerSocketFactory.getDefault()) {
+          @Override protected ServerSocket configureServerSocket(
+              ServerSocket serverSocket) throws IOException {
+            serverSocket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
+            return serverSocket;
+          }
+        });
+    client = defaultClient().newBuilder()
+        .socketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
+          @Override protected Socket configureSocket(Socket socket) throws IOException {
+            socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
+            socket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
+            return socket;
+          }
+        })
+        .build();
+  }
+
+  @Test public void interruptWritingRequestBody() throws Exception {
+    int requestBodySize = 2 * 1024 * 1024; // 2 MiB
+
+    server.enqueue(new MockResponse()
+        .throttleBody(64 * 1024, 125, TimeUnit.MILLISECONDS)); // 500 Kbps
+    server.start();
+
+    HttpURLConnection connection = new OkUrlFactory(client).open(server.url("/").url());
+    disconnectLater(connection, 500);
+
+    connection.setDoOutput(true);
+    connection.setFixedLengthStreamingMode(requestBodySize);
+    OutputStream requestBody = connection.getOutputStream();
+    byte[] buffer = new byte[1024];
+    try {
+      for (int i = 0; i < requestBodySize; i += buffer.length) {
+        requestBody.write(buffer);
+        requestBody.flush();
+      }
+      fail("Expected connection to be closed");
+    } catch (IOException expected) {
+    }
+
+    connection.disconnect();
+  }
+
+  @Test public void interruptReadingResponseBody() throws Exception {
+    int responseBodySize = 2 * 1024 * 1024; // 2 MiB
+
+    server.enqueue(new MockResponse()
+        .setBody(new Buffer().write(new byte[responseBodySize]))
+        .throttleBody(64 * 1024, 125, TimeUnit.MILLISECONDS)); // 500 Kbps
+    server.start();
+
+    HttpURLConnection connection = new OkUrlFactory(client).open(server.url("/").url());
+    disconnectLater(connection, 500);
+
+    InputStream responseBody = connection.getInputStream();
+    byte[] buffer = new byte[1024];
+    try {
+      while (responseBody.read(buffer) != -1) {
+      }
+      fail("Expected connection to be closed");
+    } catch (IOException expected) {
+    }
+
+    responseBody.close();
+  }
+
+  private void disconnectLater(final HttpURLConnection connection, final int delayMillis) {
+    Thread interruptingCow = new Thread() {
+      @Override public void run() {
+        try {
+          sleep(delayMillis);
+          connection.disconnect();
+        } catch (InterruptedException e) {
+          throw new RuntimeException(e);
+        }
+      }
+    };
+    interruptingCow.start();
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/ExternalHttp2Example.java b/okhttp-tests/src/test/java/okhttp3/internal/http/ExternalHttp2Example.java
new file mode 100644
index 0000000000..73f9471fac
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/ExternalHttp2Example.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package okhttp3.internal.http;
+
+import okhttp3.Call;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.Util;
+
+public final class ExternalHttp2Example {
+  public static void main(String[] args) throws Exception {
+    OkHttpClient client = new OkHttpClient.Builder()
+        .protocols(Util.immutableList(Protocol.HTTP_2, Protocol.HTTP_1_1))
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url("https://www.google.ca/")
+        .build());
+
+    Response response = call.execute();
+    try {
+      System.out.println(response.code());
+      System.out.println("PROTOCOL " + response.protocol());
+
+      String line;
+      while ((line = response.body().source().readUtf8Line()) != null) {
+        System.out.println(line);
+      }
+    } finally {
+      response.body().close();
+    }
+
+    client.connectionPool().evictAll();
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/HttpDateTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/HttpDateTest.java
new file mode 100644
index 0000000000..0a22eb0f8a
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/HttpDateTest.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http;
+
+import java.util.Date;
+import java.util.TimeZone;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+
+public class HttpDateTest {
+
+  private TimeZone originalDefault;
+
+  @Before
+  public void setUp() throws Exception {
+    originalDefault = TimeZone.getDefault();
+    // The default timezone should affect none of these tests: HTTP specified GMT, so we set it to
+    // something else.
+    TimeZone.setDefault(TimeZone.getTimeZone("America/Los_Angeles"));
+  }
+
+  @After
+  public void tearDown() throws Exception {
+    TimeZone.setDefault(originalDefault);
+  }
+
+  @Test public void parseStandardFormats() throws Exception {
+    // RFC 822, updated by RFC 1123 with GMT.
+    assertEquals(0L, HttpDate.parse("Thu, 01 Jan 1970 00:00:00 GMT").getTime());
+    assertEquals(1402057830000L, HttpDate.parse("Fri, 06 Jun 2014 12:30:30 GMT").getTime());
+
+    // RFC 850, obsoleted by RFC 1036 with GMT.
+    assertEquals(0L, HttpDate.parse("Thursday, 01-Jan-70 00:00:00 GMT").getTime());
+    assertEquals(1402057830000L, HttpDate.parse("Friday, 06-Jun-14 12:30:30 GMT").getTime());
+
+    // ANSI C's asctime(): should use GMT, not platform default.
+    assertEquals(0L, HttpDate.parse("Thu Jan 1 00:00:00 1970").getTime());
+    assertEquals(1402057830000L, HttpDate.parse("Fri Jun 6 12:30:30 2014").getTime());
+  }
+
+  @Test public void format() throws Exception {
+    assertEquals("Thu, 01 Jan 1970 00:00:00 GMT", HttpDate.format(new Date(0)));
+    assertEquals("Fri, 06 Jun 2014 12:30:30 GMT", HttpDate.format(new Date(1402057830000L)));
+  }
+
+  @Test public void parseNonStandardStrings() throws Exception {
+    // RFC 822, updated by RFC 1123 with any TZ
+    assertEquals(3600000L, HttpDate.parse("Thu, 01 Jan 1970 00:00:00 GMT-01:00").getTime());
+    assertEquals(28800000L, HttpDate.parse("Thu, 01 Jan 1970 00:00:00 PST").getTime());
+    // Ignore trailing junk
+    assertEquals(0L, HttpDate.parse("Thu, 01 Jan 1970 00:00:00 GMT JUNK").getTime());
+    // Missing timezones treated as bad.
+    assertNull(HttpDate.parse("Thu, 01 Jan 1970 00:00:00"));
+    // Missing seconds treated as bad.
+    assertNull(HttpDate.parse("Thu, 01 Jan 1970 00:00 GMT"));
+    // Extra spaces treated as bad.
+    assertNull(HttpDate.parse("Thu,  01 Jan 1970 00:00 GMT"));
+    // Missing leading zero treated as bad.
+    assertNull(HttpDate.parse("Thu, 1 Jan 1970 00:00 GMT"));
+
+    // RFC 850, obsoleted by RFC 1036 with any TZ.
+    assertEquals(3600000L, HttpDate.parse("Thursday, 01-Jan-1970 00:00:00 GMT-01:00").getTime());
+    assertEquals(28800000L, HttpDate.parse("Thursday, 01-Jan-1970 00:00:00 PST").getTime());
+    // Ignore trailing junk
+    assertEquals(28800000L, HttpDate.parse("Thursday, 01-Jan-1970 00:00:00 PST JUNK").getTime());
+
+    // ANSI C's asctime() format
+    // This format ignores the timezone entirely even if it is present and uses GMT.
+    assertEquals(1402057830000L, HttpDate.parse("Fri Jun 6 12:30:30 2014 PST").getTime());
+    // Ignore trailing junk.
+    assertEquals(1402057830000L, HttpDate.parse("Fri Jun 6 12:30:30 2014 JUNK").getTime());
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java b/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
new file mode 100644
index 0000000000..fb37e7e491
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http;
+
+import java.io.IOException;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.net.ProxySelector;
+import java.net.SocketAddress;
+import java.net.URI;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import okhttp3.internal.Util;
+
+import static org.junit.Assert.assertEquals;
+
+public final class RecordingProxySelector extends ProxySelector {
+  public final List<Proxy> proxies = new ArrayList<>();
+  public final List<URI> requestedUris = new ArrayList<>();
+  public final List<String> failures = new ArrayList<>();
+
+  @Override public List<Proxy> select(URI uri) {
+    requestedUris.add(uri);
+    return proxies;
+  }
+
+  public void assertRequests(URI... expectedUris) {
+    assertEquals(Arrays.asList(expectedUris), requestedUris);
+    requestedUris.clear();
+  }
+
+  @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
+    InetSocketAddress socketAddress = (InetSocketAddress) sa;
+    failures.add(Util.format("%s %s:%d %s",
+        uri, socketAddress, socketAddress.getPort(), ioe.getMessage()));
+  }
+
+  @Override public String toString() {
+    return "RecordingProxySelector";
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/StatusLineTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/StatusLineTest.java
new file mode 100644
index 0000000000..6eb1aa8b12
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/StatusLineTest.java
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http;
+
+import java.io.IOException;
+import java.net.ProtocolException;
+import okhttp3.Protocol;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class StatusLineTest {
+  @Test public void parse() throws IOException {
+    String message = "Temporary Redirect";
+    int version = 1;
+    int code = 200;
+    StatusLine statusLine = StatusLine.parse("HTTP/1." + version + " " + code + " " + message);
+    assertEquals(message, statusLine.message);
+    assertEquals(Protocol.HTTP_1_1, statusLine.protocol);
+    assertEquals(code, statusLine.code);
+  }
+
+  @Test public void emptyMessage() throws IOException {
+    int version = 1;
+    int code = 503;
+    StatusLine statusLine = StatusLine.parse("HTTP/1." + version + " " + code + " ");
+    assertEquals("", statusLine.message);
+    assertEquals(Protocol.HTTP_1_1, statusLine.protocol);
+    assertEquals(code, statusLine.code);
+  }
+
+  /**
+   * This is not defined in the protocol but some servers won't add the leading empty space when the
+   * message is empty. http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.1
+   */
+  @Test public void emptyMessageAndNoLeadingSpace() throws IOException {
+    int version = 1;
+    int code = 503;
+    StatusLine statusLine = StatusLine.parse("HTTP/1." + version + " " + code);
+    assertEquals("", statusLine.message);
+    assertEquals(Protocol.HTTP_1_1, statusLine.protocol);
+    assertEquals(code, statusLine.code);
+  }
+
+  // https://github.com/square/okhttp/issues/386
+  @Test public void shoutcast() throws IOException {
+    StatusLine statusLine = StatusLine.parse("ICY 200 OK");
+    assertEquals("OK", statusLine.message);
+    assertEquals(Protocol.HTTP_1_0, statusLine.protocol);
+    assertEquals(200, statusLine.code);
+  }
+
+  @Test public void missingProtocol() throws IOException {
+    assertInvalid("");
+    assertInvalid(" ");
+    assertInvalid("200 OK");
+    assertInvalid(" 200 OK");
+  }
+
+  @Test public void protocolVersions() throws IOException {
+    assertInvalid("HTTP/2.0 200 OK");
+    assertInvalid("HTTP/2.1 200 OK");
+    assertInvalid("HTTP/-.1 200 OK");
+    assertInvalid("HTTP/1.- 200 OK");
+    assertInvalid("HTTP/0.1 200 OK");
+    assertInvalid("HTTP/101 200 OK");
+    assertInvalid("HTTP/1.1_200 OK");
+  }
+
+  @Test public void nonThreeDigitCode() throws IOException {
+    assertInvalid("HTTP/1.1  OK");
+    assertInvalid("HTTP/1.1 2 OK");
+    assertInvalid("HTTP/1.1 20 OK");
+    assertInvalid("HTTP/1.1 2000 OK");
+    assertInvalid("HTTP/1.1 two OK");
+    assertInvalid("HTTP/1.1 2");
+    assertInvalid("HTTP/1.1 2000");
+    assertInvalid("HTTP/1.1 two");
+  }
+
+  @Test public void truncated() throws IOException {
+    assertInvalid("");
+    assertInvalid("H");
+    assertInvalid("HTTP/1");
+    assertInvalid("HTTP/1.");
+    assertInvalid("HTTP/1.1");
+    assertInvalid("HTTP/1.1 ");
+    assertInvalid("HTTP/1.1 2");
+    assertInvalid("HTTP/1.1 20");
+  }
+
+  @Test public void wrongMessageDelimiter() throws IOException {
+    assertInvalid("HTTP/1.1 200_");
+  }
+
+  private void assertInvalid(String statusLine) throws IOException {
+    try {
+      StatusLine.parse(statusLine);
+      fail();
+    } catch (ProtocolException expected) {
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
new file mode 100644
index 0000000000..9ac3b93ecc
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
@@ -0,0 +1,137 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InterruptedIOException;
+import java.io.OutputStream;
+import java.net.HttpURLConnection;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.util.concurrent.TimeUnit;
+import javax.net.ServerSocketFactory;
+import javax.net.SocketFactory;
+import okhttp3.DelegatingServerSocketFactory;
+import okhttp3.DelegatingSocketFactory;
+import okhttp3.OkHttpClient;
+import okhttp3.OkUrlFactory;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okio.Buffer;
+import org.junit.Before;
+import org.junit.Test;
+
+import static okhttp3.TestUtil.defaultClient;
+import static org.junit.Assert.fail;
+
+public final class ThreadInterruptTest {
+
+  // The size of the socket buffers in bytes.
+  private static final int SOCKET_BUFFER_SIZE = 256 * 1024;
+
+  private MockWebServer server;
+  private OkHttpClient client;
+
+  @Before public void setUp() throws Exception {
+    // Sockets on some platforms can have large buffers that mean writes do not block when
+    // required. These socket factories explicitly set the buffer sizes on sockets created.
+    server = new MockWebServer();
+    server.setServerSocketFactory(
+        new DelegatingServerSocketFactory(ServerSocketFactory.getDefault()) {
+          @Override
+          protected ServerSocket configureServerSocket(ServerSocket serverSocket)
+              throws IOException {
+            serverSocket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
+            return serverSocket;
+          }
+        });
+    client = defaultClient().newBuilder()
+        .socketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
+          @Override
+          protected Socket configureSocket(Socket socket) throws IOException {
+            socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
+            socket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
+            return socket;
+          }
+        })
+        .build();
+  }
+
+  @Test public void interruptWritingRequestBody() throws Exception {
+    int requestBodySize = 2 * 1024 * 1024; // 2 MiB
+
+    server.enqueue(new MockResponse()
+        .throttleBody(64 * 1024, 125, TimeUnit.MILLISECONDS)); // 500 Kbps
+    server.start();
+
+    interruptLater(500);
+
+    HttpURLConnection connection = new OkUrlFactory(client).open(server.url("/").url());
+    connection.setDoOutput(true);
+    connection.setFixedLengthStreamingMode(requestBodySize);
+    OutputStream requestBody = connection.getOutputStream();
+    byte[] buffer = new byte[1024];
+    try {
+      for (int i = 0; i < requestBodySize; i += buffer.length) {
+        requestBody.write(buffer);
+        requestBody.flush();
+      }
+      fail("Expected thread to be interrupted");
+    } catch (InterruptedIOException expected) {
+    }
+
+    connection.disconnect();
+  }
+
+  @Test public void interruptReadingResponseBody() throws Exception {
+    int responseBodySize = 2 * 1024 * 1024; // 2 MiB
+
+    server.enqueue(new MockResponse()
+        .setBody(new Buffer().write(new byte[responseBodySize]))
+        .throttleBody(64 * 1024, 125, TimeUnit.MILLISECONDS)); // 500 Kbps
+    server.start();
+
+    interruptLater(500);
+
+    HttpURLConnection connection = new OkUrlFactory(client).open(server.url("/").url());
+    InputStream responseBody = connection.getInputStream();
+    byte[] buffer = new byte[1024];
+    try {
+      while (responseBody.read(buffer) != -1) {
+      }
+      fail("Expected thread to be interrupted");
+    } catch (InterruptedIOException expected) {
+    }
+
+    responseBody.close();
+  }
+
+  private void interruptLater(final int delayMillis) {
+    final Thread toInterrupt = Thread.currentThread();
+    Thread interruptingCow = new Thread() {
+      @Override public void run() {
+        try {
+          sleep(delayMillis);
+          toInterrupt.interrupt();
+        } catch (InterruptedException e) {
+          throw new RuntimeException(e);
+        }
+      }
+    };
+    interruptingCow.start();
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/BaseTestHandler.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/BaseTestHandler.java
new file mode 100644
index 0000000000..b0b552b937
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/BaseTestHandler.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import java.io.IOException;
+import java.util.List;
+import okio.BufferedSource;
+import okio.ByteString;
+
+import static org.junit.Assert.fail;
+
+class BaseTestHandler implements Http2Reader.Handler {
+  @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
+      throws IOException {
+    fail();
+  }
+
+  @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,
+      List<Header> headerBlock) {
+    fail();
+  }
+
+  @Override public void rstStream(int streamId, ErrorCode errorCode) {
+    fail();
+  }
+
+  @Override public void settings(boolean clearPrevious, Settings settings) {
+    fail();
+  }
+
+  @Override public void ackSettings() {
+    fail();
+  }
+
+  @Override public void ping(boolean ack, int payload1, int payload2) {
+    fail();
+  }
+
+  @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
+    fail();
+  }
+
+  @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
+    fail();
+  }
+
+  @Override public void priority(int streamId, int streamDependency, int weight,
+      boolean exclusive) {
+    fail();
+  }
+
+  @Override
+  public void pushPromise(int streamId, int associatedStreamId, List<Header> headerBlock) {
+    fail();
+  }
+
+  @Override public void alternateService(int streamId, String origin, ByteString protocol,
+      String host, int port, long maxAge) {
+    fail();
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/FrameLogTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/FrameLogTest.java
new file mode 100644
index 0000000000..94e5e83581
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/FrameLogTest.java
@@ -0,0 +1,162 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import org.junit.Test;
+
+import static okhttp3.internal.http2.Http2.FLAG_ACK;
+import static okhttp3.internal.http2.Http2.FLAG_END_HEADERS;
+import static okhttp3.internal.http2.Http2.FLAG_END_STREAM;
+import static okhttp3.internal.http2.Http2.FLAG_NONE;
+import static okhttp3.internal.http2.Http2.TYPE_CONTINUATION;
+import static okhttp3.internal.http2.Http2.TYPE_DATA;
+import static okhttp3.internal.http2.Http2.TYPE_GOAWAY;
+import static okhttp3.internal.http2.Http2.TYPE_HEADERS;
+import static okhttp3.internal.http2.Http2.TYPE_PING;
+import static okhttp3.internal.http2.Http2.TYPE_PUSH_PROMISE;
+import static okhttp3.internal.http2.Http2.TYPE_SETTINGS;
+import static okhttp3.internal.http2.Http2.frameLog;
+import static org.junit.Assert.assertEquals;
+
+public final class FrameLogTest {
+  /** Real stream traffic applied to the log format. */
+  @Test public void exampleStream() {
+    assertEquals(">> 0x00000000     5 SETTINGS      ",
+        frameLog(false, 0, 5, TYPE_SETTINGS, FLAG_NONE));
+    assertEquals(">> 0x00000003   100 HEADERS       END_HEADERS",
+        frameLog(false, 3, 100, TYPE_HEADERS, FLAG_END_HEADERS));
+    assertEquals(">> 0x00000003     0 DATA          END_STREAM",
+        frameLog(false, 3, 0, TYPE_DATA, FLAG_END_STREAM));
+    assertEquals("<< 0x00000000    15 SETTINGS      ",
+        frameLog(true, 0, 15, TYPE_SETTINGS, FLAG_NONE));
+    assertEquals(">> 0x00000000     0 SETTINGS      ACK",
+        frameLog(false, 0, 0, TYPE_SETTINGS, FLAG_ACK));
+    assertEquals("<< 0x00000000     0 SETTINGS      ACK",
+        frameLog(true, 0, 0, TYPE_SETTINGS, FLAG_ACK));
+    assertEquals("<< 0x00000003    22 HEADERS       END_HEADERS",
+        frameLog(true, 3, 22, TYPE_HEADERS, FLAG_END_HEADERS));
+    assertEquals("<< 0x00000003   226 DATA          END_STREAM",
+        frameLog(true, 3, 226, TYPE_DATA, FLAG_END_STREAM));
+    assertEquals(">> 0x00000000     8 GOAWAY        ",
+        frameLog(false, 0, 8, TYPE_GOAWAY, FLAG_NONE));
+  }
+
+  @Test public void flagOverlapOn0x1() {
+    assertEquals("<< 0x00000000     0 SETTINGS      ACK",
+        frameLog(true, 0, 0, TYPE_SETTINGS, (byte) 0x1));
+    assertEquals("<< 0x00000000     8 PING          ACK",
+        frameLog(true, 0, 8, TYPE_PING, (byte) 0x1));
+    assertEquals("<< 0x00000003     0 HEADERS       END_STREAM",
+        frameLog(true, 3, 0, TYPE_HEADERS, (byte) 0x1));
+    assertEquals("<< 0x00000003     0 DATA          END_STREAM",
+        frameLog(true, 3, 0, TYPE_DATA, (byte) 0x1));
+  }
+
+  @Test public void flagOverlapOn0x4() {
+    assertEquals("<< 0x00000003 10000 HEADERS       END_HEADERS",
+        frameLog(true, 3, 10000, TYPE_HEADERS, (byte) 0x4));
+    assertEquals("<< 0x00000003 10000 CONTINUATION  END_HEADERS",
+        frameLog(true, 3, 10000, TYPE_CONTINUATION, (byte) 0x4));
+    assertEquals("<< 0x00000004 10000 PUSH_PROMISE  END_PUSH_PROMISE",
+        frameLog(true, 4, 10000, TYPE_PUSH_PROMISE, (byte) 0x4));
+  }
+
+  @Test public void flagOverlapOn0x20() {
+    assertEquals("<< 0x00000003 10000 HEADERS       PRIORITY",
+        frameLog(true, 3, 10000, TYPE_HEADERS, (byte) 0x20));
+    assertEquals("<< 0x00000003 10000 DATA          COMPRESSED",
+        frameLog(true, 3, 10000, TYPE_DATA, (byte) 0x20));
+  }
+
+  /**
+   * Ensures that valid flag combinations appear visually correct, and invalid show in hex.  This
+   * also demonstrates how sparse the lookup table is.
+   */
+  @Test public void allFormattedFlagsWithValidBits() {
+    List<String> formattedFlags = new ArrayList<>(0x40); // Highest valid flag is 0x20.
+    for (byte i = 0; i < 0x40; i++) formattedFlags.add(Http2.formatFlags(TYPE_HEADERS, i));
+
+    assertEquals(Arrays.asList(
+        "",
+        "END_STREAM",
+        "00000010",
+        "00000011",
+        "END_HEADERS",
+        "END_STREAM|END_HEADERS",
+        "00000110",
+        "00000111",
+        "PADDED",
+        "END_STREAM|PADDED",
+        "00001010",
+        "00001011",
+        "00001100",
+        "END_STREAM|END_HEADERS|PADDED",
+        "00001110",
+        "00001111",
+        "00010000",
+        "00010001",
+        "00010010",
+        "00010011",
+        "00010100",
+        "00010101",
+        "00010110",
+        "00010111",
+        "00011000",
+        "00011001",
+        "00011010",
+        "00011011",
+        "00011100",
+        "00011101",
+        "00011110",
+        "00011111",
+        "PRIORITY",
+        "END_STREAM|PRIORITY",
+        "00100010",
+        "00100011",
+        "END_HEADERS|PRIORITY",
+        "END_STREAM|END_HEADERS|PRIORITY",
+        "00100110",
+        "00100111",
+        "00101000",
+        "END_STREAM|PRIORITY|PADDED",
+        "00101010",
+        "00101011",
+        "00101100",
+        "END_STREAM|END_HEADERS|PRIORITY|PADDED",
+        "00101110",
+        "00101111",
+        "00110000",
+        "00110001",
+        "00110010",
+        "00110011",
+        "00110100",
+        "00110101",
+        "00110110",
+        "00110111",
+        "00111000",
+        "00111001",
+        "00111010",
+        "00111011",
+        "00111100",
+        "00111101",
+        "00111110",
+        "00111111"
+    ), formattedFlags);
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/HpackTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/HpackTest.java
new file mode 100644
index 0000000000..6a90ac0458
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/HpackTest.java
@@ -0,0 +1,1050 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.List;
+import okio.Buffer;
+import okio.ByteString;
+import org.junit.Before;
+import org.junit.Test;
+
+import static okhttp3.TestUtil.headerEntries;
+import static okio.ByteString.decodeHex;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class HpackTest {
+  private final Buffer bytesIn = new Buffer();
+  private Hpack.Reader hpackReader;
+  private Buffer bytesOut = new Buffer();
+  private Hpack.Writer hpackWriter;
+
+  @Before public void reset() {
+    hpackReader = newReader(bytesIn);
+    hpackWriter = new Hpack.Writer(4096, false, bytesOut);
+  }
+
+  /**
+   * Variable-length quantity special cases strings which are longer than 127 bytes.  Values such as
+   * cookies can be 4KiB, and should be possible to send.
+   *
+   * <p> http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-5.2
+   */
+  @Test public void largeHeaderValue() throws IOException {
+    char[] value = new char[4096];
+    Arrays.fill(value, '!');
+    List<Header> headerBlock = headerEntries("cookie", new String(value));
+
+    hpackWriter.writeHeaders(headerBlock);
+    bytesIn.writeAll(bytesOut);
+    hpackReader.readHeaders();
+
+    assertEquals(0, hpackReader.headerCount);
+
+    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
+  }
+
+  /**
+   * HPACK has a max header table size, which can be smaller than the max header message. Ensure the
+   * larger header content is not lost.
+   */
+  @Test public void tooLargeToHPackIsStillEmitted() throws IOException {
+    bytesIn.writeByte(0x21); // Dynamic table size update (size = 1).
+    bytesIn.writeByte(0x00); // Literal indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-key");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
+
+    hpackReader.readHeaders();
+
+    assertEquals(0, hpackReader.headerCount);
+
+    assertEquals(headerEntries("custom-key", "custom-header"), hpackReader.getAndResetHeaderList());
+  }
+
+  /** Oldest entries are evicted to support newer ones. */
+  @Test public void writerEviction() throws IOException {
+    List<Header> headerBlock =
+        headerEntries(
+            "custom-foo", "custom-header",
+            "custom-bar", "custom-header",
+            "custom-baz", "custom-header");
+
+    bytesIn.writeByte(0x40); // Literal indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-foo");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
+
+    bytesIn.writeByte(0x40); // Literal indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-bar");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
+
+    bytesIn.writeByte(0x40); // Literal indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-baz");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
+
+    // Set to only support 110 bytes (enough for 2 headers).
+    // Use a new Writer because we don't support change the dynamic table
+    // size after Writer constructed.
+    Hpack.Writer writer = new Hpack.Writer(110, false, bytesOut);
+    writer.writeHeaders(headerBlock);
+
+    assertEquals(bytesIn, bytesOut);
+    assertEquals(2, writer.headerCount);
+
+    int tableLength = writer.dynamicTable.length;
+    Header entry = writer.dynamicTable[tableLength - 1];
+    checkEntry(entry, "custom-bar", "custom-header", 55);
+
+    entry = writer.dynamicTable[tableLength - 2];
+    checkEntry(entry, "custom-baz", "custom-header", 55);
+  }
+
+  @Test public void readerEviction() throws IOException {
+    List<Header> headerBlock =
+        headerEntries(
+            "custom-foo", "custom-header",
+            "custom-bar", "custom-header",
+            "custom-baz", "custom-header");
+
+    // Set to only support 110 bytes (enough for 2 headers).
+    bytesIn.writeByte(0x3F); // Dynamic table size update (size = 110).
+    bytesIn.writeByte(0x4F);
+
+    bytesIn.writeByte(0x40); // Literal indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-foo");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
+
+    bytesIn.writeByte(0x40); // Literal indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-bar");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
+
+    bytesIn.writeByte(0x40); // Literal indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-baz");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
+
+    hpackReader.readHeaders();
+
+    assertEquals(2, hpackReader.headerCount);
+
+    Header entry1 = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
+    checkEntry(entry1, "custom-bar", "custom-header", 55);
+
+    Header entry2 = hpackReader.dynamicTable[readerHeaderTableLength() - 2];
+    checkEntry(entry2, "custom-baz", "custom-header", 55);
+
+    // Once a header field is decoded and added to the reconstructed header
+    // list, it cannot be removed from it. Hence, foo is here.
+    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
+
+    // Simulate receiving a small dynamic table size update, that implies eviction.
+    bytesIn.writeByte(0x3F); // Dynamic table size update (size = 55).
+    bytesIn.writeByte(0x18);
+    hpackReader.readHeaders();
+    assertEquals(1, hpackReader.headerCount);
+  }
+
+  /** Header table backing array is initially 8 long, let's ensure it grows. */
+  @Test public void dynamicallyGrowsBeyond64Entries() throws IOException {
+    // Lots of headers need more room!
+    hpackReader = new Hpack.Reader(16384, 4096, bytesIn);
+    bytesIn.writeByte(0x3F); // Dynamic table size update (size = 16384).
+    bytesIn.writeByte(0xE1);
+    bytesIn.writeByte(0x7F);
+
+    for (int i = 0; i < 256; i++) {
+      bytesIn.writeByte(0x40); // Literal indexed
+      bytesIn.writeByte(0x0a); // Literal name (len = 10)
+      bytesIn.writeUtf8("custom-foo");
+
+      bytesIn.writeByte(0x0d); // Literal value (len = 13)
+      bytesIn.writeUtf8("custom-header");
+    }
+
+    hpackReader.readHeaders();
+
+    assertEquals(256, hpackReader.headerCount);
+  }
+
+  @Test public void huffmanDecodingSupported() throws IOException {
+    bytesIn.writeByte(0x44); // == Literal indexed ==
+                             // Indexed name (idx = 4) -> :path
+    bytesIn.writeByte(0x8c); // Literal value Huffman encoded 12 bytes
+                             // decodes to www.example.com which is length 15
+    bytesIn.write(decodeHex("f1e3c2e5f23a6ba0ab90f4ff"));
+
+    hpackReader.readHeaders();
+
+    assertEquals(1, hpackReader.headerCount);
+    assertEquals(52, hpackReader.dynamicTableByteCount);
+
+    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
+    checkEntry(entry, ":path", "www.example.com", 52);
+  }
+
+  /**
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#appendix-C.2.1
+   */
+  @Test public void readLiteralHeaderFieldWithIndexing() throws IOException {
+    bytesIn.writeByte(0x40); // Literal indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-key");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
+
+    hpackReader.readHeaders();
+
+    assertEquals(1, hpackReader.headerCount);
+    assertEquals(55, hpackReader.dynamicTableByteCount);
+
+    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
+    checkEntry(entry, "custom-key", "custom-header", 55);
+
+    assertEquals(headerEntries("custom-key", "custom-header"), hpackReader.getAndResetHeaderList());
+  }
+
+  /**
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#appendix-C.2.2
+   */
+  @Test public void literalHeaderFieldWithoutIndexingIndexedName() throws IOException {
+    List<Header> headerBlock = headerEntries(":path", "/sample/path");
+
+    bytesIn.writeByte(0x04); // == Literal not indexed ==
+                             // Indexed name (idx = 4) -> :path
+    bytesIn.writeByte(0x0c); // Literal value (len = 12)
+    bytesIn.writeUtf8("/sample/path");
+
+    hpackWriter.writeHeaders(headerBlock);
+    assertEquals(bytesIn, bytesOut);
+
+    hpackReader.readHeaders();
+
+    assertEquals(0, hpackReader.headerCount);
+
+    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
+  }
+
+  @Test public void literalHeaderFieldWithoutIndexingNewName() throws IOException {
+    List<Header> headerBlock = headerEntries("custom-key", "custom-header");
+
+    bytesIn.writeByte(0x00); // Not indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-key");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
+
+    hpackReader.readHeaders();
+
+    assertEquals(0, hpackReader.headerCount);
+
+    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
+  }
+
+  @Test public void literalHeaderFieldNeverIndexedIndexedName() throws IOException {
+    bytesIn.writeByte(0x14); // == Literal never indexed ==
+                             // Indexed name (idx = 4) -> :path
+    bytesIn.writeByte(0x0c); // Literal value (len = 12)
+    bytesIn.writeUtf8("/sample/path");
+
+    hpackReader.readHeaders();
+
+    assertEquals(0, hpackReader.headerCount);
+
+    assertEquals(headerEntries(":path", "/sample/path"), hpackReader.getAndResetHeaderList());
+  }
+
+  @Test public void literalHeaderFieldNeverIndexedNewName() throws IOException {
+    List<Header> headerBlock = headerEntries("custom-key", "custom-header");
+
+    bytesIn.writeByte(0x10); // Never indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-key");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
+
+    hpackReader.readHeaders();
+
+    assertEquals(0, hpackReader.headerCount);
+
+    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
+  }
+
+  @Test public void literalHeaderFieldWithIncrementalIndexingIndexedName() throws IOException {
+    List<Header> headerBlock = headerEntries(":path", "/sample/path");
+
+    bytesIn.writeByte(0x44); // Indexed name (idx = 4) -> :path
+    bytesIn.writeByte(0x0c); // Literal value (len = 12)
+    bytesIn.writeUtf8("/sample/path");
+
+    hpackReader.readHeaders();
+
+    assertEquals(1, hpackReader.headerCount);
+
+    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
+  }
+
+  @Test public void literalHeaderFieldWithIncrementalIndexingNewName() throws IOException {
+    List<Header> headerBlock = headerEntries("custom-key", "custom-header");
+
+    bytesIn.writeByte(0x40); // Never indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-key");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
+
+    hpackWriter.writeHeaders(headerBlock);
+    assertEquals(bytesIn, bytesOut);
+
+    assertEquals(1, hpackWriter.headerCount);
+
+    Header entry = hpackWriter.dynamicTable[hpackWriter.dynamicTable.length - 1];
+    checkEntry(entry, "custom-key", "custom-header", 55);
+
+    hpackReader.readHeaders();
+
+    assertEquals(1, hpackReader.headerCount);
+
+    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
+  }
+
+  @Test public void theSameHeaderAfterOneIncrementalIndexed() throws IOException {
+    List<Header> headerBlock =
+        headerEntries(
+            "custom-key", "custom-header",
+            "custom-key", "custom-header");
+
+    bytesIn.writeByte(0x40); // Never indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-key");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
+
+    bytesIn.writeByte(0xbe); // Indexed name and value (idx = 63)
+
+    hpackWriter.writeHeaders(headerBlock);
+    assertEquals(bytesIn, bytesOut);
+
+    assertEquals(1, hpackWriter.headerCount);
+
+    Header entry = hpackWriter.dynamicTable[hpackWriter.dynamicTable.length - 1];
+    checkEntry(entry, "custom-key", "custom-header", 55);
+
+    hpackReader.readHeaders();
+
+    assertEquals(1, hpackReader.headerCount);
+
+    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
+  }
+
+  @Test public void staticHeaderIsNotCopiedIntoTheIndexedTable() throws IOException {
+    bytesIn.writeByte(0x82); // == Indexed - Add ==
+                             // idx = 2 -> :method: GET
+
+    hpackReader.readHeaders();
+
+    assertEquals(0, hpackReader.headerCount);
+    assertEquals(0, hpackReader.dynamicTableByteCount);
+
+    assertEquals(null, hpackReader.dynamicTable[readerHeaderTableLength() - 1]);
+
+    assertEquals(headerEntries(":method", "GET"), hpackReader.getAndResetHeaderList());
+  }
+
+  // Example taken from twitter/hpack DecoderTest.testUnusedIndex
+  @Test public void readIndexedHeaderFieldIndex0() throws IOException {
+    bytesIn.writeByte(0x80); // == Indexed - Add idx = 0
+
+    try {
+      hpackReader.readHeaders();
+      fail();
+    } catch (IOException e) {
+      assertEquals("index == 0", e.getMessage());
+    }
+  }
+
+  // Example taken from twitter/hpack DecoderTest.testIllegalIndex
+  @Test public void readIndexedHeaderFieldTooLargeIndex() throws IOException {
+    bytesIn.writeShort(0xff00); // == Indexed - Add idx = 127
+
+    try {
+      hpackReader.readHeaders();
+      fail();
+    } catch (IOException e) {
+      assertEquals("Header index too large 127", e.getMessage());
+    }
+  }
+
+  // Example taken from twitter/hpack DecoderTest.testInsidiousIndex
+  @Test public void readIndexedHeaderFieldInsidiousIndex() throws IOException {
+    bytesIn.writeByte(0xff); // == Indexed - Add ==
+    bytesIn.write(decodeHex("8080808008")); // idx = -2147483521
+
+    try {
+      hpackReader.readHeaders();
+      fail();
+    } catch (IOException e) {
+      assertEquals("Header index too large -2147483521", e.getMessage());
+    }
+  }
+
+  // Example taken from twitter/hpack DecoderTest.testHeaderTableSizeUpdate
+  @Test public void minMaxHeaderTableSize() throws IOException {
+    bytesIn.writeByte(0x20);
+    hpackReader.readHeaders();
+
+    assertEquals(0, hpackReader.maxDynamicTableByteCount());
+
+    bytesIn.writeByte(0x3f); // encode size 4096
+    bytesIn.writeByte(0xe1);
+    bytesIn.writeByte(0x1f);
+    hpackReader.readHeaders();
+
+    assertEquals(4096, hpackReader.maxDynamicTableByteCount());
+  }
+
+  // Example taken from twitter/hpack DecoderTest.testIllegalHeaderTableSizeUpdate
+  @Test public void cannotSetTableSizeLargerThanSettingsValue() throws IOException {
+    bytesIn.writeByte(0x3f); // encode size 4097
+    bytesIn.writeByte(0xe2);
+    bytesIn.writeByte(0x1f);
+
+    try {
+      hpackReader.readHeaders();
+      fail();
+    } catch (IOException e) {
+      assertEquals("Invalid dynamic table size update 4097", e.getMessage());
+    }
+  }
+
+  // Example taken from twitter/hpack DecoderTest.testInsidiousMaxHeaderSize
+  @Test public void readHeaderTableStateChangeInsidiousMaxHeaderByteCount() throws IOException {
+    bytesIn.writeByte(0x3f);
+    bytesIn.write(decodeHex("e1ffffff07")); // count = -2147483648
+
+    try {
+      hpackReader.readHeaders();
+      fail();
+    } catch (IOException e) {
+      assertEquals("Invalid dynamic table size update -2147483648", e.getMessage());
+    }
+  }
+
+  /**
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#appendix-C.2.4
+   */
+  @Test public void readIndexedHeaderFieldFromStaticTableWithoutBuffering() throws IOException {
+    bytesIn.writeByte(0x20); // Dynamic table size update (size = 0).
+    bytesIn.writeByte(0x82); // == Indexed - Add ==
+                             // idx = 2 -> :method: GET
+
+    hpackReader.readHeaders();
+
+    // Not buffered in header table.
+    assertEquals(0, hpackReader.headerCount);
+
+    assertEquals(headerEntries(":method", "GET"), hpackReader.getAndResetHeaderList());
+  }
+
+  /**
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#appendix-C.2
+   */
+  @Test public void readRequestExamplesWithoutHuffman() throws IOException {
+    firstRequestWithoutHuffman();
+    hpackReader.readHeaders();
+    checkReadFirstRequestWithoutHuffman();
+
+    secondRequestWithoutHuffman();
+    hpackReader.readHeaders();
+    checkReadSecondRequestWithoutHuffman();
+
+    thirdRequestWithoutHuffman();
+    hpackReader.readHeaders();
+    checkReadThirdRequestWithoutHuffman();
+  }
+
+  private void firstRequestWithoutHuffman() {
+    bytesIn.writeByte(0x82); // == Indexed - Add ==
+                             // idx = 2 -> :method: GET
+    bytesIn.writeByte(0x86); // == Indexed - Add ==
+                             // idx = 7 -> :scheme: http
+    bytesIn.writeByte(0x84); // == Indexed - Add ==
+                             // idx = 6 -> :path: /
+    bytesIn.writeByte(0x41); // == Literal indexed ==
+                             // Indexed name (idx = 4) -> :authority
+    bytesIn.writeByte(0x0f); // Literal value (len = 15)
+    bytesIn.writeUtf8("www.example.com");
+  }
+
+  private void checkReadFirstRequestWithoutHuffman() {
+    assertEquals(1, hpackReader.headerCount);
+
+    // [  1] (s =  57) :authority: www.example.com
+    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
+    checkEntry(entry, ":authority", "www.example.com", 57);
+
+    // Table size: 57
+    assertEquals(57, hpackReader.dynamicTableByteCount);
+
+    // Decoded header list:
+    assertEquals(headerEntries(
+        ":method", "GET",
+        ":scheme", "http",
+        ":path", "/",
+        ":authority", "www.example.com"), hpackReader.getAndResetHeaderList());
+  }
+
+  private void secondRequestWithoutHuffman() {
+    bytesIn.writeByte(0x82); // == Indexed - Add ==
+                             // idx = 2 -> :method: GET
+    bytesIn.writeByte(0x86); // == Indexed - Add ==
+                             // idx = 7 -> :scheme: http
+    bytesIn.writeByte(0x84); // == Indexed - Add ==
+                             // idx = 6 -> :path: /
+    bytesIn.writeByte(0xbe); // == Indexed - Add ==
+                             // Indexed name (idx = 62) -> :authority: www.example.com
+    bytesIn.writeByte(0x58); // == Literal indexed ==
+                             // Indexed name (idx = 24) -> cache-control
+    bytesIn.writeByte(0x08); // Literal value (len = 8)
+    bytesIn.writeUtf8("no-cache");
+  }
+
+  private void checkReadSecondRequestWithoutHuffman() {
+    assertEquals(2, hpackReader.headerCount);
+
+    // [  1] (s =  53) cache-control: no-cache
+    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 2];
+    checkEntry(entry, "cache-control", "no-cache", 53);
+
+    // [  2] (s =  57) :authority: www.example.com
+    entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
+    checkEntry(entry, ":authority", "www.example.com", 57);
+
+    // Table size: 110
+    assertEquals(110, hpackReader.dynamicTableByteCount);
+
+    // Decoded header list:
+    assertEquals(headerEntries(
+        ":method", "GET",
+        ":scheme", "http",
+        ":path", "/",
+        ":authority", "www.example.com",
+        "cache-control", "no-cache"), hpackReader.getAndResetHeaderList());
+  }
+
+  private void thirdRequestWithoutHuffman() {
+    bytesIn.writeByte(0x82); // == Indexed - Add ==
+                             // idx = 2 -> :method: GET
+    bytesIn.writeByte(0x87); // == Indexed - Add ==
+                             // idx = 7 -> :scheme: http
+    bytesIn.writeByte(0x85); // == Indexed - Add ==
+                             // idx = 5 -> :path: /index.html
+    bytesIn.writeByte(0xbf); // == Indexed - Add ==
+                             // Indexed name (idx = 63) -> :authority: www.example.com
+    bytesIn.writeByte(0x40); // Literal indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-key");
+    bytesIn.writeByte(0x0c); // Literal value (len = 12)
+    bytesIn.writeUtf8("custom-value");
+  }
+
+  private void checkReadThirdRequestWithoutHuffman() {
+    assertEquals(3, hpackReader.headerCount);
+
+    // [  1] (s =  54) custom-key: custom-value
+    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 3];
+    checkEntry(entry, "custom-key", "custom-value", 54);
+
+    // [  2] (s =  53) cache-control: no-cache
+    entry = hpackReader.dynamicTable[readerHeaderTableLength() - 2];
+    checkEntry(entry, "cache-control", "no-cache", 53);
+
+    // [  3] (s =  57) :authority: www.example.com
+    entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
+    checkEntry(entry, ":authority", "www.example.com", 57);
+
+    // Table size: 164
+    assertEquals(164, hpackReader.dynamicTableByteCount);
+
+    // Decoded header list:
+    assertEquals(headerEntries(
+        ":method", "GET",
+        ":scheme", "https",
+        ":path", "/index.html",
+        ":authority", "www.example.com",
+        "custom-key", "custom-value"), hpackReader.getAndResetHeaderList());
+  }
+
+  /**
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#appendix-C.4
+   */
+  @Test public void readRequestExamplesWithHuffman() throws IOException {
+    firstRequestWithHuffman();
+    hpackReader.readHeaders();
+    checkReadFirstRequestWithHuffman();
+
+    secondRequestWithHuffman();
+    hpackReader.readHeaders();
+    checkReadSecondRequestWithHuffman();
+
+    thirdRequestWithHuffman();
+    hpackReader.readHeaders();
+    checkReadThirdRequestWithHuffman();
+  }
+
+  private void firstRequestWithHuffman() {
+    bytesIn.writeByte(0x82); // == Indexed - Add ==
+                             // idx = 2 -> :method: GET
+    bytesIn.writeByte(0x86); // == Indexed - Add ==
+                             // idx = 6 -> :scheme: http
+    bytesIn.writeByte(0x84); // == Indexed - Add ==
+                             // idx = 4 -> :path: /
+    bytesIn.writeByte(0x41); // == Literal indexed ==
+                             // Indexed name (idx = 1) -> :authority
+    bytesIn.writeByte(0x8c); // Literal value Huffman encoded 12 bytes
+                             // decodes to www.example.com which is length 15
+    bytesIn.write(decodeHex("f1e3c2e5f23a6ba0ab90f4ff"));
+  }
+
+  private void checkReadFirstRequestWithHuffman() {
+    assertEquals(1, hpackReader.headerCount);
+
+    // [  1] (s =  57) :authority: www.example.com
+    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
+    checkEntry(entry, ":authority", "www.example.com", 57);
+
+    // Table size: 57
+    assertEquals(57, hpackReader.dynamicTableByteCount);
+
+    // Decoded header list:
+    assertEquals(headerEntries(
+        ":method", "GET",
+        ":scheme", "http",
+        ":path", "/",
+        ":authority", "www.example.com"), hpackReader.getAndResetHeaderList());
+  }
+
+  private void secondRequestWithHuffman() {
+    bytesIn.writeByte(0x82); // == Indexed - Add ==
+                             // idx = 2 -> :method: GET
+    bytesIn.writeByte(0x86); // == Indexed - Add ==
+                             // idx = 6 -> :scheme: http
+    bytesIn.writeByte(0x84); // == Indexed - Add ==
+                             // idx = 4 -> :path: /
+    bytesIn.writeByte(0xbe); // == Indexed - Add ==
+                             // idx = 62 -> :authority: www.example.com
+    bytesIn.writeByte(0x58); // == Literal indexed ==
+                             // Indexed name (idx = 24) -> cache-control
+    bytesIn.writeByte(0x86); // Literal value Huffman encoded 6 bytes
+                             // decodes to no-cache which is length 8
+    bytesIn.write(decodeHex("a8eb10649cbf"));
+  }
+
+  private void checkReadSecondRequestWithHuffman() {
+    assertEquals(2, hpackReader.headerCount);
+
+    // [  1] (s =  53) cache-control: no-cache
+    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 2];
+    checkEntry(entry, "cache-control", "no-cache", 53);
+
+    // [  2] (s =  57) :authority: www.example.com
+    entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
+    checkEntry(entry, ":authority", "www.example.com", 57);
+
+    // Table size: 110
+    assertEquals(110, hpackReader.dynamicTableByteCount);
+
+    // Decoded header list:
+    assertEquals(headerEntries(
+        ":method", "GET",
+        ":scheme", "http",
+        ":path", "/",
+        ":authority", "www.example.com",
+        "cache-control", "no-cache"), hpackReader.getAndResetHeaderList());
+  }
+
+  private void thirdRequestWithHuffman() {
+    bytesIn.writeByte(0x82); // == Indexed - Add ==
+                             // idx = 2 -> :method: GET
+    bytesIn.writeByte(0x87); // == Indexed - Add ==
+                             // idx = 7 -> :scheme: https
+    bytesIn.writeByte(0x85); // == Indexed - Add ==
+                             // idx = 5 -> :path: /index.html
+    bytesIn.writeByte(0xbf); // == Indexed - Add ==
+                             // idx = 63 -> :authority: www.example.com
+    bytesIn.writeByte(0x40); // Literal indexed
+    bytesIn.writeByte(0x88); // Literal name Huffman encoded 8 bytes
+                             // decodes to custom-key which is length 10
+    bytesIn.write(decodeHex("25a849e95ba97d7f"));
+    bytesIn.writeByte(0x89); // Literal value Huffman encoded 9 bytes
+                             // decodes to custom-value which is length 12
+    bytesIn.write(decodeHex("25a849e95bb8e8b4bf"));
+  }
+
+  private void checkReadThirdRequestWithHuffman() {
+    assertEquals(3, hpackReader.headerCount);
+
+    // [  1] (s =  54) custom-key: custom-value
+    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 3];
+    checkEntry(entry, "custom-key", "custom-value", 54);
+
+    // [  2] (s =  53) cache-control: no-cache
+    entry = hpackReader.dynamicTable[readerHeaderTableLength() - 2];
+    checkEntry(entry, "cache-control", "no-cache", 53);
+
+    // [  3] (s =  57) :authority: www.example.com
+    entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
+    checkEntry(entry, ":authority", "www.example.com", 57);
+
+    // Table size: 164
+    assertEquals(164, hpackReader.dynamicTableByteCount);
+
+    // Decoded header list:
+    assertEquals(headerEntries(
+        ":method", "GET",
+        ":scheme", "https",
+        ":path", "/index.html",
+        ":authority", "www.example.com",
+        "custom-key", "custom-value"), hpackReader.getAndResetHeaderList());
+  }
+
+  @Test public void readSingleByteInt() throws IOException {
+    assertEquals(10, newReader(byteStream()).readInt(10, 31));
+    assertEquals(10, newReader(byteStream()).readInt(0xe0 | 10, 31));
+  }
+
+  @Test public void readMultibyteInt() throws IOException {
+    assertEquals(1337, newReader(byteStream(154, 10)).readInt(31, 31));
+  }
+
+  @Test public void writeSingleByteInt() throws IOException {
+    hpackWriter.writeInt(10, 31, 0);
+    assertBytes(10);
+    hpackWriter.writeInt(10, 31, 0xe0);
+    assertBytes(0xe0 | 10);
+  }
+
+  @Test public void writeMultibyteInt() throws IOException {
+    hpackWriter.writeInt(1337, 31, 0);
+    assertBytes(31, 154, 10);
+    hpackWriter.writeInt(1337, 31, 0xe0);
+    assertBytes(0xe0 | 31, 154, 10);
+  }
+
+  @Test public void max31BitValue() throws IOException {
+    hpackWriter.writeInt(0x7fffffff, 31, 0);
+    assertBytes(31, 224, 255, 255, 255, 7);
+    assertEquals(0x7fffffff,
+        newReader(byteStream(224, 255, 255, 255, 7)).readInt(31, 31));
+  }
+
+  @Test public void prefixMask() throws IOException {
+    hpackWriter.writeInt(31, 31, 0);
+    assertBytes(31, 0);
+    assertEquals(31, newReader(byteStream(0)).readInt(31, 31));
+  }
+
+  @Test public void prefixMaskMinusOne() throws IOException {
+    hpackWriter.writeInt(30, 31, 0);
+    assertBytes(30);
+    assertEquals(31, newReader(byteStream(0)).readInt(31, 31));
+  }
+
+  @Test public void zero() throws IOException {
+    hpackWriter.writeInt(0, 31, 0);
+    assertBytes(0);
+    assertEquals(0, newReader(byteStream()).readInt(0, 31));
+  }
+
+  @Test public void lowercaseHeaderNameBeforeEmit() throws IOException {
+    hpackWriter.writeHeaders(Arrays.asList(new Header("FoO", "BaR")));
+    assertBytes(0x40, 3, 'f', 'o', 'o', 3, 'B', 'a', 'R');
+  }
+
+  @Test public void mixedCaseHeaderNameIsMalformed() throws IOException {
+    try {
+      newReader(byteStream(0, 3, 'F', 'o', 'o', 3, 'B', 'a', 'R')).readHeaders();
+      fail();
+    } catch (IOException e) {
+      assertEquals("PROTOCOL_ERROR response malformed: mixed case name: Foo", e.getMessage());
+    }
+  }
+
+  @Test public void emptyHeaderName() throws IOException {
+    hpackWriter.writeByteString(ByteString.encodeUtf8(""));
+    assertBytes(0);
+    assertEquals(ByteString.EMPTY, newReader(byteStream(0)).readByteString());
+  }
+
+  @Test public void emitsDynamicTableSizeUpdate() throws IOException {
+    hpackWriter.setHeaderTableSizeSetting(2048);
+    hpackWriter.writeHeaders(Arrays.asList(new Header("foo", "bar")));
+    assertBytes(
+        0x3F, 0xE1, 0xF, // Dynamic table size update (size = 2048).
+        0x40, 3, 'f', 'o', 'o', 3, 'b', 'a', 'r');
+
+    hpackWriter.setHeaderTableSizeSetting(8192);
+    hpackWriter.writeHeaders(Arrays.asList(new Header("bar", "foo")));
+    assertBytes(
+        0x3F, 0xE1, 0x3F, // Dynamic table size update (size = 8192).
+        0x40, 3, 'b', 'a', 'r', 3, 'f', 'o', 'o');
+
+    // No more dynamic table updates should be emitted.
+    hpackWriter.writeHeaders(Arrays.asList(new Header("far", "boo")));
+    assertBytes(0x40, 3, 'f', 'a', 'r', 3, 'b', 'o', 'o');
+  }
+
+  @Test public void noDynamicTableSizeUpdateWhenSizeIsEqual() throws IOException {
+    int currentSize = hpackWriter.headerTableSizeSetting;
+    hpackWriter.setHeaderTableSizeSetting(currentSize);
+    hpackWriter.writeHeaders(Arrays.asList(new Header("foo", "bar")));
+
+    assertBytes(0x40, 3, 'f', 'o', 'o', 3, 'b', 'a', 'r');
+  }
+
+  @Test public void growDynamicTableSize() throws IOException {
+    hpackWriter.setHeaderTableSizeSetting(8192);
+    hpackWriter.setHeaderTableSizeSetting(16384);
+    hpackWriter.writeHeaders(Arrays.asList(new Header("foo", "bar")));
+
+    assertBytes(
+        0x3F, 0xE1, 0x7F, // Dynamic table size update (size = 16384).
+        0x40, 3, 'f', 'o', 'o', 3, 'b', 'a', 'r');
+  }
+
+  @Test public void shrinkDynamicTableSize() throws IOException {
+    hpackWriter.setHeaderTableSizeSetting(2048);
+    hpackWriter.setHeaderTableSizeSetting(0);
+    hpackWriter.writeHeaders(Arrays.asList(new Header("foo", "bar")));
+
+    assertBytes(
+        0x20, // Dynamic size update (size = 0).
+        0x40, 3, 'f', 'o', 'o', 3, 'b', 'a', 'r');
+  }
+
+  @Test public void manyDynamicTableSizeChanges() throws IOException {
+    hpackWriter.setHeaderTableSizeSetting(16384);
+    hpackWriter.setHeaderTableSizeSetting(8096);
+    hpackWriter.setHeaderTableSizeSetting(0);
+    hpackWriter.setHeaderTableSizeSetting(4096);
+    hpackWriter.setHeaderTableSizeSetting(2048);
+    hpackWriter.writeHeaders(Arrays.asList(new Header("foo", "bar")));
+
+    assertBytes(
+        0x20, // Dynamic size update (size = 0).
+        0x3F, 0xE1, 0xF, // Dynamic size update (size = 2048).
+        0x40, 3, 'f', 'o', 'o', 3, 'b', 'a', 'r');
+  }
+
+  @Test public void dynamicTableEvictionWhenSizeLowered() throws IOException {
+    List<Header> headerBlock =
+        headerEntries(
+            "custom-key1", "custom-header",
+            "custom-key2", "custom-header");
+    hpackWriter.writeHeaders(headerBlock);
+    assertEquals(2, hpackWriter.headerCount);
+
+    hpackWriter.setHeaderTableSizeSetting(56);
+    assertEquals(1, hpackWriter.headerCount);
+
+    hpackWriter.setHeaderTableSizeSetting(0);
+    assertEquals(0, hpackWriter.headerCount);
+  }
+
+  @Test public void noEvictionOnDynamicTableSizeIncrease() throws IOException {
+    List<Header> headerBlock =
+        headerEntries(
+            "custom-key1", "custom-header",
+            "custom-key2", "custom-header");
+    hpackWriter.writeHeaders(headerBlock);
+    assertEquals(2, hpackWriter.headerCount);
+
+    hpackWriter.setHeaderTableSizeSetting(8192);
+    assertEquals(2, hpackWriter.headerCount);
+  }
+
+  @Test public void dynamicTableSizeHasAnUpperBound() {
+    hpackWriter.setHeaderTableSizeSetting(1048576);
+    assertEquals(16384, hpackWriter.maxDynamicTableByteCount);
+  }
+
+  @Test public void huffmanEncode() throws IOException {
+    hpackWriter = new Hpack.Writer(4096, true, bytesOut);
+    hpackWriter.writeHeaders(headerEntries("foo", "bar"));
+
+    ByteString expected = new Buffer()
+        .writeByte(0x40) // Literal header, new name.
+        .writeByte(0x82) // String literal is Huffman encoded (len = 2).
+        .writeByte(0x94) // 'foo' Huffman encoded.
+        .writeByte(0xE7)
+        .writeByte(3) // String literal not Huffman encoded (len = 3).
+        .writeByte('b')
+        .writeByte('a')
+        .writeByte('r')
+        .readByteString();
+
+    ByteString actual = bytesOut.readByteString();
+    assertEquals(expected, actual);
+  }
+
+  @Test public void staticTableIndexedHeaders() throws IOException {
+    hpackWriter.writeHeaders(headerEntries(":method", "GET"));
+    assertBytes(0x82);
+    assertEquals(0, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries(":method", "POST"));
+    assertBytes(0x83);
+    assertEquals(0, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries(":path", "/"));
+    assertBytes(0x84);
+    assertEquals(0, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries(":path", "/index.html"));
+    assertBytes(0x85);
+    assertEquals(0, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries(":scheme", "http"));
+    assertBytes(0x86);
+    assertEquals(0, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries(":scheme", "https"));
+    assertBytes(0x87);
+    assertEquals(0, hpackWriter.headerCount);
+  }
+
+  @Test public void dynamicTableIndexedHeader() throws IOException {
+    hpackWriter.writeHeaders(headerEntries("custom-key", "custom-header"));
+    assertBytes(0x40,
+        10, 'c', 'u', 's', 't', 'o', 'm', '-', 'k', 'e', 'y',
+        13, 'c', 'u', 's', 't', 'o', 'm', '-', 'h', 'e', 'a', 'd', 'e', 'r');
+    assertEquals(1, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries("custom-key", "custom-header"));
+    assertBytes(0xbe);
+    assertEquals(1, hpackWriter.headerCount);
+  }
+
+  @Test public void doNotIndexPseudoHeaders() throws IOException {
+    hpackWriter.writeHeaders(headerEntries(":method", "PUT"));
+    assertBytes(0x02, 3, 'P', 'U', 'T');
+    assertEquals(0, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries(":path", "/okhttp"));
+    assertBytes(0x04, 7, '/', 'o', 'k', 'h', 't', 't', 'p');
+    assertEquals(0, hpackWriter.headerCount);
+  }
+
+  @Test public void incrementalIndexingWithAuthorityPseudoHeader() throws IOException {
+    hpackWriter.writeHeaders(headerEntries(":authority", "foo.com"));
+    assertBytes(0x41, 7, 'f', 'o', 'o', '.', 'c', 'o', 'm');
+    assertEquals(1, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries(":authority", "foo.com"));
+    assertBytes(0xbe);
+    assertEquals(1, hpackWriter.headerCount);
+
+    // If the :authority header somehow changes, it should be re-added to the dynamic table.
+    hpackWriter.writeHeaders(headerEntries(":authority", "bar.com"));
+    assertBytes(0x41, 7, 'b', 'a', 'r', '.', 'c', 'o', 'm');
+    assertEquals(2, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries(":authority", "bar.com"));
+    assertBytes(0xbe);
+    assertEquals(2, hpackWriter.headerCount);
+  }
+
+  @Test public void incrementalIndexingWithStaticTableIndexedName() throws IOException {
+    hpackWriter.writeHeaders(headerEntries("accept-encoding", "gzip"));
+    assertBytes(0x50, 4, 'g', 'z', 'i', 'p');
+    assertEquals(1, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries("accept-encoding", "gzip"));
+    assertBytes(0xbe);
+    assertEquals(1, hpackWriter.headerCount);
+  }
+
+  @Test public void incrementalIndexingWithDynamcTableIndexedName() throws IOException {
+    hpackWriter.writeHeaders(headerEntries("foo", "bar"));
+    assertBytes(0x40, 3, 'f', 'o', 'o', 3, 'b', 'a', 'r');
+    assertEquals(1, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries("foo", "bar1"));
+    assertBytes(0x7e, 4, 'b', 'a', 'r', '1');
+    assertEquals(2, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries("foo", "bar1"));
+    assertBytes(0xbe);
+    assertEquals(2, hpackWriter.headerCount);
+  }
+
+  private Hpack.Reader newReader(Buffer source) {
+    return new Hpack.Reader(4096, source);
+  }
+
+  private Buffer byteStream(int... bytes) {
+    return new Buffer().write(intArrayToByteArray(bytes));
+  }
+
+  private void checkEntry(Header entry, String name, String value, int size) {
+    assertEquals(name, entry.name.utf8());
+    assertEquals(value, entry.value.utf8());
+    assertEquals(size, entry.hpackSize);
+  }
+
+  private void assertBytes(int... bytes) throws IOException {
+    ByteString expected = intArrayToByteArray(bytes);
+    ByteString actual = bytesOut.readByteString();
+    assertEquals(expected, actual);
+  }
+
+  private ByteString intArrayToByteArray(int[] bytes) {
+    byte[] data = new byte[bytes.length];
+    for (int i = 0; i < bytes.length; i++) {
+      data[i] = (byte) bytes[i];
+    }
+    return ByteString.of(data);
+  }
+
+  private int readerHeaderTableLength() {
+    return hpackReader.dynamicTable.length;
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
new file mode 100644
index 0000000000..c8af96913b
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
@@ -0,0 +1,1701 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.net.Socket;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+import okhttp3.internal.Util;
+import okhttp3.internal.http2.MockHttp2Peer.InFrame;
+import okio.AsyncTimeout;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.Okio;
+import okio.Sink;
+import okio.Source;
+import org.junit.After;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import org.junit.rules.Timeout;
+
+import static okhttp3.TestUtil.headerEntries;
+import static okhttp3.TestUtil.repeat;
+import static okhttp3.internal.Util.EMPTY_BYTE_ARRAY;
+import static okhttp3.internal.http2.Http2Connection.Listener.REFUSE_INCOMING_STREAMS;
+import static okhttp3.internal.http2.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
+import static okhttp3.internal.http2.Settings.ENABLE_PUSH;
+import static okhttp3.internal.http2.Settings.HEADER_TABLE_SIZE;
+import static okhttp3.internal.http2.Settings.INITIAL_WINDOW_SIZE;
+import static okhttp3.internal.http2.Settings.MAX_CONCURRENT_STREAMS;
+import static okhttp3.internal.http2.Settings.MAX_FRAME_SIZE;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class Http2ConnectionTest {
+  private final MockHttp2Peer peer = new MockHttp2Peer();
+
+  @Rule public final TestRule timeout = new Timeout(5_000);
+
+  @After public void tearDown() throws Exception {
+    peer.close();
+  }
+
+  @Test public void serverPingsClientHttp2() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.sendFrame().ping(false, 2, 3);
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    connect(peer);
+
+    // verify the peer received what was expected
+    InFrame ping = peer.takeFrame();
+    assertEquals(Http2.TYPE_PING, ping.type);
+    assertEquals(0, ping.streamId);
+    assertEquals(2, ping.payload1);
+    assertEquals(3, ping.payload2);
+    assertTrue(ping.ack);
+  }
+
+  @Test public void clientPingsServerHttp2() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 5);
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Ping ping = connection.ping();
+    assertTrue(ping.roundTripTime() > 0);
+    assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
+
+    // verify the peer received what was expected
+    InFrame pingFrame = peer.takeFrame();
+    assertEquals(0, pingFrame.streamId);
+    assertEquals(1, pingFrame.payload1);
+    assertEquals(0x4f4b6f6b, pingFrame.payload2); // connection.ping() sets this.
+    assertFalse(pingFrame.ack);
+  }
+
+  @Test public void peerHttp2ServerLowersInitialWindowSize() throws Exception {
+    Settings initial = new Settings();
+    initial.set(INITIAL_WINDOW_SIZE, 1684);
+    Settings shouldntImpactConnection = new Settings();
+    shouldntImpactConnection.set(INITIAL_WINDOW_SIZE, 3368);
+
+    peer.sendFrame().settings(initial);
+    peer.acceptFrame(); // ACK
+    peer.sendFrame().settings(shouldntImpactConnection);
+    peer.acceptFrame(); // ACK 2
+    peer.acceptFrame(); // HEADERS
+    peer.play();
+
+    Http2Connection connection = connect(peer);
+
+    // Verify the peer received the second ACK.
+    InFrame ackFrame = peer.takeFrame();
+    assertEquals(Http2.TYPE_SETTINGS, ackFrame.type);
+    assertEquals(0, ackFrame.streamId);
+    assertTrue(ackFrame.ack);
+
+    // This stream was created *after* the connection settings were adjusted.
+    Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
+
+    assertEquals(3368, connection.peerSettings.getInitialWindowSize());
+    assertEquals(1684, connection.bytesLeftInWriteWindow); // initial wasn't affected.
+    // New Stream is has the most recent initial window size.
+    assertEquals(3368, stream.bytesLeftInWriteWindow);
+  }
+
+  @Test public void peerHttp2ServerZerosCompressionTable() throws Exception {
+    boolean client = false; // Peer is server, so we are client.
+    Settings settings = new Settings();
+    settings.set(HEADER_TABLE_SIZE, 0);
+
+    Http2Connection connection = connectWithSettings(client, settings);
+
+    // Verify the peer's settings were read and applied.
+    assertEquals(0, connection.peerSettings.getHeaderTableSize());
+    Http2Writer writer = connection.writer;
+    assertEquals(0, writer.hpackWriter.dynamicTableByteCount);
+    assertEquals(0, writer.hpackWriter.headerTableSizeSetting);
+  }
+
+  @Test public void peerHttp2ClientDisablesPush() throws Exception {
+    boolean client = false; // Peer is client, so we are server.
+    Settings settings = new Settings();
+    settings.set(ENABLE_PUSH, 0); // The peer client disables push.
+
+    Http2Connection connection = connectWithSettings(client, settings);
+
+    // verify the peer's settings were read and applied.
+    assertFalse(connection.peerSettings.getEnablePush(true));
+  }
+
+  @Test public void peerIncreasesMaxFrameSize() throws Exception {
+    int newMaxFrameSize = 0x4001;
+    Settings settings = new Settings();
+    settings.set(MAX_FRAME_SIZE, newMaxFrameSize);
+
+    Http2Connection connection = connectWithSettings(true, settings);
+
+    // verify the peer's settings were read and applied.
+    assertEquals(newMaxFrameSize, connection.peerSettings.getMaxFrameSize(-1));
+    assertEquals(newMaxFrameSize, connection.writer.maxDataLength());
+  }
+
+  /**
+   * Webservers may set the initial window size to zero, which is a special case because it means
+   * that we have to flush headers immediately before any request body can be sent.
+   * https://github.com/square/okhttp/issues/2543
+   */
+  @Test public void peerSetsZeroFlowControl() throws Exception {
+    peer.setClient(true);
+
+    // Write the mocking script.
+    peer.sendFrame().settings(new Settings().set(INITIAL_WINDOW_SIZE, 0));
+    peer.acceptFrame(); // ACK
+    peer.sendFrame().windowUpdate(0, 10); // Increase the connection window size.
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
+    peer.acceptFrame(); // HEADERS STREAM 3
+    peer.sendFrame().windowUpdate(3, 5);
+    peer.acceptFrame(); // DATA STREAM 3 "abcde"
+    peer.sendFrame().windowUpdate(3, 5);
+    peer.acceptFrame(); // DATA STREAM 3 "fghi"
+    peer.play();
+
+    // Play it back.
+    Http2Connection connection = connect(peer);
+    connection.ping().roundTripTime(); // Ensure the SETTINGS have been received.
+    Http2Stream stream = connection.newStream(headerEntries("a", "android"), true);
+    BufferedSink sink = Okio.buffer(stream.getSink());
+    sink.writeUtf8("abcdefghi");
+    sink.flush();
+
+    // Verify the peer received what was expected.
+    peer.takeFrame(); // PING
+    InFrame headers = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, headers.type);
+    InFrame data1 = peer.takeFrame();
+    assertEquals(Http2.TYPE_DATA, data1.type);
+    assertEquals(3, data1.streamId);
+    assertTrue(Arrays.equals("abcde".getBytes("UTF-8"), data1.data));
+    InFrame data2 = peer.takeFrame();
+    assertEquals(Http2.TYPE_DATA, data2.type);
+    assertEquals(3, data2.streamId);
+    assertTrue(Arrays.equals("fghi".getBytes("UTF-8"), data2.data));
+  }
+
+  @Test public void receiveGoAwayHttp2() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM 3
+    peer.acceptFrame(); // SYN_STREAM 5
+    peer.sendFrame().goAway(3, ErrorCode.PROTOCOL_ERROR, EMPTY_BYTE_ARRAY);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
+    peer.acceptFrame(); // DATA STREAM 3
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream1 = connection.newStream(headerEntries("a", "android"), true);
+    Http2Stream stream2 = connection.newStream(headerEntries("b", "banana"), true);
+    connection.ping().roundTripTime(); // Ensure the GO_AWAY that resets stream2 has been received.
+    BufferedSink sink1 = Okio.buffer(stream1.getSink());
+    BufferedSink sink2 = Okio.buffer(stream2.getSink());
+    sink1.writeUtf8("abc");
+    try {
+      sink2.writeUtf8("abc");
+      sink2.flush();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream was reset: REFUSED_STREAM", expected.getMessage());
+    }
+    sink1.writeUtf8("def");
+    sink1.close();
+    try {
+      connection.newStream(headerEntries("c", "cola"), true);
+      fail();
+    } catch (ConnectionShutdownException expected) {
+    }
+    assertTrue(stream1.isOpen());
+    assertFalse(stream2.isOpen());
+    assertEquals(1, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    InFrame synStream1 = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream1.type);
+    InFrame synStream2 = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream2.type);
+    InFrame ping = peer.takeFrame();
+    assertEquals(Http2.TYPE_PING, ping.type);
+    InFrame data1 = peer.takeFrame();
+    assertEquals(Http2.TYPE_DATA, data1.type);
+    assertEquals(3, data1.streamId);
+    assertTrue(Arrays.equals("abcdef".getBytes("UTF-8"), data1.data));
+  }
+
+  @Test public void readSendsWindowUpdateHttp2() throws Exception {
+    int windowSize = 100;
+    int windowUpdateThreshold = 50;
+
+    // Write the mocking script.
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    for (int i = 0; i < 3; i++) {
+      // Send frames of summing to size 50, which is windowUpdateThreshold.
+      peer.sendFrame().data(false, 3, data(24), 24);
+      peer.sendFrame().data(false, 3, data(25), 25);
+      peer.sendFrame().data(false, 3, data(1), 1);
+      peer.acceptFrame(); // connection WINDOW UPDATE
+      peer.acceptFrame(); // stream WINDOW UPDATE
+    }
+    peer.sendFrame().data(true, 3, data(0), 0);
+    peer.play();
+
+    // Play it back.
+    Http2Connection connection = connect(peer);
+    connection.okHttpSettings.set(INITIAL_WINDOW_SIZE, windowSize);
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
+    assertEquals(0, stream.unacknowledgedBytesRead);
+    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
+    Source in = stream.getSource();
+    Buffer buffer = new Buffer();
+    buffer.writeAll(in);
+    assertEquals(-1, in.read(buffer, 1));
+    assertEquals(150, buffer.size());
+
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    for (int i = 0; i < 3; i++) {
+      List<Integer> windowUpdateStreamIds = new ArrayList<>(2);
+      for (int j = 0; j < 2; j++) {
+        InFrame windowUpdate = peer.takeFrame();
+        assertEquals(Http2.TYPE_WINDOW_UPDATE, windowUpdate.type);
+        windowUpdateStreamIds.add(windowUpdate.streamId);
+        assertEquals(windowUpdateThreshold, windowUpdate.windowSizeIncrement);
+      }
+      assertTrue(windowUpdateStreamIds.contains(0)); // connection
+      assertTrue(windowUpdateStreamIds.contains(3)); // stream
+    }
+  }
+
+  @Test public void serverSendsEmptyDataClientDoesntSendWindowUpdateHttp2() throws Exception {
+    // Write the mocking script.
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().data(true, 3, data(0), 0);
+    peer.play();
+
+    // Play it back.
+    Http2Connection connection = connect(peer);
+    Http2Stream client = connection.newStream(headerEntries("b", "banana"), false);
+    assertEquals(-1, client.getSource().read(new Buffer(), 1));
+
+    // Verify the peer received what was expected.
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertEquals(5, peer.frameCount());
+  }
+
+  @Test public void clientSendsEmptyDataServerDoesntSendWindowUpdateHttp2() throws Exception {
+    // Write the mocking script.
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // DATA
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.play();
+
+    // Play it back.
+    Http2Connection connection = connect(peer);
+    Http2Stream client = connection.newStream(headerEntries("b", "banana"), true);
+    BufferedSink out = Okio.buffer(client.getSink());
+    out.write(EMPTY_BYTE_ARRAY);
+    out.flush();
+    out.close();
+
+    // Verify the peer received what was expected.
+    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_DATA, peer.takeFrame().type);
+    assertEquals(5, peer.frameCount());
+  }
+
+  @Test public void maxFrameSizeHonored() throws Exception {
+    byte[] buff = new byte[peer.maxOutboundDataLength() + 1];
+    Arrays.fill(buff, (byte) '*');
+
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.acceptFrame(); // DATA
+    peer.acceptFrame(); // DATA
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
+    BufferedSink out = Okio.buffer(stream.getSink());
+    out.write(buff);
+    out.flush();
+    out.close();
+
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    InFrame data = peer.takeFrame();
+    assertEquals(peer.maxOutboundDataLength(), data.data.length);
+    data = peer.takeFrame();
+    assertEquals(1, data.data.length);
+  }
+
+  @Test public void pushPromiseStream() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    final List<Header> expectedRequestHeaders = Arrays.asList(
+        new Header(Header.TARGET_METHOD, "GET"),
+        new Header(Header.TARGET_SCHEME, "https"),
+        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
+        new Header(Header.TARGET_PATH, "/cached")
+    );
+    peer.sendFrame().pushPromise(3, 2, expectedRequestHeaders);
+    final List<Header> expectedResponseHeaders = Arrays.asList(
+        new Header(Header.RESPONSE_STATUS, "200")
+    );
+    peer.sendFrame().synReply(true, 2, expectedResponseHeaders);
+    peer.sendFrame().data(true, 3, data(0), 0);
+    peer.play();
+
+    RecordingPushObserver observer = new RecordingPushObserver();
+
+    // play it back
+    Http2Connection connection = connect(peer, observer, REFUSE_INCOMING_STREAMS);
+    Http2Stream client = connection.newStream(headerEntries("b", "banana"), false);
+    assertEquals(-1, client.getSource().read(new Buffer(), 1));
+
+    // verify the peer received what was expected
+    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
+
+    assertEquals(expectedRequestHeaders, observer.takeEvent());
+    assertEquals(expectedResponseHeaders, observer.takeEvent());
+  }
+
+  @Test public void doublePushPromise() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.sendFrame().pushPromise(3, 2, headerEntries("a", "android"));
+    peer.acceptFrame(); // SYN_REPLY
+    peer.sendFrame().pushPromise(3, 2, headerEntries("b", "banana"));
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    connection.newStream(headerEntries("b", "banana"), false);
+
+    // verify the peer received what was expected
+    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(ErrorCode.PROTOCOL_ERROR, peer.takeFrame().errorCode);
+  }
+
+  @Test public void pushPromiseStreamsAutomaticallyCancel() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.sendFrame().pushPromise(3, 2, Arrays.asList(
+        new Header(Header.TARGET_METHOD, "GET"),
+        new Header(Header.TARGET_SCHEME, "https"),
+        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
+        new Header(Header.TARGET_PATH, "/cached")
+    ));
+    peer.sendFrame().synReply(true, 2, Arrays.asList(
+        new Header(Header.RESPONSE_STATUS, "200")
+    ));
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    connect(peer, PushObserver.CANCEL, REFUSE_INCOMING_STREAMS);
+
+    // verify the peer received what was expected
+    InFrame rstStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_RST_STREAM, rstStream.type);
+    assertEquals(2, rstStream.streamId);
+    assertEquals(ErrorCode.CANCEL, rstStream.errorCode);
+  }
+
+  /**
+   * When writing a set of headers fails due to an {@code IOException}, make sure the writer is left
+   * in a consistent state so the next writer also gets an {@code IOException} also instead of
+   * something worse (like an {@link IllegalStateException}.
+   *
+   * <p>See https://github.com/square/okhttp/issues/1651
+   */
+  @Test public void socketExceptionWhileWritingHeaders() throws Exception {
+    peer.acceptFrame(); // SYN_STREAM.
+    peer.play();
+
+    String longString = repeat('a', Http2.INITIAL_MAX_FRAME_SIZE + 1);
+    Socket socket = peer.openSocket();
+    Http2Connection connection = new Http2Connection.Builder(true)
+        .socket(socket)
+        .pushObserver(IGNORE)
+        .build();
+    connection.start(false);
+    socket.shutdownOutput();
+    try {
+      connection.newStream(headerEntries("a", longString), false);
+      fail();
+    } catch (IOException expected) {
+    }
+    try {
+      connection.newStream(headerEntries("b", longString), false);
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void clientCreatesStreamAndServerReplies() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // DATA
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().data(true, 3, new Buffer().writeUtf8("robot"), 5);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0); // PING
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
+    BufferedSink out = Okio.buffer(stream.getSink());
+    out.writeUtf8("c3po");
+    out.close();
+    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
+    assertStreamData("robot", stream.getSource());
+    connection.ping().roundTripTime();
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertFalse(synStream.outFinished);
+    assertEquals(3, synStream.streamId);
+    assertEquals(-1, synStream.associatedStreamId);
+    assertEquals(headerEntries("b", "banana"), synStream.headerBlock);
+    InFrame requestData = peer.takeFrame();
+    assertTrue(Arrays.equals("c3po".getBytes("UTF-8"), requestData.data));
+  }
+
+  @Test public void clientCreatesStreamAndServerRepliesWithFin() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // PING
+    peer.sendFrame().synReply(true, 3, headerEntries("a", "android"));
+    peer.sendFrame().ping(true, 1, 0);
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    connection.newStream(headerEntries("b", "banana"), false);
+    assertEquals(1, connection.openStreamCount());
+    connection.ping().roundTripTime(); // Ensure that the SYN_REPLY has been received.
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    InFrame ping = peer.takeFrame();
+    assertEquals(Http2.TYPE_PING, ping.type);
+  }
+
+  @Test public void serverPingsClient() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.sendFrame().ping(false, 2, 0);
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    connect(peer);
+
+    // verify the peer received what was expected
+    InFrame ping = peer.takeFrame();
+    assertEquals(0, ping.streamId);
+    assertEquals(2, ping.payload1);
+    assertEquals(0, ping.payload2);
+    assertTrue(ping.ack);
+  }
+
+  @Test public void clientPingsServer() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 5);
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Ping ping = connection.ping();
+    assertTrue(ping.roundTripTime() > 0);
+    assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
+
+    // verify the peer received what was expected
+    InFrame pingFrame = peer.takeFrame();
+    assertEquals(Http2.TYPE_PING, pingFrame.type);
+    assertEquals(1, pingFrame.payload1);
+    assertEquals(new Buffer().writeUtf8("OKok").readInt(), pingFrame.payload2);
+    assertFalse(pingFrame.ack);
+  }
+
+  @Test public void unexpectedPingIsNotReturned() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.sendFrame().ping(false, 2, 0);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 3, 0); // This ping will not be returned.
+    peer.sendFrame().ping(false, 4, 0);
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    connect(peer);
+
+    // verify the peer received what was expected
+    InFrame ping2 = peer.takeFrame();
+    assertEquals(2, ping2.payload1);
+    InFrame ping4 = peer.takeFrame();
+    assertEquals(4, ping4.payload1);
+  }
+
+  @Test public void serverSendsSettingsToClient() throws Exception {
+    // write the mocking script
+    final Settings settings = new Settings();
+    settings.set(MAX_CONCURRENT_STREAMS, 10);
+    peer.sendFrame().settings(settings);
+    peer.acceptFrame(); // ACK
+    peer.sendFrame().ping(false, 2, 0);
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    final CountDownLatch maxConcurrentStreamsUpdated = new CountDownLatch(1);
+    final AtomicInteger maxConcurrentStreams = new AtomicInteger();
+    Http2Connection.Listener listener = new Http2Connection.Listener() {
+      @Override public void onStream(Http2Stream stream) throws IOException {
+        throw new AssertionError();
+      }
+
+      @Override public void onSettings(Http2Connection connection) {
+        maxConcurrentStreams.set(connection.maxConcurrentStreams());
+        maxConcurrentStreamsUpdated.countDown();
+      }
+    };
+    Http2Connection connection = connect(peer, IGNORE, listener);
+
+    synchronized (connection) {
+      assertEquals(10, connection.peerSettings.getMaxConcurrentStreams(-1));
+    }
+    maxConcurrentStreamsUpdated.await();
+    assertEquals(10, maxConcurrentStreams.get());
+  }
+
+  @Test public void multipleSettingsFramesAreMerged() throws Exception {
+    // write the mocking script
+    Settings settings1 = new Settings();
+    settings1.set(HEADER_TABLE_SIZE, 10000);
+    settings1.set(INITIAL_WINDOW_SIZE, 20000);
+    settings1.set(MAX_FRAME_SIZE, 30000);
+    peer.sendFrame().settings(settings1);
+    peer.acceptFrame(); // ACK SETTINGS
+    Settings settings2 = new Settings();
+    settings2.set(INITIAL_WINDOW_SIZE, 40000);
+    settings2.set(MAX_FRAME_SIZE, 50000);
+    settings2.set(MAX_CONCURRENT_STREAMS, 60000);
+    peer.sendFrame().settings(settings2);
+    peer.acceptFrame(); // ACK SETTINGS
+    peer.sendFrame().ping(false, 2, 0);
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+
+    assertEquals(Http2.TYPE_SETTINGS, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_PING, peer.takeFrame().type);
+    synchronized (connection) {
+      assertEquals(10000, connection.peerSettings.getHeaderTableSize());
+      assertEquals(40000, connection.peerSettings.getInitialWindowSize());
+      assertEquals(50000, connection.peerSettings.getMaxFrameSize(-1));
+      assertEquals(60000, connection.peerSettings.getMaxConcurrentStreams(-1));
+    }
+  }
+
+  @Test public void clearSettingsBeforeMerge() throws Exception {
+    // write the mocking script
+    Settings settings1 = new Settings();
+    settings1.set(HEADER_TABLE_SIZE, 10000);
+    settings1.set(INITIAL_WINDOW_SIZE, 20000);
+    settings1.set(MAX_FRAME_SIZE, 30000);
+    peer.sendFrame().settings(settings1);
+    peer.acceptFrame(); // ACK
+    peer.sendFrame().ping(false, 2, 0);
+    peer.acceptFrame();
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+
+    // fake a settings frame with clear flag set.
+    Settings settings2 = new Settings();
+    settings2.set(MAX_CONCURRENT_STREAMS, 60000);
+    connection.readerRunnable.settings(true, settings2);
+
+    synchronized (connection) {
+      assertEquals(-1, connection.peerSettings.getHeaderTableSize());
+      assertEquals(DEFAULT_INITIAL_WINDOW_SIZE, connection.peerSettings.getInitialWindowSize());
+      assertEquals(-1, connection.peerSettings.getMaxFrameSize(-1));
+      assertEquals(60000, connection.peerSettings.getMaxConcurrentStreams(-1));
+    }
+  }
+
+  @Test public void bogusDataFrameDoesNotDisruptConnection() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.sendFrame().data(true, 41, new Buffer().writeUtf8("bogus"), 5);
+    peer.acceptFrame(); // RST_STREAM
+    peer.sendFrame().ping(false, 2, 0);
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    connect(peer);
+
+    // verify the peer received what was expected
+    InFrame rstStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_RST_STREAM, rstStream.type);
+    assertEquals(41, rstStream.streamId);
+    assertEquals(ErrorCode.PROTOCOL_ERROR, rstStream.errorCode);
+    InFrame ping = peer.takeFrame();
+    assertEquals(2, ping.payload1);
+  }
+
+  @Test public void bogusReplySilentlyIgnored() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.sendFrame().synReply(false, 41, headerEntries("a", "android"));
+    peer.sendFrame().ping(false, 2, 0);
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    connect(peer);
+
+    // verify the peer received what was expected
+    InFrame ping = peer.takeFrame();
+    assertEquals(2, ping.payload1);
+  }
+
+  @Test public void serverClosesClientOutputStream() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().rstStream(3, ErrorCode.CANCEL);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("a", "android"), true);
+    BufferedSink out = Okio.buffer(stream.getSink());
+    connection.ping().roundTripTime(); // Ensure that the RST_CANCEL has been received.
+    try {
+      out.writeUtf8("square");
+      out.flush();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream was reset: CANCEL", expected.getMessage());
+    }
+    try {
+      out.close();
+      fail();
+    } catch (IOException expected) {
+      // Close throws because buffered data wasn't flushed.
+    }
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertFalse(synStream.inFinished);
+    assertFalse(synStream.outFinished);
+    InFrame ping = peer.takeFrame();
+    assertEquals(Http2.TYPE_PING, ping.type);
+    assertEquals(1, ping.payload1);
+  }
+
+  /**
+   * Test that the client sends a RST_STREAM if doing so won't disrupt the output stream.
+   */
+  @Test public void clientClosesClientInputStream() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
+    Source in = stream.getSource();
+    BufferedSink out = Okio.buffer(stream.getSink());
+    in.close();
+    try {
+      in.read(new Buffer(), 1);
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream closed", expected.getMessage());
+    }
+    try {
+      out.writeUtf8("a");
+      out.flush();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream finished", expected.getMessage());
+    }
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertTrue(synStream.inFinished);
+    assertFalse(synStream.outFinished);
+    InFrame rstStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_RST_STREAM, rstStream.type);
+    assertEquals(ErrorCode.CANCEL, rstStream.errorCode);
+  }
+
+  /**
+   * Test that the client doesn't send a RST_STREAM if doing so will disrupt the output stream.
+   */
+  @Test public void clientClosesClientInputStreamIfOutputStreamIsClosed() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // DATA
+    peer.acceptFrame(); // DATA with FLAG_FIN
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("a", "android"), true);
+    Source source = stream.getSource();
+    BufferedSink out = Okio.buffer(stream.getSink());
+    source.close();
+    try {
+      source.read(new Buffer(), 1);
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream closed", expected.getMessage());
+    }
+    out.writeUtf8("square");
+    out.flush();
+    out.close();
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertFalse(synStream.inFinished);
+    assertFalse(synStream.outFinished);
+    InFrame data = peer.takeFrame();
+    assertEquals(Http2.TYPE_DATA, data.type);
+    assertTrue(Arrays.equals("square".getBytes("UTF-8"), data.data));
+    InFrame fin = peer.takeFrame();
+    assertEquals(Http2.TYPE_DATA, fin.type);
+    assertTrue(fin.inFinished);
+    assertFalse(fin.outFinished);
+    InFrame rstStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_RST_STREAM, rstStream.type);
+    assertEquals(ErrorCode.CANCEL, rstStream.errorCode);
+  }
+
+  @Test public void serverClosesClientInputStream() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("b", "banana"));
+    peer.sendFrame().data(true, 3, new Buffer().writeUtf8("square"), 6);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
+    Source source = stream.getSource();
+    assertStreamData("square", source);
+    connection.ping().roundTripTime(); // Ensure that inFinished has been received.
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertTrue(synStream.inFinished);
+    assertFalse(synStream.outFinished);
+  }
+
+  @Test public void remoteDoubleSynReply() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.acceptFrame(); // PING
+    peer.sendFrame().synReply(false, 3, headerEntries("b", "banana"));
+    peer.sendFrame().ping(true, 1, 0);
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("c", "cola"), false);
+    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
+    connection.ping().roundTripTime(); // Ensure that the 2nd SYN REPLY has been received.
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    InFrame ping = peer.takeFrame();
+    assertEquals(Http2.TYPE_PING, ping.type);
+  }
+
+  @Test public void remoteSendsDataAfterInFinished() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().data(true, 3, new Buffer().writeUtf8("robot"), 5);
+    peer.sendFrame().data(true, 3, new Buffer().writeUtf8("c3po"), 4);
+    peer.acceptFrame(); // RST_STREAM
+    peer.sendFrame().ping(false, 2, 0); // Ping just to make sure the stream was fastforwarded.
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
+    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
+    assertStreamData("robot", stream.getSource());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    InFrame rstStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_RST_STREAM, rstStream.type);
+    assertEquals(3, rstStream.streamId);
+    InFrame ping = peer.takeFrame();
+    assertEquals(Http2.TYPE_PING, ping.type);
+    assertEquals(2, ping.payload1);
+  }
+
+  @Test public void clientDoesNotLimitFlowControl() throws Exception {
+    int dataLength = 16384;
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("b", "banana"));
+    peer.sendFrame().data(false, 3, new Buffer().write(new byte[dataLength]), dataLength);
+    peer.sendFrame().data(false, 3, new Buffer().write(new byte[dataLength]), dataLength);
+    peer.sendFrame().data(false, 3, new Buffer().write(new byte[dataLength]), dataLength);
+    peer.sendFrame().data(false, 3, new Buffer().write(new byte[dataLength]), dataLength);
+    peer.sendFrame().data(false, 3, new Buffer().write(new byte[1]), 1);
+    peer.sendFrame().ping(false, 2, 0); // Ping just to make sure the stream was fastforwarded.
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
+    assertEquals(headerEntries("b", "banana"), stream.takeResponseHeaders());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    InFrame ping = peer.takeFrame();
+    assertEquals(Http2.TYPE_PING, ping.type);
+    assertEquals(2, ping.payload1);
+  }
+
+  @Test public void remoteSendsRefusedStreamBeforeReplyHeaders() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().rstStream(3, ErrorCode.REFUSED_STREAM);
+    peer.sendFrame().ping(false, 2, 0);
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
+    try {
+      stream.takeResponseHeaders();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream was reset: REFUSED_STREAM", expected.getMessage());
+    }
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    InFrame ping = peer.takeFrame();
+    assertEquals(Http2.TYPE_PING, ping.type);
+    assertEquals(2, ping.payload1);
+  }
+
+  @Test public void receiveGoAway() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM 1
+    peer.acceptFrame(); // SYN_STREAM 3
+    peer.acceptFrame(); // PING.
+    peer.sendFrame().goAway(3, ErrorCode.PROTOCOL_ERROR, Util.EMPTY_BYTE_ARRAY);
+    peer.sendFrame().ping(true, 1, 0);
+    peer.acceptFrame(); // DATA STREAM 1
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream1 = connection.newStream(headerEntries("a", "android"), true);
+    Http2Stream stream2 = connection.newStream(headerEntries("b", "banana"), true);
+    connection.ping().roundTripTime(); // Ensure the GO_AWAY that resets stream2 has been received.
+    BufferedSink sink1 = Okio.buffer(stream1.getSink());
+    BufferedSink sink2 = Okio.buffer(stream2.getSink());
+    sink1.writeUtf8("abc");
+    try {
+      sink2.writeUtf8("abc");
+      sink2.flush();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream was reset: REFUSED_STREAM", expected.getMessage());
+    }
+    sink1.writeUtf8("def");
+    sink1.close();
+    try {
+      connection.newStream(headerEntries("c", "cola"), false);
+      fail();
+    } catch (ConnectionShutdownException expected) {
+    }
+    assertTrue(stream1.isOpen());
+    assertFalse(stream2.isOpen());
+    assertEquals(1, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    InFrame synStream1 = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream1.type);
+    InFrame synStream2 = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream2.type);
+    InFrame ping = peer.takeFrame();
+    assertEquals(Http2.TYPE_PING, ping.type);
+    InFrame data1 = peer.takeFrame();
+    assertEquals(Http2.TYPE_DATA, data1.type);
+    assertEquals(3, data1.streamId);
+    assertTrue(Arrays.equals("abcdef".getBytes("UTF-8"), data1.data));
+  }
+
+  @Test public void sendGoAway() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM 1
+    peer.acceptFrame(); // GOAWAY
+    peer.acceptFrame(); // PING
+    peer.sendFrame().synStream(false, 2, 0, headerEntries("b", "b")); // Should be ignored!
+    peer.sendFrame().ping(true, 1, 0);
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    connection.newStream(headerEntries("a", "android"), false);
+    Ping ping = connection.ping();
+    connection.shutdown(ErrorCode.PROTOCOL_ERROR);
+    assertEquals(1, connection.openStreamCount());
+    ping.roundTripTime(); // Prevent the peer from exiting prematurely.
+
+    // verify the peer received what was expected
+    InFrame synStream1 = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream1.type);
+    InFrame pingFrame = peer.takeFrame();
+    assertEquals(Http2.TYPE_PING, pingFrame.type);
+    InFrame goaway = peer.takeFrame();
+    assertEquals(Http2.TYPE_GOAWAY, goaway.type);
+    assertEquals(0, goaway.streamId);
+    assertEquals(ErrorCode.PROTOCOL_ERROR, goaway.errorCode);
+  }
+
+  @Test public void noPingsAfterShutdown() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // GOAWAY
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    connection.shutdown(ErrorCode.INTERNAL_ERROR);
+    try {
+      connection.ping();
+      fail();
+    } catch (ConnectionShutdownException expected) {
+    }
+
+    // verify the peer received what was expected
+    InFrame goaway = peer.takeFrame();
+    assertEquals(Http2.TYPE_GOAWAY, goaway.type);
+    assertEquals(ErrorCode.INTERNAL_ERROR, goaway.errorCode);
+  }
+
+  @Test public void close() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // GOAWAY
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
+    assertEquals(1, connection.openStreamCount());
+    connection.close();
+    assertEquals(0, connection.openStreamCount());
+    try {
+      connection.newStream(headerEntries("b", "banana"), false);
+      fail();
+    } catch (ConnectionShutdownException expected) {
+    }
+    BufferedSink sink = Okio.buffer(stream.getSink());
+    try {
+      sink.writeByte(0);
+      sink.flush();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream finished", expected.getMessage());
+    }
+    try {
+      stream.getSource().read(new Buffer(), 1);
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream was reset: CANCEL", expected.getMessage());
+    }
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    InFrame goaway = peer.takeFrame();
+    assertEquals(Http2.TYPE_GOAWAY, goaway.type);
+    InFrame rstStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_RST_STREAM, rstStream.type);
+    assertEquals(3, rstStream.streamId);
+  }
+
+  @Test public void closeCancelsPings() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // PING
+    peer.acceptFrame(); // GOAWAY
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Ping ping = connection.ping();
+    connection.close();
+    assertEquals(-1, ping.roundTripTime());
+  }
+
+  @Test public void getResponseHeadersTimesOut() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
+    stream.readTimeout().timeout(500, TimeUnit.MILLISECONDS);
+    long startNanos = System.nanoTime();
+    try {
+      stream.takeResponseHeaders();
+      fail();
+    } catch (InterruptedIOException expected) {
+    }
+    long elapsedNanos = System.nanoTime() - startNanos;
+    awaitWatchdogIdle();
+    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_RST_STREAM, peer.takeFrame().type);
+  }
+
+  @Test public void readTimesOut() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
+    stream.readTimeout().timeout(500, TimeUnit.MILLISECONDS);
+    Source source = stream.getSource();
+    long startNanos = System.nanoTime();
+    try {
+      source.read(new Buffer(), 1);
+      fail();
+    } catch (InterruptedIOException expected) {
+    }
+    long elapsedNanos = System.nanoTime() - startNanos;
+    awaitWatchdogIdle();
+    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_RST_STREAM, peer.takeFrame().type);
+  }
+
+  @Test public void writeTimesOutAwaitingStreamWindow() throws Exception {
+    // Set the peer's receive window to 5 bytes!
+    Settings peerSettings = new Settings().set(INITIAL_WINDOW_SIZE, 5);
+
+    // write the mocking script
+    peer.sendFrame().settings(peerSettings);
+    peer.acceptFrame(); // ACK SETTINGS
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.acceptFrame(); // DATA
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    connection.ping().roundTripTime(); // Make sure settings have been received.
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
+    Sink sink = stream.getSink();
+    sink.write(new Buffer().writeUtf8("abcde"), 5);
+    stream.writeTimeout().timeout(500, TimeUnit.MILLISECONDS);
+    long startNanos = System.nanoTime();
+    sink.write(new Buffer().writeUtf8("f"), 1);
+    try {
+      sink.flush(); // This will time out waiting on the write window.
+      fail();
+    } catch (InterruptedIOException expected) {
+    }
+    long elapsedNanos = System.nanoTime() - startNanos;
+    awaitWatchdogIdle();
+    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    assertEquals(Http2.TYPE_PING, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_DATA, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_RST_STREAM, peer.takeFrame().type);
+  }
+
+  @Test public void writeTimesOutAwaitingConnectionWindow() throws Exception {
+    // Set the peer's receive window to 5 bytes. Give the stream 5 bytes back, so only the
+    // connection-level window is applicable.
+    Settings peerSettings = new Settings().set(INITIAL_WINDOW_SIZE, 5);
+
+    // write the mocking script
+    peer.sendFrame().settings(peerSettings);
+    peer.acceptFrame(); // ACK SETTINGS
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().windowUpdate(3, 5);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 3, 0);
+    peer.acceptFrame(); // DATA
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    connection.ping().roundTripTime(); // Make sure settings have been acked.
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
+    connection.ping().roundTripTime(); // Make sure the window update has been received.
+    Sink sink = stream.getSink();
+    stream.writeTimeout().timeout(500, TimeUnit.MILLISECONDS);
+    sink.write(new Buffer().writeUtf8("abcdef"), 6);
+    long startNanos = System.nanoTime();
+    try {
+      sink.flush(); // This will time out waiting on the write window.
+      fail();
+    } catch (InterruptedIOException expected) {
+    }
+    long elapsedNanos = System.nanoTime() - startNanos;
+    awaitWatchdogIdle();
+    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    assertEquals(Http2.TYPE_PING, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_PING, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_DATA, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_RST_STREAM, peer.takeFrame().type);
+  }
+
+  @Test public void outgoingWritesAreBatched() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.acceptFrame(); // DATA
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
+
+    // two outgoing writes
+    Sink sink = stream.getSink();
+    sink.write(new Buffer().writeUtf8("abcde"), 5);
+    sink.write(new Buffer().writeUtf8("fghij"), 5);
+    sink.close();
+
+    // verify the peer received one incoming frame
+    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
+    InFrame data = peer.takeFrame();
+    assertEquals(Http2.TYPE_DATA, data.type);
+    assertTrue(Arrays.equals("abcdefghij".getBytes("UTF-8"), data.data));
+    assertTrue(data.inFinished);
+  }
+
+  @Test public void headers() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // PING
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(3, headerEntries("c", "c3po"));
+    peer.sendFrame().ping(true, 1, 0);
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
+    connection.ping().roundTripTime(); // Ensure that the HEADERS has been received.
+    assertEquals(Arrays.asList(new Header("a", "android"), null, new Header("c", "c3po")),
+        stream.takeResponseHeaders());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    InFrame ping = peer.takeFrame();
+    assertEquals(Http2.TYPE_PING, ping.type);
+  }
+
+  @Test public void readMultipleSetsOfResponseHeaders() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0); // PING
+    peer.sendFrame().synReply(true, 3, headerEntries("c", "cola"));
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
+    stream.getConnection().flush();
+    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
+    connection.ping().roundTripTime();
+    assertEquals(headerEntries("c", "cola"), stream.takeResponseHeaders());
+
+    // verify the peer received what was expected
+    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_PING, peer.takeFrame().type);
+  }
+
+  @Test public void readSendsWindowUpdate() throws Exception {
+    int windowSize = 100;
+    int windowUpdateThreshold = 50;
+
+    // Write the mocking script.
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    for (int i = 0; i < 3; i++) {
+      // Send frames of summing to size 50, which is windowUpdateThreshold.
+      peer.sendFrame().data(false, 3, data(24), 24);
+      peer.sendFrame().data(false, 3, data(25), 25);
+      peer.sendFrame().data(false, 3, data(1), 1);
+      peer.acceptFrame(); // connection WINDOW UPDATE
+      peer.acceptFrame(); // stream WINDOW UPDATE
+    }
+    peer.sendFrame().data(true, 3, data(0), 0);
+    peer.play();
+
+    // Play it back.
+    Http2Connection connection = connect(peer);
+    connection.okHttpSettings.set(INITIAL_WINDOW_SIZE, windowSize);
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
+    assertEquals(0, stream.unacknowledgedBytesRead);
+    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
+    Source in = stream.getSource();
+    Buffer buffer = new Buffer();
+    buffer.writeAll(in);
+    assertEquals(-1, in.read(buffer, 1));
+    assertEquals(150, buffer.size());
+
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    for (int i = 0; i < 3; i++) {
+      List<Integer> windowUpdateStreamIds = new ArrayList<>(2);
+      for (int j = 0; j < 2; j++) {
+        InFrame windowUpdate = peer.takeFrame();
+        assertEquals(Http2.TYPE_WINDOW_UPDATE, windowUpdate.type);
+        windowUpdateStreamIds.add(windowUpdate.streamId);
+        assertEquals(windowUpdateThreshold, windowUpdate.windowSizeIncrement);
+      }
+      assertTrue(windowUpdateStreamIds.contains(0)); // connection
+      assertTrue(windowUpdateStreamIds.contains(3)); // stream
+    }
+  }
+
+  @Test public void serverSendsEmptyDataClientDoesntSendWindowUpdate() throws Exception {
+    // Write the mocking script.
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().data(true, 3, data(0), 0);
+    peer.play();
+
+    // Play it back.
+    Http2Connection connection = connect(peer);
+    Http2Stream client = connection.newStream(headerEntries("b", "banana"), false);
+    assertEquals(-1, client.getSource().read(new Buffer(), 1));
+
+    // Verify the peer received what was expected.
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertEquals(5, peer.frameCount());
+  }
+
+  @Test public void clientSendsEmptyDataServerDoesntSendWindowUpdate() throws Exception {
+    // Write the mocking script.
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // DATA
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.play();
+
+    // Play it back.
+    Http2Connection connection = connect(peer);
+    Http2Stream client = connection.newStream(headerEntries("b", "banana"), true);
+    BufferedSink out = Okio.buffer(client.getSink());
+    out.write(Util.EMPTY_BYTE_ARRAY);
+    out.flush();
+    out.close();
+
+    // Verify the peer received what was expected.
+    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_DATA, peer.takeFrame().type);
+    assertEquals(5, peer.frameCount());
+  }
+
+  @Test public void testTruncatedDataFrame() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().data(false, 3, data(1024), 1024);
+    peer.truncateLastFrame(8 + 100);
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
+    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
+    Source in = stream.getSource();
+    try {
+      Okio.buffer(in).readByteString(101);
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream was reset: PROTOCOL_ERROR", expected.getMessage());
+    }
+  }
+
+  @Test public void blockedStreamDoesntStarveNewStream() throws Exception {
+    int framesThatFillWindow = roundUp(DEFAULT_INITIAL_WINDOW_SIZE, peer.maxOutboundDataLength());
+
+    // Write the mocking script. This accepts more data frames than necessary!
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // SETTINGS ACK
+    peer.acceptFrame(); // SYN_STREAM on stream 1
+    for (int i = 0; i < framesThatFillWindow; i++) {
+      peer.acceptFrame(); // DATA on stream 1
+    }
+    peer.acceptFrame(); // SYN_STREAM on stream 2
+    peer.acceptFrame(); // DATA on stream 2
+    peer.play();
+
+    // Play it back.
+    Http2Connection connection = connect(peer);
+    Http2Stream stream1 = connection.newStream(headerEntries("a", "apple"), true);
+    BufferedSink out1 = Okio.buffer(stream1.getSink());
+    out1.write(new byte[DEFAULT_INITIAL_WINDOW_SIZE]);
+    out1.flush();
+
+    // Check that we've filled the window for both the stream and also the connection.
+    assertEquals(0, connection.bytesLeftInWriteWindow);
+    assertEquals(0, connection.getStream(3).bytesLeftInWriteWindow);
+
+    // receiving a window update on the connection will unblock new streams.
+    connection.readerRunnable.windowUpdate(0, 3);
+
+    assertEquals(3, connection.bytesLeftInWriteWindow);
+    assertEquals(0, connection.getStream(3).bytesLeftInWriteWindow);
+
+    // Another stream should be able to send data even though 1 is blocked.
+    Http2Stream stream2 = connection.newStream(headerEntries("b", "banana"), true);
+    BufferedSink out2 = Okio.buffer(stream2.getSink());
+    out2.writeUtf8("foo");
+    out2.flush();
+
+    assertEquals(0, connection.bytesLeftInWriteWindow);
+    assertEquals(0, connection.getStream(3).bytesLeftInWriteWindow);
+    assertEquals(DEFAULT_INITIAL_WINDOW_SIZE - 3, connection.getStream(5).bytesLeftInWriteWindow);
+  }
+
+  @Test public void remoteOmitsInitialSettings() throws Exception {
+    // Write the mocking script. Note no SETTINGS frame is sent or acknowledged.
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.acceptFrame(); // GOAWAY
+    peer.play();
+
+    Http2Connection connection = new Http2Connection.Builder(true)
+        .socket(peer.openSocket())
+        .build();
+    connection.start(false);
+
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
+    try {
+      stream.takeResponseHeaders();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream was reset: PROTOCOL_ERROR", expected.getMessage());
+    }
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    InFrame goaway = peer.takeFrame();
+    assertEquals(Http2.TYPE_GOAWAY, goaway.type);
+    assertEquals(ErrorCode.PROTOCOL_ERROR, goaway.errorCode);
+  }
+
+  private Buffer data(int byteCount) {
+    return new Buffer().write(new byte[byteCount]);
+  }
+
+  private void assertStreamData(String expected, Source source) throws IOException {
+    String actual = Okio.buffer(source).readUtf8();
+    assertEquals(expected, actual);
+  }
+
+  /**
+   * Returns true when all work currently in progress by the watchdog have completed. This method
+   * creates more work for the watchdog and waits for that work to be executed. When it is, we know
+   * work that preceded this call is complete.
+   */
+  private void awaitWatchdogIdle() throws InterruptedException {
+    final CountDownLatch latch = new CountDownLatch(1);
+    AsyncTimeout watchdogJob = new AsyncTimeout() {
+      @Override protected void timedOut() {
+        latch.countDown();
+      }
+    };
+    watchdogJob.deadlineNanoTime(System.nanoTime()); // Due immediately!
+    watchdogJob.enter();
+    latch.await();
+  }
+
+  static int roundUp(int num, int divisor) {
+    return (num + divisor - 1) / divisor;
+  }
+
+  private Http2Connection connectWithSettings(boolean client, Settings settings) throws Exception {
+    peer.setClient(client);
+    peer.sendFrame().settings(settings);
+    peer.acceptFrame(); // ACK
+    peer.play();
+    return connect(peer);
+  }
+
+  private Http2Connection connect(MockHttp2Peer peer) throws Exception {
+    return connect(peer, IGNORE, REFUSE_INCOMING_STREAMS);
+  }
+
+  /** Builds a new connection to {@code peer} with settings acked. */
+  private Http2Connection connect(MockHttp2Peer peer, PushObserver pushObserver,
+      Http2Connection.Listener listener) throws Exception {
+    Http2Connection connection = new Http2Connection.Builder(true)
+        .socket(peer.openSocket())
+        .pushObserver(pushObserver)
+        .listener(listener)
+        .build();
+    connection.start(false);
+
+    // verify the peer received the ACK
+    InFrame ackFrame = peer.takeFrame();
+    assertEquals(Http2.TYPE_SETTINGS, ackFrame.type);
+    assertEquals(0, ackFrame.streamId);
+    assertTrue(ackFrame.ack);
+
+    return connection;
+  }
+
+  static final PushObserver IGNORE = new PushObserver() {
+
+    @Override public boolean onRequest(int streamId, List<Header> requestHeaders) {
+      return false;
+    }
+
+    @Override public boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last) {
+      return false;
+    }
+
+    @Override public boolean onData(int streamId, BufferedSource source, int byteCount,
+        boolean last) throws IOException {
+      source.skip(byteCount);
+      return false;
+    }
+
+    @Override public void onReset(int streamId, ErrorCode errorCode) {
+    }
+  };
+
+  private static class RecordingPushObserver implements PushObserver {
+    final List<Object> events = new ArrayList<>();
+
+    public synchronized Object takeEvent() throws InterruptedException {
+      while (events.isEmpty()) {
+        wait();
+      }
+      return events.remove(0);
+    }
+
+    @Override public synchronized boolean onRequest(int streamId, List<Header> requestHeaders) {
+      assertEquals(2, streamId);
+      events.add(requestHeaders);
+      notifyAll();
+      return false;
+    }
+
+    @Override public synchronized boolean onHeaders(
+        int streamId, List<Header> responseHeaders, boolean last) {
+      assertEquals(2, streamId);
+      assertTrue(last);
+      events.add(responseHeaders);
+      notifyAll();
+      return false;
+    }
+
+    @Override public synchronized boolean onData(
+        int streamId, BufferedSource source, int byteCount, boolean last) {
+      events.add(new AssertionError("onData"));
+      notifyAll();
+      return false;
+    }
+
+    @Override public synchronized void onReset(int streamId, ErrorCode errorCode) {
+      events.add(new AssertionError("onReset"));
+      notifyAll();
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java
new file mode 100644
index 0000000000..24ec759c2d
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java
@@ -0,0 +1,768 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
+import okhttp3.internal.Util;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.GzipSink;
+import okio.Okio;
+import org.junit.Test;
+
+import static okhttp3.TestUtil.headerEntries;
+import static okhttp3.internal.http2.Http2.FLAG_COMPRESSED;
+import static okhttp3.internal.http2.Http2.FLAG_END_HEADERS;
+import static okhttp3.internal.http2.Http2.FLAG_END_STREAM;
+import static okhttp3.internal.http2.Http2.FLAG_NONE;
+import static okhttp3.internal.http2.Http2.FLAG_PADDED;
+import static okhttp3.internal.http2.Http2.FLAG_PRIORITY;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class Http2Test {
+  final Buffer frame = new Buffer();
+  final Http2Reader reader = new Http2Reader(frame, false);
+  final int expectedStreamId = 15;
+
+  @Test public void unknownFrameTypeSkipped() throws IOException {
+    writeMedium(frame, 4); // has a 4-byte field
+    frame.writeByte(99); // type 99
+    frame.writeByte(Http2.FLAG_NONE);
+    frame.writeInt(expectedStreamId);
+    frame.writeInt(111111111); // custom data
+
+    reader.nextFrame(false, new BaseTestHandler()); // Should not callback.
+  }
+
+  @Test public void onlyOneLiteralHeadersFrame() throws IOException {
+    final List<Header> sentHeaders = headerEntries("name", "value");
+
+    Buffer headerBytes = literalHeaders(sentHeaders);
+    writeMedium(frame, (int) headerBytes.size());
+    frame.writeByte(Http2.TYPE_HEADERS);
+    frame.writeByte(FLAG_END_HEADERS | FLAG_END_STREAM);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeAll(headerBytes);
+
+    assertEquals(frame, sendHeaderFrames(true, sentHeaders)); // Check writer sends the same bytes.
+
+    reader.nextFrame(false, new BaseTestHandler() {
+      @Override public void headers(boolean inFinished, int streamId,
+          int associatedStreamId, List<Header> headerBlock) {
+        assertTrue(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(-1, associatedStreamId);
+        assertEquals(sentHeaders, headerBlock);
+      }
+    });
+  }
+
+  @Test public void headersWithPriority() throws IOException {
+    final List<Header> sentHeaders = headerEntries("name", "value");
+
+    Buffer headerBytes = literalHeaders(sentHeaders);
+    writeMedium(frame, (int) (headerBytes.size() + 5));
+    frame.writeByte(Http2.TYPE_HEADERS);
+    frame.writeByte(FLAG_END_HEADERS | FLAG_PRIORITY);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeInt(0); // Independent stream.
+    frame.writeByte(255); // Heaviest weight, zero-indexed.
+    frame.writeAll(headerBytes);
+
+    reader.nextFrame(false, new BaseTestHandler() {
+      @Override public void priority(int streamId, int streamDependency, int weight,
+          boolean exclusive) {
+        assertEquals(0, streamDependency);
+        assertEquals(256, weight);
+        assertFalse(exclusive);
+      }
+
+      @Override public void headers(boolean inFinished, int streamId,
+          int associatedStreamId, List<Header> nameValueBlock) {
+        assertFalse(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(-1, associatedStreamId);
+        assertEquals(sentHeaders, nameValueBlock);
+      }
+    });
+  }
+
+  /** Headers are compressed, then framed. */
+  @Test public void headersFrameThenContinuation() throws IOException {
+    final List<Header> sentHeaders = largeHeaders();
+
+    Buffer headerBlock = literalHeaders(sentHeaders);
+
+    // Write the first headers frame.
+    writeMedium(frame, Http2.INITIAL_MAX_FRAME_SIZE);
+    frame.writeByte(Http2.TYPE_HEADERS);
+    frame.writeByte(Http2.FLAG_NONE);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.write(headerBlock, Http2.INITIAL_MAX_FRAME_SIZE);
+
+    // Write the continuation frame, specifying no more frames are expected.
+    writeMedium(frame, (int) headerBlock.size());
+    frame.writeByte(Http2.TYPE_CONTINUATION);
+    frame.writeByte(FLAG_END_HEADERS);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeAll(headerBlock);
+
+    assertEquals(frame, sendHeaderFrames(false, sentHeaders)); // Check writer sends the same bytes.
+
+    // Reading the above frames should result in a concatenated headerBlock.
+    reader.nextFrame(false, new BaseTestHandler() {
+      @Override public void headers(boolean inFinished, int streamId,
+          int associatedStreamId, List<Header> headerBlock) {
+        assertFalse(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(-1, associatedStreamId);
+        assertEquals(sentHeaders, headerBlock);
+      }
+    });
+  }
+
+  @Test public void pushPromise() throws IOException {
+    final int expectedPromisedStreamId = 11;
+
+    final List<Header> pushPromise = Arrays.asList(
+        new Header(Header.TARGET_METHOD, "GET"),
+        new Header(Header.TARGET_SCHEME, "https"),
+        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
+        new Header(Header.TARGET_PATH, "/")
+    );
+
+    // Write the push promise frame, specifying the associated stream ID.
+    Buffer headerBytes = literalHeaders(pushPromise);
+    writeMedium(frame, (int) (headerBytes.size() + 4));
+    frame.writeByte(Http2.TYPE_PUSH_PROMISE);
+    frame.writeByte(Http2.FLAG_END_PUSH_PROMISE);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeInt(expectedPromisedStreamId & 0x7fffffff);
+    frame.writeAll(headerBytes);
+
+    assertEquals(frame, sendPushPromiseFrames(expectedPromisedStreamId, pushPromise));
+
+    reader.nextFrame(false, new BaseTestHandler() {
+      @Override
+      public void pushPromise(int streamId, int promisedStreamId, List<Header> headerBlock) {
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(expectedPromisedStreamId, promisedStreamId);
+        assertEquals(pushPromise, headerBlock);
+      }
+    });
+  }
+
+  /** Headers are compressed, then framed. */
+  @Test public void pushPromiseThenContinuation() throws IOException {
+    final int expectedPromisedStreamId = 11;
+    final List<Header> pushPromise = largeHeaders();
+
+    // Decoding the first header will cross frame boundaries.
+    Buffer headerBlock = literalHeaders(pushPromise);
+
+    // Write the first headers frame.
+    writeMedium(frame, Http2.INITIAL_MAX_FRAME_SIZE);
+    frame.writeByte(Http2.TYPE_PUSH_PROMISE);
+    frame.writeByte(Http2.FLAG_NONE);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeInt(expectedPromisedStreamId & 0x7fffffff);
+    frame.write(headerBlock, Http2.INITIAL_MAX_FRAME_SIZE - 4);
+
+    // Write the continuation frame, specifying no more frames are expected.
+    writeMedium(frame, (int) headerBlock.size());
+    frame.writeByte(Http2.TYPE_CONTINUATION);
+    frame.writeByte(FLAG_END_HEADERS);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeAll(headerBlock);
+
+    assertEquals(frame, sendPushPromiseFrames(expectedPromisedStreamId, pushPromise));
+
+    // Reading the above frames should result in a concatenated headerBlock.
+    reader.nextFrame(false, new BaseTestHandler() {
+      @Override
+      public void pushPromise(int streamId, int promisedStreamId, List<Header> headerBlock) {
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(expectedPromisedStreamId, promisedStreamId);
+        assertEquals(pushPromise, headerBlock);
+      }
+    });
+  }
+
+  @Test public void readRstStreamFrame() throws IOException {
+    writeMedium(frame, 4);
+    frame.writeByte(Http2.TYPE_RST_STREAM);
+    frame.writeByte(Http2.FLAG_NONE);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeInt(ErrorCode.PROTOCOL_ERROR.httpCode);
+
+    reader.nextFrame(false, new BaseTestHandler() {
+      @Override public void rstStream(int streamId, ErrorCode errorCode) {
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(ErrorCode.PROTOCOL_ERROR, errorCode);
+      }
+    });
+  }
+
+  @Test public void readSettingsFrame() throws IOException {
+    final int reducedTableSizeBytes = 16;
+
+    writeMedium(frame, 12); // 2 settings * 6 bytes (2 for the code and 4 for the value).
+    frame.writeByte(Http2.TYPE_SETTINGS);
+    frame.writeByte(Http2.FLAG_NONE);
+    frame.writeInt(0); // Settings are always on the connection stream 0.
+    frame.writeShort(1); // SETTINGS_HEADER_TABLE_SIZE
+    frame.writeInt(reducedTableSizeBytes);
+    frame.writeShort(2); // SETTINGS_ENABLE_PUSH
+    frame.writeInt(0);
+
+    reader.nextFrame(false, new BaseTestHandler() {
+      @Override public void settings(boolean clearPrevious, Settings settings) {
+        assertFalse(clearPrevious); // No clearPrevious in HTTP/2.
+        assertEquals(reducedTableSizeBytes, settings.getHeaderTableSize());
+        assertEquals(false, settings.getEnablePush(true));
+      }
+    });
+  }
+
+  @Test public void readSettingsFrameInvalidPushValue() throws IOException {
+    writeMedium(frame, 6); // 2 for the code and 4 for the value
+    frame.writeByte(Http2.TYPE_SETTINGS);
+    frame.writeByte(Http2.FLAG_NONE);
+    frame.writeInt(0); // Settings are always on the connection stream 0.
+    frame.writeShort(2);
+    frame.writeInt(2);
+
+    try {
+      reader.nextFrame(false, new BaseTestHandler());
+      fail();
+    } catch (IOException e) {
+      assertEquals("PROTOCOL_ERROR SETTINGS_ENABLE_PUSH != 0 or 1", e.getMessage());
+    }
+  }
+
+  @Test public void readSettingsFrameUnknownSettingId() throws IOException {
+    writeMedium(frame, 6); // 2 for the code and 4 for the value
+    frame.writeByte(Http2.TYPE_SETTINGS);
+    frame.writeByte(Http2.FLAG_NONE);
+    frame.writeInt(0); // Settings are always on the connection stream 0.
+    frame.writeShort(7); // old number for SETTINGS_INITIAL_WINDOW_SIZE
+    frame.writeInt(1);
+
+    final AtomicInteger settingValue = new AtomicInteger();
+    reader.nextFrame(false, new BaseTestHandler() {
+      @Override public void settings(boolean clearPrevious, Settings settings) {
+        settingValue.set(settings.get(7));
+      }
+    });
+    assertEquals(settingValue.intValue(), 1);
+  }
+
+  @Test public void readSettingsFrameExperimentalId() throws IOException {
+    writeMedium(frame, 6); // 2 for the code and 4 for the value
+    frame.writeByte(Http2.TYPE_SETTINGS);
+    frame.writeByte(Http2.FLAG_NONE);
+    frame.writeInt(0); // Settings are always on the connection stream 0.
+    frame.write(ByteString.decodeHex("f000")); // Id reserved for experimental use.
+    frame.writeInt(1);
+
+    reader.nextFrame(false, new BaseTestHandler() {
+      @Override public void settings(boolean clearPrevious, Settings settings) {
+        // no-op
+      }
+    });
+  }
+
+  @Test public void readSettingsFrameNegativeWindowSize() throws IOException {
+    writeMedium(frame, 6); // 2 for the code and 4 for the value
+    frame.writeByte(Http2.TYPE_SETTINGS);
+    frame.writeByte(Http2.FLAG_NONE);
+    frame.writeInt(0); // Settings are always on the connection stream 0.
+    frame.writeShort(4); // SETTINGS_INITIAL_WINDOW_SIZE
+    frame.writeInt(Integer.MIN_VALUE);
+
+    try {
+      reader.nextFrame(false, new BaseTestHandler());
+      fail();
+    } catch (IOException e) {
+      assertEquals("PROTOCOL_ERROR SETTINGS_INITIAL_WINDOW_SIZE > 2^31 - 1", e.getMessage());
+    }
+  }
+
+  @Test public void readSettingsFrameNegativeFrameLength() throws IOException {
+    writeMedium(frame, 6); // 2 for the code and 4 for the value
+    frame.writeByte(Http2.TYPE_SETTINGS);
+    frame.writeByte(Http2.FLAG_NONE);
+    frame.writeInt(0); // Settings are always on the connection stream 0.
+    frame.writeShort(5); // SETTINGS_MAX_FRAME_SIZE
+    frame.writeInt(Integer.MIN_VALUE);
+
+    try {
+      reader.nextFrame(false, new BaseTestHandler());
+      fail();
+    } catch (IOException e) {
+      assertEquals("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: -2147483648", e.getMessage());
+    }
+  }
+
+  @Test public void readSettingsFrameTooShortFrameLength() throws IOException {
+    writeMedium(frame, 6); // 2 for the code and 4 for the value
+    frame.writeByte(Http2.TYPE_SETTINGS);
+    frame.writeByte(Http2.FLAG_NONE);
+    frame.writeInt(0); // Settings are always on the connection stream 0.
+    frame.writeShort(5); // SETTINGS_MAX_FRAME_SIZE
+    frame.writeInt((int) Math.pow(2, 14) - 1);
+
+    try {
+      reader.nextFrame(false, new BaseTestHandler());
+      fail();
+    } catch (IOException e) {
+      assertEquals("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: 16383", e.getMessage());
+    }
+  }
+
+  @Test public void readSettingsFrameTooLongFrameLength() throws IOException {
+    writeMedium(frame, 6); // 2 for the code and 4 for the value
+    frame.writeByte(Http2.TYPE_SETTINGS);
+    frame.writeByte(Http2.FLAG_NONE);
+    frame.writeInt(0); // Settings are always on the connection stream 0.
+    frame.writeShort(5); // SETTINGS_MAX_FRAME_SIZE
+    frame.writeInt((int) Math.pow(2, 24));
+
+    try {
+      reader.nextFrame(false, new BaseTestHandler());
+      fail();
+    } catch (IOException e) {
+      assertEquals("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: 16777216", e.getMessage());
+    }
+  }
+
+  @Test public void pingRoundTrip() throws IOException {
+    final int expectedPayload1 = 7;
+    final int expectedPayload2 = 8;
+
+    writeMedium(frame, 8); // length
+    frame.writeByte(Http2.TYPE_PING);
+    frame.writeByte(Http2.FLAG_ACK);
+    frame.writeInt(0); // connection-level
+    frame.writeInt(expectedPayload1);
+    frame.writeInt(expectedPayload2);
+
+    // Check writer sends the same bytes.
+    assertEquals(frame, sendPingFrame(true, expectedPayload1, expectedPayload2));
+
+    reader.nextFrame(false, new BaseTestHandler() {
+      @Override public void ping(boolean ack, int payload1, int payload2) {
+        assertTrue(ack);
+        assertEquals(expectedPayload1, payload1);
+        assertEquals(expectedPayload2, payload2);
+      }
+    });
+  }
+
+  @Test public void maxLengthDataFrame() throws IOException {
+    final byte[] expectedData = new byte[Http2.INITIAL_MAX_FRAME_SIZE];
+    Arrays.fill(expectedData, (byte) 2);
+
+    writeMedium(frame, expectedData.length);
+    frame.writeByte(Http2.TYPE_DATA);
+    frame.writeByte(Http2.FLAG_NONE);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.write(expectedData);
+
+    // Check writer sends the same bytes.
+    assertEquals(frame, sendDataFrame(new Buffer().write(expectedData)));
+
+    reader.nextFrame(false, new BaseTestHandler() {
+      @Override public void data(boolean inFinished, int streamId, BufferedSource source,
+          int length) throws IOException {
+        assertFalse(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(Http2.INITIAL_MAX_FRAME_SIZE, length);
+        ByteString data = source.readByteString(length);
+        for (byte b : data.toByteArray()) {
+          assertEquals(2, b);
+        }
+      }
+    });
+  }
+
+  @Test public void dataFrameNotAssociateWithStream() throws IOException {
+    byte[] payload = new byte[] {0x01, 0x02};
+
+    writeMedium(frame, payload.length);
+    frame.writeByte(Http2.TYPE_DATA);
+    frame.writeByte(Http2.FLAG_NONE);
+    frame.writeInt(0);
+    frame.write(payload);
+
+    try {
+      reader.nextFrame(false, new BaseTestHandler());
+      fail();
+    } catch (IOException e) {
+      assertEquals("PROTOCOL_ERROR: TYPE_DATA streamId == 0", e.getMessage());
+    }
+  }
+
+  /** We do not send SETTINGS_COMPRESS_DATA = 1, nor want to. Let's make sure we error. */
+  @Test public void compressedDataFrameWhenSettingDisabled() throws IOException {
+    byte[] expectedData = new byte[Http2.INITIAL_MAX_FRAME_SIZE];
+    Arrays.fill(expectedData, (byte) 2);
+    Buffer zipped = gzip(expectedData);
+    int zippedSize = (int) zipped.size();
+
+    writeMedium(frame, zippedSize);
+    frame.writeByte(Http2.TYPE_DATA);
+    frame.writeByte(FLAG_COMPRESSED);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    zipped.readAll(frame);
+
+    try {
+      reader.nextFrame(false, new BaseTestHandler());
+      fail();
+    } catch (IOException e) {
+      assertEquals("PROTOCOL_ERROR: FLAG_COMPRESSED without SETTINGS_COMPRESS_DATA",
+          e.getMessage());
+    }
+  }
+
+  @Test public void readPaddedDataFrame() throws IOException {
+    int dataLength = 1123;
+    byte[] expectedData = new byte[dataLength];
+    Arrays.fill(expectedData, (byte) 2);
+
+    int paddingLength = 254;
+    byte[] padding = new byte[paddingLength];
+    Arrays.fill(padding, (byte) 0);
+
+    writeMedium(frame, dataLength + paddingLength + 1);
+    frame.writeByte(Http2.TYPE_DATA);
+    frame.writeByte(FLAG_PADDED);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeByte(paddingLength);
+    frame.write(expectedData);
+    frame.write(padding);
+
+    reader.nextFrame(false, assertData());
+    assertTrue(frame.exhausted()); // Padding was skipped.
+  }
+
+  @Test public void readPaddedDataFrameZeroPadding() throws IOException {
+    int dataLength = 1123;
+    byte[] expectedData = new byte[dataLength];
+    Arrays.fill(expectedData, (byte) 2);
+
+    writeMedium(frame, dataLength + 1);
+    frame.writeByte(Http2.TYPE_DATA);
+    frame.writeByte(FLAG_PADDED);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeByte(0);
+    frame.write(expectedData);
+
+    reader.nextFrame(false, assertData());
+  }
+
+  @Test public void readPaddedHeadersFrame() throws IOException {
+    int paddingLength = 254;
+    byte[] padding = new byte[paddingLength];
+    Arrays.fill(padding, (byte) 0);
+
+    Buffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
+    writeMedium(frame, (int) headerBlock.size() + paddingLength + 1);
+    frame.writeByte(Http2.TYPE_HEADERS);
+    frame.writeByte(FLAG_END_HEADERS | FLAG_PADDED);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeByte(paddingLength);
+    frame.writeAll(headerBlock);
+    frame.write(padding);
+
+    reader.nextFrame(false, assertHeaderBlock());
+    assertTrue(frame.exhausted()); // Padding was skipped.
+  }
+
+  @Test public void readPaddedHeadersFrameZeroPadding() throws IOException {
+    Buffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
+    writeMedium(frame, (int) headerBlock.size() + 1);
+    frame.writeByte(Http2.TYPE_HEADERS);
+    frame.writeByte(FLAG_END_HEADERS | FLAG_PADDED);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeByte(0);
+    frame.writeAll(headerBlock);
+
+    reader.nextFrame(false, assertHeaderBlock());
+  }
+
+  /** Headers are compressed, then framed. */
+  @Test public void readPaddedHeadersFrameThenContinuation() throws IOException {
+    int paddingLength = 254;
+    byte[] padding = new byte[paddingLength];
+    Arrays.fill(padding, (byte) 0);
+
+    // Decoding the first header will cross frame boundaries.
+    Buffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
+
+    // Write the first headers frame.
+    writeMedium(frame, (int) (headerBlock.size() / 2) + paddingLength + 1);
+    frame.writeByte(Http2.TYPE_HEADERS);
+    frame.writeByte(FLAG_PADDED);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeByte(paddingLength);
+    frame.write(headerBlock, headerBlock.size() / 2);
+    frame.write(padding);
+
+    // Write the continuation frame, specifying no more frames are expected.
+    writeMedium(frame, (int) headerBlock.size());
+    frame.writeByte(Http2.TYPE_CONTINUATION);
+    frame.writeByte(FLAG_END_HEADERS);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeAll(headerBlock);
+
+    reader.nextFrame(false, assertHeaderBlock());
+    assertTrue(frame.exhausted());
+  }
+
+  @Test public void tooLargeDataFrame() throws IOException {
+    try {
+      sendDataFrame(new Buffer().write(new byte[0x1000000]));
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("FRAME_SIZE_ERROR length > 16384: 16777216", e.getMessage());
+    }
+  }
+
+  @Test public void windowUpdateRoundTrip() throws IOException {
+    final long expectedWindowSizeIncrement = 0x7fffffff;
+
+    writeMedium(frame, 4); // length
+    frame.writeByte(Http2.TYPE_WINDOW_UPDATE);
+    frame.writeByte(Http2.FLAG_NONE);
+    frame.writeInt(expectedStreamId);
+    frame.writeInt((int) expectedWindowSizeIncrement);
+
+    // Check writer sends the same bytes.
+    assertEquals(frame, windowUpdate(expectedWindowSizeIncrement));
+
+    reader.nextFrame(false, new BaseTestHandler() {
+      @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(expectedWindowSizeIncrement, windowSizeIncrement);
+      }
+    });
+  }
+
+  @Test public void badWindowSizeIncrement() throws IOException {
+    try {
+      windowUpdate(0);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: 0",
+          e.getMessage());
+    }
+    try {
+      windowUpdate(0x80000000L);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: 2147483648",
+          e.getMessage());
+    }
+  }
+
+  @Test public void goAwayWithoutDebugDataRoundTrip() throws IOException {
+    final ErrorCode expectedError = ErrorCode.PROTOCOL_ERROR;
+
+    writeMedium(frame, 8); // Without debug data there's only 2 32-bit fields.
+    frame.writeByte(Http2.TYPE_GOAWAY);
+    frame.writeByte(Http2.FLAG_NONE);
+    frame.writeInt(0); // connection-scope
+    frame.writeInt(expectedStreamId); // last good stream.
+    frame.writeInt(expectedError.httpCode);
+
+    // Check writer sends the same bytes.
+    assertEquals(frame, sendGoAway(expectedStreamId, expectedError, Util.EMPTY_BYTE_ARRAY));
+
+    reader.nextFrame(false, new BaseTestHandler() {
+      @Override public void goAway(
+          int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
+        assertEquals(expectedStreamId, lastGoodStreamId);
+        assertEquals(expectedError, errorCode);
+        assertEquals(0, debugData.size());
+      }
+    });
+  }
+
+  @Test public void goAwayWithDebugDataRoundTrip() throws IOException {
+    final ErrorCode expectedError = ErrorCode.PROTOCOL_ERROR;
+    final ByteString expectedData = ByteString.encodeUtf8("abcdefgh");
+
+    // Compose the expected GOAWAY frame without debug data.
+    writeMedium(frame, 8 + expectedData.size());
+    frame.writeByte(Http2.TYPE_GOAWAY);
+    frame.writeByte(Http2.FLAG_NONE);
+    frame.writeInt(0); // connection-scope
+    frame.writeInt(0); // never read any stream!
+    frame.writeInt(expectedError.httpCode);
+    frame.write(expectedData.toByteArray());
+
+    // Check writer sends the same bytes.
+    assertEquals(frame, sendGoAway(0, expectedError, expectedData.toByteArray()));
+
+    reader.nextFrame(false, new BaseTestHandler() {
+      @Override public void goAway(
+          int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
+        assertEquals(0, lastGoodStreamId);
+        assertEquals(expectedError, errorCode);
+        assertEquals(expectedData, debugData);
+      }
+    });
+  }
+
+  @Test public void frameSizeError() throws IOException {
+    Http2Writer writer = new Http2Writer(new Buffer(), true);
+
+    try {
+      writer.frameHeader(0, 16777216, Http2.TYPE_DATA, FLAG_NONE);
+      fail();
+    } catch (IllegalArgumentException e) {
+      // TODO: real max is based on settings between 16384 and 16777215
+      assertEquals("FRAME_SIZE_ERROR length > 16384: 16777216", e.getMessage());
+    }
+  }
+
+  @Test public void ackSettingsAppliesMaxFrameSize() throws IOException {
+    int newMaxFrameSize = 16777215;
+
+    Http2Writer writer = new Http2Writer(new Buffer(), true);
+
+    writer.applyAndAckSettings(new Settings().set(Settings.MAX_FRAME_SIZE, newMaxFrameSize));
+
+    assertEquals(newMaxFrameSize, writer.maxDataLength());
+    writer.frameHeader(0, newMaxFrameSize, Http2.TYPE_DATA, FLAG_NONE);
+  }
+
+  @Test public void streamIdHasReservedBit() throws IOException {
+    Http2Writer writer = new Http2Writer(new Buffer(), true);
+
+    try {
+      int streamId = 3;
+      streamId |= 1L << 31; // set reserved bit
+      writer.frameHeader(streamId, Http2.INITIAL_MAX_FRAME_SIZE, Http2.TYPE_DATA, FLAG_NONE);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("reserved bit set: -2147483645", e.getMessage());
+    }
+  }
+
+  private Buffer literalHeaders(List<Header> sentHeaders) throws IOException {
+    Buffer out = new Buffer();
+    new Hpack.Writer(out).writeHeaders(sentHeaders);
+    return out;
+  }
+
+  private Buffer sendHeaderFrames(boolean outFinished, List<Header> headers) throws IOException {
+    Buffer out = new Buffer();
+    new Http2Writer(out, true).headers(outFinished, expectedStreamId, headers);
+    return out;
+  }
+
+  private Buffer sendPushPromiseFrames(int streamId, List<Header> headers) throws IOException {
+    Buffer out = new Buffer();
+    new Http2Writer(out, true).pushPromise(expectedStreamId, streamId, headers);
+    return out;
+  }
+
+  private Buffer sendPingFrame(boolean ack, int payload1, int payload2) throws IOException {
+    Buffer out = new Buffer();
+    new Http2Writer(out, true).ping(ack, payload1, payload2);
+    return out;
+  }
+
+  private Buffer sendGoAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
+      throws IOException {
+    Buffer out = new Buffer();
+    new Http2Writer(out, true).goAway(lastGoodStreamId, errorCode, debugData);
+    return out;
+  }
+
+  private Buffer sendDataFrame(Buffer data) throws IOException {
+    Buffer out = new Buffer();
+    new Http2Writer(out, true).dataFrame(expectedStreamId, FLAG_NONE, data,
+        (int) data.size());
+    return out;
+  }
+
+  private Buffer windowUpdate(long windowSizeIncrement) throws IOException {
+    Buffer out = new Buffer();
+    new Http2Writer(out, true).windowUpdate(expectedStreamId, windowSizeIncrement);
+    return out;
+  }
+
+  private Http2Reader.Handler assertHeaderBlock() {
+    return new BaseTestHandler() {
+      @Override public void headers(boolean inFinished, int streamId,
+          int associatedStreamId, List<Header> headerBlock) {
+        assertFalse(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(-1, associatedStreamId);
+        assertEquals(headerEntries("foo", "barrr", "baz", "qux"), headerBlock);
+      }
+    };
+  }
+
+  private Http2Reader.Handler assertData() {
+    return new BaseTestHandler() {
+      @Override public void data(boolean inFinished, int streamId, BufferedSource source,
+          int length) throws IOException {
+        assertFalse(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(1123, length);
+        ByteString data = source.readByteString(length);
+        for (byte b : data.toByteArray()) {
+          assertEquals(2, b);
+        }
+      }
+    };
+  }
+
+  private static Buffer gzip(byte[] data) throws IOException {
+    Buffer buffer = new Buffer();
+    Okio.buffer(new GzipSink(buffer)).write(data).close();
+    return buffer;
+  }
+
+  /** Create a sufficiently large header set to overflow INITIAL_MAX_FRAME_SIZE bytes. */
+  private static List<Header> largeHeaders() {
+    String[] nameValues = new String[32];
+    char[] chars = new char[512];
+    for (int i = 0; i < nameValues.length; ) {
+      Arrays.fill(chars, (char) i);
+      nameValues[i++] = nameValues[i++] = String.valueOf(chars);
+    }
+    return headerEntries(nameValues);
+  }
+
+  private static void writeMedium(BufferedSink sink, int i) throws IOException {
+    sink.writeByte((i >>> 16) & 0xff);
+    sink.writeByte((i >>> 8) & 0xff);
+    sink.writeByte(i & 0xff);
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
new file mode 100644
index 0000000000..4e9267eae3
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
@@ -0,0 +1,1247 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.Authenticator;
+import java.net.HttpURLConnection;
+import java.net.SocketTimeoutException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.SynchronousQueue;
+import javax.net.ssl.HostnameVerifier;
+import okhttp3.Cache;
+import okhttp3.Call;
+import okhttp3.Callback;
+import okhttp3.Cookie;
+import okhttp3.Credentials;
+import okhttp3.Headers;
+import okhttp3.Interceptor;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.RecordingCookieJar;
+import okhttp3.RecordingHostnameVerifier;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.Route;
+import okhttp3.TestUtil;
+import okhttp3.internal.DoubleInetAddressDns;
+import okhttp3.internal.RecordingOkAuthenticator;
+import okhttp3.internal.SingleInetAddressDns;
+import okhttp3.internal.SocketRecorder;
+import okhttp3.internal.Util;
+import okhttp3.internal.connection.RealConnection;
+import okhttp3.internal.tls.SslClient;
+import okhttp3.mockwebserver.Dispatcher;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.PushPromise;
+import okhttp3.mockwebserver.QueueDispatcher;
+import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.mockwebserver.SocketPolicy;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.GzipSink;
+import okio.Okio;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static okhttp3.TestUtil.defaultClient;
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+/** Test how SPDY interacts with HTTP/2 features. */
+public final class HttpOverHttp2Test {
+  @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private SslClient sslClient = SslClient.localhost();
+  private HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+  private OkHttpClient client;
+  private Cache cache;
+
+  @Before public void setUp() throws Exception {
+    server.useHttps(sslClient.socketFactory, false);
+    cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
+    client = defaultClient().newBuilder()
+        .protocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1))
+        .dns(new SingleInetAddressDns())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(hostnameVerifier)
+        .build();
+  }
+
+  @After public void tearDown() throws Exception {
+    Authenticator.setDefault(null);
+  }
+
+  @Test public void get() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("ABCDE")
+        .setStatus("HTTP/1.1 200 Sweet"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/foo"))
+        .build());
+    Response response = call.execute();
+
+    assertEquals("ABCDE", response.body().string());
+    assertEquals(200, response.code());
+    assertEquals("", response.message());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
+    assertEquals("https", request.getHeader(":scheme"));
+    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(":authority"));
+  }
+
+  @Test public void emptyResponse() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/foo"))
+        .build());
+    Response response = call.execute();
+
+    assertEquals(-1, response.body().byteStream().read());
+    response.body().close();
+  }
+
+  @Test public void noDefaultContentLengthOnStreamingPost() throws Exception {
+    final byte[] postBytes = "FGHIJ".getBytes(Util.UTF_8);
+
+    server.enqueue(new MockResponse().setBody("ABCDE"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/foo"))
+        .post(new RequestBody() {
+          @Override public MediaType contentType() {
+            return MediaType.parse("text/plain; charset=utf-8");
+          }
+
+          @Override public void writeTo(BufferedSink sink) throws IOException {
+            sink.write(postBytes);
+          }
+        })
+        .build());
+
+    Response response = call.execute();
+    assertEquals("ABCDE", response.body().string());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
+    assertArrayEquals(postBytes, request.getBody().readByteArray());
+    assertNull(request.getHeader("Content-Length"));
+  }
+
+  @Test public void userSuppliedContentLengthHeader() throws Exception {
+    final byte[] postBytes = "FGHIJ".getBytes(Util.UTF_8);
+
+    server.enqueue(new MockResponse().setBody("ABCDE"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/foo"))
+        .post(new RequestBody() {
+          @Override public MediaType contentType() {
+            return MediaType.parse("text/plain; charset=utf-8");
+          }
+
+          @Override public long contentLength() throws IOException {
+            return postBytes.length;
+          }
+
+          @Override public void writeTo(BufferedSink sink) throws IOException {
+            sink.write(postBytes);
+          }
+        })
+        .build());
+
+    Response response = call.execute();
+    assertEquals("ABCDE", response.body().string());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
+    assertArrayEquals(postBytes, request.getBody().readByteArray());
+    assertEquals(postBytes.length, Integer.parseInt(request.getHeader("Content-Length")));
+  }
+
+  @Test public void closeAfterFlush() throws Exception {
+    final byte[] postBytes = "FGHIJ".getBytes(Util.UTF_8);
+
+    server.enqueue(new MockResponse().setBody("ABCDE"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/foo"))
+        .post(new RequestBody() {
+          @Override public MediaType contentType() {
+            return MediaType.parse("text/plain; charset=utf-8");
+          }
+
+          @Override public long contentLength() throws IOException {
+            return postBytes.length;
+          }
+
+          @Override public void writeTo(BufferedSink sink) throws IOException {
+            sink.write(postBytes);  // push bytes into the stream's buffer
+            sink.flush(); // Http2Connection.writeData subject to write window
+            sink.close(); // Http2Connection.writeData empty frame
+          }
+        })
+        .build());
+
+    Response response = call.execute();
+    assertEquals("ABCDE", response.body().string());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
+    assertArrayEquals(postBytes, request.getBody().readByteArray());
+    assertEquals(postBytes.length, Integer.parseInt(request.getHeader("Content-Length")));
+  }
+
+  @Test public void connectionReuse() throws Exception {
+    server.enqueue(new MockResponse().setBody("ABCDEF"));
+    server.enqueue(new MockResponse().setBody("GHIJKL"));
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/r1"))
+        .build());
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/r1"))
+        .build());
+    Response response1 = call1.execute();
+    Response response2 = call2.execute();
+
+    assertEquals("ABC", response1.body().source().readUtf8(3));
+    assertEquals("GHI", response2.body().source().readUtf8(3));
+    assertEquals("DEF", response1.body().source().readUtf8(3));
+    assertEquals("JKL", response2.body().source().readUtf8(3));
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+
+    response1.close();
+    response2.close();
+  }
+
+  /** https://github.com/square/okhttp/issues/373 */
+  @Test @Ignore public void synchronousRequest() throws Exception {
+    server.enqueue(new MockResponse().setBody("A"));
+    server.enqueue(new MockResponse().setBody("A"));
+
+    ExecutorService executor = Executors.newCachedThreadPool();
+    CountDownLatch countDownLatch = new CountDownLatch(2);
+    executor.execute(new AsyncRequest("/r1", countDownLatch));
+    executor.execute(new AsyncRequest("/r2", countDownLatch));
+    countDownLatch.await();
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void gzippedResponseBody() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Content-Encoding: gzip")
+        .setBody(gzip("ABCABCABC")));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/r1"))
+        .build());
+
+    Response response = call.execute();
+    assertEquals("ABCABCABC", response.body().string());
+  }
+
+  @Test public void authenticate() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_UNAUTHORIZED)
+        .addHeader("www-authenticate: Basic realm=\"protected area\"")
+        .setBody("Please authenticate."));
+    server.enqueue(new MockResponse()
+        .setBody("Successful auth!"));
+
+    String credential = Credentials.basic("username", "password");
+    client = client.newBuilder()
+        .authenticator(new RecordingOkAuthenticator(credential))
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("Successful auth!", response.body().string());
+
+    RecordedRequest denied = server.takeRequest();
+    assertNull(denied.getHeader("Authorization"));
+    RecordedRequest accepted = server.takeRequest();
+    assertEquals("GET / HTTP/1.1", accepted.getRequestLine());
+    assertEquals(credential, accepted.getHeader("Authorization"));
+  }
+
+  @Test public void redirect() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: /foo")
+        .setBody("This page has moved!"));
+    server.enqueue(new MockResponse().setBody("This is the new location!"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    Response response = call.execute();
+    assertEquals("This is the new location!", response.body().string());
+
+    RecordedRequest request1 = server.takeRequest();
+    assertEquals("/", request1.getPath());
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals("/foo", request2.getPath());
+  }
+
+  @Test public void readAfterLastByte() throws Exception {
+    server.enqueue(new MockResponse().setBody("ABC"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+
+    InputStream in = response.body().byteStream();
+    assertEquals('A', in.read());
+    assertEquals('B', in.read());
+    assertEquals('C', in.read());
+    assertEquals(-1, in.read());
+    assertEquals(-1, in.read());
+
+    in.close();
+  }
+
+  @Test public void readResponseHeaderTimeout() throws Exception {
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.NO_RESPONSE));
+    server.enqueue(new MockResponse().setBody("A"));
+
+    client = client.newBuilder()
+        .readTimeout(1000, MILLISECONDS)
+        .build();
+
+    // Make a call expecting a timeout reading the response headers.
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    try {
+      call1.execute();
+      fail("Should have timed out!");
+    } catch (SocketTimeoutException expected) {
+      assertEquals("timeout", expected.getMessage());
+    }
+
+    // Confirm that a subsequent request on the same connection is not impacted.
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("A", response2.body().string());
+
+    // Confirm that the connection was reused.
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
+  /**
+   * Test to ensure we don't  throw a read timeout on responses that are progressing.  For this
+   * case, we take a 4KiB body and throttle it to 1KiB/second.  We set the read timeout to two
+   * seconds.  If our implementation is acting correctly, it will not throw, as it is progressing.
+   */
+  @Test public void readTimeoutMoreGranularThanBodySize() throws Exception {
+    char[] body = new char[4096]; // 4KiB to read.
+    Arrays.fill(body, 'y');
+    server.enqueue(new MockResponse().setBody(new String(body))
+        .throttleBody(1024, 1, SECONDS)); // Slow connection 1KiB/second.
+
+    client = client.newBuilder()
+        .readTimeout(2, SECONDS)
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    Response response = call.execute();
+    assertEquals(new String(body), response.body().string());
+  }
+
+  /**
+   * Test to ensure we throw a read timeout on responses that are progressing too slowly.  For this
+   * case, we take a 2KiB body and throttle it to 1KiB/second.  We set the read timeout to half a
+   * second.  If our implementation is acting correctly, it will throw, as a byte doesn't arrive in
+   * time.
+   */
+  @Test public void readTimeoutOnSlowConnection() throws Exception {
+    String body = TestUtil.repeat('y', 2048);
+    server.enqueue(new MockResponse()
+        .setBody(body)
+        .throttleBody(1024, 1, SECONDS)); // Slow connection 1KiB/second.
+    server.enqueue(new MockResponse()
+        .setBody(body));
+
+    client = client.newBuilder()
+        .readTimeout(500, MILLISECONDS) // Half a second to read something.
+        .build();
+
+    // Make a call expecting a timeout reading the response body.
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+    try {
+      response1.body().string();
+      fail("Should have timed out!");
+    } catch (SocketTimeoutException expected) {
+      assertEquals("timeout", expected.getMessage());
+    }
+
+    // Confirm that a subsequent request on the same connection is not impacted.
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals(body, response2.body().string());
+
+    // Confirm that the connection was reused.
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void connectionTimeout() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .setBodyDelay(1, SECONDS));
+
+    OkHttpClient client1 = client.newBuilder()
+        .readTimeout(2000, MILLISECONDS)
+        .build();
+    Call call1 = client1
+        .newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    OkHttpClient client2 = client.newBuilder()
+        .readTimeout(200, MILLISECONDS)
+        .build();
+    Call call2 = client2
+        .newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    Response response1 = call1.execute();
+    assertEquals("A", response1.body().string());
+
+    try {
+      call2.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    // Confirm that the connection was reused.
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void responsesAreCached() throws IOException {
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    server.enqueue(new MockResponse()
+        .addHeader("cache-control: max-age=60")
+        .setBody("A"));
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+
+    assertEquals("A", response1.body().string());
+    assertEquals(1, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("A", response2.body().string());
+
+    Call call3 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response3 = call3.execute();
+    assertEquals("A", response3.body().string());
+
+    assertEquals(3, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(2, cache.hitCount());
+  }
+
+  @Test public void conditionalCache() throws IOException {
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    server.enqueue(new MockResponse()
+        .addHeader("ETag: v1")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+    assertEquals("A", response1.body().string());
+
+    assertEquals(1, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("A", response2.body().string());
+
+    assertEquals(2, cache.requestCount());
+    assertEquals(2, cache.networkCount());
+    assertEquals(1, cache.hitCount());
+  }
+
+  @Test public void responseCachedWithoutConsumingFullBody() throws IOException {
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    server.enqueue(new MockResponse()
+        .addHeader("cache-control: max-age=60")
+        .setBody("ABCD"));
+    server.enqueue(new MockResponse()
+        .addHeader("cache-control: max-age=60")
+        .setBody("EFGH"));
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+    assertEquals("AB", response1.body().source().readUtf8(2));
+    response1.body().close();
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("ABCD", response2.body().source().readUtf8());
+    response2.body().close();
+  }
+
+  @Test public void sendRequestCookies() throws Exception {
+    RecordingCookieJar cookieJar = new RecordingCookieJar();
+    Cookie requestCookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .domain(server.getHostName())
+        .build();
+    cookieJar.enqueueRequestCookies(requestCookie);
+    client = client.newBuilder()
+        .cookieJar(cookieJar)
+        .build();
+
+    server.enqueue(new MockResponse());
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("", response.body().string());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("a=b", request.getHeader("Cookie"));
+  }
+
+  @Test public void receiveResponseCookies() throws Exception {
+    RecordingCookieJar cookieJar = new RecordingCookieJar();
+    client = client.newBuilder()
+        .cookieJar(cookieJar)
+        .build();
+
+    server.enqueue(new MockResponse()
+        .addHeader("set-cookie: a=b"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("", response.body().string());
+
+    cookieJar.assertResponseCookies("a=b; path=/");
+  }
+
+  /** https://github.com/square/okhttp/issues/1191 */
+  @Ignore // TODO: recover gracefully when a connection is shutdown.
+  @Test public void cancelWithStreamNotCompleted() throws Exception {
+    // Ensure that the (shared) connection pool is in a consistent state.
+    client.connectionPool().evictAll();
+    assertEquals(0, client.connectionPool().connectionCount());
+
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+    server.enqueue(new MockResponse()
+        .setBody("def"));
+
+    // Disconnect before the stream is created. A connection is still established!
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call1.execute();
+    call1.cancel();
+
+    // That connection is pooled, and it works.
+    assertEquals(1, client.connectionPool().connectionCount());
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("def", response2.body().string());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+
+    // Clean up the connection.
+    response.close();
+  }
+
+  @Test public void recoverFromOneRefusedStreamReusesConnection() throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
+        .setHttp2ErrorCode(ErrorCode.REFUSED_STREAM.httpCode));
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("abc", response.body().string());
+
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    assertEquals(1, server.takeRequest().getSequenceNumber()); // Reused connection.
+  }
+
+  @Test public void recoverFromOneInternalErrorRequiresNewConnection() throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
+        .setHttp2ErrorCode(ErrorCode.INTERNAL_ERROR.httpCode));
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    client = client.newBuilder()
+        .dns(new DoubleInetAddressDns())
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("abc", response.body().string());
+
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+  }
+
+  @Test public void recoverFromMultipleRefusedStreamsRequiresNewConnection() throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
+        .setHttp2ErrorCode(ErrorCode.REFUSED_STREAM.httpCode));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
+        .setHttp2ErrorCode(ErrorCode.REFUSED_STREAM.httpCode));
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    client = client.newBuilder()
+        .dns(new DoubleInetAddressDns())
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("abc", response.body().string());
+
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    assertEquals(1, server.takeRequest().getSequenceNumber()); // Reused connection.
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+  }
+
+  @Test public void noRecoveryFromRefusedStreamWithRetryDisabled() throws Exception {
+    noRecoveryFromErrorWithRetryDisabled(ErrorCode.REFUSED_STREAM);
+  }
+
+  @Test public void noRecoveryFromInternalErrorWithRetryDisabled() throws Exception {
+    noRecoveryFromErrorWithRetryDisabled(ErrorCode.INTERNAL_ERROR);
+  }
+
+  private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
+        .setHttp2ErrorCode(errorCode.httpCode));
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    client = client.newBuilder()
+        .retryOnConnectionFailure(false)
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (StreamResetException expected) {
+      assertEquals(errorCode, expected.errorCode);
+    }
+  }
+
+  @Test public void recoverFromConnectionNoNewStreamsOnFollowUp() throws InterruptedException {
+    server.enqueue(new MockResponse()
+        .setResponseCode(401));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
+        .setHttp2ErrorCode(ErrorCode.CANCEL.httpCode));
+    server.enqueue(new MockResponse()
+        .setBody("DEF"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location", "/foo"));
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final BlockingQueue<String> responses = new SynchronousQueue<>();
+    okhttp3.Authenticator authenticator = new okhttp3.Authenticator() {
+      @Override public Request authenticate(Route route, Response response) throws IOException {
+        responses.offer(response.body().string());
+        try {
+          latch.await();
+        } catch (InterruptedException e) {
+          throw new AssertionError();
+        }
+        return response.request();
+      }
+    };
+
+    OkHttpClient blockingAuthClient = client.newBuilder()
+        .authenticator(authenticator)
+        .build();
+
+    Callback callback = new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+        fail();
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        responses.offer(response.body().string());
+      }
+    };
+
+    // Make the first request waiting until we get our auth challenge.
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    blockingAuthClient.newCall(request).enqueue(callback);
+    String response1 = responses.take();
+    assertEquals("", response1);
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+
+    // Now make the second request which will restrict the first HTTP/2 connection from creating new
+    // streams.
+    client.newCall(request).enqueue(callback);
+    String response2 = responses.take();
+    assertEquals("DEF", response2);
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+
+    // Let the first request proceed. It should discard the the held HTTP/2 connection and get a new
+    // one.
+    latch.countDown();
+    String response3 = responses.take();
+    assertEquals("ABC", response3);
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertEquals(2, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void nonAsciiResponseHeader() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeaderLenient("Alpha", "α")
+        .addHeaderLenient("β", "Beta"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    response.close();
+
+    assertEquals("α", response.header("Alpha"));
+    assertEquals("Beta", response.header("β"));
+  }
+
+  @Test public void serverSendsPushPromise_GET() throws Exception {
+    PushPromise pushPromise = new PushPromise("GET", "/foo/bar", Headers.of("foo", "bar"),
+        new MockResponse().setBody("bar").setStatus("HTTP/1.1 200 Sweet"));
+    server.enqueue(new MockResponse()
+        .setBody("ABCDE")
+        .setStatus("HTTP/1.1 200 Sweet")
+        .withPush(pushPromise));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/foo"))
+        .build());
+    Response response = call.execute();
+
+    assertEquals("ABCDE", response.body().string());
+    assertEquals(200, response.code());
+    assertEquals("", response.message());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
+    assertEquals("https", request.getHeader(":scheme"));
+    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(":authority"));
+
+    RecordedRequest pushedRequest = server.takeRequest();
+    assertEquals("GET /foo/bar HTTP/1.1", pushedRequest.getRequestLine());
+    assertEquals("bar", pushedRequest.getHeader("foo"));
+  }
+
+  @Test public void serverSendsPushPromise_HEAD() throws Exception {
+    PushPromise pushPromise = new PushPromise("HEAD", "/foo/bar", Headers.of("foo", "bar"),
+        new MockResponse().setStatus("HTTP/1.1 204 Sweet"));
+    server.enqueue(new MockResponse()
+        .setBody("ABCDE")
+        .setStatus("HTTP/1.1 200 Sweet")
+        .withPush(pushPromise));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/foo"))
+        .build());
+    Response response = call.execute();
+    assertEquals("ABCDE", response.body().string());
+    assertEquals(200, response.code());
+    assertEquals("", response.message());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
+    assertEquals("https", request.getHeader(":scheme"));
+    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(":authority"));
+
+    RecordedRequest pushedRequest = server.takeRequest();
+    assertEquals("HEAD /foo/bar HTTP/1.1", pushedRequest.getRequestLine());
+    assertEquals("bar", pushedRequest.getHeader("foo"));
+  }
+
+  @Test public void noDataFramesSentWithNullRequestBody() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+
+    SocketRecorder socketRecorder = new SocketRecorder();
+    client = client.newBuilder()
+        .sslSocketFactory(socketRecorder.sslSocketFactory(sslClient.socketFactory),
+            sslClient.trustManager)
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .method("DELETE", null)
+        .build());
+    Response response = call.execute();
+    assertEquals("ABC", response.body().string());
+
+    // Replay the bytes written by the client to confirm no data frames were sent.
+    SocketRecorder.RecordedSocket recordedSocket = socketRecorder.takeSocket();
+    Buffer buffer = new Buffer();
+    buffer.write(recordedSocket.bytesWritten());
+
+    RecordingHandler handler = new RecordingHandler();
+    Http2Reader reader = new Http2Reader(buffer, false);
+    reader.readConnectionPreface(null);
+    while (reader.nextFrame(false, handler)) {
+    }
+
+    assertEquals(1, handler.headerFrameCount);
+    assertTrue(handler.dataFrames.isEmpty());
+  }
+
+  @Test public void emptyDataFrameSentWithEmptyBody() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+
+    SocketRecorder socketRecorder = new SocketRecorder();
+    client = client.newBuilder()
+        .sslSocketFactory(socketRecorder.sslSocketFactory(sslClient.socketFactory),
+            sslClient.trustManager)
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .method("DELETE", Util.EMPTY_REQUEST)
+        .build());
+    Response response = call.execute();
+    assertEquals("ABC", response.body().string());
+
+    // Replay the bytes written by the client to confirm an empty data frame was sent.
+    SocketRecorder.RecordedSocket recordedSocket = socketRecorder.takeSocket();
+    Buffer buffer = new Buffer();
+    buffer.write(recordedSocket.bytesWritten());
+
+    RecordingHandler handler = new RecordingHandler();
+    Http2Reader reader = new Http2Reader(buffer, false);
+    reader.readConnectionPreface(null);
+    while (reader.nextFrame(false, handler)) {
+    }
+
+    assertEquals(1, handler.headerFrameCount);
+    assertEquals(Collections.singletonList(0), handler.dataFrames);
+  }
+
+  /**
+   * Push a setting that permits up to 2 concurrent streams, then make 3 concurrent requests and
+   * confirm that the third concurrent request prepared a new connection.
+   */
+  @Test public void settingsLimitsMaxConcurrentStreams() throws Exception {
+    Settings settings = new Settings();
+    settings.set(Settings.MAX_CONCURRENT_STREAMS, 2);
+
+    // Read & write a full request to confirm settings are accepted.
+    server.enqueue(new MockResponse().withSettings(settings));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("", response.body().string());
+
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+    server.enqueue(new MockResponse()
+        .setBody("DEF"));
+    server.enqueue(new MockResponse()
+        .setBody("GHI"));
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+
+    Call call3 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response3 = call3.execute();
+
+    assertEquals("ABC", response1.body().string());
+    assertEquals("DEF", response2.body().string());
+    assertEquals("GHI", response3.body().string());
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // Settings connection.
+    assertEquals(1, server.takeRequest().getSequenceNumber()); // Reuse settings connection.
+    assertEquals(2, server.takeRequest().getSequenceNumber()); // Reuse settings connection.
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection!
+  }
+
+  @Test public void connectionNotReusedAfterShutdown() throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setBody("ABC"));
+    server.enqueue(new MockResponse()
+        .setBody("DEF"));
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+    assertEquals("ABC", response1.body().string());
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("DEF", response2.body().string());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+  }
+
+  /**
+   * This simulates a race condition where we receive a healthy HTTP/2 connection and just prior to
+   * writing our request, we get a GOAWAY frame from the server.
+   */
+  @Test public void connectionShutdownAfterHealthCheck() throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setBody("ABC"));
+    server.enqueue(new MockResponse()
+        .setBody("DEF"));
+
+    OkHttpClient client2 = client.newBuilder()
+        .addNetworkInterceptor(new Interceptor() {
+          boolean executedCall;
+
+          @Override public Response intercept(Chain chain) throws IOException {
+            if (!executedCall) {
+              // At this point, we have a healthy HTTP/2 connection. This call will trigger the
+              // server to send a GOAWAY frame, leaving the connection in a shutdown state.
+              executedCall = true;
+              Call call = client.newCall(new Request.Builder()
+                  .url(server.url("/"))
+                  .build());
+              Response response = call.execute();
+              assertEquals("ABC", response.body().string());
+              // Wait until the GOAWAY has been processed.
+              RealConnection connection = (RealConnection) chain.connection();
+              while (connection.isHealthy(false)) ;
+            }
+            return chain.proceed(chain.request());
+          }
+        })
+        .build();
+
+    Call call = client2.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("DEF", response.body().string());
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void responseHeadersAfterGoaway() throws Exception {
+    server.enqueue(new MockResponse()
+        .setHeadersDelay(1, SECONDS)
+        .setBody("ABC"));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setBody("DEF"));
+
+    final BlockingQueue<String> bodies = new SynchronousQueue<>();
+    Callback callback = new Callback() {
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        bodies.add(response.body().string());
+      }
+      @Override public void onFailure(Call call, IOException e) {
+        System.out.println(e);
+      }
+    };
+    client.newCall(new Request.Builder().url(server.url("/")).build()).enqueue(callback);
+    client.newCall(new Request.Builder().url(server.url("/")).build()).enqueue(callback);
+
+    assertEquals("DEF", bodies.poll(2, SECONDS));
+    assertEquals("ABC", bodies.poll(2, SECONDS));
+    assertEquals(2, server.getRequestCount());
+  }
+
+  /**
+   * We don't know if the connection will support HTTP/2 until after we've connected. When multiple
+   * connections are requested concurrently OkHttp will pessimistically connect multiple times, then
+   * close any unnecessary connections. This test confirms that behavior works as intended.
+   *
+   * <p>This test uses proxy tunnels to get a hook while a connection is being established.
+   */
+  @Test public void concurrentHttp2ConnectionsDeduplicated() throws Exception {
+    server.useHttps(sslClient.socketFactory, true);
+
+    // Force a fresh connection pool for the test.
+    client.connectionPool().evictAll();
+
+    final QueueDispatcher queueDispatcher = new QueueDispatcher();
+    queueDispatcher.enqueueResponse(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    queueDispatcher.enqueueResponse(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    queueDispatcher.enqueueResponse(new MockResponse()
+        .setBody("call2 response"));
+    queueDispatcher.enqueueResponse(new MockResponse()
+        .setBody("call1 response"));
+
+    // We use a re-entrant dispatcher to initiate one HTTPS connection while the other is in flight.
+    server.setDispatcher(new Dispatcher() {
+      int requestCount;
+
+      @Override public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
+        MockResponse result = queueDispatcher.dispatch(request);
+
+        requestCount++;
+        if (requestCount == 1) {
+          // Before handling call1's CONNECT we do all of call2. This part re-entrant!
+          try {
+            Call call2 = client.newCall(new Request.Builder()
+                .url("https://android.com/call2")
+                .build());
+            Response response2 = call2.execute();
+            assertEquals("call2 response", response2.body().string());
+          } catch (IOException e) {
+            throw new RuntimeException(e);
+          }
+        }
+
+        return result;
+      }
+
+      @Override public MockResponse peek() {
+        return queueDispatcher.peek();
+      }
+
+      @Override public void shutdown() {
+        queueDispatcher.shutdown();
+      }
+    });
+
+    client = client.newBuilder()
+        .proxy(server.toProxyAddress())
+        .build();
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url("https://android.com/call1")
+        .build());
+    Response response2 = call1.execute();
+    assertEquals("call1 response", response2.body().string());
+
+    RecordedRequest call1Connect = server.takeRequest();
+    assertEquals("CONNECT", call1Connect.getMethod());
+    assertEquals(0, call1Connect.getSequenceNumber());
+
+    RecordedRequest call2Connect = server.takeRequest();
+    assertEquals("CONNECT", call2Connect.getMethod());
+    assertEquals(0, call2Connect.getSequenceNumber());
+
+    RecordedRequest call2Get = server.takeRequest();
+    assertEquals("GET", call2Get.getMethod());
+    assertEquals("/call2", call2Get.getPath());
+    assertEquals(0, call2Get.getSequenceNumber());
+
+    RecordedRequest call1Get = server.takeRequest();
+    assertEquals("GET", call1Get.getMethod());
+    assertEquals("/call1", call1Get.getPath());
+    assertEquals(1, call1Get.getSequenceNumber());
+
+    assertEquals(1, client.connectionPool().connectionCount());
+  }
+
+  /** https://github.com/square/okhttp/issues/3103 */
+  @Test public void domainFronting() throws Exception {
+    client = client.newBuilder()
+        .addNetworkInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            Request request = chain.request().newBuilder()
+                .header("Host", "privateobject.com")
+                .build();
+            return chain.proceed(request);
+          }
+        })
+        .build();
+
+    server.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    Response response = call.execute();
+    assertEquals("", response.body().string());
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("privateobject.com", recordedRequest.getHeader(":authority"));
+  }
+
+  public Buffer gzip(String bytes) throws IOException {
+    Buffer bytesOut = new Buffer();
+    BufferedSink sink = Okio.buffer(new GzipSink(bytesOut));
+    sink.writeUtf8(bytes);
+    sink.close();
+    return bytesOut;
+  }
+
+  class AsyncRequest implements Runnable {
+    String path;
+    CountDownLatch countDownLatch;
+
+    public AsyncRequest(String path, CountDownLatch countDownLatch) {
+      this.path = path;
+      this.countDownLatch = countDownLatch;
+    }
+
+    @Override public void run() {
+      try {
+        Call call = client.newCall(new Request.Builder()
+            .url(server.url(path))
+            .build());
+        Response response = call.execute();
+        assertEquals("A", response.body().string());
+        countDownLatch.countDown();
+      } catch (Exception e) {
+        throw new RuntimeException(e);
+      }
+    }
+  }
+
+  static final class RecordingHandler extends BaseTestHandler {
+    int headerFrameCount;
+    final List<Integer> dataFrames = new ArrayList<>();
+
+    @Override public void settings(boolean clearPrevious, Settings settings) {
+    }
+
+    @Override public void ackSettings() {
+    }
+
+    @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
+    }
+
+    @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
+        throws IOException {
+      dataFrames.add(length);
+    }
+
+    @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,
+        List<Header> headerBlock) {
+      headerFrameCount++;
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/HuffmanTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/HuffmanTest.java
new file mode 100644
index 0000000000..53642c0ea0
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/HuffmanTest.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright 2013 Twitter, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Random;
+import okio.Buffer;
+import okio.ByteString;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+/** Original version of this class was lifted from {@code com.twitter.hpack.HuffmanTest}. */
+public final class HuffmanTest {
+  @Test public void roundTripForRequestAndResponse() throws IOException {
+    String s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
+    for (int i = 0; i < s.length(); i++) {
+      assertRoundTrip(ByteString.encodeUtf8(s.substring(0, i)));
+    }
+
+    Random random = new Random(123456789L);
+    byte[] buf = new byte[4096];
+    random.nextBytes(buf);
+    assertRoundTrip(ByteString.of(buf));
+  }
+
+  private void assertRoundTrip(ByteString data) throws IOException {
+    Buffer buffer = new Buffer();
+    Huffman.get().encode(data, buffer);
+    assertEquals(buffer.size(), Huffman.get().encodedLength(data));
+
+    byte[] decodedBytes = Huffman.get().decode(buffer.readByteArray());
+    assertTrue(Arrays.equals(data.toByteArray(), decodedBytes));
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
new file mode 100644
index 0000000000..fe5f82fd4a
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
@@ -0,0 +1,309 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package okhttp3.internal.http2;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.InetSocketAddress;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.logging.Logger;
+import okhttp3.internal.Util;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.Okio;
+
+/** Replays prerecorded outgoing frames and records incoming frames. */
+public final class MockHttp2Peer implements Closeable {
+  private static final Logger logger = Logger.getLogger(MockHttp2Peer.class.getName());
+
+  private int frameCount = 0;
+  private boolean client = false;
+  private final Buffer bytesOut = new Buffer();
+  private Http2Writer writer = new Http2Writer(bytesOut, client);
+  private final List<OutFrame> outFrames = new ArrayList<>();
+  private final BlockingQueue<InFrame> inFrames = new LinkedBlockingQueue<>();
+  private int port;
+  private final ExecutorService executor = Executors.newSingleThreadExecutor(
+      Util.threadFactory("MockHttp2Peer", false));
+  private ServerSocket serverSocket;
+  private Socket socket;
+
+  public void setClient(boolean client) {
+    if (this.client == client) {
+      return;
+    }
+    this.client = client;
+    this.writer = new Http2Writer(bytesOut, client);
+  }
+
+  public void acceptFrame() {
+    frameCount++;
+  }
+
+  /** Maximum length of an outbound data frame. */
+  public int maxOutboundDataLength() {
+    return writer.maxDataLength();
+  }
+
+  /** Count of frames sent or received. */
+  public int frameCount() {
+    return frameCount;
+  }
+
+  public Http2Writer sendFrame() {
+    outFrames.add(new OutFrame(frameCount++, bytesOut.size(), false));
+    return writer;
+  }
+
+  /**
+   * Shortens the last frame from its original length to {@code length}. This will cause the peer to
+   * close the socket as soon as this frame has been written; otherwise the peer stays open until
+   * explicitly closed.
+   */
+  public Http2Writer truncateLastFrame(int length) {
+    OutFrame lastFrame = outFrames.remove(outFrames.size() - 1);
+    if (length >= bytesOut.size() - lastFrame.start) throw new IllegalArgumentException();
+
+    // Move everything from bytesOut into a new buffer.
+    Buffer fullBuffer = new Buffer();
+    bytesOut.read(fullBuffer, bytesOut.size());
+
+    // Copy back all but what we're truncating.
+    fullBuffer.read(bytesOut, lastFrame.start + length);
+
+    outFrames.add(new OutFrame(lastFrame.sequence, lastFrame.start, true));
+    return writer;
+  }
+
+  public InFrame takeFrame() throws InterruptedException {
+    return inFrames.take();
+  }
+
+  public void play() throws IOException {
+    if (serverSocket != null) throw new IllegalStateException();
+    serverSocket = new ServerSocket();
+    serverSocket.setReuseAddress(false);
+    serverSocket.bind(new InetSocketAddress("localhost", 0), 1);
+    port = serverSocket.getLocalPort();
+    executor.execute(new Runnable() {
+      @Override public void run() {
+        try {
+          readAndWriteFrames();
+        } catch (IOException e) {
+          Util.closeQuietly(MockHttp2Peer.this);
+          logger.info(MockHttp2Peer.this + " done: " + e.getMessage());
+        }
+      }
+    });
+  }
+
+  private void readAndWriteFrames() throws IOException {
+    if (socket != null) throw new IllegalStateException();
+    socket = serverSocket.accept();
+
+    // Bail out now if this instance was closed while waiting for the socket to accept.
+    synchronized (this) {
+      if (executor.isShutdown()) {
+        socket.close();
+        return;
+      }
+    }
+
+    OutputStream out = socket.getOutputStream();
+    InputStream in = socket.getInputStream();
+    Http2Reader reader = new Http2Reader(Okio.buffer(Okio.source(in)), client);
+
+    Iterator<OutFrame> outFramesIterator = outFrames.iterator();
+    byte[] outBytes = bytesOut.readByteArray();
+    OutFrame nextOutFrame = null;
+
+    for (int i = 0; i < frameCount; i++) {
+      if (nextOutFrame == null && outFramesIterator.hasNext()) {
+        nextOutFrame = outFramesIterator.next();
+      }
+
+      if (nextOutFrame != null && nextOutFrame.sequence == i) {
+        long start = nextOutFrame.start;
+        boolean truncated;
+        long end;
+        if (outFramesIterator.hasNext()) {
+          nextOutFrame = outFramesIterator.next();
+          end = nextOutFrame.start;
+          truncated = false;
+        } else {
+          end = outBytes.length;
+          truncated = nextOutFrame.truncated;
+        }
+
+        // Write a frame.
+        int length = (int) (end - start);
+        out.write(outBytes, (int) start, length);
+
+        // If the last frame was truncated, immediately close the connection.
+        if (truncated) {
+          socket.close();
+        }
+      } else {
+        // read a frame
+        InFrame inFrame = new InFrame(i, reader);
+        reader.nextFrame(false, inFrame);
+        inFrames.add(inFrame);
+      }
+    }
+  }
+
+  public Socket openSocket() throws IOException {
+    return new Socket("localhost", port);
+  }
+
+  @Override public synchronized void close() throws IOException {
+    executor.shutdown();
+    Util.closeQuietly(socket);
+    Util.closeQuietly(serverSocket);
+  }
+
+  @Override public String toString() {
+    return "MockHttp2Peer[" + port + "]";
+  }
+
+  private static class OutFrame {
+    private final int sequence;
+    private final long start;
+    private final boolean truncated;
+
+    private OutFrame(int sequence, long start, boolean truncated) {
+      this.sequence = sequence;
+      this.start = start;
+      this.truncated = truncated;
+    }
+  }
+
+  public static class InFrame implements Http2Reader.Handler {
+    public final int sequence;
+    public final Http2Reader reader;
+    public int type = -1;
+    public boolean clearPrevious;
+    public boolean outFinished;
+    public boolean inFinished;
+    public int streamId;
+    public int associatedStreamId;
+    public ErrorCode errorCode;
+    public long windowSizeIncrement;
+    public List<Header> headerBlock;
+    public byte[] data;
+    public Settings settings;
+    public boolean ack;
+    public int payload1;
+    public int payload2;
+
+    public InFrame(int sequence, Http2Reader reader) {
+      this.sequence = sequence;
+      this.reader = reader;
+    }
+
+    @Override public void settings(boolean clearPrevious, Settings settings) {
+      if (this.type != -1) throw new IllegalStateException();
+      this.type = Http2.TYPE_SETTINGS;
+      this.clearPrevious = clearPrevious;
+      this.settings = settings;
+    }
+
+    @Override public void ackSettings() {
+      if (this.type != -1) throw new IllegalStateException();
+      this.type = Http2.TYPE_SETTINGS;
+      this.ack = true;
+    }
+
+    @Override public void headers(boolean inFinished, int streamId,
+        int associatedStreamId, List<Header> headerBlock) {
+      if (this.type != -1) throw new IllegalStateException();
+      this.type = Http2.TYPE_HEADERS;
+      this.inFinished = inFinished;
+      this.streamId = streamId;
+      this.associatedStreamId = associatedStreamId;
+      this.headerBlock = headerBlock;
+    }
+
+    @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
+        throws IOException {
+      if (this.type != -1) throw new IllegalStateException();
+      this.type = Http2.TYPE_DATA;
+      this.inFinished = inFinished;
+      this.streamId = streamId;
+      this.data = source.readByteString(length).toByteArray();
+    }
+
+    @Override public void rstStream(int streamId, ErrorCode errorCode) {
+      if (this.type != -1) throw new IllegalStateException();
+      this.type = Http2.TYPE_RST_STREAM;
+      this.streamId = streamId;
+      this.errorCode = errorCode;
+    }
+
+    @Override public void ping(boolean ack, int payload1, int payload2) {
+      if (this.type != -1) throw new IllegalStateException();
+      this.type = Http2.TYPE_PING;
+      this.ack = ack;
+      this.payload1 = payload1;
+      this.payload2 = payload2;
+    }
+
+    @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
+      if (this.type != -1) throw new IllegalStateException();
+      this.type = Http2.TYPE_GOAWAY;
+      this.streamId = lastGoodStreamId;
+      this.errorCode = errorCode;
+      this.data = debugData.toByteArray();
+    }
+
+    @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
+      if (this.type != -1) throw new IllegalStateException();
+      this.type = Http2.TYPE_WINDOW_UPDATE;
+      this.streamId = streamId;
+      this.windowSizeIncrement = windowSizeIncrement;
+    }
+
+    @Override public void priority(int streamId, int streamDependency, int weight,
+        boolean exclusive) {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void pushPromise(int streamId, int associatedStreamId, List<Header> headerBlock) {
+      this.type = Http2.TYPE_PUSH_PROMISE;
+      this.streamId = streamId;
+      this.associatedStreamId = associatedStreamId;
+      this.headerBlock = headerBlock;
+    }
+
+    @Override public void alternateService(int streamId, String origin, ByteString protocol,
+        String host, int port, long maxAge) {
+      throw new UnsupportedOperationException();
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/SettingsTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/SettingsTest.java
new file mode 100644
index 0000000000..a26506ca27
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/SettingsTest.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import org.junit.Test;
+
+import static okhttp3.internal.http2.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
+import static okhttp3.internal.http2.Settings.MAX_CONCURRENT_STREAMS;
+import static org.junit.Assert.assertEquals;
+
+public final class SettingsTest {
+  @Test public void unsetField() {
+    Settings settings = new Settings();
+    assertEquals(-3, settings.getMaxConcurrentStreams(-3));
+  }
+
+  @Test public void setFields() {
+    Settings settings = new Settings();
+
+    settings.set(Settings.HEADER_TABLE_SIZE, 8096);
+    assertEquals(8096, settings.getHeaderTableSize());
+
+    assertEquals(true, settings.getEnablePush(true));
+    settings.set(Settings.ENABLE_PUSH, 1);
+    assertEquals(true, settings.getEnablePush(false));
+    settings.clear();
+
+    assertEquals(-3, settings.getMaxConcurrentStreams(-3));
+    settings.set(MAX_CONCURRENT_STREAMS, 75);
+    assertEquals(75, settings.getMaxConcurrentStreams(-3));
+
+    settings.clear();
+    assertEquals(16384, settings.getMaxFrameSize(16384));
+    settings.set(Settings.MAX_FRAME_SIZE, 16777215);
+    assertEquals(16777215, settings.getMaxFrameSize(16384));
+
+    assertEquals(-1, settings.getMaxHeaderListSize(-1));
+    settings.set(Settings.MAX_HEADER_LIST_SIZE, 16777215);
+    assertEquals(16777215, settings.getMaxHeaderListSize(-1));
+
+    assertEquals(DEFAULT_INITIAL_WINDOW_SIZE,
+        settings.getInitialWindowSize());
+    settings.set(Settings.INITIAL_WINDOW_SIZE, 108);
+    assertEquals(108, settings.getInitialWindowSize());
+  }
+
+  @Test public void merge() {
+    Settings a = new Settings();
+    a.set(Settings.HEADER_TABLE_SIZE, 10000);
+    a.set(Settings.MAX_HEADER_LIST_SIZE, 20000);
+    a.set(Settings.INITIAL_WINDOW_SIZE, 30000);
+
+    Settings b = new Settings();
+    b.set(Settings.MAX_HEADER_LIST_SIZE, 40000);
+    b.set(Settings.INITIAL_WINDOW_SIZE, 50000);
+    b.set(Settings.MAX_CONCURRENT_STREAMS, 60000);
+
+    a.merge(b);
+    assertEquals(10000, a.getHeaderTableSize());
+    assertEquals(40000, a.getMaxHeaderListSize(-1));
+    assertEquals(50000, a.getInitialWindowSize());
+    assertEquals(60000, a.getMaxConcurrentStreams(-1));
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/io/FaultyFileSystem.java b/okhttp-tests/src/test/java/okhttp3/internal/io/FaultyFileSystem.java
new file mode 100644
index 0000000000..bc0263d830
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/io/FaultyFileSystem.java
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.io;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.util.LinkedHashSet;
+import java.util.Set;
+import okio.Buffer;
+import okio.ForwardingSink;
+import okio.Sink;
+import okio.Source;
+
+public final class FaultyFileSystem implements FileSystem {
+  private final FileSystem delegate;
+  private final Set<File> writeFaults = new LinkedHashSet<>();
+  private final Set<File> deleteFaults = new LinkedHashSet<>();
+  private final Set<File> renameFaults = new LinkedHashSet<>();
+
+  public FaultyFileSystem(FileSystem delegate) {
+    this.delegate = delegate;
+  }
+
+  public void setFaultyWrite(File file, boolean faulty) {
+    if (faulty) {
+      writeFaults.add(file);
+    } else {
+      writeFaults.remove(file);
+    }
+  }
+
+  public void setFaultyDelete(File file, boolean faulty) {
+    if (faulty) {
+      deleteFaults.add(file);
+    } else {
+      deleteFaults.remove(file);
+    }
+  }
+
+  public void setFaultyRename(File file, boolean faulty) {
+    if (faulty) {
+      renameFaults.add(file);
+    } else {
+      renameFaults.remove(file);
+    }
+  }
+
+  @Override public Source source(File file) throws FileNotFoundException {
+    return delegate.source(file);
+  }
+
+  @Override public Sink sink(File file) throws FileNotFoundException {
+    return new FaultySink(delegate.sink(file), file);
+  }
+
+  @Override public Sink appendingSink(File file) throws FileNotFoundException {
+    return new FaultySink(delegate.appendingSink(file), file);
+  }
+
+  @Override public void delete(File file) throws IOException {
+    if (deleteFaults.contains(file)) throw new IOException("boom!");
+    delegate.delete(file);
+  }
+
+  @Override public boolean exists(File file) {
+    return delegate.exists(file);
+  }
+
+  @Override public long size(File file) {
+    return delegate.size(file);
+  }
+
+  @Override public void rename(File from, File to) throws IOException {
+    if (renameFaults.contains(from) || renameFaults.contains(to)) throw new IOException("boom!");
+    delegate.rename(from, to);
+  }
+
+  @Override public void deleteContents(File directory) throws IOException {
+    if (deleteFaults.contains(directory)) throw new IOException("boom!");
+    delegate.deleteContents(directory);
+  }
+
+  private class FaultySink extends ForwardingSink {
+    private final File file;
+
+    public FaultySink(Sink delegate, File file) {
+      super(delegate);
+      this.file = file;
+    }
+
+    @Override public void write(Buffer source, long byteCount) throws IOException {
+      if (writeFaults.contains(file)) throw new IOException("boom!");
+      super.write(source, byteCount);
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java b/okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java
new file mode 100644
index 0000000000..ada8f78969
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform;
+
+import org.junit.Test;
+
+import static okhttp3.internal.platform.PlatformTest.getPlatform;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assume.assumeTrue;
+
+public class Jdk9PlatformTest {
+  @Test
+  public void buildsWhenJdk9() {
+    assumeTrue(getPlatform().equals("jdk9"));
+
+    assertNotNull(Jdk9Platform.buildIfSupported());
+  }
+
+  @Test
+  public void findsAlpnMethods() {
+    assumeTrue(getPlatform().equals("jdk9"));
+
+    Jdk9Platform platform = Jdk9Platform.buildIfSupported();
+
+    assertEquals("getApplicationProtocol", platform.getProtocolMethod.getName());
+    assertEquals("setApplicationProtocols", platform.setProtocolMethod.getName());
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/platform/JdkWithJettyBootPlatformTest.java b/okhttp-tests/src/test/java/okhttp3/internal/platform/JdkWithJettyBootPlatformTest.java
new file mode 100644
index 0000000000..afe7145a01
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/platform/JdkWithJettyBootPlatformTest.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform;
+
+import org.junit.Test;
+
+import static okhttp3.internal.platform.PlatformTest.getPlatform;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assume.assumeTrue;
+
+public class JdkWithJettyBootPlatformTest {
+  @Test
+  public void testBuildsWithJettyBoot() {
+    assumeTrue(getPlatform().equals("jdk-with-jetty-boot"));
+
+    assertNotNull(JdkWithJettyBootPlatform.buildIfSupported());
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/platform/OptionalMethodTest.java b/okhttp-tests/src/test/java/okhttp3/internal/platform/OptionalMethodTest.java
new file mode 100644
index 0000000000..7e249bd61f
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/platform/OptionalMethodTest.java
@@ -0,0 +1,347 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package okhttp3.internal.platform;
+
+import java.io.IOException;
+import java.lang.reflect.InvocationTargetException;
+import org.junit.Ignore;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+/**
+ * Tests for {@link OptionalMethod}.
+ */
+public class OptionalMethodTest {
+  @SuppressWarnings("unused")
+  private static class BaseClass {
+    public String stringMethod() {
+      return "string";
+    }
+
+    public void voidMethod() {
+    }
+  }
+
+  @SuppressWarnings("unused")
+  private static class SubClass1 extends BaseClass {
+    public String subclassMethod() {
+      return "subclassMethod1";
+    }
+
+    public String methodWithArgs(String arg) {
+      return arg;
+    }
+  }
+
+  @SuppressWarnings("unused")
+  private static class SubClass2 extends BaseClass {
+    public int subclassMethod() {
+      return 1234;
+    }
+
+    public String methodWithArgs(String arg) {
+      return arg;
+    }
+
+    public void throwsException() throws IOException {
+      throw new IOException();
+    }
+
+    public void throwsRuntimeException() throws Exception {
+      throw new NumberFormatException();
+    }
+
+    protected void nonPublic() {
+    }
+  }
+
+  private final static OptionalMethod<BaseClass> STRING_METHOD_RETURNS_ANY =
+      new OptionalMethod<>(null, "stringMethod");
+  private final static OptionalMethod<BaseClass> STRING_METHOD_RETURNS_STRING =
+      new OptionalMethod<>(String.class, "stringMethod");
+  private final static OptionalMethod<BaseClass> STRING_METHOD_RETURNS_INT =
+      new OptionalMethod<>(Integer.TYPE, "stringMethod");
+  private final static OptionalMethod<BaseClass> VOID_METHOD_RETURNS_ANY =
+      new OptionalMethod<>(null, "voidMethod");
+  private final static OptionalMethod<BaseClass> VOID_METHOD_RETURNS_VOID =
+      new OptionalMethod<>(Void.TYPE, "voidMethod");
+  private final static OptionalMethod<BaseClass> SUBCLASS_METHOD_RETURNS_ANY =
+      new OptionalMethod<>(null, "subclassMethod");
+  private final static OptionalMethod<BaseClass> SUBCLASS_METHOD_RETURNS_STRING =
+      new OptionalMethod<>(String.class, "subclassMethod");
+  private final static OptionalMethod<BaseClass> SUBCLASS_METHOD_RETURNS_INT =
+      new OptionalMethod<>(Integer.TYPE, "subclassMethod");
+  private final static OptionalMethod<BaseClass> METHOD_WITH_ARGS_WRONG_PARAMS =
+      new OptionalMethod<>(null, "methodWithArgs", Integer.class);
+  private final static OptionalMethod<BaseClass> METHOD_WITH_ARGS_CORRECT_PARAMS =
+      new OptionalMethod<>(null, "methodWithArgs", String.class);
+
+  private final static OptionalMethod<BaseClass> THROWS_EXCEPTION =
+      new OptionalMethod<>(null, "throwsException");
+  private final static OptionalMethod<BaseClass> THROWS_RUNTIME_EXCEPTION =
+      new OptionalMethod<>(null, "throwsRuntimeException");
+  private final static OptionalMethod<BaseClass> NON_PUBLIC =
+      new OptionalMethod<>(null, "nonPublic");
+
+  @Test
+  public void isSupported() throws Exception {
+    {
+      BaseClass base = new BaseClass();
+      assertTrue(STRING_METHOD_RETURNS_ANY.isSupported(base));
+      assertTrue(STRING_METHOD_RETURNS_STRING.isSupported(base));
+      assertFalse(STRING_METHOD_RETURNS_INT.isSupported(base));
+      assertTrue(VOID_METHOD_RETURNS_ANY.isSupported(base));
+      assertTrue(VOID_METHOD_RETURNS_VOID.isSupported(base));
+      assertFalse(SUBCLASS_METHOD_RETURNS_ANY.isSupported(base));
+      assertFalse(SUBCLASS_METHOD_RETURNS_STRING.isSupported(base));
+      assertFalse(SUBCLASS_METHOD_RETURNS_INT.isSupported(base));
+      assertFalse(METHOD_WITH_ARGS_WRONG_PARAMS.isSupported(base));
+      assertFalse(METHOD_WITH_ARGS_CORRECT_PARAMS.isSupported(base));
+    }
+    {
+      SubClass1 subClass1 = new SubClass1();
+      assertTrue(STRING_METHOD_RETURNS_ANY.isSupported(subClass1));
+      assertTrue(STRING_METHOD_RETURNS_STRING.isSupported(subClass1));
+      assertFalse(STRING_METHOD_RETURNS_INT.isSupported(subClass1));
+      assertTrue(VOID_METHOD_RETURNS_ANY.isSupported(subClass1));
+      assertTrue(VOID_METHOD_RETURNS_VOID.isSupported(subClass1));
+      assertTrue(SUBCLASS_METHOD_RETURNS_ANY.isSupported(subClass1));
+      assertTrue(SUBCLASS_METHOD_RETURNS_STRING.isSupported(subClass1));
+      assertFalse(SUBCLASS_METHOD_RETURNS_INT.isSupported(subClass1));
+      assertFalse(METHOD_WITH_ARGS_WRONG_PARAMS.isSupported(subClass1));
+      assertTrue(METHOD_WITH_ARGS_CORRECT_PARAMS.isSupported(subClass1));
+    }
+    {
+      SubClass2 subClass2 = new SubClass2();
+      assertTrue(STRING_METHOD_RETURNS_ANY.isSupported(subClass2));
+      assertTrue(STRING_METHOD_RETURNS_STRING.isSupported(subClass2));
+      assertFalse(STRING_METHOD_RETURNS_INT.isSupported(subClass2));
+      assertTrue(VOID_METHOD_RETURNS_ANY.isSupported(subClass2));
+      assertTrue(VOID_METHOD_RETURNS_VOID.isSupported(subClass2));
+      assertTrue(SUBCLASS_METHOD_RETURNS_ANY.isSupported(subClass2));
+      assertFalse(SUBCLASS_METHOD_RETURNS_STRING.isSupported(subClass2));
+      assertTrue(SUBCLASS_METHOD_RETURNS_INT.isSupported(subClass2));
+      assertFalse(METHOD_WITH_ARGS_WRONG_PARAMS.isSupported(subClass2));
+      assertTrue(METHOD_WITH_ARGS_CORRECT_PARAMS.isSupported(subClass2));
+    }
+  }
+
+  @Test
+  public void invoke() throws Exception {
+    {
+      BaseClass base = new BaseClass();
+      assertEquals("string", STRING_METHOD_RETURNS_STRING.invoke(base));
+      assertEquals("string", STRING_METHOD_RETURNS_ANY.invoke(base));
+      assertErrorOnInvoke(STRING_METHOD_RETURNS_INT, base);
+      assertNull(VOID_METHOD_RETURNS_ANY.invoke(base));
+      assertNull(VOID_METHOD_RETURNS_VOID.invoke(base));
+      assertErrorOnInvoke(SUBCLASS_METHOD_RETURNS_ANY, base);
+      assertErrorOnInvoke(SUBCLASS_METHOD_RETURNS_STRING, base);
+      assertErrorOnInvoke(SUBCLASS_METHOD_RETURNS_INT, base);
+      assertErrorOnInvoke(METHOD_WITH_ARGS_WRONG_PARAMS, base);
+      assertErrorOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, base);
+    }
+    {
+      SubClass1 subClass1 = new SubClass1();
+      assertEquals("string", STRING_METHOD_RETURNS_STRING.invoke(subClass1));
+      assertEquals("string", STRING_METHOD_RETURNS_ANY.invoke(subClass1));
+      assertErrorOnInvoke(STRING_METHOD_RETURNS_INT, subClass1);
+      assertNull(VOID_METHOD_RETURNS_ANY.invoke(subClass1));
+      assertNull(VOID_METHOD_RETURNS_VOID.invoke(subClass1));
+      assertEquals("subclassMethod1", SUBCLASS_METHOD_RETURNS_ANY.invoke(subClass1));
+      assertEquals("subclassMethod1", SUBCLASS_METHOD_RETURNS_STRING.invoke(subClass1));
+      assertErrorOnInvoke(SUBCLASS_METHOD_RETURNS_INT, subClass1);
+      assertErrorOnInvoke(METHOD_WITH_ARGS_WRONG_PARAMS, subClass1);
+      assertEquals("arg", METHOD_WITH_ARGS_CORRECT_PARAMS.invoke(subClass1, "arg"));
+    }
+
+    {
+      SubClass2 subClass2 = new SubClass2();
+      assertEquals("string", STRING_METHOD_RETURNS_STRING.invoke(subClass2));
+      assertEquals("string", STRING_METHOD_RETURNS_ANY.invoke(subClass2));
+      assertErrorOnInvoke(STRING_METHOD_RETURNS_INT, subClass2);
+      assertNull(VOID_METHOD_RETURNS_ANY.invoke(subClass2));
+      assertNull(VOID_METHOD_RETURNS_VOID.invoke(subClass2));
+      assertEquals(1234, SUBCLASS_METHOD_RETURNS_ANY.invoke(subClass2));
+      assertErrorOnInvoke(SUBCLASS_METHOD_RETURNS_STRING, subClass2);
+      assertEquals(1234, SUBCLASS_METHOD_RETURNS_INT.invoke(subClass2));
+      assertErrorOnInvoke(METHOD_WITH_ARGS_WRONG_PARAMS, subClass2);
+      assertEquals("arg", METHOD_WITH_ARGS_CORRECT_PARAMS.invoke(subClass2, "arg"));
+    }
+  }
+
+  @Test
+  public void invokeBadArgs() throws Exception {
+    SubClass1 subClass1 = new SubClass1();
+    assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1); // no args
+    assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, 123);
+    assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, true);
+    assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1,
+        new Object());
+    assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, "one",
+        "two");
+  }
+
+  @Test
+  public void invokeWithException() throws Exception {
+    SubClass2 subClass2 = new SubClass2();
+    try {
+      THROWS_EXCEPTION.invoke(subClass2);
+    } catch (InvocationTargetException expected) {
+      assertTrue(expected.getTargetException() instanceof IOException);
+    }
+
+    try {
+      THROWS_RUNTIME_EXCEPTION.invoke(subClass2);
+    } catch (InvocationTargetException expected) {
+      assertTrue(expected.getTargetException() instanceof NumberFormatException);
+    }
+  }
+
+  @Test
+  public void invokeNonPublic() throws Exception {
+    SubClass2 subClass2 = new SubClass2();
+    assertFalse(NON_PUBLIC.isSupported(subClass2));
+    assertErrorOnInvoke(NON_PUBLIC, subClass2);
+  }
+
+  @Test
+  public void invokeOptional() throws Exception {
+    {
+      BaseClass base = new BaseClass();
+      assertEquals("string", STRING_METHOD_RETURNS_STRING.invokeOptional(base));
+      assertEquals("string", STRING_METHOD_RETURNS_ANY.invokeOptional(base));
+      assertNull(STRING_METHOD_RETURNS_INT.invokeOptional(base));
+      assertNull(VOID_METHOD_RETURNS_ANY.invokeOptional(base));
+      assertNull(VOID_METHOD_RETURNS_VOID.invokeOptional(base));
+      assertNull(SUBCLASS_METHOD_RETURNS_ANY.invokeOptional(base));
+      assertNull(SUBCLASS_METHOD_RETURNS_STRING.invokeOptional(base));
+      assertNull(SUBCLASS_METHOD_RETURNS_INT.invokeOptional(base));
+      assertNull(METHOD_WITH_ARGS_WRONG_PARAMS.invokeOptional(base));
+      assertNull(METHOD_WITH_ARGS_CORRECT_PARAMS.invokeOptional(base));
+    }
+    {
+      SubClass1 subClass1 = new SubClass1();
+      assertEquals("string", STRING_METHOD_RETURNS_STRING.invokeOptional(subClass1));
+      assertEquals("string", STRING_METHOD_RETURNS_ANY.invokeOptional(subClass1));
+      assertNull(STRING_METHOD_RETURNS_INT.invokeOptional(subClass1));
+      assertNull(VOID_METHOD_RETURNS_ANY.invokeOptional(subClass1));
+      assertNull(VOID_METHOD_RETURNS_VOID.invokeOptional(subClass1));
+      assertEquals("subclassMethod1", SUBCLASS_METHOD_RETURNS_ANY.invokeOptional(subClass1));
+      assertEquals("subclassMethod1", SUBCLASS_METHOD_RETURNS_STRING.invokeOptional(subClass1));
+      assertNull(SUBCLASS_METHOD_RETURNS_INT.invokeOptional(subClass1));
+      assertNull(METHOD_WITH_ARGS_WRONG_PARAMS.invokeOptional(subClass1));
+      assertEquals("arg", METHOD_WITH_ARGS_CORRECT_PARAMS.invokeOptional(subClass1, "arg"));
+    }
+
+    {
+      SubClass2 subClass2 = new SubClass2();
+      assertEquals("string", STRING_METHOD_RETURNS_STRING.invokeOptional(subClass2));
+      assertEquals("string", STRING_METHOD_RETURNS_ANY.invokeOptional(subClass2));
+      assertNull(STRING_METHOD_RETURNS_INT.invokeOptional(subClass2));
+      assertNull(VOID_METHOD_RETURNS_ANY.invokeOptional(subClass2));
+      assertNull(VOID_METHOD_RETURNS_VOID.invokeOptional(subClass2));
+      assertEquals(1234, SUBCLASS_METHOD_RETURNS_ANY.invokeOptional(subClass2));
+      assertNull(SUBCLASS_METHOD_RETURNS_STRING.invokeOptional(subClass2));
+      assertEquals(1234, SUBCLASS_METHOD_RETURNS_INT.invokeOptional(subClass2));
+      assertNull(METHOD_WITH_ARGS_WRONG_PARAMS.invokeOptional(subClass2));
+      assertEquals("arg", METHOD_WITH_ARGS_CORRECT_PARAMS.invokeOptional(subClass2, "arg"));
+    }
+  }
+
+  @Test
+  public void invokeOptionalBadArgs() throws Exception {
+    SubClass1 subClass1 = new SubClass1();
+    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS,
+        subClass1); // no args
+    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, 123);
+    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1,
+        true);
+    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1,
+        new Object());
+    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1,
+        "one", "two");
+  }
+
+  @Test
+  public void invokeOptionalWithException() throws Exception {
+    SubClass2 subClass2 = new SubClass2();
+    try {
+      THROWS_EXCEPTION.invokeOptional(subClass2);
+    } catch (InvocationTargetException expected) {
+      assertTrue(expected.getTargetException() instanceof IOException);
+    }
+
+    try {
+      THROWS_RUNTIME_EXCEPTION.invokeOptional(subClass2);
+    } catch (InvocationTargetException expected) {
+      assertTrue(expected.getTargetException() instanceof NumberFormatException);
+    }
+  }
+
+  @Test
+  @Ignore("Despite returning false for isSupported, invocation actually succeeds.")
+  public void invokeOptionalNonPublic() throws Exception {
+    SubClass2 subClass2 = new SubClass2();
+    assertFalse(NON_PUBLIC.isSupported(subClass2));
+    assertErrorOnInvokeOptional(NON_PUBLIC, subClass2);
+  }
+
+  private static <T> void assertErrorOnInvoke(
+      OptionalMethod<T> optionalMethod, T base, Object... args) throws Exception {
+    try {
+      optionalMethod.invoke(base, args);
+    } catch (Error expected) {
+      return;
+    }
+    fail();
+  }
+
+  private static <T> void assertIllegalArgumentExceptionOnInvoke(
+      OptionalMethod<T> optionalMethod, T base, Object... args) throws Exception {
+    try {
+      optionalMethod.invoke(base, args);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  private static <T> void assertErrorOnInvokeOptional(
+      OptionalMethod<T> optionalMethod, T base, Object... args) throws Exception {
+    try {
+      optionalMethod.invokeOptional(base, args);
+    } catch (Error expected) {
+      return;
+    }
+    fail();
+  }
+
+  private static <T> void assertIllegalArgumentExceptionOnInvokeOptional(
+      OptionalMethod<T> optionalMethod, T base, Object... args) throws Exception {
+    try {
+      optionalMethod.invokeOptional(base, args);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/platform/PlatformTest.java b/okhttp-tests/src/test/java/okhttp3/internal/platform/PlatformTest.java
new file mode 100644
index 0000000000..ffd5842e83
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/platform/PlatformTest.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform;
+
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+public class PlatformTest {
+  @Test public void alwaysBuilds() {
+    new Platform();
+  }
+
+  /** Guard against the default value changing by accident. */
+  @Test public void defaultPrefix() {
+    assertEquals("OkHttp", new Platform().getPrefix());
+  }
+
+  public static String getPlatform() {
+    return System.getProperty("okhttp.platform", "platform");
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java b/okhttp-tests/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java
new file mode 100644
index 0000000000..e999890991
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java
@@ -0,0 +1,284 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.publicsuffix;
+
+import java.io.IOException;
+import java.io.InputStream;
+import okhttp3.internal.Util;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.GzipSource;
+import okio.Okio;
+import org.junit.Test;
+
+import static okhttp3.internal.publicsuffix.PublicSuffixDatabase.PUBLIC_SUFFIX_RESOURCE;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class PublicSuffixDatabaseTest {
+  private final PublicSuffixDatabase publicSuffixDatabase = new PublicSuffixDatabase();
+
+  @Test public void longestMatchWins() {
+    Buffer buffer = new Buffer()
+        .writeUtf8("com\n")
+        .writeUtf8("my.square.com\n")
+        .writeUtf8("square.com\n");
+    publicSuffixDatabase.setListBytes(buffer.readByteArray(), new byte[]{});
+
+    assertEquals("example.com", publicSuffixDatabase.getEffectiveTldPlusOne("example.com"));
+    assertEquals("example.com", publicSuffixDatabase.getEffectiveTldPlusOne("foo.example.com"));
+    assertEquals("bar.square.com",
+        publicSuffixDatabase.getEffectiveTldPlusOne("foo.bar.square.com"));
+    assertEquals("foo.my.square.com",
+        publicSuffixDatabase.getEffectiveTldPlusOne("foo.my.square.com"));
+  }
+
+  @Test public void wildcardMatch() {
+    Buffer buffer = new Buffer()
+        .writeUtf8("*.square.com\n")
+        .writeUtf8("com\n")
+        .writeUtf8("example.com\n");
+    publicSuffixDatabase.setListBytes(buffer.readByteArray(), new byte[]{});
+
+    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("my.square.com"));
+    assertEquals("foo.my.square.com",
+        publicSuffixDatabase.getEffectiveTldPlusOne("foo.my.square.com"));
+    assertEquals("foo.my.square.com",
+        publicSuffixDatabase.getEffectiveTldPlusOne("bar.foo.my.square.com"));
+  }
+
+  @Test public void boundarySearches() {
+    Buffer buffer = new Buffer()
+        .writeUtf8("bbb\n")
+        .writeUtf8("ddd\n")
+        .writeUtf8("fff\n");
+    publicSuffixDatabase.setListBytes(buffer.readByteArray(), new byte[]{});
+
+    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("aaa"));
+    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("ggg"));
+    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("ccc"));
+    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("eee"));
+  }
+
+  @Test public void exceptionRule() {
+    Buffer exception = new Buffer()
+        .writeUtf8("my.square.jp\n");
+    Buffer buffer = new Buffer()
+        .writeUtf8("*.jp\n")
+        .writeUtf8("*.square.jp\n")
+        .writeUtf8("example.com\n")
+        .writeUtf8("square.com\n");
+    publicSuffixDatabase.setListBytes(buffer.readByteArray(), exception.readByteArray());
+
+    assertEquals("my.square.jp", publicSuffixDatabase.getEffectiveTldPlusOne("my.square.jp"));
+    assertEquals("my.square.jp", publicSuffixDatabase.getEffectiveTldPlusOne("foo.my.square.jp"));
+    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("my1.square.jp"));
+  }
+
+  @Test public void noEffectiveTldPlusOne() {
+    Buffer exception = new Buffer()
+        .writeUtf8("my.square.jp\n");
+    Buffer buffer = new Buffer()
+        .writeUtf8("*.jp\n")
+        .writeUtf8("*.square.jp\n")
+        .writeUtf8("example.com\n")
+        .writeUtf8("square.com\n");
+    publicSuffixDatabase.setListBytes(buffer.readByteArray(), exception.readByteArray());
+
+    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("example.com"));
+    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("foo.square.jp"));
+  }
+
+  @Test public void allPublicSuffixes() throws IOException {
+    InputStream resource = PublicSuffixDatabaseTest.class
+        .getResourceAsStream(PUBLIC_SUFFIX_RESOURCE);
+    BufferedSource source = Okio.buffer(new GzipSource(Okio.source(resource)));
+    int length = source.readInt();
+    Buffer buffer = new Buffer();
+    buffer.write(source, length);
+    resource.close();
+
+    while (!buffer.exhausted()) {
+      String publicSuffix = buffer.readUtf8LineStrict();
+      if (publicSuffix.contains("*")) {
+        // A wildcard rule, let's replace the wildcard with a value.
+        publicSuffix = publicSuffix.replaceAll("\\*", "square");
+      }
+      assertNull(publicSuffixDatabase.getEffectiveTldPlusOne(publicSuffix));
+
+      String test = "foobar." + publicSuffix;
+      assertEquals(test, publicSuffixDatabase.getEffectiveTldPlusOne(test));
+    }
+  }
+
+  @Test public void publicSuffixExceptions() throws IOException {
+    InputStream resource = PublicSuffixDatabaseTest.class
+        .getResourceAsStream(PUBLIC_SUFFIX_RESOURCE);
+    BufferedSource source = Okio.buffer(new GzipSource(Okio.source(resource)));
+    int length = source.readInt();
+    source.skip(length);
+
+    length = source.readInt();
+    Buffer buffer = new Buffer();
+    buffer.write(source, length);
+    resource.close();
+
+    while (!buffer.exhausted()) {
+      String exception = buffer.readUtf8LineStrict();
+      assertEquals(exception, publicSuffixDatabase.getEffectiveTldPlusOne(exception));
+
+      String test = "foobar." + exception;
+      assertEquals(exception, publicSuffixDatabase.getEffectiveTldPlusOne(test));
+    }
+  }
+
+  @Test public void threadIsInterruptedOnFirstRead() {
+    Thread.currentThread().interrupt();
+    try {
+      String result = publicSuffixDatabase.getEffectiveTldPlusOne("squareup.com");
+      assertEquals("squareup.com", result);
+    } finally {
+      assertTrue(Thread.interrupted());
+    }
+  }
+
+  /**
+   * These tests are provided by <a href="https://publicsuffix.org/list/">publicsuffix.org</a>.
+   */
+  @Test public void publicSuffixDotOrgTestCases() {
+    // Any copyright is dedicated to the Public Domain.
+    // https://creativecommons.org/publicdomain/zero/1.0/
+
+    // null input.
+    checkPublicSuffix(null, null);
+    // Mixed case.
+    checkPublicSuffix("COM", null);
+    checkPublicSuffix("example.COM", "example.com");
+    checkPublicSuffix("WwW.example.COM", "example.com");
+    // Leading dot.
+    checkPublicSuffix(".com", null);
+    checkPublicSuffix(".example", null);
+    checkPublicSuffix(".example.com", null);
+    checkPublicSuffix(".example.example", null);
+    // Unlisted TLD.
+    checkPublicSuffix("example", null);
+    checkPublicSuffix("example.example", "example.example");
+    checkPublicSuffix("b.example.example", "example.example");
+    checkPublicSuffix("a.b.example.example", "example.example");
+    // Listed, but non-Internet, TLD.
+    //checkPublicSuffix("local", null);
+    //checkPublicSuffix("example.local", null);
+    //checkPublicSuffix("b.example.local", null);
+    //checkPublicSuffix("a.b.example.local", null);
+    // TLD with only 1 rule.
+    checkPublicSuffix("biz", null);
+    checkPublicSuffix("domain.biz", "domain.biz");
+    checkPublicSuffix("b.domain.biz", "domain.biz");
+    checkPublicSuffix("a.b.domain.biz", "domain.biz");
+    // TLD with some 2-level rules.
+    checkPublicSuffix("com", null);
+    checkPublicSuffix("example.com", "example.com");
+    checkPublicSuffix("b.example.com", "example.com");
+    checkPublicSuffix("a.b.example.com", "example.com");
+    checkPublicSuffix("uk.com", null);
+    checkPublicSuffix("example.uk.com", "example.uk.com");
+    checkPublicSuffix("b.example.uk.com", "example.uk.com");
+    checkPublicSuffix("a.b.example.uk.com", "example.uk.com");
+    checkPublicSuffix("test.ac", "test.ac");
+    // TLD with only 1 (wildcard) rule.
+    checkPublicSuffix("mm", null);
+    checkPublicSuffix("c.mm", null);
+    checkPublicSuffix("b.c.mm", "b.c.mm");
+    checkPublicSuffix("a.b.c.mm", "b.c.mm");
+    // More complex TLD.
+    checkPublicSuffix("jp", null);
+    checkPublicSuffix("test.jp", "test.jp");
+    checkPublicSuffix("www.test.jp", "test.jp");
+    checkPublicSuffix("ac.jp", null);
+    checkPublicSuffix("test.ac.jp", "test.ac.jp");
+    checkPublicSuffix("www.test.ac.jp", "test.ac.jp");
+    checkPublicSuffix("kyoto.jp", null);
+    checkPublicSuffix("test.kyoto.jp", "test.kyoto.jp");
+    checkPublicSuffix("ide.kyoto.jp", null);
+    checkPublicSuffix("b.ide.kyoto.jp", "b.ide.kyoto.jp");
+    checkPublicSuffix("a.b.ide.kyoto.jp", "b.ide.kyoto.jp");
+    checkPublicSuffix("c.kobe.jp", null);
+    checkPublicSuffix("b.c.kobe.jp", "b.c.kobe.jp");
+    checkPublicSuffix("a.b.c.kobe.jp", "b.c.kobe.jp");
+    checkPublicSuffix("city.kobe.jp", "city.kobe.jp");
+    checkPublicSuffix("www.city.kobe.jp", "city.kobe.jp");
+    // TLD with a wildcard rule and exceptions.
+    checkPublicSuffix("ck", null);
+    checkPublicSuffix("test.ck", null);
+    checkPublicSuffix("b.test.ck", "b.test.ck");
+    checkPublicSuffix("a.b.test.ck", "b.test.ck");
+    checkPublicSuffix("www.ck", "www.ck");
+    checkPublicSuffix("www.www.ck", "www.ck");
+    // US K12.
+    checkPublicSuffix("us", null);
+    checkPublicSuffix("test.us", "test.us");
+    checkPublicSuffix("www.test.us", "test.us");
+    checkPublicSuffix("ak.us", null);
+    checkPublicSuffix("test.ak.us", "test.ak.us");
+    checkPublicSuffix("www.test.ak.us", "test.ak.us");
+    checkPublicSuffix("k12.ak.us", null);
+    checkPublicSuffix("test.k12.ak.us", "test.k12.ak.us");
+    checkPublicSuffix("www.test.k12.ak.us", "test.k12.ak.us");
+    // IDN labels.
+    checkPublicSuffix("食狮.com.cn", "食狮.com.cn");
+    checkPublicSuffix("食狮.公司.cn", "食狮.公司.cn");
+    checkPublicSuffix("www.食狮.公司.cn", "食狮.公司.cn");
+    checkPublicSuffix("shishi.公司.cn", "shishi.公司.cn");
+    checkPublicSuffix("公司.cn", null);
+    checkPublicSuffix("食狮.中国", "食狮.中国");
+    checkPublicSuffix("www.食狮.中国", "食狮.中国");
+    checkPublicSuffix("shishi.中国", "shishi.中国");
+    checkPublicSuffix("中国", null);
+    // Same as above, but punycoded.
+    checkPublicSuffix("xn--85x722f.com.cn", "xn--85x722f.com.cn");
+    checkPublicSuffix("xn--85x722f.xn--55qx5d.cn", "xn--85x722f.xn--55qx5d.cn");
+    checkPublicSuffix("www.xn--85x722f.xn--55qx5d.cn", "xn--85x722f.xn--55qx5d.cn");
+    checkPublicSuffix("shishi.xn--55qx5d.cn", "shishi.xn--55qx5d.cn");
+    checkPublicSuffix("xn--55qx5d.cn", null);
+    checkPublicSuffix("xn--85x722f.xn--fiqs8s", "xn--85x722f.xn--fiqs8s");
+    checkPublicSuffix("www.xn--85x722f.xn--fiqs8s", "xn--85x722f.xn--fiqs8s");
+    checkPublicSuffix("shishi.xn--fiqs8s", "shishi.xn--fiqs8s");
+    checkPublicSuffix("xn--fiqs8s", null);
+  }
+
+  private void checkPublicSuffix(String domain, String registrablePart) {
+    if (domain == null) {
+      try {
+        publicSuffixDatabase.getEffectiveTldPlusOne(null);
+        fail();
+      } catch (NullPointerException expected) {
+      }
+      return;
+    }
+
+    String canonicalDomain = Util.canonicalizeHost(domain);
+    if (canonicalDomain == null) return;
+
+    String result = publicSuffixDatabase.getEffectiveTldPlusOne(canonicalDomain);
+    if (registrablePart == null) {
+      assertNull(result);
+    } else {
+      assertEquals(Util.canonicalizeHost(registrablePart), result);
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java b/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
new file mode 100644
index 0000000000..27b1c7783f
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
@@ -0,0 +1,332 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.tls;
+
+import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import okhttp3.Call;
+import okhttp3.CertificatePinner;
+import okhttp3.OkHttpClient;
+import okhttp3.RecordingHostnameVerifier;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.SocketPolicy;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static okhttp3.TestUtil.defaultClient;
+import static okhttp3.internal.platform.PlatformTest.getPlatform;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class CertificatePinnerChainValidationTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  /** The pinner should pull the root certificate from the trust manager. */
+  @Test public void pinRootNotPresentInChain() throws Exception {
+    HeldCertificate rootCa = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .ca(3)
+        .commonName("root")
+        .build();
+    HeldCertificate intermediateCa = new HeldCertificate.Builder()
+        .issuedBy(rootCa)
+        .ca(2)
+        .serialNumber("2")
+        .commonName("intermediate_ca")
+        .build();
+    HeldCertificate certificate = new HeldCertificate.Builder()
+        .issuedBy(intermediateCa)
+        .serialNumber("3")
+        .commonName(server.getHostName())
+        .build();
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add(server.getHostName(), CertificatePinner.pin(rootCa.certificate))
+        .build();
+    SslClient sslClient = new SslClient.Builder()
+        .addTrustedCertificate(rootCa.certificate)
+        .build();
+    OkHttpClient client = defaultClient().newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .certificatePinner(certificatePinner)
+        .build();
+
+    SslClient serverSslClient = new SslClient.Builder()
+        .certificateChain(certificate, intermediateCa)
+        .build();
+    server.useHttps(serverSslClient.socketFactory, false);
+
+    // The request should complete successfully.
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+    assertEquals("abc", response1.body().string());
+
+    // Confirm that a second request also succeeds. This should detect caching problems.
+    server.enqueue(new MockResponse()
+        .setBody("def")
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("def", response2.body().string());
+  }
+
+  /** The pinner should accept an intermediate from the server's chain. */
+  @Test public void pinIntermediatePresentInChain() throws Exception {
+    HeldCertificate rootCa = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .ca(3)
+        .commonName("root")
+        .build();
+    HeldCertificate intermediateCa = new HeldCertificate.Builder()
+        .issuedBy(rootCa)
+        .ca(2)
+        .serialNumber("2")
+        .commonName("intermediate_ca")
+        .build();
+    HeldCertificate certificate = new HeldCertificate.Builder()
+        .issuedBy(intermediateCa)
+        .serialNumber("3")
+        .commonName(server.getHostName())
+        .build();
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add(server.getHostName(), CertificatePinner.pin(intermediateCa.certificate))
+        .build();
+    SslClient contextBuilder = new SslClient.Builder()
+        .addTrustedCertificate(rootCa.certificate)
+        .build();
+    OkHttpClient client = defaultClient().newBuilder()
+        .sslSocketFactory(contextBuilder.socketFactory, contextBuilder.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .certificatePinner(certificatePinner)
+        .build();
+
+    SslClient serverSslContext = new SslClient.Builder()
+        .certificateChain(certificate.keyPair, certificate.certificate, intermediateCa.certificate)
+        .build();
+    server.useHttps(serverSslContext.socketFactory, false);
+
+    // The request should complete successfully.
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+    assertEquals("abc", response1.body().string());
+    response1.close();
+
+    // Force a fresh connection for the next request.
+    client.connectionPool().evictAll();
+
+    // Confirm that a second request also succeeds. This should detect caching problems.
+    server.enqueue(new MockResponse()
+        .setBody("def")
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("def", response2.body().string());
+    response2.close();
+  }
+
+  @Test public void unrelatedPinnedLeafCertificateInChain() throws Exception {
+    // Start with a trusted root CA certificate.
+    HeldCertificate rootCa = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .ca(3)
+        .commonName("root")
+        .build();
+
+    // Add a good intermediate CA, and have that issue a good certificate to localhost. Prepare an
+    // SSL context for an HTTP client under attack. It includes the trusted CA and a pinned
+    // certificate.
+    HeldCertificate goodIntermediateCa = new HeldCertificate.Builder()
+        .issuedBy(rootCa)
+        .ca(2)
+        .serialNumber("2")
+        .commonName("good_intermediate_ca")
+        .build();
+    HeldCertificate goodCertificate = new HeldCertificate.Builder()
+        .issuedBy(goodIntermediateCa)
+        .serialNumber("3")
+        .commonName(server.getHostName())
+        .build();
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add(server.getHostName(), CertificatePinner.pin(goodCertificate.certificate))
+        .build();
+    SslClient clientContextBuilder = new SslClient.Builder()
+        .addTrustedCertificate(rootCa.certificate)
+        .build();
+    OkHttpClient client = defaultClient().newBuilder()
+        .sslSocketFactory(clientContextBuilder.socketFactory, clientContextBuilder.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .certificatePinner(certificatePinner)
+        .build();
+
+    // Add a bad intermediate CA and have that issue a rogue certificate for localhost. Prepare
+    // an SSL context for an attacking webserver. It includes both these rogue certificates plus the
+    // trusted good certificate above. The attack is that by including the good certificate in the
+    // chain, we may trick the certificate pinner into accepting the rouge certificate.
+    HeldCertificate compromisedIntermediateCa = new HeldCertificate.Builder()
+        .issuedBy(rootCa)
+        .ca(2)
+        .serialNumber("4")
+        .commonName("bad_intermediate_ca")
+        .build();
+    HeldCertificate rogueCertificate = new HeldCertificate.Builder()
+        .serialNumber("5")
+        .issuedBy(compromisedIntermediateCa)
+        .commonName(server.getHostName())
+        .build();
+
+    SslClient.Builder sslBuilder = new SslClient.Builder();
+
+    // Test setup fails on JDK9
+    // java.security.KeyStoreException: Certificate chain is not valid
+    // at sun.security.pkcs12.PKCS12KeyStore.setKeyEntry
+    // http://openjdk.java.net/jeps/229
+    // http://hg.openjdk.java.net/jdk9/jdk9/jdk/file/2c1c21d11e58/src/share/classes/sun/security/pkcs12/PKCS12KeyStore.java#l596
+    if (getPlatform().equals("jdk9")) {
+      sslBuilder.keyStoreType("JKS");
+    }
+
+    SslClient serverSslContext = sslBuilder.certificateChain(
+        rogueCertificate.keyPair, rogueCertificate.certificate, compromisedIntermediateCa.certificate, goodCertificate.certificate, rootCa.certificate)
+        .build();
+    server.useHttps(serverSslContext.socketFactory, false);
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .addHeader("Content-Type: text/plain"));
+
+    // Make a request from client to server. It should succeed certificate checks (unfortunately the
+    // rogue CA is trusted) but it should fail certificate pinning.
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Call call = client.newCall(request);
+    try {
+      call.execute();
+      fail();
+    } catch (SSLPeerUnverifiedException expected) {
+      // Certificate pinning fails!
+      String message = expected.getMessage();
+      assertTrue(message, message.startsWith("Certificate pinning failure!"));
+    }
+  }
+
+  @Test public void unrelatedPinnedIntermediateCertificateInChain() throws Exception {
+    // Start with two root CA certificates, one is good and the other is compromised.
+    HeldCertificate rootCa = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .ca(3)
+        .commonName("root")
+        .build();
+    HeldCertificate compromisedRootCa = new HeldCertificate.Builder()
+        .serialNumber("2")
+        .ca(3)
+        .commonName("compromised_root")
+        .build();
+
+    // Add a good intermediate CA, and have that issue a good certificate to localhost. Prepare an
+    // SSL context for an HTTP client under attack. It includes the trusted CA and a pinned
+    // certificate.
+    HeldCertificate goodIntermediateCa = new HeldCertificate.Builder()
+        .issuedBy(rootCa)
+        .ca(2)
+        .serialNumber("3")
+        .commonName("intermediate_ca")
+        .build();
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add(server.getHostName(), CertificatePinner.pin(goodIntermediateCa.certificate))
+        .build();
+    SslClient clientContextBuilder = new SslClient.Builder()
+        .addTrustedCertificate(rootCa.certificate)
+        .addTrustedCertificate(compromisedRootCa.certificate)
+        .build();
+    OkHttpClient client = defaultClient().newBuilder()
+        .sslSocketFactory(clientContextBuilder.socketFactory, clientContextBuilder.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .certificatePinner(certificatePinner)
+        .build();
+
+    // The attacker compromises the root CA, issues an intermediate with the same common name
+    // "intermediate_ca" as the good CA. This signs a rogue certificate for localhost. The server
+    // serves the good CAs certificate in the chain, which means the certificate pinner sees a
+    // different set of certificates than the SSL verifier.
+    HeldCertificate compromisedIntermediateCa = new HeldCertificate.Builder()
+        .issuedBy(compromisedRootCa)
+        .ca(2)
+        .serialNumber("4")
+        .commonName("intermediate_ca")
+        .build();
+    HeldCertificate rogueCertificate = new HeldCertificate.Builder()
+        .serialNumber("5")
+        .issuedBy(compromisedIntermediateCa)
+        .commonName(server.getHostName())
+        .build();
+
+    SslClient.Builder sslBuilder = new SslClient.Builder();
+
+    // Test setup fails on JDK9
+    // java.security.KeyStoreException: Certificate chain is not valid
+    // at sun.security.pkcs12.PKCS12KeyStore.setKeyEntry
+    // http://openjdk.java.net/jeps/229
+    // http://hg.openjdk.java.net/jdk9/jdk9/jdk/file/2c1c21d11e58/src/share/classes/sun/security/pkcs12/PKCS12KeyStore.java#l596
+    if (getPlatform().equals("jdk9")) {
+      sslBuilder.keyStoreType("JKS");
+    }
+
+    SslClient serverSslContext = sslBuilder.certificateChain(
+            rogueCertificate.keyPair, rogueCertificate.certificate, goodIntermediateCa.certificate, compromisedIntermediateCa.certificate, compromisedRootCa.certificate)
+        .build();
+    server.useHttps(serverSslContext.socketFactory, false);
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .addHeader("Content-Type: text/plain"));
+
+    // Make a request from client to server. It should succeed certificate checks (unfortunately the
+    // rogue CA is trusted) but it should fail certificate pinning.
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Call call = client.newCall(request);
+    try {
+      call.execute();
+      fail();
+    } catch (SSLHandshakeException expected) {
+      // On Android, the handshake fails before the certificate pinner runs.
+      String message = expected.getMessage();
+      assertTrue(message, message.contains("Could not validate certificate"));
+    } catch (SSLPeerUnverifiedException expected) {
+      // On OpenJDK, the handshake succeeds but the certificate pinner fails.
+      String message = expected.getMessage();
+      assertTrue(message, message.startsWith("Certificate pinning failure!"));
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java b/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
new file mode 100644
index 0000000000..6642f009b5
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
@@ -0,0 +1,227 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.tls;
+
+import java.io.IOException;
+import java.net.SocketException;
+import java.security.GeneralSecurityException;
+import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import javax.security.auth.x500.X500Principal;
+import okhttp3.Call;
+import okhttp3.DelegatingSSLSocketFactory;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static okhttp3.TestUtil.defaultClient;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class ClientAuthTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  public enum ClientAuth {
+    NONE, WANTS, NEEDS
+  }
+
+  private HeldCertificate serverRootCa;
+  private HeldCertificate serverIntermediateCa;
+  private HeldCertificate serverCert;
+  private HeldCertificate clientRootCa;
+  private HeldCertificate clientIntermediateCa;
+  private HeldCertificate clientCert;
+
+  @Before
+  public void setUp() throws GeneralSecurityException {
+    serverRootCa = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .ca(3)
+        .commonName("root")
+        .build();
+    serverIntermediateCa = new HeldCertificate.Builder()
+        .issuedBy(serverRootCa)
+        .ca(2)
+        .serialNumber("2")
+        .commonName("intermediate_ca")
+        .build();
+
+    serverCert = new HeldCertificate.Builder()
+        .issuedBy(serverIntermediateCa)
+        .serialNumber("3")
+        .commonName(server.getHostName())
+        .build();
+
+    clientRootCa = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .ca(13)
+        .commonName("root")
+        .build();
+    clientIntermediateCa = new HeldCertificate.Builder()
+        .issuedBy(serverRootCa)
+        .ca(12)
+        .serialNumber("2")
+        .commonName("intermediate_ca")
+        .build();
+
+    clientCert = new HeldCertificate.Builder()
+        .issuedBy(clientIntermediateCa)
+        .serialNumber("4")
+        .commonName("Jethro Willis")
+        .build();
+  }
+
+  @Test public void clientAuthForWants() throws Exception {
+    OkHttpClient client = buildClient(clientCert, clientIntermediateCa);
+
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.WANTS);
+
+    server.useHttps(socketFactory, false);
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
+    Response response = call.execute();
+    assertEquals(new X500Principal("CN=" + server.getHostName()), response.handshake().peerPrincipal());
+    assertEquals(new X500Principal("CN=Jethro Willis"), response.handshake().localPrincipal());
+    assertEquals("abc", response.body().string());
+  }
+
+  @Test public void clientAuthForNeeds() throws Exception {
+    OkHttpClient client = buildClient(clientCert, clientIntermediateCa);
+
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.NEEDS);
+
+    server.useHttps(socketFactory, false);
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
+    Response response = call.execute();
+    assertEquals(new X500Principal("CN=" + server.getHostName()), response.handshake().peerPrincipal());
+    assertEquals(new X500Principal("CN=Jethro Willis"), response.handshake().localPrincipal());
+    assertEquals("abc", response.body().string());
+  }
+
+  @Test public void clientAuthSkippedForNone() throws Exception {
+    OkHttpClient client = buildClient(clientCert, clientIntermediateCa);
+
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.NONE);
+
+    server.useHttps(socketFactory, false);
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
+    Response response = call.execute();
+    assertEquals(new X500Principal("CN=" + server.getHostName()), response.handshake().peerPrincipal());
+    assertEquals(null, response.handshake().localPrincipal());
+    assertEquals("abc", response.body().string());
+  }
+
+  @Test public void missingClientAuthSkippedForWantsOnly() throws Exception {
+    OkHttpClient client = buildClient(null, clientIntermediateCa);
+
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.WANTS);
+
+    server.useHttps(socketFactory, false);
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
+    Response response = call.execute();
+    assertEquals(new X500Principal("CN=" + server.getHostName()), response.handshake().peerPrincipal());
+    assertEquals(null, response.handshake().localPrincipal());
+    assertEquals("abc", response.body().string());
+  }
+
+  @Test public void missingClientAuthFailsForNeeds() throws Exception {
+    OkHttpClient client = buildClient(null, clientIntermediateCa);
+
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.NEEDS);
+
+    server.useHttps(socketFactory, false);
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
+
+    try {
+      call.execute();
+      fail();
+    } catch (SSLHandshakeException expected) {
+    } catch (SocketException expected) {
+      // JDK 9
+    }
+  }
+
+  @Test public void invalidClientAuthFails() throws Throwable {
+    HeldCertificate clientCert2 = new HeldCertificate.Builder()
+        .serialNumber("4")
+        .commonName("Jethro Willis")
+        .build();
+
+    OkHttpClient client = buildClient(clientCert2);
+
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.NEEDS);
+
+    server.useHttps(socketFactory, false);
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
+
+    try {
+      call.execute();
+      fail();
+    } catch (SSLHandshakeException expected) {
+    } catch (SocketException expected) {
+      // JDK 9
+    }
+  }
+
+  public OkHttpClient buildClient(HeldCertificate cert, HeldCertificate... chain) {
+    SslClient.Builder sslClientBuilder = new SslClient.Builder()
+        .addTrustedCertificate(serverRootCa.certificate);
+
+    if (cert != null) {
+      sslClientBuilder.certificateChain(cert, chain);
+    }
+
+    SslClient sslClient = sslClientBuilder.build();
+    return defaultClient().newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .build();
+  }
+
+  public SSLSocketFactory buildServerSslSocketFactory(final ClientAuth clientAuth) {
+    SslClient serverSslClient = new SslClient.Builder()
+        .addTrustedCertificate(serverRootCa.certificate)
+        .addTrustedCertificate(clientRootCa.certificate)
+        .certificateChain(serverCert, serverIntermediateCa)
+        .build();
+
+    return new DelegatingSSLSocketFactory(serverSslClient.socketFactory) {
+      @Override protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
+        if (clientAuth == ClientAuth.NEEDS) {
+          sslSocket.setNeedClientAuth(true);
+        } else if (clientAuth == ClientAuth.WANTS) {
+          sslSocket.setWantClientAuth(true);
+        }
+
+        return super.configureSocket(sslSocket);
+      }
+    };
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/DistinguishedNameParserTest.java b/okhttp-tests/src/test/java/okhttp3/internal/tls/DistinguishedNameParserTest.java
new file mode 100644
index 0000000000..09c22b8594
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/tls/DistinguishedNameParserTest.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.tls;
+
+
+import javax.security.auth.x500.X500Principal;
+
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class DistinguishedNameParserTest {
+  @Test public void regularCases() {
+    assertCn("xxx", "ou=xxx,cn=xxx");
+    assertCn("yyy", "ou=xxx+cn=yyy,cn=zzz+cn=abc");
+    assertCn("a", "cn=a,cn=b");
+    assertCn("a   c", "cn=a   c,cn=b");
+    assertCn("Cc", "cn=Cc,cn=Bb,cn=Aa");
+    assertCn("imap.gmail.com", "cn=imap.gmail.com");
+    assertCn("c", "l=\"abcn=a,b\", cn=c");
+    assertCn("c", "l=\"abcn=a,b\", cn=c");
+    assertCn("c", "l=\"abcn=a,b\", cn= c");
+    assertCn("a b", "cn=a b");
+    assertCn("a b", "cn   =a b");
+    assertCn("a b", "Cn=a b");
+    assertCn("a b", "cN=a b");
+    assertCn("a b", "CN=a b");
+    assertCn("a#b", "cn=a#b");
+    assertCn("a", "cn=#130161");
+    assertCn("p", "l=q\t+cn=p");
+    assertCn("p", "l=q\n+cn=p");
+    assertCn("p", "l=q\n,cn=p");
+    assertCn("p", "l=,cn=p");
+    assertCn("\tp", "l=\tq\n,cn=\tp");
+  }
+
+  @Test public void emptyValues() {
+    assertCn(null, "");
+    assertCn(null, "ou=xxx");
+    assertCn("", "l=,cn=+cn=q");
+    assertCn("", "l=,cn=,cn=q");
+    assertCn(null, "l=,cn=");
+    assertCn("q", "l=,cn=q,cn=   ");
+    assertCn("q", "l=,cn=q  ,cn=   ");
+    assertCn(null, "l=,cn=\"\"");
+    assertCn("", "l=,cn=  ,cn=  ");
+    assertCn("", "l=,cn=,cn=  ,cn=  ");
+  }
+
+  @Test public void escapedChars() {
+    assertCn(",", "cn=\\,");
+    assertCn("#", "cn=\\#");
+    assertCn("+", "cn=\\+");
+    assertCn("\"", "cn=\\\"");
+    assertCn("\\", "cn=\\\\");
+    assertCn("<", "cn=\\<");
+    assertCn(">", "cn=\\>");
+    assertCn(";", "cn=\\;");
+    assertCn("+", "cn=\\+");
+    assertCn("+", "cn=\"\\+\"");
+    assertCn(",", "cn=\"\\,\"");
+    assertCn("a =", "cn= a =");
+    assertCn("=", "cn==");
+  }
+
+  @Test public void whitespace() {
+    assertCn("p", "cn= p");
+    assertCn("p", "cn=\np");
+    assertCn("\tp", "cn=\tp");
+  }
+
+  @Test public void withOid() {
+    assertCn("a", "2.5.4.3=a,ou=xxx");
+    assertCn("a", "2.5.4.3=\" a \",ou=xxx");
+    assertCn("b", "2.5.5.3=a,ou=xxx,cn=b");
+  }
+
+  @Test public void quotedStrings() {
+    assertCn("\" a ,=<>#;", "cn=\"\\\" a ,=<>#;\"");
+    assertCn("abc,def", "cn=abc\\,def");
+    assertCn("\" a ,=<>#;", "cn=\"\\\" a ,\\=<>\\#;\"");
+  }
+
+  @Test public void utf8() {
+    assertCn("\u004c\u0075\u010d\u0069\u0107", "cn=\"Lu\\C4\\8Di\\C4\\87\"");
+    assertCn("\u004c\u0075\u010d\u0069\u0107", "cn=Lu\\C4\\8Di\\C4\\87");
+    assertCn("\u004c\u0075\u010d\u0069\u0107", "cn=Lu\\C4\\8di\\c4\\87");
+    assertCn("\u004c\u0075\u010d\u0069\u0107", "cn=\"Lu\\C4\\8di\\c4\\87\"");
+    assertCn("\u004c\u0075\u010d\u0069\u0107", "cn=\u004c\u0075\u010d\u0069\u0107");
+    // \63=c
+    expectExceptionInPrincipal("\\63n=ab");
+    expectExceptionInPrincipal("cn=\\a");
+  }
+
+  @Test public void trailingWhitespace() {
+    assertCn("a  b", "ou=a, cn=  a  b  ,o=x");
+    assertCn("a  b", "cn=\"  a  b  \" ,o=x");
+    assertCn("a", "cn=a   ,cn=b");
+    assertCn("", "l=,cn=\"  \",cn=\"  \"");
+  }
+
+  /**
+   * @param expected the value of the first "cn=" argument in {@code dn},
+   *                 or null if none is expected
+   */
+  private void assertCn(String expected, String dn) {
+    X500Principal principal = new X500Principal(dn);
+    DistinguishedNameParser parser = new DistinguishedNameParser(principal);
+    assertEquals(dn, expected, parser.findMostSpecific("cn"));
+  }
+
+  private void expectExceptionInPrincipal(String dn) {
+    try {
+      new X500Principal(dn);
+      fail("Expected " + IllegalArgumentException.class.getName()
+          + " because of incorrect input name");
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java b/okhttp-tests/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java
new file mode 100644
index 0000000000..f03f197d94
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java
@@ -0,0 +1,553 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with this
+ * work for additional information regarding copyright ownership. The ASF
+ * licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package okhttp3.internal.tls;
+
+import java.io.ByteArrayInputStream;
+import java.security.cert.CertificateFactory;
+import java.security.cert.X509Certificate;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLSession;
+import javax.security.auth.x500.X500Principal;
+import okhttp3.FakeSSLSession;
+import okhttp3.internal.Util;
+import org.junit.Ignore;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+/**
+ * Tests for our hostname verifier. Most of these tests are from AOSP, which itself includes tests
+ * from the Apache HTTP Client test suite.
+ */
+public final class HostnameVerifierTest {
+  private HostnameVerifier verifier = OkHostnameVerifier.INSTANCE;
+
+  @Test public void verify() throws Exception {
+    FakeSSLSession session = new FakeSSLSession();
+    assertFalse(verifier.verify("localhost", session));
+  }
+
+  @Test public void verifyCn() throws Exception {
+    // CN=foo.com
+    SSLSession session = session(""
+        + "-----BEGIN CERTIFICATE-----\n"
+        + "MIIERjCCAy6gAwIBAgIJAIz+EYMBU6aQMA0GCSqGSIb3DQEBBQUAMIGiMQswCQYD\n"
+        + "VQQGEwJDQTELMAkGA1UECBMCQkMxEjAQBgNVBAcTCVZhbmNvdXZlcjEWMBQGA1UE\n"
+        + "ChMNd3d3LmN1Y2JjLmNvbTEUMBIGA1UECxQLY29tbW9uc19zc2wxHTAbBgNVBAMU\n"
+        + "FGRlbW9faW50ZXJtZWRpYXRlX2NhMSUwIwYJKoZIhvcNAQkBFhZqdWxpdXNkYXZp\n"
+        + "ZXNAZ21haWwuY29tMB4XDTA2MTIxMTE1MzE0MVoXDTI4MTEwNTE1MzE0MVowgaQx\n"
+        + "CzAJBgNVBAYTAlVTMREwDwYDVQQIEwhNYXJ5bGFuZDEUMBIGA1UEBxMLRm9yZXN0\n"
+        + "IEhpbGwxFzAVBgNVBAoTDmh0dHBjb21wb25lbnRzMRowGAYDVQQLExF0ZXN0IGNl\n"
+        + "cnRpZmljYXRlczEQMA4GA1UEAxMHZm9vLmNvbTElMCMGCSqGSIb3DQEJARYWanVs\n"
+        + "aXVzZGF2aWVzQGdtYWlsLmNvbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC\n"
+        + "ggEBAMhjr5aCPoyp0R1iroWAfnEyBMGYWoCidH96yGPFjYLowez5aYKY1IOKTY2B\n"
+        + "lYho4O84X244QrZTRl8kQbYtxnGh4gSCD+Z8gjZ/gMvLUlhqOb+WXPAUHMB39GRy\n"
+        + "zerA/ZtrlUqf+lKo0uWcocxeRc771KN8cPH3nHZ0rV0Hx4ZAZy6U4xxObe4rtSVY\n"
+        + "07hNKXAb2odnVqgzcYiDkLV8ilvEmoNWMWrp8UBqkTcpEhYhCYp3cTkgJwMSuqv8\n"
+        + "BqnGd87xQU3FVZI4tbtkB+KzjD9zz8QCDJAfDjZHR03KNQ5mxOgXwxwKw6lGMaiV\n"
+        + "JTxpTKqym93whYk93l3ocEe55c0CAwEAAaN7MHkwCQYDVR0TBAIwADAsBglghkgB\n"
+        + "hvhCAQ0EHxYdT3BlblNTTCBHZW5lcmF0ZWQgQ2VydGlmaWNhdGUwHQYDVR0OBBYE\n"
+        + "FJ8Ud78/OrbKOIJCSBYs2tDLXofYMB8GA1UdIwQYMBaAFHua2o+QmU5S0qzbswNS\n"
+        + "yoemDT4NMA0GCSqGSIb3DQEBBQUAA4IBAQC3jRmEya6sQCkmieULcvx8zz1euCk9\n"
+        + "fSez7BEtki8+dmfMXe3K7sH0lI8f4jJR0rbSCjpmCQLYmzC3NxBKeJOW0RcjNBpO\n"
+        + "c2JlGO9auXv2GDP4IYiXElLJ6VSqc8WvDikv0JmCCWm0Zga+bZbR/EWN5DeEtFdF\n"
+        + "815CLpJZNcYwiYwGy/CVQ7w2TnXlG+mraZOz+owr+cL6J/ZesbdEWfjoS1+cUEhE\n"
+        + "HwlNrAu8jlZ2UqSgskSWlhYdMTAP9CPHiUv9N7FcT58Itv/I4fKREINQYjDpvQcx\n"
+        + "SaTYb9dr5sB4WLNglk7zxDtM80H518VvihTcP7FHL+Gn6g4j5fkI98+S\n"
+        + "-----END CERTIFICATE-----\n");
+    assertTrue(verifier.verify("foo.com", session));
+    assertFalse(verifier.verify("a.foo.com", session));
+    assertFalse(verifier.verify("bar.com", session));
+  }
+
+  @Test public void verifyNonAsciiCn() throws Exception {
+    // CN=&#x82b1;&#x5b50;.co.jp
+    SSLSession session = session(""
+        + "-----BEGIN CERTIFICATE-----\n"
+        + "MIIESzCCAzOgAwIBAgIJAIz+EYMBU6aTMA0GCSqGSIb3DQEBBQUAMIGiMQswCQYD\n"
+        + "VQQGEwJDQTELMAkGA1UECBMCQkMxEjAQBgNVBAcTCVZhbmNvdXZlcjEWMBQGA1UE\n"
+        + "ChMNd3d3LmN1Y2JjLmNvbTEUMBIGA1UECxQLY29tbW9uc19zc2wxHTAbBgNVBAMU\n"
+        + "FGRlbW9faW50ZXJtZWRpYXRlX2NhMSUwIwYJKoZIhvcNAQkBFhZqdWxpdXNkYXZp\n"
+        + "ZXNAZ21haWwuY29tMB4XDTA2MTIxMTE1NDIxNVoXDTI4MTEwNTE1NDIxNVowgakx\n"
+        + "CzAJBgNVBAYTAlVTMREwDwYDVQQIDAhNYXJ5bGFuZDEUMBIGA1UEBwwLRm9yZXN0\n"
+        + "IEhpbGwxFzAVBgNVBAoMDmh0dHBjb21wb25lbnRzMRowGAYDVQQLDBF0ZXN0IGNl\n"
+        + "cnRpZmljYXRlczEVMBMGA1UEAwwM6Iqx5a2QLmNvLmpwMSUwIwYJKoZIhvcNAQkB\n"
+        + "FhZqdWxpdXNkYXZpZXNAZ21haWwuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A\n"
+        + "MIIBCgKCAQEAyGOvloI+jKnRHWKuhYB+cTIEwZhagKJ0f3rIY8WNgujB7PlpgpjU\n"
+        + "g4pNjYGViGjg7zhfbjhCtlNGXyRBti3GcaHiBIIP5nyCNn+Ay8tSWGo5v5Zc8BQc\n"
+        + "wHf0ZHLN6sD9m2uVSp/6UqjS5ZyhzF5FzvvUo3xw8fecdnStXQfHhkBnLpTjHE5t\n"
+        + "7iu1JVjTuE0pcBvah2dWqDNxiIOQtXyKW8Sag1YxaunxQGqRNykSFiEJindxOSAn\n"
+        + "AxK6q/wGqcZ3zvFBTcVVkji1u2QH4rOMP3PPxAIMkB8ONkdHTco1DmbE6BfDHArD\n"
+        + "qUYxqJUlPGlMqrKb3fCFiT3eXehwR7nlzQIDAQABo3sweTAJBgNVHRMEAjAAMCwG\n"
+        + "CWCGSAGG+EIBDQQfFh1PcGVuU1NMIEdlbmVyYXRlZCBDZXJ0aWZpY2F0ZTAdBgNV\n"
+        + "HQ4EFgQUnxR3vz86tso4gkJIFiza0Mteh9gwHwYDVR0jBBgwFoAUe5raj5CZTlLS\n"
+        + "rNuzA1LKh6YNPg0wDQYJKoZIhvcNAQEFBQADggEBALJ27i3okV/KvlDp6KMID3gd\n"
+        + "ITl68PyItzzx+SquF8gahMh016NX73z/oVZoVUNdftla8wPUB1GwIkAnGkhQ9LHK\n"
+        + "spBdbRiCj0gMmLCsX8SrjFvr7cYb2cK6J/fJe92l1tg/7Y4o7V/s4JBe/cy9U9w8\n"
+        + "a0ctuDmEBCgC784JMDtT67klRfr/2LlqWhlOEq7pUFxRLbhpquaAHSOjmIcWnVpw\n"
+        + "9BsO7qe46hidgn39hKh1WjKK2VcL/3YRsC4wUi0PBtFW6ScMCuMhgIRXSPU55Rae\n"
+        + "UIlOdPjjr1SUNWGId1rD7W16Scpwnknn310FNxFMHVI0GTGFkNdkilNCFJcIoRA=\n"
+        + "-----END CERTIFICATE-----\n");
+    assertTrue(verifier.verify("\u82b1\u5b50.co.jp", session));
+    assertFalse(verifier.verify("a.\u82b1\u5b50.co.jp", session));
+  }
+
+  @Test public void verifySubjectAlt() throws Exception {
+    // CN=foo.com, subjectAlt=bar.com
+    SSLSession session = session(""
+        + "-----BEGIN CERTIFICATE-----\n"
+        + "MIIEXDCCA0SgAwIBAgIJAIz+EYMBU6aRMA0GCSqGSIb3DQEBBQUAMIGiMQswCQYD\n"
+        + "VQQGEwJDQTELMAkGA1UECBMCQkMxEjAQBgNVBAcTCVZhbmNvdXZlcjEWMBQGA1UE\n"
+        + "ChMNd3d3LmN1Y2JjLmNvbTEUMBIGA1UECxQLY29tbW9uc19zc2wxHTAbBgNVBAMU\n"
+        + "FGRlbW9faW50ZXJtZWRpYXRlX2NhMSUwIwYJKoZIhvcNAQkBFhZqdWxpdXNkYXZp\n"
+        + "ZXNAZ21haWwuY29tMB4XDTA2MTIxMTE1MzYyOVoXDTI4MTEwNTE1MzYyOVowgaQx\n"
+        + "CzAJBgNVBAYTAlVTMREwDwYDVQQIEwhNYXJ5bGFuZDEUMBIGA1UEBxMLRm9yZXN0\n"
+        + "IEhpbGwxFzAVBgNVBAoTDmh0dHBjb21wb25lbnRzMRowGAYDVQQLExF0ZXN0IGNl\n"
+        + "cnRpZmljYXRlczEQMA4GA1UEAxMHZm9vLmNvbTElMCMGCSqGSIb3DQEJARYWanVs\n"
+        + "aXVzZGF2aWVzQGdtYWlsLmNvbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC\n"
+        + "ggEBAMhjr5aCPoyp0R1iroWAfnEyBMGYWoCidH96yGPFjYLowez5aYKY1IOKTY2B\n"
+        + "lYho4O84X244QrZTRl8kQbYtxnGh4gSCD+Z8gjZ/gMvLUlhqOb+WXPAUHMB39GRy\n"
+        + "zerA/ZtrlUqf+lKo0uWcocxeRc771KN8cPH3nHZ0rV0Hx4ZAZy6U4xxObe4rtSVY\n"
+        + "07hNKXAb2odnVqgzcYiDkLV8ilvEmoNWMWrp8UBqkTcpEhYhCYp3cTkgJwMSuqv8\n"
+        + "BqnGd87xQU3FVZI4tbtkB+KzjD9zz8QCDJAfDjZHR03KNQ5mxOgXwxwKw6lGMaiV\n"
+        + "JTxpTKqym93whYk93l3ocEe55c0CAwEAAaOBkDCBjTAJBgNVHRMEAjAAMCwGCWCG\n"
+        + "SAGG+EIBDQQfFh1PcGVuU1NMIEdlbmVyYXRlZCBDZXJ0aWZpY2F0ZTAdBgNVHQ4E\n"
+        + "FgQUnxR3vz86tso4gkJIFiza0Mteh9gwHwYDVR0jBBgwFoAUe5raj5CZTlLSrNuz\n"
+        + "A1LKh6YNPg0wEgYDVR0RBAswCYIHYmFyLmNvbTANBgkqhkiG9w0BAQUFAAOCAQEA\n"
+        + "dQyprNZBmVnvuVWjV42sey/PTfkYShJwy1j0/jcFZR/ypZUovpiHGDO1DgL3Y3IP\n"
+        + "zVQ26uhUsSw6G0gGRiaBDe/0LUclXZoJzXX1qpS55OadxW73brziS0sxRgGrZE/d\n"
+        + "3g5kkio6IED47OP6wYnlmZ7EKP9cqjWwlnvHnnUcZ2SscoLNYs9rN9ccp8tuq2by\n"
+        + "88OyhKwGjJfhOudqfTNZcDzRHx4Fzm7UsVaycVw4uDmhEHJrAsmMPpj/+XRK9/42\n"
+        + "2xq+8bc6HojdtbCyug/fvBZvZqQXSmU8m8IVcMmWMz0ZQO8ee3QkBHMZfCy7P/kr\n"
+        + "VbWx/uETImUu+NZg22ewEw==\n"
+        + "-----END CERTIFICATE-----\n");
+    assertFalse(verifier.verify("foo.com", session));
+    assertFalse(verifier.verify("a.foo.com", session));
+    assertTrue(verifier.verify("bar.com", session));
+    assertFalse(verifier.verify("a.bar.com", session));
+  }
+
+  /**
+   * Ignored due to incompatibilities between Android and Java on how non-ASCII subject alt names
+   * are parsed. Android fails to parse these, which means we fall back to the CN. The RI does parse
+   * them, so the CN is unused.
+   */
+  @Test @Ignore public void verifyNonAsciiSubjectAlt() throws Exception {
+    // CN=foo.com, subjectAlt=bar.com, subjectAlt=&#x82b1;&#x5b50;.co.jp
+    // (hanako.co.jp in kanji)
+    SSLSession session = session(""
+        + "-----BEGIN CERTIFICATE-----\n"
+        + "MIIEajCCA1KgAwIBAgIJAIz+EYMBU6aSMA0GCSqGSIb3DQEBBQUAMIGiMQswCQYD\n"
+        + "VQQGEwJDQTELMAkGA1UECBMCQkMxEjAQBgNVBAcTCVZhbmNvdXZlcjEWMBQGA1UE\n"
+        + "ChMNd3d3LmN1Y2JjLmNvbTEUMBIGA1UECxQLY29tbW9uc19zc2wxHTAbBgNVBAMU\n"
+        + "FGRlbW9faW50ZXJtZWRpYXRlX2NhMSUwIwYJKoZIhvcNAQkBFhZqdWxpdXNkYXZp\n"
+        + "ZXNAZ21haWwuY29tMB4XDTA2MTIxMTE1MzgxM1oXDTI4MTEwNTE1MzgxM1owgaQx\n"
+        + "CzAJBgNVBAYTAlVTMREwDwYDVQQIEwhNYXJ5bGFuZDEUMBIGA1UEBxMLRm9yZXN0\n"
+        + "IEhpbGwxFzAVBgNVBAoTDmh0dHBjb21wb25lbnRzMRowGAYDVQQLExF0ZXN0IGNl\n"
+        + "cnRpZmljYXRlczEQMA4GA1UEAxMHZm9vLmNvbTElMCMGCSqGSIb3DQEJARYWanVs\n"
+        + "aXVzZGF2aWVzQGdtYWlsLmNvbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC\n"
+        + "ggEBAMhjr5aCPoyp0R1iroWAfnEyBMGYWoCidH96yGPFjYLowez5aYKY1IOKTY2B\n"
+        + "lYho4O84X244QrZTRl8kQbYtxnGh4gSCD+Z8gjZ/gMvLUlhqOb+WXPAUHMB39GRy\n"
+        + "zerA/ZtrlUqf+lKo0uWcocxeRc771KN8cPH3nHZ0rV0Hx4ZAZy6U4xxObe4rtSVY\n"
+        + "07hNKXAb2odnVqgzcYiDkLV8ilvEmoNWMWrp8UBqkTcpEhYhCYp3cTkgJwMSuqv8\n"
+        + "BqnGd87xQU3FVZI4tbtkB+KzjD9zz8QCDJAfDjZHR03KNQ5mxOgXwxwKw6lGMaiV\n"
+        + "JTxpTKqym93whYk93l3ocEe55c0CAwEAAaOBnjCBmzAJBgNVHRMEAjAAMCwGCWCG\n"
+        + "SAGG+EIBDQQfFh1PcGVuU1NMIEdlbmVyYXRlZCBDZXJ0aWZpY2F0ZTAdBgNVHQ4E\n"
+        + "FgQUnxR3vz86tso4gkJIFiza0Mteh9gwHwYDVR0jBBgwFoAUe5raj5CZTlLSrNuz\n"
+        + "A1LKh6YNPg0wIAYDVR0RBBkwF4IHYmFyLmNvbYIM6Iqx5a2QLmNvLmpwMA0GCSqG\n"
+        + "SIb3DQEBBQUAA4IBAQBeZs7ZIYyKtdnVxVvdLgwySEPOE4pBSXii7XYv0Q9QUvG/\n"
+        + "++gFGQh89HhABzA1mVUjH5dJTQqSLFvRfqTHqLpxSxSWqMHnvRM4cPBkIRp/XlMK\n"
+        + "PlXadYtJLPTgpbgvulA1ickC9EwlNYWnowZ4uxnfsMghW4HskBqaV+PnQ8Zvy3L0\n"
+        + "12c7Cg4mKKS5pb1HdRuiD2opZ+Hc77gRQLvtWNS8jQvd/iTbh6fuvTKfAOFoXw22\n"
+        + "sWIKHYrmhCIRshUNohGXv50m2o+1w9oWmQ6Dkq7lCjfXfUB4wIbggJjpyEtbNqBt\n"
+        + "j4MC2x5rfsLKKqToKmNE7pFEgqwe8//Aar1b+Qj+\n"
+        + "-----END CERTIFICATE-----\n");
+    assertTrue(verifier.verify("foo.com", session));
+    assertFalse(verifier.verify("a.foo.com", session));
+    // these checks test alternative subjects. The test data contains an
+    // alternative subject starting with a japanese kanji character. This is
+    // not supported by Android because the underlying implementation from
+    // harmony follows the definition from rfc 1034 page 10 for alternative
+    // subject names. This causes the code to drop all alternative subjects.
+    // assertTrue(verifier.verify("bar.com", session));
+    // assertFalse(verifier.verify("a.bar.com", session));
+    // assertFalse(verifier.verify("a.\u82b1\u5b50.co.jp", session));
+  }
+
+  @Test public void verifySubjectAltOnly() throws Exception {
+    // subjectAlt=foo.com
+    SSLSession session = session(""
+        + "-----BEGIN CERTIFICATE-----\n"
+        + "MIIESjCCAzKgAwIBAgIJAIz+EYMBU6aYMA0GCSqGSIb3DQEBBQUAMIGiMQswCQYD\n"
+        + "VQQGEwJDQTELMAkGA1UECBMCQkMxEjAQBgNVBAcTCVZhbmNvdXZlcjEWMBQGA1UE\n"
+        + "ChMNd3d3LmN1Y2JjLmNvbTEUMBIGA1UECxQLY29tbW9uc19zc2wxHTAbBgNVBAMU\n"
+        + "FGRlbW9faW50ZXJtZWRpYXRlX2NhMSUwIwYJKoZIhvcNAQkBFhZqdWxpdXNkYXZp\n"
+        + "ZXNAZ21haWwuY29tMB4XDTA2MTIxMTE2MjYxMFoXDTI4MTEwNTE2MjYxMFowgZIx\n"
+        + "CzAJBgNVBAYTAlVTMREwDwYDVQQIDAhNYXJ5bGFuZDEUMBIGA1UEBwwLRm9yZXN0\n"
+        + "IEhpbGwxFzAVBgNVBAoMDmh0dHBjb21wb25lbnRzMRowGAYDVQQLDBF0ZXN0IGNl\n"
+        + "cnRpZmljYXRlczElMCMGCSqGSIb3DQEJARYWanVsaXVzZGF2aWVzQGdtYWlsLmNv\n"
+        + "bTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMhjr5aCPoyp0R1iroWA\n"
+        + "fnEyBMGYWoCidH96yGPFjYLowez5aYKY1IOKTY2BlYho4O84X244QrZTRl8kQbYt\n"
+        + "xnGh4gSCD+Z8gjZ/gMvLUlhqOb+WXPAUHMB39GRyzerA/ZtrlUqf+lKo0uWcocxe\n"
+        + "Rc771KN8cPH3nHZ0rV0Hx4ZAZy6U4xxObe4rtSVY07hNKXAb2odnVqgzcYiDkLV8\n"
+        + "ilvEmoNWMWrp8UBqkTcpEhYhCYp3cTkgJwMSuqv8BqnGd87xQU3FVZI4tbtkB+Kz\n"
+        + "jD9zz8QCDJAfDjZHR03KNQ5mxOgXwxwKw6lGMaiVJTxpTKqym93whYk93l3ocEe5\n"
+        + "5c0CAwEAAaOBkDCBjTAJBgNVHRMEAjAAMCwGCWCGSAGG+EIBDQQfFh1PcGVuU1NM\n"
+        + "IEdlbmVyYXRlZCBDZXJ0aWZpY2F0ZTAdBgNVHQ4EFgQUnxR3vz86tso4gkJIFiza\n"
+        + "0Mteh9gwHwYDVR0jBBgwFoAUe5raj5CZTlLSrNuzA1LKh6YNPg0wEgYDVR0RBAsw\n"
+        + "CYIHZm9vLmNvbTANBgkqhkiG9w0BAQUFAAOCAQEAjl78oMjzFdsMy6F1sGg/IkO8\n"
+        + "tF5yUgPgFYrs41yzAca7IQu6G9qtFDJz/7ehh/9HoG+oqCCIHPuIOmS7Sd0wnkyJ\n"
+        + "Y7Y04jVXIb3a6f6AgBkEFP1nOT0z6kjT7vkA5LJ2y3MiDcXuRNMSta5PYVnrX8aZ\n"
+        + "yiqVUNi40peuZ2R8mAUSBvWgD7z2qWhF8YgDb7wWaFjg53I36vWKn90ZEti3wNCw\n"
+        + "qAVqixM+J0qJmQStgAc53i2aTMvAQu3A3snvH/PHTBo+5UL72n9S1kZyNCsVf1Qo\n"
+        + "n8jKTiRriEM+fMFlcgQP284EBFzYHyCXFb9O/hMjK2+6mY9euMB1U1aFFzM/Bg==\n"
+        + "-----END CERTIFICATE-----\n");
+    assertTrue(verifier.verify("foo.com", session));
+    assertFalse(verifier.verify("a.foo.com", session));
+    assertTrue(verifier.verify("foo.com", session));
+    assertFalse(verifier.verify("a.foo.com", session));
+  }
+
+  @Test public void verifyMultipleCn() throws Exception {
+    // CN=foo.com, CN=bar.com, CN=&#x82b1;&#x5b50;.co.jp
+    SSLSession session = session(""
+        + "-----BEGIN CERTIFICATE-----\n"
+        + "MIIEbzCCA1egAwIBAgIJAIz+EYMBU6aXMA0GCSqGSIb3DQEBBQUAMIGiMQswCQYD\n"
+        + "VQQGEwJDQTELMAkGA1UECBMCQkMxEjAQBgNVBAcTCVZhbmNvdXZlcjEWMBQGA1UE\n"
+        + "ChMNd3d3LmN1Y2JjLmNvbTEUMBIGA1UECxQLY29tbW9uc19zc2wxHTAbBgNVBAMU\n"
+        + "FGRlbW9faW50ZXJtZWRpYXRlX2NhMSUwIwYJKoZIhvcNAQkBFhZqdWxpdXNkYXZp\n"
+        + "ZXNAZ21haWwuY29tMB4XDTA2MTIxMTE2MTk0NVoXDTI4MTEwNTE2MTk0NVowgc0x\n"
+        + "CzAJBgNVBAYTAlVTMREwDwYDVQQIDAhNYXJ5bGFuZDEUMBIGA1UEBwwLRm9yZXN0\n"
+        + "IEhpbGwxFzAVBgNVBAoMDmh0dHBjb21wb25lbnRzMRowGAYDVQQLDBF0ZXN0IGNl\n"
+        + "cnRpZmljYXRlczEQMA4GA1UEAwwHZm9vLmNvbTEQMA4GA1UEAwwHYmFyLmNvbTEV\n"
+        + "MBMGA1UEAwwM6Iqx5a2QLmNvLmpwMSUwIwYJKoZIhvcNAQkBFhZqdWxpdXNkYXZp\n"
+        + "ZXNAZ21haWwuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAyGOv\n"
+        + "loI+jKnRHWKuhYB+cTIEwZhagKJ0f3rIY8WNgujB7PlpgpjUg4pNjYGViGjg7zhf\n"
+        + "bjhCtlNGXyRBti3GcaHiBIIP5nyCNn+Ay8tSWGo5v5Zc8BQcwHf0ZHLN6sD9m2uV\n"
+        + "Sp/6UqjS5ZyhzF5FzvvUo3xw8fecdnStXQfHhkBnLpTjHE5t7iu1JVjTuE0pcBva\n"
+        + "h2dWqDNxiIOQtXyKW8Sag1YxaunxQGqRNykSFiEJindxOSAnAxK6q/wGqcZ3zvFB\n"
+        + "TcVVkji1u2QH4rOMP3PPxAIMkB8ONkdHTco1DmbE6BfDHArDqUYxqJUlPGlMqrKb\n"
+        + "3fCFiT3eXehwR7nlzQIDAQABo3sweTAJBgNVHRMEAjAAMCwGCWCGSAGG+EIBDQQf\n"
+        + "Fh1PcGVuU1NMIEdlbmVyYXRlZCBDZXJ0aWZpY2F0ZTAdBgNVHQ4EFgQUnxR3vz86\n"
+        + "tso4gkJIFiza0Mteh9gwHwYDVR0jBBgwFoAUe5raj5CZTlLSrNuzA1LKh6YNPg0w\n"
+        + "DQYJKoZIhvcNAQEFBQADggEBAGuZb8ai1NO2j4v3y9TLZvd5s0vh5/TE7n7RX+8U\n"
+        + "y37OL5k7x9nt0mM1TyAKxlCcY+9h6frue8MemZIILSIvMrtzccqNz0V1WKgA+Orf\n"
+        + "uUrabmn+CxHF5gpy6g1Qs2IjVYWA5f7FROn/J+Ad8gJYc1azOWCLQqSyfpNRLSvY\n"
+        + "EriQFEV63XvkJ8JrG62b+2OT2lqT4OO07gSPetppdlSa8NBSKP6Aro9RIX1ZjUZQ\n"
+        + "SpQFCfo02NO0uNRDPUdJx2huycdNb+AXHaO7eXevDLJ+QnqImIzxWiY6zLOdzjjI\n"
+        + "VBMkLHmnP7SjGSQ3XA4ByrQOxfOUTyLyE7NuemhHppuQPxE=\n"
+        + "-----END CERTIFICATE-----\n");
+    assertFalse(verifier.verify("foo.com", session));
+    assertFalse(verifier.verify("a.foo.com", session));
+    assertFalse(verifier.verify("bar.com", session));
+    assertFalse(verifier.verify("a.bar.com", session));
+    assertTrue(verifier.verify("\u82b1\u5b50.co.jp", session));
+    assertFalse(verifier.verify("a.\u82b1\u5b50.co.jp", session));
+  }
+
+  @Test public void verifyWilcardCn() throws Exception {
+    // CN=*.foo.com
+    SSLSession session = session(""
+        + "-----BEGIN CERTIFICATE-----\n"
+        + "MIIESDCCAzCgAwIBAgIJAIz+EYMBU6aUMA0GCSqGSIb3DQEBBQUAMIGiMQswCQYD\n"
+        + "VQQGEwJDQTELMAkGA1UECBMCQkMxEjAQBgNVBAcTCVZhbmNvdXZlcjEWMBQGA1UE\n"
+        + "ChMNd3d3LmN1Y2JjLmNvbTEUMBIGA1UECxQLY29tbW9uc19zc2wxHTAbBgNVBAMU\n"
+        + "FGRlbW9faW50ZXJtZWRpYXRlX2NhMSUwIwYJKoZIhvcNAQkBFhZqdWxpdXNkYXZp\n"
+        + "ZXNAZ21haWwuY29tMB4XDTA2MTIxMTE2MTU1NVoXDTI4MTEwNTE2MTU1NVowgaYx\n"
+        + "CzAJBgNVBAYTAlVTMREwDwYDVQQIEwhNYXJ5bGFuZDEUMBIGA1UEBxMLRm9yZXN0\n"
+        + "IEhpbGwxFzAVBgNVBAoTDmh0dHBjb21wb25lbnRzMRowGAYDVQQLExF0ZXN0IGNl\n"
+        + "cnRpZmljYXRlczESMBAGA1UEAxQJKi5mb28uY29tMSUwIwYJKoZIhvcNAQkBFhZq\n"
+        + "dWxpdXNkYXZpZXNAZ21haWwuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB\n"
+        + "CgKCAQEAyGOvloI+jKnRHWKuhYB+cTIEwZhagKJ0f3rIY8WNgujB7PlpgpjUg4pN\n"
+        + "jYGViGjg7zhfbjhCtlNGXyRBti3GcaHiBIIP5nyCNn+Ay8tSWGo5v5Zc8BQcwHf0\n"
+        + "ZHLN6sD9m2uVSp/6UqjS5ZyhzF5FzvvUo3xw8fecdnStXQfHhkBnLpTjHE5t7iu1\n"
+        + "JVjTuE0pcBvah2dWqDNxiIOQtXyKW8Sag1YxaunxQGqRNykSFiEJindxOSAnAxK6\n"
+        + "q/wGqcZ3zvFBTcVVkji1u2QH4rOMP3PPxAIMkB8ONkdHTco1DmbE6BfDHArDqUYx\n"
+        + "qJUlPGlMqrKb3fCFiT3eXehwR7nlzQIDAQABo3sweTAJBgNVHRMEAjAAMCwGCWCG\n"
+        + "SAGG+EIBDQQfFh1PcGVuU1NMIEdlbmVyYXRlZCBDZXJ0aWZpY2F0ZTAdBgNVHQ4E\n"
+        + "FgQUnxR3vz86tso4gkJIFiza0Mteh9gwHwYDVR0jBBgwFoAUe5raj5CZTlLSrNuz\n"
+        + "A1LKh6YNPg0wDQYJKoZIhvcNAQEFBQADggEBAH0ipG6J561UKUfgkeW7GvYwW98B\n"
+        + "N1ZooWX+JEEZK7+Pf/96d3Ij0rw9ACfN4bpfnCq0VUNZVSYB+GthQ2zYuz7tf/UY\n"
+        + "A6nxVgR/IjG69BmsBl92uFO7JTNtHztuiPqBn59pt+vNx4yPvno7zmxsfI7jv0ww\n"
+        + "yfs+0FNm7FwdsC1k47GBSOaGw38kuIVWqXSAbL4EX9GkryGGOKGNh0qvAENCdRSB\n"
+        + "G9Z6tyMbmfRY+dLSh3a9JwoEcBUso6EWYBakLbq4nG/nvYdYvG9ehrnLVwZFL82e\n"
+        + "l3Q/RK95bnA6cuRClGusLad0e6bjkBzx/VQ3VarDEpAkTLUGVAa0CLXtnyc=\n"
+        + "-----END CERTIFICATE-----\n");
+    assertFalse(verifier.verify("foo.com", session));
+    assertTrue(verifier.verify("www.foo.com", session));
+    assertTrue(verifier.verify("\u82b1\u5b50.foo.com", session));
+    assertFalse(verifier.verify("a.b.foo.com", session));
+  }
+
+  @Test public void verifyWilcardCnOnTld() throws Exception {
+    // It's the CA's responsibility to not issue broad-matching certificates!
+    // CN=*.co.jp
+    SSLSession session = session(""
+        + "-----BEGIN CERTIFICATE-----\n"
+        + "MIIERjCCAy6gAwIBAgIJAIz+EYMBU6aVMA0GCSqGSIb3DQEBBQUAMIGiMQswCQYD\n"
+        + "VQQGEwJDQTELMAkGA1UECBMCQkMxEjAQBgNVBAcTCVZhbmNvdXZlcjEWMBQGA1UE\n"
+        + "ChMNd3d3LmN1Y2JjLmNvbTEUMBIGA1UECxQLY29tbW9uc19zc2wxHTAbBgNVBAMU\n"
+        + "FGRlbW9faW50ZXJtZWRpYXRlX2NhMSUwIwYJKoZIhvcNAQkBFhZqdWxpdXNkYXZp\n"
+        + "ZXNAZ21haWwuY29tMB4XDTA2MTIxMTE2MTYzMFoXDTI4MTEwNTE2MTYzMFowgaQx\n"
+        + "CzAJBgNVBAYTAlVTMREwDwYDVQQIEwhNYXJ5bGFuZDEUMBIGA1UEBxMLRm9yZXN0\n"
+        + "IEhpbGwxFzAVBgNVBAoTDmh0dHBjb21wb25lbnRzMRowGAYDVQQLExF0ZXN0IGNl\n"
+        + "cnRpZmljYXRlczEQMA4GA1UEAxQHKi5jby5qcDElMCMGCSqGSIb3DQEJARYWanVs\n"
+        + "aXVzZGF2aWVzQGdtYWlsLmNvbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC\n"
+        + "ggEBAMhjr5aCPoyp0R1iroWAfnEyBMGYWoCidH96yGPFjYLowez5aYKY1IOKTY2B\n"
+        + "lYho4O84X244QrZTRl8kQbYtxnGh4gSCD+Z8gjZ/gMvLUlhqOb+WXPAUHMB39GRy\n"
+        + "zerA/ZtrlUqf+lKo0uWcocxeRc771KN8cPH3nHZ0rV0Hx4ZAZy6U4xxObe4rtSVY\n"
+        + "07hNKXAb2odnVqgzcYiDkLV8ilvEmoNWMWrp8UBqkTcpEhYhCYp3cTkgJwMSuqv8\n"
+        + "BqnGd87xQU3FVZI4tbtkB+KzjD9zz8QCDJAfDjZHR03KNQ5mxOgXwxwKw6lGMaiV\n"
+        + "JTxpTKqym93whYk93l3ocEe55c0CAwEAAaN7MHkwCQYDVR0TBAIwADAsBglghkgB\n"
+        + "hvhCAQ0EHxYdT3BlblNTTCBHZW5lcmF0ZWQgQ2VydGlmaWNhdGUwHQYDVR0OBBYE\n"
+        + "FJ8Ud78/OrbKOIJCSBYs2tDLXofYMB8GA1UdIwQYMBaAFHua2o+QmU5S0qzbswNS\n"
+        + "yoemDT4NMA0GCSqGSIb3DQEBBQUAA4IBAQA0sWglVlMx2zNGvUqFC73XtREwii53\n"
+        + "CfMM6mtf2+f3k/d8KXhLNySrg8RRlN11zgmpPaLtbdTLrmG4UdAHHYr8O4y2BBmE\n"
+        + "1cxNfGxxechgF8HX10QV4dkyzp6Z1cfwvCeMrT5G/V1pejago0ayXx+GPLbWlNeZ\n"
+        + "S+Kl0m3p+QplXujtwG5fYcIpaGpiYraBLx3Tadih39QN65CnAh/zRDhLCUzKyt9l\n"
+        + "UGPLEUDzRHMPHLnSqT1n5UU5UDRytbjJPXzF+l/+WZIsanefWLsxnkgAuZe/oMMF\n"
+        + "EJMryEzOjg4Tfuc5qM0EXoPcQ/JlheaxZ40p2IyHqbsWV4MRYuFH4bkM\n"
+        + "-----END CERTIFICATE-----\n");
+    assertTrue(verifier.verify("foo.co.jp", session));
+    assertTrue(verifier.verify("\u82b1\u5b50.co.jp", session));
+  }
+
+  /**
+   * Ignored due to incompatibilities between Android and Java on how non-ASCII subject alt names
+   * are parsed. Android fails to parse these, which means we fall back to the CN. The RI does parse
+   * them, so the CN is unused.
+   */
+  @Test @Ignore public void testWilcardNonAsciiSubjectAlt() throws Exception {
+    // CN=*.foo.com, subjectAlt=*.bar.com, subjectAlt=*.&#x82b1;&#x5b50;.co.jp
+    // (*.hanako.co.jp in kanji)
+    SSLSession session = session(""
+        + "-----BEGIN CERTIFICATE-----\n"
+        + "MIIEcDCCA1igAwIBAgIJAIz+EYMBU6aWMA0GCSqGSIb3DQEBBQUAMIGiMQswCQYD\n"
+        + "VQQGEwJDQTELMAkGA1UECBMCQkMxEjAQBgNVBAcTCVZhbmNvdXZlcjEWMBQGA1UE\n"
+        + "ChMNd3d3LmN1Y2JjLmNvbTEUMBIGA1UECxQLY29tbW9uc19zc2wxHTAbBgNVBAMU\n"
+        + "FGRlbW9faW50ZXJtZWRpYXRlX2NhMSUwIwYJKoZIhvcNAQkBFhZqdWxpdXNkYXZp\n"
+        + "ZXNAZ21haWwuY29tMB4XDTA2MTIxMTE2MTczMVoXDTI4MTEwNTE2MTczMVowgaYx\n"
+        + "CzAJBgNVBAYTAlVTMREwDwYDVQQIEwhNYXJ5bGFuZDEUMBIGA1UEBxMLRm9yZXN0\n"
+        + "IEhpbGwxFzAVBgNVBAoTDmh0dHBjb21wb25lbnRzMRowGAYDVQQLExF0ZXN0IGNl\n"
+        + "cnRpZmljYXRlczESMBAGA1UEAxQJKi5mb28uY29tMSUwIwYJKoZIhvcNAQkBFhZq\n"
+        + "dWxpdXNkYXZpZXNAZ21haWwuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB\n"
+        + "CgKCAQEAyGOvloI+jKnRHWKuhYB+cTIEwZhagKJ0f3rIY8WNgujB7PlpgpjUg4pN\n"
+        + "jYGViGjg7zhfbjhCtlNGXyRBti3GcaHiBIIP5nyCNn+Ay8tSWGo5v5Zc8BQcwHf0\n"
+        + "ZHLN6sD9m2uVSp/6UqjS5ZyhzF5FzvvUo3xw8fecdnStXQfHhkBnLpTjHE5t7iu1\n"
+        + "JVjTuE0pcBvah2dWqDNxiIOQtXyKW8Sag1YxaunxQGqRNykSFiEJindxOSAnAxK6\n"
+        + "q/wGqcZ3zvFBTcVVkji1u2QH4rOMP3PPxAIMkB8ONkdHTco1DmbE6BfDHArDqUYx\n"
+        + "qJUlPGlMqrKb3fCFiT3eXehwR7nlzQIDAQABo4GiMIGfMAkGA1UdEwQCMAAwLAYJ\n"
+        + "YIZIAYb4QgENBB8WHU9wZW5TU0wgR2VuZXJhdGVkIENlcnRpZmljYXRlMB0GA1Ud\n"
+        + "DgQWBBSfFHe/Pzq2yjiCQkgWLNrQy16H2DAfBgNVHSMEGDAWgBR7mtqPkJlOUtKs\n"
+        + "27MDUsqHpg0+DTAkBgNVHREEHTAbggkqLmJhci5jb22CDiou6Iqx5a2QLmNvLmpw\n"
+        + "MA0GCSqGSIb3DQEBBQUAA4IBAQBobWC+D5/lx6YhX64CwZ26XLjxaE0S415ajbBq\n"
+        + "DK7lz+Rg7zOE3GsTAMi+ldUYnhyz0wDiXB8UwKXl0SDToB2Z4GOgqQjAqoMmrP0u\n"
+        + "WB6Y6dpkfd1qDRUzI120zPYgSdsXjHW9q2H77iV238hqIU7qCvEz+lfqqWEY504z\n"
+        + "hYNlknbUnR525ItosEVwXFBJTkZ3Yw8gg02c19yi8TAh5Li3Ad8XQmmSJMWBV4XK\n"
+        + "qFr0AIZKBlg6NZZFf/0dP9zcKhzSriW27bY0XfzA6GSiRDXrDjgXq6baRT6YwgIg\n"
+        + "pgJsDbJtZfHnV1nd3M6zOtQPm1TIQpNmMMMd/DPrGcUQerD3\n"
+        + "-----END CERTIFICATE-----\n");
+    // try the foo.com variations
+    assertTrue(verifier.verify("foo.com", session));
+    assertTrue(verifier.verify("www.foo.com", session));
+    assertTrue(verifier.verify("\u82b1\u5b50.foo.com", session));
+    assertFalse(verifier.verify("a.b.foo.com", session));
+    // these checks test alternative subjects. The test data contains an
+    // alternative subject starting with a japanese kanji character. This is
+    // not supported by Android because the underlying implementation from
+    // harmony follows the definition from rfc 1034 page 10 for alternative
+    // subject names. This causes the code to drop all alternative subjects.
+    // assertFalse(verifier.verify("bar.com", session));
+    // assertTrue(verifier.verify("www.bar.com", session));
+    // assertTrue(verifier.verify("\u82b1\u5b50.bar.com", session));
+    // assertTrue(verifier.verify("a.b.bar.com", session));
+  }
+
+  @Test public void subjectAltUsesLocalDomainAndIp() throws Exception {
+    // cat cert.cnf
+    // [req]
+    // distinguished_name=distinguished_name
+    // req_extensions=req_extensions
+    // x509_extensions=x509_extensions
+    // [distinguished_name]
+    // [req_extensions]
+    // [x509_extensions]
+    // subjectAltName=DNS:localhost.localdomain,DNS:localhost,IP:127.0.0.1
+    //
+    // $ openssl req -x509 -nodes -days 36500 -subj '/CN=localhost' -config ./cert.cnf \
+    //     -newkey rsa:512 -out cert.pem
+    X509Certificate certificate = certificate(""
+        + "-----BEGIN CERTIFICATE-----\n"
+        + "MIIBWDCCAQKgAwIBAgIJANS1EtICX2AZMA0GCSqGSIb3DQEBBQUAMBQxEjAQBgNV\n"
+        + "BAMTCWxvY2FsaG9zdDAgFw0xMjAxMDIxOTA4NThaGA8yMTExMTIwOTE5MDg1OFow\n"
+        + "FDESMBAGA1UEAxMJbG9jYWxob3N0MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAPpt\n"
+        + "atK8r4/hf4hSIs0os/BSlQLbRBaK9AfBReM4QdAklcQqe6CHsStKfI8pp0zs7Ptg\n"
+        + "PmMdpbttL0O7mUboBC8CAwEAAaM1MDMwMQYDVR0RBCowKIIVbG9jYWxob3N0Lmxv\n"
+        + "Y2FsZG9tYWlugglsb2NhbGhvc3SHBH8AAAEwDQYJKoZIhvcNAQEFBQADQQD0ntfL\n"
+        + "DCzOCv9Ma6Lv5o5jcYWVxvBSTsnt22hsJpWD1K7iY9lbkLwl0ivn73pG2evsAn9G\n"
+        + "X8YKH52fnHsCrhSD\n"
+        + "-----END CERTIFICATE-----");
+    assertEquals(new X500Principal("CN=localhost"), certificate.getSubjectX500Principal());
+
+    FakeSSLSession session = new FakeSSLSession(certificate);
+    assertTrue(verifier.verify("localhost", session));
+    assertTrue(verifier.verify("localhost.localdomain", session));
+    assertFalse(verifier.verify("local.host", session));
+
+    assertTrue(verifier.verify("127.0.0.1", session));
+    assertFalse(verifier.verify("127.0.0.2", session));
+  }
+
+  @Test public void wildcardsCannotMatchIpAddresses() throws Exception {
+    // openssl req -x509 -nodes -days 36500 -subj '/CN=*.0.0.1' -newkey rsa:512 -out cert.pem
+    SSLSession session = session(""
+        + "-----BEGIN CERTIFICATE-----\n"
+        + "MIIBkjCCATygAwIBAgIJAMdemqOwd/BEMA0GCSqGSIb3DQEBBQUAMBIxEDAOBgNV\n"
+        + "BAMUByouMC4wLjEwIBcNMTAxMjIwMTY0NDI1WhgPMjExMDExMjYxNjQ0MjVaMBIx\n"
+        + "EDAOBgNVBAMUByouMC4wLjEwXDANBgkqhkiG9w0BAQEFAANLADBIAkEAqY8c9Qrt\n"
+        + "YPWCvb7lclI+aDHM6fgbJcHsS9Zg8nUOh5dWrS7AgeA25wyaokFl4plBbbHQe2j+\n"
+        + "cCjsRiJIcQo9HwIDAQABo3MwcTAdBgNVHQ4EFgQUJ436TZPJvwCBKklZZqIvt1Yt\n"
+        + "JjEwQgYDVR0jBDswOYAUJ436TZPJvwCBKklZZqIvt1YtJjGhFqQUMBIxEDAOBgNV\n"
+        + "BAMUByouMC4wLjGCCQDHXpqjsHfwRDAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEB\n"
+        + "BQUAA0EAk9i88xdjWoewqvE+iMC9tD2obMchgFDaHH0ogxxiRaIKeEly3g0uGxIt\n"
+        + "fl2WRY8hb4x+zRrwsFaLEpdEvqcjOQ==\n"
+        + "-----END CERTIFICATE-----");
+    assertFalse(verifier.verify("127.0.0.1", session));
+  }
+
+  /**
+   * Earlier implementations of Android's hostname verifier required that wildcard names wouldn't
+   * match "*.com" or similar. This was a nonstandard check that we've since dropped. It is the CA's
+   * responsibility to not hand out certificates that match so broadly.
+   */
+  @Test public void wildcardsDoesNotNeedTwoDots() throws Exception {
+    // openssl req -x509 -nodes -days 36500 -subj '/CN=*.com' -newkey rsa:512 -out cert.pem
+    SSLSession session = session(""
+        + "-----BEGIN CERTIFICATE-----\n"
+        + "MIIBjDCCATagAwIBAgIJAOVulXCSu6HuMA0GCSqGSIb3DQEBBQUAMBAxDjAMBgNV\n"
+        + "BAMUBSouY29tMCAXDTEwMTIyMDE2NDkzOFoYDzIxMTAxMTI2MTY0OTM4WjAQMQ4w\n"
+        + "DAYDVQQDFAUqLmNvbTBcMA0GCSqGSIb3DQEBAQUAA0sAMEgCQQDJd8xqni+h7Iaz\n"
+        + "ypItivs9kPuiJUqVz+SuJ1C05SFc3PmlRCvwSIfhyD67fHcbMdl+A/LrIjhhKZJe\n"
+        + "1joO0+pFAgMBAAGjcTBvMB0GA1UdDgQWBBS4Iuzf5w8JdCp+EtBfdFNudf6+YzBA\n"
+        + "BgNVHSMEOTA3gBS4Iuzf5w8JdCp+EtBfdFNudf6+Y6EUpBIwEDEOMAwGA1UEAxQF\n"
+        + "Ki5jb22CCQDlbpVwkruh7jAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEBBQUAA0EA\n"
+        + "U6LFxmZr31lFyis2/T68PpjAppc0DpNQuA2m/Y7oTHBDi55Fw6HVHCw3lucuWZ5d\n"
+        + "qUYo4ES548JdpQtcLrW2sA==\n"
+        + "-----END CERTIFICATE-----");
+    assertTrue(verifier.verify("google.com", session));
+  }
+
+  @Test public void subjectAltName() throws Exception {
+    // $ cat ./cert.cnf
+    // [req]
+    // distinguished_name=distinguished_name
+    // req_extensions=req_extensions
+    // x509_extensions=x509_extensions
+    // [distinguished_name]
+    // [req_extensions]
+    // [x509_extensions]
+    // subjectAltName=DNS:bar.com,DNS:baz.com
+    //
+    // $ openssl req -x509 -nodes -days 36500 -subj '/CN=foo.com' -config ./cert.cnf \
+    //     -newkey rsa:512 -out cert.pem
+    SSLSession session = session(""
+        + "-----BEGIN CERTIFICATE-----\n"
+        + "MIIBPTCB6KADAgECAgkA7zoHaaqNGHQwDQYJKoZIhvcNAQEFBQAwEjEQMA4GA1UE\n"
+        + "AxMHZm9vLmNvbTAgFw0xMDEyMjAxODM5MzZaGA8yMTEwMTEyNjE4MzkzNlowEjEQ\n"
+        + "MA4GA1UEAxMHZm9vLmNvbTBcMA0GCSqGSIb3DQEBAQUAA0sAMEgCQQC+gmoSxF+8\n"
+        + "hbV+rgRQqHIJd50216OWQJbU3BvdlPbca779NYO4+UZWTFdBM8BdQqs3H4B5Agvp\n"
+        + "y7HeSff1F7XRAgMBAAGjHzAdMBsGA1UdEQQUMBKCB2Jhci5jb22CB2Jhei5jb20w\n"
+        + "DQYJKoZIhvcNAQEFBQADQQBXpZZPOY2Dy1lGG81JTr8L4or9jpKacD7n51eS8iqI\n"
+        + "oTznPNuXHU5bFN0AAGX2ij47f/EahqTpo5RdS95P4sVm\n"
+        + "-----END CERTIFICATE-----");
+    assertFalse(verifier.verify("foo.com", session));
+    assertTrue(verifier.verify("bar.com", session));
+    assertTrue(verifier.verify("baz.com", session));
+    assertFalse(verifier.verify("a.foo.com", session));
+    assertFalse(verifier.verify("quux.com", session));
+  }
+
+  @Test public void subjectAltNameWithWildcard() throws Exception {
+    // $ cat ./cert.cnf
+    // [req]
+    // distinguished_name=distinguished_name
+    // req_extensions=req_extensions
+    // x509_extensions=x509_extensions
+    // [distinguished_name]
+    // [req_extensions]
+    // [x509_extensions]
+    // subjectAltName=DNS:bar.com,DNS:*.baz.com
+    //
+    // $ openssl req -x509 -nodes -days 36500 -subj '/CN=foo.com' -config ./cert.cnf \
+    //     -newkey rsa:512 -out cert.pem
+    SSLSession session = session(""
+        + "-----BEGIN CERTIFICATE-----\n"
+        + "MIIBPzCB6qADAgECAgkAnv/7Jv5r7pMwDQYJKoZIhvcNAQEFBQAwEjEQMA4GA1UE\n"
+        + "AxMHZm9vLmNvbTAgFw0xMDEyMjAxODQ2MDFaGA8yMTEwMTEyNjE4NDYwMVowEjEQ\n"
+        + "MA4GA1UEAxMHZm9vLmNvbTBcMA0GCSqGSIb3DQEBAQUAA0sAMEgCQQDAz2YXnyog\n"
+        + "YdYLSFr/OEgSumtwqtZKJTB4wqTW/eKbBCEzxnyUMxWZIqUGu353PzwfOuWp2re3\n"
+        + "nvVV+QDYQlh9AgMBAAGjITAfMB0GA1UdEQQWMBSCB2Jhci5jb22CCSouYmF6LmNv\n"
+        + "bTANBgkqhkiG9w0BAQUFAANBAB8yrSl8zqy07i0SNYx2B/FnvQY734pxioaqFWfO\n"
+        + "Bqo1ZZl/9aPHEWIwBrxYNVB0SGu/kkbt/vxqOjzzrkXukmI=\n"
+        + "-----END CERTIFICATE-----");
+    assertFalse(verifier.verify("foo.com", session));
+    assertTrue(verifier.verify("bar.com", session));
+    assertTrue(verifier.verify("a.baz.com", session));
+    assertFalse(verifier.verify("baz.com", session));
+    assertFalse(verifier.verify("a.foo.com", session));
+    assertFalse(verifier.verify("a.bar.com", session));
+    assertFalse(verifier.verify("quux.com", session));
+  }
+
+  @Test public void verifyAsIpAddress() {
+    // IPv4
+    assertTrue(Util.verifyAsIpAddress("127.0.0.1"));
+    assertTrue(Util.verifyAsIpAddress("1.2.3.4"));
+
+    // IPv6
+    assertTrue(Util.verifyAsIpAddress("::1"));
+    assertTrue(Util.verifyAsIpAddress("2001:db8::1"));
+    assertTrue(Util.verifyAsIpAddress("::192.168.0.1"));
+    assertTrue(Util.verifyAsIpAddress("::ffff:192.168.0.1"));
+    assertTrue(Util.verifyAsIpAddress("FEDC:BA98:7654:3210:FEDC:BA98:7654:3210"));
+    assertTrue(Util.verifyAsIpAddress("1080:0:0:0:8:800:200C:417A"));
+    assertTrue(Util.verifyAsIpAddress("1080::8:800:200C:417A"));
+    assertTrue(Util.verifyAsIpAddress("FF01::101"));
+    assertTrue(Util.verifyAsIpAddress("0:0:0:0:0:0:13.1.68.3"));
+    assertTrue(Util.verifyAsIpAddress("0:0:0:0:0:FFFF:129.144.52.38"));
+    assertTrue(Util.verifyAsIpAddress("::13.1.68.3"));
+    assertTrue(Util.verifyAsIpAddress("::FFFF:129.144.52.38"));
+
+    // Hostnames
+    assertFalse(Util.verifyAsIpAddress("go"));
+    assertFalse(Util.verifyAsIpAddress("localhost"));
+    assertFalse(Util.verifyAsIpAddress("squareup.com"));
+    assertFalse(Util.verifyAsIpAddress("www.nintendo.co.jp"));
+  }
+
+  private X509Certificate certificate(String certificate) throws Exception {
+    return (X509Certificate) CertificateFactory.getInstance("X.509").generateCertificate(
+        new ByteArrayInputStream(certificate.getBytes(Util.UTF_8)));
+  }
+
+  private SSLSession session(String certificate) throws Exception {
+    return new FakeSSLSession(certificate(certificate));
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
new file mode 100644
index 0000000000..af26aa095c
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
@@ -0,0 +1,350 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.ws;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.util.Random;
+import java.util.concurrent.TimeUnit;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okio.ByteString;
+import okio.Okio;
+import okio.Pipe;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class RealWebSocketTest {
+  // NOTE: Fields are named 'client' and 'server' for cognitive simplicity. This differentiation has
+  // zero effect on the behavior of the WebSocket API which is why tests are only written once
+  // from the perspective of a single peer.
+
+  private final Random random = new Random(0);
+  private final Pipe client2Server = new Pipe(1024L);
+  private final Pipe server2client = new Pipe(1024L);
+
+  private TestStreams client = new TestStreams(true, server2client, client2Server);
+  private TestStreams server = new TestStreams(false, client2Server, server2client);
+
+  @Before public void setUp() throws IOException {
+    client.initWebSocket(random, 0);
+    server.initWebSocket(random, 0);
+  }
+
+  @After public void tearDown() throws Exception {
+    client.listener.assertExhausted();
+    server.listener.assertExhausted();
+    server.source.close();
+    client.source.close();
+    server.webSocket.tearDown();
+    client.webSocket.tearDown();
+  }
+
+  @Test public void close() throws IOException {
+    client.webSocket.close(1000, "Hello!");
+    assertFalse(server.processNextFrame()); // This will trigger a close response.
+    server.listener.assertClosing(1000, "Hello!");
+    server.webSocket.close(1000, "Goodbye!");
+    assertFalse(client.processNextFrame());
+    client.listener.assertClosing(1000, "Goodbye!");
+    server.listener.assertClosed(1000, "Hello!");
+    client.listener.assertClosed(1000, "Goodbye!");
+  }
+
+  @Test public void clientCloseThenMethodsReturnFalse() throws IOException {
+    client.webSocket.close(1000, "Hello!");
+
+    assertFalse(client.webSocket.close(1000, "Hello!"));
+    assertFalse(client.webSocket.send("Hello!"));
+  }
+
+  @Test public void clientCloseWith0Fails() throws IOException {
+    try {
+      client.webSocket.close(0, null);
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals(expected.getMessage(), "Code must be in range [1000,5000): 0");
+    }
+  }
+
+  @Test public void afterSocketClosedPingFailsWebSocket() throws IOException {
+    client2Server.source().close();
+    client.webSocket.pong(ByteString.encodeUtf8("Ping!"));
+    client.listener.assertFailure(IOException.class, "source is closed");
+
+    assertFalse(client.webSocket.send("Hello!"));
+  }
+
+  @Test public void socketClosedDuringMessageKillsWebSocket() throws IOException {
+    client2Server.source().close();
+
+    assertTrue(client.webSocket.send("Hello!"));
+    client.listener.assertFailure(IOException.class, "source is closed");
+
+    // A failed write prevents further use of the WebSocket instance.
+    assertFalse(client.webSocket.send("Hello!"));
+    assertFalse(client.webSocket.pong(ByteString.encodeUtf8("Ping!")));
+  }
+
+  @Test public void serverCloseThenWritingPingSucceeds() throws IOException {
+    server.webSocket.close(1000, "Hello!");
+    client.processNextFrame();
+    client.listener.assertClosing(1000, "Hello!");
+
+    assertTrue(client.webSocket.pong(ByteString.encodeUtf8("Pong?")));
+  }
+
+  @Test public void clientCanWriteMessagesAfterServerClose() throws IOException {
+    server.webSocket.close(1000, "Hello!");
+    client.processNextFrame();
+    client.listener.assertClosing(1000, "Hello!");
+
+    assertTrue(client.webSocket.send("Hi!"));
+    server.processNextFrame();
+    server.listener.assertTextMessage("Hi!");
+  }
+
+  @Test public void serverCloseThenClientClose() throws IOException {
+    server.webSocket.close(1000, "Hello!");
+    client.processNextFrame();
+    client.listener.assertClosing(1000, "Hello!");
+    assertTrue(client.webSocket.close(1000, "Bye!"));
+  }
+
+  @Test public void emptyCloseInitiatesShutdown() throws IOException {
+    server.sink.write(ByteString.decodeHex("8800")).emit(); // Close without code.
+    client.processNextFrame();
+    client.listener.assertClosing(1005, "");
+
+    assertTrue(client.webSocket.close(1000, "Bye!"));
+    server.processNextFrame();
+    server.listener.assertClosing(1000, "Bye!");
+
+    client.listener.assertClosed(1005, "");
+  }
+
+  @Test public void clientCloseClosesConnection() throws IOException {
+    client.webSocket.close(1000, "Hello!");
+    assertFalse(client.closed);
+    server.processNextFrame(); // Read client closing, send server close.
+    server.listener.assertClosing(1000, "Hello!");
+
+    server.webSocket.close(1000, "Goodbye!");
+    client.processNextFrame(); // Read server closing, close connection.
+    assertTrue(client.closed);
+    client.listener.assertClosing(1000, "Goodbye!");
+
+    // Server and client both finished closing, connection is closed.
+    server.listener.assertClosed(1000, "Hello!");
+    client.listener.assertClosed(1000, "Goodbye!");
+  }
+
+  @Test public void serverCloseClosesConnection() throws IOException {
+    server.webSocket.close(1000, "Hello!");
+
+    client.processNextFrame(); // Read server close, send client close, close connection.
+    assertFalse(client.closed);
+    client.listener.assertClosing(1000, "Hello!");
+
+    client.webSocket.close(1000, "Hello!");
+    server.processNextFrame();
+    server.listener.assertClosing(1000, "Hello!");
+
+    client.listener.assertClosed(1000, "Hello!");
+    server.listener.assertClosed(1000, "Hello!");
+  }
+
+  @Test public void clientAndServerCloseClosesConnection() throws Exception {
+    // Send close from both sides at the same time.
+    server.webSocket.close(1000, "Hello!");
+    client.processNextFrame(); // Read close, close connection close.
+
+    assertFalse(client.closed);
+    client.webSocket.close(1000, "Hi!");
+    server.processNextFrame();
+
+    client.listener.assertClosing(1000, "Hello!");
+    server.listener.assertClosing(1000, "Hi!");
+    client.listener.assertClosed(1000, "Hello!");
+    server.listener.assertClosed(1000, "Hi!");
+    client.webSocket.awaitTermination(5, TimeUnit.SECONDS);
+    assertTrue(client.closed);
+
+    server.listener.assertExhausted(); // Client should not have sent second close.
+    client.listener.assertExhausted(); // Server should not have sent second close.
+  }
+
+  @Test public void serverCloseBreaksReadMessageLoop() throws IOException {
+    server.webSocket.send("Hello!");
+    server.webSocket.close(1000, "Bye!");
+    assertTrue(client.processNextFrame());
+    client.listener.assertTextMessage("Hello!");
+    assertFalse(client.processNextFrame());
+    client.listener.assertClosing(1000, "Bye!");
+  }
+
+  @Test public void protocolErrorBeforeCloseSendsFailure() throws IOException {
+    server.sink.write(ByteString.decodeHex("0a00")).emit(); // Invalid non-final ping frame.
+
+    client.processNextFrame(); // Detects error, send close, close connection.
+    assertTrue(client.closed);
+    client.listener.assertFailure(ProtocolException.class, "Control frames must be final.");
+
+    server.processNextFrame();
+    server.listener.assertFailure(EOFException.class);
+  }
+
+  @Test public void protocolErrorInCloseResponseClosesConnection() throws IOException {
+    client.webSocket.close(1000, "Hello");
+    server.processNextFrame();
+    assertFalse(client.closed); // Not closed until close reply is received.
+
+    // Manually write an invalid masked close frame.
+    server.sink.write(ByteString.decodeHex("888760b420bb635c68de0cd84f")).emit();
+
+    client.processNextFrame();// Detects error, disconnects immediately since close already sent.
+    assertTrue(client.closed);
+    client.listener.assertFailure(
+        ProtocolException.class, "Server-sent frames must not be masked.");
+
+    server.listener.assertClosing(1000, "Hello");
+    server.listener.assertExhausted(); // Client should not have sent second close.
+  }
+
+  @Test public void protocolErrorAfterCloseDoesNotSendClose() throws IOException {
+    client.webSocket.close(1000, "Hello!");
+    server.processNextFrame();
+
+    assertFalse(client.closed); // Not closed until close reply is received.
+    server.sink.write(ByteString.decodeHex("0a00")).emit(); // Invalid non-final ping frame.
+
+    client.processNextFrame(); // Detects error, disconnects immediately since close already sent.
+    assertTrue(client.closed);
+    client.listener.assertFailure(ProtocolException.class, "Control frames must be final.");
+
+    server.listener.assertClosing(1000, "Hello!");
+
+    server.listener.assertExhausted(); // Client should not have sent second close.
+  }
+
+  @Test public void networkErrorReportedAsFailure() throws IOException {
+    server.sink.close();
+    client.processNextFrame();
+    client.listener.assertFailure(EOFException.class);
+  }
+
+  @Test public void closeThrowingFailsConnection() throws IOException {
+    client2Server.source().close();
+    client.webSocket.close(1000, null);
+    client.listener.assertFailure(IOException.class, "source is closed");
+  }
+
+  @Ignore // TODO(jwilson): come up with a way to test unchecked exceptions on the writer thread.
+  @Test public void closeMessageAndConnectionCloseThrowingDoesNotMaskOriginal() throws IOException {
+    client.sink.close();
+    client.closeThrows = true;
+
+    client.webSocket.close(1000, "Bye!");
+    client.listener.assertFailure(IOException.class, "failure");
+    assertTrue(client.closed);
+  }
+
+  @Ignore // TODO(jwilson): come up with a way to test unchecked exceptions on the writer thread.
+  @Test public void peerConnectionCloseThrowingPropagates() throws IOException {
+    client.closeThrows = true;
+
+    server.webSocket.close(1000, "Bye from Server!");
+    client.processNextFrame();
+    client.listener.assertClosing(1000, "Bye from Server!");
+
+    client.webSocket.close(1000, "Bye from Client!");
+    server.processNextFrame();
+    server.listener.assertClosing(1000, "Bye from Client!");
+  }
+
+  @Test public void pingOnInterval() throws IOException {
+    long startNanos = System.nanoTime();
+    client.initWebSocket(random, 500);
+
+    server.processNextFrame(); // Ping.
+    client.processNextFrame(); // Pong.
+    long elapsedUntilPing1 = System.nanoTime() - startNanos;
+    assertEquals(500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing1), 250d);
+
+    server.processNextFrame(); // Ping.
+    client.processNextFrame(); // Pong.
+    long elapsedUntilPing2 = System.nanoTime() - startNanos;
+    assertEquals(1000, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing2), 250d);
+
+    server.processNextFrame(); // Ping.
+    client.processNextFrame(); // Pong.
+    long elapsedUntilPing3 = System.nanoTime() - startNanos;
+    assertEquals(1500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing3), 250d);
+  }
+
+  /** One peer's streams, listener, and web socket in the test. */
+  private static class TestStreams extends RealWebSocket.Streams {
+    private final String name;
+    private final WebSocketRecorder listener;
+    private RealWebSocket webSocket;
+    boolean closeThrows;
+    boolean closed;
+
+    public TestStreams(boolean client, Pipe source, Pipe sink) {
+      super(client, Okio.buffer(source.source()), Okio.buffer(sink.sink()));
+      this.name = client ? "client" : "server";
+      this.listener = new WebSocketRecorder(name);
+    }
+
+    public void initWebSocket(Random random, int pingIntervalMillis) throws IOException {
+      String url = "http://example.com/websocket";
+      Response response = new Response.Builder()
+          .code(101)
+          .message("OK")
+          .request(new Request.Builder().url(url).build())
+          .protocol(Protocol.HTTP_1_1)
+          .build();
+      webSocket = new RealWebSocket(response.request(), listener, random);
+      webSocket.initReaderAndWriter(name, pingIntervalMillis, this);
+    }
+
+    public boolean processNextFrame() throws IOException {
+      return webSocket.processNextFrame();
+    }
+
+    @Override public void close() throws IOException {
+      source.close();
+      sink.close();
+      if (closed) {
+        throw new AssertionError("Already closed");
+      }
+      closed = true;
+
+      if (closeThrows) {
+        throw new RuntimeException("Oops!");
+      }
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
new file mode 100644
index 0000000000..bb32630f39
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
@@ -0,0 +1,640 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.ws;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.net.SocketTimeoutException;
+import java.util.Collections;
+import java.util.Random;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.logging.Logger;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.RecordingEventListener;
+import okhttp3.RecordingHostnameVerifier;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.TestLogHandler;
+import okhttp3.WebSocket;
+import okhttp3.WebSocketListener;
+import okhttp3.internal.tls.SslClient;
+import okhttp3.mockwebserver.Dispatcher;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.mockwebserver.SocketPolicy;
+import okio.Buffer;
+import okio.ByteString;
+import org.junit.After;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static okhttp3.TestUtil.defaultClient;
+import static okhttp3.TestUtil.repeat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class WebSocketHttpTest {
+  @Rule public final MockWebServer webServer = new MockWebServer();
+
+  private final SslClient sslClient = SslClient.localhost();
+  private final WebSocketRecorder clientListener = new WebSocketRecorder("client");
+  private final WebSocketRecorder serverListener = new WebSocketRecorder("server");
+  private final Random random = new Random(0);
+  private OkHttpClient client = defaultClient().newBuilder()
+      .writeTimeout(500, TimeUnit.MILLISECONDS)
+      .readTimeout(500, TimeUnit.MILLISECONDS)
+      .addInterceptor(new Interceptor() {
+        @Override public Response intercept(Chain chain) throws IOException {
+          Response response = chain.proceed(chain.request());
+          assertNotNull(response.body()); // Ensure application interceptors never see a null body.
+          return response;
+        }
+      })
+      .build();
+
+  @After public void tearDown() {
+    clientListener.assertExhausted();
+  }
+
+  @Test public void textMessage() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    WebSocket webSocket = newWebSocket();
+
+    clientListener.assertOpen();
+    serverListener.assertOpen();
+
+    webSocket.send("Hello, WebSockets!");
+    serverListener.assertTextMessage("Hello, WebSockets!");
+  }
+
+  @Test public void binaryMessage() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    WebSocket webSocket = newWebSocket();
+
+    clientListener.assertOpen();
+    serverListener.assertOpen();
+
+    webSocket.send(ByteString.encodeUtf8("Hello!"));
+    serverListener.assertBinaryMessage(ByteString.of(new byte[] {'H', 'e', 'l', 'l', 'o', '!'}));
+  }
+
+  @Test public void nullStringThrows() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    WebSocket webSocket = newWebSocket();
+
+    clientListener.assertOpen();
+    try {
+      webSocket.send((String) null);
+      fail();
+    } catch (NullPointerException e) {
+      assertEquals("text == null", e.getMessage());
+    }
+  }
+
+  @Test public void nullByteStringThrows() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    WebSocket webSocket = newWebSocket();
+
+    clientListener.assertOpen();
+    try {
+      webSocket.send((ByteString) null);
+      fail();
+    } catch (NullPointerException e) {
+      assertEquals("bytes == null", e.getMessage());
+    }
+  }
+
+  @Test public void serverMessage() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    newWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+
+    server.send("Hello, WebSockets!");
+    clientListener.assertTextMessage("Hello, WebSockets!");
+  }
+
+  @Test public void throwingOnOpenFailsImmediately() {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    final RuntimeException e = new RuntimeException();
+    clientListener.setNextEventDelegate(new WebSocketListener() {
+      @Override public void onOpen(WebSocket webSocket, Response response) {
+        throw e;
+      }
+    });
+    newWebSocket();
+
+    serverListener.assertOpen();
+    serverListener.assertExhausted();
+    clientListener.assertFailure(e);
+  }
+
+  @Ignore("AsyncCall currently lets runtime exceptions propagate.")
+  @Test public void throwingOnFailLogs() throws InterruptedException {
+    TestLogHandler logs = new TestLogHandler();
+    Logger logger = Logger.getLogger(OkHttpClient.class.getName());
+    logger.addHandler(logs);
+
+    webServer.enqueue(new MockResponse().setResponseCode(200).setBody("Body"));
+
+    final RuntimeException e = new RuntimeException();
+    clientListener.setNextEventDelegate(new WebSocketListener() {
+      @Override public void onFailure(WebSocket webSocket, Throwable t, Response response) {
+        throw e;
+      }
+    });
+
+    newWebSocket();
+
+    assertEquals("", logs.take());
+    logger.removeHandler(logs);
+  }
+
+  @Test public void throwingOnMessageClosesImmediatelyAndFails() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    newWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+
+    final RuntimeException e = new RuntimeException();
+    clientListener.setNextEventDelegate(new WebSocketListener() {
+      @Override public void onMessage(WebSocket webSocket, String text) {
+        throw e;
+      }
+    });
+
+    server.send("Hello, WebSockets!");
+    clientListener.assertFailure(e);
+    serverListener.assertFailure(EOFException.class);
+    serverListener.assertExhausted();
+  }
+
+  @Test public void throwingOnClosingClosesImmediatelyAndFails() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    newWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+
+    final RuntimeException e = new RuntimeException();
+    clientListener.setNextEventDelegate(new WebSocketListener() {
+      @Override public void onClosing(WebSocket webSocket, int code, String reason) {
+        throw e;
+      }
+    });
+
+    server.close(1000, "bye");
+    clientListener.assertFailure(e);
+    serverListener.assertFailure();
+    serverListener.assertExhausted();
+  }
+
+  @Test public void non101RetainsBody() throws IOException {
+    webServer.enqueue(new MockResponse().setResponseCode(200).setBody("Body"));
+    newWebSocket();
+
+    clientListener.assertFailure(200, "Body", ProtocolException.class,
+        "Expected HTTP 101 response but was '200 OK'");
+  }
+
+  @Test public void notFound() throws IOException {
+    webServer.enqueue(new MockResponse().setStatus("HTTP/1.1 404 Not Found"));
+    newWebSocket();
+
+    clientListener.assertFailure(404, null, ProtocolException.class,
+        "Expected HTTP 101 response but was '404 Not Found'");
+  }
+
+  @Test public void clientTimeoutClosesBody() throws IOException {
+    webServer.enqueue(new MockResponse().setResponseCode(408));
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    WebSocket webSocket = newWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+
+    webSocket.send("abc");
+    serverListener.assertTextMessage("abc");
+
+    server.send("def");
+    clientListener.assertTextMessage("def");
+  }
+
+  @Test public void missingConnectionHeader() throws IOException {
+    webServer.enqueue(new MockResponse()
+        .setResponseCode(101)
+        .setHeader("Upgrade", "websocket")
+        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
+    newWebSocket();
+
+    clientListener.assertFailure(101, null, ProtocolException.class,
+        "Expected 'Connection' header value 'Upgrade' but was 'null'");
+  }
+
+  @Test public void wrongConnectionHeader() throws IOException {
+    webServer.enqueue(new MockResponse()
+        .setResponseCode(101)
+        .setHeader("Upgrade", "websocket")
+        .setHeader("Connection", "Downgrade")
+        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
+    newWebSocket();
+
+    clientListener.assertFailure(101, null, ProtocolException.class,
+        "Expected 'Connection' header value 'Upgrade' but was 'Downgrade'");
+  }
+
+  @Test public void missingUpgradeHeader() throws IOException {
+    webServer.enqueue(new MockResponse()
+        .setResponseCode(101)
+        .setHeader("Connection", "Upgrade")
+        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
+    newWebSocket();
+
+    clientListener.assertFailure(101, null, ProtocolException.class,
+        "Expected 'Upgrade' header value 'websocket' but was 'null'");
+  }
+
+  @Test public void wrongUpgradeHeader() throws IOException {
+    webServer.enqueue(new MockResponse()
+        .setResponseCode(101)
+        .setHeader("Connection", "Upgrade")
+        .setHeader("Upgrade", "Pepsi")
+        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
+    newWebSocket();
+
+    clientListener.assertFailure(101, null, ProtocolException.class,
+        "Expected 'Upgrade' header value 'websocket' but was 'Pepsi'");
+  }
+
+  @Test public void missingMagicHeader() throws IOException {
+    webServer.enqueue(new MockResponse()
+        .setResponseCode(101)
+        .setHeader("Connection", "Upgrade")
+        .setHeader("Upgrade", "websocket"));
+    newWebSocket();
+
+    clientListener.assertFailure(101, null, ProtocolException.class,
+        "Expected 'Sec-WebSocket-Accept' header value 'ujmZX4KXZqjwy6vi1aQFH5p4Ygk=' but was 'null'");
+  }
+
+  @Test public void wrongMagicHeader() throws IOException {
+    webServer.enqueue(new MockResponse()
+        .setResponseCode(101)
+        .setHeader("Connection", "Upgrade")
+        .setHeader("Upgrade", "websocket")
+        .setHeader("Sec-WebSocket-Accept", "magic"));
+    newWebSocket();
+
+    clientListener.assertFailure(101, null, ProtocolException.class,
+        "Expected 'Sec-WebSocket-Accept' header value 'ujmZX4KXZqjwy6vi1aQFH5p4Ygk=' but was 'magic'");
+  }
+
+  @Test public void webSocketAndApplicationInterceptors() throws IOException {
+    final AtomicInteger interceptedCount = new AtomicInteger();
+
+    client = client.newBuilder()
+        .addInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            assertNull(chain.request().body());
+            Response response = chain.proceed(chain.request());
+            assertEquals("Upgrade", response.header("Connection"));
+            assertTrue(response.body().source().exhausted());
+            interceptedCount.incrementAndGet();
+            return response;
+          }
+        }).build();
+
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    WebSocket webSocket = newWebSocket();
+    clientListener.assertOpen();
+    assertEquals(1, interceptedCount.get());
+    webSocket.close(1000, null);
+
+    WebSocket server = serverListener.assertOpen();
+    server.close(1000, null);
+  }
+
+  @Test public void webSocketAndNetworkInterceptors() throws IOException {
+    client = client.newBuilder()
+        .addNetworkInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            throw new AssertionError(); // Network interceptors don't execute.
+          }
+        }).build();
+
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    WebSocket webSocket = newWebSocket();
+    clientListener.assertOpen();
+    webSocket.close(1000, null);
+
+    WebSocket server = serverListener.assertOpen();
+    server.close(1000, null);
+  }
+
+  @Test public void overflowOutgoingQueue() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    WebSocket webSocket = newWebSocket();
+    clientListener.assertOpen();
+
+    // Send messages until the client's outgoing buffer overflows!
+    ByteString message = ByteString.of(new byte[1024 * 1024]);
+    int messageCount = 0;
+    while (true) {
+      boolean success = webSocket.send(message);
+      if (!success) break;
+
+      messageCount++;
+      long queueSize = webSocket.queueSize();
+      assertTrue(queueSize >= 0 && queueSize <= messageCount * message.size());
+      assertTrue(messageCount < 32); // Expect to fail before enqueueing 32 MiB.
+    }
+
+    // Confirm all sent messages were received, followed by a client-initiated close.
+    WebSocket server = serverListener.assertOpen();
+    for (int i = 0; i < messageCount; i++) {
+      serverListener.assertBinaryMessage(message);
+    }
+    serverListener.assertClosing(1001, "");
+
+    // When the server acknowledges the close the connection shuts down gracefully.
+    server.close(1000, null);
+    clientListener.assertClosing(1000, "");
+    clientListener.assertClosed(1000, "");
+    serverListener.assertClosed(1001, "");
+  }
+
+  @Test public void closeReasonMaximumLength() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    String clientReason = repeat('C', 123);
+    String serverReason = repeat('S', 123);
+
+    WebSocket webSocket = newWebSocket();
+    WebSocket server = serverListener.assertOpen();
+
+    clientListener.assertOpen();
+    webSocket.close(1000, clientReason);
+    serverListener.assertClosing(1000, clientReason);
+
+    server.close(1000, serverReason);
+    clientListener.assertClosing(1000, serverReason);
+    clientListener.assertClosed(1000, serverReason);
+
+    serverListener.assertClosed(1000, clientReason);
+  }
+
+  @Test public void closeReasonTooLong() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    WebSocket webSocket = newWebSocket();
+    WebSocket server = serverListener.assertOpen();
+
+    clientListener.assertOpen();
+    String reason = repeat('X', 124);
+    try {
+      webSocket.close(1000, reason);
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals("reason.size() > 123: " + reason, expected.getMessage());
+    }
+
+    webSocket.close(1000, null);
+    serverListener.assertClosing(1000, "");
+
+    server.close(1000, null);
+    clientListener.assertClosing(1000, "");
+    clientListener.assertClosed(1000, "");
+
+    serverListener.assertClosed(1000, "");
+  }
+
+  @Test public void wsScheme() throws IOException {
+    websocketScheme("ws");
+  }
+
+  @Test public void wsUppercaseScheme() throws IOException {
+    websocketScheme("WS");
+  }
+
+  @Test public void wssScheme() throws IOException {
+    webServer.useHttps(sslClient.socketFactory, false);
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+
+    websocketScheme("wss");
+  }
+
+  @Test public void httpsScheme() throws IOException {
+    webServer.useHttps(sslClient.socketFactory, false);
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+
+    websocketScheme("https");
+  }
+
+  @Test public void readTimeoutAppliesToHttpRequest() throws IOException {
+    webServer.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.NO_RESPONSE));
+
+    WebSocket webSocket = newWebSocket();
+
+    clientListener.assertFailure(SocketTimeoutException.class, "timeout", "Read timed out");
+    assertFalse(webSocket.close(1000, null));
+  }
+
+  /**
+   * There's no read timeout when reading the first byte of a new frame. But as soon as we start
+   * reading a frame we enable the read timeout. In this test we have the server returning the first
+   * byte of a frame but no more frames.
+   */
+  @Test public void readTimeoutAppliesWithinFrames() throws IOException {
+    webServer.setDispatcher(new Dispatcher() {
+      @Override public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
+        return upgradeResponse(request)
+            .setBody(new Buffer().write(ByteString.decodeHex("81"))) // Truncated frame.
+            .removeHeader("Content-Length")
+            .setSocketPolicy(SocketPolicy.KEEP_OPEN);
+      }
+    });
+
+    WebSocket webSocket = newWebSocket();
+    clientListener.assertOpen();
+
+    clientListener.assertFailure(SocketTimeoutException.class, "timeout", "Read timed out");
+    assertFalse(webSocket.close(1000, null));
+  }
+
+  @Test public void readTimeoutDoesNotApplyAcrossFrames() throws Exception {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    newWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+
+    // Sleep longer than the HTTP client's read timeout.
+    Thread.sleep(client.readTimeoutMillis() + 500);
+
+    server.send("abc");
+    clientListener.assertTextMessage("abc");
+  }
+
+  @Test public void clientPingsServerOnInterval() throws Exception {
+    client = client.newBuilder()
+        .pingInterval(500, TimeUnit.MILLISECONDS)
+        .build();
+
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    RealWebSocket webSocket = newWebSocket();
+
+    clientListener.assertOpen();
+    RealWebSocket server = (RealWebSocket) serverListener.assertOpen();
+
+    long startNanos = System.nanoTime();
+    while (webSocket.pongCount() < 3) {
+      Thread.sleep(50);
+    }
+
+    long elapsedUntilPong3 = System.nanoTime() - startNanos;
+    assertEquals(1500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPong3), 250d);
+
+    // The client pinged the server 3 times, and it has ponged back 3 times.
+    assertEquals(3, server.pingCount());
+    assertEquals(3, webSocket.pongCount());
+
+    // The server has never pinged the client.
+    assertEquals(0, server.pongCount());
+    assertEquals(0, webSocket.pingCount());
+  }
+
+  @Test public void clientDoesNotPingServerByDefault() throws Exception {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    RealWebSocket webSocket = newWebSocket();
+
+    clientListener.assertOpen();
+    RealWebSocket server = (RealWebSocket) serverListener.assertOpen();
+
+    Thread.sleep(1000);
+
+    // No pings and no pongs.
+    assertEquals(0, server.pingCount());
+    assertEquals(0, webSocket.pongCount());
+    assertEquals(0, server.pongCount());
+    assertEquals(0, webSocket.pingCount());
+  }
+
+  /** https://github.com/square/okhttp/issues/2788 */
+  @Test public void clientCancelsIfCloseIsNotAcknowledged() throws Exception {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    RealWebSocket webSocket = newWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+
+    // Initiate a close on the client, which will schedule a hard cancel in 500 ms.
+    long closeAtNanos = System.nanoTime();
+    webSocket.close(1000, "goodbye", 500);
+    serverListener.assertClosing(1000, "goodbye");
+
+    // Confirm that the hard cancel occurred after 500 ms.
+    clientListener.assertFailure();
+    long elapsedUntilFailure = System.nanoTime() - closeAtNanos;
+    assertEquals(500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure), 250d);
+
+    // Close the server and confirm it saw what we expected.
+    server.close(1000, null);
+    serverListener.assertClosed(1000, "goodbye");
+  }
+
+  @Test public void webSocketsDontTriggerEventListener() throws IOException {
+    RecordingEventListener listener = new RecordingEventListener();
+
+    client = client.newBuilder()
+        .eventListener(listener)
+        .build();
+
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    WebSocket webSocket = newWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+
+    webSocket.send("Web Sockets and Events?!");
+    serverListener.assertTextMessage("Web Sockets and Events?!");
+
+    webSocket.close(1000, "");
+    serverListener.assertClosing(1000, "");
+
+    server.close(1000, "");
+    clientListener.assertClosing(1000, "");
+    clientListener.assertClosed(1000, "");
+    serverListener.assertClosed(1000, "");
+
+    assertEquals(Collections.emptyList(), listener.recordedEventTypes());
+  }
+
+  private MockResponse upgradeResponse(RecordedRequest request) {
+    String key = request.getHeader("Sec-WebSocket-Key");
+    return new MockResponse()
+        .setStatus("HTTP/1.1 101 Switching Protocols")
+        .setHeader("Connection", "Upgrade")
+        .setHeader("Upgrade", "websocket")
+        .setHeader("Sec-WebSocket-Accept", WebSocketProtocol.acceptHeader(key));
+  }
+
+  private void websocketScheme(String scheme) throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    Request request = new Request.Builder()
+        .url(scheme + "://" + webServer.getHostName() + ":" + webServer.getPort() + "/")
+        .build();
+
+    RealWebSocket webSocket = newWebSocket(request);
+    clientListener.assertOpen();
+    serverListener.assertOpen();
+
+    webSocket.send("abc");
+    serverListener.assertTextMessage("abc");
+  }
+
+  private RealWebSocket newWebSocket() {
+    return newWebSocket(new Request.Builder().get().url(webServer.url("/")).build());
+  }
+
+  private RealWebSocket newWebSocket(Request request) {
+    RealWebSocket webSocket = new RealWebSocket(request, clientListener, random);
+    webSocket.connect(client);
+    return webSocket;
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
new file mode 100644
index 0000000000..21cf06df5d
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
@@ -0,0 +1,317 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.ws;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.util.Random;
+import java.util.regex.Pattern;
+import okhttp3.internal.Util;
+import okio.Buffer;
+import okio.ByteString;
+import org.junit.After;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class WebSocketReaderTest {
+  private final Buffer data = new Buffer();
+  private final WebSocketRecorder callback = new WebSocketRecorder("client");
+  private final Random random = new Random(0);
+
+  // Mutually exclusive. Use the one corresponding to the peer whose behavior you wish to test.
+  final WebSocketReader serverReader = new WebSocketReader(false, data, callback.asFrameCallback());
+  final WebSocketReader clientReader = new WebSocketReader(true, data, callback.asFrameCallback());
+
+  @After public void tearDown() {
+    callback.assertExhausted();
+  }
+
+  @Test public void controlFramesMustBeFinal() throws IOException {
+    data.write(ByteString.decodeHex("0a00")); // Empty ping.
+    try {
+      clientReader.processNextFrame();
+      fail();
+    } catch (ProtocolException e) {
+      assertEquals("Control frames must be final.", e.getMessage());
+    }
+  }
+
+  @Test public void reservedFlagsAreUnsupported() throws IOException {
+    data.write(ByteString.decodeHex("9a00")); // Empty ping, flag 1 set.
+    try {
+      clientReader.processNextFrame();
+      fail();
+    } catch (ProtocolException e) {
+      assertEquals("Reserved flags are unsupported.", e.getMessage());
+    }
+    data.clear();
+    data.write(ByteString.decodeHex("aa00")); // Empty ping, flag 2 set.
+    try {
+      clientReader.processNextFrame();
+      fail();
+    } catch (ProtocolException e) {
+      assertEquals("Reserved flags are unsupported.", e.getMessage());
+    }
+    data.clear();
+    data.write(ByteString.decodeHex("ca00")); // Empty ping, flag 3 set.
+    try {
+      clientReader.processNextFrame();
+      fail();
+    } catch (ProtocolException e) {
+      assertEquals("Reserved flags are unsupported.", e.getMessage());
+    }
+  }
+
+  @Test public void clientSentFramesMustBeMasked() throws IOException {
+    data.write(ByteString.decodeHex("8100"));
+    try {
+      serverReader.processNextFrame();
+      fail();
+    } catch (ProtocolException e) {
+      assertEquals("Client-sent frames must be masked.", e.getMessage());
+    }
+  }
+
+  @Test public void serverSentFramesMustNotBeMasked() throws IOException {
+    data.write(ByteString.decodeHex("8180"));
+    try {
+      clientReader.processNextFrame();
+      fail();
+    } catch (ProtocolException e) {
+      assertEquals("Server-sent frames must not be masked.", e.getMessage());
+    }
+  }
+
+  @Test public void controlFramePayloadMax() throws IOException {
+    data.write(ByteString.decodeHex("8a7e007e"));
+    try {
+      clientReader.processNextFrame();
+      fail();
+    } catch (ProtocolException e) {
+      assertEquals("Control frame must be less than 125B.", e.getMessage());
+    }
+  }
+
+  @Test public void clientSimpleHello() throws IOException {
+    data.write(ByteString.decodeHex("810548656c6c6f")); // Hello
+    clientReader.processNextFrame();
+    callback.assertTextMessage("Hello");
+  }
+
+  @Test public void serverSimpleHello() throws IOException {
+    data.write(ByteString.decodeHex("818537fa213d7f9f4d5158")); // Hello
+    serverReader.processNextFrame();
+    callback.assertTextMessage("Hello");
+  }
+
+  @Test public void clientFramePayloadShort() throws IOException {
+    data.write(ByteString.decodeHex("817E000548656c6c6f")); // Hello
+    clientReader.processNextFrame();
+    callback.assertTextMessage("Hello");
+  }
+
+  @Test public void clientFramePayloadLong() throws IOException {
+    data.write(ByteString.decodeHex("817f000000000000000548656c6c6f")); // Hello
+    clientReader.processNextFrame();
+    callback.assertTextMessage("Hello");
+  }
+
+  @Test public void clientFramePayloadTooLongThrows() throws IOException {
+    data.write(ByteString.decodeHex("817f8000000000000000"));
+    try {
+      clientReader.processNextFrame();
+      fail();
+    } catch (ProtocolException e) {
+      assertEquals("Frame length 0x8000000000000000 > 0x7FFFFFFFFFFFFFFF", e.getMessage());
+    }
+  }
+
+  @Test public void serverHelloTwoChunks() throws IOException {
+    data.write(ByteString.decodeHex("818537fa213d7f9f4d")); // Hel
+    data.write(ByteString.decodeHex("5158")); // lo
+
+    serverReader.processNextFrame();
+
+    callback.assertTextMessage("Hello");
+  }
+
+  @Test public void clientTwoFrameHello() throws IOException {
+    data.write(ByteString.decodeHex("010348656c")); // Hel
+    data.write(ByteString.decodeHex("80026c6f")); // lo
+    clientReader.processNextFrame();
+    callback.assertTextMessage("Hello");
+  }
+
+  @Test public void clientTwoFrameHelloWithPongs() throws IOException {
+    data.write(ByteString.decodeHex("010348656c")); // Hel
+    data.write(ByteString.decodeHex("8a00")); // Pong
+    data.write(ByteString.decodeHex("8a00")); // Pong
+    data.write(ByteString.decodeHex("8a00")); // Pong
+    data.write(ByteString.decodeHex("8a00")); // Pong
+    data.write(ByteString.decodeHex("80026c6f")); // lo
+    clientReader.processNextFrame();
+    callback.assertPong(ByteString.EMPTY);
+    callback.assertPong(ByteString.EMPTY);
+    callback.assertPong(ByteString.EMPTY);
+    callback.assertPong(ByteString.EMPTY);
+    callback.assertTextMessage("Hello");
+  }
+
+  @Test public void clientIncompleteMessageBodyThrows() throws IOException {
+    data.write(ByteString.decodeHex("810548656c")); // Length = 5, "Hel"
+    try {
+      clientReader.processNextFrame();
+      fail();
+    } catch (EOFException ignored) {
+    }
+  }
+
+  @Test public void clientIncompleteControlFrameBodyThrows() throws IOException {
+    data.write(ByteString.decodeHex("8a0548656c")); // Length = 5, "Hel"
+    try {
+      clientReader.processNextFrame();
+      fail();
+    } catch (EOFException ignored) {
+    }
+  }
+
+  @Test public void serverIncompleteMessageBodyThrows() throws IOException {
+    data.write(ByteString.decodeHex("818537fa213d7f9f4d")); // Length = 5, "Hel"
+    try {
+      serverReader.processNextFrame();
+      fail();
+    } catch (EOFException ignored) {
+    }
+  }
+
+  @Test public void serverIncompleteControlFrameBodyThrows() throws IOException {
+    data.write(ByteString.decodeHex("8a8537fa213d7f9f4d")); // Length = 5, "Hel"
+    try {
+      serverReader.processNextFrame();
+      fail();
+    } catch (EOFException ignored) {
+    }
+  }
+
+  @Test public void clientSimpleBinary() throws IOException {
+    byte[] bytes = binaryData(256);
+    data.write(ByteString.decodeHex("827E0100")).write(bytes);
+    clientReader.processNextFrame();
+    callback.assertBinaryMessage(ByteString.of(bytes));
+  }
+
+  @Test public void clientTwoFrameBinary() throws IOException {
+    byte[] bytes = binaryData(200);
+    data.write(ByteString.decodeHex("0264")).write(bytes, 0, 100);
+    data.write(ByteString.decodeHex("8064")).write(bytes, 100, 100);
+    clientReader.processNextFrame();
+    callback.assertBinaryMessage(ByteString.of(bytes));
+  }
+
+  @Test public void twoFrameNotContinuation() throws IOException {
+    byte[] bytes = binaryData(200);
+    data.write(ByteString.decodeHex("0264")).write(bytes, 0, 100);
+    data.write(ByteString.decodeHex("8264")).write(bytes, 100, 100);
+    try {
+      clientReader.processNextFrame();
+      fail();
+    } catch (ProtocolException e) {
+      assertEquals("Expected continuation opcode. Got: 2", e.getMessage());
+    }
+  }
+
+  @Test public void emptyPingCallsCallback() throws IOException {
+    data.write(ByteString.decodeHex("8900")); // Empty ping
+    clientReader.processNextFrame();
+    callback.assertPing(ByteString.EMPTY);
+  }
+
+  @Test public void pingCallsCallback() throws IOException {
+    data.write(ByteString.decodeHex("890548656c6c6f")); // Ping with "Hello"
+    clientReader.processNextFrame();
+    callback.assertPing(ByteString.encodeUtf8("Hello"));
+  }
+
+  @Test public void emptyCloseCallsCallback() throws IOException {
+    data.write(ByteString.decodeHex("8800")); // Empty close
+    clientReader.processNextFrame();
+    callback.assertClosing(1005, "");
+  }
+
+  @Test public void closeLengthOfOneThrows() throws IOException {
+    data.write(ByteString.decodeHex("880100")); // Close with invalid 1-byte payload
+    try {
+      clientReader.processNextFrame();
+      fail();
+    } catch (ProtocolException e) {
+      assertEquals("Malformed close payload length of 1.", e.getMessage());
+    }
+  }
+
+  @Test public void closeCallsCallback() throws IOException {
+    data.write(ByteString.decodeHex("880703e848656c6c6f")); // Close with code and reason
+    clientReader.processNextFrame();
+    callback.assertClosing(1000, "Hello");
+  }
+
+  @Test public void closeOutOfRangeThrows() throws IOException {
+    data.write(ByteString.decodeHex("88020001")); // Close with code 1
+    try {
+      clientReader.processNextFrame();
+      fail();
+    } catch (ProtocolException e) {
+      assertEquals("Code must be in range [1000,5000): 1", e.getMessage());
+    }
+    data.write(ByteString.decodeHex("88021388")); // Close with code 5000
+    try {
+      clientReader.processNextFrame();
+      fail();
+    } catch (ProtocolException e) {
+      assertEquals("Code must be in range [1000,5000): 5000", e.getMessage());
+    }
+  }
+
+  @Test public void closeReservedSetThrows() throws IOException {
+    data.write(ByteString.decodeHex("880203ec")); // Close with code 1004
+    data.write(ByteString.decodeHex("880203ed")); // Close with code 1005
+    data.write(ByteString.decodeHex("880203ee")); // Close with code 1006
+    for (int i = 1012; i <= 2999; i++) {
+      data.write(ByteString.decodeHex("8802" + Util.format("%04X", i))); // Close with code 'i'
+    }
+
+    int count = 0;
+    for (; !data.exhausted(); count++) {
+      try {
+        clientReader.processNextFrame();
+        fail();
+      } catch (ProtocolException e) {
+        String message = e.getMessage();
+        assertTrue(message, Pattern.matches("Code \\d+ is reserved and may not be used.", message));
+      }
+    }
+    assertEquals(1991, count);
+  }
+
+  private byte[] binaryData(int length) {
+    byte[] junk = new byte[length];
+    random.nextBytes(junk);
+    return junk;
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
new file mode 100644
index 0000000000..f6256ac42f
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
@@ -0,0 +1,406 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.ws;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
+import okhttp3.Response;
+import okhttp3.WebSocket;
+import okhttp3.WebSocketListener;
+import okhttp3.internal.Util;
+import okhttp3.internal.platform.Platform;
+import okio.ByteString;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+
+public final class WebSocketRecorder extends WebSocketListener {
+  private final String name;
+  private final BlockingQueue<Object> events = new LinkedBlockingQueue<>();
+  private WebSocketListener delegate;
+
+  public WebSocketRecorder(String name) {
+    this.name = name;
+  }
+
+  /** Sets a delegate for handling the next callback to this listener. Cleared after invoked. */
+  public void setNextEventDelegate(WebSocketListener delegate) {
+    this.delegate = delegate;
+  }
+
+  @Override public void onOpen(WebSocket webSocket, Response response) {
+    Platform.get().log(Platform.INFO, "[WS " + name + "] onOpen", null);
+
+    WebSocketListener delegate = this.delegate;
+    if (delegate != null) {
+      this.delegate = null;
+      delegate.onOpen(webSocket, response);
+    } else {
+      events.add(new Open(webSocket, response));
+    }
+  }
+
+  @Override public void onMessage(WebSocket webSocket, ByteString bytes) {
+    Platform.get().log(Platform.INFO, "[WS " + name + "] onMessage", null);
+
+    WebSocketListener delegate = this.delegate;
+    if (delegate != null) {
+      this.delegate = null;
+      delegate.onMessage(webSocket, bytes);
+    } else {
+      Message event = new Message(bytes);
+      events.add(event);
+    }
+  }
+
+  @Override public void onMessage(WebSocket webSocket, String text) {
+    Platform.get().log(Platform.INFO, "[WS " + name + "] onMessage", null);
+
+    WebSocketListener delegate = this.delegate;
+    if (delegate != null) {
+      this.delegate = null;
+      delegate.onMessage(webSocket, text);
+    } else {
+      Message event = new Message(text);
+      events.add(event);
+    }
+  }
+
+  @Override public void onClosing(WebSocket webSocket, int code, String reason) {
+    Platform.get().log(Platform.INFO, "[WS " + name + "] onClose " + code, null);
+
+    WebSocketListener delegate = this.delegate;
+    if (delegate != null) {
+      this.delegate = null;
+      delegate.onClosing(webSocket, code, reason);
+    } else {
+      events.add(new Closing(code, reason));
+    }
+  }
+
+  @Override public void onClosed(WebSocket webSocket, int code, String reason) {
+    Platform.get().log(Platform.INFO, "[WS " + name + "] onClose " + code, null);
+
+    WebSocketListener delegate = this.delegate;
+    if (delegate != null) {
+      this.delegate = null;
+      delegate.onClosed(webSocket, code, reason);
+    } else {
+      events.add(new Closed(code, reason));
+    }
+  }
+
+  @Override public void onFailure(WebSocket webSocket, Throwable t, @Nullable Response response)  {
+    Platform.get().log(Platform.INFO, "[WS " + name + "] onFailure", t);
+
+    WebSocketListener delegate = this.delegate;
+    if (delegate != null) {
+      this.delegate = null;
+      delegate.onFailure(webSocket, t, response);
+    } else {
+      events.add(new Failure(t, response));
+    }
+  }
+
+  private Object nextEvent() {
+    try {
+      Object event = events.poll(10, TimeUnit.SECONDS);
+      if (event == null) {
+        throw new AssertionError("Timed out waiting for event.");
+      }
+      return event;
+    } catch (InterruptedException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  public void assertTextMessage(String payload) {
+    Object actual = nextEvent();
+    assertEquals(new Message(payload), actual);
+  }
+
+  public void assertBinaryMessage(ByteString payload) {
+    Object actual = nextEvent();
+    assertEquals(new Message(payload), actual);
+  }
+
+  public void assertPing(ByteString payload) {
+    Object actual = nextEvent();
+    assertEquals(new Ping(payload), actual);
+  }
+
+  public void assertPong(ByteString payload) {
+    Object actual = nextEvent();
+    assertEquals(new Pong(payload), actual);
+  }
+
+  public void assertClosing(int code, String reason) {
+    Object actual = nextEvent();
+    assertEquals(new Closing(code, reason), actual);
+  }
+
+  public void assertClosed(int code, String reason) {
+    Object actual = nextEvent();
+    assertEquals(new Closed(code, reason), actual);
+  }
+
+  public void assertExhausted() {
+    assertTrue("Remaining events: " + events, events.isEmpty());
+  }
+
+  public WebSocket assertOpen() {
+    Object event = nextEvent();
+    if (!(event instanceof Open)) {
+      throw new AssertionError("Expected Open but was " + event);
+    }
+    return ((Open) event).webSocket;
+  }
+
+  public void assertFailure(Throwable t) {
+    Object event = nextEvent();
+    if (!(event instanceof Failure)) {
+      throw new AssertionError("Expected Failure but was " + event);
+    }
+    Failure failure = (Failure) event;
+    assertNull(failure.response);
+    assertSame(t, failure.t);
+  }
+
+  public void assertFailure(Class<? extends IOException> cls, String... messages) {
+    Object event = nextEvent();
+    if (!(event instanceof Failure)) {
+      throw new AssertionError("Expected Failure but was " + event);
+    }
+    Failure failure = (Failure) event;
+    assertNull(failure.response);
+    assertEquals(cls, failure.t.getClass());
+    if (messages.length > 0) {
+      assertTrue(failure.t.getMessage(), Arrays.asList(messages).contains(failure.t.getMessage()));
+    }
+  }
+
+  public void assertFailure() {
+    Object event = nextEvent();
+    if (!(event instanceof Failure)) {
+      throw new AssertionError("Expected Failure but was " + event);
+    }
+  }
+
+  public void assertFailure(int code, String body, Class<? extends IOException> cls, String message)
+      throws IOException {
+    Object event = nextEvent();
+    if (!(event instanceof Failure)) {
+      throw new AssertionError("Expected Failure but was " + event);
+    }
+    Failure failure = (Failure) event;
+    assertEquals(code, failure.response.code());
+    if (body != null) {
+      assertEquals(body, failure.responseBody);
+    }
+    assertEquals(cls, failure.t.getClass());
+    assertEquals(message, failure.t.getMessage());
+  }
+
+  /** Expose this recorder as a frame callback and shim in "ping" events. */
+  public WebSocketReader.FrameCallback asFrameCallback() {
+    return new WebSocketReader.FrameCallback() {
+      @Override public void onReadMessage(String text) throws IOException {
+        onMessage(null, text);
+      }
+
+      @Override public void onReadMessage(ByteString bytes) throws IOException {
+        onMessage(null, bytes);
+      }
+
+      @Override public void onReadPing(ByteString payload) {
+        events.add(new Ping(payload));
+      }
+
+      @Override public void onReadPong(ByteString payload) {
+        events.add(new Pong(payload));
+      }
+
+      @Override public void onReadClose(int code, String reason) {
+        onClosing(null, code, reason);
+      }
+    };
+  }
+
+  static final class Open {
+    final WebSocket webSocket;
+    final Response response;
+
+    Open(WebSocket webSocket, Response response) {
+      this.webSocket = webSocket;
+      this.response = response;
+    }
+
+    @Override public String toString() {
+      return "Open[" + response + "]";
+    }
+  }
+
+  static final class Failure {
+    final Throwable t;
+    final Response response;
+    final String responseBody;
+
+    Failure(Throwable t, Response response) {
+      this.t = t;
+      this.response = response;
+      String responseBody = null;
+      if (response != null) {
+        try {
+          responseBody = response.body().string();
+        } catch (IOException ignored) {
+        }
+      }
+      this.responseBody = responseBody;
+    }
+
+    @Override public String toString() {
+      if (response == null) {
+        return "Failure[" + t + "]";
+      }
+      return "Failure[" + response + "]";
+    }
+  }
+
+  static final class Message {
+    public final ByteString bytes;
+    public final String string;
+
+    public Message(ByteString bytes) {
+      this.bytes = bytes;
+      this.string = null;
+    }
+
+    public Message(String string) {
+      this.bytes = null;
+      this.string = string;
+    }
+
+    @Override public String toString() {
+      return "Message[" + (bytes != null ? bytes : string) + "]";
+    }
+
+    @Override public int hashCode() {
+      return (bytes != null ? bytes : string).hashCode();
+    }
+
+    @Override public boolean equals(Object other) {
+      return other instanceof Message
+          && Util.equal(((Message) other).bytes, bytes)
+          && Util.equal(((Message) other).string, string);
+    }
+  }
+
+  static final class Ping {
+    public final ByteString payload;
+
+    public Ping(ByteString payload) {
+      this.payload = payload;
+    }
+
+    @Override public String toString() {
+      return "Ping[" + payload + "]";
+    }
+
+    @Override public int hashCode() {
+      return payload.hashCode();
+    }
+
+    @Override public boolean equals(Object other) {
+      return other instanceof Ping
+          && ((Ping) other).payload.equals(payload);
+    }
+  }
+
+  static final class Pong {
+    public final ByteString payload;
+
+    public Pong(ByteString payload) {
+      this.payload = payload;
+    }
+
+    @Override public String toString() {
+      return "Pong[" + payload + "]";
+    }
+
+    @Override public int hashCode() {
+      return payload.hashCode();
+    }
+
+    @Override public boolean equals(Object other) {
+      return other instanceof Pong
+          && ((Pong) other).payload.equals(payload);
+    }
+  }
+
+  static final class Closing {
+    public final int code;
+    public final String reason;
+
+    Closing(int code, String reason) {
+      this.code = code;
+      this.reason = reason;
+    }
+
+    @Override public String toString() {
+      return "Closing[" + code + " " + reason + "]";
+    }
+
+    @Override public int hashCode() {
+      return code * 37 + reason.hashCode();
+    }
+
+    @Override public boolean equals(Object other) {
+      return other instanceof Closing
+          && ((Closing) other).code == code
+          && ((Closing) other).reason.equals(reason);
+    }
+  }
+
+  static final class Closed {
+    public final int code;
+    public final String reason;
+
+    Closed(int code, String reason) {
+      this.code = code;
+      this.reason = reason;
+    }
+
+    @Override public String toString() {
+      return "Closed[" + code + " " + reason + "]";
+    }
+
+    @Override public int hashCode() {
+      return code * 37 + reason.hashCode();
+    }
+
+    @Override public boolean equals(Object other) {
+      return other instanceof Closed
+          && ((Closed) other).code == code
+          && ((Closed) other).reason.equals(reason);
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
new file mode 100644
index 0000000000..a303cc1052
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
@@ -0,0 +1,408 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.ws;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.util.Random;
+import okhttp3.RequestBody;
+import okhttp3.internal.Util;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.ByteString;
+import okio.Okio;
+import okio.Sink;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+import static okhttp3.TestUtil.repeat;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_BINARY;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_TEXT;
+import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_BYTE_MAX;
+import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_SHORT_MAX;
+import static okhttp3.internal.ws.WebSocketProtocol.toggleMask;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class WebSocketWriterTest {
+  private final Buffer data = new Buffer();
+  private final Random random = new Random(0);
+
+  /**
+   * Check all data as verified inside of the test. We do this in a rule instead of @After so that
+   * exceptions thrown from the test do not cause this check to fail.
+   */
+  @Rule public final TestRule noDataLeftBehind = new TestRule() {
+    @Override public Statement apply(final Statement base, Description description) {
+      return new Statement() {
+        @Override public void evaluate() throws Throwable {
+          base.evaluate();
+          assertEquals("Data not empty", "", data.readByteString().hex());
+        }
+      };
+    }
+  };
+
+  // Mutually exclusive. Use the one corresponding to the peer whose behavior you wish to test.
+  private final WebSocketWriter serverWriter = new WebSocketWriter(false, data, random);
+  private final WebSocketWriter clientWriter = new WebSocketWriter(true, data, random);
+
+  @Test public void serverTextMessage() throws IOException {
+    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT, -1));
+
+    sink.writeUtf8("Hel").flush();
+    assertData("010348656c");
+
+    sink.writeUtf8("lo").flush();
+    assertData("00026c6f");
+
+    sink.close();
+    assertData("8000");
+  }
+
+  @Test public void serverSmallBufferedPayloadWrittenAsOneFrame() throws IOException {
+    int length = 5;
+    byte[] bytes = binaryData(length);
+
+    RequestBody body = RequestBody.create(null, bytes);
+    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT, length));
+    body.writeTo(sink);
+    sink.close();
+
+    assertData("8105");
+    assertData(bytes);
+    assertTrue(data.exhausted());
+  }
+
+  @Test public void serverLargeBufferedPayloadWrittenAsOneFrame() throws IOException {
+    int length = 12345;
+    byte[] bytes = binaryData(length);
+
+    RequestBody body = RequestBody.create(null, bytes);
+    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT, length));
+    body.writeTo(sink);
+    sink.close();
+
+    assertData("817e");
+    assertData(Util.format("%04x", length));
+    assertData(bytes);
+    assertTrue(data.exhausted());
+  }
+
+  @Test public void serverLargeNonBufferedPayloadWrittenAsMultipleFrames() throws IOException {
+    int length = 100_000;
+    Buffer bytes = new Buffer().write(binaryData(length));
+
+    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT, length));
+    Buffer body = bytes.clone();
+    sink.write(body.readByteString(20_000));
+    sink.write(body.readByteString(20_000));
+    sink.write(body.readByteString(20_000));
+    sink.write(body.readByteString(20_000));
+    sink.write(body.readByteString(20_000));
+    sink.close();
+
+    assertData("017e4000");
+    assertData(bytes.readByteArray(16_384));
+    assertData("007e4000");
+    assertData(bytes.readByteArray(16_384));
+    assertData("007e6000");
+    assertData(bytes.readByteArray(24_576));
+    assertData("007e4000");
+    assertData(bytes.readByteArray(16_384));
+    assertData("007e6000");
+    assertData(bytes.readByteArray(24_576));
+    assertData("807e06a0");
+    assertData(bytes.readByteArray(1_696));
+    assertTrue(data.exhausted());
+  }
+
+  @Test public void closeFlushes() throws IOException {
+    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT, -1));
+
+    sink.writeUtf8("Hel").flush();
+    assertData("010348656c");
+
+    sink.writeUtf8("lo").close();
+    assertData("80026c6f");
+  }
+
+  @Test public void noWritesAfterClose() throws IOException {
+    Sink sink = serverWriter.newMessageSink(OPCODE_TEXT, -1);
+
+    sink.close();
+    assertData("8100");
+
+    Buffer payload = new Buffer().writeUtf8("Hello");
+    try {
+      // Write to the unbuffered sink as BufferedSink keeps its own closed state.
+      sink.write(payload, payload.size());
+      fail();
+    } catch (IOException e) {
+      assertEquals("closed", e.getMessage());
+    }
+  }
+
+  @Test public void clientTextMessage() throws IOException {
+    BufferedSink sink = Okio.buffer(clientWriter.newMessageSink(OPCODE_TEXT, -1));
+
+    sink.writeUtf8("Hel").flush();
+    assertData("018360b420bb28d14c");
+
+    sink.writeUtf8("lo").flush();
+    assertData("00823851d9d4543e");
+
+    sink.close();
+    assertData("80807acb933d");
+  }
+
+  @Test public void serverBinaryMessage() throws IOException {
+    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_BINARY, -1));
+
+    sink.write(binaryData(50)).flush();
+    assertData("0232");
+    assertData(binaryData(50));
+
+    sink.write(binaryData(50)).flush();
+    assertData("0032");
+    assertData(binaryData(50));
+
+    sink.close();
+    assertData("8000");
+  }
+
+  @Test public void serverMessageLengthShort() throws IOException {
+    Sink sink = serverWriter.newMessageSink(OPCODE_BINARY, -1);
+
+    // Create a payload which will overflow the normal payload byte size.
+    Buffer payload = new Buffer();
+    while (payload.completeSegmentByteCount() <= PAYLOAD_BYTE_MAX) {
+      payload.writeByte('0');
+    }
+    long byteCount = payload.completeSegmentByteCount();
+
+    // Write directly to the unbuffered sink. This ensures it will become single frame.
+    sink.write(payload.clone(), byteCount);
+    assertData("027e"); // 'e' == 4-byte follow-up length.
+    assertData(Util.format("%04X", payload.completeSegmentByteCount()));
+    assertData(payload.readByteArray());
+
+    sink.close();
+    assertData("8000");
+  }
+
+  @Test public void serverMessageLengthLong() throws IOException {
+    Sink sink = serverWriter.newMessageSink(OPCODE_BINARY, -1);
+
+    // Create a payload which will overflow the normal and short payload byte size.
+    Buffer payload = new Buffer();
+    while (payload.completeSegmentByteCount() <= PAYLOAD_SHORT_MAX) {
+      payload.writeByte('0');
+    }
+    long byteCount = payload.completeSegmentByteCount();
+
+    // Write directly to the unbuffered sink. This ensures it will become single frame.
+    sink.write(payload.clone(), byteCount);
+    assertData("027f"); // 'f' == 16-byte follow-up length.
+    assertData(Util.format("%016X", byteCount));
+    assertData(payload.readByteArray(byteCount));
+
+    sink.close();
+    assertData("8000");
+  }
+
+  @Test public void clientBinary() throws IOException {
+    byte[] maskKey1 = new byte[4];
+    random.nextBytes(maskKey1);
+    byte[] maskKey2 = new byte[4];
+    random.nextBytes(maskKey2);
+
+    random.setSeed(0); // Reset the seed so real data matches.
+
+    BufferedSink sink = Okio.buffer(clientWriter.newMessageSink(OPCODE_BINARY, -1));
+
+    byte[] part1 = binaryData(50);
+    sink.write(part1).flush();
+    toggleMask(part1, 50, maskKey1, 0);
+    assertData("02b2");
+    assertData(maskKey1);
+    assertData(part1);
+
+    byte[] part2 = binaryData(50);
+    sink.write(part2).close();
+    toggleMask(part2, 50, maskKey2, 0);
+    assertData("80b2");
+    assertData(maskKey2);
+    assertData(part2);
+  }
+
+  @Test public void serverEmptyClose() throws IOException {
+    serverWriter.writeClose(0, null);
+    assertData("8800");
+  }
+
+  @Test public void serverCloseWithCode() throws IOException {
+    serverWriter.writeClose(1001, null);
+    assertData("880203e9");
+  }
+
+  @Test public void serverCloseWithCodeAndReason() throws IOException {
+    serverWriter.writeClose(1001, ByteString.encodeUtf8("Hello"));
+    assertData("880703e948656c6c6f");
+  }
+
+  @Test public void clientEmptyClose() throws IOException {
+    clientWriter.writeClose(0, null);
+    assertData("888060b420bb");
+  }
+
+  @Test public void clientCloseWithCode() throws IOException {
+    clientWriter.writeClose(1001, null);
+    assertData("888260b420bb635d");
+  }
+
+  @Test public void clientCloseWithCodeAndReason() throws IOException {
+    clientWriter.writeClose(1001, ByteString.encodeUtf8("Hello"));
+    assertData("888760b420bb635d68de0cd84f");
+  }
+
+  @Test public void closeWithOnlyReasonThrows() throws IOException {
+    clientWriter.writeClose(0, ByteString.encodeUtf8("Hello"));
+    assertData("888760b420bb60b468de0cd84f");
+  }
+
+  @Test public void closeCodeOutOfRangeThrows() throws IOException {
+    try {
+      clientWriter.writeClose(98724976, ByteString.encodeUtf8("Hello"));
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("Code must be in range [1000,5000): 98724976", e.getMessage());
+    }
+  }
+
+  @Test public void closeReservedThrows() throws IOException {
+    try {
+      clientWriter.writeClose(1005, ByteString.encodeUtf8("Hello"));
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("Code 1005 is reserved and may not be used.", e.getMessage());
+    }
+  }
+
+  @Test public void serverEmptyPing() throws IOException {
+    serverWriter.writePing(ByteString.EMPTY);
+    assertData("8900");
+  }
+
+  @Test public void clientEmptyPing() throws IOException {
+    clientWriter.writePing(ByteString.EMPTY);
+    assertData("898060b420bb");
+  }
+
+  @Test public void serverPingWithPayload() throws IOException {
+    serverWriter.writePing(ByteString.encodeUtf8("Hello"));
+    assertData("890548656c6c6f");
+  }
+
+  @Test public void clientPingWithPayload() throws IOException {
+    clientWriter.writePing(ByteString.encodeUtf8("Hello"));
+    assertData("898560b420bb28d14cd70f");
+  }
+
+  @Test public void serverEmptyPong() throws IOException {
+    serverWriter.writePong(ByteString.EMPTY);
+    assertData("8a00");
+  }
+
+  @Test public void clientEmptyPong() throws IOException {
+    clientWriter.writePong(ByteString.EMPTY);
+    assertData("8a8060b420bb");
+  }
+
+  @Test public void serverPongWithPayload() throws IOException {
+    serverWriter.writePong(ByteString.encodeUtf8("Hello"));
+    assertData("8a0548656c6c6f");
+  }
+
+  @Test public void clientPongWithPayload() throws IOException {
+    clientWriter.writePong(ByteString.encodeUtf8("Hello"));
+    assertData("8a8560b420bb28d14cd70f");
+  }
+
+  @Test public void pingTooLongThrows() throws IOException {
+    try {
+      serverWriter.writePing(ByteString.of(binaryData(1000)));
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("Payload size must be less than or equal to 125", e.getMessage());
+    }
+  }
+
+  @Test public void pongTooLongThrows() throws IOException {
+    try {
+      serverWriter.writePong(ByteString.of(binaryData(1000)));
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("Payload size must be less than or equal to 125", e.getMessage());
+    }
+  }
+
+  @Test public void closeTooLongThrows() throws IOException {
+    try {
+      ByteString longReason = ByteString.encodeUtf8(repeat('X', 124));
+      serverWriter.writeClose(1000, longReason);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("Payload size must be less than or equal to 125", e.getMessage());
+    }
+  }
+
+  @Test public void twoMessageSinksThrows() {
+    clientWriter.newMessageSink(OPCODE_TEXT, -1);
+    try {
+      clientWriter.newMessageSink(OPCODE_TEXT, -1);
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals("Another message writer is active. Did you call close()?", e.getMessage());
+    }
+  }
+
+  private void assertData(String hex) throws EOFException {
+    ByteString expected = ByteString.decodeHex(hex);
+    ByteString actual = data.readByteString(expected.size());
+    assertEquals(expected, actual);
+  }
+
+  private void assertData(byte[] data) throws IOException {
+    int byteCount = 16;
+    for (int i = 0; i < data.length; i += byteCount) {
+      int count = Math.min(byteCount, data.length - i);
+      Buffer expectedChunk = new Buffer();
+      expectedChunk.write(data, i, count);
+      assertEquals("At " + i, expectedChunk.readByteString(), this.data.readByteString(count));
+    }
+  }
+
+  private static byte[] binaryData(int length) {
+    byte[] junk = new byte[length];
+    new Random(0).nextBytes(junk);
+    return junk;
+  }
+}
diff --git a/okhttp-tests/src/test/resources/web-platform-test-urltestdata.txt b/okhttp-tests/src/test/resources/web-platform-test-urltestdata.txt
new file mode 100644
index 0000000000..87c4f67135
--- /dev/null
+++ b/okhttp-tests/src/test/resources/web-platform-test-urltestdata.txt
@@ -0,0 +1,342 @@
+# FORMAT NOT DOCUMENTED YET (parser is urltestparser.js)
+
+# Based on http://trac.webkit.org/browser/trunk/LayoutTests/fast/url/script-tests/segments.js
+http://example\t.\norg http://example.org/foo/bar s:http h:example.org p:/
+http://user:pass@foo:21/bar;par?b#c  s:http u:user pass:pass h:foo port:21 p:/bar;par q:?b f:#c
+http:foo.com  s:http h:example.org p:/foo/foo.com
+\t\s\s\s:foo.com\s\s\s\n  s:http h:example.org p:/foo/:foo.com
+\sfoo.com\s\s  s:http h:example.org p:/foo/foo.com
+a:\t\sfoo.com  s:a p:\sfoo.com
+http://f:21/\sb\s?\sd\s#\se\s  s:http h:f port:21 p:/%20b%20 q:?%20d%20 f:#\se
+http://f:/c  s:http h:f p:/c
+http://f:0/c  s:http h:f port:0 p:/c
+http://f:00000000000000/c  s:http h:f port:0 p:/c
+http://f:00000000000000000000080/c  s:http h:f p:/c
+http://f:b/c
+http://f:\s/c
+http://f:\n/c  s:http h:f p:/c
+http://f:fifty-two/c
+http://f:999999/c  s:http h:f port:999999 p:/c
+http://f:\s21\s/\sb\s?\sd\s#\se\s
+  s:http h:example.org p:/foo/bar
+\s\s\t  s:http h:example.org p:/foo/bar
+:foo.com/  s:http h:example.org p:/foo/:foo.com/
+:foo.com\\  s:http h:example.org p:/foo/:foo.com/
+:  s:http h:example.org p:/foo/:
+:a  s:http h:example.org p:/foo/:a
+:/  s:http h:example.org p:/foo/:/
+:\\  s:http h:example.org p:/foo/:/
+:#  s:http h:example.org p:/foo/: f:#
+\#  s:http h:example.org p:/foo/bar f:#
+\#/  s:http h:example.org p:/foo/bar f:#/
+\#\\  s:http h:example.org p:/foo/bar f:#\\
+\#;?  s:http h:example.org p:/foo/bar f:#;?
+?  s:http h:example.org p:/foo/bar q:?
+/  s:http h:example.org p:/
+:23  s:http h:example.org p:/foo/:23
+/:23  s:http h:example.org p:/:23
+::  s:http h:example.org p:/foo/::
+::23  s:http h:example.org p:/foo/::23
+foo://  s:foo p://
+http://a:b@c:29/d  s:http u:a pass:b h:c port:29 p:/d
+http::@c:29  s:http h:example.org p:/foo/:@c:29
+http://&a:foo(b]c@d:2/  s:http u:&a pass:foo(b]c h:d port:2 p:/
+http://::@c@d:2  s:http pass::%40c h:d port:2 p:/
+http://foo.com:b@d/  s:http u:foo.com pass:b h:d p:/
+http://foo.com/\\@  s:http h:foo.com p://@
+http:\\\\foo.com\\  s:http h:foo.com p:/
+http:\\\\a\\b:c\\d@foo.com\\  s:http h:a p:/b:c/d@foo.com/
+foo:/  s:foo p:/
+foo:/bar.com/  s:foo p:/bar.com/
+foo://///////  s:foo p://///////
+foo://///////bar.com/  s:foo p://///////bar.com/
+foo:////://///  s:foo p:////://///
+c:/foo  s:c p:/foo
+//foo/bar  s:http h:foo p:/bar
+http://foo/path;a??e#f#g  s:http h:foo p:/path;a q:??e f:#f#g
+http://foo/abcd?efgh?ijkl  s:http h:foo p:/abcd q:?efgh?ijkl
+http://foo/abcd#foo?bar  s:http h:foo p:/abcd f:#foo?bar
+[61:24:74]:98  s:http h:example.org p:/foo/[61:24:74]:98
+http:[61:27]/:foo  s:http h:example.org p:/foo/[61:27]/:foo
+http://[1::2]:3:4
+http://2001::1
+http://2001::1]
+http://2001::1]:80
+http://[2001::1]  s:http h:[2001::1] p:/
+http://[2001::1]:80  s:http h:[2001::1] p:/
+http:/example.com/  s:http h:example.org p:/example.com/
+ftp:/example.com/  s:ftp h:example.com p:/
+https:/example.com/  s:https h:example.com p:/
+madeupscheme:/example.com/  s:madeupscheme p:/example.com/
+file:/example.com/  s:file p:/example.com/
+ftps:/example.com/  s:ftps p:/example.com/
+gopher:/example.com/  s:gopher h:example.com p:/
+ws:/example.com/  s:ws h:example.com p:/
+wss:/example.com/  s:wss h:example.com p:/
+data:/example.com/  s:data p:/example.com/
+javascript:/example.com/  s:javascript p:/example.com/
+mailto:/example.com/  s:mailto p:/example.com/
+http:example.com/  s:http h:example.org p:/foo/example.com/
+ftp:example.com/  s:ftp h:example.com p:/
+https:example.com/  s:https h:example.com p:/
+madeupscheme:example.com/  s:madeupscheme p:example.com/
+ftps:example.com/  s:ftps p:example.com/
+gopher:example.com/  s:gopher h:example.com p:/
+ws:example.com/  s:ws h:example.com p:/
+wss:example.com/  s:wss h:example.com p:/
+data:example.com/  s:data p:example.com/
+javascript:example.com/  s:javascript p:example.com/
+mailto:example.com/  s:mailto p:example.com/
+/a/b/c  s:http h:example.org p:/a/b/c
+/a/\s/c  s:http h:example.org p:/a/%20/c
+/a%2fc  s:http h:example.org p:/a%2fc
+/a/%2f/c  s:http h:example.org p:/a/%2f/c
+\#\u03B2  s:http h:example.org p:/foo/bar f:#\u03B2
+data:text/html,test#test  s:data p:text/html,test f:#test
+
+# Based on http://trac.webkit.org/browser/trunk/LayoutTests/fast/url/file.html
+
+# Basic canonicalization, uppercase should be converted to lowercase
+file:c:\\foo\\bar.html file:///tmp/mock/path s:file p:/c:/foo/bar.html
+
+# Spaces should fail
+\s\sFile:c|////foo\\bar.html  s:file p:/c:////foo/bar.html
+
+# This should fail
+C|/foo/bar  s:file p:/C:/foo/bar
+
+# This should fail
+/C|\\foo\\bar  s:file p:/C:/foo/bar
+//C|/foo/bar  s:file p:/C:/foo/bar
+//server/file  s:file h:server p:/file
+\\\\server\\file  s:file h:server p:/file
+/\\server/file  s:file h:server p:/file
+file:///foo/bar.txt  s:file p:/foo/bar.txt
+file:///home/me  s:file p:/home/me
+//  s:file p:/
+///  s:file p:/
+///test  s:file p:/test
+file://test  s:file h:test p:/
+file://localhost  s:file h:localhost p:/
+file://localhost/  s:file h:localhost p:/
+file://localhost/test  s:file h:localhost p:/test
+test  s:file p:/tmp/mock/test
+file:test  s:file p:/tmp/mock/test
+
+# Based on http://trac.webkit.org/browser/trunk/LayoutTests/fast/url/script-tests/path.js
+http://example.com/././foo about:blank s:http h:example.com p:/foo
+http://example.com/./.foo  s:http h:example.com p:/.foo
+http://example.com/foo/.  s:http h:example.com p:/foo/
+http://example.com/foo/./  s:http h:example.com p:/foo/
+http://example.com/foo/bar/..  s:http h:example.com p:/foo/
+http://example.com/foo/bar/../  s:http h:example.com p:/foo/
+http://example.com/foo/..bar  s:http h:example.com p:/foo/..bar
+http://example.com/foo/bar/../ton  s:http h:example.com p:/foo/ton
+http://example.com/foo/bar/../ton/../../a  s:http h:example.com p:/a
+http://example.com/foo/../../..  s:http h:example.com p:/
+http://example.com/foo/../../../ton  s:http h:example.com p:/ton
+http://example.com/foo/%2e  s:http h:example.com p:/foo/
+http://example.com/foo/%2e%2  s:http h:example.com p:/foo/%2e%2
+http://example.com/foo/%2e./%2e%2e/.%2e/%2e.bar  s:http h:example.com p:/%2e.bar
+http://example.com////../..  s:http h:example.com p://
+http://example.com/foo/bar//../..  s:http h:example.com p:/foo/
+http://example.com/foo/bar//..  s:http h:example.com p:/foo/bar/
+http://example.com/foo  s:http h:example.com p:/foo
+http://example.com/%20foo  s:http h:example.com p:/%20foo
+http://example.com/foo%  s:http h:example.com p:/foo%
+http://example.com/foo%2  s:http h:example.com p:/foo%2
+http://example.com/foo%2zbar  s:http h:example.com p:/foo%2zbar
+http://example.com/foo%2\u00C2\u00A9zbar  s:http h:example.com p:/foo%2%C3%82%C2%A9zbar
+http://example.com/foo%41%7a  s:http h:example.com p:/foo%41%7a
+http://example.com/foo\t\u0091%91  s:http h:example.com p:/foo%C2%91%91
+http://example.com/foo%00%51  s:http h:example.com p:/foo%00%51
+http://example.com/(%28:%3A%29)  s:http h:example.com p:/(%28:%3A%29)
+http://example.com/%3A%3a%3C%3c  s:http h:example.com p:/%3A%3a%3C%3c
+http://example.com/foo\tbar  s:http h:example.com p:/foobar
+http://example.com\\\\foo\\\\bar  s:http h:example.com p://foo//bar
+http://example.com/%7Ffp3%3Eju%3Dduvgw%3Dd  s:http h:example.com p:/%7Ffp3%3Eju%3Dduvgw%3Dd
+http://example.com/@asdf%40  s:http h:example.com p:/@asdf%40
+http://example.com/\u4F60\u597D\u4F60\u597D  s:http h:example.com p:/%E4%BD%A0%E5%A5%BD%E4%BD%A0%E5%A5%BD
+http://example.com/\u2025/foo  s:http h:example.com p:/%E2%80%A5/foo
+http://example.com/\uFEFF/foo  s:http h:example.com p:/%EF%BB%BF/foo
+http://example.com/\u202E/foo/\u202D/bar  s:http h:example.com p:/%E2%80%AE/foo/%E2%80%AD/bar
+
+# Based on http://trac.webkit.org/browser/trunk/LayoutTests/fast/url/script-tests/relative.js
+http://www.google.com/foo?bar=baz# about:blank s:http h:www.google.com p:/foo q:?bar=baz f:#
+http://www.google.com/foo?bar=baz#\s\u00BB  s:http h:www.google.com p:/foo q:?bar=baz f:#\s\u00BB
+data:test#\s\u00BB  s:data p:test f:#\s\u00BB
+http://[www.google.com]/
+http://www.google.com  s:http h:www.google.com p:/
+http://192.0x00A80001  s:http h:192.168.0.1 p:/
+http://www/foo%2Ehtml  s:http h:www p:/foo%2Ehtml
+http://www/foo/%2E/html  s:http h:www p:/foo/html
+http://user:pass@/
+http://%25DOMAIN:foobar@foodomain.com/  s:http u:%25DOMAIN pass:foobar h:foodomain.com p:/
+http:\\\\www.google.com\\foo  s:http h:www.google.com p:/foo
+http://foo:80/  s:http h:foo p:/
+http://foo:81/  s:http h:foo port:81 p:/
+httpa://foo:80/  s:httpa p://foo:80/
+http://foo:-80/
+https://foo:443/  s:https h:foo p:/
+https://foo:80/  s:https h:foo port:80 p:/
+ftp://foo:21/  s:ftp h:foo p:/
+ftp://foo:80/  s:ftp h:foo port:80 p:/
+gopher://foo:70/  s:gopher h:foo p:/
+gopher://foo:443/  s:gopher h:foo port:443 p:/
+ws://foo:80/  s:ws h:foo p:/
+ws://foo:81/  s:ws h:foo port:81 p:/
+ws://foo:443/  s:ws h:foo port:443 p:/
+ws://foo:815/  s:ws h:foo port:815 p:/
+wss://foo:80/  s:wss h:foo port:80 p:/
+wss://foo:81/  s:wss h:foo port:81 p:/
+wss://foo:443/  s:wss h:foo p:/
+wss://foo:815/  s:wss h:foo port:815 p:/
+http:/example.com/  s:http h:example.com p:/
+ftp:/example.com/  s:ftp h:example.com p:/
+https:/example.com/  s:https h:example.com p:/
+madeupscheme:/example.com/  s:madeupscheme p:/example.com/
+file:/example.com/  s:file p:/example.com/
+ftps:/example.com/  s:ftps p:/example.com/
+gopher:/example.com/  s:gopher h:example.com p:/
+ws:/example.com/  s:ws h:example.com p:/
+wss:/example.com/  s:wss h:example.com p:/
+data:/example.com/  s:data p:/example.com/
+javascript:/example.com/  s:javascript p:/example.com/
+mailto:/example.com/  s:mailto p:/example.com/
+http:example.com/  s:http h:example.com p:/
+ftp:example.com/  s:ftp h:example.com p:/
+https:example.com/  s:https h:example.com p:/
+madeupscheme:example.com/  s:madeupscheme p:example.com/
+ftps:example.com/  s:ftps p:example.com/
+gopher:example.com/  s:gopher h:example.com p:/
+ws:example.com/  s:ws h:example.com p:/
+wss:example.com/  s:wss h:example.com p:/
+data:example.com/  s:data p:example.com/
+javascript:example.com/  s:javascript p:example.com/
+mailto:example.com/  s:mailto p:example.com/
+
+# Based on http://trac.webkit.org/browser/trunk/LayoutTests/fast/url/segments-userinfo-vs-host.html
+http:@www.example.com about:blank s:http h:www.example.com p:/
+http:/@www.example.com  s:http h:www.example.com p:/
+http://@www.example.com  s:http h:www.example.com p:/
+http:a:b@www.example.com  s:http u:a pass:b h:www.example.com p:/
+http:/a:b@www.example.com  s:http u:a pass:b h:www.example.com p:/
+http://a:b@www.example.com  s:http u:a pass:b h:www.example.com p:/
+http://@pple.com  s:http h:pple.com p:/
+http::b@www.example.com  s:http pass:b h:www.example.com p:/
+http:/:b@www.example.com  s:http pass:b h:www.example.com p:/
+http://:b@www.example.com  s:http pass:b h:www.example.com p:/
+http:/:@/www.example.com
+http://user@/www.example.com
+http:@/www.example.com
+http:/@/www.example.com
+http://@/www.example.com
+https:@/www.example.com
+http:a:b@/www.example.com
+http:/a:b@/www.example.com
+http://a:b@/www.example.com
+http::@/www.example.com
+http:a:@www.example.com  s:http u:a pass: h:www.example.com p:/
+http:/a:@www.example.com  s:http u:a pass: h:www.example.com p:/
+http://a:@www.example.com  s:http u:a pass: h:www.example.com p:/
+http://www.@pple.com  s:http u:www. h:pple.com p:/
+http:@:www.example.com
+http:/@:www.example.com
+http://@:www.example.com
+http://:@www.example.com  s:http pass: h:www.example.com p:/
+
+#Others
+/ http://www.example.com/test s:http h:www.example.com p:/
+/test.txt  s:http h:www.example.com p:/test.txt
+.  s:http h:www.example.com p:/
+..  s:http h:www.example.com p:/
+test.txt  s:http h:www.example.com p:/test.txt
+./test.txt  s:http h:www.example.com p:/test.txt
+../test.txt  s:http h:www.example.com p:/test.txt
+../aaa/test.txt  s:http h:www.example.com p:/aaa/test.txt
+../../test.txt  s:http h:www.example.com p:/test.txt
+\u4E2D/test.txt  s:http h:www.example.com p:/%E4%B8%AD/test.txt
+http://www.example2.com  s:http h:www.example2.com p:/
+//www.example2.com  s:http h:www.example2.com p:/
+
+# Based on http://trac.webkit.org/browser/trunk/LayoutTests/fast/url/host.html
+
+# Basic canonicalization, uppercase should be converted to lowercase
+http://ExAmPlE.CoM http://other.com/ s:http p:/ h:example.com
+
+# Spaces should fail
+http://example\sexample.com
+
+# This should fail
+http://Goo%20\sgoo%7C|.com
+
+# U+3000 is mapped to U+0020 (space) which is disallowed
+http://GOO\u00a0\u3000goo.com
+
+# Other types of space (no-break, zero-width, zero-width-no-break) are
+# name-prepped away to nothing.
+# U+200B, U+2060, and U+FEFF, are ignored
+http://GOO\u200b\u2060\ufeffgoo.com  s:http p:/ h:googoo.com
+
+# Ideographic full stop (full-width period for Chinese, etc.) should be
+# treated as a dot.
+# U+3002 is mapped to U+002E (dot)
+http://www.foo\u3002bar.com  s:http p:/ h:www.foo.bar.com
+
+# Invalid unicode characters should fail...
+# U+FDD0 is disallowed; %ef%b7%90 is U+FDD0
+http://\ufdd0zyx.com
+
+# ...This is the same as previous but escaped.
+http://%ef%b7%90zyx.com
+
+# Test name prepping, fullwidth input should be converted to ASCII and NOT
+# IDN-ized. This is "Go" in fullwidth UTF-8/UTF-16.
+http://\uff27\uff4f.com  s:http p:/ h:go.com
+
+# URL spec forbids the following.
+# https://www.w3.org/Bugs/Public/show_bug.cgi?id=24257
+http://\uff05\uff14\uff11.com
+http://%ef%bc%85%ef%bc%94%ef%bc%91.com
+
+# ...%00 in fullwidth should fail (also as escaped UTF-8 input)
+http://\uff05\uff10\uff10.com
+http://%ef%bc%85%ef%bc%90%ef%bc%90.com
+
+# Basic IDN support, UTF-8 and UTF-16 input should be converted to IDN
+http://\u4f60\u597d\u4f60\u597d  s:http p:/ h:xn--6qqa088eba
+
+# Invalid escaped characters should fail and the percents should be
+# escaped. https://www.w3.org/Bugs/Public/show_bug.cgi?id=24191
+http://%zz%66%a.com
+
+# If we get an invalid character that has been escaped.
+http://%25
+http://hello%00
+
+# Escaped numbers should be treated like IP addresses if they are.
+# No special handling for IPv4 or IPv4-like URLs
+http://%30%78%63%30%2e%30%32%35%30.01  s:http p:/ h:192.168.0.1
+http://%30%78%63%30%2e%30%32%35%30.01%2e  s:http p:/ h:0xc0.0250.01.
+http://192.168.0.257
+
+# Invalid escaping should trigger the regular host error handling.
+http://%3g%78%63%30%2e%30%32%35%30%2E.01
+
+# Something that isn't exactly an IP should get treated as a host and
+# spaces escaped.
+http://192.168.0.1\shello
+
+# Fullwidth and escaped UTF-8 fullwidth should still be treated as IP.
+# These are "0Xc0.0250.01" in fullwidth.
+http://\uff10\uff38\uff43\uff10\uff0e\uff10\uff12\uff15\uff10\uff0e\uff10\uff11  s:http p:/ h:192.168.0.1
+
+# Broken IPv6
+http://[google.com]
+
+# Misc Unicode
+http://foo:\uD83D\uDCA9@example.com/bar  s:http h:example.com p:/bar u:foo pass:%F0%9F%92%A9
+
+# resolving a relative reference against an unknown scheme results in an error
+x test:test
+
diff --git a/okhttp-urlconnection/pom.xml b/okhttp-urlconnection/pom.xml
new file mode 100644
index 0000000000..3894bbcd83
--- /dev/null
+++ b/okhttp-urlconnection/pom.xml
@@ -0,0 +1,66 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp3</groupId>
+    <artifactId>parent</artifactId>
+    <version>3.10.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>okhttp-urlconnection</artifactId>
+  <name>OkHttp URLConnection</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.codehaus.mojo</groupId>
+      <artifactId>animal-sniffer-annotations</artifactId>
+      <version>${animal.sniffer.version}</version>
+      <optional>true</optional>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-javadoc-plugin</artifactId>
+        <configuration>
+          <excludePackageNames>okhttp3.internal:okhttp3.internal.*</excludePackageNames>
+          <links>
+            <link>http://square.github.io/okhttp/javadoc/</link>
+          </links>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java
new file mode 100644
index 0000000000..2649510d35
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.Authenticator.RequestorType;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.PasswordAuthentication;
+import java.net.Proxy;
+import java.util.List;
+
+/**
+ * Adapts {@link java.net.Authenticator} to {@link Authenticator}. Configure OkHttp to use {@link
+ * java.net.Authenticator} with {@link OkHttpClient.Builder#authenticator} or {@link
+ * OkHttpClient.Builder#proxyAuthenticator(Authenticator)}.
+ */
+public final class JavaNetAuthenticator implements Authenticator {
+  @Override public Request authenticate(Route route, Response response) throws IOException {
+    List<Challenge> challenges = response.challenges();
+    Request request = response.request();
+    HttpUrl url = request.url();
+    boolean proxyAuthorization = response.code() == 407;
+    Proxy proxy = route.proxy();
+
+    for (int i = 0, size = challenges.size(); i < size; i++) {
+      Challenge challenge = challenges.get(i);
+      if (!"Basic".equalsIgnoreCase(challenge.scheme())) continue;
+
+      PasswordAuthentication auth;
+      if (proxyAuthorization) {
+        InetSocketAddress proxyAddress = (InetSocketAddress) proxy.address();
+        auth = java.net.Authenticator.requestPasswordAuthentication(
+            proxyAddress.getHostName(), getConnectToInetAddress(proxy, url), proxyAddress.getPort(),
+            url.scheme(), challenge.realm(), challenge.scheme(), url.url(),
+            RequestorType.PROXY);
+      } else {
+        auth = java.net.Authenticator.requestPasswordAuthentication(
+            url.host(), getConnectToInetAddress(proxy, url), url.port(), url.scheme(),
+            challenge.realm(), challenge.scheme(), url.url(), RequestorType.SERVER);
+      }
+
+      if (auth != null) {
+        String credential = Credentials.basic(
+            auth.getUserName(), new String(auth.getPassword()), challenge.charset());
+        return request.newBuilder()
+            .header(proxyAuthorization ? "Proxy-Authorization" : "Authorization", credential)
+            .build();
+      }
+    }
+
+    return null; // No challenges were satisfied!
+  }
+
+  private InetAddress getConnectToInetAddress(Proxy proxy, HttpUrl url) throws IOException {
+    return (proxy != null && proxy.type() != Proxy.Type.DIRECT)
+        ? ((InetSocketAddress) proxy.address()).getAddress()
+        : InetAddress.getByName(url.host());
+  }
+}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java
new file mode 100644
index 0000000000..5d4f671a31
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java
@@ -0,0 +1,112 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.CookieHandler;
+import java.net.HttpCookie;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import okhttp3.internal.platform.Platform;
+
+import static okhttp3.internal.Util.delimiterOffset;
+import static okhttp3.internal.Util.trimSubstring;
+import static okhttp3.internal.platform.Platform.WARN;
+
+/** A cookie jar that delegates to a {@link java.net.CookieHandler}. */
+public final class JavaNetCookieJar implements CookieJar {
+  private final CookieHandler cookieHandler;
+
+  public JavaNetCookieJar(CookieHandler cookieHandler) {
+    this.cookieHandler = cookieHandler;
+  }
+
+  @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {
+    if (cookieHandler != null) {
+      List<String> cookieStrings = new ArrayList<>();
+      for (Cookie cookie : cookies) {
+        cookieStrings.add(cookie.toString(true));
+      }
+      Map<String, List<String>> multimap = Collections.singletonMap("Set-Cookie", cookieStrings);
+      try {
+        cookieHandler.put(url.uri(), multimap);
+      } catch (IOException e) {
+        Platform.get().log(WARN, "Saving cookies failed for " + url.resolve("/..."), e);
+      }
+    }
+  }
+
+  @Override public List<Cookie> loadForRequest(HttpUrl url) {
+    // The RI passes all headers. We don't have 'em, so we don't pass 'em!
+    Map<String, List<String>> headers = Collections.emptyMap();
+    Map<String, List<String>> cookieHeaders;
+    try {
+      cookieHeaders = cookieHandler.get(url.uri(), headers);
+    } catch (IOException e) {
+      Platform.get().log(WARN, "Loading cookies failed for " + url.resolve("/..."), e);
+      return Collections.emptyList();
+    }
+
+    List<Cookie> cookies = null;
+    for (Map.Entry<String, List<String>> entry : cookieHeaders.entrySet()) {
+      String key = entry.getKey();
+      if (("Cookie".equalsIgnoreCase(key) || "Cookie2".equalsIgnoreCase(key))
+          && !entry.getValue().isEmpty()) {
+        for (String header : entry.getValue()) {
+          if (cookies == null) cookies = new ArrayList<>();
+          cookies.addAll(decodeHeaderAsJavaNetCookies(url, header));
+        }
+      }
+    }
+
+    return cookies != null
+        ? Collections.unmodifiableList(cookies)
+        : Collections.<Cookie>emptyList();
+  }
+
+  /**
+   * Convert a request header to OkHttp's cookies via {@link HttpCookie}. That extra step handles
+   * multiple cookies in a single request header, which {@link Cookie#parse} doesn't support.
+   */
+  private List<Cookie> decodeHeaderAsJavaNetCookies(HttpUrl url, String header) {
+    List<Cookie> result = new ArrayList<>();
+    for (int pos = 0, limit = header.length(), pairEnd; pos < limit; pos = pairEnd + 1) {
+      pairEnd = delimiterOffset(header, pos, limit, ";,");
+      int equalsSign = delimiterOffset(header, pos, pairEnd, '=');
+      String name = trimSubstring(header, pos, equalsSign);
+      if (name.startsWith("$")) continue;
+
+      // We have either name=value or just a name.
+      String value = equalsSign < pairEnd
+          ? trimSubstring(header, equalsSign + 1, pairEnd)
+          : "";
+
+      // If the value is "quoted", drop the quotes.
+      if (value.startsWith("\"") && value.endsWith("\"")) {
+        value = value.substring(1, value.length() - 1);
+      }
+
+      result.add(new Cookie.Builder()
+          .name(name)
+          .value(value)
+          .domain(url.host())
+          .build());
+    }
+    return result;
+  }
+}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/OkUrlFactory.java b/okhttp-urlconnection/src/main/java/okhttp3/OkUrlFactory.java
new file mode 100644
index 0000000000..0bbe613492
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/OkUrlFactory.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.net.HttpURLConnection;
+import java.net.Proxy;
+import java.net.URL;
+import java.net.URLConnection;
+import java.net.URLStreamHandler;
+import java.net.URLStreamHandlerFactory;
+import okhttp3.internal.URLFilter;
+import okhttp3.internal.huc.OkHttpURLConnection;
+import okhttp3.internal.huc.OkHttpsURLConnection;
+
+/**
+ * @deprecated OkHttp will be dropping its ability to be used with {@link HttpURLConnection} in an
+ * upcoming release. Applications that need this should either downgrade to the system's built-in
+ * {@link HttpURLConnection} or upgrade to OkHttp's Request/Response API.
+ */
+public final class OkUrlFactory implements URLStreamHandlerFactory, Cloneable {
+  private OkHttpClient client;
+  private URLFilter urlFilter;
+
+  public OkUrlFactory(OkHttpClient client) {
+    this.client = client;
+  }
+
+  public OkHttpClient client() {
+    return client;
+  }
+
+  public OkUrlFactory setClient(OkHttpClient client) {
+    this.client = client;
+    return this;
+  }
+
+  void setUrlFilter(URLFilter filter) {
+    urlFilter = filter;
+  }
+
+  /**
+   * Returns a copy of this stream handler factory that includes a shallow copy of the internal
+   * {@linkplain OkHttpClient HTTP client}.
+   */
+  @Override public OkUrlFactory clone() {
+    return new OkUrlFactory(client);
+  }
+
+  public HttpURLConnection open(URL url) {
+    return open(url, client.proxy());
+  }
+
+  HttpURLConnection open(URL url, Proxy proxy) {
+    String protocol = url.getProtocol();
+    OkHttpClient copy = client.newBuilder()
+        .proxy(proxy)
+        .build();
+
+    if (protocol.equals("http")) return new OkHttpURLConnection(url, copy, urlFilter);
+    if (protocol.equals("https")) return new OkHttpsURLConnection(url, copy, urlFilter);
+    throw new IllegalArgumentException("Unexpected protocol: " + protocol);
+  }
+
+  /**
+   * Creates a URLStreamHandler as a {@link java.net.URL#setURLStreamHandlerFactory}.
+   *
+   * <p>This code configures OkHttp to handle all HTTP and HTTPS connections
+   * created with {@link java.net.URL#openConnection()}: <pre>   {@code
+   *
+   *   OkHttpClient okHttpClient = new OkHttpClient();
+   *   URL.setURLStreamHandlerFactory(new OkUrlFactory(okHttpClient));
+   * }</pre>
+   */
+  @Override public URLStreamHandler createURLStreamHandler(final String protocol) {
+    if (!protocol.equals("http") && !protocol.equals("https")) return null;
+
+    return new URLStreamHandler() {
+      @Override protected URLConnection openConnection(URL url) {
+        return open(url);
+      }
+
+      @Override protected URLConnection openConnection(URL url, Proxy proxy) {
+        return open(url, proxy);
+      }
+
+      @Override protected int getDefaultPort() {
+        if (protocol.equals("http")) return 80;
+        if (protocol.equals("https")) return 443;
+        throw new AssertionError();
+      }
+    };
+  }
+}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/JavaNetHeaders.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/JavaNetHeaders.java
new file mode 100644
index 0000000000..0b7a02e1f9
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/JavaNetHeaders.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Map;
+import java.util.TreeMap;
+import okhttp3.Headers;
+
+public final class JavaNetHeaders {
+  private JavaNetHeaders() {
+  }
+
+  private static final Comparator<String> FIELD_NAME_COMPARATOR = new Comparator<String>() {
+    // @FindBugsSuppressWarnings("ES_COMPARING_PARAMETER_STRING_WITH_EQ")
+    @Override public int compare(String a, String b) {
+      if (a == b) {
+        return 0;
+      } else if (a == null) {
+        return -1;
+      } else if (b == null) {
+        return 1;
+      } else {
+        return String.CASE_INSENSITIVE_ORDER.compare(a, b);
+      }
+    }
+  };
+
+  /**
+   * Returns an immutable map containing each field to its list of values.
+   *
+   * @param valueForNullKey the request line for requests, or the status line for responses. If
+   * non-null, this value is mapped to the null key.
+   */
+  public static Map<String, List<String>> toMultimap(Headers headers, String valueForNullKey) {
+    Map<String, List<String>> result = new TreeMap<>(FIELD_NAME_COMPARATOR);
+    for (int i = 0, size = headers.size(); i < size; i++) {
+      String fieldName = headers.name(i);
+      String value = headers.value(i);
+
+      List<String> allValues = new ArrayList<>();
+      List<String> otherValues = result.get(fieldName);
+      if (otherValues != null) {
+        allValues.addAll(otherValues);
+      }
+      allValues.add(value);
+      result.put(fieldName, Collections.unmodifiableList(allValues));
+    }
+    if (valueForNullKey != null) {
+      result.put(null, Collections.unmodifiableList(Collections.singletonList(valueForNullKey)));
+    }
+    return Collections.unmodifiableMap(result);
+  }
+}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/URLFilter.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/URLFilter.java
new file mode 100644
index 0000000000..3b077f8bc4
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/URLFilter.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+import java.io.IOException;
+import java.net.URL;
+
+/**
+ * Request filter based on the request's URL.
+ *
+ * @deprecated use {@link okhttp3.Interceptor} for non-HttpURLConnection filtering.
+ */
+public interface URLFilter {
+  /**
+   * Check whether request to the provided URL is permitted to be issued.
+   *
+   * @throws IOException if the request to the provided URL is not permitted.
+   */
+  void checkURLPermitted(URL url) throws IOException;
+}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/BufferedRequestBody.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/BufferedRequestBody.java
new file mode 100644
index 0000000000..b4b2f68347
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/BufferedRequestBody.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.huc;
+
+import java.io.IOException;
+import okhttp3.Request;
+import okio.Buffer;
+import okio.BufferedSink;
+
+/**
+ * This request body involves an application thread only. First all bytes are written to the buffer.
+ * Only once that is complete are bytes then copied to the network.
+ *
+ * <p>This body has two special powers. First, it can retransmit the same request body multiple
+ * times in order to recover from failures or cope with redirects. Second, it can compute the total
+ * length of the request body by measuring it after it has been written to the output stream.
+ */
+final class BufferedRequestBody extends OutputStreamRequestBody {
+  final Buffer buffer = new Buffer();
+  long contentLength = -1L;
+
+  BufferedRequestBody(long expectedContentLength) {
+    initOutputStream(buffer, expectedContentLength);
+  }
+
+  @Override public long contentLength() throws IOException {
+    return contentLength;
+  }
+
+  /**
+   * Now that we've buffered the entire request body, update the request headers and the body
+   * itself. This happens late to enable HttpURLConnection users to complete the socket connection
+   * before sending request body bytes.
+   */
+  @Override public Request prepareToSendRequest(Request request) throws IOException {
+    if (request.header("Content-Length") != null) return request;
+
+    outputStream().close();
+    contentLength = buffer.size();
+    return request.newBuilder()
+        .removeHeader("Transfer-Encoding")
+        .header("Content-Length", Long.toString(buffer.size()))
+        .build();
+  }
+
+  @Override public void writeTo(BufferedSink sink) throws IOException {
+    buffer.copyTo(sink.buffer(), 0, buffer.size());
+  }
+}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/DelegatingHttpsURLConnection.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/DelegatingHttpsURLConnection.java
new file mode 100644
index 0000000000..a051bf2198
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/DelegatingHttpsURLConnection.java
@@ -0,0 +1,308 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3.internal.huc;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.HttpURLConnection;
+import java.net.ProtocolException;
+import java.net.URL;
+import java.security.Permission;
+import java.security.Principal;
+import java.security.cert.Certificate;
+import java.util.List;
+import java.util.Map;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSocketFactory;
+import okhttp3.Handshake;
+import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
+
+/**
+ * Implement an HTTPS connection by delegating to an HTTP connection for everything but the
+ * HTTPS-specific stuff.
+ */
+abstract class DelegatingHttpsURLConnection extends HttpsURLConnection {
+  private final HttpURLConnection delegate;
+
+  DelegatingHttpsURLConnection(HttpURLConnection delegate) {
+    super(delegate.getURL());
+    this.delegate = delegate;
+  }
+
+  protected abstract Handshake handshake();
+
+  @Override public abstract void setHostnameVerifier(HostnameVerifier hostnameVerifier);
+
+  @Override public abstract HostnameVerifier getHostnameVerifier();
+
+  @Override public abstract void setSSLSocketFactory(SSLSocketFactory sslSocketFactory);
+
+  @Override public abstract SSLSocketFactory getSSLSocketFactory();
+
+  @Override public String getCipherSuite() {
+    Handshake handshake = handshake();
+    return handshake != null ? handshake.cipherSuite().javaName() : null;
+  }
+
+  @Override public Certificate[] getLocalCertificates() {
+    Handshake handshake = handshake();
+    if (handshake == null) return null;
+    List<Certificate> result = handshake.localCertificates();
+    return !result.isEmpty() ? result.toArray(new Certificate[result.size()]) : null;
+  }
+
+  @Override public Certificate[] getServerCertificates() throws SSLPeerUnverifiedException {
+    Handshake handshake = handshake();
+    if (handshake == null) return null;
+    List<Certificate> result = handshake.peerCertificates();
+    return !result.isEmpty() ? result.toArray(new Certificate[result.size()]) : null;
+  }
+
+  @Override public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
+    Handshake handshake = handshake();
+    return handshake != null ? handshake.peerPrincipal() : null;
+  }
+
+  @Override public Principal getLocalPrincipal() {
+    Handshake handshake = handshake();
+    return handshake != null ? handshake.localPrincipal() : null;
+  }
+
+  @Override public void connect() throws IOException {
+    connected = true;
+    delegate.connect();
+  }
+
+  @Override public void disconnect() {
+    delegate.disconnect();
+  }
+
+  @Override public InputStream getErrorStream() {
+    return delegate.getErrorStream();
+  }
+
+  @Override public String getRequestMethod() {
+    return delegate.getRequestMethod();
+  }
+
+  @Override public int getResponseCode() throws IOException {
+    return delegate.getResponseCode();
+  }
+
+  @Override public String getResponseMessage() throws IOException {
+    return delegate.getResponseMessage();
+  }
+
+  @Override public void setRequestMethod(String method) throws ProtocolException {
+    delegate.setRequestMethod(method);
+  }
+
+  @Override public boolean usingProxy() {
+    return delegate.usingProxy();
+  }
+
+  @Override public boolean getInstanceFollowRedirects() {
+    return delegate.getInstanceFollowRedirects();
+  }
+
+  @Override public void setInstanceFollowRedirects(boolean followRedirects) {
+    delegate.setInstanceFollowRedirects(followRedirects);
+  }
+
+  @Override public boolean getAllowUserInteraction() {
+    return delegate.getAllowUserInteraction();
+  }
+
+  @Override public Object getContent() throws IOException {
+    return delegate.getContent();
+  }
+
+  @SuppressWarnings("unchecked") // Spec does not generify
+  @Override public Object getContent(Class[] types) throws IOException {
+    return delegate.getContent(types);
+  }
+
+  @Override public String getContentEncoding() {
+    return delegate.getContentEncoding();
+  }
+
+  @Override public int getContentLength() {
+    return delegate.getContentLength();
+  }
+
+  @IgnoreJRERequirement // Should only be invoked on Java 7+.
+  @Override public long getContentLengthLong() {
+    return delegate.getContentLengthLong();
+  }
+
+  @Override public String getContentType() {
+    return delegate.getContentType();
+  }
+
+  @Override public long getDate() {
+    return delegate.getDate();
+  }
+
+  @Override public boolean getDefaultUseCaches() {
+    return delegate.getDefaultUseCaches();
+  }
+
+  @Override public boolean getDoInput() {
+    return delegate.getDoInput();
+  }
+
+  @Override public boolean getDoOutput() {
+    return delegate.getDoOutput();
+  }
+
+  @Override public long getExpiration() {
+    return delegate.getExpiration();
+  }
+
+  @Override public String getHeaderField(int pos) {
+    return delegate.getHeaderField(pos);
+  }
+
+  @Override public Map<String, List<String>> getHeaderFields() {
+    return delegate.getHeaderFields();
+  }
+
+  @Override public Map<String, List<String>> getRequestProperties() {
+    return delegate.getRequestProperties();
+  }
+
+  @Override public void addRequestProperty(String field, String newValue) {
+    delegate.addRequestProperty(field, newValue);
+  }
+
+  @Override public String getHeaderField(String key) {
+    return delegate.getHeaderField(key);
+  }
+
+  @IgnoreJRERequirement // Should only be invoked on Java 7+.
+  @Override public long getHeaderFieldLong(String field, long defaultValue) {
+    return delegate.getHeaderFieldLong(field, defaultValue);
+  }
+
+  @Override public long getHeaderFieldDate(String field, long defaultValue) {
+    return delegate.getHeaderFieldDate(field, defaultValue);
+  }
+
+  @Override public int getHeaderFieldInt(String field, int defaultValue) {
+    return delegate.getHeaderFieldInt(field, defaultValue);
+  }
+
+  @Override public String getHeaderFieldKey(int position) {
+    return delegate.getHeaderFieldKey(position);
+  }
+
+  @Override public long getIfModifiedSince() {
+    return delegate.getIfModifiedSince();
+  }
+
+  @Override public InputStream getInputStream() throws IOException {
+    return delegate.getInputStream();
+  }
+
+  @Override public long getLastModified() {
+    return delegate.getLastModified();
+  }
+
+  @Override public OutputStream getOutputStream() throws IOException {
+    return delegate.getOutputStream();
+  }
+
+  @Override public Permission getPermission() throws IOException {
+    return delegate.getPermission();
+  }
+
+  @Override public String getRequestProperty(String field) {
+    return delegate.getRequestProperty(field);
+  }
+
+  @Override public URL getURL() {
+    return delegate.getURL();
+  }
+
+  @Override public boolean getUseCaches() {
+    return delegate.getUseCaches();
+  }
+
+  @Override public void setAllowUserInteraction(boolean newValue) {
+    delegate.setAllowUserInteraction(newValue);
+  }
+
+  @Override public void setDefaultUseCaches(boolean newValue) {
+    delegate.setDefaultUseCaches(newValue);
+  }
+
+  @Override public void setDoInput(boolean newValue) {
+    delegate.setDoInput(newValue);
+  }
+
+  @Override public void setDoOutput(boolean newValue) {
+    delegate.setDoOutput(newValue);
+  }
+
+  @IgnoreJRERequirement // Should only be invoked on Java 7+.
+  @Override public void setFixedLengthStreamingMode(long contentLength) {
+    delegate.setFixedLengthStreamingMode(contentLength);
+  }
+
+  @Override public void setIfModifiedSince(long newValue) {
+    delegate.setIfModifiedSince(newValue);
+  }
+
+  @Override public void setRequestProperty(String field, String newValue) {
+    delegate.setRequestProperty(field, newValue);
+  }
+
+  @Override public void setUseCaches(boolean newValue) {
+    delegate.setUseCaches(newValue);
+  }
+
+  @Override public void setConnectTimeout(int timeoutMillis) {
+    delegate.setConnectTimeout(timeoutMillis);
+  }
+
+  @Override public int getConnectTimeout() {
+    return delegate.getConnectTimeout();
+  }
+
+  @Override public void setReadTimeout(int timeoutMillis) {
+    delegate.setReadTimeout(timeoutMillis);
+  }
+
+  @Override public int getReadTimeout() {
+    return delegate.getReadTimeout();
+  }
+
+  @Override public String toString() {
+    return delegate.toString();
+  }
+
+  @Override public void setFixedLengthStreamingMode(int contentLength) {
+    delegate.setFixedLengthStreamingMode(contentLength);
+  }
+
+  @Override public void setChunkedStreamingMode(int chunkLength) {
+    delegate.setChunkedStreamingMode(chunkLength);
+  }
+}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java
new file mode 100644
index 0000000000..344a61e446
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java
@@ -0,0 +1,639 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3.internal.huc;
+
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InterruptedIOException;
+import java.io.OutputStream;
+import java.net.HttpURLConnection;
+import java.net.InetSocketAddress;
+import java.net.ProtocolException;
+import java.net.Proxy;
+import java.net.SocketPermission;
+import java.net.URL;
+import java.security.Permission;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Date;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+import okhttp3.Call;
+import okhttp3.Callback;
+import okhttp3.Dispatcher;
+import okhttp3.Handshake;
+import okhttp3.Headers;
+import okhttp3.HttpUrl;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.Internal;
+import okhttp3.internal.JavaNetHeaders;
+import okhttp3.internal.URLFilter;
+import okhttp3.internal.Util;
+import okhttp3.internal.Version;
+import okhttp3.internal.http.HttpDate;
+import okhttp3.internal.http.HttpHeaders;
+import okhttp3.internal.http.HttpMethod;
+import okhttp3.internal.http.StatusLine;
+import okhttp3.internal.platform.Platform;
+
+import static okhttp3.internal.platform.Platform.WARN;
+
+/**
+ * This implementation uses {@linkplain Call} to send requests and receive responses.
+ *
+ * <h3>What does 'connected' mean?</h3> This class inherits a {@code connected} field from the
+ * superclass. That field is <strong>not</strong> used to indicate whether this URLConnection is
+ * currently connected. Instead, it indicates whether a connection has ever been attempted. Once a
+ * connection has been attempted, certain properties (request header fields, request method, etc.)
+ * are immutable.
+ */
+public final class OkHttpURLConnection extends HttpURLConnection implements Callback {
+  /**
+   * Synthetic response header: the selected {@link Protocol protocol} ("spdy/3.1", "http/1.1",
+   * etc).
+   */
+  public static final String SELECTED_PROTOCOL = Platform.get().getPrefix() + "-Selected-Protocol";
+
+  /** Synthetic response header: the location from which the response was loaded. */
+  public static final String RESPONSE_SOURCE = Platform.get().getPrefix() + "-Response-Source";
+
+  private static final Set<String> METHODS = new LinkedHashSet<>(
+      Arrays.asList("OPTIONS", "GET", "HEAD", "POST", "PUT", "DELETE", "TRACE", "PATCH"));
+
+  // These fields are confined to the application thread that uses HttpURLConnection.
+
+  OkHttpClient client;
+  private final NetworkInterceptor networkInterceptor = new NetworkInterceptor();
+  private Headers.Builder requestHeaders = new Headers.Builder();
+  private boolean executed;
+  Call call;
+  URLFilter urlFilter;
+
+  /** Lazily created (with synthetic headers) on first call to getHeaders(). */
+  private Headers responseHeaders;
+
+  /** Like the superclass field of the same name, but a long and available on all platforms. */
+  private long fixedContentLength = -1L;
+
+  // These fields are guarded by lock.
+  private final Object lock = new Object();
+  private Response response;
+  private Throwable callFailure;
+  Response networkResponse;
+  boolean connectPending = true;
+  Proxy proxy;
+  Handshake handshake;
+
+  public OkHttpURLConnection(URL url, OkHttpClient client) {
+    super(url);
+    this.client = client;
+  }
+
+  public OkHttpURLConnection(URL url, OkHttpClient client, URLFilter urlFilter) {
+    this(url, client);
+    this.urlFilter = urlFilter;
+  }
+
+  @Override public void connect() throws IOException {
+    if (executed) return;
+
+    Call call = buildCall();
+    executed = true;
+    call.enqueue(this);
+
+    synchronized (lock) {
+      try {
+        while (connectPending && response == null && callFailure == null) {
+          lock.wait(); // Wait 'til the network interceptor is reached or the call fails.
+        }
+        if (callFailure != null) {
+          throw propagate(callFailure);
+        }
+      } catch (InterruptedException e) {
+        throw new InterruptedIOException();
+      }
+    }
+  }
+
+  @Override public void disconnect() {
+    // Calling disconnect() before a connection exists should have no effect.
+    if (call == null) return;
+
+    networkInterceptor.proceed(); // Unblock any waiting async thread.
+    call.cancel();
+  }
+
+  /**
+   * Returns an input stream from the server in the case of error such as the requested file (txt,
+   * htm, html) is not found on the remote server.
+   */
+  @Override public InputStream getErrorStream() {
+    try {
+      Response response = getResponse(true);
+      if (HttpHeaders.hasBody(response) && response.code() >= HTTP_BAD_REQUEST) {
+        return response.body().byteStream();
+      }
+      return null;
+    } catch (IOException e) {
+      return null;
+    }
+  }
+
+  private Headers getHeaders() throws IOException {
+    if (responseHeaders == null) {
+      Response response = getResponse(true);
+      Headers headers = response.headers();
+      responseHeaders = headers.newBuilder()
+          .add(SELECTED_PROTOCOL, response.protocol().toString())
+          .add(RESPONSE_SOURCE, responseSourceHeader(response))
+          .build();
+    }
+    return responseHeaders;
+  }
+
+  private static String responseSourceHeader(Response response) {
+    if (response.networkResponse() == null) {
+      if (response.cacheResponse() == null) {
+        return "NONE";
+      }
+      return "CACHE " + response.code();
+    }
+    if (response.cacheResponse() == null) {
+      return "NETWORK " + response.code();
+    }
+    return "CONDITIONAL_CACHE " + response.networkResponse().code();
+  }
+
+  /**
+   * Returns the value of the field at {@code position}. Returns null if there are fewer than {@code
+   * position} headers.
+   */
+  @Override public String getHeaderField(int position) {
+    try {
+      Headers headers = getHeaders();
+      if (position < 0 || position >= headers.size()) return null;
+      return headers.value(position);
+    } catch (IOException e) {
+      return null;
+    }
+  }
+
+  /**
+   * Returns the value of the field corresponding to the {@code fieldName}, or null if there is no
+   * such field. If the field has multiple values, the last value is returned.
+   */
+  @Override public String getHeaderField(String fieldName) {
+    try {
+      return fieldName == null
+          ? StatusLine.get(getResponse(true)).toString()
+          : getHeaders().get(fieldName);
+    } catch (IOException e) {
+      return null;
+    }
+  }
+
+  @Override public String getHeaderFieldKey(int position) {
+    try {
+      Headers headers = getHeaders();
+      if (position < 0 || position >= headers.size()) return null;
+      return headers.name(position);
+    } catch (IOException e) {
+      return null;
+    }
+  }
+
+  @Override public Map<String, List<String>> getHeaderFields() {
+    try {
+      return JavaNetHeaders.toMultimap(getHeaders(),
+          StatusLine.get(getResponse(true)).toString());
+    } catch (IOException e) {
+      return Collections.emptyMap();
+    }
+  }
+
+  @Override public Map<String, List<String>> getRequestProperties() {
+    if (connected) {
+      throw new IllegalStateException(
+          "Cannot access request header fields after connection is set");
+    }
+
+    return JavaNetHeaders.toMultimap(requestHeaders.build(), null);
+  }
+
+  @Override public InputStream getInputStream() throws IOException {
+    if (!doInput) {
+      throw new ProtocolException("This protocol does not support input");
+    }
+
+    Response response = getResponse(false);
+
+    if (response.code() >= HTTP_BAD_REQUEST) {
+      throw new FileNotFoundException(url.toString());
+    }
+
+    return response.body().byteStream();
+  }
+
+  @Override public OutputStream getOutputStream() throws IOException {
+    OutputStreamRequestBody requestBody = (OutputStreamRequestBody) buildCall().request().body();
+    if (requestBody == null) {
+      throw new ProtocolException("method does not support a request body: " + method);
+    }
+
+    // If this request needs to stream bytes to the server, build a physical connection immediately
+    // and start streaming those bytes over that connection.
+    if (requestBody instanceof StreamedRequestBody) {
+      connect();
+      networkInterceptor.proceed();
+    }
+
+    if (requestBody.isClosed()) {
+      throw new ProtocolException("cannot write request body after response has been read");
+    }
+
+    return requestBody.outputStream();
+  }
+
+  @Override public Permission getPermission() throws IOException {
+    URL url = getURL();
+    String hostname = url.getHost();
+    int hostPort = url.getPort() != -1
+        ? url.getPort()
+        : HttpUrl.defaultPort(url.getProtocol());
+    if (usingProxy()) {
+      InetSocketAddress proxyAddress = (InetSocketAddress) client.proxy().address();
+      hostname = proxyAddress.getHostName();
+      hostPort = proxyAddress.getPort();
+    }
+    return new SocketPermission(hostname + ":" + hostPort, "connect, resolve");
+  }
+
+  @Override public String getRequestProperty(String field) {
+    if (field == null) return null;
+    return requestHeaders.get(field);
+  }
+
+  @Override public void setConnectTimeout(int timeoutMillis) {
+    client = client.newBuilder()
+        .connectTimeout(timeoutMillis, TimeUnit.MILLISECONDS)
+        .build();
+  }
+
+  @Override public void setInstanceFollowRedirects(boolean followRedirects) {
+    client = client.newBuilder()
+        .followRedirects(followRedirects)
+        .build();
+  }
+
+  @Override public boolean getInstanceFollowRedirects() {
+    return client.followRedirects();
+  }
+
+  @Override public int getConnectTimeout() {
+    return client.connectTimeoutMillis();
+  }
+
+  @Override public void setReadTimeout(int timeoutMillis) {
+    client = client.newBuilder()
+        .readTimeout(timeoutMillis, TimeUnit.MILLISECONDS)
+        .build();
+  }
+
+  @Override public int getReadTimeout() {
+    return client.readTimeoutMillis();
+  }
+
+  private Call buildCall() throws IOException {
+    if (call != null) {
+      return call;
+    }
+
+    connected = true;
+    if (doOutput) {
+      if (method.equals("GET")) {
+        // they are requesting a stream to write to. This implies a POST method
+        method = "POST";
+      } else if (!HttpMethod.permitsRequestBody(method)) {
+        throw new ProtocolException(method + " does not support writing");
+      }
+    }
+
+    if (requestHeaders.get("User-Agent") == null) {
+      requestHeaders.add("User-Agent", defaultUserAgent());
+    }
+
+    OutputStreamRequestBody requestBody = null;
+    if (HttpMethod.permitsRequestBody(method)) {
+      // Add a content type for the request body, if one isn't already present.
+      String contentType = requestHeaders.get("Content-Type");
+      if (contentType == null) {
+        contentType = "application/x-www-form-urlencoded";
+        requestHeaders.add("Content-Type", contentType);
+      }
+
+      boolean stream = fixedContentLength != -1L || chunkLength > 0;
+
+      long contentLength = -1L;
+      String contentLengthString = requestHeaders.get("Content-Length");
+      if (fixedContentLength != -1L) {
+        contentLength = fixedContentLength;
+      } else if (contentLengthString != null) {
+        contentLength = Long.parseLong(contentLengthString);
+      }
+
+      requestBody = stream
+          ? new StreamedRequestBody(contentLength)
+          : new BufferedRequestBody(contentLength);
+      requestBody.timeout().timeout(client.writeTimeoutMillis(), TimeUnit.MILLISECONDS);
+    }
+
+    Request request = new Request.Builder()
+        .url(Internal.instance.getHttpUrlChecked(getURL().toString()))
+        .headers(requestHeaders.build())
+        .method(method, requestBody)
+        .build();
+
+    if (urlFilter != null) {
+      urlFilter.checkURLPermitted(request.url().url());
+    }
+
+    OkHttpClient.Builder clientBuilder = client.newBuilder();
+    clientBuilder.interceptors().clear();
+    clientBuilder.interceptors().add(UnexpectedException.INTERCEPTOR);
+    clientBuilder.networkInterceptors().clear();
+    clientBuilder.networkInterceptors().add(networkInterceptor);
+
+    // Use a separate dispatcher so that limits aren't impacted. But use the same executor service!
+    clientBuilder.dispatcher(new Dispatcher(client.dispatcher().executorService()));
+
+    // If we're currently not using caches, make sure the engine's client doesn't have one.
+    if (!getUseCaches()) {
+      clientBuilder.cache(null);
+    }
+
+    return call = clientBuilder.build().newCall(request);
+  }
+
+  private String defaultUserAgent() {
+    String agent = System.getProperty("http.agent");
+    return agent != null ? Util.toHumanReadableAscii(agent) : Version.userAgent();
+  }
+
+  /**
+   * Aggressively tries to get the final HTTP response, potentially making many HTTP requests in the
+   * process in order to cope with redirects and authentication.
+   */
+  private Response getResponse(boolean networkResponseOnError) throws IOException {
+    synchronized (lock) {
+      if (response != null) return response;
+      if (callFailure != null) {
+        if (networkResponseOnError && networkResponse != null) return networkResponse;
+        throw propagate(callFailure);
+      }
+    }
+
+    Call call = buildCall();
+    networkInterceptor.proceed();
+
+    OutputStreamRequestBody requestBody = (OutputStreamRequestBody) call.request().body();
+    if (requestBody != null) requestBody.outputStream().close();
+
+    if (executed) {
+      synchronized (lock) {
+        try {
+          while (response == null && callFailure == null) {
+            lock.wait(); // Wait until the response is returned or the call fails.
+          }
+        } catch (InterruptedException e) {
+          throw new InterruptedIOException();
+        }
+      }
+    } else {
+      executed = true;
+      try {
+        onResponse(call, call.execute());
+      } catch (IOException e) {
+        onFailure(call, e);
+      }
+    }
+
+    synchronized (lock) {
+      if (callFailure != null) throw propagate(callFailure);
+      if (response != null) return response;
+    }
+
+    throw new AssertionError();
+  }
+
+  /**
+   * Returns true if either:
+   *
+   * <ul>
+   *   <li>A specific proxy was explicitly configured for this connection.
+   *   <li>The response has already been retrieved, and a proxy was {@link
+   *       java.net.ProxySelector selected} in order to get it.
+   * </ul>
+   *
+   * <p><strong>Warning:</strong> This method may return false before attempting to connect and true
+   * afterwards.
+   */
+  @Override public boolean usingProxy() {
+    if (proxy != null) return true;
+    Proxy clientProxy = client.proxy();
+    return clientProxy != null && clientProxy.type() != Proxy.Type.DIRECT;
+  }
+
+  @Override public String getResponseMessage() throws IOException {
+    return getResponse(true).message();
+  }
+
+  @Override public int getResponseCode() throws IOException {
+    return getResponse(true).code();
+  }
+
+  @Override public void setRequestProperty(String field, String newValue) {
+    if (connected) {
+      throw new IllegalStateException("Cannot set request property after connection is made");
+    }
+    if (field == null) {
+      throw new NullPointerException("field == null");
+    }
+    if (newValue == null) {
+      // Silently ignore null header values for backwards compatibility with older
+      // android versions as well as with other URLConnection implementations.
+      //
+      // Some implementations send a malformed HTTP header when faced with
+      // such requests, we respect the spec and ignore the header.
+      Platform.get().log(WARN, "Ignoring header " + field + " because its value was null.", null);
+      return;
+    }
+
+    requestHeaders.set(field, newValue);
+  }
+
+  @Override public void setIfModifiedSince(long newValue) {
+    super.setIfModifiedSince(newValue);
+    if (ifModifiedSince != 0) {
+      requestHeaders.set("If-Modified-Since", HttpDate.format(new Date(ifModifiedSince)));
+    } else {
+      requestHeaders.removeAll("If-Modified-Since");
+    }
+  }
+
+  @Override public void addRequestProperty(String field, String value) {
+    if (connected) {
+      throw new IllegalStateException("Cannot add request property after connection is made");
+    }
+    if (field == null) {
+      throw new NullPointerException("field == null");
+    }
+    if (value == null) {
+      // Silently ignore null header values for backwards compatibility with older
+      // android versions as well as with other URLConnection implementations.
+      //
+      // Some implementations send a malformed HTTP header when faced with
+      // such requests, we respect the spec and ignore the header.
+      Platform.get().log(WARN, "Ignoring header " + field + " because its value was null.", null);
+      return;
+    }
+
+    requestHeaders.add(field, value);
+  }
+
+  @Override public void setRequestMethod(String method) throws ProtocolException {
+    if (!METHODS.contains(method)) {
+      throw new ProtocolException("Expected one of " + METHODS + " but was " + method);
+    }
+    this.method = method;
+  }
+
+  @Override public void setFixedLengthStreamingMode(int contentLength) {
+    setFixedLengthStreamingMode((long) contentLength);
+  }
+
+  @Override public void setFixedLengthStreamingMode(long contentLength) {
+    if (super.connected) throw new IllegalStateException("Already connected");
+    if (chunkLength > 0) throw new IllegalStateException("Already in chunked mode");
+    if (contentLength < 0) throw new IllegalArgumentException("contentLength < 0");
+    this.fixedContentLength = contentLength;
+    super.fixedContentLength = (int) Math.min(contentLength, Integer.MAX_VALUE);
+  }
+
+  @Override public void onFailure(Call call, IOException e) {
+    synchronized (lock) {
+      this.callFailure = (e instanceof UnexpectedException) ? e.getCause() : e;
+      lock.notifyAll();
+    }
+  }
+
+  @Override public void onResponse(Call call, Response response) {
+    synchronized (lock) {
+      this.response = response;
+      this.handshake = response.handshake();
+      this.url = response.request().url().url();
+      lock.notifyAll();
+    }
+  }
+
+  static final class UnexpectedException extends IOException {
+    static final Interceptor INTERCEPTOR = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        try {
+          return chain.proceed(chain.request());
+        } catch (Error | RuntimeException e) {
+          throw new UnexpectedException(e);
+        }
+      }
+    };
+
+    UnexpectedException(Throwable cause) {
+      super(cause);
+    }
+  }
+
+  /** Throws {@code throwable} as either an IOException, RuntimeException, or Error. */
+  private static IOException propagate(Throwable throwable) throws IOException {
+    if (throwable instanceof IOException) throw (IOException) throwable;
+    if (throwable instanceof Error) throw (Error) throwable;
+    if (throwable instanceof RuntimeException) throw (RuntimeException) throwable;
+    throw new AssertionError();
+  }
+
+  /**
+   * The HttpURLConnection gives the application control between establishing the connection and
+   * transmitting the request body. This interceptor stalls async calls right at this point. The
+   * call will remain stalled until {@link #proceed()} is called.
+   */
+  final class NetworkInterceptor implements Interceptor {
+    // Guarded by HttpUrlConnection.this.
+    private boolean proceed;
+
+    public void proceed() {
+      synchronized (lock) {
+        this.proceed = true;
+        lock.notifyAll();
+      }
+    }
+
+    @Override public Response intercept(Chain chain) throws IOException {
+      Request request = chain.request();
+
+      // Double-check the URL filter to prevent redirects from hitting filtered URLs.
+      if (urlFilter != null) {
+        urlFilter.checkURLPermitted(request.url().url());
+      }
+
+      synchronized (lock) {
+        connectPending = false;
+        proxy = chain.connection().route().proxy();
+        handshake = chain.connection().handshake();
+        lock.notifyAll();
+
+        try {
+          while (!proceed) {
+            lock.wait(); // Wait until proceed() is called.
+          }
+        } catch (InterruptedException e) {
+          throw new InterruptedIOException();
+        }
+      }
+
+      // Try to lock in the Content-Length before transmitting the request body.
+      if (request.body() instanceof OutputStreamRequestBody) {
+        OutputStreamRequestBody requestBody = (OutputStreamRequestBody) request.body();
+        request = requestBody.prepareToSendRequest(request);
+      }
+
+      Response response = chain.proceed(request);
+
+      synchronized (lock) {
+        networkResponse = response;
+        url = response.request().url().url();
+      }
+
+      return response;
+    }
+  }
+}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpsURLConnection.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpsURLConnection.java
new file mode 100644
index 0000000000..0057174226
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpsURLConnection.java
@@ -0,0 +1,71 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3.internal.huc;
+
+import java.net.URL;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLSocketFactory;
+import okhttp3.Handshake;
+import okhttp3.OkHttpClient;
+import okhttp3.internal.URLFilter;
+
+public final class OkHttpsURLConnection extends DelegatingHttpsURLConnection {
+  private final OkHttpURLConnection delegate;
+
+  public OkHttpsURLConnection(URL url, OkHttpClient client) {
+    this(new OkHttpURLConnection(url, client));
+  }
+
+  public OkHttpsURLConnection(URL url, OkHttpClient client, URLFilter filter) {
+    this(new OkHttpURLConnection(url, client, filter));
+  }
+
+  public OkHttpsURLConnection(OkHttpURLConnection delegate) {
+    super(delegate);
+    this.delegate = delegate;
+  }
+
+  @Override protected Handshake handshake() {
+    if (delegate.call == null) {
+      throw new IllegalStateException("Connection has not yet been established");
+    }
+
+    return delegate.handshake;
+  }
+
+  @Override public void setHostnameVerifier(HostnameVerifier hostnameVerifier) {
+    delegate.client = delegate.client.newBuilder()
+        .hostnameVerifier(hostnameVerifier)
+        .build();
+  }
+
+  @Override public HostnameVerifier getHostnameVerifier() {
+    return delegate.client.hostnameVerifier();
+  }
+
+  @Override public void setSSLSocketFactory(SSLSocketFactory sslSocketFactory) {
+    // This fails in JDK 9 because OkHttp is unable to extract the trust manager.
+    delegate.client = delegate.client.newBuilder()
+        .sslSocketFactory(sslSocketFactory)
+        .build();
+  }
+
+  @Override public SSLSocketFactory getSSLSocketFactory() {
+    return delegate.client.sslSocketFactory();
+  }
+
+}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OutputStreamRequestBody.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OutputStreamRequestBody.java
new file mode 100644
index 0000000000..6f4e8ef9e9
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OutputStreamRequestBody.java
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.huc;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.io.OutputStream;
+import java.net.ProtocolException;
+import java.net.SocketTimeoutException;
+import okhttp3.MediaType;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okio.BufferedSink;
+import okio.Timeout;
+
+/**
+ * A request body that's populated by blocking writes to an output stream. The output data is either
+ * fully buffered (with {@link BufferedRequestBody}) or streamed (with {@link StreamedRequestBody}).
+ * In either case the bytes of the body aren't known until the caller writes them to the output
+ * stream.
+ */
+abstract class OutputStreamRequestBody extends RequestBody {
+  private Timeout timeout;
+  private long expectedContentLength;
+  private OutputStream outputStream;
+  boolean closed;
+
+  protected void initOutputStream(final BufferedSink sink, final long expectedContentLength) {
+    this.timeout = sink.timeout();
+    this.expectedContentLength = expectedContentLength;
+
+    // An output stream that writes to sink. If expectedContentLength is not -1, then this expects
+    // exactly that many bytes to be written.
+    this.outputStream = new OutputStream() {
+      private long bytesReceived;
+
+      @Override public void write(int b) throws IOException {
+        write(new byte[] {(byte) b}, 0, 1);
+      }
+
+      @Override public void write(byte[] source, int offset, int byteCount) throws IOException {
+        if (closed) throw new IOException("closed"); // Not IllegalStateException!
+
+        if (expectedContentLength != -1L && bytesReceived + byteCount > expectedContentLength) {
+          throw new ProtocolException("expected " + expectedContentLength
+              + " bytes but received " + bytesReceived + byteCount);
+        }
+
+        bytesReceived += byteCount;
+        try {
+          sink.write(source, offset, byteCount);
+        } catch (InterruptedIOException e) {
+          throw new SocketTimeoutException(e.getMessage());
+        }
+      }
+
+      @Override public void flush() throws IOException {
+        if (closed) return; // Weird, but consistent with historical behavior.
+        sink.flush();
+      }
+
+      @Override public void close() throws IOException {
+        closed = true;
+
+        if (expectedContentLength != -1L && bytesReceived < expectedContentLength) {
+          throw new ProtocolException("expected " + expectedContentLength
+              + " bytes but received " + bytesReceived);
+        }
+
+        sink.close();
+      }
+    };
+  }
+
+  public final OutputStream outputStream() {
+    return outputStream;
+  }
+
+  public final Timeout timeout() {
+    return timeout;
+  }
+
+  public final boolean isClosed() {
+    return closed;
+  }
+
+  @Override public long contentLength() throws IOException {
+    return expectedContentLength;
+  }
+
+  @Override public final MediaType contentType() {
+    return null; // Let the caller provide this in a regular header.
+  }
+
+  public Request prepareToSendRequest(Request request) throws IOException {
+    return request;
+  }
+}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/StreamedRequestBody.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/StreamedRequestBody.java
new file mode 100644
index 0000000000..201ab09b66
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/StreamedRequestBody.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.huc;
+
+import java.io.IOException;
+import okhttp3.internal.http.UnrepeatableRequestBody;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.Okio;
+import okio.Pipe;
+
+/**
+ * This request body streams bytes from an application thread to an OkHttp dispatcher thread via a
+ * pipe. Because the data is not buffered it can only be transmitted once.
+ */
+final class StreamedRequestBody extends OutputStreamRequestBody implements UnrepeatableRequestBody {
+  private final Pipe pipe = new Pipe(8192);
+
+  StreamedRequestBody(long expectedContentLength) {
+    initOutputStream(Okio.buffer(pipe.sink()), expectedContentLength);
+  }
+
+  @Override public void writeTo(BufferedSink sink) throws IOException {
+    Buffer buffer = new Buffer();
+    while (pipe.source().read(buffer, 8192) != -1L) {
+      sink.write(buffer, buffer.size());
+    }
+  }
+}
diff --git a/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java b/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java
new file mode 100644
index 0000000000..d0f706f0d0
--- /dev/null
+++ b/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java
@@ -0,0 +1,238 @@
+package okhttp3;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Locale;
+import java.util.TimeZone;
+import java.util.concurrent.TimeUnit;
+import javax.net.ssl.HttpsURLConnection;
+import okhttp3.internal.URLFilter;
+import okhttp3.internal.huc.OkHttpURLConnection;
+import okhttp3.internal.io.InMemoryFileSystem;
+import okhttp3.internal.tls.SslClient;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okio.BufferedSource;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static java.nio.charset.StandardCharsets.US_ASCII;
+import static okio.Okio.buffer;
+import static okio.Okio.source;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public class OkUrlFactoryTest {
+  @Rule public MockWebServer server = new MockWebServer();
+  @Rule public InMemoryFileSystem fileSystem = new InMemoryFileSystem();
+
+  private OkUrlFactory factory;
+  private Cache cache;
+
+  @Before public void setUp() throws IOException {
+    cache = new Cache(new File("/cache/"), 10 * 1024 * 1024, fileSystem);
+    OkHttpClient client = new OkHttpClient.Builder()
+        .cache(cache)
+        .build();
+    factory = new OkUrlFactory(client);
+  }
+
+  @After public void tearDown() throws IOException {
+    cache.delete();
+  }
+
+  /**
+   * Response code 407 should only come from proxy servers. Android's client throws if it is sent by
+   * an origin server.
+   */
+  @Test public void originServerSends407() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(407));
+
+    HttpURLConnection conn = factory.open(server.url("/").url());
+    try {
+      conn.getResponseCode();
+      fail();
+    } catch (IOException ignored) {
+    }
+  }
+
+  @Test public void networkResponseSourceHeader() throws Exception {
+    server.enqueue(new MockResponse().setBody("Isla Sorna"));
+
+    HttpURLConnection connection = factory.open(server.url("/").url());
+    assertResponseHeader(connection, "NETWORK 200");
+    assertResponseBody(connection, "Isla Sorna");
+  }
+
+  @Test public void networkFailureResponseSourceHeader() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    HttpURLConnection connection = factory.open(server.url("/").url());
+    assertResponseHeader(connection, "NETWORK 404");
+    connection.getErrorStream().close();
+  }
+
+  @Test public void conditionalCacheHitResponseSourceHeaders() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(0, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("Isla Nublar"));
+    server.enqueue(new MockResponse().setResponseCode(304));
+
+    HttpURLConnection connection1 = factory.open(server.url("/").url());
+    assertResponseHeader(connection1, "NETWORK 200");
+    assertResponseBody(connection1, "Isla Nublar");
+
+    HttpURLConnection connection2 = factory.open(server.url("/").url());
+    assertResponseHeader(connection2, "CONDITIONAL_CACHE 304");
+    assertResponseBody(connection2, "Isla Nublar");
+  }
+
+  @Test public void conditionalCacheMissResponseSourceHeaders() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(0, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("Isla Nublar"));
+    server.enqueue(new MockResponse().setBody("Isla Sorna"));
+
+    HttpURLConnection connection1 = factory.open(server.url("/").url());
+    assertResponseHeader(connection1, "NETWORK 200");
+    assertResponseBody(connection1, "Isla Nublar");
+
+    HttpURLConnection connection2 = factory.open(server.url("/").url());
+    assertResponseHeader(connection2, "CONDITIONAL_CACHE 200");
+    assertResponseBody(connection2, "Isla Sorna");
+  }
+
+  @Test public void cacheResponseSourceHeaders() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Expires: " + formatDate(2, TimeUnit.HOURS))
+        .setBody("Isla Nublar"));
+
+    HttpURLConnection connection1 = factory.open(server.url("/").url());
+    assertResponseHeader(connection1, "NETWORK 200");
+    assertResponseBody(connection1, "Isla Nublar");
+
+    HttpURLConnection connection2 = factory.open(server.url("/").url());
+    assertResponseHeader(connection2, "CACHE 200");
+    assertResponseBody(connection2, "Isla Nublar");
+  }
+
+  @Test public void noneResponseSourceHeaders() throws Exception {
+    server.enqueue(new MockResponse().setBody("Isla Nublar"));
+
+    HttpURLConnection connection1 = factory.open(server.url("/").url());
+    assertResponseHeader(connection1, "NETWORK 200");
+    assertResponseBody(connection1, "Isla Nublar");
+
+    HttpURLConnection connection2 = factory.open(server.url("/").url());
+    connection2.setRequestProperty("Cache-Control", "only-if-cached");
+    assertResponseHeader(connection2, "NONE");
+  }
+
+  @Test
+  public void setInstanceFollowRedirectsFalse() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: /b")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    HttpURLConnection connection = factory.open(server.url("/a").url());
+    connection.setInstanceFollowRedirects(false);
+    assertResponseBody(connection, "A");
+    assertResponseCode(connection, 302);
+  }
+
+  @Test
+  public void testURLFilter() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+    final URL blockedURL = server.url("/a").url();
+    factory.setUrlFilter(new URLFilter() {
+      @Override
+      public void checkURLPermitted(URL url) throws IOException {
+        if (blockedURL.equals(url)) {
+          throw new IOException("Blocked");
+        }
+      }
+    });
+    try {
+      HttpURLConnection connection = factory.open(server.url("/a").url());
+      connection.getInputStream();
+      fail("Connection was successful");
+    } catch (IOException e) {
+      assertEquals("Blocked", e.getMessage());
+    }
+    HttpURLConnection connection = factory.open(server.url("/b").url());
+    assertResponseBody(connection, "B");
+  }
+
+  @Test
+  public void testURLFilterRedirect() throws Exception {
+    MockWebServer cleartextServer = new MockWebServer();
+    cleartextServer.enqueue(new MockResponse()
+        .setBody("Blocked!"));
+    final URL blockedURL = cleartextServer.url("/").url();
+
+    SslClient contextBuilder = SslClient.localhost();
+    server.useHttps(contextBuilder.socketFactory, false);
+    factory.setClient(factory.client().newBuilder()
+        .sslSocketFactory(contextBuilder.socketFactory, contextBuilder.trustManager)
+        .followSslRedirects(true)
+        .build());
+    factory.setUrlFilter(new URLFilter() {
+      @Override
+      public void checkURLPermitted(URL url) throws IOException {
+        if (blockedURL.equals(url)) {
+          throw new IOException("Blocked");
+        }
+      }
+    });
+
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: " + blockedURL)
+        .setBody("This page has moved"));
+    URL destination = server.url("/").url();
+    try {
+      HttpsURLConnection httpsConnection = (HttpsURLConnection) factory.open(destination);
+      httpsConnection.getInputStream();
+      fail("Connection was successful");
+    } catch (IOException expected) {
+    }
+  }
+
+  private void assertResponseBody(HttpURLConnection connection, String expected) throws Exception {
+    BufferedSource source = buffer(source(connection.getInputStream()));
+    String actual = source.readString(US_ASCII);
+    source.close();
+    assertEquals(expected, actual);
+  }
+
+  private void assertResponseHeader(HttpURLConnection connection, String expected) {
+    assertEquals(expected, connection.getHeaderField(OkHttpURLConnection.RESPONSE_SOURCE));
+  }
+
+  private void assertResponseCode(HttpURLConnection connection, int expected) throws IOException {
+    assertEquals(expected, connection.getResponseCode());
+  }
+
+  private static String formatDate(long delta, TimeUnit timeUnit) {
+    return formatDate(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
+  }
+
+  private static String formatDate(Date date) {
+    DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
+    rfc1123.setTimeZone(TimeZone.getTimeZone("GMT"));
+    return rfc1123.format(date);
+  }
+}
diff --git a/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java b/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java
new file mode 100644
index 0000000000..ab4af9a350
--- /dev/null
+++ b/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java
@@ -0,0 +1,1849 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package okhttp3;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.net.CookieManager;
+import java.net.HttpURLConnection;
+import java.net.ResponseCache;
+import java.net.URL;
+import java.net.URLConnection;
+import java.security.Principal;
+import java.security.cert.Certificate;
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.List;
+import java.util.Locale;
+import java.util.TimeZone;
+import java.util.concurrent.TimeUnit;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLSession;
+import okhttp3.internal.Internal;
+import okhttp3.internal.io.InMemoryFileSystem;
+import okhttp3.internal.platform.Platform;
+import okhttp3.internal.tls.SslClient;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.GzipSink;
+import okio.Okio;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeFalse;
+
+/** Test caching with {@link OkUrlFactory}. */
+public final class UrlConnectionCacheTest {
+  private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = new HostnameVerifier() {
+    @Override public boolean verify(String s, SSLSession sslSession) {
+      return true;
+    }
+  };
+
+  @Rule public MockWebServer server = new MockWebServer();
+  @Rule public MockWebServer server2 = new MockWebServer();
+  @Rule public InMemoryFileSystem fileSystem = new InMemoryFileSystem();
+
+  private final SslClient sslClient = SslClient.localhost();
+  private OkUrlFactory urlFactory = new OkUrlFactory(new OkHttpClient());
+  private Cache cache;
+  private final CookieManager cookieManager = new CookieManager();
+
+  @Before public void setUp() throws Exception {
+    server.setProtocolNegotiationEnabled(false);
+    cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
+    urlFactory = new OkUrlFactory(new OkHttpClient.Builder()
+        .cache(cache)
+        .cookieJar(new JavaNetCookieJar(cookieManager))
+        .build());
+  }
+
+  @After public void tearDown() throws Exception {
+    ResponseCache.setDefault(null);
+    cache.delete();
+  }
+
+  @Test public void responseCacheAccessWithOkHttpMember() throws IOException {
+    assertSame(cache, urlFactory.client().cache());
+  }
+
+  /**
+   * Test that response caching is consistent with the RI and the spec.
+   * http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.4
+   */
+  @Test public void responseCachingByResponseCode() throws Exception {
+    // Test each documented HTTP/1.1 code, plus the first unused value in each range.
+    // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
+
+    // We can't test 100 because it's not really a response.
+    // assertCached(false, 100);
+    assertCached(false, 101);
+    assertCached(false, 102);
+    assertCached(true, 200);
+    assertCached(false, 201);
+    assertCached(false, 202);
+    assertCached(true, 203);
+    assertCached(true, 204);
+    assertCached(false, 205);
+    assertCached(false, 206); //Electing to not cache partial responses
+    assertCached(false, 207);
+    assertCached(true, 300);
+    assertCached(true, 301);
+    assertCached(true, 302);
+    assertCached(false, 303);
+    assertCached(false, 304);
+    assertCached(false, 305);
+    assertCached(false, 306);
+    assertCached(true, 307);
+    assertCached(true, 308);
+    assertCached(false, 400);
+    assertCached(false, 401);
+    assertCached(false, 402);
+    assertCached(false, 403);
+    assertCached(true, 404);
+    assertCached(true, 405);
+    assertCached(false, 406);
+    assertCached(false, 408);
+    assertCached(false, 409);
+    // the HTTP spec permits caching 410s, but the RI doesn't.
+    assertCached(true, 410);
+    assertCached(false, 411);
+    assertCached(false, 412);
+    assertCached(false, 413);
+    assertCached(true, 414);
+    assertCached(false, 415);
+    assertCached(false, 416);
+    assertCached(false, 417);
+    assertCached(false, 418);
+
+    assertCached(false, 500);
+    assertCached(true, 501);
+    assertCached(false, 502);
+    assertCached(false, 503);
+    assertCached(false, 504);
+    assertCached(false, 505);
+    assertCached(false, 506);
+  }
+
+  private void assertCached(boolean shouldPut, int responseCode) throws Exception {
+    int expectedResponseCode = responseCode;
+
+    server = new MockWebServer();
+    MockResponse response = new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setResponseCode(responseCode)
+        .setBody("ABCDE")
+        .addHeader("WWW-Authenticate: challenge");
+    if (responseCode == HttpURLConnection.HTTP_PROXY_AUTH) {
+      response.addHeader("Proxy-Authenticate: Basic realm=\"protected area\"");
+    } else if (responseCode == HttpURLConnection.HTTP_UNAUTHORIZED) {
+      response.addHeader("WWW-Authenticate: Basic realm=\"protected area\"");
+    } else if (responseCode == HttpURLConnection.HTTP_NO_CONTENT
+        || responseCode == HttpURLConnection.HTTP_RESET) {
+      response.setBody(""); // We forbid bodies for 204 and 205.
+    }
+    server.enqueue(response);
+
+    if (responseCode == HttpURLConnection.HTTP_CLIENT_TIMEOUT) {
+      // 408's are a bit of an outlier because we may repeat the request if we encounter this
+      // response code. In this scenario, there are 2 responses: the initial 408 and then the 200
+      // because of the retry. We just want to ensure the initial 408 isn't cached.
+      expectedResponseCode = 200;
+      server.enqueue(new MockResponse()
+          .addHeader("Cache-Control", "no-store")
+          .setBody("FGHIJ"));
+    }
+
+    server.start();
+
+    URL url = server.url("/").url();
+    HttpURLConnection conn = urlFactory.open(url);
+    assertEquals(expectedResponseCode, conn.getResponseCode());
+
+    // exhaust the content stream
+    readAscii(conn);
+
+    Response cached = cache.get(new Request.Builder().url(url).build());
+    if (shouldPut) {
+      assertNotNull(Integer.toString(responseCode), cached);
+      cached.body().close();
+    } else {
+      assertNull(Integer.toString(responseCode), cached);
+    }
+    server.shutdown(); // tearDown() isn't sufficient; this test starts multiple servers
+  }
+
+  @Test public void responseCachingAndInputStreamSkipWithFixedLength() throws IOException {
+    testResponseCaching(TransferKind.FIXED_LENGTH);
+  }
+
+  @Test public void responseCachingAndInputStreamSkipWithChunkedEncoding() throws IOException {
+    testResponseCaching(TransferKind.CHUNKED);
+  }
+
+  @Test public void responseCachingAndInputStreamSkipWithNoLengthHeaders() throws IOException {
+    testResponseCaching(TransferKind.END_OF_STREAM);
+  }
+
+  /**
+   * HttpURLConnection.getInputStream().skip(long) causes ResponseCache corruption
+   * http://code.google.com/p/android/issues/detail?id=8175
+   */
+  private void testResponseCaching(TransferKind transferKind) throws IOException {
+    MockResponse response =
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+            .setStatus("HTTP/1.1 200 Fantastic");
+    transferKind.setBody(response, "I love puppies but hate spiders", 1);
+    server.enqueue(response);
+
+    // Make sure that calling skip() doesn't omit bytes from the cache.
+    HttpURLConnection urlConnection = urlFactory.open(server.url("/").url());
+    InputStream in = urlConnection.getInputStream();
+    assertEquals("I love ", readAscii(urlConnection, "I love ".length()));
+    reliableSkip(in, "puppies but hate ".length());
+    assertEquals("spiders", readAscii(urlConnection, "spiders".length()));
+    assertEquals(-1, in.read());
+    in.close();
+    assertEquals(1, cache.writeSuccessCount());
+    assertEquals(0, cache.writeAbortCount());
+
+    urlConnection = urlFactory.open(server.url("/").url()); // cached!
+    in = urlConnection.getInputStream();
+    assertEquals("I love puppies but hate spiders",
+        readAscii(urlConnection, "I love puppies but hate spiders".length()));
+    assertEquals(200, urlConnection.getResponseCode());
+    assertEquals("Fantastic", urlConnection.getResponseMessage());
+
+    assertEquals(-1, in.read());
+    in.close();
+    assertEquals(1, cache.writeSuccessCount());
+    assertEquals(0, cache.writeAbortCount());
+    assertEquals(2, cache.requestCount());
+    assertEquals(1, cache.hitCount());
+  }
+
+  @Test public void secureResponseCaching() throws IOException {
+    assumeFalse(getPlatform().equals("jdk9"));
+
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setBody("ABC"));
+
+    HttpsURLConnection c1 = (HttpsURLConnection) urlFactory.open(server.url("/").url());
+    c1.setSSLSocketFactory(sslClient.socketFactory);
+    c1.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    assertEquals("ABC", readAscii(c1));
+
+    // OpenJDK 6 fails on this line, complaining that the connection isn't open yet
+    String suite = c1.getCipherSuite();
+    List<Certificate> localCerts = toListOrNull(c1.getLocalCertificates());
+    List<Certificate> serverCerts = toListOrNull(c1.getServerCertificates());
+    Principal peerPrincipal = c1.getPeerPrincipal();
+    Principal localPrincipal = c1.getLocalPrincipal();
+
+    HttpsURLConnection c2 = (HttpsURLConnection) urlFactory.open(server.url("/").url()); // cached!
+    c2.setSSLSocketFactory(sslClient.socketFactory);
+    c2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    assertEquals("ABC", readAscii(c2));
+
+    assertEquals(2, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(1, cache.hitCount());
+
+    assertEquals(suite, c2.getCipherSuite());
+    assertEquals(localCerts, toListOrNull(c2.getLocalCertificates()));
+    assertEquals(serverCerts, toListOrNull(c2.getServerCertificates()));
+    assertEquals(peerPrincipal, c2.getPeerPrincipal());
+    assertEquals(localPrincipal, c2.getLocalPrincipal());
+  }
+
+  @Test public void responseCachingAndRedirects() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
+        .addHeader("Location: /foo"));
+    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setBody("ABC"));
+    server.enqueue(new MockResponse().setBody("DEF"));
+
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
+    assertEquals("ABC", readAscii(connection));
+
+    connection = urlFactory.open(server.url("/").url()); // cached!
+    assertEquals("ABC", readAscii(connection));
+
+    assertEquals(4, cache.requestCount()); // 2 requests + 2 redirects
+    assertEquals(2, cache.networkCount());
+    assertEquals(2, cache.hitCount());
+  }
+
+  @Test public void redirectToCachedResult() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60").setBody("ABC"));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
+        .addHeader("Location: /foo"));
+    server.enqueue(new MockResponse().setBody("DEF"));
+
+    assertEquals("ABC", readAscii(urlFactory.open(server.url("/foo").url())));
+    RecordedRequest request1 = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", request1.getRequestLine());
+    assertEquals(0, request1.getSequenceNumber());
+
+    assertEquals("ABC", readAscii(urlFactory.open(server.url("/bar").url())));
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals("GET /bar HTTP/1.1", request2.getRequestLine());
+    assertEquals(1, request2.getSequenceNumber());
+
+    // an unrelated request should reuse the pooled connection
+    assertEquals("DEF", readAscii(urlFactory.open(server.url("/baz").url())));
+    RecordedRequest request3 = server.takeRequest();
+    assertEquals("GET /baz HTTP/1.1", request3.getRequestLine());
+    assertEquals(2, request3.getSequenceNumber());
+  }
+
+  @Test public void secureResponseCachingAndRedirects() throws IOException {
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
+        .addHeader("Location: /foo"));
+    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setBody("ABC"));
+    server.enqueue(new MockResponse().setBody("DEF"));
+
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
+        .build());
+
+    HttpsURLConnection connection1 = (HttpsURLConnection) urlFactory.open(server.url("/").url());
+    assertEquals("ABC", readAscii(connection1));
+    assertNotNull(connection1.getCipherSuite());
+
+    // Cached!
+    HttpsURLConnection connection2 = (HttpsURLConnection) urlFactory.open(server.url("/").url());
+    assertEquals("ABC", readAscii(connection2));
+    assertNotNull(connection2.getCipherSuite());
+
+    assertEquals(4, cache.requestCount()); // 2 direct + 2 redirect = 4
+    assertEquals(2, cache.hitCount());
+    assertEquals(connection1.getCipherSuite(), connection2.getCipherSuite());
+  }
+
+  /**
+   * We've had bugs where caching and cross-protocol redirects yield class cast exceptions internal
+   * to the cache because we incorrectly assumed that HttpsURLConnection was always HTTPS and
+   * HttpURLConnection was always HTTP; in practice redirects mean that each can do either.
+   *
+   * https://github.com/square/okhttp/issues/214
+   */
+  @Test public void secureResponseCachingAndProtocolRedirects() throws IOException {
+    server2.useHttps(sslClient.socketFactory, false);
+    server2.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setBody("ABC"));
+    server2.enqueue(new MockResponse().setBody("DEF"));
+
+    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
+        .addHeader("Location: " + server2.url("/").url()));
+
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
+        .build());
+
+    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
+    assertEquals("ABC", readAscii(connection1));
+
+    // Cached!
+    HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
+    assertEquals("ABC", readAscii(connection2));
+
+    assertEquals(4, cache.requestCount()); // 2 direct + 2 redirect = 4
+    assertEquals(2, cache.hitCount());
+  }
+
+  @Test public void serverDisconnectsPrematurelyWithContentLengthHeader() throws IOException {
+    testServerPrematureDisconnect(TransferKind.FIXED_LENGTH);
+  }
+
+  @Test public void serverDisconnectsPrematurelyWithChunkedEncoding() throws IOException {
+    testServerPrematureDisconnect(TransferKind.CHUNKED);
+  }
+
+  @Test public void serverDisconnectsPrematurelyWithNoLengthHeaders() throws IOException {
+    // Intentionally empty. This case doesn't make sense because there's no
+    // such thing as a premature disconnect when the disconnect itself
+    // indicates the end of the data stream.
+  }
+
+  private void testServerPrematureDisconnect(TransferKind transferKind) throws IOException {
+    MockResponse response = new MockResponse();
+    transferKind.setBody(response, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 16);
+    server.enqueue(truncateViolently(response, 16));
+    server.enqueue(new MockResponse().setBody("Request #2"));
+
+    BufferedReader reader = new BufferedReader(
+        new InputStreamReader(urlFactory.open(server.url("/").url()).getInputStream()));
+    assertEquals("ABCDE", reader.readLine());
+    try {
+      reader.readLine();
+      fail("This implementation silently ignored a truncated HTTP body.");
+    } catch (IOException expected) {
+    } finally {
+      reader.close();
+    }
+
+    assertEquals(1, cache.writeAbortCount());
+    assertEquals(0, cache.writeSuccessCount());
+    URLConnection connection = urlFactory.open(server.url("/").url());
+    assertEquals("Request #2", readAscii(connection));
+    assertEquals(1, cache.writeAbortCount());
+    assertEquals(1, cache.writeSuccessCount());
+  }
+
+  @Test public void clientPrematureDisconnectWithContentLengthHeader() throws IOException {
+    testClientPrematureDisconnect(TransferKind.FIXED_LENGTH);
+  }
+
+  @Test public void clientPrematureDisconnectWithChunkedEncoding() throws IOException {
+    testClientPrematureDisconnect(TransferKind.CHUNKED);
+  }
+
+  @Test public void clientPrematureDisconnectWithNoLengthHeaders() throws IOException {
+    testClientPrematureDisconnect(TransferKind.END_OF_STREAM);
+  }
+
+  private void testClientPrematureDisconnect(TransferKind transferKind) throws IOException {
+    // Setting a low transfer speed ensures that stream discarding will time out.
+    MockResponse response = new MockResponse().throttleBody(6, 1, TimeUnit.SECONDS);
+    transferKind.setBody(response, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 1024);
+    server.enqueue(response);
+    server.enqueue(new MockResponse().setBody("Request #2"));
+
+    URLConnection connection = urlFactory.open(server.url("/").url());
+    InputStream in = connection.getInputStream();
+    assertEquals("ABCDE", readAscii(connection, 5));
+    in.close();
+    try {
+      in.read();
+      fail("Expected an IOException because the stream is closed.");
+    } catch (IOException expected) {
+    }
+
+    assertEquals(1, cache.writeAbortCount());
+    assertEquals(0, cache.writeSuccessCount());
+    connection = urlFactory.open(server.url("/").url());
+    assertEquals("Request #2", readAscii(connection));
+    assertEquals(1, cache.writeAbortCount());
+    assertEquals(1, cache.writeSuccessCount());
+  }
+
+  @Test public void defaultExpirationDateFullyCachedForLessThan24Hours() throws Exception {
+    //      last modified: 105 seconds ago
+    //             served:   5 seconds ago
+    //   default lifetime: (105 - 5) / 10 = 10 seconds
+    //            expires:  10 seconds from served date = 5 seconds from now
+    server.enqueue(
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
+            .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
+            .setBody("A"));
+
+    URL url = server.url("/").url();
+    assertEquals("A", readAscii(urlFactory.open(url)));
+    URLConnection connection = urlFactory.open(url);
+    assertEquals("A", readAscii(connection));
+    assertNull(connection.getHeaderField("Warning"));
+  }
+
+  @Test public void defaultExpirationDateConditionallyCached() throws Exception {
+    //      last modified: 115 seconds ago
+    //             served:  15 seconds ago
+    //   default lifetime: (115 - 15) / 10 = 10 seconds
+    //            expires:  10 seconds from served date = 5 seconds ago
+    String lastModifiedDate = formatDate(-115, TimeUnit.SECONDS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(
+        new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
+            .addHeader("Date: " + formatDate(-15, TimeUnit.SECONDS)));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+  }
+
+  @Test public void defaultExpirationDateFullyCachedForMoreThan24Hours() throws Exception {
+    //      last modified: 105 days ago
+    //             served:   5 days ago
+    //   default lifetime: (105 - 5) / 10 = 10 days
+    //            expires:  10 days from served date = 5 days from now
+    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-105, TimeUnit.DAYS))
+        .addHeader("Date: " + formatDate(-5, TimeUnit.DAYS))
+        .setBody("A"));
+
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    URLConnection connection = urlFactory.open(server.url("/").url());
+    assertEquals("A", readAscii(connection));
+    assertEquals("113 HttpURLConnection \"Heuristic expiration\"",
+        connection.getHeaderField("Warning"));
+  }
+
+  @Test public void noDefaultExpirationForUrlsWithQueryString() throws Exception {
+    server.enqueue(
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
+            .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
+            .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    URL url = server.url("/?foo=bar").url();
+    assertEquals("A", readAscii(urlFactory.open(url)));
+    assertEquals("B", readAscii(urlFactory.open(url)));
+  }
+
+  @Test public void expirationDateInThePastWithLastModifiedHeader() throws Exception {
+    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(
+        new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
+            .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+  }
+
+  @Test public void expirationDateInThePastWithNoLastModifiedHeader() throws Exception {
+    assertNotCached(new MockResponse().addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+  }
+
+  @Test public void expirationDateInTheFuture() throws Exception {
+    assertFullyCached(new MockResponse().addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+  }
+
+  @Test public void maxAgePreferredWithMaxAgeAndExpires() throws Exception {
+    assertFullyCached(new MockResponse().addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgeInThePastWithDateAndLastModifiedHeaders() throws Exception {
+    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(
+        new MockResponse().addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
+            .addHeader("Last-Modified: " + lastModifiedDate)
+            .addHeader("Cache-Control: max-age=60"));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+  }
+
+  @Test public void maxAgeInThePastWithDateHeaderButNoLastModifiedHeader() throws Exception {
+    // Chrome interprets max-age relative to the local clock. Both our cache
+    // and Firefox both use the earlier of the local and server's clock.
+    assertNotCached(new MockResponse().addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgeInTheFutureWithDateHeader() throws Exception {
+    assertFullyCached(new MockResponse().addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgeInTheFutureWithNoDateHeader() throws Exception {
+    assertFullyCached(new MockResponse().addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgeWithLastModifiedButNoServedDate() throws Exception {
+    assertFullyCached(
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
+            .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgeInTheFutureWithDateAndLastModifiedHeaders() throws Exception {
+    assertFullyCached(
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
+            .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
+            .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgePreferredOverLowerSharedMaxAge() throws Exception {
+    assertFullyCached(new MockResponse().addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
+        .addHeader("Cache-Control: s-maxage=60")
+        .addHeader("Cache-Control: max-age=180"));
+  }
+
+  @Test public void maxAgePreferredOverHigherMaxAge() throws Exception {
+    assertNotCached(new MockResponse().addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
+        .addHeader("Cache-Control: s-maxage=180")
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void requestMethodOptionsIsNotCached() throws Exception {
+    testRequestMethod("OPTIONS", false);
+  }
+
+  @Test public void requestMethodGetIsCached() throws Exception {
+    testRequestMethod("GET", true);
+  }
+
+  @Test public void requestMethodHeadIsNotCached() throws Exception {
+    // We could support this but choose not to for implementation simplicity
+    testRequestMethod("HEAD", false);
+  }
+
+  @Test public void requestMethodPostIsNotCached() throws Exception {
+    // We could support this but choose not to for implementation simplicity
+    testRequestMethod("POST", false);
+  }
+
+  @Test public void requestMethodPutIsNotCached() throws Exception {
+    testRequestMethod("PUT", false);
+  }
+
+  @Test public void requestMethodDeleteIsNotCached() throws Exception {
+    testRequestMethod("DELETE", false);
+  }
+
+  @Test public void requestMethodTraceIsNotCached() throws Exception {
+    testRequestMethod("TRACE", false);
+  }
+
+  private void testRequestMethod(String requestMethod, boolean expectCached) throws Exception {
+    // 1. seed the cache (potentially)
+    // 2. expect a cache hit or miss
+    server.enqueue(new MockResponse().addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .addHeader("X-Response-ID: 1"));
+    server.enqueue(new MockResponse().addHeader("X-Response-ID: 2"));
+
+    URL url = server.url("/").url();
+
+    HttpURLConnection request1 = urlFactory.open(url);
+    request1.setRequestMethod(requestMethod);
+    addRequestBodyIfNecessary(requestMethod, request1);
+    request1.getInputStream().close();
+    assertEquals("1", request1.getHeaderField("X-Response-ID"));
+
+    URLConnection request2 = urlFactory.open(url);
+    request2.getInputStream().close();
+    if (expectCached) {
+      assertEquals("1", request2.getHeaderField("X-Response-ID"));
+    } else {
+      assertEquals("2", request2.getHeaderField("X-Response-ID"));
+    }
+  }
+
+  @Test public void postInvalidatesCache() throws Exception {
+    testMethodInvalidates("POST");
+  }
+
+  @Test public void putInvalidatesCache() throws Exception {
+    testMethodInvalidates("PUT");
+  }
+
+  @Test public void deleteMethodInvalidatesCache() throws Exception {
+    testMethodInvalidates("DELETE");
+  }
+
+  private void testMethodInvalidates(String requestMethod) throws Exception {
+    // 1. seed the cache
+    // 2. invalidate it
+    // 3. expect a cache miss
+    server.enqueue(
+        new MockResponse().setBody("A").addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse().setBody("B"));
+    server.enqueue(new MockResponse().setBody("C"));
+
+    URL url = server.url("/").url();
+
+    assertEquals("A", readAscii(urlFactory.open(url)));
+
+    HttpURLConnection invalidate = urlFactory.open(url);
+    invalidate.setRequestMethod(requestMethod);
+    addRequestBodyIfNecessary(requestMethod, invalidate);
+    assertEquals("B", readAscii(invalidate));
+
+    assertEquals("C", readAscii(urlFactory.open(url)));
+  }
+
+  @Test public void postInvalidatesCacheWithUncacheableResponse() throws Exception {
+    // 1. seed the cache
+    // 2. invalidate it with uncacheable response
+    // 3. expect a cache miss
+    server.enqueue(
+        new MockResponse().setBody("A").addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse().setBody("B").setResponseCode(500));
+    server.enqueue(new MockResponse().setBody("C"));
+
+    URL url = server.url("/").url();
+
+    assertEquals("A", readAscii(urlFactory.open(url)));
+
+    HttpURLConnection invalidate = urlFactory.open(url);
+    invalidate.setRequestMethod("POST");
+    addRequestBodyIfNecessary("POST", invalidate);
+    assertEquals("B", readAscii(invalidate));
+
+    assertEquals("C", readAscii(urlFactory.open(url)));
+  }
+
+  @Test public void etag() throws Exception {
+    RecordedRequest conditionalRequest =
+        assertConditionallyCached(new MockResponse().addHeader("ETag: v1"));
+    assertEquals("v1", conditionalRequest.getHeader("If-None-Match"));
+  }
+
+  @Test public void etagAndExpirationDateInThePast() throws Exception {
+    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(
+        new MockResponse().addHeader("ETag: v1")
+            .addHeader("Last-Modified: " + lastModifiedDate)
+            .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    assertEquals("v1", conditionalRequest.getHeader("If-None-Match"));
+    assertNull(conditionalRequest.getHeader("If-Modified-Since"));
+  }
+
+  @Test public void etagAndExpirationDateInTheFuture() throws Exception {
+    assertFullyCached(new MockResponse().addHeader("ETag: v1")
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+  }
+
+  @Test public void cacheControlNoCache() throws Exception {
+    assertNotCached(new MockResponse().addHeader("Cache-Control: no-cache"));
+  }
+
+  @Test public void cacheControlNoCacheAndExpirationDateInTheFuture() throws Exception {
+    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(
+        new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
+            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+            .addHeader("Cache-Control: no-cache"));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+  }
+
+  @Test public void pragmaNoCache() throws Exception {
+    assertNotCached(new MockResponse().addHeader("Pragma: no-cache"));
+  }
+
+  @Test public void pragmaNoCacheAndExpirationDateInTheFuture() throws Exception {
+    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(
+        new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
+            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+            .addHeader("Pragma: no-cache"));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+  }
+
+  @Test public void cacheControlNoStore() throws Exception {
+    assertNotCached(new MockResponse().addHeader("Cache-Control: no-store"));
+  }
+
+  @Test public void cacheControlNoStoreAndExpirationDateInTheFuture() throws Exception {
+    assertNotCached(new MockResponse().addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: no-store"));
+  }
+
+  @Test public void partialRangeResponsesDoNotCorruptCache() throws Exception {
+    // 1. request a range
+    // 2. request a full document, expecting a cache miss
+    server.enqueue(new MockResponse().setBody("AA")
+        .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .addHeader("Content-Range: bytes 1000-1001/2000"));
+    server.enqueue(new MockResponse().setBody("BB"));
+
+    URL url = server.url("/").url();
+
+    URLConnection range = urlFactory.open(url);
+    range.addRequestProperty("Range", "bytes=1000-1001");
+    assertEquals("AA", readAscii(range));
+
+    assertEquals("BB", readAscii(urlFactory.open(url)));
+  }
+
+  @Test public void serverReturnsDocumentOlderThanCache() throws Exception {
+    server.enqueue(new MockResponse().setBody("A")
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse().setBody("B")
+        .addHeader("Last-Modified: " + formatDate(-4, TimeUnit.HOURS)));
+
+    URL url = server.url("/").url();
+
+    assertEquals("A", readAscii(urlFactory.open(url)));
+    assertEquals("B", readAscii(urlFactory.open(url)));
+  }
+
+  @Test public void nonIdentityEncodingAndConditionalCache() throws Exception {
+    assertNonIdentityEncodingCached(
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+            .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+  }
+
+  @Test public void nonIdentityEncodingAndFullCache() throws Exception {
+    assertNonIdentityEncodingCached(
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+  }
+
+  private void assertNonIdentityEncodingCached(MockResponse response) throws Exception {
+    server.enqueue(
+        response.setBody(gzip("ABCABCABC")).addHeader("Content-Encoding: gzip"));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    // At least three request/response pairs are required because after the first request is cached
+    // a different execution path might be taken. Thus modifications to the cache applied during
+    // the second request might not be visible until another request is performed.
+    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
+  }
+
+  @Test public void notModifiedSpecifiesEncoding() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(gzip("ABCABCABC"))
+        .addHeader("Content-Encoding: gzip")
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
+        .addHeader("Content-Encoding: gzip"));
+    server.enqueue(new MockResponse()
+        .setBody("DEFDEFDEF"));
+
+    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("DEFDEFDEF", readAscii(urlFactory.open(server.url("/").url())));
+  }
+
+  /** https://github.com/square/okhttp/issues/947 */
+  @Test public void gzipAndVaryOnAcceptEncoding() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(gzip("ABCABCABC"))
+        .addHeader("Content-Encoding: gzip")
+        .addHeader("Vary: Accept-Encoding")
+        .addHeader("Cache-Control: max-age=60"));
+    server.enqueue(new MockResponse().setBody("FAIL"));
+
+    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
+  }
+
+  @Test public void conditionalCacheHitIsNotDoublePooled() throws Exception {
+    server.enqueue(new MockResponse().addHeader("ETag: v1").setBody("A"));
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals(1, urlFactory.client().connectionPool().idleConnectionCount());
+  }
+
+  @Test public void expiresDateBeforeModifiedDate() throws Exception {
+    assertConditionallyCached(
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+            .addHeader("Expires: " + formatDate(-2, TimeUnit.HOURS)));
+  }
+
+  @Test public void requestMaxAge() throws IOException {
+    server.enqueue(new MockResponse().setBody("A")
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+
+    URLConnection connection = urlFactory.open(server.url("/").url());
+    connection.addRequestProperty("Cache-Control", "max-age=30");
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void requestMinFresh() throws IOException {
+    server.enqueue(new MockResponse().setBody("A")
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+
+    URLConnection connection = urlFactory.open(server.url("/").url());
+    connection.addRequestProperty("Cache-Control", "min-fresh=120");
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void requestMaxStale() throws IOException {
+    server.enqueue(new MockResponse().setBody("A")
+        .addHeader("Cache-Control: max-age=120")
+        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+
+    URLConnection connection = urlFactory.open(server.url("/").url());
+    connection.addRequestProperty("Cache-Control", "max-stale=180");
+    assertEquals("A", readAscii(connection));
+    assertEquals("110 HttpURLConnection \"Response is stale\"",
+        connection.getHeaderField("Warning"));
+  }
+
+  @Test public void requestMaxStaleNotHonoredWithMustRevalidate() throws IOException {
+    server.enqueue(new MockResponse().setBody("A")
+        .addHeader("Cache-Control: max-age=120, must-revalidate")
+        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+
+    URLConnection connection = urlFactory.open(server.url("/").url());
+    connection.addRequestProperty("Cache-Control", "max-stale=180");
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void requestOnlyIfCachedWithNoResponseCached() throws IOException {
+    // (no responses enqueued)
+
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
+    connection.addRequestProperty("Cache-Control", "only-if-cached");
+    assertGatewayTimeout(connection);
+    assertEquals(1, cache.requestCount());
+    assertEquals(0, cache.networkCount());
+    assertEquals(0, cache.hitCount());
+  }
+
+  @Test public void requestOnlyIfCachedWithFullResponseCached() throws IOException {
+    server.enqueue(new MockResponse().setBody("A")
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    URLConnection connection = urlFactory.open(server.url("/").url());
+    connection.addRequestProperty("Cache-Control", "only-if-cached");
+    assertEquals("A", readAscii(connection));
+    assertEquals(2, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(1, cache.hitCount());
+  }
+
+  @Test public void requestOnlyIfCachedWithConditionalResponseCached() throws IOException {
+    server.enqueue(new MockResponse().setBody("A")
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES)));
+
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
+    connection.addRequestProperty("Cache-Control", "only-if-cached");
+    assertGatewayTimeout(connection);
+    assertEquals(2, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
+  }
+
+  @Test public void requestOnlyIfCachedWithUnhelpfulResponseCached() throws IOException {
+    server.enqueue(new MockResponse().setBody("A"));
+
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
+    connection.addRequestProperty("Cache-Control", "only-if-cached");
+    assertGatewayTimeout(connection);
+    assertEquals(2, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
+  }
+
+  @Test public void requestCacheControlNoCache() throws Exception {
+    server.enqueue(
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
+            .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
+            .addHeader("Cache-Control: max-age=60")
+            .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    URL url = server.url("/").url();
+    assertEquals("A", readAscii(urlFactory.open(url)));
+    URLConnection connection = urlFactory.open(url);
+    connection.setRequestProperty("Cache-Control", "no-cache");
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void requestPragmaNoCache() throws Exception {
+    server.enqueue(
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
+            .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
+            .addHeader("Cache-Control: max-age=60")
+            .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    URL url = server.url("/").url();
+    assertEquals("A", readAscii(urlFactory.open(url)));
+    URLConnection connection = urlFactory.open(url);
+    connection.setRequestProperty("Pragma", "no-cache");
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void clientSuppliedIfModifiedSinceWithCachedResult() throws Exception {
+    MockResponse response =
+        new MockResponse().addHeader("ETag: v3").addHeader("Cache-Control: max-age=0");
+    String ifModifiedSinceDate = formatDate(-24, TimeUnit.HOURS);
+    RecordedRequest request =
+        assertClientSuppliedCondition(response, "If-Modified-Since", ifModifiedSinceDate);
+    assertEquals(ifModifiedSinceDate, request.getHeader("If-Modified-Since"));
+    assertNull(request.getHeader("If-None-Match"));
+  }
+
+  @Test public void clientSuppliedIfNoneMatchSinceWithCachedResult() throws Exception {
+    String lastModifiedDate = formatDate(-3, TimeUnit.MINUTES);
+    MockResponse response = new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
+        .addHeader("Cache-Control: max-age=0");
+    RecordedRequest request = assertClientSuppliedCondition(response, "If-None-Match", "v1");
+    assertEquals("v1", request.getHeader("If-None-Match"));
+    assertNull(request.getHeader("If-Modified-Since"));
+  }
+
+  private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String conditionName,
+      String conditionValue) throws Exception {
+    server.enqueue(seed.setBody("A"));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    URL url = server.url("/").url();
+    assertEquals("A", readAscii(urlFactory.open(url)));
+
+    HttpURLConnection connection = urlFactory.open(url);
+    connection.addRequestProperty(conditionName, conditionValue);
+    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection.getResponseCode());
+    assertEquals("", readAscii(connection));
+
+    server.takeRequest(); // seed
+    return server.takeRequest();
+  }
+
+  /**
+   * Confirm that {@link URLConnection#setIfModifiedSince} causes an If-Modified-Since header with a
+   * GMT timestamp.
+   *
+   * https://code.google.com/p/android/issues/detail?id=66135
+   */
+  @Test public void setIfModifiedSince() throws Exception {
+    server.enqueue(new MockResponse().setBody("A"));
+
+    URL url = server.url("/").url();
+    URLConnection connection = urlFactory.open(url);
+    connection.setIfModifiedSince(1393666200000L);
+    assertEquals("A", readAscii(connection));
+    RecordedRequest request = server.takeRequest();
+    String ifModifiedSinceHeader = request.getHeader("If-Modified-Since");
+    assertEquals("Sat, 01 Mar 2014 09:30:00 GMT", ifModifiedSinceHeader);
+  }
+
+  /**
+   * For Last-Modified and Date headers, we should echo the date back in the exact format we were
+   * served.
+   */
+  @Test public void retainServedDateFormat() throws Exception {
+    // Serve a response with a non-standard date format that OkHttp supports.
+    Date lastModifiedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-1));
+    Date servedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-2));
+    DateFormat dateFormat = new SimpleDateFormat("EEE dd-MMM-yyyy HH:mm:ss z", Locale.US);
+    dateFormat.setTimeZone(TimeZone.getTimeZone("EDT"));
+    String lastModifiedString = dateFormat.format(lastModifiedDate);
+    String servedString = dateFormat.format(servedDate);
+
+    // This response should be conditionally cached.
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + lastModifiedString)
+        .addHeader("Expires: " + servedString)
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+
+    // The first request has no conditions.
+    RecordedRequest request1 = server.takeRequest();
+    assertNull(request1.getHeader("If-Modified-Since"));
+
+    // The 2nd request uses the server's date format.
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals(lastModifiedString, request2.getHeader("If-Modified-Since"));
+  }
+
+  @Test public void clientSuppliedConditionWithoutCachedResult() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
+    String clientIfModifiedSince = formatDate(-24, TimeUnit.HOURS);
+    connection.addRequestProperty("If-Modified-Since", clientIfModifiedSince);
+    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection.getResponseCode());
+    assertEquals("", readAscii(connection));
+  }
+
+  @Test public void authorizationRequestFullyCached() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    URL url = server.url("/").url();
+    URLConnection connection = urlFactory.open(url);
+    connection.addRequestProperty("Authorization", "password");
+    assertEquals("A", readAscii(connection));
+    assertEquals("A", readAscii(urlFactory.open(url)));
+  }
+
+  @Test public void contentLocationDoesNotPopulateCache() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
+        .addHeader("Content-Location: /bar")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    assertEquals("A", readAscii(urlFactory.open(server.url("/foo").url())));
+    assertEquals("B", readAscii(urlFactory.open(server.url("/bar").url())));
+  }
+
+  @Test public void useCachesFalseDoesNotWriteToCache() throws Exception {
+    server.enqueue(
+        new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A").setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    URLConnection connection = urlFactory.open(server.url("/").url());
+    connection.setUseCaches(false);
+    assertEquals("A", readAscii(connection));
+    assertEquals("B", readAscii(urlFactory.open(server.url("/").url())));
+  }
+
+  @Test public void useCachesFalseDoesNotReadFromCache() throws Exception {
+    server.enqueue(
+        new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A").setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    URLConnection connection = urlFactory.open(server.url("/").url());
+    connection.setUseCaches(false);
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void defaultUseCachesSetsInitialValueOnly() throws Exception {
+    URL url = new URL("http://localhost/");
+    URLConnection c1 = urlFactory.open(url);
+    URLConnection c2 = urlFactory.open(url);
+    assertTrue(c1.getDefaultUseCaches());
+    c1.setDefaultUseCaches(false);
+    try {
+      assertTrue(c1.getUseCaches());
+      assertTrue(c2.getUseCaches());
+      URLConnection c3 = urlFactory.open(url);
+      assertFalse(c3.getUseCaches());
+    } finally {
+      c1.setDefaultUseCaches(true);
+    }
+  }
+
+  @Test public void connectionIsReturnedToPoolAfterConditionalSuccess() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    assertEquals("A", readAscii(urlFactory.open(server.url("/a").url())));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/a").url())));
+    assertEquals("B", readAscii(urlFactory.open(server.url("/b").url())));
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertEquals(2, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void statisticsConditionalCacheMiss() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+    server.enqueue(new MockResponse().setBody("C"));
+
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals(1, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
+    assertEquals("B", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("C", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals(3, cache.requestCount());
+    assertEquals(3, cache.networkCount());
+    assertEquals(0, cache.hitCount());
+  }
+
+  @Test public void statisticsConditionalCacheHit() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals(1, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals(3, cache.requestCount());
+    assertEquals(3, cache.networkCount());
+    assertEquals(2, cache.hitCount());
+  }
+
+  @Test public void statisticsFullCacheHit() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A"));
+
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals(1, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals(3, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(2, cache.hitCount());
+  }
+
+  @Test public void varyMatchesChangedRequestHeaderField() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    URL url = server.url("/").url();
+    HttpURLConnection frConnection = urlFactory.open(url);
+    frConnection.addRequestProperty("Accept-Language", "fr-CA");
+    assertEquals("A", readAscii(frConnection));
+
+    HttpURLConnection enConnection = urlFactory.open(url);
+    enConnection.addRequestProperty("Accept-Language", "en-US");
+    assertEquals("B", readAscii(enConnection));
+  }
+
+  @Test public void varyMatchesUnchangedRequestHeaderField() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    URL url = server.url("/").url();
+    URLConnection connection1 = urlFactory.open(url);
+    connection1.addRequestProperty("Accept-Language", "fr-CA");
+    assertEquals("A", readAscii(connection1));
+    URLConnection connection2 = urlFactory.open(url);
+    connection2.addRequestProperty("Accept-Language", "fr-CA");
+    assertEquals("A", readAscii(connection2));
+  }
+
+  @Test public void varyMatchesAbsentRequestHeaderField() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Foo")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+  }
+
+  @Test public void varyMatchesAddedRequestHeaderField() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Foo")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    URLConnection fooConnection = urlFactory.open(server.url("/").url());
+    fooConnection.addRequestProperty("Foo", "bar");
+    assertEquals("B", readAscii(fooConnection));
+  }
+
+  @Test public void varyMatchesRemovedRequestHeaderField() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Foo")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    URLConnection fooConnection = urlFactory.open(server.url("/").url());
+    fooConnection.addRequestProperty("Foo", "bar");
+    assertEquals("A", readAscii(fooConnection));
+    assertEquals("B", readAscii(urlFactory.open(server.url("/").url())));
+  }
+
+  @Test public void varyFieldsAreCaseInsensitive() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: ACCEPT-LANGUAGE")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    URL url = server.url("/").url();
+    URLConnection connection1 = urlFactory.open(url);
+    connection1.addRequestProperty("Accept-Language", "fr-CA");
+    assertEquals("A", readAscii(connection1));
+    URLConnection connection2 = urlFactory.open(url);
+    connection2.addRequestProperty("accept-language", "fr-CA");
+    assertEquals("A", readAscii(connection2));
+  }
+
+  @Test public void varyMultipleFieldsWithMatch() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language, Accept-Charset")
+        .addHeader("Vary: Accept-Encoding")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    URL url = server.url("/").url();
+    URLConnection connection1 = urlFactory.open(url);
+    connection1.addRequestProperty("Accept-Language", "fr-CA");
+    connection1.addRequestProperty("Accept-Charset", "UTF-8");
+    connection1.addRequestProperty("Accept-Encoding", "identity");
+    assertEquals("A", readAscii(connection1));
+    URLConnection connection2 = urlFactory.open(url);
+    connection2.addRequestProperty("Accept-Language", "fr-CA");
+    connection2.addRequestProperty("Accept-Charset", "UTF-8");
+    connection2.addRequestProperty("Accept-Encoding", "identity");
+    assertEquals("A", readAscii(connection2));
+  }
+
+  @Test public void varyMultipleFieldsWithNoMatch() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language, Accept-Charset")
+        .addHeader("Vary: Accept-Encoding")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    URL url = server.url("/").url();
+    URLConnection frConnection = urlFactory.open(url);
+    frConnection.addRequestProperty("Accept-Language", "fr-CA");
+    frConnection.addRequestProperty("Accept-Charset", "UTF-8");
+    frConnection.addRequestProperty("Accept-Encoding", "identity");
+    assertEquals("A", readAscii(frConnection));
+    URLConnection enConnection = urlFactory.open(url);
+    enConnection.addRequestProperty("Accept-Language", "en-CA");
+    enConnection.addRequestProperty("Accept-Charset", "UTF-8");
+    enConnection.addRequestProperty("Accept-Encoding", "identity");
+    assertEquals("B", readAscii(enConnection));
+  }
+
+  @Test public void varyMultipleFieldValuesWithMatch() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    URL url = server.url("/").url();
+    URLConnection connection1 = urlFactory.open(url);
+    connection1.addRequestProperty("Accept-Language", "fr-CA, fr-FR");
+    connection1.addRequestProperty("Accept-Language", "en-US");
+    assertEquals("A", readAscii(connection1));
+
+    URLConnection connection2 = urlFactory.open(url);
+    connection2.addRequestProperty("Accept-Language", "fr-CA, fr-FR");
+    connection2.addRequestProperty("Accept-Language", "en-US");
+    assertEquals("A", readAscii(connection2));
+  }
+
+  @Test public void varyMultipleFieldValuesWithNoMatch() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    URL url = server.url("/").url();
+    URLConnection connection1 = urlFactory.open(url);
+    connection1.addRequestProperty("Accept-Language", "fr-CA, fr-FR");
+    connection1.addRequestProperty("Accept-Language", "en-US");
+    assertEquals("A", readAscii(connection1));
+
+    URLConnection connection2 = urlFactory.open(url);
+    connection2.addRequestProperty("Accept-Language", "fr-CA");
+    connection2.addRequestProperty("Accept-Language", "en-US");
+    assertEquals("B", readAscii(connection2));
+  }
+
+  @Test public void varyAsterisk() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: *")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("B", readAscii(urlFactory.open(server.url("/").url())));
+  }
+
+  @Test public void varyAndHttps() throws Exception {
+    assumeFalse(getPlatform().equals("jdk9"));
+
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    URL url = server.url("/").url();
+    HttpsURLConnection connection1 = (HttpsURLConnection) urlFactory.open(url);
+    connection1.setSSLSocketFactory(sslClient.socketFactory);
+    connection1.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    connection1.addRequestProperty("Accept-Language", "en-US");
+    assertEquals("A", readAscii(connection1));
+
+    HttpsURLConnection connection2 = (HttpsURLConnection) urlFactory.open(url);
+    connection2.setSSLSocketFactory(sslClient.socketFactory);
+    connection2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    connection2.addRequestProperty("Accept-Language", "en-US");
+    assertEquals("A", readAscii(connection2));
+  }
+
+  @Test public void cachePlusCookies() throws Exception {
+    RecordingCookieJar cookieJar = new RecordingCookieJar();
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .cookieJar(cookieJar)
+        .build());
+
+    server.enqueue(new MockResponse()
+        .addHeader("Set-Cookie: a=FIRST")
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .addHeader("Set-Cookie: a=SECOND")
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    URL url = server.url("/").url();
+    assertEquals("A", readAscii(urlFactory.open(url)));
+    cookieJar.assertResponseCookies("a=FIRST; path=/");
+
+    assertEquals("A", readAscii(urlFactory.open(url)));
+    cookieJar.assertResponseCookies("a=SECOND; path=/");
+  }
+
+  @Test public void getHeadersReturnsNetworkEndToEndHeaders() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Allow: GET, HEAD")
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse().addHeader("Allow: GET, HEAD, PUT")
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    URLConnection connection1 = urlFactory.open(server.url("/").url());
+    assertEquals("A", readAscii(connection1));
+    assertEquals("GET, HEAD", connection1.getHeaderField("Allow"));
+
+    URLConnection connection2 = urlFactory.open(server.url("/").url());
+    assertEquals("A", readAscii(connection2));
+    assertEquals("GET, HEAD, PUT", connection2.getHeaderField("Allow"));
+  }
+
+  @Test public void getHeadersReturnsCachedHopByHopHeaders() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Transfer-Encoding: identity")
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse().addHeader("Transfer-Encoding: none")
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    URLConnection connection1 = urlFactory.open(server.url("/").url());
+    assertEquals("A", readAscii(connection1));
+    assertEquals("identity", connection1.getHeaderField("Transfer-Encoding"));
+
+    URLConnection connection2 = urlFactory.open(server.url("/").url());
+    assertEquals("A", readAscii(connection2));
+    assertEquals("identity", connection2.getHeaderField("Transfer-Encoding"));
+  }
+
+  @Test public void getHeadersDeletesCached100LevelWarnings() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Warning: 199 test danger")
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    URLConnection connection1 = urlFactory.open(server.url("/").url());
+    assertEquals("A", readAscii(connection1));
+    assertEquals("199 test danger", connection1.getHeaderField("Warning"));
+
+    URLConnection connection2 = urlFactory.open(server.url("/").url());
+    assertEquals("A", readAscii(connection2));
+    assertEquals(null, connection2.getHeaderField("Warning"));
+  }
+
+  @Test public void getHeadersRetainsCached200LevelWarnings() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Warning: 299 test danger")
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    URLConnection connection1 = urlFactory.open(server.url("/").url());
+    assertEquals("A", readAscii(connection1));
+    assertEquals("299 test danger", connection1.getHeaderField("Warning"));
+
+    URLConnection connection2 = urlFactory.open(server.url("/").url());
+    assertEquals("A", readAscii(connection2));
+    assertEquals("299 test danger", connection2.getHeaderField("Warning"));
+  }
+
+  @Test public void cachePlusRange() throws Exception {
+    assertNotCached(new MockResponse().setResponseCode(HttpURLConnection.HTTP_PARTIAL)
+        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
+        .addHeader("Content-Range: bytes 100-100/200")
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void conditionalHitUpdatesCache() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(0, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=30")
+        .addHeader("Allow: GET, HEAD")
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    // cache miss; seed the cache
+    HttpURLConnection connection1 = urlFactory.open(server.url("/a").url());
+    assertEquals("A", readAscii(connection1));
+    assertEquals(null, connection1.getHeaderField("Allow"));
+
+    // conditional cache hit; update the cache
+    HttpURLConnection connection2 = urlFactory.open(server.url("/a").url());
+    assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
+    assertEquals("A", readAscii(connection2));
+    assertEquals("GET, HEAD", connection2.getHeaderField("Allow"));
+
+    // full cache hit
+    HttpURLConnection connection3 = urlFactory.open(server.url("/a").url());
+    assertEquals("A", readAscii(connection3));
+    assertEquals("GET, HEAD", connection3.getHeaderField("Allow"));
+
+    assertEquals(2, server.getRequestCount());
+  }
+
+  @Test public void responseSourceHeaderCached() throws IOException {
+    server.enqueue(new MockResponse().setBody("A")
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    URLConnection connection = urlFactory.open(server.url("/").url());
+    connection.addRequestProperty("Cache-Control", "only-if-cached");
+    assertEquals("A", readAscii(connection));
+  }
+
+  @Test public void responseSourceHeaderConditionalCacheFetched() throws IOException {
+    server.enqueue(new MockResponse().setBody("A")
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Date: " + formatDate(-31, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse().setBody("B")
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void responseSourceHeaderConditionalCacheNotFetched() throws IOException {
+    server.enqueue(new MockResponse().setBody("A")
+        .addHeader("Cache-Control: max-age=0")
+        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse().setResponseCode(304));
+
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
+    assertEquals("A", readAscii(connection));
+  }
+
+  @Test public void responseSourceHeaderFetched() throws IOException {
+    server.enqueue(new MockResponse().setBody("A"));
+
+    URLConnection connection = urlFactory.open(server.url("/").url());
+    assertEquals("A", readAscii(connection));
+  }
+
+  @Test public void emptyResponseHeaderNameFromCacheIsLenient() throws Exception {
+    Headers.Builder headers = new Headers.Builder()
+        .add("Cache-Control: max-age=120");
+    Internal.instance.addLenient(headers, ": A");
+    server.enqueue(new MockResponse().setHeaders(headers.build()).setBody("body"));
+
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
+    assertEquals("A", connection.getHeaderField(""));
+    assertEquals("body", readAscii(connection));
+  }
+
+  /**
+   * Old implementations of OkHttp's response cache wrote header fields like ":status: 200 OK". This
+   * broke our cached response parser because it split on the first colon. This regression test
+   * exists to help us read these old bad cache entries.
+   *
+   * https://github.com/square/okhttp/issues/227
+   */
+  @Test public void testGoldenCacheResponse() throws Exception {
+    cache.close();
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    URL url = server.url("/").url();
+    String urlKey = Cache.key(HttpUrl.get(url));
+    String prefix = Platform.get().getPrefix();
+    String entryMetadata = ""
+        + "" + url + "\n"
+        + "GET\n"
+        + "0\n"
+        + "HTTP/1.1 200 OK\n"
+        + "7\n"
+        + ":status: 200 OK\n"
+        + ":version: HTTP/1.1\n"
+        + "etag: foo\n"
+        + "content-length: 3\n"
+        + prefix + "-Received-Millis: " + System.currentTimeMillis() + "\n"
+        + "X-Android-Response-Source: NETWORK 200\n"
+        + "OkHttp-Sent-Millis: " + System.currentTimeMillis() + "\n"
+        + "\n"
+        + "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\n"
+        + "1\n"
+        + "MIIBpDCCAQ2gAwIBAgIBATANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDEw1qd2lsc29uLmxvY2FsMB4XDTEzMDgy"
+        + "OTA1MDE1OVoXDTEzMDgzMDA1MDE1OVowGDEWMBQGA1UEAxMNandpbHNvbi5sb2NhbDCBnzANBgkqhkiG9w0BAQEF"
+        + "AAOBjQAwgYkCgYEAlFW+rGo/YikCcRghOyKkJanmVmJSce/p2/jH1QvNIFKizZdh8AKNwojt3ywRWaDULA/RlCUc"
+        + "ltF3HGNsCyjQI/+Lf40x7JpxXF8oim1E6EtDoYtGWAseelawus3IQ13nmo6nWzfyCA55KhAWf4VipelEy8DjcuFK"
+        + "v6L0xwXnI0ECAwEAATANBgkqhkiG9w0BAQsFAAOBgQAuluNyPo1HksU3+Mr/PyRQIQS4BI7pRXN8mcejXmqyscdP"
+        + "7S6J21FBFeRR8/XNjVOp4HT9uSc2hrRtTEHEZCmpyoxixbnM706ikTmC7SN/GgM+SmcoJ1ipJcNcl8N0X6zym4dm"
+        + "yFfXKHu2PkTo7QFdpOJFvP3lIigcSZXozfmEDg==\n"
+        + "-1\n";
+    String entryBody = "abc";
+    String journalBody = ""
+        + "libcore.io.DiskLruCache\n"
+        + "1\n"
+        + "201105\n"
+        + "2\n"
+        + "\n"
+        + "CLEAN " + urlKey + " " + entryMetadata.length() + " " + entryBody.length() + "\n";
+    writeFile(cache.directory(), urlKey + ".0", entryMetadata);
+    writeFile(cache.directory(), urlKey + ".1", entryBody);
+    writeFile(cache.directory(), "journal", journalBody);
+    cache = new Cache(cache.directory(), Integer.MAX_VALUE, fileSystem);
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .cache(cache)
+        .build());
+
+    HttpURLConnection connection = urlFactory.open(url);
+    assertEquals(entryBody, readAscii(connection));
+    assertEquals("3", connection.getHeaderField("Content-Length"));
+    assertEquals("foo", connection.getHeaderField("etag"));
+  }
+
+  private void writeFile(File directory, String file, String content) throws IOException {
+    BufferedSink sink = Okio.buffer(fileSystem.sink(new File(directory, file)));
+    sink.writeUtf8(content);
+    sink.close();
+  }
+
+  /**
+   * @param delta the offset from the current date to use. Negative values yield dates in the past;
+   * positive values yield dates in the future.
+   */
+  private String formatDate(long delta, TimeUnit timeUnit) {
+    return formatDate(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
+  }
+
+  private String formatDate(Date date) {
+    DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
+    rfc1123.setTimeZone(TimeZone.getTimeZone("GMT"));
+    return rfc1123.format(date);
+  }
+
+  private void addRequestBodyIfNecessary(String requestMethod, HttpURLConnection invalidate)
+      throws IOException {
+    if (requestMethod.equals("POST") || requestMethod.equals("PUT")) {
+      invalidate.setDoOutput(true);
+      OutputStream requestBody = invalidate.getOutputStream();
+      requestBody.write('x');
+      requestBody.close();
+    }
+  }
+
+  private void assertNotCached(MockResponse response) throws Exception {
+    server.enqueue(response.setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    URL url = server.url("/").url();
+    assertEquals("A", readAscii(urlFactory.open(url)));
+    assertEquals("B", readAscii(urlFactory.open(url)));
+  }
+
+  /** @return the request with the conditional get headers. */
+  private RecordedRequest assertConditionallyCached(MockResponse response) throws Exception {
+    // scenario 1: condition succeeds
+    server.enqueue(response.setBody("A").setStatus("HTTP/1.1 200 A-OK"));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    // scenario 2: condition fails
+    server.enqueue(response.setBody("B").setStatus("HTTP/1.1 200 B-OK"));
+    server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 C-OK").setBody("C"));
+
+    URL valid = server.url("/valid").url();
+    HttpURLConnection connection1 = urlFactory.open(valid);
+    assertEquals("A", readAscii(connection1));
+    assertEquals(HttpURLConnection.HTTP_OK, connection1.getResponseCode());
+    assertEquals("A-OK", connection1.getResponseMessage());
+    HttpURLConnection connection2 = urlFactory.open(valid);
+    assertEquals("A", readAscii(connection2));
+    assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
+    assertEquals("A-OK", connection2.getResponseMessage());
+
+    URL invalid = server.url("/invalid").url();
+    HttpURLConnection connection3 = urlFactory.open(invalid);
+    assertEquals("B", readAscii(connection3));
+    assertEquals(HttpURLConnection.HTTP_OK, connection3.getResponseCode());
+    assertEquals("B-OK", connection3.getResponseMessage());
+    HttpURLConnection connection4 = urlFactory.open(invalid);
+    assertEquals("C", readAscii(connection4));
+    assertEquals(HttpURLConnection.HTTP_OK, connection4.getResponseCode());
+    assertEquals("C-OK", connection4.getResponseMessage());
+
+    server.takeRequest(); // regular get
+    return server.takeRequest(); // conditional get
+  }
+
+  private void assertFullyCached(MockResponse response) throws Exception {
+    server.enqueue(response.setBody("A"));
+    server.enqueue(response.setBody("B"));
+
+    URL url = server.url("/").url();
+    assertEquals("A", readAscii(urlFactory.open(url)));
+    assertEquals("A", readAscii(urlFactory.open(url)));
+  }
+
+  /**
+   * Shortens the body of {@code response} but not the corresponding headers. Only useful to test
+   * how clients respond to the premature conclusion of the HTTP body.
+   */
+  private MockResponse truncateViolently(MockResponse response, int numBytesToKeep) {
+    response.setSocketPolicy(DISCONNECT_AT_END);
+    Headers headers = response.getHeaders();
+    Buffer truncatedBody = new Buffer();
+    truncatedBody.write(response.getBody(), numBytesToKeep);
+    response.setBody(truncatedBody);
+    response.setHeaders(headers);
+    return response;
+  }
+
+  /**
+   * Reads {@code count} characters from the stream. If the stream is exhausted before {@code count}
+   * characters can be read, the remaining characters are returned and the stream is closed.
+   */
+  private String readAscii(URLConnection connection, int count) throws IOException {
+    HttpURLConnection httpConnection = (HttpURLConnection) connection;
+    InputStream in = httpConnection.getResponseCode() < HttpURLConnection.HTTP_BAD_REQUEST
+        ? connection.getInputStream()
+        : httpConnection.getErrorStream();
+    StringBuilder result = new StringBuilder();
+    for (int i = 0; i < count; i++) {
+      int value = in.read();
+      if (value == -1) {
+        in.close();
+        break;
+      }
+      result.append((char) value);
+    }
+    return result.toString();
+  }
+
+  private String readAscii(URLConnection connection) throws IOException {
+    return readAscii(connection, Integer.MAX_VALUE);
+  }
+
+  private void reliableSkip(InputStream in, int length) throws IOException {
+    while (length > 0) {
+      length -= in.skip(length);
+    }
+  }
+
+  private void assertGatewayTimeout(HttpURLConnection connection) throws IOException {
+    try {
+      connection.getInputStream();
+      fail();
+    } catch (FileNotFoundException expected) {
+    }
+    assertEquals(504, connection.getResponseCode());
+    assertEquals(-1, connection.getErrorStream().read());
+  }
+
+  enum TransferKind {
+    CHUNKED() {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize)
+          throws IOException {
+        response.setChunkedBody(content, chunkSize);
+      }
+    },
+    FIXED_LENGTH() {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
+        response.setBody(content);
+      }
+    },
+    END_OF_STREAM() {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
+        response.setBody(content);
+        response.setSocketPolicy(DISCONNECT_AT_END);
+        response.removeHeader("Content-Length");
+      }
+    };
+
+    abstract void setBody(MockResponse response, Buffer content, int chunkSize) throws IOException;
+
+    void setBody(MockResponse response, String content, int chunkSize) throws IOException {
+      setBody(response, new Buffer().writeUtf8(content), chunkSize);
+    }
+  }
+
+  private <T> List<T> toListOrNull(T[] arrayOrNull) {
+    return arrayOrNull != null ? Arrays.asList(arrayOrNull) : null;
+  }
+
+  /** Returns a gzipped copy of {@code bytes}. */
+  public Buffer gzip(String data) throws IOException {
+    Buffer result = new Buffer();
+    BufferedSink sink = Okio.buffer(new GzipSink(result));
+    sink.writeUtf8(data);
+    sink.close();
+    return result;
+  }
+
+  private String getPlatform() {
+    return System.getProperty("okhttp.platform", "platform");
+  }
+}
diff --git a/okhttp-urlconnection/src/test/java/okhttp3/internal/huc/URLEncodingTest.java b/okhttp-urlconnection/src/test/java/okhttp3/internal/huc/URLEncodingTest.java
new file mode 100644
index 0000000000..ec0de83e52
--- /dev/null
+++ b/okhttp-urlconnection/src/test/java/okhttp3/internal/huc/URLEncodingTest.java
@@ -0,0 +1,161 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package okhttp3.internal.huc;
+
+import java.io.IOException;
+import java.net.HttpURLConnection;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.OkHttpClient;
+import okhttp3.OkUrlFactory;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.Internal;
+import okhttp3.internal.cache.CacheRequest;
+import okhttp3.internal.cache.CacheStrategy;
+import okhttp3.internal.cache.InternalCache;
+import org.junit.Ignore;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+/**
+ * Exercises HttpURLConnection to convert URL to a URI. Unlike URL#toURI, HttpURLConnection recovers
+ * from URLs with unescaped but unsupported URI characters like '{' and '|' by escaping these
+ * characters.
+ */
+public final class URLEncodingTest {
+  /**
+   * This test goes through the exhaustive set of interesting ASCII characters because most of those
+   * characters are interesting in some way according to RFC 2396 and RFC 2732. http://b/1158780
+   */
+  @Test @Ignore public void lenientUrlToUri() throws Exception {
+    // alphanum
+    testUrlToUriMapping("abzABZ09", "abzABZ09", "abzABZ09", "abzABZ09", "abzABZ09");
+
+    // control characters
+    testUrlToUriMapping("\u0001", "%01", "%01", "%01", "%01");
+    testUrlToUriMapping("\u001f", "%1F", "%1F", "%1F", "%1F");
+
+    // ascii characters
+    testUrlToUriMapping("%20", "%20", "%20", "%20", "%20");
+    testUrlToUriMapping("%20", "%20", "%20", "%20", "%20");
+    testUrlToUriMapping(" ", "%20", "%20", "%20", "%20");
+    testUrlToUriMapping("!", "!", "!", "!", "!");
+    testUrlToUriMapping("\"", "%22", "%22", "%22", "%22");
+    testUrlToUriMapping("#", null, null, null, "%23");
+    testUrlToUriMapping("$", "$", "$", "$", "$");
+    testUrlToUriMapping("&", "&", "&", "&", "&");
+    testUrlToUriMapping("'", "'", "'", "'", "'");
+    testUrlToUriMapping("(", "(", "(", "(", "(");
+    testUrlToUriMapping(")", ")", ")", ")", ")");
+    testUrlToUriMapping("*", "*", "*", "*", "*");
+    testUrlToUriMapping("+", "+", "+", "+", "+");
+    testUrlToUriMapping(",", ",", ",", ",", ",");
+    testUrlToUriMapping("-", "-", "-", "-", "-");
+    testUrlToUriMapping(".", ".", ".", ".", ".");
+    testUrlToUriMapping("/", null, "/", "/", "/");
+    testUrlToUriMapping(":", null, ":", ":", ":");
+    testUrlToUriMapping(";", ";", ";", ";", ";");
+    testUrlToUriMapping("<", "%3C", "%3C", "%3C", "%3C");
+    testUrlToUriMapping("=", "=", "=", "=", "=");
+    testUrlToUriMapping(">", "%3E", "%3E", "%3E", "%3E");
+    testUrlToUriMapping("?", null, null, "?", "?");
+    testUrlToUriMapping("@", "@", "@", "@", "@");
+    testUrlToUriMapping("[", null, "%5B", null, "%5B");
+    testUrlToUriMapping("\\", "%5C", "%5C", "%5C", "%5C");
+    testUrlToUriMapping("]", null, "%5D", null, "%5D");
+    testUrlToUriMapping("^", "%5E", "%5E", "%5E", "%5E");
+    testUrlToUriMapping("_", "_", "_", "_", "_");
+    testUrlToUriMapping("`", "%60", "%60", "%60", "%60");
+    testUrlToUriMapping("{", "%7B", "%7B", "%7B", "%7B");
+    testUrlToUriMapping("|", "%7C", "%7C", "%7C", "%7C");
+    testUrlToUriMapping("}", "%7D", "%7D", "%7D", "%7D");
+    testUrlToUriMapping("~", "~", "~", "~", "~");
+    testUrlToUriMapping("~", "~", "~", "~", "~");
+    testUrlToUriMapping("\u007f", "%7F", "%7F", "%7F", "%7F");
+
+    // beyond ascii
+    testUrlToUriMapping("\u0080", "%C2%80", "%C2%80", "%C2%80", "%C2%80");
+    testUrlToUriMapping("\u20ac", "\u20ac", "\u20ac", "\u20ac", "\u20ac");
+    testUrlToUriMapping("\ud842\udf9f", "\ud842\udf9f", "\ud842\udf9f", "\ud842\udf9f",
+        "\ud842\udf9f");
+  }
+
+  @Test @Ignore public void lenientUrlToUriNul() throws Exception {
+    testUrlToUriMapping("\u0000", "%00", "%00", "%00", "%00"); // RI fails this
+  }
+
+  private void testUrlToUriMapping(String string, String asAuthority, String asFile, String asQuery,
+      String asFragment) throws Exception {
+    if (asAuthority != null) {
+      assertEquals("http://host" + asAuthority + ".tld/",
+          backdoorUrlToUri(new URL("http://host" + string + ".tld/")).toString());
+    }
+    if (asFile != null) {
+      assertEquals("http://host.tld/file" + asFile + "/",
+          backdoorUrlToUri(new URL("http://host.tld/file" + string + "/")).toString());
+    }
+    if (asQuery != null) {
+      assertEquals("http://host.tld/file?q" + asQuery + "=x",
+          backdoorUrlToUri(new URL("http://host.tld/file?q" + string + "=x")).toString());
+    }
+    assertEquals("http://host.tld/file#" + asFragment + "-x",
+        backdoorUrlToUri(new URL("http://host.tld/file#" + asFragment + "-x")).toString());
+  }
+
+  private URI backdoorUrlToUri(URL url) throws Exception {
+    final AtomicReference<URI> uriReference = new AtomicReference<>();
+
+    OkHttpClient.Builder builder = new OkHttpClient.Builder();
+    Internal.instance.setCache(builder, new InternalCache() {
+      @Override public Response get(Request request) throws IOException {
+        uriReference.set(request.url().uri());
+        throw new UnsupportedOperationException();
+      }
+
+      @Override public CacheRequest put(Response response) throws IOException {
+        return null;
+      }
+
+      @Override public void remove(Request request) throws IOException {
+      }
+
+      @Override public void update(Response cached, Response network) {
+      }
+
+      @Override public void trackConditionalCacheHit() {
+      }
+
+      @Override public void trackResponse(CacheStrategy cacheStrategy) {
+      }
+    });
+
+    try {
+      HttpURLConnection connection = new OkUrlFactory(builder.build()).open(url);
+      connection.getResponseCode();
+    } catch (Exception expected) {
+      if (expected.getCause() instanceof URISyntaxException) {
+        expected.printStackTrace();
+      }
+    }
+
+    return uriReference.get();
+  }
+}
diff --git a/okhttp/pom.xml b/okhttp/pom.xml
new file mode 100644
index 0000000000..09015c18e0
--- /dev/null
+++ b/okhttp/pom.xml
@@ -0,0 +1,58 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp3</groupId>
+    <artifactId>parent</artifactId>
+    <version>3.10.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>okhttp</artifactId>
+  <name>OkHttp</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.okio</groupId>
+      <artifactId>okio</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>com.google.android</groupId>
+      <artifactId>android</artifactId>
+      <scope>provided</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>templating-maven-plugin</artifactId>
+        <version>1.0-alpha-3</version>
+        <executions>
+          <execution>
+            <goals>
+              <goal>filter-sources</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-javadoc-plugin</artifactId>
+        <configuration>
+          <excludePackageNames>okhttp3.internal:okhttp3.internal.*</excludePackageNames>
+          <links>
+            <link>http://square.github.io/okio/</link>
+          </links>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/okhttp/src/main/java-templates/okhttp3/internal/Version.java b/okhttp/src/main/java-templates/okhttp3/internal/Version.java
new file mode 100644
index 0000000000..fce1c067c0
--- /dev/null
+++ b/okhttp/src/main/java-templates/okhttp3/internal/Version.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+public final class Version {
+  public static String userAgent() {
+    return "okhttp/${project.version}";
+  }
+
+  private Version() {
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Address.java b/okhttp/src/main/java/okhttp3/Address.java
new file mode 100644
index 0000000000..9df666ad78
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Address.java
@@ -0,0 +1,202 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.net.Proxy;
+import java.net.ProxySelector;
+import java.util.List;
+import javax.annotation.Nullable;
+import javax.net.SocketFactory;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLSocketFactory;
+import okhttp3.internal.Util;
+
+import static okhttp3.internal.Util.equal;
+
+/**
+ * A specification for a connection to an origin server. For simple connections, this is the
+ * server's hostname and port. If an explicit proxy is requested (or {@linkplain Proxy#NO_PROXY no
+ * proxy} is explicitly requested), this also includes that proxy information. For secure
+ * connections the address also includes the SSL socket factory, hostname verifier, and certificate
+ * pinner.
+ *
+ * <p>HTTP requests that share the same {@code Address} may also share the same {@link Connection}.
+ */
+public final class Address {
+  final HttpUrl url;
+  final Dns dns;
+  final SocketFactory socketFactory;
+  final Authenticator proxyAuthenticator;
+  final List<Protocol> protocols;
+  final List<ConnectionSpec> connectionSpecs;
+  final ProxySelector proxySelector;
+  final @Nullable Proxy proxy;
+  final @Nullable SSLSocketFactory sslSocketFactory;
+  final @Nullable HostnameVerifier hostnameVerifier;
+  final @Nullable CertificatePinner certificatePinner;
+
+  public Address(String uriHost, int uriPort, Dns dns, SocketFactory socketFactory,
+      @Nullable SSLSocketFactory sslSocketFactory, @Nullable HostnameVerifier hostnameVerifier,
+      @Nullable CertificatePinner certificatePinner, Authenticator proxyAuthenticator,
+      @Nullable Proxy proxy, List<Protocol> protocols, List<ConnectionSpec> connectionSpecs,
+      ProxySelector proxySelector) {
+    this.url = new HttpUrl.Builder()
+        .scheme(sslSocketFactory != null ? "https" : "http")
+        .host(uriHost)
+        .port(uriPort)
+        .build();
+
+    if (dns == null) throw new NullPointerException("dns == null");
+    this.dns = dns;
+
+    if (socketFactory == null) throw new NullPointerException("socketFactory == null");
+    this.socketFactory = socketFactory;
+
+    if (proxyAuthenticator == null) {
+      throw new NullPointerException("proxyAuthenticator == null");
+    }
+    this.proxyAuthenticator = proxyAuthenticator;
+
+    if (protocols == null) throw new NullPointerException("protocols == null");
+    this.protocols = Util.immutableList(protocols);
+
+    if (connectionSpecs == null) throw new NullPointerException("connectionSpecs == null");
+    this.connectionSpecs = Util.immutableList(connectionSpecs);
+
+    if (proxySelector == null) throw new NullPointerException("proxySelector == null");
+    this.proxySelector = proxySelector;
+
+    this.proxy = proxy;
+    this.sslSocketFactory = sslSocketFactory;
+    this.hostnameVerifier = hostnameVerifier;
+    this.certificatePinner = certificatePinner;
+  }
+
+  /**
+   * Returns a URL with the hostname and port of the origin server. The path, query, and fragment of
+   * this URL are always empty, since they are not significant for planning a route.
+   */
+  public HttpUrl url() {
+    return url;
+  }
+
+  /** Returns the service that will be used to resolve IP addresses for hostnames. */
+  public Dns dns() {
+    return dns;
+  }
+
+  /** Returns the socket factory for new connections. */
+  public SocketFactory socketFactory() {
+    return socketFactory;
+  }
+
+  /** Returns the client's proxy authenticator. */
+  public Authenticator proxyAuthenticator() {
+    return proxyAuthenticator;
+  }
+
+  /**
+   * Returns the protocols the client supports. This method always returns a non-null list that
+   * contains minimally {@link Protocol#HTTP_1_1}.
+   */
+  public List<Protocol> protocols() {
+    return protocols;
+  }
+
+  public List<ConnectionSpec> connectionSpecs() {
+    return connectionSpecs;
+  }
+
+  /**
+   * Returns this address's proxy selector. Only used if the proxy is null. If none of this
+   * selector's proxies are reachable, a direct connection will be attempted.
+   */
+  public ProxySelector proxySelector() {
+    return proxySelector;
+  }
+
+  /**
+   * Returns this address's explicitly-specified HTTP proxy, or null to delegate to the {@linkplain
+   * #proxySelector proxy selector}.
+   */
+  public @Nullable Proxy proxy() {
+    return proxy;
+  }
+
+  /** Returns the SSL socket factory, or null if this is not an HTTPS address. */
+  public @Nullable SSLSocketFactory sslSocketFactory() {
+    return sslSocketFactory;
+  }
+
+  /** Returns the hostname verifier, or null if this is not an HTTPS address. */
+  public @Nullable HostnameVerifier hostnameVerifier() {
+    return hostnameVerifier;
+  }
+
+  /** Returns this address's certificate pinner, or null if this is not an HTTPS address. */
+  public @Nullable CertificatePinner certificatePinner() {
+    return certificatePinner;
+  }
+
+  @Override public boolean equals(@Nullable Object other) {
+    return other instanceof Address
+        && url.equals(((Address) other).url)
+        && equalsNonHost((Address) other);
+  }
+
+  @Override public int hashCode() {
+    int result = 17;
+    result = 31 * result + url.hashCode();
+    result = 31 * result + dns.hashCode();
+    result = 31 * result + proxyAuthenticator.hashCode();
+    result = 31 * result + protocols.hashCode();
+    result = 31 * result + connectionSpecs.hashCode();
+    result = 31 * result + proxySelector.hashCode();
+    result = 31 * result + (proxy != null ? proxy.hashCode() : 0);
+    result = 31 * result + (sslSocketFactory != null ? sslSocketFactory.hashCode() : 0);
+    result = 31 * result + (hostnameVerifier != null ? hostnameVerifier.hashCode() : 0);
+    result = 31 * result + (certificatePinner != null ? certificatePinner.hashCode() : 0);
+    return result;
+  }
+
+  boolean equalsNonHost(Address that) {
+    return this.dns.equals(that.dns)
+        && this.proxyAuthenticator.equals(that.proxyAuthenticator)
+        && this.protocols.equals(that.protocols)
+        && this.connectionSpecs.equals(that.connectionSpecs)
+        && this.proxySelector.equals(that.proxySelector)
+        && equal(this.proxy, that.proxy)
+        && equal(this.sslSocketFactory, that.sslSocketFactory)
+        && equal(this.hostnameVerifier, that.hostnameVerifier)
+        && equal(this.certificatePinner, that.certificatePinner)
+        && this.url().port() == that.url().port();
+  }
+
+  @Override public String toString() {
+    StringBuilder result = new StringBuilder()
+        .append("Address{")
+        .append(url.host()).append(":").append(url.port());
+
+    if (proxy != null) {
+      result.append(", proxy=").append(proxy);
+    } else {
+      result.append(", proxySelector=").append(proxySelector);
+    }
+
+    result.append("}");
+    return result.toString();
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Authenticator.java b/okhttp/src/main/java/okhttp3/Authenticator.java
new file mode 100644
index 0000000000..9e34bc9706
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Authenticator.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import javax.annotation.Nullable;
+
+/**
+ * Responds to an authentication challenge from either a remote web server or a proxy server.
+ * Implementations may either attempt to satisfy the challenge by returning a request that includes
+ * an authorization header, or they may refuse the challenge by returning null. In this case the
+ * unauthenticated response will be returned to the caller that triggered it.
+ *
+ * <p>Implementations should check if the initial request already included an attempt to
+ * authenticate. If so it is likely that further attempts will not be useful and the authenticator
+ * should give up.
+ *
+ * <p>When authentication is requested by an origin server, the response code is 401 and the
+ * implementation should respond with a new request that sets the "Authorization" header.
+ * <pre>   {@code
+ *
+ *    if (response.request().header("Authorization") != null) {
+ *      return null; // Give up, we've already failed to authenticate.
+ *    }
+ *
+ *    String credential = Credentials.basic(...)
+ *    return response.request().newBuilder()
+ *        .header("Authorization", credential)
+ *        .build();
+ * }</pre>
+ *
+ * <p>When authentication is requested by a proxy server, the response code is 407 and the
+ * implementation should respond with a new request that sets the "Proxy-Authorization" header.
+ * <pre>   {@code
+ *
+ *    if (response.request().header("Proxy-Authorization") != null) {
+ *      return null; // Give up, we've already failed to authenticate.
+ *    }
+ *
+ *    String credential = Credentials.basic(...)
+ *    return response.request().newBuilder()
+ *        .header("Proxy-Authorization", credential)
+ *        .build();
+ * }</pre>
+ *
+ * <p>Applications may configure OkHttp with an authenticator for origin servers, or proxy servers,
+ * or both.
+ */
+public interface Authenticator {
+  /** An authenticator that knows no credentials and makes no attempt to authenticate. */
+  Authenticator NONE = new Authenticator() {
+    @Override public Request authenticate(Route route, Response response) {
+      return null;
+    }
+  };
+
+  /**
+   * Returns a request that includes a credential to satisfy an authentication challenge in {@code
+   * response}. Returns null if the challenge cannot be satisfied.
+   */
+  @Nullable Request authenticate(Route route, Response response) throws IOException;
+}
diff --git a/okhttp/src/main/java/okhttp3/Cache.java b/okhttp/src/main/java/okhttp3/Cache.java
new file mode 100644
index 0000000000..d43d91d257
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Cache.java
@@ -0,0 +1,770 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.Closeable;
+import java.io.File;
+import java.io.Flushable;
+import java.io.IOException;
+import java.security.cert.Certificate;
+import java.security.cert.CertificateEncodingException;
+import java.security.cert.CertificateException;
+import java.security.cert.CertificateFactory;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.NoSuchElementException;
+import javax.annotation.Nullable;
+import okhttp3.internal.Util;
+import okhttp3.internal.cache.CacheRequest;
+import okhttp3.internal.cache.CacheStrategy;
+import okhttp3.internal.cache.DiskLruCache;
+import okhttp3.internal.cache.InternalCache;
+import okhttp3.internal.http.HttpHeaders;
+import okhttp3.internal.http.HttpMethod;
+import okhttp3.internal.http.StatusLine;
+import okhttp3.internal.io.FileSystem;
+import okhttp3.internal.platform.Platform;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.ForwardingSink;
+import okio.ForwardingSource;
+import okio.Okio;
+import okio.Sink;
+import okio.Source;
+
+/**
+ * Caches HTTP and HTTPS responses to the filesystem so they may be reused, saving time and
+ * bandwidth.
+ *
+ * <h3>Cache Optimization</h3>
+ *
+ * <p>To measure cache effectiveness, this class tracks three statistics:
+ * <ul>
+ *     <li><strong>{@linkplain #requestCount() Request Count:}</strong> the number of HTTP
+ *         requests issued since this cache was created.
+ *     <li><strong>{@linkplain #networkCount() Network Count:}</strong> the number of those
+ *         requests that required network use.
+ *     <li><strong>{@linkplain #hitCount() Hit Count:}</strong> the number of those requests
+ *         whose responses were served by the cache.
+ * </ul>
+ *
+ * Sometimes a request will result in a conditional cache hit. If the cache contains a stale copy of
+ * the response, the client will issue a conditional {@code GET}. The server will then send either
+ * the updated response if it has changed, or a short 'not modified' response if the client's copy
+ * is still valid. Such responses increment both the network count and hit count.
+ *
+ * <p>The best way to improve the cache hit rate is by configuring the web server to return
+ * cacheable responses. Although this client honors all <a
+ * href="http://tools.ietf.org/html/rfc7234">HTTP/1.1 (RFC 7234)</a> cache headers, it doesn't cache
+ * partial responses.
+ *
+ * <h3>Force a Network Response</h3>
+ *
+ * <p>In some situations, such as after a user clicks a 'refresh' button, it may be necessary to
+ * skip the cache, and fetch data directly from the server. To force a full refresh, add the {@code
+ * no-cache} directive: <pre>   {@code
+ *
+ *   Request request = new Request.Builder()
+ *       .cacheControl(new CacheControl.Builder().noCache().build())
+ *       .url("http://publicobject.com/helloworld.txt")
+ *       .build();
+ * }</pre>
+ *
+ * If it is only necessary to force a cached response to be validated by the server, use the more
+ * efficient {@code max-age=0} directive instead: <pre>   {@code
+ *
+ *   Request request = new Request.Builder()
+ *       .cacheControl(new CacheControl.Builder()
+ *           .maxAge(0, TimeUnit.SECONDS)
+ *           .build())
+ *       .url("http://publicobject.com/helloworld.txt")
+ *       .build();
+ * }</pre>
+ *
+ * <h3>Force a Cache Response</h3>
+ *
+ * <p>Sometimes you'll want to show resources if they are available immediately, but not otherwise.
+ * This can be used so your application can show <i>something</i> while waiting for the latest data
+ * to be downloaded. To restrict a request to locally-cached resources, add the {@code
+ * only-if-cached} directive: <pre>   {@code
+ *
+ *     Request request = new Request.Builder()
+ *         .cacheControl(new CacheControl.Builder()
+ *             .onlyIfCached()
+ *             .build())
+ *         .url("http://publicobject.com/helloworld.txt")
+ *         .build();
+ *     Response forceCacheResponse = client.newCall(request).execute();
+ *     if (forceCacheResponse.code() != 504) {
+ *       // The resource was cached! Show it.
+ *     } else {
+ *       // The resource was not cached.
+ *     }
+ * }</pre>
+ * This technique works even better in situations where a stale response is better than no response.
+ * To permit stale cached responses, use the {@code max-stale} directive with the maximum staleness
+ * in seconds: <pre>   {@code
+ *
+ *   Request request = new Request.Builder()
+ *       .cacheControl(new CacheControl.Builder()
+ *           .maxStale(365, TimeUnit.DAYS)
+ *           .build())
+ *       .url("http://publicobject.com/helloworld.txt")
+ *       .build();
+ * }</pre>
+ *
+ * <p>The {@link CacheControl} class can configure request caching directives and parse response
+ * caching directives. It even offers convenient constants {@link CacheControl#FORCE_NETWORK} and
+ * {@link CacheControl#FORCE_CACHE} that address the use cases above.
+ */
+public final class Cache implements Closeable, Flushable {
+  private static final int VERSION = 201105;
+  private static final int ENTRY_METADATA = 0;
+  private static final int ENTRY_BODY = 1;
+  private static final int ENTRY_COUNT = 2;
+
+  final InternalCache internalCache = new InternalCache() {
+    @Override public Response get(Request request) throws IOException {
+      return Cache.this.get(request);
+    }
+
+    @Override public CacheRequest put(Response response) throws IOException {
+      return Cache.this.put(response);
+    }
+
+    @Override public void remove(Request request) throws IOException {
+      Cache.this.remove(request);
+    }
+
+    @Override public void update(Response cached, Response network) {
+      Cache.this.update(cached, network);
+    }
+
+    @Override public void trackConditionalCacheHit() {
+      Cache.this.trackConditionalCacheHit();
+    }
+
+    @Override public void trackResponse(CacheStrategy cacheStrategy) {
+      Cache.this.trackResponse(cacheStrategy);
+    }
+  };
+
+  final DiskLruCache cache;
+
+  /* read and write statistics, all guarded by 'this' */
+  int writeSuccessCount;
+  int writeAbortCount;
+  private int networkCount;
+  private int hitCount;
+  private int requestCount;
+
+  public Cache(File directory, long maxSize) {
+    this(directory, maxSize, FileSystem.SYSTEM);
+  }
+
+  Cache(File directory, long maxSize, FileSystem fileSystem) {
+    this.cache = DiskLruCache.create(fileSystem, directory, VERSION, ENTRY_COUNT, maxSize);
+  }
+
+  public static String key(HttpUrl url) {
+    return ByteString.encodeUtf8(url.toString()).md5().hex();
+  }
+
+  @Nullable Response get(Request request) {
+    String key = key(request.url());
+    DiskLruCache.Snapshot snapshot;
+    Entry entry;
+    try {
+      snapshot = cache.get(key);
+      if (snapshot == null) {
+        return null;
+      }
+    } catch (IOException e) {
+      // Give up because the cache cannot be read.
+      return null;
+    }
+
+    try {
+      entry = new Entry(snapshot.getSource(ENTRY_METADATA));
+    } catch (IOException e) {
+      Util.closeQuietly(snapshot);
+      return null;
+    }
+
+    Response response = entry.response(snapshot);
+
+    if (!entry.matches(request, response)) {
+      Util.closeQuietly(response.body());
+      return null;
+    }
+
+    return response;
+  }
+
+  @Nullable CacheRequest put(Response response) {
+    String requestMethod = response.request().method();
+
+    if (HttpMethod.invalidatesCache(response.request().method())) {
+      try {
+        remove(response.request());
+      } catch (IOException ignored) {
+        // The cache cannot be written.
+      }
+      return null;
+    }
+    if (!requestMethod.equals("GET")) {
+      // Don't cache non-GET responses. We're technically allowed to cache
+      // HEAD requests and some POST requests, but the complexity of doing
+      // so is high and the benefit is low.
+      return null;
+    }
+
+    if (HttpHeaders.hasVaryAll(response)) {
+      return null;
+    }
+
+    Entry entry = new Entry(response);
+    DiskLruCache.Editor editor = null;
+    try {
+      editor = cache.edit(key(response.request().url()));
+      if (editor == null) {
+        return null;
+      }
+      entry.writeTo(editor);
+      return new CacheRequestImpl(editor);
+    } catch (IOException e) {
+      abortQuietly(editor);
+      return null;
+    }
+  }
+
+  void remove(Request request) throws IOException {
+    cache.remove(key(request.url()));
+  }
+
+  void update(Response cached, Response network) {
+    Entry entry = new Entry(network);
+    DiskLruCache.Snapshot snapshot = ((CacheResponseBody) cached.body()).snapshot;
+    DiskLruCache.Editor editor = null;
+    try {
+      editor = snapshot.edit(); // Returns null if snapshot is not current.
+      if (editor != null) {
+        entry.writeTo(editor);
+        editor.commit();
+      }
+    } catch (IOException e) {
+      abortQuietly(editor);
+    }
+  }
+
+  private void abortQuietly(@Nullable DiskLruCache.Editor editor) {
+    // Give up because the cache cannot be written.
+    try {
+      if (editor != null) {
+        editor.abort();
+      }
+    } catch (IOException ignored) {
+    }
+  }
+
+  /**
+   * Initialize the cache. This will include reading the journal files from the storage and building
+   * up the necessary in-memory cache information.
+   *
+   * <p>The initialization time may vary depending on the journal file size and the current actual
+   * cache size. The application needs to be aware of calling this function during the
+   * initialization phase and preferably in a background worker thread.
+   *
+   * <p>Note that if the application chooses to not call this method to initialize the cache. By
+   * default, the okhttp will perform lazy initialization upon the first usage of the cache.
+   */
+  public void initialize() throws IOException {
+    cache.initialize();
+  }
+
+  /**
+   * Closes the cache and deletes all of its stored values. This will delete all files in the cache
+   * directory including files that weren't created by the cache.
+   */
+  public void delete() throws IOException {
+    cache.delete();
+  }
+
+  /**
+   * Deletes all values stored in the cache. In-flight writes to the cache will complete normally,
+   * but the corresponding responses will not be stored.
+   */
+  public void evictAll() throws IOException {
+    cache.evictAll();
+  }
+
+  /**
+   * Returns an iterator over the URLs in this cache. This iterator doesn't throw {@code
+   * ConcurrentModificationException}, but if new responses are added while iterating, their URLs
+   * will not be returned. If existing responses are evicted during iteration, they will be absent
+   * (unless they were already returned).
+   *
+   * <p>The iterator supports {@linkplain Iterator#remove}. Removing a URL from the iterator evicts
+   * the corresponding response from the cache. Use this to evict selected responses.
+   */
+  public Iterator<String> urls() throws IOException {
+    return new Iterator<String>() {
+      final Iterator<DiskLruCache.Snapshot> delegate = cache.snapshots();
+
+      @Nullable String nextUrl;
+      boolean canRemove;
+
+      @Override public boolean hasNext() {
+        if (nextUrl != null) return true;
+
+        canRemove = false; // Prevent delegate.remove() on the wrong item!
+        while (delegate.hasNext()) {
+          DiskLruCache.Snapshot snapshot = delegate.next();
+          try {
+            BufferedSource metadata = Okio.buffer(snapshot.getSource(ENTRY_METADATA));
+            nextUrl = metadata.readUtf8LineStrict();
+            return true;
+          } catch (IOException ignored) {
+            // We couldn't read the metadata for this snapshot; possibly because the host filesystem
+            // has disappeared! Skip it.
+          } finally {
+            snapshot.close();
+          }
+        }
+
+        return false;
+      }
+
+      @Override public String next() {
+        if (!hasNext()) throw new NoSuchElementException();
+        String result = nextUrl;
+        nextUrl = null;
+        canRemove = true;
+        return result;
+      }
+
+      @Override public void remove() {
+        if (!canRemove) throw new IllegalStateException("remove() before next()");
+        delegate.remove();
+      }
+    };
+  }
+
+  public synchronized int writeAbortCount() {
+    return writeAbortCount;
+  }
+
+  public synchronized int writeSuccessCount() {
+    return writeSuccessCount;
+  }
+
+  public long size() throws IOException {
+    return cache.size();
+  }
+
+  public long maxSize() {
+    return cache.getMaxSize();
+  }
+
+  @Override public void flush() throws IOException {
+    cache.flush();
+  }
+
+  @Override public void close() throws IOException {
+    cache.close();
+  }
+
+  public File directory() {
+    return cache.getDirectory();
+  }
+
+  public boolean isClosed() {
+    return cache.isClosed();
+  }
+
+  synchronized void trackResponse(CacheStrategy cacheStrategy) {
+    requestCount++;
+
+    if (cacheStrategy.networkRequest != null) {
+      // If this is a conditional request, we'll increment hitCount if/when it hits.
+      networkCount++;
+    } else if (cacheStrategy.cacheResponse != null) {
+      // This response uses the cache and not the network. That's a cache hit.
+      hitCount++;
+    }
+  }
+
+  synchronized void trackConditionalCacheHit() {
+    hitCount++;
+  }
+
+  public synchronized int networkCount() {
+    return networkCount;
+  }
+
+  public synchronized int hitCount() {
+    return hitCount;
+  }
+
+  public synchronized int requestCount() {
+    return requestCount;
+  }
+
+  private final class CacheRequestImpl implements CacheRequest {
+    private final DiskLruCache.Editor editor;
+    private Sink cacheOut;
+    private Sink body;
+    boolean done;
+
+    CacheRequestImpl(final DiskLruCache.Editor editor) {
+      this.editor = editor;
+      this.cacheOut = editor.newSink(ENTRY_BODY);
+      this.body = new ForwardingSink(cacheOut) {
+        @Override public void close() throws IOException {
+          synchronized (Cache.this) {
+            if (done) {
+              return;
+            }
+            done = true;
+            writeSuccessCount++;
+          }
+          super.close();
+          editor.commit();
+        }
+      };
+    }
+
+    @Override public void abort() {
+      synchronized (Cache.this) {
+        if (done) {
+          return;
+        }
+        done = true;
+        writeAbortCount++;
+      }
+      Util.closeQuietly(cacheOut);
+      try {
+        editor.abort();
+      } catch (IOException ignored) {
+      }
+    }
+
+    @Override public Sink body() {
+      return body;
+    }
+  }
+
+  private static final class Entry {
+    /** Synthetic response header: the local time when the request was sent. */
+    private static final String SENT_MILLIS = Platform.get().getPrefix() + "-Sent-Millis";
+
+    /** Synthetic response header: the local time when the response was received. */
+    private static final String RECEIVED_MILLIS = Platform.get().getPrefix() + "-Received-Millis";
+
+    private final String url;
+    private final Headers varyHeaders;
+    private final String requestMethod;
+    private final Protocol protocol;
+    private final int code;
+    private final String message;
+    private final Headers responseHeaders;
+    private final @Nullable Handshake handshake;
+    private final long sentRequestMillis;
+    private final long receivedResponseMillis;
+
+    /**
+     * Reads an entry from an input stream. A typical entry looks like this:
+     * <pre>{@code
+     *   http://google.com/foo
+     *   GET
+     *   2
+     *   Accept-Language: fr-CA
+     *   Accept-Charset: UTF-8
+     *   HTTP/1.1 200 OK
+     *   3
+     *   Content-Type: image/png
+     *   Content-Length: 100
+     *   Cache-Control: max-age=600
+     * }</pre>
+     *
+     * <p>A typical HTTPS file looks like this:
+     * <pre>{@code
+     *   https://google.com/foo
+     *   GET
+     *   2
+     *   Accept-Language: fr-CA
+     *   Accept-Charset: UTF-8
+     *   HTTP/1.1 200 OK
+     *   3
+     *   Content-Type: image/png
+     *   Content-Length: 100
+     *   Cache-Control: max-age=600
+     *
+     *   AES_256_WITH_MD5
+     *   2
+     *   base64-encoded peerCertificate[0]
+     *   base64-encoded peerCertificate[1]
+     *   -1
+     *   TLSv1.2
+     * }</pre>
+     * The file is newline separated. The first two lines are the URL and the request method. Next
+     * is the number of HTTP Vary request header lines, followed by those lines.
+     *
+     * <p>Next is the response status line, followed by the number of HTTP response header lines,
+     * followed by those lines.
+     *
+     * <p>HTTPS responses also contain SSL session information. This begins with a blank line, and
+     * then a line containing the cipher suite. Next is the length of the peer certificate chain.
+     * These certificates are base64-encoded and appear each on their own line. The next line
+     * contains the length of the local certificate chain. These certificates are also
+     * base64-encoded and appear each on their own line. A length of -1 is used to encode a null
+     * array. The last line is optional. If present, it contains the TLS version.
+     */
+    Entry(Source in) throws IOException {
+      try {
+        BufferedSource source = Okio.buffer(in);
+        url = source.readUtf8LineStrict();
+        requestMethod = source.readUtf8LineStrict();
+        Headers.Builder varyHeadersBuilder = new Headers.Builder();
+        int varyRequestHeaderLineCount = readInt(source);
+        for (int i = 0; i < varyRequestHeaderLineCount; i++) {
+          varyHeadersBuilder.addLenient(source.readUtf8LineStrict());
+        }
+        varyHeaders = varyHeadersBuilder.build();
+
+        StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict());
+        protocol = statusLine.protocol;
+        code = statusLine.code;
+        message = statusLine.message;
+        Headers.Builder responseHeadersBuilder = new Headers.Builder();
+        int responseHeaderLineCount = readInt(source);
+        for (int i = 0; i < responseHeaderLineCount; i++) {
+          responseHeadersBuilder.addLenient(source.readUtf8LineStrict());
+        }
+        String sendRequestMillisString = responseHeadersBuilder.get(SENT_MILLIS);
+        String receivedResponseMillisString = responseHeadersBuilder.get(RECEIVED_MILLIS);
+        responseHeadersBuilder.removeAll(SENT_MILLIS);
+        responseHeadersBuilder.removeAll(RECEIVED_MILLIS);
+        sentRequestMillis = sendRequestMillisString != null
+            ? Long.parseLong(sendRequestMillisString)
+            : 0L;
+        receivedResponseMillis = receivedResponseMillisString != null
+            ? Long.parseLong(receivedResponseMillisString)
+            : 0L;
+        responseHeaders = responseHeadersBuilder.build();
+
+        if (isHttps()) {
+          String blank = source.readUtf8LineStrict();
+          if (blank.length() > 0) {
+            throw new IOException("expected \"\" but was \"" + blank + "\"");
+          }
+          String cipherSuiteString = source.readUtf8LineStrict();
+          CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);
+          List<Certificate> peerCertificates = readCertificateList(source);
+          List<Certificate> localCertificates = readCertificateList(source);
+          TlsVersion tlsVersion = !source.exhausted()
+              ? TlsVersion.forJavaName(source.readUtf8LineStrict())
+              : TlsVersion.SSL_3_0;
+          handshake = Handshake.get(tlsVersion, cipherSuite, peerCertificates, localCertificates);
+        } else {
+          handshake = null;
+        }
+      } finally {
+        in.close();
+      }
+    }
+
+    Entry(Response response) {
+      this.url = response.request().url().toString();
+      this.varyHeaders = HttpHeaders.varyHeaders(response);
+      this.requestMethod = response.request().method();
+      this.protocol = response.protocol();
+      this.code = response.code();
+      this.message = response.message();
+      this.responseHeaders = response.headers();
+      this.handshake = response.handshake();
+      this.sentRequestMillis = response.sentRequestAtMillis();
+      this.receivedResponseMillis = response.receivedResponseAtMillis();
+    }
+
+    public void writeTo(DiskLruCache.Editor editor) throws IOException {
+      BufferedSink sink = Okio.buffer(editor.newSink(ENTRY_METADATA));
+
+      sink.writeUtf8(url)
+          .writeByte('\n');
+      sink.writeUtf8(requestMethod)
+          .writeByte('\n');
+      sink.writeDecimalLong(varyHeaders.size())
+          .writeByte('\n');
+      for (int i = 0, size = varyHeaders.size(); i < size; i++) {
+        sink.writeUtf8(varyHeaders.name(i))
+            .writeUtf8(": ")
+            .writeUtf8(varyHeaders.value(i))
+            .writeByte('\n');
+      }
+
+      sink.writeUtf8(new StatusLine(protocol, code, message).toString())
+          .writeByte('\n');
+      sink.writeDecimalLong(responseHeaders.size() + 2)
+          .writeByte('\n');
+      for (int i = 0, size = responseHeaders.size(); i < size; i++) {
+        sink.writeUtf8(responseHeaders.name(i))
+            .writeUtf8(": ")
+            .writeUtf8(responseHeaders.value(i))
+            .writeByte('\n');
+      }
+      sink.writeUtf8(SENT_MILLIS)
+          .writeUtf8(": ")
+          .writeDecimalLong(sentRequestMillis)
+          .writeByte('\n');
+      sink.writeUtf8(RECEIVED_MILLIS)
+          .writeUtf8(": ")
+          .writeDecimalLong(receivedResponseMillis)
+          .writeByte('\n');
+
+      if (isHttps()) {
+        sink.writeByte('\n');
+        sink.writeUtf8(handshake.cipherSuite().javaName())
+            .writeByte('\n');
+        writeCertList(sink, handshake.peerCertificates());
+        writeCertList(sink, handshake.localCertificates());
+        sink.writeUtf8(handshake.tlsVersion().javaName()).writeByte('\n');
+      }
+      sink.close();
+    }
+
+    private boolean isHttps() {
+      return url.startsWith("https://");
+    }
+
+    private List<Certificate> readCertificateList(BufferedSource source) throws IOException {
+      int length = readInt(source);
+      if (length == -1) return Collections.emptyList(); // OkHttp v1.2 used -1 to indicate null.
+
+      try {
+        CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
+        List<Certificate> result = new ArrayList<>(length);
+        for (int i = 0; i < length; i++) {
+          String line = source.readUtf8LineStrict();
+          Buffer bytes = new Buffer();
+          bytes.write(ByteString.decodeBase64(line));
+          result.add(certificateFactory.generateCertificate(bytes.inputStream()));
+        }
+        return result;
+      } catch (CertificateException e) {
+        throw new IOException(e.getMessage());
+      }
+    }
+
+    private void writeCertList(BufferedSink sink, List<Certificate> certificates)
+        throws IOException {
+      try {
+        sink.writeDecimalLong(certificates.size())
+            .writeByte('\n');
+        for (int i = 0, size = certificates.size(); i < size; i++) {
+          byte[] bytes = certificates.get(i).getEncoded();
+          String line = ByteString.of(bytes).base64();
+          sink.writeUtf8(line)
+              .writeByte('\n');
+        }
+      } catch (CertificateEncodingException e) {
+        throw new IOException(e.getMessage());
+      }
+    }
+
+    public boolean matches(Request request, Response response) {
+      return url.equals(request.url().toString())
+          && requestMethod.equals(request.method())
+          && HttpHeaders.varyMatches(response, varyHeaders, request);
+    }
+
+    public Response response(DiskLruCache.Snapshot snapshot) {
+      String contentType = responseHeaders.get("Content-Type");
+      String contentLength = responseHeaders.get("Content-Length");
+      Request cacheRequest = new Request.Builder()
+          .url(url)
+          .method(requestMethod, null)
+          .headers(varyHeaders)
+          .build();
+      return new Response.Builder()
+          .request(cacheRequest)
+          .protocol(protocol)
+          .code(code)
+          .message(message)
+          .headers(responseHeaders)
+          .body(new CacheResponseBody(snapshot, contentType, contentLength))
+          .handshake(handshake)
+          .sentRequestAtMillis(sentRequestMillis)
+          .receivedResponseAtMillis(receivedResponseMillis)
+          .build();
+    }
+  }
+
+  static int readInt(BufferedSource source) throws IOException {
+    try {
+      long result = source.readDecimalLong();
+      String line = source.readUtf8LineStrict();
+      if (result < 0 || result > Integer.MAX_VALUE || !line.isEmpty()) {
+        throw new IOException("expected an int but was \"" + result + line + "\"");
+      }
+      return (int) result;
+    } catch (NumberFormatException e) {
+      throw new IOException(e.getMessage());
+    }
+  }
+
+  private static class CacheResponseBody extends ResponseBody {
+    final DiskLruCache.Snapshot snapshot;
+    private final BufferedSource bodySource;
+    private final @Nullable String contentType;
+    private final @Nullable String contentLength;
+
+    CacheResponseBody(final DiskLruCache.Snapshot snapshot,
+        String contentType, String contentLength) {
+      this.snapshot = snapshot;
+      this.contentType = contentType;
+      this.contentLength = contentLength;
+
+      Source source = snapshot.getSource(ENTRY_BODY);
+      bodySource = Okio.buffer(new ForwardingSource(source) {
+        @Override public void close() throws IOException {
+          snapshot.close();
+          super.close();
+        }
+      });
+    }
+
+    @Override public MediaType contentType() {
+      return contentType != null ? MediaType.parse(contentType) : null;
+    }
+
+    @Override public long contentLength() {
+      try {
+        return contentLength != null ? Long.parseLong(contentLength) : -1;
+      } catch (NumberFormatException e) {
+        return -1;
+      }
+    }
+
+    @Override public BufferedSource source() {
+      return bodySource;
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/CacheControl.java b/okhttp/src/main/java/okhttp3/CacheControl.java
new file mode 100644
index 0000000000..a32add5f97
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/CacheControl.java
@@ -0,0 +1,373 @@
+package okhttp3;
+
+import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
+import okhttp3.internal.http.HttpHeaders;
+
+/**
+ * A Cache-Control header with cache directives from a server or client. These directives set policy
+ * on what responses can be stored, and which requests can be satisfied by those stored responses.
+ *
+ * <p>See <a href="https://tools.ietf.org/html/rfc7234#section-5.2">RFC 7234, 5.2</a>.
+ */
+public final class CacheControl {
+  /**
+   * Cache control request directives that require network validation of responses. Note that such
+   * requests may be assisted by the cache via conditional GET requests.
+   */
+  public static final CacheControl FORCE_NETWORK = new Builder().noCache().build();
+
+  /**
+   * Cache control request directives that uses the cache only, even if the cached response is
+   * stale. If the response isn't available in the cache or requires server validation, the call
+   * will fail with a {@code 504 Unsatisfiable Request}.
+   */
+  public static final CacheControl FORCE_CACHE = new Builder()
+      .onlyIfCached()
+      .maxStale(Integer.MAX_VALUE, TimeUnit.SECONDS)
+      .build();
+
+  private final boolean noCache;
+  private final boolean noStore;
+  private final int maxAgeSeconds;
+  private final int sMaxAgeSeconds;
+  private final boolean isPrivate;
+  private final boolean isPublic;
+  private final boolean mustRevalidate;
+  private final int maxStaleSeconds;
+  private final int minFreshSeconds;
+  private final boolean onlyIfCached;
+  private final boolean noTransform;
+  private final boolean immutable;
+
+  @Nullable String headerValue; // Lazily computed, null if absent.
+
+  private CacheControl(boolean noCache, boolean noStore, int maxAgeSeconds, int sMaxAgeSeconds,
+      boolean isPrivate, boolean isPublic, boolean mustRevalidate, int maxStaleSeconds,
+      int minFreshSeconds, boolean onlyIfCached, boolean noTransform, boolean immutable,
+      @Nullable String headerValue) {
+    this.noCache = noCache;
+    this.noStore = noStore;
+    this.maxAgeSeconds = maxAgeSeconds;
+    this.sMaxAgeSeconds = sMaxAgeSeconds;
+    this.isPrivate = isPrivate;
+    this.isPublic = isPublic;
+    this.mustRevalidate = mustRevalidate;
+    this.maxStaleSeconds = maxStaleSeconds;
+    this.minFreshSeconds = minFreshSeconds;
+    this.onlyIfCached = onlyIfCached;
+    this.noTransform = noTransform;
+    this.immutable = immutable;
+    this.headerValue = headerValue;
+  }
+
+  CacheControl(Builder builder) {
+    this.noCache = builder.noCache;
+    this.noStore = builder.noStore;
+    this.maxAgeSeconds = builder.maxAgeSeconds;
+    this.sMaxAgeSeconds = -1;
+    this.isPrivate = false;
+    this.isPublic = false;
+    this.mustRevalidate = false;
+    this.maxStaleSeconds = builder.maxStaleSeconds;
+    this.minFreshSeconds = builder.minFreshSeconds;
+    this.onlyIfCached = builder.onlyIfCached;
+    this.noTransform = builder.noTransform;
+    this.immutable = builder.immutable;
+  }
+
+  /**
+   * In a response, this field's name "no-cache" is misleading. It doesn't prevent us from caching
+   * the response; it only means we have to validate the response with the origin server before
+   * returning it. We can do this with a conditional GET.
+   *
+   * <p>In a request, it means do not use a cache to satisfy the request.
+   */
+  public boolean noCache() {
+    return noCache;
+  }
+
+  /** If true, this response should not be cached. */
+  public boolean noStore() {
+    return noStore;
+  }
+
+  /**
+   * The duration past the response's served date that it can be served without validation.
+   */
+  public int maxAgeSeconds() {
+    return maxAgeSeconds;
+  }
+
+  /**
+   * The "s-maxage" directive is the max age for shared caches. Not to be confused with "max-age"
+   * for non-shared caches, As in Firefox and Chrome, this directive is not honored by this cache.
+   */
+  public int sMaxAgeSeconds() {
+    return sMaxAgeSeconds;
+  }
+
+  public boolean isPrivate() {
+    return isPrivate;
+  }
+
+  public boolean isPublic() {
+    return isPublic;
+  }
+
+  public boolean mustRevalidate() {
+    return mustRevalidate;
+  }
+
+  public int maxStaleSeconds() {
+    return maxStaleSeconds;
+  }
+
+  public int minFreshSeconds() {
+    return minFreshSeconds;
+  }
+
+  /**
+   * This field's name "only-if-cached" is misleading. It actually means "do not use the network".
+   * It is set by a client who only wants to make a request if it can be fully satisfied by the
+   * cache. Cached responses that would require validation (ie. conditional gets) are not permitted
+   * if this header is set.
+   */
+  public boolean onlyIfCached() {
+    return onlyIfCached;
+  }
+
+  public boolean noTransform() {
+    return noTransform;
+  }
+
+  public boolean immutable() {
+    return immutable;
+  }
+
+  /**
+   * Returns the cache directives of {@code headers}. This honors both Cache-Control and Pragma
+   * headers if they are present.
+   */
+  public static CacheControl parse(Headers headers) {
+    boolean noCache = false;
+    boolean noStore = false;
+    int maxAgeSeconds = -1;
+    int sMaxAgeSeconds = -1;
+    boolean isPrivate = false;
+    boolean isPublic = false;
+    boolean mustRevalidate = false;
+    int maxStaleSeconds = -1;
+    int minFreshSeconds = -1;
+    boolean onlyIfCached = false;
+    boolean noTransform = false;
+    boolean immutable = false;
+
+    boolean canUseHeaderValue = true;
+    String headerValue = null;
+
+    for (int i = 0, size = headers.size(); i < size; i++) {
+      String name = headers.name(i);
+      String value = headers.value(i);
+
+      if (name.equalsIgnoreCase("Cache-Control")) {
+        if (headerValue != null) {
+          // Multiple cache-control headers means we can't use the raw value.
+          canUseHeaderValue = false;
+        } else {
+          headerValue = value;
+        }
+      } else if (name.equalsIgnoreCase("Pragma")) {
+        // Might specify additional cache-control params. We invalidate just in case.
+        canUseHeaderValue = false;
+      } else {
+        continue;
+      }
+
+      int pos = 0;
+      while (pos < value.length()) {
+        int tokenStart = pos;
+        pos = HttpHeaders.skipUntil(value, pos, "=,;");
+        String directive = value.substring(tokenStart, pos).trim();
+        String parameter;
+
+        if (pos == value.length() || value.charAt(pos) == ',' || value.charAt(pos) == ';') {
+          pos++; // consume ',' or ';' (if necessary)
+          parameter = null;
+        } else {
+          pos++; // consume '='
+          pos = HttpHeaders.skipWhitespace(value, pos);
+
+          // quoted string
+          if (pos < value.length() && value.charAt(pos) == '\"') {
+            pos++; // consume '"' open quote
+            int parameterStart = pos;
+            pos = HttpHeaders.skipUntil(value, pos, "\"");
+            parameter = value.substring(parameterStart, pos);
+            pos++; // consume '"' close quote (if necessary)
+
+            // unquoted string
+          } else {
+            int parameterStart = pos;
+            pos = HttpHeaders.skipUntil(value, pos, ",;");
+            parameter = value.substring(parameterStart, pos).trim();
+          }
+        }
+
+        if ("no-cache".equalsIgnoreCase(directive)) {
+          noCache = true;
+        } else if ("no-store".equalsIgnoreCase(directive)) {
+          noStore = true;
+        } else if ("max-age".equalsIgnoreCase(directive)) {
+          maxAgeSeconds = HttpHeaders.parseSeconds(parameter, -1);
+        } else if ("s-maxage".equalsIgnoreCase(directive)) {
+          sMaxAgeSeconds = HttpHeaders.parseSeconds(parameter, -1);
+        } else if ("private".equalsIgnoreCase(directive)) {
+          isPrivate = true;
+        } else if ("public".equalsIgnoreCase(directive)) {
+          isPublic = true;
+        } else if ("must-revalidate".equalsIgnoreCase(directive)) {
+          mustRevalidate = true;
+        } else if ("max-stale".equalsIgnoreCase(directive)) {
+          maxStaleSeconds = HttpHeaders.parseSeconds(parameter, Integer.MAX_VALUE);
+        } else if ("min-fresh".equalsIgnoreCase(directive)) {
+          minFreshSeconds = HttpHeaders.parseSeconds(parameter, -1);
+        } else if ("only-if-cached".equalsIgnoreCase(directive)) {
+          onlyIfCached = true;
+        } else if ("no-transform".equalsIgnoreCase(directive)) {
+          noTransform = true;
+        } else if ("immutable".equalsIgnoreCase(directive)) {
+          immutable = true;
+        }
+      }
+    }
+
+    if (!canUseHeaderValue) {
+      headerValue = null;
+    }
+    return new CacheControl(noCache, noStore, maxAgeSeconds, sMaxAgeSeconds, isPrivate, isPublic,
+        mustRevalidate, maxStaleSeconds, minFreshSeconds, onlyIfCached, noTransform, immutable,
+        headerValue);
+  }
+
+  @Override public String toString() {
+    String result = headerValue;
+    return result != null ? result : (headerValue = headerValue());
+  }
+
+  private String headerValue() {
+    StringBuilder result = new StringBuilder();
+    if (noCache) result.append("no-cache, ");
+    if (noStore) result.append("no-store, ");
+    if (maxAgeSeconds != -1) result.append("max-age=").append(maxAgeSeconds).append(", ");
+    if (sMaxAgeSeconds != -1) result.append("s-maxage=").append(sMaxAgeSeconds).append(", ");
+    if (isPrivate) result.append("private, ");
+    if (isPublic) result.append("public, ");
+    if (mustRevalidate) result.append("must-revalidate, ");
+    if (maxStaleSeconds != -1) result.append("max-stale=").append(maxStaleSeconds).append(", ");
+    if (minFreshSeconds != -1) result.append("min-fresh=").append(minFreshSeconds).append(", ");
+    if (onlyIfCached) result.append("only-if-cached, ");
+    if (noTransform) result.append("no-transform, ");
+    if (immutable) result.append("immutable, ");
+    if (result.length() == 0) return "";
+    result.delete(result.length() - 2, result.length());
+    return result.toString();
+  }
+
+  /** Builds a {@code Cache-Control} request header. */
+  public static final class Builder {
+    boolean noCache;
+    boolean noStore;
+    int maxAgeSeconds = -1;
+    int maxStaleSeconds = -1;
+    int minFreshSeconds = -1;
+    boolean onlyIfCached;
+    boolean noTransform;
+    boolean immutable;
+
+    /** Don't accept an unvalidated cached response. */
+    public Builder noCache() {
+      this.noCache = true;
+      return this;
+    }
+
+    /** Don't store the server's response in any cache. */
+    public Builder noStore() {
+      this.noStore = true;
+      return this;
+    }
+
+    /**
+     * Sets the maximum age of a cached response. If the cache response's age exceeds {@code
+     * maxAge}, it will not be used and a network request will be made.
+     *
+     * @param maxAge a non-negative integer. This is stored and transmitted with {@link
+     * TimeUnit#SECONDS} precision; finer precision will be lost.
+     */
+    public Builder maxAge(int maxAge, TimeUnit timeUnit) {
+      if (maxAge < 0) throw new IllegalArgumentException("maxAge < 0: " + maxAge);
+      long maxAgeSecondsLong = timeUnit.toSeconds(maxAge);
+      this.maxAgeSeconds = maxAgeSecondsLong > Integer.MAX_VALUE
+          ? Integer.MAX_VALUE
+          : (int) maxAgeSecondsLong;
+      return this;
+    }
+
+    /**
+     * Accept cached responses that have exceeded their freshness lifetime by up to {@code
+     * maxStale}. If unspecified, stale cache responses will not be used.
+     *
+     * @param maxStale a non-negative integer. This is stored and transmitted with {@link
+     * TimeUnit#SECONDS} precision; finer precision will be lost.
+     */
+    public Builder maxStale(int maxStale, TimeUnit timeUnit) {
+      if (maxStale < 0) throw new IllegalArgumentException("maxStale < 0: " + maxStale);
+      long maxStaleSecondsLong = timeUnit.toSeconds(maxStale);
+      this.maxStaleSeconds = maxStaleSecondsLong > Integer.MAX_VALUE
+          ? Integer.MAX_VALUE
+          : (int) maxStaleSecondsLong;
+      return this;
+    }
+
+    /**
+     * Sets the minimum number of seconds that a response will continue to be fresh for. If the
+     * response will be stale when {@code minFresh} have elapsed, the cached response will not be
+     * used and a network request will be made.
+     *
+     * @param minFresh a non-negative integer. This is stored and transmitted with {@link
+     * TimeUnit#SECONDS} precision; finer precision will be lost.
+     */
+    public Builder minFresh(int minFresh, TimeUnit timeUnit) {
+      if (minFresh < 0) throw new IllegalArgumentException("minFresh < 0: " + minFresh);
+      long minFreshSecondsLong = timeUnit.toSeconds(minFresh);
+      this.minFreshSeconds = minFreshSecondsLong > Integer.MAX_VALUE
+          ? Integer.MAX_VALUE
+          : (int) minFreshSecondsLong;
+      return this;
+    }
+
+    /**
+     * Only accept the response if it is in the cache. If the response isn't cached, a {@code 504
+     * Unsatisfiable Request} response will be returned.
+     */
+    public Builder onlyIfCached() {
+      this.onlyIfCached = true;
+      return this;
+    }
+
+    /** Don't accept a transformed response. */
+    public Builder noTransform() {
+      this.noTransform = true;
+      return this;
+    }
+
+    public Builder immutable() {
+      this.immutable = true;
+      return this;
+    }
+
+    public CacheControl build() {
+      return new CacheControl(this);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Call.java b/okhttp/src/main/java/okhttp3/Call.java
new file mode 100644
index 0000000000..5b4669ad21
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Call.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+
+/**
+ * A call is a request that has been prepared for execution. A call can be canceled. As this object
+ * represents a single request/response pair (stream), it cannot be executed twice.
+ */
+public interface Call extends Cloneable {
+  /** Returns the original request that initiated this call. */
+  Request request();
+
+  /**
+   * Invokes the request immediately, and blocks until the response can be processed or is in
+   * error.
+   *
+   * <p>To avoid leaking resources callers should close the {@link Response} which in turn will
+   * close the underlying {@link ResponseBody}.
+   *
+   * <pre>@{code
+   *
+   *   // ensure the response (and underlying response body) is closed
+   *   try (Response response = client.newCall(request).execute()) {
+   *     ...
+   *   }
+   *
+   * }</pre>
+   *
+   * <p>The caller may read the response body with the response's {@link Response#body} method. To
+   * avoid leaking resources callers must {@linkplain ResponseBody close the response body} or the
+   * Response.
+   *
+   * <p>Note that transport-layer success (receiving a HTTP response code, headers and body) does
+   * not necessarily indicate application-layer success: {@code response} may still indicate an
+   * unhappy HTTP response code like 404 or 500.
+   *
+   * @throws IOException if the request could not be executed due to cancellation, a connectivity
+   * problem or timeout. Because networks can fail during an exchange, it is possible that the
+   * remote server accepted the request before the failure.
+   * @throws IllegalStateException when the call has already been executed.
+   */
+  Response execute() throws IOException;
+
+  /**
+   * Schedules the request to be executed at some point in the future.
+   *
+   * <p>The {@link OkHttpClient#dispatcher dispatcher} defines when the request will run: usually
+   * immediately unless there are several other requests currently being executed.
+   *
+   * <p>This client will later call back {@code responseCallback} with either an HTTP response or a
+   * failure exception.
+   *
+   * @throws IllegalStateException when the call has already been executed.
+   */
+  void enqueue(Callback responseCallback);
+
+  /** Cancels the request, if possible. Requests that are already complete cannot be canceled. */
+  void cancel();
+
+  /**
+   * Returns true if this call has been either {@linkplain #execute() executed} or {@linkplain
+   * #enqueue(Callback) enqueued}. It is an error to execute a call more than once.
+   */
+  boolean isExecuted();
+
+  boolean isCanceled();
+
+  /**
+   * Create a new, identical call to this one which can be enqueued or executed even if this call
+   * has already been.
+   */
+  Call clone();
+
+  interface Factory {
+    Call newCall(Request request);
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Callback.java b/okhttp/src/main/java/okhttp3/Callback.java
new file mode 100644
index 0000000000..3b7ed85bf4
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Callback.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+
+public interface Callback {
+  /**
+   * Called when the request could not be executed due to cancellation, a connectivity problem or
+   * timeout. Because networks can fail during an exchange, it is possible that the remote server
+   * accepted the request before the failure.
+   */
+  void onFailure(Call call, IOException e);
+
+  /**
+   * Called when the HTTP response was successfully returned by the remote server. The callback may
+   * proceed to read the response body with {@link Response#body}. The response is still live until
+   * its response body is {@linkplain ResponseBody closed}. The recipient of the callback may
+   * consume the response body on another thread.
+   *
+   * <p>Note that transport-layer success (receiving a HTTP response code, headers and body) does
+   * not necessarily indicate application-layer success: {@code response} may still indicate an
+   * unhappy HTTP response code like 404 or 500.
+   */
+  void onResponse(Call call, Response response) throws IOException;
+}
diff --git a/okhttp/src/main/java/okhttp3/CertificatePinner.java b/okhttp/src/main/java/okhttp3/CertificatePinner.java
new file mode 100644
index 0000000000..6fab2cf1d1
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/CertificatePinner.java
@@ -0,0 +1,344 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.security.cert.Certificate;
+import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Set;
+import javax.annotation.Nullable;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import okhttp3.internal.tls.CertificateChainCleaner;
+import okio.ByteString;
+
+import static okhttp3.internal.Util.equal;
+
+/**
+ * Constrains which certificates are trusted. Pinning certificates defends against attacks on
+ * certificate authorities. It also prevents connections through man-in-the-middle certificate
+ * authorities either known or unknown to the application's user.
+ *
+ * <p>This class currently pins a certificate's Subject Public Key Info as described on <a
+ * href="http://goo.gl/AIx3e5">Adam Langley's Weblog</a>. Pins are either base64 SHA-256 hashes as
+ * in <a href="http://tools.ietf.org/html/rfc7469">HTTP Public Key Pinning (HPKP)</a> or SHA-1
+ * base64 hashes as in Chromium's <a href="http://goo.gl/XDh6je">static certificates</a>.
+ *
+ * <h3>Setting up Certificate Pinning</h3>
+ *
+ * <p>The easiest way to pin a host is turn on pinning with a broken configuration and read the
+ * expected configuration when the connection fails. Be sure to do this on a trusted network, and
+ * without man-in-the-middle tools like <a href="http://charlesproxy.com">Charles</a> or <a
+ * href="http://fiddlertool.com">Fiddler</a>.
+ *
+ * <p>For example, to pin {@code https://publicobject.com}, start with a broken
+ * configuration: <pre>   {@code
+ *
+ *     String hostname = "publicobject.com";
+ *     CertificatePinner certificatePinner = new CertificatePinner.Builder()
+ *         .add(hostname, "sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=")
+ *         .build();
+ *     OkHttpClient client = OkHttpClient.Builder()
+ *         .certificatePinner(certificatePinner)
+ *         .build();
+ *
+ *     Request request = new Request.Builder()
+ *         .url("https://" + hostname)
+ *         .build();
+ *     client.newCall(request).execute();
+ * }</pre>
+ *
+ * As expected, this fails with a certificate pinning exception: <pre>   {@code
+ *
+ * javax.net.ssl.SSLPeerUnverifiedException: Certificate pinning failure!
+ *   Peer certificate chain:
+ *     sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=: CN=publicobject.com, OU=PositiveSSL
+ *     sha256/klO23nT2ehFDXCfx3eHTDRESMz3asj1muO+4aIdjiuY=: CN=COMODO RSA Secure Server CA
+ *     sha256/grX4Ta9HpZx6tSHkmCrvpApTQGo67CYDnvprLg5yRME=: CN=COMODO RSA Certification Authority
+ *     sha256/lCppFqbkrlJ3EcVFAkeip0+44VaoJUymbnOaEUk7tEU=: CN=AddTrust External CA Root
+ *   Pinned certificates for publicobject.com:
+ *     sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=
+ *   at okhttp3.CertificatePinner.check(CertificatePinner.java)
+ *   at okhttp3.Connection.upgradeToTls(Connection.java)
+ *   at okhttp3.Connection.connect(Connection.java)
+ *   at okhttp3.Connection.connectAndSetOwner(Connection.java)
+ * }</pre>
+ *
+ * Follow up by pasting the public key hashes from the exception into the
+ * certificate pinner's configuration: <pre>   {@code
+ *
+ *     CertificatePinner certificatePinner = new CertificatePinner.Builder()
+ *       .add("publicobject.com", "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
+ *       .add("publicobject.com", "sha256/klO23nT2ehFDXCfx3eHTDRESMz3asj1muO+4aIdjiuY=")
+ *       .add("publicobject.com", "sha256/grX4Ta9HpZx6tSHkmCrvpApTQGo67CYDnvprLg5yRME=")
+ *       .add("publicobject.com", "sha256/lCppFqbkrlJ3EcVFAkeip0+44VaoJUymbnOaEUk7tEU=")
+ *       .build();
+ * }</pre>
+ *
+ * Pinning is per-hostname and/or per-wildcard pattern. To pin both {@code publicobject.com} and
+ * {@code www.publicobject.com}, you must configure both hostnames.
+ *
+ * <p>Wildcard pattern rules:
+ * <ol>
+ *     <li>Asterisk {@code *} is only permitted in the left-most domain name label and must be the
+ *         only character in that label (i.e., must match the whole left-most label). For example,
+ *         {@code *.example.com} is permitted, while {@code *a.example.com}, {@code a*.example.com},
+ *         {@code a*b.example.com}, {@code a.*.example.com} are not permitted.
+ *     <li>Asterisk {@code *} cannot match across domain name labels. For example,
+ *         {@code *.example.com} matches {@code test.example.com} but does not match
+ *         {@code sub.test.example.com}.
+ *     <li>Wildcard patterns for single-label domain names are not permitted.
+ * </ol>
+ *
+ * If hostname pinned directly and via wildcard pattern, both direct and wildcard pins will be used.
+ * For example: {@code *.example.com} pinned with {@code pin1} and {@code a.example.com} pinned with
+ * {@code pin2}, to check {@code a.example.com} both {@code pin1} and {@code pin2} will be used.
+ *
+ * <h3>Warning: Certificate Pinning is Dangerous!</h3>
+ *
+ * <p>Pinning certificates limits your server team's abilities to update their TLS certificates. By
+ * pinning certificates, you take on additional operational complexity and limit your ability to
+ * migrate between certificate authorities. Do not use certificate pinning without the blessing of
+ * your server's TLS administrator!
+ *
+ * <h4>Note about self-signed certificates</h4>
+ *
+ * <p>{@link CertificatePinner} can not be used to pin self-signed certificate if such certificate
+ * is not accepted by {@link javax.net.ssl.TrustManager}.
+ *
+ * @see <a href="https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning"> OWASP:
+ * Certificate and Public Key Pinning</a>
+ */
+public final class CertificatePinner {
+  public static final CertificatePinner DEFAULT = new Builder().build();
+
+  private final Set<Pin> pins;
+  private final @Nullable CertificateChainCleaner certificateChainCleaner;
+
+  CertificatePinner(Set<Pin> pins, @Nullable CertificateChainCleaner certificateChainCleaner) {
+    this.pins = pins;
+    this.certificateChainCleaner = certificateChainCleaner;
+  }
+
+  @Override public boolean equals(@Nullable Object other) {
+    if (other == this) return true;
+    return other instanceof CertificatePinner
+        && (equal(certificateChainCleaner, ((CertificatePinner) other).certificateChainCleaner)
+        && pins.equals(((CertificatePinner) other).pins));
+  }
+
+  @Override public int hashCode() {
+    int result = certificateChainCleaner != null ? certificateChainCleaner.hashCode() : 0;
+    result = 31 * result + pins.hashCode();
+    return result;
+  }
+
+  /**
+   * Confirms that at least one of the certificates pinned for {@code hostname} is in {@code
+   * peerCertificates}. Does nothing if there are no certificates pinned for {@code hostname}.
+   * OkHttp calls this after a successful TLS handshake, but before the connection is used.
+   *
+   * @throws SSLPeerUnverifiedException if {@code peerCertificates} don't match the certificates
+   * pinned for {@code hostname}.
+   */
+  public void check(String hostname, List<Certificate> peerCertificates)
+      throws SSLPeerUnverifiedException {
+    List<Pin> pins = findMatchingPins(hostname);
+    if (pins.isEmpty()) return;
+
+    if (certificateChainCleaner != null) {
+      peerCertificates = certificateChainCleaner.clean(peerCertificates, hostname);
+    }
+
+    for (int c = 0, certsSize = peerCertificates.size(); c < certsSize; c++) {
+      X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(c);
+
+      // Lazily compute the hashes for each certificate.
+      ByteString sha1 = null;
+      ByteString sha256 = null;
+
+      for (int p = 0, pinsSize = pins.size(); p < pinsSize; p++) {
+        Pin pin = pins.get(p);
+        if (pin.hashAlgorithm.equals("sha256/")) {
+          if (sha256 == null) sha256 = sha256(x509Certificate);
+          if (pin.hash.equals(sha256)) return; // Success!
+        } else if (pin.hashAlgorithm.equals("sha1/")) {
+          if (sha1 == null) sha1 = sha1(x509Certificate);
+          if (pin.hash.equals(sha1)) return; // Success!
+        } else {
+          throw new AssertionError("unsupported hashAlgorithm: " + pin.hashAlgorithm);
+        }
+      }
+    }
+
+    // If we couldn't find a matching pin, format a nice exception.
+    StringBuilder message = new StringBuilder()
+        .append("Certificate pinning failure!")
+        .append("\n  Peer certificate chain:");
+    for (int c = 0, certsSize = peerCertificates.size(); c < certsSize; c++) {
+      X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(c);
+      message.append("\n    ").append(pin(x509Certificate))
+          .append(": ").append(x509Certificate.getSubjectDN().getName());
+    }
+    message.append("\n  Pinned certificates for ").append(hostname).append(":");
+    for (int p = 0, pinsSize = pins.size(); p < pinsSize; p++) {
+      Pin pin = pins.get(p);
+      message.append("\n    ").append(pin);
+    }
+    throw new SSLPeerUnverifiedException(message.toString());
+  }
+
+  /** @deprecated replaced with {@link #check(String, List)}. */
+  public void check(String hostname, Certificate... peerCertificates)
+      throws SSLPeerUnverifiedException {
+    check(hostname, Arrays.asList(peerCertificates));
+  }
+
+  /**
+   * Returns list of matching certificates' pins for the hostname. Returns an empty list if the
+   * hostname does not have pinned certificates.
+   */
+  List<Pin> findMatchingPins(String hostname) {
+    List<Pin> result = Collections.emptyList();
+    for (Pin pin : pins) {
+      if (pin.matches(hostname)) {
+        if (result.isEmpty()) result = new ArrayList<>();
+        result.add(pin);
+      }
+    }
+    return result;
+  }
+
+  /** Returns a certificate pinner that uses {@code certificateChainCleaner}. */
+  CertificatePinner withCertificateChainCleaner(
+      @Nullable CertificateChainCleaner certificateChainCleaner) {
+    return equal(this.certificateChainCleaner, certificateChainCleaner)
+        ? this
+        : new CertificatePinner(pins, certificateChainCleaner);
+  }
+
+  /**
+   * Returns the SHA-256 of {@code certificate}'s public key.
+   *
+   * <p>In OkHttp 3.1.2 and earlier, this returned a SHA-1 hash of the public key. Both types are
+   * supported, but SHA-256 is preferred.
+   */
+  public static String pin(Certificate certificate) {
+    if (!(certificate instanceof X509Certificate)) {
+      throw new IllegalArgumentException("Certificate pinning requires X509 certificates");
+    }
+    return "sha256/" + sha256((X509Certificate) certificate).base64();
+  }
+
+  static ByteString sha1(X509Certificate x509Certificate) {
+    return ByteString.of(x509Certificate.getPublicKey().getEncoded()).sha1();
+  }
+
+  static ByteString sha256(X509Certificate x509Certificate) {
+    return ByteString.of(x509Certificate.getPublicKey().getEncoded()).sha256();
+  }
+
+  static final class Pin {
+    private static final String WILDCARD = "*.";
+    /** A hostname like {@code example.com} or a pattern like {@code *.example.com}. */
+    final String pattern;
+    /** The canonical hostname, i.e. {@code EXAMPLE.com} becomes {@code example.com}. */
+    final String canonicalHostname;
+    /** Either {@code sha1/} or {@code sha256/}. */
+    final String hashAlgorithm;
+    /** The hash of the pinned certificate using {@link #hashAlgorithm}. */
+    final ByteString hash;
+
+    Pin(String pattern, String pin) {
+      this.pattern = pattern;
+      this.canonicalHostname = pattern.startsWith(WILDCARD)
+          ? HttpUrl.parse("http://" + pattern.substring(WILDCARD.length())).host()
+          : HttpUrl.parse("http://" + pattern).host();
+      if (pin.startsWith("sha1/")) {
+        this.hashAlgorithm = "sha1/";
+        this.hash = ByteString.decodeBase64(pin.substring("sha1/".length()));
+      } else if (pin.startsWith("sha256/")) {
+        this.hashAlgorithm = "sha256/";
+        this.hash = ByteString.decodeBase64(pin.substring("sha256/".length()));
+      } else {
+        throw new IllegalArgumentException("pins must start with 'sha256/' or 'sha1/': " + pin);
+      }
+
+      if (this.hash == null) {
+        throw new IllegalArgumentException("pins must be base64: " + pin);
+      }
+    }
+
+    boolean matches(String hostname) {
+      if (pattern.startsWith(WILDCARD)) {
+        int firstDot = hostname.indexOf('.');
+        return (hostname.length() - firstDot - 1) == canonicalHostname.length()
+            && hostname.regionMatches(false, firstDot + 1, canonicalHostname, 0,
+            canonicalHostname.length());
+      }
+
+      return hostname.equals(canonicalHostname);
+    }
+
+    @Override public boolean equals(Object other) {
+      return other instanceof Pin
+          && pattern.equals(((Pin) other).pattern)
+          && hashAlgorithm.equals(((Pin) other).hashAlgorithm)
+          && hash.equals(((Pin) other).hash);
+    }
+
+    @Override public int hashCode() {
+      int result = 17;
+      result = 31 * result + pattern.hashCode();
+      result = 31 * result + hashAlgorithm.hashCode();
+      result = 31 * result + hash.hashCode();
+      return result;
+    }
+
+    @Override public String toString() {
+      return hashAlgorithm + hash.base64();
+    }
+  }
+
+  /** Builds a configured certificate pinner. */
+  public static final class Builder {
+    private final List<Pin> pins = new ArrayList<>();
+
+    /**
+     * Pins certificates for {@code pattern}.
+     *
+     * @param pattern lower-case host name or wildcard pattern such as {@code *.example.com}.
+     * @param pins SHA-256 or SHA-1 hashes. Each pin is a hash of a certificate's Subject Public Key
+     * Info, base64-encoded and prefixed with either {@code sha256/} or {@code sha1/}.
+     */
+    public Builder add(String pattern, String... pins) {
+      if (pattern == null) throw new NullPointerException("pattern == null");
+
+      for (String pin : pins) {
+        this.pins.add(new Pin(pattern, pin));
+      }
+
+      return this;
+    }
+
+    public CertificatePinner build() {
+      return new CertificatePinner(new LinkedHashSet<>(pins), null);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Challenge.java b/okhttp/src/main/java/okhttp3/Challenge.java
new file mode 100644
index 0000000000..4b000eceda
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Challenge.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.nio.charset.Charset;
+import javax.annotation.Nullable;
+
+import static okhttp3.internal.Util.ISO_8859_1;
+
+/** An RFC 7617 challenge. */
+public final class Challenge {
+  private final String scheme;
+  private final String realm;
+  private final Charset charset;
+
+  public Challenge(String scheme, String realm) {
+    this(scheme, realm, ISO_8859_1);
+  }
+
+  private Challenge(String scheme, String realm, Charset charset) {
+    if (scheme == null) throw new NullPointerException("scheme == null");
+    if (realm == null) throw new NullPointerException("realm == null");
+    if (charset == null) throw new NullPointerException("charset == null");
+    this.scheme = scheme;
+    this.realm = realm;
+    this.charset = charset;
+  }
+
+  /** Returns a copy of this charset that expects a credential encoded with {@code charset}. */
+  public Challenge withCharset(Charset charset) {
+    return new Challenge(scheme, realm, charset);
+  }
+
+  /** Returns the authentication scheme, like {@code Basic}. */
+  public String scheme() {
+    return scheme;
+  }
+
+  /** Returns the protection space. */
+  public String realm() {
+    return realm;
+  }
+
+  /** Returns the charset that should be used to encode the credential. */
+  public Charset charset() {
+    return charset;
+  }
+
+  @Override public boolean equals(@Nullable Object other) {
+    return other instanceof Challenge
+        && ((Challenge) other).scheme.equals(scheme)
+        && ((Challenge) other).realm.equals(realm)
+        && ((Challenge) other).charset.equals(charset);
+  }
+
+  @Override public int hashCode() {
+    int result = 29;
+    result = 31 * result + realm.hashCode();
+    result = 31 * result + scheme.hashCode();
+    result = 31 * result + charset.hashCode();
+    return result;
+  }
+
+  @Override public String toString() {
+    return scheme
+        + " realm=\"" + realm + "\""
+        + " charset=\"" + charset + "\"";
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/CipherSuite.java b/okhttp/src/main/java/okhttp3/CipherSuite.java
new file mode 100644
index 0000000000..a71ddc5ed9
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/CipherSuite.java
@@ -0,0 +1,444 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Map;
+import java.util.TreeMap;
+
+/**
+ * <a href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml">TLS cipher
+ * suites</a>.
+ *
+ * <p><strong>Not all cipher suites are supported on all platforms.</strong> As newer cipher suites
+ * are created (for stronger privacy, better performance, etc.) they will be adopted by the platform
+ * and then exposed here. Cipher suites that are not available on either Android (through API level
+ * 20) or Java (through JDK 8) are omitted for brevity.
+ *
+ * <p>See also <a href="https://android.googlesource.com/platform/external/conscrypt/+/master/src/main/java/org/conscrypt/NativeCrypto.java">NativeCrypto.java</a>
+ * from conscrypt, which lists the cipher suites supported by Android.
+ */
+public final class CipherSuite {
+  /**
+   * Compares cipher suites names like "TLS_RSA_WITH_NULL_MD5" and "SSL_RSA_WITH_NULL_MD5", ignoring
+   * the "TLS_" or "SSL_" prefix which is not consistent across platforms. In particular some IBM
+   * JVMs use the "SSL_" prefix everywhere whereas Oracle JVMs mix "TLS_" and "SSL_".
+   */
+  static final Comparator<String> ORDER_BY_NAME = new Comparator<String>() {
+    @Override public int compare(String a, String b) {
+      for (int i = 4, limit = Math.min(a.length(), b.length()); i < limit; i++) {
+        char charA = a.charAt(i);
+        char charB = b.charAt(i);
+        if (charA != charB) return charA < charB ? -1 : 1;
+      }
+      int lengthA = a.length();
+      int lengthB = b.length();
+      if (lengthA != lengthB) return lengthA < lengthB ? -1 : 1;
+      return 0;
+    }
+  };
+
+  /**
+   * Holds interned instances. This needs to be above the of() calls below so that it's
+   * initialized by the time those parts of {@code <clinit>()} run. Guarded by CipherSuite.class.
+   */
+  private static final Map<String, CipherSuite> INSTANCES = new TreeMap<>(ORDER_BY_NAME);
+
+  // Last updated 2016-07-03 using cipher suites from Android 24 and Java 9.
+
+  // public static final CipherSuite TLS_NULL_WITH_NULL_NULL = of("TLS_NULL_WITH_NULL_NULL", 0x0000);
+  public static final CipherSuite TLS_RSA_WITH_NULL_MD5 = of("SSL_RSA_WITH_NULL_MD5", 0x0001);
+  public static final CipherSuite TLS_RSA_WITH_NULL_SHA = of("SSL_RSA_WITH_NULL_SHA", 0x0002);
+  public static final CipherSuite TLS_RSA_EXPORT_WITH_RC4_40_MD5 = of("SSL_RSA_EXPORT_WITH_RC4_40_MD5", 0x0003);
+  public static final CipherSuite TLS_RSA_WITH_RC4_128_MD5 = of("SSL_RSA_WITH_RC4_128_MD5", 0x0004);
+  public static final CipherSuite TLS_RSA_WITH_RC4_128_SHA = of("SSL_RSA_WITH_RC4_128_SHA", 0x0005);
+  // public static final CipherSuite TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 = of("SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5", 0x0006);
+  // public static final CipherSuite TLS_RSA_WITH_IDEA_CBC_SHA = of("TLS_RSA_WITH_IDEA_CBC_SHA", 0x0007);
+  public static final CipherSuite TLS_RSA_EXPORT_WITH_DES40_CBC_SHA = of("SSL_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0008);
+  public static final CipherSuite TLS_RSA_WITH_DES_CBC_SHA = of("SSL_RSA_WITH_DES_CBC_SHA", 0x0009);
+  public static final CipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA = of("SSL_RSA_WITH_3DES_EDE_CBC_SHA", 0x000a);
+  // public static final CipherSuite TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x000b);
+  // public static final CipherSuite TLS_DH_DSS_WITH_DES_CBC_SHA = of("TLS_DH_DSS_WITH_DES_CBC_SHA", 0x000c);
+  // public static final CipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA = of("TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA", 0x000d);
+  // public static final CipherSuite TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x000e);
+  // public static final CipherSuite TLS_DH_RSA_WITH_DES_CBC_SHA = of("TLS_DH_RSA_WITH_DES_CBC_SHA", 0x000f);
+  // public static final CipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA = of("TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA", 0x0010);
+  public static final CipherSuite TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x0011);
+  public static final CipherSuite TLS_DHE_DSS_WITH_DES_CBC_SHA = of("SSL_DHE_DSS_WITH_DES_CBC_SHA", 0x0012);
+  public static final CipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA = of("SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA", 0x0013);
+  public static final CipherSuite TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0014);
+  public static final CipherSuite TLS_DHE_RSA_WITH_DES_CBC_SHA = of("SSL_DHE_RSA_WITH_DES_CBC_SHA", 0x0015);
+  public static final CipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA = of("SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA", 0x0016);
+  public static final CipherSuite TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 = of("SSL_DH_anon_EXPORT_WITH_RC4_40_MD5", 0x0017);
+  public static final CipherSuite TLS_DH_anon_WITH_RC4_128_MD5 = of("SSL_DH_anon_WITH_RC4_128_MD5", 0x0018);
+  public static final CipherSuite TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA", 0x0019);
+  public static final CipherSuite TLS_DH_anon_WITH_DES_CBC_SHA = of("SSL_DH_anon_WITH_DES_CBC_SHA", 0x001a);
+  public static final CipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA = of("SSL_DH_anon_WITH_3DES_EDE_CBC_SHA", 0x001b);
+  public static final CipherSuite TLS_KRB5_WITH_DES_CBC_SHA = of("TLS_KRB5_WITH_DES_CBC_SHA", 0x001e);
+  public static final CipherSuite TLS_KRB5_WITH_3DES_EDE_CBC_SHA = of("TLS_KRB5_WITH_3DES_EDE_CBC_SHA", 0x001f);
+  public static final CipherSuite TLS_KRB5_WITH_RC4_128_SHA = of("TLS_KRB5_WITH_RC4_128_SHA", 0x0020);
+  // public static final CipherSuite TLS_KRB5_WITH_IDEA_CBC_SHA = of("TLS_KRB5_WITH_IDEA_CBC_SHA", 0x0021);
+  public static final CipherSuite TLS_KRB5_WITH_DES_CBC_MD5 = of("TLS_KRB5_WITH_DES_CBC_MD5", 0x0022);
+  public static final CipherSuite TLS_KRB5_WITH_3DES_EDE_CBC_MD5 = of("TLS_KRB5_WITH_3DES_EDE_CBC_MD5", 0x0023);
+  public static final CipherSuite TLS_KRB5_WITH_RC4_128_MD5 = of("TLS_KRB5_WITH_RC4_128_MD5", 0x0024);
+  // public static final CipherSuite TLS_KRB5_WITH_IDEA_CBC_MD5 = of("TLS_KRB5_WITH_IDEA_CBC_MD5", 0x0025);
+  public static final CipherSuite TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA = of("TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA", 0x0026);
+  // public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA = of("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA", 0x0027);
+  public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC4_40_SHA = of("TLS_KRB5_EXPORT_WITH_RC4_40_SHA", 0x0028);
+  public static final CipherSuite TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5 = of("TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5", 0x0029);
+  // public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5 = of("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5", 0x002a);
+  public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC4_40_MD5 = of("TLS_KRB5_EXPORT_WITH_RC4_40_MD5", 0x002b);
+  // public static final CipherSuite TLS_PSK_WITH_NULL_SHA = of("TLS_PSK_WITH_NULL_SHA", 0x002c);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_NULL_SHA = of("TLS_DHE_PSK_WITH_NULL_SHA", 0x002d);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_NULL_SHA = of("TLS_RSA_PSK_WITH_NULL_SHA", 0x002e);
+  public static final CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA = of("TLS_RSA_WITH_AES_128_CBC_SHA", 0x002f);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA = of("TLS_DH_DSS_WITH_AES_128_CBC_SHA", 0x0030);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA = of("TLS_DH_RSA_WITH_AES_128_CBC_SHA", 0x0031);
+  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA = of("TLS_DHE_DSS_WITH_AES_128_CBC_SHA", 0x0032);
+  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA = of("TLS_DHE_RSA_WITH_AES_128_CBC_SHA", 0x0033);
+  public static final CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA = of("TLS_DH_anon_WITH_AES_128_CBC_SHA", 0x0034);
+  public static final CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA = of("TLS_RSA_WITH_AES_256_CBC_SHA", 0x0035);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA = of("TLS_DH_DSS_WITH_AES_256_CBC_SHA", 0x0036);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA = of("TLS_DH_RSA_WITH_AES_256_CBC_SHA", 0x0037);
+  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA = of("TLS_DHE_DSS_WITH_AES_256_CBC_SHA", 0x0038);
+  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA = of("TLS_DHE_RSA_WITH_AES_256_CBC_SHA", 0x0039);
+  public static final CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA = of("TLS_DH_anon_WITH_AES_256_CBC_SHA", 0x003a);
+  public static final CipherSuite TLS_RSA_WITH_NULL_SHA256 = of("TLS_RSA_WITH_NULL_SHA256", 0x003b);
+  public static final CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_RSA_WITH_AES_128_CBC_SHA256", 0x003c);
+  public static final CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA256 = of("TLS_RSA_WITH_AES_256_CBC_SHA256", 0x003d);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA256 = of("TLS_DH_DSS_WITH_AES_128_CBC_SHA256", 0x003e);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_DH_RSA_WITH_AES_128_CBC_SHA256", 0x003f);
+  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 = of("TLS_DHE_DSS_WITH_AES_128_CBC_SHA256", 0x0040);
+  public static final CipherSuite TLS_RSA_WITH_CAMELLIA_128_CBC_SHA = of("TLS_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0041);
+  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0042);
+  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0043);
+  public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0044);
+  public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0045);
+  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA", 0x0046);
+  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_DHE_RSA_WITH_AES_128_CBC_SHA256", 0x0067);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA256 = of("TLS_DH_DSS_WITH_AES_256_CBC_SHA256", 0x0068);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA256 = of("TLS_DH_RSA_WITH_AES_256_CBC_SHA256", 0x0069);
+  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 = of("TLS_DHE_DSS_WITH_AES_256_CBC_SHA256", 0x006a);
+  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 = of("TLS_DHE_RSA_WITH_AES_256_CBC_SHA256", 0x006b);
+  public static final CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA256 = of("TLS_DH_anon_WITH_AES_128_CBC_SHA256", 0x006c);
+  public static final CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA256 = of("TLS_DH_anon_WITH_AES_256_CBC_SHA256", 0x006d);
+  public static final CipherSuite TLS_RSA_WITH_CAMELLIA_256_CBC_SHA = of("TLS_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0084);
+  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0085);
+  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0086);
+  public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0087);
+  public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0088);
+  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA", 0x0089);
+  public static final CipherSuite TLS_PSK_WITH_RC4_128_SHA = of("TLS_PSK_WITH_RC4_128_SHA", 0x008a);
+  public static final CipherSuite TLS_PSK_WITH_3DES_EDE_CBC_SHA = of("TLS_PSK_WITH_3DES_EDE_CBC_SHA", 0x008b);
+  public static final CipherSuite TLS_PSK_WITH_AES_128_CBC_SHA = of("TLS_PSK_WITH_AES_128_CBC_SHA", 0x008c);
+  public static final CipherSuite TLS_PSK_WITH_AES_256_CBC_SHA = of("TLS_PSK_WITH_AES_256_CBC_SHA", 0x008d);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_RC4_128_SHA = of("TLS_DHE_PSK_WITH_RC4_128_SHA", 0x008e);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA = of("TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA", 0x008f);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_CBC_SHA = of("TLS_DHE_PSK_WITH_AES_128_CBC_SHA", 0x0090);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_CBC_SHA = of("TLS_DHE_PSK_WITH_AES_256_CBC_SHA", 0x0091);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_RC4_128_SHA = of("TLS_RSA_PSK_WITH_RC4_128_SHA", 0x0092);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA = of("TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA", 0x0093);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_128_CBC_SHA = of("TLS_RSA_PSK_WITH_AES_128_CBC_SHA", 0x0094);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_256_CBC_SHA = of("TLS_RSA_PSK_WITH_AES_256_CBC_SHA", 0x0095);
+  public static final CipherSuite TLS_RSA_WITH_SEED_CBC_SHA = of("TLS_RSA_WITH_SEED_CBC_SHA", 0x0096);
+  // public static final CipherSuite TLS_DH_DSS_WITH_SEED_CBC_SHA = of("TLS_DH_DSS_WITH_SEED_CBC_SHA", 0x0097);
+  // public static final CipherSuite TLS_DH_RSA_WITH_SEED_CBC_SHA = of("TLS_DH_RSA_WITH_SEED_CBC_SHA", 0x0098);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_SEED_CBC_SHA = of("TLS_DHE_DSS_WITH_SEED_CBC_SHA", 0x0099);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_SEED_CBC_SHA = of("TLS_DHE_RSA_WITH_SEED_CBC_SHA", 0x009a);
+  // public static final CipherSuite TLS_DH_anon_WITH_SEED_CBC_SHA = of("TLS_DH_anon_WITH_SEED_CBC_SHA", 0x009b);
+  public static final CipherSuite TLS_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_RSA_WITH_AES_128_GCM_SHA256", 0x009c);
+  public static final CipherSuite TLS_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_RSA_WITH_AES_256_GCM_SHA384", 0x009d);
+  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_DHE_RSA_WITH_AES_128_GCM_SHA256", 0x009e);
+  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_DHE_RSA_WITH_AES_256_GCM_SHA384", 0x009f);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_DH_RSA_WITH_AES_128_GCM_SHA256", 0x00a0);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_DH_RSA_WITH_AES_256_GCM_SHA384", 0x00a1);
+  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_GCM_SHA256 = of("TLS_DHE_DSS_WITH_AES_128_GCM_SHA256", 0x00a2);
+  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_GCM_SHA384 = of("TLS_DHE_DSS_WITH_AES_256_GCM_SHA384", 0x00a3);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_GCM_SHA256 = of("TLS_DH_DSS_WITH_AES_128_GCM_SHA256", 0x00a4);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_GCM_SHA384 = of("TLS_DH_DSS_WITH_AES_256_GCM_SHA384", 0x00a5);
+  public static final CipherSuite TLS_DH_anon_WITH_AES_128_GCM_SHA256 = of("TLS_DH_anon_WITH_AES_128_GCM_SHA256", 0x00a6);
+  public static final CipherSuite TLS_DH_anon_WITH_AES_256_GCM_SHA384 = of("TLS_DH_anon_WITH_AES_256_GCM_SHA384", 0x00a7);
+  // public static final CipherSuite TLS_PSK_WITH_AES_128_GCM_SHA256 = of("TLS_PSK_WITH_AES_128_GCM_SHA256", 0x00a8);
+  // public static final CipherSuite TLS_PSK_WITH_AES_256_GCM_SHA384 = of("TLS_PSK_WITH_AES_256_GCM_SHA384", 0x00a9);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_GCM_SHA256 = of("TLS_DHE_PSK_WITH_AES_128_GCM_SHA256", 0x00aa);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_GCM_SHA384 = of("TLS_DHE_PSK_WITH_AES_256_GCM_SHA384", 0x00ab);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_128_GCM_SHA256 = of("TLS_RSA_PSK_WITH_AES_128_GCM_SHA256", 0x00ac);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_256_GCM_SHA384 = of("TLS_RSA_PSK_WITH_AES_256_GCM_SHA384", 0x00ad);
+  // public static final CipherSuite TLS_PSK_WITH_AES_128_CBC_SHA256 = of("TLS_PSK_WITH_AES_128_CBC_SHA256", 0x00ae);
+  // public static final CipherSuite TLS_PSK_WITH_AES_256_CBC_SHA384 = of("TLS_PSK_WITH_AES_256_CBC_SHA384", 0x00af);
+  // public static final CipherSuite TLS_PSK_WITH_NULL_SHA256 = of("TLS_PSK_WITH_NULL_SHA256", 0x00b0);
+  // public static final CipherSuite TLS_PSK_WITH_NULL_SHA384 = of("TLS_PSK_WITH_NULL_SHA384", 0x00b1);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_CBC_SHA256 = of("TLS_DHE_PSK_WITH_AES_128_CBC_SHA256", 0x00b2);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_CBC_SHA384 = of("TLS_DHE_PSK_WITH_AES_256_CBC_SHA384", 0x00b3);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_NULL_SHA256 = of("TLS_DHE_PSK_WITH_NULL_SHA256", 0x00b4);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_NULL_SHA384 = of("TLS_DHE_PSK_WITH_NULL_SHA384", 0x00b5);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_128_CBC_SHA256 = of("TLS_RSA_PSK_WITH_AES_128_CBC_SHA256", 0x00b6);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_256_CBC_SHA384 = of("TLS_RSA_PSK_WITH_AES_256_CBC_SHA384", 0x00b7);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_NULL_SHA256 = of("TLS_RSA_PSK_WITH_NULL_SHA256", 0x00b8);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_NULL_SHA384 = of("TLS_RSA_PSK_WITH_NULL_SHA384", 0x00b9);
+  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00ba);
+  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256", 0x00bb);
+  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00bc);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256", 0x00bd);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00be);
+  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256", 0x00bf);
+  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c0);
+  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256", 0x00c1);
+  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c2);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256", 0x00c3);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c4);
+  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256", 0x00c5);
+  public static final CipherSuite TLS_EMPTY_RENEGOTIATION_INFO_SCSV = of("TLS_EMPTY_RENEGOTIATION_INFO_SCSV", 0x00ff);
+  public static final CipherSuite TLS_FALLBACK_SCSV = of("TLS_FALLBACK_SCSV", 0x5600);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_NULL_SHA = of("TLS_ECDH_ECDSA_WITH_NULL_SHA", 0xc001);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_RC4_128_SHA = of("TLS_ECDH_ECDSA_WITH_RC4_128_SHA", 0xc002);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA", 0xc003);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA = of("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA", 0xc004);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA = of("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA", 0xc005);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_NULL_SHA = of("TLS_ECDHE_ECDSA_WITH_NULL_SHA", 0xc006);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_RC4_128_SHA = of("TLS_ECDHE_ECDSA_WITH_RC4_128_SHA", 0xc007);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA", 0xc008);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = of("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA", 0xc009);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = of("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA", 0xc00a);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_NULL_SHA = of("TLS_ECDH_RSA_WITH_NULL_SHA", 0xc00b);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_RC4_128_SHA = of("TLS_ECDH_RSA_WITH_RC4_128_SHA", 0xc00c);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA", 0xc00d);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA = of("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA", 0xc00e);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA = of("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA", 0xc00f);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_NULL_SHA = of("TLS_ECDHE_RSA_WITH_NULL_SHA", 0xc010);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_RC4_128_SHA = of("TLS_ECDHE_RSA_WITH_RC4_128_SHA", 0xc011);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA", 0xc012);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA = of("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA", 0xc013);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA = of("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA", 0xc014);
+  public static final CipherSuite TLS_ECDH_anon_WITH_NULL_SHA = of("TLS_ECDH_anon_WITH_NULL_SHA", 0xc015);
+  public static final CipherSuite TLS_ECDH_anon_WITH_RC4_128_SHA = of("TLS_ECDH_anon_WITH_RC4_128_SHA", 0xc016);
+  public static final CipherSuite TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA", 0xc017);
+  public static final CipherSuite TLS_ECDH_anon_WITH_AES_128_CBC_SHA = of("TLS_ECDH_anon_WITH_AES_128_CBC_SHA", 0xc018);
+  public static final CipherSuite TLS_ECDH_anon_WITH_AES_256_CBC_SHA = of("TLS_ECDH_anon_WITH_AES_256_CBC_SHA", 0xc019);
+  // public static final CipherSuite TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA = of("TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA", 0xc01a);
+  // public static final CipherSuite TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA = of("TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA", 0xc01b);
+  // public static final CipherSuite TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA = of("TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA", 0xc01c);
+  // public static final CipherSuite TLS_SRP_SHA_WITH_AES_128_CBC_SHA = of("TLS_SRP_SHA_WITH_AES_128_CBC_SHA", 0xc01d);
+  // public static final CipherSuite TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA = of("TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA", 0xc01e);
+  // public static final CipherSuite TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA = of("TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA", 0xc01f);
+  // public static final CipherSuite TLS_SRP_SHA_WITH_AES_256_CBC_SHA = of("TLS_SRP_SHA_WITH_AES_256_CBC_SHA", 0xc020);
+  // public static final CipherSuite TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA = of("TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA", 0xc021);
+  // public static final CipherSuite TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA = of("TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA", 0xc022);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 = of("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256", 0xc023);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 = of("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384", 0xc024);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 = of("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256", 0xc025);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 = of("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384", 0xc026);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256", 0xc027);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 = of("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384", 0xc028);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256", 0xc029);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 = of("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384", 0xc02a);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = of("TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02b);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = of("TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02c);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 = of("TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02d);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 = of("TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02e);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256", 0xc02f);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384", 0xc030);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256", 0xc031);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384", 0xc032);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_RC4_128_SHA = of("TLS_ECDHE_PSK_WITH_RC4_128_SHA", 0xc033);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA", 0xc034);
+  public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA = of("TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA", 0xc035);
+  public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA = of("TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA", 0xc036);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256 = of("TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256", 0xc037);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384 = of("TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384", 0xc038);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA = of("TLS_ECDHE_PSK_WITH_NULL_SHA", 0xc039);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA256 = of("TLS_ECDHE_PSK_WITH_NULL_SHA256", 0xc03a);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA384 = of("TLS_ECDHE_PSK_WITH_NULL_SHA384", 0xc03b);
+  // public static final CipherSuite TLS_RSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_RSA_WITH_ARIA_128_CBC_SHA256", 0xc03c);
+  // public static final CipherSuite TLS_RSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_RSA_WITH_ARIA_256_CBC_SHA384", 0xc03d);
+  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256 = of("TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256", 0xc03e);
+  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384 = of("TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384", 0xc03f);
+  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256", 0xc040);
+  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384", 0xc041);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256 = of("TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256", 0xc042);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384 = of("TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384", 0xc043);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256", 0xc044);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384", 0xc045);
+  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_128_CBC_SHA256 = of("TLS_DH_anon_WITH_ARIA_128_CBC_SHA256", 0xc046);
+  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_256_CBC_SHA384 = of("TLS_DH_anon_WITH_ARIA_256_CBC_SHA384", 0xc047);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256", 0xc048);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384", 0xc049);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256", 0xc04a);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384", 0xc04b);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256", 0xc04c);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384", 0xc04d);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256", 0xc04e);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384", 0xc04f);
+  // public static final CipherSuite TLS_RSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_RSA_WITH_ARIA_128_GCM_SHA256", 0xc050);
+  // public static final CipherSuite TLS_RSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_RSA_WITH_ARIA_256_GCM_SHA384", 0xc051);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256", 0xc052);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384", 0xc053);
+  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256", 0xc054);
+  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384", 0xc055);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256 = of("TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256", 0xc056);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384 = of("TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384", 0xc057);
+  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256 = of("TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256", 0xc058);
+  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384 = of("TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384", 0xc059);
+  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_128_GCM_SHA256 = of("TLS_DH_anon_WITH_ARIA_128_GCM_SHA256", 0xc05a);
+  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_256_GCM_SHA384 = of("TLS_DH_anon_WITH_ARIA_256_GCM_SHA384", 0xc05b);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256", 0xc05c);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384", 0xc05d);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256", 0xc05e);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384", 0xc05f);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256", 0xc060);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384", 0xc061);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256", 0xc062);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384", 0xc063);
+  // public static final CipherSuite TLS_PSK_WITH_ARIA_128_CBC_SHA256 = of("TLS_PSK_WITH_ARIA_128_CBC_SHA256", 0xc064);
+  // public static final CipherSuite TLS_PSK_WITH_ARIA_256_CBC_SHA384 = of("TLS_PSK_WITH_ARIA_256_CBC_SHA384", 0xc065);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256 = of("TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256", 0xc066);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384 = of("TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384", 0xc067);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256 = of("TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256", 0xc068);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384 = of("TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384", 0xc069);
+  // public static final CipherSuite TLS_PSK_WITH_ARIA_128_GCM_SHA256 = of("TLS_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06a);
+  // public static final CipherSuite TLS_PSK_WITH_ARIA_256_GCM_SHA384 = of("TLS_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06b);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256 = of("TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06c);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384 = of("TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06d);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256 = of("TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06e);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384 = of("TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06f);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256 = of("TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256", 0xc070);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384 = of("TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384", 0xc071);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc072);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc073);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc074);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc075);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc076);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc077);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc078);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc079);
+  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07a);
+  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07b);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07c);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07d);
+  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07e);
+  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07f);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256", 0xc080);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384", 0xc081);
+  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256", 0xc082);
+  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384", 0xc083);
+  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256", 0xc084);
+  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384", 0xc085);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc086);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc087);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc088);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc089);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc08a);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc08b);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc08c);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc08d);
+  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc08e);
+  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc08f);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc090);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc091);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc092);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc093);
+  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc094);
+  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc095);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc096);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc097);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc098);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc099);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc09a);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc09b);
+  // public static final CipherSuite TLS_RSA_WITH_AES_128_CCM = of("TLS_RSA_WITH_AES_128_CCM", 0xc09c);
+  // public static final CipherSuite TLS_RSA_WITH_AES_256_CCM = of("TLS_RSA_WITH_AES_256_CCM", 0xc09d);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CCM = of("TLS_DHE_RSA_WITH_AES_128_CCM", 0xc09e);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CCM = of("TLS_DHE_RSA_WITH_AES_256_CCM", 0xc09f);
+  // public static final CipherSuite TLS_RSA_WITH_AES_128_CCM_8 = of("TLS_RSA_WITH_AES_128_CCM_8", 0xc0a0);
+  // public static final CipherSuite TLS_RSA_WITH_AES_256_CCM_8 = of("TLS_RSA_WITH_AES_256_CCM_8", 0xc0a1);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CCM_8 = of("TLS_DHE_RSA_WITH_AES_128_CCM_8", 0xc0a2);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CCM_8 = of("TLS_DHE_RSA_WITH_AES_256_CCM_8", 0xc0a3);
+  // public static final CipherSuite TLS_PSK_WITH_AES_128_CCM = of("TLS_PSK_WITH_AES_128_CCM", 0xc0a4);
+  // public static final CipherSuite TLS_PSK_WITH_AES_256_CCM = of("TLS_PSK_WITH_AES_256_CCM", 0xc0a5);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_CCM = of("TLS_DHE_PSK_WITH_AES_128_CCM", 0xc0a6);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_CCM = of("TLS_DHE_PSK_WITH_AES_256_CCM", 0xc0a7);
+  // public static final CipherSuite TLS_PSK_WITH_AES_128_CCM_8 = of("TLS_PSK_WITH_AES_128_CCM_8", 0xc0a8);
+  // public static final CipherSuite TLS_PSK_WITH_AES_256_CCM_8 = of("TLS_PSK_WITH_AES_256_CCM_8", 0xc0a9);
+  // public static final CipherSuite TLS_PSK_DHE_WITH_AES_128_CCM_8 = of("TLS_PSK_DHE_WITH_AES_128_CCM_8", 0xc0aa);
+  // public static final CipherSuite TLS_PSK_DHE_WITH_AES_256_CCM_8 = of("TLS_PSK_DHE_WITH_AES_256_CCM_8", 0xc0ab);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CCM = of("TLS_ECDHE_ECDSA_WITH_AES_128_CCM", 0xc0ac);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CCM = of("TLS_ECDHE_ECDSA_WITH_AES_256_CCM", 0xc0ad);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 = of("TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8", 0xc0ae);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8 = of("TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8", 0xc0af);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256", 0xcca8);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256", 0xcca9);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256", 0xccaa);
+  // public static final CipherSuite TLS_PSK_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccab);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccac);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccad);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccae);
+
+  final String javaName;
+
+  /**
+   * @param javaName the name used by Java APIs for this cipher suite. Different than the IANA name
+   *     for older cipher suites because the prefix is {@code SSL_} instead of {@code TLS_}.
+   */
+  public static synchronized CipherSuite forJavaName(String javaName) {
+    CipherSuite result = INSTANCES.get(javaName);
+    if (result == null) {
+      result = new CipherSuite(javaName);
+      INSTANCES.put(javaName, result);
+    }
+    return result;
+  }
+
+  static List<CipherSuite> forJavaNames(String... cipherSuites) {
+    List<CipherSuite> result = new ArrayList<>(cipherSuites.length);
+    for (String cipherSuite : cipherSuites) {
+      result.add(forJavaName(cipherSuite));
+    }
+    return Collections.unmodifiableList(result);
+  }
+
+  private CipherSuite(String javaName) {
+    if (javaName == null) {
+      throw new NullPointerException();
+    }
+    this.javaName = javaName;
+  }
+
+  /**
+   * @param javaName the name used by Java APIs for this cipher suite. Different than the IANA name
+   *     for older cipher suites because the prefix is {@code SSL_} instead of {@code TLS_}.
+   * @param value the integer identifier for this cipher suite. (Documentation only.)
+   */
+  private static CipherSuite of(String javaName, int value) {
+    return forJavaName(javaName);
+  }
+
+  /**
+   * Returns the Java name of this cipher suite. For some older cipher suites the Java name has the
+   * prefix {@code SSL_}, causing the Java name to be different from the instance name which is
+   * always prefixed {@code TLS_}. For example, {@code TLS_RSA_EXPORT_WITH_RC4_40_MD5.javaName()}
+   * is {@code "SSL_RSA_EXPORT_WITH_RC4_40_MD5"}.
+   */
+  public String javaName() {
+    return javaName;
+  }
+
+  @Override public String toString() {
+    return javaName;
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Connection.java b/okhttp/src/main/java/okhttp3/Connection.java
new file mode 100644
index 0000000000..cb6d70996d
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Connection.java
@@ -0,0 +1,94 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3;
+
+import java.net.Socket;
+import javax.annotation.Nullable;
+
+/**
+ * The sockets and streams of an HTTP, HTTPS, or HTTPS+HTTP/2 connection. May be used for multiple
+ * HTTP request/response exchanges. Connections may be direct to the origin server or via a proxy.
+ *
+ * <p>Typically instances of this class are created, connected and exercised automatically by the
+ * HTTP client. Applications may use this class to monitor HTTP connections as members of a
+ * {@linkplain ConnectionPool connection pool}.
+ *
+ * <p>Do not confuse this class with the misnamed {@code HttpURLConnection}, which isn't so much a
+ * connection as a single request/response exchange.
+ *
+ * <h3>Modern TLS</h3>
+ *
+ * <p>There are tradeoffs when selecting which options to include when negotiating a secure
+ * connection to a remote host. Newer TLS options are quite useful:
+ *
+ * <ul>
+ *     <li>Server Name Indication (SNI) enables one IP address to negotiate secure connections for
+ *         multiple domain names.
+ *     <li>Application Layer Protocol Negotiation (ALPN) enables the HTTPS port (443) to be used to
+ *         negotiate HTTP/2.
+ * </ul>
+ *
+ * <p>Unfortunately, older HTTPS servers refuse to connect when such options are presented. Rather
+ * than avoiding these options entirely, this class allows a connection to be attempted with modern
+ * options and then retried without them should the attempt fail.
+ *
+ * <h3>Connection Reuse</h3>
+ *
+ * <p>Each connection can carry a varying number of streams, depending on the underlying protocol
+ * being used. HTTP/1.x connections can carry either zero or one streams. HTTP/2 connections can
+ * carry any number of streams, dynamically configured with {@code SETTINGS_MAX_CONCURRENT_STREAMS}.
+ * A connection currently carrying zero streams is an idle stream. We keep it alive because reusing
+ * an existing connection is typically faster than establishing a new one.
+ *
+ * <p>When a single logical call requires multiple streams due to redirects or authorization
+ * challenges, we prefer to use the same physical connection for all streams in the sequence. There
+ * are potential performance and behavior consequences to this preference. To support this feature,
+ * this class separates <i>allocations</i> from <i>streams</i>. An allocation is created by a call,
+ * used for one or more streams, and then released. An allocated connection won't be stolen by other
+ * calls while a redirect or authorization challenge is being handled.
+ *
+ * <p>When the maximum concurrent streams limit is reduced, some allocations will be rescinded.
+ * Attempting to create new streams on these allocations will fail.
+ *
+ * <p>Note that an allocation may be released before its stream is completed. This is intended to
+ * make bookkeeping easier for the caller: releasing the allocation as soon as the terminal stream
+ * has been found. But only complete the stream once its data stream has been exhausted.
+ */
+public interface Connection {
+  /** Returns the route used by this connection. */
+  Route route();
+
+  /**
+   * Returns the socket that this connection is using. Returns an {@linkplain
+   * javax.net.ssl.SSLSocket SSL socket} if this connection is HTTPS. If this is an HTTP/2
+   * connection the socket may be shared by multiple concurrent calls.
+   */
+  Socket socket();
+
+  /**
+   * Returns the TLS handshake used to establish this connection, or null if the connection is not
+   * HTTPS.
+   */
+  @Nullable Handshake handshake();
+
+  /**
+   * Returns the protocol negotiated by this connection, or {@link Protocol#HTTP_1_1} if no protocol
+   * has been negotiated. This method returns {@link Protocol#HTTP_1_1} even if the remote peer is
+   * using {@link Protocol#HTTP_1_0}.
+   */
+  Protocol protocol();
+}
diff --git a/okhttp/src/main/java/okhttp3/ConnectionPool.java b/okhttp/src/main/java/okhttp3/ConnectionPool.java
new file mode 100644
index 0000000000..605f275661
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/ConnectionPool.java
@@ -0,0 +1,285 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3;
+
+import java.lang.ref.Reference;
+import java.net.Socket;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Deque;
+import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.Executor;
+import java.util.concurrent.SynchronousQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
+import okhttp3.internal.Util;
+import okhttp3.internal.connection.RealConnection;
+import okhttp3.internal.connection.RouteDatabase;
+import okhttp3.internal.connection.StreamAllocation;
+import okhttp3.internal.platform.Platform;
+
+import static okhttp3.internal.Util.closeQuietly;
+
+/**
+ * Manages reuse of HTTP and HTTP/2 connections for reduced network latency. HTTP requests that
+ * share the same {@link Address} may share a {@link Connection}. This class implements the policy
+ * of which connections to keep open for future use.
+ */
+public final class ConnectionPool {
+  /**
+   * Background threads are used to cleanup expired connections. There will be at most a single
+   * thread running per connection pool. The thread pool executor permits the pool itself to be
+   * garbage collected.
+   */
+  private static final Executor executor = new ThreadPoolExecutor(0 /* corePoolSize */,
+      Integer.MAX_VALUE /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS,
+      new SynchronousQueue<Runnable>(), Util.threadFactory("OkHttp ConnectionPool", true));
+
+  /** The maximum number of idle connections for each address. */
+  private final int maxIdleConnections;
+  private final long keepAliveDurationNs;
+  private final Runnable cleanupRunnable = new Runnable() {
+    @Override public void run() {
+      while (true) {
+        long waitNanos = cleanup(System.nanoTime());
+        if (waitNanos == -1) return;
+        if (waitNanos > 0) {
+          long waitMillis = waitNanos / 1000000L;
+          waitNanos -= (waitMillis * 1000000L);
+          synchronized (ConnectionPool.this) {
+            try {
+              ConnectionPool.this.wait(waitMillis, (int) waitNanos);
+            } catch (InterruptedException ignored) {
+            }
+          }
+        }
+      }
+    }
+  };
+
+  private final Deque<RealConnection> connections = new ArrayDeque<>();
+  final RouteDatabase routeDatabase = new RouteDatabase();
+  boolean cleanupRunning;
+
+  /**
+   * Create a new connection pool with tuning parameters appropriate for a single-user application.
+   * The tuning parameters in this pool are subject to change in future OkHttp releases. Currently
+   * this pool holds up to 5 idle connections which will be evicted after 5 minutes of inactivity.
+   */
+  public ConnectionPool() {
+    this(5, 5, TimeUnit.MINUTES);
+  }
+
+  public ConnectionPool(int maxIdleConnections, long keepAliveDuration, TimeUnit timeUnit) {
+    this.maxIdleConnections = maxIdleConnections;
+    this.keepAliveDurationNs = timeUnit.toNanos(keepAliveDuration);
+
+    // Put a floor on the keep alive duration, otherwise cleanup will spin loop.
+    if (keepAliveDuration <= 0) {
+      throw new IllegalArgumentException("keepAliveDuration <= 0: " + keepAliveDuration);
+    }
+  }
+
+  /** Returns the number of idle connections in the pool. */
+  public synchronized int idleConnectionCount() {
+    int total = 0;
+    for (RealConnection connection : connections) {
+      if (connection.allocations.isEmpty()) total++;
+    }
+    return total;
+  }
+
+  /**
+   * Returns total number of connections in the pool. Note that prior to OkHttp 2.7 this included
+   * only idle connections and HTTP/2 connections. Since OkHttp 2.7 this includes all connections,
+   * both active and inactive. Use {@link #idleConnectionCount()} to count connections not currently
+   * in use.
+   */
+  public synchronized int connectionCount() {
+    return connections.size();
+  }
+
+  /**
+   * Returns a recycled connection to {@code address}, or null if no such connection exists. The
+   * route is null if the address has not yet been routed.
+   */
+  @Nullable RealConnection get(Address address, StreamAllocation streamAllocation, Route route) {
+    assert (Thread.holdsLock(this));
+    for (RealConnection connection : connections) {
+      if (connection.isEligible(address, route)) {
+        streamAllocation.acquire(connection, true);
+        return connection;
+      }
+    }
+    return null;
+  }
+
+  /**
+   * Replaces the connection held by {@code streamAllocation} with a shared connection if possible.
+   * This recovers when multiple multiplexed connections are created concurrently.
+   */
+  @Nullable Socket deduplicate(Address address, StreamAllocation streamAllocation) {
+    assert (Thread.holdsLock(this));
+    for (RealConnection connection : connections) {
+      if (connection.isEligible(address, null)
+          && connection.isMultiplexed()
+          && connection != streamAllocation.connection()) {
+        return streamAllocation.releaseAndAcquire(connection);
+      }
+    }
+    return null;
+  }
+
+  void put(RealConnection connection) {
+    assert (Thread.holdsLock(this));
+    if (!cleanupRunning) {
+      cleanupRunning = true;
+      executor.execute(cleanupRunnable);
+    }
+    connections.add(connection);
+  }
+
+  /**
+   * Notify this pool that {@code connection} has become idle. Returns true if the connection has
+   * been removed from the pool and should be closed.
+   */
+  boolean connectionBecameIdle(RealConnection connection) {
+    assert (Thread.holdsLock(this));
+    if (connection.noNewStreams || maxIdleConnections == 0) {
+      connections.remove(connection);
+      return true;
+    } else {
+      notifyAll(); // Awake the cleanup thread: we may have exceeded the idle connection limit.
+      return false;
+    }
+  }
+
+  /** Close and remove all idle connections in the pool. */
+  public void evictAll() {
+    List<RealConnection> evictedConnections = new ArrayList<>();
+    synchronized (this) {
+      for (Iterator<RealConnection> i = connections.iterator(); i.hasNext(); ) {
+        RealConnection connection = i.next();
+        if (connection.allocations.isEmpty()) {
+          connection.noNewStreams = true;
+          evictedConnections.add(connection);
+          i.remove();
+        }
+      }
+    }
+
+    for (RealConnection connection : evictedConnections) {
+      closeQuietly(connection.socket());
+    }
+  }
+
+  /**
+   * Performs maintenance on this pool, evicting the connection that has been idle the longest if
+   * either it has exceeded the keep alive limit or the idle connections limit.
+   *
+   * <p>Returns the duration in nanos to sleep until the next scheduled call to this method. Returns
+   * -1 if no further cleanups are required.
+   */
+  long cleanup(long now) {
+    int inUseConnectionCount = 0;
+    int idleConnectionCount = 0;
+    RealConnection longestIdleConnection = null;
+    long longestIdleDurationNs = Long.MIN_VALUE;
+
+    // Find either a connection to evict, or the time that the next eviction is due.
+    synchronized (this) {
+      for (Iterator<RealConnection> i = connections.iterator(); i.hasNext(); ) {
+        RealConnection connection = i.next();
+
+        // If the connection is in use, keep searching.
+        if (pruneAndGetAllocationCount(connection, now) > 0) {
+          inUseConnectionCount++;
+          continue;
+        }
+
+        idleConnectionCount++;
+
+        // If the connection is ready to be evicted, we're done.
+        long idleDurationNs = now - connection.idleAtNanos;
+        if (idleDurationNs > longestIdleDurationNs) {
+          longestIdleDurationNs = idleDurationNs;
+          longestIdleConnection = connection;
+        }
+      }
+
+      if (longestIdleDurationNs >= this.keepAliveDurationNs
+          || idleConnectionCount > this.maxIdleConnections) {
+        // We've found a connection to evict. Remove it from the list, then close it below (outside
+        // of the synchronized block).
+        connections.remove(longestIdleConnection);
+      } else if (idleConnectionCount > 0) {
+        // A connection will be ready to evict soon.
+        return keepAliveDurationNs - longestIdleDurationNs;
+      } else if (inUseConnectionCount > 0) {
+        // All connections are in use. It'll be at least the keep alive duration 'til we run again.
+        return keepAliveDurationNs;
+      } else {
+        // No connections, idle or in use.
+        cleanupRunning = false;
+        return -1;
+      }
+    }
+
+    closeQuietly(longestIdleConnection.socket());
+
+    // Cleanup again immediately.
+    return 0;
+  }
+
+  /**
+   * Prunes any leaked allocations and then returns the number of remaining live allocations on
+   * {@code connection}. Allocations are leaked if the connection is tracking them but the
+   * application code has abandoned them. Leak detection is imprecise and relies on garbage
+   * collection.
+   */
+  private int pruneAndGetAllocationCount(RealConnection connection, long now) {
+    List<Reference<StreamAllocation>> references = connection.allocations;
+    for (int i = 0; i < references.size(); ) {
+      Reference<StreamAllocation> reference = references.get(i);
+
+      if (reference.get() != null) {
+        i++;
+        continue;
+      }
+
+      // We've discovered a leaked allocation. This is an application bug.
+      StreamAllocation.StreamAllocationReference streamAllocRef =
+          (StreamAllocation.StreamAllocationReference) reference;
+      String message = "A connection to " + connection.route().address().url()
+          + " was leaked. Did you forget to close a response body?";
+      Platform.get().logCloseableLeak(message, streamAllocRef.callStackTrace);
+
+      references.remove(i);
+      connection.noNewStreams = true;
+
+      // If this was the last allocation, the connection is eligible for immediate eviction.
+      if (references.isEmpty()) {
+        connection.idleAtNanos = now - keepAliveDurationNs;
+        return 0;
+      }
+    }
+
+    return references.size();
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/ConnectionSpec.java b/okhttp/src/main/java/okhttp3/ConnectionSpec.java
new file mode 100644
index 0000000000..25b9ee328b
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/ConnectionSpec.java
@@ -0,0 +1,311 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.util.Arrays;
+import java.util.List;
+import javax.annotation.Nullable;
+import javax.net.ssl.SSLSocket;
+import okhttp3.internal.Util;
+
+import static okhttp3.internal.Util.concat;
+import static okhttp3.internal.Util.indexOf;
+import static okhttp3.internal.Util.intersect;
+import static okhttp3.internal.Util.nonEmptyIntersection;
+
+/**
+ * Specifies configuration for the socket connection that HTTP traffic travels through. For {@code
+ * https:} URLs, this includes the TLS version and cipher suites to use when negotiating a secure
+ * connection.
+ *
+ * <p>The TLS versions configured in a connection spec are only be used if they are also enabled in
+ * the SSL socket. For example, if an SSL socket does not have TLS 1.3 enabled, it will not be used
+ * even if it is present on the connection spec. The same policy also applies to cipher suites.
+ *
+ * <p>Use {@link Builder#allEnabledTlsVersions()} and {@link Builder#allEnabledCipherSuites} to
+ * defer all feature selection to the underlying SSL socket.
+ */
+public final class ConnectionSpec {
+
+  // This is nearly equal to the cipher suites supported in Chrome 51, current as of 2016-05-25.
+  // All of these suites are available on Android 7.0; earlier releases support a subset of these
+  // suites. https://github.com/square/okhttp/issues/1972
+  private static final CipherSuite[] APPROVED_CIPHER_SUITES = new CipherSuite[] {
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+      CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+      CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,
+      CipherSuite.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,
+
+      // Note that the following cipher suites are all on HTTP/2's bad cipher suites list. We'll
+      // continue to include them until better suites are commonly available. For example, none
+      // of the better cipher suites listed above shipped with Android 4.4 or Java 7.
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
+      CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
+      CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
+      CipherSuite.TLS_RSA_WITH_AES_128_GCM_SHA256,
+      CipherSuite.TLS_RSA_WITH_AES_256_GCM_SHA384,
+      CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA,
+      CipherSuite.TLS_RSA_WITH_AES_256_CBC_SHA,
+      CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
+  };
+
+  /** A modern TLS connection with extensions like SNI and ALPN available. */
+  public static final ConnectionSpec MODERN_TLS = new Builder(true)
+      .cipherSuites(APPROVED_CIPHER_SUITES)
+      .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0)
+      .supportsTlsExtensions(true)
+      .build();
+
+  /** A backwards-compatible fallback connection for interop with obsolete servers. */
+  public static final ConnectionSpec COMPATIBLE_TLS = new Builder(MODERN_TLS)
+      .tlsVersions(TlsVersion.TLS_1_0)
+      .supportsTlsExtensions(true)
+      .build();
+
+  /** Unencrypted, unauthenticated connections for {@code http:} URLs. */
+  public static final ConnectionSpec CLEARTEXT = new Builder(false).build();
+
+  final boolean tls;
+  final boolean supportsTlsExtensions;
+  final @Nullable String[] cipherSuites;
+  final @Nullable String[] tlsVersions;
+
+  ConnectionSpec(Builder builder) {
+    this.tls = builder.tls;
+    this.cipherSuites = builder.cipherSuites;
+    this.tlsVersions = builder.tlsVersions;
+    this.supportsTlsExtensions = builder.supportsTlsExtensions;
+  }
+
+  public boolean isTls() {
+    return tls;
+  }
+
+  /**
+   * Returns the cipher suites to use for a connection. Returns null if all of the SSL socket's
+   * enabled cipher suites should be used.
+   */
+  public @Nullable List<CipherSuite> cipherSuites() {
+    return cipherSuites != null ? CipherSuite.forJavaNames(cipherSuites) : null;
+  }
+
+  /**
+   * Returns the TLS versions to use when negotiating a connection. Returns null if all of the SSL
+   * socket's enabled TLS versions should be used.
+   */
+  public @Nullable List<TlsVersion> tlsVersions() {
+    return tlsVersions != null ? TlsVersion.forJavaNames(tlsVersions) : null;
+  }
+
+  public boolean supportsTlsExtensions() {
+    return supportsTlsExtensions;
+  }
+
+  /** Applies this spec to {@code sslSocket}. */
+  void apply(SSLSocket sslSocket, boolean isFallback) {
+    ConnectionSpec specToApply = supportedSpec(sslSocket, isFallback);
+
+    if (specToApply.tlsVersions != null) {
+      sslSocket.setEnabledProtocols(specToApply.tlsVersions);
+    }
+    if (specToApply.cipherSuites != null) {
+      sslSocket.setEnabledCipherSuites(specToApply.cipherSuites);
+    }
+  }
+
+  /**
+   * Returns a copy of this that omits cipher suites and TLS versions not enabled by {@code
+   * sslSocket}.
+   */
+  private ConnectionSpec supportedSpec(SSLSocket sslSocket, boolean isFallback) {
+    String[] cipherSuitesIntersection = cipherSuites != null
+        ? intersect(CipherSuite.ORDER_BY_NAME, sslSocket.getEnabledCipherSuites(), cipherSuites)
+        : sslSocket.getEnabledCipherSuites();
+    String[] tlsVersionsIntersection = tlsVersions != null
+        ? intersect(Util.NATURAL_ORDER, sslSocket.getEnabledProtocols(), tlsVersions)
+        : sslSocket.getEnabledProtocols();
+
+    // In accordance with https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00
+    // the SCSV cipher is added to signal that a protocol fallback has taken place.
+    String[] supportedCipherSuites = sslSocket.getSupportedCipherSuites();
+    int indexOfFallbackScsv = indexOf(
+        CipherSuite.ORDER_BY_NAME, supportedCipherSuites, "TLS_FALLBACK_SCSV");
+    if (isFallback && indexOfFallbackScsv != -1) {
+      cipherSuitesIntersection = concat(
+          cipherSuitesIntersection, supportedCipherSuites[indexOfFallbackScsv]);
+    }
+
+    return new Builder(this)
+        .cipherSuites(cipherSuitesIntersection)
+        .tlsVersions(tlsVersionsIntersection)
+        .build();
+  }
+
+  /**
+   * Returns {@code true} if the socket, as currently configured, supports this connection spec. In
+   * order for a socket to be compatible the enabled cipher suites and protocols must intersect.
+   *
+   * <p>For cipher suites, at least one of the {@link #cipherSuites() required cipher suites} must
+   * match the socket's enabled cipher suites. If there are no required cipher suites the socket
+   * must have at least one cipher suite enabled.
+   *
+   * <p>For protocols, at least one of the {@link #tlsVersions() required protocols} must match the
+   * socket's enabled protocols.
+   */
+  public boolean isCompatible(SSLSocket socket) {
+    if (!tls) {
+      return false;
+    }
+
+    if (tlsVersions != null && !nonEmptyIntersection(
+        Util.NATURAL_ORDER, tlsVersions, socket.getEnabledProtocols())) {
+      return false;
+    }
+
+    if (cipherSuites != null && !nonEmptyIntersection(
+        CipherSuite.ORDER_BY_NAME, cipherSuites, socket.getEnabledCipherSuites())) {
+      return false;
+    }
+
+    return true;
+  }
+
+  @Override public boolean equals(@Nullable Object other) {
+    if (!(other instanceof ConnectionSpec)) return false;
+    if (other == this) return true;
+
+    ConnectionSpec that = (ConnectionSpec) other;
+    if (this.tls != that.tls) return false;
+
+    if (tls) {
+      if (!Arrays.equals(this.cipherSuites, that.cipherSuites)) return false;
+      if (!Arrays.equals(this.tlsVersions, that.tlsVersions)) return false;
+      if (this.supportsTlsExtensions != that.supportsTlsExtensions) return false;
+    }
+
+    return true;
+  }
+
+  @Override public int hashCode() {
+    int result = 17;
+    if (tls) {
+      result = 31 * result + Arrays.hashCode(cipherSuites);
+      result = 31 * result + Arrays.hashCode(tlsVersions);
+      result = 31 * result + (supportsTlsExtensions ? 0 : 1);
+    }
+    return result;
+  }
+
+  @Override public String toString() {
+    if (!tls) {
+      return "ConnectionSpec()";
+    }
+
+    String cipherSuitesString = cipherSuites != null ? cipherSuites().toString() : "[all enabled]";
+    String tlsVersionsString = tlsVersions != null ? tlsVersions().toString() : "[all enabled]";
+    return "ConnectionSpec("
+        + "cipherSuites=" + cipherSuitesString
+        + ", tlsVersions=" + tlsVersionsString
+        + ", supportsTlsExtensions=" + supportsTlsExtensions
+        + ")";
+  }
+
+  public static final class Builder {
+    boolean tls;
+    @Nullable String[] cipherSuites;
+    @Nullable String[] tlsVersions;
+    boolean supportsTlsExtensions;
+
+    Builder(boolean tls) {
+      this.tls = tls;
+    }
+
+    public Builder(ConnectionSpec connectionSpec) {
+      this.tls = connectionSpec.tls;
+      this.cipherSuites = connectionSpec.cipherSuites;
+      this.tlsVersions = connectionSpec.tlsVersions;
+      this.supportsTlsExtensions = connectionSpec.supportsTlsExtensions;
+    }
+
+    public Builder allEnabledCipherSuites() {
+      if (!tls) throw new IllegalStateException("no cipher suites for cleartext connections");
+      this.cipherSuites = null;
+      return this;
+    }
+
+    public Builder cipherSuites(CipherSuite... cipherSuites) {
+      if (!tls) throw new IllegalStateException("no cipher suites for cleartext connections");
+
+      String[] strings = new String[cipherSuites.length];
+      for (int i = 0; i < cipherSuites.length; i++) {
+        strings[i] = cipherSuites[i].javaName;
+      }
+      return cipherSuites(strings);
+    }
+
+    public Builder cipherSuites(String... cipherSuites) {
+      if (!tls) throw new IllegalStateException("no cipher suites for cleartext connections");
+
+      if (cipherSuites.length == 0) {
+        throw new IllegalArgumentException("At least one cipher suite is required");
+      }
+
+      this.cipherSuites = cipherSuites.clone(); // Defensive copy.
+      return this;
+    }
+
+    public Builder allEnabledTlsVersions() {
+      if (!tls) throw new IllegalStateException("no TLS versions for cleartext connections");
+      this.tlsVersions = null;
+      return this;
+    }
+
+    public Builder tlsVersions(TlsVersion... tlsVersions) {
+      if (!tls) throw new IllegalStateException("no TLS versions for cleartext connections");
+
+      String[] strings = new String[tlsVersions.length];
+      for (int i = 0; i < tlsVersions.length; i++) {
+        strings[i] = tlsVersions[i].javaName;
+      }
+
+      return tlsVersions(strings);
+    }
+
+    public Builder tlsVersions(String... tlsVersions) {
+      if (!tls) throw new IllegalStateException("no TLS versions for cleartext connections");
+
+      if (tlsVersions.length == 0) {
+        throw new IllegalArgumentException("At least one TLS version is required");
+      }
+
+      this.tlsVersions = tlsVersions.clone(); // Defensive copy.
+      return this;
+    }
+
+    public Builder supportsTlsExtensions(boolean supportsTlsExtensions) {
+      if (!tls) throw new IllegalStateException("no TLS extensions for cleartext connections");
+      this.supportsTlsExtensions = supportsTlsExtensions;
+      return this;
+    }
+
+    public ConnectionSpec build() {
+      return new ConnectionSpec(this);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Cookie.java b/okhttp/src/main/java/okhttp3/Cookie.java
new file mode 100644
index 0000000000..fbfa99c26d
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Cookie.java
@@ -0,0 +1,612 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.Collections;
+import java.util.Date;
+import java.util.GregorianCalendar;
+import java.util.List;
+import java.util.Locale;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import javax.annotation.Nullable;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.HttpDate;
+import okhttp3.internal.publicsuffix.PublicSuffixDatabase;
+
+import static okhttp3.internal.Util.UTC;
+import static okhttp3.internal.Util.canonicalizeHost;
+import static okhttp3.internal.Util.delimiterOffset;
+import static okhttp3.internal.Util.indexOfControlOrNonAscii;
+import static okhttp3.internal.Util.trimSubstring;
+import static okhttp3.internal.Util.verifyAsIpAddress;
+
+/**
+ * An <a href="http://tools.ietf.org/html/rfc6265">RFC 6265</a> Cookie.
+ *
+ * <p>This class doesn't support additional attributes on cookies, like <a
+ * href="https://code.google.com/p/chromium/issues/detail?id=232693">Chromium's Priority=HIGH
+ * extension</a>.
+ */
+public final class Cookie {
+  private static final Pattern YEAR_PATTERN
+      = Pattern.compile("(\\d{2,4})[^\\d]*");
+  private static final Pattern MONTH_PATTERN
+      = Pattern.compile("(?i)(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec).*");
+  private static final Pattern DAY_OF_MONTH_PATTERN
+      = Pattern.compile("(\\d{1,2})[^\\d]*");
+  private static final Pattern TIME_PATTERN
+      = Pattern.compile("(\\d{1,2}):(\\d{1,2}):(\\d{1,2})[^\\d]*");
+
+  private final String name;
+  private final String value;
+  private final long expiresAt;
+  private final String domain;
+  private final String path;
+  private final boolean secure;
+  private final boolean httpOnly;
+
+  private final boolean persistent; // True if 'expires' or 'max-age' is present.
+  private final boolean hostOnly; // True unless 'domain' is present.
+
+  private Cookie(String name, String value, long expiresAt, String domain, String path,
+      boolean secure, boolean httpOnly, boolean hostOnly, boolean persistent) {
+    this.name = name;
+    this.value = value;
+    this.expiresAt = expiresAt;
+    this.domain = domain;
+    this.path = path;
+    this.secure = secure;
+    this.httpOnly = httpOnly;
+    this.hostOnly = hostOnly;
+    this.persistent = persistent;
+  }
+
+  Cookie(Builder builder) {
+    if (builder.name == null) throw new NullPointerException("builder.name == null");
+    if (builder.value == null) throw new NullPointerException("builder.value == null");
+    if (builder.domain == null) throw new NullPointerException("builder.domain == null");
+
+    this.name = builder.name;
+    this.value = builder.value;
+    this.expiresAt = builder.expiresAt;
+    this.domain = builder.domain;
+    this.path = builder.path;
+    this.secure = builder.secure;
+    this.httpOnly = builder.httpOnly;
+    this.persistent = builder.persistent;
+    this.hostOnly = builder.hostOnly;
+  }
+
+  /** Returns a non-empty string with this cookie's name. */
+  public String name() {
+    return name;
+  }
+
+  /** Returns a possibly-empty string with this cookie's value. */
+  public String value() {
+    return value;
+  }
+
+  /** Returns true if this cookie does not expire at the end of the current session. */
+  public boolean persistent() {
+    return persistent;
+  }
+
+  /**
+   * Returns the time that this cookie expires, in the same format as {@link
+   * System#currentTimeMillis()}. This is December 31, 9999 if the cookie is {@linkplain
+   * #persistent() not persistent}, in which case it will expire at the end of the current session.
+   *
+   * <p>This may return a value less than the current time, in which case the cookie is already
+   * expired. Webservers may return expired cookies as a mechanism to delete previously set cookies
+   * that may or may not themselves be expired.
+   */
+  public long expiresAt() {
+    return expiresAt;
+  }
+
+  /**
+   * Returns true if this cookie's domain should be interpreted as a single host name, or false if
+   * it should be interpreted as a pattern. This flag will be false if its {@code Set-Cookie} header
+   * included a {@code domain} attribute.
+   *
+   * <p>For example, suppose the cookie's domain is {@code example.com}. If this flag is true it
+   * matches <strong>only</strong> {@code example.com}. If this flag is false it matches {@code
+   * example.com} and all subdomains including {@code api.example.com}, {@code www.example.com}, and
+   * {@code beta.api.example.com}.
+   */
+  public boolean hostOnly() {
+    return hostOnly;
+  }
+
+  /**
+   * Returns the cookie's domain. If {@link #hostOnly()} returns true this is the only domain that
+   * matches this cookie; otherwise it matches this domain and all subdomains.
+   */
+  public String domain() {
+    return domain;
+  }
+
+  /**
+   * Returns this cookie's path. This cookie matches URLs prefixed with path segments that match
+   * this path's segments. For example, if this path is {@code /foo} this cookie matches requests to
+   * {@code /foo} and {@code /foo/bar}, but not {@code /} or {@code /football}.
+   */
+  public String path() {
+    return path;
+  }
+
+  /**
+   * Returns true if this cookie should be limited to only HTTP APIs. In web browsers this prevents
+   * the cookie from being accessible to scripts.
+   */
+  public boolean httpOnly() {
+    return httpOnly;
+  }
+
+  /** Returns true if this cookie should be limited to only HTTPS requests. */
+  public boolean secure() {
+    return secure;
+  }
+
+  /**
+   * Returns true if this cookie should be included on a request to {@code url}. In addition to this
+   * check callers should also confirm that this cookie has not expired.
+   */
+  public boolean matches(HttpUrl url) {
+    boolean domainMatch = hostOnly
+        ? url.host().equals(domain)
+        : domainMatch(url.host(), domain);
+    if (!domainMatch) return false;
+
+    if (!pathMatch(url, path)) return false;
+
+    if (secure && !url.isHttps()) return false;
+
+    return true;
+  }
+
+  private static boolean domainMatch(String urlHost, String domain) {
+    if (urlHost.equals(domain)) {
+      return true; // As in 'example.com' matching 'example.com'.
+    }
+
+    if (urlHost.endsWith(domain)
+        && urlHost.charAt(urlHost.length() - domain.length() - 1) == '.'
+        && !verifyAsIpAddress(urlHost)) {
+      return true; // As in 'example.com' matching 'www.example.com'.
+    }
+
+    return false;
+  }
+
+  private static boolean pathMatch(HttpUrl url, String path) {
+    String urlPath = url.encodedPath();
+
+    if (urlPath.equals(path)) {
+      return true; // As in '/foo' matching '/foo'.
+    }
+
+    if (urlPath.startsWith(path)) {
+      if (path.endsWith("/")) return true; // As in '/' matching '/foo'.
+      if (urlPath.charAt(path.length()) == '/') return true; // As in '/foo' matching '/foo/bar'.
+    }
+
+    return false;
+  }
+
+  /**
+   * Attempt to parse a {@code Set-Cookie} HTTP header value {@code setCookie} as a cookie. Returns
+   * null if {@code setCookie} is not a well-formed cookie.
+   */
+  public static @Nullable Cookie parse(HttpUrl url, String setCookie) {
+    return parse(System.currentTimeMillis(), url, setCookie);
+  }
+
+  static @Nullable Cookie parse(long currentTimeMillis, HttpUrl url, String setCookie) {
+    int pos = 0;
+    int limit = setCookie.length();
+    int cookiePairEnd = delimiterOffset(setCookie, pos, limit, ';');
+
+    int pairEqualsSign = delimiterOffset(setCookie, pos, cookiePairEnd, '=');
+    if (pairEqualsSign == cookiePairEnd) return null;
+
+    String cookieName = trimSubstring(setCookie, pos, pairEqualsSign);
+    if (cookieName.isEmpty() || indexOfControlOrNonAscii(cookieName) != -1) return null;
+
+    String cookieValue = trimSubstring(setCookie, pairEqualsSign + 1, cookiePairEnd);
+    if (indexOfControlOrNonAscii(cookieValue) != -1) return null;
+
+    long expiresAt = HttpDate.MAX_DATE;
+    long deltaSeconds = -1L;
+    String domain = null;
+    String path = null;
+    boolean secureOnly = false;
+    boolean httpOnly = false;
+    boolean hostOnly = true;
+    boolean persistent = false;
+
+    pos = cookiePairEnd + 1;
+    while (pos < limit) {
+      int attributePairEnd = delimiterOffset(setCookie, pos, limit, ';');
+
+      int attributeEqualsSign = delimiterOffset(setCookie, pos, attributePairEnd, '=');
+      String attributeName = trimSubstring(setCookie, pos, attributeEqualsSign);
+      String attributeValue = attributeEqualsSign < attributePairEnd
+          ? trimSubstring(setCookie, attributeEqualsSign + 1, attributePairEnd)
+          : "";
+
+      if (attributeName.equalsIgnoreCase("expires")) {
+        try {
+          expiresAt = parseExpires(attributeValue, 0, attributeValue.length());
+          persistent = true;
+        } catch (IllegalArgumentException e) {
+          // Ignore this attribute, it isn't recognizable as a date.
+        }
+      } else if (attributeName.equalsIgnoreCase("max-age")) {
+        try {
+          deltaSeconds = parseMaxAge(attributeValue);
+          persistent = true;
+        } catch (NumberFormatException e) {
+          // Ignore this attribute, it isn't recognizable as a max age.
+        }
+      } else if (attributeName.equalsIgnoreCase("domain")) {
+        try {
+          domain = parseDomain(attributeValue);
+          hostOnly = false;
+        } catch (IllegalArgumentException e) {
+          // Ignore this attribute, it isn't recognizable as a domain.
+        }
+      } else if (attributeName.equalsIgnoreCase("path")) {
+        path = attributeValue;
+      } else if (attributeName.equalsIgnoreCase("secure")) {
+        secureOnly = true;
+      } else if (attributeName.equalsIgnoreCase("httponly")) {
+        httpOnly = true;
+      }
+
+      pos = attributePairEnd + 1;
+    }
+
+    // If 'Max-Age' is present, it takes precedence over 'Expires', regardless of the order the two
+    // attributes are declared in the cookie string.
+    if (deltaSeconds == Long.MIN_VALUE) {
+      expiresAt = Long.MIN_VALUE;
+    } else if (deltaSeconds != -1L) {
+      long deltaMilliseconds = deltaSeconds <= (Long.MAX_VALUE / 1000)
+          ? deltaSeconds * 1000
+          : Long.MAX_VALUE;
+      expiresAt = currentTimeMillis + deltaMilliseconds;
+      if (expiresAt < currentTimeMillis || expiresAt > HttpDate.MAX_DATE) {
+        expiresAt = HttpDate.MAX_DATE; // Handle overflow & limit the date range.
+      }
+    }
+
+    // If the domain is present, it must domain match. Otherwise we have a host-only cookie.
+    String urlHost = url.host();
+    if (domain == null) {
+      domain = urlHost;
+    } else if (!domainMatch(urlHost, domain)) {
+      return null; // No domain match? This is either incompetence or malice!
+    }
+
+    // If the domain is a suffix of the url host, it must not be a public suffix.
+    if (urlHost.length() != domain.length()
+        && PublicSuffixDatabase.get().getEffectiveTldPlusOne(domain) == null) {
+      return null;
+    }
+
+    // If the path is absent or didn't start with '/', use the default path. It's a string like
+    // '/foo/bar' for a URL like 'http://example.com/foo/bar/baz'. It always starts with '/'.
+    if (path == null || !path.startsWith("/")) {
+      String encodedPath = url.encodedPath();
+      int lastSlash = encodedPath.lastIndexOf('/');
+      path = lastSlash != 0 ? encodedPath.substring(0, lastSlash) : "/";
+    }
+
+    return new Cookie(cookieName, cookieValue, expiresAt, domain, path, secureOnly, httpOnly,
+        hostOnly, persistent);
+  }
+
+  /** Parse a date as specified in RFC 6265, section 5.1.1. */
+  private static long parseExpires(String s, int pos, int limit) {
+    pos = dateCharacterOffset(s, pos, limit, false);
+
+    int hour = -1;
+    int minute = -1;
+    int second = -1;
+    int dayOfMonth = -1;
+    int month = -1;
+    int year = -1;
+    Matcher matcher = TIME_PATTERN.matcher(s);
+
+    while (pos < limit) {
+      int end = dateCharacterOffset(s, pos + 1, limit, true);
+      matcher.region(pos, end);
+
+      if (hour == -1 && matcher.usePattern(TIME_PATTERN).matches()) {
+        hour = Integer.parseInt(matcher.group(1));
+        minute = Integer.parseInt(matcher.group(2));
+        second = Integer.parseInt(matcher.group(3));
+      } else if (dayOfMonth == -1 && matcher.usePattern(DAY_OF_MONTH_PATTERN).matches()) {
+        dayOfMonth = Integer.parseInt(matcher.group(1));
+      } else if (month == -1 && matcher.usePattern(MONTH_PATTERN).matches()) {
+        String monthString = matcher.group(1).toLowerCase(Locale.US);
+        month = MONTH_PATTERN.pattern().indexOf(monthString) / 4; // Sneaky! jan=1, dec=12.
+      } else if (year == -1 && matcher.usePattern(YEAR_PATTERN).matches()) {
+        year = Integer.parseInt(matcher.group(1));
+      }
+
+      pos = dateCharacterOffset(s, end + 1, limit, false);
+    }
+
+    // Convert two-digit years into four-digit years. 99 becomes 1999, 15 becomes 2015.
+    if (year >= 70 && year <= 99) year += 1900;
+    if (year >= 0 && year <= 69) year += 2000;
+
+    // If any partial is omitted or out of range, return -1. The date is impossible. Note that leap
+    // seconds are not supported by this syntax.
+    if (year < 1601) throw new IllegalArgumentException();
+    if (month == -1) throw new IllegalArgumentException();
+    if (dayOfMonth < 1 || dayOfMonth > 31) throw new IllegalArgumentException();
+    if (hour < 0 || hour > 23) throw new IllegalArgumentException();
+    if (minute < 0 || minute > 59) throw new IllegalArgumentException();
+    if (second < 0 || second > 59) throw new IllegalArgumentException();
+
+    Calendar calendar = new GregorianCalendar(UTC);
+    calendar.setLenient(false);
+    calendar.set(Calendar.YEAR, year);
+    calendar.set(Calendar.MONTH, month - 1);
+    calendar.set(Calendar.DAY_OF_MONTH, dayOfMonth);
+    calendar.set(Calendar.HOUR_OF_DAY, hour);
+    calendar.set(Calendar.MINUTE, minute);
+    calendar.set(Calendar.SECOND, second);
+    calendar.set(Calendar.MILLISECOND, 0);
+    return calendar.getTimeInMillis();
+  }
+
+  /**
+   * Returns the index of the next date character in {@code input}, or if {@code invert} the index
+   * of the next non-date character in {@code input}.
+   */
+  private static int dateCharacterOffset(String input, int pos, int limit, boolean invert) {
+    for (int i = pos; i < limit; i++) {
+      int c = input.charAt(i);
+      boolean dateCharacter = (c < ' ' && c != '\t') || (c >= '\u007f')
+          || (c >= '0' && c <= '9')
+          || (c >= 'a' && c <= 'z')
+          || (c >= 'A' && c <= 'Z')
+          || (c == ':');
+      if (dateCharacter == !invert) return i;
+    }
+    return limit;
+  }
+
+  /**
+   * Returns the positive value if {@code attributeValue} is positive, or {@link Long#MIN_VALUE} if
+   * it is either 0 or negative. If the value is positive but out of range, this returns {@link
+   * Long#MAX_VALUE}.
+   *
+   * @throws NumberFormatException if {@code s} is not an integer of any precision.
+   */
+  private static long parseMaxAge(String s) {
+    try {
+      long parsed = Long.parseLong(s);
+      return parsed <= 0L ? Long.MIN_VALUE : parsed;
+    } catch (NumberFormatException e) {
+      // Check if the value is an integer (positive or negative) that's too big for a long.
+      if (s.matches("-?\\d+")) {
+        return s.startsWith("-") ? Long.MIN_VALUE : Long.MAX_VALUE;
+      }
+      throw e;
+    }
+  }
+
+  /**
+   * Returns a domain string like {@code example.com} for an input domain like {@code EXAMPLE.COM}
+   * or {@code .example.com}.
+   */
+  private static String parseDomain(String s) {
+    if (s.endsWith(".")) {
+      throw new IllegalArgumentException();
+    }
+    if (s.startsWith(".")) {
+      s = s.substring(1);
+    }
+    String canonicalDomain = canonicalizeHost(s);
+    if (canonicalDomain == null) {
+      throw new IllegalArgumentException();
+    }
+    return canonicalDomain;
+  }
+
+  /** Returns all of the cookies from a set of HTTP response headers. */
+  public static List<Cookie> parseAll(HttpUrl url, Headers headers) {
+    List<String> cookieStrings = headers.values("Set-Cookie");
+    List<Cookie> cookies = null;
+
+    for (int i = 0, size = cookieStrings.size(); i < size; i++) {
+      Cookie cookie = Cookie.parse(url, cookieStrings.get(i));
+      if (cookie == null) continue;
+      if (cookies == null) cookies = new ArrayList<>();
+      cookies.add(cookie);
+    }
+
+    return cookies != null
+        ? Collections.unmodifiableList(cookies)
+        : Collections.<Cookie>emptyList();
+  }
+
+  /**
+   * Builds a cookie. The {@linkplain #name() name}, {@linkplain #value() value}, and {@linkplain
+   * #domain() domain} values must all be set before calling {@link #build}.
+   */
+  public static final class Builder {
+    String name;
+    String value;
+    long expiresAt = HttpDate.MAX_DATE;
+    String domain;
+    String path = "/";
+    boolean secure;
+    boolean httpOnly;
+    boolean persistent;
+    boolean hostOnly;
+
+    public Builder name(String name) {
+      if (name == null) throw new NullPointerException("name == null");
+      if (!name.trim().equals(name)) throw new IllegalArgumentException("name is not trimmed");
+      this.name = name;
+      return this;
+    }
+
+    public Builder value(String value) {
+      if (value == null) throw new NullPointerException("value == null");
+      if (!value.trim().equals(value)) throw new IllegalArgumentException("value is not trimmed");
+      this.value = value;
+      return this;
+    }
+
+    public Builder expiresAt(long expiresAt) {
+      if (expiresAt <= 0) expiresAt = Long.MIN_VALUE;
+      if (expiresAt > HttpDate.MAX_DATE) expiresAt = HttpDate.MAX_DATE;
+      this.expiresAt = expiresAt;
+      this.persistent = true;
+      return this;
+    }
+
+    /**
+     * Set the domain pattern for this cookie. The cookie will match {@code domain} and all of its
+     * subdomains.
+     */
+    public Builder domain(String domain) {
+      return domain(domain, false);
+    }
+
+    /**
+     * Set the host-only domain for this cookie. The cookie will match {@code domain} but none of
+     * its subdomains.
+     */
+    public Builder hostOnlyDomain(String domain) {
+      return domain(domain, true);
+    }
+
+    private Builder domain(String domain, boolean hostOnly) {
+      if (domain == null) throw new NullPointerException("domain == null");
+      String canonicalDomain = Util.canonicalizeHost(domain);
+      if (canonicalDomain == null) {
+        throw new IllegalArgumentException("unexpected domain: " + domain);
+      }
+      this.domain = canonicalDomain;
+      this.hostOnly = hostOnly;
+      return this;
+    }
+
+    public Builder path(String path) {
+      if (!path.startsWith("/")) throw new IllegalArgumentException("path must start with '/'");
+      this.path = path;
+      return this;
+    }
+
+    public Builder secure() {
+      this.secure = true;
+      return this;
+    }
+
+    public Builder httpOnly() {
+      this.httpOnly = true;
+      return this;
+    }
+
+    public Cookie build() {
+      return new Cookie(this);
+    }
+  }
+
+  @Override public String toString() {
+    return toString(false);
+  }
+
+  /**
+   * @param forObsoleteRfc2965 true to include a leading {@code .} on the domain pattern. This is
+   *     necessary for {@code example.com} to match {@code www.example.com} under RFC 2965. This
+   *     extra dot is ignored by more recent specifications.
+   */
+  String toString(boolean forObsoleteRfc2965) {
+    StringBuilder result = new StringBuilder();
+    result.append(name);
+    result.append('=');
+    result.append(value);
+
+    if (persistent) {
+      if (expiresAt == Long.MIN_VALUE) {
+        result.append("; max-age=0");
+      } else {
+        result.append("; expires=").append(HttpDate.format(new Date(expiresAt)));
+      }
+    }
+
+    if (!hostOnly) {
+      result.append("; domain=");
+      if (forObsoleteRfc2965) {
+        result.append(".");
+      }
+      result.append(domain);
+    }
+
+    result.append("; path=").append(path);
+
+    if (secure) {
+      result.append("; secure");
+    }
+
+    if (httpOnly) {
+      result.append("; httponly");
+    }
+
+    return result.toString();
+  }
+
+  @Override public boolean equals(@Nullable Object other) {
+    if (!(other instanceof Cookie)) return false;
+    Cookie that = (Cookie) other;
+    return that.name.equals(name)
+        && that.value.equals(value)
+        && that.domain.equals(domain)
+        && that.path.equals(path)
+        && that.expiresAt == expiresAt
+        && that.secure == secure
+        && that.httpOnly == httpOnly
+        && that.persistent == persistent
+        && that.hostOnly == hostOnly;
+  }
+
+  @Override public int hashCode() {
+    int hash = 17;
+    hash = 31 * hash + name.hashCode();
+    hash = 31 * hash + value.hashCode();
+    hash = 31 * hash + domain.hashCode();
+    hash = 31 * hash + path.hashCode();
+    hash = 31 * hash + (int) (expiresAt ^ (expiresAt >>> 32));
+    hash = 31 * hash + (secure ? 0 : 1);
+    hash = 31 * hash + (httpOnly ? 0 : 1);
+    hash = 31 * hash + (persistent ? 0 : 1);
+    hash = 31 * hash + (hostOnly ? 0 : 1);
+    return hash;
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/CookieJar.java b/okhttp/src/main/java/okhttp3/CookieJar.java
new file mode 100644
index 0000000000..bdb3cd552e
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/CookieJar.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * Provides <strong>policy</strong> and <strong>persistence</strong> for HTTP cookies.
+ *
+ * <p>As policy, implementations of this interface are responsible for selecting which cookies to
+ * accept and which to reject. A reasonable policy is to reject all cookies, though that may
+ * interfere with session-based authentication schemes that require cookies.
+ *
+ * <p>As persistence, implementations of this interface must also provide storage of cookies. Simple
+ * implementations may store cookies in memory; sophisticated ones may use the file system or
+ * database to hold accepted cookies. The <a
+ * href="https://tools.ietf.org/html/rfc6265#section-5.3">cookie storage model</a> specifies
+ * policies for updating and expiring cookies.
+ */
+public interface CookieJar {
+  /** A cookie jar that never accepts any cookies. */
+  CookieJar NO_COOKIES = new CookieJar() {
+    @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {
+    }
+
+    @Override public List<Cookie> loadForRequest(HttpUrl url) {
+      return Collections.emptyList();
+    }
+  };
+
+  /**
+   * Saves {@code cookies} from an HTTP response to this store according to this jar's policy.
+   *
+   * <p>Note that this method may be called a second time for a single HTTP response if the response
+   * includes a trailer. For this obscure HTTP feature, {@code cookies} contains only the trailer's
+   * cookies.
+   */
+  void saveFromResponse(HttpUrl url, List<Cookie> cookies);
+
+  /**
+   * Load cookies from the jar for an HTTP request to {@code url}. This method returns a possibly
+   * empty list of cookies for the network request.
+   *
+   * <p>Simple implementations will return the accepted cookies that have not yet expired and that
+   * {@linkplain Cookie#matches match} {@code url}.
+   */
+  List<Cookie> loadForRequest(HttpUrl url);
+}
diff --git a/okhttp/src/main/java/okhttp3/Credentials.java b/okhttp/src/main/java/okhttp3/Credentials.java
new file mode 100644
index 0000000000..a27ecae001
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Credentials.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.nio.charset.Charset;
+import okio.ByteString;
+
+import static okhttp3.internal.Util.ISO_8859_1;
+
+/** Factory for HTTP authorization credentials. */
+public final class Credentials {
+  private Credentials() {
+  }
+
+  /** Returns an auth credential for the Basic scheme. */
+  public static String basic(String userName, String password) {
+    return basic(userName, password, ISO_8859_1);
+  }
+
+  public static String basic(String userName, String password, Charset charset) {
+    String usernameAndPassword = userName + ":" + password;
+    String encoded = ByteString.encodeString(usernameAndPassword, charset).base64();
+    return "Basic " + encoded;
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Dispatcher.java b/okhttp/src/main/java/okhttp3/Dispatcher.java
new file mode 100644
index 0000000000..43f5aa48e7
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Dispatcher.java
@@ -0,0 +1,236 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Deque;
+import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.SynchronousQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
+import okhttp3.RealCall.AsyncCall;
+import okhttp3.internal.Util;
+
+/**
+ * Policy on when async requests are executed.
+ *
+ * <p>Each dispatcher uses an {@link ExecutorService} to run calls internally. If you supply your
+ * own executor, it should be able to run {@linkplain #getMaxRequests the configured maximum} number
+ * of calls concurrently.
+ */
+public final class Dispatcher {
+  private int maxRequests = 64;
+  private int maxRequestsPerHost = 5;
+  private @Nullable Runnable idleCallback;
+
+  /** Executes calls. Created lazily. */
+  private @Nullable ExecutorService executorService;
+
+  /** Ready async calls in the order they'll be run. */
+  private final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<>();
+
+  /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */
+  private final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();
+
+  /** Running synchronous calls. Includes canceled calls that haven't finished yet. */
+  private final Deque<RealCall> runningSyncCalls = new ArrayDeque<>();
+
+  public Dispatcher(ExecutorService executorService) {
+    this.executorService = executorService;
+  }
+
+  public Dispatcher() {
+  }
+
+  public synchronized ExecutorService executorService() {
+    if (executorService == null) {
+      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,
+          new SynchronousQueue<Runnable>(), Util.threadFactory("OkHttp Dispatcher", false));
+    }
+    return executorService;
+  }
+
+  /**
+   * Set the maximum number of requests to execute concurrently. Above this requests queue in
+   * memory, waiting for the running calls to complete.
+   *
+   * <p>If more than {@code maxRequests} requests are in flight when this is invoked, those requests
+   * will remain in flight.
+   */
+  public synchronized void setMaxRequests(int maxRequests) {
+    if (maxRequests < 1) {
+      throw new IllegalArgumentException("max < 1: " + maxRequests);
+    }
+    this.maxRequests = maxRequests;
+    promoteCalls();
+  }
+
+  public synchronized int getMaxRequests() {
+    return maxRequests;
+  }
+
+  /**
+   * Set the maximum number of requests for each host to execute concurrently. This limits requests
+   * by the URL's host name. Note that concurrent requests to a single IP address may still exceed
+   * this limit: multiple hostnames may share an IP address or be routed through the same HTTP
+   * proxy.
+   *
+   * <p>If more than {@code maxRequestsPerHost} requests are in flight when this is invoked, those
+   * requests will remain in flight.
+   */
+  public synchronized void setMaxRequestsPerHost(int maxRequestsPerHost) {
+    if (maxRequestsPerHost < 1) {
+      throw new IllegalArgumentException("max < 1: " + maxRequestsPerHost);
+    }
+    this.maxRequestsPerHost = maxRequestsPerHost;
+    promoteCalls();
+  }
+
+  public synchronized int getMaxRequestsPerHost() {
+    return maxRequestsPerHost;
+  }
+
+  /**
+   * Set a callback to be invoked each time the dispatcher becomes idle (when the number of running
+   * calls returns to zero).
+   *
+   * <p>Note: The time at which a {@linkplain Call call} is considered idle is different depending
+   * on whether it was run {@linkplain Call#enqueue(Callback) asynchronously} or
+   * {@linkplain Call#execute() synchronously}. Asynchronous calls become idle after the
+   * {@link Callback#onResponse onResponse} or {@link Callback#onFailure onFailure} callback has
+   * returned. Synchronous calls become idle once {@link Call#execute() execute()} returns. This
+   * means that if you are doing synchronous calls the network layer will not truly be idle until
+   * every returned {@link Response} has been closed.
+   */
+  public synchronized void setIdleCallback(@Nullable Runnable idleCallback) {
+    this.idleCallback = idleCallback;
+  }
+
+  synchronized void enqueue(AsyncCall call) {
+    if (runningAsyncCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {
+      runningAsyncCalls.add(call);
+      executorService().execute(call);
+    } else {
+      readyAsyncCalls.add(call);
+    }
+  }
+
+  /**
+   * Cancel all calls currently enqueued or executing. Includes calls executed both {@linkplain
+   * Call#execute() synchronously} and {@linkplain Call#enqueue asynchronously}.
+   */
+  public synchronized void cancelAll() {
+    for (AsyncCall call : readyAsyncCalls) {
+      call.get().cancel();
+    }
+
+    for (AsyncCall call : runningAsyncCalls) {
+      call.get().cancel();
+    }
+
+    for (RealCall call : runningSyncCalls) {
+      call.cancel();
+    }
+  }
+
+  private void promoteCalls() {
+    if (runningAsyncCalls.size() >= maxRequests) return; // Already running max capacity.
+    if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.
+
+    for (Iterator<AsyncCall> i = readyAsyncCalls.iterator(); i.hasNext(); ) {
+      AsyncCall call = i.next();
+
+      if (runningCallsForHost(call) < maxRequestsPerHost) {
+        i.remove();
+        runningAsyncCalls.add(call);
+        executorService().execute(call);
+      }
+
+      if (runningAsyncCalls.size() >= maxRequests) return; // Reached max capacity.
+    }
+  }
+
+  /** Returns the number of running calls that share a host with {@code call}. */
+  private int runningCallsForHost(AsyncCall call) {
+    int result = 0;
+    for (AsyncCall c : runningAsyncCalls) {
+      if (c.host().equals(call.host())) result++;
+    }
+    return result;
+  }
+
+  /** Used by {@code Call#execute} to signal it is in-flight. */
+  synchronized void executed(RealCall call) {
+    runningSyncCalls.add(call);
+  }
+
+  /** Used by {@code AsyncCall#run} to signal completion. */
+  void finished(AsyncCall call) {
+    finished(runningAsyncCalls, call, true);
+  }
+
+  /** Used by {@code Call#execute} to signal completion. */
+  void finished(RealCall call) {
+    finished(runningSyncCalls, call, false);
+  }
+
+  private <T> void finished(Deque<T> calls, T call, boolean promoteCalls) {
+    int runningCallsCount;
+    Runnable idleCallback;
+    synchronized (this) {
+      if (!calls.remove(call)) throw new AssertionError("Call wasn't in-flight!");
+      if (promoteCalls) promoteCalls();
+      runningCallsCount = runningCallsCount();
+      idleCallback = this.idleCallback;
+    }
+
+    if (runningCallsCount == 0 && idleCallback != null) {
+      idleCallback.run();
+    }
+  }
+
+  /** Returns a snapshot of the calls currently awaiting execution. */
+  public synchronized List<Call> queuedCalls() {
+    List<Call> result = new ArrayList<>();
+    for (AsyncCall asyncCall : readyAsyncCalls) {
+      result.add(asyncCall.get());
+    }
+    return Collections.unmodifiableList(result);
+  }
+
+  /** Returns a snapshot of the calls currently being executed. */
+  public synchronized List<Call> runningCalls() {
+    List<Call> result = new ArrayList<>();
+    result.addAll(runningSyncCalls);
+    for (AsyncCall asyncCall : runningAsyncCalls) {
+      result.add(asyncCall.get());
+    }
+    return Collections.unmodifiableList(result);
+  }
+
+  public synchronized int queuedCallsCount() {
+    return readyAsyncCalls.size();
+  }
+
+  public synchronized int runningCallsCount() {
+    return runningAsyncCalls.size() + runningSyncCalls.size();
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Dns.java b/okhttp/src/main/java/okhttp3/Dns.java
new file mode 100644
index 0000000000..a2e6db591c
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Dns.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * A domain name service that resolves IP addresses for host names. Most applications will use the
+ * {@linkplain #SYSTEM system DNS service}, which is the default. Some applications may provide
+ * their own implementation to use a different DNS server, to prefer IPv6 addresses, to prefer IPv4
+ * addresses, or to force a specific known IP address.
+ *
+ * <p>Implementations of this interface must be safe for concurrent use.
+ */
+public interface Dns {
+  /**
+   * A DNS that uses {@link InetAddress#getAllByName} to ask the underlying operating system to
+   * lookup IP addresses. Most custom {@link Dns} implementations should delegate to this instance.
+   */
+  Dns SYSTEM = new Dns() {
+    @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
+      if (hostname == null) throw new UnknownHostException("hostname == null");
+      return Arrays.asList(InetAddress.getAllByName(hostname));
+    }
+  };
+
+  /**
+   * Returns the IP addresses of {@code hostname}, in the order they will be attempted by OkHttp. If
+   * a connection to an address fails, OkHttp will retry the connection with the next address until
+   * either a connection is made, the set of IP addresses is exhausted, or a limit is exceeded.
+   */
+  List<InetAddress> lookup(String hostname) throws UnknownHostException;
+}
diff --git a/okhttp/src/main/java/okhttp3/EventListener.java b/okhttp/src/main/java/okhttp3/EventListener.java
new file mode 100644
index 0000000000..1feebd3ad0
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/EventListener.java
@@ -0,0 +1,307 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.util.List;
+import javax.annotation.Nullable;
+
+/**
+ * Listener for metrics events. Extend this class to monitor the quantity, size, and duration of
+ * your application's HTTP calls.
+ *
+ * <h3>Warning: This is a non-final API.</h3>
+ *
+ * <p><strong>As of OkHttp 3.9, this feature is an unstable preview: the API is subject to change,
+ * and the implementation is incomplete. We expect that OkHttp 3.10 or 3.11 will finalize this API.
+ * Until then, expect API and behavior changes when you update your OkHttp dependency.</strong>
+ *
+ * <p>All start/connect/acquire events will eventually receive a matching end/release event,
+ * either successful (non-null parameters), or failed (non-null throwable).  The first common
+ * parameters of each event pair are used to link the event in case of concurrent or repeated
+ * events e.g. dnsStart(call, domainName) -&gt; dnsEnd(call, domainName, inetAddressList).
+ *
+ * <p>Nesting is as follows
+ * <ul>
+ *   <li>call -&gt; (dns -&gt; connect -&gt; secure connect)* -&gt; request events</li>
+ *   <li>call -&gt; (connection acquire/release)*</li>
+ * </ul>
+ *
+ * <p>Request events are ordered:
+ * requestHeaders -&gt; requestBody -&gt; responseHeaders -&gt; responseBody
+ *
+ * <p>Since connections may be reused, the dns and connect events may not be present for a call,
+ * or may be repeated in case of failure retries, even concurrently in case of happy eyeballs type
+ * scenarios. A redirect cross domain, or to use https may cause additional connection and request
+ * events.
+ *
+ * <p>All event methods must execute fast, without external locking, cannot throw exceptions,
+ * attempt to mutate the event parameters, or be reentrant back into the client.
+ * Any IO - writing to files or network should be done asynchronously.
+ */
+public abstract class EventListener {
+  public static final EventListener NONE = new EventListener() {
+  };
+
+  static EventListener.Factory factory(final EventListener listener) {
+    return new EventListener.Factory() {
+      public EventListener create(Call call) {
+        return listener;
+      }
+    };
+  }
+
+  /**
+   * Invoked as soon as a call is enqueued or executed by a client. In case of thread or stream
+   * limits, this call may be executed well before processing the request is able to begin.
+   *
+   * <p>This will be invoked only once for a single {@link Call}. Retries of different routes
+   * or redirects will be handled within the boundaries of a single callStart and {@link
+   * #callEnd}/{@link #callFailed} pair.
+   */
+  public void callStart(Call call) {
+  }
+
+  /**
+   * Invoked just prior to a DNS lookup. See {@link Dns#lookup(String)}.
+   *
+   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
+   * to the {@link Call#request()} is a redirect to a different host.
+   *
+   * <p>If the {@link Call} is able to reuse an existing pooled connection, this method will not be
+   * invoked. See {@link ConnectionPool}.
+   */
+  public void dnsStart(Call call, String domainName) {
+  }
+
+  /**
+   * Invoked immediately after a DNS lookup.
+   *
+   * <p>This method is invoked after {@link #dnsStart}.
+   */
+  public void dnsEnd(Call call, String domainName, @Nullable List<InetAddress> inetAddressList) {
+  }
+
+  /**
+   * Invoked just prior to initiating a socket connection.
+   *
+   * <p>This method will be invoked if no existing connection in the {@link ConnectionPool} can be
+   * reused.
+   *
+   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
+   * to the {@link Call#request()} is a redirect to a different address, or a connection is retried.
+   */
+  public void connectStart(Call call, InetSocketAddress inetSocketAddress, Proxy proxy) {
+  }
+
+  /**
+   * Invoked just prior to initiating a TLS connection.
+   *
+   * <p>This method is invoked if the following conditions are met:
+   * <ul>
+   * <li>The {@link Call#request()} requires TLS.</li>
+   * <li>No existing connection from the {@link ConnectionPool} can be reused.</li>
+   * </ul>
+   *
+   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
+   * to the {@link Call#request()} is a redirect to a different address, or a connection is retried.
+   */
+  public void secureConnectStart(Call call) {
+  }
+
+  /**
+   * Invoked immediately after a TLS connection was attempted.
+   *
+   * <p>This method is invoked after {@link #secureConnectStart}.
+   */
+  public void secureConnectEnd(Call call, @Nullable Handshake handshake) {
+  }
+
+  /**
+   * Invoked immediately after a socket connection was attempted.
+   *
+   * <p>If the {@code call} uses HTTPS, this will be invoked after
+   * {@link #secureConnectEnd(Call, Handshake)}, otherwise it will invoked after
+   * {@link #connectStart(Call, InetSocketAddress, Proxy)}.
+   */
+  public void connectEnd(Call call, InetSocketAddress inetSocketAddress,
+      @Nullable Proxy proxy, @Nullable Protocol protocol) {
+  }
+
+  /**
+   * Invoked when a connection attempt fails. This failure is not terminal if further routes are
+   * available and failure recovery is enabled.
+   *
+   * <p>If the {@code call} uses HTTPS, this will be invoked after {@link #secureConnectEnd(Call,
+   * Handshake)}, otherwise it will invoked after {@link #connectStart(Call, InetSocketAddress,
+   * Proxy)}.
+   */
+  public void connectFailed(Call call, InetSocketAddress inetSocketAddress,
+      @Nullable Proxy proxy, @Nullable Protocol protocol, @Nullable IOException ioe) {
+  }
+
+  /**
+   * Invoked after a connection has been acquired for the {@code call}.
+   *
+   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
+   * to the {@link Call#request()} is a redirect to a different address.
+   */
+  public void connectionAcquired(Call call, Connection connection) {
+  }
+
+  /**
+   * Invoked after a connection has been released for the {@code call}.
+   *
+   * <p>This method is always invoked after {@link #connectionAcquired(Call, Connection)}.
+   *
+   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
+   * to the {@link Call#request()} is a redirect to a different address.
+   */
+  public void connectionReleased(Call call, Connection connection) {
+  }
+
+  /**
+   * Invoked just prior to sending request headers.
+   *
+   * <p>The connection is implicit, and will generally relate to the last
+   * {@link #connectionAcquired(Call, Connection)} event.
+   *
+   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
+   * to the {@link Call#request()} is a redirect to a different address.
+   */
+  public void requestHeadersStart(Call call) {
+  }
+
+  /**
+   * Invoked immediately after sending request headers.
+   *
+   * <p>This method is always invoked after {@link #requestHeadersStart(Call)}.
+   *
+   * @param request the request sent over the network. It is an error to access the body of this
+   *     request.
+   */
+  public void requestHeadersEnd(Call call, Request request) {
+  }
+
+  /**
+   * Invoked just prior to sending a request body.  Will only be invoked for request allowing and
+   * having a request body to send.
+   *
+   * <p>The connection is implicit, and will generally relate to the last
+   * {@link #connectionAcquired(Call, Connection)} event.
+   *
+   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
+   * to the {@link Call#request()} is a redirect to a different address.
+   */
+  public void requestBodyStart(Call call) {
+  }
+
+  /**
+   * Invoked immediately after sending a request body.
+   *
+   * <p>This method is always invoked after {@link #requestBodyStart(Call)}.
+   */
+  public void requestBodyEnd(Call call, long byteCount) {
+  }
+
+  /**
+   * Invoked just prior to receiving response headers.
+   *
+   * <p>The connection is implicit, and will generally relate to the last
+   * {@link #connectionAcquired(Call, Connection)} event.
+   *
+   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
+   * to the {@link Call#request()} is a redirect to a different address.
+   */
+  public void responseHeadersStart(Call call) {
+  }
+
+  /**
+   * Invoked immediately after receiving response headers.
+   *
+   * <p>This method is always invoked after {@link #responseHeadersStart}.
+   *
+   * @param response the response received over the network. It is an error to access the body of
+   *     this response.
+   */
+  public void responseHeadersEnd(Call call, Response response) {
+  }
+
+  /**
+   * Invoked just prior to receiving the response body.
+   *
+   * <p>The connection is implicit, and will generally relate to the last
+   * {@link #connectionAcquired(Call, Connection)} event.
+   *
+   * <p>This will usually be invoked only 1 time for a single {@link Call},
+   * exceptions are a limited set of cases including failure recovery.
+   */
+  public void responseBodyStart(Call call) {
+  }
+
+  /**
+   * Invoked immediately after receiving a response body and completing reading it.
+   *
+   * <p>Will only be invoked for requests having a response body e.g. won't be invoked for a
+   * websocket upgrade.
+   *
+   * <p>This method is always invoked after {@link #requestBodyStart(Call)}.
+   */
+  public void responseBodyEnd(Call call, long byteCount) {
+  }
+
+  /**
+   * Invoked immediately after a call has completely ended.  This includes delayed consumption
+   * of response body by the caller.
+   *
+   * <p>This method is always invoked after {@link #callStart(Call)}.
+   */
+  public void callEnd(Call call) {
+  }
+
+  /**
+   * Invoked when a call fails permanently.
+   *
+   * <p>This method is always invoked after {@link #callStart(Call)}.
+   */
+  public void callFailed(Call call, IOException ioe) {
+  }
+
+  /**
+   * <h3>Warning: This is a non-final API.</h3>
+   *
+   * <p><strong>As of OkHttp 3.9, this feature is an unstable preview: the API is subject to change,
+   * and the implementation is incomplete. We expect that OkHttp 3.10 or 3.11 will finalize this
+   * API. Until then, expect API and behavior changes when you update your OkHttp
+   * dependency.</strong>
+   */
+  public interface Factory {
+    /**
+     * Creates an instance of the {@link EventListener} for a particular {@link Call}. The returned
+     * {@link EventListener} instance will be used during the lifecycle of the {@code call}.
+     *
+     * <p>This method is invoked after the {@code call} is created. See
+     * {@link OkHttpClient#newCall(Request)}.
+     *
+     * <p><strong>It is an error for implementations to issue any mutating operations on the
+     * {@code call} instance from this method.</strong>
+     */
+    EventListener create(Call call);
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/FormBody.java b/okhttp/src/main/java/okhttp3/FormBody.java
new file mode 100644
index 0000000000..ff9a8c2572
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/FormBody.java
@@ -0,0 +1,135 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.nio.charset.Charset;
+import java.util.ArrayList;
+import java.util.List;
+import javax.annotation.Nullable;
+import okhttp3.internal.Util;
+import okio.Buffer;
+import okio.BufferedSink;
+
+import static okhttp3.HttpUrl.FORM_ENCODE_SET;
+import static okhttp3.HttpUrl.percentDecode;
+
+public final class FormBody extends RequestBody {
+  private static final MediaType CONTENT_TYPE =
+      MediaType.parse("application/x-www-form-urlencoded");
+
+  private final List<String> encodedNames;
+  private final List<String> encodedValues;
+
+  FormBody(List<String> encodedNames, List<String> encodedValues) {
+    this.encodedNames = Util.immutableList(encodedNames);
+    this.encodedValues = Util.immutableList(encodedValues);
+  }
+
+  /** The number of key-value pairs in this form-encoded body. */
+  public int size() {
+    return encodedNames.size();
+  }
+
+  public String encodedName(int index) {
+    return encodedNames.get(index);
+  }
+
+  public String name(int index) {
+    return percentDecode(encodedName(index), true);
+  }
+
+  public String encodedValue(int index) {
+    return encodedValues.get(index);
+  }
+
+  public String value(int index) {
+    return percentDecode(encodedValue(index), true);
+  }
+
+  @Override public MediaType contentType() {
+    return CONTENT_TYPE;
+  }
+
+  @Override public long contentLength() {
+    return writeOrCountBytes(null, true);
+  }
+
+  @Override public void writeTo(BufferedSink sink) throws IOException {
+    writeOrCountBytes(sink, false);
+  }
+
+  /**
+   * Either writes this request to {@code sink} or measures its content length. We have one method
+   * do double-duty to make sure the counting and content are consistent, particularly when it comes
+   * to awkward operations like measuring the encoded length of header strings, or the
+   * length-in-digits of an encoded integer.
+   */
+  private long writeOrCountBytes(@Nullable BufferedSink sink, boolean countBytes) {
+    long byteCount = 0L;
+
+    Buffer buffer;
+    if (countBytes) {
+      buffer = new Buffer();
+    } else {
+      buffer = sink.buffer();
+    }
+
+    for (int i = 0, size = encodedNames.size(); i < size; i++) {
+      if (i > 0) buffer.writeByte('&');
+      buffer.writeUtf8(encodedNames.get(i));
+      buffer.writeByte('=');
+      buffer.writeUtf8(encodedValues.get(i));
+    }
+
+    if (countBytes) {
+      byteCount = buffer.size();
+      buffer.clear();
+    }
+
+    return byteCount;
+  }
+
+  public static final class Builder {
+    private final List<String> names = new ArrayList<>();
+    private final List<String> values = new ArrayList<>();
+    private final Charset charset;
+
+    public Builder() {
+      this(null);
+    }
+
+    public Builder(Charset charset) {
+      this.charset = charset;
+    }
+
+    public Builder add(String name, String value) {
+      names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, false, false, true, true, charset));
+      values.add(HttpUrl.canonicalize(value, FORM_ENCODE_SET, false, false, true, true, charset));
+      return this;
+    }
+
+    public Builder addEncoded(String name, String value) {
+      names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, true, false, true, true, charset));
+      values.add(HttpUrl.canonicalize(value, FORM_ENCODE_SET, true, false, true, true, charset));
+      return this;
+    }
+
+    public FormBody build() {
+      return new FormBody(names, values);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Handshake.java b/okhttp/src/main/java/okhttp3/Handshake.java
new file mode 100644
index 0000000000..59a5418b86
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Handshake.java
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.security.Principal;
+import java.security.cert.Certificate;
+import java.security.cert.X509Certificate;
+import java.util.Collections;
+import java.util.List;
+import javax.annotation.Nullable;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSession;
+import okhttp3.internal.Util;
+
+/**
+ * A record of a TLS handshake. For HTTPS clients, the client is <i>local</i> and the remote server
+ * is its <i>peer</i>.
+ *
+ * <p>This value object describes a completed handshake. Use {@link ConnectionSpec} to set policy
+ * for new handshakes.
+ */
+public final class Handshake {
+  private final TlsVersion tlsVersion;
+  private final CipherSuite cipherSuite;
+  private final List<Certificate> peerCertificates;
+  private final List<Certificate> localCertificates;
+
+  private Handshake(TlsVersion tlsVersion, CipherSuite cipherSuite,
+      List<Certificate> peerCertificates, List<Certificate> localCertificates) {
+    this.tlsVersion = tlsVersion;
+    this.cipherSuite = cipherSuite;
+    this.peerCertificates = peerCertificates;
+    this.localCertificates = localCertificates;
+  }
+
+  public static Handshake get(SSLSession session) {
+    String cipherSuiteString = session.getCipherSuite();
+    if (cipherSuiteString == null) throw new IllegalStateException("cipherSuite == null");
+    CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);
+
+    String tlsVersionString = session.getProtocol();
+    if (tlsVersionString == null) throw new IllegalStateException("tlsVersion == null");
+    TlsVersion tlsVersion = TlsVersion.forJavaName(tlsVersionString);
+
+    Certificate[] peerCertificates;
+    try {
+      peerCertificates = session.getPeerCertificates();
+    } catch (SSLPeerUnverifiedException ignored) {
+      peerCertificates = null;
+    }
+    List<Certificate> peerCertificatesList = peerCertificates != null
+        ? Util.immutableList(peerCertificates)
+        : Collections.<Certificate>emptyList();
+
+    Certificate[] localCertificates = session.getLocalCertificates();
+    List<Certificate> localCertificatesList = localCertificates != null
+        ? Util.immutableList(localCertificates)
+        : Collections.<Certificate>emptyList();
+
+    return new Handshake(tlsVersion, cipherSuite, peerCertificatesList, localCertificatesList);
+  }
+
+  public static Handshake get(TlsVersion tlsVersion, CipherSuite cipherSuite,
+      List<Certificate> peerCertificates, List<Certificate> localCertificates) {
+    if (tlsVersion == null) throw new NullPointerException("tlsVersion == null");
+    if (cipherSuite == null) throw new NullPointerException("cipherSuite == null");
+    return new Handshake(tlsVersion, cipherSuite, Util.immutableList(peerCertificates),
+        Util.immutableList(localCertificates));
+  }
+
+  /**
+   * Returns the TLS version used for this connection. This value wasn't tracked prior to OkHttp
+   * 3.0. For responses cached by preceding versions this returns {@link TlsVersion#SSL_3_0}.
+   */
+  public TlsVersion tlsVersion() {
+    return tlsVersion;
+  }
+
+  /** Returns the cipher suite used for the connection. */
+  public CipherSuite cipherSuite() {
+    return cipherSuite;
+  }
+
+  /** Returns a possibly-empty list of certificates that identify the remote peer. */
+  public List<Certificate> peerCertificates() {
+    return peerCertificates;
+  }
+
+  /** Returns the remote peer's principle, or null if that peer is anonymous. */
+  public @Nullable Principal peerPrincipal() {
+    return !peerCertificates.isEmpty()
+        ? ((X509Certificate) peerCertificates.get(0)).getSubjectX500Principal()
+        : null;
+  }
+
+  /** Returns a possibly-empty list of certificates that identify this peer. */
+  public List<Certificate> localCertificates() {
+    return localCertificates;
+  }
+
+  /** Returns the local principle, or null if this peer is anonymous. */
+  public @Nullable Principal localPrincipal() {
+    return !localCertificates.isEmpty()
+        ? ((X509Certificate) localCertificates.get(0)).getSubjectX500Principal()
+        : null;
+  }
+
+  @Override public boolean equals(@Nullable Object other) {
+    if (!(other instanceof Handshake)) return false;
+    Handshake that = (Handshake) other;
+    return tlsVersion.equals(that.tlsVersion)
+        && cipherSuite.equals(that.cipherSuite)
+        && peerCertificates.equals(that.peerCertificates)
+        && localCertificates.equals(that.localCertificates);
+  }
+
+  @Override public int hashCode() {
+    int result = 17;
+    result = 31 * result + tlsVersion.hashCode();
+    result = 31 * result + cipherSuite.hashCode();
+    result = 31 * result + peerCertificates.hashCode();
+    result = 31 * result + localCertificates.hashCode();
+    return result;
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Headers.java b/okhttp/src/main/java/okhttp3/Headers.java
new file mode 100644
index 0000000000..d5ef33aa70
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Headers.java
@@ -0,0 +1,358 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package okhttp3;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Date;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeMap;
+import java.util.TreeSet;
+import javax.annotation.Nullable;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.HttpDate;
+
+/**
+ * The header fields of a single HTTP message. Values are uninterpreted strings; use {@code Request}
+ * and {@code Response} for interpreted headers. This class maintains the order of the header fields
+ * within the HTTP message.
+ *
+ * <p>This class tracks header values line-by-line. A field with multiple comma- separated values on
+ * the same line will be treated as a field with a single value by this class. It is the caller's
+ * responsibility to detect and split on commas if their field permits multiple values. This
+ * simplifies use of single-valued fields whose values routinely contain commas, such as cookies or
+ * dates.
+ *
+ * <p>This class trims whitespace from values. It never returns values with leading or trailing
+ * whitespace.
+ *
+ * <p>Instances of this class are immutable. Use {@link Builder} to create instances.
+ */
+public final class Headers {
+  private final String[] namesAndValues;
+
+  Headers(Builder builder) {
+    this.namesAndValues = builder.namesAndValues.toArray(new String[builder.namesAndValues.size()]);
+  }
+
+  private Headers(String[] namesAndValues) {
+    this.namesAndValues = namesAndValues;
+  }
+
+  /** Returns the last value corresponding to the specified field, or null. */
+  public @Nullable String get(String name) {
+    return get(namesAndValues, name);
+  }
+
+  /**
+   * Returns the last value corresponding to the specified field parsed as an HTTP date, or null if
+   * either the field is absent or cannot be parsed as a date.
+   */
+  public @Nullable Date getDate(String name) {
+    String value = get(name);
+    return value != null ? HttpDate.parse(value) : null;
+  }
+
+  /** Returns the number of field values. */
+  public int size() {
+    return namesAndValues.length / 2;
+  }
+
+  /** Returns the field at {@code position}. */
+  public String name(int index) {
+    return namesAndValues[index * 2];
+  }
+
+  /** Returns the value at {@code index}. */
+  public String value(int index) {
+    return namesAndValues[index * 2 + 1];
+  }
+
+  /** Returns an immutable case-insensitive set of header names. */
+  public Set<String> names() {
+    TreeSet<String> result = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
+    for (int i = 0, size = size(); i < size; i++) {
+      result.add(name(i));
+    }
+    return Collections.unmodifiableSet(result);
+  }
+
+  /** Returns an immutable list of the header values for {@code name}. */
+  public List<String> values(String name) {
+    List<String> result = null;
+    for (int i = 0, size = size(); i < size; i++) {
+      if (name.equalsIgnoreCase(name(i))) {
+        if (result == null) result = new ArrayList<>(2);
+        result.add(value(i));
+      }
+    }
+    return result != null
+        ? Collections.unmodifiableList(result)
+        : Collections.<String>emptyList();
+  }
+
+  /**
+   * Returns the number of bytes required to encode these headers using HTTP/1.1. This is also the
+   * approximate size of HTTP/2 headers before they are compressed with HPACK. This value is
+   * intended to be used as a metric: smaller headers are more efficient to encode and transmit.
+   */
+  public long byteCount() {
+    // Each header name has 2 bytes of overhead for ': ' and every header value has 2 bytes of
+    // overhead for '\r\n'.
+    long result = namesAndValues.length * 2;
+
+    for (int i = 0, size = namesAndValues.length; i < size; i++) {
+      result += namesAndValues[i].length();
+    }
+
+    return result;
+  }
+
+  public Builder newBuilder() {
+    Builder result = new Builder();
+    Collections.addAll(result.namesAndValues, namesAndValues);
+    return result;
+  }
+
+  /**
+   * Returns true if {@code other} is a {@code Headers} object with the same headers, with the same
+   * casing, in the same order. Note that two headers instances may be <i>semantically</i> equal
+   * but not equal according to this method. In particular, none of the following sets of headers
+   * are equal according to this method: <pre>   {@code
+   *
+   *   1. Original
+   *   Content-Type: text/html
+   *   Content-Length: 50
+   *
+   *   2. Different order
+   *   Content-Length: 50
+   *   Content-Type: text/html
+   *
+   *   3. Different case
+   *   content-type: text/html
+   *   content-length: 50
+   *
+   *   4. Different values
+   *   Content-Type: text/html
+   *   Content-Length: 050
+   * }</pre>
+   *
+   * Applications that require semantically equal headers should convert them into a canonical form
+   * before comparing them for equality.
+   */
+  @Override public boolean equals(@Nullable Object other) {
+    return other instanceof Headers
+        && Arrays.equals(((Headers) other).namesAndValues, namesAndValues);
+  }
+
+  @Override public int hashCode() {
+    return Arrays.hashCode(namesAndValues);
+  }
+
+  @Override public String toString() {
+    StringBuilder result = new StringBuilder();
+    for (int i = 0, size = size(); i < size; i++) {
+      result.append(name(i)).append(": ").append(value(i)).append("\n");
+    }
+    return result.toString();
+  }
+
+  public Map<String, List<String>> toMultimap() {
+    Map<String, List<String>> result = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
+    for (int i = 0, size = size(); i < size; i++) {
+      String name = name(i).toLowerCase(Locale.US);
+      List<String> values = result.get(name);
+      if (values == null) {
+        values = new ArrayList<>(2);
+        result.put(name, values);
+      }
+      values.add(value(i));
+    }
+    return result;
+  }
+
+  private static String get(String[] namesAndValues, String name) {
+    for (int i = namesAndValues.length - 2; i >= 0; i -= 2) {
+      if (name.equalsIgnoreCase(namesAndValues[i])) {
+        return namesAndValues[i + 1];
+      }
+    }
+    return null;
+  }
+
+  /**
+   * Returns headers for the alternating header names and values. There must be an even number of
+   * arguments, and they must alternate between header names and values.
+   */
+  public static Headers of(String... namesAndValues) {
+    if (namesAndValues == null) throw new NullPointerException("namesAndValues == null");
+    if (namesAndValues.length % 2 != 0) {
+      throw new IllegalArgumentException("Expected alternating header names and values");
+    }
+
+    // Make a defensive copy and clean it up.
+    namesAndValues = namesAndValues.clone();
+    for (int i = 0; i < namesAndValues.length; i++) {
+      if (namesAndValues[i] == null) throw new IllegalArgumentException("Headers cannot be null");
+      namesAndValues[i] = namesAndValues[i].trim();
+    }
+
+    // Check for malformed headers.
+    for (int i = 0; i < namesAndValues.length; i += 2) {
+      String name = namesAndValues[i];
+      String value = namesAndValues[i + 1];
+      if (name.length() == 0 || name.indexOf('\0') != -1 || value.indexOf('\0') != -1) {
+        throw new IllegalArgumentException("Unexpected header: " + name + ": " + value);
+      }
+    }
+
+    return new Headers(namesAndValues);
+  }
+
+  /**
+   * Returns headers for the header names and values in the {@link Map}.
+   */
+  public static Headers of(Map<String, String> headers) {
+    if (headers == null) throw new NullPointerException("headers == null");
+
+    // Make a defensive copy and clean it up.
+    String[] namesAndValues = new String[headers.size() * 2];
+    int i = 0;
+    for (Map.Entry<String, String> header : headers.entrySet()) {
+      if (header.getKey() == null || header.getValue() == null) {
+        throw new IllegalArgumentException("Headers cannot be null");
+      }
+      String name = header.getKey().trim();
+      String value = header.getValue().trim();
+      if (name.length() == 0 || name.indexOf('\0') != -1 || value.indexOf('\0') != -1) {
+        throw new IllegalArgumentException("Unexpected header: " + name + ": " + value);
+      }
+      namesAndValues[i] = name;
+      namesAndValues[i + 1] = value;
+      i += 2;
+    }
+
+    return new Headers(namesAndValues);
+  }
+
+  public static final class Builder {
+    final List<String> namesAndValues = new ArrayList<>(20);
+
+    /**
+     * Add a header line without any validation. Only appropriate for headers from the remote peer
+     * or cache.
+     */
+    Builder addLenient(String line) {
+      int index = line.indexOf(":", 1);
+      if (index != -1) {
+        return addLenient(line.substring(0, index), line.substring(index + 1));
+      } else if (line.startsWith(":")) {
+        // Work around empty header names and header names that start with a
+        // colon (created by old broken SPDY versions of the response cache).
+        return addLenient("", line.substring(1)); // Empty header name.
+      } else {
+        return addLenient("", line); // No header name.
+      }
+    }
+
+    /** Add an header line containing a field name, a literal colon, and a value. */
+    public Builder add(String line) {
+      int index = line.indexOf(":");
+      if (index == -1) {
+        throw new IllegalArgumentException("Unexpected header: " + line);
+      }
+      return add(line.substring(0, index).trim(), line.substring(index + 1));
+    }
+
+    /** Add a field with the specified value. */
+    public Builder add(String name, String value) {
+      checkNameAndValue(name, value);
+      return addLenient(name, value);
+    }
+
+    /**
+     * Add a field with the specified value without any validation. Only appropriate for headers
+     * from the remote peer or cache.
+     */
+    Builder addLenient(String name, String value) {
+      namesAndValues.add(name);
+      namesAndValues.add(value.trim());
+      return this;
+    }
+
+    public Builder removeAll(String name) {
+      for (int i = 0; i < namesAndValues.size(); i += 2) {
+        if (name.equalsIgnoreCase(namesAndValues.get(i))) {
+          namesAndValues.remove(i); // name
+          namesAndValues.remove(i); // value
+          i -= 2;
+        }
+      }
+      return this;
+    }
+
+    /**
+     * Set a field with the specified value. If the field is not found, it is added. If the field is
+     * found, the existing values are replaced.
+     */
+    public Builder set(String name, String value) {
+      checkNameAndValue(name, value);
+      removeAll(name);
+      addLenient(name, value);
+      return this;
+    }
+
+    private void checkNameAndValue(String name, String value) {
+      if (name == null) throw new NullPointerException("name == null");
+      if (name.isEmpty()) throw new IllegalArgumentException("name is empty");
+      for (int i = 0, length = name.length(); i < length; i++) {
+        char c = name.charAt(i);
+        if (c <= '\u0020' || c >= '\u007f') {
+          throw new IllegalArgumentException(Util.format(
+              "Unexpected char %#04x at %d in header name: %s", (int) c, i, name));
+        }
+      }
+      if (value == null) throw new NullPointerException("value for name " + name + " == null");
+      for (int i = 0, length = value.length(); i < length; i++) {
+        char c = value.charAt(i);
+        if ((c <= '\u001f' && c != '\t') || c >= '\u007f') {
+          throw new IllegalArgumentException(Util.format(
+              "Unexpected char %#04x at %d in %s value: %s", (int) c, i, name, value));
+        }
+      }
+    }
+
+    /** Equivalent to {@code build().get(name)}, but potentially faster. */
+    public String get(String name) {
+      for (int i = namesAndValues.size() - 2; i >= 0; i -= 2) {
+        if (name.equalsIgnoreCase(namesAndValues.get(i))) {
+          return namesAndValues.get(i + 1);
+        }
+      }
+      return null;
+    }
+
+    public Headers build() {
+      return new Headers(this);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/HttpUrl.java b/okhttp/src/main/java/okhttp3/HttpUrl.java
new file mode 100644
index 0000000000..85292eec88
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/HttpUrl.java
@@ -0,0 +1,1760 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.net.InetAddress;
+import java.net.MalformedURLException;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.net.UnknownHostException;
+import java.nio.charset.Charset;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Set;
+import javax.annotation.Nullable;
+import okhttp3.internal.Util;
+import okhttp3.internal.publicsuffix.PublicSuffixDatabase;
+import okio.Buffer;
+
+import static okhttp3.internal.Util.decodeHexDigit;
+import static okhttp3.internal.Util.delimiterOffset;
+import static okhttp3.internal.Util.skipLeadingAsciiWhitespace;
+import static okhttp3.internal.Util.skipTrailingAsciiWhitespace;
+import static okhttp3.internal.Util.verifyAsIpAddress;
+
+/**
+ * A uniform resource locator (URL) with a scheme of either {@code http} or {@code https}. Use this
+ * class to compose and decompose Internet addresses. For example, this code will compose and print
+ * a URL for Google search: <pre>   {@code
+ *
+ *   HttpUrl url = new HttpUrl.Builder()
+ *       .scheme("https")
+ *       .host("www.google.com")
+ *       .addPathSegment("search")
+ *       .addQueryParameter("q", "polar bears")
+ *       .build();
+ *   System.out.println(url);
+ * }</pre>
+ *
+ * which prints: <pre>   {@code
+ *
+ *     https://www.google.com/search?q=polar%20bears
+ * }</pre>
+ *
+ * As another example, this code prints the human-readable query parameters of a Twitter search:
+ * <pre>   {@code
+ *
+ *   HttpUrl url = HttpUrl.parse("https://twitter.com/search?q=cute%20%23puppies&f=images");
+ *   for (int i = 0, size = url.querySize(); i < size; i++) {
+ *     System.out.println(url.queryParameterName(i) + ": " + url.queryParameterValue(i));
+ *   }
+ * }</pre>
+ *
+ * which prints: <pre>   {@code
+ *
+ *   q: cute #puppies
+ *   f: images
+ * }</pre>
+ *
+ * In addition to composing URLs from their component parts and decomposing URLs into their
+ * component parts, this class implements relative URL resolution: what address you'd reach by
+ * clicking a relative link on a specified page. For example: <pre>   {@code
+ *
+ *   HttpUrl base = HttpUrl.parse("https://www.youtube.com/user/WatchTheDaily/videos");
+ *   HttpUrl link = base.resolve("../../watch?v=cbP2N1BQdYc");
+ *   System.out.println(link);
+ * }</pre>
+ *
+ * which prints: <pre>   {@code
+ *
+ *   https://www.youtube.com/watch?v=cbP2N1BQdYc
+ * }</pre>
+ *
+ * <h3>What's in a URL?</h3>
+ *
+ * A URL has several components.
+ *
+ * <h4>Scheme</h4>
+ *
+ * <p>Sometimes referred to as <i>protocol</i>, A URL's scheme describes what mechanism should be
+ * used to retrieve the resource. Although URLs have many schemes ({@code mailto}, {@code file},
+ * {@code ftp}), this class only supports {@code http} and {@code https}. Use {@link URI
+ * java.net.URI} for URLs with arbitrary schemes.
+ *
+ * <h4>Username and Password</h4>
+ *
+ * <p>Username and password are either present, or the empty string {@code ""} if absent. This class
+ * offers no mechanism to differentiate empty from absent. Neither of these components are popular
+ * in practice. Typically HTTP applications use other mechanisms for user identification and
+ * authentication.
+ *
+ * <h4>Host</h4>
+ *
+ * <p>The host identifies the webserver that serves the URL's resource. It is either a hostname like
+ * {@code square.com} or {@code localhost}, an IPv4 address like {@code 192.168.0.1}, or an IPv6
+ * address like {@code ::1}.
+ *
+ * <p>Usually a webserver is reachable with multiple identifiers: its IP addresses, registered
+ * domain names, and even {@code localhost} when connecting from the server itself. Each of a
+ * webserver's names is a distinct URL and they are not interchangeable. For example, even if {@code
+ * http://square.github.io/dagger} and {@code http://google.github.io/dagger} are served by the same
+ * IP address, the two URLs identify different resources.
+ *
+ * <h4>Port</h4>
+ *
+ * <p>The port used to connect to the webserver. By default this is 80 for HTTP and 443 for HTTPS.
+ * This class never returns -1 for the port: if no port is explicitly specified in the URL then the
+ * scheme's default is used.
+ *
+ * <h4>Path</h4>
+ *
+ * <p>The path identifies a specific resource on the host. Paths have a hierarchical structure like
+ * "/square/okhttp/issues/1486" and decompose into a list of segments like ["square", "okhttp",
+ * "issues", "1486"].
+ *
+ * <p>This class offers methods to compose and decompose paths by segment. It composes each path
+ * from a list of segments by alternating between "/" and the encoded segment. For example the
+ * segments ["a", "b"] build "/a/b" and the segments ["a", "b", ""] build "/a/b/".
+ *
+ * <p>If a path's last segment is the empty string then the path ends with "/". This class always
+ * builds non-empty paths: if the path is omitted it defaults to "/". The default path's segment
+ * list is a single empty string: [""].
+ *
+ * <h4>Query</h4>
+ *
+ * <p>The query is optional: it can be null, empty, or non-empty. For many HTTP URLs the query
+ * string is subdivided into a collection of name-value parameters. This class offers methods to set
+ * the query as the single string, or as individual name-value parameters. With name-value
+ * parameters the values are optional and names may be repeated.
+ *
+ * <h4>Fragment</h4>
+ *
+ * <p>The fragment is optional: it can be null, empty, or non-empty. Unlike host, port, path, and
+ * query the fragment is not sent to the webserver: it's private to the client.
+ *
+ * <h3>Encoding</h3>
+ *
+ * <p>Each component must be encoded before it is embedded in the complete URL. As we saw above, the
+ * string {@code cute #puppies} is encoded as {@code cute%20%23puppies} when used as a query
+ * parameter value.
+ *
+ * <h4>Percent encoding</h4>
+ *
+ * <p>Percent encoding replaces a character (like {@code \ud83c\udf69}) with its UTF-8 hex bytes
+ * (like {@code %F0%9F%8D%A9}). This approach works for whitespace characters, control characters,
+ * non-ASCII characters, and characters that already have another meaning in a particular context.
+ *
+ * <p>Percent encoding is used in every URL component except for the hostname. But the set of
+ * characters that need to be encoded is different for each component. For example, the path
+ * component must escape all of its {@code ?} characters, otherwise it could be interpreted as the
+ * start of the URL's query. But within the query and fragment components, the {@code ?} character
+ * doesn't delimit anything and doesn't need to be escaped. <pre>   {@code
+ *
+ *   HttpUrl url = HttpUrl.parse("http://who-let-the-dogs.out").newBuilder()
+ *       .addPathSegment("_Who?_")
+ *       .query("_Who?_")
+ *       .fragment("_Who?_")
+ *       .build();
+ *   System.out.println(url);
+ * }</pre>
+ *
+ * This prints: <pre>   {@code
+ *
+ *   http://who-let-the-dogs.out/_Who%3F_?_Who?_#_Who?_
+ * }</pre>
+ *
+ * When parsing URLs that lack percent encoding where it is required, this class will percent encode
+ * the offending characters.
+ *
+ * <h4>IDNA Mapping and Punycode encoding</h4>
+ *
+ * <p>Hostnames have different requirements and use a different encoding scheme. It consists of IDNA
+ * mapping and Punycode encoding.
+ *
+ * <p>In order to avoid confusion and discourage phishing attacks, <a
+ * href="http://www.unicode.org/reports/tr46/#ToASCII">IDNA Mapping</a> transforms names to avoid
+ * confusing characters. This includes basic case folding: transforming shouting {@code SQUARE.COM}
+ * into cool and casual {@code square.com}. It also handles more exotic characters. For example, the
+ * Unicode trademark sign (™) could be confused for the letters "TM" in {@code http://ho™mail.com}.
+ * To mitigate this, the single character (™) maps to the string (tm). There is similar policy for
+ * all of the 1.1 million Unicode code points. Note that some code points such as "\ud83c\udf69" are
+ * not mapped and cannot be used in a hostname.
+ *
+ * <p><a href="http://ietf.org/rfc/rfc3492.txt">Punycode</a> converts a Unicode string to an ASCII
+ * string to make international domain names work everywhere. For example, "σ" encodes as "xn--4xa".
+ * The encoded string is not human readable, but can be used with classes like {@link InetAddress}
+ * to establish connections.
+ *
+ * <h3>Why another URL model?</h3>
+ *
+ * <p>Java includes both {@link URL java.net.URL} and {@link URI java.net.URI}. We offer a new URL
+ * model to address problems that the others don't.
+ *
+ * <h4>Different URLs should be different</h4>
+ *
+ * <p>Although they have different content, {@code java.net.URL} considers the following two URLs
+ * equal, and the {@link Object#equals equals()} method between them returns true:
+ *
+ * <ul>
+ *   <li>http://square.github.io/
+ *   <li>http://google.github.io/
+ * </ul>
+ *
+ * This is because those two hosts share the same IP address. This is an old, bad design decision
+ * that makes {@code java.net.URL} unusable for many things. It shouldn't be used as a {@link
+ * java.util.Map Map} key or in a {@link Set}. Doing so is both inefficient because equality may
+ * require a DNS lookup, and incorrect because unequal URLs may be equal because of how they are
+ * hosted.
+ *
+ * <h4>Equal URLs should be equal</h4>
+ *
+ * <p>These two URLs are semantically identical, but {@code java.net.URI} disagrees:
+ *
+ * <ul>
+ *   <li>http://host:80/
+ *   <li>http://host
+ * </ul>
+ *
+ * Both the unnecessary port specification ({@code :80}) and the absent trailing slash ({@code /})
+ * cause URI to bucket the two URLs separately. This harms URI's usefulness in collections. Any
+ * application that stores information-per-URL will need to either canonicalize manually, or suffer
+ * unnecessary redundancy for such URLs.
+ *
+ * <p>Because they don't attempt canonical form, these classes are surprisingly difficult to use
+ * securely. Suppose you're building a webservice that checks that incoming paths are prefixed
+ * "/static/images/" before serving the corresponding assets from the filesystem. <pre>   {@code
+ *
+ *   String attack = "http://example.com/static/images/../../../../../etc/passwd";
+ *   System.out.println(new URL(attack).getPath());
+ *   System.out.println(new URI(attack).getPath());
+ *   System.out.println(HttpUrl.parse(attack).encodedPath());
+ * }</pre>
+ *
+ * By canonicalizing the input paths, they are complicit in directory traversal attacks. Code that
+ * checks only the path prefix may suffer!
+ * <pre>   {@code
+ *
+ *    /static/images/../../../../../etc/passwd
+ *    /static/images/../../../../../etc/passwd
+ *    /etc/passwd
+ * }</pre>
+ *
+ * <h4>If it works on the web, it should work in your application</h4>
+ *
+ * <p>The {@code java.net.URI} class is strict around what URLs it accepts. It rejects URLs like
+ * "http://example.com/abc|def" because the '|' character is unsupported. This class is more
+ * forgiving: it will automatically percent-encode the '|', yielding "http://example.com/abc%7Cdef".
+ * This kind behavior is consistent with web browsers. {@code HttpUrl} prefers consistency with
+ * major web browsers over consistency with obsolete specifications.
+ *
+ * <h4>Paths and Queries should decompose</h4>
+ *
+ * <p>Neither of the built-in URL models offer direct access to path segments or query parameters.
+ * Manually using {@code StringBuilder} to assemble these components is cumbersome: do '+'
+ * characters get silently replaced with spaces? If a query parameter contains a '&amp;', does that
+ * get escaped? By offering methods to read and write individual query parameters directly,
+ * application developers are saved from the hassles of encoding and decoding.
+ *
+ * <h4>Plus a modern API</h4>
+ *
+ * <p>The URL (JDK1.0) and URI (Java 1.4) classes predate builders and instead use telescoping
+ * constructors. For example, there's no API to compose a URI with a custom port without also
+ * providing a query and fragment.
+ *
+ * <p>Instances of {@link HttpUrl} are well-formed and always have a scheme, host, and path. With
+ * {@code java.net.URL} it's possible to create an awkward URL like {@code http:/} with scheme and
+ * path but no hostname. Building APIs that consume such malformed values is difficult!
+ *
+ * <p>This class has a modern API. It avoids punitive checked exceptions: {@link #parse parse()}
+ * returns null if the input is an invalid URL. You can even be explicit about whether each
+ * component has been encoded already.
+ */
+public final class HttpUrl {
+  private static final char[] HEX_DIGITS =
+      {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
+  static final String USERNAME_ENCODE_SET = " \"':;<=>@[]^`{}|/\\?#";
+  static final String PASSWORD_ENCODE_SET = " \"':;<=>@[]^`{}|/\\?#";
+  static final String PATH_SEGMENT_ENCODE_SET = " \"<>^`{}|/\\?#";
+  static final String PATH_SEGMENT_ENCODE_SET_URI = "[]";
+  static final String QUERY_ENCODE_SET = " \"'<>#";
+  static final String QUERY_COMPONENT_ENCODE_SET = " \"'<>#&=";
+  static final String QUERY_COMPONENT_ENCODE_SET_URI = "\\^`{|}";
+  static final String FORM_ENCODE_SET = " \"':;<=>@[]^`{}|/\\?#&!$(),~";
+  static final String FRAGMENT_ENCODE_SET = "";
+  static final String FRAGMENT_ENCODE_SET_URI = " \"#<>\\^`{|}";
+
+  /** Either "http" or "https". */
+  final String scheme;
+
+  /** Decoded username. */
+  private final String username;
+
+  /** Decoded password. */
+  private final String password;
+
+  /** Canonical hostname. */
+  final String host;
+
+  /** Either 80, 443 or a user-specified port. In range [1..65535]. */
+  final int port;
+
+  /**
+   * A list of canonical path segments. This list always contains at least one element, which may be
+   * the empty string. Each segment is formatted with a leading '/', so if path segments were ["a",
+   * "b", ""], then the encoded path would be "/a/b/".
+   */
+  private final List<String> pathSegments;
+
+  /**
+   * Alternating, decoded query names and values, or null for no query. Names may be empty or
+   * non-empty, but never null. Values are null if the name has no corresponding '=' separator, or
+   * empty, or non-empty.
+   */
+  private final @Nullable List<String> queryNamesAndValues;
+
+  /** Decoded fragment. */
+  private final @Nullable String fragment;
+
+  /** Canonical URL. */
+  private final String url;
+
+  HttpUrl(Builder builder) {
+    this.scheme = builder.scheme;
+    this.username = percentDecode(builder.encodedUsername, false);
+    this.password = percentDecode(builder.encodedPassword, false);
+    this.host = builder.host;
+    this.port = builder.effectivePort();
+    this.pathSegments = percentDecode(builder.encodedPathSegments, false);
+    this.queryNamesAndValues = builder.encodedQueryNamesAndValues != null
+        ? percentDecode(builder.encodedQueryNamesAndValues, true)
+        : null;
+    this.fragment = builder.encodedFragment != null
+        ? percentDecode(builder.encodedFragment, false)
+        : null;
+    this.url = builder.toString();
+  }
+
+  /** Returns this URL as a {@link URL java.net.URL}. */
+  public URL url() {
+    try {
+      return new URL(url);
+    } catch (MalformedURLException e) {
+      throw new RuntimeException(e); // Unexpected!
+    }
+  }
+
+  /**
+   * Returns this URL as a {@link URI java.net.URI}. Because {@code URI} is more strict than this
+   * class, the returned URI may be semantically different from this URL:
+   *
+   * <ul>
+   *     <li>Characters forbidden by URI like {@code [} and {@code |} will be escaped.
+   *     <li>Invalid percent-encoded sequences like {@code %xx} will be encoded like {@code %25xx}.
+   *     <li>Whitespace and control characters in the fragment will be stripped.
+   * </ul>
+   *
+   * <p>These differences may have a significant consequence when the URI is interpreted by a
+   * webserver. For this reason the {@linkplain URI URI class} and this method should be avoided.
+   */
+  public URI uri() {
+    String uri = newBuilder().reencodeForUri().toString();
+    try {
+      return new URI(uri);
+    } catch (URISyntaxException e) {
+      // Unlikely edge case: the URI has a forbidden character in the fragment. Strip it & retry.
+      try {
+        String stripped = uri.replaceAll("[\\u0000-\\u001F\\u007F-\\u009F\\p{javaWhitespace}]", "");
+        return URI.create(stripped);
+      } catch (Exception e1) {
+        throw new RuntimeException(e); // Unexpected!
+      }
+    }
+  }
+
+  /** Returns either "http" or "https". */
+  public String scheme() {
+    return scheme;
+  }
+
+  public boolean isHttps() {
+    return scheme.equals("https");
+  }
+
+  /**
+   * Returns the username, or an empty string if none is set.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code encodedUsername()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>{@code ""}</td></tr>
+   *   <tr><td>{@code http://username@host/}</td><td>{@code "username"}</td></tr>
+   *   <tr><td>{@code http://username:password@host/}</td><td>{@code "username"}</td></tr>
+   *   <tr><td>{@code http://a%20b:c%20d@host/}</td><td>{@code "a%20b"}</td></tr>
+   * </table>
+   */
+  public String encodedUsername() {
+    if (username.isEmpty()) return "";
+    int usernameStart = scheme.length() + 3; // "://".length() == 3.
+    int usernameEnd = delimiterOffset(url, usernameStart, url.length(), ":@");
+    return url.substring(usernameStart, usernameEnd);
+  }
+
+  /**
+   * Returns the decoded username, or an empty string if none is present.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code username()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>{@code ""}</td></tr>
+   *   <tr><td>{@code http://username@host/}</td><td>{@code "username"}</td></tr>
+   *   <tr><td>{@code http://username:password@host/}</td><td>{@code "username"}</td></tr>
+   *   <tr><td>{@code http://a%20b:c%20d@host/}</td><td>{@code "a b"}</td></tr>
+   * </table>
+   */
+  public String username() {
+    return username;
+  }
+
+  /**
+   * Returns the password, or an empty string if none is set.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code encodedPassword()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>{@code ""}</td></tr>
+   *   <tr><td>{@code http://username@host/}</td><td>{@code ""}</td></tr>
+   *   <tr><td>{@code http://username:password@host/}</td><td>{@code "password"}</td></tr>
+   *   <tr><td>{@code http://a%20b:c%20d@host/}</td><td>{@code "c%20d"}</td></tr>
+   * </table>
+   */
+  public String encodedPassword() {
+    if (password.isEmpty()) return "";
+    int passwordStart = url.indexOf(':', scheme.length() + 3) + 1;
+    int passwordEnd = url.indexOf('@');
+    return url.substring(passwordStart, passwordEnd);
+  }
+
+  /**
+   * Returns the decoded password, or an empty string if none is present.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code password()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>{@code ""}</td></tr>
+   *   <tr><td>{@code http://username@host/}</td><td>{@code ""}</td></tr>
+   *   <tr><td>{@code http://username:password@host/}</td><td>{@code "password"}</td></tr>
+   *   <tr><td>{@code http://a%20b:c%20d@host/}</td><td>{@code "c d"}</td></tr>
+   * </table>
+   */
+  public String password() {
+    return password;
+  }
+
+  /**
+   * Returns the host address suitable for use with {@link InetAddress#getAllByName(String)}. May
+   * be:
+   *
+   * <ul>
+   *   <li>A regular host name, like {@code android.com}.
+   *   <li>An IPv4 address, like {@code 127.0.0.1}.
+   *   <li>An IPv6 address, like {@code ::1}. Note that there are no square braces.
+   *   <li>An encoded IDN, like {@code xn--n3h.net}.
+   * </ul>
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code host()}</th></tr>
+   *   <tr><td>{@code http://android.com/}</td><td>{@code "android.com"}</td></tr>
+   *   <tr><td>{@code http://127.0.0.1/}</td><td>{@code "127.0.0.1"}</td></tr>
+   *   <tr><td>{@code http://[::1]/}</td><td>{@code "::1"}</td></tr>
+   *   <tr><td>{@code http://xn--n3h.net/}</td><td>{@code "xn--n3h.net"}</td></tr>
+   * </table>
+   */
+  public String host() {
+    return host;
+  }
+
+  /**
+   * Returns the explicitly-specified port if one was provided, or the default port for this URL's
+   * scheme. For example, this returns 8443 for {@code https://square.com:8443/} and 443 for {@code
+   * https://square.com/}. The result is in {@code [1..65535]}.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code port()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>{@code 80}</td></tr>
+   *   <tr><td>{@code http://host:8000/}</td><td>{@code 8000}</td></tr>
+   *   <tr><td>{@code https://host/}</td><td>{@code 443}</td></tr>
+   * </table>
+   */
+  public int port() {
+    return port;
+  }
+
+  /**
+   * Returns 80 if {@code scheme.equals("http")}, 443 if {@code scheme.equals("https")} and -1
+   * otherwise.
+   */
+  public static int defaultPort(String scheme) {
+    if (scheme.equals("http")) {
+      return 80;
+    } else if (scheme.equals("https")) {
+      return 443;
+    } else {
+      return -1;
+    }
+  }
+
+  /**
+   * Returns the number of segments in this URL's path. This is also the number of slashes in the
+   * URL's path, like 3 in {@code http://host/a/b/c}. This is always at least 1.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code pathSize()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>{@code 1}</td></tr>
+   *   <tr><td>{@code http://host/a/b/c}</td><td>{@code 3}</td></tr>
+   *   <tr><td>{@code http://host/a/b/c/}</td><td>{@code 4}</td></tr>
+   * </table>
+   */
+  public int pathSize() {
+    return pathSegments.size();
+  }
+
+  /**
+   * Returns the entire path of this URL encoded for use in HTTP resource resolution. The returned
+   * path will start with {@code "/"}.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code encodedPath()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>{@code "/"}</td></tr>
+   *   <tr><td>{@code http://host/a/b/c}</td><td>{@code "/a/b/c"}</td></tr>
+   *   <tr><td>{@code http://host/a/b%20c/d}</td><td>{@code "/a/b%20c/d"}</td></tr>
+   * </table>
+   */
+  public String encodedPath() {
+    int pathStart = url.indexOf('/', scheme.length() + 3); // "://".length() == 3.
+    int pathEnd = delimiterOffset(url, pathStart, url.length(), "?#");
+    return url.substring(pathStart, pathEnd);
+  }
+
+  static void pathSegmentsToString(StringBuilder out, List<String> pathSegments) {
+    for (int i = 0, size = pathSegments.size(); i < size; i++) {
+      out.append('/');
+      out.append(pathSegments.get(i));
+    }
+  }
+
+  /**
+   * Returns a list of encoded path segments like {@code ["a", "b", "c"]} for the URL {@code
+   * http://host/a/b/c}. This list is never empty though it may contain a single empty string.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code encodedPathSegments()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>{@code [""]}</td></tr>
+   *   <tr><td>{@code http://host/a/b/c}</td><td>{@code ["a", "b", "c"]}</td></tr>
+   *   <tr><td>{@code http://host/a/b%20c/d}</td><td>{@code ["a", "b%20c", "d"]}</td></tr>
+   * </table>
+   */
+  public List<String> encodedPathSegments() {
+    int pathStart = url.indexOf('/', scheme.length() + 3);
+    int pathEnd = delimiterOffset(url, pathStart, url.length(), "?#");
+    List<String> result = new ArrayList<>();
+    for (int i = pathStart; i < pathEnd; ) {
+      i++; // Skip the '/'.
+      int segmentEnd = delimiterOffset(url, i, pathEnd, '/');
+      result.add(url.substring(i, segmentEnd));
+      i = segmentEnd;
+    }
+    return result;
+  }
+
+  /**
+   * Returns a list of path segments like {@code ["a", "b", "c"]} for the URL {@code
+   * http://host/a/b/c}. This list is never empty though it may contain a single empty string.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code pathSegments()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>{@code [""]}</td></tr>
+   *   <tr><td>{@code http://host/a/b/c"}</td><td>{@code ["a", "b", "c"]}</td></tr>
+   *   <tr><td>{@code http://host/a/b%20c/d"}</td><td>{@code ["a", "b c", "d"]}</td></tr>
+   * </table>
+   */
+  public List<String> pathSegments() {
+    return pathSegments;
+  }
+
+  /**
+   * Returns the query of this URL, encoded for use in HTTP resource resolution. The returned string
+   * may be null (for URLs with no query), empty (for URLs with an empty query) or non-empty (all
+   * other URLs).
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code encodedQuery()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>null</td></tr>
+   *   <tr><td>{@code http://host/?}</td><td>{@code ""}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&k=key+lime}</td><td>{@code
+   *       "a=apple&k=key+lime"}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&a=apricot}</td><td>{@code "a=apple&a=apricot"}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code "a=apple&b"}</td></tr>
+   * </table>
+   */
+  public @Nullable String encodedQuery() {
+    if (queryNamesAndValues == null) return null; // No query.
+    int queryStart = url.indexOf('?') + 1;
+    int queryEnd = delimiterOffset(url, queryStart, url.length(), '#');
+    return url.substring(queryStart, queryEnd);
+  }
+
+  static void namesAndValuesToQueryString(StringBuilder out, List<String> namesAndValues) {
+    for (int i = 0, size = namesAndValues.size(); i < size; i += 2) {
+      String name = namesAndValues.get(i);
+      String value = namesAndValues.get(i + 1);
+      if (i > 0) out.append('&');
+      out.append(name);
+      if (value != null) {
+        out.append('=');
+        out.append(value);
+      }
+    }
+  }
+
+  /**
+   * Cuts {@code encodedQuery} up into alternating parameter names and values. This divides a query
+   * string like {@code subject=math&easy&problem=5-2=3} into the list {@code ["subject", "math",
+   * "easy", null, "problem", "5-2=3"]}. Note that values may be null and may contain '='
+   * characters.
+   */
+  static List<String> queryStringToNamesAndValues(String encodedQuery) {
+    List<String> result = new ArrayList<>();
+    for (int pos = 0; pos <= encodedQuery.length(); ) {
+      int ampersandOffset = encodedQuery.indexOf('&', pos);
+      if (ampersandOffset == -1) ampersandOffset = encodedQuery.length();
+
+      int equalsOffset = encodedQuery.indexOf('=', pos);
+      if (equalsOffset == -1 || equalsOffset > ampersandOffset) {
+        result.add(encodedQuery.substring(pos, ampersandOffset));
+        result.add(null); // No value for this name.
+      } else {
+        result.add(encodedQuery.substring(pos, equalsOffset));
+        result.add(encodedQuery.substring(equalsOffset + 1, ampersandOffset));
+      }
+      pos = ampersandOffset + 1;
+    }
+    return result;
+  }
+
+  /**
+   * Returns this URL's query, like {@code "abc"} for {@code http://host/?abc}. Most callers should
+   * prefer {@link #queryParameterName} and {@link #queryParameterValue} because these methods offer
+   * direct access to individual query parameters.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code query()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>null</td></tr>
+   *   <tr><td>{@code http://host/?}</td><td>{@code ""}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&k=key+lime}</td><td>{@code "a=apple&k=key
+   *       lime"}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&a=apricot}</td><td>{@code "a=apple&a=apricot"}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code "a=apple&b"}</td></tr>
+   * </table>
+   */
+  public @Nullable String query() {
+    if (queryNamesAndValues == null) return null; // No query.
+    StringBuilder result = new StringBuilder();
+    namesAndValuesToQueryString(result, queryNamesAndValues);
+    return result.toString();
+  }
+
+  /**
+   * Returns the number of query parameters in this URL, like 2 for {@code
+   * http://host/?a=apple&b=banana}. If this URL has no query this returns 0. Otherwise it returns
+   * one more than the number of {@code "&"} separators in the query.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code querySize()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>{@code 0}</td></tr>
+   *   <tr><td>{@code http://host/?}</td><td>{@code 1}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&k=key+lime}</td><td>{@code 2}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&a=apricot}</td><td>{@code 2}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code 2}</td></tr>
+   * </table>
+   */
+  public int querySize() {
+    return queryNamesAndValues != null ? queryNamesAndValues.size() / 2 : 0;
+  }
+
+  /**
+   * Returns the first query parameter named {@code name} decoded using UTF-8, or null if there is
+   * no such query parameter.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code queryParameter("a")}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>null</td></tr>
+   *   <tr><td>{@code http://host/?}</td><td>null</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&k=key+lime}</td><td>{@code "apple"}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&a=apricot}</td><td>{@code "apple"}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code "apple"}</td></tr>
+   * </table>
+   */
+  public @Nullable String queryParameter(String name) {
+    if (queryNamesAndValues == null) return null;
+    for (int i = 0, size = queryNamesAndValues.size(); i < size; i += 2) {
+      if (name.equals(queryNamesAndValues.get(i))) {
+        return queryNamesAndValues.get(i + 1);
+      }
+    }
+    return null;
+  }
+
+  /**
+   * Returns the distinct query parameter names in this URL, like {@code ["a", "b"]} for {@code
+   * http://host/?a=apple&b=banana}. If this URL has no query this returns the empty set.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code queryParameterNames()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>{@code []}</td></tr>
+   *   <tr><td>{@code http://host/?}</td><td>{@code [""]}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&k=key+lime}</td><td>{@code ["a", "k"]}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&a=apricot}</td><td>{@code ["a"]}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code ["a", "b"]}</td></tr>
+   * </table>
+   */
+  public Set<String> queryParameterNames() {
+    if (queryNamesAndValues == null) return Collections.emptySet();
+    Set<String> result = new LinkedHashSet<>();
+    for (int i = 0, size = queryNamesAndValues.size(); i < size; i += 2) {
+      result.add(queryNamesAndValues.get(i));
+    }
+    return Collections.unmodifiableSet(result);
+  }
+
+  /**
+   * Returns all values for the query parameter {@code name} ordered by their appearance in this
+   * URL. For example this returns {@code ["banana"]} for {@code queryParameterValue("b")} on {@code
+   * http://host/?a=apple&b=banana}.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code queryParameterValues("a")}</th><th>{@code
+   *       queryParameterValues("b")}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>{@code []}</td><td>{@code []}</td></tr>
+   *   <tr><td>{@code http://host/?}</td><td>{@code []}</td><td>{@code []}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&k=key+lime}</td><td>{@code ["apple"]}</td><td>{@code
+   *       []}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&a=apricot}</td><td>{@code ["apple",
+   *       "apricot"]}</td><td>{@code []}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code ["apple"]}</td><td>{@code
+   *       [null]}</td></tr>
+   * </table>
+   */
+  public List<String> queryParameterValues(String name) {
+    if (queryNamesAndValues == null) return Collections.emptyList();
+    List<String> result = new ArrayList<>();
+    for (int i = 0, size = queryNamesAndValues.size(); i < size; i += 2) {
+      if (name.equals(queryNamesAndValues.get(i))) {
+        result.add(queryNamesAndValues.get(i + 1));
+      }
+    }
+    return Collections.unmodifiableList(result);
+  }
+
+  /**
+   * Returns the name of the query parameter at {@code index}. For example this returns {@code "a"}
+   * for {@code queryParameterName(0)} on {@code http://host/?a=apple&b=banana}. This throws if
+   * {@code index} is not less than the {@linkplain #querySize query size}.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code queryParameterName(0)}</th><th>{@code
+   *       queryParameterName(1)}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>exception</td><td>exception</td></tr>
+   *   <tr><td>{@code http://host/?}</td><td>{@code ""}</td><td>exception</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&k=key+lime}</td><td>{@code "a"}</td><td>{@code
+   *       "k"}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&a=apricot}</td><td>{@code "a"}</td><td>{@code
+   *       "a"}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code "a"}</td><td>{@code "b"}</td></tr>
+   * </table>
+   */
+  public String queryParameterName(int index) {
+    if (queryNamesAndValues == null) throw new IndexOutOfBoundsException();
+    return queryNamesAndValues.get(index * 2);
+  }
+
+  /**
+   * Returns the value of the query parameter at {@code index}. For example this returns {@code
+   * "apple"} for {@code queryParameterName(0)} on {@code http://host/?a=apple&b=banana}. This
+   * throws if {@code index} is not less than the {@linkplain #querySize query size}.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code queryParameterValue(0)}</th><th>{@code
+   *       queryParameterValue(1)}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>exception</td><td>exception</td></tr>
+   *   <tr><td>{@code http://host/?}</td><td>null</td><td>exception</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&k=key+lime}</td><td>{@code "apple"}</td><td>{@code
+   *       "key lime"}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&a=apricot}</td><td>{@code "apple"}</td><td>{@code
+   *       "apricot"}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code "apple"}</td><td>null</td></tr>
+   * </table>
+   */
+  public String queryParameterValue(int index) {
+    if (queryNamesAndValues == null) throw new IndexOutOfBoundsException();
+    return queryNamesAndValues.get(index * 2 + 1);
+  }
+
+  /**
+   * Returns this URL's encoded fragment, like {@code "abc"} for {@code http://host/#abc}. This
+   * returns null if the URL has no fragment.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code encodedFragment()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>null</td></tr>
+   *   <tr><td>{@code http://host/#}</td><td>{@code ""}</td></tr>
+   *   <tr><td>{@code http://host/#abc}</td><td>{@code "abc"}</td></tr>
+   *   <tr><td>{@code http://host/#abc|def}</td><td>{@code "abc|def"}</td></tr>
+   * </table>
+   */
+  public @Nullable String encodedFragment() {
+    if (fragment == null) return null;
+    int fragmentStart = url.indexOf('#') + 1;
+    return url.substring(fragmentStart);
+  }
+
+  /**
+   * Returns this URL's fragment, like {@code "abc"} for {@code http://host/#abc}. This returns null
+   * if the URL has no fragment.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code fragment()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>null</td></tr>
+   *   <tr><td>{@code http://host/#}</td><td>{@code ""}</td></tr>
+   *   <tr><td>{@code http://host/#abc}</td><td>{@code "abc"}</td></tr>
+   *   <tr><td>{@code http://host/#abc|def}</td><td>{@code "abc|def"}</td></tr>
+   * </table>
+   */
+  public @Nullable String fragment() {
+    return fragment;
+  }
+
+  /**
+   * Returns a string with containing this URL with its username, password, query, and fragment
+   * stripped, and its path replaced with {@code /...}. For example, redacting {@code
+   * http://username:password@example.com/path} returns {@code http://example.com/...}.
+   */
+  public String redact() {
+    return newBuilder("/...")
+        .username("")
+        .password("")
+        .build()
+        .toString();
+  }
+
+  /**
+   * Returns the URL that would be retrieved by following {@code link} from this URL, or null if
+   * the resulting URL is not well-formed.
+   */
+  public @Nullable HttpUrl resolve(String link) {
+    Builder builder = newBuilder(link);
+    return builder != null ? builder.build() : null;
+  }
+
+  public Builder newBuilder() {
+    Builder result = new Builder();
+    result.scheme = scheme;
+    result.encodedUsername = encodedUsername();
+    result.encodedPassword = encodedPassword();
+    result.host = host;
+    // If we're set to a default port, unset it in case of a scheme change.
+    result.port = port != defaultPort(scheme) ? port : -1;
+    result.encodedPathSegments.clear();
+    result.encodedPathSegments.addAll(encodedPathSegments());
+    result.encodedQuery(encodedQuery());
+    result.encodedFragment = encodedFragment();
+    return result;
+  }
+
+  /**
+   * Returns a builder for the URL that would be retrieved by following {@code link} from this URL,
+   * or null if the resulting URL is not well-formed.
+   */
+  public @Nullable Builder newBuilder(String link) {
+    Builder builder = new Builder();
+    Builder.ParseResult result = builder.parse(this, link);
+    return result == Builder.ParseResult.SUCCESS ? builder : null;
+  }
+
+  /**
+   * Returns a new {@code HttpUrl} representing {@code url} if it is a well-formed HTTP or HTTPS
+   * URL, or null if it isn't.
+   */
+  public static @Nullable HttpUrl parse(String url) {
+    Builder builder = new Builder();
+    Builder.ParseResult result = builder.parse(null, url);
+    return result == Builder.ParseResult.SUCCESS ? builder.build() : null;
+  }
+
+  /**
+   * Returns an {@link HttpUrl} for {@code url} if its protocol is {@code http} or {@code https}, or
+   * null if it has any other protocol.
+   */
+  public static @Nullable HttpUrl get(URL url) {
+    return parse(url.toString());
+  }
+
+  /**
+   * Returns a new {@code HttpUrl} representing {@code url} if it is a well-formed HTTP or HTTPS
+   * URL, or throws an exception if it isn't.
+   *
+   * @throws MalformedURLException if there was a non-host related URL issue
+   * @throws UnknownHostException if the host was invalid
+   */
+  static HttpUrl getChecked(String url) throws MalformedURLException, UnknownHostException {
+    Builder builder = new Builder();
+    Builder.ParseResult result = builder.parse(null, url);
+    switch (result) {
+      case SUCCESS:
+        return builder.build();
+      case INVALID_HOST:
+        throw new UnknownHostException("Invalid host: " + url);
+      case UNSUPPORTED_SCHEME:
+      case MISSING_SCHEME:
+      case INVALID_PORT:
+      default:
+        throw new MalformedURLException("Invalid URL: " + result + " for " + url);
+    }
+  }
+
+  public static @Nullable HttpUrl get(URI uri) {
+    return parse(uri.toString());
+  }
+
+  @Override public boolean equals(@Nullable Object other) {
+    return other instanceof HttpUrl && ((HttpUrl) other).url.equals(url);
+  }
+
+  @Override public int hashCode() {
+    return url.hashCode();
+  }
+
+  @Override public String toString() {
+    return url;
+  }
+
+  /**
+   * Returns the domain name of this URL's {@link #host()} that is one level beneath the public
+   * suffix by consulting the <a href="https://publicsuffix.org">public suffix list</a>. Returns
+   * null if this URL's {@link #host()} is an IP address or is considered a public suffix by the
+   * public suffix list.
+   *
+   * <p>In general this method <strong>should not</strong> be used to test whether a domain is valid
+   * or routable. Instead, DNS is the recommended source for that information.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code topPrivateDomain()}</th></tr>
+   *   <tr><td>{@code http://google.com}</td><td>{@code "google.com"}</td></tr>
+   *   <tr><td>{@code http://adwords.google.co.uk}</td><td>{@code "google.co.uk"}</td></tr>
+   *   <tr><td>{@code http://square}</td><td>null</td></tr>
+   *   <tr><td>{@code http://co.uk}</td><td>null</td></tr>
+   *   <tr><td>{@code http://localhost}</td><td>null</td></tr>
+   *   <tr><td>{@code http://127.0.0.1}</td><td>null</td></tr>
+   * </table>
+   */
+  public @Nullable String topPrivateDomain() {
+    if (verifyAsIpAddress(host)) return null;
+    return PublicSuffixDatabase.get().getEffectiveTldPlusOne(host);
+  }
+
+  public static final class Builder {
+    @Nullable String scheme;
+    String encodedUsername = "";
+    String encodedPassword = "";
+    @Nullable String host;
+    int port = -1;
+    final List<String> encodedPathSegments = new ArrayList<>();
+    @Nullable List<String> encodedQueryNamesAndValues;
+    @Nullable String encodedFragment;
+
+    public Builder() {
+      encodedPathSegments.add(""); // The default path is '/' which needs a trailing space.
+    }
+
+    public Builder scheme(String scheme) {
+      if (scheme == null) {
+        throw new NullPointerException("scheme == null");
+      } else if (scheme.equalsIgnoreCase("http")) {
+        this.scheme = "http";
+      } else if (scheme.equalsIgnoreCase("https")) {
+        this.scheme = "https";
+      } else {
+        throw new IllegalArgumentException("unexpected scheme: " + scheme);
+      }
+      return this;
+    }
+
+    public Builder username(String username) {
+      if (username == null) throw new NullPointerException("username == null");
+      this.encodedUsername = canonicalize(username, USERNAME_ENCODE_SET, false, false, false, true);
+      return this;
+    }
+
+    public Builder encodedUsername(String encodedUsername) {
+      if (encodedUsername == null) throw new NullPointerException("encodedUsername == null");
+      this.encodedUsername = canonicalize(
+          encodedUsername, USERNAME_ENCODE_SET, true, false, false, true);
+      return this;
+    }
+
+    public Builder password(String password) {
+      if (password == null) throw new NullPointerException("password == null");
+      this.encodedPassword = canonicalize(password, PASSWORD_ENCODE_SET, false, false, false, true);
+      return this;
+    }
+
+    public Builder encodedPassword(String encodedPassword) {
+      if (encodedPassword == null) throw new NullPointerException("encodedPassword == null");
+      this.encodedPassword = canonicalize(
+          encodedPassword, PASSWORD_ENCODE_SET, true, false, false, true);
+      return this;
+    }
+
+    /**
+     * @param host either a regular hostname, International Domain Name, IPv4 address, or IPv6
+     * address.
+     */
+    public Builder host(String host) {
+      if (host == null) throw new NullPointerException("host == null");
+      String encoded = canonicalizeHost(host, 0, host.length());
+      if (encoded == null) throw new IllegalArgumentException("unexpected host: " + host);
+      this.host = encoded;
+      return this;
+    }
+
+    public Builder port(int port) {
+      if (port <= 0 || port > 65535) throw new IllegalArgumentException("unexpected port: " + port);
+      this.port = port;
+      return this;
+    }
+
+    int effectivePort() {
+      return port != -1 ? port : defaultPort(scheme);
+    }
+
+    public Builder addPathSegment(String pathSegment) {
+      if (pathSegment == null) throw new NullPointerException("pathSegment == null");
+      push(pathSegment, 0, pathSegment.length(), false, false);
+      return this;
+    }
+
+    /**
+     * Adds a set of path segments separated by a slash (either {@code \} or {@code /}). If
+     * {@code pathSegments} starts with a slash, the resulting URL will have empty path segment.
+     */
+    public Builder addPathSegments(String pathSegments) {
+      if (pathSegments == null) throw new NullPointerException("pathSegments == null");
+      return addPathSegments(pathSegments, false);
+    }
+
+    public Builder addEncodedPathSegment(String encodedPathSegment) {
+      if (encodedPathSegment == null) {
+        throw new NullPointerException("encodedPathSegment == null");
+      }
+      push(encodedPathSegment, 0, encodedPathSegment.length(), false, true);
+      return this;
+    }
+
+    /**
+     * Adds a set of encoded path segments separated by a slash (either {@code \} or {@code /}). If
+     * {@code encodedPathSegments} starts with a slash, the resulting URL will have empty path
+     * segment.
+     */
+    public Builder addEncodedPathSegments(String encodedPathSegments) {
+      if (encodedPathSegments == null) {
+        throw new NullPointerException("encodedPathSegments == null");
+      }
+      return addPathSegments(encodedPathSegments, true);
+    }
+
+    private Builder addPathSegments(String pathSegments, boolean alreadyEncoded) {
+      int offset = 0;
+      do {
+        int segmentEnd = delimiterOffset(pathSegments, offset, pathSegments.length(), "/\\");
+        boolean addTrailingSlash = segmentEnd < pathSegments.length();
+        push(pathSegments, offset, segmentEnd, addTrailingSlash, alreadyEncoded);
+        offset = segmentEnd + 1;
+      } while (offset <= pathSegments.length());
+      return this;
+    }
+
+    public Builder setPathSegment(int index, String pathSegment) {
+      if (pathSegment == null) throw new NullPointerException("pathSegment == null");
+      String canonicalPathSegment = canonicalize(
+          pathSegment, 0, pathSegment.length(), PATH_SEGMENT_ENCODE_SET, false, false, false, true,
+              null);
+      if (isDot(canonicalPathSegment) || isDotDot(canonicalPathSegment)) {
+        throw new IllegalArgumentException("unexpected path segment: " + pathSegment);
+      }
+      encodedPathSegments.set(index, canonicalPathSegment);
+      return this;
+    }
+
+    public Builder setEncodedPathSegment(int index, String encodedPathSegment) {
+      if (encodedPathSegment == null) {
+        throw new NullPointerException("encodedPathSegment == null");
+      }
+      String canonicalPathSegment = canonicalize(encodedPathSegment,
+          0, encodedPathSegment.length(), PATH_SEGMENT_ENCODE_SET, true, false, false, true,
+          null);
+      encodedPathSegments.set(index, canonicalPathSegment);
+      if (isDot(canonicalPathSegment) || isDotDot(canonicalPathSegment)) {
+        throw new IllegalArgumentException("unexpected path segment: " + encodedPathSegment);
+      }
+      return this;
+    }
+
+    public Builder removePathSegment(int index) {
+      encodedPathSegments.remove(index);
+      if (encodedPathSegments.isEmpty()) {
+        encodedPathSegments.add(""); // Always leave at least one '/'.
+      }
+      return this;
+    }
+
+    public Builder encodedPath(String encodedPath) {
+      if (encodedPath == null) throw new NullPointerException("encodedPath == null");
+      if (!encodedPath.startsWith("/")) {
+        throw new IllegalArgumentException("unexpected encodedPath: " + encodedPath);
+      }
+      resolvePath(encodedPath, 0, encodedPath.length());
+      return this;
+    }
+
+    public Builder query(@Nullable String query) {
+      this.encodedQueryNamesAndValues = query != null
+          ? queryStringToNamesAndValues(canonicalize(
+          query, QUERY_ENCODE_SET, false, false, true, true))
+          : null;
+      return this;
+    }
+
+    public Builder encodedQuery(@Nullable String encodedQuery) {
+      this.encodedQueryNamesAndValues = encodedQuery != null
+          ? queryStringToNamesAndValues(
+          canonicalize(encodedQuery, QUERY_ENCODE_SET, true, false, true, true))
+          : null;
+      return this;
+    }
+
+    /** Encodes the query parameter using UTF-8 and adds it to this URL's query string. */
+    public Builder addQueryParameter(String name, @Nullable String value) {
+      if (name == null) throw new NullPointerException("name == null");
+      if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = new ArrayList<>();
+      encodedQueryNamesAndValues.add(
+          canonicalize(name, QUERY_COMPONENT_ENCODE_SET, false, false, true, true));
+      encodedQueryNamesAndValues.add(value != null
+          ? canonicalize(value, QUERY_COMPONENT_ENCODE_SET, false, false, true, true)
+          : null);
+      return this;
+    }
+
+    /** Adds the pre-encoded query parameter to this URL's query string. */
+    public Builder addEncodedQueryParameter(String encodedName, @Nullable String encodedValue) {
+      if (encodedName == null) throw new NullPointerException("encodedName == null");
+      if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = new ArrayList<>();
+      encodedQueryNamesAndValues.add(
+          canonicalize(encodedName, QUERY_COMPONENT_ENCODE_SET, true, false, true, true));
+      encodedQueryNamesAndValues.add(encodedValue != null
+          ? canonicalize(encodedValue, QUERY_COMPONENT_ENCODE_SET, true, false, true, true)
+          : null);
+      return this;
+    }
+
+    public Builder setQueryParameter(String name, @Nullable String value) {
+      removeAllQueryParameters(name);
+      addQueryParameter(name, value);
+      return this;
+    }
+
+    public Builder setEncodedQueryParameter(String encodedName, @Nullable String encodedValue) {
+      removeAllEncodedQueryParameters(encodedName);
+      addEncodedQueryParameter(encodedName, encodedValue);
+      return this;
+    }
+
+    public Builder removeAllQueryParameters(String name) {
+      if (name == null) throw new NullPointerException("name == null");
+      if (encodedQueryNamesAndValues == null) return this;
+      String nameToRemove = canonicalize(
+          name, QUERY_COMPONENT_ENCODE_SET, false, false, true, true);
+      removeAllCanonicalQueryParameters(nameToRemove);
+      return this;
+    }
+
+    public Builder removeAllEncodedQueryParameters(String encodedName) {
+      if (encodedName == null) throw new NullPointerException("encodedName == null");
+      if (encodedQueryNamesAndValues == null) return this;
+      removeAllCanonicalQueryParameters(
+          canonicalize(encodedName, QUERY_COMPONENT_ENCODE_SET, true, false, true, true));
+      return this;
+    }
+
+    private void removeAllCanonicalQueryParameters(String canonicalName) {
+      for (int i = encodedQueryNamesAndValues.size() - 2; i >= 0; i -= 2) {
+        if (canonicalName.equals(encodedQueryNamesAndValues.get(i))) {
+          encodedQueryNamesAndValues.remove(i + 1);
+          encodedQueryNamesAndValues.remove(i);
+          if (encodedQueryNamesAndValues.isEmpty()) {
+            encodedQueryNamesAndValues = null;
+            return;
+          }
+        }
+      }
+    }
+
+    public Builder fragment(@Nullable String fragment) {
+      this.encodedFragment = fragment != null
+          ? canonicalize(fragment, FRAGMENT_ENCODE_SET, false, false, false, false)
+          : null;
+      return this;
+    }
+
+    public Builder encodedFragment(@Nullable String encodedFragment) {
+      this.encodedFragment = encodedFragment != null
+          ? canonicalize(encodedFragment, FRAGMENT_ENCODE_SET, true, false, false, false)
+          : null;
+      return this;
+    }
+
+    /**
+     * Re-encodes the components of this URL so that it satisfies (obsolete) RFC 2396, which is
+     * particularly strict for certain components.
+     */
+    Builder reencodeForUri() {
+      for (int i = 0, size = encodedPathSegments.size(); i < size; i++) {
+        String pathSegment = encodedPathSegments.get(i);
+        encodedPathSegments.set(i,
+            canonicalize(pathSegment, PATH_SEGMENT_ENCODE_SET_URI, true, true, false, true));
+      }
+      if (encodedQueryNamesAndValues != null) {
+        for (int i = 0, size = encodedQueryNamesAndValues.size(); i < size; i++) {
+          String component = encodedQueryNamesAndValues.get(i);
+          if (component != null) {
+            encodedQueryNamesAndValues.set(i,
+                canonicalize(component, QUERY_COMPONENT_ENCODE_SET_URI, true, true, true, true));
+          }
+        }
+      }
+      if (encodedFragment != null) {
+        encodedFragment = canonicalize(
+            encodedFragment, FRAGMENT_ENCODE_SET_URI, true, true, false, false);
+      }
+      return this;
+    }
+
+    public HttpUrl build() {
+      if (scheme == null) throw new IllegalStateException("scheme == null");
+      if (host == null) throw new IllegalStateException("host == null");
+      return new HttpUrl(this);
+    }
+
+    @Override public String toString() {
+      StringBuilder result = new StringBuilder();
+      result.append(scheme);
+      result.append("://");
+
+      if (!encodedUsername.isEmpty() || !encodedPassword.isEmpty()) {
+        result.append(encodedUsername);
+        if (!encodedPassword.isEmpty()) {
+          result.append(':');
+          result.append(encodedPassword);
+        }
+        result.append('@');
+      }
+
+      if (host.indexOf(':') != -1) {
+        // Host is an IPv6 address.
+        result.append('[');
+        result.append(host);
+        result.append(']');
+      } else {
+        result.append(host);
+      }
+
+      int effectivePort = effectivePort();
+      if (effectivePort != defaultPort(scheme)) {
+        result.append(':');
+        result.append(effectivePort);
+      }
+
+      pathSegmentsToString(result, encodedPathSegments);
+
+      if (encodedQueryNamesAndValues != null) {
+        result.append('?');
+        namesAndValuesToQueryString(result, encodedQueryNamesAndValues);
+      }
+
+      if (encodedFragment != null) {
+        result.append('#');
+        result.append(encodedFragment);
+      }
+
+      return result.toString();
+    }
+
+    enum ParseResult {
+      SUCCESS,
+      MISSING_SCHEME,
+      UNSUPPORTED_SCHEME,
+      INVALID_PORT,
+      INVALID_HOST,
+    }
+
+    ParseResult parse(@Nullable HttpUrl base, String input) {
+      int pos = skipLeadingAsciiWhitespace(input, 0, input.length());
+      int limit = skipTrailingAsciiWhitespace(input, pos, input.length());
+
+      // Scheme.
+      int schemeDelimiterOffset = schemeDelimiterOffset(input, pos, limit);
+      if (schemeDelimiterOffset != -1) {
+        if (input.regionMatches(true, pos, "https:", 0, 6)) {
+          this.scheme = "https";
+          pos += "https:".length();
+        } else if (input.regionMatches(true, pos, "http:", 0, 5)) {
+          this.scheme = "http";
+          pos += "http:".length();
+        } else {
+          return ParseResult.UNSUPPORTED_SCHEME; // Not an HTTP scheme.
+        }
+      } else if (base != null) {
+        this.scheme = base.scheme;
+      } else {
+        return ParseResult.MISSING_SCHEME; // No scheme.
+      }
+
+      // Authority.
+      boolean hasUsername = false;
+      boolean hasPassword = false;
+      int slashCount = slashCount(input, pos, limit);
+      if (slashCount >= 2 || base == null || !base.scheme.equals(this.scheme)) {
+        // Read an authority if either:
+        //  * The input starts with 2 or more slashes. These follow the scheme if it exists.
+        //  * The input scheme exists and is different from the base URL's scheme.
+        //
+        // The structure of an authority is:
+        //   username:password@host:port
+        //
+        // Username, password and port are optional.
+        //   [username[:password]@]host[:port]
+        pos += slashCount;
+        authority:
+        while (true) {
+          int componentDelimiterOffset = delimiterOffset(input, pos, limit, "@/\\?#");
+          int c = componentDelimiterOffset != limit
+              ? input.charAt(componentDelimiterOffset)
+              : -1;
+          switch (c) {
+            case '@':
+              // User info precedes.
+              if (!hasPassword) {
+                int passwordColonOffset = delimiterOffset(
+                    input, pos, componentDelimiterOffset, ':');
+                String canonicalUsername = canonicalize(
+                    input, pos, passwordColonOffset, USERNAME_ENCODE_SET, true, false, false, true,
+                    null);
+                this.encodedUsername = hasUsername
+                    ? this.encodedUsername + "%40" + canonicalUsername
+                    : canonicalUsername;
+                if (passwordColonOffset != componentDelimiterOffset) {
+                  hasPassword = true;
+                  this.encodedPassword = canonicalize(input, passwordColonOffset + 1,
+                      componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false, false, true,
+                      null);
+                }
+                hasUsername = true;
+              } else {
+                this.encodedPassword = this.encodedPassword + "%40" + canonicalize(input, pos,
+                    componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false, false, true,
+                    null);
+              }
+              pos = componentDelimiterOffset + 1;
+              break;
+
+            case -1:
+            case '/':
+            case '\\':
+            case '?':
+            case '#':
+              // Host info precedes.
+              int portColonOffset = portColonOffset(input, pos, componentDelimiterOffset);
+              if (portColonOffset + 1 < componentDelimiterOffset) {
+                this.host = canonicalizeHost(input, pos, portColonOffset);
+                this.port = parsePort(input, portColonOffset + 1, componentDelimiterOffset);
+                if (this.port == -1) return ParseResult.INVALID_PORT; // Invalid port.
+              } else {
+                this.host = canonicalizeHost(input, pos, portColonOffset);
+                this.port = defaultPort(this.scheme);
+              }
+              if (this.host == null) return ParseResult.INVALID_HOST; // Invalid host.
+              pos = componentDelimiterOffset;
+              break authority;
+          }
+        }
+      } else {
+        // This is a relative link. Copy over all authority components. Also maybe the path & query.
+        this.encodedUsername = base.encodedUsername();
+        this.encodedPassword = base.encodedPassword();
+        this.host = base.host;
+        this.port = base.port;
+        this.encodedPathSegments.clear();
+        this.encodedPathSegments.addAll(base.encodedPathSegments());
+        if (pos == limit || input.charAt(pos) == '#') {
+          encodedQuery(base.encodedQuery());
+        }
+      }
+
+      // Resolve the relative path.
+      int pathDelimiterOffset = delimiterOffset(input, pos, limit, "?#");
+      resolvePath(input, pos, pathDelimiterOffset);
+      pos = pathDelimiterOffset;
+
+      // Query.
+      if (pos < limit && input.charAt(pos) == '?') {
+        int queryDelimiterOffset = delimiterOffset(input, pos, limit, '#');
+        this.encodedQueryNamesAndValues = queryStringToNamesAndValues(canonicalize(
+            input, pos + 1, queryDelimiterOffset, QUERY_ENCODE_SET, true, false, true, true, null));
+        pos = queryDelimiterOffset;
+      }
+
+      // Fragment.
+      if (pos < limit && input.charAt(pos) == '#') {
+        this.encodedFragment = canonicalize(
+            input, pos + 1, limit, FRAGMENT_ENCODE_SET, true, false, false, false, null);
+      }
+
+      return ParseResult.SUCCESS;
+    }
+
+    private void resolvePath(String input, int pos, int limit) {
+      // Read a delimiter.
+      if (pos == limit) {
+        // Empty path: keep the base path as-is.
+        return;
+      }
+      char c = input.charAt(pos);
+      if (c == '/' || c == '\\') {
+        // Absolute path: reset to the default "/".
+        encodedPathSegments.clear();
+        encodedPathSegments.add("");
+        pos++;
+      } else {
+        // Relative path: clear everything after the last '/'.
+        encodedPathSegments.set(encodedPathSegments.size() - 1, "");
+      }
+
+      // Read path segments.
+      for (int i = pos; i < limit; ) {
+        int pathSegmentDelimiterOffset = delimiterOffset(input, i, limit, "/\\");
+        boolean segmentHasTrailingSlash = pathSegmentDelimiterOffset < limit;
+        push(input, i, pathSegmentDelimiterOffset, segmentHasTrailingSlash, true);
+        i = pathSegmentDelimiterOffset;
+        if (segmentHasTrailingSlash) i++;
+      }
+    }
+
+    /** Adds a path segment. If the input is ".." or equivalent, this pops a path segment. */
+    private void push(String input, int pos, int limit, boolean addTrailingSlash,
+        boolean alreadyEncoded) {
+      String segment = canonicalize(
+          input, pos, limit, PATH_SEGMENT_ENCODE_SET, alreadyEncoded, false, false, true, null);
+      if (isDot(segment)) {
+        return; // Skip '.' path segments.
+      }
+      if (isDotDot(segment)) {
+        pop();
+        return;
+      }
+      if (encodedPathSegments.get(encodedPathSegments.size() - 1).isEmpty()) {
+        encodedPathSegments.set(encodedPathSegments.size() - 1, segment);
+      } else {
+        encodedPathSegments.add(segment);
+      }
+      if (addTrailingSlash) {
+        encodedPathSegments.add("");
+      }
+    }
+
+    private boolean isDot(String input) {
+      return input.equals(".") || input.equalsIgnoreCase("%2e");
+    }
+
+    private boolean isDotDot(String input) {
+      return input.equals("..")
+          || input.equalsIgnoreCase("%2e.")
+          || input.equalsIgnoreCase(".%2e")
+          || input.equalsIgnoreCase("%2e%2e");
+    }
+
+    /**
+     * Removes a path segment. When this method returns the last segment is always "", which means
+     * the encoded path will have a trailing '/'.
+     *
+     * <p>Popping "/a/b/c/" yields "/a/b/". In this case the list of path segments goes from ["a",
+     * "b", "c", ""] to ["a", "b", ""].
+     *
+     * <p>Popping "/a/b/c" also yields "/a/b/". The list of path segments goes from ["a", "b", "c"]
+     * to ["a", "b", ""].
+     */
+    private void pop() {
+      String removed = encodedPathSegments.remove(encodedPathSegments.size() - 1);
+
+      // Make sure the path ends with a '/' by either adding an empty string or clearing a segment.
+      if (removed.isEmpty() && !encodedPathSegments.isEmpty()) {
+        encodedPathSegments.set(encodedPathSegments.size() - 1, "");
+      } else {
+        encodedPathSegments.add("");
+      }
+    }
+
+    /**
+     * Returns the index of the ':' in {@code input} that is after scheme characters. Returns -1 if
+     * {@code input} does not have a scheme that starts at {@code pos}.
+     */
+    private static int schemeDelimiterOffset(String input, int pos, int limit) {
+      if (limit - pos < 2) return -1;
+
+      char c0 = input.charAt(pos);
+      if ((c0 < 'a' || c0 > 'z') && (c0 < 'A' || c0 > 'Z')) return -1; // Not a scheme start char.
+
+      for (int i = pos + 1; i < limit; i++) {
+        char c = input.charAt(i);
+
+        if ((c >= 'a' && c <= 'z')
+            || (c >= 'A' && c <= 'Z')
+            || (c >= '0' && c <= '9')
+            || c == '+'
+            || c == '-'
+            || c == '.') {
+          continue; // Scheme character. Keep going.
+        } else if (c == ':') {
+          return i; // Scheme prefix!
+        } else {
+          return -1; // Non-scheme character before the first ':'.
+        }
+      }
+
+      return -1; // No ':'; doesn't start with a scheme.
+    }
+
+    /** Returns the number of '/' and '\' slashes in {@code input}, starting at {@code pos}. */
+    private static int slashCount(String input, int pos, int limit) {
+      int slashCount = 0;
+      while (pos < limit) {
+        char c = input.charAt(pos);
+        if (c == '\\' || c == '/') {
+          slashCount++;
+          pos++;
+        } else {
+          break;
+        }
+      }
+      return slashCount;
+    }
+
+    /** Finds the first ':' in {@code input}, skipping characters between square braces "[...]". */
+    private static int portColonOffset(String input, int pos, int limit) {
+      for (int i = pos; i < limit; i++) {
+        switch (input.charAt(i)) {
+          case '[':
+            while (++i < limit) {
+              if (input.charAt(i) == ']') break;
+            }
+            break;
+          case ':':
+            return i;
+        }
+      }
+      return limit; // No colon.
+    }
+
+    private static String canonicalizeHost(String input, int pos, int limit) {
+      // Start by percent decoding the host. The WHATWG spec suggests doing this only after we've
+      // checked for IPv6 square braces. But Chrome does it first, and that's more lenient.
+      String percentDecoded = percentDecode(input, pos, limit, false);
+      return Util.canonicalizeHost(percentDecoded);
+    }
+
+    private static int parsePort(String input, int pos, int limit) {
+      try {
+        // Canonicalize the port string to skip '\n' etc.
+        String portString = canonicalize(input, pos, limit, "", false, false, false, true, null);
+        int i = Integer.parseInt(portString);
+        if (i > 0 && i <= 65535) return i;
+        return -1;
+      } catch (NumberFormatException e) {
+        return -1; // Invalid port.
+      }
+    }
+  }
+
+  static String percentDecode(String encoded, boolean plusIsSpace) {
+    return percentDecode(encoded, 0, encoded.length(), plusIsSpace);
+  }
+
+  private List<String> percentDecode(List<String> list, boolean plusIsSpace) {
+    int size = list.size();
+    List<String> result = new ArrayList<>(size);
+    for (int i = 0; i < size; i++) {
+      String s = list.get(i);
+      result.add(s != null ? percentDecode(s, plusIsSpace) : null);
+    }
+    return Collections.unmodifiableList(result);
+  }
+
+  static String percentDecode(String encoded, int pos, int limit, boolean plusIsSpace) {
+    for (int i = pos; i < limit; i++) {
+      char c = encoded.charAt(i);
+      if (c == '%' || (c == '+' && plusIsSpace)) {
+        // Slow path: the character at i requires decoding!
+        Buffer out = new Buffer();
+        out.writeUtf8(encoded, pos, i);
+        percentDecode(out, encoded, i, limit, plusIsSpace);
+        return out.readUtf8();
+      }
+    }
+
+    // Fast path: no characters in [pos..limit) required decoding.
+    return encoded.substring(pos, limit);
+  }
+
+  static void percentDecode(Buffer out, String encoded, int pos, int limit, boolean plusIsSpace) {
+    int codePoint;
+    for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
+      codePoint = encoded.codePointAt(i);
+      if (codePoint == '%' && i + 2 < limit) {
+        int d1 = decodeHexDigit(encoded.charAt(i + 1));
+        int d2 = decodeHexDigit(encoded.charAt(i + 2));
+        if (d1 != -1 && d2 != -1) {
+          out.writeByte((d1 << 4) + d2);
+          i += 2;
+          continue;
+        }
+      } else if (codePoint == '+' && plusIsSpace) {
+        out.writeByte(' ');
+        continue;
+      }
+      out.writeUtf8CodePoint(codePoint);
+    }
+  }
+
+  static boolean percentEncoded(String encoded, int pos, int limit) {
+    return pos + 2 < limit
+        && encoded.charAt(pos) == '%'
+        && decodeHexDigit(encoded.charAt(pos + 1)) != -1
+        && decodeHexDigit(encoded.charAt(pos + 2)) != -1;
+  }
+
+  /**
+   * Returns a substring of {@code input} on the range {@code [pos..limit)} with the following
+   * transformations:
+   * <ul>
+   *   <li>Tabs, newlines, form feeds and carriage returns are skipped.
+   *   <li>In queries, ' ' is encoded to '+' and '+' is encoded to "%2B".
+   *   <li>Characters in {@code encodeSet} are percent-encoded.
+   *   <li>Control characters and non-ASCII characters are percent-encoded.
+   *   <li>All other characters are copied without transformation.
+   * </ul>
+   *
+   * @param alreadyEncoded true to leave '%' as-is; false to convert it to '%25'.
+   * @param strict true to encode '%' if it is not the prefix of a valid percent encoding.
+   * @param plusIsSpace true to encode '+' as "%2B" if it is not already encoded.
+   * @param asciiOnly true to encode all non-ASCII codepoints.
+   * @param charset which charset to use, null equals UTF-8.
+   */
+  static String canonicalize(String input, int pos, int limit, String encodeSet,
+      boolean alreadyEncoded, boolean strict, boolean plusIsSpace, boolean asciiOnly,
+      Charset charset) {
+    int codePoint;
+    for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
+      codePoint = input.codePointAt(i);
+      if (codePoint < 0x20
+          || codePoint == 0x7f
+          || codePoint >= 0x80 && asciiOnly
+          || encodeSet.indexOf(codePoint) != -1
+          || codePoint == '%' && (!alreadyEncoded || strict && !percentEncoded(input, i, limit))
+          || codePoint == '+' && plusIsSpace) {
+        // Slow path: the character at i requires encoding!
+        Buffer out = new Buffer();
+        out.writeUtf8(input, pos, i);
+        canonicalize(out, input, i, limit, encodeSet, alreadyEncoded, strict, plusIsSpace,
+            asciiOnly, charset);
+        return out.readUtf8();
+      }
+    }
+
+    // Fast path: no characters in [pos..limit) required encoding.
+    return input.substring(pos, limit);
+  }
+
+  static void canonicalize(Buffer out, String input, int pos, int limit, String encodeSet,
+      boolean alreadyEncoded, boolean strict, boolean plusIsSpace, boolean asciiOnly,
+      Charset charset) {
+    Buffer encodedCharBuffer = null; // Lazily allocated.
+    int codePoint;
+    for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
+      codePoint = input.codePointAt(i);
+      if (alreadyEncoded
+          && (codePoint == '\t' || codePoint == '\n' || codePoint == '\f' || codePoint == '\r')) {
+        // Skip this character.
+      } else if (codePoint == '+' && plusIsSpace) {
+        // Encode '+' as '%2B' since we permit ' ' to be encoded as either '+' or '%20'.
+        out.writeUtf8(alreadyEncoded ? "+" : "%2B");
+      } else if (codePoint < 0x20
+          || codePoint == 0x7f
+          || codePoint >= 0x80 && asciiOnly
+          || encodeSet.indexOf(codePoint) != -1
+          || codePoint == '%' && (!alreadyEncoded || strict && !percentEncoded(input, i, limit))) {
+        // Percent encode this character.
+        if (encodedCharBuffer == null) {
+          encodedCharBuffer = new Buffer();
+        }
+
+        if (charset == null || charset.equals(Util.UTF_8)) {
+          encodedCharBuffer.writeUtf8CodePoint(codePoint);
+        } else {
+          encodedCharBuffer.writeString(input, i, i + Character.charCount(codePoint), charset);
+        }
+
+        while (!encodedCharBuffer.exhausted()) {
+          int b = encodedCharBuffer.readByte() & 0xff;
+          out.writeByte('%');
+          out.writeByte(HEX_DIGITS[(b >> 4) & 0xf]);
+          out.writeByte(HEX_DIGITS[b & 0xf]);
+        }
+      } else {
+        // This character doesn't need encoding. Just copy it over.
+        out.writeUtf8CodePoint(codePoint);
+      }
+    }
+  }
+
+  static String canonicalize(String input, String encodeSet, boolean alreadyEncoded, boolean strict,
+      boolean plusIsSpace, boolean asciiOnly, Charset charset) {
+    return canonicalize(
+        input, 0, input.length(), encodeSet, alreadyEncoded, strict, plusIsSpace, asciiOnly,
+            charset);
+  }
+
+  static String canonicalize(String input, String encodeSet, boolean alreadyEncoded, boolean strict,
+      boolean plusIsSpace, boolean asciiOnly) {
+   return canonicalize(
+        input, 0, input.length(), encodeSet, alreadyEncoded, strict, plusIsSpace, asciiOnly, null);
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Interceptor.java b/okhttp/src/main/java/okhttp3/Interceptor.java
new file mode 100644
index 0000000000..1005592697
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Interceptor.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
+
+/**
+ * Observes, modifies, and potentially short-circuits requests going out and the corresponding
+ * responses coming back in. Typically interceptors add, remove, or transform headers on the request
+ * or response.
+ */
+public interface Interceptor {
+  Response intercept(Chain chain) throws IOException;
+
+  interface Chain {
+    Request request();
+
+    Response proceed(Request request) throws IOException;
+
+    /**
+     * Returns the connection the request will be executed on. This is only available in the chains
+     * of network interceptors; for application interceptors this is always null.
+     */
+    @Nullable Connection connection();
+
+    Call call();
+
+    int connectTimeoutMillis();
+
+    Chain withConnectTimeout(int timeout, TimeUnit unit);
+
+    int readTimeoutMillis();
+
+    Chain withReadTimeout(int timeout, TimeUnit unit);
+
+    int writeTimeoutMillis();
+
+    Chain withWriteTimeout(int timeout, TimeUnit unit);
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/MediaType.java b/okhttp/src/main/java/okhttp3/MediaType.java
new file mode 100644
index 0000000000..95194c5711
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/MediaType.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.nio.charset.Charset;
+import java.util.Locale;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import javax.annotation.Nullable;
+
+/**
+ * An <a href="http://tools.ietf.org/html/rfc2045">RFC 2045</a> Media Type, appropriate to describe
+ * the content type of an HTTP request or response body.
+ */
+public final class MediaType {
+  private static final String TOKEN = "([a-zA-Z0-9-!#$%&'*+.^_`{|}~]+)";
+  private static final String QUOTED = "\"([^\"]*)\"";
+  private static final Pattern TYPE_SUBTYPE = Pattern.compile(TOKEN + "/" + TOKEN);
+  private static final Pattern PARAMETER = Pattern.compile(
+      ";\\s*(?:" + TOKEN + "=(?:" + TOKEN + "|" + QUOTED + "))?");
+
+  private final String mediaType;
+  private final String type;
+  private final String subtype;
+  private final @Nullable String charset;
+
+  private MediaType(String mediaType, String type, String subtype, @Nullable String charset) {
+    this.mediaType = mediaType;
+    this.type = type;
+    this.subtype = subtype;
+    this.charset = charset;
+  }
+
+  /**
+   * Returns a media type for {@code string}, or null if {@code string} is not a well-formed media
+   * type.
+   */
+  public static @Nullable MediaType parse(String string) {
+    Matcher typeSubtype = TYPE_SUBTYPE.matcher(string);
+    if (!typeSubtype.lookingAt()) return null;
+    String type = typeSubtype.group(1).toLowerCase(Locale.US);
+    String subtype = typeSubtype.group(2).toLowerCase(Locale.US);
+
+    String charset = null;
+    Matcher parameter = PARAMETER.matcher(string);
+    for (int s = typeSubtype.end(); s < string.length(); s = parameter.end()) {
+      parameter.region(s, string.length());
+      if (!parameter.lookingAt()) return null; // This is not a well-formed media type.
+
+      String name = parameter.group(1);
+      if (name == null || !name.equalsIgnoreCase("charset")) continue;
+      String charsetParameter;
+      String token = parameter.group(2);
+      if (token != null) {
+        // If the token is 'single-quoted' it's invalid! But we're lenient and strip the quotes.
+        charsetParameter = (token.startsWith("'") && token.endsWith("'") && token.length() > 2)
+            ? token.substring(1, token.length() - 1)
+            : token;
+      } else {
+        // Value is "double-quoted". That's valid and our regex group already strips the quotes.
+        charsetParameter = parameter.group(3);
+      }
+      if (charset != null && !charsetParameter.equalsIgnoreCase(charset)) {
+        return null; // Multiple different charsets!
+      }
+      charset = charsetParameter;
+    }
+
+    return new MediaType(string, type, subtype, charset);
+  }
+
+  /**
+   * Returns the high-level media type, such as "text", "image", "audio", "video", or
+   * "application".
+   */
+  public String type() {
+    return type;
+  }
+
+  /**
+   * Returns a specific media subtype, such as "plain" or "png", "mpeg", "mp4" or "xml".
+   */
+  public String subtype() {
+    return subtype;
+  }
+
+  /**
+   * Returns the charset of this media type, or null if this media type doesn't specify a charset.
+   */
+  public @Nullable Charset charset() {
+    return charset(null);
+  }
+
+  /**
+   * Returns the charset of this media type, or {@code defaultValue} if either this media type
+   * doesn't specify a charset, of it its charset is unsupported by the current runtime.
+   */
+  public @Nullable Charset charset(@Nullable Charset defaultValue) {
+    try {
+      return charset != null ? Charset.forName(charset) : defaultValue;
+    } catch (IllegalArgumentException e) {
+      return defaultValue; // This charset is invalid or unsupported. Give up.
+    }
+  }
+
+  /**
+   * Returns the encoded media type, like "text/plain; charset=utf-8", appropriate for use in a
+   * Content-Type header.
+   */
+  @Override public String toString() {
+    return mediaType;
+  }
+
+  @Override public boolean equals(@Nullable Object other) {
+    return other instanceof MediaType && ((MediaType) other).mediaType.equals(mediaType);
+  }
+
+  @Override public int hashCode() {
+    return mediaType.hashCode();
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/MultipartBody.java b/okhttp/src/main/java/okhttp3/MultipartBody.java
new file mode 100644
index 0000000000..09c1eaf2fe
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/MultipartBody.java
@@ -0,0 +1,342 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.UUID;
+import javax.annotation.Nullable;
+import okhttp3.internal.Util;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.ByteString;
+
+/** An <a href="http://www.ietf.org/rfc/rfc2387.txt">RFC 2387</a>-compliant request body. */
+public final class MultipartBody extends RequestBody {
+  /**
+   * The "mixed" subtype of "multipart" is intended for use when the body parts are independent and
+   * need to be bundled in a particular order. Any "multipart" subtypes that an implementation does
+   * not recognize must be treated as being of subtype "mixed".
+   */
+  public static final MediaType MIXED = MediaType.parse("multipart/mixed");
+
+  /**
+   * The "multipart/alternative" type is syntactically identical to "multipart/mixed", but the
+   * semantics are different. In particular, each of the body parts is an "alternative" version of
+   * the same information.
+   */
+  public static final MediaType ALTERNATIVE = MediaType.parse("multipart/alternative");
+
+  /**
+   * This type is syntactically identical to "multipart/mixed", but the semantics are different. In
+   * particular, in a digest, the default {@code Content-Type} value for a body part is changed from
+   * "text/plain" to "message/rfc822".
+   */
+  public static final MediaType DIGEST = MediaType.parse("multipart/digest");
+
+  /**
+   * This type is syntactically identical to "multipart/mixed", but the semantics are different. In
+   * particular, in a parallel entity, the order of body parts is not significant.
+   */
+  public static final MediaType PARALLEL = MediaType.parse("multipart/parallel");
+
+  /**
+   * The media-type multipart/form-data follows the rules of all multipart MIME data streams as
+   * outlined in RFC 2046. In forms, there are a series of fields to be supplied by the user who
+   * fills out the form. Each field has a name. Within a given form, the names are unique.
+   */
+  public static final MediaType FORM = MediaType.parse("multipart/form-data");
+
+  private static final byte[] COLONSPACE = {':', ' '};
+  private static final byte[] CRLF = {'\r', '\n'};
+  private static final byte[] DASHDASH = {'-', '-'};
+
+  private final ByteString boundary;
+  private final MediaType originalType;
+  private final MediaType contentType;
+  private final List<Part> parts;
+  private long contentLength = -1L;
+
+  MultipartBody(ByteString boundary, MediaType type, List<Part> parts) {
+    this.boundary = boundary;
+    this.originalType = type;
+    this.contentType = MediaType.parse(type + "; boundary=" + boundary.utf8());
+    this.parts = Util.immutableList(parts);
+  }
+
+  public MediaType type() {
+    return originalType;
+  }
+
+  public String boundary() {
+    return boundary.utf8();
+  }
+
+  /** The number of parts in this multipart body. */
+  public int size() {
+    return parts.size();
+  }
+
+  public List<Part> parts() {
+    return parts;
+  }
+
+  public Part part(int index) {
+    return parts.get(index);
+  }
+
+  /** A combination of {@link #type()} and {@link #boundary()}. */
+  @Override public MediaType contentType() {
+    return contentType;
+  }
+
+  @Override public long contentLength() throws IOException {
+    long result = contentLength;
+    if (result != -1L) return result;
+    return contentLength = writeOrCountBytes(null, true);
+  }
+
+  @Override public void writeTo(BufferedSink sink) throws IOException {
+    writeOrCountBytes(sink, false);
+  }
+
+  /**
+   * Either writes this request to {@code sink} or measures its content length. We have one method
+   * do double-duty to make sure the counting and content are consistent, particularly when it comes
+   * to awkward operations like measuring the encoded length of header strings, or the
+   * length-in-digits of an encoded integer.
+   */
+  private long writeOrCountBytes(
+      @Nullable BufferedSink sink, boolean countBytes) throws IOException {
+    long byteCount = 0L;
+
+    Buffer byteCountBuffer = null;
+    if (countBytes) {
+      sink = byteCountBuffer = new Buffer();
+    }
+
+    for (int p = 0, partCount = parts.size(); p < partCount; p++) {
+      Part part = parts.get(p);
+      Headers headers = part.headers;
+      RequestBody body = part.body;
+
+      sink.write(DASHDASH);
+      sink.write(boundary);
+      sink.write(CRLF);
+
+      if (headers != null) {
+        for (int h = 0, headerCount = headers.size(); h < headerCount; h++) {
+          sink.writeUtf8(headers.name(h))
+              .write(COLONSPACE)
+              .writeUtf8(headers.value(h))
+              .write(CRLF);
+        }
+      }
+
+      MediaType contentType = body.contentType();
+      if (contentType != null) {
+        sink.writeUtf8("Content-Type: ")
+            .writeUtf8(contentType.toString())
+            .write(CRLF);
+      }
+
+      long contentLength = body.contentLength();
+      if (contentLength != -1) {
+        sink.writeUtf8("Content-Length: ")
+            .writeDecimalLong(contentLength)
+            .write(CRLF);
+      } else if (countBytes) {
+        // We can't measure the body's size without the sizes of its components.
+        byteCountBuffer.clear();
+        return -1L;
+      }
+
+      sink.write(CRLF);
+
+      if (countBytes) {
+        byteCount += contentLength;
+      } else {
+        body.writeTo(sink);
+      }
+
+      sink.write(CRLF);
+    }
+
+    sink.write(DASHDASH);
+    sink.write(boundary);
+    sink.write(DASHDASH);
+    sink.write(CRLF);
+
+    if (countBytes) {
+      byteCount += byteCountBuffer.size();
+      byteCountBuffer.clear();
+    }
+
+    return byteCount;
+  }
+
+  /**
+   * Appends a quoted-string to a StringBuilder.
+   *
+   * <p>RFC 2388 is rather vague about how one should escape special characters in form-data
+   * parameters, and as it turns out Firefox and Chrome actually do rather different things, and
+   * both say in their comments that they're not really sure what the right approach is. We go with
+   * Chrome's behavior (which also experimentally seems to match what IE does), but if you actually
+   * want to have a good chance of things working, please avoid double-quotes, newlines, percent
+   * signs, and the like in your field names.
+   */
+  static StringBuilder appendQuotedString(StringBuilder target, String key) {
+    target.append('"');
+    for (int i = 0, len = key.length(); i < len; i++) {
+      char ch = key.charAt(i);
+      switch (ch) {
+        case '\n':
+          target.append("%0A");
+          break;
+        case '\r':
+          target.append("%0D");
+          break;
+        case '"':
+          target.append("%22");
+          break;
+        default:
+          target.append(ch);
+          break;
+      }
+    }
+    target.append('"');
+    return target;
+  }
+
+  public static final class Part {
+    public static Part create(RequestBody body) {
+      return create(null, body);
+    }
+
+    public static Part create(@Nullable Headers headers, RequestBody body) {
+      if (body == null) {
+        throw new NullPointerException("body == null");
+      }
+      if (headers != null && headers.get("Content-Type") != null) {
+        throw new IllegalArgumentException("Unexpected header: Content-Type");
+      }
+      if (headers != null && headers.get("Content-Length") != null) {
+        throw new IllegalArgumentException("Unexpected header: Content-Length");
+      }
+      return new Part(headers, body);
+    }
+
+    public static Part createFormData(String name, String value) {
+      return createFormData(name, null, RequestBody.create(null, value));
+    }
+
+    public static Part createFormData(String name, @Nullable String filename, RequestBody body) {
+      if (name == null) {
+        throw new NullPointerException("name == null");
+      }
+      StringBuilder disposition = new StringBuilder("form-data; name=");
+      appendQuotedString(disposition, name);
+
+      if (filename != null) {
+        disposition.append("; filename=");
+        appendQuotedString(disposition, filename);
+      }
+
+      return create(Headers.of("Content-Disposition", disposition.toString()), body);
+    }
+
+    final @Nullable Headers headers;
+    final RequestBody body;
+
+    private Part(@Nullable Headers headers, RequestBody body) {
+      this.headers = headers;
+      this.body = body;
+    }
+
+    public @Nullable Headers headers() {
+      return headers;
+    }
+
+    public RequestBody body() {
+      return body;
+    }
+  }
+
+  public static final class Builder {
+    private final ByteString boundary;
+    private MediaType type = MIXED;
+    private final List<Part> parts = new ArrayList<>();
+
+    public Builder() {
+      this(UUID.randomUUID().toString());
+    }
+
+    public Builder(String boundary) {
+      this.boundary = ByteString.encodeUtf8(boundary);
+    }
+
+    /**
+     * Set the MIME type. Expected values for {@code type} are {@link #MIXED} (the default), {@link
+     * #ALTERNATIVE}, {@link #DIGEST}, {@link #PARALLEL} and {@link #FORM}.
+     */
+    public Builder setType(MediaType type) {
+      if (type == null) {
+        throw new NullPointerException("type == null");
+      }
+      if (!type.type().equals("multipart")) {
+        throw new IllegalArgumentException("multipart != " + type);
+      }
+      this.type = type;
+      return this;
+    }
+
+    /** Add a part to the body. */
+    public Builder addPart(RequestBody body) {
+      return addPart(Part.create(body));
+    }
+
+    /** Add a part to the body. */
+    public Builder addPart(@Nullable Headers headers, RequestBody body) {
+      return addPart(Part.create(headers, body));
+    }
+
+    /** Add a form data part to the body. */
+    public Builder addFormDataPart(String name, String value) {
+      return addPart(Part.createFormData(name, value));
+    }
+
+    /** Add a form data part to the body. */
+    public Builder addFormDataPart(String name, @Nullable String filename, RequestBody body) {
+      return addPart(Part.createFormData(name, filename, body));
+    }
+
+    /** Add a part to the body. */
+    public Builder addPart(Part part) {
+      if (part == null) throw new NullPointerException("part == null");
+      parts.add(part);
+      return this;
+    }
+
+    /** Assemble the specified parts into a request body. */
+    public MultipartBody build() {
+      if (parts.isEmpty()) {
+        throw new IllegalStateException("Multipart body must have at least one part.");
+      }
+      return new MultipartBody(boundary, type, parts);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
new file mode 100644
index 0000000000..f69cab89ba
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java
@@ -0,0 +1,917 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.net.MalformedURLException;
+import java.net.Proxy;
+import java.net.ProxySelector;
+import java.net.Socket;
+import java.net.UnknownHostException;
+import java.security.GeneralSecurityException;
+import java.security.KeyStore;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.Random;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
+import javax.net.SocketFactory;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.internal.Internal;
+import okhttp3.internal.Util;
+import okhttp3.internal.cache.InternalCache;
+import okhttp3.internal.connection.RealConnection;
+import okhttp3.internal.connection.RouteDatabase;
+import okhttp3.internal.connection.StreamAllocation;
+import okhttp3.internal.platform.Platform;
+import okhttp3.internal.tls.CertificateChainCleaner;
+import okhttp3.internal.tls.OkHostnameVerifier;
+import okhttp3.internal.ws.RealWebSocket;
+
+import static okhttp3.internal.Util.assertionError;
+import static okhttp3.internal.Util.checkDuration;
+
+/**
+ * Factory for {@linkplain Call calls}, which can be used to send HTTP requests and read their
+ * responses.
+ *
+ * <h3>OkHttpClients should be shared</h3>
+ *
+ * <p>OkHttp performs best when you create a single {@code OkHttpClient} instance and reuse it for
+ * all of your HTTP calls. This is because each client holds its own connection pool and thread
+ * pools. Reusing connections and threads reduces latency and saves memory. Conversely, creating a
+ * client for each request wastes resources on idle pools.
+ *
+ * <p>Use {@code new OkHttpClient()} to create a shared instance with the default settings:
+ * <pre>   {@code
+ *
+ *   // The singleton HTTP client.
+ *   public final OkHttpClient client = new OkHttpClient();
+ * }</pre>
+ *
+ * <p>Or use {@code new OkHttpClient.Builder()} to create a shared instance with custom settings:
+ * <pre>   {@code
+ *
+ *   // The singleton HTTP client.
+ *   public final OkHttpClient client = new OkHttpClient.Builder()
+ *       .addInterceptor(new HttpLoggingInterceptor())
+ *       .cache(new Cache(cacheDir, cacheSize))
+ *       .build();
+ * }</pre>
+ *
+ * <h3>Customize your client with newBuilder()</h3>
+ *
+ * <p>You can customize a shared OkHttpClient instance with {@link #newBuilder()}. This builds a
+ * client that shares the same connection pool, thread pools, and configuration. Use the builder
+ * methods to configure the derived client for a specific purpose.
+ *
+ * <p>This example shows a call with a short 500 millisecond timeout: <pre>   {@code
+ *
+ *   OkHttpClient eagerClient = client.newBuilder()
+ *       .readTimeout(500, TimeUnit.MILLISECONDS)
+ *       .build();
+ *   Response response = eagerClient.newCall(request).execute();
+ * }</pre>
+ *
+ * <h3>Shutdown isn't necessary</h3>
+ *
+ * <p>The threads and connections that are held will be released automatically if they remain idle.
+ * But if you are writing a application that needs to aggressively release unused resources you may
+ * do so.
+ *
+ * <p>Shutdown the dispatcher's executor service with {@link ExecutorService#shutdown shutdown()}.
+ * This will also cause future calls to the client to be rejected. <pre>   {@code
+ *
+ *     client.dispatcher().executorService().shutdown();
+ * }</pre>
+ *
+ * <p>Clear the connection pool with {@link ConnectionPool#evictAll() evictAll()}. Note that the
+ * connection pool's daemon thread may not exit immediately. <pre>   {@code
+ *
+ *     client.connectionPool().evictAll();
+ * }</pre>
+ *
+ * <p>If your client has a cache, call {@link Cache#close close()}. Note that it is an error to
+ * create calls against a cache that is closed, and doing so will cause the call to crash.
+ * <pre>   {@code
+ *
+ *     client.cache().close();
+ * }</pre>
+ *
+ * <p>OkHttp also uses daemon threads for HTTP/2 connections. These will exit automatically if they
+ * remain idle.
+ */
+public class OkHttpClient implements Cloneable, Call.Factory, WebSocket.Factory {
+  static final List<Protocol> DEFAULT_PROTOCOLS = Util.immutableList(
+      Protocol.HTTP_2, Protocol.HTTP_1_1);
+
+  static final List<ConnectionSpec> DEFAULT_CONNECTION_SPECS = Util.immutableList(
+      ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT);
+
+  static {
+    Internal.instance = new Internal() {
+      @Override public void addLenient(Headers.Builder builder, String line) {
+        builder.addLenient(line);
+      }
+
+      @Override public void addLenient(Headers.Builder builder, String name, String value) {
+        builder.addLenient(name, value);
+      }
+
+      @Override public void setCache(OkHttpClient.Builder builder, InternalCache internalCache) {
+        builder.setInternalCache(internalCache);
+      }
+
+      @Override public boolean connectionBecameIdle(
+          ConnectionPool pool, RealConnection connection) {
+        return pool.connectionBecameIdle(connection);
+      }
+
+      @Override public RealConnection get(ConnectionPool pool, Address address,
+          StreamAllocation streamAllocation, Route route) {
+        return pool.get(address, streamAllocation, route);
+      }
+
+      @Override public boolean equalsNonHost(Address a, Address b) {
+        return a.equalsNonHost(b);
+      }
+
+      @Override public Socket deduplicate(
+          ConnectionPool pool, Address address, StreamAllocation streamAllocation) {
+        return pool.deduplicate(address, streamAllocation);
+      }
+
+      @Override public void put(ConnectionPool pool, RealConnection connection) {
+        pool.put(connection);
+      }
+
+      @Override public RouteDatabase routeDatabase(ConnectionPool connectionPool) {
+        return connectionPool.routeDatabase;
+      }
+
+      @Override public int code(Response.Builder responseBuilder) {
+        return responseBuilder.code;
+      }
+
+      @Override
+      public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean isFallback) {
+        tlsConfiguration.apply(sslSocket, isFallback);
+      }
+
+      @Override public HttpUrl getHttpUrlChecked(String url)
+          throws MalformedURLException, UnknownHostException {
+        return HttpUrl.getChecked(url);
+      }
+
+      @Override public StreamAllocation streamAllocation(Call call) {
+        return ((RealCall) call).streamAllocation();
+      }
+
+      @Override public Call newWebSocketCall(OkHttpClient client, Request originalRequest) {
+        return RealCall.newRealCall(client, originalRequest, true);
+      }
+    };
+  }
+
+  final Dispatcher dispatcher;
+  final @Nullable Proxy proxy;
+  final List<Protocol> protocols;
+  final List<ConnectionSpec> connectionSpecs;
+  final List<Interceptor> interceptors;
+  final List<Interceptor> networkInterceptors;
+  final EventListener.Factory eventListenerFactory;
+  final ProxySelector proxySelector;
+  final CookieJar cookieJar;
+  final @Nullable Cache cache;
+  final @Nullable InternalCache internalCache;
+  final SocketFactory socketFactory;
+  final @Nullable SSLSocketFactory sslSocketFactory;
+  final @Nullable CertificateChainCleaner certificateChainCleaner;
+  final HostnameVerifier hostnameVerifier;
+  final CertificatePinner certificatePinner;
+  final Authenticator proxyAuthenticator;
+  final Authenticator authenticator;
+  final ConnectionPool connectionPool;
+  final Dns dns;
+  final boolean followSslRedirects;
+  final boolean followRedirects;
+  final boolean retryOnConnectionFailure;
+  final int connectTimeout;
+  final int readTimeout;
+  final int writeTimeout;
+  final int pingInterval;
+
+  public OkHttpClient() {
+    this(new Builder());
+  }
+
+  OkHttpClient(Builder builder) {
+    this.dispatcher = builder.dispatcher;
+    this.proxy = builder.proxy;
+    this.protocols = builder.protocols;
+    this.connectionSpecs = builder.connectionSpecs;
+    this.interceptors = Util.immutableList(builder.interceptors);
+    this.networkInterceptors = Util.immutableList(builder.networkInterceptors);
+    this.eventListenerFactory = builder.eventListenerFactory;
+    this.proxySelector = builder.proxySelector;
+    this.cookieJar = builder.cookieJar;
+    this.cache = builder.cache;
+    this.internalCache = builder.internalCache;
+    this.socketFactory = builder.socketFactory;
+
+    boolean isTLS = false;
+    for (ConnectionSpec spec : connectionSpecs) {
+      isTLS = isTLS || spec.isTls();
+    }
+
+    if (builder.sslSocketFactory != null || !isTLS) {
+      this.sslSocketFactory = builder.sslSocketFactory;
+      this.certificateChainCleaner = builder.certificateChainCleaner;
+    } else {
+      X509TrustManager trustManager = systemDefaultTrustManager();
+      this.sslSocketFactory = systemDefaultSslSocketFactory(trustManager);
+      this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
+    }
+
+    this.hostnameVerifier = builder.hostnameVerifier;
+    this.certificatePinner = builder.certificatePinner.withCertificateChainCleaner(
+        certificateChainCleaner);
+    this.proxyAuthenticator = builder.proxyAuthenticator;
+    this.authenticator = builder.authenticator;
+    this.connectionPool = builder.connectionPool;
+    this.dns = builder.dns;
+    this.followSslRedirects = builder.followSslRedirects;
+    this.followRedirects = builder.followRedirects;
+    this.retryOnConnectionFailure = builder.retryOnConnectionFailure;
+    this.connectTimeout = builder.connectTimeout;
+    this.readTimeout = builder.readTimeout;
+    this.writeTimeout = builder.writeTimeout;
+    this.pingInterval = builder.pingInterval;
+
+    if (interceptors.contains(null)) {
+      throw new IllegalStateException("Null interceptor: " + interceptors);
+    }
+    if (networkInterceptors.contains(null)) {
+      throw new IllegalStateException("Null network interceptor: " + networkInterceptors);
+    }
+  }
+
+  private X509TrustManager systemDefaultTrustManager() {
+    try {
+      TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+          TrustManagerFactory.getDefaultAlgorithm());
+      trustManagerFactory.init((KeyStore) null);
+      TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
+      if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
+        throw new IllegalStateException("Unexpected default trust managers:"
+            + Arrays.toString(trustManagers));
+      }
+      return (X509TrustManager) trustManagers[0];
+    } catch (GeneralSecurityException e) {
+      throw assertionError("No System TLS", e); // The system has no TLS. Just give up.
+    }
+  }
+
+  private SSLSocketFactory systemDefaultSslSocketFactory(X509TrustManager trustManager) {
+    try {
+      SSLContext sslContext = SSLContext.getInstance("TLS");
+      sslContext.init(null, new TrustManager[] { trustManager }, null);
+      return sslContext.getSocketFactory();
+    } catch (GeneralSecurityException e) {
+      throw assertionError("No System TLS", e); // The system has no TLS. Just give up.
+    }
+  }
+
+  /** Default connect timeout (in milliseconds). */
+  public int connectTimeoutMillis() {
+    return connectTimeout;
+  }
+
+  /** Default read timeout (in milliseconds). */
+  public int readTimeoutMillis() {
+    return readTimeout;
+  }
+
+  /** Default write timeout (in milliseconds). */
+  public int writeTimeoutMillis() {
+    return writeTimeout;
+  }
+
+  /** Web socket ping interval (in milliseconds). */
+  public int pingIntervalMillis() {
+    return pingInterval;
+  }
+
+  public Proxy proxy() {
+    return proxy;
+  }
+
+  public ProxySelector proxySelector() {
+    return proxySelector;
+  }
+
+  public CookieJar cookieJar() {
+    return cookieJar;
+  }
+
+  public Cache cache() {
+    return cache;
+  }
+
+  InternalCache internalCache() {
+    return cache != null ? cache.internalCache : internalCache;
+  }
+
+  public Dns dns() {
+    return dns;
+  }
+
+  public SocketFactory socketFactory() {
+    return socketFactory;
+  }
+
+  public SSLSocketFactory sslSocketFactory() {
+    return sslSocketFactory;
+  }
+
+  public HostnameVerifier hostnameVerifier() {
+    return hostnameVerifier;
+  }
+
+  public CertificatePinner certificatePinner() {
+    return certificatePinner;
+  }
+
+  public Authenticator authenticator() {
+    return authenticator;
+  }
+
+  public Authenticator proxyAuthenticator() {
+    return proxyAuthenticator;
+  }
+
+  public ConnectionPool connectionPool() {
+    return connectionPool;
+  }
+
+  public boolean followSslRedirects() {
+    return followSslRedirects;
+  }
+
+  public boolean followRedirects() {
+    return followRedirects;
+  }
+
+  public boolean retryOnConnectionFailure() {
+    return retryOnConnectionFailure;
+  }
+
+  public Dispatcher dispatcher() {
+    return dispatcher;
+  }
+
+  public List<Protocol> protocols() {
+    return protocols;
+  }
+
+  public List<ConnectionSpec> connectionSpecs() {
+    return connectionSpecs;
+  }
+
+  /**
+   * Returns an immutable list of interceptors that observe the full span of each call: from before
+   * the connection is established (if any) until after the response source is selected (either the
+   * origin server, cache, or both).
+   */
+  public List<Interceptor> interceptors() {
+    return interceptors;
+  }
+
+  /**
+   * Returns an immutable list of interceptors that observe a single network request and response.
+   * These interceptors must call {@link Interceptor.Chain#proceed} exactly once: it is an error for
+   * a network interceptor to short-circuit or repeat a network request.
+   */
+  public List<Interceptor> networkInterceptors() {
+    return networkInterceptors;
+  }
+
+  public EventListener.Factory eventListenerFactory() {
+    return eventListenerFactory;
+  }
+
+  /**
+   * Prepares the {@code request} to be executed at some point in the future.
+   */
+  @Override public Call newCall(Request request) {
+    return RealCall.newRealCall(this, request, false /* for web socket */);
+  }
+
+  /**
+   * Uses {@code request} to connect a new web socket.
+   */
+  @Override public WebSocket newWebSocket(Request request, WebSocketListener listener) {
+    RealWebSocket webSocket = new RealWebSocket(request, listener, new Random());
+    webSocket.connect(this);
+    return webSocket;
+  }
+
+  public Builder newBuilder() {
+    return new Builder(this);
+  }
+
+  public static final class Builder {
+    Dispatcher dispatcher;
+    @Nullable Proxy proxy;
+    List<Protocol> protocols;
+    List<ConnectionSpec> connectionSpecs;
+    final List<Interceptor> interceptors = new ArrayList<>();
+    final List<Interceptor> networkInterceptors = new ArrayList<>();
+    EventListener.Factory eventListenerFactory;
+    ProxySelector proxySelector;
+    CookieJar cookieJar;
+    @Nullable Cache cache;
+    @Nullable InternalCache internalCache;
+    SocketFactory socketFactory;
+    @Nullable SSLSocketFactory sslSocketFactory;
+    @Nullable CertificateChainCleaner certificateChainCleaner;
+    HostnameVerifier hostnameVerifier;
+    CertificatePinner certificatePinner;
+    Authenticator proxyAuthenticator;
+    Authenticator authenticator;
+    ConnectionPool connectionPool;
+    Dns dns;
+    boolean followSslRedirects;
+    boolean followRedirects;
+    boolean retryOnConnectionFailure;
+    int connectTimeout;
+    int readTimeout;
+    int writeTimeout;
+    int pingInterval;
+
+    public Builder() {
+      dispatcher = new Dispatcher();
+      protocols = DEFAULT_PROTOCOLS;
+      connectionSpecs = DEFAULT_CONNECTION_SPECS;
+      eventListenerFactory = EventListener.factory(EventListener.NONE);
+      proxySelector = ProxySelector.getDefault();
+      cookieJar = CookieJar.NO_COOKIES;
+      socketFactory = SocketFactory.getDefault();
+      hostnameVerifier = OkHostnameVerifier.INSTANCE;
+      certificatePinner = CertificatePinner.DEFAULT;
+      proxyAuthenticator = Authenticator.NONE;
+      authenticator = Authenticator.NONE;
+      connectionPool = new ConnectionPool();
+      dns = Dns.SYSTEM;
+      followSslRedirects = true;
+      followRedirects = true;
+      retryOnConnectionFailure = true;
+      connectTimeout = 10_000;
+      readTimeout = 10_000;
+      writeTimeout = 10_000;
+      pingInterval = 0;
+    }
+
+    Builder(OkHttpClient okHttpClient) {
+      this.dispatcher = okHttpClient.dispatcher;
+      this.proxy = okHttpClient.proxy;
+      this.protocols = okHttpClient.protocols;
+      this.connectionSpecs = okHttpClient.connectionSpecs;
+      this.interceptors.addAll(okHttpClient.interceptors);
+      this.networkInterceptors.addAll(okHttpClient.networkInterceptors);
+      this.eventListenerFactory = okHttpClient.eventListenerFactory;
+      this.proxySelector = okHttpClient.proxySelector;
+      this.cookieJar = okHttpClient.cookieJar;
+      this.internalCache = okHttpClient.internalCache;
+      this.cache = okHttpClient.cache;
+      this.socketFactory = okHttpClient.socketFactory;
+      this.sslSocketFactory = okHttpClient.sslSocketFactory;
+      this.certificateChainCleaner = okHttpClient.certificateChainCleaner;
+      this.hostnameVerifier = okHttpClient.hostnameVerifier;
+      this.certificatePinner = okHttpClient.certificatePinner;
+      this.proxyAuthenticator = okHttpClient.proxyAuthenticator;
+      this.authenticator = okHttpClient.authenticator;
+      this.connectionPool = okHttpClient.connectionPool;
+      this.dns = okHttpClient.dns;
+      this.followSslRedirects = okHttpClient.followSslRedirects;
+      this.followRedirects = okHttpClient.followRedirects;
+      this.retryOnConnectionFailure = okHttpClient.retryOnConnectionFailure;
+      this.connectTimeout = okHttpClient.connectTimeout;
+      this.readTimeout = okHttpClient.readTimeout;
+      this.writeTimeout = okHttpClient.writeTimeout;
+      this.pingInterval = okHttpClient.pingInterval;
+    }
+
+    /**
+     * Sets the default connect timeout for new connections. A value of 0 means no timeout,
+     * otherwise values must be between 1 and {@link Integer#MAX_VALUE} when converted to
+     * milliseconds.
+     */
+    public Builder connectTimeout(long timeout, TimeUnit unit) {
+      connectTimeout = checkDuration("timeout", timeout, unit);
+      return this;
+    }
+
+    /**
+     * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
+     * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+     */
+    public Builder readTimeout(long timeout, TimeUnit unit) {
+      readTimeout = checkDuration("timeout", timeout, unit);
+      return this;
+    }
+
+    /**
+     * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
+     * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+     */
+    public Builder writeTimeout(long timeout, TimeUnit unit) {
+      writeTimeout = checkDuration("timeout", timeout, unit);
+      return this;
+    }
+
+    /**
+     * Sets the interval between web socket pings initiated by this client. Use this to
+     * automatically send web socket ping frames until either the web socket fails or it is closed.
+     * This keeps the connection alive and may detect connectivity failures early. No timeouts are
+     * enforced on the acknowledging pongs.
+     *
+     * <p>The default value of 0 disables client-initiated pings.
+     */
+    public Builder pingInterval(long interval, TimeUnit unit) {
+      pingInterval = checkDuration("interval", interval, unit);
+      return this;
+    }
+
+    /**
+     * Sets the HTTP proxy that will be used by connections created by this client. This takes
+     * precedence over {@link #proxySelector}, which is only honored when this proxy is null (which
+     * it is by default). To disable proxy use completely, call {@code setProxy(Proxy.NO_PROXY)}.
+     */
+    public Builder proxy(@Nullable Proxy proxy) {
+      this.proxy = proxy;
+      return this;
+    }
+
+    /**
+     * Sets the proxy selection policy to be used if no {@link #proxy proxy} is specified
+     * explicitly. The proxy selector may return multiple proxies; in that case they will be tried
+     * in sequence until a successful connection is established.
+     *
+     * <p>If unset, the {@link ProxySelector#getDefault() system-wide default} proxy selector will
+     * be used.
+     */
+    public Builder proxySelector(ProxySelector proxySelector) {
+      this.proxySelector = proxySelector;
+      return this;
+    }
+
+    /**
+     * Sets the handler that can accept cookies from incoming HTTP responses and provides cookies to
+     * outgoing HTTP requests.
+     *
+     * <p>If unset, {@linkplain CookieJar#NO_COOKIES no cookies} will be accepted nor provided.
+     */
+    public Builder cookieJar(CookieJar cookieJar) {
+      if (cookieJar == null) throw new NullPointerException("cookieJar == null");
+      this.cookieJar = cookieJar;
+      return this;
+    }
+
+    /** Sets the response cache to be used to read and write cached responses. */
+    void setInternalCache(@Nullable InternalCache internalCache) {
+      this.internalCache = internalCache;
+      this.cache = null;
+    }
+
+    /** Sets the response cache to be used to read and write cached responses. */
+    public Builder cache(@Nullable Cache cache) {
+      this.cache = cache;
+      this.internalCache = null;
+      return this;
+    }
+
+    /**
+     * Sets the DNS service used to lookup IP addresses for hostnames.
+     *
+     * <p>If unset, the {@link Dns#SYSTEM system-wide default} DNS will be used.
+     */
+    public Builder dns(Dns dns) {
+      if (dns == null) throw new NullPointerException("dns == null");
+      this.dns = dns;
+      return this;
+    }
+
+    /**
+     * Sets the socket factory used to create connections. OkHttp only uses the parameterless {@link
+     * SocketFactory#createSocket() createSocket()} method to create unconnected sockets. Overriding
+     * this method, e. g., allows the socket to be bound to a specific local address.
+     *
+     * <p>If unset, the {@link SocketFactory#getDefault() system-wide default} socket factory will
+     * be used.
+     */
+    public Builder socketFactory(SocketFactory socketFactory) {
+      if (socketFactory == null) throw new NullPointerException("socketFactory == null");
+      this.socketFactory = socketFactory;
+      return this;
+    }
+
+    /**
+     * Sets the socket factory used to secure HTTPS connections. If unset, the system default will
+     * be used.
+     *
+     * @deprecated {@code SSLSocketFactory} does not expose its {@link X509TrustManager}, which is
+     *     a field that OkHttp needs to build a clean certificate chain. This method instead must
+     *     use reflection to extract the trust manager. Applications should prefer to call {@link
+     *     #sslSocketFactory(SSLSocketFactory, X509TrustManager)}, which avoids such reflection.
+     */
+    public Builder sslSocketFactory(SSLSocketFactory sslSocketFactory) {
+      if (sslSocketFactory == null) throw new NullPointerException("sslSocketFactory == null");
+      this.sslSocketFactory = sslSocketFactory;
+      this.certificateChainCleaner = Platform.get().buildCertificateChainCleaner(sslSocketFactory);
+      return this;
+    }
+
+    /**
+     * Sets the socket factory and trust manager used to secure HTTPS connections. If unset, the
+     * system defaults will be used.
+     *
+     * <p>Most applications should not call this method, and instead use the system defaults. Those
+     * classes include special optimizations that can be lost if the implementations are decorated.
+     *
+     * <p>If necessary, you can create and configure the defaults yourself with the following code:
+     *
+     * <pre>   {@code
+     *
+     *   TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+     *       TrustManagerFactory.getDefaultAlgorithm());
+     *   trustManagerFactory.init((KeyStore) null);
+     *   TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
+     *   if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
+     *     throw new IllegalStateException("Unexpected default trust managers:"
+     *         + Arrays.toString(trustManagers));
+     *   }
+     *   X509TrustManager trustManager = (X509TrustManager) trustManagers[0];
+     *
+     *   SSLContext sslContext = SSLContext.getInstance("TLS");
+     *   sslContext.init(null, new TrustManager[] { trustManager }, null);
+     *   SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();
+     *
+     *   OkHttpClient client = new OkHttpClient.Builder()
+     *       .sslSocketFactory(sslSocketFactory, trustManager);
+     *       .build();
+     * }</pre>
+     */
+    public Builder sslSocketFactory(
+        SSLSocketFactory sslSocketFactory, X509TrustManager trustManager) {
+      if (sslSocketFactory == null) throw new NullPointerException("sslSocketFactory == null");
+      if (trustManager == null) throw new NullPointerException("trustManager == null");
+      this.sslSocketFactory = sslSocketFactory;
+      this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
+      return this;
+    }
+
+    /**
+     * Sets the verifier used to confirm that response certificates apply to requested hostnames for
+     * HTTPS connections.
+     *
+     * <p>If unset, a default hostname verifier will be used.
+     */
+    public Builder hostnameVerifier(HostnameVerifier hostnameVerifier) {
+      if (hostnameVerifier == null) throw new NullPointerException("hostnameVerifier == null");
+      this.hostnameVerifier = hostnameVerifier;
+      return this;
+    }
+
+    /**
+     * Sets the certificate pinner that constrains which certificates are trusted. By default HTTPS
+     * connections rely on only the {@link #sslSocketFactory SSL socket factory} to establish trust.
+     * Pinning certificates avoids the need to trust certificate authorities.
+     */
+    public Builder certificatePinner(CertificatePinner certificatePinner) {
+      if (certificatePinner == null) throw new NullPointerException("certificatePinner == null");
+      this.certificatePinner = certificatePinner;
+      return this;
+    }
+
+    /**
+     * Sets the authenticator used to respond to challenges from origin servers. Use {@link
+     * #proxyAuthenticator} to set the authenticator for proxy servers.
+     *
+     * <p>If unset, the {@linkplain Authenticator#NONE no authentication will be attempted}.
+     */
+    public Builder authenticator(Authenticator authenticator) {
+      if (authenticator == null) throw new NullPointerException("authenticator == null");
+      this.authenticator = authenticator;
+      return this;
+    }
+
+    /**
+     * Sets the authenticator used to respond to challenges from proxy servers. Use {@link
+     * #authenticator} to set the authenticator for origin servers.
+     *
+     * <p>If unset, the {@linkplain Authenticator#NONE no authentication will be attempted}.
+     */
+    public Builder proxyAuthenticator(Authenticator proxyAuthenticator) {
+      if (proxyAuthenticator == null) throw new NullPointerException("proxyAuthenticator == null");
+      this.proxyAuthenticator = proxyAuthenticator;
+      return this;
+    }
+
+    /**
+     * Sets the connection pool used to recycle HTTP and HTTPS connections.
+     *
+     * <p>If unset, a new connection pool will be used.
+     */
+    public Builder connectionPool(ConnectionPool connectionPool) {
+      if (connectionPool == null) throw new NullPointerException("connectionPool == null");
+      this.connectionPool = connectionPool;
+      return this;
+    }
+
+    /**
+     * Configure this client to follow redirects from HTTPS to HTTP and from HTTP to HTTPS.
+     *
+     * <p>If unset, protocol redirects will be followed. This is different than the built-in {@code
+     * HttpURLConnection}'s default.
+     */
+    public Builder followSslRedirects(boolean followProtocolRedirects) {
+      this.followSslRedirects = followProtocolRedirects;
+      return this;
+    }
+
+    /** Configure this client to follow redirects. If unset, redirects will be followed. */
+    public Builder followRedirects(boolean followRedirects) {
+      this.followRedirects = followRedirects;
+      return this;
+    }
+
+    /**
+     * Configure this client to retry or not when a connectivity problem is encountered. By default,
+     * this client silently recovers from the following problems:
+     *
+     * <ul>
+     *   <li><strong>Unreachable IP addresses.</strong> If the URL's host has multiple IP addresses,
+     *       failure to reach any individual IP address doesn't fail the overall request. This can
+     *       increase availability of multi-homed services.
+     *   <li><strong>Stale pooled connections.</strong> The {@link ConnectionPool} reuses sockets
+     *       to decrease request latency, but these connections will occasionally time out.
+     *   <li><strong>Unreachable proxy servers.</strong> A {@link ProxySelector} can be used to
+     *       attempt multiple proxy servers in sequence, eventually falling back to a direct
+     *       connection.
+     * </ul>
+     *
+     * Set this to false to avoid retrying requests when doing so is destructive. In this case the
+     * calling application should do its own recovery of connectivity failures.
+     */
+    public Builder retryOnConnectionFailure(boolean retryOnConnectionFailure) {
+      this.retryOnConnectionFailure = retryOnConnectionFailure;
+      return this;
+    }
+
+    /**
+     * Sets the dispatcher used to set policy and execute asynchronous requests. Must not be null.
+     */
+    public Builder dispatcher(Dispatcher dispatcher) {
+      if (dispatcher == null) throw new IllegalArgumentException("dispatcher == null");
+      this.dispatcher = dispatcher;
+      return this;
+    }
+
+    /**
+     * Configure the protocols used by this client to communicate with remote servers. By default
+     * this client will prefer the most efficient transport available, falling back to more
+     * ubiquitous protocols. Applications should only call this method to avoid specific
+     * compatibility problems, such as web servers that behave incorrectly when HTTP/2 is enabled.
+     *
+     * <p>The following protocols are currently supported:
+     *
+     * <ul>
+     *     <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>
+     *     <li><a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-17">h2</a>
+     * </ul>
+     *
+     * <p><strong>This is an evolving set.</strong> Future releases include support for transitional
+     * protocols. The http/1.1 transport will never be dropped.
+     *
+     * <p>If multiple protocols are specified, <a
+     * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a> will be used to
+     * negotiate a transport.
+     *
+     * <p>{@link Protocol#HTTP_1_0} is not supported in this set. Requests are initiated with {@code
+     * HTTP/1.1} only. If the server responds with {@code HTTP/1.0}, that will be exposed by {@link
+     * Response#protocol()}.
+     *
+     * @param protocols the protocols to use, in order of preference. The list must contain {@link
+     * Protocol#HTTP_1_1}. It must not contain null or {@link Protocol#HTTP_1_0}.
+     */
+    public Builder protocols(List<Protocol> protocols) {
+      // Create a private copy of the list.
+      protocols = new ArrayList<>(protocols);
+
+      // Validate that the list has everything we require and nothing we forbid.
+      if (!protocols.contains(Protocol.HTTP_1_1)) {
+        throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
+      }
+      if (protocols.contains(Protocol.HTTP_1_0)) {
+        throw new IllegalArgumentException("protocols must not contain http/1.0: " + protocols);
+      }
+      if (protocols.contains(null)) {
+        throw new IllegalArgumentException("protocols must not contain null");
+      }
+
+      // Remove protocols that we no longer support.
+      protocols.remove(Protocol.SPDY_3);
+
+      // Assign as an unmodifiable list. This is effectively immutable.
+      this.protocols = Collections.unmodifiableList(protocols);
+      return this;
+    }
+
+    public Builder connectionSpecs(List<ConnectionSpec> connectionSpecs) {
+      this.connectionSpecs = Util.immutableList(connectionSpecs);
+      return this;
+    }
+
+    /**
+     * Returns a modifiable list of interceptors that observe the full span of each call: from
+     * before the connection is established (if any) until after the response source is selected
+     * (either the origin server, cache, or both).
+     */
+    public List<Interceptor> interceptors() {
+      return interceptors;
+    }
+
+    public Builder addInterceptor(Interceptor interceptor) {
+      if (interceptor == null) throw new IllegalArgumentException("interceptor == null");
+      interceptors.add(interceptor);
+      return this;
+    }
+
+    /**
+     * Returns a modifiable list of interceptors that observe a single network request and response.
+     * These interceptors must call {@link Interceptor.Chain#proceed} exactly once: it is an error
+     * for a network interceptor to short-circuit or repeat a network request.
+     */
+    public List<Interceptor> networkInterceptors() {
+      return networkInterceptors;
+    }
+
+    public Builder addNetworkInterceptor(Interceptor interceptor) {
+      if (interceptor == null) throw new IllegalArgumentException("interceptor == null");
+      networkInterceptors.add(interceptor);
+      return this;
+    }
+
+    /**
+     * Configure a single client scoped listener that will receive all analytic events
+     * for this client.
+     *
+     * @see EventListener for semantics and restrictions on listener implementations.
+     */
+    public Builder eventListener(EventListener eventListener) {
+      if (eventListener == null) throw new NullPointerException("eventListener == null");
+      this.eventListenerFactory = EventListener.factory(eventListener);
+      return this;
+    }
+
+    /**
+     * Configure a factory to provide per-call scoped listeners that will receive analytic events
+     * for this client.
+     *
+     * @see EventListener for semantics and restrictions on listener implementations.
+     */
+    public Builder eventListenerFactory(EventListener.Factory eventListenerFactory) {
+      if (eventListenerFactory == null) {
+        throw new NullPointerException("eventListenerFactory == null");
+      }
+      this.eventListenerFactory = eventListenerFactory;
+      return this;
+    }
+
+    public OkHttpClient build() {
+      return new OkHttpClient(this);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Protocol.java b/okhttp/src/main/java/okhttp3/Protocol.java
new file mode 100644
index 0000000000..7c4c1afc05
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Protocol.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+
+/**
+ * Protocols that OkHttp implements for <a
+ * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a> selection.
+ *
+ * <h3>Protocol vs Scheme</h3> Despite its name, {@link java.net.URL#getProtocol()} returns the
+ * {@linkplain java.net.URI#getScheme() scheme} (http, https, etc.) of the URL, not the protocol
+ * (http/1.1, spdy/3.1, etc.). OkHttp uses the word <i>protocol</i> to identify how HTTP messages
+ * are framed.
+ */
+public enum Protocol {
+  /**
+   * An obsolete plaintext framing that does not use persistent sockets by default.
+   */
+  HTTP_1_0("http/1.0"),
+
+  /**
+   * A plaintext framing that includes persistent connections.
+   *
+   * <p>This version of OkHttp implements <a href="https://tools.ietf.org/html/rfc7230">RFC
+   * 7230</a>, and tracks revisions to that spec.
+   */
+  HTTP_1_1("http/1.1"),
+
+  /**
+   * Chromium's binary-framed protocol that includes header compression, multiplexing multiple
+   * requests on the same socket, and server-push. HTTP/1.1 semantics are layered on SPDY/3.
+   *
+   * <p>Current versions of OkHttp do not support this protocol.
+   *
+   * @deprecated OkHttp has dropped support for SPDY. Prefer {@link #HTTP_2}.
+   */
+  SPDY_3("spdy/3.1"),
+
+  /**
+   * The IETF's binary-framed protocol that includes header compression, multiplexing multiple
+   * requests on the same socket, and server-push. HTTP/1.1 semantics are layered on HTTP/2.
+   *
+   * <p>HTTP/2 requires deployments of HTTP/2 that use TLS 1.2 support {@linkplain
+   * CipherSuite#TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256} , present in Java 8+ and Android 5+. Servers
+   * that enforce this may send an exception message including the string {@code
+   * INADEQUATE_SECURITY}.
+   */
+  HTTP_2("h2");
+
+  private final String protocol;
+
+  Protocol(String protocol) {
+    this.protocol = protocol;
+  }
+
+  /**
+   * Returns the protocol identified by {@code protocol}.
+   *
+   * @throws IOException if {@code protocol} is unknown.
+   */
+  public static Protocol get(String protocol) throws IOException {
+    // Unroll the loop over values() to save an allocation.
+    if (protocol.equals(HTTP_1_0.protocol)) return HTTP_1_0;
+    if (protocol.equals(HTTP_1_1.protocol)) return HTTP_1_1;
+    if (protocol.equals(HTTP_2.protocol)) return HTTP_2;
+    if (protocol.equals(SPDY_3.protocol)) return SPDY_3;
+    throw new IOException("Unexpected protocol: " + protocol);
+  }
+
+  /**
+   * Returns the string used to identify this protocol for ALPN, like "http/1.1", "spdy/3.1" or
+   * "h2".
+   */
+  @Override public String toString() {
+    return protocol;
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/RealCall.java b/okhttp/src/main/java/okhttp3/RealCall.java
new file mode 100644
index 0000000000..808b3dc7ba
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/RealCall.java
@@ -0,0 +1,202 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import okhttp3.internal.NamedRunnable;
+import okhttp3.internal.cache.CacheInterceptor;
+import okhttp3.internal.connection.ConnectInterceptor;
+import okhttp3.internal.connection.StreamAllocation;
+import okhttp3.internal.http.BridgeInterceptor;
+import okhttp3.internal.http.CallServerInterceptor;
+import okhttp3.internal.http.RealInterceptorChain;
+import okhttp3.internal.http.RetryAndFollowUpInterceptor;
+import okhttp3.internal.platform.Platform;
+
+import static okhttp3.internal.platform.Platform.INFO;
+
+final class RealCall implements Call {
+  final OkHttpClient client;
+  final RetryAndFollowUpInterceptor retryAndFollowUpInterceptor;
+
+  /**
+   * There is a cycle between the {@link Call} and {@link EventListener} that makes this awkward.
+   * This will be set after we create the call instance then create the event listener instance.
+   */
+  private EventListener eventListener;
+
+  /** The application's original request unadulterated by redirects or auth headers. */
+  final Request originalRequest;
+  final boolean forWebSocket;
+
+  // Guarded by this.
+  private boolean executed;
+
+  private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
+    this.client = client;
+    this.originalRequest = originalRequest;
+    this.forWebSocket = forWebSocket;
+    this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket);
+  }
+
+  static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
+    // Safely publish the Call instance to the EventListener.
+    RealCall call = new RealCall(client, originalRequest, forWebSocket);
+    call.eventListener = client.eventListenerFactory().create(call);
+    return call;
+  }
+
+  @Override public Request request() {
+    return originalRequest;
+  }
+
+  @Override public Response execute() throws IOException {
+    synchronized (this) {
+      if (executed) throw new IllegalStateException("Already Executed");
+      executed = true;
+    }
+    captureCallStackTrace();
+    eventListener.callStart(this);
+    try {
+      client.dispatcher().executed(this);
+      Response result = getResponseWithInterceptorChain();
+      if (result == null) throw new IOException("Canceled");
+      return result;
+    } catch (IOException e) {
+      eventListener.callFailed(this, e);
+      throw e;
+    } finally {
+      client.dispatcher().finished(this);
+    }
+  }
+
+  private void captureCallStackTrace() {
+    Object callStackTrace = Platform.get().getStackTraceForCloseable("response.body().close()");
+    retryAndFollowUpInterceptor.setCallStackTrace(callStackTrace);
+  }
+
+  @Override public void enqueue(Callback responseCallback) {
+    synchronized (this) {
+      if (executed) throw new IllegalStateException("Already Executed");
+      executed = true;
+    }
+    captureCallStackTrace();
+    eventListener.callStart(this);
+    client.dispatcher().enqueue(new AsyncCall(responseCallback));
+  }
+
+  @Override public void cancel() {
+    retryAndFollowUpInterceptor.cancel();
+  }
+
+  @Override public synchronized boolean isExecuted() {
+    return executed;
+  }
+
+  @Override public boolean isCanceled() {
+    return retryAndFollowUpInterceptor.isCanceled();
+  }
+
+  @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
+  @Override public RealCall clone() {
+    return RealCall.newRealCall(client, originalRequest, forWebSocket);
+  }
+
+  StreamAllocation streamAllocation() {
+    return retryAndFollowUpInterceptor.streamAllocation();
+  }
+
+  final class AsyncCall extends NamedRunnable {
+    private final Callback responseCallback;
+
+    AsyncCall(Callback responseCallback) {
+      super("OkHttp %s", redactedUrl());
+      this.responseCallback = responseCallback;
+    }
+
+    String host() {
+      return originalRequest.url().host();
+    }
+
+    Request request() {
+      return originalRequest;
+    }
+
+    RealCall get() {
+      return RealCall.this;
+    }
+
+    @Override protected void execute() {
+      boolean signalledCallback = false;
+      try {
+        Response response = getResponseWithInterceptorChain();
+        if (retryAndFollowUpInterceptor.isCanceled()) {
+          signalledCallback = true;
+          responseCallback.onFailure(RealCall.this, new IOException("Canceled"));
+        } else {
+          signalledCallback = true;
+          responseCallback.onResponse(RealCall.this, response);
+        }
+      } catch (IOException e) {
+        if (signalledCallback) {
+          // Do not signal the callback twice!
+          Platform.get().log(INFO, "Callback failure for " + toLoggableString(), e);
+        } else {
+          eventListener.callFailed(RealCall.this, e);
+          responseCallback.onFailure(RealCall.this, e);
+        }
+      } finally {
+        client.dispatcher().finished(this);
+      }
+    }
+  }
+
+  /**
+   * Returns a string that describes this call. Doesn't include a full URL as that might contain
+   * sensitive information.
+   */
+  String toLoggableString() {
+    return (isCanceled() ? "canceled " : "")
+        + (forWebSocket ? "web socket" : "call")
+        + " to " + redactedUrl();
+  }
+
+  String redactedUrl() {
+    return originalRequest.url().redact();
+  }
+
+  Response getResponseWithInterceptorChain() throws IOException {
+    // Build a full stack of interceptors.
+    List<Interceptor> interceptors = new ArrayList<>();
+    interceptors.addAll(client.interceptors());
+    interceptors.add(retryAndFollowUpInterceptor);
+    interceptors.add(new BridgeInterceptor(client.cookieJar()));
+    interceptors.add(new CacheInterceptor(client.internalCache()));
+    interceptors.add(new ConnectInterceptor(client));
+    if (!forWebSocket) {
+      interceptors.addAll(client.networkInterceptors());
+    }
+    interceptors.add(new CallServerInterceptor(forWebSocket));
+
+    Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,
+        originalRequest, this, eventListener, client.connectTimeoutMillis(),
+        client.readTimeoutMillis(), client.writeTimeoutMillis());
+
+    return chain.proceed(originalRequest);
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Request.java b/okhttp/src/main/java/okhttp3/Request.java
new file mode 100644
index 0000000000..cb88696260
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Request.java
@@ -0,0 +1,259 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.net.URL;
+import java.util.List;
+import javax.annotation.Nullable;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.HttpMethod;
+
+/**
+ * An HTTP request. Instances of this class are immutable if their {@link #body} is null or itself
+ * immutable.
+ */
+public final class Request {
+  final HttpUrl url;
+  final String method;
+  final Headers headers;
+  final @Nullable RequestBody body;
+  final Object tag;
+
+  private volatile CacheControl cacheControl; // Lazily initialized.
+
+  Request(Builder builder) {
+    this.url = builder.url;
+    this.method = builder.method;
+    this.headers = builder.headers.build();
+    this.body = builder.body;
+    this.tag = builder.tag != null ? builder.tag : this;
+  }
+
+  public HttpUrl url() {
+    return url;
+  }
+
+  public String method() {
+    return method;
+  }
+
+  public Headers headers() {
+    return headers;
+  }
+
+  public String header(String name) {
+    return headers.get(name);
+  }
+
+  public List<String> headers(String name) {
+    return headers.values(name);
+  }
+
+  public @Nullable RequestBody body() {
+    return body;
+  }
+
+  public Object tag() {
+    return tag;
+  }
+
+  public Builder newBuilder() {
+    return new Builder(this);
+  }
+
+  /**
+   * Returns the cache control directives for this response. This is never null, even if this
+   * response contains no {@code Cache-Control} header.
+   */
+  public CacheControl cacheControl() {
+    CacheControl result = cacheControl;
+    return result != null ? result : (cacheControl = CacheControl.parse(headers));
+  }
+
+  public boolean isHttps() {
+    return url.isHttps();
+  }
+
+  @Override public String toString() {
+    return "Request{method="
+        + method
+        + ", url="
+        + url
+        + ", tag="
+        + (tag != this ? tag : null)
+        + '}';
+  }
+
+  public static class Builder {
+    HttpUrl url;
+    String method;
+    Headers.Builder headers;
+    RequestBody body;
+    Object tag;
+
+    public Builder() {
+      this.method = "GET";
+      this.headers = new Headers.Builder();
+    }
+
+    Builder(Request request) {
+      this.url = request.url;
+      this.method = request.method;
+      this.body = request.body;
+      this.tag = request.tag;
+      this.headers = request.headers.newBuilder();
+    }
+
+    public Builder url(HttpUrl url) {
+      if (url == null) throw new NullPointerException("url == null");
+      this.url = url;
+      return this;
+    }
+
+    /**
+     * Sets the URL target of this request.
+     *
+     * @throws IllegalArgumentException if {@code url} is not a valid HTTP or HTTPS URL. Avoid this
+     * exception by calling {@link HttpUrl#parse}; it returns null for invalid URLs.
+     */
+    public Builder url(String url) {
+      if (url == null) throw new NullPointerException("url == null");
+
+      // Silently replace web socket URLs with HTTP URLs.
+      if (url.regionMatches(true, 0, "ws:", 0, 3)) {
+        url = "http:" + url.substring(3);
+      } else if (url.regionMatches(true, 0, "wss:", 0, 4)) {
+        url = "https:" + url.substring(4);
+      }
+
+      HttpUrl parsed = HttpUrl.parse(url);
+      if (parsed == null) throw new IllegalArgumentException("unexpected url: " + url);
+      return url(parsed);
+    }
+
+    /**
+     * Sets the URL target of this request.
+     *
+     * @throws IllegalArgumentException if the scheme of {@code url} is not {@code http} or {@code
+     * https}.
+     */
+    public Builder url(URL url) {
+      if (url == null) throw new NullPointerException("url == null");
+      HttpUrl parsed = HttpUrl.get(url);
+      if (parsed == null) throw new IllegalArgumentException("unexpected url: " + url);
+      return url(parsed);
+    }
+
+    /**
+     * Sets the header named {@code name} to {@code value}. If this request already has any headers
+     * with that name, they are all replaced.
+     */
+    public Builder header(String name, String value) {
+      headers.set(name, value);
+      return this;
+    }
+
+    /**
+     * Adds a header with {@code name} and {@code value}. Prefer this method for multiply-valued
+     * headers like "Cookie".
+     *
+     * <p>Note that for some headers including {@code Content-Length} and {@code Content-Encoding},
+     * OkHttp may replace {@code value} with a header derived from the request body.
+     */
+    public Builder addHeader(String name, String value) {
+      headers.add(name, value);
+      return this;
+    }
+
+    public Builder removeHeader(String name) {
+      headers.removeAll(name);
+      return this;
+    }
+
+    /** Removes all headers on this builder and adds {@code headers}. */
+    public Builder headers(Headers headers) {
+      this.headers = headers.newBuilder();
+      return this;
+    }
+
+    /**
+     * Sets this request's {@code Cache-Control} header, replacing any cache control headers already
+     * present. If {@code cacheControl} doesn't define any directives, this clears this request's
+     * cache-control headers.
+     */
+    public Builder cacheControl(CacheControl cacheControl) {
+      String value = cacheControl.toString();
+      if (value.isEmpty()) return removeHeader("Cache-Control");
+      return header("Cache-Control", value);
+    }
+
+    public Builder get() {
+      return method("GET", null);
+    }
+
+    public Builder head() {
+      return method("HEAD", null);
+    }
+
+    public Builder post(RequestBody body) {
+      return method("POST", body);
+    }
+
+    public Builder delete(@Nullable RequestBody body) {
+      return method("DELETE", body);
+    }
+
+    public Builder delete() {
+      return delete(Util.EMPTY_REQUEST);
+    }
+
+    public Builder put(RequestBody body) {
+      return method("PUT", body);
+    }
+
+    public Builder patch(RequestBody body) {
+      return method("PATCH", body);
+    }
+
+    public Builder method(String method, @Nullable RequestBody body) {
+      if (method == null) throw new NullPointerException("method == null");
+      if (method.length() == 0) throw new IllegalArgumentException("method.length() == 0");
+      if (body != null && !HttpMethod.permitsRequestBody(method)) {
+        throw new IllegalArgumentException("method " + method + " must not have a request body.");
+      }
+      if (body == null && HttpMethod.requiresRequestBody(method)) {
+        throw new IllegalArgumentException("method " + method + " must have a request body.");
+      }
+      this.method = method;
+      this.body = body;
+      return this;
+    }
+
+    /**
+     * Attaches {@code tag} to the request. It can be used later to cancel the request. If the tag
+     * is unspecified or null, the request is canceled by using the request itself as the tag.
+     */
+    public Builder tag(Object tag) {
+      this.tag = tag;
+      return this;
+    }
+
+    public Request build() {
+      if (url == null) throw new IllegalStateException("url == null");
+      return new Request(this);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/RequestBody.java b/okhttp/src/main/java/okhttp3/RequestBody.java
new file mode 100644
index 0000000000..3cb29477d3
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/RequestBody.java
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.charset.Charset;
+import javax.annotation.Nullable;
+import okhttp3.internal.Util;
+import okio.BufferedSink;
+import okio.ByteString;
+import okio.Okio;
+import okio.Source;
+
+public abstract class RequestBody {
+  /** Returns the Content-Type header for this body. */
+  public abstract @Nullable MediaType contentType();
+
+  /**
+   * Returns the number of bytes that will be written to {@code sink} in a call to {@link #writeTo},
+   * or -1 if that count is unknown.
+   */
+  public long contentLength() throws IOException {
+    return -1;
+  }
+
+  /** Writes the content of this request to {@code sink}. */
+  public abstract void writeTo(BufferedSink sink) throws IOException;
+
+  /**
+   * Returns a new request body that transmits {@code content}. If {@code contentType} is non-null
+   * and lacks a charset, this will use UTF-8.
+   */
+  public static RequestBody create(@Nullable MediaType contentType, String content) {
+    Charset charset = Util.UTF_8;
+    if (contentType != null) {
+      charset = contentType.charset();
+      if (charset == null) {
+        charset = Util.UTF_8;
+        contentType = MediaType.parse(contentType + "; charset=utf-8");
+      }
+    }
+    byte[] bytes = content.getBytes(charset);
+    return create(contentType, bytes);
+  }
+
+  /** Returns a new request body that transmits {@code content}. */
+  public static RequestBody create(
+      final @Nullable MediaType contentType, final ByteString content) {
+    return new RequestBody() {
+      @Override public @Nullable MediaType contentType() {
+        return contentType;
+      }
+
+      @Override public long contentLength() throws IOException {
+        return content.size();
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.write(content);
+      }
+    };
+  }
+
+  /** Returns a new request body that transmits {@code content}. */
+  public static RequestBody create(final @Nullable MediaType contentType, final byte[] content) {
+    return create(contentType, content, 0, content.length);
+  }
+
+  /** Returns a new request body that transmits {@code content}. */
+  public static RequestBody create(final @Nullable MediaType contentType, final byte[] content,
+      final int offset, final int byteCount) {
+    if (content == null) throw new NullPointerException("content == null");
+    Util.checkOffsetAndCount(content.length, offset, byteCount);
+    return new RequestBody() {
+      @Override public @Nullable MediaType contentType() {
+        return contentType;
+      }
+
+      @Override public long contentLength() {
+        return byteCount;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.write(content, offset, byteCount);
+      }
+    };
+  }
+
+  /** Returns a new request body that transmits the content of {@code file}. */
+  public static RequestBody create(final @Nullable MediaType contentType, final File file) {
+    if (file == null) throw new NullPointerException("content == null");
+
+    return new RequestBody() {
+      @Override public @Nullable MediaType contentType() {
+        return contentType;
+      }
+
+      @Override public long contentLength() {
+        return file.length();
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        Source source = null;
+        try {
+          source = Okio.source(file);
+          sink.writeAll(source);
+        } finally {
+          Util.closeQuietly(source);
+        }
+      }
+    };
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Response.java b/okhttp/src/main/java/okhttp3/Response.java
new file mode 100644
index 0000000000..1e3ab454a5
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Response.java
@@ -0,0 +1,444 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.util.Collections;
+import java.util.List;
+import javax.annotation.Nullable;
+import okhttp3.internal.http.HttpHeaders;
+import okio.Buffer;
+import okio.BufferedSource;
+
+import static java.net.HttpURLConnection.HTTP_MOVED_PERM;
+import static java.net.HttpURLConnection.HTTP_MOVED_TEMP;
+import static java.net.HttpURLConnection.HTTP_MULT_CHOICE;
+import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
+import static java.net.HttpURLConnection.HTTP_SEE_OTHER;
+import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
+import static okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT;
+import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
+
+/**
+ * An HTTP response. Instances of this class are not immutable: the response body is a one-shot
+ * value that may be consumed only once and then closed. All other properties are immutable.
+ *
+ * <p>This class implements {@link Closeable}. Closing it simply closes its response body. See
+ * {@link ResponseBody} for an explanation and examples.
+ */
+public final class Response implements Closeable {
+  final Request request;
+  final Protocol protocol;
+  final int code;
+  final String message;
+  final @Nullable Handshake handshake;
+  final Headers headers;
+  final @Nullable ResponseBody body;
+  final @Nullable Response networkResponse;
+  final @Nullable Response cacheResponse;
+  final @Nullable Response priorResponse;
+  final long sentRequestAtMillis;
+  final long receivedResponseAtMillis;
+
+  private volatile CacheControl cacheControl; // Lazily initialized.
+
+  Response(Builder builder) {
+    this.request = builder.request;
+    this.protocol = builder.protocol;
+    this.code = builder.code;
+    this.message = builder.message;
+    this.handshake = builder.handshake;
+    this.headers = builder.headers.build();
+    this.body = builder.body;
+    this.networkResponse = builder.networkResponse;
+    this.cacheResponse = builder.cacheResponse;
+    this.priorResponse = builder.priorResponse;
+    this.sentRequestAtMillis = builder.sentRequestAtMillis;
+    this.receivedResponseAtMillis = builder.receivedResponseAtMillis;
+  }
+
+  /**
+   * The wire-level request that initiated this HTTP response. This is not necessarily the same
+   * request issued by the application:
+   *
+   * <ul>
+   *     <li>It may be transformed by the HTTP client. For example, the client may copy headers like
+   *         {@code Content-Length} from the request body.
+   *     <li>It may be the request generated in response to an HTTP redirect or authentication
+   *         challenge. In this case the request URL may be different than the initial request URL.
+   * </ul>
+   */
+  public Request request() {
+    return request;
+  }
+
+  /**
+   * Returns the HTTP protocol, such as {@link Protocol#HTTP_1_1} or {@link Protocol#HTTP_1_0}.
+   */
+  public Protocol protocol() {
+    return protocol;
+  }
+
+  /** Returns the HTTP status code. */
+  public int code() {
+    return code;
+  }
+
+  /**
+   * Returns true if the code is in [200..300), which means the request was successfully received,
+   * understood, and accepted.
+   */
+  public boolean isSuccessful() {
+    return code >= 200 && code < 300;
+  }
+
+  /** Returns the HTTP status message. */
+  public String message() {
+    return message;
+  }
+
+  /**
+   * Returns the TLS handshake of the connection that carried this response, or null if the response
+   * was received without TLS.
+   */
+  public Handshake handshake() {
+    return handshake;
+  }
+
+  public List<String> headers(String name) {
+    return headers.values(name);
+  }
+
+  public @Nullable String header(String name) {
+    return header(name, null);
+  }
+
+  public @Nullable String header(String name, @Nullable String defaultValue) {
+    String result = headers.get(name);
+    return result != null ? result : defaultValue;
+  }
+
+  public Headers headers() {
+    return headers;
+  }
+
+  /**
+   * Peeks up to {@code byteCount} bytes from the response body and returns them as a new response
+   * body. If fewer than {@code byteCount} bytes are in the response body, the full response body is
+   * returned. If more than {@code byteCount} bytes are in the response body, the returned value
+   * will be truncated to {@code byteCount} bytes.
+   *
+   * <p>It is an error to call this method after the body has been consumed.
+   *
+   * <p><strong>Warning:</strong> this method loads the requested bytes into memory. Most
+   * applications should set a modest limit on {@code byteCount}, such as 1 MiB.
+   */
+  public ResponseBody peekBody(long byteCount) throws IOException {
+    BufferedSource source = body.source();
+    source.request(byteCount);
+    Buffer copy = source.buffer().clone();
+
+    // There may be more than byteCount bytes in source.buffer(). If there is, return a prefix.
+    Buffer result;
+    if (copy.size() > byteCount) {
+      result = new Buffer();
+      result.write(copy, byteCount);
+      copy.clear();
+    } else {
+      result = copy;
+    }
+
+    return ResponseBody.create(body.contentType(), result.size(), result);
+  }
+
+  /**
+   * Returns a non-null value if this response was passed to {@link Callback#onResponse} or returned
+   * from {@link Call#execute()}. Response bodies must be {@linkplain ResponseBody closed} and may
+   * be consumed only once.
+   *
+   * <p>This always returns null on responses returned from {@link #cacheResponse}, {@link
+   * #networkResponse}, and {@link #priorResponse()}.
+   */
+  public @Nullable ResponseBody body() {
+    return body;
+  }
+
+  public Builder newBuilder() {
+    return new Builder(this);
+  }
+
+  /** Returns true if this response redirects to another resource. */
+  public boolean isRedirect() {
+    switch (code) {
+      case HTTP_PERM_REDIRECT:
+      case HTTP_TEMP_REDIRECT:
+      case HTTP_MULT_CHOICE:
+      case HTTP_MOVED_PERM:
+      case HTTP_MOVED_TEMP:
+      case HTTP_SEE_OTHER:
+        return true;
+      default:
+        return false;
+    }
+  }
+
+  /**
+   * Returns the raw response received from the network. Will be null if this response didn't use
+   * the network, such as when the response is fully cached. The body of the returned response
+   * should not be read.
+   */
+  public @Nullable Response networkResponse() {
+    return networkResponse;
+  }
+
+  /**
+   * Returns the raw response received from the cache. Will be null if this response didn't use the
+   * cache. For conditional get requests the cache response and network response may both be
+   * non-null. The body of the returned response should not be read.
+   */
+  public @Nullable Response cacheResponse() {
+    return cacheResponse;
+  }
+
+  /**
+   * Returns the response for the HTTP redirect or authorization challenge that triggered this
+   * response, or null if this response wasn't triggered by an automatic retry. The body of the
+   * returned response should not be read because it has already been consumed by the redirecting
+   * client.
+   */
+  public @Nullable Response priorResponse() {
+    return priorResponse;
+  }
+
+  /**
+   * Returns the authorization challenges appropriate for this response's code. If the response code
+   * is 401 unauthorized, this returns the "WWW-Authenticate" challenges. If the response code is
+   * 407 proxy unauthorized, this returns the "Proxy-Authenticate" challenges. Otherwise this
+   * returns an empty list of challenges.
+   */
+  public List<Challenge> challenges() {
+    String responseField;
+    if (code == HTTP_UNAUTHORIZED) {
+      responseField = "WWW-Authenticate";
+    } else if (code == HTTP_PROXY_AUTH) {
+      responseField = "Proxy-Authenticate";
+    } else {
+      return Collections.emptyList();
+    }
+    return HttpHeaders.parseChallenges(headers(), responseField);
+  }
+
+  /**
+   * Returns the cache control directives for this response. This is never null, even if this
+   * response contains no {@code Cache-Control} header.
+   */
+  public CacheControl cacheControl() {
+    CacheControl result = cacheControl;
+    return result != null ? result : (cacheControl = CacheControl.parse(headers));
+  }
+
+  /**
+   * Returns a {@linkplain System#currentTimeMillis() timestamp} taken immediately before OkHttp
+   * transmitted the initiating request over the network. If this response is being served from the
+   * cache then this is the timestamp of the original request.
+   */
+  public long sentRequestAtMillis() {
+    return sentRequestAtMillis;
+  }
+
+  /**
+   * Returns a {@linkplain System#currentTimeMillis() timestamp} taken immediately after OkHttp
+   * received this response's headers from the network. If this response is being served from the
+   * cache then this is the timestamp of the original response.
+   */
+  public long receivedResponseAtMillis() {
+    return receivedResponseAtMillis;
+  }
+
+  /**
+   * Closes the response body. Equivalent to {@code body().close()}.
+   *
+   * <p>It is an error to close a response that is not eligible for a body. This includes the
+   * responses returned from {@link #cacheResponse}, {@link #networkResponse}, and {@link
+   * #priorResponse()}.
+   */
+  @Override public void close() {
+    if (body == null) {
+      throw new IllegalStateException("response is not eligible for a body and must not be closed");
+    }
+    body.close();
+  }
+
+  @Override public String toString() {
+    return "Response{protocol="
+        + protocol
+        + ", code="
+        + code
+        + ", message="
+        + message
+        + ", url="
+        + request.url()
+        + '}';
+  }
+
+  public static class Builder {
+    Request request;
+    Protocol protocol;
+    int code = -1;
+    String message;
+    @Nullable Handshake handshake;
+    Headers.Builder headers;
+    ResponseBody body;
+    Response networkResponse;
+    Response cacheResponse;
+    Response priorResponse;
+    long sentRequestAtMillis;
+    long receivedResponseAtMillis;
+
+    public Builder() {
+      headers = new Headers.Builder();
+    }
+
+    Builder(Response response) {
+      this.request = response.request;
+      this.protocol = response.protocol;
+      this.code = response.code;
+      this.message = response.message;
+      this.handshake = response.handshake;
+      this.headers = response.headers.newBuilder();
+      this.body = response.body;
+      this.networkResponse = response.networkResponse;
+      this.cacheResponse = response.cacheResponse;
+      this.priorResponse = response.priorResponse;
+      this.sentRequestAtMillis = response.sentRequestAtMillis;
+      this.receivedResponseAtMillis = response.receivedResponseAtMillis;
+    }
+
+    public Builder request(Request request) {
+      this.request = request;
+      return this;
+    }
+
+    public Builder protocol(Protocol protocol) {
+      this.protocol = protocol;
+      return this;
+    }
+
+    public Builder code(int code) {
+      this.code = code;
+      return this;
+    }
+
+    public Builder message(String message) {
+      this.message = message;
+      return this;
+    }
+
+    public Builder handshake(@Nullable Handshake handshake) {
+      this.handshake = handshake;
+      return this;
+    }
+
+    /**
+     * Sets the header named {@code name} to {@code value}. If this request already has any headers
+     * with that name, they are all replaced.
+     */
+    public Builder header(String name, String value) {
+      headers.set(name, value);
+      return this;
+    }
+
+    /**
+     * Adds a header with {@code name} and {@code value}. Prefer this method for multiply-valued
+     * headers like "Set-Cookie".
+     */
+    public Builder addHeader(String name, String value) {
+      headers.add(name, value);
+      return this;
+    }
+
+    public Builder removeHeader(String name) {
+      headers.removeAll(name);
+      return this;
+    }
+
+    /** Removes all headers on this builder and adds {@code headers}. */
+    public Builder headers(Headers headers) {
+      this.headers = headers.newBuilder();
+      return this;
+    }
+
+    public Builder body(@Nullable ResponseBody body) {
+      this.body = body;
+      return this;
+    }
+
+    public Builder networkResponse(@Nullable Response networkResponse) {
+      if (networkResponse != null) checkSupportResponse("networkResponse", networkResponse);
+      this.networkResponse = networkResponse;
+      return this;
+    }
+
+    public Builder cacheResponse(@Nullable Response cacheResponse) {
+      if (cacheResponse != null) checkSupportResponse("cacheResponse", cacheResponse);
+      this.cacheResponse = cacheResponse;
+      return this;
+    }
+
+    private void checkSupportResponse(String name, Response response) {
+      if (response.body != null) {
+        throw new IllegalArgumentException(name + ".body != null");
+      } else if (response.networkResponse != null) {
+        throw new IllegalArgumentException(name + ".networkResponse != null");
+      } else if (response.cacheResponse != null) {
+        throw new IllegalArgumentException(name + ".cacheResponse != null");
+      } else if (response.priorResponse != null) {
+        throw new IllegalArgumentException(name + ".priorResponse != null");
+      }
+    }
+
+    public Builder priorResponse(@Nullable Response priorResponse) {
+      if (priorResponse != null) checkPriorResponse(priorResponse);
+      this.priorResponse = priorResponse;
+      return this;
+    }
+
+    private void checkPriorResponse(Response response) {
+      if (response.body != null) {
+        throw new IllegalArgumentException("priorResponse.body != null");
+      }
+    }
+
+    public Builder sentRequestAtMillis(long sentRequestAtMillis) {
+      this.sentRequestAtMillis = sentRequestAtMillis;
+      return this;
+    }
+
+    public Builder receivedResponseAtMillis(long receivedResponseAtMillis) {
+      this.receivedResponseAtMillis = receivedResponseAtMillis;
+      return this;
+    }
+
+    public Response build() {
+      if (request == null) throw new IllegalStateException("request == null");
+      if (protocol == null) throw new IllegalStateException("protocol == null");
+      if (code < 0) throw new IllegalStateException("code < 0: " + code);
+      if (message == null) throw new IllegalStateException("message == null");
+      return new Response(this);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/ResponseBody.java b/okhttp/src/main/java/okhttp3/ResponseBody.java
new file mode 100644
index 0000000000..17447f3d64
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/ResponseBody.java
@@ -0,0 +1,264 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.Reader;
+import java.nio.charset.Charset;
+import javax.annotation.Nullable;
+import okhttp3.internal.Util;
+import okio.Buffer;
+import okio.BufferedSource;
+
+import static okhttp3.internal.Util.UTF_8;
+
+/**
+ * A one-shot stream from the origin server to the client application with the raw bytes of the
+ * response body. Each response body is supported by an active connection to the webserver. This
+ * imposes both obligations and limits on the client application.
+ *
+ * <h3>The response body must be closed.</h3>
+ *
+ * Each response body is backed by a limited resource like a socket (live network responses) or
+ * an open file (for cached responses). Failing to close the response body will leak resources and
+ * may ultimately cause the application to slow down or crash.
+ *
+ * <p>Both this class and {@link Response} implement {@link Closeable}. Closing a response simply
+ * closes its response body. If you invoke {@link Call#execute()} or implement {@link
+ * Callback#onResponse} you must close this body by calling any of the following methods:
+ *
+ * <ul>
+ *   <li>Response.close()</li>
+ *   <li>Response.body().close()</li>
+ *   <li>Response.body().source().close()</li>
+ *   <li>Response.body().charStream().close()</li>
+ *   <li>Response.body().byteString().close()</li>
+ *   <li>Response.body().bytes()</li>
+ *   <li>Response.body().string()</li>
+ * </ul>
+ *
+ * <p>There is no benefit to invoking multiple {@code close()} methods for the same response body.
+ *
+ * <p>For synchronous calls, the easiest way to make sure a response body is closed is with a {@code
+ * try} block. With this structure the compiler inserts an implicit {@code finally} clause that
+ * calls {@code close()} for you.
+ *
+ * <pre>   {@code
+ *
+ *   Call call = client.newCall(request);
+ *   try (Response response = call.execute()) {
+ *     ... // Use the response.
+ *   }
+ * }</pre>
+ *
+ * You can use a similar block for asynchronous calls: <pre>   {@code
+ *
+ *   Call call = client.newCall(request);
+ *   call.enqueue(new Callback() {
+ *     public void onResponse(Call call, Response response) throws IOException {
+ *       try (ResponseBody responseBody = response.body()) {
+ *         ... // Use the response.
+ *       }
+ *     }
+ *
+ *     public void onFailure(Call call, IOException e) {
+ *       ... // Handle the failure.
+ *     }
+ *   });
+ * }</pre>
+ *
+ * These examples will not work if you're consuming the response body on another thread. In such
+ * cases the consuming thread must call {@link #close} when it has finished reading the response
+ * body.
+ *
+ * <h3>The response body can be consumed only once.</h3>
+ *
+ * <p>This class may be used to stream very large responses. For example, it is possible to use this
+ * class to read a response that is larger than the entire memory allocated to the current process.
+ * It can even stream a response larger than the total storage on the current device, which is a
+ * common requirement for video streaming applications.
+ *
+ * <p>Because this class does not buffer the full response in memory, the application may not
+ * re-read the bytes of the response. Use this one shot to read the entire response into memory with
+ * {@link #bytes()} or {@link #string()}. Or stream the response with either {@link #source()},
+ * {@link #byteStream()}, or {@link #charStream()}.
+ */
+public abstract class ResponseBody implements Closeable {
+  /** Multiple calls to {@link #charStream()} must return the same instance. */
+  private Reader reader;
+
+  public abstract @Nullable MediaType contentType();
+
+  /**
+   * Returns the number of bytes in that will returned by {@link #bytes}, or {@link #byteStream}, or
+   * -1 if unknown.
+   */
+  public abstract long contentLength();
+
+  public final InputStream byteStream() {
+    return source().inputStream();
+  }
+
+  public abstract BufferedSource source();
+
+  /**
+   * Returns the response as a byte array.
+   *
+   * <p>This method loads entire response body into memory. If the response body is very large this
+   * may trigger an {@link OutOfMemoryError}. Prefer to stream the response body if this is a
+   * possibility for your response.
+   */
+  public final byte[] bytes() throws IOException {
+    long contentLength = contentLength();
+    if (contentLength > Integer.MAX_VALUE) {
+      throw new IOException("Cannot buffer entire body for content length: " + contentLength);
+    }
+
+    BufferedSource source = source();
+    byte[] bytes;
+    try {
+      bytes = source.readByteArray();
+    } finally {
+      Util.closeQuietly(source);
+    }
+    if (contentLength != -1 && contentLength != bytes.length) {
+      throw new IOException("Content-Length ("
+          + contentLength
+          + ") and stream length ("
+          + bytes.length
+          + ") disagree");
+    }
+    return bytes;
+  }
+
+  /**
+   * Returns the response as a character stream decoded with the charset of the Content-Type header.
+   * If that header is either absent or lacks a charset, this will attempt to decode the response
+   * body in accordance to <a href="https://en.wikipedia.org/wiki/Byte_order_mark">its BOM</a> or
+   * UTF-8.
+   */
+  public final Reader charStream() {
+    Reader r = reader;
+    return r != null ? r : (reader = new BomAwareReader(source(), charset()));
+  }
+
+  /**
+   * Returns the response as a string decoded with the charset of the Content-Type header. If that
+   * header is either absent or lacks a charset, this will attempt to decode the response body in
+   * accordance to <a href="https://en.wikipedia.org/wiki/Byte_order_mark">its BOM</a> or UTF-8.
+   * Closes {@link ResponseBody} automatically.
+   *
+   * <p>This method loads entire response body into memory. If the response body is very large this
+   * may trigger an {@link OutOfMemoryError}. Prefer to stream the response body if this is a
+   * possibility for your response.
+   */
+  public final String string() throws IOException {
+    BufferedSource source = source();
+    try {
+      Charset charset = Util.bomAwareCharset(source, charset());
+      return source.readString(charset);
+    } finally {
+      Util.closeQuietly(source);
+    }
+  }
+
+  private Charset charset() {
+    MediaType contentType = contentType();
+    return contentType != null ? contentType.charset(UTF_8) : UTF_8;
+  }
+
+  @Override public void close() {
+    Util.closeQuietly(source());
+  }
+
+  /**
+   * Returns a new response body that transmits {@code content}. If {@code contentType} is non-null
+   * and lacks a charset, this will use UTF-8.
+   */
+  public static ResponseBody create(@Nullable MediaType contentType, String content) {
+    Charset charset = UTF_8;
+    if (contentType != null) {
+      charset = contentType.charset();
+      if (charset == null) {
+        charset = UTF_8;
+        contentType = MediaType.parse(contentType + "; charset=utf-8");
+      }
+    }
+    Buffer buffer = new Buffer().writeString(content, charset);
+    return create(contentType, buffer.size(), buffer);
+  }
+
+  /** Returns a new response body that transmits {@code content}. */
+  public static ResponseBody create(final @Nullable MediaType contentType, byte[] content) {
+    Buffer buffer = new Buffer().write(content);
+    return create(contentType, content.length, buffer);
+  }
+
+  /** Returns a new response body that transmits {@code content}. */
+  public static ResponseBody create(final @Nullable MediaType contentType,
+      final long contentLength, final BufferedSource content) {
+    if (content == null) throw new NullPointerException("source == null");
+    return new ResponseBody() {
+      @Override public @Nullable MediaType contentType() {
+        return contentType;
+      }
+
+      @Override public long contentLength() {
+        return contentLength;
+      }
+
+      @Override public BufferedSource source() {
+        return content;
+      }
+    };
+  }
+
+  static final class BomAwareReader extends Reader {
+    private final BufferedSource source;
+    private final Charset charset;
+
+    private boolean closed;
+    private Reader delegate;
+
+    BomAwareReader(BufferedSource source, Charset charset) {
+      this.source = source;
+      this.charset = charset;
+    }
+
+    @Override public int read(char[] cbuf, int off, int len) throws IOException {
+      if (closed) throw new IOException("Stream closed");
+
+      Reader delegate = this.delegate;
+      if (delegate == null) {
+        Charset charset = Util.bomAwareCharset(source, this.charset);
+        delegate = this.delegate = new InputStreamReader(source.inputStream(), charset);
+      }
+      return delegate.read(cbuf, off, len);
+    }
+
+    @Override public void close() throws IOException {
+      closed = true;
+      if (delegate != null) {
+        delegate.close();
+      } else {
+        source.close();
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Route.java b/okhttp/src/main/java/okhttp3/Route.java
new file mode 100644
index 0000000000..14158673ca
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Route.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import javax.annotation.Nullable;
+
+/**
+ * The concrete route used by a connection to reach an abstract origin server. When creating a
+ * connection the client has many options:
+ *
+ * <ul>
+ *     <li><strong>HTTP proxy:</strong> a proxy server may be explicitly configured for the client.
+ *         Otherwise the {@linkplain java.net.ProxySelector proxy selector} is used. It may return
+ *         multiple proxies to attempt.
+ *     <li><strong>IP address:</strong> whether connecting directly to an origin server or a proxy,
+ *         opening a socket requires an IP address. The DNS server may return multiple IP addresses
+ *         to attempt.
+ * </ul>
+ *
+ * <p>Each route is a specific selection of these options.
+ */
+public final class Route {
+  final Address address;
+  final Proxy proxy;
+  final InetSocketAddress inetSocketAddress;
+
+  public Route(Address address, Proxy proxy, InetSocketAddress inetSocketAddress) {
+    if (address == null) {
+      throw new NullPointerException("address == null");
+    }
+    if (proxy == null) {
+      throw new NullPointerException("proxy == null");
+    }
+    if (inetSocketAddress == null) {
+      throw new NullPointerException("inetSocketAddress == null");
+    }
+    this.address = address;
+    this.proxy = proxy;
+    this.inetSocketAddress = inetSocketAddress;
+  }
+
+  public Address address() {
+    return address;
+  }
+
+  /**
+   * Returns the {@link Proxy} of this route.
+   *
+   * <strong>Warning:</strong> This may disagree with {@link Address#proxy} when it is null. When
+   * the address's proxy is null, the proxy selector is used.
+   */
+  public Proxy proxy() {
+    return proxy;
+  }
+
+  public InetSocketAddress socketAddress() {
+    return inetSocketAddress;
+  }
+
+  /**
+   * Returns true if this route tunnels HTTPS through an HTTP proxy. See <a
+   * href="http://www.ietf.org/rfc/rfc2817.txt">RFC 2817, Section 5.2</a>.
+   */
+  public boolean requiresTunnel() {
+    return address.sslSocketFactory != null && proxy.type() == Proxy.Type.HTTP;
+  }
+
+  @Override public boolean equals(@Nullable Object other) {
+    return other instanceof Route
+        && ((Route) other).address.equals(address)
+        && ((Route) other).proxy.equals(proxy)
+        && ((Route) other).inetSocketAddress.equals(inetSocketAddress);
+  }
+
+  @Override public int hashCode() {
+    int result = 17;
+    result = 31 * result + address.hashCode();
+    result = 31 * result + proxy.hashCode();
+    result = 31 * result + inetSocketAddress.hashCode();
+    return result;
+  }
+
+  @Override public String toString() {
+    return "Route{" + inetSocketAddress + "}";
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/TlsVersion.java b/okhttp/src/main/java/okhttp3/TlsVersion.java
new file mode 100644
index 0000000000..02cbeca3d1
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/TlsVersion.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * Versions of TLS that can be offered when negotiating a secure socket. See {@link
+ * javax.net.ssl.SSLSocket#setEnabledProtocols}.
+ */
+public enum TlsVersion {
+  TLS_1_3("TLSv1.3"), // 2016.
+  TLS_1_2("TLSv1.2"), // 2008.
+  TLS_1_1("TLSv1.1"), // 2006.
+  TLS_1_0("TLSv1"),   // 1999.
+  SSL_3_0("SSLv3"),   // 1996.
+  ;
+
+  final String javaName;
+
+  TlsVersion(String javaName) {
+    this.javaName = javaName;
+  }
+
+  public static TlsVersion forJavaName(String javaName) {
+    switch (javaName) {
+      case "TLSv1.3":
+        return TLS_1_3;
+      case "TLSv1.2":
+        return TLS_1_2;
+      case "TLSv1.1":
+        return TLS_1_1;
+      case "TLSv1":
+        return TLS_1_0;
+      case "SSLv3":
+        return SSL_3_0;
+    }
+    throw new IllegalArgumentException("Unexpected TLS version: " + javaName);
+  }
+
+  static List<TlsVersion> forJavaNames(String... tlsVersions) {
+    List<TlsVersion> result = new ArrayList<>(tlsVersions.length);
+    for (String tlsVersion : tlsVersions) {
+      result.add(forJavaName(tlsVersion));
+    }
+    return Collections.unmodifiableList(result);
+  }
+
+  public String javaName() {
+    return javaName;
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/WebSocket.java b/okhttp/src/main/java/okhttp3/WebSocket.java
new file mode 100644
index 0000000000..42daf90594
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/WebSocket.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import javax.annotation.Nullable;
+import okio.ByteString;
+
+/**
+ * A non-blocking interface to a web socket. Use the {@linkplain WebSocket.Factory factory} to
+ * create instances; usually this is {@link OkHttpClient}.
+ *
+ * <h3>Web Socket Lifecycle</h3>
+ *
+ * Upon normal operation each web socket progresses through a sequence of states:
+ *
+ * <ul>
+ *   <li><strong>Connecting:</strong> the initial state of each web socket. Messages may be enqueued
+ *       but they won't be transmitted until the web socket is open.
+ *   <li><strong>Open:</strong> the web socket has been accepted by the remote peer and is fully
+ *       operational. Messages in either direction are enqueued for immediate transmission.
+ *   <li><strong>Closing:</strong> one of the peers on the web socket has initiated a graceful
+ *       shutdown. The web socket will continue to transmit already-enqueued messages but will
+ *       refuse to enqueue new ones.
+ *   <li><strong>Closed:</strong> the web socket has transmitted all of its messages and has
+ *       received all messages from the peer.
+ * </ul>
+ *
+ * Web sockets may fail due to HTTP upgrade problems, connectivity problems, or if either peer
+ * chooses to short-circuit the graceful shutdown process:
+ *
+ * <ul>
+ *   <li><strong>Canceled:</strong> the web socket connection failed. Messages that were
+ *       successfully enqueued by either peer may not have been transmitted to the other.
+ * </ul>
+ *
+ * Note that the state progression is independent for each peer. Arriving at a gracefully-closed
+ * state indicates that a peer has sent all of its outgoing messages and received all of its
+ * incoming messages. But it does not guarantee that the other peer will successfully receive all of
+ * its incoming messages.
+ */
+public interface WebSocket {
+  /** Returns the original request that initiated this web socket. */
+  Request request();
+
+  /**
+   * Returns the size in bytes of all messages enqueued to be transmitted to the server. This
+   * doesn't include framing overhead. It also doesn't include any bytes buffered by the operating
+   * system or network intermediaries. This method returns 0 if no messages are waiting
+   * in the queue. If may return a nonzero value after the web socket has been canceled; this
+   * indicates that enqueued messages were not transmitted.
+   */
+  long queueSize();
+
+  /**
+   * Attempts to enqueue {@code text} to be UTF-8 encoded and sent as a the data of a text (type
+   * {@code 0x1}) message.
+   *
+   * <p>This method returns true if the message was enqueued. Messages that would overflow the
+   * outgoing message buffer will be rejected and trigger a {@linkplain #close graceful shutdown} of
+   * this web socket. This method returns false in that case, and in any other case where this
+   * web socket is closing, closed, or canceled.
+   *
+   * <p>This method returns immediately.
+   */
+  boolean send(String text);
+
+  /**
+   * Attempts to enqueue {@code bytes} to be sent as a the data of a binary (type {@code 0x2})
+   * message.
+   *
+   * <p>This method returns true if the message was enqueued. Messages that would overflow the
+   * outgoing message buffer will be rejected and trigger a {@linkplain #close graceful shutdown} of
+   * this web socket. This method returns false in that case, and in any other case where this
+   * web socket is closing, closed, or canceled.
+   *
+   * <p>This method returns immediately.
+   */
+  boolean send(ByteString bytes);
+
+  /**
+   * Attempts to initiate a graceful shutdown of this web socket. Any already-enqueued messages will
+   * be transmitted before the close message is sent but subsequent calls to {@link #send} will
+   * return false and their messages will not be enqueued.
+   *
+   * <p>This returns true if a graceful shutdown was initiated by this call. It returns false and if
+   * a graceful shutdown was already underway or if the web socket is already closed or canceled.
+   *
+   * @param code Status code as defined by <a
+   * href="http://tools.ietf.org/html/rfc6455#section-7.4">Section 7.4 of RFC 6455</a>.
+   * @param reason Reason for shutting down or {@code null}.
+   * @throws IllegalArgumentException if code is invalid.
+   */
+  boolean close(int code, @Nullable String reason);
+
+  /**
+   * Immediately and violently release resources held by this web socket, discarding any enqueued
+   * messages. This does nothing if the web socket has already been closed or canceled.
+   */
+  void cancel();
+
+  interface Factory {
+    /**
+     * Creates a new web socket and immediately returns it. Creating a web socket initiates an
+     * asynchronous process to connect the socket. Once that succeeds or fails, {@code listener}
+     * will be notified. The caller must either close or cancel the returned web socket when it is
+     * no longer in use.
+     */
+    WebSocket newWebSocket(Request request, WebSocketListener listener);
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/WebSocketListener.java b/okhttp/src/main/java/okhttp3/WebSocketListener.java
new file mode 100644
index 0000000000..69276d933b
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/WebSocketListener.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import javax.annotation.Nullable;
+import okio.ByteString;
+
+public abstract class WebSocketListener {
+  /**
+   * Invoked when a web socket has been accepted by the remote peer and may begin transmitting
+   * messages.
+   */
+  public void onOpen(WebSocket webSocket, Response response) {
+  }
+
+  /** Invoked when a text (type {@code 0x1}) message has been received. */
+  public void onMessage(WebSocket webSocket, String text) {
+  }
+
+  /** Invoked when a binary (type {@code 0x2}) message has been received. */
+  public void onMessage(WebSocket webSocket, ByteString bytes) {
+  }
+
+  /**
+   * Invoked when the remote peer has indicated that no more incoming messages will be
+   * transmitted.
+   */
+  public void onClosing(WebSocket webSocket, int code, String reason) {
+  }
+
+  /**
+   * Invoked when both peers have indicated that no more messages will be transmitted and the
+   * connection has been successfully released. No further calls to this listener will be made.
+   */
+  public void onClosed(WebSocket webSocket, int code, String reason) {
+  }
+
+  /**
+   * Invoked when a web socket has been closed due to an error reading from or writing to the
+   * network. Both outgoing and incoming messages may have been lost. No further calls to this
+   * listener will be made.
+   */
+  public void onFailure(WebSocket webSocket, Throwable t, @Nullable Response response) {
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/Internal.java b/okhttp/src/main/java/okhttp3/internal/Internal.java
new file mode 100644
index 0000000000..1be96fd3e7
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/Internal.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import java.net.MalformedURLException;
+import java.net.Socket;
+import java.net.UnknownHostException;
+import javax.net.ssl.SSLSocket;
+import okhttp3.Address;
+import okhttp3.Call;
+import okhttp3.ConnectionPool;
+import okhttp3.ConnectionSpec;
+import okhttp3.Headers;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.Route;
+import okhttp3.internal.cache.InternalCache;
+import okhttp3.internal.connection.RealConnection;
+import okhttp3.internal.connection.RouteDatabase;
+import okhttp3.internal.connection.StreamAllocation;
+
+/**
+ * Escalate internal APIs in {@code okhttp3} so they can be used from OkHttp's implementation
+ * packages. The only implementation of this interface is in {@link OkHttpClient}.
+ */
+public abstract class Internal {
+
+  public static void initializeInstanceForTests() {
+    // Needed in tests to ensure that the instance is actually pointing to something.
+    new OkHttpClient();
+  }
+
+  public static Internal instance;
+
+  public abstract void addLenient(Headers.Builder builder, String line);
+
+  public abstract void addLenient(Headers.Builder builder, String name, String value);
+
+  public abstract void setCache(OkHttpClient.Builder builder, InternalCache internalCache);
+
+  public abstract RealConnection get(ConnectionPool pool, Address address,
+      StreamAllocation streamAllocation, Route route);
+
+  public abstract boolean equalsNonHost(Address a, Address b);
+
+  public abstract Socket deduplicate(
+      ConnectionPool pool, Address address, StreamAllocation streamAllocation);
+
+  public abstract void put(ConnectionPool pool, RealConnection connection);
+
+  public abstract boolean connectionBecameIdle(ConnectionPool pool, RealConnection connection);
+
+  public abstract RouteDatabase routeDatabase(ConnectionPool connectionPool);
+
+  public abstract int code(Response.Builder responseBuilder);
+
+  public abstract void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket,
+      boolean isFallback);
+
+  public abstract HttpUrl getHttpUrlChecked(String url)
+      throws MalformedURLException, UnknownHostException;
+
+  public abstract StreamAllocation streamAllocation(Call call);
+
+  public abstract Call newWebSocketCall(OkHttpClient client, Request request);
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/NamedRunnable.java b/okhttp/src/main/java/okhttp3/internal/NamedRunnable.java
new file mode 100644
index 0000000000..ff9729e2af
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/NamedRunnable.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+/**
+ * Runnable implementation which always sets its thread name.
+ */
+public abstract class NamedRunnable implements Runnable {
+  protected final String name;
+
+  public NamedRunnable(String format, Object... args) {
+    this.name = Util.format(format, args);
+  }
+
+  @Override public final void run() {
+    String oldName = Thread.currentThread().getName();
+    Thread.currentThread().setName(name);
+    try {
+      execute();
+    } finally {
+      Thread.currentThread().setName(oldName);
+    }
+  }
+
+  protected abstract void execute();
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/Util.java b/okhttp/src/main/java/okhttp3/internal/Util.java
new file mode 100644
index 0000000000..68bbf5f6a2
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/Util.java
@@ -0,0 +1,633 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.net.IDN;
+import java.net.InetAddress;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.net.UnknownHostException;
+import java.nio.charset.Charset;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Locale;
+import java.util.TimeZone;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.TimeUnit;
+import java.util.regex.Pattern;
+import javax.annotation.Nullable;
+import okhttp3.HttpUrl;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.Source;
+
+/** Junk drawer of utility methods. */
+public final class Util {
+  public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
+  public static final String[] EMPTY_STRING_ARRAY = new String[0];
+
+  public static final ResponseBody EMPTY_RESPONSE = ResponseBody.create(null, EMPTY_BYTE_ARRAY);
+  public static final RequestBody EMPTY_REQUEST = RequestBody.create(null, EMPTY_BYTE_ARRAY);
+
+  private static final ByteString UTF_8_BOM = ByteString.decodeHex("efbbbf");
+  private static final ByteString UTF_16_BE_BOM = ByteString.decodeHex("feff");
+  private static final ByteString UTF_16_LE_BOM = ByteString.decodeHex("fffe");
+  private static final ByteString UTF_32_BE_BOM = ByteString.decodeHex("0000ffff");
+  private static final ByteString UTF_32_LE_BOM = ByteString.decodeHex("ffff0000");
+
+  public static final Charset UTF_8 = Charset.forName("UTF-8");
+  public static final Charset ISO_8859_1 = Charset.forName("ISO-8859-1");
+  private static final Charset UTF_16_BE = Charset.forName("UTF-16BE");
+  private static final Charset UTF_16_LE = Charset.forName("UTF-16LE");
+  private static final Charset UTF_32_BE = Charset.forName("UTF-32BE");
+  private static final Charset UTF_32_LE = Charset.forName("UTF-32LE");
+
+  /** GMT and UTC are equivalent for our purposes. */
+  public static final TimeZone UTC = TimeZone.getTimeZone("GMT");
+
+  public static final Comparator<String> NATURAL_ORDER = new Comparator<String>() {
+    @Override public int compare(String a, String b) {
+      return a.compareTo(b);
+    }
+  };
+
+  /**
+   * Quick and dirty pattern to differentiate IP addresses from hostnames. This is an approximation
+   * of Android's private InetAddress#isNumeric API.
+   *
+   * <p>This matches IPv6 addresses as a hex string containing at least one colon, and possibly
+   * including dots after the first colon. It matches IPv4 addresses as strings containing only
+   * decimal digits and dots. This pattern matches strings like "a:.23" and "54" that are neither IP
+   * addresses nor hostnames; they will be verified as IP addresses (which is a more strict
+   * verification).
+   */
+  private static final Pattern VERIFY_AS_IP_ADDRESS = Pattern.compile(
+      "([0-9a-fA-F]*:[0-9a-fA-F:.]*)|([\\d.]+)");
+
+  private Util() {
+  }
+
+  public static void checkOffsetAndCount(long arrayLength, long offset, long count) {
+    if ((offset | count) < 0 || offset > arrayLength || arrayLength - offset < count) {
+      throw new ArrayIndexOutOfBoundsException();
+    }
+  }
+
+  /** Returns true if two possibly-null objects are equal. */
+  public static boolean equal(Object a, Object b) {
+    return a == b || (a != null && a.equals(b));
+  }
+
+  /**
+   * Closes {@code closeable}, ignoring any checked exceptions. Does nothing if {@code closeable} is
+   * null.
+   */
+  public static void closeQuietly(Closeable closeable) {
+    if (closeable != null) {
+      try {
+        closeable.close();
+      } catch (RuntimeException rethrown) {
+        throw rethrown;
+      } catch (Exception ignored) {
+      }
+    }
+  }
+
+  /**
+   * Closes {@code socket}, ignoring any checked exceptions. Does nothing if {@code socket} is
+   * null.
+   */
+  public static void closeQuietly(Socket socket) {
+    if (socket != null) {
+      try {
+        socket.close();
+      } catch (AssertionError e) {
+        if (!isAndroidGetsocknameError(e)) throw e;
+      } catch (RuntimeException rethrown) {
+        throw rethrown;
+      } catch (Exception ignored) {
+      }
+    }
+  }
+
+  /**
+   * Closes {@code serverSocket}, ignoring any checked exceptions. Does nothing if {@code
+   * serverSocket} is null.
+   */
+  public static void closeQuietly(ServerSocket serverSocket) {
+    if (serverSocket != null) {
+      try {
+        serverSocket.close();
+      } catch (RuntimeException rethrown) {
+        throw rethrown;
+      } catch (Exception ignored) {
+      }
+    }
+  }
+
+  /**
+   * Attempts to exhaust {@code source}, returning true if successful. This is useful when reading a
+   * complete source is helpful, such as when doing so completes a cache body or frees a socket
+   * connection for reuse.
+   */
+  public static boolean discard(Source source, int timeout, TimeUnit timeUnit) {
+    try {
+      return skipAll(source, timeout, timeUnit);
+    } catch (IOException e) {
+      return false;
+    }
+  }
+
+  /**
+   * Reads until {@code in} is exhausted or the deadline has been reached. This is careful to not
+   * extend the deadline if one exists already.
+   */
+  public static boolean skipAll(Source source, int duration, TimeUnit timeUnit) throws IOException {
+    long now = System.nanoTime();
+    long originalDuration = source.timeout().hasDeadline()
+        ? source.timeout().deadlineNanoTime() - now
+        : Long.MAX_VALUE;
+    source.timeout().deadlineNanoTime(now + Math.min(originalDuration, timeUnit.toNanos(duration)));
+    try {
+      Buffer skipBuffer = new Buffer();
+      while (source.read(skipBuffer, 8192) != -1) {
+        skipBuffer.clear();
+      }
+      return true; // Success! The source has been exhausted.
+    } catch (InterruptedIOException e) {
+      return false; // We ran out of time before exhausting the source.
+    } finally {
+      if (originalDuration == Long.MAX_VALUE) {
+        source.timeout().clearDeadline();
+      } else {
+        source.timeout().deadlineNanoTime(now + originalDuration);
+      }
+    }
+  }
+
+  /** Returns an immutable copy of {@code list}. */
+  public static <T> List<T> immutableList(List<T> list) {
+    return Collections.unmodifiableList(new ArrayList<>(list));
+  }
+
+  /** Returns an immutable list containing {@code elements}. */
+  public static <T> List<T> immutableList(T... elements) {
+    return Collections.unmodifiableList(Arrays.asList(elements.clone()));
+  }
+
+  public static ThreadFactory threadFactory(final String name, final boolean daemon) {
+    return new ThreadFactory() {
+      @Override public Thread newThread(Runnable runnable) {
+        Thread result = new Thread(runnable, name);
+        result.setDaemon(daemon);
+        return result;
+      }
+    };
+  }
+
+  /**
+   * Returns an array containing only elements found in {@code first} and also in {@code
+   * second}. The returned elements are in the same order as in {@code first}.
+   */
+  @SuppressWarnings("unchecked")
+  public static String[] intersect(
+      Comparator<? super String> comparator, String[] first, String[] second) {
+    List<String> result = new ArrayList<>();
+    for (String a : first) {
+      for (String b : second) {
+        if (comparator.compare(a, b) == 0) {
+          result.add(a);
+          break;
+        }
+      }
+    }
+    return result.toArray(new String[result.size()]);
+  }
+
+  /**
+   * Returns true if there is an element in {@code first} that is also in {@code second}. This
+   * method terminates if any intersection is found. The sizes of both arguments are assumed to be
+   * so small, and the likelihood of an intersection so great, that it is not worth the CPU cost of
+   * sorting or the memory cost of hashing.
+   */
+  public static boolean nonEmptyIntersection(
+      Comparator<String> comparator, String[] first, String[] second) {
+    if (first == null || second == null || first.length == 0 || second.length == 0) {
+      return false;
+    }
+    for (String a : first) {
+      for (String b : second) {
+        if (comparator.compare(a, b) == 0) {
+          return true;
+        }
+      }
+    }
+    return false;
+  }
+
+  public static String hostHeader(HttpUrl url, boolean includeDefaultPort) {
+    String host = url.host().contains(":")
+        ? "[" + url.host() + "]"
+        : url.host();
+    return includeDefaultPort || url.port() != HttpUrl.defaultPort(url.scheme())
+        ? host + ":" + url.port()
+        : host;
+  }
+
+  /** Returns {@code s} with control characters and non-ASCII characters replaced with '?'. */
+  public static String toHumanReadableAscii(String s) {
+    for (int i = 0, length = s.length(), c; i < length; i += Character.charCount(c)) {
+      c = s.codePointAt(i);
+      if (c > '\u001f' && c < '\u007f') continue;
+
+      Buffer buffer = new Buffer();
+      buffer.writeUtf8(s, 0, i);
+      for (int j = i; j < length; j += Character.charCount(c)) {
+        c = s.codePointAt(j);
+        buffer.writeUtf8CodePoint(c > '\u001f' && c < '\u007f' ? c : '?');
+      }
+      return buffer.readUtf8();
+    }
+    return s;
+  }
+
+  /**
+   * Returns true if {@code e} is due to a firmware bug fixed after Android 4.2.2.
+   * https://code.google.com/p/android/issues/detail?id=54072
+   */
+  public static boolean isAndroidGetsocknameError(AssertionError e) {
+    return e.getCause() != null && e.getMessage() != null
+        && e.getMessage().contains("getsockname failed");
+  }
+
+  public static int indexOf(Comparator<String> comparator, String[] array, String value) {
+    for (int i = 0, size = array.length; i < size; i++) {
+      if (comparator.compare(array[i], value) == 0) return i;
+    }
+    return -1;
+  }
+
+  public static String[] concat(String[] array, String value) {
+    String[] result = new String[array.length + 1];
+    System.arraycopy(array, 0, result, 0, array.length);
+    result[result.length - 1] = value;
+    return result;
+  }
+
+  /**
+   * Increments {@code pos} until {@code input[pos]} is not ASCII whitespace. Stops at {@code
+   * limit}.
+   */
+  public static int skipLeadingAsciiWhitespace(String input, int pos, int limit) {
+    for (int i = pos; i < limit; i++) {
+      switch (input.charAt(i)) {
+        case '\t':
+        case '\n':
+        case '\f':
+        case '\r':
+        case ' ':
+          continue;
+        default:
+          return i;
+      }
+    }
+    return limit;
+  }
+
+  /**
+   * Decrements {@code limit} until {@code input[limit - 1]} is not ASCII whitespace. Stops at
+   * {@code pos}.
+   */
+  public static int skipTrailingAsciiWhitespace(String input, int pos, int limit) {
+    for (int i = limit - 1; i >= pos; i--) {
+      switch (input.charAt(i)) {
+        case '\t':
+        case '\n':
+        case '\f':
+        case '\r':
+        case ' ':
+          continue;
+        default:
+          return i + 1;
+      }
+    }
+    return pos;
+  }
+
+  /** Equivalent to {@code string.substring(pos, limit).trim()}. */
+  public static String trimSubstring(String string, int pos, int limit) {
+    int start = skipLeadingAsciiWhitespace(string, pos, limit);
+    int end = skipTrailingAsciiWhitespace(string, start, limit);
+    return string.substring(start, end);
+  }
+
+  /**
+   * Returns the index of the first character in {@code input} that contains a character in {@code
+   * delimiters}. Returns limit if there is no such character.
+   */
+  public static int delimiterOffset(String input, int pos, int limit, String delimiters) {
+    for (int i = pos; i < limit; i++) {
+      if (delimiters.indexOf(input.charAt(i)) != -1) return i;
+    }
+    return limit;
+  }
+
+  /**
+   * Returns the index of the first character in {@code input} that is {@code delimiter}. Returns
+   * limit if there is no such character.
+   */
+  public static int delimiterOffset(String input, int pos, int limit, char delimiter) {
+    for (int i = pos; i < limit; i++) {
+      if (input.charAt(i) == delimiter) return i;
+    }
+    return limit;
+  }
+
+  /**
+   * If {@code host} is an IP address, this returns the IP address in canonical form.
+   *
+   * <p>Otherwise this performs IDN ToASCII encoding and canonicalize the result to lowercase. For
+   * example this converts {@code ☃.net} to {@code xn--n3h.net}, and {@code WwW.GoOgLe.cOm} to
+   * {@code www.google.com}. {@code null} will be returned if the host cannot be ToASCII encoded or
+   * if the result contains unsupported ASCII characters.
+   */
+  public static String canonicalizeHost(String host) {
+    // If the input contains a :, it’s an IPv6 address.
+    if (host.contains(":")) {
+      // If the input is encased in square braces "[...]", drop 'em.
+      InetAddress inetAddress = host.startsWith("[") && host.endsWith("]")
+          ? decodeIpv6(host, 1, host.length() - 1)
+          : decodeIpv6(host, 0, host.length());
+      if (inetAddress == null) return null;
+      byte[] address = inetAddress.getAddress();
+      if (address.length == 16) return inet6AddressToAscii(address);
+      throw new AssertionError("Invalid IPv6 address: '" + host + "'");
+    }
+
+    try {
+      String result = IDN.toASCII(host).toLowerCase(Locale.US);
+      if (result.isEmpty()) return null;
+
+      // Confirm that the IDN ToASCII result doesn't contain any illegal characters.
+      if (containsInvalidHostnameAsciiCodes(result)) {
+        return null;
+      }
+      // TODO: implement all label limits.
+      return result;
+    } catch (IllegalArgumentException e) {
+      return null;
+    }
+  }
+
+  private static boolean containsInvalidHostnameAsciiCodes(String hostnameAscii) {
+    for (int i = 0; i < hostnameAscii.length(); i++) {
+      char c = hostnameAscii.charAt(i);
+      // The WHATWG Host parsing rules accepts some character codes which are invalid by
+      // definition for OkHttp's host header checks (and the WHATWG Host syntax definition). Here
+      // we rule out characters that would cause problems in host headers.
+      if (c <= '\u001f' || c >= '\u007f') {
+        return true;
+      }
+      // Check for the characters mentioned in the WHATWG Host parsing spec:
+      // U+0000, U+0009, U+000A, U+000D, U+0020, "#", "%", "/", ":", "?", "@", "[", "\", and "]"
+      // (excluding the characters covered above).
+      if (" #%/:?@[\\]".indexOf(c) != -1) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  /**
+   * Returns the index of the first character in {@code input} that is either a control character
+   * (like {@code \u0000 or \n}) or a non-ASCII character. Returns -1 if {@code input} has no such
+   * characters.
+   */
+  public static int indexOfControlOrNonAscii(String input) {
+    for (int i = 0, length = input.length(); i < length; i++) {
+      char c = input.charAt(i);
+      if (c <= '\u001f' || c >= '\u007f') {
+        return i;
+      }
+    }
+    return -1;
+  }
+
+  /** Returns true if {@code host} is not a host name and might be an IP address. */
+  public static boolean verifyAsIpAddress(String host) {
+    return VERIFY_AS_IP_ADDRESS.matcher(host).matches();
+  }
+
+  /** Returns a {@link Locale#US} formatted {@link String}. */
+  public static String format(String format, Object... args) {
+    return String.format(Locale.US, format, args);
+  }
+
+  public static Charset bomAwareCharset(BufferedSource source, Charset charset) throws IOException {
+    if (source.rangeEquals(0, UTF_8_BOM)) {
+      source.skip(UTF_8_BOM.size());
+      return UTF_8;
+    }
+    if (source.rangeEquals(0, UTF_16_BE_BOM)) {
+      source.skip(UTF_16_BE_BOM.size());
+      return UTF_16_BE;
+    }
+    if (source.rangeEquals(0, UTF_16_LE_BOM)) {
+      source.skip(UTF_16_LE_BOM.size());
+      return UTF_16_LE;
+    }
+    if (source.rangeEquals(0, UTF_32_BE_BOM)) {
+      source.skip(UTF_32_BE_BOM.size());
+      return UTF_32_BE;
+    }
+    if (source.rangeEquals(0, UTF_32_LE_BOM)) {
+      source.skip(UTF_32_LE_BOM.size());
+      return UTF_32_LE;
+    }
+    return charset;
+  }
+
+  public static int checkDuration(String name, long duration, TimeUnit unit) {
+    if (duration < 0) throw new IllegalArgumentException(name + " < 0");
+    if (unit == null) throw new NullPointerException("unit == null");
+    long millis = unit.toMillis(duration);
+    if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException(name + " too large.");
+    if (millis == 0 && duration > 0) throw new IllegalArgumentException(name + " too small.");
+    return (int) millis;
+  }
+
+  public static AssertionError assertionError(String message, Exception e) {
+    return (AssertionError) new AssertionError(message).initCause(e);
+  }
+
+  public static int decodeHexDigit(char c) {
+    if (c >= '0' && c <= '9') return c - '0';
+    if (c >= 'a' && c <= 'f') return c - 'a' + 10;
+    if (c >= 'A' && c <= 'F') return c - 'A' + 10;
+    return -1;
+  }
+
+  /** Decodes an IPv6 address like 1111:2222:3333:4444:5555:6666:7777:8888 or ::1. */
+  private static @Nullable InetAddress decodeIpv6(String input, int pos, int limit) {
+    byte[] address = new byte[16];
+    int b = 0;
+    int compress = -1;
+    int groupOffset = -1;
+
+    for (int i = pos; i < limit; ) {
+      if (b == address.length) return null; // Too many groups.
+
+      // Read a delimiter.
+      if (i + 2 <= limit && input.regionMatches(i, "::", 0, 2)) {
+        // Compression "::" delimiter, which is anywhere in the input, including its prefix.
+        if (compress != -1) return null; // Multiple "::" delimiters.
+        i += 2;
+        b += 2;
+        compress = b;
+        if (i == limit) break;
+      } else if (b != 0) {
+        // Group separator ":" delimiter.
+        if (input.regionMatches(i, ":", 0, 1)) {
+          i++;
+        } else if (input.regionMatches(i, ".", 0, 1)) {
+          // If we see a '.', rewind to the beginning of the previous group and parse as IPv4.
+          if (!decodeIpv4Suffix(input, groupOffset, limit, address, b - 2)) return null;
+          b += 2; // We rewound two bytes and then added four.
+          break;
+        } else {
+          return null; // Wrong delimiter.
+        }
+      }
+
+      // Read a group, one to four hex digits.
+      int value = 0;
+      groupOffset = i;
+      for (; i < limit; i++) {
+        char c = input.charAt(i);
+        int hexDigit = decodeHexDigit(c);
+        if (hexDigit == -1) break;
+        value = (value << 4) + hexDigit;
+      }
+      int groupLength = i - groupOffset;
+      if (groupLength == 0 || groupLength > 4) return null; // Group is the wrong size.
+
+      // We've successfully read a group. Assign its value to our byte array.
+      address[b++] = (byte) ((value >>> 8) & 0xff);
+      address[b++] = (byte) (value & 0xff);
+    }
+
+    // All done. If compression happened, we need to move bytes to the right place in the
+    // address. Here's a sample:
+    //
+    //      input: "1111:2222:3333::7777:8888"
+    //     before: { 11, 11, 22, 22, 33, 33, 00, 00, 77, 77, 88, 88, 00, 00, 00, 00  }
+    //   compress: 6
+    //          b: 10
+    //      after: { 11, 11, 22, 22, 33, 33, 00, 00, 00, 00, 00, 00, 77, 77, 88, 88 }
+    //
+    if (b != address.length) {
+      if (compress == -1) return null; // Address didn't have compression or enough groups.
+      System.arraycopy(address, compress, address, address.length - (b - compress), b - compress);
+      Arrays.fill(address, compress, compress + (address.length - b), (byte) 0);
+    }
+
+    try {
+      return InetAddress.getByAddress(address);
+    } catch (UnknownHostException e) {
+      throw new AssertionError();
+    }
+  }
+
+  /** Decodes an IPv4 address suffix of an IPv6 address, like 1111::5555:6666:192.168.0.1. */
+  private static boolean decodeIpv4Suffix(
+      String input, int pos, int limit, byte[] address, int addressOffset) {
+    int b = addressOffset;
+
+    for (int i = pos; i < limit; ) {
+      if (b == address.length) return false; // Too many groups.
+
+      // Read a delimiter.
+      if (b != addressOffset) {
+        if (input.charAt(i) != '.') return false; // Wrong delimiter.
+        i++;
+      }
+
+      // Read 1 or more decimal digits for a value in 0..255.
+      int value = 0;
+      int groupOffset = i;
+      for (; i < limit; i++) {
+        char c = input.charAt(i);
+        if (c < '0' || c > '9') break;
+        if (value == 0 && groupOffset != i) return false; // Reject unnecessary leading '0's.
+        value = (value * 10) + c - '0';
+        if (value > 255) return false; // Value out of range.
+      }
+      int groupLength = i - groupOffset;
+      if (groupLength == 0) return false; // No digits.
+
+      // We've successfully read a byte.
+      address[b++] = (byte) value;
+    }
+
+    if (b != addressOffset + 4) return false; // Too few groups. We wanted exactly four.
+    return true; // Success.
+  }
+
+  /** Encodes an IPv6 address in canonical form according to RFC 5952. */
+  private static String inet6AddressToAscii(byte[] address) {
+    // Go through the address looking for the longest run of 0s. Each group is 2-bytes.
+    // A run must be longer than one group (section 4.2.2).
+    // If there are multiple equal runs, the first one must be used (section 4.2.3).
+    int longestRunOffset = -1;
+    int longestRunLength = 0;
+    for (int i = 0; i < address.length; i += 2) {
+      int currentRunOffset = i;
+      while (i < 16 && address[i] == 0 && address[i + 1] == 0) {
+        i += 2;
+      }
+      int currentRunLength = i - currentRunOffset;
+      if (currentRunLength > longestRunLength && currentRunLength >= 4) {
+        longestRunOffset = currentRunOffset;
+        longestRunLength = currentRunLength;
+      }
+    }
+
+    // Emit each 2-byte group in hex, separated by ':'. The longest run of zeroes is "::".
+    Buffer result = new Buffer();
+    for (int i = 0; i < address.length; ) {
+      if (i == longestRunOffset) {
+        result.writeByte(':');
+        i += longestRunLength;
+        if (i == 16) result.writeByte(':');
+      } else {
+        if (i > 0) result.writeByte(':');
+        int group = (address[i] & 0xff) << 8 | address[i + 1] & 0xff;
+        result.writeHexadecimalUnsignedLong(group);
+        i += 2;
+      }
+    }
+    return result.readUtf8();
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
new file mode 100644
index 0000000000..787e6b31a9
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
@@ -0,0 +1,259 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3.internal.cache;
+
+import java.io.IOException;
+import okhttp3.Headers;
+import okhttp3.Interceptor;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.Internal;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.HttpCodec;
+import okhttp3.internal.http.HttpHeaders;
+import okhttp3.internal.http.HttpMethod;
+import okhttp3.internal.http.RealResponseBody;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.Okio;
+import okio.Sink;
+import okio.Source;
+import okio.Timeout;
+
+import static java.net.HttpURLConnection.HTTP_NOT_MODIFIED;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static okhttp3.internal.Util.closeQuietly;
+import static okhttp3.internal.Util.discard;
+
+/** Serves requests from the cache and writes responses to the cache. */
+public final class CacheInterceptor implements Interceptor {
+  final InternalCache cache;
+
+  public CacheInterceptor(InternalCache cache) {
+    this.cache = cache;
+  }
+
+  @Override public Response intercept(Chain chain) throws IOException {
+    Response cacheCandidate = cache != null
+        ? cache.get(chain.request())
+        : null;
+
+    long now = System.currentTimeMillis();
+
+    CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();
+    Request networkRequest = strategy.networkRequest;
+    Response cacheResponse = strategy.cacheResponse;
+
+    if (cache != null) {
+      cache.trackResponse(strategy);
+    }
+
+    if (cacheCandidate != null && cacheResponse == null) {
+      closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.
+    }
+
+    // If we're forbidden from using the network and the cache is insufficient, fail.
+    if (networkRequest == null && cacheResponse == null) {
+      return new Response.Builder()
+          .request(chain.request())
+          .protocol(Protocol.HTTP_1_1)
+          .code(504)
+          .message("Unsatisfiable Request (only-if-cached)")
+          .body(Util.EMPTY_RESPONSE)
+          .sentRequestAtMillis(-1L)
+          .receivedResponseAtMillis(System.currentTimeMillis())
+          .build();
+    }
+
+    // If we don't need the network, we're done.
+    if (networkRequest == null) {
+      return cacheResponse.newBuilder()
+          .cacheResponse(stripBody(cacheResponse))
+          .build();
+    }
+
+    Response networkResponse = null;
+    try {
+      networkResponse = chain.proceed(networkRequest);
+    } finally {
+      // If we're crashing on I/O or otherwise, don't leak the cache body.
+      if (networkResponse == null && cacheCandidate != null) {
+        closeQuietly(cacheCandidate.body());
+      }
+    }
+
+    // If we have a cache response too, then we're doing a conditional get.
+    if (cacheResponse != null) {
+      if (networkResponse.code() == HTTP_NOT_MODIFIED) {
+        Response response = cacheResponse.newBuilder()
+            .headers(combine(cacheResponse.headers(), networkResponse.headers()))
+            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())
+            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())
+            .cacheResponse(stripBody(cacheResponse))
+            .networkResponse(stripBody(networkResponse))
+            .build();
+        networkResponse.body().close();
+
+        // Update the cache after combining headers but before stripping the
+        // Content-Encoding header (as performed by initContentStream()).
+        cache.trackConditionalCacheHit();
+        cache.update(cacheResponse, response);
+        return response;
+      } else {
+        closeQuietly(cacheResponse.body());
+      }
+    }
+
+    Response response = networkResponse.newBuilder()
+        .cacheResponse(stripBody(cacheResponse))
+        .networkResponse(stripBody(networkResponse))
+        .build();
+
+    if (cache != null) {
+      if (HttpHeaders.hasBody(response) && CacheStrategy.isCacheable(response, networkRequest)) {
+        // Offer this request to the cache.
+        CacheRequest cacheRequest = cache.put(response);
+        return cacheWritingResponse(cacheRequest, response);
+      }
+
+      if (HttpMethod.invalidatesCache(networkRequest.method())) {
+        try {
+          cache.remove(networkRequest);
+        } catch (IOException ignored) {
+          // The cache cannot be written.
+        }
+      }
+    }
+
+    return response;
+  }
+
+  private static Response stripBody(Response response) {
+    return response != null && response.body() != null
+        ? response.newBuilder().body(null).build()
+        : response;
+  }
+
+  /**
+   * Returns a new source that writes bytes to {@code cacheRequest} as they are read by the source
+   * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we
+   * may never exhaust the source stream and therefore not complete the cached response.
+   */
+  private Response cacheWritingResponse(final CacheRequest cacheRequest, Response response)
+      throws IOException {
+    // Some apps return a null body; for compatibility we treat that like a null cache request.
+    if (cacheRequest == null) return response;
+    Sink cacheBodyUnbuffered = cacheRequest.body();
+    if (cacheBodyUnbuffered == null) return response;
+
+    final BufferedSource source = response.body().source();
+    final BufferedSink cacheBody = Okio.buffer(cacheBodyUnbuffered);
+
+    Source cacheWritingSource = new Source() {
+      boolean cacheRequestClosed;
+
+      @Override public long read(Buffer sink, long byteCount) throws IOException {
+        long bytesRead;
+        try {
+          bytesRead = source.read(sink, byteCount);
+        } catch (IOException e) {
+          if (!cacheRequestClosed) {
+            cacheRequestClosed = true;
+            cacheRequest.abort(); // Failed to write a complete cache response.
+          }
+          throw e;
+        }
+
+        if (bytesRead == -1) {
+          if (!cacheRequestClosed) {
+            cacheRequestClosed = true;
+            cacheBody.close(); // The cache response is complete!
+          }
+          return -1;
+        }
+
+        sink.copyTo(cacheBody.buffer(), sink.size() - bytesRead, bytesRead);
+        cacheBody.emitCompleteSegments();
+        return bytesRead;
+      }
+
+      @Override public Timeout timeout() {
+        return source.timeout();
+      }
+
+      @Override public void close() throws IOException {
+        if (!cacheRequestClosed
+            && !discard(this, HttpCodec.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
+          cacheRequestClosed = true;
+          cacheRequest.abort();
+        }
+        source.close();
+      }
+    };
+
+    String contentType = response.header("Content-Type");
+    long contentLength = response.body().contentLength();
+    return response.newBuilder()
+        .body(new RealResponseBody(contentType, contentLength, Okio.buffer(cacheWritingSource)))
+        .build();
+  }
+
+  /** Combines cached headers with a network headers as defined by RFC 7234, 4.3.4. */
+  private static Headers combine(Headers cachedHeaders, Headers networkHeaders) {
+    Headers.Builder result = new Headers.Builder();
+
+    for (int i = 0, size = cachedHeaders.size(); i < size; i++) {
+      String fieldName = cachedHeaders.name(i);
+      String value = cachedHeaders.value(i);
+      if ("Warning".equalsIgnoreCase(fieldName) && value.startsWith("1")) {
+        continue; // Drop 100-level freshness warnings.
+      }
+      if (!isEndToEnd(fieldName) || networkHeaders.get(fieldName) == null) {
+        Internal.instance.addLenient(result, fieldName, value);
+      }
+    }
+
+    for (int i = 0, size = networkHeaders.size(); i < size; i++) {
+      String fieldName = networkHeaders.name(i);
+      if ("Content-Length".equalsIgnoreCase(fieldName)) {
+        continue; // Ignore content-length headers of validating responses.
+      }
+      if (isEndToEnd(fieldName)) {
+        Internal.instance.addLenient(result, fieldName, networkHeaders.value(i));
+      }
+    }
+
+    return result.build();
+  }
+
+  /**
+   * Returns true if {@code fieldName} is an end-to-end HTTP header, as defined by RFC 2616,
+   * 13.5.1.
+   */
+  static boolean isEndToEnd(String fieldName) {
+    return !"Connection".equalsIgnoreCase(fieldName)
+        && !"Keep-Alive".equalsIgnoreCase(fieldName)
+        && !"Proxy-Authenticate".equalsIgnoreCase(fieldName)
+        && !"Proxy-Authorization".equalsIgnoreCase(fieldName)
+        && !"TE".equalsIgnoreCase(fieldName)
+        && !"Trailers".equalsIgnoreCase(fieldName)
+        && !"Transfer-Encoding".equalsIgnoreCase(fieldName)
+        && !"Upgrade".equalsIgnoreCase(fieldName);
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheRequest.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheRequest.java
new file mode 100644
index 0000000000..b4432b4e1d
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheRequest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.cache;
+
+import java.io.IOException;
+import okio.Sink;
+
+public interface CacheRequest {
+  Sink body() throws IOException;
+
+  void abort();
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
new file mode 100644
index 0000000000..3ae1926650
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
@@ -0,0 +1,329 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.cache;
+
+import java.util.Date;
+import javax.annotation.Nullable;
+import okhttp3.CacheControl;
+import okhttp3.Headers;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.Internal;
+import okhttp3.internal.http.HttpDate;
+import okhttp3.internal.http.HttpHeaders;
+import okhttp3.internal.http.StatusLine;
+
+import static java.net.HttpURLConnection.HTTP_BAD_METHOD;
+import static java.net.HttpURLConnection.HTTP_GONE;
+import static java.net.HttpURLConnection.HTTP_MOVED_PERM;
+import static java.net.HttpURLConnection.HTTP_MOVED_TEMP;
+import static java.net.HttpURLConnection.HTTP_MULT_CHOICE;
+import static java.net.HttpURLConnection.HTTP_NOT_AUTHORITATIVE;
+import static java.net.HttpURLConnection.HTTP_NOT_FOUND;
+import static java.net.HttpURLConnection.HTTP_NOT_IMPLEMENTED;
+import static java.net.HttpURLConnection.HTTP_NO_CONTENT;
+import static java.net.HttpURLConnection.HTTP_OK;
+import static java.net.HttpURLConnection.HTTP_REQ_TOO_LONG;
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+/**
+ * Given a request and cached response, this figures out whether to use the network, the cache, or
+ * both.
+ *
+ * <p>Selecting a cache strategy may add conditions to the request (like the "If-Modified-Since"
+ * header for conditional GETs) or warnings to the cached response (if the cached data is
+ * potentially stale).
+ */
+public final class CacheStrategy {
+  /** The request to send on the network, or null if this call doesn't use the network. */
+  public final @Nullable Request networkRequest;
+
+  /** The cached response to return or validate; or null if this call doesn't use a cache. */
+  public final @Nullable Response cacheResponse;
+
+  CacheStrategy(Request networkRequest, Response cacheResponse) {
+    this.networkRequest = networkRequest;
+    this.cacheResponse = cacheResponse;
+  }
+
+  /** Returns true if {@code response} can be stored to later serve another request. */
+  public static boolean isCacheable(Response response, Request request) {
+    // Always go to network for uncacheable response codes (RFC 7231 section 6.1),
+    // This implementation doesn't support caching partial content.
+    switch (response.code()) {
+      case HTTP_OK:
+      case HTTP_NOT_AUTHORITATIVE:
+      case HTTP_NO_CONTENT:
+      case HTTP_MULT_CHOICE:
+      case HTTP_MOVED_PERM:
+      case HTTP_NOT_FOUND:
+      case HTTP_BAD_METHOD:
+      case HTTP_GONE:
+      case HTTP_REQ_TOO_LONG:
+      case HTTP_NOT_IMPLEMENTED:
+      case StatusLine.HTTP_PERM_REDIRECT:
+        // These codes can be cached unless headers forbid it.
+        break;
+
+      case HTTP_MOVED_TEMP:
+      case StatusLine.HTTP_TEMP_REDIRECT:
+        // These codes can only be cached with the right response headers.
+        // http://tools.ietf.org/html/rfc7234#section-3
+        // s-maxage is not checked because OkHttp is a private cache that should ignore s-maxage.
+        if (response.header("Expires") != null
+            || response.cacheControl().maxAgeSeconds() != -1
+            || response.cacheControl().isPublic()
+            || response.cacheControl().isPrivate()) {
+          break;
+        }
+        // Fall-through.
+
+      default:
+        // All other codes cannot be cached.
+        return false;
+    }
+
+    // A 'no-store' directive on request or response prevents the response from being cached.
+    return !response.cacheControl().noStore() && !request.cacheControl().noStore();
+  }
+
+  public static class Factory {
+    final long nowMillis;
+    final Request request;
+    final Response cacheResponse;
+
+    /** The server's time when the cached response was served, if known. */
+    private Date servedDate;
+    private String servedDateString;
+
+    /** The last modified date of the cached response, if known. */
+    private Date lastModified;
+    private String lastModifiedString;
+
+    /**
+     * The expiration date of the cached response, if known. If both this field and the max age are
+     * set, the max age is preferred.
+     */
+    private Date expires;
+
+    /**
+     * Extension header set by OkHttp specifying the timestamp when the cached HTTP request was
+     * first initiated.
+     */
+    private long sentRequestMillis;
+
+    /**
+     * Extension header set by OkHttp specifying the timestamp when the cached HTTP response was
+     * first received.
+     */
+    private long receivedResponseMillis;
+
+    /** Etag of the cached response. */
+    private String etag;
+
+    /** Age of the cached response. */
+    private int ageSeconds = -1;
+
+    public Factory(long nowMillis, Request request, Response cacheResponse) {
+      this.nowMillis = nowMillis;
+      this.request = request;
+      this.cacheResponse = cacheResponse;
+
+      if (cacheResponse != null) {
+        this.sentRequestMillis = cacheResponse.sentRequestAtMillis();
+        this.receivedResponseMillis = cacheResponse.receivedResponseAtMillis();
+        Headers headers = cacheResponse.headers();
+        for (int i = 0, size = headers.size(); i < size; i++) {
+          String fieldName = headers.name(i);
+          String value = headers.value(i);
+          if ("Date".equalsIgnoreCase(fieldName)) {
+            servedDate = HttpDate.parse(value);
+            servedDateString = value;
+          } else if ("Expires".equalsIgnoreCase(fieldName)) {
+            expires = HttpDate.parse(value);
+          } else if ("Last-Modified".equalsIgnoreCase(fieldName)) {
+            lastModified = HttpDate.parse(value);
+            lastModifiedString = value;
+          } else if ("ETag".equalsIgnoreCase(fieldName)) {
+            etag = value;
+          } else if ("Age".equalsIgnoreCase(fieldName)) {
+            ageSeconds = HttpHeaders.parseSeconds(value, -1);
+          }
+        }
+      }
+    }
+
+    /**
+     * Returns a strategy to satisfy {@code request} using the a cached response {@code response}.
+     */
+    public CacheStrategy get() {
+      CacheStrategy candidate = getCandidate();
+
+      if (candidate.networkRequest != null && request.cacheControl().onlyIfCached()) {
+        // We're forbidden from using the network and the cache is insufficient.
+        return new CacheStrategy(null, null);
+      }
+
+      return candidate;
+    }
+
+    /** Returns a strategy to use assuming the request can use the network. */
+    private CacheStrategy getCandidate() {
+      // No cached response.
+      if (cacheResponse == null) {
+        return new CacheStrategy(request, null);
+      }
+
+      // Drop the cached response if it's missing a required handshake.
+      if (request.isHttps() && cacheResponse.handshake() == null) {
+        return new CacheStrategy(request, null);
+      }
+
+      // If this response shouldn't have been stored, it should never be used
+      // as a response source. This check should be redundant as long as the
+      // persistence store is well-behaved and the rules are constant.
+      if (!isCacheable(cacheResponse, request)) {
+        return new CacheStrategy(request, null);
+      }
+
+      CacheControl requestCaching = request.cacheControl();
+      if (requestCaching.noCache() || hasConditions(request)) {
+        return new CacheStrategy(request, null);
+      }
+
+      CacheControl responseCaching = cacheResponse.cacheControl();
+      if (responseCaching.immutable()) {
+        return new CacheStrategy(null, cacheResponse);
+      }
+
+      long ageMillis = cacheResponseAge();
+      long freshMillis = computeFreshnessLifetime();
+
+      if (requestCaching.maxAgeSeconds() != -1) {
+        freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));
+      }
+
+      long minFreshMillis = 0;
+      if (requestCaching.minFreshSeconds() != -1) {
+        minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());
+      }
+
+      long maxStaleMillis = 0;
+      if (!responseCaching.mustRevalidate() && requestCaching.maxStaleSeconds() != -1) {
+        maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());
+      }
+
+      if (!responseCaching.noCache() && ageMillis + minFreshMillis < freshMillis + maxStaleMillis) {
+        Response.Builder builder = cacheResponse.newBuilder();
+        if (ageMillis + minFreshMillis >= freshMillis) {
+          builder.addHeader("Warning", "110 HttpURLConnection \"Response is stale\"");
+        }
+        long oneDayMillis = 24 * 60 * 60 * 1000L;
+        if (ageMillis > oneDayMillis && isFreshnessLifetimeHeuristic()) {
+          builder.addHeader("Warning", "113 HttpURLConnection \"Heuristic expiration\"");
+        }
+        return new CacheStrategy(null, builder.build());
+      }
+
+      // Find a condition to add to the request. If the condition is satisfied, the response body
+      // will not be transmitted.
+      String conditionName;
+      String conditionValue;
+      if (etag != null) {
+        conditionName = "If-None-Match";
+        conditionValue = etag;
+      } else if (lastModified != null) {
+        conditionName = "If-Modified-Since";
+        conditionValue = lastModifiedString;
+      } else if (servedDate != null) {
+        conditionName = "If-Modified-Since";
+        conditionValue = servedDateString;
+      } else {
+        return new CacheStrategy(request, null); // No condition! Make a regular request.
+      }
+
+      Headers.Builder conditionalRequestHeaders = request.headers().newBuilder();
+      Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue);
+
+      Request conditionalRequest = request.newBuilder()
+          .headers(conditionalRequestHeaders.build())
+          .build();
+      return new CacheStrategy(conditionalRequest, cacheResponse);
+    }
+
+    /**
+     * Returns the number of milliseconds that the response was fresh for, starting from the served
+     * date.
+     */
+    private long computeFreshnessLifetime() {
+      CacheControl responseCaching = cacheResponse.cacheControl();
+      if (responseCaching.maxAgeSeconds() != -1) {
+        return SECONDS.toMillis(responseCaching.maxAgeSeconds());
+      } else if (expires != null) {
+        long servedMillis = servedDate != null
+            ? servedDate.getTime()
+            : receivedResponseMillis;
+        long delta = expires.getTime() - servedMillis;
+        return delta > 0 ? delta : 0;
+      } else if (lastModified != null
+          && cacheResponse.request().url().query() == null) {
+        // As recommended by the HTTP RFC and implemented in Firefox, the
+        // max age of a document should be defaulted to 10% of the
+        // document's age at the time it was served. Default expiration
+        // dates aren't used for URIs containing a query.
+        long servedMillis = servedDate != null
+            ? servedDate.getTime()
+            : sentRequestMillis;
+        long delta = servedMillis - lastModified.getTime();
+        return delta > 0 ? (delta / 10) : 0;
+      }
+      return 0;
+    }
+
+    /**
+     * Returns the current age of the response, in milliseconds. The calculation is specified by RFC
+     * 7234, 4.2.3 Calculating Age.
+     */
+    private long cacheResponseAge() {
+      long apparentReceivedAge = servedDate != null
+          ? Math.max(0, receivedResponseMillis - servedDate.getTime())
+          : 0;
+      long receivedAge = ageSeconds != -1
+          ? Math.max(apparentReceivedAge, SECONDS.toMillis(ageSeconds))
+          : apparentReceivedAge;
+      long responseDuration = receivedResponseMillis - sentRequestMillis;
+      long residentDuration = nowMillis - receivedResponseMillis;
+      return receivedAge + responseDuration + residentDuration;
+    }
+
+    /**
+     * Returns true if computeFreshnessLifetime used a heuristic. If we used a heuristic to serve a
+     * cached response older than 24 hours, we are required to attach a warning.
+     */
+    private boolean isFreshnessLifetimeHeuristic() {
+      return cacheResponse.cacheControl().maxAgeSeconds() == -1 && expires == null;
+    }
+
+    /**
+     * Returns true if the request contains conditions that save the server from sending a response
+     * that the client has locally. When a request is enqueued with its own conditions, the built-in
+     * response cache won't be used.
+     */
+    private static boolean hasConditions(Request request) {
+      return request.header("If-Modified-Since") != null || request.header("If-None-Match") != null;
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
new file mode 100644
index 0000000000..c3fb740e28
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
@@ -0,0 +1,1053 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.cache;
+
+import java.io.Closeable;
+import java.io.EOFException;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.Flushable;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.NoSuchElementException;
+import java.util.concurrent.Executor;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import javax.annotation.Nullable;
+import okhttp3.internal.Util;
+import okhttp3.internal.io.FileSystem;
+import okhttp3.internal.platform.Platform;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.Okio;
+import okio.Sink;
+import okio.Source;
+
+import static okhttp3.internal.platform.Platform.WARN;
+
+/**
+ * A cache that uses a bounded amount of space on a filesystem. Each cache entry has a string key
+ * and a fixed number of values. Each key must match the regex <strong>[a-z0-9_-]{1,64}</strong>.
+ * Values are byte sequences, accessible as streams or files. Each value must be between {@code 0}
+ * and {@code Integer.MAX_VALUE} bytes in length.
+ *
+ * <p>The cache stores its data in a directory on the filesystem. This directory must be exclusive
+ * to the cache; the cache may delete or overwrite files from its directory. It is an error for
+ * multiple processes to use the same cache directory at the same time.
+ *
+ * <p>This cache limits the number of bytes that it will store on the filesystem. When the number of
+ * stored bytes exceeds the limit, the cache will remove entries in the background until the limit
+ * is satisfied. The limit is not strict: the cache may temporarily exceed it while waiting for
+ * files to be deleted. The limit does not include filesystem overhead or the cache journal so
+ * space-sensitive applications should set a conservative limit.
+ *
+ * <p>Clients call {@link #edit} to create or update the values of an entry. An entry may have only
+ * one editor at one time; if a value is not available to be edited then {@link #edit} will return
+ * null.
+ *
+ * <ul>
+ *     <li>When an entry is being <strong>created</strong> it is necessary to supply a full set of
+ *         values; the empty value should be used as a placeholder if necessary.
+ *     <li>When an entry is being <strong>edited</strong>, it is not necessary to supply data for
+ *         every value; values default to their previous value.
+ * </ul>
+ *
+ * <p>Every {@link #edit} call must be matched by a call to {@link Editor#commit} or {@link
+ * Editor#abort}. Committing is atomic: a read observes the full set of values as they were before
+ * or after the commit, but never a mix of values.
+ *
+ * <p>Clients call {@link #get} to read a snapshot of an entry. The read will observe the value at
+ * the time that {@link #get} was called. Updates and removals after the call do not impact ongoing
+ * reads.
+ *
+ * <p>This class is tolerant of some I/O errors. If files are missing from the filesystem, the
+ * corresponding entries will be dropped from the cache. If an error occurs while writing a cache
+ * value, the edit will fail silently. Callers should handle other problems by catching {@code
+ * IOException} and responding appropriately.
+ */
+public final class DiskLruCache implements Closeable, Flushable {
+  static final String JOURNAL_FILE = "journal";
+  static final String JOURNAL_FILE_TEMP = "journal.tmp";
+  static final String JOURNAL_FILE_BACKUP = "journal.bkp";
+  static final String MAGIC = "libcore.io.DiskLruCache";
+  static final String VERSION_1 = "1";
+  static final long ANY_SEQUENCE_NUMBER = -1;
+  static final Pattern LEGAL_KEY_PATTERN = Pattern.compile("[a-z0-9_-]{1,120}");
+  private static final String CLEAN = "CLEAN";
+  private static final String DIRTY = "DIRTY";
+  private static final String REMOVE = "REMOVE";
+  private static final String READ = "READ";
+
+    /*
+     * This cache uses a journal file named "journal". A typical journal file
+     * looks like this:
+     *     libcore.io.DiskLruCache
+     *     1
+     *     100
+     *     2
+     *
+     *     CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054
+     *     DIRTY 335c4c6028171cfddfbaae1a9c313c52
+     *     CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934 2342
+     *     REMOVE 335c4c6028171cfddfbaae1a9c313c52
+     *     DIRTY 1ab96a171faeeee38496d8b330771a7a
+     *     CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234
+     *     READ 335c4c6028171cfddfbaae1a9c313c52
+     *     READ 3400330d1dfc7f3f7f4b8d4d803dfcf6
+     *
+     * The first five lines of the journal form its header. They are the
+     * constant string "libcore.io.DiskLruCache", the disk cache's version,
+     * the application's version, the value count, and a blank line.
+     *
+     * Each of the subsequent lines in the file is a record of the state of a
+     * cache entry. Each line contains space-separated values: a state, a key,
+     * and optional state-specific values.
+     *   o DIRTY lines track that an entry is actively being created or updated.
+     *     Every successful DIRTY action should be followed by a CLEAN or REMOVE
+     *     action. DIRTY lines without a matching CLEAN or REMOVE indicate that
+     *     temporary files may need to be deleted.
+     *   o CLEAN lines track a cache entry that has been successfully published
+     *     and may be read. A publish line is followed by the lengths of each of
+     *     its values.
+     *   o READ lines track accesses for LRU.
+     *   o REMOVE lines track entries that have been deleted.
+     *
+     * The journal file is appended to as cache operations occur. The journal may
+     * occasionally be compacted by dropping redundant lines. A temporary file named
+     * "journal.tmp" will be used during compaction; that file should be deleted if
+     * it exists when the cache is opened.
+     */
+
+  final FileSystem fileSystem;
+  final File directory;
+  private final File journalFile;
+  private final File journalFileTmp;
+  private final File journalFileBackup;
+  private final int appVersion;
+  private long maxSize;
+  final int valueCount;
+  private long size = 0;
+  BufferedSink journalWriter;
+  final LinkedHashMap<String, Entry> lruEntries = new LinkedHashMap<>(0, 0.75f, true);
+  int redundantOpCount;
+  boolean hasJournalErrors;
+
+  // Must be read and written when synchronized on 'this'.
+  boolean initialized;
+  boolean closed;
+  boolean mostRecentTrimFailed;
+  boolean mostRecentRebuildFailed;
+
+  /**
+   * To differentiate between old and current snapshots, each entry is given a sequence number each
+   * time an edit is committed. A snapshot is stale if its sequence number is not equal to its
+   * entry's sequence number.
+   */
+  private long nextSequenceNumber = 0;
+
+  /** Used to run 'cleanupRunnable' for journal rebuilds. */
+  private final Executor executor;
+  private final Runnable cleanupRunnable = new Runnable() {
+    public void run() {
+      synchronized (DiskLruCache.this) {
+        if (!initialized | closed) {
+          return; // Nothing to do
+        }
+
+        try {
+          trimToSize();
+        } catch (IOException ignored) {
+          mostRecentTrimFailed = true;
+        }
+
+        try {
+          if (journalRebuildRequired()) {
+            rebuildJournal();
+            redundantOpCount = 0;
+          }
+        } catch (IOException e) {
+          mostRecentRebuildFailed = true;
+          journalWriter = Okio.buffer(Okio.blackhole());
+        }
+      }
+    }
+  };
+
+  DiskLruCache(FileSystem fileSystem, File directory, int appVersion, int valueCount, long maxSize,
+      Executor executor) {
+    this.fileSystem = fileSystem;
+    this.directory = directory;
+    this.appVersion = appVersion;
+    this.journalFile = new File(directory, JOURNAL_FILE);
+    this.journalFileTmp = new File(directory, JOURNAL_FILE_TEMP);
+    this.journalFileBackup = new File(directory, JOURNAL_FILE_BACKUP);
+    this.valueCount = valueCount;
+    this.maxSize = maxSize;
+    this.executor = executor;
+  }
+
+  public synchronized void initialize() throws IOException {
+    assert Thread.holdsLock(this);
+
+    if (initialized) {
+      return; // Already initialized.
+    }
+
+    // If a bkp file exists, use it instead.
+    if (fileSystem.exists(journalFileBackup)) {
+      // If journal file also exists just delete backup file.
+      if (fileSystem.exists(journalFile)) {
+        fileSystem.delete(journalFileBackup);
+      } else {
+        fileSystem.rename(journalFileBackup, journalFile);
+      }
+    }
+
+    // Prefer to pick up where we left off.
+    if (fileSystem.exists(journalFile)) {
+      try {
+        readJournal();
+        processJournal();
+        initialized = true;
+        return;
+      } catch (IOException journalIsCorrupt) {
+        Platform.get().log(WARN, "DiskLruCache " + directory + " is corrupt: "
+            + journalIsCorrupt.getMessage() + ", removing", journalIsCorrupt);
+      }
+
+      // The cache is corrupted, attempt to delete the contents of the directory. This can throw and
+      // we'll let that propagate out as it likely means there is a severe filesystem problem.
+      try {
+        delete();
+      } finally {
+        closed = false;
+      }
+    }
+
+    rebuildJournal();
+
+    initialized = true;
+  }
+
+  /**
+   * Create a cache which will reside in {@code directory}. This cache is lazily initialized on
+   * first access and will be created if it does not exist.
+   *
+   * @param directory a writable directory
+   * @param valueCount the number of values per cache entry. Must be positive.
+   * @param maxSize the maximum number of bytes this cache should use to store
+   */
+  public static DiskLruCache create(FileSystem fileSystem, File directory, int appVersion,
+      int valueCount, long maxSize) {
+    if (maxSize <= 0) {
+      throw new IllegalArgumentException("maxSize <= 0");
+    }
+    if (valueCount <= 0) {
+      throw new IllegalArgumentException("valueCount <= 0");
+    }
+
+    // Use a single background thread to evict entries.
+    Executor executor = new ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS,
+        new LinkedBlockingQueue<Runnable>(), Util.threadFactory("OkHttp DiskLruCache", true));
+
+    return new DiskLruCache(fileSystem, directory, appVersion, valueCount, maxSize, executor);
+  }
+
+  private void readJournal() throws IOException {
+    BufferedSource source = Okio.buffer(fileSystem.source(journalFile));
+    try {
+      String magic = source.readUtf8LineStrict();
+      String version = source.readUtf8LineStrict();
+      String appVersionString = source.readUtf8LineStrict();
+      String valueCountString = source.readUtf8LineStrict();
+      String blank = source.readUtf8LineStrict();
+      if (!MAGIC.equals(magic)
+          || !VERSION_1.equals(version)
+          || !Integer.toString(appVersion).equals(appVersionString)
+          || !Integer.toString(valueCount).equals(valueCountString)
+          || !"".equals(blank)) {
+        throw new IOException("unexpected journal header: [" + magic + ", " + version + ", "
+            + valueCountString + ", " + blank + "]");
+      }
+
+      int lineCount = 0;
+      while (true) {
+        try {
+          readJournalLine(source.readUtf8LineStrict());
+          lineCount++;
+        } catch (EOFException endOfJournal) {
+          break;
+        }
+      }
+      redundantOpCount = lineCount - lruEntries.size();
+
+      // If we ended on a truncated line, rebuild the journal before appending to it.
+      if (!source.exhausted()) {
+        rebuildJournal();
+      } else {
+        journalWriter = newJournalWriter();
+      }
+    } finally {
+      Util.closeQuietly(source);
+    }
+  }
+
+  private BufferedSink newJournalWriter() throws FileNotFoundException {
+    Sink fileSink = fileSystem.appendingSink(journalFile);
+    Sink faultHidingSink = new FaultHidingSink(fileSink) {
+      @Override protected void onException(IOException e) {
+        assert (Thread.holdsLock(DiskLruCache.this));
+        hasJournalErrors = true;
+      }
+    };
+    return Okio.buffer(faultHidingSink);
+  }
+
+  private void readJournalLine(String line) throws IOException {
+    int firstSpace = line.indexOf(' ');
+    if (firstSpace == -1) {
+      throw new IOException("unexpected journal line: " + line);
+    }
+
+    int keyBegin = firstSpace + 1;
+    int secondSpace = line.indexOf(' ', keyBegin);
+    final String key;
+    if (secondSpace == -1) {
+      key = line.substring(keyBegin);
+      if (firstSpace == REMOVE.length() && line.startsWith(REMOVE)) {
+        lruEntries.remove(key);
+        return;
+      }
+    } else {
+      key = line.substring(keyBegin, secondSpace);
+    }
+
+    Entry entry = lruEntries.get(key);
+    if (entry == null) {
+      entry = new Entry(key);
+      lruEntries.put(key, entry);
+    }
+
+    if (secondSpace != -1 && firstSpace == CLEAN.length() && line.startsWith(CLEAN)) {
+      String[] parts = line.substring(secondSpace + 1).split(" ");
+      entry.readable = true;
+      entry.currentEditor = null;
+      entry.setLengths(parts);
+    } else if (secondSpace == -1 && firstSpace == DIRTY.length() && line.startsWith(DIRTY)) {
+      entry.currentEditor = new Editor(entry);
+    } else if (secondSpace == -1 && firstSpace == READ.length() && line.startsWith(READ)) {
+      // This work was already done by calling lruEntries.get().
+    } else {
+      throw new IOException("unexpected journal line: " + line);
+    }
+  }
+
+  /**
+   * Computes the initial size and collects garbage as a part of opening the cache. Dirty entries
+   * are assumed to be inconsistent and will be deleted.
+   */
+  private void processJournal() throws IOException {
+    fileSystem.delete(journalFileTmp);
+    for (Iterator<Entry> i = lruEntries.values().iterator(); i.hasNext(); ) {
+      Entry entry = i.next();
+      if (entry.currentEditor == null) {
+        for (int t = 0; t < valueCount; t++) {
+          size += entry.lengths[t];
+        }
+      } else {
+        entry.currentEditor = null;
+        for (int t = 0; t < valueCount; t++) {
+          fileSystem.delete(entry.cleanFiles[t]);
+          fileSystem.delete(entry.dirtyFiles[t]);
+        }
+        i.remove();
+      }
+    }
+  }
+
+  /**
+   * Creates a new journal that omits redundant information. This replaces the current journal if it
+   * exists.
+   */
+  synchronized void rebuildJournal() throws IOException {
+    if (journalWriter != null) {
+      journalWriter.close();
+    }
+
+    BufferedSink writer = Okio.buffer(fileSystem.sink(journalFileTmp));
+    try {
+      writer.writeUtf8(MAGIC).writeByte('\n');
+      writer.writeUtf8(VERSION_1).writeByte('\n');
+      writer.writeDecimalLong(appVersion).writeByte('\n');
+      writer.writeDecimalLong(valueCount).writeByte('\n');
+      writer.writeByte('\n');
+
+      for (Entry entry : lruEntries.values()) {
+        if (entry.currentEditor != null) {
+          writer.writeUtf8(DIRTY).writeByte(' ');
+          writer.writeUtf8(entry.key);
+          writer.writeByte('\n');
+        } else {
+          writer.writeUtf8(CLEAN).writeByte(' ');
+          writer.writeUtf8(entry.key);
+          entry.writeLengths(writer);
+          writer.writeByte('\n');
+        }
+      }
+    } finally {
+      writer.close();
+    }
+
+    if (fileSystem.exists(journalFile)) {
+      fileSystem.rename(journalFile, journalFileBackup);
+    }
+    fileSystem.rename(journalFileTmp, journalFile);
+    fileSystem.delete(journalFileBackup);
+
+    journalWriter = newJournalWriter();
+    hasJournalErrors = false;
+    mostRecentRebuildFailed = false;
+  }
+
+  /**
+   * Returns a snapshot of the entry named {@code key}, or null if it doesn't exist is not currently
+   * readable. If a value is returned, it is moved to the head of the LRU queue.
+   */
+  public synchronized Snapshot get(String key) throws IOException {
+    initialize();
+
+    checkNotClosed();
+    validateKey(key);
+    Entry entry = lruEntries.get(key);
+    if (entry == null || !entry.readable) return null;
+
+    Snapshot snapshot = entry.snapshot();
+    if (snapshot == null) return null;
+
+    redundantOpCount++;
+    journalWriter.writeUtf8(READ).writeByte(' ').writeUtf8(key).writeByte('\n');
+    if (journalRebuildRequired()) {
+      executor.execute(cleanupRunnable);
+    }
+
+    return snapshot;
+  }
+
+  /**
+   * Returns an editor for the entry named {@code key}, or null if another edit is in progress.
+   */
+  public @Nullable Editor edit(String key) throws IOException {
+    return edit(key, ANY_SEQUENCE_NUMBER);
+  }
+
+  synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException {
+    initialize();
+
+    checkNotClosed();
+    validateKey(key);
+    Entry entry = lruEntries.get(key);
+    if (expectedSequenceNumber != ANY_SEQUENCE_NUMBER && (entry == null
+        || entry.sequenceNumber != expectedSequenceNumber)) {
+      return null; // Snapshot is stale.
+    }
+    if (entry != null && entry.currentEditor != null) {
+      return null; // Another edit is in progress.
+    }
+    if (mostRecentTrimFailed || mostRecentRebuildFailed) {
+      // The OS has become our enemy! If the trim job failed, it means we are storing more data than
+      // requested by the user. Do not allow edits so we do not go over that limit any further. If
+      // the journal rebuild failed, the journal writer will not be active, meaning we will not be
+      // able to record the edit, causing file leaks. In both cases, we want to retry the clean up
+      // so we can get out of this state!
+      executor.execute(cleanupRunnable);
+      return null;
+    }
+
+    // Flush the journal before creating files to prevent file leaks.
+    journalWriter.writeUtf8(DIRTY).writeByte(' ').writeUtf8(key).writeByte('\n');
+    journalWriter.flush();
+
+    if (hasJournalErrors) {
+      return null; // Don't edit; the journal can't be written.
+    }
+
+    if (entry == null) {
+      entry = new Entry(key);
+      lruEntries.put(key, entry);
+    }
+    Editor editor = new Editor(entry);
+    entry.currentEditor = editor;
+    return editor;
+  }
+
+  /** Returns the directory where this cache stores its data. */
+  public File getDirectory() {
+    return directory;
+  }
+
+  /**
+   * Returns the maximum number of bytes that this cache should use to store its data.
+   */
+  public synchronized long getMaxSize() {
+    return maxSize;
+  }
+
+  /**
+   * Changes the maximum number of bytes the cache can store and queues a job to trim the existing
+   * store, if necessary.
+   */
+  public synchronized void setMaxSize(long maxSize) {
+    this.maxSize = maxSize;
+    if (initialized) {
+      executor.execute(cleanupRunnable);
+    }
+  }
+
+  /**
+   * Returns the number of bytes currently being used to store the values in this cache. This may be
+   * greater than the max size if a background deletion is pending.
+   */
+  public synchronized long size() throws IOException {
+    initialize();
+    return size;
+  }
+
+  synchronized void completeEdit(Editor editor, boolean success) throws IOException {
+    Entry entry = editor.entry;
+    if (entry.currentEditor != editor) {
+      throw new IllegalStateException();
+    }
+
+    // If this edit is creating the entry for the first time, every index must have a value.
+    if (success && !entry.readable) {
+      for (int i = 0; i < valueCount; i++) {
+        if (!editor.written[i]) {
+          editor.abort();
+          throw new IllegalStateException("Newly created entry didn't create value for index " + i);
+        }
+        if (!fileSystem.exists(entry.dirtyFiles[i])) {
+          editor.abort();
+          return;
+        }
+      }
+    }
+
+    for (int i = 0; i < valueCount; i++) {
+      File dirty = entry.dirtyFiles[i];
+      if (success) {
+        if (fileSystem.exists(dirty)) {
+          File clean = entry.cleanFiles[i];
+          fileSystem.rename(dirty, clean);
+          long oldLength = entry.lengths[i];
+          long newLength = fileSystem.size(clean);
+          entry.lengths[i] = newLength;
+          size = size - oldLength + newLength;
+        }
+      } else {
+        fileSystem.delete(dirty);
+      }
+    }
+
+    redundantOpCount++;
+    entry.currentEditor = null;
+    if (entry.readable | success) {
+      entry.readable = true;
+      journalWriter.writeUtf8(CLEAN).writeByte(' ');
+      journalWriter.writeUtf8(entry.key);
+      entry.writeLengths(journalWriter);
+      journalWriter.writeByte('\n');
+      if (success) {
+        entry.sequenceNumber = nextSequenceNumber++;
+      }
+    } else {
+      lruEntries.remove(entry.key);
+      journalWriter.writeUtf8(REMOVE).writeByte(' ');
+      journalWriter.writeUtf8(entry.key);
+      journalWriter.writeByte('\n');
+    }
+    journalWriter.flush();
+
+    if (size > maxSize || journalRebuildRequired()) {
+      executor.execute(cleanupRunnable);
+    }
+  }
+
+  /**
+   * We only rebuild the journal when it will halve the size of the journal and eliminate at least
+   * 2000 ops.
+   */
+  boolean journalRebuildRequired() {
+    final int redundantOpCompactThreshold = 2000;
+    return redundantOpCount >= redundantOpCompactThreshold
+        && redundantOpCount >= lruEntries.size();
+  }
+
+  /**
+   * Drops the entry for {@code key} if it exists and can be removed. If the entry for {@code key}
+   * is currently being edited, that edit will complete normally but its value will not be stored.
+   *
+   * @return true if an entry was removed.
+   */
+  public synchronized boolean remove(String key) throws IOException {
+    initialize();
+
+    checkNotClosed();
+    validateKey(key);
+    Entry entry = lruEntries.get(key);
+    if (entry == null) return false;
+    boolean removed = removeEntry(entry);
+    if (removed && size <= maxSize) mostRecentTrimFailed = false;
+    return removed;
+  }
+
+  boolean removeEntry(Entry entry) throws IOException {
+    if (entry.currentEditor != null) {
+      entry.currentEditor.detach(); // Prevent the edit from completing normally.
+    }
+
+    for (int i = 0; i < valueCount; i++) {
+      fileSystem.delete(entry.cleanFiles[i]);
+      size -= entry.lengths[i];
+      entry.lengths[i] = 0;
+    }
+
+    redundantOpCount++;
+    journalWriter.writeUtf8(REMOVE).writeByte(' ').writeUtf8(entry.key).writeByte('\n');
+    lruEntries.remove(entry.key);
+
+    if (journalRebuildRequired()) {
+      executor.execute(cleanupRunnable);
+    }
+
+    return true;
+  }
+
+  /** Returns true if this cache has been closed. */
+  public synchronized boolean isClosed() {
+    return closed;
+  }
+
+  private synchronized void checkNotClosed() {
+    if (isClosed()) {
+      throw new IllegalStateException("cache is closed");
+    }
+  }
+
+  /** Force buffered operations to the filesystem. */
+  @Override public synchronized void flush() throws IOException {
+    if (!initialized) return;
+
+    checkNotClosed();
+    trimToSize();
+    journalWriter.flush();
+  }
+
+  /** Closes this cache. Stored values will remain on the filesystem. */
+  @Override public synchronized void close() throws IOException {
+    if (!initialized || closed) {
+      closed = true;
+      return;
+    }
+    // Copying for safe iteration.
+    for (Entry entry : lruEntries.values().toArray(new Entry[lruEntries.size()])) {
+      if (entry.currentEditor != null) {
+        entry.currentEditor.abort();
+      }
+    }
+    trimToSize();
+    journalWriter.close();
+    journalWriter = null;
+    closed = true;
+  }
+
+  void trimToSize() throws IOException {
+    while (size > maxSize) {
+      Entry toEvict = lruEntries.values().iterator().next();
+      removeEntry(toEvict);
+    }
+    mostRecentTrimFailed = false;
+  }
+
+  /**
+   * Closes the cache and deletes all of its stored values. This will delete all files in the cache
+   * directory including files that weren't created by the cache.
+   */
+  public void delete() throws IOException {
+    close();
+    fileSystem.deleteContents(directory);
+  }
+
+  /**
+   * Deletes all stored values from the cache. In-flight edits will complete normally but their
+   * values will not be stored.
+   */
+  public synchronized void evictAll() throws IOException {
+    initialize();
+    // Copying for safe iteration.
+    for (Entry entry : lruEntries.values().toArray(new Entry[lruEntries.size()])) {
+      removeEntry(entry);
+    }
+    mostRecentTrimFailed = false;
+  }
+
+  private void validateKey(String key) {
+    Matcher matcher = LEGAL_KEY_PATTERN.matcher(key);
+    if (!matcher.matches()) {
+      throw new IllegalArgumentException(
+          "keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"");
+    }
+  }
+
+  /**
+   * Returns an iterator over the cache's current entries. This iterator doesn't throw {@code
+   * ConcurrentModificationException}, but if new entries are added while iterating, those new
+   * entries will not be returned by the iterator. If existing entries are removed during iteration,
+   * they will be absent (unless they were already returned).
+   *
+   * <p>If there are I/O problems during iteration, this iterator fails silently. For example, if
+   * the hosting filesystem becomes unreachable, the iterator will omit elements rather than
+   * throwing exceptions.
+   *
+   * <p><strong>The caller must {@link Snapshot#close close}</strong> each snapshot returned by
+   * {@link Iterator#next}. Failing to do so leaks open files!
+   *
+   * <p>The returned iterator supports {@link Iterator#remove}.
+   */
+  public synchronized Iterator<Snapshot> snapshots() throws IOException {
+    initialize();
+    return new Iterator<Snapshot>() {
+      /** Iterate a copy of the entries to defend against concurrent modification errors. */
+      final Iterator<Entry> delegate = new ArrayList<>(lruEntries.values()).iterator();
+
+      /** The snapshot to return from {@link #next}. Null if we haven't computed that yet. */
+      Snapshot nextSnapshot;
+
+      /** The snapshot to remove with {@link #remove}. Null if removal is illegal. */
+      Snapshot removeSnapshot;
+
+      @Override public boolean hasNext() {
+        if (nextSnapshot != null) return true;
+
+        synchronized (DiskLruCache.this) {
+          // If the cache is closed, truncate the iterator.
+          if (closed) return false;
+
+          while (delegate.hasNext()) {
+            Entry entry = delegate.next();
+            Snapshot snapshot = entry.snapshot();
+            if (snapshot == null) continue; // Evicted since we copied the entries.
+            nextSnapshot = snapshot;
+            return true;
+          }
+        }
+
+        return false;
+      }
+
+      @Override public Snapshot next() {
+        if (!hasNext()) throw new NoSuchElementException();
+        removeSnapshot = nextSnapshot;
+        nextSnapshot = null;
+        return removeSnapshot;
+      }
+
+      @Override public void remove() {
+        if (removeSnapshot == null) throw new IllegalStateException("remove() before next()");
+        try {
+          DiskLruCache.this.remove(removeSnapshot.key);
+        } catch (IOException ignored) {
+          // Nothing useful to do here. We failed to remove from the cache. Most likely that's
+          // because we couldn't update the journal, but the cached entry will still be gone.
+        } finally {
+          removeSnapshot = null;
+        }
+      }
+    };
+  }
+
+  /** A snapshot of the values for an entry. */
+  public final class Snapshot implements Closeable {
+    private final String key;
+    private final long sequenceNumber;
+    private final Source[] sources;
+    private final long[] lengths;
+
+    Snapshot(String key, long sequenceNumber, Source[] sources, long[] lengths) {
+      this.key = key;
+      this.sequenceNumber = sequenceNumber;
+      this.sources = sources;
+      this.lengths = lengths;
+    }
+
+    public String key() {
+      return key;
+    }
+
+    /**
+     * Returns an editor for this snapshot's entry, or null if either the entry has changed since
+     * this snapshot was created or if another edit is in progress.
+     */
+    public @Nullable Editor edit() throws IOException {
+      return DiskLruCache.this.edit(key, sequenceNumber);
+    }
+
+    /** Returns the unbuffered stream with the value for {@code index}. */
+    public Source getSource(int index) {
+      return sources[index];
+    }
+
+    /** Returns the byte length of the value for {@code index}. */
+    public long getLength(int index) {
+      return lengths[index];
+    }
+
+    public void close() {
+      for (Source in : sources) {
+        Util.closeQuietly(in);
+      }
+    }
+  }
+
+  /** Edits the values for an entry. */
+  public final class Editor {
+    final Entry entry;
+    final boolean[] written;
+    private boolean done;
+
+    Editor(Entry entry) {
+      this.entry = entry;
+      this.written = (entry.readable) ? null : new boolean[valueCount];
+    }
+
+    /**
+     * Prevents this editor from completing normally. This is necessary either when the edit causes
+     * an I/O error, or if the target entry is evicted while this editor is active. In either case
+     * we delete the editor's created files and prevent new files from being created. Note that once
+     * an editor has been detached it is possible for another editor to edit the entry.
+     */
+    void detach() {
+      if (entry.currentEditor == this) {
+        for (int i = 0; i < valueCount; i++) {
+          try {
+            fileSystem.delete(entry.dirtyFiles[i]);
+          } catch (IOException e) {
+            // This file is potentially leaked. Not much we can do about that.
+          }
+        }
+        entry.currentEditor = null;
+      }
+    }
+
+    /**
+     * Returns an unbuffered input stream to read the last committed value, or null if no value has
+     * been committed.
+     */
+    public Source newSource(int index) {
+      synchronized (DiskLruCache.this) {
+        if (done) {
+          throw new IllegalStateException();
+        }
+        if (!entry.readable || entry.currentEditor != this) {
+          return null;
+        }
+        try {
+          return fileSystem.source(entry.cleanFiles[index]);
+        } catch (FileNotFoundException e) {
+          return null;
+        }
+      }
+    }
+
+    /**
+     * Returns a new unbuffered output stream to write the value at {@code index}. If the underlying
+     * output stream encounters errors when writing to the filesystem, this edit will be aborted
+     * when {@link #commit} is called. The returned output stream does not throw IOExceptions.
+     */
+    public Sink newSink(int index) {
+      synchronized (DiskLruCache.this) {
+        if (done) {
+          throw new IllegalStateException();
+        }
+        if (entry.currentEditor != this) {
+          return Okio.blackhole();
+        }
+        if (!entry.readable) {
+          written[index] = true;
+        }
+        File dirtyFile = entry.dirtyFiles[index];
+        Sink sink;
+        try {
+          sink = fileSystem.sink(dirtyFile);
+        } catch (FileNotFoundException e) {
+          return Okio.blackhole();
+        }
+        return new FaultHidingSink(sink) {
+          @Override protected void onException(IOException e) {
+            synchronized (DiskLruCache.this) {
+              detach();
+            }
+          }
+        };
+      }
+    }
+
+    /**
+     * Commits this edit so it is visible to readers.  This releases the edit lock so another edit
+     * may be started on the same key.
+     */
+    public void commit() throws IOException {
+      synchronized (DiskLruCache.this) {
+        if (done) {
+          throw new IllegalStateException();
+        }
+        if (entry.currentEditor == this) {
+          completeEdit(this, true);
+        }
+        done = true;
+      }
+    }
+
+    /**
+     * Aborts this edit. This releases the edit lock so another edit may be started on the same
+     * key.
+     */
+    public void abort() throws IOException {
+      synchronized (DiskLruCache.this) {
+        if (done) {
+          throw new IllegalStateException();
+        }
+        if (entry.currentEditor == this) {
+          completeEdit(this, false);
+        }
+        done = true;
+      }
+    }
+
+    public void abortUnlessCommitted() {
+      synchronized (DiskLruCache.this) {
+        if (!done && entry.currentEditor == this) {
+          try {
+            completeEdit(this, false);
+          } catch (IOException ignored) {
+          }
+        }
+      }
+    }
+  }
+
+  private final class Entry {
+    final String key;
+
+    /** Lengths of this entry's files. */
+    final long[] lengths;
+    final File[] cleanFiles;
+    final File[] dirtyFiles;
+
+    /** True if this entry has ever been published. */
+    boolean readable;
+
+    /** The ongoing edit or null if this entry is not being edited. */
+    Editor currentEditor;
+
+    /** The sequence number of the most recently committed edit to this entry. */
+    long sequenceNumber;
+
+    Entry(String key) {
+      this.key = key;
+
+      lengths = new long[valueCount];
+      cleanFiles = new File[valueCount];
+      dirtyFiles = new File[valueCount];
+
+      // The names are repetitive so re-use the same builder to avoid allocations.
+      StringBuilder fileBuilder = new StringBuilder(key).append('.');
+      int truncateTo = fileBuilder.length();
+      for (int i = 0; i < valueCount; i++) {
+        fileBuilder.append(i);
+        cleanFiles[i] = new File(directory, fileBuilder.toString());
+        fileBuilder.append(".tmp");
+        dirtyFiles[i] = new File(directory, fileBuilder.toString());
+        fileBuilder.setLength(truncateTo);
+      }
+    }
+
+    /** Set lengths using decimal numbers like "10123". */
+    void setLengths(String[] strings) throws IOException {
+      if (strings.length != valueCount) {
+        throw invalidLengths(strings);
+      }
+
+      try {
+        for (int i = 0; i < strings.length; i++) {
+          lengths[i] = Long.parseLong(strings[i]);
+        }
+      } catch (NumberFormatException e) {
+        throw invalidLengths(strings);
+      }
+    }
+
+    /** Append space-prefixed lengths to {@code writer}. */
+    void writeLengths(BufferedSink writer) throws IOException {
+      for (long length : lengths) {
+        writer.writeByte(' ').writeDecimalLong(length);
+      }
+    }
+
+    private IOException invalidLengths(String[] strings) throws IOException {
+      throw new IOException("unexpected journal line: " + Arrays.toString(strings));
+    }
+
+    /**
+     * Returns a snapshot of this entry. This opens all streams eagerly to guarantee that we see a
+     * single published snapshot. If we opened streams lazily then the streams could come from
+     * different edits.
+     */
+    Snapshot snapshot() {
+      if (!Thread.holdsLock(DiskLruCache.this)) throw new AssertionError();
+
+      Source[] sources = new Source[valueCount];
+      long[] lengths = this.lengths.clone(); // Defensive copy since these can be zeroed out.
+      try {
+        for (int i = 0; i < valueCount; i++) {
+          sources[i] = fileSystem.source(cleanFiles[i]);
+        }
+        return new Snapshot(key, sequenceNumber, sources, lengths);
+      } catch (FileNotFoundException e) {
+        // A file must have been deleted manually!
+        for (int i = 0; i < valueCount; i++) {
+          if (sources[i] != null) {
+            Util.closeQuietly(sources[i]);
+          } else {
+            break;
+          }
+        }
+        // Since the entry is no longer valid, remove it so the metadata is accurate (i.e. the cache
+        // size.)
+        try {
+          removeEntry(this);
+        } catch (IOException ignored) {
+        }
+        return null;
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/FaultHidingSink.java b/okhttp/src/main/java/okhttp3/internal/cache/FaultHidingSink.java
new file mode 100644
index 0000000000..561a30507e
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/cache/FaultHidingSink.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.cache;
+
+import java.io.IOException;
+import okio.Buffer;
+import okio.ForwardingSink;
+import okio.Sink;
+
+/** A sink that never throws IOExceptions, even if the underlying sink does. */
+class FaultHidingSink extends ForwardingSink {
+  private boolean hasErrors;
+
+  FaultHidingSink(Sink delegate) {
+    super(delegate);
+  }
+
+  @Override public void write(Buffer source, long byteCount) throws IOException {
+    if (hasErrors) {
+      source.skip(byteCount);
+      return;
+    }
+    try {
+      super.write(source, byteCount);
+    } catch (IOException e) {
+      hasErrors = true;
+      onException(e);
+    }
+  }
+
+  @Override public void flush() throws IOException {
+    if (hasErrors) return;
+    try {
+      super.flush();
+    } catch (IOException e) {
+      hasErrors = true;
+      onException(e);
+    }
+  }
+
+  @Override public void close() throws IOException {
+    if (hasErrors) return;
+    try {
+      super.close();
+    } catch (IOException e) {
+      hasErrors = true;
+      onException(e);
+    }
+  }
+
+  protected void onException(IOException e) {
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/InternalCache.java b/okhttp/src/main/java/okhttp3/internal/cache/InternalCache.java
new file mode 100644
index 0000000000..6c70465b59
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/cache/InternalCache.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.cache;
+
+import java.io.IOException;
+import okhttp3.Request;
+import okhttp3.Response;
+
+/**
+ * OkHttp's internal cache interface. Applications shouldn't implement this: instead use {@link
+ * okhttp3.Cache}.
+ */
+public interface InternalCache {
+  Response get(Request request) throws IOException;
+
+  CacheRequest put(Response response) throws IOException;
+
+  /**
+   * Remove any cache entries for the supplied {@code request}. This is invoked when the client
+   * invalidates the cache, such as when making POST requests.
+   */
+  void remove(Request request) throws IOException;
+
+  /**
+   * Handles a conditional request hit by updating the stored cache response with the headers from
+   * {@code network}. The cached response body is not updated. If the stored response has changed
+   * since {@code cached} was returned, this does nothing.
+   */
+  void update(Response cached, Response network);
+
+  /** Track an conditional GET that was satisfied by this cache. */
+  void trackConditionalCacheHit();
+
+  /** Track an HTTP response being satisfied with {@code cacheStrategy}. */
+  void trackResponse(CacheStrategy cacheStrategy);
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/cache2/FileOperator.java b/okhttp/src/main/java/okhttp3/internal/cache2/FileOperator.java
new file mode 100644
index 0000000000..b1326cddc9
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/cache2/FileOperator.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.cache2;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.channels.FileChannel;
+import okio.Buffer;
+import okio.Okio;
+
+/**
+ * Read and write a target file. Unlike Okio's built-in {@linkplain Okio#source(java.io.File) file
+ * source} and {@linkplain Okio#sink(java.io.File) file sink} this class offers:
+ *
+ * <ul>
+ *   <li><strong>Read/write:</strong> read and write using the same operator.
+ *   <li><strong>Random access:</strong> access any position within the file.
+ *   <li><strong>Shared channels:</strong> read and write a file channel that's shared between
+ *       multiple operators. Note that although the underlying {@code FileChannel} may be shared,
+ *       each {@code FileOperator} should not be.
+ * </ul>
+ */
+final class FileOperator {
+  private static final int BUFFER_SIZE = 8192;
+
+  private final byte[] byteArray = new byte[BUFFER_SIZE];
+  private final ByteBuffer byteBuffer = ByteBuffer.wrap(byteArray);
+  private final FileChannel fileChannel;
+
+  FileOperator(FileChannel fileChannel) {
+    this.fileChannel = fileChannel;
+  }
+
+  /** Write {@code byteCount} bytes from {@code source} to the file at {@code pos}. */
+  public void write(long pos, Buffer source, long byteCount) throws IOException {
+    if (byteCount < 0 || byteCount > source.size()) throw new IndexOutOfBoundsException();
+
+    while (byteCount > 0L) {
+      try {
+        // Write bytes to the byte[], and tell the ByteBuffer wrapper about 'em.
+        int toWrite = (int) Math.min(BUFFER_SIZE, byteCount);
+        source.read(byteArray, 0, toWrite);
+        byteBuffer.limit(toWrite);
+
+        // Copy bytes from the ByteBuffer to the file.
+        do {
+          int bytesWritten = fileChannel.write(byteBuffer, pos);
+          pos += bytesWritten;
+        } while (byteBuffer.hasRemaining());
+
+        byteCount -= toWrite;
+      } finally {
+        byteBuffer.clear();
+      }
+    }
+  }
+
+  /**
+   * Copy {@code byteCount} bytes from the file at {@code pos} into to {@code source}. It is the
+   * caller's responsibility to make sure there are sufficient bytes to read: if there aren't this
+   * method throws an {@link EOFException}.
+   */
+  public void read(long pos, Buffer sink, long byteCount) throws IOException {
+    if (byteCount < 0) throw new IndexOutOfBoundsException();
+
+    while (byteCount > 0L) {
+      try {
+        // Read up to byteCount bytes.
+        byteBuffer.limit((int) Math.min(BUFFER_SIZE, byteCount));
+        if (fileChannel.read(byteBuffer, pos) == -1) throw new EOFException();
+        int bytesRead = byteBuffer.position();
+
+        // Write those bytes to sink.
+        sink.write(byteArray, 0, bytesRead);
+        pos += bytesRead;
+        byteCount -= bytesRead;
+      } finally {
+        byteBuffer.clear();
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/cache2/Relay.java b/okhttp/src/main/java/okhttp3/internal/cache2/Relay.java
new file mode 100644
index 0000000000..5131e6cd16
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/cache2/Relay.java
@@ -0,0 +1,361 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.cache2;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.RandomAccessFile;
+import okio.Buffer;
+import okio.ByteString;
+import okio.Source;
+import okio.Timeout;
+
+import static okhttp3.internal.Util.closeQuietly;
+
+/**
+ * Replicates a single upstream source into multiple downstream sources. Each downstream source
+ * returns the same bytes as the upstream source. Downstream sources may read data either as it
+ * is returned by upstream, or after the upstream source has been exhausted.
+ *
+ * <p>As bytes are returned from upstream they are written to a local file. Downstream sources read
+ * from this file as necessary.
+ *
+ * <p>This class also keeps a small buffer of bytes recently read from upstream. This is intended to
+ * save a small amount of file I/O and data copying.
+ */
+// TODO(jwilson): what to do about timeouts? They could be different and unfortunately when any
+//     timeout is hit we like to tear down the whole stream.
+final class Relay {
+  private static final int SOURCE_UPSTREAM = 1;
+  private static final int SOURCE_FILE = 2;
+
+  static final ByteString PREFIX_CLEAN = ByteString.encodeUtf8("OkHttp cache v1\n");
+  static final ByteString PREFIX_DIRTY = ByteString.encodeUtf8("OkHttp DIRTY :(\n");
+  private static final long FILE_HEADER_SIZE = 32L;
+
+  /**
+   * Read/write persistence of the upstream source and its metadata. Its layout is as follows:
+   *
+   * <ul>
+   *   <li>16 bytes: either {@code OkHttp cache v1\n} if the persisted file is complete. This is
+   *       another sequence of bytes if the file is incomplete and should not be used.
+   *   <li>8 bytes: <i>n</i>: upstream data size
+   *   <li>8 bytes: <i>m</i>: metadata size
+   *   <li><i>n</i> bytes: upstream data
+   *   <li><i>m</i> bytes: metadata
+   * </ul>
+   *
+   * <p>This is closed and assigned to null when the last source is closed and no further sources
+   * are permitted.
+   */
+  RandomAccessFile file;
+
+  /** The thread that currently has access to upstream. Possibly null. Guarded by this. */
+  Thread upstreamReader;
+
+  /**
+   * Null once the file has a complete copy of the upstream bytes. Only the {@code upstreamReader}
+   * thread may access this source.
+   */
+  Source upstream;
+
+  /**
+   * A buffer for {@code upstreamReader} to use when pulling bytes from upstream. Only the {@code
+   * upstreamReader} thread may access this buffer.
+   */
+  final Buffer upstreamBuffer = new Buffer();
+
+  /** The number of bytes consumed from {@link #upstream}. Guarded by this. */
+  long upstreamPos;
+
+  /** True if there are no further bytes to read from {@code upstream}. Guarded by this. */
+  boolean complete;
+
+  /** User-supplied additional data persisted with the source data. */
+  private final ByteString metadata;
+
+  /**
+   * The most recently read bytes from {@link #upstream}. This is a suffix of {@link #file}. Guarded
+   * by this.
+   */
+  final Buffer buffer = new Buffer();
+
+  /** The maximum size of {@code buffer}. */
+  final long bufferMaxSize;
+
+  /**
+   * Reference count of the number of active sources reading this stream. When decremented to 0
+   * resources are released and all following calls to {@link #newSource} return null. Guarded by
+   * this.
+   */
+  int sourceCount;
+
+  private Relay(RandomAccessFile file, Source upstream, long upstreamPos, ByteString metadata,
+      long bufferMaxSize) {
+    this.file = file;
+    this.upstream = upstream;
+    this.complete = upstream == null;
+    this.upstreamPos = upstreamPos;
+    this.metadata = metadata;
+    this.bufferMaxSize = bufferMaxSize;
+  }
+
+  /**
+   * Creates a new relay that reads a live stream from {@code upstream}, using {@code file} to share
+   * that data with other sources.
+   *
+   * <p><strong>Warning:</strong> callers to this method must immediately call {@link #newSource} to
+   * create a source and close that when they're done. Otherwise a handle to {@code file} will be
+   * leaked.
+   */
+  public static Relay edit(
+      File file, Source upstream, ByteString metadata, long bufferMaxSize) throws IOException {
+    RandomAccessFile randomAccessFile = new RandomAccessFile(file, "rw");
+    Relay result = new Relay(randomAccessFile, upstream, 0L, metadata, bufferMaxSize);
+
+    // Write a dirty header. That way if we crash we won't attempt to recover this.
+    randomAccessFile.setLength(0L);
+    result.writeHeader(PREFIX_DIRTY, -1L, -1L);
+
+    return result;
+  }
+
+  /**
+   * Creates a relay that reads a recorded stream from {@code file}.
+   *
+   * <p><strong>Warning:</strong> callers to this method must immediately call {@link #newSource} to
+   * create a source and close that when they're done. Otherwise a handle to {@code file} will be
+   * leaked.
+   */
+  public static Relay read(File file) throws IOException {
+    RandomAccessFile randomAccessFile = new RandomAccessFile(file, "rw");
+    FileOperator fileOperator = new FileOperator(randomAccessFile.getChannel());
+
+    // Read the header.
+    Buffer header = new Buffer();
+    fileOperator.read(0, header, FILE_HEADER_SIZE);
+    ByteString prefix = header.readByteString(PREFIX_CLEAN.size());
+    if (!prefix.equals(PREFIX_CLEAN)) throw new IOException("unreadable cache file");
+    long upstreamSize = header.readLong();
+    long metadataSize = header.readLong();
+
+    // Read the metadata.
+    Buffer metadataBuffer = new Buffer();
+    fileOperator.read(FILE_HEADER_SIZE + upstreamSize, metadataBuffer, metadataSize);
+    ByteString metadata = metadataBuffer.readByteString();
+
+    // Return the result.
+    return new Relay(randomAccessFile, null, upstreamSize, metadata, 0L);
+  }
+
+  private void writeHeader(
+      ByteString prefix, long upstreamSize, long metadataSize) throws IOException {
+    Buffer header = new Buffer();
+    header.write(prefix);
+    header.writeLong(upstreamSize);
+    header.writeLong(metadataSize);
+    if (header.size() != FILE_HEADER_SIZE) throw new IllegalArgumentException();
+
+    FileOperator fileOperator = new FileOperator(file.getChannel());
+    fileOperator.write(0, header, FILE_HEADER_SIZE);
+  }
+
+  private void writeMetadata(long upstreamSize) throws IOException {
+    Buffer metadataBuffer = new Buffer();
+    metadataBuffer.write(metadata);
+
+    FileOperator fileOperator = new FileOperator(file.getChannel());
+    fileOperator.write(FILE_HEADER_SIZE + upstreamSize, metadataBuffer, metadata.size());
+  }
+
+  void commit(long upstreamSize) throws IOException {
+    // Write metadata to the end of the file.
+    writeMetadata(upstreamSize);
+    file.getChannel().force(false);
+
+    // Once everything else is in place we can swap the dirty header for a clean one.
+    writeHeader(PREFIX_CLEAN, upstreamSize, metadata.size());
+    file.getChannel().force(false);
+
+    // This file is complete.
+    synchronized (Relay.this) {
+      complete = true;
+    }
+
+    closeQuietly(upstream);
+    upstream = null;
+  }
+
+  boolean isClosed() {
+    return file == null;
+  }
+
+  public ByteString metadata() {
+    return metadata;
+  }
+
+  /**
+   * Returns a new source that returns the same bytes as upstream. Returns null if this relay has
+   * been closed and no further sources are possible. In that case callers should retry after
+   * building a new relay with {@link #read}.
+   */
+  public Source newSource() {
+    synchronized (Relay.this) {
+      if (file == null) return null;
+      sourceCount++;
+    }
+
+    return new RelaySource();
+  }
+
+  class RelaySource implements Source {
+    private final Timeout timeout = new Timeout();
+
+    /** The operator to read and write the shared file. Null if this source is closed. */
+    private FileOperator fileOperator = new FileOperator(file.getChannel());
+
+    /** The next byte to read. This is always less than or equal to {@code upstreamPos}. */
+    private long sourcePos;
+
+    /**
+     * Selects where to find the bytes for a read and read them. This is one of three sources.
+     *
+     * <h3>Upstream:</h3>
+     * In this case the current thread is assigned as the upstream reader. We read bytes from
+     * upstream and copy them to both the file and to the buffer. Finally we release the upstream
+     * reader lock and return the new bytes.
+     *
+     * <h3>The file</h3>
+     * In this case we copy bytes from the file to the {@code sink}.
+     *
+     * <h3>The buffer</h3>
+     * In this case the bytes are immediately copied into {@code sink} and the number of bytes
+     * copied is returned.
+     *
+     * <p>If upstream would be selected but another thread is already reading upstream this will
+     * block until that read completes. It is possible to time out while waiting for that.
+     */
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
+      if (fileOperator == null) throw new IllegalStateException("closed");
+
+      long upstreamPos;
+      int source;
+
+      selectSource:
+      synchronized (Relay.this) {
+        // We need new data from upstream.
+        while (sourcePos == (upstreamPos = Relay.this.upstreamPos)) {
+          // No more data upstream. We're done.
+          if (complete) return -1L;
+
+          // Another thread is already reading. Wait for that.
+          if (upstreamReader != null) {
+            timeout.waitUntilNotified(Relay.this);
+            continue;
+          }
+
+          // We will do the read.
+          upstreamReader = Thread.currentThread();
+          source = SOURCE_UPSTREAM;
+          break selectSource;
+        }
+
+        long bufferPos = upstreamPos - buffer.size();
+
+        // Bytes of the read precede the buffer. Read from the file.
+        if (sourcePos < bufferPos) {
+          source = SOURCE_FILE;
+          break selectSource;
+        }
+
+        // The buffer has the data we need. Read from there and return immediately.
+        long bytesToRead = Math.min(byteCount, upstreamPos - sourcePos);
+        buffer.copyTo(sink, sourcePos - bufferPos, bytesToRead);
+        sourcePos += bytesToRead;
+        return bytesToRead;
+      }
+
+      // Read from the file.
+      if (source == SOURCE_FILE) {
+        long bytesToRead = Math.min(byteCount, upstreamPos - sourcePos);
+        fileOperator.read(FILE_HEADER_SIZE + sourcePos, sink, bytesToRead);
+        sourcePos += bytesToRead;
+        return bytesToRead;
+      }
+
+      // Read from upstream. This always reads a full buffer: that might be more than what the
+      // current call to Source.read() has requested.
+      try {
+        long upstreamBytesRead = upstream.read(upstreamBuffer, bufferMaxSize);
+
+        // If we've exhausted upstream, we're done.
+        if (upstreamBytesRead == -1L) {
+          commit(upstreamPos);
+          return -1L;
+        }
+
+        // Update this source and prepare this call's result.
+        long bytesRead = Math.min(upstreamBytesRead, byteCount);
+        upstreamBuffer.copyTo(sink, 0, bytesRead);
+        sourcePos += bytesRead;
+
+        // Append the upstream bytes to the file.
+        fileOperator.write(
+            FILE_HEADER_SIZE + upstreamPos, upstreamBuffer.clone(), upstreamBytesRead);
+
+        synchronized (Relay.this) {
+          // Append new upstream bytes into the buffer. Trim it to its max size.
+          buffer.write(upstreamBuffer, upstreamBytesRead);
+          if (buffer.size() > bufferMaxSize) {
+            buffer.skip(buffer.size() - bufferMaxSize);
+          }
+
+          // Now that the file and buffer have bytes, adjust upstreamPos.
+          Relay.this.upstreamPos += upstreamBytesRead;
+        }
+
+        return bytesRead;
+      } finally {
+        synchronized (Relay.this) {
+          upstreamReader = null;
+          Relay.this.notifyAll();
+        }
+      }
+    }
+
+    @Override public Timeout timeout() {
+      return timeout;
+    }
+
+    @Override public void close() throws IOException {
+      if (fileOperator == null) return; // Already closed.
+      fileOperator = null;
+
+      RandomAccessFile fileToClose = null;
+      synchronized (Relay.this) {
+        sourceCount--;
+        if (sourceCount == 0) {
+          fileToClose = file;
+          file = null;
+        }
+      }
+
+      if (fileToClose != null) {
+        closeQuietly(fileToClose);
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java b/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java
new file mode 100644
index 0000000000..b8a346c03a
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java
@@ -0,0 +1,47 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3.internal.connection;
+
+import java.io.IOException;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.http.HttpCodec;
+import okhttp3.internal.http.RealInterceptorChain;
+
+/** Opens a connection to the target server and proceeds to the next interceptor. */
+public final class ConnectInterceptor implements Interceptor {
+  public final OkHttpClient client;
+
+  public ConnectInterceptor(OkHttpClient client) {
+    this.client = client;
+  }
+
+  @Override public Response intercept(Chain chain) throws IOException {
+    RealInterceptorChain realChain = (RealInterceptorChain) chain;
+    Request request = realChain.request();
+    StreamAllocation streamAllocation = realChain.streamAllocation();
+
+    // We need the network to satisfy this request. Possibly for validating a conditional GET.
+    boolean doExtensiveHealthChecks = !request.method().equals("GET");
+    HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);
+    RealConnection connection = streamAllocation.connection();
+
+    return realChain.proceed(request, streamAllocation, httpCodec, connection);
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/ConnectionSpecSelector.java b/okhttp/src/main/java/okhttp3/internal/connection/ConnectionSpecSelector.java
new file mode 100644
index 0000000000..0b438bfa1f
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/connection/ConnectionSpecSelector.java
@@ -0,0 +1,142 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.connection;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.net.ProtocolException;
+import java.net.UnknownServiceException;
+import java.security.cert.CertificateException;
+import java.util.Arrays;
+import java.util.List;
+import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLProtocolException;
+import javax.net.ssl.SSLSocket;
+import okhttp3.ConnectionSpec;
+import okhttp3.internal.Internal;
+
+/**
+ * Handles the connection spec fallback strategy: When a secure socket connection fails due to a
+ * handshake / protocol problem the connection may be retried with different protocols. Instances
+ * are stateful and should be created and used for a single connection attempt.
+ */
+public final class ConnectionSpecSelector {
+
+  private final List<ConnectionSpec> connectionSpecs;
+  private int nextModeIndex;
+  private boolean isFallbackPossible;
+  private boolean isFallback;
+
+  public ConnectionSpecSelector(List<ConnectionSpec> connectionSpecs) {
+    this.nextModeIndex = 0;
+    this.connectionSpecs = connectionSpecs;
+  }
+
+  /**
+   * Configures the supplied {@link SSLSocket} to connect to the specified host using an appropriate
+   * {@link ConnectionSpec}. Returns the chosen {@link ConnectionSpec}, never {@code null}.
+   *
+   * @throws IOException if the socket does not support any of the TLS modes available
+   */
+  public ConnectionSpec configureSecureSocket(SSLSocket sslSocket) throws IOException {
+    ConnectionSpec tlsConfiguration = null;
+    for (int i = nextModeIndex, size = connectionSpecs.size(); i < size; i++) {
+      ConnectionSpec connectionSpec = connectionSpecs.get(i);
+      if (connectionSpec.isCompatible(sslSocket)) {
+        tlsConfiguration = connectionSpec;
+        nextModeIndex = i + 1;
+        break;
+      }
+    }
+
+    if (tlsConfiguration == null) {
+      // This may be the first time a connection has been attempted and the socket does not support
+      // any the required protocols, or it may be a retry (but this socket supports fewer
+      // protocols than was suggested by a prior socket).
+      throw new UnknownServiceException(
+          "Unable to find acceptable protocols. isFallback=" + isFallback
+              + ", modes=" + connectionSpecs
+              + ", supported protocols=" + Arrays.toString(sslSocket.getEnabledProtocols()));
+    }
+
+    isFallbackPossible = isFallbackPossible(sslSocket);
+
+    Internal.instance.apply(tlsConfiguration, sslSocket, isFallback);
+
+    return tlsConfiguration;
+  }
+
+  /**
+   * Reports a failure to complete a connection. Determines the next {@link ConnectionSpec} to try,
+   * if any.
+   *
+   * @return {@code true} if the connection should be retried using {@link
+   * #configureSecureSocket(SSLSocket)} or {@code false} if not
+   */
+  public boolean connectionFailed(IOException e) {
+    // Any future attempt to connect using this strategy will be a fallback attempt.
+    isFallback = true;
+
+    if (!isFallbackPossible) {
+      return false;
+    }
+
+    // If there was a protocol problem, don't recover.
+    if (e instanceof ProtocolException) {
+      return false;
+    }
+
+    // If there was an interruption or timeout (SocketTimeoutException), don't recover.
+    // For the socket connect timeout case we do not try the same host with a different
+    // ConnectionSpec: we assume it is unreachable.
+    if (e instanceof InterruptedIOException) {
+      return false;
+    }
+
+    // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
+    // again with a different connection spec.
+    if (e instanceof SSLHandshakeException) {
+      // If the problem was a CertificateException from the X509TrustManager,
+      // do not retry.
+      if (e.getCause() instanceof CertificateException) {
+        return false;
+      }
+    }
+    if (e instanceof SSLPeerUnverifiedException) {
+      // e.g. a certificate pinning error.
+      return false;
+    }
+
+    // On Android, SSLProtocolExceptions can be caused by TLS_FALLBACK_SCSV failures, which means we
+    // retry those when we probably should not.
+    return (e instanceof SSLHandshakeException || e instanceof SSLProtocolException);
+  }
+
+  /**
+   * Returns {@code true} if any later {@link ConnectionSpec} in the fallback strategy looks
+   * possible based on the supplied {@link SSLSocket}. It assumes that a future socket will have the
+   * same capabilities as the supplied socket.
+   */
+  private boolean isFallbackPossible(SSLSocket socket) {
+    for (int i = nextModeIndex; i < connectionSpecs.size(); i++) {
+      if (connectionSpecs.get(i).isCompatible(socket)) {
+        return true;
+      }
+    }
+    return false;
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
new file mode 100644
index 0000000000..6afb0fd017
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
@@ -0,0 +1,574 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3.internal.connection;
+
+import java.io.IOException;
+import java.lang.ref.Reference;
+import java.net.ConnectException;
+import java.net.ProtocolException;
+import java.net.Proxy;
+import java.net.Socket;
+import java.net.SocketException;
+import java.net.SocketTimeoutException;
+import java.net.UnknownServiceException;
+import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import okhttp3.Address;
+import okhttp3.Call;
+import okhttp3.CertificatePinner;
+import okhttp3.Connection;
+import okhttp3.ConnectionPool;
+import okhttp3.ConnectionSpec;
+import okhttp3.EventListener;
+import okhttp3.Handshake;
+import okhttp3.HttpUrl;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.Route;
+import okhttp3.internal.Internal;
+import okhttp3.internal.Util;
+import okhttp3.internal.Version;
+import okhttp3.internal.http.HttpCodec;
+import okhttp3.internal.http.HttpHeaders;
+import okhttp3.internal.http1.Http1Codec;
+import okhttp3.internal.http2.ErrorCode;
+import okhttp3.internal.http2.Http2Codec;
+import okhttp3.internal.http2.Http2Connection;
+import okhttp3.internal.http2.Http2Stream;
+import okhttp3.internal.platform.Platform;
+import okhttp3.internal.tls.OkHostnameVerifier;
+import okhttp3.internal.ws.RealWebSocket;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.Okio;
+import okio.Source;
+
+import static java.net.HttpURLConnection.HTTP_OK;
+import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static okhttp3.internal.Util.closeQuietly;
+
+public final class RealConnection extends Http2Connection.Listener implements Connection {
+  private static final String NPE_THROW_WITH_NULL = "throw with null exception";
+  private static final int MAX_TUNNEL_ATTEMPTS = 21;
+
+  private final ConnectionPool connectionPool;
+  private final Route route;
+
+  // The fields below are initialized by connect() and never reassigned.
+
+  /** The low-level TCP socket. */
+  private Socket rawSocket;
+
+  /**
+   * The application layer socket. Either an {@link SSLSocket} layered over {@link #rawSocket}, or
+   * {@link #rawSocket} itself if this connection does not use SSL.
+   */
+  private Socket socket;
+  private Handshake handshake;
+  private Protocol protocol;
+  private Http2Connection http2Connection;
+  private BufferedSource source;
+  private BufferedSink sink;
+
+  // The fields below track connection state and are guarded by connectionPool.
+
+  /** If true, no new streams can be created on this connection. Once true this is always true. */
+  public boolean noNewStreams;
+
+  public int successCount;
+
+  /**
+   * The maximum number of concurrent streams that can be carried by this connection. If {@code
+   * allocations.size() < allocationLimit} then new streams can be created on this connection.
+   */
+  public int allocationLimit = 1;
+
+  /** Current streams carried by this connection. */
+  public final List<Reference<StreamAllocation>> allocations = new ArrayList<>();
+
+  /** Nanotime timestamp when {@code allocations.size()} reached zero. */
+  public long idleAtNanos = Long.MAX_VALUE;
+
+  public RealConnection(ConnectionPool connectionPool, Route route) {
+    this.connectionPool = connectionPool;
+    this.route = route;
+  }
+
+  public static RealConnection testConnection(
+      ConnectionPool connectionPool, Route route, Socket socket, long idleAtNanos) {
+    RealConnection result = new RealConnection(connectionPool, route);
+    result.socket = socket;
+    result.idleAtNanos = idleAtNanos;
+    return result;
+  }
+
+  public void connect(int connectTimeout, int readTimeout, int writeTimeout,
+      boolean connectionRetryEnabled, Call call, EventListener eventListener) {
+    if (protocol != null) throw new IllegalStateException("already connected");
+
+    RouteException routeException = null;
+    List<ConnectionSpec> connectionSpecs = route.address().connectionSpecs();
+    ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);
+
+    if (route.address().sslSocketFactory() == null) {
+      if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {
+        throw new RouteException(new UnknownServiceException(
+            "CLEARTEXT communication not enabled for client"));
+      }
+      String host = route.address().url().host();
+      if (!Platform.get().isCleartextTrafficPermitted(host)) {
+        throw new RouteException(new UnknownServiceException(
+            "CLEARTEXT communication to " + host + " not permitted by network security policy"));
+      }
+    }
+
+    while (true) {
+      try {
+        if (route.requiresTunnel()) {
+          connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);
+          if (rawSocket == null) {
+            // We were unable to connect the tunnel but properly closed down our resources.
+            break;
+          }
+        } else {
+          connectSocket(connectTimeout, readTimeout, call, eventListener);
+        }
+        establishProtocol(connectionSpecSelector, call, eventListener);
+        eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol);
+        break;
+      } catch (IOException e) {
+        closeQuietly(socket);
+        closeQuietly(rawSocket);
+        socket = null;
+        rawSocket = null;
+        source = null;
+        sink = null;
+        handshake = null;
+        protocol = null;
+        http2Connection = null;
+
+        eventListener.connectFailed(call, route.socketAddress(), route.proxy(), null, e);
+
+        if (routeException == null) {
+          routeException = new RouteException(e);
+        } else {
+          routeException.addConnectException(e);
+        }
+
+        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {
+          throw routeException;
+        }
+      }
+    }
+
+    if (route.requiresTunnel() && rawSocket == null) {
+      ProtocolException exception = new ProtocolException("Too many tunnel connections attempted: "
+          + MAX_TUNNEL_ATTEMPTS);
+      throw new RouteException(exception);
+    }
+
+    if (http2Connection != null) {
+      synchronized (connectionPool) {
+        allocationLimit = http2Connection.maxConcurrentStreams();
+      }
+    }
+  }
+
+  /**
+   * Does all the work to build an HTTPS connection over a proxy tunnel. The catch here is that a
+   * proxy server can issue an auth challenge and then close the connection.
+   */
+  private void connectTunnel(int connectTimeout, int readTimeout, int writeTimeout, Call call,
+      EventListener eventListener) throws IOException {
+    Request tunnelRequest = createTunnelRequest();
+    HttpUrl url = tunnelRequest.url();
+    for (int i = 0; i < MAX_TUNNEL_ATTEMPTS; i++) {
+      connectSocket(connectTimeout, readTimeout, call, eventListener);
+      tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url);
+
+      if (tunnelRequest == null) break; // Tunnel successfully created.
+
+      // The proxy decided to close the connection after an auth challenge. We need to create a new
+      // connection, but this time with the auth credentials.
+      closeQuietly(rawSocket);
+      rawSocket = null;
+      sink = null;
+      source = null;
+      eventListener.connectEnd(call, route.socketAddress(), route.proxy(), null);
+    }
+  }
+
+  /** Does all the work necessary to build a full HTTP or HTTPS connection on a raw socket. */
+  private void connectSocket(int connectTimeout, int readTimeout, Call call,
+      EventListener eventListener) throws IOException {
+    Proxy proxy = route.proxy();
+    Address address = route.address();
+
+    rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP
+        ? address.socketFactory().createSocket()
+        : new Socket(proxy);
+
+    eventListener.connectStart(call, route.socketAddress(), proxy);
+    rawSocket.setSoTimeout(readTimeout);
+    try {
+      Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);
+    } catch (ConnectException e) {
+      ConnectException ce = new ConnectException("Failed to connect to " + route.socketAddress());
+      ce.initCause(e);
+      throw ce;
+    }
+
+    // The following try/catch block is a pseudo hacky way to get around a crash on Android 7.0
+    // More details:
+    // https://github.com/square/okhttp/issues/3245
+    // https://android-review.googlesource.com/#/c/271775/
+    try {
+      source = Okio.buffer(Okio.source(rawSocket));
+      sink = Okio.buffer(Okio.sink(rawSocket));
+    } catch (NullPointerException npe) {
+      if (NPE_THROW_WITH_NULL.equals(npe.getMessage())) {
+        throw new IOException(npe);
+      }
+    }
+  }
+
+  private void establishProtocol(ConnectionSpecSelector connectionSpecSelector, Call call,
+      EventListener eventListener) throws IOException {
+    if (route.address().sslSocketFactory() == null) {
+      protocol = Protocol.HTTP_1_1;
+      socket = rawSocket;
+      return;
+    }
+
+    eventListener.secureConnectStart(call);
+    connectTls(connectionSpecSelector);
+    eventListener.secureConnectEnd(call, handshake);
+
+    if (protocol == Protocol.HTTP_2) {
+      socket.setSoTimeout(0); // HTTP/2 connection timeouts are set per-stream.
+      http2Connection = new Http2Connection.Builder(true)
+          .socket(socket, route.address().url().host(), source, sink)
+          .listener(this)
+          .build();
+      http2Connection.start();
+    }
+  }
+
+  private void connectTls(ConnectionSpecSelector connectionSpecSelector) throws IOException {
+    Address address = route.address();
+    SSLSocketFactory sslSocketFactory = address.sslSocketFactory();
+    boolean success = false;
+    SSLSocket sslSocket = null;
+    try {
+      // Create the wrapper over the connected socket.
+      sslSocket = (SSLSocket) sslSocketFactory.createSocket(
+          rawSocket, address.url().host(), address.url().port(), true /* autoClose */);
+
+      // Configure the socket's ciphers, TLS versions, and extensions.
+      ConnectionSpec connectionSpec = connectionSpecSelector.configureSecureSocket(sslSocket);
+      if (connectionSpec.supportsTlsExtensions()) {
+        Platform.get().configureTlsExtensions(
+            sslSocket, address.url().host(), address.protocols());
+      }
+
+      // Force handshake. This can throw!
+      sslSocket.startHandshake();
+      Handshake unverifiedHandshake = Handshake.get(sslSocket.getSession());
+
+      // Verify that the socket's certificates are acceptable for the target host.
+      if (!address.hostnameVerifier().verify(address.url().host(), sslSocket.getSession())) {
+        X509Certificate cert = (X509Certificate) unverifiedHandshake.peerCertificates().get(0);
+        throw new SSLPeerUnverifiedException("Hostname " + address.url().host() + " not verified:"
+            + "\n    certificate: " + CertificatePinner.pin(cert)
+            + "\n    DN: " + cert.getSubjectDN().getName()
+            + "\n    subjectAltNames: " + OkHostnameVerifier.allSubjectAltNames(cert));
+      }
+
+      // Check that the certificate pinner is satisfied by the certificates presented.
+      address.certificatePinner().check(address.url().host(),
+          unverifiedHandshake.peerCertificates());
+
+      // Success! Save the handshake and the ALPN protocol.
+      String maybeProtocol = connectionSpec.supportsTlsExtensions()
+          ? Platform.get().getSelectedProtocol(sslSocket)
+          : null;
+      socket = sslSocket;
+      source = Okio.buffer(Okio.source(socket));
+      sink = Okio.buffer(Okio.sink(socket));
+      handshake = unverifiedHandshake;
+      protocol = maybeProtocol != null
+          ? Protocol.get(maybeProtocol)
+          : Protocol.HTTP_1_1;
+      success = true;
+    } catch (AssertionError e) {
+      if (Util.isAndroidGetsocknameError(e)) throw new IOException(e);
+      throw e;
+    } finally {
+      if (sslSocket != null) {
+        Platform.get().afterHandshake(sslSocket);
+      }
+      if (!success) {
+        closeQuietly(sslSocket);
+      }
+    }
+  }
+
+  /**
+   * To make an HTTPS connection over an HTTP proxy, send an unencrypted CONNECT request to create
+   * the proxy connection. This may need to be retried if the proxy requires authorization.
+   */
+  private Request createTunnel(int readTimeout, int writeTimeout, Request tunnelRequest,
+      HttpUrl url) throws IOException {
+    // Make an SSL Tunnel on the first message pair of each SSL + proxy connection.
+    String requestLine = "CONNECT " + Util.hostHeader(url, true) + " HTTP/1.1";
+    while (true) {
+      Http1Codec tunnelConnection = new Http1Codec(null, null, source, sink);
+      source.timeout().timeout(readTimeout, MILLISECONDS);
+      sink.timeout().timeout(writeTimeout, MILLISECONDS);
+      tunnelConnection.writeRequest(tunnelRequest.headers(), requestLine);
+      tunnelConnection.finishRequest();
+      Response response = tunnelConnection.readResponseHeaders(false)
+          .request(tunnelRequest)
+          .build();
+      // The response body from a CONNECT should be empty, but if it is not then we should consume
+      // it before proceeding.
+      long contentLength = HttpHeaders.contentLength(response);
+      if (contentLength == -1L) {
+        contentLength = 0L;
+      }
+      Source body = tunnelConnection.newFixedLengthSource(contentLength);
+      Util.skipAll(body, Integer.MAX_VALUE, TimeUnit.MILLISECONDS);
+      body.close();
+
+      switch (response.code()) {
+        case HTTP_OK:
+          // Assume the server won't send a TLS ServerHello until we send a TLS ClientHello. If
+          // that happens, then we will have buffered bytes that are needed by the SSLSocket!
+          // This check is imperfect: it doesn't tell us whether a handshake will succeed, just
+          // that it will almost certainly fail because the proxy has sent unexpected data.
+          if (!source.buffer().exhausted() || !sink.buffer().exhausted()) {
+            throw new IOException("TLS tunnel buffered too many bytes!");
+          }
+          return null;
+
+        case HTTP_PROXY_AUTH:
+          tunnelRequest = route.address().proxyAuthenticator().authenticate(route, response);
+          if (tunnelRequest == null) throw new IOException("Failed to authenticate with proxy");
+
+          if ("close".equalsIgnoreCase(response.header("Connection"))) {
+            return tunnelRequest;
+          }
+          break;
+
+        default:
+          throw new IOException(
+              "Unexpected response code for CONNECT: " + response.code());
+      }
+    }
+  }
+
+  /**
+   * Returns a request that creates a TLS tunnel via an HTTP proxy. Everything in the tunnel request
+   * is sent unencrypted to the proxy server, so tunnels include only the minimum set of headers.
+   * This avoids sending potentially sensitive data like HTTP cookies to the proxy unencrypted.
+   */
+  private Request createTunnelRequest() {
+    return new Request.Builder()
+        .url(route.address().url())
+        .header("Host", Util.hostHeader(route.address().url(), true))
+        .header("Proxy-Connection", "Keep-Alive") // For HTTP/1.0 proxies like Squid.
+        .header("User-Agent", Version.userAgent())
+        .build();
+  }
+
+  /**
+   * Returns true if this connection can carry a stream allocation to {@code address}. If non-null
+   * {@code route} is the resolved route for a connection.
+   */
+  public boolean isEligible(Address address, @Nullable Route route) {
+    // If this connection is not accepting new streams, we're done.
+    if (allocations.size() >= allocationLimit || noNewStreams) return false;
+
+    // If the non-host fields of the address don't overlap, we're done.
+    if (!Internal.instance.equalsNonHost(this.route.address(), address)) return false;
+
+    // If the host exactly matches, we're done: this connection can carry the address.
+    if (address.url().host().equals(this.route().address().url().host())) {
+      return true; // This connection is a perfect match.
+    }
+
+    // At this point we don't have a hostname match. But we still be able to carry the request if
+    // our connection coalescing requirements are met. See also:
+    // https://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding
+    // https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/
+
+    // 1. This connection must be HTTP/2.
+    if (http2Connection == null) return false;
+
+    // 2. The routes must share an IP address. This requires us to have a DNS address for both
+    // hosts, which only happens after route planning. We can't coalesce connections that use a
+    // proxy, since proxies don't tell us the origin server's IP address.
+    if (route == null) return false;
+    if (route.proxy().type() != Proxy.Type.DIRECT) return false;
+    if (this.route.proxy().type() != Proxy.Type.DIRECT) return false;
+    if (!this.route.socketAddress().equals(route.socketAddress())) return false;
+
+    // 3. This connection's server certificate's must cover the new host.
+    if (route.address().hostnameVerifier() != OkHostnameVerifier.INSTANCE) return false;
+    if (!supportsUrl(address.url())) return false;
+
+    // 4. Certificate pinning must match the host.
+    try {
+      address.certificatePinner().check(address.url().host(), handshake().peerCertificates());
+    } catch (SSLPeerUnverifiedException e) {
+      return false;
+    }
+
+    return true; // The caller's address can be carried by this connection.
+  }
+
+  public boolean supportsUrl(HttpUrl url) {
+    if (url.port() != route.address().url().port()) {
+      return false; // Port mismatch.
+    }
+
+    if (!url.host().equals(route.address().url().host())) {
+      // We have a host mismatch. But if the certificate matches, we're still good.
+      return handshake != null && OkHostnameVerifier.INSTANCE.verify(
+          url.host(), (X509Certificate) handshake.peerCertificates().get(0));
+    }
+
+    return true; // Success. The URL is supported.
+  }
+
+  public HttpCodec newCodec(OkHttpClient client, Interceptor.Chain chain,
+      StreamAllocation streamAllocation) throws SocketException {
+    if (http2Connection != null) {
+      return new Http2Codec(client, chain, streamAllocation, http2Connection);
+    } else {
+      socket.setSoTimeout(chain.readTimeoutMillis());
+      source.timeout().timeout(chain.readTimeoutMillis(), MILLISECONDS);
+      sink.timeout().timeout(chain.writeTimeoutMillis(), MILLISECONDS);
+      return new Http1Codec(client, streamAllocation, source, sink);
+    }
+  }
+
+  public RealWebSocket.Streams newWebSocketStreams(final StreamAllocation streamAllocation) {
+    return new RealWebSocket.Streams(true, source, sink) {
+      @Override public void close() throws IOException {
+        streamAllocation.streamFinished(true, streamAllocation.codec(), -1L, null);
+      }
+    };
+  }
+
+  @Override public Route route() {
+    return route;
+  }
+
+  public void cancel() {
+    // Close the raw socket so we don't end up doing synchronous I/O.
+    closeQuietly(rawSocket);
+  }
+
+  @Override public Socket socket() {
+    return socket;
+  }
+
+  /** Returns true if this connection is ready to host new streams. */
+  public boolean isHealthy(boolean doExtensiveChecks) {
+    if (socket.isClosed() || socket.isInputShutdown() || socket.isOutputShutdown()) {
+      return false;
+    }
+
+    if (http2Connection != null) {
+      return !http2Connection.isShutdown();
+    }
+
+    if (doExtensiveChecks) {
+      try {
+        int readTimeout = socket.getSoTimeout();
+        try {
+          socket.setSoTimeout(1);
+          if (source.exhausted()) {
+            return false; // Stream is exhausted; socket is closed.
+          }
+          return true;
+        } finally {
+          socket.setSoTimeout(readTimeout);
+        }
+      } catch (SocketTimeoutException ignored) {
+        // Read timed out; socket is good.
+      } catch (IOException e) {
+        return false; // Couldn't read; socket is closed.
+      }
+    }
+
+    return true;
+  }
+
+  /** Refuse incoming streams. */
+  @Override public void onStream(Http2Stream stream) throws IOException {
+    stream.close(ErrorCode.REFUSED_STREAM);
+  }
+
+  /** When settings are received, adjust the allocation limit. */
+  @Override public void onSettings(Http2Connection connection) {
+    synchronized (connectionPool) {
+      allocationLimit = connection.maxConcurrentStreams();
+    }
+  }
+
+  @Override public Handshake handshake() {
+    return handshake;
+  }
+
+  /**
+   * Returns true if this is an HTTP/2 connection. Such connections can be used in multiple HTTP
+   * requests simultaneously.
+   */
+  public boolean isMultiplexed() {
+    return http2Connection != null;
+  }
+
+  @Override public Protocol protocol() {
+    return protocol;
+  }
+
+  @Override public String toString() {
+    return "Connection{"
+        + route.address().url().host() + ":" + route.address().url().port()
+        + ", proxy="
+        + route.proxy()
+        + " hostAddress="
+        + route.socketAddress()
+        + " cipherSuite="
+        + (handshake != null ? handshake.cipherSuite() : "none")
+        + " protocol="
+        + protocol
+        + '}';
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RouteDatabase.java b/okhttp/src/main/java/okhttp3/internal/connection/RouteDatabase.java
new file mode 100644
index 0000000000..d0c1a9d79e
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RouteDatabase.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.connection;
+
+import java.util.LinkedHashSet;
+import java.util.Set;
+import okhttp3.Route;
+
+/**
+ * A blacklist of failed routes to avoid when creating a new connection to a target address. This is
+ * used so that OkHttp can learn from its mistakes: if there was a failure attempting to connect to
+ * a specific IP address or proxy server, that failure is remembered and alternate routes are
+ * preferred.
+ */
+public final class RouteDatabase {
+  private final Set<Route> failedRoutes = new LinkedHashSet<>();
+
+  /** Records a failure connecting to {@code failedRoute}. */
+  public synchronized void failed(Route failedRoute) {
+    failedRoutes.add(failedRoute);
+  }
+
+  /** Records success connecting to {@code route}. */
+  public synchronized void connected(Route route) {
+    failedRoutes.remove(route);
+  }
+
+  /** Returns true if {@code route} has failed recently and should be avoided. */
+  public synchronized boolean shouldPostpone(Route route) {
+    return failedRoutes.contains(route);
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RouteException.java b/okhttp/src/main/java/okhttp3/internal/connection/RouteException.java
new file mode 100644
index 0000000000..5f50576611
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RouteException.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.connection;
+
+import java.io.IOException;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+/**
+ * An exception thrown to indicate a problem connecting via a single Route. Multiple attempts may
+ * have been made with alternative protocols, none of which were successful.
+ */
+public final class RouteException extends RuntimeException {
+  private static final Method addSuppressedExceptionMethod;
+
+  static {
+    Method m;
+    try {
+      m = Throwable.class.getDeclaredMethod("addSuppressed", Throwable.class);
+    } catch (Exception e) {
+      m = null;
+    }
+    addSuppressedExceptionMethod = m;
+  }
+
+  private IOException lastException;
+
+  public RouteException(IOException cause) {
+    super(cause);
+    lastException = cause;
+  }
+
+  public IOException getLastConnectException() {
+    return lastException;
+  }
+
+  public void addConnectException(IOException e) {
+    addSuppressedIfPossible(e, lastException);
+    lastException = e;
+  }
+
+  private void addSuppressedIfPossible(IOException e, IOException suppressed) {
+    if (addSuppressedExceptionMethod != null) {
+      try {
+        addSuppressedExceptionMethod.invoke(e, suppressed);
+      } catch (InvocationTargetException | IllegalAccessException ignored) {
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.java b/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.java
new file mode 100644
index 0000000000..40752ce23d
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.java
@@ -0,0 +1,241 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.connection;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.net.SocketAddress;
+import java.net.SocketException;
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.NoSuchElementException;
+import okhttp3.Address;
+import okhttp3.Call;
+import okhttp3.EventListener;
+import okhttp3.HttpUrl;
+import okhttp3.Route;
+import okhttp3.internal.Util;
+
+/**
+ * Selects routes to connect to an origin server. Each connection requires a choice of proxy server,
+ * IP address, and TLS mode. Connections may also be recycled.
+ */
+public final class RouteSelector {
+  private final Address address;
+  private final RouteDatabase routeDatabase;
+  private final Call call;
+  private final EventListener eventListener;
+
+  /* State for negotiating the next proxy to use. */
+  private List<Proxy> proxies = Collections.emptyList();
+  private int nextProxyIndex;
+
+  /* State for negotiating the next socket address to use. */
+  private List<InetSocketAddress> inetSocketAddresses = Collections.emptyList();
+
+  /* State for negotiating failed routes */
+  private final List<Route> postponedRoutes = new ArrayList<>();
+
+  public RouteSelector(Address address, RouteDatabase routeDatabase, Call call,
+      EventListener eventListener) {
+    this.address = address;
+    this.routeDatabase = routeDatabase;
+    this.call = call;
+    this.eventListener = eventListener;
+
+    resetNextProxy(address.url(), address.proxy());
+  }
+
+  /**
+   * Returns true if there's another set of routes to attempt. Every address has at least one route.
+   */
+  public boolean hasNext() {
+    return hasNextProxy() || !postponedRoutes.isEmpty();
+  }
+
+  public Selection next() throws IOException {
+    if (!hasNext()) {
+      throw new NoSuchElementException();
+    }
+
+    // Compute the next set of routes to attempt.
+    List<Route> routes = new ArrayList<>();
+    while (hasNextProxy()) {
+      // Postponed routes are always tried last. For example, if we have 2 proxies and all the
+      // routes for proxy1 should be postponed, we'll move to proxy2. Only after we've exhausted
+      // all the good routes will we attempt the postponed routes.
+      Proxy proxy = nextProxy();
+      for (int i = 0, size = inetSocketAddresses.size(); i < size; i++) {
+        Route route = new Route(address, proxy, inetSocketAddresses.get(i));
+        if (routeDatabase.shouldPostpone(route)) {
+          postponedRoutes.add(route);
+        } else {
+          routes.add(route);
+        }
+      }
+
+      if (!routes.isEmpty()) {
+        break;
+      }
+    }
+
+    if (routes.isEmpty()) {
+      // We've exhausted all Proxies so fallback to the postponed routes.
+      routes.addAll(postponedRoutes);
+      postponedRoutes.clear();
+    }
+
+    return new Selection(routes);
+  }
+
+  /**
+   * Clients should invoke this method when they encounter a connectivity failure on a connection
+   * returned by this route selector.
+   */
+  public void connectFailed(Route failedRoute, IOException failure) {
+    if (failedRoute.proxy().type() != Proxy.Type.DIRECT && address.proxySelector() != null) {
+      // Tell the proxy selector when we fail to connect on a fresh connection.
+      address.proxySelector().connectFailed(
+          address.url().uri(), failedRoute.proxy().address(), failure);
+    }
+
+    routeDatabase.failed(failedRoute);
+  }
+
+  /** Prepares the proxy servers to try. */
+  private void resetNextProxy(HttpUrl url, Proxy proxy) {
+    if (proxy != null) {
+      // If the user specifies a proxy, try that and only that.
+      proxies = Collections.singletonList(proxy);
+    } else {
+      // Try each of the ProxySelector choices until one connection succeeds.
+      List<Proxy> proxiesOrNull = address.proxySelector().select(url.uri());
+      proxies = proxiesOrNull != null && !proxiesOrNull.isEmpty()
+          ? Util.immutableList(proxiesOrNull)
+          : Util.immutableList(Proxy.NO_PROXY);
+    }
+    nextProxyIndex = 0;
+  }
+
+  /** Returns true if there's another proxy to try. */
+  private boolean hasNextProxy() {
+    return nextProxyIndex < proxies.size();
+  }
+
+  /** Returns the next proxy to try. May be PROXY.NO_PROXY but never null. */
+  private Proxy nextProxy() throws IOException {
+    if (!hasNextProxy()) {
+      throw new SocketException("No route to " + address.url().host()
+          + "; exhausted proxy configurations: " + proxies);
+    }
+    Proxy result = proxies.get(nextProxyIndex++);
+    resetNextInetSocketAddress(result);
+    return result;
+  }
+
+  /** Prepares the socket addresses to attempt for the current proxy or host. */
+  private void resetNextInetSocketAddress(Proxy proxy) throws IOException {
+    // Clear the addresses. Necessary if getAllByName() below throws!
+    inetSocketAddresses = new ArrayList<>();
+
+    String socketHost;
+    int socketPort;
+    if (proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.SOCKS) {
+      socketHost = address.url().host();
+      socketPort = address.url().port();
+    } else {
+      SocketAddress proxyAddress = proxy.address();
+      if (!(proxyAddress instanceof InetSocketAddress)) {
+        throw new IllegalArgumentException(
+            "Proxy.address() is not an " + "InetSocketAddress: " + proxyAddress.getClass());
+      }
+      InetSocketAddress proxySocketAddress = (InetSocketAddress) proxyAddress;
+      socketHost = getHostString(proxySocketAddress);
+      socketPort = proxySocketAddress.getPort();
+    }
+
+    if (socketPort < 1 || socketPort > 65535) {
+      throw new SocketException("No route to " + socketHost + ":" + socketPort
+          + "; port is out of range");
+    }
+
+    if (proxy.type() == Proxy.Type.SOCKS) {
+      inetSocketAddresses.add(InetSocketAddress.createUnresolved(socketHost, socketPort));
+    } else {
+      eventListener.dnsStart(call, socketHost);
+
+      // Try each address for best behavior in mixed IPv4/IPv6 environments.
+      List<InetAddress> addresses = address.dns().lookup(socketHost);
+      if (addresses.isEmpty()) {
+        throw new UnknownHostException(address.dns() + " returned no addresses for " + socketHost);
+      }
+
+      eventListener.dnsEnd(call, socketHost, addresses);
+
+      for (int i = 0, size = addresses.size(); i < size; i++) {
+        InetAddress inetAddress = addresses.get(i);
+        inetSocketAddresses.add(new InetSocketAddress(inetAddress, socketPort));
+      }
+    }
+  }
+
+  /**
+   * Obtain a "host" from an {@link InetSocketAddress}. This returns a string containing either an
+   * actual host name or a numeric IP address.
+   */
+  // Visible for testing
+  static String getHostString(InetSocketAddress socketAddress) {
+    InetAddress address = socketAddress.getAddress();
+    if (address == null) {
+      // The InetSocketAddress was specified with a string (either a numeric IP or a host name). If
+      // it is a name, all IPs for that name should be tried. If it is an IP address, only that IP
+      // address should be tried.
+      return socketAddress.getHostName();
+    }
+    // The InetSocketAddress has a specific address: we should only try that address. Therefore we
+    // return the address and ignore any host name that may be available.
+    return address.getHostAddress();
+  }
+
+  /** A set of selected Routes. */
+  public static final class Selection {
+    private final List<Route> routes;
+    private int nextRouteIndex = 0;
+
+    Selection(List<Route> routes) {
+      this.routes = routes;
+    }
+
+    public boolean hasNext() {
+      return nextRouteIndex < routes.size();
+    }
+
+    public Route next() {
+      if (!hasNext()) {
+        throw new NoSuchElementException();
+      }
+      return routes.get(nextRouteIndex++);
+    }
+
+    public List<Route> getAll() {
+      return new ArrayList<>(routes);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
new file mode 100644
index 0000000000..2e5e043a15
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
@@ -0,0 +1,529 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.connection;
+
+import java.io.IOException;
+import java.lang.ref.Reference;
+import java.lang.ref.WeakReference;
+import java.net.Socket;
+import java.util.List;
+import okhttp3.Address;
+import okhttp3.Call;
+import okhttp3.Connection;
+import okhttp3.ConnectionPool;
+import okhttp3.EventListener;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Route;
+import okhttp3.internal.Internal;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.HttpCodec;
+import okhttp3.internal.http2.ConnectionShutdownException;
+import okhttp3.internal.http2.ErrorCode;
+import okhttp3.internal.http2.StreamResetException;
+
+import static okhttp3.internal.Util.closeQuietly;
+
+/**
+ * This class coordinates the relationship between three entities:
+ *
+ * <ul>
+ *     <li><strong>Connections:</strong> physical socket connections to remote servers. These are
+ *         potentially slow to establish so it is necessary to be able to cancel a connection
+ *         currently being connected.
+ *     <li><strong>Streams:</strong> logical HTTP request/response pairs that are layered on
+ *         connections. Each connection has its own allocation limit, which defines how many
+ *         concurrent streams that connection can carry. HTTP/1.x connections can carry 1 stream
+ *         at a time, HTTP/2 typically carry multiple.
+ *     <li><strong>Calls:</strong> a logical sequence of streams, typically an initial request and
+ *         its follow up requests. We prefer to keep all streams of a single call on the same
+ *         connection for better behavior and locality.
+ * </ul>
+ *
+ * <p>Instances of this class act on behalf of the call, using one or more streams over one or more
+ * connections. This class has APIs to release each of the above resources:
+ *
+ * <ul>
+ *     <li>{@link #noNewStreams()} prevents the connection from being used for new streams in the
+ *         future. Use this after a {@code Connection: close} header, or when the connection may be
+ *         inconsistent.
+ *     <li>{@link #streamFinished streamFinished()} releases the active stream from this allocation.
+ *         Note that only one stream may be active at a given time, so it is necessary to call
+ *         {@link #streamFinished streamFinished()} before creating a subsequent stream with {@link
+ *         #newStream newStream()}.
+ *     <li>{@link #release()} removes the call's hold on the connection. Note that this won't
+ *         immediately free the connection if there is a stream still lingering. That happens when a
+ *         call is complete but its response body has yet to be fully consumed.
+ * </ul>
+ *
+ * <p>This class supports {@linkplain #cancel asynchronous canceling}. This is intended to have the
+ * smallest blast radius possible. If an HTTP/2 stream is active, canceling will cancel that stream
+ * but not the other streams sharing its connection. But if the TLS handshake is still in progress
+ * then canceling may break the entire connection.
+ */
+public final class StreamAllocation {
+  public final Address address;
+  private RouteSelector.Selection routeSelection;
+  private Route route;
+  private final ConnectionPool connectionPool;
+  public final Call call;
+  public final EventListener eventListener;
+  private final Object callStackTrace;
+
+  // State guarded by connectionPool.
+  private final RouteSelector routeSelector;
+  private int refusedStreamCount;
+  private RealConnection connection;
+  private boolean reportedAcquired;
+  private boolean released;
+  private boolean canceled;
+  private HttpCodec codec;
+
+  public StreamAllocation(ConnectionPool connectionPool, Address address, Call call,
+      EventListener eventListener, Object callStackTrace) {
+    this.connectionPool = connectionPool;
+    this.address = address;
+    this.call = call;
+    this.eventListener = eventListener;
+    this.routeSelector = new RouteSelector(address, routeDatabase(), call, eventListener);
+    this.callStackTrace = callStackTrace;
+  }
+
+  public HttpCodec newStream(
+      OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) {
+    int connectTimeout = chain.connectTimeoutMillis();
+    int readTimeout = chain.readTimeoutMillis();
+    int writeTimeout = chain.writeTimeoutMillis();
+    boolean connectionRetryEnabled = client.retryOnConnectionFailure();
+
+    try {
+      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,
+          writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);
+      HttpCodec resultCodec = resultConnection.newCodec(client, chain, this);
+
+      synchronized (connectionPool) {
+        codec = resultCodec;
+        return resultCodec;
+      }
+    } catch (IOException e) {
+      throw new RouteException(e);
+    }
+  }
+
+  /**
+   * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated
+   * until a healthy connection is found.
+   */
+  private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,
+      int writeTimeout, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks)
+      throws IOException {
+    while (true) {
+      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,
+          connectionRetryEnabled);
+
+      // If this is a brand new connection, we can skip the extensive health checks.
+      synchronized (connectionPool) {
+        if (candidate.successCount == 0) {
+          return candidate;
+        }
+      }
+
+      // Do a (potentially slow) check to confirm that the pooled connection is still good. If it
+      // isn't, take it out of the pool and start again.
+      if (!candidate.isHealthy(doExtensiveHealthChecks)) {
+        noNewStreams();
+        continue;
+      }
+
+      return candidate;
+    }
+  }
+
+  /**
+   * Returns a connection to host a new stream. This prefers the existing connection if it exists,
+   * then the pool, finally building a new connection.
+   */
+  private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,
+      boolean connectionRetryEnabled) throws IOException {
+    boolean foundPooledConnection = false;
+    RealConnection result = null;
+    Route selectedRoute = null;
+    Connection releasedConnection;
+    Socket toClose;
+    synchronized (connectionPool) {
+      if (released) throw new IllegalStateException("released");
+      if (codec != null) throw new IllegalStateException("codec != null");
+      if (canceled) throw new IOException("Canceled");
+
+      // Attempt to use an already-allocated connection. We need to be careful here because our
+      // already-allocated connection may have been restricted from creating new streams.
+      releasedConnection = this.connection;
+      toClose = releaseIfNoNewStreams();
+      if (this.connection != null) {
+        // We had an already-allocated connection and it's good.
+        result = this.connection;
+        releasedConnection = null;
+      }
+      if (!reportedAcquired) {
+        // If the connection was never reported acquired, don't report it as released!
+        releasedConnection = null;
+      }
+
+      if (result == null) {
+        // Attempt to get a connection from the pool.
+        Internal.instance.get(connectionPool, address, this, null);
+        if (connection != null) {
+          foundPooledConnection = true;
+          result = connection;
+        } else {
+          selectedRoute = route;
+        }
+      }
+    }
+    closeQuietly(toClose);
+
+    if (releasedConnection != null) {
+      eventListener.connectionReleased(call, releasedConnection);
+    }
+    if (foundPooledConnection) {
+      eventListener.connectionAcquired(call, result);
+    }
+    if (result != null) {
+      // If we found an already-allocated or pooled connection, we're done.
+      return result;
+    }
+
+    // If we need a route selection, make one. This is a blocking operation.
+    boolean newRouteSelection = false;
+    if (selectedRoute == null && (routeSelection == null || !routeSelection.hasNext())) {
+      newRouteSelection = true;
+      routeSelection = routeSelector.next();
+    }
+
+    synchronized (connectionPool) {
+      if (canceled) throw new IOException("Canceled");
+
+      if (newRouteSelection) {
+        // Now that we have a set of IP addresses, make another attempt at getting a connection from
+        // the pool. This could match due to connection coalescing.
+        List<Route> routes = routeSelection.getAll();
+        for (int i = 0, size = routes.size(); i < size; i++) {
+          Route route = routes.get(i);
+          Internal.instance.get(connectionPool, address, this, route);
+          if (connection != null) {
+            foundPooledConnection = true;
+            result = connection;
+            this.route = route;
+            break;
+          }
+        }
+      }
+
+      if (!foundPooledConnection) {
+        if (selectedRoute == null) {
+          selectedRoute = routeSelection.next();
+        }
+
+        // Create a connection and assign it to this allocation immediately. This makes it possible
+        // for an asynchronous cancel() to interrupt the handshake we're about to do.
+        route = selectedRoute;
+        refusedStreamCount = 0;
+        result = new RealConnection(connectionPool, selectedRoute);
+        acquire(result, false);
+      }
+    }
+
+    // If we found a pooled connection on the 2nd time around, we're done.
+    if (foundPooledConnection) {
+      eventListener.connectionAcquired(call, result);
+      return result;
+    }
+
+    // Do TCP + TLS handshakes. This is a blocking operation.
+    result.connect(
+        connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled, call, eventListener);
+    routeDatabase().connected(result.route());
+
+    Socket socket = null;
+    synchronized (connectionPool) {
+      reportedAcquired = true;
+
+      // Pool the connection.
+      Internal.instance.put(connectionPool, result);
+
+      // If another multiplexed connection to the same address was created concurrently, then
+      // release this connection and acquire that one.
+      if (result.isMultiplexed()) {
+        socket = Internal.instance.deduplicate(connectionPool, address, this);
+        result = connection;
+      }
+    }
+    closeQuietly(socket);
+
+    eventListener.connectionAcquired(call, result);
+    return result;
+  }
+
+  /**
+   * Releases the currently held connection and returns a socket to close if the held connection
+   * restricts new streams from being created. With HTTP/2 multiple requests share the same
+   * connection so it's possible that our connection is restricted from creating new streams during
+   * a follow-up request.
+   */
+  private Socket releaseIfNoNewStreams() {
+    assert (Thread.holdsLock(connectionPool));
+    RealConnection allocatedConnection = this.connection;
+    if (allocatedConnection != null && allocatedConnection.noNewStreams) {
+      return deallocate(false, false, true);
+    }
+    return null;
+  }
+
+  public void streamFinished(boolean noNewStreams, HttpCodec codec, long bytesRead, IOException e) {
+    eventListener.responseBodyEnd(call, bytesRead);
+
+    Socket socket;
+    Connection releasedConnection;
+    boolean callEnd;
+    synchronized (connectionPool) {
+      if (codec == null || codec != this.codec) {
+        throw new IllegalStateException("expected " + this.codec + " but was " + codec);
+      }
+      if (!noNewStreams) {
+        connection.successCount++;
+      }
+      releasedConnection = connection;
+      socket = deallocate(noNewStreams, false, true);
+      if (connection != null) releasedConnection = null;
+      callEnd = this.released;
+    }
+    closeQuietly(socket);
+    if (releasedConnection != null) {
+      eventListener.connectionReleased(call, releasedConnection);
+    }
+
+    if (e != null) {
+      eventListener.callFailed(call, e);
+    } else if (callEnd) {
+      eventListener.callEnd(call);
+    }
+  }
+
+  public HttpCodec codec() {
+    synchronized (connectionPool) {
+      return codec;
+    }
+  }
+
+  private RouteDatabase routeDatabase() {
+    return Internal.instance.routeDatabase(connectionPool);
+  }
+
+  public synchronized RealConnection connection() {
+    return connection;
+  }
+
+  public void release() {
+    Socket socket;
+    Connection releasedConnection;
+    synchronized (connectionPool) {
+      releasedConnection = connection;
+      socket = deallocate(false, true, false);
+      if (connection != null) releasedConnection = null;
+    }
+    closeQuietly(socket);
+    if (releasedConnection != null) {
+      eventListener.connectionReleased(call, releasedConnection);
+    }
+  }
+
+  /** Forbid new streams from being created on the connection that hosts this allocation. */
+  public void noNewStreams() {
+    Socket socket;
+    Connection releasedConnection;
+    synchronized (connectionPool) {
+      releasedConnection = connection;
+      socket = deallocate(true, false, false);
+      if (connection != null) releasedConnection = null;
+    }
+    closeQuietly(socket);
+    if (releasedConnection != null) {
+      eventListener.connectionReleased(call, releasedConnection);
+    }
+  }
+
+  /**
+   * Releases resources held by this allocation. If sufficient resources are allocated, the
+   * connection will be detached or closed. Callers must be synchronized on the connection pool.
+   *
+   * <p>Returns a closeable that the caller should pass to {@link Util#closeQuietly} upon completion
+   * of the synchronized block. (We don't do I/O while synchronized on the connection pool.)
+   */
+  private Socket deallocate(boolean noNewStreams, boolean released, boolean streamFinished) {
+    assert (Thread.holdsLock(connectionPool));
+
+    if (streamFinished) {
+      this.codec = null;
+    }
+    if (released) {
+      this.released = true;
+    }
+    Socket socket = null;
+    if (connection != null) {
+      if (noNewStreams) {
+        connection.noNewStreams = true;
+      }
+      if (this.codec == null && (this.released || connection.noNewStreams)) {
+        release(connection);
+        if (connection.allocations.isEmpty()) {
+          connection.idleAtNanos = System.nanoTime();
+          if (Internal.instance.connectionBecameIdle(connectionPool, connection)) {
+            socket = connection.socket();
+          }
+        }
+        connection = null;
+      }
+    }
+    return socket;
+  }
+
+  public void cancel() {
+    HttpCodec codecToCancel;
+    RealConnection connectionToCancel;
+    synchronized (connectionPool) {
+      canceled = true;
+      codecToCancel = codec;
+      connectionToCancel = connection;
+    }
+    if (codecToCancel != null) {
+      codecToCancel.cancel();
+    } else if (connectionToCancel != null) {
+      connectionToCancel.cancel();
+    }
+  }
+
+  public void streamFailed(IOException e) {
+    Socket socket;
+    Connection releasedConnection;
+    boolean noNewStreams = false;
+
+    synchronized (connectionPool) {
+      if (e instanceof StreamResetException) {
+        StreamResetException streamResetException = (StreamResetException) e;
+        if (streamResetException.errorCode == ErrorCode.REFUSED_STREAM) {
+          refusedStreamCount++;
+        }
+        // On HTTP/2 stream errors, retry REFUSED_STREAM errors once on the same connection. All
+        // other errors must be retried on a new connection.
+        if (streamResetException.errorCode != ErrorCode.REFUSED_STREAM || refusedStreamCount > 1) {
+          noNewStreams = true;
+          route = null;
+        }
+      } else if (connection != null
+          && (!connection.isMultiplexed() || e instanceof ConnectionShutdownException)) {
+        noNewStreams = true;
+
+        // If this route hasn't completed a call, avoid it for new connections.
+        if (connection.successCount == 0) {
+          if (route != null && e != null) {
+            routeSelector.connectFailed(route, e);
+          }
+          route = null;
+        }
+      }
+      releasedConnection = connection;
+      socket = deallocate(noNewStreams, false, true);
+      if (connection != null || !reportedAcquired) releasedConnection = null;
+    }
+
+    closeQuietly(socket);
+    if (releasedConnection != null) {
+      eventListener.connectionReleased(call, releasedConnection);
+    }
+  }
+
+  /**
+   * Use this allocation to hold {@code connection}. Each call to this must be paired with a call to
+   * {@link #release} on the same connection.
+   */
+  public void acquire(RealConnection connection, boolean reportedAcquired) {
+    assert (Thread.holdsLock(connectionPool));
+    if (this.connection != null) throw new IllegalStateException();
+
+    this.connection = connection;
+    this.reportedAcquired = reportedAcquired;
+    connection.allocations.add(new StreamAllocationReference(this, callStackTrace));
+  }
+
+  /** Remove this allocation from the connection's list of allocations. */
+  private void release(RealConnection connection) {
+    for (int i = 0, size = connection.allocations.size(); i < size; i++) {
+      Reference<StreamAllocation> reference = connection.allocations.get(i);
+      if (reference.get() == this) {
+        connection.allocations.remove(i);
+        return;
+      }
+    }
+    throw new IllegalStateException();
+  }
+
+  /**
+   * Release the connection held by this connection and acquire {@code newConnection} instead. It is
+   * only safe to call this if the held connection is newly connected but duplicated by {@code
+   * newConnection}. Typically this occurs when concurrently connecting to an HTTP/2 webserver.
+   *
+   * <p>Returns a closeable that the caller should pass to {@link Util#closeQuietly} upon completion
+   * of the synchronized block. (We don't do I/O while synchronized on the connection pool.)
+   */
+  public Socket releaseAndAcquire(RealConnection newConnection) {
+    assert (Thread.holdsLock(connectionPool));
+    if (codec != null || connection.allocations.size() != 1) throw new IllegalStateException();
+
+    // Release the old connection.
+    Reference<StreamAllocation> onlyAllocation = connection.allocations.get(0);
+    Socket socket = deallocate(true, false, false);
+
+    // Acquire the new connection.
+    this.connection = newConnection;
+    newConnection.allocations.add(onlyAllocation);
+
+    return socket;
+  }
+
+  public boolean hasMoreRoutes() {
+    return route != null
+        || (routeSelection != null && routeSelection.hasNext())
+        || routeSelector.hasNext();
+  }
+
+  @Override public String toString() {
+    RealConnection connection = connection();
+    return connection != null ? connection.toString() : address.toString();
+  }
+
+  public static final class StreamAllocationReference extends WeakReference<StreamAllocation> {
+    /**
+     * Captures the stack trace at the time the Call is executed or enqueued. This is helpful for
+     * identifying the origin of connection leaks.
+     */
+    public final Object callStackTrace;
+
+    StreamAllocationReference(StreamAllocation referent, Object callStackTrace) {
+      super(referent);
+      this.callStackTrace = callStackTrace;
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
new file mode 100644
index 0000000000..c10dc34cdc
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
@@ -0,0 +1,128 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3.internal.http;
+
+import java.io.IOException;
+import java.util.List;
+import okhttp3.Cookie;
+import okhttp3.CookieJar;
+import okhttp3.Headers;
+import okhttp3.Interceptor;
+import okhttp3.MediaType;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.internal.Version;
+import okio.GzipSource;
+import okio.Okio;
+
+import static okhttp3.internal.Util.hostHeader;
+
+/**
+ * Bridges from application code to network code. First it builds a network request from a user
+ * request. Then it proceeds to call the network. Finally it builds a user response from the network
+ * response.
+ */
+public final class BridgeInterceptor implements Interceptor {
+  private final CookieJar cookieJar;
+
+  public BridgeInterceptor(CookieJar cookieJar) {
+    this.cookieJar = cookieJar;
+  }
+
+  @Override public Response intercept(Chain chain) throws IOException {
+    Request userRequest = chain.request();
+    Request.Builder requestBuilder = userRequest.newBuilder();
+
+    RequestBody body = userRequest.body();
+    if (body != null) {
+      MediaType contentType = body.contentType();
+      if (contentType != null) {
+        requestBuilder.header("Content-Type", contentType.toString());
+      }
+
+      long contentLength = body.contentLength();
+      if (contentLength != -1) {
+        requestBuilder.header("Content-Length", Long.toString(contentLength));
+        requestBuilder.removeHeader("Transfer-Encoding");
+      } else {
+        requestBuilder.header("Transfer-Encoding", "chunked");
+        requestBuilder.removeHeader("Content-Length");
+      }
+    }
+
+    if (userRequest.header("Host") == null) {
+      requestBuilder.header("Host", hostHeader(userRequest.url(), false));
+    }
+
+    if (userRequest.header("Connection") == null) {
+      requestBuilder.header("Connection", "Keep-Alive");
+    }
+
+    // If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing
+    // the transfer stream.
+    boolean transparentGzip = false;
+    if (userRequest.header("Accept-Encoding") == null && userRequest.header("Range") == null) {
+      transparentGzip = true;
+      requestBuilder.header("Accept-Encoding", "gzip");
+    }
+
+    List<Cookie> cookies = cookieJar.loadForRequest(userRequest.url());
+    if (!cookies.isEmpty()) {
+      requestBuilder.header("Cookie", cookieHeader(cookies));
+    }
+
+    if (userRequest.header("User-Agent") == null) {
+      requestBuilder.header("User-Agent", Version.userAgent());
+    }
+
+    Response networkResponse = chain.proceed(requestBuilder.build());
+
+    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());
+
+    Response.Builder responseBuilder = networkResponse.newBuilder()
+        .request(userRequest);
+
+    if (transparentGzip
+        && "gzip".equalsIgnoreCase(networkResponse.header("Content-Encoding"))
+        && HttpHeaders.hasBody(networkResponse)) {
+      GzipSource responseBody = new GzipSource(networkResponse.body().source());
+      Headers strippedHeaders = networkResponse.headers().newBuilder()
+          .removeAll("Content-Encoding")
+          .removeAll("Content-Length")
+          .build();
+      responseBuilder.headers(strippedHeaders);
+      String contentType = networkResponse.header("Content-Type");
+      responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody)));
+    }
+
+    return responseBuilder.build();
+  }
+
+  /** Returns a 'Cookie' HTTP request header with all cookies, like {@code a=b; c=d}. */
+  private String cookieHeader(List<Cookie> cookies) {
+    StringBuilder cookieHeader = new StringBuilder();
+    for (int i = 0, size = cookies.size(); i < size; i++) {
+      if (i > 0) {
+        cookieHeader.append("; ");
+      }
+      Cookie cookie = cookies.get(i);
+      cookieHeader.append(cookie.name()).append('=').append(cookie.value());
+    }
+    return cookieHeader.toString();
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
new file mode 100644
index 0000000000..b7aba87d6a
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http;
+
+import java.io.IOException;
+import java.net.ProtocolException;
+import okhttp3.Interceptor;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.Util;
+import okhttp3.internal.connection.RealConnection;
+import okhttp3.internal.connection.StreamAllocation;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.ForwardingSink;
+import okio.Okio;
+import okio.Sink;
+
+/** This is the last interceptor in the chain. It makes a network call to the server. */
+public final class CallServerInterceptor implements Interceptor {
+  private final boolean forWebSocket;
+
+  public CallServerInterceptor(boolean forWebSocket) {
+    this.forWebSocket = forWebSocket;
+  }
+
+  @Override public Response intercept(Chain chain) throws IOException {
+    RealInterceptorChain realChain = (RealInterceptorChain) chain;
+    HttpCodec httpCodec = realChain.httpStream();
+    StreamAllocation streamAllocation = realChain.streamAllocation();
+    RealConnection connection = (RealConnection) realChain.connection();
+    Request request = realChain.request();
+
+    long sentRequestMillis = System.currentTimeMillis();
+
+    realChain.eventListener().requestHeadersStart(realChain.call());
+    httpCodec.writeRequestHeaders(request);
+    realChain.eventListener().requestHeadersEnd(realChain.call(), request);
+
+    Response.Builder responseBuilder = null;
+    if (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {
+      // If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100
+      // Continue" response before transmitting the request body. If we don't get that, return
+      // what we did get (such as a 4xx response) without ever transmitting the request body.
+      if ("100-continue".equalsIgnoreCase(request.header("Expect"))) {
+        httpCodec.flushRequest();
+        realChain.eventListener().responseHeadersStart(realChain.call());
+        responseBuilder = httpCodec.readResponseHeaders(true);
+      }
+
+      if (responseBuilder == null) {
+        // Write the request body if the "Expect: 100-continue" expectation was met.
+        realChain.eventListener().requestBodyStart(realChain.call());
+        long contentLength = request.body().contentLength();
+        CountingSink requestBodyOut =
+            new CountingSink(httpCodec.createRequestBody(request, contentLength));
+        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
+
+        request.body().writeTo(bufferedRequestBody);
+        bufferedRequestBody.close();
+        realChain.eventListener()
+            .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);
+      } else if (!connection.isMultiplexed()) {
+        // If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection
+        // from being reused. Otherwise we're still obligated to transmit the request body to
+        // leave the connection in a consistent state.
+        streamAllocation.noNewStreams();
+      }
+    }
+
+    httpCodec.finishRequest();
+
+    if (responseBuilder == null) {
+      realChain.eventListener().responseHeadersStart(realChain.call());
+      responseBuilder = httpCodec.readResponseHeaders(false);
+    }
+
+    Response response = responseBuilder
+        .request(request)
+        .handshake(streamAllocation.connection().handshake())
+        .sentRequestAtMillis(sentRequestMillis)
+        .receivedResponseAtMillis(System.currentTimeMillis())
+        .build();
+
+    realChain.eventListener()
+        .responseHeadersEnd(realChain.call(), response);
+
+    int code = response.code();
+    if (forWebSocket && code == 101) {
+      // Connection is upgrading, but we need to ensure interceptors see a non-null response body.
+      response = response.newBuilder()
+          .body(Util.EMPTY_RESPONSE)
+          .build();
+    } else {
+      response = response.newBuilder()
+          .body(httpCodec.openResponseBody(response))
+          .build();
+    }
+
+    if ("close".equalsIgnoreCase(response.request().header("Connection"))
+        || "close".equalsIgnoreCase(response.header("Connection"))) {
+      streamAllocation.noNewStreams();
+    }
+
+    if ((code == 204 || code == 205) && response.body().contentLength() > 0) {
+      throw new ProtocolException(
+          "HTTP " + code + " had non-zero Content-Length: " + response.body().contentLength());
+    }
+
+    return response;
+  }
+
+  static final class CountingSink extends ForwardingSink {
+    long successfulCount;
+
+    CountingSink(Sink delegate) {
+      super(delegate);
+    }
+
+    @Override public void write(Buffer source, long byteCount) throws IOException {
+      super.write(source, byteCount);
+      successfulCount += byteCount;
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java b/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java
new file mode 100644
index 0000000000..ad9759acce
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http;
+
+import java.io.IOException;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okio.Sink;
+
+/** Encodes HTTP requests and decodes HTTP responses. */
+public interface HttpCodec {
+  /**
+   * The timeout to use while discarding a stream of input data. Since this is used for connection
+   * reuse, this timeout should be significantly less than the time it takes to establish a new
+   * connection.
+   */
+  int DISCARD_STREAM_TIMEOUT_MILLIS = 100;
+
+  /** Returns an output stream where the request body can be streamed. */
+  Sink createRequestBody(Request request, long contentLength);
+
+  /** This should update the HTTP engine's sentRequestMillis field. */
+  void writeRequestHeaders(Request request) throws IOException;
+
+  /** Flush the request to the underlying socket. */
+  void flushRequest() throws IOException;
+
+  /** Flush the request to the underlying socket and signal no more bytes will be transmitted. */
+  void finishRequest() throws IOException;
+
+  /**
+   * Parses bytes of a response header from an HTTP transport.
+   *
+   * @param expectContinue true to return null if this is an intermediate response with a "100"
+   *     response code. Otherwise this method never returns null.
+   */
+  Response.Builder readResponseHeaders(boolean expectContinue) throws IOException;
+
+  /** Returns a stream that reads the response body. */
+  ResponseBody openResponseBody(Response response) throws IOException;
+
+  /**
+   * Cancel this stream. Resources held by this stream will be cleaned up, though not synchronously.
+   * That may happen later by the connection pool thread.
+   */
+  void cancel();
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpDate.java b/okhttp/src/main/java/okhttp3/internal/http/HttpDate.java
new file mode 100644
index 0000000000..6df2cfd2ec
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpDate.java
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http;
+
+import java.text.DateFormat;
+import java.text.ParsePosition;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Locale;
+
+import static okhttp3.internal.Util.UTC;
+
+/**
+ * Best-effort parser for HTTP dates.
+ */
+public final class HttpDate {
+  /** The last four-digit year: "Fri, 31 Dec 9999 23:59:59 GMT". */
+  public static final long MAX_DATE = 253402300799999L;
+
+  /**
+   * Most websites serve cookies in the blessed format. Eagerly create the parser to ensure such
+   * cookies are on the fast path.
+   */
+  private static final ThreadLocal<DateFormat> STANDARD_DATE_FORMAT =
+      new ThreadLocal<DateFormat>() {
+        @Override protected DateFormat initialValue() {
+          // Date format specified by RFC 7231 section 7.1.1.1.
+          DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss 'GMT'", Locale.US);
+          rfc1123.setLenient(false);
+          rfc1123.setTimeZone(UTC);
+          return rfc1123;
+        }
+      };
+
+  /** If we fail to parse a date in a non-standard format, try each of these formats in sequence. */
+  private static final String[] BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS = new String[] {
+      // HTTP formats required by RFC2616 but with any timezone.
+      "EEE, dd MMM yyyy HH:mm:ss zzz", // RFC 822, updated by RFC 1123 with any TZ
+      "EEEE, dd-MMM-yy HH:mm:ss zzz", // RFC 850, obsoleted by RFC 1036 with any TZ.
+      "EEE MMM d HH:mm:ss yyyy", // ANSI C's asctime() format
+      // Alternative formats.
+      "EEE, dd-MMM-yyyy HH:mm:ss z",
+      "EEE, dd-MMM-yyyy HH-mm-ss z",
+      "EEE, dd MMM yy HH:mm:ss z",
+      "EEE dd-MMM-yyyy HH:mm:ss z",
+      "EEE dd MMM yyyy HH:mm:ss z",
+      "EEE dd-MMM-yyyy HH-mm-ss z",
+      "EEE dd-MMM-yy HH:mm:ss z",
+      "EEE dd MMM yy HH:mm:ss z",
+      "EEE,dd-MMM-yy HH:mm:ss z",
+      "EEE,dd-MMM-yyyy HH:mm:ss z",
+      "EEE, dd-MM-yyyy HH:mm:ss z",
+
+      /* RI bug 6641315 claims a cookie of this format was once served by www.yahoo.com */
+      "EEE MMM d yyyy HH:mm:ss z",
+  };
+
+  private static final DateFormat[] BROWSER_COMPATIBLE_DATE_FORMATS =
+      new DateFormat[BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS.length];
+
+  /** Returns the date for {@code value}. Returns null if the value couldn't be parsed. */
+  public static Date parse(String value) {
+    if (value.length() == 0) {
+      return null;
+    }
+
+    ParsePosition position = new ParsePosition(0);
+    Date result = STANDARD_DATE_FORMAT.get().parse(value, position);
+    if (position.getIndex() == value.length()) {
+      // STANDARD_DATE_FORMAT must match exactly; all text must be consumed, e.g. no ignored
+      // non-standard trailing "+01:00". Those cases are covered below.
+      return result;
+    }
+    synchronized (BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS) {
+      for (int i = 0, count = BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS.length; i < count; i++) {
+        DateFormat format = BROWSER_COMPATIBLE_DATE_FORMATS[i];
+        if (format == null) {
+          format = new SimpleDateFormat(BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS[i], Locale.US);
+          // Set the timezone to use when interpreting formats that don't have a timezone. GMT is
+          // specified by RFC 7231.
+          format.setTimeZone(UTC);
+          BROWSER_COMPATIBLE_DATE_FORMATS[i] = format;
+        }
+        position.setIndex(0);
+        result = format.parse(value, position);
+        if (position.getIndex() != 0) {
+          // Something was parsed. It's possible the entire string was not consumed but we ignore
+          // that. If any of the BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS ended in "'GMT'" we'd have
+          // to also check that position.getIndex() == value.length() otherwise parsing might have
+          // terminated early, ignoring things like "+01:00". Leaving this as != 0 means that any
+          // trailing junk is ignored.
+          return result;
+        }
+      }
+    }
+    return null;
+  }
+
+  /** Returns the string for {@code value}. */
+  public static String format(Date value) {
+    return STANDARD_DATE_FORMAT.get().format(value);
+  }
+
+  private HttpDate() {
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java b/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java
new file mode 100644
index 0000000000..a1d6712906
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java
@@ -0,0 +1,276 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+import java.util.TreeSet;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import okhttp3.Challenge;
+import okhttp3.Cookie;
+import okhttp3.CookieJar;
+import okhttp3.Headers;
+import okhttp3.HttpUrl;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.Util;
+
+import static java.net.HttpURLConnection.HTTP_NOT_MODIFIED;
+import static java.net.HttpURLConnection.HTTP_NO_CONTENT;
+import static okhttp3.internal.Util.equal;
+import static okhttp3.internal.http.StatusLine.HTTP_CONTINUE;
+
+/** Headers and utilities for internal use by OkHttp. */
+public final class HttpHeaders {
+  private static final String TOKEN = "([^ \"=]*)";
+  private static final String QUOTED_STRING = "\"([^\"]*)\"";
+  private static final Pattern PARAMETER
+      = Pattern.compile(" +" + TOKEN + "=(:?" + QUOTED_STRING + "|" + TOKEN + ") *(:?,|$)");
+
+  private HttpHeaders() {
+  }
+
+  public static long contentLength(Response response) {
+    return contentLength(response.headers());
+  }
+
+  public static long contentLength(Headers headers) {
+    return stringToLong(headers.get("Content-Length"));
+  }
+
+  private static long stringToLong(String s) {
+    if (s == null) return -1;
+    try {
+      return Long.parseLong(s);
+    } catch (NumberFormatException e) {
+      return -1;
+    }
+  }
+
+  /**
+   * Returns true if none of the Vary headers have changed between {@code cachedRequest} and {@code
+   * newRequest}.
+   */
+  public static boolean varyMatches(
+      Response cachedResponse, Headers cachedRequest, Request newRequest) {
+    for (String field : varyFields(cachedResponse)) {
+      if (!equal(cachedRequest.values(field), newRequest.headers(field))) return false;
+    }
+    return true;
+  }
+
+  /**
+   * Returns true if a Vary header contains an asterisk. Such responses cannot be cached.
+   */
+  public static boolean hasVaryAll(Response response) {
+    return hasVaryAll(response.headers());
+  }
+
+  /**
+   * Returns true if a Vary header contains an asterisk. Such responses cannot be cached.
+   */
+  public static boolean hasVaryAll(Headers responseHeaders) {
+    return varyFields(responseHeaders).contains("*");
+  }
+
+  private static Set<String> varyFields(Response response) {
+    return varyFields(response.headers());
+  }
+
+  /**
+   * Returns the names of the request headers that need to be checked for equality when caching.
+   */
+  public static Set<String> varyFields(Headers responseHeaders) {
+    Set<String> result = Collections.emptySet();
+    for (int i = 0, size = responseHeaders.size(); i < size; i++) {
+      if (!"Vary".equalsIgnoreCase(responseHeaders.name(i))) continue;
+
+      String value = responseHeaders.value(i);
+      if (result.isEmpty()) {
+        result = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
+      }
+      for (String varyField : value.split(",")) {
+        result.add(varyField.trim());
+      }
+    }
+    return result;
+  }
+
+  /**
+   * Returns the subset of the headers in {@code response}'s request that impact the content of
+   * response's body.
+   */
+  public static Headers varyHeaders(Response response) {
+    // Use the request headers sent over the network, since that's what the
+    // response varies on. Otherwise OkHttp-supplied headers like
+    // "Accept-Encoding: gzip" may be lost.
+    Headers requestHeaders = response.networkResponse().request().headers();
+    Headers responseHeaders = response.headers();
+    return varyHeaders(requestHeaders, responseHeaders);
+  }
+
+  /**
+   * Returns the subset of the headers in {@code requestHeaders} that impact the content of
+   * response's body.
+   */
+  public static Headers varyHeaders(Headers requestHeaders, Headers responseHeaders) {
+    Set<String> varyFields = varyFields(responseHeaders);
+    if (varyFields.isEmpty()) return new Headers.Builder().build();
+
+    Headers.Builder result = new Headers.Builder();
+    for (int i = 0, size = requestHeaders.size(); i < size; i++) {
+      String fieldName = requestHeaders.name(i);
+      if (varyFields.contains(fieldName)) {
+        result.add(fieldName, requestHeaders.value(i));
+      }
+    }
+    return result.build();
+  }
+
+  /**
+   * Parse RFC 7617 challenges, also wrong ordered ones.
+   * This API is only interested in the scheme name and realm.
+   */
+  public static List<Challenge> parseChallenges(Headers responseHeaders, String challengeHeader) {
+    // auth-scheme = token
+    // auth-param  = token "=" ( token | quoted-string )
+    // challenge   = auth-scheme 1*SP 1#auth-param
+    // realm       = "realm" "=" realm-value
+    // realm-value = quoted-string
+    List<Challenge> challenges = new ArrayList<>();
+    List<String> authenticationHeaders = responseHeaders.values(challengeHeader);
+    for (String header : authenticationHeaders) {
+      int index = header.indexOf(' ');
+      if (index == -1) continue;
+
+      String scheme = header.substring(0, index);
+      String realm = null;
+      String charset = null;
+
+      Matcher matcher = PARAMETER.matcher(header);
+      for (int i = index; matcher.find(i); i = matcher.end()) {
+        if (header.regionMatches(true, matcher.start(1), "realm", 0, 5)) {
+          realm = matcher.group(3);
+        } else if (header.regionMatches(true, matcher.start(1), "charset", 0, 7)) {
+          charset = matcher.group(3);
+        }
+
+        if (realm != null && charset != null) {
+          break;
+        }
+      }
+
+      // "realm" is required.
+      if (realm == null) continue;
+
+      Challenge challenge = new Challenge(scheme, realm);
+
+      // If a charset is provided, RFC 7617 says it must be "UTF-8".
+      if (charset != null) {
+        if (charset.equalsIgnoreCase("UTF-8")) {
+          challenge = challenge.withCharset(Util.UTF_8);
+        } else {
+          continue;
+        }
+      }
+
+      challenges.add(challenge);
+    }
+    return challenges;
+  }
+
+  public static void receiveHeaders(CookieJar cookieJar, HttpUrl url, Headers headers) {
+    if (cookieJar == CookieJar.NO_COOKIES) return;
+
+    List<Cookie> cookies = Cookie.parseAll(url, headers);
+    if (cookies.isEmpty()) return;
+
+    cookieJar.saveFromResponse(url, cookies);
+  }
+
+  /** Returns true if the response must have a (possibly 0-length) body. See RFC 7231. */
+  public static boolean hasBody(Response response) {
+    // HEAD requests never yield a body regardless of the response headers.
+    if (response.request().method().equals("HEAD")) {
+      return false;
+    }
+
+    int responseCode = response.code();
+    if ((responseCode < HTTP_CONTINUE || responseCode >= 200)
+        && responseCode != HTTP_NO_CONTENT
+        && responseCode != HTTP_NOT_MODIFIED) {
+      return true;
+    }
+
+    // If the Content-Length or Transfer-Encoding headers disagree with the response code, the
+    // response is malformed. For best compatibility, we honor the headers.
+    if (contentLength(response) != -1
+        || "chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {
+      return true;
+    }
+
+    return false;
+  }
+
+  /**
+   * Returns the next index in {@code input} at or after {@code pos} that contains a character from
+   * {@code characters}. Returns the input length if none of the requested characters can be found.
+   */
+  public static int skipUntil(String input, int pos, String characters) {
+    for (; pos < input.length(); pos++) {
+      if (characters.indexOf(input.charAt(pos)) != -1) {
+        break;
+      }
+    }
+    return pos;
+  }
+
+  /**
+   * Returns the next non-whitespace character in {@code input} that is white space. Result is
+   * undefined if input contains newline characters.
+   */
+  public static int skipWhitespace(String input, int pos) {
+    for (; pos < input.length(); pos++) {
+      char c = input.charAt(pos);
+      if (c != ' ' && c != '\t') {
+        break;
+      }
+    }
+    return pos;
+  }
+
+  /**
+   * Returns {@code value} as a positive integer, or 0 if it is negative, or {@code defaultValue} if
+   * it cannot be parsed.
+   */
+  public static int parseSeconds(String value, int defaultValue) {
+    try {
+      long seconds = Long.parseLong(value);
+      if (seconds > Integer.MAX_VALUE) {
+        return Integer.MAX_VALUE;
+      } else if (seconds < 0) {
+        return 0;
+      } else {
+        return (int) seconds;
+      }
+    } catch (NumberFormatException e) {
+      return defaultValue;
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.java b/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.java
new file mode 100644
index 0000000000..e10fa88a77
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http;
+
+public final class HttpMethod {
+  public static boolean invalidatesCache(String method) {
+    return method.equals("POST")
+        || method.equals("PATCH")
+        || method.equals("PUT")
+        || method.equals("DELETE")
+        || method.equals("MOVE");     // WebDAV
+  }
+
+  public static boolean requiresRequestBody(String method) {
+    return method.equals("POST")
+        || method.equals("PUT")
+        || method.equals("PATCH")
+        || method.equals("PROPPATCH") // WebDAV
+        || method.equals("REPORT");   // CalDAV/CardDAV (defined in WebDAV Versioning)
+  }
+
+  public static boolean permitsRequestBody(String method) {
+    return requiresRequestBody(method)
+        || method.equals("OPTIONS")
+        || method.equals("DELETE")    // Permitted as spec is ambiguous.
+        || method.equals("PROPFIND")  // (WebDAV) without body: request <allprop/>
+        || method.equals("MKCOL")     // (WebDAV) may contain a body, but behaviour is unspecified
+        || method.equals("LOCK");     // (WebDAV) body: create lock, without body: refresh lock
+  }
+
+  public static boolean redirectsWithBody(String method) {
+    return method.equals("PROPFIND"); // (WebDAV) redirects should also maintain the request body
+  }
+
+  public static boolean redirectsToGet(String method) {
+    // All requests but PROPFIND should redirect to a GET request.
+    return !method.equals("PROPFIND");
+  }
+
+  private HttpMethod() {
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
new file mode 100644
index 0000000000..52f9880892
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
@@ -0,0 +1,167 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http;
+
+import java.io.IOException;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import okhttp3.Call;
+import okhttp3.Connection;
+import okhttp3.EventListener;
+import okhttp3.Interceptor;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.connection.RealConnection;
+import okhttp3.internal.connection.StreamAllocation;
+
+import static okhttp3.internal.Util.checkDuration;
+
+/**
+ * A concrete interceptor chain that carries the entire interceptor chain: all application
+ * interceptors, the OkHttp core, all network interceptors, and finally the network caller.
+ */
+public final class RealInterceptorChain implements Interceptor.Chain {
+  private final List<Interceptor> interceptors;
+  private final StreamAllocation streamAllocation;
+  private final HttpCodec httpCodec;
+  private final RealConnection connection;
+  private final int index;
+  private final Request request;
+  private final Call call;
+  private final EventListener eventListener;
+  private final int connectTimeout;
+  private final int readTimeout;
+  private final int writeTimeout;
+  private int calls;
+
+  public RealInterceptorChain(List<Interceptor> interceptors, StreamAllocation streamAllocation,
+      HttpCodec httpCodec, RealConnection connection, int index, Request request, Call call,
+      EventListener eventListener, int connectTimeout, int readTimeout, int writeTimeout) {
+    this.interceptors = interceptors;
+    this.connection = connection;
+    this.streamAllocation = streamAllocation;
+    this.httpCodec = httpCodec;
+    this.index = index;
+    this.request = request;
+    this.call = call;
+    this.eventListener = eventListener;
+    this.connectTimeout = connectTimeout;
+    this.readTimeout = readTimeout;
+    this.writeTimeout = writeTimeout;
+  }
+
+  @Override public Connection connection() {
+    return connection;
+  }
+
+  @Override public int connectTimeoutMillis() {
+    return connectTimeout;
+  }
+
+  @Override public Interceptor.Chain withConnectTimeout(int timeout, TimeUnit unit) {
+    int millis = checkDuration("timeout", timeout, unit);
+    return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,
+        request, call, eventListener, millis, readTimeout, writeTimeout);
+  }
+
+  @Override public int readTimeoutMillis() {
+    return readTimeout;
+  }
+
+  @Override public Interceptor.Chain withReadTimeout(int timeout, TimeUnit unit) {
+    int millis = checkDuration("timeout", timeout, unit);
+    return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,
+        request, call, eventListener, connectTimeout, millis, writeTimeout);
+  }
+
+  @Override public int writeTimeoutMillis() {
+    return writeTimeout;
+  }
+
+  @Override public Interceptor.Chain withWriteTimeout(int timeout, TimeUnit unit) {
+    int millis = checkDuration("timeout", timeout, unit);
+    return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,
+        request, call, eventListener, connectTimeout, readTimeout, millis);
+  }
+
+  public StreamAllocation streamAllocation() {
+    return streamAllocation;
+  }
+
+  public HttpCodec httpStream() {
+    return httpCodec;
+  }
+
+  @Override public Call call() {
+    return call;
+  }
+
+  public EventListener eventListener() {
+    return eventListener;
+  }
+
+  @Override public Request request() {
+    return request;
+  }
+
+  @Override public Response proceed(Request request) throws IOException {
+    return proceed(request, streamAllocation, httpCodec, connection);
+  }
+
+  public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,
+      RealConnection connection) throws IOException {
+    if (index >= interceptors.size()) throw new AssertionError();
+
+    calls++;
+
+    // If we already have a stream, confirm that the incoming request will use it.
+    if (this.httpCodec != null && !this.connection.supportsUrl(request.url())) {
+      throw new IllegalStateException("network interceptor " + interceptors.get(index - 1)
+          + " must retain the same host and port");
+    }
+
+    // If we already have a stream, confirm that this is the only call to chain.proceed().
+    if (this.httpCodec != null && calls > 1) {
+      throw new IllegalStateException("network interceptor " + interceptors.get(index - 1)
+          + " must call proceed() exactly once");
+    }
+
+    // Call the next interceptor in the chain.
+    RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,
+        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,
+        writeTimeout);
+    Interceptor interceptor = interceptors.get(index);
+    Response response = interceptor.intercept(next);
+
+    // Confirm that the next interceptor made its required call to chain.proceed().
+    if (httpCodec != null && index + 1 < interceptors.size() && next.calls != 1) {
+      throw new IllegalStateException("network interceptor " + interceptor
+          + " must call proceed() exactly once");
+    }
+
+    // Confirm that the intercepted response isn't null.
+    if (response == null) {
+      throw new NullPointerException("interceptor " + interceptor + " returned null");
+    }
+
+    if (response.body() == null) {
+      throw new IllegalStateException(
+          "interceptor " + interceptor + " returned a response with no body");
+    }
+
+    return response;
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RealResponseBody.java b/okhttp/src/main/java/okhttp3/internal/http/RealResponseBody.java
new file mode 100644
index 0000000000..970d7ca949
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/RealResponseBody.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http;
+
+import javax.annotation.Nullable;
+import okhttp3.MediaType;
+import okhttp3.ResponseBody;
+import okio.BufferedSource;
+
+public final class RealResponseBody extends ResponseBody {
+  /**
+   * Use a string to avoid parsing the content type until needed. This also defers problems caused
+   * by malformed content types.
+   */
+  private final @Nullable String contentTypeString;
+  private final long contentLength;
+  private final BufferedSource source;
+
+  public RealResponseBody(
+      @Nullable String contentTypeString, long contentLength, BufferedSource source) {
+    this.contentTypeString = contentTypeString;
+    this.contentLength = contentLength;
+    this.source = source;
+  }
+
+  @Override public MediaType contentType() {
+    return contentTypeString != null ? MediaType.parse(contentTypeString) : null;
+  }
+
+  @Override public long contentLength() {
+    return contentLength;
+  }
+
+  @Override public BufferedSource source() {
+    return source;
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RequestLine.java b/okhttp/src/main/java/okhttp3/internal/http/RequestLine.java
new file mode 100644
index 0000000000..3e09098097
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/RequestLine.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http;
+
+import java.net.HttpURLConnection;
+import java.net.Proxy;
+import okhttp3.HttpUrl;
+import okhttp3.Request;
+
+public final class RequestLine {
+  private RequestLine() {
+  }
+
+  /**
+   * Returns the request status line, like "GET / HTTP/1.1". This is exposed to the application by
+   * {@link HttpURLConnection#getHeaderFields}, so it needs to be set even if the transport is
+   * HTTP/2.
+   */
+  public static String get(Request request, Proxy.Type proxyType) {
+    StringBuilder result = new StringBuilder();
+    result.append(request.method());
+    result.append(' ');
+
+    if (includeAuthorityInRequestLine(request, proxyType)) {
+      result.append(request.url());
+    } else {
+      result.append(requestPath(request.url()));
+    }
+
+    result.append(" HTTP/1.1");
+    return result.toString();
+  }
+
+  /**
+   * Returns true if the request line should contain the full URL with host and port (like "GET
+   * http://android.com/foo HTTP/1.1") or only the path (like "GET /foo HTTP/1.1").
+   */
+  private static boolean includeAuthorityInRequestLine(Request request, Proxy.Type proxyType) {
+    return !request.isHttps() && proxyType == Proxy.Type.HTTP;
+  }
+
+  /**
+   * Returns the path to request, like the '/' in 'GET / HTTP/1.1'. Never empty, even if the request
+   * URL is. Includes the query component if it exists.
+   */
+  public static String requestPath(HttpUrl url) {
+    String path = url.encodedPath();
+    String query = url.encodedQuery();
+    return query != null ? (path + '?' + query) : path;
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
new file mode 100644
index 0000000000..937ba28ea7
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
@@ -0,0 +1,379 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.net.HttpRetryException;
+import java.net.ProtocolException;
+import java.net.Proxy;
+import java.net.SocketTimeoutException;
+import java.security.cert.CertificateException;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSocketFactory;
+import okhttp3.Address;
+import okhttp3.Call;
+import okhttp3.CertificatePinner;
+import okhttp3.Connection;
+import okhttp3.EventListener;
+import okhttp3.HttpUrl;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.Route;
+import okhttp3.internal.connection.RouteException;
+import okhttp3.internal.connection.StreamAllocation;
+import okhttp3.internal.http2.ConnectionShutdownException;
+
+import static java.net.HttpURLConnection.HTTP_CLIENT_TIMEOUT;
+import static java.net.HttpURLConnection.HTTP_MOVED_PERM;
+import static java.net.HttpURLConnection.HTTP_MOVED_TEMP;
+import static java.net.HttpURLConnection.HTTP_MULT_CHOICE;
+import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
+import static java.net.HttpURLConnection.HTTP_SEE_OTHER;
+import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
+import static okhttp3.internal.Util.closeQuietly;
+import static okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT;
+import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
+
+/**
+ * This interceptor recovers from failures and follows redirects as necessary. It may throw an
+ * {@link IOException} if the call was canceled.
+ */
+public final class RetryAndFollowUpInterceptor implements Interceptor {
+  /**
+   * How many redirects and auth challenges should we attempt? Chrome follows 21 redirects; Firefox,
+   * curl, and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5.
+   */
+  private static final int MAX_FOLLOW_UPS = 20;
+
+  private final OkHttpClient client;
+  private final boolean forWebSocket;
+  private StreamAllocation streamAllocation;
+  private Object callStackTrace;
+  private volatile boolean canceled;
+
+  public RetryAndFollowUpInterceptor(OkHttpClient client, boolean forWebSocket) {
+    this.client = client;
+    this.forWebSocket = forWebSocket;
+  }
+
+  /**
+   * Immediately closes the socket connection if it's currently held. Use this to interrupt an
+   * in-flight request from any thread. It's the caller's responsibility to close the request body
+   * and response body streams; otherwise resources may be leaked.
+   *
+   * <p>This method is safe to be called concurrently, but provides limited guarantees. If a
+   * transport layer connection has been established (such as a HTTP/2 stream) that is terminated.
+   * Otherwise if a socket connection is being established, that is terminated.
+   */
+  public void cancel() {
+    canceled = true;
+    StreamAllocation streamAllocation = this.streamAllocation;
+    if (streamAllocation != null) streamAllocation.cancel();
+  }
+
+  public boolean isCanceled() {
+    return canceled;
+  }
+
+  public void setCallStackTrace(Object callStackTrace) {
+    this.callStackTrace = callStackTrace;
+  }
+
+  public StreamAllocation streamAllocation() {
+    return streamAllocation;
+  }
+
+  @Override public Response intercept(Chain chain) throws IOException {
+    Request request = chain.request();
+    RealInterceptorChain realChain = (RealInterceptorChain) chain;
+    Call call = realChain.call();
+    EventListener eventListener = realChain.eventListener();
+
+    streamAllocation = new StreamAllocation(client.connectionPool(), createAddress(request.url()),
+        call, eventListener, callStackTrace);
+
+    int followUpCount = 0;
+    Response priorResponse = null;
+    while (true) {
+      if (canceled) {
+        streamAllocation.release();
+        throw new IOException("Canceled");
+      }
+
+      Response response;
+      boolean releaseConnection = true;
+      try {
+        response = realChain.proceed(request, streamAllocation, null, null);
+        releaseConnection = false;
+      } catch (RouteException e) {
+        // The attempt to connect via a route failed. The request will not have been sent.
+        if (!recover(e.getLastConnectException(), false, request)) {
+          throw e.getLastConnectException();
+        }
+        releaseConnection = false;
+        continue;
+      } catch (IOException e) {
+        // An attempt to communicate with a server failed. The request may have been sent.
+        boolean requestSendStarted = !(e instanceof ConnectionShutdownException);
+        if (!recover(e, requestSendStarted, request)) throw e;
+        releaseConnection = false;
+        continue;
+      } finally {
+        // We're throwing an unchecked exception. Release any resources.
+        if (releaseConnection) {
+          streamAllocation.streamFailed(null);
+          streamAllocation.release();
+        }
+      }
+
+      // Attach the prior response if it exists. Such responses never have a body.
+      if (priorResponse != null) {
+        response = response.newBuilder()
+            .priorResponse(priorResponse.newBuilder()
+                    .body(null)
+                    .build())
+            .build();
+      }
+
+      Request followUp = followUpRequest(response);
+
+      if (followUp == null) {
+        if (!forWebSocket) {
+          streamAllocation.release();
+        }
+        return response;
+      }
+
+      closeQuietly(response.body());
+
+      if (++followUpCount > MAX_FOLLOW_UPS) {
+        streamAllocation.release();
+        throw new ProtocolException("Too many follow-up requests: " + followUpCount);
+      }
+
+      if (followUp.body() instanceof UnrepeatableRequestBody) {
+        streamAllocation.release();
+        throw new HttpRetryException("Cannot retry streamed HTTP body", response.code());
+      }
+
+      if (!sameConnection(response, followUp.url())) {
+        streamAllocation.release();
+        streamAllocation = new StreamAllocation(client.connectionPool(),
+            createAddress(followUp.url()), call, eventListener, callStackTrace);
+      } else if (streamAllocation.codec() != null) {
+        throw new IllegalStateException("Closing the body of " + response
+            + " didn't close its backing stream. Bad interceptor?");
+      }
+
+      request = followUp;
+      priorResponse = response;
+    }
+  }
+
+  private Address createAddress(HttpUrl url) {
+    SSLSocketFactory sslSocketFactory = null;
+    HostnameVerifier hostnameVerifier = null;
+    CertificatePinner certificatePinner = null;
+    if (url.isHttps()) {
+      sslSocketFactory = client.sslSocketFactory();
+      hostnameVerifier = client.hostnameVerifier();
+      certificatePinner = client.certificatePinner();
+    }
+
+    return new Address(url.host(), url.port(), client.dns(), client.socketFactory(),
+        sslSocketFactory, hostnameVerifier, certificatePinner, client.proxyAuthenticator(),
+        client.proxy(), client.protocols(), client.connectionSpecs(), client.proxySelector());
+  }
+
+  /**
+   * Report and attempt to recover from a failure to communicate with a server. Returns true if
+   * {@code e} is recoverable, or false if the failure is permanent. Requests with a body can only
+   * be recovered if the body is buffered or if the failure occurred before the request has been
+   * sent.
+   */
+  private boolean recover(IOException e, boolean requestSendStarted, Request userRequest) {
+    streamAllocation.streamFailed(e);
+
+    // The application layer has forbidden retries.
+    if (!client.retryOnConnectionFailure()) return false;
+
+    // We can't send the request body again.
+    if (requestSendStarted && userRequest.body() instanceof UnrepeatableRequestBody) return false;
+
+    // This exception is fatal.
+    if (!isRecoverable(e, requestSendStarted)) return false;
+
+    // No more routes to attempt.
+    if (!streamAllocation.hasMoreRoutes()) return false;
+
+    // For failure recovery, use the same route selector with a new connection.
+    return true;
+  }
+
+  private boolean isRecoverable(IOException e, boolean requestSendStarted) {
+    // If there was a protocol problem, don't recover.
+    if (e instanceof ProtocolException) {
+      return false;
+    }
+
+    // If there was an interruption don't recover, but if there was a timeout connecting to a route
+    // we should try the next route (if there is one).
+    if (e instanceof InterruptedIOException) {
+      return e instanceof SocketTimeoutException && !requestSendStarted;
+    }
+
+    // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
+    // again with a different route.
+    if (e instanceof SSLHandshakeException) {
+      // If the problem was a CertificateException from the X509TrustManager,
+      // do not retry.
+      if (e.getCause() instanceof CertificateException) {
+        return false;
+      }
+    }
+    if (e instanceof SSLPeerUnverifiedException) {
+      // e.g. a certificate pinning error.
+      return false;
+    }
+
+    // An example of one we might want to retry with a different route is a problem connecting to a
+    // proxy and would manifest as a standard IOException. Unless it is one we know we should not
+    // retry, we return true and try a new route.
+    return true;
+  }
+
+  /**
+   * Figures out the HTTP request to make in response to receiving {@code userResponse}. This will
+   * either add authentication headers, follow redirects or handle a client request timeout. If a
+   * follow-up is either unnecessary or not applicable, this returns null.
+   */
+  private Request followUpRequest(Response userResponse) throws IOException {
+    if (userResponse == null) throw new IllegalStateException();
+    Connection connection = streamAllocation.connection();
+    Route route = connection != null
+        ? connection.route()
+        : null;
+    int responseCode = userResponse.code();
+
+    final String method = userResponse.request().method();
+    switch (responseCode) {
+      case HTTP_PROXY_AUTH:
+        Proxy selectedProxy = route != null
+            ? route.proxy()
+            : client.proxy();
+        if (selectedProxy.type() != Proxy.Type.HTTP) {
+          throw new ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy");
+        }
+        return client.proxyAuthenticator().authenticate(route, userResponse);
+
+      case HTTP_UNAUTHORIZED:
+        return client.authenticator().authenticate(route, userResponse);
+
+      case HTTP_PERM_REDIRECT:
+      case HTTP_TEMP_REDIRECT:
+        // "If the 307 or 308 status code is received in response to a request other than GET
+        // or HEAD, the user agent MUST NOT automatically redirect the request"
+        if (!method.equals("GET") && !method.equals("HEAD")) {
+          return null;
+        }
+        // fall-through
+      case HTTP_MULT_CHOICE:
+      case HTTP_MOVED_PERM:
+      case HTTP_MOVED_TEMP:
+      case HTTP_SEE_OTHER:
+        // Does the client allow redirects?
+        if (!client.followRedirects()) return null;
+
+        String location = userResponse.header("Location");
+        if (location == null) return null;
+        HttpUrl url = userResponse.request().url().resolve(location);
+
+        // Don't follow redirects to unsupported protocols.
+        if (url == null) return null;
+
+        // If configured, don't follow redirects between SSL and non-SSL.
+        boolean sameScheme = url.scheme().equals(userResponse.request().url().scheme());
+        if (!sameScheme && !client.followSslRedirects()) return null;
+
+        // Most redirects don't include a request body.
+        Request.Builder requestBuilder = userResponse.request().newBuilder();
+        if (HttpMethod.permitsRequestBody(method)) {
+          final boolean maintainBody = HttpMethod.redirectsWithBody(method);
+          if (HttpMethod.redirectsToGet(method)) {
+            requestBuilder.method("GET", null);
+          } else {
+            RequestBody requestBody = maintainBody ? userResponse.request().body() : null;
+            requestBuilder.method(method, requestBody);
+          }
+          if (!maintainBody) {
+            requestBuilder.removeHeader("Transfer-Encoding");
+            requestBuilder.removeHeader("Content-Length");
+            requestBuilder.removeHeader("Content-Type");
+          }
+        }
+
+        // When redirecting across hosts, drop all authentication headers. This
+        // is potentially annoying to the application layer since they have no
+        // way to retain them.
+        if (!sameConnection(userResponse, url)) {
+          requestBuilder.removeHeader("Authorization");
+        }
+
+        return requestBuilder.url(url).build();
+
+      case HTTP_CLIENT_TIMEOUT:
+        // 408's are rare in practice, but some servers like HAProxy use this response code. The
+        // spec says that we may repeat the request without modifications. Modern browsers also
+        // repeat the request (even non-idempotent ones.)
+        if (!client.retryOnConnectionFailure()) {
+          // The application layer has directed us not to retry the request.
+          return null;
+        }
+
+        if (userResponse.request().body() instanceof UnrepeatableRequestBody) {
+          return null;
+        }
+
+        if (userResponse.priorResponse() != null
+            && userResponse.priorResponse().code() == HTTP_CLIENT_TIMEOUT) {
+          // We attempted to retry and got another timeout. Give up.
+          return null;
+        }
+
+        return userResponse.request();
+
+      default:
+        return null;
+    }
+  }
+
+  /**
+   * Returns true if an HTTP request for {@code followUp} can reuse the connection used by this
+   * engine.
+   */
+  private boolean sameConnection(Response response, HttpUrl followUp) {
+    HttpUrl url = response.request().url();
+    return url.host().equals(followUp.host())
+        && url.port() == followUp.port()
+        && url.scheme().equals(followUp.scheme());
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/StatusLine.java b/okhttp/src/main/java/okhttp3/internal/http/StatusLine.java
new file mode 100644
index 0000000000..f3591a6bf9
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/StatusLine.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http;
+
+import java.io.IOException;
+import java.net.ProtocolException;
+import okhttp3.Protocol;
+import okhttp3.Response;
+
+/** An HTTP response status line like "HTTP/1.1 200 OK". */
+public final class StatusLine {
+  /** Numeric status code, 307: Temporary Redirect. */
+  public static final int HTTP_TEMP_REDIRECT = 307;
+  public static final int HTTP_PERM_REDIRECT = 308;
+  public static final int HTTP_CONTINUE = 100;
+
+  public final Protocol protocol;
+  public final int code;
+  public final String message;
+
+  public StatusLine(Protocol protocol, int code, String message) {
+    this.protocol = protocol;
+    this.code = code;
+    this.message = message;
+  }
+
+  public static StatusLine get(Response response) {
+    return new StatusLine(response.protocol(), response.code(), response.message());
+  }
+
+  public static StatusLine parse(String statusLine) throws IOException {
+    // H T T P / 1 . 1   2 0 0   T e m p o r a r y   R e d i r e c t
+    // 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0
+
+    // Parse protocol like "HTTP/1.1" followed by a space.
+    int codeStart;
+    Protocol protocol;
+    if (statusLine.startsWith("HTTP/1.")) {
+      if (statusLine.length() < 9 || statusLine.charAt(8) != ' ') {
+        throw new ProtocolException("Unexpected status line: " + statusLine);
+      }
+      int httpMinorVersion = statusLine.charAt(7) - '0';
+      codeStart = 9;
+      if (httpMinorVersion == 0) {
+        protocol = Protocol.HTTP_1_0;
+      } else if (httpMinorVersion == 1) {
+        protocol = Protocol.HTTP_1_1;
+      } else {
+        throw new ProtocolException("Unexpected status line: " + statusLine);
+      }
+    } else if (statusLine.startsWith("ICY ")) {
+      // Shoutcast uses ICY instead of "HTTP/1.0".
+      protocol = Protocol.HTTP_1_0;
+      codeStart = 4;
+    } else {
+      throw new ProtocolException("Unexpected status line: " + statusLine);
+    }
+
+    // Parse response code like "200". Always 3 digits.
+    if (statusLine.length() < codeStart + 3) {
+      throw new ProtocolException("Unexpected status line: " + statusLine);
+    }
+    int code;
+    try {
+      code = Integer.parseInt(statusLine.substring(codeStart, codeStart + 3));
+    } catch (NumberFormatException e) {
+      throw new ProtocolException("Unexpected status line: " + statusLine);
+    }
+
+    // Parse an optional response message like "OK" or "Not Modified". If it
+    // exists, it is separated from the response code by a space.
+    String message = "";
+    if (statusLine.length() > codeStart + 3) {
+      if (statusLine.charAt(codeStart + 3) != ' ') {
+        throw new ProtocolException("Unexpected status line: " + statusLine);
+      }
+      message = statusLine.substring(codeStart + 4);
+    }
+
+    return new StatusLine(protocol, code, message);
+  }
+
+  @Override public String toString() {
+    StringBuilder result = new StringBuilder();
+    result.append(protocol == Protocol.HTTP_1_0 ? "HTTP/1.0" : "HTTP/1.1");
+    result.append(' ').append(code);
+    if (message != null) {
+      result.append(' ').append(message);
+    }
+    return result.toString();
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/UnrepeatableRequestBody.java b/okhttp/src/main/java/okhttp3/internal/http/UnrepeatableRequestBody.java
new file mode 100644
index 0000000000..60b893fbf3
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/UnrepeatableRequestBody.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http;
+
+public interface UnrepeatableRequestBody {
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
new file mode 100644
index 0000000000..83780ff863
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
@@ -0,0 +1,521 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http1;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.net.ProtocolException;
+import okhttp3.Headers;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.Internal;
+import okhttp3.internal.Util;
+import okhttp3.internal.connection.RealConnection;
+import okhttp3.internal.connection.StreamAllocation;
+import okhttp3.internal.http.HttpCodec;
+import okhttp3.internal.http.HttpHeaders;
+import okhttp3.internal.http.RealResponseBody;
+import okhttp3.internal.http.RequestLine;
+import okhttp3.internal.http.StatusLine;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.ForwardingTimeout;
+import okio.Okio;
+import okio.Sink;
+import okio.Source;
+import okio.Timeout;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static okhttp3.internal.Util.checkOffsetAndCount;
+import static okhttp3.internal.http.StatusLine.HTTP_CONTINUE;
+
+/**
+ * A socket connection that can be used to send HTTP/1.1 messages. This class strictly enforces the
+ * following lifecycle:
+ *
+ * <ol>
+ *     <li>{@linkplain #writeRequest Send request headers}.
+ *     <li>Open a sink to write the request body. Either {@linkplain #newFixedLengthSink
+ *         fixed-length} or {@link #newChunkedSink chunked}.
+ *     <li>Write to and then close that sink.
+ *     <li>{@linkplain #readResponseHeaders Read response headers}.
+ *     <li>Open a source to read the response body. Either {@linkplain #newFixedLengthSource
+ *         fixed-length}, {@linkplain #newChunkedSource chunked} or {@linkplain
+ *         #newUnknownLengthSource unknown length}.
+ *     <li>Read from and close that source.
+ * </ol>
+ *
+ * <p>Exchanges that do not have a request body may skip creating and closing the request body.
+ * Exchanges that do not have a response body can call {@link #newFixedLengthSource(long)
+ * newFixedLengthSource(0)} and may skip reading and closing that source.
+ */
+public final class Http1Codec implements HttpCodec {
+  private static final int STATE_IDLE = 0; // Idle connections are ready to write request headers.
+  private static final int STATE_OPEN_REQUEST_BODY = 1;
+  private static final int STATE_WRITING_REQUEST_BODY = 2;
+  private static final int STATE_READ_RESPONSE_HEADERS = 3;
+  private static final int STATE_OPEN_RESPONSE_BODY = 4;
+  private static final int STATE_READING_RESPONSE_BODY = 5;
+  private static final int STATE_CLOSED = 6;
+  private static final int HEADER_LIMIT = 256 * 1024;
+
+  /** The client that configures this stream. May be null for HTTPS proxy tunnels. */
+  final OkHttpClient client;
+  /** The stream allocation that owns this stream. May be null for HTTPS proxy tunnels. */
+  final StreamAllocation streamAllocation;
+
+  final BufferedSource source;
+  final BufferedSink sink;
+  int state = STATE_IDLE;
+  private long headerLimit = HEADER_LIMIT;
+
+  public Http1Codec(OkHttpClient client, StreamAllocation streamAllocation, BufferedSource source,
+      BufferedSink sink) {
+    this.client = client;
+    this.streamAllocation = streamAllocation;
+    this.source = source;
+    this.sink = sink;
+  }
+
+  @Override public Sink createRequestBody(Request request, long contentLength) {
+    if ("chunked".equalsIgnoreCase(request.header("Transfer-Encoding"))) {
+      // Stream a request body of unknown length.
+      return newChunkedSink();
+    }
+
+    if (contentLength != -1) {
+      // Stream a request body of a known length.
+      return newFixedLengthSink(contentLength);
+    }
+
+    throw new IllegalStateException(
+        "Cannot stream a request body without chunked encoding or a known content length!");
+  }
+
+  @Override public void cancel() {
+    RealConnection connection = streamAllocation.connection();
+    if (connection != null) connection.cancel();
+  }
+
+  /**
+   * Prepares the HTTP headers and sends them to the server.
+   *
+   * <p>For streaming requests with a body, headers must be prepared <strong>before</strong> the
+   * output stream has been written to. Otherwise the body would need to be buffered!
+   *
+   * <p>For non-streaming requests with a body, headers must be prepared <strong>after</strong> the
+   * output stream has been written to and closed. This ensures that the {@code Content-Length}
+   * header field receives the proper value.
+   */
+  @Override public void writeRequestHeaders(Request request) throws IOException {
+    String requestLine = RequestLine.get(
+        request, streamAllocation.connection().route().proxy().type());
+    writeRequest(request.headers(), requestLine);
+  }
+
+  @Override public ResponseBody openResponseBody(Response response) throws IOException {
+    streamAllocation.eventListener.responseBodyStart(streamAllocation.call);
+    String contentType = response.header("Content-Type");
+
+    if (!HttpHeaders.hasBody(response)) {
+      Source source = newFixedLengthSource(0);
+      return new RealResponseBody(contentType, 0, Okio.buffer(source));
+    }
+
+    if ("chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {
+      Source source = newChunkedSource(response.request().url());
+      return new RealResponseBody(contentType, -1L, Okio.buffer(source));
+    }
+
+    long contentLength = HttpHeaders.contentLength(response);
+    if (contentLength != -1) {
+      Source source = newFixedLengthSource(contentLength);
+      return new RealResponseBody(contentType, contentLength, Okio.buffer(source));
+    }
+
+    return new RealResponseBody(contentType, -1L, Okio.buffer(newUnknownLengthSource()));
+  }
+
+  /** Returns true if this connection is closed. */
+  public boolean isClosed() {
+    return state == STATE_CLOSED;
+  }
+
+  @Override public void flushRequest() throws IOException {
+    sink.flush();
+  }
+
+  @Override public void finishRequest() throws IOException {
+    sink.flush();
+  }
+
+  /** Returns bytes of a request header for sending on an HTTP transport. */
+  public void writeRequest(Headers headers, String requestLine) throws IOException {
+    if (state != STATE_IDLE) throw new IllegalStateException("state: " + state);
+    sink.writeUtf8(requestLine).writeUtf8("\r\n");
+    for (int i = 0, size = headers.size(); i < size; i++) {
+      sink.writeUtf8(headers.name(i))
+          .writeUtf8(": ")
+          .writeUtf8(headers.value(i))
+          .writeUtf8("\r\n");
+    }
+    sink.writeUtf8("\r\n");
+    state = STATE_OPEN_REQUEST_BODY;
+  }
+
+  @Override public Response.Builder readResponseHeaders(boolean expectContinue) throws IOException {
+    if (state != STATE_OPEN_REQUEST_BODY && state != STATE_READ_RESPONSE_HEADERS) {
+      throw new IllegalStateException("state: " + state);
+    }
+
+    try {
+      StatusLine statusLine = StatusLine.parse(readHeaderLine());
+
+      Response.Builder responseBuilder = new Response.Builder()
+          .protocol(statusLine.protocol)
+          .code(statusLine.code)
+          .message(statusLine.message)
+          .headers(readHeaders());
+
+      if (expectContinue && statusLine.code == HTTP_CONTINUE) {
+        return null;
+      }
+
+      state = STATE_OPEN_RESPONSE_BODY;
+      return responseBuilder;
+    } catch (EOFException e) {
+      // Provide more context if the server ends the stream before sending a response.
+      IOException exception = new IOException("unexpected end of stream on " + streamAllocation);
+      exception.initCause(e);
+      throw exception;
+    }
+  }
+
+  private String readHeaderLine() throws IOException {
+    String line = source.readUtf8LineStrict(headerLimit);
+    headerLimit -= line.length();
+    return line;
+  }
+
+  /** Reads headers or trailers. */
+  public Headers readHeaders() throws IOException {
+    Headers.Builder headers = new Headers.Builder();
+    // parse the result headers until the first blank line
+    for (String line; (line = readHeaderLine()).length() != 0; ) {
+      Internal.instance.addLenient(headers, line);
+    }
+    return headers.build();
+  }
+
+  public Sink newChunkedSink() {
+    if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException("state: " + state);
+    state = STATE_WRITING_REQUEST_BODY;
+    return new ChunkedSink();
+  }
+
+  public Sink newFixedLengthSink(long contentLength) {
+    if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException("state: " + state);
+    state = STATE_WRITING_REQUEST_BODY;
+    return new FixedLengthSink(contentLength);
+  }
+
+  public Source newFixedLengthSource(long length) throws IOException {
+    if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
+    state = STATE_READING_RESPONSE_BODY;
+    return new FixedLengthSource(length);
+  }
+
+  public Source newChunkedSource(HttpUrl url) throws IOException {
+    if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
+    state = STATE_READING_RESPONSE_BODY;
+    return new ChunkedSource(url);
+  }
+
+  public Source newUnknownLengthSource() throws IOException {
+    if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
+    if (streamAllocation == null) throw new IllegalStateException("streamAllocation == null");
+    state = STATE_READING_RESPONSE_BODY;
+    streamAllocation.noNewStreams();
+    return new UnknownLengthSource();
+  }
+
+  /**
+   * Sets the delegate of {@code timeout} to {@link Timeout#NONE} and resets its underlying timeout
+   * to the default configuration. Use this to avoid unexpected sharing of timeouts between pooled
+   * connections.
+   */
+  void detachTimeout(ForwardingTimeout timeout) {
+    Timeout oldDelegate = timeout.delegate();
+    timeout.setDelegate(Timeout.NONE);
+    oldDelegate.clearDeadline();
+    oldDelegate.clearTimeout();
+  }
+
+  /** An HTTP body with a fixed length known in advance. */
+  private final class FixedLengthSink implements Sink {
+    private final ForwardingTimeout timeout = new ForwardingTimeout(sink.timeout());
+    private boolean closed;
+    private long bytesRemaining;
+
+    FixedLengthSink(long bytesRemaining) {
+      this.bytesRemaining = bytesRemaining;
+    }
+
+    @Override public Timeout timeout() {
+      return timeout;
+    }
+
+    @Override public void write(Buffer source, long byteCount) throws IOException {
+      if (closed) throw new IllegalStateException("closed");
+      checkOffsetAndCount(source.size(), 0, byteCount);
+      if (byteCount > bytesRemaining) {
+        throw new ProtocolException("expected " + bytesRemaining
+            + " bytes but received " + byteCount);
+      }
+      sink.write(source, byteCount);
+      bytesRemaining -= byteCount;
+    }
+
+    @Override public void flush() throws IOException {
+      if (closed) return; // Don't throw; this stream might have been closed on the caller's behalf.
+      sink.flush();
+    }
+
+    @Override public void close() throws IOException {
+      if (closed) return;
+      closed = true;
+      if (bytesRemaining > 0) throw new ProtocolException("unexpected end of stream");
+      detachTimeout(timeout);
+      state = STATE_READ_RESPONSE_HEADERS;
+    }
+  }
+
+  /**
+   * An HTTP body with alternating chunk sizes and chunk bodies. It is the caller's responsibility
+   * to buffer chunks; typically by using a buffered sink with this sink.
+   */
+  private final class ChunkedSink implements Sink {
+    private final ForwardingTimeout timeout = new ForwardingTimeout(sink.timeout());
+    private boolean closed;
+
+    ChunkedSink() {
+    }
+
+    @Override public Timeout timeout() {
+      return timeout;
+    }
+
+    @Override public void write(Buffer source, long byteCount) throws IOException {
+      if (closed) throw new IllegalStateException("closed");
+      if (byteCount == 0) return;
+
+      sink.writeHexadecimalUnsignedLong(byteCount);
+      sink.writeUtf8("\r\n");
+      sink.write(source, byteCount);
+      sink.writeUtf8("\r\n");
+    }
+
+    @Override public synchronized void flush() throws IOException {
+      if (closed) return; // Don't throw; this stream might have been closed on the caller's behalf.
+      sink.flush();
+    }
+
+    @Override public synchronized void close() throws IOException {
+      if (closed) return;
+      closed = true;
+      sink.writeUtf8("0\r\n\r\n");
+      detachTimeout(timeout);
+      state = STATE_READ_RESPONSE_HEADERS;
+    }
+  }
+
+  private abstract class AbstractSource implements Source {
+    protected final ForwardingTimeout timeout = new ForwardingTimeout(source.timeout());
+    protected boolean closed;
+    protected long bytesRead = 0;
+
+    @Override public Timeout timeout() {
+      return timeout;
+    }
+
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
+      try {
+        long read = source.read(sink, byteCount);
+        if (read > 0) {
+          bytesRead += read;
+        }
+        return read;
+      } catch (IOException e) {
+        endOfInput(false, e);
+        throw e;
+      }
+    }
+
+    /**
+     * Closes the cache entry and makes the socket available for reuse. This should be invoked when
+     * the end of the body has been reached.
+     */
+    protected final void endOfInput(boolean reuseConnection, IOException e) throws IOException {
+      if (state == STATE_CLOSED) return;
+      if (state != STATE_READING_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
+
+      detachTimeout(timeout);
+
+      state = STATE_CLOSED;
+      if (streamAllocation != null) {
+        streamAllocation.streamFinished(!reuseConnection, Http1Codec.this, bytesRead, e);
+      }
+    }
+  }
+
+  /** An HTTP body with a fixed length specified in advance. */
+  private class FixedLengthSource extends AbstractSource {
+    private long bytesRemaining;
+
+    FixedLengthSource(long length) throws IOException {
+      bytesRemaining = length;
+      if (bytesRemaining == 0) {
+        endOfInput(true, null);
+      }
+    }
+
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
+      if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
+      if (closed) throw new IllegalStateException("closed");
+      if (bytesRemaining == 0) return -1;
+
+      long read = super.read(sink, Math.min(bytesRemaining, byteCount));
+      if (read == -1) {
+        ProtocolException e = new ProtocolException("unexpected end of stream");
+        endOfInput(false, e); // The server didn't supply the promised content length.
+        throw e;
+      }
+
+      bytesRemaining -= read;
+      if (bytesRemaining == 0) {
+        endOfInput(true, null);
+      }
+      return read;
+    }
+
+    @Override public void close() throws IOException {
+      if (closed) return;
+
+      if (bytesRemaining != 0 && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
+        endOfInput(false, null);
+      }
+
+      closed = true;
+    }
+  }
+
+  /** An HTTP body with alternating chunk sizes and chunk bodies. */
+  private class ChunkedSource extends AbstractSource {
+    private static final long NO_CHUNK_YET = -1L;
+    private final HttpUrl url;
+    private long bytesRemainingInChunk = NO_CHUNK_YET;
+    private boolean hasMoreChunks = true;
+
+    ChunkedSource(HttpUrl url) {
+      this.url = url;
+    }
+
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
+      if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
+      if (closed) throw new IllegalStateException("closed");
+      if (!hasMoreChunks) return -1;
+
+      if (bytesRemainingInChunk == 0 || bytesRemainingInChunk == NO_CHUNK_YET) {
+        readChunkSize();
+        if (!hasMoreChunks) return -1;
+      }
+
+      long read = super.read(sink, Math.min(byteCount, bytesRemainingInChunk));
+      if (read == -1) {
+        ProtocolException e = new ProtocolException("unexpected end of stream");
+        endOfInput(false, e); // The server didn't supply the promised chunk length.
+        throw e;
+      }
+      bytesRemainingInChunk -= read;
+      return read;
+    }
+
+    private void readChunkSize() throws IOException {
+      // Read the suffix of the previous chunk.
+      if (bytesRemainingInChunk != NO_CHUNK_YET) {
+        source.readUtf8LineStrict();
+      }
+      try {
+        bytesRemainingInChunk = source.readHexadecimalUnsignedLong();
+        String extensions = source.readUtf8LineStrict().trim();
+        if (bytesRemainingInChunk < 0 || (!extensions.isEmpty() && !extensions.startsWith(";"))) {
+          throw new ProtocolException("expected chunk size and optional extensions but was \""
+              + bytesRemainingInChunk + extensions + "\"");
+        }
+      } catch (NumberFormatException e) {
+        throw new ProtocolException(e.getMessage());
+      }
+      if (bytesRemainingInChunk == 0L) {
+        hasMoreChunks = false;
+        HttpHeaders.receiveHeaders(client.cookieJar(), url, readHeaders());
+        endOfInput(true, null);
+      }
+    }
+
+    @Override public void close() throws IOException {
+      if (closed) return;
+      if (hasMoreChunks && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
+        endOfInput(false, null);
+      }
+      closed = true;
+    }
+  }
+
+  /** An HTTP message body terminated by the end of the underlying stream. */
+  private class UnknownLengthSource extends AbstractSource {
+    private boolean inputExhausted;
+
+    UnknownLengthSource() {
+    }
+
+    @Override public long read(Buffer sink, long byteCount)
+        throws IOException {
+      if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
+      if (closed) throw new IllegalStateException("closed");
+      if (inputExhausted) return -1;
+
+      long read = super.read(sink, byteCount);
+      if (read == -1) {
+        inputExhausted = true;
+        endOfInput(true, null);
+        return -1;
+      }
+      return read;
+    }
+
+    @Override public void close() throws IOException {
+      if (closed) return;
+      if (!inputExhausted) {
+        endOfInput(false, null);
+      }
+      closed = true;
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/ConnectionShutdownException.java b/okhttp/src/main/java/okhttp3/internal/http2/ConnectionShutdownException.java
new file mode 100644
index 0000000000..00c4f2441c
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http2/ConnectionShutdownException.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import java.io.IOException;
+
+/**
+ * Thrown when an HTTP/2 connection is shutdown (either explicitly or if the peer has sent a GOAWAY
+ * frame) and an attempt is made to use the connection.
+ */
+public final class ConnectionShutdownException extends IOException {
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/ErrorCode.java b/okhttp/src/main/java/okhttp3/internal/http2/ErrorCode.java
new file mode 100644
index 0000000000..26defebe06
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http2/ErrorCode.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+// http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-7
+public enum ErrorCode {
+  /** Not an error! */
+  NO_ERROR(0),
+
+  PROTOCOL_ERROR(1),
+
+  INTERNAL_ERROR(2),
+
+  FLOW_CONTROL_ERROR(3),
+
+  REFUSED_STREAM(7),
+
+  CANCEL(8);
+
+  public final int httpCode;
+
+  ErrorCode(int httpCode) {
+    this.httpCode = httpCode;
+  }
+
+  public static ErrorCode fromHttp2(int code) {
+    for (ErrorCode errorCode : ErrorCode.values()) {
+      if (errorCode.httpCode == code) return errorCode;
+    }
+    return null;
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Header.java b/okhttp/src/main/java/okhttp3/internal/http2/Header.java
new file mode 100644
index 0000000000..3cfd7be8d7
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Header.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import okhttp3.internal.Util;
+import okio.ByteString;
+
+/** HTTP header: the name is an ASCII string, but the value can be UTF-8. */
+public final class Header {
+  // Special header names defined in HTTP/2 spec.
+  public static final ByteString PSEUDO_PREFIX = ByteString.encodeUtf8(":");
+  public static final ByteString RESPONSE_STATUS = ByteString.encodeUtf8(":status");
+  public static final ByteString TARGET_METHOD = ByteString.encodeUtf8(":method");
+  public static final ByteString TARGET_PATH = ByteString.encodeUtf8(":path");
+  public static final ByteString TARGET_SCHEME = ByteString.encodeUtf8(":scheme");
+  public static final ByteString TARGET_AUTHORITY = ByteString.encodeUtf8(":authority");
+
+  /** Name in case-insensitive ASCII encoding. */
+  public final ByteString name;
+  /** Value in UTF-8 encoding. */
+  public final ByteString value;
+  final int hpackSize;
+
+  // TODO: search for toLowerCase and consider moving logic here.
+  public Header(String name, String value) {
+    this(ByteString.encodeUtf8(name), ByteString.encodeUtf8(value));
+  }
+
+  public Header(ByteString name, String value) {
+    this(name, ByteString.encodeUtf8(value));
+  }
+
+  public Header(ByteString name, ByteString value) {
+    this.name = name;
+    this.value = value;
+    this.hpackSize = 32 + name.size() + value.size();
+  }
+
+  @Override public boolean equals(Object other) {
+    if (other instanceof Header) {
+      Header that = (Header) other;
+      return this.name.equals(that.name)
+          && this.value.equals(that.value);
+    }
+    return false;
+  }
+
+  @Override public int hashCode() {
+    int result = 17;
+    result = 31 * result + name.hashCode();
+    result = 31 * result + value.hashCode();
+    return result;
+  }
+
+  @Override public String toString() {
+    return Util.format("%s: %s", name.utf8(), value.utf8());
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java b/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
new file mode 100644
index 0000000000..a28698bf01
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
@@ -0,0 +1,599 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import okhttp3.internal.Util;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.Okio;
+import okio.Source;
+
+/**
+ * Read and write HPACK v10.
+ *
+ * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12
+ *
+ * This implementation uses an array for the dynamic table and a list for indexed entries.  Dynamic
+ * entries are added to the array, starting in the last position moving forward.  When the array
+ * fills, it is doubled.
+ */
+final class Hpack {
+  private static final int PREFIX_4_BITS = 0x0f;
+  private static final int PREFIX_5_BITS = 0x1f;
+  private static final int PREFIX_6_BITS = 0x3f;
+  private static final int PREFIX_7_BITS = 0x7f;
+
+  static final Header[] STATIC_HEADER_TABLE = new Header[] {
+      new Header(Header.TARGET_AUTHORITY, ""),
+      new Header(Header.TARGET_METHOD, "GET"),
+      new Header(Header.TARGET_METHOD, "POST"),
+      new Header(Header.TARGET_PATH, "/"),
+      new Header(Header.TARGET_PATH, "/index.html"),
+      new Header(Header.TARGET_SCHEME, "http"),
+      new Header(Header.TARGET_SCHEME, "https"),
+      new Header(Header.RESPONSE_STATUS, "200"),
+      new Header(Header.RESPONSE_STATUS, "204"),
+      new Header(Header.RESPONSE_STATUS, "206"),
+      new Header(Header.RESPONSE_STATUS, "304"),
+      new Header(Header.RESPONSE_STATUS, "400"),
+      new Header(Header.RESPONSE_STATUS, "404"),
+      new Header(Header.RESPONSE_STATUS, "500"),
+      new Header("accept-charset", ""),
+      new Header("accept-encoding", "gzip, deflate"),
+      new Header("accept-language", ""),
+      new Header("accept-ranges", ""),
+      new Header("accept", ""),
+      new Header("access-control-allow-origin", ""),
+      new Header("age", ""),
+      new Header("allow", ""),
+      new Header("authorization", ""),
+      new Header("cache-control", ""),
+      new Header("content-disposition", ""),
+      new Header("content-encoding", ""),
+      new Header("content-language", ""),
+      new Header("content-length", ""),
+      new Header("content-location", ""),
+      new Header("content-range", ""),
+      new Header("content-type", ""),
+      new Header("cookie", ""),
+      new Header("date", ""),
+      new Header("etag", ""),
+      new Header("expect", ""),
+      new Header("expires", ""),
+      new Header("from", ""),
+      new Header("host", ""),
+      new Header("if-match", ""),
+      new Header("if-modified-since", ""),
+      new Header("if-none-match", ""),
+      new Header("if-range", ""),
+      new Header("if-unmodified-since", ""),
+      new Header("last-modified", ""),
+      new Header("link", ""),
+      new Header("location", ""),
+      new Header("max-forwards", ""),
+      new Header("proxy-authenticate", ""),
+      new Header("proxy-authorization", ""),
+      new Header("range", ""),
+      new Header("referer", ""),
+      new Header("refresh", ""),
+      new Header("retry-after", ""),
+      new Header("server", ""),
+      new Header("set-cookie", ""),
+      new Header("strict-transport-security", ""),
+      new Header("transfer-encoding", ""),
+      new Header("user-agent", ""),
+      new Header("vary", ""),
+      new Header("via", ""),
+      new Header("www-authenticate", "")
+  };
+
+  private Hpack() {
+  }
+
+  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-3.1
+  static final class Reader {
+
+    private final List<Header> headerList = new ArrayList<>();
+    private final BufferedSource source;
+
+    private final int headerTableSizeSetting;
+    private int maxDynamicTableByteCount;
+
+    // Visible for testing.
+    Header[] dynamicTable = new Header[8];
+    // Array is populated back to front, so new entries always have lowest index.
+    int nextHeaderIndex = dynamicTable.length - 1;
+    int headerCount = 0;
+    int dynamicTableByteCount = 0;
+
+    Reader(int headerTableSizeSetting, Source source) {
+      this(headerTableSizeSetting, headerTableSizeSetting, source);
+    }
+
+    Reader(int headerTableSizeSetting, int maxDynamicTableByteCount, Source source) {
+      this.headerTableSizeSetting = headerTableSizeSetting;
+      this.maxDynamicTableByteCount = maxDynamicTableByteCount;
+      this.source = Okio.buffer(source);
+    }
+
+    int maxDynamicTableByteCount() {
+      return maxDynamicTableByteCount;
+    }
+
+    private void adjustDynamicTableByteCount() {
+      if (maxDynamicTableByteCount < dynamicTableByteCount) {
+        if (maxDynamicTableByteCount == 0) {
+          clearDynamicTable();
+        } else {
+          evictToRecoverBytes(dynamicTableByteCount - maxDynamicTableByteCount);
+        }
+      }
+    }
+
+    private void clearDynamicTable() {
+      Arrays.fill(dynamicTable, null);
+      nextHeaderIndex = dynamicTable.length - 1;
+      headerCount = 0;
+      dynamicTableByteCount = 0;
+    }
+
+    /** Returns the count of entries evicted. */
+    private int evictToRecoverBytes(int bytesToRecover) {
+      int entriesToEvict = 0;
+      if (bytesToRecover > 0) {
+        // determine how many headers need to be evicted.
+        for (int j = dynamicTable.length - 1; j >= nextHeaderIndex && bytesToRecover > 0; j--) {
+          bytesToRecover -= dynamicTable[j].hpackSize;
+          dynamicTableByteCount -= dynamicTable[j].hpackSize;
+          headerCount--;
+          entriesToEvict++;
+        }
+        System.arraycopy(dynamicTable, nextHeaderIndex + 1, dynamicTable,
+            nextHeaderIndex + 1 + entriesToEvict, headerCount);
+        nextHeaderIndex += entriesToEvict;
+      }
+      return entriesToEvict;
+    }
+
+    /**
+     * Read {@code byteCount} bytes of headers from the source stream. This implementation does not
+     * propagate the never indexed flag of a header.
+     */
+    void readHeaders() throws IOException {
+      while (!source.exhausted()) {
+        int b = source.readByte() & 0xff;
+        if (b == 0x80) { // 10000000
+          throw new IOException("index == 0");
+        } else if ((b & 0x80) == 0x80) { // 1NNNNNNN
+          int index = readInt(b, PREFIX_7_BITS);
+          readIndexedHeader(index - 1);
+        } else if (b == 0x40) { // 01000000
+          readLiteralHeaderWithIncrementalIndexingNewName();
+        } else if ((b & 0x40) == 0x40) {  // 01NNNNNN
+          int index = readInt(b, PREFIX_6_BITS);
+          readLiteralHeaderWithIncrementalIndexingIndexedName(index - 1);
+        } else if ((b & 0x20) == 0x20) {  // 001NNNNN
+          maxDynamicTableByteCount = readInt(b, PREFIX_5_BITS);
+          if (maxDynamicTableByteCount < 0
+              || maxDynamicTableByteCount > headerTableSizeSetting) {
+            throw new IOException("Invalid dynamic table size update " + maxDynamicTableByteCount);
+          }
+          adjustDynamicTableByteCount();
+        } else if (b == 0x10 || b == 0) { // 000?0000 - Ignore never indexed bit.
+          readLiteralHeaderWithoutIndexingNewName();
+        } else { // 000?NNNN - Ignore never indexed bit.
+          int index = readInt(b, PREFIX_4_BITS);
+          readLiteralHeaderWithoutIndexingIndexedName(index - 1);
+        }
+      }
+    }
+
+    public List<Header> getAndResetHeaderList() {
+      List<Header> result = new ArrayList<>(headerList);
+      headerList.clear();
+      return result;
+    }
+
+    private void readIndexedHeader(int index) throws IOException {
+      if (isStaticHeader(index)) {
+        Header staticEntry = STATIC_HEADER_TABLE[index];
+        headerList.add(staticEntry);
+      } else {
+        int dynamicTableIndex = dynamicTableIndex(index - STATIC_HEADER_TABLE.length);
+        if (dynamicTableIndex < 0 || dynamicTableIndex > dynamicTable.length - 1) {
+          throw new IOException("Header index too large " + (index + 1));
+        }
+        headerList.add(dynamicTable[dynamicTableIndex]);
+      }
+    }
+
+    // referencedHeaders is relative to nextHeaderIndex + 1.
+    private int dynamicTableIndex(int index) {
+      return nextHeaderIndex + 1 + index;
+    }
+
+    private void readLiteralHeaderWithoutIndexingIndexedName(int index) throws IOException {
+      ByteString name = getName(index);
+      ByteString value = readByteString();
+      headerList.add(new Header(name, value));
+    }
+
+    private void readLiteralHeaderWithoutIndexingNewName() throws IOException {
+      ByteString name = checkLowercase(readByteString());
+      ByteString value = readByteString();
+      headerList.add(new Header(name, value));
+    }
+
+    private void readLiteralHeaderWithIncrementalIndexingIndexedName(int nameIndex)
+        throws IOException {
+      ByteString name = getName(nameIndex);
+      ByteString value = readByteString();
+      insertIntoDynamicTable(-1, new Header(name, value));
+    }
+
+    private void readLiteralHeaderWithIncrementalIndexingNewName() throws IOException {
+      ByteString name = checkLowercase(readByteString());
+      ByteString value = readByteString();
+      insertIntoDynamicTable(-1, new Header(name, value));
+    }
+
+    private ByteString getName(int index) {
+      if (isStaticHeader(index)) {
+        return STATIC_HEADER_TABLE[index].name;
+      } else {
+        return dynamicTable[dynamicTableIndex(index - STATIC_HEADER_TABLE.length)].name;
+      }
+    }
+
+    private boolean isStaticHeader(int index) {
+      return index >= 0 && index <= STATIC_HEADER_TABLE.length - 1;
+    }
+
+    /** index == -1 when new. */
+    private void insertIntoDynamicTable(int index, Header entry) {
+      headerList.add(entry);
+
+      int delta = entry.hpackSize;
+      if (index != -1) { // Index -1 == new header.
+        delta -= dynamicTable[dynamicTableIndex(index)].hpackSize;
+      }
+
+      // if the new or replacement header is too big, drop all entries.
+      if (delta > maxDynamicTableByteCount) {
+        clearDynamicTable();
+        return;
+      }
+
+      // Evict headers to the required length.
+      int bytesToRecover = (dynamicTableByteCount + delta) - maxDynamicTableByteCount;
+      int entriesEvicted = evictToRecoverBytes(bytesToRecover);
+
+      if (index == -1) { // Adding a value to the dynamic table.
+        if (headerCount + 1 > dynamicTable.length) { // Need to grow the dynamic table.
+          Header[] doubled = new Header[dynamicTable.length * 2];
+          System.arraycopy(dynamicTable, 0, doubled, dynamicTable.length, dynamicTable.length);
+          nextHeaderIndex = dynamicTable.length - 1;
+          dynamicTable = doubled;
+        }
+        index = nextHeaderIndex--;
+        dynamicTable[index] = entry;
+        headerCount++;
+      } else { // Replace value at same position.
+        index += dynamicTableIndex(index) + entriesEvicted;
+        dynamicTable[index] = entry;
+      }
+      dynamicTableByteCount += delta;
+    }
+
+    private int readByte() throws IOException {
+      return source.readByte() & 0xff;
+    }
+
+    int readInt(int firstByte, int prefixMask) throws IOException {
+      int prefix = firstByte & prefixMask;
+      if (prefix < prefixMask) {
+        return prefix; // This was a single byte value.
+      }
+
+      // This is a multibyte value. Read 7 bits at a time.
+      int result = prefixMask;
+      int shift = 0;
+      while (true) {
+        int b = readByte();
+        if ((b & 0x80) != 0) { // Equivalent to (b >= 128) since b is in [0..255].
+          result += (b & 0x7f) << shift;
+          shift += 7;
+        } else {
+          result += b << shift; // Last byte.
+          break;
+        }
+      }
+      return result;
+    }
+
+    /** Reads a potentially Huffman encoded byte string. */
+    ByteString readByteString() throws IOException {
+      int firstByte = readByte();
+      boolean huffmanDecode = (firstByte & 0x80) == 0x80; // 1NNNNNNN
+      int length = readInt(firstByte, PREFIX_7_BITS);
+
+      if (huffmanDecode) {
+        return ByteString.of(Huffman.get().decode(source.readByteArray(length)));
+      } else {
+        return source.readByteString(length);
+      }
+    }
+  }
+
+  static final Map<ByteString, Integer> NAME_TO_FIRST_INDEX = nameToFirstIndex();
+
+  private static Map<ByteString, Integer> nameToFirstIndex() {
+    Map<ByteString, Integer> result = new LinkedHashMap<>(STATIC_HEADER_TABLE.length);
+    for (int i = 0; i < STATIC_HEADER_TABLE.length; i++) {
+      if (!result.containsKey(STATIC_HEADER_TABLE[i].name)) {
+        result.put(STATIC_HEADER_TABLE[i].name, i);
+      }
+    }
+    return Collections.unmodifiableMap(result);
+  }
+
+  static final class Writer {
+    private static final int SETTINGS_HEADER_TABLE_SIZE = 4096;
+
+    /**
+     * The decoder has ultimate control of the maximum size of the dynamic table but we can choose
+     * to use less. We'll put a cap at 16K. This is arbitrary but should be enough for most
+     * purposes.
+     */
+    private static final int SETTINGS_HEADER_TABLE_SIZE_LIMIT = 16384;
+
+    private final Buffer out;
+    private final boolean useCompression;
+
+    /**
+     * In the scenario where the dynamic table size changes multiple times between transmission of
+     * header blocks, we need to keep track of the smallest value in that interval.
+     */
+    private int smallestHeaderTableSizeSetting = Integer.MAX_VALUE;
+    private boolean emitDynamicTableSizeUpdate;
+
+    int headerTableSizeSetting;
+    int maxDynamicTableByteCount;
+
+    // Visible for testing.
+    Header[] dynamicTable = new Header[8];
+    // Array is populated back to front, so new entries always have lowest index.
+    int nextHeaderIndex = dynamicTable.length - 1;
+    int headerCount = 0;
+    int dynamicTableByteCount = 0;
+
+    Writer(Buffer out) {
+      this(SETTINGS_HEADER_TABLE_SIZE, true, out);
+    }
+
+    Writer(int headerTableSizeSetting, boolean useCompression, Buffer out) {
+      this.headerTableSizeSetting = headerTableSizeSetting;
+      this.maxDynamicTableByteCount = headerTableSizeSetting;
+      this.useCompression = useCompression;
+      this.out = out;
+    }
+
+    private void clearDynamicTable() {
+      Arrays.fill(dynamicTable, null);
+      nextHeaderIndex = dynamicTable.length - 1;
+      headerCount = 0;
+      dynamicTableByteCount = 0;
+    }
+
+    /** Returns the count of entries evicted. */
+    private int evictToRecoverBytes(int bytesToRecover) {
+      int entriesToEvict = 0;
+      if (bytesToRecover > 0) {
+        // determine how many headers need to be evicted.
+        for (int j = dynamicTable.length - 1; j >= nextHeaderIndex && bytesToRecover > 0; j--) {
+          bytesToRecover -= dynamicTable[j].hpackSize;
+          dynamicTableByteCount -= dynamicTable[j].hpackSize;
+          headerCount--;
+          entriesToEvict++;
+        }
+        System.arraycopy(dynamicTable, nextHeaderIndex + 1, dynamicTable,
+            nextHeaderIndex + 1 + entriesToEvict, headerCount);
+        Arrays.fill(dynamicTable, nextHeaderIndex + 1, nextHeaderIndex + 1 + entriesToEvict, null);
+        nextHeaderIndex += entriesToEvict;
+      }
+      return entriesToEvict;
+    }
+
+    private void insertIntoDynamicTable(Header entry) {
+      int delta = entry.hpackSize;
+
+      // if the new or replacement header is too big, drop all entries.
+      if (delta > maxDynamicTableByteCount) {
+        clearDynamicTable();
+        return;
+      }
+
+      // Evict headers to the required length.
+      int bytesToRecover = (dynamicTableByteCount + delta) - maxDynamicTableByteCount;
+      evictToRecoverBytes(bytesToRecover);
+
+      if (headerCount + 1 > dynamicTable.length) { // Need to grow the dynamic table.
+        Header[] doubled = new Header[dynamicTable.length * 2];
+        System.arraycopy(dynamicTable, 0, doubled, dynamicTable.length, dynamicTable.length);
+        nextHeaderIndex = dynamicTable.length - 1;
+        dynamicTable = doubled;
+      }
+      int index = nextHeaderIndex--;
+      dynamicTable[index] = entry;
+      headerCount++;
+      dynamicTableByteCount += delta;
+    }
+
+    /** This does not use "never indexed" semantics for sensitive headers. */
+    // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-6.2.3
+    void writeHeaders(List<Header> headerBlock) throws IOException {
+      if (emitDynamicTableSizeUpdate) {
+        if (smallestHeaderTableSizeSetting < maxDynamicTableByteCount) {
+          // Multiple dynamic table size updates!
+          writeInt(smallestHeaderTableSizeSetting, PREFIX_5_BITS, 0x20);
+        }
+        emitDynamicTableSizeUpdate = false;
+        smallestHeaderTableSizeSetting = Integer.MAX_VALUE;
+        writeInt(maxDynamicTableByteCount, PREFIX_5_BITS, 0x20);
+      }
+
+      for (int i = 0, size = headerBlock.size(); i < size; i++) {
+        Header header = headerBlock.get(i);
+        ByteString name = header.name.toAsciiLowercase();
+        ByteString value = header.value;
+        int headerIndex = -1;
+        int headerNameIndex = -1;
+
+        Integer staticIndex = NAME_TO_FIRST_INDEX.get(name);
+        if (staticIndex != null) {
+          headerNameIndex = staticIndex + 1;
+          if (headerNameIndex > 1 && headerNameIndex < 8) {
+            // Only search a subset of the static header table. Most entries have an empty value, so
+            // it's unnecessary to waste cycles looking at them. This check is built on the
+            // observation that the header entries we care about are in adjacent pairs, and we
+            // always know the first index of the pair.
+            if (Util.equal(STATIC_HEADER_TABLE[headerNameIndex - 1].value, value)) {
+              headerIndex = headerNameIndex;
+            } else if (Util.equal(STATIC_HEADER_TABLE[headerNameIndex].value, value)) {
+              headerIndex = headerNameIndex + 1;
+            }
+          }
+        }
+
+        if (headerIndex == -1) {
+          for (int j = nextHeaderIndex + 1, length = dynamicTable.length; j < length; j++) {
+            if (Util.equal(dynamicTable[j].name, name)) {
+              if (Util.equal(dynamicTable[j].value, value)) {
+                headerIndex = j - nextHeaderIndex + STATIC_HEADER_TABLE.length;
+                break;
+              } else if (headerNameIndex == -1) {
+                headerNameIndex = j - nextHeaderIndex + STATIC_HEADER_TABLE.length;
+              }
+            }
+          }
+        }
+
+        if (headerIndex != -1) {
+          // Indexed Header Field.
+          writeInt(headerIndex, PREFIX_7_BITS, 0x80);
+        } else if (headerNameIndex == -1) {
+          // Literal Header Field with Incremental Indexing - New Name.
+          out.writeByte(0x40);
+          writeByteString(name);
+          writeByteString(value);
+          insertIntoDynamicTable(header);
+        } else if (name.startsWith(Header.PSEUDO_PREFIX) && !Header.TARGET_AUTHORITY.equals(name)) {
+          // Follow Chromes lead - only include the :authority pseudo header, but exclude all other
+          // pseudo headers. Literal Header Field without Indexing - Indexed Name.
+          writeInt(headerNameIndex, PREFIX_4_BITS, 0);
+          writeByteString(value);
+        } else {
+          // Literal Header Field with Incremental Indexing - Indexed Name.
+          writeInt(headerNameIndex, PREFIX_6_BITS, 0x40);
+          writeByteString(value);
+          insertIntoDynamicTable(header);
+        }
+      }
+    }
+
+    // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-4.1.1
+    void writeInt(int value, int prefixMask, int bits) {
+      // Write the raw value for a single byte value.
+      if (value < prefixMask) {
+        out.writeByte(bits | value);
+        return;
+      }
+
+      // Write the mask to start a multibyte value.
+      out.writeByte(bits | prefixMask);
+      value -= prefixMask;
+
+      // Write 7 bits at a time 'til we're done.
+      while (value >= 0x80) {
+        int b = value & 0x7f;
+        out.writeByte(b | 0x80);
+        value >>>= 7;
+      }
+      out.writeByte(value);
+    }
+
+    void writeByteString(ByteString data) throws IOException {
+      if (useCompression && Huffman.get().encodedLength(data) < data.size()) {
+        Buffer huffmanBuffer = new Buffer();
+        Huffman.get().encode(data, huffmanBuffer);
+        ByteString huffmanBytes = huffmanBuffer.readByteString();
+        writeInt(huffmanBytes.size(), PREFIX_7_BITS, 0x80);
+        out.write(huffmanBytes);
+      } else {
+        writeInt(data.size(), PREFIX_7_BITS, 0);
+        out.write(data);
+      }
+    }
+
+    void setHeaderTableSizeSetting(int headerTableSizeSetting) {
+      this.headerTableSizeSetting = headerTableSizeSetting;
+      int effectiveHeaderTableSize = Math.min(headerTableSizeSetting,
+          SETTINGS_HEADER_TABLE_SIZE_LIMIT);
+
+      if (maxDynamicTableByteCount == effectiveHeaderTableSize) return; // No change.
+
+      if (effectiveHeaderTableSize < maxDynamicTableByteCount) {
+        smallestHeaderTableSizeSetting = Math.min(smallestHeaderTableSizeSetting,
+            effectiveHeaderTableSize);
+      }
+      emitDynamicTableSizeUpdate = true;
+      maxDynamicTableByteCount = effectiveHeaderTableSize;
+      adjustDynamicTableByteCount();
+    }
+
+    private void adjustDynamicTableByteCount() {
+      if (maxDynamicTableByteCount < dynamicTableByteCount) {
+        if (maxDynamicTableByteCount == 0) {
+          clearDynamicTable();
+        } else {
+          evictToRecoverBytes(dynamicTableByteCount - maxDynamicTableByteCount);
+        }
+      }
+    }
+  }
+
+  /**
+   * An HTTP/2 response cannot contain uppercase header characters and must be treated as
+   * malformed.
+   */
+  static ByteString checkLowercase(ByteString name) throws IOException {
+    for (int i = 0, length = name.size(); i < length; i++) {
+      byte c = name.getByte(i);
+      if (c >= 'A' && c <= 'Z') {
+        throw new IOException("PROTOCOL_ERROR response malformed: mixed case name: " + name.utf8());
+      }
+    }
+    return name;
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2.java
new file mode 100644
index 0000000000..cecee406ce
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2.java
@@ -0,0 +1,167 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import java.io.IOException;
+import okio.ByteString;
+
+import static okhttp3.internal.Util.format;
+
+public final class Http2 {
+  static final ByteString CONNECTION_PREFACE
+      = ByteString.encodeUtf8("PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n");
+
+  /** The initial max frame size, applied independently writing to, or reading from the peer. */
+  static final int INITIAL_MAX_FRAME_SIZE = 0x4000; // 16384
+
+  static final byte TYPE_DATA = 0x0;
+  static final byte TYPE_HEADERS = 0x1;
+  static final byte TYPE_PRIORITY = 0x2;
+  static final byte TYPE_RST_STREAM = 0x3;
+  static final byte TYPE_SETTINGS = 0x4;
+  static final byte TYPE_PUSH_PROMISE = 0x5;
+  static final byte TYPE_PING = 0x6;
+  static final byte TYPE_GOAWAY = 0x7;
+  static final byte TYPE_WINDOW_UPDATE = 0x8;
+  static final byte TYPE_CONTINUATION = 0x9;
+
+  static final byte FLAG_NONE = 0x0;
+  static final byte FLAG_ACK = 0x1; // Used for settings and ping.
+  static final byte FLAG_END_STREAM = 0x1; // Used for headers and data.
+  static final byte FLAG_END_HEADERS = 0x4; // Used for headers and continuation.
+  static final byte FLAG_END_PUSH_PROMISE = 0x4;
+  static final byte FLAG_PADDED = 0x8; // Used for headers and data.
+  static final byte FLAG_PRIORITY = 0x20; // Used for headers.
+  static final byte FLAG_COMPRESSED = 0x20; // Used for data.
+
+  /** Lookup table for valid frame types. */
+  private static final String[] FRAME_NAMES = new String[] {
+      "DATA",
+      "HEADERS",
+      "PRIORITY",
+      "RST_STREAM",
+      "SETTINGS",
+      "PUSH_PROMISE",
+      "PING",
+      "GOAWAY",
+      "WINDOW_UPDATE",
+      "CONTINUATION"
+  };
+
+  /**
+   * Lookup table for valid flags for DATA, HEADERS, CONTINUATION. Invalid combinations are
+   * represented in binary.
+   */
+  static final String[] FLAGS = new String[0x40]; // Highest bit flag is 0x20.
+  static final String[] BINARY = new String[256];
+  static {
+    for (int i = 0; i < BINARY.length; i++) {
+      BINARY[i] = format("%8s", Integer.toBinaryString(i)).replace(' ', '0');
+    }
+
+    FLAGS[FLAG_NONE] = "";
+    FLAGS[FLAG_END_STREAM] = "END_STREAM";
+
+    int[] prefixFlags = new int[] {FLAG_END_STREAM};
+
+    FLAGS[FLAG_PADDED] = "PADDED";
+    for (int prefixFlag : prefixFlags) {
+      FLAGS[prefixFlag | FLAG_PADDED] = FLAGS[prefixFlag] + "|PADDED";
+    }
+
+    FLAGS[FLAG_END_HEADERS] = "END_HEADERS"; // Same as END_PUSH_PROMISE.
+    FLAGS[FLAG_PRIORITY] = "PRIORITY"; // Same as FLAG_COMPRESSED.
+    FLAGS[FLAG_END_HEADERS | FLAG_PRIORITY] = "END_HEADERS|PRIORITY"; // Only valid on HEADERS.
+    int[] frameFlags = new int[] {
+        FLAG_END_HEADERS, FLAG_PRIORITY, FLAG_END_HEADERS | FLAG_PRIORITY
+    };
+
+    for (int frameFlag : frameFlags) {
+      for (int prefixFlag : prefixFlags) {
+        FLAGS[prefixFlag | frameFlag] = FLAGS[prefixFlag] + '|' + FLAGS[frameFlag];
+        FLAGS[prefixFlag | frameFlag | FLAG_PADDED]
+            = FLAGS[prefixFlag] + '|' + FLAGS[frameFlag] + "|PADDED";
+      }
+    }
+
+    for (int i = 0; i < FLAGS.length; i++) { // Fill in holes with binary representation.
+      if (FLAGS[i] == null) FLAGS[i] = BINARY[i];
+    }
+  }
+
+  private Http2() {
+  }
+
+  static IllegalArgumentException illegalArgument(String message, Object... args) {
+    throw new IllegalArgumentException(format(message, args));
+  }
+
+  static IOException ioException(String message, Object... args) throws IOException {
+    throw new IOException(format(message, args));
+  }
+
+  /**
+   * Returns human-readable representation of HTTP/2 frame headers.
+   *
+   * <p>The format is:
+   *
+   * <pre>
+   *   direction streamID length type flags
+   * </pre>
+   *
+   * Where direction is {@code <<} for inbound and {@code >>} for outbound.
+   *
+   * <p>For example, the following would indicate a HEAD request sent from the client.
+   * <pre>
+   * {@code
+   *   << 0x0000000f    12 HEADERS       END_HEADERS|END_STREAM
+   * }
+   * </pre>
+   */
+  static String frameLog(boolean inbound, int streamId, int length, byte type, byte flags) {
+    String formattedType = type < FRAME_NAMES.length ? FRAME_NAMES[type] : format("0x%02x", type);
+    String formattedFlags = formatFlags(type, flags);
+    return format("%s 0x%08x %5d %-13s %s", inbound ? "<<" : ">>", streamId, length,
+        formattedType, formattedFlags);
+  }
+
+  /**
+   * Looks up valid string representing flags from the table. Invalid combinations are represented
+   * in binary.
+   */
+  // Visible for testing.
+  static String formatFlags(byte type, byte flags) {
+    if (flags == 0) return "";
+    switch (type) { // Special case types that have 0 or 1 flag.
+      case TYPE_SETTINGS:
+      case TYPE_PING:
+        return flags == FLAG_ACK ? "ACK" : BINARY[flags];
+      case TYPE_PRIORITY:
+      case TYPE_RST_STREAM:
+      case TYPE_GOAWAY:
+      case TYPE_WINDOW_UPDATE:
+        return BINARY[flags];
+    }
+    String result = flags < FLAGS.length ? FLAGS[flags] : BINARY[flags];
+    // Special case types that have overlap flag values.
+    if (type == TYPE_PUSH_PROMISE && (flags & FLAG_END_PUSH_PROMISE) != 0) {
+      return result.replace("HEADERS", "PUSH_PROMISE"); // TODO: Avoid allocation.
+    } else if (type == TYPE_DATA && (flags & FLAG_COMPRESSED) != 0) {
+      return result.replace("PRIORITY", "COMPRESSED"); // TODO: Avoid allocation.
+    }
+    return result;
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
new file mode 100644
index 0000000000..5268aa2c91
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
@@ -0,0 +1,232 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Locale;
+import java.util.concurrent.TimeUnit;
+import okhttp3.Headers;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.Internal;
+import okhttp3.internal.Util;
+import okhttp3.internal.connection.StreamAllocation;
+import okhttp3.internal.http.HttpCodec;
+import okhttp3.internal.http.HttpHeaders;
+import okhttp3.internal.http.RealResponseBody;
+import okhttp3.internal.http.RequestLine;
+import okhttp3.internal.http.StatusLine;
+import okio.Buffer;
+import okio.ByteString;
+import okio.ForwardingSource;
+import okio.Okio;
+import okio.Sink;
+import okio.Source;
+
+import static okhttp3.internal.http.StatusLine.HTTP_CONTINUE;
+import static okhttp3.internal.http2.Header.RESPONSE_STATUS;
+import static okhttp3.internal.http2.Header.TARGET_AUTHORITY;
+import static okhttp3.internal.http2.Header.TARGET_METHOD;
+import static okhttp3.internal.http2.Header.TARGET_PATH;
+import static okhttp3.internal.http2.Header.TARGET_SCHEME;
+
+/** Encode requests and responses using HTTP/2 frames. */
+public final class Http2Codec implements HttpCodec {
+  private static final ByteString CONNECTION = ByteString.encodeUtf8("connection");
+  private static final ByteString HOST = ByteString.encodeUtf8("host");
+  private static final ByteString KEEP_ALIVE = ByteString.encodeUtf8("keep-alive");
+  private static final ByteString PROXY_CONNECTION = ByteString.encodeUtf8("proxy-connection");
+  private static final ByteString TRANSFER_ENCODING = ByteString.encodeUtf8("transfer-encoding");
+  private static final ByteString TE = ByteString.encodeUtf8("te");
+  private static final ByteString ENCODING = ByteString.encodeUtf8("encoding");
+  private static final ByteString UPGRADE = ByteString.encodeUtf8("upgrade");
+
+  /** See http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-8.1.3. */
+  private static final List<ByteString> HTTP_2_SKIPPED_REQUEST_HEADERS = Util.immutableList(
+      CONNECTION,
+      HOST,
+      KEEP_ALIVE,
+      PROXY_CONNECTION,
+      TE,
+      TRANSFER_ENCODING,
+      ENCODING,
+      UPGRADE,
+      TARGET_METHOD,
+      TARGET_PATH,
+      TARGET_SCHEME,
+      TARGET_AUTHORITY);
+  private static final List<ByteString> HTTP_2_SKIPPED_RESPONSE_HEADERS = Util.immutableList(
+      CONNECTION,
+      HOST,
+      KEEP_ALIVE,
+      PROXY_CONNECTION,
+      TE,
+      TRANSFER_ENCODING,
+      ENCODING,
+      UPGRADE);
+
+  private final OkHttpClient client;
+  private final Interceptor.Chain chain;
+  final StreamAllocation streamAllocation;
+  private final Http2Connection connection;
+  private Http2Stream stream;
+
+  public Http2Codec(OkHttpClient client, Interceptor.Chain chain, StreamAllocation streamAllocation,
+      Http2Connection connection) {
+    this.client = client;
+    this.chain = chain;
+    this.streamAllocation = streamAllocation;
+    this.connection = connection;
+  }
+
+  @Override public Sink createRequestBody(Request request, long contentLength) {
+    return stream.getSink();
+  }
+
+  @Override public void writeRequestHeaders(Request request) throws IOException {
+    if (stream != null) return;
+
+    boolean hasRequestBody = request.body() != null;
+    List<Header> requestHeaders = http2HeadersList(request);
+    stream = connection.newStream(requestHeaders, hasRequestBody);
+    stream.readTimeout().timeout(chain.readTimeoutMillis(), TimeUnit.MILLISECONDS);
+    stream.writeTimeout().timeout(chain.writeTimeoutMillis(), TimeUnit.MILLISECONDS);
+  }
+
+  @Override public void flushRequest() throws IOException {
+    connection.flush();
+  }
+
+  @Override public void finishRequest() throws IOException {
+    stream.getSink().close();
+  }
+
+  @Override public Response.Builder readResponseHeaders(boolean expectContinue) throws IOException {
+    List<Header> headers = stream.takeResponseHeaders();
+    Response.Builder responseBuilder = readHttp2HeadersList(headers);
+    if (expectContinue && Internal.instance.code(responseBuilder) == HTTP_CONTINUE) {
+      return null;
+    }
+    return responseBuilder;
+  }
+
+  public static List<Header> http2HeadersList(Request request) {
+    Headers headers = request.headers();
+    List<Header> result = new ArrayList<>(headers.size() + 4);
+    result.add(new Header(TARGET_METHOD, request.method()));
+    result.add(new Header(TARGET_PATH, RequestLine.requestPath(request.url())));
+    String host = request.header("Host");
+    if (host != null) {
+      result.add(new Header(TARGET_AUTHORITY, host)); // Optional.
+    }
+    result.add(new Header(TARGET_SCHEME, request.url().scheme()));
+
+    for (int i = 0, size = headers.size(); i < size; i++) {
+      // header names must be lowercase.
+      ByteString name = ByteString.encodeUtf8(headers.name(i).toLowerCase(Locale.US));
+      if (!HTTP_2_SKIPPED_REQUEST_HEADERS.contains(name)) {
+        result.add(new Header(name, headers.value(i)));
+      }
+    }
+    return result;
+  }
+
+  /** Returns headers for a name value block containing an HTTP/2 response. */
+  public static Response.Builder readHttp2HeadersList(List<Header> headerBlock) throws IOException {
+    StatusLine statusLine = null;
+    Headers.Builder headersBuilder = new Headers.Builder();
+    for (int i = 0, size = headerBlock.size(); i < size; i++) {
+      Header header = headerBlock.get(i);
+
+      // If there were multiple header blocks they will be delimited by nulls. Discard existing
+      // header blocks if the existing header block is a '100 Continue' intermediate response.
+      if (header == null) {
+        if (statusLine != null && statusLine.code == HTTP_CONTINUE) {
+          statusLine = null;
+          headersBuilder = new Headers.Builder();
+        }
+        continue;
+      }
+
+      ByteString name = header.name;
+      String value = header.value.utf8();
+      if (name.equals(RESPONSE_STATUS)) {
+        statusLine = StatusLine.parse("HTTP/1.1 " + value);
+      } else if (!HTTP_2_SKIPPED_RESPONSE_HEADERS.contains(name)) {
+        Internal.instance.addLenient(headersBuilder, name.utf8(), value);
+      }
+    }
+    if (statusLine == null) throw new ProtocolException("Expected ':status' header not present");
+
+    return new Response.Builder()
+        .protocol(Protocol.HTTP_2)
+        .code(statusLine.code)
+        .message(statusLine.message)
+        .headers(headersBuilder.build());
+  }
+
+  @Override public ResponseBody openResponseBody(Response response) throws IOException {
+    streamAllocation.eventListener.responseBodyStart(streamAllocation.call);
+    String contentType = response.header("Content-Type");
+    long contentLength = HttpHeaders.contentLength(response);
+    Source source = new StreamFinishingSource(stream.getSource());
+    return new RealResponseBody(contentType, contentLength, Okio.buffer(source));
+  }
+
+  @Override public void cancel() {
+    if (stream != null) stream.closeLater(ErrorCode.CANCEL);
+  }
+
+  class StreamFinishingSource extends ForwardingSource {
+    boolean completed = false;
+    long bytesRead = 0;
+
+    StreamFinishingSource(Source delegate) {
+      super(delegate);
+    }
+
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
+      try {
+        long read = delegate().read(sink, byteCount);
+        if (read > 0) {
+          bytesRead += read;
+        }
+        return read;
+      } catch (IOException e) {
+        endOfInput(e);
+        throw e;
+      }
+    }
+
+    @Override public void close() throws IOException {
+      super.close();
+      endOfInput(null);
+    }
+
+    private void endOfInput(IOException e) {
+      if (completed) return;
+      completed = true;
+      streamAllocation.streamFinished(false, Http2Codec.this, bytesRead, e);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
new file mode 100644
index 0000000000..a79b3b7608
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
@@ -0,0 +1,884 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.net.InetSocketAddress;
+import java.net.Socket;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.SynchronousQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import okhttp3.Protocol;
+import okhttp3.internal.NamedRunnable;
+import okhttp3.internal.Util;
+import okhttp3.internal.platform.Platform;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.Okio;
+
+import static okhttp3.internal.http2.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
+import static okhttp3.internal.platform.Platform.INFO;
+
+/**
+ * A socket connection to a remote peer. A connection hosts streams which can send and receive
+ * data.
+ *
+ * <p>Many methods in this API are <strong>synchronous:</strong> the call is completed before the
+ * method returns. This is typical for Java but atypical for HTTP/2. This is motivated by exception
+ * transparency: an IOException that was triggered by a certain caller can be caught and handled by
+ * that caller.
+ */
+public final class Http2Connection implements Closeable {
+
+  // Internal state of this connection is guarded by 'this'. No blocking
+  // operations may be performed while holding this lock!
+  //
+  // Socket writes are guarded by frameWriter.
+  //
+  // Socket reads are unguarded but are only made by the reader thread.
+  //
+  // Certain operations (like SYN_STREAM) need to synchronize on both the
+  // frameWriter (to do blocking I/O) and this (to create streams). Such
+  // operations must synchronize on 'this' last. This ensures that we never
+  // wait for a blocking operation while holding 'this'.
+
+  static final ExecutorService executor = new ThreadPoolExecutor(0,
+      Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),
+      Util.threadFactory("OkHttp Http2Connection", true));
+
+  /** True if this peer initiated the connection. */
+  final boolean client;
+
+  /**
+   * User code to run in response to incoming streams or settings. Calls to this are always invoked
+   * on {@link #executor}.
+   */
+  final Listener listener;
+  final Map<Integer, Http2Stream> streams = new LinkedHashMap<>();
+  final String hostname;
+  int lastGoodStreamId;
+  int nextStreamId;
+  boolean shutdown;
+
+  /** Ensures push promise callbacks events are sent in order per stream. */
+  private final ExecutorService pushExecutor;
+
+  /** Lazily-created map of in-flight pings awaiting a response. Guarded by this. */
+  private Map<Integer, Ping> pings;
+  /** User code to run in response to push promise events. */
+  final PushObserver pushObserver;
+  private int nextPingId;
+
+  /**
+   * The total number of bytes consumed by the application, but not yet acknowledged by sending a
+   * {@code WINDOW_UPDATE} frame on this connection.
+   */
+  // Visible for testing
+  long unacknowledgedBytesRead = 0;
+
+  /**
+   * Count of bytes that can be written on the connection before receiving a window update.
+   */
+  // Visible for testing
+  long bytesLeftInWriteWindow;
+
+  /** Settings we communicate to the peer. */
+  Settings okHttpSettings = new Settings();
+
+  private static final int OKHTTP_CLIENT_WINDOW_SIZE = 16 * 1024 * 1024;
+
+  /** Settings we receive from the peer. */
+  // TODO: MWS will need to guard on this setting before attempting to push.
+  final Settings peerSettings = new Settings();
+
+  boolean receivedInitialPeerSettings = false;
+  final Socket socket;
+  final Http2Writer writer;
+
+  // Visible for testing
+  final ReaderRunnable readerRunnable;
+
+  Http2Connection(Builder builder) {
+    pushObserver = builder.pushObserver;
+    client = builder.client;
+    listener = builder.listener;
+    // http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-5.1.1
+    nextStreamId = builder.client ? 1 : 2;
+    if (builder.client) {
+      nextStreamId += 2; // In HTTP/2, 1 on client is reserved for Upgrade.
+    }
+
+    nextPingId = builder.client ? 1 : 2;
+
+    // Flow control was designed more for servers, or proxies than edge clients.
+    // If we are a client, set the flow control window to 16MiB.  This avoids
+    // thrashing window updates every 64KiB, yet small enough to avoid blowing
+    // up the heap.
+    if (builder.client) {
+      okHttpSettings.set(Settings.INITIAL_WINDOW_SIZE, OKHTTP_CLIENT_WINDOW_SIZE);
+    }
+
+    hostname = builder.hostname;
+
+    // Like newSingleThreadExecutor, except lazy creates the thread.
+    pushExecutor = new ThreadPoolExecutor(0, 1, 60, TimeUnit.SECONDS,
+        new LinkedBlockingQueue<Runnable>(),
+        Util.threadFactory(Util.format("OkHttp %s Push Observer", hostname), true));
+    peerSettings.set(Settings.INITIAL_WINDOW_SIZE, DEFAULT_INITIAL_WINDOW_SIZE);
+    peerSettings.set(Settings.MAX_FRAME_SIZE, Http2.INITIAL_MAX_FRAME_SIZE);
+    bytesLeftInWriteWindow = peerSettings.getInitialWindowSize();
+    socket = builder.socket;
+    writer = new Http2Writer(builder.sink, client);
+
+    readerRunnable = new ReaderRunnable(new Http2Reader(builder.source, client));
+  }
+
+  /** The protocol as selected using ALPN. */
+  public Protocol getProtocol() {
+    return Protocol.HTTP_2;
+  }
+
+  /**
+   * Returns the number of {@link Http2Stream#isOpen() open streams} on this connection.
+   */
+  public synchronized int openStreamCount() {
+    return streams.size();
+  }
+
+  synchronized Http2Stream getStream(int id) {
+    return streams.get(id);
+  }
+
+  synchronized Http2Stream removeStream(int streamId) {
+    Http2Stream stream = streams.remove(streamId);
+    notifyAll(); // The removed stream may be blocked on a connection-wide window update.
+    return stream;
+  }
+
+  public synchronized int maxConcurrentStreams() {
+    return peerSettings.getMaxConcurrentStreams(Integer.MAX_VALUE);
+  }
+
+  /**
+   * Returns a new server-initiated stream.
+   *
+   * @param associatedStreamId the stream that triggered the sender to create this stream.
+   * @param out true to create an output stream that we can use to send data to the remote peer.
+   * Corresponds to {@code FLAG_FIN}.
+   */
+  public Http2Stream pushStream(int associatedStreamId, List<Header> requestHeaders, boolean out)
+      throws IOException {
+    if (client) throw new IllegalStateException("Client cannot push requests.");
+    return newStream(associatedStreamId, requestHeaders, out);
+  }
+
+  /**
+   * Returns a new locally-initiated stream.
+   * @param out true to create an output stream that we can use to send data to the remote peer.
+   * Corresponds to {@code FLAG_FIN}.
+   */
+  public Http2Stream newStream(List<Header> requestHeaders, boolean out) throws IOException {
+    return newStream(0, requestHeaders, out);
+  }
+
+  private Http2Stream newStream(
+      int associatedStreamId, List<Header> requestHeaders, boolean out) throws IOException {
+    boolean outFinished = !out;
+    boolean inFinished = false;
+    boolean flushHeaders;
+    Http2Stream stream;
+    int streamId;
+
+    synchronized (writer) {
+      synchronized (this) {
+        if (shutdown) {
+          throw new ConnectionShutdownException();
+        }
+        streamId = nextStreamId;
+        nextStreamId += 2;
+        stream = new Http2Stream(streamId, this, outFinished, inFinished, requestHeaders);
+        flushHeaders = !out || bytesLeftInWriteWindow == 0L || stream.bytesLeftInWriteWindow == 0L;
+        if (stream.isOpen()) {
+          streams.put(streamId, stream);
+        }
+      }
+      if (associatedStreamId == 0) {
+        writer.synStream(outFinished, streamId, associatedStreamId, requestHeaders);
+      } else if (client) {
+        throw new IllegalArgumentException("client streams shouldn't have associated stream IDs");
+      } else { // HTTP/2 has a PUSH_PROMISE frame.
+        writer.pushPromise(associatedStreamId, streamId, requestHeaders);
+      }
+    }
+
+    if (flushHeaders) {
+      writer.flush();
+    }
+
+    return stream;
+  }
+
+  void writeSynReply(int streamId, boolean outFinished, List<Header> alternating)
+      throws IOException {
+    writer.synReply(outFinished, streamId, alternating);
+  }
+
+  /**
+   * Callers of this method are not thread safe, and sometimes on application threads. Most often,
+   * this method will be called to send a buffer worth of data to the peer.
+   *
+   * <p>Writes are subject to the write window of the stream and the connection. Until there is a
+   * window sufficient to send {@code byteCount}, the caller will block. For example, a user of
+   * {@code HttpURLConnection} who flushes more bytes to the output stream than the connection's
+   * write window will block.
+   *
+   * <p>Zero {@code byteCount} writes are not subject to flow control and will not block. The only
+   * use case for zero {@code byteCount} is closing a flushed output stream.
+   */
+  public void writeData(int streamId, boolean outFinished, Buffer buffer, long byteCount)
+      throws IOException {
+    if (byteCount == 0) { // Empty data frames are not flow-controlled.
+      writer.data(outFinished, streamId, buffer, 0);
+      return;
+    }
+
+    while (byteCount > 0) {
+      int toWrite;
+      synchronized (Http2Connection.this) {
+        try {
+          while (bytesLeftInWriteWindow <= 0) {
+            // Before blocking, confirm that the stream we're writing is still open. It's possible
+            // that the stream has since been closed (such as if this write timed out.)
+            if (!streams.containsKey(streamId)) {
+              throw new IOException("stream closed");
+            }
+            Http2Connection.this.wait(); // Wait until we receive a WINDOW_UPDATE.
+          }
+        } catch (InterruptedException e) {
+          throw new InterruptedIOException();
+        }
+
+        toWrite = (int) Math.min(byteCount, bytesLeftInWriteWindow);
+        toWrite = Math.min(toWrite, writer.maxDataLength());
+        bytesLeftInWriteWindow -= toWrite;
+      }
+
+      byteCount -= toWrite;
+      writer.data(outFinished && byteCount == 0, streamId, buffer, toWrite);
+    }
+  }
+
+  /**
+   * {@code delta} will be negative if a settings frame initial window is smaller than the last.
+   */
+  void addBytesToWriteWindow(long delta) {
+    bytesLeftInWriteWindow += delta;
+    if (delta > 0) Http2Connection.this.notifyAll();
+  }
+
+  void writeSynResetLater(final int streamId, final ErrorCode errorCode) {
+    executor.execute(new NamedRunnable("OkHttp %s stream %d", hostname, streamId) {
+      @Override public void execute() {
+        try {
+          writeSynReset(streamId, errorCode);
+        } catch (IOException ignored) {
+        }
+      }
+    });
+  }
+
+  void writeSynReset(int streamId, ErrorCode statusCode) throws IOException {
+    writer.rstStream(streamId, statusCode);
+  }
+
+  void writeWindowUpdateLater(final int streamId, final long unacknowledgedBytesRead) {
+    executor.execute(new NamedRunnable("OkHttp Window Update %s stream %d", hostname, streamId) {
+      @Override public void execute() {
+        try {
+          writer.windowUpdate(streamId, unacknowledgedBytesRead);
+        } catch (IOException ignored) {
+        }
+      }
+    });
+  }
+
+  /**
+   * Sends a ping frame to the peer. Use the returned object to await the ping's response and
+   * observe its round trip time.
+   */
+  public Ping ping() throws IOException {
+    Ping ping = new Ping();
+    int pingId;
+    synchronized (this) {
+      if (shutdown) {
+        throw new ConnectionShutdownException();
+      }
+      pingId = nextPingId;
+      nextPingId += 2;
+      if (pings == null) pings = new LinkedHashMap<>();
+      pings.put(pingId, ping);
+    }
+    writePing(false, pingId, 0x4f4b6f6b /* ASCII "OKok" */, ping);
+    return ping;
+  }
+
+  void writePingLater(
+      final boolean reply, final int payload1, final int payload2, final Ping ping) {
+    executor.execute(new NamedRunnable("OkHttp %s ping %08x%08x",
+        hostname, payload1, payload2) {
+      @Override public void execute() {
+        try {
+          writePing(reply, payload1, payload2, ping);
+        } catch (IOException ignored) {
+        }
+      }
+    });
+  }
+
+  void writePing(boolean reply, int payload1, int payload2, Ping ping) throws IOException {
+    synchronized (writer) {
+      // Observe the sent time immediately before performing I/O.
+      if (ping != null) ping.send();
+      writer.ping(reply, payload1, payload2);
+    }
+  }
+
+  synchronized Ping removePing(int id) {
+    return pings != null ? pings.remove(id) : null;
+  }
+
+  public void flush() throws IOException {
+    writer.flush();
+  }
+
+  /**
+   * Degrades this connection such that new streams can neither be created locally, nor accepted
+   * from the remote peer. Existing streams are not impacted. This is intended to permit an endpoint
+   * to gracefully stop accepting new requests without harming previously established streams.
+   */
+  public void shutdown(ErrorCode statusCode) throws IOException {
+    synchronized (writer) {
+      int lastGoodStreamId;
+      synchronized (this) {
+        if (shutdown) {
+          return;
+        }
+        shutdown = true;
+        lastGoodStreamId = this.lastGoodStreamId;
+      }
+      // TODO: propagate exception message into debugData.
+      // TODO: configure a timeout on the reader so that it doesn’t block forever.
+      writer.goAway(lastGoodStreamId, statusCode, Util.EMPTY_BYTE_ARRAY);
+    }
+  }
+
+  /**
+   * Closes this connection. This cancels all open streams and unanswered pings. It closes the
+   * underlying input and output streams and shuts down internal executor services.
+   */
+  @Override public void close() throws IOException {
+    close(ErrorCode.NO_ERROR, ErrorCode.CANCEL);
+  }
+
+  void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOException {
+    assert (!Thread.holdsLock(this));
+    IOException thrown = null;
+    try {
+      shutdown(connectionCode);
+    } catch (IOException e) {
+      thrown = e;
+    }
+
+    Http2Stream[] streamsToClose = null;
+    Ping[] pingsToCancel = null;
+    synchronized (this) {
+      if (!streams.isEmpty()) {
+        streamsToClose = streams.values().toArray(new Http2Stream[streams.size()]);
+        streams.clear();
+      }
+      if (pings != null) {
+        pingsToCancel = pings.values().toArray(new Ping[pings.size()]);
+        pings = null;
+      }
+    }
+
+    if (streamsToClose != null) {
+      for (Http2Stream stream : streamsToClose) {
+        try {
+          stream.close(streamCode);
+        } catch (IOException e) {
+          if (thrown != null) thrown = e;
+        }
+      }
+    }
+
+    if (pingsToCancel != null) {
+      for (Ping ping : pingsToCancel) {
+        ping.cancel();
+      }
+    }
+
+    // Close the writer to release its resources (such as deflaters).
+    try {
+      writer.close();
+    } catch (IOException e) {
+      if (thrown == null) thrown = e;
+    }
+
+    // Close the socket to break out the reader thread, which will clean up after itself.
+    try {
+      socket.close();
+    } catch (IOException e) {
+      thrown = e;
+    }
+
+    if (thrown != null) throw thrown;
+  }
+
+  /**
+   * Sends any initial frames and starts reading frames from the remote peer. This should be called
+   * after {@link Builder#build} for all new connections.
+   */
+  public void start() throws IOException {
+    start(true);
+  }
+
+  /**
+   * @param sendConnectionPreface true to send connection preface frames. This should always be true
+   *     except for in tests that don't check for a connection preface.
+   */
+  void start(boolean sendConnectionPreface) throws IOException {
+    if (sendConnectionPreface) {
+      writer.connectionPreface();
+      writer.settings(okHttpSettings);
+      int windowSize = okHttpSettings.getInitialWindowSize();
+      if (windowSize != Settings.DEFAULT_INITIAL_WINDOW_SIZE) {
+        writer.windowUpdate(0, windowSize - Settings.DEFAULT_INITIAL_WINDOW_SIZE);
+      }
+    }
+    new Thread(readerRunnable).start(); // Not a daemon thread.
+  }
+
+  /** Merges {@code settings} into this peer's settings and sends them to the remote peer. */
+  public void setSettings(Settings settings) throws IOException {
+    synchronized (writer) {
+      synchronized (this) {
+        if (shutdown) {
+          throw new ConnectionShutdownException();
+        }
+        okHttpSettings.merge(settings);
+        writer.settings(settings);
+      }
+    }
+  }
+
+  public synchronized boolean isShutdown() {
+    return shutdown;
+  }
+
+  public static class Builder {
+    Socket socket;
+    String hostname;
+    BufferedSource source;
+    BufferedSink sink;
+    Listener listener = Listener.REFUSE_INCOMING_STREAMS;
+    PushObserver pushObserver = PushObserver.CANCEL;
+    boolean client;
+
+    /**
+     * @param client true if this peer initiated the connection; false if this peer accepted the
+     * connection.
+     */
+    public Builder(boolean client) {
+      this.client = client;
+    }
+
+    public Builder socket(Socket socket) throws IOException {
+      return socket(socket, ((InetSocketAddress) socket.getRemoteSocketAddress()).getHostName(),
+          Okio.buffer(Okio.source(socket)), Okio.buffer(Okio.sink(socket)));
+    }
+
+    public Builder socket(
+        Socket socket, String hostname, BufferedSource source, BufferedSink sink) {
+      this.socket = socket;
+      this.hostname = hostname;
+      this.source = source;
+      this.sink = sink;
+      return this;
+    }
+
+    public Builder listener(Listener listener) {
+      this.listener = listener;
+      return this;
+    }
+
+    public Builder pushObserver(PushObserver pushObserver) {
+      this.pushObserver = pushObserver;
+      return this;
+    }
+
+    public Http2Connection build() {
+      return new Http2Connection(this);
+    }
+  }
+
+  /**
+   * Methods in this class must not lock FrameWriter.  If a method needs to write a frame, create an
+   * async task to do so.
+   */
+  class ReaderRunnable extends NamedRunnable implements Http2Reader.Handler {
+    final Http2Reader reader;
+
+    ReaderRunnable(Http2Reader reader) {
+      super("OkHttp %s", hostname);
+      this.reader = reader;
+    }
+
+    @Override protected void execute() {
+      ErrorCode connectionErrorCode = ErrorCode.INTERNAL_ERROR;
+      ErrorCode streamErrorCode = ErrorCode.INTERNAL_ERROR;
+      try {
+        reader.readConnectionPreface(this);
+        while (reader.nextFrame(false, this)) {
+        }
+        connectionErrorCode = ErrorCode.NO_ERROR;
+        streamErrorCode = ErrorCode.CANCEL;
+      } catch (IOException e) {
+        connectionErrorCode = ErrorCode.PROTOCOL_ERROR;
+        streamErrorCode = ErrorCode.PROTOCOL_ERROR;
+      } finally {
+        try {
+          close(connectionErrorCode, streamErrorCode);
+        } catch (IOException ignored) {
+        }
+        Util.closeQuietly(reader);
+      }
+    }
+
+    @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
+        throws IOException {
+      if (pushedStream(streamId)) {
+        pushDataLater(streamId, source, length, inFinished);
+        return;
+      }
+      Http2Stream dataStream = getStream(streamId);
+      if (dataStream == null) {
+        writeSynResetLater(streamId, ErrorCode.PROTOCOL_ERROR);
+        source.skip(length);
+        return;
+      }
+      dataStream.receiveData(source, length);
+      if (inFinished) {
+        dataStream.receiveFin();
+      }
+    }
+
+    @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,
+        List<Header> headerBlock) {
+      if (pushedStream(streamId)) {
+        pushHeadersLater(streamId, headerBlock, inFinished);
+        return;
+      }
+      Http2Stream stream;
+      synchronized (Http2Connection.this) {
+        stream = getStream(streamId);
+
+        if (stream == null) {
+          // If we're shutdown, don't bother with this stream.
+          if (shutdown) return;
+
+          // If the stream ID is less than the last created ID, assume it's already closed.
+          if (streamId <= lastGoodStreamId) return;
+
+          // If the stream ID is in the client's namespace, assume it's already closed.
+          if (streamId % 2 == nextStreamId % 2) return;
+
+          // Create a stream.
+          final Http2Stream newStream = new Http2Stream(streamId, Http2Connection.this,
+              false, inFinished, headerBlock);
+          lastGoodStreamId = streamId;
+          streams.put(streamId, newStream);
+          executor.execute(new NamedRunnable("OkHttp %s stream %d", hostname, streamId) {
+            @Override public void execute() {
+              try {
+                listener.onStream(newStream);
+              } catch (IOException e) {
+                Platform.get().log(INFO, "Http2Connection.Listener failure for " + hostname, e);
+                try {
+                  newStream.close(ErrorCode.PROTOCOL_ERROR);
+                } catch (IOException ignored) {
+                }
+              }
+            }
+          });
+          return;
+        }
+      }
+
+      // Update an existing stream.
+      stream.receiveHeaders(headerBlock);
+      if (inFinished) stream.receiveFin();
+    }
+
+    @Override public void rstStream(int streamId, ErrorCode errorCode) {
+      if (pushedStream(streamId)) {
+        pushResetLater(streamId, errorCode);
+        return;
+      }
+      Http2Stream rstStream = removeStream(streamId);
+      if (rstStream != null) {
+        rstStream.receiveRstStream(errorCode);
+      }
+    }
+
+    @Override public void settings(boolean clearPrevious, Settings newSettings) {
+      long delta = 0;
+      Http2Stream[] streamsToNotify = null;
+      synchronized (Http2Connection.this) {
+        int priorWriteWindowSize = peerSettings.getInitialWindowSize();
+        if (clearPrevious) peerSettings.clear();
+        peerSettings.merge(newSettings);
+        applyAndAckSettings(newSettings);
+        int peerInitialWindowSize = peerSettings.getInitialWindowSize();
+        if (peerInitialWindowSize != -1 && peerInitialWindowSize != priorWriteWindowSize) {
+          delta = peerInitialWindowSize - priorWriteWindowSize;
+          if (!receivedInitialPeerSettings) {
+            addBytesToWriteWindow(delta);
+            receivedInitialPeerSettings = true;
+          }
+          if (!streams.isEmpty()) {
+            streamsToNotify = streams.values().toArray(new Http2Stream[streams.size()]);
+          }
+        }
+        executor.execute(new NamedRunnable("OkHttp %s settings", hostname) {
+          @Override public void execute() {
+            listener.onSettings(Http2Connection.this);
+          }
+        });
+      }
+      if (streamsToNotify != null && delta != 0) {
+        for (Http2Stream stream : streamsToNotify) {
+          synchronized (stream) {
+            stream.addBytesToWriteWindow(delta);
+          }
+        }
+      }
+    }
+
+    private void applyAndAckSettings(final Settings peerSettings) {
+      executor.execute(new NamedRunnable("OkHttp %s ACK Settings", hostname) {
+        @Override public void execute() {
+          try {
+            writer.applyAndAckSettings(peerSettings);
+          } catch (IOException ignored) {
+          }
+        }
+      });
+    }
+
+    @Override public void ackSettings() {
+      // TODO: If we don't get this callback after sending settings to the peer, SETTINGS_TIMEOUT.
+    }
+
+    @Override public void ping(boolean reply, int payload1, int payload2) {
+      if (reply) {
+        Ping ping = removePing(payload1);
+        if (ping != null) {
+          ping.receive();
+        }
+      } else {
+        // Send a reply to a client ping if this is a server and vice versa.
+        writePingLater(true, payload1, payload2, null);
+      }
+    }
+
+    @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
+      if (debugData.size() > 0) { // TODO: log the debugData
+      }
+
+      // Copy the streams first. We don't want to hold a lock when we call receiveRstStream().
+      Http2Stream[] streamsCopy;
+      synchronized (Http2Connection.this) {
+        streamsCopy = streams.values().toArray(new Http2Stream[streams.size()]);
+        shutdown = true;
+      }
+
+      // Fail all streams created after the last good stream ID.
+      for (Http2Stream http2Stream : streamsCopy) {
+        if (http2Stream.getId() > lastGoodStreamId && http2Stream.isLocallyInitiated()) {
+          http2Stream.receiveRstStream(ErrorCode.REFUSED_STREAM);
+          removeStream(http2Stream.getId());
+        }
+      }
+    }
+
+    @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
+      if (streamId == 0) {
+        synchronized (Http2Connection.this) {
+          bytesLeftInWriteWindow += windowSizeIncrement;
+          Http2Connection.this.notifyAll();
+        }
+      } else {
+        Http2Stream stream = getStream(streamId);
+        if (stream != null) {
+          synchronized (stream) {
+            stream.addBytesToWriteWindow(windowSizeIncrement);
+          }
+        }
+      }
+    }
+
+    @Override public void priority(int streamId, int streamDependency, int weight,
+        boolean exclusive) {
+      // TODO: honor priority.
+    }
+
+    @Override
+    public void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders) {
+      pushRequestLater(promisedStreamId, requestHeaders);
+    }
+
+    @Override public void alternateService(int streamId, String origin, ByteString protocol,
+        String host, int port, long maxAge) {
+      // TODO: register alternate service.
+    }
+  }
+
+  /** Even, positive numbered streams are pushed streams in HTTP/2. */
+  boolean pushedStream(int streamId) {
+    return streamId != 0 && (streamId & 1) == 0;
+  }
+
+  // Guarded by this.
+  final Set<Integer> currentPushRequests = new LinkedHashSet<>();
+
+  void pushRequestLater(final int streamId, final List<Header> requestHeaders) {
+    synchronized (this) {
+      if (currentPushRequests.contains(streamId)) {
+        writeSynResetLater(streamId, ErrorCode.PROTOCOL_ERROR);
+        return;
+      }
+      currentPushRequests.add(streamId);
+    }
+    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Request[%s]", hostname, streamId) {
+      @Override public void execute() {
+        boolean cancel = pushObserver.onRequest(streamId, requestHeaders);
+        try {
+          if (cancel) {
+            writer.rstStream(streamId, ErrorCode.CANCEL);
+            synchronized (Http2Connection.this) {
+              currentPushRequests.remove(streamId);
+            }
+          }
+        } catch (IOException ignored) {
+        }
+      }
+    });
+  }
+
+  void pushHeadersLater(final int streamId, final List<Header> requestHeaders,
+      final boolean inFinished) {
+    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Headers[%s]", hostname, streamId) {
+      @Override public void execute() {
+        boolean cancel = pushObserver.onHeaders(streamId, requestHeaders, inFinished);
+        try {
+          if (cancel) writer.rstStream(streamId, ErrorCode.CANCEL);
+          if (cancel || inFinished) {
+            synchronized (Http2Connection.this) {
+              currentPushRequests.remove(streamId);
+            }
+          }
+        } catch (IOException ignored) {
+        }
+      }
+    });
+  }
+
+  /**
+   * Eagerly reads {@code byteCount} bytes from the source before launching a background task to
+   * process the data.  This avoids corrupting the stream.
+   */
+  void pushDataLater(final int streamId, final BufferedSource source, final int byteCount,
+      final boolean inFinished) throws IOException {
+    final Buffer buffer = new Buffer();
+    source.require(byteCount); // Eagerly read the frame before firing client thread.
+    source.read(buffer, byteCount);
+    if (buffer.size() != byteCount) throw new IOException(buffer.size() + " != " + byteCount);
+    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Data[%s]", hostname, streamId) {
+      @Override public void execute() {
+        try {
+          boolean cancel = pushObserver.onData(streamId, buffer, byteCount, inFinished);
+          if (cancel) writer.rstStream(streamId, ErrorCode.CANCEL);
+          if (cancel || inFinished) {
+            synchronized (Http2Connection.this) {
+              currentPushRequests.remove(streamId);
+            }
+          }
+        } catch (IOException ignored) {
+        }
+      }
+    });
+  }
+
+  void pushResetLater(final int streamId, final ErrorCode errorCode) {
+    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Reset[%s]", hostname, streamId) {
+      @Override public void execute() {
+        pushObserver.onReset(streamId, errorCode);
+        synchronized (Http2Connection.this) {
+          currentPushRequests.remove(streamId);
+        }
+      }
+    });
+  }
+
+  /** Listener of streams and settings initiated by the peer. */
+  public abstract static class Listener {
+    public static final Listener REFUSE_INCOMING_STREAMS = new Listener() {
+      @Override public void onStream(Http2Stream stream) throws IOException {
+        stream.close(ErrorCode.REFUSED_STREAM);
+      }
+    };
+
+    /**
+     * Handle a new stream from this connection's peer. Implementations should respond by either
+     * {@linkplain Http2Stream#sendResponseHeaders replying to the stream} or {@linkplain
+     * Http2Stream#close closing it}. This response does not need to be synchronous.
+     */
+    public abstract void onStream(Http2Stream stream) throws IOException;
+
+    /**
+     * Notification that the connection's peer's settings may have changed. Implementations should
+     * take appropriate action to handle the updated settings.
+     *
+     * <p>It is the implementation's responsibility to handle concurrent calls to this method. A
+     * remote peer that sends multiple settings frames will trigger multiple calls to this method,
+     * and those calls are not necessarily serialized.
+     */
+    public void onSettings(Http2Connection connection) {
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java
new file mode 100644
index 0000000000..2b093b3323
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java
@@ -0,0 +1,505 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.util.List;
+import java.util.logging.Logger;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.Source;
+import okio.Timeout;
+
+import static java.util.logging.Level.FINE;
+import static okhttp3.internal.Util.format;
+import static okhttp3.internal.http2.Http2.CONNECTION_PREFACE;
+import static okhttp3.internal.http2.Http2.FLAG_ACK;
+import static okhttp3.internal.http2.Http2.FLAG_COMPRESSED;
+import static okhttp3.internal.http2.Http2.FLAG_END_HEADERS;
+import static okhttp3.internal.http2.Http2.FLAG_END_STREAM;
+import static okhttp3.internal.http2.Http2.FLAG_PADDED;
+import static okhttp3.internal.http2.Http2.FLAG_PRIORITY;
+import static okhttp3.internal.http2.Http2.INITIAL_MAX_FRAME_SIZE;
+import static okhttp3.internal.http2.Http2.TYPE_CONTINUATION;
+import static okhttp3.internal.http2.Http2.TYPE_DATA;
+import static okhttp3.internal.http2.Http2.TYPE_GOAWAY;
+import static okhttp3.internal.http2.Http2.TYPE_HEADERS;
+import static okhttp3.internal.http2.Http2.TYPE_PING;
+import static okhttp3.internal.http2.Http2.TYPE_PRIORITY;
+import static okhttp3.internal.http2.Http2.TYPE_PUSH_PROMISE;
+import static okhttp3.internal.http2.Http2.TYPE_RST_STREAM;
+import static okhttp3.internal.http2.Http2.TYPE_SETTINGS;
+import static okhttp3.internal.http2.Http2.TYPE_WINDOW_UPDATE;
+import static okhttp3.internal.http2.Http2.frameLog;
+import static okhttp3.internal.http2.Http2.ioException;
+import static okio.ByteString.EMPTY;
+
+/**
+ * Reads HTTP/2 transport frames.
+ *
+ * <p>This implementation assumes we do not send an increased {@link Settings#getMaxFrameSize frame
+ * size setting} to the peer. Hence, we expect all frames to have a max length of {@link
+ * Http2#INITIAL_MAX_FRAME_SIZE}.
+ */
+final class Http2Reader implements Closeable {
+  static final Logger logger = Logger.getLogger(Http2.class.getName());
+
+  private final BufferedSource source;
+  private final ContinuationSource continuation;
+  private final boolean client;
+
+  // Visible for testing.
+  final Hpack.Reader hpackReader;
+
+  /** Creates a frame reader with max header table size of 4096. */
+  Http2Reader(BufferedSource source, boolean client) {
+    this.source = source;
+    this.client = client;
+    this.continuation = new ContinuationSource(this.source);
+    this.hpackReader = new Hpack.Reader(4096, continuation);
+  }
+
+  public void readConnectionPreface(Handler handler) throws IOException {
+    if (client) {
+      // The client reads the initial SETTINGS frame.
+      if (!nextFrame(true, handler)) {
+        throw ioException("Required SETTINGS preface not received");
+      }
+    } else {
+      // The server reads the CONNECTION_PREFACE byte string.
+      ByteString connectionPreface = source.readByteString(CONNECTION_PREFACE.size());
+      if (logger.isLoggable(FINE)) logger.fine(format("<< CONNECTION %s", connectionPreface.hex()));
+      if (!CONNECTION_PREFACE.equals(connectionPreface)) {
+        throw ioException("Expected a connection header but was %s", connectionPreface.utf8());
+      }
+    }
+  }
+
+  public boolean nextFrame(boolean requireSettings, Handler handler) throws IOException {
+    try {
+      source.require(9); // Frame header size
+    } catch (IOException e) {
+      return false; // This might be a normal socket close.
+    }
+
+    //  0                   1                   2                   3
+    //  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+    // +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    // |                 Length (24)                   |
+    // +---------------+---------------+---------------+
+    // |   Type (8)    |   Flags (8)   |
+    // +-+-+-----------+---------------+-------------------------------+
+    // |R|                 Stream Identifier (31)                      |
+    // +=+=============================================================+
+    // |                   Frame Payload (0...)                      ...
+    // +---------------------------------------------------------------+
+    int length = readMedium(source);
+    if (length < 0 || length > INITIAL_MAX_FRAME_SIZE) {
+      throw ioException("FRAME_SIZE_ERROR: %s", length);
+    }
+    byte type = (byte) (source.readByte() & 0xff);
+    if (requireSettings && type != TYPE_SETTINGS) {
+      throw ioException("Expected a SETTINGS frame but was %s", type);
+    }
+    byte flags = (byte) (source.readByte() & 0xff);
+    int streamId = (source.readInt() & 0x7fffffff); // Ignore reserved bit.
+    if (logger.isLoggable(FINE)) logger.fine(frameLog(true, streamId, length, type, flags));
+
+    switch (type) {
+      case TYPE_DATA:
+        readData(handler, length, flags, streamId);
+        break;
+
+      case TYPE_HEADERS:
+        readHeaders(handler, length, flags, streamId);
+        break;
+
+      case TYPE_PRIORITY:
+        readPriority(handler, length, flags, streamId);
+        break;
+
+      case TYPE_RST_STREAM:
+        readRstStream(handler, length, flags, streamId);
+        break;
+
+      case TYPE_SETTINGS:
+        readSettings(handler, length, flags, streamId);
+        break;
+
+      case TYPE_PUSH_PROMISE:
+        readPushPromise(handler, length, flags, streamId);
+        break;
+
+      case TYPE_PING:
+        readPing(handler, length, flags, streamId);
+        break;
+
+      case TYPE_GOAWAY:
+        readGoAway(handler, length, flags, streamId);
+        break;
+
+      case TYPE_WINDOW_UPDATE:
+        readWindowUpdate(handler, length, flags, streamId);
+        break;
+
+      default:
+        // Implementations MUST discard frames that have unknown or unsupported types.
+        source.skip(length);
+    }
+    return true;
+  }
+
+  private void readHeaders(Handler handler, int length, byte flags, int streamId)
+      throws IOException {
+    if (streamId == 0) throw ioException("PROTOCOL_ERROR: TYPE_HEADERS streamId == 0");
+
+    boolean endStream = (flags & FLAG_END_STREAM) != 0;
+
+    short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
+
+    if ((flags & FLAG_PRIORITY) != 0) {
+      readPriority(handler, streamId);
+      length -= 5; // account for above read.
+    }
+
+    length = lengthWithoutPadding(length, flags, padding);
+
+    List<Header> headerBlock = readHeaderBlock(length, padding, flags, streamId);
+
+    handler.headers(endStream, streamId, -1, headerBlock);
+  }
+
+  private List<Header> readHeaderBlock(int length, short padding, byte flags, int streamId)
+      throws IOException {
+    continuation.length = continuation.left = length;
+    continuation.padding = padding;
+    continuation.flags = flags;
+    continuation.streamId = streamId;
+
+    // TODO: Concat multi-value headers with 0x0, except COOKIE, which uses 0x3B, 0x20.
+    // http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-8.1.2.5
+    hpackReader.readHeaders();
+    return hpackReader.getAndResetHeaderList();
+  }
+
+  private void readData(Handler handler, int length, byte flags, int streamId)
+      throws IOException {
+    if (streamId == 0) throw ioException("PROTOCOL_ERROR: TYPE_DATA streamId == 0");
+
+    // TODO: checkState open or half-closed (local) or raise STREAM_CLOSED
+    boolean inFinished = (flags & FLAG_END_STREAM) != 0;
+    boolean gzipped = (flags & FLAG_COMPRESSED) != 0;
+    if (gzipped) {
+      throw ioException("PROTOCOL_ERROR: FLAG_COMPRESSED without SETTINGS_COMPRESS_DATA");
+    }
+
+    short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
+    length = lengthWithoutPadding(length, flags, padding);
+
+    handler.data(inFinished, streamId, source, length);
+    source.skip(padding);
+  }
+
+  private void readPriority(Handler handler, int length, byte flags, int streamId)
+      throws IOException {
+    if (length != 5) throw ioException("TYPE_PRIORITY length: %d != 5", length);
+    if (streamId == 0) throw ioException("TYPE_PRIORITY streamId == 0");
+    readPriority(handler, streamId);
+  }
+
+  private void readPriority(Handler handler, int streamId) throws IOException {
+    int w1 = source.readInt();
+    boolean exclusive = (w1 & 0x80000000) != 0;
+    int streamDependency = (w1 & 0x7fffffff);
+    int weight = (source.readByte() & 0xff) + 1;
+    handler.priority(streamId, streamDependency, weight, exclusive);
+  }
+
+  private void readRstStream(Handler handler, int length, byte flags, int streamId)
+      throws IOException {
+    if (length != 4) throw ioException("TYPE_RST_STREAM length: %d != 4", length);
+    if (streamId == 0) throw ioException("TYPE_RST_STREAM streamId == 0");
+    int errorCodeInt = source.readInt();
+    ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
+    if (errorCode == null) {
+      throw ioException("TYPE_RST_STREAM unexpected error code: %d", errorCodeInt);
+    }
+    handler.rstStream(streamId, errorCode);
+  }
+
+  private void readSettings(Handler handler, int length, byte flags, int streamId)
+      throws IOException {
+    if (streamId != 0) throw ioException("TYPE_SETTINGS streamId != 0");
+    if ((flags & FLAG_ACK) != 0) {
+      if (length != 0) throw ioException("FRAME_SIZE_ERROR ack frame should be empty!");
+      handler.ackSettings();
+      return;
+    }
+
+    if (length % 6 != 0) throw ioException("TYPE_SETTINGS length %% 6 != 0: %s", length);
+    Settings settings = new Settings();
+    for (int i = 0; i < length; i += 6) {
+      short id = source.readShort();
+      int value = source.readInt();
+
+      switch (id) {
+        case 1: // SETTINGS_HEADER_TABLE_SIZE
+          break;
+        case 2: // SETTINGS_ENABLE_PUSH
+          if (value != 0 && value != 1) {
+            throw ioException("PROTOCOL_ERROR SETTINGS_ENABLE_PUSH != 0 or 1");
+          }
+          break;
+        case 3: // SETTINGS_MAX_CONCURRENT_STREAMS
+          id = 4; // Renumbered in draft 10.
+          break;
+        case 4: // SETTINGS_INITIAL_WINDOW_SIZE
+          id = 7; // Renumbered in draft 10.
+          if (value < 0) {
+            throw ioException("PROTOCOL_ERROR SETTINGS_INITIAL_WINDOW_SIZE > 2^31 - 1");
+          }
+          break;
+        case 5: // SETTINGS_MAX_FRAME_SIZE
+          if (value < INITIAL_MAX_FRAME_SIZE || value > 16777215) {
+            throw ioException("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: %s", value);
+          }
+          break;
+        case 6: // SETTINGS_MAX_HEADER_LIST_SIZE
+          break; // Advisory only, so ignored.
+        default:
+          break; // Must ignore setting with unknown id.
+      }
+      settings.set(id, value);
+    }
+    handler.settings(false, settings);
+  }
+
+  private void readPushPromise(Handler handler, int length, byte flags, int streamId)
+      throws IOException {
+    if (streamId == 0) {
+      throw ioException("PROTOCOL_ERROR: TYPE_PUSH_PROMISE streamId == 0");
+    }
+    short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
+    int promisedStreamId = source.readInt() & 0x7fffffff;
+    length -= 4; // account for above read.
+    length = lengthWithoutPadding(length, flags, padding);
+    List<Header> headerBlock = readHeaderBlock(length, padding, flags, streamId);
+    handler.pushPromise(streamId, promisedStreamId, headerBlock);
+  }
+
+  private void readPing(Handler handler, int length, byte flags, int streamId)
+      throws IOException {
+    if (length != 8) throw ioException("TYPE_PING length != 8: %s", length);
+    if (streamId != 0) throw ioException("TYPE_PING streamId != 0");
+    int payload1 = source.readInt();
+    int payload2 = source.readInt();
+    boolean ack = (flags & FLAG_ACK) != 0;
+    handler.ping(ack, payload1, payload2);
+  }
+
+  private void readGoAway(Handler handler, int length, byte flags, int streamId)
+      throws IOException {
+    if (length < 8) throw ioException("TYPE_GOAWAY length < 8: %s", length);
+    if (streamId != 0) throw ioException("TYPE_GOAWAY streamId != 0");
+    int lastStreamId = source.readInt();
+    int errorCodeInt = source.readInt();
+    int opaqueDataLength = length - 8;
+    ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
+    if (errorCode == null) {
+      throw ioException("TYPE_GOAWAY unexpected error code: %d", errorCodeInt);
+    }
+    ByteString debugData = EMPTY;
+    if (opaqueDataLength > 0) { // Must read debug data in order to not corrupt the connection.
+      debugData = source.readByteString(opaqueDataLength);
+    }
+    handler.goAway(lastStreamId, errorCode, debugData);
+  }
+
+  private void readWindowUpdate(Handler handler, int length, byte flags, int streamId)
+      throws IOException {
+    if (length != 4) throw ioException("TYPE_WINDOW_UPDATE length !=4: %s", length);
+    long increment = (source.readInt() & 0x7fffffffL);
+    if (increment == 0) throw ioException("windowSizeIncrement was 0", increment);
+    handler.windowUpdate(streamId, increment);
+  }
+
+  @Override public void close() throws IOException {
+    source.close();
+  }
+
+  /**
+   * Decompression of the header block occurs above the framing layer. This class lazily reads
+   * continuation frames as they are needed by {@link Hpack.Reader#readHeaders()}.
+   */
+  static final class ContinuationSource implements Source {
+    private final BufferedSource source;
+
+    int length;
+    byte flags;
+    int streamId;
+
+    int left;
+    short padding;
+
+    ContinuationSource(BufferedSource source) {
+      this.source = source;
+    }
+
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
+      while (left == 0) {
+        source.skip(padding);
+        padding = 0;
+        if ((flags & FLAG_END_HEADERS) != 0) return -1;
+        readContinuationHeader();
+        // TODO: test case for empty continuation header?
+      }
+
+      long read = source.read(sink, Math.min(byteCount, left));
+      if (read == -1) return -1;
+      left -= read;
+      return read;
+    }
+
+    @Override public Timeout timeout() {
+      return source.timeout();
+    }
+
+    @Override public void close() throws IOException {
+    }
+
+    private void readContinuationHeader() throws IOException {
+      int previousStreamId = streamId;
+
+      length = left = readMedium(source);
+      byte type = (byte) (source.readByte() & 0xff);
+      flags = (byte) (source.readByte() & 0xff);
+      if (logger.isLoggable(FINE)) logger.fine(frameLog(true, streamId, length, type, flags));
+      streamId = (source.readInt() & 0x7fffffff);
+      if (type != TYPE_CONTINUATION) throw ioException("%s != TYPE_CONTINUATION", type);
+      if (streamId != previousStreamId) throw ioException("TYPE_CONTINUATION streamId changed");
+    }
+  }
+
+  static int readMedium(BufferedSource source) throws IOException {
+    return (source.readByte() & 0xff) << 16
+        | (source.readByte() & 0xff) << 8
+        | (source.readByte() & 0xff);
+  }
+
+  static int lengthWithoutPadding(int length, byte flags, short padding)
+      throws IOException {
+    if ((flags & FLAG_PADDED) != 0) length--; // Account for reading the padding length.
+    if (padding > length) {
+      throw ioException("PROTOCOL_ERROR padding %s > remaining length %s", padding, length);
+    }
+    return (short) (length - padding);
+  }
+
+  interface Handler {
+    void data(boolean inFinished, int streamId, BufferedSource source, int length)
+        throws IOException;
+
+    /**
+     * Create or update incoming headers, creating the corresponding streams if necessary. Frames
+     * that trigger this are HEADERS and PUSH_PROMISE.
+     *
+     * @param inFinished true if the sender will not send further frames.
+     * @param streamId the stream owning these headers.
+     * @param associatedStreamId the stream that triggered the sender to create this stream.
+     */
+    void headers(boolean inFinished, int streamId, int associatedStreamId,
+        List<Header> headerBlock);
+
+    void rstStream(int streamId, ErrorCode errorCode);
+
+    void settings(boolean clearPrevious, Settings settings);
+
+    /** HTTP/2 only. */
+    void ackSettings();
+
+    /**
+     * Read a connection-level ping from the peer. {@code ack} indicates this is a reply. The data
+     * in {@code payload1} and {@code payload2} opaque binary, and there are no rules on the
+     * content.
+     */
+    void ping(boolean ack, int payload1, int payload2);
+
+    /**
+     * The peer tells us to stop creating streams.  It is safe to replay streams with {@code ID >
+     * lastGoodStreamId} on a new connection.  In- flight streams with {@code ID <=
+     * lastGoodStreamId} can only be replayed on a new connection if they are idempotent.
+     *
+     * @param lastGoodStreamId the last stream ID the peer processed before sending this message. If
+     * {@code lastGoodStreamId} is zero, the peer processed no frames.
+     * @param errorCode reason for closing the connection.
+     * @param debugData only valid for HTTP/2; opaque debug data to send.
+     */
+    void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData);
+
+    /**
+     * Notifies that an additional {@code windowSizeIncrement} bytes can be sent on {@code
+     * streamId}, or the connection if {@code streamId} is zero.
+     */
+    void windowUpdate(int streamId, long windowSizeIncrement);
+
+    /**
+     * Called when reading a headers or priority frame. This may be used to change the stream's
+     * weight from the default (16) to a new value.
+     *
+     * @param streamId stream which has a priority change.
+     * @param streamDependency the stream ID this stream is dependent on.
+     * @param weight relative proportion of priority in [1..256].
+     * @param exclusive inserts this stream ID as the sole child of {@code streamDependency}.
+     */
+    void priority(int streamId, int streamDependency, int weight, boolean exclusive);
+
+    /**
+     * HTTP/2 only. Receive a push promise header block. <p> A push promise contains all the headers
+     * that pertain to a server-initiated request, and a {@code promisedStreamId} to which response
+     * frames will be delivered. Push promise frames are sent as a part of the response to {@code
+     * streamId}.
+     *
+     * @param streamId client-initiated stream ID.  Must be an odd number.
+     * @param promisedStreamId server-initiated stream ID.  Must be an even number.
+     * @param requestHeaders minimally includes {@code :method}, {@code :scheme}, {@code
+     * :authority}, and (@code :path}.
+     */
+    void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
+        throws IOException;
+
+    /**
+     * HTTP/2 only. Expresses that resources for the connection or a client- initiated stream are
+     * available from a different network location or protocol configuration.
+     *
+     * <p>See <a href="http://tools.ietf.org/html/draft-ietf-httpbis-alt-svc-01">alt-svc</a>
+     *
+     * @param streamId when a client-initiated stream ID (odd number), the origin of this alternate
+     * service is the origin of the stream. When zero, the origin is specified in the {@code origin}
+     * parameter.
+     * @param origin when present, the <a href="http://tools.ietf.org/html/rfc6454">origin</a> is
+     * typically represented as a combination of scheme, host and port. When empty, the origin is
+     * that of the {@code streamId}.
+     * @param protocol an ALPN protocol, such as {@code h2}.
+     * @param host an IP address or hostname.
+     * @param port the IP port associated with the service.
+     * @param maxAge time in seconds that this alternative is considered fresh.
+     */
+    void alternateService(int streamId, String origin, ByteString protocol, String host, int port,
+        long maxAge);
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
new file mode 100644
index 0000000000..19ac954d7e
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
@@ -0,0 +1,604 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.net.SocketTimeoutException;
+import java.util.ArrayList;
+import java.util.List;
+import okio.AsyncTimeout;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.Sink;
+import okio.Source;
+import okio.Timeout;
+
+/** A logical bidirectional stream. */
+public final class Http2Stream {
+  // Internal state is guarded by this. No long-running or potentially
+  // blocking operations are performed while the lock is held.
+
+  /**
+   * The total number of bytes consumed by the application (with {@link FramingSource#read}), but
+   * not yet acknowledged by sending a {@code WINDOW_UPDATE} frame on this stream.
+   */
+  // Visible for testing
+  long unacknowledgedBytesRead = 0;
+
+  /**
+   * Count of bytes that can be written on the stream before receiving a window update. Even if this
+   * is positive, writes will block until there available bytes in {@code
+   * connection.bytesLeftInWriteWindow}.
+   */
+  // guarded by this
+  long bytesLeftInWriteWindow;
+
+  final int id;
+  final Http2Connection connection;
+
+  /** Request headers. Immutable and non null. */
+  private final List<Header> requestHeaders;
+
+  /** Response headers yet to be {@linkplain #takeResponseHeaders taken}. */
+  private List<Header> responseHeaders;
+
+  /** True if response headers have been sent or received. */
+  private boolean hasResponseHeaders;
+
+  private final FramingSource source;
+  final FramingSink sink;
+  final StreamTimeout readTimeout = new StreamTimeout();
+  final StreamTimeout writeTimeout = new StreamTimeout();
+
+  /**
+   * The reason why this stream was abnormally closed. If there are multiple reasons to abnormally
+   * close this stream (such as both peers closing it near-simultaneously) then this is the first
+   * reason known to this peer.
+   */
+  ErrorCode errorCode = null;
+
+  Http2Stream(int id, Http2Connection connection, boolean outFinished, boolean inFinished,
+      List<Header> requestHeaders) {
+    if (connection == null) throw new NullPointerException("connection == null");
+    if (requestHeaders == null) throw new NullPointerException("requestHeaders == null");
+    this.id = id;
+    this.connection = connection;
+    this.bytesLeftInWriteWindow =
+        connection.peerSettings.getInitialWindowSize();
+    this.source = new FramingSource(connection.okHttpSettings.getInitialWindowSize());
+    this.sink = new FramingSink();
+    this.source.finished = inFinished;
+    this.sink.finished = outFinished;
+    this.requestHeaders = requestHeaders;
+  }
+
+  public int getId() {
+    return id;
+  }
+
+  /**
+   * Returns true if this stream is open. A stream is open until either:
+   *
+   * <ul>
+   *     <li>A {@code SYN_RESET} frame abnormally terminates the stream.
+   *     <li>Both input and output streams have transmitted all data and headers.
+   * </ul>
+   *
+   * <p>Note that the input stream may continue to yield data even after a stream reports itself as
+   * not open. This is because input data is buffered.
+   */
+  public synchronized boolean isOpen() {
+    if (errorCode != null) {
+      return false;
+    }
+    if ((source.finished || source.closed)
+        && (sink.finished || sink.closed)
+        && hasResponseHeaders) {
+      return false;
+    }
+    return true;
+  }
+
+  /** Returns true if this stream was created by this peer. */
+  public boolean isLocallyInitiated() {
+    boolean streamIsClient = ((id & 1) == 1);
+    return connection.client == streamIsClient;
+  }
+
+  public Http2Connection getConnection() {
+    return connection;
+  }
+
+  public List<Header> getRequestHeaders() {
+    return requestHeaders;
+  }
+
+  /**
+   * Removes and returns the stream's received response headers, blocking if necessary until headers
+   * have been received. If the returned list contains multiple blocks of headers the blocks will be
+   * delimited by 'null'.
+   */
+  public synchronized List<Header> takeResponseHeaders() throws IOException {
+    if (!isLocallyInitiated()) {
+      throw new IllegalStateException("servers cannot read response headers");
+    }
+    readTimeout.enter();
+    try {
+      while (responseHeaders == null && errorCode == null) {
+        waitForIo();
+      }
+    } finally {
+      readTimeout.exitAndThrowIfTimedOut();
+    }
+    List<Header> result = responseHeaders;
+    if (result != null) {
+      responseHeaders = null;
+      return result;
+    }
+    throw new StreamResetException(errorCode);
+  }
+
+  /**
+   * Returns the reason why this stream was closed, or null if it closed normally or has not yet
+   * been closed.
+   */
+  public synchronized ErrorCode getErrorCode() {
+    return errorCode;
+  }
+
+  /**
+   * Sends a reply to an incoming stream.
+   *
+   * @param out true to create an output stream that we can use to send data to the remote peer.
+   * Corresponds to {@code FLAG_FIN}.
+   */
+  public void sendResponseHeaders(List<Header> responseHeaders, boolean out) throws IOException {
+    assert (!Thread.holdsLock(Http2Stream.this));
+    if (responseHeaders == null) {
+      throw new NullPointerException("responseHeaders == null");
+    }
+    boolean outFinished = false;
+    synchronized (this) {
+      this.hasResponseHeaders = true;
+      if (!out) {
+        this.sink.finished = true;
+        outFinished = true;
+      }
+    }
+    connection.writeSynReply(id, outFinished, responseHeaders);
+
+    if (outFinished) {
+      connection.flush();
+    }
+  }
+
+  public Timeout readTimeout() {
+    return readTimeout;
+  }
+
+  public Timeout writeTimeout() {
+    return writeTimeout;
+  }
+
+  /** Returns a source that reads data from the peer. */
+  public Source getSource() {
+    return source;
+  }
+
+  /**
+   * Returns a sink that can be used to write data to the peer.
+   *
+   * @throws IllegalStateException if this stream was initiated by the peer and a {@link
+   * #sendResponseHeaders} has not yet been sent.
+   */
+  public Sink getSink() {
+    synchronized (this) {
+      if (!hasResponseHeaders && !isLocallyInitiated()) {
+        throw new IllegalStateException("reply before requesting the sink");
+      }
+    }
+    return sink;
+  }
+
+  /**
+   * Abnormally terminate this stream. This blocks until the {@code RST_STREAM} frame has been
+   * transmitted.
+   */
+  public void close(ErrorCode rstStatusCode) throws IOException {
+    if (!closeInternal(rstStatusCode)) {
+      return; // Already closed.
+    }
+    connection.writeSynReset(id, rstStatusCode);
+  }
+
+  /**
+   * Abnormally terminate this stream. This enqueues a {@code RST_STREAM} frame and returns
+   * immediately.
+   */
+  public void closeLater(ErrorCode errorCode) {
+    if (!closeInternal(errorCode)) {
+      return; // Already closed.
+    }
+    connection.writeSynResetLater(id, errorCode);
+  }
+
+  /** Returns true if this stream was closed. */
+  private boolean closeInternal(ErrorCode errorCode) {
+    assert (!Thread.holdsLock(this));
+    synchronized (this) {
+      if (this.errorCode != null) {
+        return false;
+      }
+      if (source.finished && sink.finished) {
+        return false;
+      }
+      this.errorCode = errorCode;
+      notifyAll();
+    }
+    connection.removeStream(id);
+    return true;
+  }
+
+  void receiveHeaders(List<Header> headers) {
+    assert (!Thread.holdsLock(Http2Stream.this));
+    boolean open = true;
+    synchronized (this) {
+      hasResponseHeaders = true;
+      if (responseHeaders == null) {
+        responseHeaders = headers;
+        open = isOpen();
+        notifyAll();
+      } else {
+        List<Header> newHeaders = new ArrayList<>();
+        newHeaders.addAll(responseHeaders);
+        newHeaders.add(null); // Delimit separate blocks of headers with null.
+        newHeaders.addAll(headers);
+        this.responseHeaders = newHeaders;
+      }
+    }
+    if (!open) {
+      connection.removeStream(id);
+    }
+  }
+
+  void receiveData(BufferedSource in, int length) throws IOException {
+    assert (!Thread.holdsLock(Http2Stream.this));
+    this.source.receive(in, length);
+  }
+
+  void receiveFin() {
+    assert (!Thread.holdsLock(Http2Stream.this));
+    boolean open;
+    synchronized (this) {
+      this.source.finished = true;
+      open = isOpen();
+      notifyAll();
+    }
+    if (!open) {
+      connection.removeStream(id);
+    }
+  }
+
+  synchronized void receiveRstStream(ErrorCode errorCode) {
+    if (this.errorCode == null) {
+      this.errorCode = errorCode;
+      notifyAll();
+    }
+  }
+
+  /**
+   * A source that reads the incoming data frames of a stream. Although this class uses
+   * synchronization to safely receive incoming data frames, it is not intended for use by multiple
+   * readers.
+   */
+  private final class FramingSource implements Source {
+    /** Buffer to receive data from the network into. Only accessed by the reader thread. */
+    private final Buffer receiveBuffer = new Buffer();
+
+    /** Buffer with readable data. Guarded by Http2Stream.this. */
+    private final Buffer readBuffer = new Buffer();
+
+    /** Maximum number of bytes to buffer before reporting a flow control error. */
+    private final long maxByteCount;
+
+    /** True if the caller has closed this stream. */
+    boolean closed;
+
+    /**
+     * True if either side has cleanly shut down this stream. We will receive no more bytes beyond
+     * those already in the buffer.
+     */
+    boolean finished;
+
+    FramingSource(long maxByteCount) {
+      this.maxByteCount = maxByteCount;
+    }
+
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
+      if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
+
+      long read;
+      synchronized (Http2Stream.this) {
+        waitUntilReadable();
+        checkNotClosed();
+        if (readBuffer.size() == 0) return -1; // This source is exhausted.
+
+        // Move bytes from the read buffer into the caller's buffer.
+        read = readBuffer.read(sink, Math.min(byteCount, readBuffer.size()));
+
+        // Flow control: notify the peer that we're ready for more data!
+        unacknowledgedBytesRead += read;
+        if (unacknowledgedBytesRead
+            >= connection.okHttpSettings.getInitialWindowSize() / 2) {
+          connection.writeWindowUpdateLater(id, unacknowledgedBytesRead);
+          unacknowledgedBytesRead = 0;
+        }
+      }
+
+      // Update connection.unacknowledgedBytesRead outside the stream lock.
+      synchronized (connection) { // Multiple application threads may hit this section.
+        connection.unacknowledgedBytesRead += read;
+        if (connection.unacknowledgedBytesRead
+            >= connection.okHttpSettings.getInitialWindowSize() / 2) {
+          connection.writeWindowUpdateLater(0, connection.unacknowledgedBytesRead);
+          connection.unacknowledgedBytesRead = 0;
+        }
+      }
+
+      return read;
+    }
+
+    /** Returns once the source is either readable or finished. */
+    private void waitUntilReadable() throws IOException {
+      readTimeout.enter();
+      try {
+        while (readBuffer.size() == 0 && !finished && !closed && errorCode == null) {
+          waitForIo();
+        }
+      } finally {
+        readTimeout.exitAndThrowIfTimedOut();
+      }
+    }
+
+    void receive(BufferedSource in, long byteCount) throws IOException {
+      assert (!Thread.holdsLock(Http2Stream.this));
+
+      while (byteCount > 0) {
+        boolean finished;
+        boolean flowControlError;
+        synchronized (Http2Stream.this) {
+          finished = this.finished;
+          flowControlError = byteCount + readBuffer.size() > maxByteCount;
+        }
+
+        // If the peer sends more data than we can handle, discard it and close the connection.
+        if (flowControlError) {
+          in.skip(byteCount);
+          closeLater(ErrorCode.FLOW_CONTROL_ERROR);
+          return;
+        }
+
+        // Discard data received after the stream is finished. It's probably a benign race.
+        if (finished) {
+          in.skip(byteCount);
+          return;
+        }
+
+        // Fill the receive buffer without holding any locks.
+        long read = in.read(receiveBuffer, byteCount);
+        if (read == -1) throw new EOFException();
+        byteCount -= read;
+
+        // Move the received data to the read buffer to the reader can read it.
+        synchronized (Http2Stream.this) {
+          boolean wasEmpty = readBuffer.size() == 0;
+          readBuffer.writeAll(receiveBuffer);
+          if (wasEmpty) {
+            Http2Stream.this.notifyAll();
+          }
+        }
+      }
+    }
+
+    @Override public Timeout timeout() {
+      return readTimeout;
+    }
+
+    @Override public void close() throws IOException {
+      synchronized (Http2Stream.this) {
+        closed = true;
+        readBuffer.clear();
+        Http2Stream.this.notifyAll();
+      }
+      cancelStreamIfNecessary();
+    }
+
+    private void checkNotClosed() throws IOException {
+      if (closed) {
+        throw new IOException("stream closed");
+      }
+      if (errorCode != null) {
+        throw new StreamResetException(errorCode);
+      }
+    }
+  }
+
+  void cancelStreamIfNecessary() throws IOException {
+    assert (!Thread.holdsLock(Http2Stream.this));
+    boolean open;
+    boolean cancel;
+    synchronized (this) {
+      cancel = !source.finished && source.closed && (sink.finished || sink.closed);
+      open = isOpen();
+    }
+    if (cancel) {
+      // RST this stream to prevent additional data from being sent. This
+      // is safe because the input stream is closed (we won't use any
+      // further bytes) and the output stream is either finished or closed
+      // (so RSTing both streams doesn't cause harm).
+      Http2Stream.this.close(ErrorCode.CANCEL);
+    } else if (!open) {
+      connection.removeStream(id);
+    }
+  }
+
+  /** A sink that writes outgoing data frames of a stream. This class is not thread safe. */
+  final class FramingSink implements Sink {
+    private static final long EMIT_BUFFER_SIZE = 16384;
+
+    /**
+     * Buffer of outgoing data. This batches writes of small writes into this sink as larges frames
+     * written to the outgoing connection. Batching saves the (small) framing overhead.
+     */
+    private final Buffer sendBuffer = new Buffer();
+
+    boolean closed;
+
+    /**
+     * True if either side has cleanly shut down this stream. We shall send no more bytes.
+     */
+    boolean finished;
+
+    @Override public void write(Buffer source, long byteCount) throws IOException {
+      assert (!Thread.holdsLock(Http2Stream.this));
+      sendBuffer.write(source, byteCount);
+      while (sendBuffer.size() >= EMIT_BUFFER_SIZE) {
+        emitFrame(false);
+      }
+    }
+
+    /**
+     * Emit a single data frame to the connection. The frame's size be limited by this stream's
+     * write window. This method will block until the write window is nonempty.
+     */
+    private void emitFrame(boolean outFinished) throws IOException {
+      long toWrite;
+      synchronized (Http2Stream.this) {
+        writeTimeout.enter();
+        try {
+          while (bytesLeftInWriteWindow <= 0 && !finished && !closed && errorCode == null) {
+            waitForIo(); // Wait until we receive a WINDOW_UPDATE for this stream.
+          }
+        } finally {
+          writeTimeout.exitAndThrowIfTimedOut();
+        }
+
+        checkOutNotClosed(); // Kick out if the stream was reset or closed while waiting.
+        toWrite = Math.min(bytesLeftInWriteWindow, sendBuffer.size());
+        bytesLeftInWriteWindow -= toWrite;
+      }
+
+      writeTimeout.enter();
+      try {
+        connection.writeData(id, outFinished && toWrite == sendBuffer.size(), sendBuffer, toWrite);
+      } finally {
+        writeTimeout.exitAndThrowIfTimedOut();
+      }
+    }
+
+    @Override public void flush() throws IOException {
+      assert (!Thread.holdsLock(Http2Stream.this));
+      synchronized (Http2Stream.this) {
+        checkOutNotClosed();
+      }
+      while (sendBuffer.size() > 0) {
+        emitFrame(false);
+        connection.flush();
+      }
+    }
+
+    @Override public Timeout timeout() {
+      return writeTimeout;
+    }
+
+    @Override public void close() throws IOException {
+      assert (!Thread.holdsLock(Http2Stream.this));
+      synchronized (Http2Stream.this) {
+        if (closed) return;
+      }
+      if (!sink.finished) {
+        // Emit the remaining data, setting the END_STREAM flag on the last frame.
+        if (sendBuffer.size() > 0) {
+          while (sendBuffer.size() > 0) {
+            emitFrame(true);
+          }
+        } else {
+          // Send an empty frame just so we can set the END_STREAM flag.
+          connection.writeData(id, true, null, 0);
+        }
+      }
+      synchronized (Http2Stream.this) {
+        closed = true;
+      }
+      connection.flush();
+      cancelStreamIfNecessary();
+    }
+  }
+
+  /**
+   * {@code delta} will be negative if a settings frame initial window is smaller than the last.
+   */
+  void addBytesToWriteWindow(long delta) {
+    bytesLeftInWriteWindow += delta;
+    if (delta > 0) Http2Stream.this.notifyAll();
+  }
+
+  void checkOutNotClosed() throws IOException {
+    if (sink.closed) {
+      throw new IOException("stream closed");
+    } else if (sink.finished) {
+      throw new IOException("stream finished");
+    } else if (errorCode != null) {
+      throw new StreamResetException(errorCode);
+    }
+  }
+
+  /**
+   * Like {@link #wait}, but throws an {@code InterruptedIOException} when interrupted instead of
+   * the more awkward {@link InterruptedException}.
+   */
+  void waitForIo() throws InterruptedIOException {
+    try {
+      wait();
+    } catch (InterruptedException e) {
+      throw new InterruptedIOException();
+    }
+  }
+
+  /**
+   * The Okio timeout watchdog will call {@link #timedOut} if the timeout is reached. In that case
+   * we close the stream (asynchronously) which will notify the waiting thread.
+   */
+  class StreamTimeout extends AsyncTimeout {
+    @Override protected void timedOut() {
+      closeLater(ErrorCode.CANCEL);
+    }
+
+    @Override protected IOException newTimeoutException(IOException cause) {
+      SocketTimeoutException socketTimeoutException = new SocketTimeoutException("timeout");
+      if (cause != null) {
+        socketTimeoutException.initCause(cause);
+      }
+      return socketTimeoutException;
+    }
+
+    public void exitAndThrowIfTimedOut() throws IOException {
+      if (exit()) throw newTimeoutException(null /* cause */);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.java
new file mode 100644
index 0000000000..5ef6bb9c4a
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.java
@@ -0,0 +1,311 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.util.List;
+import java.util.logging.Logger;
+import okio.Buffer;
+import okio.BufferedSink;
+
+import static java.util.logging.Level.FINE;
+import static okhttp3.internal.Util.format;
+import static okhttp3.internal.http2.Http2.CONNECTION_PREFACE;
+import static okhttp3.internal.http2.Http2.FLAG_ACK;
+import static okhttp3.internal.http2.Http2.FLAG_END_HEADERS;
+import static okhttp3.internal.http2.Http2.FLAG_END_STREAM;
+import static okhttp3.internal.http2.Http2.FLAG_NONE;
+import static okhttp3.internal.http2.Http2.INITIAL_MAX_FRAME_SIZE;
+import static okhttp3.internal.http2.Http2.TYPE_CONTINUATION;
+import static okhttp3.internal.http2.Http2.TYPE_DATA;
+import static okhttp3.internal.http2.Http2.TYPE_GOAWAY;
+import static okhttp3.internal.http2.Http2.TYPE_HEADERS;
+import static okhttp3.internal.http2.Http2.TYPE_PING;
+import static okhttp3.internal.http2.Http2.TYPE_PUSH_PROMISE;
+import static okhttp3.internal.http2.Http2.TYPE_RST_STREAM;
+import static okhttp3.internal.http2.Http2.TYPE_SETTINGS;
+import static okhttp3.internal.http2.Http2.TYPE_WINDOW_UPDATE;
+import static okhttp3.internal.http2.Http2.frameLog;
+import static okhttp3.internal.http2.Http2.illegalArgument;
+
+/** Writes HTTP/2 transport frames. */
+final class Http2Writer implements Closeable {
+  private static final Logger logger = Logger.getLogger(Http2.class.getName());
+
+  private final BufferedSink sink;
+  private final boolean client;
+  private final Buffer hpackBuffer;
+  private int maxFrameSize;
+  private boolean closed;
+
+  final Hpack.Writer hpackWriter;
+
+  Http2Writer(BufferedSink sink, boolean client) {
+    this.sink = sink;
+    this.client = client;
+    this.hpackBuffer = new Buffer();
+    this.hpackWriter = new Hpack.Writer(hpackBuffer);
+    this.maxFrameSize = INITIAL_MAX_FRAME_SIZE;
+  }
+
+  public synchronized void connectionPreface() throws IOException {
+    if (closed) throw new IOException("closed");
+    if (!client) return; // Nothing to write; servers don't send connection headers!
+    if (logger.isLoggable(FINE)) {
+      logger.fine(format(">> CONNECTION %s", CONNECTION_PREFACE.hex()));
+    }
+    sink.write(CONNECTION_PREFACE.toByteArray());
+    sink.flush();
+  }
+
+  /** Applies {@code peerSettings} and then sends a settings ACK. */
+  public synchronized void applyAndAckSettings(Settings peerSettings) throws IOException {
+    if (closed) throw new IOException("closed");
+    this.maxFrameSize = peerSettings.getMaxFrameSize(maxFrameSize);
+    if (peerSettings.getHeaderTableSize() != -1) {
+      hpackWriter.setHeaderTableSizeSetting(peerSettings.getHeaderTableSize());
+    }
+    int length = 0;
+    byte type = TYPE_SETTINGS;
+    byte flags = FLAG_ACK;
+    int streamId = 0;
+    frameHeader(streamId, length, type, flags);
+    sink.flush();
+  }
+
+  /**
+   * HTTP/2 only. Send a push promise header block.
+   *
+   * <p>A push promise contains all the headers that pertain to a server-initiated request, and a
+   * {@code promisedStreamId} to which response frames will be delivered. Push promise frames are
+   * sent as a part of the response to {@code streamId}. The {@code promisedStreamId} has a priority
+   * of one greater than {@code streamId}.
+   *
+   * @param streamId client-initiated stream ID.  Must be an odd number.
+   * @param promisedStreamId server-initiated stream ID.  Must be an even number.
+   * @param requestHeaders minimally includes {@code :method}, {@code :scheme}, {@code :authority},
+   * and {@code :path}.
+   */
+  public synchronized void pushPromise(int streamId, int promisedStreamId,
+      List<Header> requestHeaders) throws IOException {
+    if (closed) throw new IOException("closed");
+    hpackWriter.writeHeaders(requestHeaders);
+
+    long byteCount = hpackBuffer.size();
+    int length = (int) Math.min(maxFrameSize - 4, byteCount);
+    byte type = TYPE_PUSH_PROMISE;
+    byte flags = byteCount == length ? FLAG_END_HEADERS : 0;
+    frameHeader(streamId, length + 4, type, flags);
+    sink.writeInt(promisedStreamId & 0x7fffffff);
+    sink.write(hpackBuffer, length);
+
+    if (byteCount > length) writeContinuationFrames(streamId, byteCount - length);
+  }
+
+  public synchronized void flush() throws IOException {
+    if (closed) throw new IOException("closed");
+    sink.flush();
+  }
+
+  public synchronized void synStream(boolean outFinished, int streamId,
+      int associatedStreamId, List<Header> headerBlock) throws IOException {
+    if (closed) throw new IOException("closed");
+    headers(outFinished, streamId, headerBlock);
+  }
+
+  public synchronized void synReply(boolean outFinished, int streamId,
+      List<Header> headerBlock) throws IOException {
+    if (closed) throw new IOException("closed");
+    headers(outFinished, streamId, headerBlock);
+  }
+
+  public synchronized void headers(int streamId, List<Header> headerBlock)
+      throws IOException {
+    if (closed) throw new IOException("closed");
+    headers(false, streamId, headerBlock);
+  }
+
+  public synchronized void rstStream(int streamId, ErrorCode errorCode)
+      throws IOException {
+    if (closed) throw new IOException("closed");
+    if (errorCode.httpCode == -1) throw new IllegalArgumentException();
+
+    int length = 4;
+    byte type = TYPE_RST_STREAM;
+    byte flags = FLAG_NONE;
+    frameHeader(streamId, length, type, flags);
+    sink.writeInt(errorCode.httpCode);
+    sink.flush();
+  }
+
+  /** The maximum size of bytes that may be sent in a single call to {@link #data}. */
+  public int maxDataLength() {
+    return maxFrameSize;
+  }
+
+  /**
+   * {@code source.length} may be longer than the max length of the variant's data frame.
+   * Implementations must send multiple frames as necessary.
+   *
+   * @param source the buffer to draw bytes from. May be null if byteCount is 0.
+   * @param byteCount must be between 0 and the minimum of {@code source.length} and {@link
+   * #maxDataLength}.
+   */
+  public synchronized void data(boolean outFinished, int streamId, Buffer source, int byteCount)
+      throws IOException {
+    if (closed) throw new IOException("closed");
+    byte flags = FLAG_NONE;
+    if (outFinished) flags |= FLAG_END_STREAM;
+    dataFrame(streamId, flags, source, byteCount);
+  }
+
+  void dataFrame(int streamId, byte flags, Buffer buffer, int byteCount) throws IOException {
+    byte type = TYPE_DATA;
+    frameHeader(streamId, byteCount, type, flags);
+    if (byteCount > 0) {
+      sink.write(buffer, byteCount);
+    }
+  }
+
+  /** Write okhttp's settings to the peer. */
+  public synchronized void settings(Settings settings) throws IOException {
+    if (closed) throw new IOException("closed");
+    int length = settings.size() * 6;
+    byte type = TYPE_SETTINGS;
+    byte flags = FLAG_NONE;
+    int streamId = 0;
+    frameHeader(streamId, length, type, flags);
+    for (int i = 0; i < Settings.COUNT; i++) {
+      if (!settings.isSet(i)) continue;
+      int id = i;
+      if (id == 4) {
+        id = 3; // SETTINGS_MAX_CONCURRENT_STREAMS renumbered.
+      } else if (id == 7) {
+        id = 4; // SETTINGS_INITIAL_WINDOW_SIZE renumbered.
+      }
+      sink.writeShort(id);
+      sink.writeInt(settings.get(i));
+    }
+    sink.flush();
+  }
+
+  /**
+   * Send a connection-level ping to the peer. {@code ack} indicates this is a reply. The data in
+   * {@code payload1} and {@code payload2} opaque binary, and there are no rules on the content.
+   */
+  public synchronized void ping(boolean ack, int payload1, int payload2) throws IOException {
+    if (closed) throw new IOException("closed");
+    int length = 8;
+    byte type = TYPE_PING;
+    byte flags = ack ? FLAG_ACK : FLAG_NONE;
+    int streamId = 0;
+    frameHeader(streamId, length, type, flags);
+    sink.writeInt(payload1);
+    sink.writeInt(payload2);
+    sink.flush();
+  }
+
+  /**
+   * Tell the peer to stop creating streams and that we last processed {@code lastGoodStreamId}, or
+   * zero if no streams were processed.
+   *
+   * @param lastGoodStreamId the last stream ID processed, or zero if no streams were processed.
+   * @param errorCode reason for closing the connection.
+   * @param debugData only valid for HTTP/2; opaque debug data to send.
+   */
+  public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
+      throws IOException {
+    if (closed) throw new IOException("closed");
+    if (errorCode.httpCode == -1) throw illegalArgument("errorCode.httpCode == -1");
+    int length = 8 + debugData.length;
+    byte type = TYPE_GOAWAY;
+    byte flags = FLAG_NONE;
+    int streamId = 0;
+    frameHeader(streamId, length, type, flags);
+    sink.writeInt(lastGoodStreamId);
+    sink.writeInt(errorCode.httpCode);
+    if (debugData.length > 0) {
+      sink.write(debugData);
+    }
+    sink.flush();
+  }
+
+  /**
+   * Inform peer that an additional {@code windowSizeIncrement} bytes can be sent on {@code
+   * streamId}, or the connection if {@code streamId} is zero.
+   */
+  public synchronized void windowUpdate(int streamId, long windowSizeIncrement) throws IOException {
+    if (closed) throw new IOException("closed");
+    if (windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL) {
+      throw illegalArgument("windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: %s",
+          windowSizeIncrement);
+    }
+    int length = 4;
+    byte type = TYPE_WINDOW_UPDATE;
+    byte flags = FLAG_NONE;
+    frameHeader(streamId, length, type, flags);
+    sink.writeInt((int) windowSizeIncrement);
+    sink.flush();
+  }
+
+  public void frameHeader(int streamId, int length, byte type, byte flags) throws IOException {
+    if (logger.isLoggable(FINE)) logger.fine(frameLog(false, streamId, length, type, flags));
+    if (length > maxFrameSize) {
+      throw illegalArgument("FRAME_SIZE_ERROR length > %d: %d", maxFrameSize, length);
+    }
+    if ((streamId & 0x80000000) != 0) throw illegalArgument("reserved bit set: %s", streamId);
+    writeMedium(sink, length);
+    sink.writeByte(type & 0xff);
+    sink.writeByte(flags & 0xff);
+    sink.writeInt(streamId & 0x7fffffff);
+  }
+
+  @Override public synchronized void close() throws IOException {
+    closed = true;
+    sink.close();
+  }
+
+  private static void writeMedium(BufferedSink sink, int i) throws IOException {
+    sink.writeByte((i >>> 16) & 0xff);
+    sink.writeByte((i >>> 8) & 0xff);
+    sink.writeByte(i & 0xff);
+  }
+
+  private void writeContinuationFrames(int streamId, long byteCount) throws IOException {
+    while (byteCount > 0) {
+      int length = (int) Math.min(maxFrameSize, byteCount);
+      byteCount -= length;
+      frameHeader(streamId, length, TYPE_CONTINUATION, byteCount == 0 ? FLAG_END_HEADERS : 0);
+      sink.write(hpackBuffer, length);
+    }
+  }
+
+  void headers(boolean outFinished, int streamId, List<Header> headerBlock) throws IOException {
+    if (closed) throw new IOException("closed");
+    hpackWriter.writeHeaders(headerBlock);
+
+    long byteCount = hpackBuffer.size();
+    int length = (int) Math.min(maxFrameSize, byteCount);
+    byte type = TYPE_HEADERS;
+    byte flags = byteCount == length ? FLAG_END_HEADERS : 0;
+    if (outFinished) flags |= FLAG_END_STREAM;
+    frameHeader(streamId, length, type, flags);
+    sink.write(hpackBuffer, length);
+
+    if (byteCount > length) writeContinuationFrames(streamId, byteCount - length);
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Huffman.java b/okhttp/src/main/java/okhttp3/internal/http2/Huffman.java
new file mode 100644
index 0000000000..7aa8024b72
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Huffman.java
@@ -0,0 +1,227 @@
+/*
+ * Copyright 2013 Twitter, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import okio.BufferedSink;
+import okio.ByteString;
+
+/**
+ * This class was originally composed from the following classes in <a
+ * href="https://github.com/twitter/hpack">Twitter Hpack</a>.
+ *
+ * <ul>
+ *     <li>{@code com.twitter.hpack.HuffmanEncoder}</li>
+ *     <li>{@code com.twitter.hpack.HuffmanDecoder}</li>
+ *     <li>{@code com.twitter.hpack.HpackUtil}</li>
+ * </ul>
+ */
+class Huffman {
+
+  // Appendix C: Huffman Codes
+  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#appendix-B
+  private static final int[] CODES = {
+      0x1ff8, 0x7fffd8, 0xfffffe2, 0xfffffe3, 0xfffffe4, 0xfffffe5, 0xfffffe6, 0xfffffe7, 0xfffffe8,
+      0xffffea, 0x3ffffffc, 0xfffffe9, 0xfffffea, 0x3ffffffd, 0xfffffeb, 0xfffffec, 0xfffffed,
+      0xfffffee, 0xfffffef, 0xffffff0, 0xffffff1, 0xffffff2, 0x3ffffffe, 0xffffff3, 0xffffff4,
+      0xffffff5, 0xffffff6, 0xffffff7, 0xffffff8, 0xffffff9, 0xffffffa, 0xffffffb, 0x14, 0x3f8,
+      0x3f9, 0xffa, 0x1ff9, 0x15, 0xf8, 0x7fa, 0x3fa, 0x3fb, 0xf9, 0x7fb, 0xfa, 0x16, 0x17, 0x18,
+      0x0, 0x1, 0x2, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x5c, 0xfb, 0x7ffc, 0x20, 0xffb,
+      0x3fc, 0x1ffa, 0x21, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
+      0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0xfc, 0x73, 0xfd, 0x1ffb, 0x7fff0,
+      0x1ffc, 0x3ffc, 0x22, 0x7ffd, 0x3, 0x23, 0x4, 0x24, 0x5, 0x25, 0x26, 0x27, 0x6, 0x74, 0x75,
+      0x28, 0x29, 0x2a, 0x7, 0x2b, 0x76, 0x2c, 0x8, 0x9, 0x2d, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7ffe,
+      0x7fc, 0x3ffd, 0x1ffd, 0xffffffc, 0xfffe6, 0x3fffd2, 0xfffe7, 0xfffe8, 0x3fffd3, 0x3fffd4,
+      0x3fffd5, 0x7fffd9, 0x3fffd6, 0x7fffda, 0x7fffdb, 0x7fffdc, 0x7fffdd, 0x7fffde, 0xffffeb,
+      0x7fffdf, 0xffffec, 0xffffed, 0x3fffd7, 0x7fffe0, 0xffffee, 0x7fffe1, 0x7fffe2, 0x7fffe3,
+      0x7fffe4, 0x1fffdc, 0x3fffd8, 0x7fffe5, 0x3fffd9, 0x7fffe6, 0x7fffe7, 0xffffef, 0x3fffda,
+      0x1fffdd, 0xfffe9, 0x3fffdb, 0x3fffdc, 0x7fffe8, 0x7fffe9, 0x1fffde, 0x7fffea, 0x3fffdd,
+      0x3fffde, 0xfffff0, 0x1fffdf, 0x3fffdf, 0x7fffeb, 0x7fffec, 0x1fffe0, 0x1fffe1, 0x3fffe0,
+      0x1fffe2, 0x7fffed, 0x3fffe1, 0x7fffee, 0x7fffef, 0xfffea, 0x3fffe2, 0x3fffe3, 0x3fffe4,
+      0x7ffff0, 0x3fffe5, 0x3fffe6, 0x7ffff1, 0x3ffffe0, 0x3ffffe1, 0xfffeb, 0x7fff1, 0x3fffe7,
+      0x7ffff2, 0x3fffe8, 0x1ffffec, 0x3ffffe2, 0x3ffffe3, 0x3ffffe4, 0x7ffffde, 0x7ffffdf,
+      0x3ffffe5, 0xfffff1, 0x1ffffed, 0x7fff2, 0x1fffe3, 0x3ffffe6, 0x7ffffe0, 0x7ffffe1, 0x3ffffe7,
+      0x7ffffe2, 0xfffff2, 0x1fffe4, 0x1fffe5, 0x3ffffe8, 0x3ffffe9, 0xffffffd, 0x7ffffe3,
+      0x7ffffe4, 0x7ffffe5, 0xfffec, 0xfffff3, 0xfffed, 0x1fffe6, 0x3fffe9, 0x1fffe7, 0x1fffe8,
+      0x7ffff3, 0x3fffea, 0x3fffeb, 0x1ffffee, 0x1ffffef, 0xfffff4, 0xfffff5, 0x3ffffea, 0x7ffff4,
+      0x3ffffeb, 0x7ffffe6, 0x3ffffec, 0x3ffffed, 0x7ffffe7, 0x7ffffe8, 0x7ffffe9, 0x7ffffea,
+      0x7ffffeb, 0xffffffe, 0x7ffffec, 0x7ffffed, 0x7ffffee, 0x7ffffef, 0x7fffff0, 0x3ffffee
+  };
+
+  private static final byte[] CODE_LENGTHS = {
+      13, 23, 28, 28, 28, 28, 28, 28, 28, 24, 30, 28, 28, 30, 28, 28, 28, 28, 28, 28, 28, 28, 30,
+      28, 28, 28, 28, 28, 28, 28, 28, 28, 6, 10, 10, 12, 13, 6, 8, 11, 10, 10, 8, 11, 8, 6, 6, 6, 5,
+      5, 5, 6, 6, 6, 6, 6, 6, 6, 7, 8, 15, 6, 12, 10, 13, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
+      7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 8, 13, 19, 13, 14, 6, 15, 5, 6, 5, 6, 5, 6, 6, 6, 5, 7, 7, 6,
+      6, 6, 5, 6, 7, 6, 5, 5, 6, 7, 7, 7, 7, 7, 15, 11, 14, 13, 28, 20, 22, 20, 20, 22, 22, 22, 23,
+      22, 23, 23, 23, 23, 23, 24, 23, 24, 24, 22, 23, 24, 23, 23, 23, 23, 21, 22, 23, 22, 23, 23,
+      24, 22, 21, 20, 22, 22, 23, 23, 21, 23, 22, 22, 24, 21, 22, 23, 23, 21, 21, 22, 21, 23, 22,
+      23, 23, 20, 22, 22, 22, 23, 22, 22, 23, 26, 26, 20, 19, 22, 23, 22, 25, 26, 26, 26, 27, 27,
+      26, 24, 25, 19, 21, 26, 27, 27, 26, 27, 24, 21, 21, 26, 26, 28, 27, 27, 27, 20, 24, 20, 21,
+      22, 21, 21, 23, 22, 22, 25, 25, 24, 24, 26, 23, 26, 27, 26, 26, 27, 27, 27, 27, 27, 28, 27,
+      27, 27, 27, 27, 26
+  };
+
+  private static final Huffman INSTANCE = new Huffman();
+
+  public static Huffman get() {
+    return INSTANCE;
+  }
+
+  private final Node root = new Node();
+
+  private Huffman() {
+    buildTree();
+  }
+
+  void encode(ByteString data, BufferedSink sink) throws IOException {
+    long current = 0;
+    int n = 0;
+
+    for (int i = 0; i < data.size(); i++) {
+      int b = data.getByte(i) & 0xFF;
+      int code = CODES[b];
+      int nbits = CODE_LENGTHS[b];
+
+      current <<= nbits;
+      current |= code;
+      n += nbits;
+
+      while (n >= 8) {
+        n -= 8;
+        sink.writeByte(((int) (current >> n)));
+      }
+    }
+
+    if (n > 0) {
+      current <<= (8 - n);
+      current |= (0xFF >>> n);
+      sink.writeByte((int) current);
+    }
+  }
+
+  int encodedLength(ByteString bytes) {
+    long len = 0;
+
+    for (int i = 0; i < bytes.size(); i++) {
+      int b = bytes.getByte(i) & 0xFF;
+      len += CODE_LENGTHS[b];
+    }
+
+    return (int) ((len + 7) >> 3);
+  }
+
+  byte[] decode(byte[] buf) {
+    ByteArrayOutputStream baos = new ByteArrayOutputStream();
+    Node node = root;
+    int current = 0;
+    int nbits = 0;
+    for (int i = 0; i < buf.length; i++) {
+      int b = buf[i] & 0xFF;
+      current = (current << 8) | b;
+      nbits += 8;
+      while (nbits >= 8) {
+        int c = (current >>> (nbits - 8)) & 0xFF;
+        node = node.children[c];
+        if (node.children == null) {
+          // terminal node
+          baos.write(node.symbol);
+          nbits -= node.terminalBits;
+          node = root;
+        } else {
+          // non-terminal node
+          nbits -= 8;
+        }
+      }
+    }
+
+    while (nbits > 0) {
+      int c = (current << (8 - nbits)) & 0xFF;
+      node = node.children[c];
+      if (node.children != null || node.terminalBits > nbits) {
+        break;
+      }
+      baos.write(node.symbol);
+      nbits -= node.terminalBits;
+      node = root;
+    }
+
+    return baos.toByteArray();
+  }
+
+  private void buildTree() {
+    for (int i = 0; i < CODE_LENGTHS.length; i++) {
+      addCode(i, CODES[i], CODE_LENGTHS[i]);
+    }
+  }
+
+  private void addCode(int sym, int code, byte len) {
+    Node terminal = new Node(sym, len);
+
+    Node current = root;
+    while (len > 8) {
+      len -= 8;
+      int i = ((code >>> len) & 0xFF);
+      if (current.children == null) {
+        throw new IllegalStateException("invalid dictionary: prefix not unique");
+      }
+      if (current.children[i] == null) {
+        current.children[i] = new Node();
+      }
+      current = current.children[i];
+    }
+
+    int shift = 8 - len;
+    int start = (code << shift) & 0xFF;
+    int end = 1 << shift;
+    for (int i = start; i < start + end; i++) {
+      current.children[i] = terminal;
+    }
+  }
+
+  private static final class Node {
+
+    // Null if terminal.
+    final Node[] children;
+
+    // Terminal nodes have a symbol.
+    final int symbol;
+
+    // Number of bits represented in the terminal node.
+    final int terminalBits;
+
+    /** Construct an internal node. */
+    Node() {
+      this.children = new Node[256];
+      this.symbol = 0; // Not read.
+      this.terminalBits = 0; // Not read.
+    }
+
+    /**
+     * Construct a terminal node.
+     *
+     * @param symbol symbol the node represents
+     * @param bits length of Huffman code in bits
+     */
+    Node(int symbol, int bits) {
+      this.children = null;
+      this.symbol = symbol;
+      int b = bits & 0x07;
+      this.terminalBits = b == 0 ? 8 : b;
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Ping.java b/okhttp/src/main/java/okhttp3/internal/http2/Ping.java
new file mode 100644
index 0000000000..7847db7aab
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Ping.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * A locally-originated ping.
+ */
+final class Ping {
+  private final CountDownLatch latch = new CountDownLatch(1);
+  private long sent = -1;
+  private long received = -1;
+
+  Ping() {
+  }
+
+  void send() {
+    if (sent != -1) throw new IllegalStateException();
+    sent = System.nanoTime();
+  }
+
+  void receive() {
+    if (received != -1 || sent == -1) throw new IllegalStateException();
+    received = System.nanoTime();
+    latch.countDown();
+  }
+
+  void cancel() {
+    if (received != -1 || sent == -1) throw new IllegalStateException();
+    received = sent - 1;
+    latch.countDown();
+  }
+
+  /**
+   * Returns the round trip time for this ping in nanoseconds, waiting for the response to arrive if
+   * necessary. Returns -1 if the response was canceled.
+   */
+  public long roundTripTime() throws InterruptedException {
+    latch.await();
+    return received - sent;
+  }
+
+  /**
+   * Returns the round trip time for this ping in nanoseconds, or -1 if the response was canceled,
+   * or -2 if the timeout elapsed before the round trip completed.
+   */
+  public long roundTripTime(long timeout, TimeUnit unit) throws InterruptedException {
+    if (latch.await(timeout, unit)) {
+      return received - sent;
+    } else {
+      return -2;
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/PushObserver.java b/okhttp/src/main/java/okhttp3/internal/http2/PushObserver.java
new file mode 100644
index 0000000000..8c08ddb56a
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http2/PushObserver.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import java.io.IOException;
+import java.util.List;
+import okhttp3.Protocol;
+import okio.BufferedSource;
+
+/**
+ * {@link Protocol#HTTP_2 HTTP/2} only. Processes server-initiated HTTP requests on the client.
+ * Implementations must quickly dispatch callbacks to avoid creating a bottleneck.
+ *
+ * <p>While {@link #onReset} may occur at any time, the following callbacks are expected in order,
+ * correlated by stream ID.
+ *
+ * <ul>
+ *     <li>{@link #onRequest}</li> <li>{@link #onHeaders} (unless canceled)
+ *     <li>{@link #onData} (optional sequence of data frames)
+ * </ul>
+ *
+ * <p>As a stream ID is scoped to a single HTTP/2 connection, implementations which target multiple
+ * connections should expect repetition of stream IDs.
+ *
+ * <p>Return true to request cancellation of a pushed stream.  Note that this does not guarantee
+ * future frames won't arrive on the stream ID.
+ */
+public interface PushObserver {
+  /**
+   * Describes the request that the server intends to push a response for.
+   *
+   * @param streamId server-initiated stream ID: an even number.
+   * @param requestHeaders minimally includes {@code :method}, {@code :scheme}, {@code :authority},
+   * and {@code :path}.
+   */
+  boolean onRequest(int streamId, List<Header> requestHeaders);
+
+  /**
+   * The response headers corresponding to a pushed request.  When {@code last} is true, there are
+   * no data frames to follow.
+   *
+   * @param streamId server-initiated stream ID: an even number.
+   * @param responseHeaders minimally includes {@code :status}.
+   * @param last when true, there is no response data.
+   */
+  boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last);
+
+  /**
+   * A chunk of response data corresponding to a pushed request.  This data must either be read or
+   * skipped.
+   *
+   * @param streamId server-initiated stream ID: an even number.
+   * @param source location of data corresponding with this stream ID.
+   * @param byteCount number of bytes to read or skip from the source.
+   * @param last when true, there are no data frames to follow.
+   */
+  boolean onData(int streamId, BufferedSource source, int byteCount, boolean last)
+      throws IOException;
+
+  /** Indicates the reason why this stream was canceled. */
+  void onReset(int streamId, ErrorCode errorCode);
+
+  PushObserver CANCEL = new PushObserver() {
+
+    @Override public boolean onRequest(int streamId, List<Header> requestHeaders) {
+      return true;
+    }
+
+    @Override public boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last) {
+      return true;
+    }
+
+    @Override public boolean onData(int streamId, BufferedSource source, int byteCount,
+        boolean last) throws IOException {
+      source.skip(byteCount);
+      return true;
+    }
+
+    @Override public void onReset(int streamId, ErrorCode errorCode) {
+    }
+  };
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Settings.java b/okhttp/src/main/java/okhttp3/internal/http2/Settings.java
new file mode 100644
index 0000000000..5b548de484
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Settings.java
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import java.util.Arrays;
+
+/**
+ * Settings describe characteristics of the sending peer, which are used by the receiving peer.
+ * Settings are {@link Http2Connection connection} scoped.
+ */
+public final class Settings {
+  /**
+   * From the HTTP/2 specs, the default initial window size for all streams is 64 KiB. (Chrome 25
+   * uses 10 MiB).
+   */
+  static final int DEFAULT_INITIAL_WINDOW_SIZE = 65535;
+
+  /** HTTP/2: Size in bytes of the table used to decode the sender's header blocks. */
+  static final int HEADER_TABLE_SIZE = 1;
+  /** HTTP/2: The peer must not send a PUSH_PROMISE frame when this is 0. */
+  static final int ENABLE_PUSH = 2;
+  /** Sender's maximum number of concurrent streams. */
+  static final int MAX_CONCURRENT_STREAMS = 4;
+  /** HTTP/2: Size in bytes of the largest frame payload the sender will accept. */
+  static final int MAX_FRAME_SIZE = 5;
+  /** HTTP/2: Advisory only. Size in bytes of the largest header list the sender will accept. */
+  static final int MAX_HEADER_LIST_SIZE = 6;
+  /** Window size in bytes. */
+  static final int INITIAL_WINDOW_SIZE = 7;
+
+  /** Total number of settings. */
+  static final int COUNT = 10;
+
+  /** Bitfield of which flags that values. */
+  private int set;
+
+  /** Flag values. */
+  private final int[] values = new int[COUNT];
+
+  void clear() {
+    set = 0;
+    Arrays.fill(values, 0);
+  }
+
+  Settings set(int id, int value) {
+    if (id < 0 || id >= values.length) {
+      return this; // Discard unknown settings.
+    }
+
+    int bit = 1 << id;
+    set |= bit;
+    values[id] = value;
+    return this;
+  }
+
+  /** Returns true if a value has been assigned for the setting {@code id}. */
+  boolean isSet(int id) {
+    int bit = 1 << id;
+    return (set & bit) != 0;
+  }
+
+  /** Returns the value for the setting {@code id}, or 0 if unset. */
+  int get(int id) {
+    return values[id];
+  }
+
+  /** Returns the number of settings that have values assigned. */
+  int size() {
+    return Integer.bitCount(set);
+  }
+
+  /** Returns -1 if unset. */
+  int getHeaderTableSize() {
+    int bit = 1 << HEADER_TABLE_SIZE;
+    return (bit & set) != 0 ? values[HEADER_TABLE_SIZE] : -1;
+  }
+
+  // TODO: honor this setting.
+  boolean getEnablePush(boolean defaultValue) {
+    int bit = 1 << ENABLE_PUSH;
+    return ((bit & set) != 0 ? values[ENABLE_PUSH] : defaultValue ? 1 : 0) == 1;
+  }
+
+  int getMaxConcurrentStreams(int defaultValue) {
+    int bit = 1 << MAX_CONCURRENT_STREAMS;
+    return (bit & set) != 0 ? values[MAX_CONCURRENT_STREAMS] : defaultValue;
+  }
+
+  int getMaxFrameSize(int defaultValue) {
+    int bit = 1 << MAX_FRAME_SIZE;
+    return (bit & set) != 0 ? values[MAX_FRAME_SIZE] : defaultValue;
+  }
+
+  int getMaxHeaderListSize(int defaultValue) {
+    int bit = 1 << MAX_HEADER_LIST_SIZE;
+    return (bit & set) != 0 ? values[MAX_HEADER_LIST_SIZE] : defaultValue;
+  }
+
+  int getInitialWindowSize() {
+    int bit = 1 << INITIAL_WINDOW_SIZE;
+    return (bit & set) != 0 ? values[INITIAL_WINDOW_SIZE] : DEFAULT_INITIAL_WINDOW_SIZE;
+  }
+
+  /**
+   * Writes {@code other} into this. If any setting is populated by this and {@code other}, the
+   * value and flags from {@code other} will be kept.
+   */
+  void merge(Settings other) {
+    for (int i = 0; i < COUNT; i++) {
+      if (!other.isSet(i)) continue;
+      set(i, other.get(i));
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/StreamResetException.java b/okhttp/src/main/java/okhttp3/internal/http2/StreamResetException.java
new file mode 100644
index 0000000000..299f81e1b9
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http2/StreamResetException.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import java.io.IOException;
+
+/** Thrown when an HTTP/2 stream is canceled without damage to the socket that carries it. */
+public final class StreamResetException extends IOException {
+  public final ErrorCode errorCode;
+
+  public StreamResetException(ErrorCode errorCode) {
+    super("stream was reset: " + errorCode);
+    this.errorCode = errorCode;
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/io/FileSystem.java b/okhttp/src/main/java/okhttp3/internal/io/FileSystem.java
new file mode 100644
index 0000000000..0b1b1cfbc4
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/io/FileSystem.java
@@ -0,0 +1,137 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.io;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import okio.Okio;
+import okio.Sink;
+import okio.Source;
+
+/**
+ * Access to read and write files on a hierarchical data store. Most callers should use the {@link
+ * #SYSTEM} implementation, which uses the host machine's local file system. Alternate
+ * implementations may be used to inject faults (for testing) or to transform stored data (to add
+ * encryption, for example).
+ *
+ * <p>All operations on a file system are racy. For example, guarding a call to {@link #source} with
+ * {@link #exists} does not guarantee that {@link FileNotFoundException} will not be thrown. The
+ * file may be moved between the two calls!
+ *
+ * <p>This interface is less ambitious than {@link java.nio.file.FileSystem} introduced in Java 7.
+ * It lacks important features like file watching, metadata, permissions, and disk space
+ * information. In exchange for these limitations, this interface is easier to implement and works
+ * on all versions of Java and Android.
+ */
+public interface FileSystem {
+  /** The host machine's local file system. */
+  FileSystem SYSTEM = new FileSystem() {
+    @Override public Source source(File file) throws FileNotFoundException {
+      return Okio.source(file);
+    }
+
+    @Override public Sink sink(File file) throws FileNotFoundException {
+      try {
+        return Okio.sink(file);
+      } catch (FileNotFoundException e) {
+        // Maybe the parent directory doesn't exist? Try creating it first.
+        file.getParentFile().mkdirs();
+        return Okio.sink(file);
+      }
+    }
+
+    @Override public Sink appendingSink(File file) throws FileNotFoundException {
+      try {
+        return Okio.appendingSink(file);
+      } catch (FileNotFoundException e) {
+        // Maybe the parent directory doesn't exist? Try creating it first.
+        file.getParentFile().mkdirs();
+        return Okio.appendingSink(file);
+      }
+    }
+
+    @Override public void delete(File file) throws IOException {
+      // If delete() fails, make sure it's because the file didn't exist!
+      if (!file.delete() && file.exists()) {
+        throw new IOException("failed to delete " + file);
+      }
+    }
+
+    @Override public boolean exists(File file) {
+      return file.exists();
+    }
+
+    @Override public long size(File file) {
+      return file.length();
+    }
+
+    @Override public void rename(File from, File to) throws IOException {
+      delete(to);
+      if (!from.renameTo(to)) {
+        throw new IOException("failed to rename " + from + " to " + to);
+      }
+    }
+
+    @Override public void deleteContents(File directory) throws IOException {
+      File[] files = directory.listFiles();
+      if (files == null) {
+        throw new IOException("not a readable directory: " + directory);
+      }
+      for (File file : files) {
+        if (file.isDirectory()) {
+          deleteContents(file);
+        }
+        if (!file.delete()) {
+          throw new IOException("failed to delete " + file);
+        }
+      }
+    }
+  };
+
+  /** Reads from {@code file}. */
+  Source source(File file) throws FileNotFoundException;
+
+  /**
+   * Writes to {@code file}, discarding any data already present. Creates parent directories if
+   * necessary.
+   */
+  Sink sink(File file) throws FileNotFoundException;
+
+  /**
+   * Writes to {@code file}, appending if data is already present. Creates parent directories if
+   * necessary.
+   */
+  Sink appendingSink(File file) throws FileNotFoundException;
+
+  /** Deletes {@code file} if it exists. Throws if the file exists and cannot be deleted. */
+  void delete(File file) throws IOException;
+
+  /** Returns true if {@code file} exists on the file system. */
+  boolean exists(File file);
+
+  /** Returns the number of bytes stored in {@code file}, or 0 if it does not exist. */
+  long size(File file);
+
+  /** Renames {@code from} to {@code to}. Throws if the file cannot be renamed. */
+  void rename(File from, File to) throws IOException;
+
+  /**
+   * Recursively delete the contents of {@code directory}. Throws an IOException if any file could
+   * not be deleted, or if {@code dir} is not a readable directory.
+   */
+  void deleteContents(File directory) throws IOException;
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java b/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java
new file mode 100644
index 0000000000..342e91f150
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java
@@ -0,0 +1,429 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform;
+
+import android.os.Build;
+import android.util.Log;
+import java.io.IOException;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.net.InetSocketAddress;
+import java.net.Socket;
+import java.security.Security;
+import java.security.cert.Certificate;
+import java.security.cert.TrustAnchor;
+import java.security.cert.X509Certificate;
+import java.util.List;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.Protocol;
+import okhttp3.internal.Util;
+import okhttp3.internal.tls.BasicTrustRootIndex;
+import okhttp3.internal.tls.CertificateChainCleaner;
+import okhttp3.internal.tls.TrustRootIndex;
+
+import static okhttp3.internal.Util.assertionError;
+
+/** Android 2.3 or better. */
+class AndroidPlatform extends Platform {
+  private static final int MAX_LOG_LENGTH = 4000;
+
+  private final Class<?> sslParametersClass;
+  private final OptionalMethod<Socket> setUseSessionTickets;
+  private final OptionalMethod<Socket> setHostname;
+
+  // Non-null on Android 5.0+.
+  private final OptionalMethod<Socket> getAlpnSelectedProtocol;
+  private final OptionalMethod<Socket> setAlpnProtocols;
+
+  private final CloseGuard closeGuard = CloseGuard.get();
+
+  AndroidPlatform(Class<?> sslParametersClass, OptionalMethod<Socket> setUseSessionTickets,
+      OptionalMethod<Socket> setHostname, OptionalMethod<Socket> getAlpnSelectedProtocol,
+      OptionalMethod<Socket> setAlpnProtocols) {
+    this.sslParametersClass = sslParametersClass;
+    this.setUseSessionTickets = setUseSessionTickets;
+    this.setHostname = setHostname;
+    this.getAlpnSelectedProtocol = getAlpnSelectedProtocol;
+    this.setAlpnProtocols = setAlpnProtocols;
+  }
+
+  @Override public void connectSocket(Socket socket, InetSocketAddress address,
+      int connectTimeout) throws IOException {
+    try {
+      socket.connect(address, connectTimeout);
+    } catch (AssertionError e) {
+      if (Util.isAndroidGetsocknameError(e)) throw new IOException(e);
+      throw e;
+    } catch (SecurityException e) {
+      // Before android 4.3, socket.connect could throw a SecurityException
+      // if opening a socket resulted in an EACCES error.
+      IOException ioException = new IOException("Exception in connect");
+      ioException.initCause(e);
+      throw ioException;
+    } catch (ClassCastException e) {
+      // On android 8.0, socket.connect throws a ClassCastException due to a bug
+      // see https://issuetracker.google.com/issues/63649622
+      if (Build.VERSION.SDK_INT == 26) {
+        IOException ioException = new IOException("Exception in connect");
+        ioException.initCause(e);
+        throw ioException;
+      } else {
+        throw e;
+      }
+    }
+  }
+
+  @Override protected X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
+    Object context = readFieldOrNull(sslSocketFactory, sslParametersClass, "sslParameters");
+    if (context == null) {
+      // If that didn't work, try the Google Play Services SSL provider before giving up. This
+      // must be loaded by the SSLSocketFactory's class loader.
+      try {
+        Class<?> gmsSslParametersClass = Class.forName(
+            "com.google.android.gms.org.conscrypt.SSLParametersImpl", false,
+            sslSocketFactory.getClass().getClassLoader());
+        context = readFieldOrNull(sslSocketFactory, gmsSslParametersClass, "sslParameters");
+      } catch (ClassNotFoundException e) {
+        return super.trustManager(sslSocketFactory);
+      }
+    }
+
+    X509TrustManager x509TrustManager = readFieldOrNull(
+        context, X509TrustManager.class, "x509TrustManager");
+    if (x509TrustManager != null) return x509TrustManager;
+
+    return readFieldOrNull(context, X509TrustManager.class, "trustManager");
+  }
+
+  @Override public void configureTlsExtensions(
+      SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
+    // Enable SNI and session tickets.
+    if (hostname != null) {
+      setUseSessionTickets.invokeOptionalWithoutCheckedException(sslSocket, true);
+      setHostname.invokeOptionalWithoutCheckedException(sslSocket, hostname);
+    }
+
+    // Enable ALPN.
+    if (setAlpnProtocols != null && setAlpnProtocols.isSupported(sslSocket)) {
+      Object[] parameters = {concatLengthPrefixed(protocols)};
+      setAlpnProtocols.invokeWithoutCheckedException(sslSocket, parameters);
+    }
+  }
+
+  @Override public String getSelectedProtocol(SSLSocket socket) {
+    if (getAlpnSelectedProtocol == null) return null;
+    if (!getAlpnSelectedProtocol.isSupported(socket)) return null;
+
+    byte[] alpnResult = (byte[]) getAlpnSelectedProtocol.invokeWithoutCheckedException(socket);
+    return alpnResult != null ? new String(alpnResult, Util.UTF_8) : null;
+  }
+
+  @Override public void log(int level, String message, Throwable t) {
+    int logLevel = level == WARN ? Log.WARN : Log.DEBUG;
+    if (t != null) message = message + '\n' + Log.getStackTraceString(t);
+
+    // Split by line, then ensure each line can fit into Log's maximum length.
+    for (int i = 0, length = message.length(); i < length; i++) {
+      int newline = message.indexOf('\n', i);
+      newline = newline != -1 ? newline : length;
+      do {
+        int end = Math.min(newline, i + MAX_LOG_LENGTH);
+        Log.println(logLevel, "OkHttp", message.substring(i, end));
+        i = end;
+      } while (i < newline);
+    }
+  }
+
+  @Override public Object getStackTraceForCloseable(String closer) {
+    return closeGuard.createAndOpen(closer);
+  }
+
+  @Override public void logCloseableLeak(String message, Object stackTrace) {
+    boolean reported = closeGuard.warnIfOpen(stackTrace);
+    if (!reported) {
+      // Unable to report via CloseGuard. As a last-ditch effort, send it to the logger.
+      log(WARN, message, null);
+    }
+  }
+
+  @Override public boolean isCleartextTrafficPermitted(String hostname) {
+    try {
+      Class<?> networkPolicyClass = Class.forName("android.security.NetworkSecurityPolicy");
+      Method getInstanceMethod = networkPolicyClass.getMethod("getInstance");
+      Object networkSecurityPolicy = getInstanceMethod.invoke(null);
+      return api24IsCleartextTrafficPermitted(hostname, networkPolicyClass, networkSecurityPolicy);
+    } catch (ClassNotFoundException | NoSuchMethodException e) {
+      return super.isCleartextTrafficPermitted(hostname);
+    } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
+      throw assertionError("unable to determine cleartext support", e);
+    }
+  }
+
+  private boolean api24IsCleartextTrafficPermitted(String hostname, Class<?> networkPolicyClass,
+      Object networkSecurityPolicy) throws InvocationTargetException, IllegalAccessException {
+    try {
+      Method isCleartextTrafficPermittedMethod = networkPolicyClass
+          .getMethod("isCleartextTrafficPermitted", String.class);
+      return (boolean) isCleartextTrafficPermittedMethod.invoke(networkSecurityPolicy, hostname);
+    } catch (NoSuchMethodException e) {
+      return api23IsCleartextTrafficPermitted(hostname, networkPolicyClass, networkSecurityPolicy);
+    }
+  }
+
+  private boolean api23IsCleartextTrafficPermitted(String hostname, Class<?> networkPolicyClass,
+      Object networkSecurityPolicy) throws InvocationTargetException, IllegalAccessException {
+    try {
+      Method isCleartextTrafficPermittedMethod = networkPolicyClass
+          .getMethod("isCleartextTrafficPermitted");
+      return (boolean) isCleartextTrafficPermittedMethod.invoke(networkSecurityPolicy);
+    } catch (NoSuchMethodException e) {
+      return super.isCleartextTrafficPermitted(hostname);
+    }
+  }
+
+  /**
+   * Checks to see if Google Play Services Dynamic Security Provider is present which provides ALPN
+   * support. If it isn't checks to see if device is Android 5.0+ since 4.x device have broken
+   * ALPN support.
+   */
+  private static boolean supportsAlpn() {
+    if (Security.getProvider("GMSCore_OpenSSL") != null) {
+      return true;
+    } else {
+      try {
+        Class.forName("android.net.Network"); // Arbitrary class added in Android 5.0.
+        return true;
+      } catch (ClassNotFoundException ignored) { }
+    }
+    return false;
+  }
+
+  public CertificateChainCleaner buildCertificateChainCleaner(X509TrustManager trustManager) {
+    try {
+      Class<?> extensionsClass = Class.forName("android.net.http.X509TrustManagerExtensions");
+      Constructor<?> constructor = extensionsClass.getConstructor(X509TrustManager.class);
+      Object extensions = constructor.newInstance(trustManager);
+      Method checkServerTrusted = extensionsClass.getMethod(
+          "checkServerTrusted", X509Certificate[].class, String.class, String.class);
+      return new AndroidCertificateChainCleaner(extensions, checkServerTrusted);
+    } catch (Exception e) {
+      return super.buildCertificateChainCleaner(trustManager);
+    }
+  }
+
+  public static Platform buildIfSupported() {
+    // Attempt to find Android 2.3+ APIs.
+    try {
+      Class<?> sslParametersClass;
+      try {
+        sslParametersClass = Class.forName("com.android.org.conscrypt.SSLParametersImpl");
+      } catch (ClassNotFoundException e) {
+        // Older platform before being unbundled.
+        sslParametersClass = Class.forName(
+            "org.apache.harmony.xnet.provider.jsse.SSLParametersImpl");
+      }
+
+      OptionalMethod<Socket> setUseSessionTickets = new OptionalMethod<>(
+          null, "setUseSessionTickets", boolean.class);
+      OptionalMethod<Socket> setHostname = new OptionalMethod<>(
+          null, "setHostname", String.class);
+      OptionalMethod<Socket> getAlpnSelectedProtocol = null;
+      OptionalMethod<Socket> setAlpnProtocols = null;
+
+      if (supportsAlpn()) {
+        getAlpnSelectedProtocol
+            = new OptionalMethod<>(byte[].class, "getAlpnSelectedProtocol");
+        setAlpnProtocols
+            = new OptionalMethod<>(null, "setAlpnProtocols", byte[].class);
+      }
+
+      return new AndroidPlatform(sslParametersClass, setUseSessionTickets, setHostname,
+          getAlpnSelectedProtocol, setAlpnProtocols);
+    } catch (ClassNotFoundException ignored) {
+      // This isn't an Android runtime.
+    }
+
+    return null;
+  }
+
+  @Override
+  public TrustRootIndex buildTrustRootIndex(X509TrustManager trustManager) {
+
+    try {
+      // From org.conscrypt.TrustManagerImpl, we want the method with this signature:
+      // private TrustAnchor findTrustAnchorByIssuerAndSignature(X509Certificate lastCert);
+      Method method = trustManager.getClass().getDeclaredMethod(
+              "findTrustAnchorByIssuerAndSignature", X509Certificate.class);
+      method.setAccessible(true);
+      return new AndroidTrustRootIndex(trustManager, method);
+    } catch (NoSuchMethodException e) {
+      return super.buildTrustRootIndex(trustManager);
+    }
+  }
+
+  /**
+   * X509TrustManagerExtensions was added to Android in API 17 (Android 4.2, released in late 2012).
+   * This is the best way to get a clean chain on Android because it uses the same code as the TLS
+   * handshake.
+   */
+  static final class AndroidCertificateChainCleaner extends CertificateChainCleaner {
+    private final Object x509TrustManagerExtensions;
+    private final Method checkServerTrusted;
+
+    AndroidCertificateChainCleaner(Object x509TrustManagerExtensions, Method checkServerTrusted) {
+      this.x509TrustManagerExtensions = x509TrustManagerExtensions;
+      this.checkServerTrusted = checkServerTrusted;
+    }
+
+    @SuppressWarnings({"unchecked", "SuspiciousToArrayCall"}) // Reflection on List<Certificate>.
+    @Override public List<Certificate> clean(List<Certificate> chain, String hostname)
+        throws SSLPeerUnverifiedException {
+      try {
+        X509Certificate[] certificates = chain.toArray(new X509Certificate[chain.size()]);
+        return (List<Certificate>) checkServerTrusted.invoke(
+            x509TrustManagerExtensions, certificates, "RSA", hostname);
+      } catch (InvocationTargetException e) {
+        SSLPeerUnverifiedException exception = new SSLPeerUnverifiedException(e.getMessage());
+        exception.initCause(e);
+        throw exception;
+      } catch (IllegalAccessException e) {
+        throw new AssertionError(e);
+      }
+    }
+
+    @Override public boolean equals(Object other) {
+      return other instanceof AndroidCertificateChainCleaner; // All instances are equivalent.
+    }
+
+    @Override public int hashCode() {
+      return 0;
+    }
+  }
+
+  /**
+   * Provides access to the internal dalvik.system.CloseGuard class. Android uses this in
+   * combination with android.os.StrictMode to report on leaked java.io.Closeable's. Available since
+   * Android API 11.
+   */
+  static final class CloseGuard {
+    private final Method getMethod;
+    private final Method openMethod;
+    private final Method warnIfOpenMethod;
+
+    CloseGuard(Method getMethod, Method openMethod, Method warnIfOpenMethod) {
+      this.getMethod = getMethod;
+      this.openMethod = openMethod;
+      this.warnIfOpenMethod = warnIfOpenMethod;
+    }
+
+    Object createAndOpen(String closer) {
+      if (getMethod != null) {
+        try {
+          Object closeGuardInstance = getMethod.invoke(null);
+          openMethod.invoke(closeGuardInstance, closer);
+          return closeGuardInstance;
+        } catch (Exception ignored) {
+        }
+      }
+      return null;
+    }
+
+    boolean warnIfOpen(Object closeGuardInstance) {
+      boolean reported = false;
+      if (closeGuardInstance != null) {
+        try {
+          warnIfOpenMethod.invoke(closeGuardInstance);
+          reported = true;
+        } catch (Exception ignored) {
+        }
+      }
+      return reported;
+    }
+
+    static CloseGuard get() {
+      Method getMethod;
+      Method openMethod;
+      Method warnIfOpenMethod;
+
+      try {
+        Class<?> closeGuardClass = Class.forName("dalvik.system.CloseGuard");
+        getMethod = closeGuardClass.getMethod("get");
+        openMethod = closeGuardClass.getMethod("open", String.class);
+        warnIfOpenMethod = closeGuardClass.getMethod("warnIfOpen");
+      } catch (Exception ignored) {
+        getMethod = null;
+        openMethod = null;
+        warnIfOpenMethod = null;
+      }
+      return new CloseGuard(getMethod, openMethod, warnIfOpenMethod);
+    }
+  }
+
+  /**
+   * An index of trusted root certificates that exploits knowledge of Android implementation
+   * details. This class is potentially much faster to initialize than {@link BasicTrustRootIndex}
+   * because it doesn't need to load and index trusted CA certificates.
+   *
+   * <p>This class uses APIs added to Android in API 14 (Android 4.0, released October 2011). This
+   * class shouldn't be used in Android API 17 or better because those releases are better served by
+   * {@link AndroidPlatform.AndroidCertificateChainCleaner}.
+   */
+  static final class AndroidTrustRootIndex implements TrustRootIndex {
+    private final X509TrustManager trustManager;
+    private final Method findByIssuerAndSignatureMethod;
+
+    AndroidTrustRootIndex(X509TrustManager trustManager, Method findByIssuerAndSignatureMethod) {
+      this.findByIssuerAndSignatureMethod = findByIssuerAndSignatureMethod;
+      this.trustManager = trustManager;
+    }
+
+    @Override public X509Certificate findByIssuerAndSignature(X509Certificate cert) {
+      try {
+        TrustAnchor trustAnchor = (TrustAnchor) findByIssuerAndSignatureMethod.invoke(
+                trustManager, cert);
+        return trustAnchor != null
+                ? trustAnchor.getTrustedCert()
+                : null;
+      } catch (IllegalAccessException e) {
+        throw assertionError("unable to get issues and signature", e);
+      } catch (InvocationTargetException e) {
+        return null;
+      }
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+      if (obj == this) {
+        return true;
+      }
+      if (!(obj instanceof AndroidTrustRootIndex)) {
+        return false;
+      }
+      AndroidTrustRootIndex that = (AndroidTrustRootIndex) obj;
+      return trustManager.equals(that.trustManager)
+              && findByIssuerAndSignatureMethod.equals(that.findByIssuerAndSignatureMethod);
+    }
+
+    @Override
+    public int hashCode() {
+      return trustManager.hashCode() + 31 * findByIssuerAndSignatureMethod.hashCode();
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java b/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java
new file mode 100644
index 0000000000..24b75217b0
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.List;
+import javax.net.ssl.SSLParameters;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.Protocol;
+
+import static okhttp3.internal.Util.assertionError;
+
+/**
+ * OpenJDK 9+.
+ */
+final class Jdk9Platform extends Platform {
+  final Method setProtocolMethod;
+  final Method getProtocolMethod;
+
+  Jdk9Platform(Method setProtocolMethod, Method getProtocolMethod) {
+    this.setProtocolMethod = setProtocolMethod;
+    this.getProtocolMethod = getProtocolMethod;
+  }
+
+  @Override
+  public void configureTlsExtensions(SSLSocket sslSocket, String hostname,
+      List<Protocol> protocols) {
+    try {
+      SSLParameters sslParameters = sslSocket.getSSLParameters();
+
+      List<String> names = alpnProtocolNames(protocols);
+
+      setProtocolMethod.invoke(sslParameters,
+          new Object[] {names.toArray(new String[names.size()])});
+
+      sslSocket.setSSLParameters(sslParameters);
+    } catch (IllegalAccessException | InvocationTargetException e) {
+      throw assertionError("unable to set ssl parameters", e);
+    }
+  }
+
+  @Override
+  public String getSelectedProtocol(SSLSocket socket) {
+    try {
+      String protocol = (String) getProtocolMethod.invoke(socket);
+
+      // SSLSocket.getApplicationProtocol returns "" if application protocols values will not
+      // be used. Observed if you didn't specify SSLParameters.setApplicationProtocols
+      if (protocol == null || protocol.equals("")) {
+        return null;
+      }
+
+      return protocol;
+    } catch (IllegalAccessException | InvocationTargetException e) {
+      throw assertionError("unable to get selected protocols", e);
+    }
+  }
+
+  @Override public X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
+    // Not supported due to access checks on JDK 9+:
+    // java.lang.reflect.InaccessibleObjectException: Unable to make member of class
+    // sun.security.ssl.SSLSocketFactoryImpl accessible:  module java.base does not export
+    // sun.security.ssl to unnamed module @xxx
+    throw new UnsupportedOperationException(
+        "clientBuilder.sslSocketFactory(SSLSocketFactory) not supported on JDK 9+");
+  }
+
+  public static Jdk9Platform buildIfSupported() {
+    // Find JDK 9 new methods
+    try {
+      Method setProtocolMethod =
+          SSLParameters.class.getMethod("setApplicationProtocols", String[].class);
+      Method getProtocolMethod = SSLSocket.class.getMethod("getApplicationProtocol");
+
+      return new Jdk9Platform(setProtocolMethod, getProtocolMethod);
+    } catch (NoSuchMethodException ignored) {
+      // pre JDK 9
+    }
+
+    return null;
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java b/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java
new file mode 100644
index 0000000000..bfb4ed8c89
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java
@@ -0,0 +1,151 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform;
+
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Proxy;
+import java.util.List;
+import javax.net.ssl.SSLSocket;
+import okhttp3.Protocol;
+import okhttp3.internal.Util;
+
+import static okhttp3.internal.Util.assertionError;
+
+/**
+ * OpenJDK 7 or OpenJDK 8 with {@code org.mortbay.jetty.alpn/alpn-boot} in the boot class path.
+ */
+class JdkWithJettyBootPlatform extends Platform {
+  private final Method putMethod;
+  private final Method getMethod;
+  private final Method removeMethod;
+  private final Class<?> clientProviderClass;
+  private final Class<?> serverProviderClass;
+
+  JdkWithJettyBootPlatform(Method putMethod, Method getMethod, Method removeMethod,
+      Class<?> clientProviderClass, Class<?> serverProviderClass) {
+    this.putMethod = putMethod;
+    this.getMethod = getMethod;
+    this.removeMethod = removeMethod;
+    this.clientProviderClass = clientProviderClass;
+    this.serverProviderClass = serverProviderClass;
+  }
+
+  @Override public void configureTlsExtensions(
+      SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
+    List<String> names = alpnProtocolNames(protocols);
+
+    try {
+      Object provider = Proxy.newProxyInstance(Platform.class.getClassLoader(),
+          new Class[] {clientProviderClass, serverProviderClass}, new JettyNegoProvider(names));
+      putMethod.invoke(null, sslSocket, provider);
+    } catch (InvocationTargetException | IllegalAccessException e) {
+      throw assertionError("unable to set alpn", e);
+    }
+  }
+
+  @Override public void afterHandshake(SSLSocket sslSocket) {
+    try {
+      removeMethod.invoke(null, sslSocket);
+    } catch (IllegalAccessException | InvocationTargetException e) {
+      throw assertionError("unable to remove alpn", e);
+    }
+  }
+
+  @Override public String getSelectedProtocol(SSLSocket socket) {
+    try {
+      JettyNegoProvider provider =
+          (JettyNegoProvider) Proxy.getInvocationHandler(getMethod.invoke(null, socket));
+      if (!provider.unsupported && provider.selected == null) {
+        Platform.get().log(INFO, "ALPN callback dropped: HTTP/2 is disabled. "
+            + "Is alpn-boot on the boot class path?", null);
+        return null;
+      }
+      return provider.unsupported ? null : provider.selected;
+    } catch (InvocationTargetException | IllegalAccessException e) {
+      throw assertionError("unable to get selected protocol", e);
+    }
+  }
+
+  public static Platform buildIfSupported() {
+    // Find Jetty's ALPN extension for OpenJDK.
+    try {
+      String negoClassName = "org.eclipse.jetty.alpn.ALPN";
+      Class<?> negoClass = Class.forName(negoClassName);
+      Class<?> providerClass = Class.forName(negoClassName + "$Provider");
+      Class<?> clientProviderClass = Class.forName(negoClassName + "$ClientProvider");
+      Class<?> serverProviderClass = Class.forName(negoClassName + "$ServerProvider");
+      Method putMethod = negoClass.getMethod("put", SSLSocket.class, providerClass);
+      Method getMethod = negoClass.getMethod("get", SSLSocket.class);
+      Method removeMethod = negoClass.getMethod("remove", SSLSocket.class);
+      return new JdkWithJettyBootPlatform(
+          putMethod, getMethod, removeMethod, clientProviderClass, serverProviderClass);
+    } catch (ClassNotFoundException | NoSuchMethodException ignored) {
+    }
+
+    return null;
+  }
+
+  /**
+   * Handle the methods of ALPN's ClientProvider and ServerProvider without a compile-time
+   * dependency on those interfaces.
+   */
+  private static class JettyNegoProvider implements InvocationHandler {
+    /** This peer's supported protocols. */
+    private final List<String> protocols;
+    /** Set when remote peer notifies ALPN is unsupported. */
+    boolean unsupported;
+    /** The protocol the server selected. */
+    String selected;
+
+    JettyNegoProvider(List<String> protocols) {
+      this.protocols = protocols;
+    }
+
+    @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
+      String methodName = method.getName();
+      Class<?> returnType = method.getReturnType();
+      if (args == null) {
+        args = Util.EMPTY_STRING_ARRAY;
+      }
+      if (methodName.equals("supports") && boolean.class == returnType) {
+        return true; // ALPN is supported.
+      } else if (methodName.equals("unsupported") && void.class == returnType) {
+        this.unsupported = true; // Peer doesn't support ALPN.
+        return null;
+      } else if (methodName.equals("protocols") && args.length == 0) {
+        return protocols; // Client advertises these protocols.
+      } else if ((methodName.equals("selectProtocol") || methodName.equals("select"))
+          && String.class == returnType && args.length == 1 && args[0] instanceof List) {
+        List<String> peerProtocols = (List) args[0];
+        // Pick the first known protocol the peer advertises.
+        for (int i = 0, size = peerProtocols.size(); i < size; i++) {
+          if (protocols.contains(peerProtocols.get(i))) {
+            return selected = peerProtocols.get(i);
+          }
+        }
+        return selected = protocols.get(0); // On no intersection, try peer's first protocol.
+      } else if ((methodName.equals("protocolSelected") || methodName.equals("selected"))
+          && args.length == 1) {
+        this.selected = (String) args[0]; // Server selected this protocol.
+        return null;
+      } else {
+        return method.invoke(this, args);
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/OptionalMethod.java b/okhttp/src/main/java/okhttp3/internal/platform/OptionalMethod.java
new file mode 100644
index 0000000000..c26132fedb
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/OptionalMethod.java
@@ -0,0 +1,174 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package okhttp3.internal.platform;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+
+/**
+ * Duck-typing for methods: Represents a method that may or may not be present on an object.
+ *
+ * @param <T> the type of the object the method might be on, typically an interface or base class
+ */
+class OptionalMethod<T> {
+
+  /** The return type of the method. null means "don't care". */
+  private final Class<?> returnType;
+
+  private final String methodName;
+
+  private final Class[] methodParams;
+
+  /**
+   * Creates an optional method.
+   *
+   * @param returnType the return type to required, null if it does not matter
+   * @param methodName the name of the method
+   * @param methodParams the method parameter types
+   */
+  OptionalMethod(Class<?> returnType, String methodName, Class... methodParams) {
+    this.returnType = returnType;
+    this.methodName = methodName;
+    this.methodParams = methodParams;
+  }
+
+  /**
+   * Returns true if the method exists on the supplied {@code target}.
+   */
+  public boolean isSupported(T target) {
+    return getMethod(target.getClass()) != null;
+  }
+
+  /**
+   * Invokes the method on {@code target} with {@code args}. If the method does not exist or is not
+   * public then {@code null} is returned. See also {@link #invokeOptionalWithoutCheckedException}.
+   *
+   * @throws IllegalArgumentException if the arguments are invalid
+   * @throws InvocationTargetException if the invocation throws an exception
+   */
+  public Object invokeOptional(T target, Object... args) throws InvocationTargetException {
+    Method m = getMethod(target.getClass());
+    if (m == null) {
+      return null;
+    }
+    try {
+      return m.invoke(target, args);
+    } catch (IllegalAccessException e) {
+      return null;
+    }
+  }
+
+  /**
+   * Invokes the method on {@code target}.  If the method does not exist or is not public then
+   * {@code null} is returned. Any RuntimeException thrown by the method is thrown, checked
+   * exceptions are wrapped in an {@link AssertionError}.
+   *
+   * @throws IllegalArgumentException if the arguments are invalid
+   */
+  public Object invokeOptionalWithoutCheckedException(T target, Object... args) {
+    try {
+      return invokeOptional(target, args);
+    } catch (InvocationTargetException e) {
+      Throwable targetException = e.getTargetException();
+      if (targetException instanceof RuntimeException) {
+        throw (RuntimeException) targetException;
+      }
+      AssertionError error = new AssertionError("Unexpected exception");
+      error.initCause(targetException);
+      throw error;
+    }
+  }
+
+  /**
+   * Invokes the method on {@code target} with {@code args}. Throws an error if the method is not
+   * supported. See also {@link #invokeWithoutCheckedException(Object, Object...)}.
+   *
+   * @throws IllegalArgumentException if the arguments are invalid
+   * @throws InvocationTargetException if the invocation throws an exception
+   */
+  public Object invoke(T target, Object... args) throws InvocationTargetException {
+    Method m = getMethod(target.getClass());
+    if (m == null) {
+      throw new AssertionError("Method " + methodName + " not supported for object " + target);
+    }
+    try {
+      return m.invoke(target, args);
+    } catch (IllegalAccessException e) {
+      // Method should be public: we checked.
+      AssertionError error = new AssertionError("Unexpectedly could not call: " + m);
+      error.initCause(e);
+      throw error;
+    }
+  }
+
+  /**
+   * Invokes the method on {@code target}. Throws an error if the method is not supported. Any
+   * RuntimeException thrown by the method is thrown, checked exceptions are wrapped in an {@link
+   * AssertionError}.
+   *
+   * @throws IllegalArgumentException if the arguments are invalid
+   */
+  public Object invokeWithoutCheckedException(T target, Object... args) {
+    try {
+      return invoke(target, args);
+    } catch (InvocationTargetException e) {
+      Throwable targetException = e.getTargetException();
+      if (targetException instanceof RuntimeException) {
+        throw (RuntimeException) targetException;
+      }
+      AssertionError error = new AssertionError("Unexpected exception");
+      error.initCause(targetException);
+      throw error;
+    }
+  }
+
+  /**
+   * Perform a lookup for the method. No caching. In order to return a method the method name and
+   * arguments must match those specified when the {@link OptionalMethod} was created. If the return
+   * type is specified (i.e. non-null) it must also be compatible. The method must also be public.
+   */
+  private Method getMethod(Class<?> clazz) {
+    Method method = null;
+    if (methodName != null) {
+      method = getPublicMethod(clazz, methodName, methodParams);
+      if (method != null
+          && returnType != null
+          && !returnType.isAssignableFrom(method.getReturnType())) {
+
+        // If the return type is non-null it must be compatible.
+        method = null;
+      }
+    }
+    return method;
+  }
+
+  private static Method getPublicMethod(Class<?> clazz, String methodName, Class[] parameterTypes) {
+    Method method = null;
+    try {
+      method = clazz.getMethod(methodName, parameterTypes);
+      if ((method.getModifiers() & Modifier.PUBLIC) == 0) {
+        method = null;
+      }
+    } catch (NoSuchMethodException e) {
+      // None.
+    }
+    return method;
+  }
+}
+
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Platform.java b/okhttp/src/main/java/okhttp3/internal/platform/Platform.java
new file mode 100644
index 0000000000..c4e12b4b38
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/Platform.java
@@ -0,0 +1,247 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform;
+
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.net.InetSocketAddress;
+import java.net.Socket;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.internal.tls.BasicCertificateChainCleaner;
+import okhttp3.internal.tls.BasicTrustRootIndex;
+import okhttp3.internal.tls.CertificateChainCleaner;
+import okhttp3.internal.tls.TrustRootIndex;
+import okio.Buffer;
+
+/**
+ * Access to platform-specific features.
+ *
+ * <h3>Server name indication (SNI)</h3>
+ *
+ * <p>Supported on Android 2.3+.
+ *
+ * Supported on OpenJDK 7+
+ *
+ * <h3>Session Tickets</h3>
+ *
+ * <p>Supported on Android 2.3+.
+ *
+ * <h3>Android Traffic Stats (Socket Tagging)</h3>
+ *
+ * <p>Supported on Android 4.0+.
+ *
+ * <h3>ALPN (Application Layer Protocol Negotiation)</h3>
+ *
+ * <p>Supported on Android 5.0+. The APIs were present in Android 4.4, but that implementation was
+ * unstable.
+ *
+ * Supported on OpenJDK 7 and 8 (via the JettyALPN-boot library).
+ *
+ * Supported on OpenJDK 9 via SSLParameters and SSLSocket features.
+ *
+ * <h3>Trust Manager Extraction</h3>
+ *
+ * <p>Supported on Android 2.3+ and OpenJDK 7+. There are no public APIs to recover the trust
+ * manager that was used to create an {@link SSLSocketFactory}.
+ *
+ * <h3>Android Cleartext Permit Detection</h3>
+ *
+ * <p>Supported on Android 6.0+ via {@code NetworkSecurityPolicy}.
+ */
+public class Platform {
+  private static final Platform PLATFORM = findPlatform();
+  public static final int INFO = 4;
+  public static final int WARN = 5;
+  private static final Logger logger = Logger.getLogger(OkHttpClient.class.getName());
+
+  public static Platform get() {
+    return PLATFORM;
+  }
+
+  /** Prefix used on custom headers. */
+  public String getPrefix() {
+    return "OkHttp";
+  }
+
+  protected X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
+    // Attempt to get the trust manager from an OpenJDK socket factory. We attempt this on all
+    // platforms in order to support Robolectric, which mixes classes from both Android and the
+    // Oracle JDK. Note that we don't support HTTP/2 or other nice features on Robolectric.
+    try {
+      Class<?> sslContextClass = Class.forName("sun.security.ssl.SSLContextImpl");
+      Object context = readFieldOrNull(sslSocketFactory, sslContextClass, "context");
+      if (context == null) return null;
+      return readFieldOrNull(context, X509TrustManager.class, "trustManager");
+    } catch (ClassNotFoundException e) {
+      return null;
+    }
+  }
+
+  /**
+   * Configure TLS extensions on {@code sslSocket} for {@code route}.
+   *
+   * @param hostname non-null for client-side handshakes; null for server-side handshakes.
+   */
+  public void configureTlsExtensions(SSLSocket sslSocket, String hostname,
+      List<Protocol> protocols) {
+  }
+
+  /**
+   * Called after the TLS handshake to release resources allocated by {@link
+   * #configureTlsExtensions}.
+   */
+  public void afterHandshake(SSLSocket sslSocket) {
+  }
+
+  /** Returns the negotiated protocol, or null if no protocol was negotiated. */
+  public String getSelectedProtocol(SSLSocket socket) {
+    return null;
+  }
+
+  public void connectSocket(Socket socket, InetSocketAddress address,
+      int connectTimeout) throws IOException {
+    socket.connect(address, connectTimeout);
+  }
+
+  public void log(int level, String message, Throwable t) {
+    Level logLevel = level == WARN ? Level.WARNING : Level.INFO;
+    logger.log(logLevel, message, t);
+  }
+
+  public boolean isCleartextTrafficPermitted(String hostname) {
+    return true;
+  }
+
+  /**
+   * Returns an object that holds a stack trace created at the moment this method is executed. This
+   * should be used specifically for {@link java.io.Closeable} objects and in conjunction with
+   * {@link #logCloseableLeak(String, Object)}.
+   */
+  public Object getStackTraceForCloseable(String closer) {
+    if (logger.isLoggable(Level.FINE)) {
+      return new Throwable(closer); // These are expensive to allocate.
+    }
+    return null;
+  }
+
+  public void logCloseableLeak(String message, Object stackTrace) {
+    if (stackTrace == null) {
+      message += " To see where this was allocated, set the OkHttpClient logger level to FINE: "
+          + "Logger.getLogger(OkHttpClient.class.getName()).setLevel(Level.FINE);";
+    }
+    log(WARN, message, (Throwable) stackTrace);
+  }
+
+  public static List<String> alpnProtocolNames(List<Protocol> protocols) {
+    List<String> names = new ArrayList<>(protocols.size());
+    for (int i = 0, size = protocols.size(); i < size; i++) {
+      Protocol protocol = protocols.get(i);
+      if (protocol == Protocol.HTTP_1_0) continue; // No HTTP/1.0 for ALPN.
+      names.add(protocol.toString());
+    }
+    return names;
+  }
+
+  public CertificateChainCleaner buildCertificateChainCleaner(X509TrustManager trustManager) {
+    return new BasicCertificateChainCleaner(buildTrustRootIndex(trustManager));
+  }
+
+  public CertificateChainCleaner buildCertificateChainCleaner(SSLSocketFactory sslSocketFactory) {
+    X509TrustManager trustManager = trustManager(sslSocketFactory);
+
+    if (trustManager == null) {
+      throw new IllegalStateException("Unable to extract the trust manager on " + Platform.get()
+          + ", sslSocketFactory is " + sslSocketFactory.getClass());
+    }
+
+    return buildCertificateChainCleaner(trustManager);
+  }
+
+  /** Attempt to match the host runtime to a capable Platform implementation. */
+  private static Platform findPlatform() {
+    Platform android = AndroidPlatform.buildIfSupported();
+
+    if (android != null) {
+      return android;
+    }
+
+    Platform jdk9 = Jdk9Platform.buildIfSupported();
+
+    if (jdk9 != null) {
+      return jdk9;
+    }
+
+    Platform jdkWithJettyBoot = JdkWithJettyBootPlatform.buildIfSupported();
+
+    if (jdkWithJettyBoot != null) {
+      return jdkWithJettyBoot;
+    }
+
+    // Probably an Oracle JDK like OpenJDK.
+    return new Platform();
+  }
+
+  /**
+   * Returns the concatenation of 8-bit, length prefixed protocol names.
+   * http://tools.ietf.org/html/draft-agl-tls-nextprotoneg-04#page-4
+   */
+  static byte[] concatLengthPrefixed(List<Protocol> protocols) {
+    Buffer result = new Buffer();
+    for (int i = 0, size = protocols.size(); i < size; i++) {
+      Protocol protocol = protocols.get(i);
+      if (protocol == Protocol.HTTP_1_0) continue; // No HTTP/1.0 for ALPN.
+      result.writeByte(protocol.toString().length());
+      result.writeUtf8(protocol.toString());
+    }
+    return result.readByteArray();
+  }
+
+  static <T> T readFieldOrNull(Object instance, Class<T> fieldType, String fieldName) {
+    for (Class<?> c = instance.getClass(); c != Object.class; c = c.getSuperclass()) {
+      try {
+        Field field = c.getDeclaredField(fieldName);
+        field.setAccessible(true);
+        Object value = field.get(instance);
+        if (value == null || !fieldType.isInstance(value)) return null;
+        return fieldType.cast(value);
+      } catch (NoSuchFieldException ignored) {
+      } catch (IllegalAccessException e) {
+        throw new AssertionError();
+      }
+    }
+
+    // Didn't find the field we wanted. As a last gasp attempt, try to find the value on a delegate.
+    if (!fieldName.equals("delegate")) {
+      Object delegate = readFieldOrNull(instance, Object.class, "delegate");
+      if (delegate != null) return readFieldOrNull(delegate, fieldType, fieldName);
+    }
+
+    return null;
+  }
+
+    public TrustRootIndex buildTrustRootIndex(X509TrustManager trustManager) {
+      return new BasicTrustRootIndex(trustManager.getAcceptedIssuers());
+    }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.java b/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.java
new file mode 100644
index 0000000000..75dafdd0a3
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.java
@@ -0,0 +1,340 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.publicsuffix;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InterruptedIOException;
+import java.net.IDN;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicBoolean;
+import okhttp3.internal.Util;
+import okhttp3.internal.platform.Platform;
+import okio.BufferedSource;
+import okio.GzipSource;
+import okio.Okio;
+
+import static okhttp3.internal.Util.closeQuietly;
+
+/**
+ * A database of public suffixes provided by
+ * <a href="https://publicsuffix.org/">publicsuffix.org</a>.
+ */
+public final class PublicSuffixDatabase {
+  public static final String PUBLIC_SUFFIX_RESOURCE = "publicsuffixes.gz";
+
+  private static final byte[] WILDCARD_LABEL = new byte[]{'*'};
+  private static final String[] EMPTY_RULE = new String[0];
+  private static final String[] PREVAILING_RULE = new String[]{"*"};
+
+  private static final byte EXCEPTION_MARKER = '!';
+
+  private static final PublicSuffixDatabase instance = new PublicSuffixDatabase();
+
+  /** True after we've attempted to read the list for the first time. */
+  private final AtomicBoolean listRead = new AtomicBoolean(false);
+
+  /** Used for concurrent threads reading the list for the first time. */
+  private final CountDownLatch readCompleteLatch = new CountDownLatch(1);
+
+  // The lists are held as a large array of UTF-8 bytes. This is to avoid allocating lots of strings
+  // that will likely never be used. Each rule is separated by '\n'. Please see the
+  // PublicSuffixListGenerator class for how these lists are generated.
+  // Guarded by this.
+  private byte[] publicSuffixListBytes;
+  private byte[] publicSuffixExceptionListBytes;
+
+  public static PublicSuffixDatabase get() {
+    return instance;
+  }
+
+  /**
+   * Returns the effective top-level domain plus one (eTLD+1) by referencing the public suffix list.
+   * Returns null if the domain is a public suffix.
+   *
+   * <p>Here are some examples: <pre>{@code
+   * assertEquals("google.com", getEffectiveTldPlusOne("google.com"));
+   * assertEquals("google.com", getEffectiveTldPlusOne("www.google.com"));
+   * assertNull(getEffectiveTldPlusOne("com"));
+   * }</pre>
+   *
+   * @param domain A canonicalized domain. An International Domain Name (IDN) should be punycode
+   *    encoded.
+   */
+  public String getEffectiveTldPlusOne(String domain) {
+    if (domain == null) throw new NullPointerException("domain == null");
+
+    // We use UTF-8 in the list so we need to convert to Unicode.
+    String unicodeDomain = IDN.toUnicode(domain);
+    String[] domainLabels = unicodeDomain.split("\\.");
+    String[] rule = findMatchingRule(domainLabels);
+    if (domainLabels.length == rule.length && rule[0].charAt(0) != EXCEPTION_MARKER) {
+      // The domain is a public suffix.
+      return null;
+    }
+
+    int firstLabelOffset;
+    if (rule[0].charAt(0) == EXCEPTION_MARKER) {
+      // Exception rules hold the effective TLD plus one.
+      firstLabelOffset = domainLabels.length - rule.length;
+    } else {
+      // Otherwise the rule is for a public suffix, so we must take one more label.
+      firstLabelOffset = domainLabels.length - (rule.length + 1);
+    }
+
+    StringBuilder effectiveTldPlusOne = new StringBuilder();
+    String[] punycodeLabels = domain.split("\\.");
+    for (int i = firstLabelOffset; i < punycodeLabels.length; i++) {
+      effectiveTldPlusOne.append(punycodeLabels[i]).append('.');
+    }
+    effectiveTldPlusOne.deleteCharAt(effectiveTldPlusOne.length() - 1);
+
+    return effectiveTldPlusOne.toString();
+  }
+
+  private String[] findMatchingRule(String[] domainLabels) {
+    if (!listRead.get() && listRead.compareAndSet(false, true)) {
+      readTheListUninterruptibly();
+    } else {
+      try {
+        readCompleteLatch.await();
+      } catch (InterruptedException ignored) {
+      }
+    }
+
+    synchronized (this) {
+      if (publicSuffixListBytes == null) {
+        throw new IllegalStateException("Unable to load " + PUBLIC_SUFFIX_RESOURCE + " resource "
+            + "from the classpath.");
+      }
+    }
+
+    // Break apart the domain into UTF-8 labels, i.e. foo.bar.com turns into [foo, bar, com].
+    byte[][] domainLabelsUtf8Bytes = new byte[domainLabels.length][];
+    for (int i = 0; i < domainLabels.length; i++) {
+      domainLabelsUtf8Bytes[i] = domainLabels[i].getBytes(Util.UTF_8);
+    }
+
+    // Start by looking for exact matches. We start at the leftmost label. For example, foo.bar.com
+    // will look like: [foo, bar, com], [bar, com], [com]. The longest matching rule wins.
+    String exactMatch = null;
+    for (int i = 0; i < domainLabelsUtf8Bytes.length; i++) {
+      String rule = binarySearchBytes(publicSuffixListBytes, domainLabelsUtf8Bytes, i);
+      if (rule != null) {
+        exactMatch = rule;
+        break;
+      }
+    }
+
+    // In theory, wildcard rules are not restricted to having the wildcard in the leftmost position.
+    // In practice, wildcards are always in the leftmost position. For now, this implementation
+    // cheats and does not attempt every possible permutation. Instead, it only considers wildcards
+    // in the leftmost position. We assert this fact when we generate the public suffix file. If
+    // this assertion ever fails we'll need to refactor this implementation.
+    String wildcardMatch = null;
+    if (domainLabelsUtf8Bytes.length > 1) {
+      byte[][] labelsWithWildcard = domainLabelsUtf8Bytes.clone();
+      for (int labelIndex = 0; labelIndex < labelsWithWildcard.length - 1; labelIndex++) {
+        labelsWithWildcard[labelIndex] = WILDCARD_LABEL;
+        String rule = binarySearchBytes(publicSuffixListBytes, labelsWithWildcard, labelIndex);
+        if (rule != null) {
+          wildcardMatch = rule;
+          break;
+        }
+      }
+    }
+
+    // Exception rules only apply to wildcard rules, so only try it if we matched a wildcard.
+    String exception = null;
+    if (wildcardMatch != null) {
+      for (int labelIndex = 0; labelIndex < domainLabelsUtf8Bytes.length - 1; labelIndex++) {
+        String rule = binarySearchBytes(
+            publicSuffixExceptionListBytes, domainLabelsUtf8Bytes, labelIndex);
+        if (rule != null) {
+          exception = rule;
+          break;
+        }
+      }
+    }
+
+    if (exception != null) {
+      // Signal we've identified an exception rule.
+      exception = "!" + exception;
+      return exception.split("\\.");
+    } else if (exactMatch == null && wildcardMatch == null) {
+      return PREVAILING_RULE;
+    }
+
+    String[] exactRuleLabels = exactMatch != null
+        ? exactMatch.split("\\.")
+        : EMPTY_RULE;
+
+    String[] wildcardRuleLabels = wildcardMatch != null
+        ? wildcardMatch.split("\\.")
+        : EMPTY_RULE;
+
+    return exactRuleLabels.length > wildcardRuleLabels.length
+        ? exactRuleLabels
+        : wildcardRuleLabels;
+  }
+
+  private static String binarySearchBytes(byte[] bytesToSearch, byte[][] labels, int labelIndex) {
+    int low = 0;
+    int high = bytesToSearch.length;
+    String match = null;
+    while (low < high) {
+      int mid = (low + high) / 2;
+      // Search for a '\n' that marks the start of a value. Don't go back past the start of the
+      // array.
+      while (mid > -1 && bytesToSearch[mid] != '\n') {
+        mid--;
+      }
+      mid++;
+
+      // Now look for the ending '\n'.
+      int end = 1;
+      while (bytesToSearch[mid + end] != '\n') {
+        end++;
+      }
+      int publicSuffixLength = (mid + end) - mid;
+
+      // Compare the bytes. Note that the file stores UTF-8 encoded bytes, so we must compare the
+      // unsigned bytes.
+      int compareResult;
+      int currentLabelIndex = labelIndex;
+      int currentLabelByteIndex = 0;
+      int publicSuffixByteIndex = 0;
+
+      boolean expectDot = false;
+      while (true) {
+        int byte0;
+        if (expectDot) {
+          byte0 = '.';
+          expectDot = false;
+        } else {
+          byte0 = labels[currentLabelIndex][currentLabelByteIndex] & 0xff;
+        }
+
+        int byte1 = bytesToSearch[mid + publicSuffixByteIndex] & 0xff;
+
+        compareResult = byte0 - byte1;
+        if (compareResult != 0) break;
+
+        publicSuffixByteIndex++;
+        currentLabelByteIndex++;
+        if (publicSuffixByteIndex == publicSuffixLength) break;
+
+        if (labels[currentLabelIndex].length == currentLabelByteIndex) {
+          // We've exhausted our current label. Either there are more labels to compare, in which
+          // case we expect a dot as the next character. Otherwise, we've checked all our labels.
+          if (currentLabelIndex == labels.length - 1) {
+            break;
+          } else {
+            currentLabelIndex++;
+            currentLabelByteIndex = -1;
+            expectDot = true;
+          }
+        }
+      }
+
+      if (compareResult < 0) {
+        high = mid - 1;
+      } else if (compareResult > 0) {
+        low = mid + end + 1;
+      } else {
+        // We found a match, but are the lengths equal?
+        int publicSuffixBytesLeft = publicSuffixLength - publicSuffixByteIndex;
+        int labelBytesLeft = labels[currentLabelIndex].length - currentLabelByteIndex;
+        for (int i = currentLabelIndex + 1; i < labels.length; i++) {
+          labelBytesLeft += labels[i].length;
+        }
+
+        if (labelBytesLeft < publicSuffixBytesLeft) {
+          high = mid - 1;
+        } else if (labelBytesLeft > publicSuffixBytesLeft) {
+          low = mid + end + 1;
+        } else {
+          // Found a match.
+          match = new String(bytesToSearch, mid, publicSuffixLength, Util.UTF_8);
+          break;
+        }
+      }
+    }
+    return match;
+  }
+
+  /**
+   * Reads the public suffix list treating the operation as uninterruptible. We always want to read
+   * the list otherwise we'll be left in a bad state. If the thread was interrupted prior to this
+   * operation, it will be re-interrupted after the list is read.
+   */
+  private void readTheListUninterruptibly() {
+    boolean interrupted = false;
+    try {
+      while (true) {
+        try {
+          readTheList();
+          return;
+        } catch (InterruptedIOException e) {
+          interrupted = true;
+        } catch (IOException e) {
+          Platform.get().log(Platform.WARN, "Failed to read public suffix list", e);
+          return;
+        }
+      }
+    } finally {
+      if (interrupted) {
+        Thread.currentThread().interrupt();
+      }
+    }
+  }
+
+  private void readTheList() throws IOException {
+    byte[] publicSuffixListBytes;
+    byte[] publicSuffixExceptionListBytes;
+
+    InputStream resource = PublicSuffixDatabase.class.getResourceAsStream(PUBLIC_SUFFIX_RESOURCE);
+    if (resource == null) return;
+
+    BufferedSource bufferedSource = Okio.buffer(new GzipSource(Okio.source(resource)));
+    try {
+      int totalBytes = bufferedSource.readInt();
+      publicSuffixListBytes = new byte[totalBytes];
+      bufferedSource.readFully(publicSuffixListBytes);
+
+      int totalExceptionBytes = bufferedSource.readInt();
+      publicSuffixExceptionListBytes = new byte[totalExceptionBytes];
+      bufferedSource.readFully(publicSuffixExceptionListBytes);
+    } finally {
+      closeQuietly(bufferedSource);
+    }
+
+    synchronized (this) {
+      this.publicSuffixListBytes = publicSuffixListBytes;
+      this.publicSuffixExceptionListBytes = publicSuffixExceptionListBytes;
+    }
+
+    readCompleteLatch.countDown();
+  }
+
+  /** Visible for testing. */
+  void setListBytes(byte[] publicSuffixListBytes, byte[] publicSuffixExceptionListBytes) {
+    this.publicSuffixListBytes = publicSuffixListBytes;
+    this.publicSuffixExceptionListBytes = publicSuffixExceptionListBytes;
+    listRead.set(true);
+    readCompleteLatch.countDown();
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/BasicCertificateChainCleaner.java b/okhttp/src/main/java/okhttp3/internal/tls/BasicCertificateChainCleaner.java
new file mode 100644
index 0000000000..8a8c1d11d2
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/tls/BasicCertificateChainCleaner.java
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.tls;
+
+import java.security.GeneralSecurityException;
+import java.security.cert.Certificate;
+import java.security.cert.X509Certificate;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Deque;
+import java.util.Iterator;
+import java.util.List;
+import javax.net.ssl.SSLPeerUnverifiedException;
+
+/**
+ * A certificate chain cleaner that uses a set of trusted root certificates to build the trusted
+ * chain. This class duplicates the clean chain building performed during the TLS handshake. We
+ * prefer other mechanisms where they exist, such as with
+ * {@code okhttp3.internal.platform.AndroidPlatform.AndroidCertificateChainCleaner}.
+ *
+ * <p>This class includes code from <a href="https://conscrypt.org/">Conscrypt's</a> {@code
+ * TrustManagerImpl} and {@code TrustedCertificateIndex}.
+ */
+public final class BasicCertificateChainCleaner extends CertificateChainCleaner {
+  /** The maximum number of signers in a chain. We use 9 for consistency with OpenSSL. */
+  private static final int MAX_SIGNERS = 9;
+
+  private final TrustRootIndex trustRootIndex;
+
+  public BasicCertificateChainCleaner(TrustRootIndex trustRootIndex) {
+    this.trustRootIndex = trustRootIndex;
+  }
+
+  /**
+   * Returns a cleaned chain for {@code chain}.
+   *
+   * <p>This method throws if the complete chain to a trusted CA certificate cannot be constructed.
+   * This is unexpected unless the trust root index in this class has a different trust manager than
+   * what was used to establish {@code chain}.
+   */
+  @Override public List<Certificate> clean(List<Certificate> chain, String hostname)
+      throws SSLPeerUnverifiedException {
+    Deque<Certificate> queue = new ArrayDeque<>(chain);
+    List<Certificate> result = new ArrayList<>();
+    result.add(queue.removeFirst());
+    boolean foundTrustedCertificate = false;
+
+    followIssuerChain:
+    for (int c = 0; c < MAX_SIGNERS; c++) {
+      X509Certificate toVerify = (X509Certificate) result.get(result.size() - 1);
+
+      // If this cert has been signed by a trusted cert, use that. Add the trusted certificate to
+      // the end of the chain unless it's already present. (That would happen if the first
+      // certificate in the chain is itself a self-signed and trusted CA certificate.)
+      X509Certificate trustedCert = trustRootIndex.findByIssuerAndSignature(toVerify);
+      if (trustedCert != null) {
+        if (result.size() > 1 || !toVerify.equals(trustedCert)) {
+          result.add(trustedCert);
+        }
+        if (verifySignature(trustedCert, trustedCert)) {
+          return result; // The self-signed cert is a root CA. We're done.
+        }
+        foundTrustedCertificate = true;
+        continue;
+      }
+
+      // Search for the certificate in the chain that signed this certificate. This is typically
+      // the next element in the chain, but it could be any element.
+      for (Iterator<Certificate> i = queue.iterator(); i.hasNext(); ) {
+        X509Certificate signingCert = (X509Certificate) i.next();
+        if (verifySignature(toVerify, signingCert)) {
+          i.remove();
+          result.add(signingCert);
+          continue followIssuerChain;
+        }
+      }
+
+      // We've reached the end of the chain. If any cert in the chain is trusted, we're done.
+      if (foundTrustedCertificate) {
+        return result;
+      }
+
+      // The last link isn't trusted. Fail.
+      throw new SSLPeerUnverifiedException(
+          "Failed to find a trusted cert that signed " + toVerify);
+    }
+
+    throw new SSLPeerUnverifiedException("Certificate chain too long: " + result);
+  }
+
+  /** Returns true if {@code toVerify} was signed by {@code signingCert}'s public key. */
+  private boolean verifySignature(X509Certificate toVerify, X509Certificate signingCert) {
+    if (!toVerify.getIssuerDN().equals(signingCert.getSubjectDN())) return false;
+    try {
+      toVerify.verify(signingCert.getPublicKey());
+      return true;
+    } catch (GeneralSecurityException verifyFailed) {
+      return false;
+    }
+  }
+
+  @Override public int hashCode() {
+    return trustRootIndex.hashCode();
+  }
+
+  @Override public boolean equals(Object other) {
+    if (other == this) return true;
+    return other instanceof BasicCertificateChainCleaner
+        && ((BasicCertificateChainCleaner) other).trustRootIndex.equals(trustRootIndex);
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/BasicTrustRootIndex.java b/okhttp/src/main/java/okhttp3/internal/tls/BasicTrustRootIndex.java
new file mode 100644
index 0000000000..cfd8923668
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/tls/BasicTrustRootIndex.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.tls;
+
+import java.security.PublicKey;
+import java.security.cert.X509Certificate;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
+import java.util.Map;
+import java.util.Set;
+import javax.security.auth.x500.X500Principal;
+
+/** A simple index that of trusted root certificates that have been loaded into memory. */
+public final class BasicTrustRootIndex implements TrustRootIndex {
+  private final Map<X500Principal, Set<X509Certificate>> subjectToCaCerts;
+
+  public BasicTrustRootIndex(X509Certificate... caCerts) {
+    subjectToCaCerts = new LinkedHashMap<>();
+    for (X509Certificate caCert : caCerts) {
+      X500Principal subject = caCert.getSubjectX500Principal();
+      Set<X509Certificate> subjectCaCerts = subjectToCaCerts.get(subject);
+      if (subjectCaCerts == null) {
+        subjectCaCerts = new LinkedHashSet<>(1);
+        subjectToCaCerts.put(subject, subjectCaCerts);
+      }
+      subjectCaCerts.add(caCert);
+    }
+  }
+
+  @Override public X509Certificate findByIssuerAndSignature(X509Certificate cert) {
+    X500Principal issuer = cert.getIssuerX500Principal();
+    Set<X509Certificate> subjectCaCerts = subjectToCaCerts.get(issuer);
+    if (subjectCaCerts == null) return null;
+
+    for (X509Certificate caCert : subjectCaCerts) {
+      PublicKey publicKey = caCert.getPublicKey();
+      try {
+        cert.verify(publicKey);
+        return caCert;
+      } catch (Exception ignored) {
+      }
+    }
+
+    return null;
+  }
+
+  @Override public boolean equals(Object other) {
+    if (other == this) return true;
+    return other instanceof okhttp3.internal.tls.BasicTrustRootIndex
+        && ((okhttp3.internal.tls.BasicTrustRootIndex) other).subjectToCaCerts.equals(
+        subjectToCaCerts);
+  }
+
+  @Override public int hashCode() {
+    return subjectToCaCerts.hashCode();
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java b/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java
new file mode 100644
index 0000000000..98060db27a
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java
@@ -0,0 +1,47 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3.internal.tls;
+
+import java.security.cert.Certificate;
+import java.security.cert.X509Certificate;
+import java.util.List;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.internal.platform.Platform;
+
+/**
+ * Computes the effective certificate chain from the raw array returned by Java's built in TLS APIs.
+ * Cleaning a chain returns a list of certificates where the first element is {@code chain[0]}, each
+ * certificate is signed by the certificate that follows, and the last certificate is a trusted CA
+ * certificate.
+ *
+ * <p>Use of the chain cleaner is necessary to omit unexpected certificates that aren't relevant to
+ * the TLS handshake and to extract the trusted CA certificate for the benefit of certificate
+ * pinning.
+ */
+public abstract class CertificateChainCleaner {
+  public abstract List<Certificate> clean(List<Certificate> chain, String hostname)
+      throws SSLPeerUnverifiedException;
+
+  public static CertificateChainCleaner get(X509TrustManager trustManager) {
+    return Platform.get().buildCertificateChainCleaner(trustManager);
+  }
+
+  public static CertificateChainCleaner get(X509Certificate... caCerts) {
+    return new BasicCertificateChainCleaner(new BasicTrustRootIndex(caCerts));
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/DistinguishedNameParser.java b/okhttp/src/main/java/okhttp3/internal/tls/DistinguishedNameParser.java
new file mode 100644
index 0000000000..cae8dfae76
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/tls/DistinguishedNameParser.java
@@ -0,0 +1,406 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3.internal.tls;
+
+import javax.security.auth.x500.X500Principal;
+
+/**
+ * A distinguished name (DN) parser. This parser only supports extracting a string value from a DN.
+ * It doesn't support values in the hex-string style.
+ */
+final class DistinguishedNameParser {
+  private final String dn;
+  private final int length;
+  private int pos;
+  private int beg;
+  private int end;
+
+  /** Temporary variable to store positions of the currently parsed item. */
+  private int cur;
+
+  /** Distinguished name characters. */
+  private char[] chars;
+
+  DistinguishedNameParser(X500Principal principal) {
+    // RFC2253 is used to ensure we get attributes in the reverse
+    // order of the underlying ASN.1 encoding, so that the most
+    // significant values of repeated attributes occur first.
+    this.dn = principal.getName(X500Principal.RFC2253);
+    this.length = this.dn.length();
+  }
+
+  // gets next attribute type: (ALPHA 1*keychar) / oid
+  private String nextAT() {
+    // skip preceding space chars, they can present after
+    // comma or semicolon (compatibility with RFC 1779)
+    for (; pos < length && chars[pos] == ' '; pos++) {
+    }
+    if (pos == length) {
+      return null; // reached the end of DN
+    }
+
+    // mark the beginning of attribute type
+    beg = pos;
+
+    // attribute type chars
+    pos++;
+    for (; pos < length && chars[pos] != '=' && chars[pos] != ' '; pos++) {
+      // we don't follow exact BNF syntax here:
+      // accept any char except space and '='
+    }
+    if (pos >= length) {
+      throw new IllegalStateException("Unexpected end of DN: " + dn);
+    }
+
+    // mark the end of attribute type
+    end = pos;
+
+    // skip trailing space chars between attribute type and '='
+    // (compatibility with RFC 1779)
+    if (chars[pos] == ' ') {
+      for (; pos < length && chars[pos] != '=' && chars[pos] == ' '; pos++) {
+      }
+
+      if (chars[pos] != '=' || pos == length) {
+        throw new IllegalStateException("Unexpected end of DN: " + dn);
+      }
+    }
+
+    pos++; //skip '=' char
+
+    // skip space chars between '=' and attribute value
+    // (compatibility with RFC 1779)
+    for (; pos < length && chars[pos] == ' '; pos++) {
+    }
+
+    // in case of oid attribute type skip its prefix: "oid." or "OID."
+    // (compatibility with RFC 1779)
+    if ((end - beg > 4) && (chars[beg + 3] == '.')
+        && (chars[beg] == 'O' || chars[beg] == 'o')
+        && (chars[beg + 1] == 'I' || chars[beg + 1] == 'i')
+        && (chars[beg + 2] == 'D' || chars[beg + 2] == 'd')) {
+      beg += 4;
+    }
+
+    return new String(chars, beg, end - beg);
+  }
+
+  // gets quoted attribute value: QUOTATION *( quotechar / pair ) QUOTATION
+  private String quotedAV() {
+    pos++;
+    beg = pos;
+    end = beg;
+    while (true) {
+
+      if (pos == length) {
+        throw new IllegalStateException("Unexpected end of DN: " + dn);
+      }
+
+      if (chars[pos] == '"') {
+        // enclosing quotation was found
+        pos++;
+        break;
+      } else if (chars[pos] == '\\') {
+        chars[end] = getEscaped();
+      } else {
+        // shift char: required for string with escaped chars
+        chars[end] = chars[pos];
+      }
+      pos++;
+      end++;
+    }
+
+    // skip trailing space chars before comma or semicolon.
+    // (compatibility with RFC 1779)
+    for (; pos < length && chars[pos] == ' '; pos++) {
+    }
+
+    return new String(chars, beg, end - beg);
+  }
+
+  // gets hex string attribute value: "#" hexstring
+  private String hexAV() {
+    if (pos + 4 >= length) {
+      // encoded byte array  must be not less then 4 c
+      throw new IllegalStateException("Unexpected end of DN: " + dn);
+    }
+
+    beg = pos; // store '#' position
+    pos++;
+    while (true) {
+
+      // check for end of attribute value
+      // looks for space and component separators
+      if (pos == length || chars[pos] == '+' || chars[pos] == ','
+          || chars[pos] == ';') {
+        end = pos;
+        break;
+      }
+
+      if (chars[pos] == ' ') {
+        end = pos;
+        pos++;
+        // skip trailing space chars before comma or semicolon.
+        // (compatibility with RFC 1779)
+        for (; pos < length && chars[pos] == ' '; pos++) {
+        }
+        break;
+      } else if (chars[pos] >= 'A' && chars[pos] <= 'F') {
+        chars[pos] += 32; //to low case
+      }
+
+      pos++;
+    }
+
+    // verify length of hex string
+    // encoded byte array  must be not less then 4 and must be even number
+    int hexLen = end - beg; // skip first '#' char
+    if (hexLen < 5 || (hexLen & 1) == 0) {
+      throw new IllegalStateException("Unexpected end of DN: " + dn);
+    }
+
+    // get byte encoding from string representation
+    byte[] encoded = new byte[hexLen / 2];
+    for (int i = 0, p = beg + 1; i < encoded.length; p += 2, i++) {
+      encoded[i] = (byte) getByte(p);
+    }
+
+    return new String(chars, beg, hexLen);
+  }
+
+  // gets string attribute value: *( stringchar / pair )
+  private String escapedAV() {
+    beg = pos;
+    end = pos;
+    while (true) {
+      if (pos >= length) {
+        // the end of DN has been found
+        return new String(chars, beg, end - beg);
+      }
+
+      switch (chars[pos]) {
+        case '+':
+        case ',':
+        case ';':
+          // separator char has been found
+          return new String(chars, beg, end - beg);
+        case '\\':
+          // escaped char
+          chars[end++] = getEscaped();
+          pos++;
+          break;
+        case ' ':
+          // need to figure out whether space defines
+          // the end of attribute value or not
+          cur = end;
+
+          pos++;
+          chars[end++] = ' ';
+
+          for (; pos < length && chars[pos] == ' '; pos++) {
+            chars[end++] = ' ';
+          }
+          if (pos == length || chars[pos] == ',' || chars[pos] == '+'
+              || chars[pos] == ';') {
+            // separator char or the end of DN has been found
+            return new String(chars, beg, cur - beg);
+          }
+          break;
+        default:
+          chars[end++] = chars[pos];
+          pos++;
+      }
+    }
+  }
+
+  // returns escaped char
+  private char getEscaped() {
+    pos++;
+    if (pos == length) {
+      throw new IllegalStateException("Unexpected end of DN: " + dn);
+    }
+
+    switch (chars[pos]) {
+      case '"':
+      case '\\':
+      case ',':
+      case '=':
+      case '+':
+      case '<':
+      case '>':
+      case '#':
+      case ';':
+      case ' ':
+      case '*':
+      case '%':
+      case '_':
+        //FIXME: escaping is allowed only for leading or trailing space char
+        return chars[pos];
+      default:
+        // RFC doesn't explicitly say that escaped hex pair is
+        // interpreted as UTF-8 char. It only contains an example of such DN.
+        return getUTF8();
+    }
+  }
+
+  // decodes UTF-8 char
+  // see http://www.unicode.org for UTF-8 bit distribution table
+  private char getUTF8() {
+    int res = getByte(pos);
+    pos++; //FIXME tmp
+
+    if (res < 128) { // one byte: 0-7F
+      return (char) res;
+    } else if (res >= 192 && res <= 247) {
+
+      int count;
+      if (res <= 223) { // two bytes: C0-DF
+        count = 1;
+        res = res & 0x1F;
+      } else if (res <= 239) { // three bytes: E0-EF
+        count = 2;
+        res = res & 0x0F;
+      } else { // four bytes: F0-F7
+        count = 3;
+        res = res & 0x07;
+      }
+
+      int b;
+      for (int i = 0; i < count; i++) {
+        pos++;
+        if (pos == length || chars[pos] != '\\') {
+          return 0x3F; //FIXME failed to decode UTF-8 char - return '?'
+        }
+        pos++;
+
+        b = getByte(pos);
+        pos++; //FIXME tmp
+        if ((b & 0xC0) != 0x80) {
+          return 0x3F; //FIXME failed to decode UTF-8 char - return '?'
+        }
+
+        res = (res << 6) + (b & 0x3F);
+      }
+      return (char) res;
+    } else {
+      return 0x3F; //FIXME failed to decode UTF-8 char - return '?'
+    }
+  }
+
+  // Returns byte representation of a char pair
+  // The char pair is composed of DN char in
+  // specified 'position' and the next char
+  // According to BNF syntax:
+  // hexchar    = DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
+  //                    / "a" / "b" / "c" / "d" / "e" / "f"
+  private int getByte(int position) {
+    if (position + 1 >= length) {
+      throw new IllegalStateException("Malformed DN: " + dn);
+    }
+
+    int b1, b2;
+
+    b1 = chars[position];
+    if (b1 >= '0' && b1 <= '9') {
+      b1 = b1 - '0';
+    } else if (b1 >= 'a' && b1 <= 'f') {
+      b1 = b1 - 87; // 87 = 'a' - 10
+    } else if (b1 >= 'A' && b1 <= 'F') {
+      b1 = b1 - 55; // 55 = 'A' - 10
+    } else {
+      throw new IllegalStateException("Malformed DN: " + dn);
+    }
+
+    b2 = chars[position + 1];
+    if (b2 >= '0' && b2 <= '9') {
+      b2 = b2 - '0';
+    } else if (b2 >= 'a' && b2 <= 'f') {
+      b2 = b2 - 87; // 87 = 'a' - 10
+    } else if (b2 >= 'A' && b2 <= 'F') {
+      b2 = b2 - 55; // 55 = 'A' - 10
+    } else {
+      throw new IllegalStateException("Malformed DN: " + dn);
+    }
+
+    return (b1 << 4) + b2;
+  }
+
+  /**
+   * Parses the DN and returns the most significant attribute value for an attribute type, or null
+   * if none found.
+   *
+   * @param attributeType attribute type to look for (e.g. "ca")
+   */
+  public String findMostSpecific(String attributeType) {
+    // Initialize internal state.
+    pos = 0;
+    beg = 0;
+    end = 0;
+    cur = 0;
+    chars = dn.toCharArray();
+
+    String attType = nextAT();
+    if (attType == null) {
+      return null;
+    }
+    while (true) {
+      String attValue = "";
+
+      if (pos == length) {
+        return null;
+      }
+
+      switch (chars[pos]) {
+        case '"':
+          attValue = quotedAV();
+          break;
+        case '#':
+          attValue = hexAV();
+          break;
+        case '+':
+        case ',':
+        case ';': // compatibility with RFC 1779: semicolon can separate RDNs
+          //empty attribute value
+          break;
+        default:
+          attValue = escapedAV();
+      }
+
+      // Values are ordered from most specific to least specific
+      // due to the RFC2253 formatting. So take the first match
+      // we see.
+      if (attributeType.equalsIgnoreCase(attType)) {
+        return attValue;
+      }
+
+      if (pos >= length) {
+        return null;
+      }
+
+      if (chars[pos] == ',' || chars[pos] == ';') {
+      } else if (chars[pos] != '+') {
+        throw new IllegalStateException("Malformed DN: " + dn);
+      }
+
+      pos++;
+      attType = nextAT();
+      if (attType == null) {
+        throw new IllegalStateException("Malformed DN: " + dn);
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java b/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java
new file mode 100644
index 0000000000..7441abadad
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java
@@ -0,0 +1,229 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3.internal.tls;
+
+import java.security.cert.Certificate;
+import java.security.cert.CertificateParsingException;
+import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+import java.util.Locale;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLException;
+import javax.net.ssl.SSLSession;
+import javax.security.auth.x500.X500Principal;
+
+import static okhttp3.internal.Util.verifyAsIpAddress;
+
+/**
+ * A HostnameVerifier consistent with <a href="http://www.ietf.org/rfc/rfc2818.txt">RFC 2818</a>.
+ */
+public final class OkHostnameVerifier implements HostnameVerifier {
+  public static final OkHostnameVerifier INSTANCE = new OkHostnameVerifier();
+
+  private static final int ALT_DNS_NAME = 2;
+  private static final int ALT_IPA_NAME = 7;
+
+  private OkHostnameVerifier() {
+  }
+
+  @Override
+  public boolean verify(String host, SSLSession session) {
+    try {
+      Certificate[] certificates = session.getPeerCertificates();
+      return verify(host, (X509Certificate) certificates[0]);
+    } catch (SSLException e) {
+      return false;
+    }
+  }
+
+  public boolean verify(String host, X509Certificate certificate) {
+    return verifyAsIpAddress(host)
+        ? verifyIpAddress(host, certificate)
+        : verifyHostname(host, certificate);
+  }
+
+  /** Returns true if {@code certificate} matches {@code ipAddress}. */
+  private boolean verifyIpAddress(String ipAddress, X509Certificate certificate) {
+    List<String> altNames = getSubjectAltNames(certificate, ALT_IPA_NAME);
+    for (int i = 0, size = altNames.size(); i < size; i++) {
+      if (ipAddress.equalsIgnoreCase(altNames.get(i))) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  /** Returns true if {@code certificate} matches {@code hostname}. */
+  private boolean verifyHostname(String hostname, X509Certificate certificate) {
+    hostname = hostname.toLowerCase(Locale.US);
+    boolean hasDns = false;
+    List<String> altNames = getSubjectAltNames(certificate, ALT_DNS_NAME);
+    for (int i = 0, size = altNames.size(); i < size; i++) {
+      hasDns = true;
+      if (verifyHostname(hostname, altNames.get(i))) {
+        return true;
+      }
+    }
+
+    if (!hasDns) {
+      X500Principal principal = certificate.getSubjectX500Principal();
+      // RFC 2818 advises using the most specific name for matching.
+      String cn = new DistinguishedNameParser(principal).findMostSpecific("cn");
+      if (cn != null) {
+        return verifyHostname(hostname, cn);
+      }
+    }
+
+    return false;
+  }
+
+  public static List<String> allSubjectAltNames(X509Certificate certificate) {
+    List<String> altIpaNames = getSubjectAltNames(certificate, ALT_IPA_NAME);
+    List<String> altDnsNames = getSubjectAltNames(certificate, ALT_DNS_NAME);
+    List<String> result = new ArrayList<>(altIpaNames.size() + altDnsNames.size());
+    result.addAll(altIpaNames);
+    result.addAll(altDnsNames);
+    return result;
+  }
+
+  private static List<String> getSubjectAltNames(X509Certificate certificate, int type) {
+    List<String> result = new ArrayList<>();
+    try {
+      Collection<?> subjectAltNames = certificate.getSubjectAlternativeNames();
+      if (subjectAltNames == null) {
+        return Collections.emptyList();
+      }
+      for (Object subjectAltName : subjectAltNames) {
+        List<?> entry = (List<?>) subjectAltName;
+        if (entry == null || entry.size() < 2) {
+          continue;
+        }
+        Integer altNameType = (Integer) entry.get(0);
+        if (altNameType == null) {
+          continue;
+        }
+        if (altNameType == type) {
+          String altName = (String) entry.get(1);
+          if (altName != null) {
+            result.add(altName);
+          }
+        }
+      }
+      return result;
+    } catch (CertificateParsingException e) {
+      return Collections.emptyList();
+    }
+  }
+
+  /**
+   * Returns {@code true} iff {@code hostname} matches the domain name {@code pattern}.
+   *
+   * @param hostname lower-case host name.
+   * @param pattern domain name pattern from certificate. May be a wildcard pattern such as {@code
+   * *.android.com}.
+   */
+  public boolean verifyHostname(String hostname, String pattern) {
+    // Basic sanity checks
+    // Check length == 0 instead of .isEmpty() to support Java 5.
+    if ((hostname == null) || (hostname.length() == 0) || (hostname.startsWith("."))
+        || (hostname.endsWith(".."))) {
+      // Invalid domain name
+      return false;
+    }
+    if ((pattern == null) || (pattern.length() == 0) || (pattern.startsWith("."))
+        || (pattern.endsWith(".."))) {
+      // Invalid pattern/domain name
+      return false;
+    }
+
+    // Normalize hostname and pattern by turning them into absolute domain names if they are not
+    // yet absolute. This is needed because server certificates do not normally contain absolute
+    // names or patterns, but they should be treated as absolute. At the same time, any hostname
+    // presented to this method should also be treated as absolute for the purposes of matching
+    // to the server certificate.
+    //   www.android.com  matches www.android.com
+    //   www.android.com  matches www.android.com.
+    //   www.android.com. matches www.android.com.
+    //   www.android.com. matches www.android.com
+    if (!hostname.endsWith(".")) {
+      hostname += '.';
+    }
+    if (!pattern.endsWith(".")) {
+      pattern += '.';
+    }
+    // hostname and pattern are now absolute domain names.
+
+    pattern = pattern.toLowerCase(Locale.US);
+    // hostname and pattern are now in lower case -- domain names are case-insensitive.
+
+    if (!pattern.contains("*")) {
+      // Not a wildcard pattern -- hostname and pattern must match exactly.
+      return hostname.equals(pattern);
+    }
+    // Wildcard pattern
+
+    // WILDCARD PATTERN RULES:
+    // 1. Asterisk (*) is only permitted in the left-most domain name label and must be the
+    //    only character in that label (i.e., must match the whole left-most label).
+    //    For example, *.example.com is permitted, while *a.example.com, a*.example.com,
+    //    a*b.example.com, a.*.example.com are not permitted.
+    // 2. Asterisk (*) cannot match across domain name labels.
+    //    For example, *.example.com matches test.example.com but does not match
+    //    sub.test.example.com.
+    // 3. Wildcard patterns for single-label domain names are not permitted.
+
+    if ((!pattern.startsWith("*.")) || (pattern.indexOf('*', 1) != -1)) {
+      // Asterisk (*) is only permitted in the left-most domain name label and must be the only
+      // character in that label
+      return false;
+    }
+
+    // Optimization: check whether hostname is too short to match the pattern. hostName must be at
+    // least as long as the pattern because asterisk must match the whole left-most label and
+    // hostname starts with a non-empty label. Thus, asterisk has to match one or more characters.
+    if (hostname.length() < pattern.length()) {
+      // hostname too short to match the pattern.
+      return false;
+    }
+
+    if ("*.".equals(pattern)) {
+      // Wildcard pattern for single-label domain name -- not permitted.
+      return false;
+    }
+
+    // hostname must end with the region of pattern following the asterisk.
+    String suffix = pattern.substring(1);
+    if (!hostname.endsWith(suffix)) {
+      // hostname does not end with the suffix
+      return false;
+    }
+
+    // Check that asterisk did not match across domain name labels.
+    int suffixStartIndexInHostname = hostname.length() - suffix.length();
+    if ((suffixStartIndexInHostname > 0)
+        && (hostname.lastIndexOf('.', suffixStartIndexInHostname - 1) != -1)) {
+      // Asterisk is matching across domain name labels -- not permitted.
+      return false;
+    }
+
+    // hostname matches pattern
+    return true;
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java b/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java
new file mode 100644
index 0000000000..499f120e33
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.tls;
+
+import java.security.cert.X509Certificate;
+
+public interface TrustRootIndex {
+  /** Returns the trusted CA certificate that signed {@code cert}. */
+  X509Certificate findByIssuerAndSignature(X509Certificate cert);
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
new file mode 100644
index 0000000000..0d39abc8d5
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
@@ -0,0 +1,591 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.ws;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.util.ArrayDeque;
+import java.util.Collections;
+import java.util.List;
+import java.util.Random;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.ScheduledThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
+import okhttp3.Call;
+import okhttp3.Callback;
+import okhttp3.EventListener;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.WebSocket;
+import okhttp3.WebSocketListener;
+import okhttp3.internal.Internal;
+import okhttp3.internal.Util;
+import okhttp3.internal.connection.StreamAllocation;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.Okio;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static okhttp3.internal.Util.closeQuietly;
+import static okhttp3.internal.ws.WebSocketProtocol.CLOSE_CLIENT_GOING_AWAY;
+import static okhttp3.internal.ws.WebSocketProtocol.CLOSE_MESSAGE_MAX;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_BINARY;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_TEXT;
+import static okhttp3.internal.ws.WebSocketProtocol.validateCloseCode;
+
+public final class RealWebSocket implements WebSocket, WebSocketReader.FrameCallback {
+  private static final List<Protocol> ONLY_HTTP1 = Collections.singletonList(Protocol.HTTP_1_1);
+
+  /**
+   * The maximum number of bytes to enqueue. Rather than enqueueing beyond this limit we tear down
+   * the web socket! It's possible that we're writing faster than the peer can read.
+   */
+  private static final long MAX_QUEUE_SIZE = 16 * 1024 * 1024; // 16 MiB.
+
+  /**
+   * The maximum amount of time after the client calls {@link #close} to wait for a graceful
+   * shutdown. If the server doesn't respond the websocket will be canceled.
+   */
+  private static final long CANCEL_AFTER_CLOSE_MILLIS = 60 * 1000;
+
+  /** The application's original request unadulterated by web socket headers. */
+  private final Request originalRequest;
+
+  final WebSocketListener listener;
+  private final Random random;
+  private final String key;
+
+  /** Non-null for client web sockets. These can be canceled. */
+  private Call call;
+
+  /** This runnable processes the outgoing queues. Call {@link #runWriter()} to after enqueueing. */
+  private final Runnable writerRunnable;
+
+  /** Null until this web socket is connected. Only accessed by the reader thread. */
+  private WebSocketReader reader;
+
+  // All mutable web socket state is guarded by this.
+
+  /** Null until this web socket is connected. Note that messages may be enqueued before that. */
+  private WebSocketWriter writer;
+
+  /** Null until this web socket is connected. Used for writes, pings, and close timeouts. */
+  private ScheduledExecutorService executor;
+
+  /**
+   * The streams held by this web socket. This is non-null until all incoming messages have been
+   * read and all outgoing messages have been written. It is closed when both reader and writer are
+   * exhausted, or if there is any failure.
+   */
+  private Streams streams;
+
+  /** Outgoing pongs in the order they should be written. */
+  private final ArrayDeque<ByteString> pongQueue = new ArrayDeque<>();
+
+  /** Outgoing messages and close frames in the order they should be written. */
+  private final ArrayDeque<Object> messageAndCloseQueue = new ArrayDeque<>();
+
+  /** The total size in bytes of enqueued but not yet transmitted messages. */
+  private long queueSize;
+
+  /** True if we've enqueued a close frame. No further message frames will be enqueued. */
+  private boolean enqueuedClose;
+
+  /**
+   * When executed this will cancel this websocket. This future itself should be canceled if that is
+   * unnecessary because the web socket is already closed or canceled.
+   */
+  private ScheduledFuture<?> cancelFuture;
+
+  /** The close code from the peer, or -1 if this web socket has not yet read a close frame. */
+  private int receivedCloseCode = -1;
+
+  /** The close reason from the peer, or null if this web socket has not yet read a close frame. */
+  private String receivedCloseReason;
+
+  /** True if this web socket failed and the listener has been notified. */
+  private boolean failed;
+
+  /** For testing. */
+  int pingCount;
+
+  /** For testing. */
+  int pongCount;
+
+  public RealWebSocket(Request request, WebSocketListener listener, Random random) {
+    if (!"GET".equals(request.method())) {
+      throw new IllegalArgumentException("Request must be GET: " + request.method());
+    }
+    this.originalRequest = request;
+    this.listener = listener;
+    this.random = random;
+
+    byte[] nonce = new byte[16];
+    random.nextBytes(nonce);
+    this.key = ByteString.of(nonce).base64();
+
+    this.writerRunnable = new Runnable() {
+      @Override public void run() {
+        try {
+          while (writeOneFrame()) {
+          }
+        } catch (IOException e) {
+          failWebSocket(e, null);
+        }
+      }
+    };
+  }
+
+  @Override public Request request() {
+    return originalRequest;
+  }
+
+  @Override public synchronized long queueSize() {
+    return queueSize;
+  }
+
+  @Override public void cancel() {
+    call.cancel();
+  }
+
+  public void connect(OkHttpClient client) {
+    client = client.newBuilder()
+        .eventListener(EventListener.NONE)
+        .protocols(ONLY_HTTP1)
+        .build();
+    final int pingIntervalMillis = client.pingIntervalMillis();
+    final Request request = originalRequest.newBuilder()
+        .header("Upgrade", "websocket")
+        .header("Connection", "Upgrade")
+        .header("Sec-WebSocket-Key", key)
+        .header("Sec-WebSocket-Version", "13")
+        .build();
+    call = Internal.instance.newWebSocketCall(client, request);
+    call.enqueue(new Callback() {
+      @Override public void onResponse(Call call, Response response) {
+        try {
+          checkResponse(response);
+        } catch (ProtocolException e) {
+          failWebSocket(e, response);
+          closeQuietly(response);
+          return;
+        }
+
+        // Promote the HTTP streams into web socket streams.
+        StreamAllocation streamAllocation = Internal.instance.streamAllocation(call);
+        streamAllocation.noNewStreams(); // Prevent connection pooling!
+        Streams streams = streamAllocation.connection().newWebSocketStreams(streamAllocation);
+
+        // Process all web socket messages.
+        try {
+          listener.onOpen(RealWebSocket.this, response);
+          String name = "OkHttp WebSocket " + request.url().redact();
+          initReaderAndWriter(name, pingIntervalMillis, streams);
+          streamAllocation.connection().socket().setSoTimeout(0);
+          loopReader();
+        } catch (Exception e) {
+          failWebSocket(e, null);
+        }
+      }
+
+      @Override public void onFailure(Call call, IOException e) {
+        failWebSocket(e, null);
+      }
+    });
+  }
+
+  void checkResponse(Response response) throws ProtocolException {
+    if (response.code() != 101) {
+      throw new ProtocolException("Expected HTTP 101 response but was '"
+          + response.code() + " " + response.message() + "'");
+    }
+
+    String headerConnection = response.header("Connection");
+    if (!"Upgrade".equalsIgnoreCase(headerConnection)) {
+      throw new ProtocolException("Expected 'Connection' header value 'Upgrade' but was '"
+          + headerConnection + "'");
+    }
+
+    String headerUpgrade = response.header("Upgrade");
+    if (!"websocket".equalsIgnoreCase(headerUpgrade)) {
+      throw new ProtocolException(
+          "Expected 'Upgrade' header value 'websocket' but was '" + headerUpgrade + "'");
+    }
+
+    String headerAccept = response.header("Sec-WebSocket-Accept");
+    String acceptExpected = ByteString.encodeUtf8(key + WebSocketProtocol.ACCEPT_MAGIC)
+        .sha1().base64();
+    if (!acceptExpected.equals(headerAccept)) {
+      throw new ProtocolException("Expected 'Sec-WebSocket-Accept' header value '"
+          + acceptExpected + "' but was '" + headerAccept + "'");
+    }
+  }
+
+  public void initReaderAndWriter(
+      String name, long pingIntervalMillis, Streams streams) throws IOException {
+    synchronized (this) {
+      this.streams = streams;
+      this.writer = new WebSocketWriter(streams.client, streams.sink, random);
+      this.executor = new ScheduledThreadPoolExecutor(1, Util.threadFactory(name, false));
+      if (pingIntervalMillis != 0) {
+        executor.scheduleAtFixedRate(
+            new PingRunnable(), pingIntervalMillis, pingIntervalMillis, MILLISECONDS);
+      }
+      if (!messageAndCloseQueue.isEmpty()) {
+        runWriter(); // Send messages that were enqueued before we were connected.
+      }
+    }
+
+    reader = new WebSocketReader(streams.client, streams.source, this);
+  }
+
+  /** Receive frames until there are no more. Invoked only by the reader thread. */
+  public void loopReader() throws IOException {
+    while (receivedCloseCode == -1) {
+      // This method call results in one or more onRead* methods being called on this thread.
+      reader.processNextFrame();
+    }
+  }
+
+  /**
+   * For testing: receive a single frame and return true if there are more frames to read. Invoked
+   * only by the reader thread.
+   */
+  boolean processNextFrame() throws IOException {
+    try {
+      reader.processNextFrame();
+      return receivedCloseCode == -1;
+    } catch (Exception e) {
+      failWebSocket(e, null);
+      return false;
+    }
+  }
+
+  /**
+   * For testing: wait until the web socket's executor has terminated.
+   */
+  void awaitTermination(int timeout, TimeUnit timeUnit) throws InterruptedException {
+    executor.awaitTermination(timeout, timeUnit);
+  }
+
+  /**
+   * For testing: force this web socket to release its threads.
+   */
+  void tearDown() throws InterruptedException {
+    if (cancelFuture != null) {
+      cancelFuture.cancel(false);
+    }
+    executor.shutdown();
+    executor.awaitTermination(10, TimeUnit.SECONDS);
+  }
+
+  synchronized int pingCount() {
+    return pingCount;
+  }
+
+  synchronized int pongCount() {
+    return pongCount;
+  }
+
+  @Override public void onReadMessage(String text) throws IOException {
+    listener.onMessage(this, text);
+  }
+
+  @Override public void onReadMessage(ByteString bytes) throws IOException {
+    listener.onMessage(this, bytes);
+  }
+
+  @Override public synchronized void onReadPing(ByteString payload) {
+    // Don't respond to pings after we've failed or sent the close frame.
+    if (failed || (enqueuedClose && messageAndCloseQueue.isEmpty())) return;
+
+    pongQueue.add(payload);
+    runWriter();
+    pingCount++;
+  }
+
+  @Override public synchronized void onReadPong(ByteString buffer) {
+    // This API doesn't expose pings.
+    pongCount++;
+  }
+
+  @Override public void onReadClose(int code, String reason) {
+    if (code == -1) throw new IllegalArgumentException();
+
+    Streams toClose = null;
+    synchronized (this) {
+      if (receivedCloseCode != -1) throw new IllegalStateException("already closed");
+      receivedCloseCode = code;
+      receivedCloseReason = reason;
+      if (enqueuedClose && messageAndCloseQueue.isEmpty()) {
+        toClose = this.streams;
+        this.streams = null;
+        if (cancelFuture != null) cancelFuture.cancel(false);
+        this.executor.shutdown();
+      }
+    }
+
+    try {
+      listener.onClosing(this, code, reason);
+
+      if (toClose != null) {
+        listener.onClosed(this, code, reason);
+      }
+    } finally {
+      closeQuietly(toClose);
+    }
+  }
+
+  // Writer methods to enqueue frames. They'll be sent asynchronously by the writer thread.
+
+  @Override public boolean send(String text) {
+    if (text == null) throw new NullPointerException("text == null");
+    return send(ByteString.encodeUtf8(text), OPCODE_TEXT);
+  }
+
+  @Override public boolean send(ByteString bytes) {
+    if (bytes == null) throw new NullPointerException("bytes == null");
+    return send(bytes, OPCODE_BINARY);
+  }
+
+  private synchronized boolean send(ByteString data, int formatOpcode) {
+    // Don't send new frames after we've failed or enqueued a close frame.
+    if (failed || enqueuedClose) return false;
+
+    // If this frame overflows the buffer, reject it and close the web socket.
+    if (queueSize + data.size() > MAX_QUEUE_SIZE) {
+      close(CLOSE_CLIENT_GOING_AWAY, null);
+      return false;
+    }
+
+    // Enqueue the message frame.
+    queueSize += data.size();
+    messageAndCloseQueue.add(new Message(formatOpcode, data));
+    runWriter();
+    return true;
+  }
+
+  synchronized boolean pong(ByteString payload) {
+    // Don't send pongs after we've failed or sent the close frame.
+    if (failed || (enqueuedClose && messageAndCloseQueue.isEmpty())) return false;
+
+    pongQueue.add(payload);
+    runWriter();
+    return true;
+  }
+
+  @Override public boolean close(int code, String reason) {
+    return close(code, reason, CANCEL_AFTER_CLOSE_MILLIS);
+  }
+
+  synchronized boolean close(int code, String reason, long cancelAfterCloseMillis) {
+    validateCloseCode(code);
+
+    ByteString reasonBytes = null;
+    if (reason != null) {
+      reasonBytes = ByteString.encodeUtf8(reason);
+      if (reasonBytes.size() > CLOSE_MESSAGE_MAX) {
+        throw new IllegalArgumentException("reason.size() > " + CLOSE_MESSAGE_MAX + ": " + reason);
+      }
+    }
+
+    if (failed || enqueuedClose) return false;
+
+    // Immediately prevent further frames from being enqueued.
+    enqueuedClose = true;
+
+    // Enqueue the close frame.
+    messageAndCloseQueue.add(new Close(code, reasonBytes, cancelAfterCloseMillis));
+    runWriter();
+    return true;
+  }
+
+  private void runWriter() {
+    assert (Thread.holdsLock(this));
+
+    if (executor != null) {
+      executor.execute(writerRunnable);
+    }
+  }
+
+  /**
+   * Attempts to remove a single frame from a queue and send it. This prefers to write urgent pongs
+   * before less urgent messages and close frames. For example it's possible that a caller will
+   * enqueue messages followed by pongs, but this sends pongs followed by messages. Pongs are always
+   * written in the order they were enqueued.
+   *
+   * <p>If a frame cannot be sent - because there are none enqueued or because the web socket is not
+   * connected - this does nothing and returns false. Otherwise this returns true and the caller
+   * should immediately invoke this method again until it returns false.
+   *
+   * <p>This method may only be invoked by the writer thread. There may be only thread invoking this
+   * method at a time.
+   */
+  boolean writeOneFrame() throws IOException {
+    WebSocketWriter writer;
+    ByteString pong;
+    Object messageOrClose = null;
+    int receivedCloseCode = -1;
+    String receivedCloseReason = null;
+    Streams streamsToClose = null;
+
+    synchronized (RealWebSocket.this) {
+      if (failed) {
+        return false; // Failed web socket.
+      }
+
+      writer = this.writer;
+      pong = pongQueue.poll();
+      if (pong == null) {
+        messageOrClose = messageAndCloseQueue.poll();
+        if (messageOrClose instanceof Close) {
+          receivedCloseCode = this.receivedCloseCode;
+          receivedCloseReason = this.receivedCloseReason;
+          if (receivedCloseCode != -1) {
+            streamsToClose = this.streams;
+            this.streams = null;
+            this.executor.shutdown();
+          } else {
+            // When we request a graceful close also schedule a cancel of the websocket.
+            cancelFuture = executor.schedule(new CancelRunnable(),
+                ((Close) messageOrClose).cancelAfterCloseMillis, MILLISECONDS);
+          }
+        } else if (messageOrClose == null) {
+          return false; // The queue is exhausted.
+        }
+      }
+    }
+
+    try {
+      if (pong != null) {
+        writer.writePong(pong);
+
+      } else if (messageOrClose instanceof Message) {
+        ByteString data = ((Message) messageOrClose).data;
+        BufferedSink sink = Okio.buffer(writer.newMessageSink(
+            ((Message) messageOrClose).formatOpcode, data.size()));
+        sink.write(data);
+        sink.close();
+        synchronized (this) {
+          queueSize -= data.size();
+        }
+
+      } else if (messageOrClose instanceof Close) {
+        Close close = (Close) messageOrClose;
+        writer.writeClose(close.code, close.reason);
+
+        // We closed the writer: now both reader and writer are closed.
+        if (streamsToClose != null) {
+          listener.onClosed(this, receivedCloseCode, receivedCloseReason);
+        }
+
+      } else {
+        throw new AssertionError();
+      }
+
+      return true;
+    } finally {
+      closeQuietly(streamsToClose);
+    }
+  }
+
+  private final class PingRunnable implements Runnable {
+    PingRunnable() {
+    }
+
+    @Override public void run() {
+      writePingFrame();
+    }
+  }
+
+  void writePingFrame() {
+    WebSocketWriter writer;
+    synchronized (this) {
+      if (failed) return;
+      writer = this.writer;
+    }
+
+    try {
+      writer.writePing(ByteString.EMPTY);
+    } catch (IOException e) {
+      failWebSocket(e, null);
+    }
+  }
+
+  public void failWebSocket(Exception e, @Nullable Response response) {
+    Streams streamsToClose;
+    synchronized (this) {
+      if (failed) return; // Already failed.
+      failed = true;
+      streamsToClose = this.streams;
+      this.streams = null;
+      if (cancelFuture != null) cancelFuture.cancel(false);
+      if (executor != null) executor.shutdown();
+    }
+
+    try {
+      listener.onFailure(this, e, response);
+    } finally {
+      closeQuietly(streamsToClose);
+    }
+  }
+
+  static final class Message {
+    final int formatOpcode;
+    final ByteString data;
+
+    Message(int formatOpcode, ByteString data) {
+      this.formatOpcode = formatOpcode;
+      this.data = data;
+    }
+  }
+
+  static final class Close {
+    final int code;
+    final ByteString reason;
+    final long cancelAfterCloseMillis;
+
+    Close(int code, ByteString reason, long cancelAfterCloseMillis) {
+      this.code = code;
+      this.reason = reason;
+      this.cancelAfterCloseMillis = cancelAfterCloseMillis;
+    }
+  }
+
+  public abstract static class Streams implements Closeable {
+    public final boolean client;
+    public final BufferedSource source;
+    public final BufferedSink sink;
+
+    public Streams(boolean client, BufferedSource source, BufferedSink sink) {
+      this.client = client;
+      this.source = source;
+      this.sink = sink;
+    }
+  }
+
+  final class CancelRunnable implements Runnable {
+    @Override public void run() {
+      cancel();
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
new file mode 100644
index 0000000000..5be61eea5f
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.ws;
+
+import java.io.IOException;
+import java.net.ProtocolException;
+import okio.ByteString;
+
+public final class WebSocketProtocol {
+  /** Magic value which must be appended to the key in a response header. */
+  static final String ACCEPT_MAGIC = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
+
+  /*
+  Each frame starts with two bytes of data.
+
+   0 1 2 3 4 5 6 7    0 1 2 3 4 5 6 7
+  +-+-+-+-+-------+  +-+-------------+
+  |F|R|R|R| OP    |  |M| LENGTH      |
+  |I|S|S|S| CODE  |  |A|             |
+  |N|V|V|V|       |  |S|             |
+  | |1|2|3|       |  |K|             |
+  +-+-+-+-+-------+  +-+-------------+
+  */
+
+  /** Byte 0 flag for whether this is the final fragment in a message. */
+  static final int B0_FLAG_FIN = 0b10000000;
+  /** Byte 0 reserved flag 1. Must be 0 unless negotiated otherwise. */
+  static final int B0_FLAG_RSV1 = 0b01000000;
+  /** Byte 0 reserved flag 2. Must be 0 unless negotiated otherwise. */
+  static final int B0_FLAG_RSV2 = 0b00100000;
+  /** Byte 0 reserved flag 3. Must be 0 unless negotiated otherwise. */
+  static final int B0_FLAG_RSV3 = 0b00010000;
+  /** Byte 0 mask for the frame opcode. */
+  static final int B0_MASK_OPCODE = 0b00001111;
+  /** Flag in the opcode which indicates a control frame. */
+  static final int OPCODE_FLAG_CONTROL = 0b00001000;
+
+  /**
+   * Byte 1 flag for whether the payload data is masked. <p> If this flag is set, the next four
+   * bytes represent the mask key. These bytes appear after any additional bytes specified by {@link
+   * #B1_MASK_LENGTH}.
+   */
+  static final int B1_FLAG_MASK = 0b10000000;
+  /**
+   * Byte 1 mask for the payload length. <p> If this value is {@link #PAYLOAD_SHORT}, the next two
+   * bytes represent the length. If this value is {@link #PAYLOAD_LONG}, the next eight bytes
+   * represent the length.
+   */
+  static final int B1_MASK_LENGTH = 0b01111111;
+
+  static final int OPCODE_CONTINUATION = 0x0;
+  static final int OPCODE_TEXT = 0x1;
+  static final int OPCODE_BINARY = 0x2;
+
+  static final int OPCODE_CONTROL_CLOSE = 0x8;
+  static final int OPCODE_CONTROL_PING = 0x9;
+  static final int OPCODE_CONTROL_PONG = 0xa;
+
+  /**
+   * Maximum length of frame payload. Larger payloads, if supported by the frame type, can use the
+   * special values {@link #PAYLOAD_SHORT} or {@link #PAYLOAD_LONG}.
+   */
+  static final long PAYLOAD_BYTE_MAX = 125L;
+  /** Maximum length of close message in bytes. */
+  static final long CLOSE_MESSAGE_MAX = PAYLOAD_BYTE_MAX - 2;
+  /**
+   * Value for {@link #B1_MASK_LENGTH} which indicates the next two bytes are the unsigned length.
+   */
+  static final int PAYLOAD_SHORT = 126;
+  /** Maximum length of a frame payload to be denoted as {@link #PAYLOAD_SHORT}. */
+  static final long PAYLOAD_SHORT_MAX = 0xffffL;
+  /**
+   * Value for {@link #B1_MASK_LENGTH} which indicates the next eight bytes are the unsigned
+   * length.
+   */
+  static final int PAYLOAD_LONG = 127;
+
+  /** Used when an unchecked exception was thrown in a listener. */
+  static final int CLOSE_CLIENT_GOING_AWAY = 1001;
+  /** Used when a {@link ProtocolException} was thrown by the reader or writer. */
+  static final int CLOSE_PROTOCOL_EXCEPTION = 1002;
+  /** Used when an empty close frame was received (i.e., without a status code). */
+  static final int CLOSE_NO_STATUS_CODE = 1005;
+  /** Used when a non-{@link ProtocolException} {@link IOException} was thrown by the reader. */
+  static final int CLOSE_ABNORMAL_TERMINATION = 1006;
+
+  static void toggleMask(byte[] buffer, long byteCount, byte[] key, long frameBytesRead) {
+    int keyLength = key.length;
+    for (int i = 0; i < byteCount; i++, frameBytesRead++) {
+      int keyIndex = (int) (frameBytesRead % keyLength);
+      buffer[i] = (byte) (buffer[i] ^ key[keyIndex]);
+    }
+  }
+
+  static String closeCodeExceptionMessage(int code) {
+    if (code < 1000 || code >= 5000) {
+      return "Code must be in range [1000,5000): " + code;
+    } else if ((code >= 1004 && code <= 1006) || (code >= 1012 && code <= 2999)) {
+      return "Code " + code + " is reserved and may not be used.";
+    } else {
+      return null;
+    }
+  }
+
+  static void validateCloseCode(int code) {
+    String message = closeCodeExceptionMessage(code);
+    if (message != null) throw new IllegalArgumentException(message);
+  }
+
+  public static String acceptHeader(String key) {
+    return ByteString.encodeUtf8(key + WebSocketProtocol.ACCEPT_MAGIC).sha1().base64();
+  }
+
+  private WebSocketProtocol() {
+    throw new AssertionError("No instances.");
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java
new file mode 100644
index 0000000000..f2844737cc
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java
@@ -0,0 +1,277 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.ws;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.util.concurrent.TimeUnit;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ByteString;
+
+import static java.lang.Integer.toHexString;
+import static okhttp3.internal.ws.WebSocketProtocol.B0_FLAG_FIN;
+import static okhttp3.internal.ws.WebSocketProtocol.B0_FLAG_RSV1;
+import static okhttp3.internal.ws.WebSocketProtocol.B0_FLAG_RSV2;
+import static okhttp3.internal.ws.WebSocketProtocol.B0_FLAG_RSV3;
+import static okhttp3.internal.ws.WebSocketProtocol.B0_MASK_OPCODE;
+import static okhttp3.internal.ws.WebSocketProtocol.B1_FLAG_MASK;
+import static okhttp3.internal.ws.WebSocketProtocol.B1_MASK_LENGTH;
+import static okhttp3.internal.ws.WebSocketProtocol.CLOSE_NO_STATUS_CODE;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_BINARY;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTINUATION;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTROL_CLOSE;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PING;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PONG;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_FLAG_CONTROL;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_TEXT;
+import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_BYTE_MAX;
+import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_LONG;
+import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_SHORT;
+import static okhttp3.internal.ws.WebSocketProtocol.toggleMask;
+
+/**
+ * An <a href="http://tools.ietf.org/html/rfc6455">RFC 6455</a>-compatible WebSocket frame reader.
+ *
+ * <p>This class is not thread safe.
+ */
+final class WebSocketReader {
+  public interface FrameCallback {
+    void onReadMessage(String text) throws IOException;
+    void onReadMessage(ByteString bytes) throws IOException;
+    void onReadPing(ByteString buffer);
+    void onReadPong(ByteString buffer);
+    void onReadClose(int code, String reason);
+  }
+
+  final boolean isClient;
+  final BufferedSource source;
+  final FrameCallback frameCallback;
+
+  boolean closed;
+
+  // Stateful data about the current frame.
+  int opcode;
+  long frameLength;
+  long frameBytesRead;
+  boolean isFinalFrame;
+  boolean isControlFrame;
+  boolean isMasked;
+
+  final byte[] maskKey = new byte[4];
+  final byte[] maskBuffer = new byte[8192];
+
+  WebSocketReader(boolean isClient, BufferedSource source, FrameCallback frameCallback) {
+    if (source == null) throw new NullPointerException("source == null");
+    if (frameCallback == null) throw new NullPointerException("frameCallback == null");
+    this.isClient = isClient;
+    this.source = source;
+    this.frameCallback = frameCallback;
+  }
+
+  /**
+   * Process the next protocol frame.
+   *
+   * <ul>
+   *     <li>If it is a control frame this will result in a single call to {@link FrameCallback}.
+   *     <li>If it is a message frame this will result in a single call to {@link
+   *         FrameCallback#onReadMessage}. If the message spans multiple frames, each interleaved
+   *         control frame will result in a corresponding call to {@link FrameCallback}.
+   * </ul>
+   */
+  void processNextFrame() throws IOException {
+    readHeader();
+    if (isControlFrame) {
+      readControlFrame();
+    } else {
+      readMessageFrame();
+    }
+  }
+
+  private void readHeader() throws IOException {
+    if (closed) throw new IOException("closed");
+
+    // Disable the timeout to read the first byte of a new frame.
+    int b0;
+    long timeoutBefore = source.timeout().timeoutNanos();
+    source.timeout().clearTimeout();
+    try {
+      b0 = source.readByte() & 0xff;
+    } finally {
+      source.timeout().timeout(timeoutBefore, TimeUnit.NANOSECONDS);
+    }
+
+    opcode = b0 & B0_MASK_OPCODE;
+    isFinalFrame = (b0 & B0_FLAG_FIN) != 0;
+    isControlFrame = (b0 & OPCODE_FLAG_CONTROL) != 0;
+
+    // Control frames must be final frames (cannot contain continuations).
+    if (isControlFrame && !isFinalFrame) {
+      throw new ProtocolException("Control frames must be final.");
+    }
+
+    boolean reservedFlag1 = (b0 & B0_FLAG_RSV1) != 0;
+    boolean reservedFlag2 = (b0 & B0_FLAG_RSV2) != 0;
+    boolean reservedFlag3 = (b0 & B0_FLAG_RSV3) != 0;
+    if (reservedFlag1 || reservedFlag2 || reservedFlag3) {
+      // Reserved flags are for extensions which we currently do not support.
+      throw new ProtocolException("Reserved flags are unsupported.");
+    }
+
+    int b1 = source.readByte() & 0xff;
+
+    isMasked = (b1 & B1_FLAG_MASK) != 0;
+    if (isMasked == isClient) {
+      // Masked payloads must be read on the server. Unmasked payloads must be read on the client.
+      throw new ProtocolException(isClient
+          ? "Server-sent frames must not be masked."
+          : "Client-sent frames must be masked.");
+    }
+
+    // Get frame length, optionally reading from follow-up bytes if indicated by special values.
+    frameLength = b1 & B1_MASK_LENGTH;
+    if (frameLength == PAYLOAD_SHORT) {
+      frameLength = source.readShort() & 0xffffL; // Value is unsigned.
+    } else if (frameLength == PAYLOAD_LONG) {
+      frameLength = source.readLong();
+      if (frameLength < 0) {
+        throw new ProtocolException(
+            "Frame length 0x" + Long.toHexString(frameLength) + " > 0x7FFFFFFFFFFFFFFF");
+      }
+    }
+    frameBytesRead = 0;
+
+    if (isControlFrame && frameLength > PAYLOAD_BYTE_MAX) {
+      throw new ProtocolException("Control frame must be less than " + PAYLOAD_BYTE_MAX + "B.");
+    }
+
+    if (isMasked) {
+      // Read the masking key as bytes so that they can be used directly for unmasking.
+      source.readFully(maskKey);
+    }
+  }
+
+  private void readControlFrame() throws IOException {
+    Buffer buffer = new Buffer();
+    if (frameBytesRead < frameLength) {
+      if (isClient) {
+        source.readFully(buffer, frameLength);
+      } else {
+        while (frameBytesRead < frameLength) {
+          int toRead = (int) Math.min(frameLength - frameBytesRead, maskBuffer.length);
+          int read = source.read(maskBuffer, 0, toRead);
+          if (read == -1) throw new EOFException();
+          toggleMask(maskBuffer, read, maskKey, frameBytesRead);
+          buffer.write(maskBuffer, 0, read);
+          frameBytesRead += read;
+        }
+      }
+    }
+
+    switch (opcode) {
+      case OPCODE_CONTROL_PING:
+        frameCallback.onReadPing(buffer.readByteString());
+        break;
+      case OPCODE_CONTROL_PONG:
+        frameCallback.onReadPong(buffer.readByteString());
+        break;
+      case OPCODE_CONTROL_CLOSE:
+        int code = CLOSE_NO_STATUS_CODE;
+        String reason = "";
+        long bufferSize = buffer.size();
+        if (bufferSize == 1) {
+          throw new ProtocolException("Malformed close payload length of 1.");
+        } else if (bufferSize != 0) {
+          code = buffer.readShort();
+          reason = buffer.readUtf8();
+          String codeExceptionMessage = WebSocketProtocol.closeCodeExceptionMessage(code);
+          if (codeExceptionMessage != null) throw new ProtocolException(codeExceptionMessage);
+        }
+        frameCallback.onReadClose(code, reason);
+        closed = true;
+        break;
+      default:
+        throw new ProtocolException("Unknown control opcode: " + toHexString(opcode));
+    }
+  }
+
+  private void readMessageFrame() throws IOException {
+    int opcode = this.opcode;
+    if (opcode != OPCODE_TEXT && opcode != OPCODE_BINARY) {
+      throw new ProtocolException("Unknown opcode: " + toHexString(opcode));
+    }
+
+    Buffer message = new Buffer();
+    readMessage(message);
+
+    if (opcode == OPCODE_TEXT) {
+      frameCallback.onReadMessage(message.readUtf8());
+    } else {
+      frameCallback.onReadMessage(message.readByteString());
+    }
+  }
+
+  /** Read headers and process any control frames until we reach a non-control frame. */
+  void readUntilNonControlFrame() throws IOException {
+    while (!closed) {
+      readHeader();
+      if (!isControlFrame) {
+        break;
+      }
+      readControlFrame();
+    }
+  }
+
+  /**
+   * Reads a message body into across one or more frames. Control frames that occur between
+   * fragments will be processed. If the message payload is masked this will unmask as it's being
+   * processed.
+   */
+  private void readMessage(Buffer sink) throws IOException {
+    while (true) {
+      if (closed) throw new IOException("closed");
+
+      if (frameBytesRead == frameLength) {
+        if (isFinalFrame) return; // We are exhausted and have no continuations.
+
+        readUntilNonControlFrame();
+        if (opcode != OPCODE_CONTINUATION) {
+          throw new ProtocolException("Expected continuation opcode. Got: " + toHexString(opcode));
+        }
+        if (isFinalFrame && frameLength == 0) {
+          return; // Fast-path for empty final frame.
+        }
+      }
+
+      long toRead = frameLength - frameBytesRead;
+
+      long read;
+      if (isMasked) {
+        toRead = Math.min(toRead, maskBuffer.length);
+        read = source.read(maskBuffer, 0, (int) toRead);
+        if (read == -1) throw new EOFException();
+        toggleMask(maskBuffer, read, maskKey, frameBytesRead);
+        sink.write(maskBuffer, 0, (int) read);
+      } else {
+        read = source.read(sink, toRead);
+        if (read == -1) throw new EOFException();
+      }
+
+      frameBytesRead += read;
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
new file mode 100644
index 0000000000..321b5ae475
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
@@ -0,0 +1,250 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.ws;
+
+import java.io.IOException;
+import java.util.Random;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.ByteString;
+import okio.Sink;
+import okio.Timeout;
+
+import static okhttp3.internal.ws.WebSocketProtocol.B0_FLAG_FIN;
+import static okhttp3.internal.ws.WebSocketProtocol.B1_FLAG_MASK;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTINUATION;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTROL_CLOSE;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PING;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PONG;
+import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_BYTE_MAX;
+import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_LONG;
+import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_SHORT;
+import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_SHORT_MAX;
+import static okhttp3.internal.ws.WebSocketProtocol.toggleMask;
+import static okhttp3.internal.ws.WebSocketProtocol.validateCloseCode;
+
+/**
+ * An <a href="http://tools.ietf.org/html/rfc6455">RFC 6455</a>-compatible WebSocket frame writer.
+ *
+ * <p>This class is not thread safe.
+ */
+final class WebSocketWriter {
+  final boolean isClient;
+  final Random random;
+
+  /** Writes must be guarded by synchronizing on 'this'. */
+  final BufferedSink sink;
+  /** Access must be guarded by synchronizing on 'this'. */
+  boolean writerClosed;
+
+  final Buffer buffer = new Buffer();
+  final FrameSink frameSink = new FrameSink();
+
+  boolean activeWriter;
+
+  final byte[] maskKey;
+  final byte[] maskBuffer;
+
+  WebSocketWriter(boolean isClient, BufferedSink sink, Random random) {
+    if (sink == null) throw new NullPointerException("sink == null");
+    if (random == null) throw new NullPointerException("random == null");
+    this.isClient = isClient;
+    this.sink = sink;
+    this.random = random;
+
+    // Masks are only a concern for client writers.
+    maskKey = isClient ? new byte[4] : null;
+    maskBuffer = isClient ? new byte[8192] : null;
+  }
+
+  /** Send a ping with the supplied {@code payload}. */
+  void writePing(ByteString payload) throws IOException {
+    writeControlFrame(OPCODE_CONTROL_PING, payload);
+  }
+
+  /** Send a pong with the supplied {@code payload}. */
+  void writePong(ByteString payload) throws IOException {
+    writeControlFrame(OPCODE_CONTROL_PONG, payload);
+  }
+
+  /**
+   * Send a close frame with optional code and reason.
+   *
+   * @param code Status code as defined by <a
+   * href="http://tools.ietf.org/html/rfc6455#section-7.4">Section 7.4 of RFC 6455</a> or {@code 0}.
+   * @param reason Reason for shutting down or {@code null}.
+   */
+  void writeClose(int code, ByteString reason) throws IOException {
+    ByteString payload = ByteString.EMPTY;
+    if (code != 0 || reason != null) {
+      if (code != 0) {
+        validateCloseCode(code);
+      }
+      Buffer buffer = new Buffer();
+      buffer.writeShort(code);
+      if (reason != null) {
+        buffer.write(reason);
+      }
+      payload = buffer.readByteString();
+    }
+
+    try {
+      writeControlFrame(OPCODE_CONTROL_CLOSE, payload);
+    } finally {
+      writerClosed = true;
+    }
+  }
+
+  private void writeControlFrame(int opcode, ByteString payload) throws IOException {
+    if (writerClosed) throw new IOException("closed");
+
+    int length = payload.size();
+    if (length > PAYLOAD_BYTE_MAX) {
+      throw new IllegalArgumentException(
+          "Payload size must be less than or equal to " + PAYLOAD_BYTE_MAX);
+    }
+
+    int b0 = B0_FLAG_FIN | opcode;
+    sink.writeByte(b0);
+
+    int b1 = length;
+    if (isClient) {
+      b1 |= B1_FLAG_MASK;
+      sink.writeByte(b1);
+
+      random.nextBytes(maskKey);
+      sink.write(maskKey);
+
+      byte[] bytes = payload.toByteArray();
+      toggleMask(bytes, bytes.length, maskKey, 0);
+      sink.write(bytes);
+    } else {
+      sink.writeByte(b1);
+      sink.write(payload);
+    }
+
+    sink.flush();
+  }
+
+  /**
+   * Stream a message payload as a series of frames. This allows control frames to be interleaved
+   * between parts of the message.
+   */
+  Sink newMessageSink(int formatOpcode, long contentLength) {
+    if (activeWriter) {
+      throw new IllegalStateException("Another message writer is active. Did you call close()?");
+    }
+    activeWriter = true;
+
+    // Reset FrameSink state for a new writer.
+    frameSink.formatOpcode = formatOpcode;
+    frameSink.contentLength = contentLength;
+    frameSink.isFirstFrame = true;
+    frameSink.closed = false;
+
+    return frameSink;
+  }
+
+  void writeMessageFrame(int formatOpcode, long byteCount, boolean isFirstFrame,
+      boolean isFinal) throws IOException {
+    if (writerClosed) throw new IOException("closed");
+
+    int b0 = isFirstFrame ? formatOpcode : OPCODE_CONTINUATION;
+    if (isFinal) {
+      b0 |= B0_FLAG_FIN;
+    }
+    sink.writeByte(b0);
+
+    int b1 = 0;
+    if (isClient) {
+      b1 |= B1_FLAG_MASK;
+    }
+    if (byteCount <= PAYLOAD_BYTE_MAX) {
+      b1 |= (int) byteCount;
+      sink.writeByte(b1);
+    } else if (byteCount <= PAYLOAD_SHORT_MAX) {
+      b1 |= PAYLOAD_SHORT;
+      sink.writeByte(b1);
+      sink.writeShort((int) byteCount);
+    } else {
+      b1 |= PAYLOAD_LONG;
+      sink.writeByte(b1);
+      sink.writeLong(byteCount);
+    }
+
+    if (isClient) {
+      random.nextBytes(maskKey);
+      sink.write(maskKey);
+
+      for (long written = 0; written < byteCount; ) {
+        int toRead = (int) Math.min(byteCount, maskBuffer.length);
+        int read = buffer.read(maskBuffer, 0, toRead);
+        if (read == -1) throw new AssertionError();
+        toggleMask(maskBuffer, read, maskKey, written);
+        sink.write(maskBuffer, 0, read);
+        written += read;
+      }
+    } else {
+      sink.write(buffer, byteCount);
+    }
+
+    sink.emit();
+  }
+
+  final class FrameSink implements Sink {
+    int formatOpcode;
+    long contentLength;
+    boolean isFirstFrame;
+    boolean closed;
+
+    @Override public void write(Buffer source, long byteCount) throws IOException {
+      if (closed) throw new IOException("closed");
+
+      buffer.write(source, byteCount);
+
+      // Determine if this is a buffered write which we can defer until close() flushes.
+      boolean deferWrite = isFirstFrame
+          && contentLength != -1
+          && buffer.size() > contentLength - 8192 /* segment size */;
+
+      long emitCount = buffer.completeSegmentByteCount();
+      if (emitCount > 0 && !deferWrite) {
+        writeMessageFrame(formatOpcode, emitCount, isFirstFrame, false /* final */);
+        isFirstFrame = false;
+      }
+    }
+
+    @Override public void flush() throws IOException {
+      if (closed) throw new IOException("closed");
+
+      writeMessageFrame(formatOpcode, buffer.size(), isFirstFrame, false /* final */);
+      isFirstFrame = false;
+    }
+
+    @Override public Timeout timeout() {
+      return sink.timeout();
+    }
+
+    @SuppressWarnings("PointlessBitwiseExpression")
+    @Override public void close() throws IOException {
+      if (closed) throw new IOException("closed");
+
+      writeMessageFrame(formatOpcode, buffer.size(), isFirstFrame, true /* final */);
+      closed = true;
+      activeWriter = false;
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/package-info.java b/okhttp/src/main/java/okhttp3/package-info.java
new file mode 100644
index 0000000000..a34c5bbf86
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/package-info.java
@@ -0,0 +1,3 @@
+/** An HTTP+HTTP/2 client for Android and Java applications. */
+@javax.annotation.ParametersAreNonnullByDefault
+package okhttp3;
diff --git a/okhttp/src/main/resources/okhttp3/internal/publicsuffix/publicsuffixes.gz b/okhttp/src/main/resources/okhttp3/internal/publicsuffix/publicsuffixes.gz
new file mode 100644
index 0000000000..3d9b2c9ccf
Binary files /dev/null and b/okhttp/src/main/resources/okhttp3/internal/publicsuffix/publicsuffixes.gz differ
diff --git a/okhttp/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixListGenerator.java b/okhttp/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixListGenerator.java
new file mode 100644
index 0000000000..50b1f8703a
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixListGenerator.java
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.publicsuffix;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.SortedSet;
+import java.util.TreeSet;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.GzipSink;
+import okio.Okio;
+import okio.Sink;
+
+/**
+ * Downloads the public suffix list from https://publicsuffix.org/list/public_suffix_list.dat and
+ * transforms the file into an efficient format used by OkHttp.
+ *
+ * <p>The intent is to use this class to update the list periodically by manually running the main
+ * method. This should be run from the top-level okhttp directory.
+ *
+ * <p>The resulting file is used by {@link PublicSuffixDatabase}.
+ */
+public final class PublicSuffixListGenerator {
+  private static final String OKHTTP_RESOURCE_DIR = "okhttp" + File.separator + "src"
+      + File.separator + "main" + File.separator + "resources" + File.separator
+      + "okhttp3" + File.separator + "internal" + File.separator + "publicsuffix";
+
+  private static final ByteString EXCEPTION_RULE_MARKER = ByteString.encodeUtf8("!");
+  private static final String WILDCARD_CHAR = "*";
+
+  public static void main(String... args) throws IOException {
+    OkHttpClient client = new OkHttpClient.Builder().build();
+    Request request = new Request.Builder()
+        .url("https://publicsuffix.org/list/public_suffix_list.dat")
+        .build();
+    SortedSet<ByteString> sortedRules = new TreeSet<>();
+    SortedSet<ByteString> sortedExceptionRules = new TreeSet<>();
+    try (Response response = client.newCall(request).execute()) {
+      BufferedSource source = response.body().source();
+      int totalRuleBytes = 0;
+      int totalExceptionRuleBytes = 0;
+      while (!source.exhausted()) {
+        String line = source.readUtf8LineStrict();
+        if (line.trim().isEmpty() || line.startsWith("//")) continue;
+
+        if (line.contains(WILDCARD_CHAR)) {
+          assertWildcardRule(line);
+        }
+
+        ByteString rule = ByteString.encodeUtf8(line);
+        if (rule.startsWith(EXCEPTION_RULE_MARKER)) {
+          rule = rule.substring(1);
+          // We use '\n' for end of value.
+          totalExceptionRuleBytes += rule.size() + 1;
+          sortedExceptionRules.add(rule);
+        } else {
+          totalRuleBytes += rule.size() + 1; // We use '\n' for end of value.
+          sortedRules.add(rule);
+        }
+      }
+
+      File resources = new File(OKHTTP_RESOURCE_DIR);
+      if (!resources.mkdirs() && !resources.exists()) {
+        throw new RuntimeException("Unable to create resource directory!");
+      }
+
+      Sink fileSink = Okio.sink(new File(resources, PublicSuffixDatabase.PUBLIC_SUFFIX_RESOURCE));
+      try (BufferedSink sink = Okio.buffer(new GzipSink(fileSink))) {
+        sink.writeInt(totalRuleBytes);
+        for (ByteString domain : sortedRules) {
+          sink.write(domain).writeByte('\n');
+        }
+
+        sink.writeInt(totalExceptionRuleBytes);
+        for (ByteString domain : sortedExceptionRules) {
+          sink.write(domain).writeByte('\n');
+        }
+      }
+    }
+  }
+
+  /**
+   * These assertions ensure the {@link PublicSuffixDatabase} remains correct. The specification is
+   * very flexible regarding wildcard rules, but this flexibility is not something currently used
+   * in practice. To simplify the implementation, we've avoided implementing the flexible rules in
+   * favor of supporting what's actually used in practice. That means if these assertions ever fail,
+   * the implementation will need to be revisited to support a more flexible rule.
+   */
+  private static void assertWildcardRule(String rule) {
+    if (rule.indexOf(WILDCARD_CHAR) != 0) {
+      throw new RuntimeException("Wildcard Assertion Failure: " + rule + "\nA wildcard rule was "
+          + "added with a wildcard that is not in leftmost position! We'll need to change the "
+          + PublicSuffixDatabase.class.getName() + " to handle this.");
+    }
+    if (rule.indexOf(WILDCARD_CHAR, 1) != -1) {
+      throw new RuntimeException("Wildcard Assertion Failure: " + rule + "\nA wildcard rule was "
+          + "added with multiple wildcards! We'll need to change "
+          + PublicSuffixDatabase.class.getName() + " to handle this.");
+    }
+    if (rule.length() == 1) {
+      throw new RuntimeException("Wildcard Assertion Failure: " + rule + "\nA wildcard rule was "
+          + "added that wildcards the first level! We'll need to change the "
+          + PublicSuffixDatabase.class.getName() + " to handle this.");
+    }
+  }
+}
diff --git a/pom.xml b/pom.xml
new file mode 100644
index 0000000000..92945305da
--- /dev/null
+++ b/pom.xml
@@ -0,0 +1,574 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>org.sonatype.oss</groupId>
+    <artifactId>oss-parent</artifactId>
+    <version>7</version>
+  </parent>
+
+  <groupId>com.squareup.okhttp3</groupId>
+  <artifactId>parent</artifactId>
+  <version>3.10.0-SNAPSHOT</version>
+  <packaging>pom</packaging>
+
+  <name>OkHttp (Parent)</name>
+  <description>An HTTP+HTTP/2 client for Android and Java applications</description>
+  <url>https://github.com/square/okhttp</url>
+
+  <modules>
+    <module>okhttp</module>
+    <module>okhttp-tests</module>
+
+    <module>okhttp-android-support</module>
+
+    <module>okhttp-apache</module>
+    <module>okhttp-testing-support</module>
+    <module>okhttp-urlconnection</module>
+
+    <module>okhttp-logging-interceptor</module>
+
+    <module>okcurl</module>
+    <module>mockwebserver</module>
+    <module>samples</module>
+    <module>benchmarks</module>
+  </modules>
+
+  <properties>
+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+
+    <!-- Compilation -->
+    <airlift.version>0.7</airlift.version>
+    <!-- ALPN library targeted to Java 7 -->
+    <alpn.jdk7.version>7.1.2.v20141202</alpn.jdk7.version>
+    <android.version>4.1.1.4</android.version>
+    <animal.sniffer.version>1.15</animal.sniffer.version>
+    <apache.http.version>4.2.2</apache.http.version>
+    <bouncycastle.version>1.50</bouncycastle.version>
+    <guava.version>16.0</guava.version>
+    <java.version>1.7</java.version>
+    <moshi.version>1.1.0</moshi.version>
+    <okio.version>1.13.0</okio.version>
+
+    <!-- Test Dependencies -->
+    <junit.version>4.12</junit.version>
+
+    <!-- platform test mode -->
+    <okhttp.platform>platform</okhttp.platform>
+  </properties>
+
+  <scm>
+    <url>https://github.com/square/okhttp/</url>
+    <connection>scm:git:https://github.com/square/okhttp.git</connection>
+    <developerConnection>scm:git:git@github.com:square/okhttp.git</developerConnection>
+    <tag>HEAD</tag>
+  </scm>
+
+  <issueManagement>
+    <system>GitHub Issues</system>
+    <url>https://github.com/square/okhttp/issues</url>
+  </issueManagement>
+
+  <licenses>
+    <license>
+      <name>Apache 2.0</name>
+      <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
+    </license>
+  </licenses>
+
+  <dependencyManagement>
+    <dependencies>
+      <dependency>
+        <groupId>com.squareup.okio</groupId>
+        <artifactId>okio</artifactId>
+        <version>${okio.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>com.google.code.findbugs</groupId>
+        <artifactId>jsr305</artifactId>
+        <version>3.0.2</version>
+        <scope>provided</scope>
+      </dependency>
+      <dependency>
+        <groupId>junit</groupId>
+        <artifactId>junit</artifactId>
+        <version>${junit.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>org.bouncycastle</groupId>
+        <artifactId>bcprov-jdk15on</artifactId>
+        <version>${bouncycastle.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>org.apache.httpcomponents</groupId>
+        <artifactId>httpclient</artifactId>
+        <version>${apache.http.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>io.airlift</groupId>
+        <artifactId>airline</artifactId>
+        <version>${airlift.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>com.google.guava</groupId>
+        <artifactId>guava</artifactId>
+        <version>${guava.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>com.google.android</groupId>
+        <artifactId>android</artifactId>
+        <version>${android.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>com.squareup.moshi</groupId>
+        <artifactId>moshi</artifactId>
+        <version>${moshi.version}</version>
+      </dependency>
+    </dependencies>
+  </dependencyManagement>
+
+  <build>
+    <pluginManagement>
+      <plugins>
+        <plugin>
+          <groupId>org.apache.maven.plugins</groupId>
+          <artifactId>maven-compiler-plugin</artifactId>
+          <version>3.6.1</version>
+          <configuration>
+            <compilerId>javac-with-errorprone</compilerId>
+            <forceJavacCompilerUse>true</forceJavacCompilerUse>
+            <source>${java.version}</source>
+            <target>${java.version}</target>
+          </configuration>
+          <dependencies>
+            <dependency>
+              <groupId>org.codehaus.plexus</groupId>
+              <artifactId>plexus-compiler-javac-errorprone</artifactId>
+              <version>2.8.1</version>
+            </dependency>
+            <dependency>
+              <groupId>com.google.errorprone</groupId>
+              <artifactId>error_prone_core</artifactId>
+              <version>2.0.16</version>
+            </dependency>
+          </dependencies>
+        </plugin>
+
+        <plugin>
+          <groupId>org.apache.maven.plugins</groupId>
+          <artifactId>maven-surefire-plugin</artifactId>
+          <version>2.17</version>
+          <configuration>
+            <systemPropertyVariables>
+              <okhttp.platform>${okhttp.platform}</okhttp.platform>
+            </systemPropertyVariables>
+            <properties>
+              <!--
+                Configure a listener for enforcing that no uncaught exceptions issue from OkHttp
+                tests. Every test must have a <scope>test</scope> dependency on
+                okhttp-testing-support.
+                -->
+              <property>
+                <name>listener</name>
+                <value>okhttp3.testing.InstallUncaughtExceptionHandlerListener</value>
+              </property>
+            </properties>
+          </configuration>
+          <dependencies>
+            <dependency>
+              <groupId>org.apache.maven.surefire</groupId>
+              <artifactId>surefire-junit47</artifactId>
+              <version>2.17</version>
+            </dependency>
+          </dependencies>
+        </plugin>
+
+        <plugin>
+          <groupId>org.apache.maven.plugins</groupId>
+          <artifactId>maven-javadoc-plugin</artifactId>
+          <version>2.9</version>
+        </plugin>
+      </plugins>
+    </pluginManagement>
+
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-release-plugin</artifactId>
+        <version>2.4.2</version>
+        <dependencies>
+          <dependency>
+            <groupId>org.apache.maven.scm</groupId>
+            <artifactId>maven-scm-provider-gitexe</artifactId>
+            <version>1.9</version>
+          </dependency>
+        </dependencies>
+        <configuration>
+          <autoVersionSubmodules>true</autoVersionSubmodules>
+        </configuration>
+      </plugin>
+
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-checkstyle-plugin</artifactId>
+        <version>2.17</version>
+        <dependencies>
+          <dependency>
+            <groupId>com.puppycrawl.tools</groupId>
+            <artifactId>checkstyle</artifactId>
+            <version>7.7</version>
+          </dependency>
+        </dependencies>
+        <configuration>
+          <failsOnError>true</failsOnError>
+          <configLocation>checkstyle.xml</configLocation>
+          <consoleOutput>true</consoleOutput>
+          <excludes>**/CipherSuite.java</excludes>
+        </configuration>
+        <executions>
+          <execution>
+            <phase>verify</phase>
+            <goals>
+              <goal>checkstyle</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
+      <plugin>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>animal-sniffer-maven-plugin</artifactId>
+        <version>${animal.sniffer.version}</version>
+        <executions>
+          <execution>
+            <phase>test</phase>
+            <goals>
+              <goal>check</goal>
+            </goals>
+          </execution>
+        </executions>
+        <configuration>
+          <signature>
+            <groupId>org.codehaus.mojo.signature</groupId>
+            <artifactId>java16</artifactId>
+            <version>1.1</version>
+          </signature>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+
+  <profiles>
+    <profile>
+      <id>alpn-when-jdk7</id>
+      <activation>
+        <jdk>1.7</jdk>
+      </activation>
+      <properties>
+        <bootclasspathPrefix>
+          ${settings.localRepository}/org/mortbay/jetty/alpn/alpn-boot/${alpn.jdk7.version}/alpn-boot-${alpn.jdk7.version}.jar
+        </bootclasspathPrefix>
+        <okhttp.platform>jdk-with-jetty-boot</okhttp.platform>
+      </properties>
+      <build>
+        <pluginManagement>
+          <plugins>
+            <plugin>
+              <groupId>org.apache.maven.plugins</groupId>
+              <artifactId>maven-surefire-plugin</artifactId>
+              <configuration>
+                <argLine>-Xbootclasspath/p:${bootclasspathPrefix} -Xms512m -Xmx512m</argLine>
+              </configuration>
+              <dependencies>
+                <dependency>
+                  <groupId>org.mortbay.jetty.alpn</groupId>
+                  <artifactId>alpn-boot</artifactId>
+                  <version>${alpn.jdk7.version}</version>
+                </dependency>
+              </dependencies>
+            </plugin>
+          </plugins>
+        </pluginManagement>
+      </build>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8</id>
+      <activation>
+        <jdk>1.8</jdk>
+      </activation>
+      <properties>
+        <bootclasspathPrefix>
+          ${settings.localRepository}/org/mortbay/jetty/alpn/alpn-boot/${alpn.jdk8.version}/alpn-boot-${alpn.jdk8.version}.jar
+        </bootclasspathPrefix>
+        <okhttp.platform>jdk-with-jetty-boot</okhttp.platform>
+      </properties>
+      <build>
+        <pluginManagement>
+          <plugins>
+            <plugin>
+              <groupId>org.apache.maven.plugins</groupId>
+              <artifactId>maven-surefire-plugin</artifactId>
+              <configuration>
+                <argLine>-Xbootclasspath/p:${bootclasspathPrefix} -Xms512m -Xmx512m</argLine>
+              </configuration>
+              <dependencies>
+                <dependency>
+                  <groupId>org.mortbay.jetty.alpn</groupId>
+                  <artifactId>alpn-boot</artifactId>
+                  <version>${alpn.jdk8.version}</version>
+                </dependency>
+              </dependencies>
+            </plugin>
+          </plugins>
+        </pluginManagement>
+      </build>
+    </profile>
+    <profile>
+      <id>jdk9</id>
+      <activation>
+        <jdk>9</jdk>
+      </activation>
+      <properties>
+        <okhttp.platform>jdk9</okhttp.platform>
+      </properties>
+    </profile>
+    <!-- ALPN Versions targeted for each Java 8 minor release -->
+    <!-- Check versions with this page: -->
+    <!-- http://www.eclipse.org/jetty/documentation/current/alpn-chapter.html#alpn-chapterchapterversions -->
+    <profile>
+      <id>alpn-when-jdk8_05</id>
+      <activation>
+        <jdk>1.8.0_05</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.0.v20141016</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_11</id>
+      <activation>
+        <jdk>1.8.0_11</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.0.v20141016</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_20</id>
+      <activation>
+        <jdk>1.8.0_20</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.0.v20141016</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_25</id>
+      <activation>
+        <jdk>1.8.0_25</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.2.v20141202</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_31</id>
+      <activation>
+        <jdk>1.8.0_31</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.3.v20150130</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_40</id>
+      <activation>
+        <jdk>1.8.0_40</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.3.v20150130</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_45</id>
+      <activation>
+        <jdk>1.8.0_45</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.3.v20150130</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_51</id>
+      <activation>
+        <jdk>1.8.0_51</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.4.v20150727</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_60</id>
+      <activation>
+        <jdk>1.8.0_60</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.5.v20150921</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_65</id>
+      <activation>
+        <jdk>1.8.0_65</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.6.v20151105</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_66</id>
+      <activation>
+        <jdk>1.8.0_66</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.6.v20151105</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_71</id>
+      <activation>
+        <jdk>1.8.0_71</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.7.v20160121</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_72</id>
+      <activation>
+        <jdk>1.8.0_72</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.7.v20160121</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_73</id>
+      <activation>
+        <jdk>1.8.0_73</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.7.v20160121</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_74</id>
+      <activation>
+        <jdk>1.8.0_74</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.7.v20160121</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_77</id>
+      <activation>
+        <jdk>1.8.0_77</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.7.v20160121</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_91</id>
+      <activation>
+        <jdk>1.8.0_91</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.7.v20160121</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_92</id>
+      <activation>
+        <jdk>1.8.0_92</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.8.v20160420</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_101</id>
+      <activation>
+        <jdk>1.8.0_101</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.8.v20160420</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_102</id>
+      <activation>
+        <jdk>1.8.0_102</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.9.v20160720</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_111</id>
+      <activation>
+        <jdk>1.8.0_111</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.9.v20160720</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_112</id>
+      <activation>
+        <jdk>1.8.0_112</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.9.v20160720</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_121</id>
+      <activation>
+        <jdk>1.8.0_121</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_131</id>
+      <activation>
+        <jdk>1.8.0_131</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_141</id>
+      <activation>
+        <jdk>1.8.0_141</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_144</id>
+      <activation>
+        <jdk>1.8.0_144</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
+      </properties>
+    </profile>
+  </profiles>
+</project>
diff --git a/samples/crawler/pom.xml b/samples/crawler/pom.xml
new file mode 100644
index 0000000000..77eea94b1b
--- /dev/null
+++ b/samples/crawler/pom.xml
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp3.sample</groupId>
+    <artifactId>sample-parent</artifactId>
+    <version>3.10.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>crawler</artifactId>
+  <name>Sample: Crawler</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>org.jsoup</groupId>
+      <artifactId>jsoup</artifactId>
+      <version>1.7.3</version>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/samples/crawler/src/main/java/okhttp3/sample/Crawler.java b/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
new file mode 100644
index 0000000000..72f59d32c2
--- /dev/null
+++ b/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
@@ -0,0 +1,146 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.sample;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Collections;
+import java.util.LinkedHashSet;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.atomic.AtomicInteger;
+import okhttp3.Cache;
+import okhttp3.HttpUrl;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.NamedRunnable;
+import org.jsoup.Jsoup;
+import org.jsoup.nodes.Document;
+import org.jsoup.nodes.Element;
+
+/**
+ * Fetches HTML from a requested URL, follows the links, and repeats.
+ */
+public final class Crawler {
+  private final OkHttpClient client;
+  private final Set<HttpUrl> fetchedUrls = Collections.synchronizedSet(
+      new LinkedHashSet<HttpUrl>());
+  private final LinkedBlockingQueue<HttpUrl> queue = new LinkedBlockingQueue<>();
+  private final ConcurrentHashMap<String, AtomicInteger> hostnames = new ConcurrentHashMap<>();
+
+  public Crawler(OkHttpClient client) {
+    this.client = client;
+  }
+
+  private void parallelDrainQueue(int threadCount) {
+    ExecutorService executor = Executors.newFixedThreadPool(threadCount);
+    for (int i = 0; i < threadCount; i++) {
+      executor.execute(new NamedRunnable("Crawler %s", i) {
+        @Override protected void execute() {
+          try {
+            drainQueue();
+          } catch (Exception e) {
+            e.printStackTrace();
+          }
+        }
+      });
+    }
+    executor.shutdown();
+  }
+
+  private void drainQueue() throws Exception {
+    for (HttpUrl url; (url = queue.take()) != null; ) {
+      if (!fetchedUrls.add(url)) {
+        continue;
+      }
+
+      Thread currentThread = Thread.currentThread();
+      String originalName = currentThread.getName();
+      currentThread.setName("Crawler " + url.toString());
+      try {
+        fetch(url);
+      } catch (IOException e) {
+        System.out.printf("XXX: %s %s%n", url, e);
+      } finally {
+        currentThread.setName(originalName);
+      }
+    }
+  }
+
+  public void fetch(HttpUrl url) throws IOException {
+    // Skip hosts that we've visited many times.
+    AtomicInteger hostnameCount = new AtomicInteger();
+    AtomicInteger previous = hostnames.putIfAbsent(url.host(), hostnameCount);
+    if (previous != null) hostnameCount = previous;
+    if (hostnameCount.incrementAndGet() > 100) return;
+
+    Request request = new Request.Builder()
+        .url(url)
+        .build();
+    try (Response response = client.newCall(request).execute()) {
+      String responseSource = response.networkResponse() != null ? ("(network: "
+          + response.networkResponse().code()
+          + " over "
+          + response.protocol()
+          + ")") : "(cache)";
+      int responseCode = response.code();
+
+      System.out.printf("%03d: %s %s%n", responseCode, url, responseSource);
+
+      String contentType = response.header("Content-Type");
+      if (responseCode != 200 || contentType == null) {
+        return;
+      }
+
+      MediaType mediaType = MediaType.parse(contentType);
+      if (mediaType == null || !mediaType.subtype().equalsIgnoreCase("html")) {
+        return;
+      }
+
+      Document document = Jsoup.parse(response.body().string(), url.toString());
+      for (Element element : document.select("a[href]")) {
+        String href = element.attr("href");
+        HttpUrl link = response.request().url().resolve(href);
+        if (link == null) continue; // URL is either invalid or its scheme isn't http/https.
+        queue.add(link.newBuilder().fragment(null).build());
+      }
+    }
+  }
+
+  public static void main(String[] args) throws IOException {
+    if (args.length != 2) {
+      System.out.println("Usage: Crawler <cache dir> <root>");
+      return;
+    }
+
+    int threadCount = 20;
+    long cacheByteCount = 1024L * 1024L * 100L;
+
+    Cache cache = new Cache(new File(args[0]), cacheByteCount);
+    OkHttpClient client = new OkHttpClient.Builder()
+        .cache(cache)
+        .build();
+
+    Crawler crawler = new Crawler(client);
+    crawler.queue.add(HttpUrl.parse(args[1]));
+    crawler.parallelDrainQueue(threadCount);
+  }
+}
diff --git a/samples/guide/pom.xml b/samples/guide/pom.xml
new file mode 100644
index 0000000000..c654656624
--- /dev/null
+++ b/samples/guide/pom.xml
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp3.sample</groupId>
+    <artifactId>sample-parent</artifactId>
+    <version>3.10.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>guide</artifactId>
+  <name>Sample: Guide</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.moshi</groupId>
+      <artifactId>moshi</artifactId>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/samples/guide/src/main/java/okhttp3/guide/GetExample.java b/samples/guide/src/main/java/okhttp3/guide/GetExample.java
new file mode 100644
index 0000000000..35a1cc658c
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/guide/GetExample.java
@@ -0,0 +1,26 @@
+package okhttp3.guide;
+
+import java.io.IOException;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+
+public class GetExample {
+  OkHttpClient client = new OkHttpClient();
+
+  String run(String url) throws IOException {
+    Request request = new Request.Builder()
+        .url(url)
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      return response.body().string();
+    }
+  }
+
+  public static void main(String[] args) throws IOException {
+    GetExample example = new GetExample();
+    String response = example.run("https://raw.github.com/square/okhttp/master/README.md");
+    System.out.println(response);
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/guide/PostExample.java b/samples/guide/src/main/java/okhttp3/guide/PostExample.java
new file mode 100644
index 0000000000..b6e70ccc7d
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/guide/PostExample.java
@@ -0,0 +1,45 @@
+package okhttp3.guide;
+
+import java.io.IOException;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+
+public class PostExample {
+  public static final MediaType JSON
+      = MediaType.parse("application/json; charset=utf-8");
+
+  OkHttpClient client = new OkHttpClient();
+
+  String post(String url, String json) throws IOException {
+    RequestBody body = RequestBody.create(JSON, json);
+    Request request = new Request.Builder()
+        .url(url)
+        .post(body)
+        .build();
+    try (Response response = client.newCall(request).execute()) {
+      return response.body().string();
+    }
+  }
+
+  String bowlingJson(String player1, String player2) {
+    return "{'winCondition':'HIGH_SCORE',"
+        + "'name':'Bowling',"
+        + "'round':4,"
+        + "'lastSaved':1367702411696,"
+        + "'dateStarted':1367702378785,"
+        + "'players':["
+        + "{'name':'" + player1 + "','history':[10,8,6,7,8],'color':-13388315,'total':39},"
+        + "{'name':'" + player2 + "','history':[6,10,5,10,10],'color':-48060,'total':41}"
+        + "]}";
+  }
+
+  public static void main(String[] args) throws IOException {
+    PostExample example = new PostExample();
+    String json = example.bowlingJson("Jesse", "Jake");
+    String response = example.post("http://www.roundsapp.com/post", json);
+    System.out.println(response);
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/AccessHeaders.java b/samples/guide/src/main/java/okhttp3/recipes/AccessHeaders.java
new file mode 100644
index 0000000000..95fa49241c
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/AccessHeaders.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.IOException;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+
+public final class AccessHeaders {
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://api.github.com/repos/square/okhttp/issues")
+        .header("User-Agent", "OkHttp Headers.java")
+        .addHeader("Accept", "application/json; q=0.5")
+        .addHeader("Accept", "application/vnd.github.v3+json")
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+      System.out.println("Server: " + response.header("Server"));
+      System.out.println("Date: " + response.header("Date"));
+      System.out.println("Vary: " + response.headers("Vary"));
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new AccessHeaders().run();
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/AsynchronousGet.java b/samples/guide/src/main/java/okhttp3/recipes/AsynchronousGet.java
new file mode 100644
index 0000000000..68f1c2d591
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/AsynchronousGet.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.IOException;
+import okhttp3.Call;
+import okhttp3.Callback;
+import okhttp3.Headers;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+
+public final class AsynchronousGet {
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("http://publicobject.com/helloworld.txt")
+        .build();
+
+    client.newCall(request).enqueue(new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+        e.printStackTrace();
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        try (ResponseBody responseBody = response.body()) {
+          if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+          Headers responseHeaders = response.headers();
+          for (int i = 0, size = responseHeaders.size(); i < size; i++) {
+            System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i));
+          }
+
+          System.out.println(responseBody.string());
+        }
+      }
+    });
+  }
+
+  public static void main(String... args) throws Exception {
+    new AsynchronousGet().run();
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/Authenticate.java b/samples/guide/src/main/java/okhttp3/recipes/Authenticate.java
new file mode 100644
index 0000000000..4eb09d8f11
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/Authenticate.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.IOException;
+import okhttp3.Authenticator;
+import okhttp3.Credentials;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.Route;
+
+public final class Authenticate {
+  private final OkHttpClient client;
+
+  public Authenticate() {
+    client = new OkHttpClient.Builder()
+        .authenticator(new Authenticator() {
+          @Override public Request authenticate(Route route, Response response) throws IOException {
+            if (response.request().header("Authorization") != null) {
+              return null; // Give up, we've already attempted to authenticate.
+            }
+
+            System.out.println("Authenticating for response: " + response);
+            System.out.println("Challenges: " + response.challenges());
+            String credential = Credentials.basic("jesse", "password1");
+            return response.request().newBuilder()
+                .header("Authorization", credential)
+                .build();
+          }
+        })
+        .build();
+  }
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("http://publicobject.com/secrets/hellosecret.txt")
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+      System.out.println(response.body().string());
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new Authenticate().run();
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CacheResponse.java b/samples/guide/src/main/java/okhttp3/recipes/CacheResponse.java
new file mode 100644
index 0000000000..c43f9214ab
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/CacheResponse.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.File;
+import java.io.IOException;
+import okhttp3.Cache;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+
+public final class CacheResponse {
+  private final OkHttpClient client;
+
+  public CacheResponse(File cacheDirectory) throws Exception {
+    int cacheSize = 10 * 1024 * 1024; // 10 MiB
+    Cache cache = new Cache(cacheDirectory, cacheSize);
+
+    client = new OkHttpClient.Builder()
+        .cache(cache)
+        .build();
+  }
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("http://publicobject.com/helloworld.txt")
+        .build();
+
+    String response1Body;
+    try (Response response1 = client.newCall(request).execute()) {
+      if (!response1.isSuccessful()) throw new IOException("Unexpected code " + response1);
+
+      response1Body = response1.body().string();
+      System.out.println("Response 1 response:          " + response1);
+      System.out.println("Response 1 cache response:    " + response1.cacheResponse());
+      System.out.println("Response 1 network response:  " + response1.networkResponse());
+    }
+
+    String response2Body;
+    try (Response response2 = client.newCall(request).execute()) {
+      if (!response2.isSuccessful()) throw new IOException("Unexpected code " + response2);
+
+      response2Body = response2.body().string();
+      System.out.println("Response 2 response:          " + response2);
+      System.out.println("Response 2 cache response:    " + response2.cacheResponse());
+      System.out.println("Response 2 network response:  " + response2.networkResponse());
+    }
+
+    System.out.println("Response 2 equals Response 1? " + response1Body.equals(response2Body));
+  }
+
+  public static void main(String... args) throws Exception {
+    new CacheResponse(new File("CacheResponse.tmp")).run();
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CancelCall.java b/samples/guide/src/main/java/okhttp3/recipes/CancelCall.java
new file mode 100644
index 0000000000..644f638300
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/CancelCall.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.IOException;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
+import okhttp3.Call;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+
+public class CancelCall {
+  private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("http://httpbin.org/delay/2") // This URL is served with a 2 second delay.
+        .build();
+
+    final long startNanos = System.nanoTime();
+    final Call call = client.newCall(request);
+
+    // Schedule a job to cancel the call in 1 second.
+    executor.schedule(new Runnable() {
+      @Override public void run() {
+        System.out.printf("%.2f Canceling call.%n", (System.nanoTime() - startNanos) / 1e9f);
+        call.cancel();
+        System.out.printf("%.2f Canceled call.%n", (System.nanoTime() - startNanos) / 1e9f);
+      }
+    }, 1, TimeUnit.SECONDS);
+
+    System.out.printf("%.2f Executing call.%n", (System.nanoTime() - startNanos) / 1e9f);
+    try (Response response = call.execute()) {
+      System.out.printf("%.2f Call was expected to fail, but completed: %s%n",
+          (System.nanoTime() - startNanos) / 1e9f, response);
+    } catch (IOException e) {
+      System.out.printf("%.2f Call failed as expected: %s%n",
+          (System.nanoTime() - startNanos) / 1e9f, e);
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new CancelCall().run();
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java b/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java
new file mode 100644
index 0000000000..91c3fcc59f
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.IOException;
+import java.security.cert.Certificate;
+import okhttp3.CertificatePinner;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+
+public final class CertificatePinning {
+  private final OkHttpClient client;
+
+  public CertificatePinning() {
+    client = new OkHttpClient.Builder()
+        .certificatePinner(
+            new CertificatePinner.Builder()
+                .add("publicobject.com", "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
+                .build())
+        .build();
+  }
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://publicobject.com/robots.txt")
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+      for (Certificate certificate : response.handshake().peerCertificates()) {
+        System.out.println(CertificatePinner.pin(certificate));
+      }
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new CertificatePinning().run();
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CheckHandshake.java b/samples/guide/src/main/java/okhttp3/recipes/CheckHandshake.java
new file mode 100644
index 0000000000..befd80983c
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/CheckHandshake.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.IOException;
+import java.security.cert.Certificate;
+import java.util.Collections;
+import java.util.Set;
+import okhttp3.CertificatePinner;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+
+public final class CheckHandshake {
+  /** Rejects otherwise-trusted certificates. */
+  private static final Interceptor CHECK_HANDSHAKE_INTERCEPTOR = new Interceptor() {
+    Set<String> blacklist = Collections.singleton(
+        "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=");
+
+    @Override public Response intercept(Chain chain) throws IOException {
+      for (Certificate certificate : chain.connection().handshake().peerCertificates()) {
+        String pin = CertificatePinner.pin(certificate);
+        if (blacklist.contains(pin)) {
+          throw new IOException("Blacklisted peer certificate: " + pin);
+        }
+      }
+      return chain.proceed(chain.request());
+    }
+  };
+
+  private final OkHttpClient client = new OkHttpClient.Builder()
+      .addNetworkInterceptor(CHECK_HANDSHAKE_INTERCEPTOR)
+      .build();
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://publicobject.com/helloworld.txt")
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+      System.out.println(response.body().string());
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new CheckHandshake().run();
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/ConfigureTimeouts.java b/samples/guide/src/main/java/okhttp3/recipes/ConfigureTimeouts.java
new file mode 100644
index 0000000000..a6d3000732
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/ConfigureTimeouts.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.util.concurrent.TimeUnit;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+
+public final class ConfigureTimeouts {
+  private final OkHttpClient client;
+
+  public ConfigureTimeouts() throws Exception {
+    client = new OkHttpClient.Builder()
+        .connectTimeout(10, TimeUnit.SECONDS)
+        .writeTimeout(10, TimeUnit.SECONDS)
+        .readTimeout(30, TimeUnit.SECONDS)
+        .build();
+  }
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("http://httpbin.org/delay/2") // This URL is served with a 2 second delay.
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      System.out.println("Response completed: " + response);
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new ConfigureTimeouts().run();
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CustomCipherSuites.java b/samples/guide/src/main/java/okhttp3/recipes/CustomCipherSuites.java
new file mode 100644
index 0000000000..b568bdf01c
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/CustomCipherSuites.java
@@ -0,0 +1,169 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.Socket;
+import java.security.GeneralSecurityException;
+import java.security.KeyManagementException;
+import java.security.KeyStore;
+import java.security.NoSuchAlgorithmException;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.CipherSuite;
+import okhttp3.ConnectionSpec;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+
+public final class CustomCipherSuites {
+  private final OkHttpClient client;
+
+  public CustomCipherSuites() throws GeneralSecurityException {
+    // Configure cipher suites to demonstrate how to customize which cipher suites will be used for
+    // an OkHttp request. In order to be selected a cipher suite must be included in both OkHttp's
+    // connection spec and in the SSLSocket's enabled cipher suites array. Most applications should
+    // not customize the cipher suites list.
+    List<CipherSuite> customCipherSuites = Arrays.asList(
+        CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+        CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+        CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+        CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384);
+    final ConnectionSpec spec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+        .cipherSuites(customCipherSuites.toArray(new CipherSuite[0]))
+        .build();
+
+    X509TrustManager trustManager = defaultTrustManager();
+    SSLSocketFactory sslSocketFactory = defaultSslSocketFactory(trustManager);
+    SSLSocketFactory customSslSocketFactory = new DelegatingSSLSocketFactory(sslSocketFactory) {
+      @Override protected SSLSocket configureSocket(SSLSocket socket) throws IOException {
+        socket.setEnabledCipherSuites(javaNames(spec.cipherSuites()));
+        return socket;
+      }
+    };
+
+    client = new OkHttpClient.Builder()
+        .connectionSpecs(Collections.singletonList(spec))
+        .sslSocketFactory(customSslSocketFactory, trustManager)
+        .build();
+  }
+
+  /**
+   * Returns the VM's default SSL socket factory, using {@code trustManager} for trusted root
+   * certificates.
+   */
+  private SSLSocketFactory defaultSslSocketFactory(X509TrustManager trustManager)
+      throws NoSuchAlgorithmException, KeyManagementException {
+    SSLContext sslContext = SSLContext.getInstance("TLS");
+    sslContext.init(null, new TrustManager[] { trustManager }, null);
+
+    return sslContext.getSocketFactory();
+  }
+
+  /** Returns a trust manager that trusts the VM's default certificate authorities. */
+  private X509TrustManager defaultTrustManager() throws GeneralSecurityException {
+    TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+        TrustManagerFactory.getDefaultAlgorithm());
+    trustManagerFactory.init((KeyStore) null);
+    TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
+    if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
+      throw new IllegalStateException("Unexpected default trust managers:"
+          + Arrays.toString(trustManagers));
+    }
+    return (X509TrustManager) trustManagers[0];
+  }
+
+  private String[] javaNames(List<CipherSuite> cipherSuites) {
+    String[] result = new String[cipherSuites.size()];
+    for (int i = 0; i < result.length; i++) {
+      result[i] = cipherSuites.get(i).javaName();
+    }
+    return result;
+  }
+
+  /**
+   * An SSL socket factory that forwards all calls to a delegate. Override {@link #configureSocket}
+   * to customize a created socket before it is returned.
+   */
+  static class DelegatingSSLSocketFactory extends SSLSocketFactory {
+    protected final SSLSocketFactory delegate;
+
+    DelegatingSSLSocketFactory(SSLSocketFactory delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public String[] getDefaultCipherSuites() {
+      return delegate.getDefaultCipherSuites();
+    }
+
+    @Override public String[] getSupportedCipherSuites() {
+      return delegate.getSupportedCipherSuites();
+    }
+
+    @Override public Socket createSocket(
+        Socket socket, String host, int port, boolean autoClose) throws IOException {
+      return configureSocket((SSLSocket) delegate.createSocket(socket, host, port, autoClose));
+    }
+
+    @Override public Socket createSocket(String host, int port) throws IOException {
+      return configureSocket((SSLSocket) delegate.createSocket(host, port));
+    }
+
+    @Override public Socket createSocket(
+        String host, int port, InetAddress localHost, int localPort) throws IOException {
+      return configureSocket((SSLSocket) delegate.createSocket(host, port, localHost, localPort));
+    }
+
+    @Override public Socket createSocket(InetAddress host, int port) throws IOException {
+      return configureSocket((SSLSocket) delegate.createSocket(host, port));
+    }
+
+    @Override public Socket createSocket(
+        InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
+      return configureSocket((SSLSocket) delegate.createSocket(
+          address, port, localAddress, localPort));
+    }
+
+    protected SSLSocket configureSocket(SSLSocket socket) throws IOException {
+      return socket;
+    }
+  }
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://publicobject.com/helloworld.txt")
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+      System.out.println(response.handshake().cipherSuite());
+      System.out.println(response.body().string());
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new CustomCipherSuites().run();
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CustomTrust.java b/samples/guide/src/main/java/okhttp3/recipes/CustomTrust.java
new file mode 100644
index 0000000000..a8df15ba32
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/CustomTrust.java
@@ -0,0 +1,221 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.security.GeneralSecurityException;
+import java.security.KeyStore;
+import java.security.cert.Certificate;
+import java.security.cert.CertificateFactory;
+import java.util.Arrays;
+import java.util.Collection;
+import javax.net.ssl.KeyManagerFactory;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.CertificatePinner;
+import okhttp3.Headers;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okio.Buffer;
+
+public final class CustomTrust {
+  private final OkHttpClient client;
+
+  public CustomTrust() {
+    X509TrustManager trustManager;
+    SSLSocketFactory sslSocketFactory;
+    try {
+      trustManager = trustManagerForCertificates(trustedCertificatesInputStream());
+      SSLContext sslContext = SSLContext.getInstance("TLS");
+      sslContext.init(null, new TrustManager[] { trustManager }, null);
+      sslSocketFactory = sslContext.getSocketFactory();
+    } catch (GeneralSecurityException e) {
+      throw new RuntimeException(e);
+    }
+
+    client = new OkHttpClient.Builder()
+        .sslSocketFactory(sslSocketFactory, trustManager)
+        .build();
+  }
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://publicobject.com/helloworld.txt")
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+      Headers responseHeaders = response.headers();
+      for (int i = 0; i < responseHeaders.size(); i++) {
+        System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i));
+      }
+
+      System.out.println(response.body().string());
+    }
+  }
+
+  /**
+   * Returns an input stream containing one or more certificate PEM files. This implementation just
+   * embeds the PEM files in Java strings; most applications will instead read this from a resource
+   * file that gets bundled with the application.
+   */
+  private InputStream trustedCertificatesInputStream() {
+    // PEM files for root certificates of Comodo and Entrust. These two CAs are sufficient to view
+    // https://publicobject.com (Comodo) and https://squareup.com (Entrust). But they aren't
+    // sufficient to connect to most HTTPS sites including https://godaddy.com and https://visa.com.
+    // Typically developers will need to get a PEM file from their organization's TLS administrator.
+    String comodoRsaCertificationAuthority = ""
+        + "-----BEGIN CERTIFICATE-----\n"
+        + "MIIF2DCCA8CgAwIBAgIQTKr5yttjb+Af907YWwOGnTANBgkqhkiG9w0BAQwFADCB\n"
+        + "hTELMAkGA1UEBhMCR0IxGzAZBgNVBAgTEkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4G\n"
+        + "A1UEBxMHU2FsZm9yZDEaMBgGA1UEChMRQ09NT0RPIENBIExpbWl0ZWQxKzApBgNV\n"
+        + "BAMTIkNPTU9ETyBSU0EgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMTAwMTE5\n"
+        + "MDAwMDAwWhcNMzgwMTE4MjM1OTU5WjCBhTELMAkGA1UEBhMCR0IxGzAZBgNVBAgT\n"
+        + "EkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4GA1UEBxMHU2FsZm9yZDEaMBgGA1UEChMR\n"
+        + "Q09NT0RPIENBIExpbWl0ZWQxKzApBgNVBAMTIkNPTU9ETyBSU0EgQ2VydGlmaWNh\n"
+        + "dGlvbiBBdXRob3JpdHkwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCR\n"
+        + "6FSS0gpWsawNJN3Fz0RndJkrN6N9I3AAcbxT38T6KhKPS38QVr2fcHK3YX/JSw8X\n"
+        + "pz3jsARh7v8Rl8f0hj4K+j5c+ZPmNHrZFGvnnLOFoIJ6dq9xkNfs/Q36nGz637CC\n"
+        + "9BR++b7Epi9Pf5l/tfxnQ3K9DADWietrLNPtj5gcFKt+5eNu/Nio5JIk2kNrYrhV\n"
+        + "/erBvGy2i/MOjZrkm2xpmfh4SDBF1a3hDTxFYPwyllEnvGfDyi62a+pGx8cgoLEf\n"
+        + "Zd5ICLqkTqnyg0Y3hOvozIFIQ2dOciqbXL1MGyiKXCJ7tKuY2e7gUYPDCUZObT6Z\n"
+        + "+pUX2nwzV0E8jVHtC7ZcryxjGt9XyD+86V3Em69FmeKjWiS0uqlWPc9vqv9JWL7w\n"
+        + "qP/0uK3pN/u6uPQLOvnoQ0IeidiEyxPx2bvhiWC4jChWrBQdnArncevPDt09qZah\n"
+        + "SL0896+1DSJMwBGB7FY79tOi4lu3sgQiUpWAk2nojkxl8ZEDLXB0AuqLZxUpaVIC\n"
+        + "u9ffUGpVRr+goyhhf3DQw6KqLCGqR84onAZFdr+CGCe01a60y1Dma/RMhnEw6abf\n"
+        + "Fobg2P9A3fvQQoh/ozM6LlweQRGBY84YcWsr7KaKtzFcOmpH4MN5WdYgGq/yapiq\n"
+        + "crxXStJLnbsQ/LBMQeXtHT1eKJ2czL+zUdqnR+WEUwIDAQABo0IwQDAdBgNVHQ4E\n"
+        + "FgQUu69+Aj36pvE8hI6t7jiY7NkyMtQwDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB\n"
+        + "/wQFMAMBAf8wDQYJKoZIhvcNAQEMBQADggIBAArx1UaEt65Ru2yyTUEUAJNMnMvl\n"
+        + "wFTPoCWOAvn9sKIN9SCYPBMtrFaisNZ+EZLpLrqeLppysb0ZRGxhNaKatBYSaVqM\n"
+        + "4dc+pBroLwP0rmEdEBsqpIt6xf4FpuHA1sj+nq6PK7o9mfjYcwlYRm6mnPTXJ9OV\n"
+        + "2jeDchzTc+CiR5kDOF3VSXkAKRzH7JsgHAckaVd4sjn8OoSgtZx8jb8uk2Intzna\n"
+        + "FxiuvTwJaP+EmzzV1gsD41eeFPfR60/IvYcjt7ZJQ3mFXLrrkguhxuhoqEwWsRqZ\n"
+        + "CuhTLJK7oQkYdQxlqHvLI7cawiiFwxv/0Cti76R7CZGYZ4wUAc1oBmpjIXUDgIiK\n"
+        + "boHGhfKppC3n9KUkEEeDys30jXlYsQab5xoq2Z0B15R97QNKyvDb6KkBPvVWmcke\n"
+        + "jkk9u+UJueBPSZI9FoJAzMxZxuY67RIuaTxslbH9qh17f4a+Hg4yRvv7E491f0yL\n"
+        + "S0Zj/gA0QHDBw7mh3aZw4gSzQbzpgJHqZJx64SIDqZxubw5lT2yHh17zbqD5daWb\n"
+        + "QOhTsiedSrnAdyGN/4fy3ryM7xfft0kL0fJuMAsaDk527RH89elWsn2/x20Kk4yl\n"
+        + "0MC2Hb46TpSi125sC8KKfPog88Tk5c0NqMuRkrF8hey1FGlmDoLnzc7ILaZRfyHB\n"
+        + "NVOFBkpdn627G190\n"
+        + "-----END CERTIFICATE-----\n";
+    String entrustRootCertificateAuthority = ""
+        + "-----BEGIN CERTIFICATE-----\n"
+        + "MIIEkTCCA3mgAwIBAgIERWtQVDANBgkqhkiG9w0BAQUFADCBsDELMAkGA1UEBhMC\n"
+        + "VVMxFjAUBgNVBAoTDUVudHJ1c3QsIEluYy4xOTA3BgNVBAsTMHd3dy5lbnRydXN0\n"
+        + "Lm5ldC9DUFMgaXMgaW5jb3Jwb3JhdGVkIGJ5IHJlZmVyZW5jZTEfMB0GA1UECxMW\n"
+        + "KGMpIDIwMDYgRW50cnVzdCwgSW5jLjEtMCsGA1UEAxMkRW50cnVzdCBSb290IENl\n"
+        + "cnRpZmljYXRpb24gQXV0aG9yaXR5MB4XDTA2MTEyNzIwMjM0MloXDTI2MTEyNzIw\n"
+        + "NTM0MlowgbAxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1FbnRydXN0LCBJbmMuMTkw\n"
+        + "NwYDVQQLEzB3d3cuZW50cnVzdC5uZXQvQ1BTIGlzIGluY29ycG9yYXRlZCBieSBy\n"
+        + "ZWZlcmVuY2UxHzAdBgNVBAsTFihjKSAyMDA2IEVudHJ1c3QsIEluYy4xLTArBgNV\n"
+        + "BAMTJEVudHJ1c3QgUm9vdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTCCASIwDQYJ\n"
+        + "KoZIhvcNAQEBBQADggEPADCCAQoCggEBALaVtkNC+sZtKm9I35RMOVcF7sN5EUFo\n"
+        + "Nu3s/poBj6E4KPz3EEZmLk0eGrEaTsbRwJWIsMn/MYszA9u3g3s+IIRe7bJWKKf4\n"
+        + "4LlAcTfFy0cOlypowCKVYhXbR9n10Cv/gkvJrT7eTNuQgFA/CYqEAOwwCj0Yzfv9\n"
+        + "KlmaI5UXLEWeH25DeW0MXJj+SKfFI0dcXv1u5x609mhF0YaDW6KKjbHjKYD+JXGI\n"
+        + "rb68j6xSlkuqUY3kEzEZ6E5Nn9uss2rVvDlUccp6en+Q3X0dgNmBu1kmwhH+5pPi\n"
+        + "94DkZfs0Nw4pgHBNrziGLp5/V6+eF67rHMsoIV+2HNjnogQi+dPa2MsCAwEAAaOB\n"
+        + "sDCBrTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zArBgNVHRAEJDAi\n"
+        + "gA8yMDA2MTEyNzIwMjM0MlqBDzIwMjYxMTI3MjA1MzQyWjAfBgNVHSMEGDAWgBRo\n"
+        + "kORnpKZTgMeGZqTx90tD+4S9bTAdBgNVHQ4EFgQUaJDkZ6SmU4DHhmak8fdLQ/uE\n"
+        + "vW0wHQYJKoZIhvZ9B0EABBAwDhsIVjcuMTo0LjADAgSQMA0GCSqGSIb3DQEBBQUA\n"
+        + "A4IBAQCT1DCw1wMgKtD5Y+iRDAUgqV8ZyntyTtSx29CW+1RaGSwMCPeyvIWonX9t\n"
+        + "O1KzKtvn1ISMY/YPyyYBkVBs9F8U4pN0wBOeMDpQ47RgxRzwIkSNcUesyBrJ6Zua\n"
+        + "AGAT/3B+XxFNSRuzFVJ7yVTav52Vr2ua2J7p8eRDjeIRRDq/r72DQnNSi6q7pynP\n"
+        + "9WQcCk3RvKqsnyrQ/39/2n3qse0wJcGE2jTSW3iDVuycNsMm4hH2Z0kdkquM++v/\n"
+        + "eu6FSqdQgPCnXEqULl8FmTxSQeDNtGPPAUO6nIPcj2A781q0tHuu2guQOHXvgR1m\n"
+        + "0vdXcDazv/wor3ElhVsT/h5/WrQ8\n"
+        + "-----END CERTIFICATE-----\n";
+    return new Buffer()
+        .writeUtf8(comodoRsaCertificationAuthority)
+        .writeUtf8(entrustRootCertificateAuthority)
+        .inputStream();
+  }
+
+  /**
+   * Returns a trust manager that trusts {@code certificates} and none other. HTTPS services whose
+   * certificates have not been signed by these certificates will fail with a {@code
+   * SSLHandshakeException}.
+   *
+   * <p>This can be used to replace the host platform's built-in trusted certificates with a custom
+   * set. This is useful in development where certificate authority-trusted certificates aren't
+   * available. Or in production, to avoid reliance on third-party certificate authorities.
+   *
+   * <p>See also {@link CertificatePinner}, which can limit trusted certificates while still using
+   * the host platform's built-in trust store.
+   *
+   * <h3>Warning: Customizing Trusted Certificates is Dangerous!</h3>
+   *
+   * <p>Relying on your own trusted certificates limits your server team's ability to update their
+   * TLS certificates. By installing a specific set of trusted certificates, you take on additional
+   * operational complexity and limit your ability to migrate between certificate authorities. Do
+   * not use custom trusted certificates in production without the blessing of your server's TLS
+   * administrator.
+   */
+  private X509TrustManager trustManagerForCertificates(InputStream in)
+      throws GeneralSecurityException {
+    CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
+    Collection<? extends Certificate> certificates = certificateFactory.generateCertificates(in);
+    if (certificates.isEmpty()) {
+      throw new IllegalArgumentException("expected non-empty set of trusted certificates");
+    }
+
+    // Put the certificates a key store.
+    char[] password = "password".toCharArray(); // Any password will work.
+    KeyStore keyStore = newEmptyKeyStore(password);
+    int index = 0;
+    for (Certificate certificate : certificates) {
+      String certificateAlias = Integer.toString(index++);
+      keyStore.setCertificateEntry(certificateAlias, certificate);
+    }
+
+    // Use it to build an X509 trust manager.
+    KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(
+        KeyManagerFactory.getDefaultAlgorithm());
+    keyManagerFactory.init(keyStore, password);
+    TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+        TrustManagerFactory.getDefaultAlgorithm());
+    trustManagerFactory.init(keyStore);
+    TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
+    if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
+      throw new IllegalStateException("Unexpected default trust managers:"
+          + Arrays.toString(trustManagers));
+    }
+    return (X509TrustManager) trustManagers[0];
+  }
+
+  private KeyStore newEmptyKeyStore(char[] password) throws GeneralSecurityException {
+    try {
+      KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
+      InputStream in = null; // By convention, 'null' creates an empty key store.
+      keyStore.load(in, password);
+      return keyStore;
+    } catch (IOException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new CustomTrust().run();
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/LoggingInterceptors.java b/samples/guide/src/main/java/okhttp3/recipes/LoggingInterceptors.java
new file mode 100644
index 0000000000..8cb72b4bc8
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/LoggingInterceptors.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.IOException;
+import java.util.logging.Logger;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+
+public final class LoggingInterceptors {
+  private static final Logger logger = Logger.getLogger(LoggingInterceptors.class.getName());
+  private final OkHttpClient client = new OkHttpClient.Builder()
+      .addInterceptor(new LoggingInterceptor())
+      .build();
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://publicobject.com/helloworld.txt")
+        .build();
+
+    Response response = client.newCall(request).execute();
+    response.body().close();
+  }
+
+  private static class LoggingInterceptor implements Interceptor {
+    @Override public Response intercept(Chain chain) throws IOException {
+      long t1 = System.nanoTime();
+      Request request = chain.request();
+      logger.info(String.format("Sending request %s on %s%n%s",
+          request.url(), chain.connection(), request.headers()));
+      Response response = chain.proceed(request);
+
+      long t2 = System.nanoTime();
+      logger.info(String.format("Received response for %s in %.1fms%n%s",
+          request.url(), (t2 - t1) / 1e6d, response.headers()));
+      return response;
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new LoggingInterceptors().run();
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/ParseResponseWithMoshi.java b/samples/guide/src/main/java/okhttp3/recipes/ParseResponseWithMoshi.java
new file mode 100644
index 0000000000..68570bf13f
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/ParseResponseWithMoshi.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import com.squareup.moshi.JsonAdapter;
+import com.squareup.moshi.Moshi;
+import java.io.IOException;
+import java.util.Map;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+
+public final class ParseResponseWithMoshi {
+  private final OkHttpClient client = new OkHttpClient();
+  private final Moshi moshi = new Moshi.Builder().build();
+  private final JsonAdapter<Gist> gistJsonAdapter = moshi.adapter(Gist.class);
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://api.github.com/gists/c2a7c39532239ff261be")
+        .build();
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+      Gist gist = gistJsonAdapter.fromJson(response.body().source());
+
+      for (Map.Entry<String, GistFile> entry : gist.files.entrySet()) {
+        System.out.println(entry.getKey());
+        System.out.println(entry.getValue().content);
+      }
+    }
+  }
+
+  static class Gist {
+    Map<String, GistFile> files;
+  }
+
+  static class GistFile {
+    String content;
+  }
+
+  public static void main(String... args) throws Exception {
+    new ParseResponseWithMoshi().run();
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PerCallSettings.java b/samples/guide/src/main/java/okhttp3/recipes/PerCallSettings.java
new file mode 100644
index 0000000000..6aa266c11d
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/PerCallSettings.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.IOException;
+import java.util.concurrent.TimeUnit;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+
+public final class PerCallSettings {
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("http://httpbin.org/delay/1") // This URL is served with a 1 second delay.
+        .build();
+
+    // Copy to customize OkHttp for this request.
+    OkHttpClient client1 = client.newBuilder()
+        .readTimeout(500, TimeUnit.MILLISECONDS)
+        .build();
+    try (Response response = client1.newCall(request).execute()) {
+      System.out.println("Response 1 succeeded: " + response);
+    } catch (IOException e) {
+      System.out.println("Response 1 failed: " + e);
+    }
+
+    // Copy to customize OkHttp for this request.
+    OkHttpClient client2 = client.newBuilder()
+        .readTimeout(3000, TimeUnit.MILLISECONDS)
+        .build();
+    try (Response response = client2.newCall(request).execute()) {
+      System.out.println("Response 2 succeeded: " + response);
+    } catch (IOException e) {
+      System.out.println("Response 2 failed: " + e);
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new PerCallSettings().run();
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostFile.java b/samples/guide/src/main/java/okhttp3/recipes/PostFile.java
new file mode 100644
index 0000000000..b216b24b3b
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostFile.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.File;
+import java.io.IOException;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+
+public final class PostFile {
+  public static final MediaType MEDIA_TYPE_MARKDOWN
+      = MediaType.parse("text/x-markdown; charset=utf-8");
+
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    File file = new File("README.md");
+
+    Request request = new Request.Builder()
+        .url("https://api.github.com/markdown/raw")
+        .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file))
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+      System.out.println(response.body().string());
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new PostFile().run();
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostForm.java b/samples/guide/src/main/java/okhttp3/recipes/PostForm.java
new file mode 100644
index 0000000000..eab32b01ab
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostForm.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.IOException;
+import okhttp3.FormBody;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+
+public final class PostForm {
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    RequestBody formBody = new FormBody.Builder()
+        .add("search", "Jurassic Park")
+        .build();
+    Request request = new Request.Builder()
+        .url("https://en.wikipedia.org/w/index.php")
+        .post(formBody)
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+      System.out.println(response.body().string());
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new PostForm().run();
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java b/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java
new file mode 100644
index 0000000000..3e93a00e82
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.File;
+import java.io.IOException;
+import okhttp3.MediaType;
+import okhttp3.MultipartBody;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+
+public final class PostMultipart {
+  /**
+   * The imgur client ID for OkHttp recipes. If you're using imgur for anything other than running
+   * these examples, please request your own client ID! https://api.imgur.com/oauth2
+   */
+  private static final String IMGUR_CLIENT_ID = "9199fdef135c122";
+  private static final MediaType MEDIA_TYPE_PNG = MediaType.parse("image/png");
+
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    // Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image
+    RequestBody requestBody = new MultipartBody.Builder()
+        .setType(MultipartBody.FORM)
+        .addFormDataPart("title", "Square Logo")
+        .addFormDataPart("image", "logo-square.png",
+            RequestBody.create(MEDIA_TYPE_PNG, new File("website/static/logo-square.png")))
+        .build();
+
+    Request request = new Request.Builder()
+        .header("Authorization", "Client-ID " + IMGUR_CLIENT_ID)
+        .url("https://api.imgur.com/3/image")
+        .post(requestBody)
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+      System.out.println(response.body().string());
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new PostMultipart().run();
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java b/samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java
new file mode 100644
index 0000000000..440c7768ea
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.IOException;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okio.BufferedSink;
+
+public final class PostStreaming {
+  public static final MediaType MEDIA_TYPE_MARKDOWN
+      = MediaType.parse("text/x-markdown; charset=utf-8");
+
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    RequestBody requestBody = new RequestBody() {
+      @Override public MediaType contentType() {
+        return MEDIA_TYPE_MARKDOWN;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.writeUtf8("Numbers\n");
+        sink.writeUtf8("-------\n");
+        for (int i = 2; i <= 997; i++) {
+          sink.writeUtf8(String.format(" * %s = %s\n", i, factor(i)));
+        }
+      }
+
+      private String factor(int n) {
+        for (int i = 2; i < n; i++) {
+          int x = n / i;
+          if (x * i == n) return factor(x) + " × " + i;
+        }
+        return Integer.toString(n);
+      }
+    };
+
+    Request request = new Request.Builder()
+        .url("https://api.github.com/markdown/raw")
+        .post(requestBody)
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+      System.out.println(response.body().string());
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new PostStreaming().run();
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostStreamingWithPipe.java b/samples/guide/src/main/java/okhttp3/recipes/PostStreamingWithPipe.java
new file mode 100644
index 0000000000..b313ce0d1a
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostStreamingWithPipe.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.IOException;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okio.BufferedSink;
+import okio.Okio;
+import okio.Pipe;
+
+public final class PostStreamingWithPipe {
+  public static final MediaType MEDIA_TYPE_MARKDOWN
+      = MediaType.parse("text/x-markdown; charset=utf-8");
+
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    final PipeBody pipeBody = new PipeBody();
+
+    Request request = new Request.Builder()
+        .url("https://api.github.com/markdown/raw")
+        .post(pipeBody)
+        .build();
+
+    streamPrimesToSinkAsynchronously(pipeBody.sink());
+
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+      System.out.println(response.body().string());
+    }
+  }
+
+  private void streamPrimesToSinkAsynchronously(final BufferedSink sink) {
+    Thread thread = new Thread("writer") {
+      @Override public void run() {
+        try {
+          sink.writeUtf8("Numbers\n");
+          sink.writeUtf8("-------\n");
+          for (int i = 2; i <= 997; i++) {
+            System.out.println(i);
+            Thread.sleep(10);
+            sink.writeUtf8(String.format(" * %s = %s\n", i, factor(i)));
+          }
+          sink.close();
+        } catch (IOException | InterruptedException e) {
+          e.printStackTrace();
+        }
+      }
+
+      private String factor(int n) {
+        for (int i = 2; i < n; i++) {
+          int x = n / i;
+          if (x * i == n) return factor(x) + " × " + i;
+        }
+        return Integer.toString(n);
+      }
+    };
+
+    thread.start();
+  }
+
+  /**
+   * This request body makes it possible for another thread to stream data to the uploading request.
+   * This is potentially useful for posting live event streams like video capture. Callers should
+   * write to {@code sink()} and close it to complete the post.
+   */
+  static final class PipeBody extends RequestBody {
+    private final Pipe pipe = new Pipe(8192);
+    private final BufferedSink sink = Okio.buffer(pipe.sink());
+
+    public BufferedSink sink() {
+      return sink;
+    }
+
+    @Override public MediaType contentType() {
+      return MEDIA_TYPE_MARKDOWN;
+    }
+
+    @Override public void writeTo(BufferedSink sink) throws IOException {
+      sink.writeAll(pipe.source());
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new PostStreamingWithPipe().run();
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostString.java b/samples/guide/src/main/java/okhttp3/recipes/PostString.java
new file mode 100644
index 0000000000..8a312bde8a
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostString.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.IOException;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+
+public final class PostString {
+  public static final MediaType MEDIA_TYPE_MARKDOWN
+      = MediaType.parse("text/x-markdown; charset=utf-8");
+
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    String postBody = ""
+        + "Releases\n"
+        + "--------\n"
+        + "\n"
+        + " * _1.0_ May 6, 2013\n"
+        + " * _1.1_ June 15, 2013\n"
+        + " * _1.2_ August 11, 2013\n";
+
+    Request request = new Request.Builder()
+        .url("https://api.github.com/markdown/raw")
+        .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody))
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+      System.out.println(response.body().string());
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new PostString().run();
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PrintEvents.java b/samples/guide/src/main/java/okhttp3/recipes/PrintEvents.java
new file mode 100644
index 0000000000..1366a82f15
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/PrintEvents.java
@@ -0,0 +1,183 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicLong;
+import okhttp3.Call;
+import okhttp3.Callback;
+import okhttp3.Connection;
+import okhttp3.EventListener;
+import okhttp3.Handshake;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+
+public final class PrintEvents {
+  private final OkHttpClient client = new OkHttpClient.Builder()
+      .eventListenerFactory(PrintingEventListener.FACTORY)
+      .build();
+
+  public void run() throws Exception {
+    Request washingtonPostRequest = new Request.Builder()
+        .url("https://www.washingtonpost.com/")
+        .build();
+    client.newCall(washingtonPostRequest).enqueue(new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        try (ResponseBody body = response.body()) {
+          // Consume and discard the response body.
+          body.source().readByteString();
+        }
+      }
+    });
+
+    Request newYorkTimesRequest = new Request.Builder()
+        .url("https://www.nytimes.com/")
+        .build();
+    client.newCall(newYorkTimesRequest).enqueue(new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        try (ResponseBody body = response.body()) {
+          // Consume and discard the response body.
+          body.source().readByteString();
+        }
+      }
+    });
+  }
+
+  public static void main(String... args) throws Exception {
+    new PrintEvents().run();
+  }
+
+  private static final class PrintingEventListener extends EventListener {
+    private static final Factory FACTORY = new Factory() {
+      final AtomicLong nextCallId = new AtomicLong(1L);
+
+      @Override public EventListener create(Call call) {
+        long callId = nextCallId.getAndIncrement();
+        System.out.printf("%04d %s%n", callId, call.request().url());
+        return new PrintingEventListener(callId, System.nanoTime());
+      }
+    };
+
+    final long callId;
+    final long callStartNanos;
+
+    PrintingEventListener(long callId, long callStartNanos) {
+      this.callId = callId;
+      this.callStartNanos = callStartNanos;
+    }
+
+    private void printEvent(String name) {
+      long elapsedNanos = System.nanoTime() - callStartNanos;
+      System.out.printf("%04d %.3f %s%n", callId, elapsedNanos / 1000000000d, name);
+    }
+
+    @Override public void callStart(Call call) {
+      printEvent("callStart");
+    }
+
+    @Override public void dnsStart(Call call, String domainName) {
+      printEvent("dnsStart");
+    }
+
+    @Override public void dnsEnd(Call call, String domainName, List<InetAddress> inetAddressList) {
+      printEvent("dnsEnd");
+    }
+
+    @Override public void connectStart(
+        Call call, InetSocketAddress inetSocketAddress, Proxy proxy) {
+      printEvent("connectStart");
+    }
+
+    @Override public void secureConnectStart(Call call) {
+      printEvent("secureConnectStart");
+    }
+
+    @Override public void secureConnectEnd(Call call, Handshake handshake) {
+      printEvent("secureConnectEnd");
+    }
+
+    @Override public void connectEnd(
+        Call call, InetSocketAddress inetSocketAddress, Proxy proxy, Protocol protocol) {
+      printEvent("connectEnd");
+    }
+
+    @Override public void connectFailed(Call call, InetSocketAddress inetSocketAddress, Proxy proxy,
+        Protocol protocol, IOException ioe) {
+      printEvent("connectFailed");
+    }
+
+    @Override public void connectionAcquired(Call call, Connection connection) {
+      printEvent("connectionAcquired");
+    }
+
+    @Override public void connectionReleased(Call call, Connection connection) {
+      printEvent("connectionReleased");
+    }
+
+    @Override public void requestHeadersStart(Call call) {
+      printEvent("requestHeadersStart");
+    }
+
+    @Override public void requestHeadersEnd(Call call, Request request) {
+      printEvent("requestHeadersEnd");
+    }
+
+    @Override public void requestBodyStart(Call call) {
+      printEvent("requestBodyStart");
+    }
+
+    @Override public void requestBodyEnd(Call call, long byteCount) {
+      printEvent("requestBodyEnd");
+    }
+
+    @Override public void responseHeadersStart(Call call) {
+      printEvent("responseHeadersStart");
+    }
+
+    @Override public void responseHeadersEnd(Call call, Response response) {
+      printEvent("responseHeadersEnd");
+    }
+
+    @Override public void responseBodyStart(Call call) {
+      printEvent("responseBodyStart");
+    }
+
+    @Override public void responseBodyEnd(Call call, long byteCount) {
+      printEvent("responseBodyEnd");
+    }
+
+    @Override public void callEnd(Call call) {
+      printEvent("callEnd");
+    }
+
+    @Override public void callFailed(Call call, IOException ioe) {
+      printEvent("callFailed");
+    }
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PrintEventsNonConcurrent.java b/samples/guide/src/main/java/okhttp3/recipes/PrintEventsNonConcurrent.java
new file mode 100644
index 0000000000..6acedb19e7
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/PrintEventsNonConcurrent.java
@@ -0,0 +1,158 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.util.List;
+import okhttp3.Call;
+import okhttp3.Connection;
+import okhttp3.EventListener;
+import okhttp3.Handshake;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+
+/**
+ * This prints events for a single in-flight call. It won't work for multiple concurrent calls
+ * because we don't know what callStartNanos refers to.
+ */
+public final class PrintEventsNonConcurrent {
+  private final OkHttpClient client = new OkHttpClient.Builder()
+      .eventListener(new PrintingEventListener())
+      .build();
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://publicobject.com/helloworld.txt")
+        .build();
+
+    System.out.println("REQUEST 1 (new connection)");
+    try (Response response = client.newCall(request).execute()) {
+      // Consume and discard the response body.
+      response.body().source().readByteString();
+    }
+
+    System.out.println("REQUEST 2 (pooled connection)");
+    try (Response response = client.newCall(request).execute()) {
+      // Consume and discard the response body.
+      response.body().source().readByteString();
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new PrintEventsNonConcurrent().run();
+  }
+
+  private static final class PrintingEventListener extends EventListener {
+    long callStartNanos;
+
+    private void printEvent(String name) {
+      long nowNanos = System.nanoTime();
+      if (name.equals("callStart")) {
+        callStartNanos = nowNanos;
+      }
+      long elapsedNanos = nowNanos - callStartNanos;
+      System.out.printf("%.3f %s%n", elapsedNanos / 1000000000d, name);
+    }
+
+    @Override public void callStart(Call call) {
+      printEvent("callStart");
+    }
+
+    @Override public void dnsStart(Call call, String domainName) {
+      printEvent("dnsStart");
+    }
+
+    @Override public void dnsEnd(Call call, String domainName, List<InetAddress> inetAddressList) {
+      printEvent("dnsEnd");
+    }
+
+    @Override public void connectStart(
+        Call call, InetSocketAddress inetSocketAddress, Proxy proxy) {
+      printEvent("connectStart");
+    }
+
+    @Override public void secureConnectStart(Call call) {
+      printEvent("secureConnectStart");
+    }
+
+    @Override public void secureConnectEnd(Call call, Handshake handshake) {
+      printEvent("secureConnectEnd");
+    }
+
+    @Override public void connectEnd(
+        Call call, InetSocketAddress inetSocketAddress, Proxy proxy, Protocol protocol) {
+      printEvent("connectEnd");
+    }
+
+    @Override public void connectFailed(Call call, InetSocketAddress inetSocketAddress, Proxy proxy,
+        Protocol protocol, IOException ioe) {
+      printEvent("connectFailed");
+    }
+
+    @Override public void connectionAcquired(Call call, Connection connection) {
+      printEvent("connectionAcquired");
+    }
+
+    @Override public void connectionReleased(Call call, Connection connection) {
+      printEvent("connectionReleased");
+    }
+
+    @Override public void requestHeadersStart(Call call) {
+      printEvent("requestHeadersStart");
+    }
+
+    @Override public void requestHeadersEnd(Call call, Request request) {
+      printEvent("requestHeadersEnd");
+    }
+
+    @Override public void requestBodyStart(Call call) {
+      printEvent("requestBodyStart");
+    }
+
+    @Override public void requestBodyEnd(Call call, long byteCount) {
+      printEvent("requestBodyEnd");
+    }
+
+    @Override public void responseHeadersStart(Call call) {
+      printEvent("responseHeadersStart");
+    }
+
+    @Override public void responseHeadersEnd(Call call, Response response) {
+      printEvent("responseHeadersEnd");
+    }
+
+    @Override public void responseBodyStart(Call call) {
+      printEvent("responseBodyStart");
+    }
+
+    @Override public void responseBodyEnd(Call call, long byteCount) {
+      printEvent("responseBodyEnd");
+    }
+
+    @Override public void callEnd(Call call) {
+      printEvent("callEnd");
+    }
+
+    @Override public void callFailed(Call call, IOException ioe) {
+      printEvent("callFailed");
+    }
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/Progress.java b/samples/guide/src/main/java/okhttp3/recipes/Progress.java
new file mode 100644
index 0000000000..30566908a1
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/Progress.java
@@ -0,0 +1,113 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.IOException;
+import okhttp3.Interceptor;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ForwardingSource;
+import okio.Okio;
+import okio.Source;
+
+public final class Progress {
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://publicobject.com/helloworld.txt")
+        .build();
+
+    final ProgressListener progressListener = new ProgressListener() {
+      @Override public void update(long bytesRead, long contentLength, boolean done) {
+        System.out.println(bytesRead);
+        System.out.println(contentLength);
+        System.out.println(done);
+        System.out.format("%d%% done\n", (100 * bytesRead) / contentLength);
+      }
+    };
+
+    OkHttpClient client = new OkHttpClient.Builder()
+        .addNetworkInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            Response originalResponse = chain.proceed(chain.request());
+            return originalResponse.newBuilder()
+                .body(new ProgressResponseBody(originalResponse.body(), progressListener))
+                .build();
+          }
+        })
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+      System.out.println(response.body().string());
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new Progress().run();
+  }
+
+  private static class ProgressResponseBody extends ResponseBody {
+
+    private final ResponseBody responseBody;
+    private final ProgressListener progressListener;
+    private BufferedSource bufferedSource;
+
+    ProgressResponseBody(ResponseBody responseBody, ProgressListener progressListener) {
+      this.responseBody = responseBody;
+      this.progressListener = progressListener;
+    }
+
+    @Override public MediaType contentType() {
+      return responseBody.contentType();
+    }
+
+    @Override public long contentLength() {
+      return responseBody.contentLength();
+    }
+
+    @Override public BufferedSource source() {
+      if (bufferedSource == null) {
+        bufferedSource = Okio.buffer(source(responseBody.source()));
+      }
+      return bufferedSource;
+    }
+
+    private Source source(Source source) {
+      return new ForwardingSource(source) {
+        long totalBytesRead = 0L;
+
+        @Override public long read(Buffer sink, long byteCount) throws IOException {
+          long bytesRead = super.read(sink, byteCount);
+          // read() returns the number of bytes read, or -1 if this source is exhausted.
+          totalBytesRead += bytesRead != -1 ? bytesRead : 0;
+          progressListener.update(totalBytesRead, responseBody.contentLength(), bytesRead == -1);
+          return bytesRead;
+        }
+      };
+    }
+  }
+
+  interface ProgressListener {
+    void update(long bytesRead, long contentLength, boolean done);
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/RequestBodyCompression.java b/samples/guide/src/main/java/okhttp3/recipes/RequestBodyCompression.java
new file mode 100644
index 0000000000..b1a62c0fa3
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/RequestBodyCompression.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import com.squareup.moshi.JsonAdapter;
+import com.squareup.moshi.Moshi;
+import com.squareup.moshi.Types;
+import java.io.IOException;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import okhttp3.Interceptor;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okio.BufferedSink;
+import okio.GzipSink;
+import okio.Okio;
+
+public final class RequestBodyCompression {
+  /**
+   * The Google API KEY for OkHttp recipes. If you're using Google APIs for anything other than
+   * running these examples, please request your own client ID!
+   *
+   * https://console.developers.google.com/project
+   */
+  public static final String GOOGLE_API_KEY = "AIzaSyAx2WZYe0My0i-uGurpvraYJxO7XNbwiGs";
+  public static final MediaType MEDIA_TYPE_JSON = MediaType.parse("application/json");
+
+  private final OkHttpClient client = new OkHttpClient.Builder()
+      .addInterceptor(new GzipRequestInterceptor())
+      .build();
+  private final Moshi moshi = new Moshi.Builder().build();
+  private final JsonAdapter<Map<String, String>> mapJsonAdapter = moshi.adapter(
+      Types.newParameterizedType(Map.class, String.class, String.class));
+
+  public void run() throws Exception {
+    Map<String, String> requestBody = new LinkedHashMap<>();
+    requestBody.put("longUrl", "https://publicobject.com/2014/12/04/html-formatting-javadocs/");
+    RequestBody jsonRequestBody = RequestBody.create(
+        MEDIA_TYPE_JSON, mapJsonAdapter.toJson(requestBody));
+    Request request = new Request.Builder()
+        .url("https://www.googleapis.com/urlshortener/v1/url?key=" + GOOGLE_API_KEY)
+        .post(jsonRequestBody)
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+      System.out.println(response.body().string());
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new RequestBodyCompression().run();
+  }
+
+  /** This interceptor compresses the HTTP request body. Many webservers can't handle this! */
+  static class GzipRequestInterceptor implements Interceptor {
+    @Override public Response intercept(Chain chain) throws IOException {
+      Request originalRequest = chain.request();
+      if (originalRequest.body() == null || originalRequest.header("Content-Encoding") != null) {
+        return chain.proceed(originalRequest);
+      }
+
+      Request compressedRequest = originalRequest.newBuilder()
+          .header("Content-Encoding", "gzip")
+          .method(originalRequest.method(), gzip(originalRequest.body()))
+          .build();
+      return chain.proceed(compressedRequest);
+    }
+
+    private RequestBody gzip(final RequestBody body) {
+      return new RequestBody() {
+        @Override public MediaType contentType() {
+          return body.contentType();
+        }
+
+        @Override public long contentLength() {
+          return -1; // We don't know the compressed length in advance!
+        }
+
+        @Override public void writeTo(BufferedSink sink) throws IOException {
+          BufferedSink gzipSink = Okio.buffer(new GzipSink(sink));
+          body.writeTo(gzipSink);
+          gzipSink.close();
+        }
+      };
+    }
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/RewriteResponseCacheControl.java b/samples/guide/src/main/java/okhttp3/recipes/RewriteResponseCacheControl.java
new file mode 100644
index 0000000000..92d65d8169
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/RewriteResponseCacheControl.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.File;
+import java.io.IOException;
+import okhttp3.Cache;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+
+public final class RewriteResponseCacheControl {
+  /** Dangerous interceptor that rewrites the server's cache-control header. */
+  private static final Interceptor REWRITE_CACHE_CONTROL_INTERCEPTOR = new Interceptor() {
+    @Override public Response intercept(Chain chain) throws IOException {
+      Response originalResponse = chain.proceed(chain.request());
+      return originalResponse.newBuilder()
+          .header("Cache-Control", "max-age=60")
+          .build();
+    }
+  };
+
+  private final OkHttpClient client;
+
+  public RewriteResponseCacheControl(File cacheDirectory) throws Exception {
+    Cache cache = new Cache(cacheDirectory, 1024 * 1024);
+    cache.evictAll();
+
+    client = new OkHttpClient.Builder()
+        .cache(cache)
+        .build();
+  }
+
+  public void run() throws Exception {
+    for (int i = 0; i < 5; i++) {
+      System.out.println("    Request: " + i);
+
+      Request request = new Request.Builder()
+          .url("https://api.github.com/search/repositories?q=http")
+          .build();
+
+      OkHttpClient clientForCall;
+      if (i == 2) {
+        // Force this request's response to be written to the cache. This way, subsequent responses
+        // can be read from the cache.
+        System.out.println("Force cache: true");
+        clientForCall = client.newBuilder()
+            .addNetworkInterceptor(REWRITE_CACHE_CONTROL_INTERCEPTOR)
+            .build();
+      } else {
+        System.out.println("Force cache: false");
+        clientForCall = client;
+      }
+
+      try (Response response = clientForCall.newCall(request).execute()) {
+        if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+        System.out.println("    Network: " + (response.networkResponse() != null));
+        System.out.println();
+      }
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new RewriteResponseCacheControl(new File("RewriteResponseCacheControl.tmp")).run();
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/SynchronousGet.java b/samples/guide/src/main/java/okhttp3/recipes/SynchronousGet.java
new file mode 100644
index 0000000000..38c91a50c2
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/SynchronousGet.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.IOException;
+import okhttp3.Headers;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+
+public final class SynchronousGet {
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://publicobject.com/helloworld.txt")
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+      Headers responseHeaders = response.headers();
+      for (int i = 0; i < responseHeaders.size(); i++) {
+        System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i));
+      }
+
+      System.out.println(response.body().string());
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new SynchronousGet().run();
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java b/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java
new file mode 100644
index 0000000000..288fadb7ce
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java
@@ -0,0 +1,53 @@
+package okhttp3.recipes;
+
+import java.util.concurrent.TimeUnit;
+import okhttp3.WebSocket;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.WebSocketListener;
+import okio.ByteString;
+
+public final class WebSocketEcho extends WebSocketListener {
+  private void run() {
+    OkHttpClient client = new OkHttpClient.Builder()
+        .readTimeout(0,  TimeUnit.MILLISECONDS)
+        .build();
+
+    Request request = new Request.Builder()
+        .url("ws://echo.websocket.org")
+        .build();
+    client.newWebSocket(request, this);
+
+    // Trigger shutdown of the dispatcher's executor so this process can exit cleanly.
+    client.dispatcher().executorService().shutdown();
+  }
+
+  @Override public void onOpen(WebSocket webSocket, Response response) {
+    webSocket.send("Hello...");
+    webSocket.send("...World!");
+    webSocket.send(ByteString.decodeHex("deadbeef"));
+    webSocket.close(1000, "Goodbye, World!");
+  }
+
+  @Override public void onMessage(WebSocket webSocket, String text) {
+    System.out.println("MESSAGE: " + text);
+  }
+
+  @Override public void onMessage(WebSocket webSocket, ByteString bytes) {
+    System.out.println("MESSAGE: " + bytes.hex());
+  }
+
+  @Override public void onClosing(WebSocket webSocket, int code, String reason) {
+    webSocket.close(1000, null);
+    System.out.println("CLOSE: " + code + " " + reason);
+  }
+
+  @Override public void onFailure(WebSocket webSocket, Throwable t, Response response) {
+    t.printStackTrace();
+  }
+
+  public static void main(String... args) {
+    new WebSocketEcho().run();
+  }
+}
diff --git a/samples/pom.xml b/samples/pom.xml
new file mode 100644
index 0000000000..4bb53c9d5b
--- /dev/null
+++ b/samples/pom.xml
@@ -0,0 +1,39 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp3</groupId>
+    <artifactId>parent</artifactId>
+    <version>3.10.0-SNAPSHOT</version>
+  </parent>
+
+  <groupId>com.squareup.okhttp3.sample</groupId>
+  <artifactId>sample-parent</artifactId>
+  <packaging>pom</packaging>
+  <name>Samples (Parent)</name>
+
+  <modules>
+    <module>guide</module>
+    <module>crawler</module>
+    <module>simple-client</module>
+    <module>slack</module>
+    <module>static-server</module>
+  </modules>
+
+  <build>
+    <plugins>
+      <plugin>
+        <!-- Fails on Throwable.addSuppressed() in ARM blocks. -->
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>animal-sniffer-maven-plugin</artifactId>
+        <executions>
+          <execution>
+            <phase>none</phase>
+          </execution>
+        </executions>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/samples/simple-client/pom.xml b/samples/simple-client/pom.xml
new file mode 100644
index 0000000000..347edefa27
--- /dev/null
+++ b/samples/simple-client/pom.xml
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp3.sample</groupId>
+    <artifactId>sample-parent</artifactId>
+    <version>3.10.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>simple-client</artifactId>
+  <name>Sample: Simple Client</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+
+    <dependency>
+      <groupId>com.squareup.moshi</groupId>
+      <artifactId>moshi</artifactId>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java b/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java
new file mode 100644
index 0000000000..f2ac973db2
--- /dev/null
+++ b/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java
@@ -0,0 +1,56 @@
+package okhttp3.sample;
+
+import com.squareup.moshi.JsonAdapter;
+import com.squareup.moshi.Moshi;
+import com.squareup.moshi.Types;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+
+public class OkHttpContributors {
+  private static final String ENDPOINT = "https://api.github.com/repos/square/okhttp/contributors";
+  private static final Moshi MOSHI = new Moshi.Builder().build();
+  private static final JsonAdapter<List<Contributor>> CONTRIBUTORS_JSON_ADAPTER = MOSHI.adapter(
+      Types.newParameterizedType(List.class, Contributor.class));
+
+  static class Contributor {
+    String login;
+    int contributions;
+  }
+
+  public static void main(String... args) throws Exception {
+    OkHttpClient client = new OkHttpClient();
+
+    // Create request for remote resource.
+    Request request = new Request.Builder()
+        .url(ENDPOINT)
+        .build();
+
+    // Execute the request and retrieve the response.
+    try (Response response = client.newCall(request).execute()) {
+      // Deserialize HTTP response to concrete type.
+      ResponseBody body = response.body();
+      List<Contributor> contributors = CONTRIBUTORS_JSON_ADAPTER.fromJson(body.source());
+
+      // Sort list by the most contributions.
+      Collections.sort(contributors, new Comparator<Contributor>() {
+        @Override public int compare(Contributor c1, Contributor c2) {
+          return c2.contributions - c1.contributions;
+        }
+      });
+
+      // Output list of contributors.
+      for (Contributor contributor : contributors) {
+        System.out.println(contributor.login + ": " + contributor.contributions);
+      }
+    }
+  }
+
+  private OkHttpContributors() {
+    // No instances.
+  }
+}
diff --git a/samples/slack/pom.xml b/samples/slack/pom.xml
new file mode 100644
index 0000000000..c76577e6c7
--- /dev/null
+++ b/samples/slack/pom.xml
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp3.sample</groupId>
+    <artifactId>sample-parent</artifactId>
+    <version>3.10.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>slack</artifactId>
+  <name>Sample: Slack</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.moshi</groupId>
+      <artifactId>moshi</artifactId>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/samples/slack/src/main/java/okhttp3/slack/OAuthSession.java b/samples/slack/src/main/java/okhttp3/slack/OAuthSession.java
new file mode 100644
index 0000000000..9a6869d2fb
--- /dev/null
+++ b/samples/slack/src/main/java/okhttp3/slack/OAuthSession.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.slack;
+
+/** Authorization for an application to make Slack API calls on behalf of a user. */
+@SuppressWarnings("checkstyle:membername")
+public final class OAuthSession {
+  public final boolean ok;
+  public final String access_token;
+  public final String scope;
+  public final String user_id;
+  public final String team_name;
+  public final String team_id;
+
+  public OAuthSession(
+      boolean ok, String accessToken, String scope, String userId, String teamName, String teamId) {
+    this.ok = ok;
+    this.access_token = accessToken;
+    this.scope = scope;
+    this.user_id = userId;
+    this.team_name = teamName;
+    this.team_id = teamId;
+  }
+
+  @Override public String toString() {
+    return String.format("(ok=%s, access_token=%s, scope=%s, user_id=%s, team_name=%s, team_id=%s)",
+        ok, access_token, scope, user_id, team_name, team_id);
+  }
+}
diff --git a/samples/slack/src/main/java/okhttp3/slack/OAuthSessionFactory.java b/samples/slack/src/main/java/okhttp3/slack/OAuthSessionFactory.java
new file mode 100644
index 0000000000..04ba201c96
--- /dev/null
+++ b/samples/slack/src/main/java/okhttp3/slack/OAuthSessionFactory.java
@@ -0,0 +1,126 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.slack;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.security.SecureRandom;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import okhttp3.HttpUrl;
+import okhttp3.mockwebserver.Dispatcher;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okio.ByteString;
+
+/**
+ * Runs a MockWebServer on localhost and uses it as the backend to receive an OAuth session.
+ *
+ * <p>Clients should call {@link #start}, {@link #newAuthorizeUrl} and {@link #close} in that order.
+ * Clients may request multiple sessions.
+ */
+public final class OAuthSessionFactory extends Dispatcher implements Closeable {
+  private final SecureRandom secureRandom = new SecureRandom();
+
+  private final SlackApi slackApi;
+  private MockWebServer mockWebServer;
+
+  /** Guarded by this. */
+  private Map<ByteString, Listener> listeners = new LinkedHashMap<>();
+
+  public OAuthSessionFactory(SlackApi slackApi) {
+    this.slackApi = slackApi;
+  }
+
+  public void start() throws Exception {
+    if (mockWebServer != null) throw new IllegalStateException();
+
+    mockWebServer = new MockWebServer();
+    mockWebServer.setDispatcher(this);
+    mockWebServer.start(slackApi.port);
+  }
+
+  public HttpUrl newAuthorizeUrl(String scopes, String team, Listener listener) {
+    if (mockWebServer == null) throw new IllegalStateException();
+
+    ByteString state = randomToken();
+    synchronized (this) {
+      listeners.put(state, listener);
+    }
+
+    return slackApi.authorizeUrl(scopes, redirectUrl(), state, team);
+  }
+
+  private ByteString randomToken() {
+    byte[] bytes = new byte[16];
+    secureRandom.nextBytes(bytes);
+    return ByteString.of(bytes);
+  }
+
+  private HttpUrl redirectUrl() {
+    return mockWebServer.url("/oauth/");
+  }
+
+  /** When the browser hits the redirect URL, use the provided code to ask Slack for a session. */
+  @Override public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
+    HttpUrl requestUrl = mockWebServer.url(request.getPath());
+    String code = requestUrl.queryParameter("code");
+    String stateString = requestUrl.queryParameter("state");
+    ByteString state = stateString != null ? ByteString.decodeBase64(stateString) : null;
+
+    Listener listener;
+    synchronized (this) {
+      listener = listeners.get(state);
+    }
+
+    if (code == null || listener == null) {
+      return new MockResponse()
+          .setResponseCode(404)
+          .setBody("unexpected request");
+    }
+
+    try {
+      OAuthSession session = slackApi.exchangeCode(code, redirectUrl());
+      listener.sessionGranted(session);
+    } catch (IOException e) {
+      return new MockResponse()
+          .setResponseCode(400)
+          .setBody("code exchange failed: " + e.getMessage());
+    }
+
+    synchronized (this) {
+      listeners.remove(state);
+    }
+
+    // Success!
+    return new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location", "https://twitter.com/CuteEmergency/status/789457462864863232");
+  }
+
+  public interface Listener {
+    void sessionGranted(OAuthSession session);
+  }
+
+  @Override public void close() {
+    if (mockWebServer == null) throw new IllegalStateException();
+    try {
+      mockWebServer.close();
+    } catch (IOException ignored) {
+    }
+  }
+}
diff --git a/samples/slack/src/main/java/okhttp3/slack/RtmSession.java b/samples/slack/src/main/java/okhttp3/slack/RtmSession.java
new file mode 100644
index 0000000000..b5802ef4ad
--- /dev/null
+++ b/samples/slack/src/main/java/okhttp3/slack/RtmSession.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.slack;
+
+import java.io.Closeable;
+import java.io.IOException;
+import okhttp3.WebSocket;
+import okhttp3.Response;
+import okhttp3.WebSocketListener;
+
+/** A realtime messaging session. */
+public final class RtmSession extends WebSocketListener implements Closeable {
+  private final SlackApi slackApi;
+
+  /** Guarded by this. */
+  private WebSocket webSocket;
+
+  public RtmSession(SlackApi slackApi) {
+    this.slackApi = slackApi;
+  }
+
+  public void open(String accessToken) throws IOException {
+    if (webSocket != null) throw new IllegalStateException();
+
+    RtmStartResponse rtmStartResponse = slackApi.rtmStart(accessToken);
+    webSocket = slackApi.rtm(rtmStartResponse.url, this);
+  }
+
+  // TODO(jwilson): can I read the response body? Do I have to?
+  //                the body from slack is a 0-byte-buffer
+  @Override public synchronized void onOpen(WebSocket webSocket, Response response) {
+    System.out.println("onOpen: " + response);
+  }
+
+  // TOOD(jwilson): decode incoming messages and dispatch them somewhere.
+  @Override public void onMessage(WebSocket webSocket, String text) {
+    System.out.println("onMessage: " + text);
+  }
+
+  @Override public void onClosing(WebSocket webSocket, int code, String reason) {
+    webSocket.close(1000, null);
+    System.out.println("onClose (" + code + "): " + reason);
+  }
+
+  @Override public void onFailure(WebSocket webSocket, Throwable t, Response response) {
+    // TODO(jwilson): can I read the response body? Do I have to?
+    System.out.println("onFailure " + response);
+  }
+
+  @Override public void close() throws IOException {
+    if (webSocket == null) return;
+
+    WebSocket webSocket;
+    synchronized (this) {
+      webSocket = this.webSocket;
+    }
+
+    if (webSocket != null) {
+      webSocket.close(1000, "bye");
+    }
+  }
+}
diff --git a/samples/slack/src/main/java/okhttp3/slack/RtmStartResponse.java b/samples/slack/src/main/java/okhttp3/slack/RtmStartResponse.java
new file mode 100644
index 0000000000..b19fff6256
--- /dev/null
+++ b/samples/slack/src/main/java/okhttp3/slack/RtmStartResponse.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.slack;
+
+import java.util.List;
+import okhttp3.HttpUrl;
+
+/** See https://api.slack.com/methods/rtm.start. */
+public final class RtmStartResponse {
+  HttpUrl url;
+  Object self;
+  Object team;
+  List<Object> users;
+  List<Object> channels;
+  List<Object> groups;
+  List<Object> mpims;
+  List<Object> ims;
+  List<Object> bots;
+}
diff --git a/samples/slack/src/main/java/okhttp3/slack/SlackApi.java b/samples/slack/src/main/java/okhttp3/slack/SlackApi.java
new file mode 100644
index 0000000000..0ec0ef7a45
--- /dev/null
+++ b/samples/slack/src/main/java/okhttp3/slack/SlackApi.java
@@ -0,0 +1,126 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.slack;
+
+import com.squareup.moshi.FromJson;
+import com.squareup.moshi.JsonAdapter;
+import com.squareup.moshi.Moshi;
+import com.squareup.moshi.ToJson;
+import java.io.IOException;
+import okhttp3.Call;
+import okhttp3.HttpUrl;
+import okhttp3.WebSocket;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.WebSocketListener;
+import okio.ByteString;
+
+/**
+ * API access to the <a href="https://api.slack.com/apps">Slack API</a> as an application. One
+ * instance of this class may operate without a user, or on behalf of many users. Use the Slack API
+ * dashboard to create a client ID and secret for this application.
+ *
+ * <p>You must configure your Slack API OAuth and Permissions page with a localhost URL like {@code
+ * http://localhost:53203/oauth/}, passing the same port to this class’ constructor.
+ */
+public final class SlackApi {
+  private final HttpUrl baseUrl = HttpUrl.parse("https://slack.com/api/");
+  private final OkHttpClient httpClient;
+  private final Moshi moshi;
+
+  public final String clientId;
+  public final String clientSecret;
+  public final int port;
+
+  public SlackApi(String clientId, String clientSecret, int port) {
+    this.httpClient = new OkHttpClient.Builder()
+        .build();
+    this.moshi = new Moshi.Builder()
+        .add(new SlackJsonAdapters())
+        .build();
+    this.clientId = clientId;
+    this.clientSecret = clientSecret;
+    this.port = port;
+  }
+
+  /** See https://api.slack.com/docs/oauth. */
+  public HttpUrl authorizeUrl(String scopes, HttpUrl redirectUrl, ByteString state, String team) {
+    HttpUrl.Builder builder = baseUrl.newBuilder("/oauth/authorize")
+        .addQueryParameter("client_id", clientId)
+        .addQueryParameter("scope", scopes)
+        .addQueryParameter("redirect_uri", redirectUrl.toString())
+        .addQueryParameter("state", state.base64());
+
+    if (team != null) {
+      builder.addQueryParameter("team", team);
+    }
+
+    return builder.build();
+  }
+
+  /** See https://api.slack.com/methods/oauth.access. */
+  public OAuthSession exchangeCode(String code, HttpUrl redirectUrl) throws IOException {
+    HttpUrl url = baseUrl.newBuilder("oauth.access")
+        .addQueryParameter("client_id", clientId)
+        .addQueryParameter("client_secret", clientSecret)
+        .addQueryParameter("code", code)
+        .addQueryParameter("redirect_uri", redirectUrl.toString())
+        .build();
+    Request request = new Request.Builder()
+        .url(url)
+        .build();
+    Call call = httpClient.newCall(request);
+    try (Response response = call.execute()) {
+      JsonAdapter<OAuthSession> jsonAdapter = moshi.adapter(OAuthSession.class);
+      return jsonAdapter.fromJson(response.body().source());
+    }
+  }
+
+  /** See https://api.slack.com/methods/rtm.start. */
+  public RtmStartResponse rtmStart(String accessToken) throws IOException {
+    HttpUrl url = baseUrl.newBuilder("rtm.start")
+        .addQueryParameter("token", accessToken)
+        .build();
+    Request request = new Request.Builder()
+        .url(url)
+        .build();
+    Call call = httpClient.newCall(request);
+    try (Response response = call.execute()) {
+      JsonAdapter<RtmStartResponse> jsonAdapter = moshi.adapter(RtmStartResponse.class);
+      return jsonAdapter.fromJson(response.body().source());
+    }
+  }
+
+  /** See https://api.slack.com/rtm. */
+  public WebSocket rtm(HttpUrl url, WebSocketListener listener) {
+    return httpClient.newWebSocket(new Request.Builder()
+        .url(url)
+        .build(), listener);
+  }
+
+  static final class SlackJsonAdapters {
+    @ToJson String urlToJson(HttpUrl httpUrl) {
+      return httpUrl.toString();
+    }
+
+    @FromJson HttpUrl urlFromJson(String urlString) {
+      if (urlString.startsWith("wss:")) urlString = "https:" + urlString.substring(4);
+      if (urlString.startsWith("ws:")) urlString = "http:" + urlString.substring(3);
+      return HttpUrl.parse(urlString);
+    }
+  }
+}
diff --git a/samples/slack/src/main/java/okhttp3/slack/SlackClient.java b/samples/slack/src/main/java/okhttp3/slack/SlackClient.java
new file mode 100644
index 0000000000..2aa2608986
--- /dev/null
+++ b/samples/slack/src/main/java/okhttp3/slack/SlackClient.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.slack;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import okhttp3.HttpUrl;
+import okio.Timeout;
+
+/** A connection to Slack as a single user. */
+public final class SlackClient {
+  private final SlackApi slackApi;
+  private OAuthSessionFactory sessionFactory;
+
+  /** Guarded by this. */
+  private OAuthSession session;
+
+  public SlackClient(SlackApi slackApi) {
+    this.slackApi = slackApi;
+  }
+
+  /** Shows a browser URL to authorize this app to act as this user. */
+  public void requestOauthSession(String scopes, String team) throws Exception {
+    if (sessionFactory == null) {
+      sessionFactory = new OAuthSessionFactory(slackApi);
+      sessionFactory.start();
+    }
+
+    HttpUrl authorizeUrl = sessionFactory.newAuthorizeUrl(scopes, team,
+        new OAuthSessionFactory.Listener() {
+          @Override public void sessionGranted(OAuthSession session) {
+            initOauthSession(session);
+            System.out.printf("session granted: %s\n", session);
+          }
+        });
+
+    System.out.printf("open this URL in a browser: %s\n", authorizeUrl);
+  }
+
+  /** Set the OAuth session for this client. */
+  public synchronized void initOauthSession(OAuthSession session) {
+    this.session = session;
+    this.notifyAll();
+  }
+
+  /** Waits for an OAuth session for this client to be set. */
+  public synchronized void awaitAccessToken(Timeout timeout) throws InterruptedIOException {
+    while (session == null) {
+      timeout.waitUntilNotified(this);
+    }
+  }
+
+  /** Starts a real time messaging session. */
+  public void startRtm() throws IOException {
+    String accessToken;
+    synchronized (this) {
+      accessToken = session.access_token;
+    }
+
+    RtmSession rtmSession = new RtmSession(slackApi);
+    rtmSession.open(accessToken);
+  }
+
+  public static void main(String... args) throws Exception {
+    String clientId = "0000000000.00000000000";
+    String clientSecret = "00000000000000000000000000000000";
+    int port = 53203;
+    SlackApi slackApi = new SlackApi(clientId, clientSecret, port);
+
+    SlackClient client = new SlackClient(slackApi);
+    String scopes = "channels:history channels:read channels:write chat:write:bot chat:write:user "
+        + "dnd:read dnd:write emoji:read files:read files:write:user groups:history groups:read "
+        + "groups:write im:history im:read im:write mpim:history mpim:read mpim:write pins:read "
+        + "pins:write reactions:read reactions:write search:read stars:read stars:write team:read "
+        + "usergroups:read usergroups:write users:read users:write identify";
+
+    if (true) {
+      client.requestOauthSession(scopes, null);
+    } else {
+      OAuthSession session = new OAuthSession(true,
+          "xoxp-XXXXXXXXXX-XXXXXXXXXX-XXXXXXXXXXX-XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
+          scopes, "UXXXXXXXX", "My Slack Group", "TXXXXXXXX");
+      client.initOauthSession(session);
+    }
+
+    client.awaitAccessToken(Timeout.NONE);
+    client.startRtm();
+  }
+}
diff --git a/samples/static-server/pom.xml b/samples/static-server/pom.xml
new file mode 100644
index 0000000000..30b3cb8689
--- /dev/null
+++ b/samples/static-server/pom.xml
@@ -0,0 +1,62 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp3.sample</groupId>
+    <artifactId>sample-parent</artifactId>
+    <version>3.10.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>static-server</artifactId>
+  <name>Sample: Static Server</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-shade-plugin</artifactId>
+        <version>2.1</version>
+        <configuration>
+          <shadedArtifactAttached>true</shadedArtifactAttached>
+          <shadedClassifierName>shaded</shadedClassifierName>
+          <transformers>
+            <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
+              <manifestEntries>
+                <Main-Class>okhttp3.sample.SampleServer</Main-Class>
+              </manifestEntries>
+            </transformer>
+          </transformers>
+          <filters>
+            <filter>
+              <artifact>*:*</artifact>
+              <excludes>
+                <exclude>META-INF/*.SF</exclude>
+                <exclude>META-INF/*.DSA</exclude>
+                <exclude>META-INF/*.RSA</exclude>
+              </excludes>
+            </filter>
+          </filters>
+        </configuration>
+        <executions>
+          <execution>
+            <phase>package</phase>
+            <goals>
+              <goal>shade</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/samples/static-server/src/main/java/okhttp3/sample/SampleServer.java b/samples/static-server/src/main/java/okhttp3/sample/SampleServer.java
new file mode 100644
index 0000000000..e21432ed20
--- /dev/null
+++ b/samples/static-server/src/main/java/okhttp3/sample/SampleServer.java
@@ -0,0 +1,144 @@
+package okhttp3.sample;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.security.GeneralSecurityException;
+import java.security.KeyStore;
+import java.security.SecureRandom;
+import javax.net.ssl.KeyManagerFactory;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.TrustManagerFactory;
+import okhttp3.internal.Util;
+import okhttp3.mockwebserver.Dispatcher;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okio.Buffer;
+import okio.Okio;
+
+public class SampleServer extends Dispatcher {
+  private final SSLContext sslContext;
+  private final String root;
+  private final int port;
+
+  public SampleServer(SSLContext sslContext, String root, int port) {
+    this.sslContext = sslContext;
+    this.root = root;
+    this.port = port;
+  }
+
+  public void run() throws IOException {
+    MockWebServer server = new MockWebServer();
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.setDispatcher(this);
+    server.start(port);
+  }
+
+  @Override public MockResponse dispatch(RecordedRequest request) {
+    String path = request.getPath();
+    try {
+      if (!path.startsWith("/") || path.contains("..")) throw new FileNotFoundException();
+
+      File file = new File(root + path);
+      return file.isDirectory()
+          ? directoryToResponse(path, file)
+          : fileToResponse(path, file);
+    } catch (FileNotFoundException e) {
+      return new MockResponse()
+          .setStatus("HTTP/1.1 404")
+          .addHeader("content-type: text/plain; charset=utf-8")
+          .setBody("NOT FOUND: " + path);
+    } catch (IOException e) {
+      return new MockResponse()
+          .setStatus("HTTP/1.1 500")
+          .addHeader("content-type: text/plain; charset=utf-8")
+          .setBody("SERVER ERROR: " + e);
+    }
+  }
+
+  private MockResponse directoryToResponse(String basePath, File directory) {
+    if (!basePath.endsWith("/")) basePath += "/";
+
+    StringBuilder response = new StringBuilder();
+    response.append(String.format("<html><head><title>%s</title></head><body>", basePath));
+    response.append(String.format("<h1>%s</h1>", basePath));
+    for (String file : directory.list()) {
+      response.append(String.format("<div class='file'><a href='%s'>%s</a></div>",
+          basePath + file, file));
+    }
+    response.append("</body></html>");
+
+    return new MockResponse()
+        .setStatus("HTTP/1.1 200")
+        .addHeader("content-type: text/html; charset=utf-8")
+        .setBody(response.toString());
+  }
+
+  private MockResponse fileToResponse(String path, File file) throws IOException {
+    return new MockResponse()
+        .setStatus("HTTP/1.1 200")
+        .setBody(fileToBytes(file))
+        .addHeader("content-type: " + contentType(path));
+  }
+
+  private Buffer fileToBytes(File file) throws IOException {
+    Buffer result = new Buffer();
+    result.writeAll(Okio.source(file));
+    return result;
+  }
+
+  private String contentType(String path) {
+    if (path.endsWith(".png")) return "image/png";
+    if (path.endsWith(".jpg")) return "image/jpeg";
+    if (path.endsWith(".jpeg")) return "image/jpeg";
+    if (path.endsWith(".gif")) return "image/gif";
+    if (path.endsWith(".html")) return "text/html; charset=utf-8";
+    if (path.endsWith(".txt")) return "text/plain; charset=utf-8";
+    return "application/octet-stream";
+  }
+
+  public static void main(String[] args) throws Exception {
+    if (args.length != 4) {
+      System.out.println("Usage: SampleServer <keystore> <password> <root file> <port>");
+      return;
+    }
+
+    String keystoreFile = args[0];
+    String password = args[1];
+    String root = args[2];
+    int port = Integer.parseInt(args[3]);
+
+    SSLContext sslContext = sslContext(keystoreFile, password);
+    SampleServer server = new SampleServer(sslContext, root, port);
+    server.run();
+  }
+
+  private static SSLContext sslContext(String keystoreFile, String password)
+      throws GeneralSecurityException, IOException {
+    KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());
+    InputStream in = new FileInputStream(keystoreFile);
+    try {
+      keystore.load(in, password.toCharArray());
+    } finally {
+      Util.closeQuietly(in);
+    }
+    KeyManagerFactory keyManagerFactory =
+        KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
+    keyManagerFactory.init(keystore, password.toCharArray());
+
+    TrustManagerFactory trustManagerFactory =
+        TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
+    trustManagerFactory.init(keystore);
+
+    SSLContext sslContext = SSLContext.getInstance("TLS");
+    sslContext.init(
+        keyManagerFactory.getKeyManagers(),
+        trustManagerFactory.getTrustManagers(),
+        new SecureRandom());
+
+    return sslContext;
+  }
+}
diff --git a/website/index.html b/website/index.html
new file mode 100644
index 0000000000..6f0df48a03
--- /dev/null
+++ b/website/index.html
@@ -0,0 +1,217 @@
+<!DOCTYPE html>
+<html lang="en">
+  <head>
+    <meta charset="utf-8">
+    <title>OkHttp</title>
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <meta name="description" content="An HTTP &amp; HTTP/2 client for Android and Java applications">
+    <link href="static/bootstrap-combined.min.css" rel="stylesheet">
+    <link href="static/app.css" rel="stylesheet">
+    <link href="static/app-theme.css" rel="stylesheet">
+    <link href="http://fonts.googleapis.com/css?family=Roboto:400,300italic,100,100italic,300" rel="stylesheet" type="text/css">
+    <!--[if lt IE 9]><script src="static/html5shiv.min.js"></script><![endif]-->
+  </head>
+  <body data-target=".content-nav">
+    <header>
+      <div class="container">
+        <div class="row">
+          <div class="span5">
+            <h1>OkHttp</h1>
+          </div>
+          <div class="span7">
+            <menu>
+              <ul>
+                <li><a href="#download" class="menu download">Download <span class="version-tag">Latest</span></a></li>
+                <li><a href="http://github.com/square/okhttp" data-title="View GitHub Project" class="menu github"><img src="static/icon-github.png" alt="GitHub"/></a></li>
+                <li><a href="http://square.github.io/" data-title="Square Open Source Portal" class="menu square"><img src="static/icon-square.png" alt="Square"/></a></li>
+              </ul>
+            </menu>
+          </div>
+      </div>
+    </header>
+    <section id="subtitle">
+      <div class="container">
+        <div class="row">
+          <div class="span12">
+            <h2>An <strong>HTTP &amp; HTTP/2</strong> client for Android and Java applications</h2>
+          </div>
+        </div>
+      </div>
+    </section>
+    <section id="body">
+      <div class="container">
+        <div class="row">
+          <div class="span9">
+            <h3 id="overview">Overview</h3>
+            <p>HTTP is the way modern applications network. It’s how we exchange data &amp; media.
+                Doing HTTP efficiently makes your stuff load faster and saves bandwidth.</p>
+
+            <p>OkHttp is an HTTP client that’s efficient by default:</p>
+            <ul>
+                <li>HTTP/2 support allows all requests to the same host to share a socket.</li>
+                <li>Connection pooling reduces request latency (if HTTP/2 isn’t available).</li>
+                <li>Transparent GZIP shrinks download sizes.</li>
+                <li>Response caching avoids the network completely for repeat requests.</li>
+            </ul>
+
+            <p>OkHttp perseveres when the network is troublesome: it will silently recover from
+                common connection problems. If your service has multiple IP addresses OkHttp will
+                attempt alternate addresses if the first connect fails. This is necessary for IPv4+IPv6
+                and for services hosted in redundant data centers. OkHttp initiates new connections
+                with modern TLS features (SNI, ALPN), and falls back to TLS 1.0 if the handshake
+                fails.</p>
+
+            <p>Using OkHttp is easy. Its request/response API is designed with fluent builders and
+                immutability. It supports both synchronous blocking calls and async calls with
+                callbacks.</p>
+
+            <p>OkHttp supports Android 2.3 and above. For Java, the minimum requirement is 1.7.</p>
+
+            <h3 id="examples">Examples</h3>
+            <h4>Get a URL</h4>
+            <p>This program downloads a URL and print its contents as a string. <a href="https://raw.github.com/square/okhttp/master/samples/guide/src/main/java/okhttp3/guide/GetExample.java">Full source</a>.
+<pre class="prettyprint">
+OkHttpClient client = new OkHttpClient();
+
+String run(String url) throws IOException {
+  Request request = new Request.Builder()
+      .url(url)
+      .build();
+
+  try (Response response = client.newCall(request).execute()) {
+    return response.body().string();
+  }
+}
+</pre>
+            <h4>Post to a Server</h4>
+            <p>This program posts data to a service. <a href="https://raw.github.com/square/okhttp/master/samples/guide/src/main/java/okhttp3/guide/PostExample.java">Full source</a>.
+
+<pre class="prettyprint">
+public static final MediaType JSON
+    = MediaType.parse("application/json; charset=utf-8");
+
+OkHttpClient client = new OkHttpClient();
+
+String post(String url, String json) throws IOException {
+  RequestBody body = RequestBody.create(JSON, json);
+  Request request = new Request.Builder()
+      .url(url)
+      .post(body)
+      .build();
+  try (Response response = client.newCall(request).execute()) {
+    return response.body().string();
+  }
+}
+</pre>
+
+            <h3 id="download">Download</h3>
+            <p><a href="https://search.maven.org/remote_content?g=com.squareup.okhttp3&a=okhttp&v=LATEST" class="dl version-href">&darr; <span class="version-tag">Latest</span> JAR</a></p>
+            <p>You'll also need <a href="http://github.com/square/okio">Okio</a>, which OkHttp
+                uses for fast I/O and resizable buffers. Download the
+                <a href="https://search.maven.org/remote_content?g=com.squareup.okio&a=okio&v=LATEST">latest JAR</a>.
+            <p>The source code to OkHttp, its samples, and this website is <a href="http://github.com/square/okhttp">available on GitHub</a>.</p>
+
+            <h4>Maven</h4>
+            <pre class="prettyprint">&lt;dependency>
+  &lt;groupId>com.squareup.okhttp3&lt;/groupId>
+  &lt;artifactId>okhttp&lt;/artifactId>
+  &lt;version><span class="version pln"><em>(insert latest version)</em></span>&lt;/version>
+&lt;/dependency></pre>
+
+            <h4>Gradle</h4>
+            <pre class="prettyprint">compile 'com.squareup.okhttp3:okhttp:<span class="version pln"><em>(insert latest version)</em></span>'</pre>
+
+            <h3 id="contributing">Contributing</h3>
+            <p>If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request.</p>
+            <p>When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles by running <code>mvn clean verify</code>.</p>
+            <p>Before your code can be accepted into the project you must also sign the <a href="http://squ.re/sign-the-cla">Individual Contributor License Agreement (CLA)</a>.</p>
+
+            <h3 id="license">License</h3>
+            <pre>Copyright 2016 Square, Inc.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.</pre>
+          </div>
+          <div class="span3">
+            <div class="content-nav" data-spy="affix" data-offset-top="80">
+              <ul class="nav nav-tabs nav-stacked primary">
+                <li><a href="#overview">Overview</a></li>
+                <li><a href="#examples">Examples</a></li>
+                <li><a href="#download">Download</a></li>
+                <li><a href="#contributing">Contributing</a></li>
+                <li><a href="#license">License</a></li>
+              </ul>
+              <ul class="nav nav-pills nav-stacked secondary">
+                <li><a href="https://github.com/square/okhttp/wiki">Wiki</a></li>
+                <li><a href="3.x/okhttp/">Javadoc</a></li>
+                <li><a href="http://stackoverflow.com/questions/tagged/okhttp?sort=active">StackOverflow</a></li>
+              </ul>
+            </div>
+          </div>
+        </div>
+        <div class="row">
+          <div class="span12 logo">
+            <a href="https://squareup.com"><img src="static/logo-square.png" alt="Square, Inc."/></a>
+          </div>
+        </div>
+      </div>
+    </section>
+    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
+    <script src="static/bootstrap.min.js"></script>
+    <script src="static/jquery.smooth-scroll.min.js"></script>
+    <script src="static/jquery-maven-artifact.min.js"></script>
+    <script src="static/prettify.js"></script>
+    <script type="text/javascript">
+      $(function() {
+        // Syntax highlight code blocks.
+        prettyPrint();
+
+        // Spy on scroll position for real-time updating of current section.
+        $('body').scrollspy();
+
+        // Use smooth-scroll for internal links.
+        $('a').smoothScroll();
+
+        // Enable tooltips on the header nav image items.
+        $('.menu').tooltip({
+          placement: 'bottom',
+          trigger: 'hover',
+          container: 'body',
+          delay: {
+            show: 500,
+            hide: 0
+          }
+        });
+
+        // Look up the latest version of the library.
+        $.fn.artifactVersion({
+          'groupId': 'com.squareup.okhttp3',
+          'artifactId': 'okhttp'
+        }, function(version, url) {
+          $('.version').text(version);
+          $('.version-tag').text('v' + version);
+          $('.version-href').attr('href', url);
+        });
+      });
+
+      var _gaq = _gaq || [];
+      _gaq.push(['_setAccount', 'UA-40704740-2']);
+      _gaq.push(['_trackPageview']);
+
+      (function() {
+        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
+        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
+        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
+      })();
+    </script>
+  </body>
+</html>
diff --git a/website/static/app-theme.css b/website/static/app-theme.css
new file mode 100644
index 0000000000..d7d00c4a93
--- /dev/null
+++ b/website/static/app-theme.css
@@ -0,0 +1,51 @@
+/* http://www.colorhexa.com/487fb9 */
+
+/*** Primary ***/
+
+header,
+#subtitle,
+a.dl {
+  background-color: #48b7b9;
+}
+
+.content-nav li.active a,
+.content-nav li.active a:hover {
+  border-left-color: #48b7b9;
+}
+
+/*** One step left on the monochromatic scale ***/
+
+header menu li a:hover,
+a.dl:hover {
+  background-color: #40a6a7;
+}
+a {
+  color: #40a6a7;
+}
+
+/*** Three steps left on the monochromatic scale ***/
+
+a:hover {
+  color: #328183;
+}
+
+
+/****************************************************************\
+ **** Syntax highlighting styles ********************************
+\****************************************************************/
+
+.pln { color: #000; }
+.str { color: #399395; }
+.kwd { color: #666; }
+.com { color: #399395; }
+.typ { color: #222; }
+.lit { color: #666; }
+.pun { color: #888; }
+.opn { color: #888; }
+.clo { color: #888; }
+.tag { color: #399395; }
+.atn { color: #606; }
+.atv { color: #080; }
+.dec { color: #606; }
+.var { color: #606; }
+.fun { color: #f00; }
diff --git a/website/static/app.css b/website/static/app.css
new file mode 100644
index 0000000000..e3574b739d
--- /dev/null
+++ b/website/static/app.css
@@ -0,0 +1,188 @@
+html, body {
+  font-family: 'Roboto', sans-serif;
+  font-size: 15px;
+}
+body {
+  background-color: #f6f6f6;
+  padding-bottom: 50px;
+  padding-top: 80px;
+}
+
+header {
+  min-height: 80px;
+  color: #f6f6f6;
+  position: fixed;
+  top: 0;
+  left: 0;
+  width: 100%;
+  z-index: 99;
+}
+header h1 {
+  margin: 10px 0;
+  font-size: 50px;
+  line-height: 60px;
+  font-weight: 100;
+  text-rendering: auto;
+}
+header menu {
+  margin: 20px 0 0;
+  padding: 0;
+  height: 40px;
+}
+header menu ul {
+  margin: 0;
+  padding: 0;
+  float: right;
+}
+header menu li {
+  list-style: none;
+  float: left;
+  margin: 0;
+  padding: 0;
+}
+header menu li a {
+  display: inline-block;
+  height: 40px;
+  font-size: 17px;
+  line-height: 40px;
+  padding: 0 20px;
+  color: #f6f6f6;
+}
+header menu li a:hover {
+  color: #f6f6f6;
+  text-decoration: none;
+}
+header menu li a img {
+  margin: 0;
+  padding: 5px 0;
+  vertical-align: bottom;
+  width: 30px;
+  height: 30px;
+}
+
+#subtitle {
+  position: absolute;
+  top: 80px;
+  left: 0;
+  width: 100%;
+}
+h2 {
+  font-weight: 200;
+  font-size: 26px;
+  line-height: 30px;
+  padding: 15px 0;
+  margin: 0;
+  color: #eee;
+}
+h2 strong {
+  font-weight: 300;
+}
+
+a.dl {
+  font-weight: 300;
+  font-size: 30px;
+  line-height: 40px;
+  padding: 3px 10px;
+  display: inline-block;
+  border-radius: 6px;
+  color: #f0f0f0;
+  margin: 5px 0;
+}
+a.dl:hover {
+  color: #f0f0f0;
+  text-decoration: none;
+}
+
+.content-nav {
+  margin-top: 130px;
+  width: 220px;
+}
+.content-nav.affix {
+  top: 0;
+}
+.content-nav li.active a, .content-nav li.active a:hover {
+  background-color: transparent;
+  color: #555;
+  border-left-width: 2px;
+}
+.content-nav .secondary a {
+  color: #aaa;
+}
+.content-nav .secondary a:hover {
+  color: #888;
+}
+
+h3 {
+  font-weight: 300;
+  font-style: italic;
+  color: #888;
+  font-size: 20px;
+  padding-top: 115px;
+  margin-top: 0;
+}
+
+h4 {
+  font-weight: 400;
+  text-transform: uppercase;
+  color: #888;
+  font-size: 15px;
+  padding-top: 20px;
+}
+
+p.license {
+  font-family: fixed-width;
+}
+
+.row .logo {
+  text-align: center;
+  margin-top: 150px;
+}
+.row .logo img {
+  height: 30px;
+}
+
+pre, code {
+  color: #666;
+}
+code {
+  border: 0;
+  background-color: transparent;
+}
+
+/* Widescreen desktop. */
+@media (min-width: 1200px) {
+  .content-nav {
+    width: 270px;
+  }
+}
+
+/* Smaller width browser, tablets. */
+@media (max-width: 979px) {
+  .content-nav {
+    width: 166px;
+  }
+}
+
+/* One-column mobile display. */
+@media (max-width: 767px) {
+  header {
+    position: absolute;
+    top: 0;
+    left: 0;
+    width: 100%;
+    padding-left: 20px;
+  }
+  header menu {
+    display: none;
+  }
+  #subtitle {
+    position: absolute;
+    top: 80px;
+    left: 0;
+    width: 100%;
+    padding-left: 20px;
+  }
+  .content-nav {
+    display: none;
+  }
+}
\ No newline at end of file
diff --git a/website/static/bootstrap-combined.min.css b/website/static/bootstrap-combined.min.css
new file mode 100644
index 0000000000..1334dfa697
--- /dev/null
+++ b/website/static/bootstrap-combined.min.css
@@ -0,0 +1,18 @@
+/*!
+ * Bootstrap v2.3.1
+ *
+ * Copyright 2012 Twitter, Inc
+ * Licensed under the Apache License v2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Designed and built with all the love in the world @twitter by @mdo and @fat.
+ */.clearfix{*zoom:1}.clearfix:before,.clearfix:after{display:table;line-height:0;content:""}.clearfix:after{clear:both}.hide-text{font:0/0 a;color:transparent;text-shadow:none;background-color:transparent;border:0}.input-block-level{display:block;width:100%;min-height:30px;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}article,aside,details,figcaption,figure,footer,header,hgroup,nav,section{display:block}audio,canvas,video{display:inline-block;*display:inline;*zoom:1}audio:not([controls]){display:none}html{font-size:100%;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%}a:focus{outline:thin dotted #333;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}a:hover,a:active{outline:0}sub,sup{position:relative;font-size:75%;line-height:0;vertical-align:baseline}sup{top:-0.5em}sub{bottom:-0.25em}img{width:auto\9;height:auto;max-width:100%;vertical-align:middle;border:0;-ms-interpolation-mode:bicubic}#map_canvas img,.google-maps img{max-width:none}button,input,select,textarea{margin:0;font-size:100%;vertical-align:middle}button,input{*overflow:visible;line-height:normal}button::-moz-focus-inner,input::-moz-focus-inner{padding:0;border:0}button,html input[type="button"],input[type="reset"],input[type="submit"]{cursor:pointer;-webkit-appearance:button}label,select,button,input[type="button"],input[type="reset"],input[type="submit"],input[type="radio"],input[type="checkbox"]{cursor:pointer}input[type="search"]{-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;-webkit-appearance:textfield}input[type="search"]::-webkit-search-decoration,input[type="search"]::-webkit-search-cancel-button{-webkit-appearance:none}textarea{overflow:auto;vertical-align:top}@media print{*{color:#000!important;text-shadow:none!important;background:transparent!important;box-shadow:none!important}a,a:visited{text-decoration:underline}a[href]:after{content:" (" attr(href) ")"}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100%!important}@page{margin:.5cm}p,h2,h3{orphans:3;widows:3}h2,h3{page-break-after:avoid}}body{margin:0;font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;font-size:14px;line-height:20px;color:#333;background-color:#fff}a{color:#08c;text-decoration:none}a:hover,a:focus{color:#005580;text-decoration:underline}.img-rounded{-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px}.img-polaroid{padding:4px;background-color:#fff;border:1px solid #ccc;border:1px solid rgba(0,0,0,0.2);-webkit-box-shadow:0 1px 3px rgba(0,0,0,0.1);-moz-box-shadow:0 1px 3px rgba(0,0,0,0.1);box-shadow:0 1px 3px rgba(0,0,0,0.1)}.img-circle{-webkit-border-radius:500px;-moz-border-radius:500px;border-radius:500px}.row{margin-left:-20px;*zoom:1}.row:before,.row:after{display:table;line-height:0;content:""}.row:after{clear:both}[class*="span"]{float:left;min-height:1px;margin-left:20px}.container,.navbar-static-top .container,.navbar-fixed-top .container,.navbar-fixed-bottom .container{width:940px}.span12{width:940px}.span11{width:860px}.span10{width:780px}.span9{width:700px}.span8{width:620px}.span7{width:540px}.span6{width:460px}.span5{width:380px}.span4{width:300px}.span3{width:220px}.span2{width:140px}.span1{width:60px}.offset12{margin-left:980px}.offset11{margin-left:900px}.offset10{margin-left:820px}.offset9{margin-left:740px}.offset8{margin-left:660px}.offset7{margin-left:580px}.offset6{margin-left:500px}.offset5{margin-left:420px}.offset4{margin-left:340px}.offset3{margin-left:260px}.offset2{margin-left:180px}.offset1{margin-left:100px}.row-fluid{width:100%;*zoom:1}.row-fluid:before,.row-fluid:after{display:table;line-height:0;content:""}.row-fluid:after{clear:both}.row-fluid [class*="span"]{display:block;float:left;width:100%;min-height:30px;margin-left:2.127659574468085%;*margin-left:2.074468085106383%;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}.row-fluid [class*="span"]:first-child{margin-left:0}.row-fluid .controls-row [class*="span"]+[class*="span"]{margin-left:2.127659574468085%}.row-fluid .span12{width:100%;*width:99.94680851063829%}.row-fluid .span11{width:91.48936170212765%;*width:91.43617021276594%}.row-fluid .span10{width:82.97872340425532%;*width:82.92553191489361%}.row-fluid .span9{width:74.46808510638297%;*width:74.41489361702126%}.row-fluid .span8{width:65.95744680851064%;*width:65.90425531914893%}.row-fluid .span7{width:57.44680851063829%;*width:57.39361702127659%}.row-fluid .span6{width:48.93617021276595%;*width:48.88297872340425%}.row-fluid .span5{width:40.42553191489362%;*width:40.37234042553192%}.row-fluid .span4{width:31.914893617021278%;*width:31.861702127659576%}.row-fluid .span3{width:23.404255319148934%;*width:23.351063829787233%}.row-fluid .span2{width:14.893617021276595%;*width:14.840425531914894%}.row-fluid .span1{width:6.382978723404255%;*width:6.329787234042553%}.row-fluid .offset12{margin-left:104.25531914893617%;*margin-left:104.14893617021275%}.row-fluid .offset12:first-child{margin-left:102.12765957446808%;*margin-left:102.02127659574467%}.row-fluid .offset11{margin-left:95.74468085106382%;*margin-left:95.6382978723404%}.row-fluid .offset11:first-child{margin-left:93.61702127659574%;*margin-left:93.51063829787232%}.row-fluid .offset10{margin-left:87.23404255319149%;*margin-left:87.12765957446807%}.row-fluid .offset10:first-child{margin-left:85.1063829787234%;*margin-left:84.99999999999999%}.row-fluid .offset9{margin-left:78.72340425531914%;*margin-left:78.61702127659572%}.row-fluid .offset9:first-child{margin-left:76.59574468085106%;*margin-left:76.48936170212764%}.row-fluid .offset8{margin-left:70.2127659574468%;*margin-left:70.10638297872339%}.row-fluid .offset8:first-child{margin-left:68.08510638297872%;*margin-left:67.9787234042553%}.row-fluid .offset7{margin-left:61.70212765957446%;*margin-left:61.59574468085106%}.row-fluid .offset7:first-child{margin-left:59.574468085106375%;*margin-left:59.46808510638297%}.row-fluid .offset6{margin-left:53.191489361702125%;*margin-left:53.085106382978715%}.row-fluid .offset6:first-child{margin-left:51.063829787234035%;*margin-left:50.95744680851063%}.row-fluid .offset5{margin-left:44.68085106382979%;*margin-left:44.57446808510638%}.row-fluid .offset5:first-child{margin-left:42.5531914893617%;*margin-left:42.4468085106383%}.row-fluid .offset4{margin-left:36.170212765957444%;*margin-left:36.06382978723405%}.row-fluid .offset4:first-child{margin-left:34.04255319148936%;*margin-left:33.93617021276596%}.row-fluid .offset3{margin-left:27.659574468085104%;*margin-left:27.5531914893617%}.row-fluid .offset3:first-child{margin-left:25.53191489361702%;*margin-left:25.425531914893618%}.row-fluid .offset2{margin-left:19.148936170212764%;*margin-left:19.04255319148936%}.row-fluid .offset2:first-child{margin-left:17.02127659574468%;*margin-left:16.914893617021278%}.row-fluid .offset1{margin-left:10.638297872340425%;*margin-left:10.53191489361702%}.row-fluid .offset1:first-child{margin-left:8.51063829787234%;*margin-left:8.404255319148938%}[class*="span"].hide,.row-fluid [class*="span"].hide{display:none}[class*="span"].pull-right,.row-fluid [class*="span"].pull-right{float:right}.container{margin-right:auto;margin-left:auto;*zoom:1}.container:before,.container:after{display:table;line-height:0;content:""}.container:after{clear:both}.container-fluid{padding-right:20px;padding-left:20px;*zoom:1}.container-fluid:before,.container-fluid:after{display:table;line-height:0;content:""}.container-fluid:after{clear:both}p{margin:0 0 10px}.lead{margin-bottom:20px;font-size:21px;font-weight:200;line-height:30px}small{font-size:85%}strong{font-weight:bold}em{font-style:italic}cite{font-style:normal}.muted{color:#999}a.muted:hover,a.muted:focus{color:#808080}.text-warning{color:#c09853}a.text-warning:hover,a.text-warning:focus{color:#a47e3c}.text-error{color:#b94a48}a.text-error:hover,a.text-error:focus{color:#953b39}.text-info{color:#3a87ad}a.text-info:hover,a.text-info:focus{color:#2d6987}.text-success{color:#468847}a.text-success:hover,a.text-success:focus{color:#356635}.text-left{text-align:left}.text-right{text-align:right}.text-center{text-align:center}h1,h2,h3,h4,h5,h6{margin:10px 0;font-family:inherit;font-weight:bold;line-height:20px;color:inherit;text-rendering:optimizelegibility}h1 small,h2 small,h3 small,h4 small,h5 small,h6 small{font-weight:normal;line-height:1;color:#999}h1,h2,h3{line-height:40px}h1{font-size:38.5px}h2{font-size:31.5px}h3{font-size:24.5px}h4{font-size:17.5px}h5{font-size:14px}h6{font-size:11.9px}h1 small{font-size:24.5px}h2 small{font-size:17.5px}h3 small{font-size:14px}h4 small{font-size:14px}.page-header{padding-bottom:9px;margin:20px 0 30px;border-bottom:1px solid #eee}ul,ol{padding:0;margin:0 0 10px 25px}ul ul,ul ol,ol ol,ol ul{margin-bottom:0}li{line-height:20px}ul.unstyled,ol.unstyled{margin-left:0;list-style:none}ul.inline,ol.inline{margin-left:0;list-style:none}ul.inline>li,ol.inline>li{display:inline-block;*display:inline;padding-right:5px;padding-left:5px;*zoom:1}dl{margin-bottom:20px}dt,dd{line-height:20px}dt{font-weight:bold}dd{margin-left:10px}.dl-horizontal{*zoom:1}.dl-horizontal:before,.dl-horizontal:after{display:table;line-height:0;content:""}.dl-horizontal:after{clear:both}.dl-horizontal dt{float:left;width:160px;overflow:hidden;clear:left;text-align:right;text-overflow:ellipsis;white-space:nowrap}.dl-horizontal dd{margin-left:180px}hr{margin:20px 0;border:0;border-top:1px solid #eee;border-bottom:1px solid #fff}abbr[title],abbr[data-original-title]{cursor:help;border-bottom:1px dotted #999}abbr.initialism{font-size:90%;text-transform:uppercase}blockquote{padding:0 0 0 15px;margin:0 0 20px;border-left:5px solid #eee}blockquote p{margin-bottom:0;font-size:17.5px;font-weight:300;line-height:1.25}blockquote small{display:block;line-height:20px;color:#999}blockquote small:before{content:'\2014 \00A0'}blockquote.pull-right{float:right;padding-right:15px;padding-left:0;border-right:5px solid #eee;border-left:0}blockquote.pull-right p,blockquote.pull-right small{text-align:right}blockquote.pull-right small:before{content:''}blockquote.pull-right small:after{content:'\00A0 \2014'}q:before,q:after,blockquote:before,blockquote:after{content:""}address{display:block;margin-bottom:20px;font-style:normal;line-height:20px}code,pre{padding:0 3px 2px;font-family:Monaco,Menlo,Consolas,"Courier New",monospace;font-size:12px;color:#333;-webkit-border-radius:3px;-moz-border-radius:3px;border-radius:3px}code{padding:2px 4px;color:#d14;white-space:nowrap;background-color:#f7f7f9;border:1px solid #e1e1e8}pre{display:block;padding:9.5px;margin:0 0 10px;font-size:13px;line-height:20px;word-break:break-all;word-wrap:break-word;white-space:pre;white-space:pre-wrap;background-color:#f5f5f5;border:1px solid #ccc;border:1px solid rgba(0,0,0,0.15);-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}pre.prettyprint{margin-bottom:20px}pre code{padding:0;color:inherit;white-space:pre;white-space:pre-wrap;background-color:transparent;border:0}.pre-scrollable{max-height:340px;overflow-y:scroll}form{margin:0 0 20px}fieldset{padding:0;margin:0;border:0}legend{display:block;width:100%;padding:0;margin-bottom:20px;font-size:21px;line-height:40px;color:#333;border:0;border-bottom:1px solid #e5e5e5}legend small{font-size:15px;color:#999}label,input,button,select,textarea{font-size:14px;font-weight:normal;line-height:20px}input,button,select,textarea{font-family:"Helvetica Neue",Helvetica,Arial,sans-serif}label{display:block;margin-bottom:5px}select,textarea,input[type="text"],input[type="password"],input[type="datetime"],input[type="datetime-local"],input[type="date"],input[type="month"],input[type="time"],input[type="week"],input[type="number"],input[type="email"],input[type="url"],input[type="search"],input[type="tel"],input[type="color"],.uneditable-input{display:inline-block;height:20px;padding:4px 6px;margin-bottom:10px;font-size:14px;line-height:20px;color:#555;vertical-align:middle;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}input,textarea,.uneditable-input{width:206px}textarea{height:auto}textarea,input[type="text"],input[type="password"],input[type="datetime"],input[type="datetime-local"],input[type="date"],input[type="month"],input[type="time"],input[type="week"],input[type="number"],input[type="email"],input[type="url"],input[type="search"],input[type="tel"],input[type="color"],.uneditable-input{background-color:#fff;border:1px solid #ccc;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);-webkit-transition:border linear .2s,box-shadow linear .2s;-moz-transition:border linear .2s,box-shadow linear .2s;-o-transition:border linear .2s,box-shadow linear .2s;transition:border linear .2s,box-shadow linear .2s}textarea:focus,input[type="text"]:focus,input[type="password"]:focus,input[type="datetime"]:focus,input[type="datetime-local"]:focus,input[type="date"]:focus,input[type="month"]:focus,input[type="time"]:focus,input[type="week"]:focus,input[type="number"]:focus,input[type="email"]:focus,input[type="url"]:focus,input[type="search"]:focus,input[type="tel"]:focus,input[type="color"]:focus,.uneditable-input:focus{border-color:rgba(82,168,236,0.8);outline:0;outline:thin dotted \9;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 8px rgba(82,168,236,0.6);-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 8px rgba(82,168,236,0.6);box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 8px rgba(82,168,236,0.6)}input[type="radio"],input[type="checkbox"]{margin:4px 0 0;margin-top:1px \9;*margin-top:0;line-height:normal}input[type="file"],input[type="image"],input[type="submit"],input[type="reset"],input[type="button"],input[type="radio"],input[type="checkbox"]{width:auto}select,input[type="file"]{height:30px;*margin-top:4px;line-height:30px}select{width:220px;background-color:#fff;border:1px solid #ccc}select[multiple],select[size]{height:auto}select:focus,input[type="file"]:focus,input[type="radio"]:focus,input[type="checkbox"]:focus{outline:thin dotted #333;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}.uneditable-input,.uneditable-textarea{color:#999;cursor:not-allowed;background-color:#fcfcfc;border-color:#ccc;-webkit-box-shadow:inset 0 1px 2px rgba(0,0,0,0.025);-moz-box-shadow:inset 0 1px 2px rgba(0,0,0,0.025);box-shadow:inset 0 1px 2px rgba(0,0,0,0.025)}.uneditable-input{overflow:hidden;white-space:nowrap}.uneditable-textarea{width:auto;height:auto}input:-moz-placeholder,textarea:-moz-placeholder{color:#999}input:-ms-input-placeholder,textarea:-ms-input-placeholder{color:#999}input::-webkit-input-placeholder,textarea::-webkit-input-placeholder{color:#999}.radio,.checkbox{min-height:20px;padding-left:20px}.radio input[type="radio"],.checkbox input[type="checkbox"]{float:left;margin-left:-20px}.controls>.radio:first-child,.controls>.checkbox:first-child{padding-top:5px}.radio.inline,.checkbox.inline{display:inline-block;padding-top:5px;margin-bottom:0;vertical-align:middle}.radio.inline+.radio.inline,.checkbox.inline+.checkbox.inline{margin-left:10px}.input-mini{width:60px}.input-small{width:90px}.input-medium{width:150px}.input-large{width:210px}.input-xlarge{width:270px}.input-xxlarge{width:530px}input[class*="span"],select[class*="span"],textarea[class*="span"],.uneditable-input[class*="span"],.row-fluid input[class*="span"],.row-fluid select[class*="span"],.row-fluid textarea[class*="span"],.row-fluid .uneditable-input[class*="span"]{float:none;margin-left:0}.input-append input[class*="span"],.input-append .uneditable-input[class*="span"],.input-prepend input[class*="span"],.input-prepend .uneditable-input[class*="span"],.row-fluid input[class*="span"],.row-fluid select[class*="span"],.row-fluid textarea[class*="span"],.row-fluid .uneditable-input[class*="span"],.row-fluid .input-prepend [class*="span"],.row-fluid .input-append [class*="span"]{display:inline-block}input,textarea,.uneditable-input{margin-left:0}.controls-row [class*="span"]+[class*="span"]{margin-left:20px}input.span12,textarea.span12,.uneditable-input.span12{width:926px}input.span11,textarea.span11,.uneditable-input.span11{width:846px}input.span10,textarea.span10,.uneditable-input.span10{width:766px}input.span9,textarea.span9,.uneditable-input.span9{width:686px}input.span8,textarea.span8,.uneditable-input.span8{width:606px}input.span7,textarea.span7,.uneditable-input.span7{width:526px}input.span6,textarea.span6,.uneditable-input.span6{width:446px}input.span5,textarea.span5,.uneditable-input.span5{width:366px}input.span4,textarea.span4,.uneditable-input.span4{width:286px}input.span3,textarea.span3,.uneditable-input.span3{width:206px}input.span2,textarea.span2,.uneditable-input.span2{width:126px}input.span1,textarea.span1,.uneditable-input.span1{width:46px}.controls-row{*zoom:1}.controls-row:before,.controls-row:after{display:table;line-height:0;content:""}.controls-row:after{clear:both}.controls-row [class*="span"],.row-fluid .controls-row [class*="span"]{float:left}.controls-row .checkbox[class*="span"],.controls-row .radio[class*="span"]{padding-top:5px}input[disabled],select[disabled],textarea[disabled],input[readonly],select[readonly],textarea[readonly]{cursor:not-allowed;background-color:#eee}input[type="radio"][disabled],input[type="checkbox"][disabled],input[type="radio"][readonly],input[type="checkbox"][readonly]{background-color:transparent}.control-group.warning .control-label,.control-group.warning .help-block,.control-group.warning .help-inline{color:#c09853}.control-group.warning .checkbox,.control-group.warning .radio,.control-group.warning input,.control-group.warning select,.control-group.warning textarea{color:#c09853}.control-group.warning input,.control-group.warning select,.control-group.warning textarea{border-color:#c09853;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);box-shadow:inset 0 1px 1px rgba(0,0,0,0.075)}.control-group.warning input:focus,.control-group.warning select:focus,.control-group.warning textarea:focus{border-color:#a47e3c;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #dbc59e;-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #dbc59e;box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #dbc59e}.control-group.warning .input-prepend .add-on,.control-group.warning .input-append .add-on{color:#c09853;background-color:#fcf8e3;border-color:#c09853}.control-group.error .control-label,.control-group.error .help-block,.control-group.error .help-inline{color:#b94a48}.control-group.error .checkbox,.control-group.error .radio,.control-group.error input,.control-group.error select,.control-group.error textarea{color:#b94a48}.control-group.error input,.control-group.error select,.control-group.error textarea{border-color:#b94a48;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);box-shadow:inset 0 1px 1px rgba(0,0,0,0.075)}.control-group.error input:focus,.control-group.error select:focus,.control-group.error textarea:focus{border-color:#953b39;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #d59392;-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #d59392;box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #d59392}.control-group.error .input-prepend .add-on,.control-group.error .input-append .add-on{color:#b94a48;background-color:#f2dede;border-color:#b94a48}.control-group.success .control-label,.control-group.success .help-block,.control-group.success .help-inline{color:#468847}.control-group.success .checkbox,.control-group.success .radio,.control-group.success input,.control-group.success select,.control-group.success textarea{color:#468847}.control-group.success input,.control-group.success select,.control-group.success textarea{border-color:#468847;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);box-shadow:inset 0 1px 1px rgba(0,0,0,0.075)}.control-group.success input:focus,.control-group.success select:focus,.control-group.success textarea:focus{border-color:#356635;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #7aba7b;-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #7aba7b;box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #7aba7b}.control-group.success .input-prepend .add-on,.control-group.success .input-append .add-on{color:#468847;background-color:#dff0d8;border-color:#468847}.control-group.info .control-label,.control-group.info .help-block,.control-group.info .help-inline{color:#3a87ad}.control-group.info .checkbox,.control-group.info .radio,.control-group.info input,.control-group.info select,.control-group.info textarea{color:#3a87ad}.control-group.info input,.control-group.info select,.control-group.info textarea{border-color:#3a87ad;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);box-shadow:inset 0 1px 1px rgba(0,0,0,0.075)}.control-group.info input:focus,.control-group.info select:focus,.control-group.info textarea:focus{border-color:#2d6987;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #7ab5d3;-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #7ab5d3;box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #7ab5d3}.control-group.info .input-prepend .add-on,.control-group.info .input-append .add-on{color:#3a87ad;background-color:#d9edf7;border-color:#3a87ad}input:focus:invalid,textarea:focus:invalid,select:focus:invalid{color:#b94a48;border-color:#ee5f5b}input:focus:invalid:focus,textarea:focus:invalid:focus,select:focus:invalid:focus{border-color:#e9322d;-webkit-box-shadow:0 0 6px #f8b9b7;-moz-box-shadow:0 0 6px #f8b9b7;box-shadow:0 0 6px #f8b9b7}.form-actions{padding:19px 20px 20px;margin-top:20px;margin-bottom:20px;background-color:#f5f5f5;border-top:1px solid #e5e5e5;*zoom:1}.form-actions:before,.form-actions:after{display:table;line-height:0;content:""}.form-actions:after{clear:both}.help-block,.help-inline{color:#595959}.help-block{display:block;margin-bottom:10px}.help-inline{display:inline-block;*display:inline;padding-left:5px;vertical-align:middle;*zoom:1}.input-append,.input-prepend{display:inline-block;margin-bottom:10px;font-size:0;white-space:nowrap;vertical-align:middle}.input-append input,.input-prepend input,.input-append select,.input-prepend select,.input-append .uneditable-input,.input-prepend .uneditable-input,.input-append .dropdown-menu,.input-prepend .dropdown-menu,.input-append .popover,.input-prepend .popover{font-size:14px}.input-append input,.input-prepend input,.input-append select,.input-prepend select,.input-append .uneditable-input,.input-prepend .uneditable-input{position:relative;margin-bottom:0;*margin-left:0;vertical-align:top;-webkit-border-radius:0 4px 4px 0;-moz-border-radius:0 4px 4px 0;border-radius:0 4px 4px 0}.input-append input:focus,.input-prepend input:focus,.input-append select:focus,.input-prepend select:focus,.input-append .uneditable-input:focus,.input-prepend .uneditable-input:focus{z-index:2}.input-append .add-on,.input-prepend .add-on{display:inline-block;width:auto;height:20px;min-width:16px;padding:4px 5px;font-size:14px;font-weight:normal;line-height:20px;text-align:center;text-shadow:0 1px 0 #fff;background-color:#eee;border:1px solid #ccc}.input-append .add-on,.input-prepend .add-on,.input-append .btn,.input-prepend .btn,.input-append .btn-group>.dropdown-toggle,.input-prepend .btn-group>.dropdown-toggle{vertical-align:top;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.input-append .active,.input-prepend .active{background-color:#a9dba9;border-color:#46a546}.input-prepend .add-on,.input-prepend .btn{margin-right:-1px}.input-prepend .add-on:first-child,.input-prepend .btn:first-child{-webkit-border-radius:4px 0 0 4px;-moz-border-radius:4px 0 0 4px;border-radius:4px 0 0 4px}.input-append input,.input-append select,.input-append .uneditable-input{-webkit-border-radius:4px 0 0 4px;-moz-border-radius:4px 0 0 4px;border-radius:4px 0 0 4px}.input-append input+.btn-group .btn:last-child,.input-append select+.btn-group .btn:last-child,.input-append .uneditable-input+.btn-group .btn:last-child{-webkit-border-radius:0 4px 4px 0;-moz-border-radius:0 4px 4px 0;border-radius:0 4px 4px 0}.input-append .add-on,.input-append .btn,.input-append .btn-group{margin-left:-1px}.input-append .add-on:last-child,.input-append .btn:last-child,.input-append .btn-group:last-child>.dropdown-toggle{-webkit-border-radius:0 4px 4px 0;-moz-border-radius:0 4px 4px 0;border-radius:0 4px 4px 0}.input-prepend.input-append input,.input-prepend.input-append select,.input-prepend.input-append .uneditable-input{-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.input-prepend.input-append input+.btn-group .btn,.input-prepend.input-append select+.btn-group .btn,.input-prepend.input-append .uneditable-input+.btn-group .btn{-webkit-border-radius:0 4px 4px 0;-moz-border-radius:0 4px 4px 0;border-radius:0 4px 4px 0}.input-prepend.input-append .add-on:first-child,.input-prepend.input-append .btn:first-child{margin-right:-1px;-webkit-border-radius:4px 0 0 4px;-moz-border-radius:4px 0 0 4px;border-radius:4px 0 0 4px}.input-prepend.input-append .add-on:last-child,.input-prepend.input-append .btn:last-child{margin-left:-1px;-webkit-border-radius:0 4px 4px 0;-moz-border-radius:0 4px 4px 0;border-radius:0 4px 4px 0}.input-prepend.input-append .btn-group:first-child{margin-left:0}input.search-query{padding-right:14px;padding-right:4px \9;padding-left:14px;padding-left:4px \9;margin-bottom:0;-webkit-border-radius:15px;-moz-border-radius:15px;border-radius:15px}.form-search .input-append .search-query,.form-search .input-prepend .search-query{-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.form-search .input-append .search-query{-webkit-border-radius:14px 0 0 14px;-moz-border-radius:14px 0 0 14px;border-radius:14px 0 0 14px}.form-search .input-append .btn{-webkit-border-radius:0 14px 14px 0;-moz-border-radius:0 14px 14px 0;border-radius:0 14px 14px 0}.form-search .input-prepend .search-query{-webkit-border-radius:0 14px 14px 0;-moz-border-radius:0 14px 14px 0;border-radius:0 14px 14px 0}.form-search .input-prepend .btn{-webkit-border-radius:14px 0 0 14px;-moz-border-radius:14px 0 0 14px;border-radius:14px 0 0 14px}.form-search input,.form-inline input,.form-horizontal input,.form-search textarea,.form-inline textarea,.form-horizontal textarea,.form-search select,.form-inline select,.form-horizontal select,.form-search .help-inline,.form-inline .help-inline,.form-horizontal .help-inline,.form-search .uneditable-input,.form-inline .uneditable-input,.form-horizontal .uneditable-input,.form-search .input-prepend,.form-inline .input-prepend,.form-horizontal .input-prepend,.form-search .input-append,.form-inline .input-append,.form-horizontal .input-append{display:inline-block;*display:inline;margin-bottom:0;vertical-align:middle;*zoom:1}.form-search .hide,.form-inline .hide,.form-horizontal .hide{display:none}.form-search label,.form-inline label,.form-search .btn-group,.form-inline .btn-group{display:inline-block}.form-search .input-append,.form-inline .input-append,.form-search .input-prepend,.form-inline .input-prepend{margin-bottom:0}.form-search .radio,.form-search .checkbox,.form-inline .radio,.form-inline .checkbox{padding-left:0;margin-bottom:0;vertical-align:middle}.form-search .radio input[type="radio"],.form-search .checkbox input[type="checkbox"],.form-inline .radio input[type="radio"],.form-inline .checkbox input[type="checkbox"]{float:left;margin-right:3px;margin-left:0}.control-group{margin-bottom:10px}legend+.control-group{margin-top:20px;-webkit-margin-top-collapse:separate}.form-horizontal .control-group{margin-bottom:20px;*zoom:1}.form-horizontal .control-group:before,.form-horizontal .control-group:after{display:table;line-height:0;content:""}.form-horizontal .control-group:after{clear:both}.form-horizontal .control-label{float:left;width:160px;padding-top:5px;text-align:right}.form-horizontal .controls{*display:inline-block;*padding-left:20px;margin-left:180px;*margin-left:0}.form-horizontal .controls:first-child{*padding-left:180px}.form-horizontal .help-block{margin-bottom:0}.form-horizontal input+.help-block,.form-horizontal select+.help-block,.form-horizontal textarea+.help-block,.form-horizontal .uneditable-input+.help-block,.form-horizontal .input-prepend+.help-block,.form-horizontal .input-append+.help-block{margin-top:10px}.form-horizontal .form-actions{padding-left:180px}table{max-width:100%;background-color:transparent;border-collapse:collapse;border-spacing:0}.table{width:100%;margin-bottom:20px}.table th,.table td{padding:8px;line-height:20px;text-align:left;vertical-align:top;border-top:1px solid #ddd}.table th{font-weight:bold}.table thead th{vertical-align:bottom}.table caption+thead tr:first-child th,.table caption+thead tr:first-child td,.table colgroup+thead tr:first-child th,.table colgroup+thead tr:first-child td,.table thead:first-child tr:first-child th,.table thead:first-child tr:first-child td{border-top:0}.table tbody+tbody{border-top:2px solid #ddd}.table .table{background-color:#fff}.table-condensed th,.table-condensed td{padding:4px 5px}.table-bordered{border:1px solid #ddd;border-collapse:separate;*border-collapse:collapse;border-left:0;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}.table-bordered th,.table-bordered td{border-left:1px solid #ddd}.table-bordered caption+thead tr:first-child th,.table-bordered caption+tbody tr:first-child th,.table-bordered caption+tbody tr:first-child td,.table-bordered colgroup+thead tr:first-child th,.table-bordered colgroup+tbody tr:first-child th,.table-bordered colgroup+tbody tr:first-child td,.table-bordered thead:first-child tr:first-child th,.table-bordered tbody:first-child tr:first-child th,.table-bordered tbody:first-child tr:first-child td{border-top:0}.table-bordered thead:first-child tr:first-child>th:first-child,.table-bordered tbody:first-child tr:first-child>td:first-child,.table-bordered tbody:first-child tr:first-child>th:first-child{-webkit-border-top-left-radius:4px;border-top-left-radius:4px;-moz-border-radius-topleft:4px}.table-bordered thead:first-child tr:first-child>th:last-child,.table-bordered tbody:first-child tr:first-child>td:last-child,.table-bordered tbody:first-child tr:first-child>th:last-child{-webkit-border-top-right-radius:4px;border-top-right-radius:4px;-moz-border-radius-topright:4px}.table-bordered thead:last-child tr:last-child>th:first-child,.table-bordered tbody:last-child tr:last-child>td:first-child,.table-bordered tbody:last-child tr:last-child>th:first-child,.table-bordered tfoot:last-child tr:last-child>td:first-child,.table-bordered tfoot:last-child tr:last-child>th:first-child{-webkit-border-bottom-left-radius:4px;border-bottom-left-radius:4px;-moz-border-radius-bottomleft:4px}.table-bordered thead:last-child tr:last-child>th:last-child,.table-bordered tbody:last-child tr:last-child>td:last-child,.table-bordered tbody:last-child tr:last-child>th:last-child,.table-bordered tfoot:last-child tr:last-child>td:last-child,.table-bordered tfoot:last-child tr:last-child>th:last-child{-webkit-border-bottom-right-radius:4px;border-bottom-right-radius:4px;-moz-border-radius-bottomright:4px}.table-bordered tfoot+tbody:last-child tr:last-child td:first-child{-webkit-border-bottom-left-radius:0;border-bottom-left-radius:0;-moz-border-radius-bottomleft:0}.table-bordered tfoot+tbody:last-child tr:last-child td:last-child{-webkit-border-bottom-right-radius:0;border-bottom-right-radius:0;-moz-border-radius-bottomright:0}.table-bordered caption+thead tr:first-child th:first-child,.table-bordered caption+tbody tr:first-child td:first-child,.table-bordered colgroup+thead tr:first-child th:first-child,.table-bordered colgroup+tbody tr:first-child td:first-child{-webkit-border-top-left-radius:4px;border-top-left-radius:4px;-moz-border-radius-topleft:4px}.table-bordered caption+thead tr:first-child th:last-child,.table-bordered caption+tbody tr:first-child td:last-child,.table-bordered colgroup+thead tr:first-child th:last-child,.table-bordered colgroup+tbody tr:first-child td:last-child{-webkit-border-top-right-radius:4px;border-top-right-radius:4px;-moz-border-radius-topright:4px}.table-striped tbody>tr:nth-child(odd)>td,.table-striped tbody>tr:nth-child(odd)>th{background-color:#f9f9f9}.table-hover tbody tr:hover>td,.table-hover tbody tr:hover>th{background-color:#f5f5f5}table td[class*="span"],table th[class*="span"],.row-fluid table td[class*="span"],.row-fluid table th[class*="span"]{display:table-cell;float:none;margin-left:0}.table td.span1,.table th.span1{float:none;width:44px;margin-left:0}.table td.span2,.table th.span2{float:none;width:124px;margin-left:0}.table td.span3,.table th.span3{float:none;width:204px;margin-left:0}.table td.span4,.table th.span4{float:none;width:284px;margin-left:0}.table td.span5,.table th.span5{float:none;width:364px;margin-left:0}.table td.span6,.table th.span6{float:none;width:444px;margin-left:0}.table td.span7,.table th.span7{float:none;width:524px;margin-left:0}.table td.span8,.table th.span8{float:none;width:604px;margin-left:0}.table td.span9,.table th.span9{float:none;width:684px;margin-left:0}.table td.span10,.table th.span10{float:none;width:764px;margin-left:0}.table td.span11,.table th.span11{float:none;width:844px;margin-left:0}.table td.span12,.table th.span12{float:none;width:924px;margin-left:0}.table tbody tr.success>td{background-color:#dff0d8}.table tbody tr.error>td{background-color:#f2dede}.table tbody tr.warning>td{background-color:#fcf8e3}.table tbody tr.info>td{background-color:#d9edf7}.table-hover tbody tr.success:hover>td{background-color:#d0e9c6}.table-hover tbody tr.error:hover>td{background-color:#ebcccc}.table-hover tbody tr.warning:hover>td{background-color:#faf2cc}.table-hover tbody tr.info:hover>td{background-color:#c4e3f3}[class^="icon-"],[class*=" icon-"]{display:inline-block;width:14px;height:14px;margin-top:1px;*margin-right:.3em;line-height:14px;vertical-align:text-top;background-image:url("../img/glyphicons-halflings.png");background-position:14px 14px;background-repeat:no-repeat}.icon-white,.nav-pills>.active>a>[class^="icon-"],.nav-pills>.active>a>[class*=" icon-"],.nav-list>.active>a>[class^="icon-"],.nav-list>.active>a>[class*=" icon-"],.navbar-inverse .nav>.active>a>[class^="icon-"],.navbar-inverse .nav>.active>a>[class*=" icon-"],.dropdown-menu>li>a:hover>[class^="icon-"],.dropdown-menu>li>a:focus>[class^="icon-"],.dropdown-menu>li>a:hover>[class*=" icon-"],.dropdown-menu>li>a:focus>[class*=" icon-"],.dropdown-menu>.active>a>[class^="icon-"],.dropdown-menu>.active>a>[class*=" icon-"],.dropdown-submenu:hover>a>[class^="icon-"],.dropdown-submenu:focus>a>[class^="icon-"],.dropdown-submenu:hover>a>[class*=" icon-"],.dropdown-submenu:focus>a>[class*=" icon-"]{background-image:url("../img/glyphicons-halflings-white.png")}.icon-glass{background-position:0 0}.icon-music{background-position:-24px 0}.icon-search{background-position:-48px 0}.icon-envelope{background-position:-72px 0}.icon-heart{background-position:-96px 0}.icon-star{background-position:-120px 0}.icon-star-empty{background-position:-144px 0}.icon-user{background-position:-168px 0}.icon-film{background-position:-192px 0}.icon-th-large{background-position:-216px 0}.icon-th{background-position:-240px 0}.icon-th-list{background-position:-264px 0}.icon-ok{background-position:-288px 0}.icon-remove{background-position:-312px 0}.icon-zoom-in{background-position:-336px 0}.icon-zoom-out{background-position:-360px 0}.icon-off{background-position:-384px 0}.icon-signal{background-position:-408px 0}.icon-cog{background-position:-432px 0}.icon-trash{background-position:-456px 0}.icon-home{background-position:0 -24px}.icon-file{background-position:-24px -24px}.icon-time{background-position:-48px -24px}.icon-road{background-position:-72px -24px}.icon-download-alt{background-position:-96px -24px}.icon-download{background-position:-120px -24px}.icon-upload{background-position:-144px -24px}.icon-inbox{background-position:-168px -24px}.icon-play-circle{background-position:-192px -24px}.icon-repeat{background-position:-216px -24px}.icon-refresh{background-position:-240px -24px}.icon-list-alt{background-position:-264px -24px}.icon-lock{background-position:-287px -24px}.icon-flag{background-position:-312px -24px}.icon-headphones{background-position:-336px -24px}.icon-volume-off{background-position:-360px -24px}.icon-volume-down{background-position:-384px -24px}.icon-volume-up{background-position:-408px -24px}.icon-qrcode{background-position:-432px -24px}.icon-barcode{background-position:-456px -24px}.icon-tag{background-position:0 -48px}.icon-tags{background-position:-25px -48px}.icon-book{background-position:-48px -48px}.icon-bookmark{background-position:-72px -48px}.icon-print{background-position:-96px -48px}.icon-camera{background-position:-120px -48px}.icon-font{background-position:-144px -48px}.icon-bold{background-position:-167px -48px}.icon-italic{background-position:-192px -48px}.icon-text-height{background-position:-216px -48px}.icon-text-width{background-position:-240px -48px}.icon-align-left{background-position:-264px -48px}.icon-align-center{background-position:-288px -48px}.icon-align-right{background-position:-312px -48px}.icon-align-justify{background-position:-336px -48px}.icon-list{background-position:-360px -48px}.icon-indent-left{background-position:-384px -48px}.icon-indent-right{background-position:-408px -48px}.icon-facetime-video{background-position:-432px -48px}.icon-picture{background-position:-456px -48px}.icon-pencil{background-position:0 -72px}.icon-map-marker{background-position:-24px -72px}.icon-adjust{background-position:-48px -72px}.icon-tint{background-position:-72px -72px}.icon-edit{background-position:-96px -72px}.icon-share{background-position:-120px -72px}.icon-check{background-position:-144px -72px}.icon-move{background-position:-168px -72px}.icon-step-backward{background-position:-192px -72px}.icon-fast-backward{background-position:-216px -72px}.icon-backward{background-position:-240px -72px}.icon-play{background-position:-264px -72px}.icon-pause{background-position:-288px -72px}.icon-stop{background-position:-312px -72px}.icon-forward{background-position:-336px -72px}.icon-fast-forward{background-position:-360px -72px}.icon-step-forward{background-position:-384px -72px}.icon-eject{background-position:-408px -72px}.icon-chevron-left{background-position:-432px -72px}.icon-chevron-right{background-position:-456px -72px}.icon-plus-sign{background-position:0 -96px}.icon-minus-sign{background-position:-24px -96px}.icon-remove-sign{background-position:-48px -96px}.icon-ok-sign{background-position:-72px -96px}.icon-question-sign{background-position:-96px -96px}.icon-info-sign{background-position:-120px -96px}.icon-screenshot{background-position:-144px -96px}.icon-remove-circle{background-position:-168px -96px}.icon-ok-circle{background-position:-192px -96px}.icon-ban-circle{background-position:-216px -96px}.icon-arrow-left{background-position:-240px -96px}.icon-arrow-right{background-position:-264px -96px}.icon-arrow-up{background-position:-289px -96px}.icon-arrow-down{background-position:-312px -96px}.icon-share-alt{background-position:-336px -96px}.icon-resize-full{background-position:-360px -96px}.icon-resize-small{background-position:-384px -96px}.icon-plus{background-position:-408px -96px}.icon-minus{background-position:-433px -96px}.icon-asterisk{background-position:-456px -96px}.icon-exclamation-sign{background-position:0 -120px}.icon-gift{background-position:-24px -120px}.icon-leaf{background-position:-48px -120px}.icon-fire{background-position:-72px -120px}.icon-eye-open{background-position:-96px -120px}.icon-eye-close{background-position:-120px -120px}.icon-warning-sign{background-position:-144px -120px}.icon-plane{background-position:-168px -120px}.icon-calendar{background-position:-192px -120px}.icon-random{width:16px;background-position:-216px -120px}.icon-comment{background-position:-240px -120px}.icon-magnet{background-position:-264px -120px}.icon-chevron-up{background-position:-288px -120px}.icon-chevron-down{background-position:-313px -119px}.icon-retweet{background-position:-336px -120px}.icon-shopping-cart{background-position:-360px -120px}.icon-folder-close{width:16px;background-position:-384px -120px}.icon-folder-open{width:16px;background-position:-408px -120px}.icon-resize-vertical{background-position:-432px -119px}.icon-resize-horizontal{background-position:-456px -118px}.icon-hdd{background-position:0 -144px}.icon-bullhorn{background-position:-24px -144px}.icon-bell{background-position:-48px -144px}.icon-certificate{background-position:-72px -144px}.icon-thumbs-up{background-position:-96px -144px}.icon-thumbs-down{background-position:-120px -144px}.icon-hand-right{background-position:-144px -144px}.icon-hand-left{background-position:-168px -144px}.icon-hand-up{background-position:-192px -144px}.icon-hand-down{background-position:-216px -144px}.icon-circle-arrow-right{background-position:-240px -144px}.icon-circle-arrow-left{background-position:-264px -144px}.icon-circle-arrow-up{background-position:-288px -144px}.icon-circle-arrow-down{background-position:-312px -144px}.icon-globe{background-position:-336px -144px}.icon-wrench{background-position:-360px -144px}.icon-tasks{background-position:-384px -144px}.icon-filter{background-position:-408px -144px}.icon-briefcase{background-position:-432px -144px}.icon-fullscreen{background-position:-456px -144px}.dropup,.dropdown{position:relative}.dropdown-toggle{*margin-bottom:-3px}.dropdown-toggle:active,.open .dropdown-toggle{outline:0}.caret{display:inline-block;width:0;height:0;vertical-align:top;border-top:4px solid #000;border-right:4px solid transparent;border-left:4px solid transparent;content:""}.dropdown .caret{margin-top:8px;margin-left:2px}.dropdown-menu{position:absolute;top:100%;left:0;z-index:1000;display:none;float:left;min-width:160px;padding:5px 0;margin:2px 0 0;list-style:none;background-color:#fff;border:1px solid #ccc;border:1px solid rgba(0,0,0,0.2);*border-right-width:2px;*border-bottom-width:2px;-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px;-webkit-box-shadow:0 5px 10px rgba(0,0,0,0.2);-moz-box-shadow:0 5px 10px rgba(0,0,0,0.2);box-shadow:0 5px 10px rgba(0,0,0,0.2);-webkit-background-clip:padding-box;-moz-background-clip:padding;background-clip:padding-box}.dropdown-menu.pull-right{right:0;left:auto}.dropdown-menu .divider{*width:100%;height:1px;margin:9px 1px;*margin:-5px 0 5px;overflow:hidden;background-color:#e5e5e5;border-bottom:1px solid #fff}.dropdown-menu>li>a{display:block;padding:3px 20px;clear:both;font-weight:normal;line-height:20px;color:#333;white-space:nowrap}.dropdown-menu>li>a:hover,.dropdown-menu>li>a:focus,.dropdown-submenu:hover>a,.dropdown-submenu:focus>a{color:#fff;text-decoration:none;background-color:#0081c2;background-image:-moz-linear-gradient(top,#08c,#0077b3);background-image:-webkit-gradient(linear,0 0,0 100%,from(#08c),to(#0077b3));background-image:-webkit-linear-gradient(top,#08c,#0077b3);background-image:-o-linear-gradient(top,#08c,#0077b3);background-image:linear-gradient(to bottom,#08c,#0077b3);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff0088cc',endColorstr='#ff0077b3',GradientType=0)}.dropdown-menu>.active>a,.dropdown-menu>.active>a:hover,.dropdown-menu>.active>a:focus{color:#fff;text-decoration:none;background-color:#0081c2;background-image:-moz-linear-gradient(top,#08c,#0077b3);background-image:-webkit-gradient(linear,0 0,0 100%,from(#08c),to(#0077b3));background-image:-webkit-linear-gradient(top,#08c,#0077b3);background-image:-o-linear-gradient(top,#08c,#0077b3);background-image:linear-gradient(to bottom,#08c,#0077b3);background-repeat:repeat-x;outline:0;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff0088cc',endColorstr='#ff0077b3',GradientType=0)}.dropdown-menu>.disabled>a,.dropdown-menu>.disabled>a:hover,.dropdown-menu>.disabled>a:focus{color:#999}.dropdown-menu>.disabled>a:hover,.dropdown-menu>.disabled>a:focus{text-decoration:none;cursor:default;background-color:transparent;background-image:none;filter:progid:DXImageTransform.Microsoft.gradient(enabled=false)}.open{*z-index:1000}.open>.dropdown-menu{display:block}.pull-right>.dropdown-menu{right:0;left:auto}.dropup .caret,.navbar-fixed-bottom .dropdown .caret{border-top:0;border-bottom:4px solid #000;content:""}.dropup .dropdown-menu,.navbar-fixed-bottom .dropdown .dropdown-menu{top:auto;bottom:100%;margin-bottom:1px}.dropdown-submenu{position:relative}.dropdown-submenu>.dropdown-menu{top:0;left:100%;margin-top:-6px;margin-left:-1px;-webkit-border-radius:0 6px 6px 6px;-moz-border-radius:0 6px 6px 6px;border-radius:0 6px 6px 6px}.dropdown-submenu:hover>.dropdown-menu{display:block}.dropup .dropdown-submenu>.dropdown-menu{top:auto;bottom:0;margin-top:0;margin-bottom:-2px;-webkit-border-radius:5px 5px 5px 0;-moz-border-radius:5px 5px 5px 0;border-radius:5px 5px 5px 0}.dropdown-submenu>a:after{display:block;float:right;width:0;height:0;margin-top:5px;margin-right:-10px;border-color:transparent;border-left-color:#ccc;border-style:solid;border-width:5px 0 5px 5px;content:" "}.dropdown-submenu:hover>a:after{border-left-color:#fff}.dropdown-submenu.pull-left{float:none}.dropdown-submenu.pull-left>.dropdown-menu{left:-100%;margin-left:10px;-webkit-border-radius:6px 0 6px 6px;-moz-border-radius:6px 0 6px 6px;border-radius:6px 0 6px 6px}.dropdown .dropdown-menu .nav-header{padding-right:20px;padding-left:20px}.typeahead{z-index:1051;margin-top:2px;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}.well{min-height:20px;padding:19px;margin-bottom:20px;background-color:#f5f5f5;border:1px solid #e3e3e3;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.05);-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.05);box-shadow:inset 0 1px 1px rgba(0,0,0,0.05)}.well blockquote{border-color:#ddd;border-color:rgba(0,0,0,0.15)}.well-large{padding:24px;-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px}.well-small{padding:9px;-webkit-border-radius:3px;-moz-border-radius:3px;border-radius:3px}.fade{opacity:0;-webkit-transition:opacity .15s linear;-moz-transition:opacity .15s linear;-o-transition:opacity .15s linear;transition:opacity .15s linear}.fade.in{opacity:1}.collapse{position:relative;height:0;overflow:hidden;-webkit-transition:height .35s ease;-moz-transition:height .35s ease;-o-transition:height .35s ease;transition:height .35s ease}.collapse.in{height:auto}.close{float:right;font-size:20px;font-weight:bold;line-height:20px;color:#000;text-shadow:0 1px 0 #fff;opacity:.2;filter:alpha(opacity=20)}.close:hover,.close:focus{color:#000;text-decoration:none;cursor:pointer;opacity:.4;filter:alpha(opacity=40)}button.close{padding:0;cursor:pointer;background:transparent;border:0;-webkit-appearance:none}.btn{display:inline-block;*display:inline;padding:4px 12px;margin-bottom:0;*margin-left:.3em;font-size:14px;line-height:20px;color:#333;text-align:center;text-shadow:0 1px 1px rgba(255,255,255,0.75);vertical-align:middle;cursor:pointer;background-color:#f5f5f5;*background-color:#e6e6e6;background-image:-moz-linear-gradient(top,#fff,#e6e6e6);background-image:-webkit-gradient(linear,0 0,0 100%,from(#fff),to(#e6e6e6));background-image:-webkit-linear-gradient(top,#fff,#e6e6e6);background-image:-o-linear-gradient(top,#fff,#e6e6e6);background-image:linear-gradient(to bottom,#fff,#e6e6e6);background-repeat:repeat-x;border:1px solid #ccc;*border:0;border-color:#e6e6e6 #e6e6e6 #bfbfbf;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);border-bottom-color:#b3b3b3;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffffffff',endColorstr='#ffe6e6e6',GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false);*zoom:1;-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,0.2),0 1px 2px rgba(0,0,0,0.05);-moz-box-shadow:inset 0 1px 0 rgba(255,255,255,0.2),0 1px 2px rgba(0,0,0,0.05);box-shadow:inset 0 1px 0 rgba(255,255,255,0.2),0 1px 2px rgba(0,0,0,0.05)}.btn:hover,.btn:focus,.btn:active,.btn.active,.btn.disabled,.btn[disabled]{color:#333;background-color:#e6e6e6;*background-color:#d9d9d9}.btn:active,.btn.active{background-color:#ccc \9}.btn:first-child{*margin-left:0}.btn:hover,.btn:focus{color:#333;text-decoration:none;background-position:0 -15px;-webkit-transition:background-position .1s linear;-moz-transition:background-position .1s linear;-o-transition:background-position .1s linear;transition:background-position .1s linear}.btn:focus{outline:thin dotted #333;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}.btn.active,.btn:active{background-image:none;outline:0;-webkit-box-shadow:inset 0 2px 4px rgba(0,0,0,0.15),0 1px 2px rgba(0,0,0,0.05);-moz-box-shadow:inset 0 2px 4px rgba(0,0,0,0.15),0 1px 2px rgba(0,0,0,0.05);box-shadow:inset 0 2px 4px rgba(0,0,0,0.15),0 1px 2px rgba(0,0,0,0.05)}.btn.disabled,.btn[disabled]{cursor:default;background-image:none;opacity:.65;filter:alpha(opacity=65);-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none}.btn-large{padding:11px 19px;font-size:17.5px;-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px}.btn-large [class^="icon-"],.btn-large [class*=" icon-"]{margin-top:4px}.btn-small{padding:2px 10px;font-size:11.9px;-webkit-border-radius:3px;-moz-border-radius:3px;border-radius:3px}.btn-small [class^="icon-"],.btn-small [class*=" icon-"]{margin-top:0}.btn-mini [class^="icon-"],.btn-mini [class*=" icon-"]{margin-top:-1px}.btn-mini{padding:0 6px;font-size:10.5px;-webkit-border-radius:3px;-moz-border-radius:3px;border-radius:3px}.btn-block{display:block;width:100%;padding-right:0;padding-left:0;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}.btn-block+.btn-block{margin-top:5px}input[type="submit"].btn-block,input[type="reset"].btn-block,input[type="button"].btn-block{width:100%}.btn-primary.active,.btn-warning.active,.btn-danger.active,.btn-success.active,.btn-info.active,.btn-inverse.active{color:rgba(255,255,255,0.75)}.btn-primary{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,0.25);background-color:#006dcc;*background-color:#04c;background-image:-moz-linear-gradient(top,#08c,#04c);background-image:-webkit-gradient(linear,0 0,0 100%,from(#08c),to(#04c));background-image:-webkit-linear-gradient(top,#08c,#04c);background-image:-o-linear-gradient(top,#08c,#04c);background-image:linear-gradient(to bottom,#08c,#04c);background-repeat:repeat-x;border-color:#04c #04c #002a80;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff0088cc',endColorstr='#ff0044cc',GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false)}.btn-primary:hover,.btn-primary:focus,.btn-primary:active,.btn-primary.active,.btn-primary.disabled,.btn-primary[disabled]{color:#fff;background-color:#04c;*background-color:#003bb3}.btn-primary:active,.btn-primary.active{background-color:#039 \9}.btn-warning{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,0.25);background-color:#faa732;*background-color:#f89406;background-image:-moz-linear-gradient(top,#fbb450,#f89406);background-image:-webkit-gradient(linear,0 0,0 100%,from(#fbb450),to(#f89406));background-image:-webkit-linear-gradient(top,#fbb450,#f89406);background-image:-o-linear-gradient(top,#fbb450,#f89406);background-image:linear-gradient(to bottom,#fbb450,#f89406);background-repeat:repeat-x;border-color:#f89406 #f89406 #ad6704;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#fffbb450',endColorstr='#fff89406',GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false)}.btn-warning:hover,.btn-warning:focus,.btn-warning:active,.btn-warning.active,.btn-warning.disabled,.btn-warning[disabled]{color:#fff;background-color:#f89406;*background-color:#df8505}.btn-warning:active,.btn-warning.active{background-color:#c67605 \9}.btn-danger{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,0.25);background-color:#da4f49;*background-color:#bd362f;background-image:-moz-linear-gradient(top,#ee5f5b,#bd362f);background-image:-webkit-gradient(linear,0 0,0 100%,from(#ee5f5b),to(#bd362f));background-image:-webkit-linear-gradient(top,#ee5f5b,#bd362f);background-image:-o-linear-gradient(top,#ee5f5b,#bd362f);background-image:linear-gradient(to bottom,#ee5f5b,#bd362f);background-repeat:repeat-x;border-color:#bd362f #bd362f #802420;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffee5f5b',endColorstr='#ffbd362f',GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false)}.btn-danger:hover,.btn-danger:focus,.btn-danger:active,.btn-danger.active,.btn-danger.disabled,.btn-danger[disabled]{color:#fff;background-color:#bd362f;*background-color:#a9302a}.btn-danger:active,.btn-danger.active{background-color:#942a25 \9}.btn-success{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,0.25);background-color:#5bb75b;*background-color:#51a351;background-image:-moz-linear-gradient(top,#62c462,#51a351);background-image:-webkit-gradient(linear,0 0,0 100%,from(#62c462),to(#51a351));background-image:-webkit-linear-gradient(top,#62c462,#51a351);background-image:-o-linear-gradient(top,#62c462,#51a351);background-image:linear-gradient(to bottom,#62c462,#51a351);background-repeat:repeat-x;border-color:#51a351 #51a351 #387038;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff62c462',endColorstr='#ff51a351',GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false)}.btn-success:hover,.btn-success:focus,.btn-success:active,.btn-success.active,.btn-success.disabled,.btn-success[disabled]{color:#fff;background-color:#51a351;*background-color:#499249}.btn-success:active,.btn-success.active{background-color:#408140 \9}.btn-info{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,0.25);background-color:#49afcd;*background-color:#2f96b4;background-image:-moz-linear-gradient(top,#5bc0de,#2f96b4);background-image:-webkit-gradient(linear,0 0,0 100%,from(#5bc0de),to(#2f96b4));background-image:-webkit-linear-gradient(top,#5bc0de,#2f96b4);background-image:-o-linear-gradient(top,#5bc0de,#2f96b4);background-image:linear-gradient(to bottom,#5bc0de,#2f96b4);background-repeat:repeat-x;border-color:#2f96b4 #2f96b4 #1f6377;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff5bc0de',endColorstr='#ff2f96b4',GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false)}.btn-info:hover,.btn-info:focus,.btn-info:active,.btn-info.active,.btn-info.disabled,.btn-info[disabled]{color:#fff;background-color:#2f96b4;*background-color:#2a85a0}.btn-info:active,.btn-info.active{background-color:#24748c \9}.btn-inverse{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,0.25);background-color:#363636;*background-color:#222;background-image:-moz-linear-gradient(top,#444,#222);background-image:-webkit-gradient(linear,0 0,0 100%,from(#444),to(#222));background-image:-webkit-linear-gradient(top,#444,#222);background-image:-o-linear-gradient(top,#444,#222);background-image:linear-gradient(to bottom,#444,#222);background-repeat:repeat-x;border-color:#222 #222 #000;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff444444',endColorstr='#ff222222',GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false)}.btn-inverse:hover,.btn-inverse:focus,.btn-inverse:active,.btn-inverse.active,.btn-inverse.disabled,.btn-inverse[disabled]{color:#fff;background-color:#222;*background-color:#151515}.btn-inverse:active,.btn-inverse.active{background-color:#080808 \9}button.btn,input[type="submit"].btn{*padding-top:3px;*padding-bottom:3px}button.btn::-moz-focus-inner,input[type="submit"].btn::-moz-focus-inner{padding:0;border:0}button.btn.btn-large,input[type="submit"].btn.btn-large{*padding-top:7px;*padding-bottom:7px}button.btn.btn-small,input[type="submit"].btn.btn-small{*padding-top:3px;*padding-bottom:3px}button.btn.btn-mini,input[type="submit"].btn.btn-mini{*padding-top:1px;*padding-bottom:1px}.btn-link,.btn-link:active,.btn-link[disabled]{background-color:transparent;background-image:none;-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none}.btn-link{color:#08c;cursor:pointer;border-color:transparent;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.btn-link:hover,.btn-link:focus{color:#005580;text-decoration:underline;background-color:transparent}.btn-link[disabled]:hover,.btn-link[disabled]:focus{color:#333;text-decoration:none}.btn-group{position:relative;display:inline-block;*display:inline;*margin-left:.3em;font-size:0;white-space:nowrap;vertical-align:middle;*zoom:1}.btn-group:first-child{*margin-left:0}.btn-group+.btn-group{margin-left:5px}.btn-toolbar{margin-top:10px;margin-bottom:10px;font-size:0}.btn-toolbar>.btn+.btn,.btn-toolbar>.btn-group+.btn,.btn-toolbar>.btn+.btn-group{margin-left:5px}.btn-group>.btn{position:relative;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.btn-group>.btn+.btn{margin-left:-1px}.btn-group>.btn,.btn-group>.dropdown-menu,.btn-group>.popover{font-size:14px}.btn-group>.btn-mini{font-size:10.5px}.btn-group>.btn-small{font-size:11.9px}.btn-group>.btn-large{font-size:17.5px}.btn-group>.btn:first-child{margin-left:0;-webkit-border-bottom-left-radius:4px;border-bottom-left-radius:4px;-webkit-border-top-left-radius:4px;border-top-left-radius:4px;-moz-border-radius-bottomleft:4px;-moz-border-radius-topleft:4px}.btn-group>.btn:last-child,.btn-group>.dropdown-toggle{-webkit-border-top-right-radius:4px;border-top-right-radius:4px;-webkit-border-bottom-right-radius:4px;border-bottom-right-radius:4px;-moz-border-radius-topright:4px;-moz-border-radius-bottomright:4px}.btn-group>.btn.large:first-child{margin-left:0;-webkit-border-bottom-left-radius:6px;border-bottom-left-radius:6px;-webkit-border-top-left-radius:6px;border-top-left-radius:6px;-moz-border-radius-bottomleft:6px;-moz-border-radius-topleft:6px}.btn-group>.btn.large:last-child,.btn-group>.large.dropdown-toggle{-webkit-border-top-right-radius:6px;border-top-right-radius:6px;-webkit-border-bottom-right-radius:6px;border-bottom-right-radius:6px;-moz-border-radius-topright:6px;-moz-border-radius-bottomright:6px}.btn-group>.btn:hover,.btn-group>.btn:focus,.btn-group>.btn:active,.btn-group>.btn.active{z-index:2}.btn-group .dropdown-toggle:active,.btn-group.open .dropdown-toggle{outline:0}.btn-group>.btn+.dropdown-toggle{*padding-top:5px;padding-right:8px;*padding-bottom:5px;padding-left:8px;-webkit-box-shadow:inset 1px 0 0 rgba(255,255,255,0.125),inset 0 1px 0 rgba(255,255,255,0.2),0 1px 2px rgba(0,0,0,0.05);-moz-box-shadow:inset 1px 0 0 rgba(255,255,255,0.125),inset 0 1px 0 rgba(255,255,255,0.2),0 1px 2px rgba(0,0,0,0.05);box-shadow:inset 1px 0 0 rgba(255,255,255,0.125),inset 0 1px 0 rgba(255,255,255,0.2),0 1px 2px rgba(0,0,0,0.05)}.btn-group>.btn-mini+.dropdown-toggle{*padding-top:2px;padding-right:5px;*padding-bottom:2px;padding-left:5px}.btn-group>.btn-small+.dropdown-toggle{*padding-top:5px;*padding-bottom:4px}.btn-group>.btn-large+.dropdown-toggle{*padding-top:7px;padding-right:12px;*padding-bottom:7px;padding-left:12px}.btn-group.open .dropdown-toggle{background-image:none;-webkit-box-shadow:inset 0 2px 4px rgba(0,0,0,0.15),0 1px 2px rgba(0,0,0,0.05);-moz-box-shadow:inset 0 2px 4px rgba(0,0,0,0.15),0 1px 2px rgba(0,0,0,0.05);box-shadow:inset 0 2px 4px rgba(0,0,0,0.15),0 1px 2px rgba(0,0,0,0.05)}.btn-group.open .btn.dropdown-toggle{background-color:#e6e6e6}.btn-group.open .btn-primary.dropdown-toggle{background-color:#04c}.btn-group.open .btn-warning.dropdown-toggle{background-color:#f89406}.btn-group.open .btn-danger.dropdown-toggle{background-color:#bd362f}.btn-group.open .btn-success.dropdown-toggle{background-color:#51a351}.btn-group.open .btn-info.dropdown-toggle{background-color:#2f96b4}.btn-group.open .btn-inverse.dropdown-toggle{background-color:#222}.btn .caret{margin-top:8px;margin-left:0}.btn-large .caret{margin-top:6px}.btn-large .caret{border-top-width:5px;border-right-width:5px;border-left-width:5px}.btn-mini .caret,.btn-small .caret{margin-top:8px}.dropup .btn-large .caret{border-bottom-width:5px}.btn-primary .caret,.btn-warning .caret,.btn-danger .caret,.btn-info .caret,.btn-success .caret,.btn-inverse .caret{border-top-color:#fff;border-bottom-color:#fff}.btn-group-vertical{display:inline-block;*display:inline;*zoom:1}.btn-group-vertical>.btn{display:block;float:none;max-width:100%;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.btn-group-vertical>.btn+.btn{margin-top:-1px;margin-left:0}.btn-group-vertical>.btn:first-child{-webkit-border-radius:4px 4px 0 0;-moz-border-radius:4px 4px 0 0;border-radius:4px 4px 0 0}.btn-group-vertical>.btn:last-child{-webkit-border-radius:0 0 4px 4px;-moz-border-radius:0 0 4px 4px;border-radius:0 0 4px 4px}.btn-group-vertical>.btn-large:first-child{-webkit-border-radius:6px 6px 0 0;-moz-border-radius:6px 6px 0 0;border-radius:6px 6px 0 0}.btn-group-vertical>.btn-large:last-child{-webkit-border-radius:0 0 6px 6px;-moz-border-radius:0 0 6px 6px;border-radius:0 0 6px 6px}.alert{padding:8px 35px 8px 14px;margin-bottom:20px;text-shadow:0 1px 0 rgba(255,255,255,0.5);background-color:#fcf8e3;border:1px solid #fbeed5;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}.alert,.alert h4{color:#c09853}.alert h4{margin:0}.alert .close{position:relative;top:-2px;right:-21px;line-height:20px}.alert-success{color:#468847;background-color:#dff0d8;border-color:#d6e9c6}.alert-success h4{color:#468847}.alert-danger,.alert-error{color:#b94a48;background-color:#f2dede;border-color:#eed3d7}.alert-danger h4,.alert-error h4{color:#b94a48}.alert-info{color:#3a87ad;background-color:#d9edf7;border-color:#bce8f1}.alert-info h4{color:#3a87ad}.alert-block{padding-top:14px;padding-bottom:14px}.alert-block>p,.alert-block>ul{margin-bottom:0}.alert-block p+p{margin-top:5px}.nav{margin-bottom:20px;margin-left:0;list-style:none}.nav>li>a{display:block}.nav>li>a:hover,.nav>li>a:focus{text-decoration:none;background-color:#eee}.nav>li>a>img{max-width:none}.nav>.pull-right{float:right}.nav-header{display:block;padding:3px 15px;font-size:11px;font-weight:bold;line-height:20px;color:#999;text-shadow:0 1px 0 rgba(255,255,255,0.5);text-transform:uppercase}.nav li+.nav-header{margin-top:9px}.nav-list{padding-right:15px;padding-left:15px;margin-bottom:0}.nav-list>li>a,.nav-list .nav-header{margin-right:-15px;margin-left:-15px;text-shadow:0 1px 0 rgba(255,255,255,0.5)}.nav-list>li>a{padding:3px 15px}.nav-list>.active>a,.nav-list>.active>a:hover,.nav-list>.active>a:focus{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,0.2);background-color:#08c}.nav-list [class^="icon-"],.nav-list [class*=" icon-"]{margin-right:2px}.nav-list .divider{*width:100%;height:1px;margin:9px 1px;*margin:-5px 0 5px;overflow:hidden;background-color:#e5e5e5;border-bottom:1px solid #fff}.nav-tabs,.nav-pills{*zoom:1}.nav-tabs:before,.nav-pills:before,.nav-tabs:after,.nav-pills:after{display:table;line-height:0;content:""}.nav-tabs:after,.nav-pills:after{clear:both}.nav-tabs>li,.nav-pills>li{float:left}.nav-tabs>li>a,.nav-pills>li>a{padding-right:12px;padding-left:12px;margin-right:2px;line-height:14px}.nav-tabs{border-bottom:1px solid #ddd}.nav-tabs>li{margin-bottom:-1px}.nav-tabs>li>a{padding-top:8px;padding-bottom:8px;line-height:20px;border:1px solid transparent;-webkit-border-radius:4px 4px 0 0;-moz-border-radius:4px 4px 0 0;border-radius:4px 4px 0 0}.nav-tabs>li>a:hover,.nav-tabs>li>a:focus{border-color:#eee #eee #ddd}.nav-tabs>.active>a,.nav-tabs>.active>a:hover,.nav-tabs>.active>a:focus{color:#555;cursor:default;background-color:#fff;border:1px solid #ddd;border-bottom-color:transparent}.nav-pills>li>a{padding-top:8px;padding-bottom:8px;margin-top:2px;margin-bottom:2px;-webkit-border-radius:5px;-moz-border-radius:5px;border-radius:5px}.nav-pills>.active>a,.nav-pills>.active>a:hover,.nav-pills>.active>a:focus{color:#fff;background-color:#08c}.nav-stacked>li{float:none}.nav-stacked>li>a{margin-right:0}.nav-tabs.nav-stacked{border-bottom:0}.nav-tabs.nav-stacked>li>a{border:1px solid #ddd;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.nav-tabs.nav-stacked>li:first-child>a{-webkit-border-top-right-radius:4px;border-top-right-radius:4px;-webkit-border-top-left-radius:4px;border-top-left-radius:4px;-moz-border-radius-topright:4px;-moz-border-radius-topleft:4px}.nav-tabs.nav-stacked>li:last-child>a{-webkit-border-bottom-right-radius:4px;border-bottom-right-radius:4px;-webkit-border-bottom-left-radius:4px;border-bottom-left-radius:4px;-moz-border-radius-bottomright:4px;-moz-border-radius-bottomleft:4px}.nav-tabs.nav-stacked>li>a:hover,.nav-tabs.nav-stacked>li>a:focus{z-index:2;border-color:#ddd}.nav-pills.nav-stacked>li>a{margin-bottom:3px}.nav-pills.nav-stacked>li:last-child>a{margin-bottom:1px}.nav-tabs .dropdown-menu{-webkit-border-radius:0 0 6px 6px;-moz-border-radius:0 0 6px 6px;border-radius:0 0 6px 6px}.nav-pills .dropdown-menu{-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px}.nav .dropdown-toggle .caret{margin-top:6px;border-top-color:#08c;border-bottom-color:#08c}.nav .dropdown-toggle:hover .caret,.nav .dropdown-toggle:focus .caret{border-top-color:#005580;border-bottom-color:#005580}.nav-tabs .dropdown-toggle .caret{margin-top:8px}.nav .active .dropdown-toggle .caret{border-top-color:#fff;border-bottom-color:#fff}.nav-tabs .active .dropdown-toggle .caret{border-top-color:#555;border-bottom-color:#555}.nav>.dropdown.active>a:hover,.nav>.dropdown.active>a:focus{cursor:pointer}.nav-tabs .open .dropdown-toggle,.nav-pills .open .dropdown-toggle,.nav>li.dropdown.open.active>a:hover,.nav>li.dropdown.open.active>a:focus{color:#fff;background-color:#999;border-color:#999}.nav li.dropdown.open .caret,.nav li.dropdown.open.active .caret,.nav li.dropdown.open a:hover .caret,.nav li.dropdown.open a:focus .caret{border-top-color:#fff;border-bottom-color:#fff;opacity:1;filter:alpha(opacity=100)}.tabs-stacked .open>a:hover,.tabs-stacked .open>a:focus{border-color:#999}.tabbable{*zoom:1}.tabbable:before,.tabbable:after{display:table;line-height:0;content:""}.tabbable:after{clear:both}.tab-content{overflow:auto}.tabs-below>.nav-tabs,.tabs-right>.nav-tabs,.tabs-left>.nav-tabs{border-bottom:0}.tab-content>.tab-pane,.pill-content>.pill-pane{display:none}.tab-content>.active,.pill-content>.active{display:block}.tabs-below>.nav-tabs{border-top:1px solid #ddd}.tabs-below>.nav-tabs>li{margin-top:-1px;margin-bottom:0}.tabs-below>.nav-tabs>li>a{-webkit-border-radius:0 0 4px 4px;-moz-border-radius:0 0 4px 4px;border-radius:0 0 4px 4px}.tabs-below>.nav-tabs>li>a:hover,.tabs-below>.nav-tabs>li>a:focus{border-top-color:#ddd;border-bottom-color:transparent}.tabs-below>.nav-tabs>.active>a,.tabs-below>.nav-tabs>.active>a:hover,.tabs-below>.nav-tabs>.active>a:focus{border-color:transparent #ddd #ddd #ddd}.tabs-left>.nav-tabs>li,.tabs-right>.nav-tabs>li{float:none}.tabs-left>.nav-tabs>li>a,.tabs-right>.nav-tabs>li>a{min-width:74px;margin-right:0;margin-bottom:3px}.tabs-left>.nav-tabs{float:left;margin-right:19px;border-right:1px solid #ddd}.tabs-left>.nav-tabs>li>a{margin-right:-1px;-webkit-border-radius:4px 0 0 4px;-moz-border-radius:4px 0 0 4px;border-radius:4px 0 0 4px}.tabs-left>.nav-tabs>li>a:hover,.tabs-left>.nav-tabs>li>a:focus{border-color:#eee #ddd #eee #eee}.tabs-left>.nav-tabs .active>a,.tabs-left>.nav-tabs .active>a:hover,.tabs-left>.nav-tabs .active>a:focus{border-color:#ddd transparent #ddd #ddd;*border-right-color:#fff}.tabs-right>.nav-tabs{float:right;margin-left:19px;border-left:1px solid #ddd}.tabs-right>.nav-tabs>li>a{margin-left:-1px;-webkit-border-radius:0 4px 4px 0;-moz-border-radius:0 4px 4px 0;border-radius:0 4px 4px 0}.tabs-right>.nav-tabs>li>a:hover,.tabs-right>.nav-tabs>li>a:focus{border-color:#eee #eee #eee #ddd}.tabs-right>.nav-tabs .active>a,.tabs-right>.nav-tabs .active>a:hover,.tabs-right>.nav-tabs .active>a:focus{border-color:#ddd #ddd #ddd transparent;*border-left-color:#fff}.nav>.disabled>a{color:#999}.nav>.disabled>a:hover,.nav>.disabled>a:focus{text-decoration:none;cursor:default;background-color:transparent}.navbar{*position:relative;*z-index:2;margin-bottom:20px;overflow:visible}.navbar-inner{min-height:40px;padding-right:20px;padding-left:20px;background-color:#fafafa;background-image:-moz-linear-gradient(top,#fff,#f2f2f2);background-image:-webkit-gradient(linear,0 0,0 100%,from(#fff),to(#f2f2f2));background-image:-webkit-linear-gradient(top,#fff,#f2f2f2);background-image:-o-linear-gradient(top,#fff,#f2f2f2);background-image:linear-gradient(to bottom,#fff,#f2f2f2);background-repeat:repeat-x;border:1px solid #d4d4d4;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffffffff',endColorstr='#fff2f2f2',GradientType=0);*zoom:1;-webkit-box-shadow:0 1px 4px rgba(0,0,0,0.065);-moz-box-shadow:0 1px 4px rgba(0,0,0,0.065);box-shadow:0 1px 4px rgba(0,0,0,0.065)}.navbar-inner:before,.navbar-inner:after{display:table;line-height:0;content:""}.navbar-inner:after{clear:both}.navbar .container{width:auto}.nav-collapse.collapse{height:auto;overflow:visible}.navbar .brand{display:block;float:left;padding:10px 20px 10px;margin-left:-20px;font-size:20px;font-weight:200;color:#777;text-shadow:0 1px 0 #fff}.navbar .brand:hover,.navbar .brand:focus{text-decoration:none}.navbar-text{margin-bottom:0;line-height:40px;color:#777}.navbar-link{color:#777}.navbar-link:hover,.navbar-link:focus{color:#333}.navbar .divider-vertical{height:40px;margin:0 9px;border-right:1px solid #fff;border-left:1px solid #f2f2f2}.navbar .btn,.navbar .btn-group{margin-top:5px}.navbar .btn-group .btn,.navbar .input-prepend .btn,.navbar .input-append .btn,.navbar .input-prepend .btn-group,.navbar .input-append .btn-group{margin-top:0}.navbar-form{margin-bottom:0;*zoom:1}.navbar-form:before,.navbar-form:after{display:table;line-height:0;content:""}.navbar-form:after{clear:both}.navbar-form input,.navbar-form select,.navbar-form .radio,.navbar-form .checkbox{margin-top:5px}.navbar-form input,.navbar-form select,.navbar-form .btn{display:inline-block;margin-bottom:0}.navbar-form input[type="image"],.navbar-form input[type="checkbox"],.navbar-form input[type="radio"]{margin-top:3px}.navbar-form .input-append,.navbar-form .input-prepend{margin-top:5px;white-space:nowrap}.navbar-form .input-append input,.navbar-form .input-prepend input{margin-top:0}.navbar-search{position:relative;float:left;margin-top:5px;margin-bottom:0}.navbar-search .search-query{padding:4px 14px;margin-bottom:0;font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;font-size:13px;font-weight:normal;line-height:1;-webkit-border-radius:15px;-moz-border-radius:15px;border-radius:15px}.navbar-static-top{position:static;margin-bottom:0}.navbar-static-top .navbar-inner{-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.navbar-fixed-top,.navbar-fixed-bottom{position:fixed;right:0;left:0;z-index:1030;margin-bottom:0}.navbar-fixed-top .navbar-inner,.navbar-static-top .navbar-inner{border-width:0 0 1px}.navbar-fixed-bottom .navbar-inner{border-width:1px 0 0}.navbar-fixed-top .navbar-inner,.navbar-fixed-bottom .navbar-inner{padding-right:0;padding-left:0;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.navbar-static-top .container,.navbar-fixed-top .container,.navbar-fixed-bottom .container{width:940px}.navbar-fixed-top{top:0}.navbar-fixed-top .navbar-inner,.navbar-static-top .navbar-inner{-webkit-box-shadow:0 1px 10px rgba(0,0,0,0.1);-moz-box-shadow:0 1px 10px rgba(0,0,0,0.1);box-shadow:0 1px 10px rgba(0,0,0,0.1)}.navbar-fixed-bottom{bottom:0}.navbar-fixed-bottom .navbar-inner{-webkit-box-shadow:0 -1px 10px rgba(0,0,0,0.1);-moz-box-shadow:0 -1px 10px rgba(0,0,0,0.1);box-shadow:0 -1px 10px rgba(0,0,0,0.1)}.navbar .nav{position:relative;left:0;display:block;float:left;margin:0 10px 0 0}.navbar .nav.pull-right{float:right;margin-right:0}.navbar .nav>li{float:left}.navbar .nav>li>a{float:none;padding:10px 15px 10px;color:#777;text-decoration:none;text-shadow:0 1px 0 #fff}.navbar .nav .dropdown-toggle .caret{margin-top:8px}.navbar .nav>li>a:focus,.navbar .nav>li>a:hover{color:#333;text-decoration:none;background-color:transparent}.navbar .nav>.active>a,.navbar .nav>.active>a:hover,.navbar .nav>.active>a:focus{color:#555;text-decoration:none;background-color:#e5e5e5;-webkit-box-shadow:inset 0 3px 8px rgba(0,0,0,0.125);-moz-box-shadow:inset 0 3px 8px rgba(0,0,0,0.125);box-shadow:inset 0 3px 8px rgba(0,0,0,0.125)}.navbar .btn-navbar{display:none;float:right;padding:7px 10px;margin-right:5px;margin-left:5px;color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,0.25);background-color:#ededed;*background-color:#e5e5e5;background-image:-moz-linear-gradient(top,#f2f2f2,#e5e5e5);background-image:-webkit-gradient(linear,0 0,0 100%,from(#f2f2f2),to(#e5e5e5));background-image:-webkit-linear-gradient(top,#f2f2f2,#e5e5e5);background-image:-o-linear-gradient(top,#f2f2f2,#e5e5e5);background-image:linear-gradient(to bottom,#f2f2f2,#e5e5e5);background-repeat:repeat-x;border-color:#e5e5e5 #e5e5e5 #bfbfbf;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#fff2f2f2',endColorstr='#ffe5e5e5',GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false);-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,0.1),0 1px 0 rgba(255,255,255,0.075);-moz-box-shadow:inset 0 1px 0 rgba(255,255,255,0.1),0 1px 0 rgba(255,255,255,0.075);box-shadow:inset 0 1px 0 rgba(255,255,255,0.1),0 1px 0 rgba(255,255,255,0.075)}.navbar .btn-navbar:hover,.navbar .btn-navbar:focus,.navbar .btn-navbar:active,.navbar .btn-navbar.active,.navbar .btn-navbar.disabled,.navbar .btn-navbar[disabled]{color:#fff;background-color:#e5e5e5;*background-color:#d9d9d9}.navbar .btn-navbar:active,.navbar .btn-navbar.active{background-color:#ccc \9}.navbar .btn-navbar .icon-bar{display:block;width:18px;height:2px;background-color:#f5f5f5;-webkit-border-radius:1px;-moz-border-radius:1px;border-radius:1px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,0.25);-moz-box-shadow:0 1px 0 rgba(0,0,0,0.25);box-shadow:0 1px 0 rgba(0,0,0,0.25)}.btn-navbar .icon-bar+.icon-bar{margin-top:3px}.navbar .nav>li>.dropdown-menu:before{position:absolute;top:-7px;left:9px;display:inline-block;border-right:7px solid transparent;border-bottom:7px solid #ccc;border-left:7px solid transparent;border-bottom-color:rgba(0,0,0,0.2);content:''}.navbar .nav>li>.dropdown-menu:after{position:absolute;top:-6px;left:10px;display:inline-block;border-right:6px solid transparent;border-bottom:6px solid #fff;border-left:6px solid transparent;content:''}.navbar-fixed-bottom .nav>li>.dropdown-menu:before{top:auto;bottom:-7px;border-top:7px solid #ccc;border-bottom:0;border-top-color:rgba(0,0,0,0.2)}.navbar-fixed-bottom .nav>li>.dropdown-menu:after{top:auto;bottom:-6px;border-top:6px solid #fff;border-bottom:0}.navbar .nav li.dropdown>a:hover .caret,.navbar .nav li.dropdown>a:focus .caret{border-top-color:#333;border-bottom-color:#333}.navbar .nav li.dropdown.open>.dropdown-toggle,.navbar .nav li.dropdown.active>.dropdown-toggle,.navbar .nav li.dropdown.open.active>.dropdown-toggle{color:#555;background-color:#e5e5e5}.navbar .nav li.dropdown>.dropdown-toggle .caret{border-top-color:#777;border-bottom-color:#777}.navbar .nav li.dropdown.open>.dropdown-toggle .caret,.navbar .nav li.dropdown.active>.dropdown-toggle .caret,.navbar .nav li.dropdown.open.active>.dropdown-toggle .caret{border-top-color:#555;border-bottom-color:#555}.navbar .pull-right>li>.dropdown-menu,.navbar .nav>li>.dropdown-menu.pull-right{right:0;left:auto}.navbar .pull-right>li>.dropdown-menu:before,.navbar .nav>li>.dropdown-menu.pull-right:before{right:12px;left:auto}.navbar .pull-right>li>.dropdown-menu:after,.navbar .nav>li>.dropdown-menu.pull-right:after{right:13px;left:auto}.navbar .pull-right>li>.dropdown-menu .dropdown-menu,.navbar .nav>li>.dropdown-menu.pull-right .dropdown-menu{right:100%;left:auto;margin-right:-1px;margin-left:0;-webkit-border-radius:6px 0 6px 6px;-moz-border-radius:6px 0 6px 6px;border-radius:6px 0 6px 6px}.navbar-inverse .navbar-inner{background-color:#1b1b1b;background-image:-moz-linear-gradient(top,#222,#111);background-image:-webkit-gradient(linear,0 0,0 100%,from(#222),to(#111));background-image:-webkit-linear-gradient(top,#222,#111);background-image:-o-linear-gradient(top,#222,#111);background-image:linear-gradient(to bottom,#222,#111);background-repeat:repeat-x;border-color:#252525;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff222222',endColorstr='#ff111111',GradientType=0)}.navbar-inverse .brand,.navbar-inverse .nav>li>a{color:#999;text-shadow:0 -1px 0 rgba(0,0,0,0.25)}.navbar-inverse .brand:hover,.navbar-inverse .nav>li>a:hover,.navbar-inverse .brand:focus,.navbar-inverse .nav>li>a:focus{color:#fff}.navbar-inverse .brand{color:#999}.navbar-inverse .navbar-text{color:#999}.navbar-inverse .nav>li>a:focus,.navbar-inverse .nav>li>a:hover{color:#fff;background-color:transparent}.navbar-inverse .nav .active>a,.navbar-inverse .nav .active>a:hover,.navbar-inverse .nav .active>a:focus{color:#fff;background-color:#111}.navbar-inverse .navbar-link{color:#999}.navbar-inverse .navbar-link:hover,.navbar-inverse .navbar-link:focus{color:#fff}.navbar-inverse .divider-vertical{border-right-color:#222;border-left-color:#111}.navbar-inverse .nav li.dropdown.open>.dropdown-toggle,.navbar-inverse .nav li.dropdown.active>.dropdown-toggle,.navbar-inverse .nav li.dropdown.open.active>.dropdown-toggle{color:#fff;background-color:#111}.navbar-inverse .nav li.dropdown>a:hover .caret,.navbar-inverse .nav li.dropdown>a:focus .caret{border-top-color:#fff;border-bottom-color:#fff}.navbar-inverse .nav li.dropdown>.dropdown-toggle .caret{border-top-color:#999;border-bottom-color:#999}.navbar-inverse .nav li.dropdown.open>.dropdown-toggle .caret,.navbar-inverse .nav li.dropdown.active>.dropdown-toggle .caret,.navbar-inverse .nav li.dropdown.open.active>.dropdown-toggle .caret{border-top-color:#fff;border-bottom-color:#fff}.navbar-inverse .navbar-search .search-query{color:#fff;background-color:#515151;border-color:#111;-webkit-box-shadow:inset 0 1px 2px rgba(0,0,0,0.1),0 1px 0 rgba(255,255,255,0.15);-moz-box-shadow:inset 0 1px 2px rgba(0,0,0,0.1),0 1px 0 rgba(255,255,255,0.15);box-shadow:inset 0 1px 2px rgba(0,0,0,0.1),0 1px 0 rgba(255,255,255,0.15);-webkit-transition:none;-moz-transition:none;-o-transition:none;transition:none}.navbar-inverse .navbar-search .search-query:-moz-placeholder{color:#ccc}.navbar-inverse .navbar-search .search-query:-ms-input-placeholder{color:#ccc}.navbar-inverse .navbar-search .search-query::-webkit-input-placeholder{color:#ccc}.navbar-inverse .navbar-search .search-query:focus,.navbar-inverse .navbar-search .search-query.focused{padding:5px 15px;color:#333;text-shadow:0 1px 0 #fff;background-color:#fff;border:0;outline:0;-webkit-box-shadow:0 0 3px rgba(0,0,0,0.15);-moz-box-shadow:0 0 3px rgba(0,0,0,0.15);box-shadow:0 0 3px rgba(0,0,0,0.15)}.navbar-inverse .btn-navbar{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,0.25);background-color:#0e0e0e;*background-color:#040404;background-image:-moz-linear-gradient(top,#151515,#040404);background-image:-webkit-gradient(linear,0 0,0 100%,from(#151515),to(#040404));background-image:-webkit-linear-gradient(top,#151515,#040404);background-image:-o-linear-gradient(top,#151515,#040404);background-image:linear-gradient(to bottom,#151515,#040404);background-repeat:repeat-x;border-color:#040404 #040404 #000;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff151515',endColorstr='#ff040404',GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false)}.navbar-inverse .btn-navbar:hover,.navbar-inverse .btn-navbar:focus,.navbar-inverse .btn-navbar:active,.navbar-inverse .btn-navbar.active,.navbar-inverse .btn-navbar.disabled,.navbar-inverse .btn-navbar[disabled]{color:#fff;background-color:#040404;*background-color:#000}.navbar-inverse .btn-navbar:active,.navbar-inverse .btn-navbar.active{background-color:#000 \9}.breadcrumb{padding:8px 15px;margin:0 0 20px;list-style:none;background-color:#f5f5f5;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}.breadcrumb>li{display:inline-block;*display:inline;text-shadow:0 1px 0 #fff;*zoom:1}.breadcrumb>li>.divider{padding:0 5px;color:#ccc}.breadcrumb>.active{color:#999}.pagination{margin:20px 0}.pagination ul{display:inline-block;*display:inline;margin-bottom:0;margin-left:0;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px;*zoom:1;-webkit-box-shadow:0 1px 2px rgba(0,0,0,0.05);-moz-box-shadow:0 1px 2px rgba(0,0,0,0.05);box-shadow:0 1px 2px rgba(0,0,0,0.05)}.pagination ul>li{display:inline}.pagination ul>li>a,.pagination ul>li>span{float:left;padding:4px 12px;line-height:20px;text-decoration:none;background-color:#fff;border:1px solid #ddd;border-left-width:0}.pagination ul>li>a:hover,.pagination ul>li>a:focus,.pagination ul>.active>a,.pagination ul>.active>span{background-color:#f5f5f5}.pagination ul>.active>a,.pagination ul>.active>span{color:#999;cursor:default}.pagination ul>.disabled>span,.pagination ul>.disabled>a,.pagination ul>.disabled>a:hover,.pagination ul>.disabled>a:focus{color:#999;cursor:default;background-color:transparent}.pagination ul>li:first-child>a,.pagination ul>li:first-child>span{border-left-width:1px;-webkit-border-bottom-left-radius:4px;border-bottom-left-radius:4px;-webkit-border-top-left-radius:4px;border-top-left-radius:4px;-moz-border-radius-bottomleft:4px;-moz-border-radius-topleft:4px}.pagination ul>li:last-child>a,.pagination ul>li:last-child>span{-webkit-border-top-right-radius:4px;border-top-right-radius:4px;-webkit-border-bottom-right-radius:4px;border-bottom-right-radius:4px;-moz-border-radius-topright:4px;-moz-border-radius-bottomright:4px}.pagination-centered{text-align:center}.pagination-right{text-align:right}.pagination-large ul>li>a,.pagination-large ul>li>span{padding:11px 19px;font-size:17.5px}.pagination-large ul>li:first-child>a,.pagination-large ul>li:first-child>span{-webkit-border-bottom-left-radius:6px;border-bottom-left-radius:6px;-webkit-border-top-left-radius:6px;border-top-left-radius:6px;-moz-border-radius-bottomleft:6px;-moz-border-radius-topleft:6px}.pagination-large ul>li:last-child>a,.pagination-large ul>li:last-child>span{-webkit-border-top-right-radius:6px;border-top-right-radius:6px;-webkit-border-bottom-right-radius:6px;border-bottom-right-radius:6px;-moz-border-radius-topright:6px;-moz-border-radius-bottomright:6px}.pagination-mini ul>li:first-child>a,.pagination-small ul>li:first-child>a,.pagination-mini ul>li:first-child>span,.pagination-small ul>li:first-child>span{-webkit-border-bottom-left-radius:3px;border-bottom-left-radius:3px;-webkit-border-top-left-radius:3px;border-top-left-radius:3px;-moz-border-radius-bottomleft:3px;-moz-border-radius-topleft:3px}.pagination-mini ul>li:last-child>a,.pagination-small ul>li:last-child>a,.pagination-mini ul>li:last-child>span,.pagination-small ul>li:last-child>span{-webkit-border-top-right-radius:3px;border-top-right-radius:3px;-webkit-border-bottom-right-radius:3px;border-bottom-right-radius:3px;-moz-border-radius-topright:3px;-moz-border-radius-bottomright:3px}.pagination-small ul>li>a,.pagination-small ul>li>span{padding:2px 10px;font-size:11.9px}.pagination-mini ul>li>a,.pagination-mini ul>li>span{padding:0 6px;font-size:10.5px}.pager{margin:20px 0;text-align:center;list-style:none;*zoom:1}.pager:before,.pager:after{display:table;line-height:0;content:""}.pager:after{clear:both}.pager li{display:inline}.pager li>a,.pager li>span{display:inline-block;padding:5px 14px;background-color:#fff;border:1px solid #ddd;-webkit-border-radius:15px;-moz-border-radius:15px;border-radius:15px}.pager li>a:hover,.pager li>a:focus{text-decoration:none;background-color:#f5f5f5}.pager .next>a,.pager .next>span{float:right}.pager .previous>a,.pager .previous>span{float:left}.pager .disabled>a,.pager .disabled>a:hover,.pager .disabled>a:focus,.pager .disabled>span{color:#999;cursor:default;background-color:#fff}.modal-backdrop{position:fixed;top:0;right:0;bottom:0;left:0;z-index:1040;background-color:#000}.modal-backdrop.fade{opacity:0}.modal-backdrop,.modal-backdrop.fade.in{opacity:.8;filter:alpha(opacity=80)}.modal{position:fixed;top:10%;left:50%;z-index:1050;width:560px;margin-left:-280px;background-color:#fff;border:1px solid #999;border:1px solid rgba(0,0,0,0.3);*border:1px solid #999;-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px;outline:0;-webkit-box-shadow:0 3px 7px rgba(0,0,0,0.3);-moz-box-shadow:0 3px 7px rgba(0,0,0,0.3);box-shadow:0 3px 7px rgba(0,0,0,0.3);-webkit-background-clip:padding-box;-moz-background-clip:padding-box;background-clip:padding-box}.modal.fade{top:-25%;-webkit-transition:opacity .3s linear,top .3s ease-out;-moz-transition:opacity .3s linear,top .3s ease-out;-o-transition:opacity .3s linear,top .3s ease-out;transition:opacity .3s linear,top .3s ease-out}.modal.fade.in{top:10%}.modal-header{padding:9px 15px;border-bottom:1px solid #eee}.modal-header .close{margin-top:2px}.modal-header h3{margin:0;line-height:30px}.modal-body{position:relative;max-height:400px;padding:15px;overflow-y:auto}.modal-form{margin-bottom:0}.modal-footer{padding:14px 15px 15px;margin-bottom:0;text-align:right;background-color:#f5f5f5;border-top:1px solid #ddd;-webkit-border-radius:0 0 6px 6px;-moz-border-radius:0 0 6px 6px;border-radius:0 0 6px 6px;*zoom:1;-webkit-box-shadow:inset 0 1px 0 #fff;-moz-box-shadow:inset 0 1px 0 #fff;box-shadow:inset 0 1px 0 #fff}.modal-footer:before,.modal-footer:after{display:table;line-height:0;content:""}.modal-footer:after{clear:both}.modal-footer .btn+.btn{margin-bottom:0;margin-left:5px}.modal-footer .btn-group .btn+.btn{margin-left:-1px}.modal-footer .btn-block+.btn-block{margin-left:0}.tooltip{position:absolute;z-index:1030;display:block;font-size:11px;line-height:1.4;opacity:0;filter:alpha(opacity=0);visibility:visible}.tooltip.in{opacity:.8;filter:alpha(opacity=80)}.tooltip.top{padding:5px 0;margin-top:-3px}.tooltip.right{padding:0 5px;margin-left:3px}.tooltip.bottom{padding:5px 0;margin-top:3px}.tooltip.left{padding:0 5px;margin-left:-3px}.tooltip-inner{max-width:200px;padding:8px;color:#fff;text-align:center;text-decoration:none;background-color:#000;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}.tooltip-arrow{position:absolute;width:0;height:0;border-color:transparent;border-style:solid}.tooltip.top .tooltip-arrow{bottom:0;left:50%;margin-left:-5px;border-top-color:#000;border-width:5px 5px 0}.tooltip.right .tooltip-arrow{top:50%;left:0;margin-top:-5px;border-right-color:#000;border-width:5px 5px 5px 0}.tooltip.left .tooltip-arrow{top:50%;right:0;margin-top:-5px;border-left-color:#000;border-width:5px 0 5px 5px}.tooltip.bottom .tooltip-arrow{top:0;left:50%;margin-left:-5px;border-bottom-color:#000;border-width:0 5px 5px}.popover{position:absolute;top:0;left:0;z-index:1010;display:none;max-width:276px;padding:1px;text-align:left;white-space:normal;background-color:#fff;border:1px solid #ccc;border:1px solid rgba(0,0,0,0.2);-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px;-webkit-box-shadow:0 5px 10px rgba(0,0,0,0.2);-moz-box-shadow:0 5px 10px rgba(0,0,0,0.2);box-shadow:0 5px 10px rgba(0,0,0,0.2);-webkit-background-clip:padding-box;-moz-background-clip:padding;background-clip:padding-box}.popover.top{margin-top:-10px}.popover.right{margin-left:10px}.popover.bottom{margin-top:10px}.popover.left{margin-left:-10px}.popover-title{padding:8px 14px;margin:0;font-size:14px;font-weight:normal;line-height:18px;background-color:#f7f7f7;border-bottom:1px solid #ebebeb;-webkit-border-radius:5px 5px 0 0;-moz-border-radius:5px 5px 0 0;border-radius:5px 5px 0 0}.popover-title:empty{display:none}.popover-content{padding:9px 14px}.popover .arrow,.popover .arrow:after{position:absolute;display:block;width:0;height:0;border-color:transparent;border-style:solid}.popover .arrow{border-width:11px}.popover .arrow:after{border-width:10px;content:""}.popover.top .arrow{bottom:-11px;left:50%;margin-left:-11px;border-top-color:#999;border-top-color:rgba(0,0,0,0.25);border-bottom-width:0}.popover.top .arrow:after{bottom:1px;margin-left:-10px;border-top-color:#fff;border-bottom-width:0}.popover.right .arrow{top:50%;left:-11px;margin-top:-11px;border-right-color:#999;border-right-color:rgba(0,0,0,0.25);border-left-width:0}.popover.right .arrow:after{bottom:-10px;left:1px;border-right-color:#fff;border-left-width:0}.popover.bottom .arrow{top:-11px;left:50%;margin-left:-11px;border-bottom-color:#999;border-bottom-color:rgba(0,0,0,0.25);border-top-width:0}.popover.bottom .arrow:after{top:1px;margin-left:-10px;border-bottom-color:#fff;border-top-width:0}.popover.left .arrow{top:50%;right:-11px;margin-top:-11px;border-left-color:#999;border-left-color:rgba(0,0,0,0.25);border-right-width:0}.popover.left .arrow:after{right:1px;bottom:-10px;border-left-color:#fff;border-right-width:0}.thumbnails{margin-left:-20px;list-style:none;*zoom:1}.thumbnails:before,.thumbnails:after{display:table;line-height:0;content:""}.thumbnails:after{clear:both}.row-fluid .thumbnails{margin-left:0}.thumbnails>li{float:left;margin-bottom:20px;margin-left:20px}.thumbnail{display:block;padding:4px;line-height:20px;border:1px solid #ddd;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px;-webkit-box-shadow:0 1px 3px rgba(0,0,0,0.055);-moz-box-shadow:0 1px 3px rgba(0,0,0,0.055);box-shadow:0 1px 3px rgba(0,0,0,0.055);-webkit-transition:all .2s ease-in-out;-moz-transition:all .2s ease-in-out;-o-transition:all .2s ease-in-out;transition:all .2s ease-in-out}a.thumbnail:hover,a.thumbnail:focus{border-color:#08c;-webkit-box-shadow:0 1px 4px rgba(0,105,214,0.25);-moz-box-shadow:0 1px 4px rgba(0,105,214,0.25);box-shadow:0 1px 4px rgba(0,105,214,0.25)}.thumbnail>img{display:block;max-width:100%;margin-right:auto;margin-left:auto}.thumbnail .caption{padding:9px;color:#555}.media,.media-body{overflow:hidden;*overflow:visible;zoom:1}.media,.media .media{margin-top:15px}.media:first-child{margin-top:0}.media-object{display:block}.media-heading{margin:0 0 5px}.media>.pull-left{margin-right:10px}.media>.pull-right{margin-left:10px}.media-list{margin-left:0;list-style:none}.label,.badge{display:inline-block;padding:2px 4px;font-size:11.844px;font-weight:bold;line-height:14px;color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,0.25);white-space:nowrap;vertical-align:baseline;background-color:#999}.label{-webkit-border-radius:3px;-moz-border-radius:3px;border-radius:3px}.badge{padding-right:9px;padding-left:9px;-webkit-border-radius:9px;-moz-border-radius:9px;border-radius:9px}.label:empty,.badge:empty{display:none}a.label:hover,a.label:focus,a.badge:hover,a.badge:focus{color:#fff;text-decoration:none;cursor:pointer}.label-important,.badge-important{background-color:#b94a48}.label-important[href],.badge-important[href]{background-color:#953b39}.label-warning,.badge-warning{background-color:#f89406}.label-warning[href],.badge-warning[href]{background-color:#c67605}.label-success,.badge-success{background-color:#468847}.label-success[href],.badge-success[href]{background-color:#356635}.label-info,.badge-info{background-color:#3a87ad}.label-info[href],.badge-info[href]{background-color:#2d6987}.label-inverse,.badge-inverse{background-color:#333}.label-inverse[href],.badge-inverse[href]{background-color:#1a1a1a}.btn .label,.btn .badge{position:relative;top:-1px}.btn-mini .label,.btn-mini .badge{top:0}@-webkit-keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}@-moz-keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}@-ms-keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}@-o-keyframes progress-bar-stripes{from{background-position:0 0}to{background-position:40px 0}}@keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}.progress{height:20px;margin-bottom:20px;overflow:hidden;background-color:#f7f7f7;background-image:-moz-linear-gradient(top,#f5f5f5,#f9f9f9);background-image:-webkit-gradient(linear,0 0,0 100%,from(#f5f5f5),to(#f9f9f9));background-image:-webkit-linear-gradient(top,#f5f5f5,#f9f9f9);background-image:-o-linear-gradient(top,#f5f5f5,#f9f9f9);background-image:linear-gradient(to bottom,#f5f5f5,#f9f9f9);background-repeat:repeat-x;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#fff5f5f5',endColorstr='#fff9f9f9',GradientType=0);-webkit-box-shadow:inset 0 1px 2px rgba(0,0,0,0.1);-moz-box-shadow:inset 0 1px 2px rgba(0,0,0,0.1);box-shadow:inset 0 1px 2px rgba(0,0,0,0.1)}.progress .bar{float:left;width:0;height:100%;font-size:12px;color:#fff;text-align:center;text-shadow:0 -1px 0 rgba(0,0,0,0.25);background-color:#0e90d2;background-image:-moz-linear-gradient(top,#149bdf,#0480be);background-image:-webkit-gradient(linear,0 0,0 100%,from(#149bdf),to(#0480be));background-image:-webkit-linear-gradient(top,#149bdf,#0480be);background-image:-o-linear-gradient(top,#149bdf,#0480be);background-image:linear-gradient(to bottom,#149bdf,#0480be);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff149bdf',endColorstr='#ff0480be',GradientType=0);-webkit-box-shadow:inset 0 -1px 0 rgba(0,0,0,0.15);-moz-box-shadow:inset 0 -1px 0 rgba(0,0,0,0.15);box-shadow:inset 0 -1px 0 rgba(0,0,0,0.15);-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;-webkit-transition:width .6s ease;-moz-transition:width .6s ease;-o-transition:width .6s ease;transition:width .6s ease}.progress .bar+.bar{-webkit-box-shadow:inset 1px 0 0 rgba(0,0,0,0.15),inset 0 -1px 0 rgba(0,0,0,0.15);-moz-box-shadow:inset 1px 0 0 rgba(0,0,0,0.15),inset 0 -1px 0 rgba(0,0,0,0.15);box-shadow:inset 1px 0 0 rgba(0,0,0,0.15),inset 0 -1px 0 rgba(0,0,0,0.15)}.progress-striped .bar{background-color:#149bdf;background-image:-webkit-gradient(linear,0 100%,100% 0,color-stop(0.25,rgba(255,255,255,0.15)),color-stop(0.25,transparent),color-stop(0.5,transparent),color-stop(0.5,rgba(255,255,255,0.15)),color-stop(0.75,rgba(255,255,255,0.15)),color-stop(0.75,transparent),to(transparent));background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-moz-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);-webkit-background-size:40px 40px;-moz-background-size:40px 40px;-o-background-size:40px 40px;background-size:40px 40px}.progress.active .bar{-webkit-animation:progress-bar-stripes 2s linear infinite;-moz-animation:progress-bar-stripes 2s linear infinite;-ms-animation:progress-bar-stripes 2s linear infinite;-o-animation:progress-bar-stripes 2s linear infinite;animation:progress-bar-stripes 2s linear infinite}.progress-danger .bar,.progress .bar-danger{background-color:#dd514c;background-image:-moz-linear-gradient(top,#ee5f5b,#c43c35);background-image:-webkit-gradient(linear,0 0,0 100%,from(#ee5f5b),to(#c43c35));background-image:-webkit-linear-gradient(top,#ee5f5b,#c43c35);background-image:-o-linear-gradient(top,#ee5f5b,#c43c35);background-image:linear-gradient(to bottom,#ee5f5b,#c43c35);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffee5f5b',endColorstr='#ffc43c35',GradientType=0)}.progress-danger.progress-striped .bar,.progress-striped .bar-danger{background-color:#ee5f5b;background-image:-webkit-gradient(linear,0 100%,100% 0,color-stop(0.25,rgba(255,255,255,0.15)),color-stop(0.25,transparent),color-stop(0.5,transparent),color-stop(0.5,rgba(255,255,255,0.15)),color-stop(0.75,rgba(255,255,255,0.15)),color-stop(0.75,transparent),to(transparent));background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-moz-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent)}.progress-success .bar,.progress .bar-success{background-color:#5eb95e;background-image:-moz-linear-gradient(top,#62c462,#57a957);background-image:-webkit-gradient(linear,0 0,0 100%,from(#62c462),to(#57a957));background-image:-webkit-linear-gradient(top,#62c462,#57a957);background-image:-o-linear-gradient(top,#62c462,#57a957);background-image:linear-gradient(to bottom,#62c462,#57a957);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff62c462',endColorstr='#ff57a957',GradientType=0)}.progress-success.progress-striped .bar,.progress-striped .bar-success{background-color:#62c462;background-image:-webkit-gradient(linear,0 100%,100% 0,color-stop(0.25,rgba(255,255,255,0.15)),color-stop(0.25,transparent),color-stop(0.5,transparent),color-stop(0.5,rgba(255,255,255,0.15)),color-stop(0.75,rgba(255,255,255,0.15)),color-stop(0.75,transparent),to(transparent));background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-moz-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent)}.progress-info .bar,.progress .bar-info{background-color:#4bb1cf;background-image:-moz-linear-gradient(top,#5bc0de,#339bb9);background-image:-webkit-gradient(linear,0 0,0 100%,from(#5bc0de),to(#339bb9));background-image:-webkit-linear-gradient(top,#5bc0de,#339bb9);background-image:-o-linear-gradient(top,#5bc0de,#339bb9);background-image:linear-gradient(to bottom,#5bc0de,#339bb9);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff5bc0de',endColorstr='#ff339bb9',GradientType=0)}.progress-info.progress-striped .bar,.progress-striped .bar-info{background-color:#5bc0de;background-image:-webkit-gradient(linear,0 100%,100% 0,color-stop(0.25,rgba(255,255,255,0.15)),color-stop(0.25,transparent),color-stop(0.5,transparent),color-stop(0.5,rgba(255,255,255,0.15)),color-stop(0.75,rgba(255,255,255,0.15)),color-stop(0.75,transparent),to(transparent));background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-moz-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent)}.progress-warning .bar,.progress .bar-warning{background-color:#faa732;background-image:-moz-linear-gradient(top,#fbb450,#f89406);background-image:-webkit-gradient(linear,0 0,0 100%,from(#fbb450),to(#f89406));background-image:-webkit-linear-gradient(top,#fbb450,#f89406);background-image:-o-linear-gradient(top,#fbb450,#f89406);background-image:linear-gradient(to bottom,#fbb450,#f89406);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#fffbb450',endColorstr='#fff89406',GradientType=0)}.progress-warning.progress-striped .bar,.progress-striped .bar-warning{background-color:#fbb450;background-image:-webkit-gradient(linear,0 100%,100% 0,color-stop(0.25,rgba(255,255,255,0.15)),color-stop(0.25,transparent),color-stop(0.5,transparent),color-stop(0.5,rgba(255,255,255,0.15)),color-stop(0.75,rgba(255,255,255,0.15)),color-stop(0.75,transparent),to(transparent));background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-moz-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent)}.accordion{margin-bottom:20px}.accordion-group{margin-bottom:2px;border:1px solid #e5e5e5;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}.accordion-heading{border-bottom:0}.accordion-heading .accordion-toggle{display:block;padding:8px 15px}.accordion-toggle{cursor:pointer}.accordion-inner{padding:9px 15px;border-top:1px solid #e5e5e5}.carousel{position:relative;margin-bottom:20px;line-height:1}.carousel-inner{position:relative;width:100%;overflow:hidden}.carousel-inner>.item{position:relative;display:none;-webkit-transition:.6s ease-in-out left;-moz-transition:.6s ease-in-out left;-o-transition:.6s ease-in-out left;transition:.6s ease-in-out left}.carousel-inner>.item>img,.carousel-inner>.item>a>img{display:block;line-height:1}.carousel-inner>.active,.carousel-inner>.next,.carousel-inner>.prev{display:block}.carousel-inner>.active{left:0}.carousel-inner>.next,.carousel-inner>.prev{position:absolute;top:0;width:100%}.carousel-inner>.next{left:100%}.carousel-inner>.prev{left:-100%}.carousel-inner>.next.left,.carousel-inner>.prev.right{left:0}.carousel-inner>.active.left{left:-100%}.carousel-inner>.active.right{left:100%}.carousel-control{position:absolute;top:40%;left:15px;width:40px;height:40px;margin-top:-20px;font-size:60px;font-weight:100;line-height:30px;color:#fff;text-align:center;background:#222;border:3px solid #fff;-webkit-border-radius:23px;-moz-border-radius:23px;border-radius:23px;opacity:.5;filter:alpha(opacity=50)}.carousel-control.right{right:15px;left:auto}.carousel-control:hover,.carousel-control:focus{color:#fff;text-decoration:none;opacity:.9;filter:alpha(opacity=90)}.carousel-indicators{position:absolute;top:15px;right:15px;z-index:5;margin:0;list-style:none}.carousel-indicators li{display:block;float:left;width:10px;height:10px;margin-left:5px;text-indent:-999px;background-color:#ccc;background-color:rgba(255,255,255,0.25);border-radius:5px}.carousel-indicators .active{background-color:#fff}.carousel-caption{position:absolute;right:0;bottom:0;left:0;padding:15px;background:#333;background:rgba(0,0,0,0.75)}.carousel-caption h4,.carousel-caption p{line-height:20px;color:#fff}.carousel-caption h4{margin:0 0 5px}.carousel-caption p{margin-bottom:0}.hero-unit{padding:60px;margin-bottom:30px;font-size:18px;font-weight:200;line-height:30px;color:inherit;background-color:#eee;-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px}.hero-unit h1{margin-bottom:0;font-size:60px;line-height:1;letter-spacing:-1px;color:inherit}.hero-unit li{line-height:30px}.pull-right{float:right}.pull-left{float:left}.hide{display:none}.show{display:block}.invisible{visibility:hidden}.affix{position:fixed}
+/*!
+ * Bootstrap Responsive v2.3.1
+ *
+ * Copyright 2012 Twitter, Inc
+ * Licensed under the Apache License v2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Designed and built with all the love in the world @twitter by @mdo and @fat.
+ */.clearfix{*zoom:1}.clearfix:before,.clearfix:after{display:table;line-height:0;content:""}.clearfix:after{clear:both}.hide-text{font:0/0 a;color:transparent;text-shadow:none;background-color:transparent;border:0}.input-block-level{display:block;width:100%;min-height:30px;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}@-ms-viewport{width:device-width}.hidden{display:none;visibility:hidden}.visible-phone{display:none!important}.visible-tablet{display:none!important}.hidden-desktop{display:none!important}.visible-desktop{display:inherit!important}@media(min-width:768px) and (max-width:979px){.hidden-desktop{display:inherit!important}.visible-desktop{display:none!important}.visible-tablet{display:inherit!important}.hidden-tablet{display:none!important}}@media(max-width:767px){.hidden-desktop{display:inherit!important}.visible-desktop{display:none!important}.visible-phone{display:inherit!important}.hidden-phone{display:none!important}}.visible-print{display:none!important}@media print{.visible-print{display:inherit!important}.hidden-print{display:none!important}}@media(min-width:1200px){.row{margin-left:-30px;*zoom:1}.row:before,.row:after{display:table;line-height:0;content:""}.row:after{clear:both}[class*="span"]{float:left;min-height:1px;margin-left:30px}.container,.navbar-static-top .container,.navbar-fixed-top .container,.navbar-fixed-bottom .container{width:1170px}.span12{width:1170px}.span11{width:1070px}.span10{width:970px}.span9{width:870px}.span8{width:770px}.span7{width:670px}.span6{width:570px}.span5{width:470px}.span4{width:370px}.span3{width:270px}.span2{width:170px}.span1{width:70px}.offset12{margin-left:1230px}.offset11{margin-left:1130px}.offset10{margin-left:1030px}.offset9{margin-left:930px}.offset8{margin-left:830px}.offset7{margin-left:730px}.offset6{margin-left:630px}.offset5{margin-left:530px}.offset4{margin-left:430px}.offset3{margin-left:330px}.offset2{margin-left:230px}.offset1{margin-left:130px}.row-fluid{width:100%;*zoom:1}.row-fluid:before,.row-fluid:after{display:table;line-height:0;content:""}.row-fluid:after{clear:both}.row-fluid [class*="span"]{display:block;float:left;width:100%;min-height:30px;margin-left:2.564102564102564%;*margin-left:2.5109110747408616%;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}.row-fluid [class*="span"]:first-child{margin-left:0}.row-fluid .controls-row [class*="span"]+[class*="span"]{margin-left:2.564102564102564%}.row-fluid .span12{width:100%;*width:99.94680851063829%}.row-fluid .span11{width:91.45299145299145%;*width:91.39979996362975%}.row-fluid .span10{width:82.90598290598291%;*width:82.8527914166212%}.row-fluid .span9{width:74.35897435897436%;*width:74.30578286961266%}.row-fluid .span8{width:65.81196581196582%;*width:65.75877432260411%}.row-fluid .span7{width:57.26495726495726%;*width:57.21176577559556%}.row-fluid .span6{width:48.717948717948715%;*width:48.664757228587014%}.row-fluid .span5{width:40.17094017094017%;*width:40.11774868157847%}.row-fluid .span4{width:31.623931623931625%;*width:31.570740134569924%}.row-fluid .span3{width:23.076923076923077%;*width:23.023731587561375%}.row-fluid .span2{width:14.52991452991453%;*width:14.476723040552828%}.row-fluid .span1{width:5.982905982905983%;*width:5.929714493544281%}.row-fluid .offset12{margin-left:105.12820512820512%;*margin-left:105.02182214948171%}.row-fluid .offset12:first-child{margin-left:102.56410256410257%;*margin-left:102.45771958537915%}.row-fluid .offset11{margin-left:96.58119658119658%;*margin-left:96.47481360247316%}.row-fluid .offset11:first-child{margin-left:94.01709401709402%;*margin-left:93.91071103837061%}.row-fluid .offset10{margin-left:88.03418803418803%;*margin-left:87.92780505546462%}.row-fluid .offset10:first-child{margin-left:85.47008547008548%;*margin-left:85.36370249136206%}.row-fluid .offset9{margin-left:79.48717948717949%;*margin-left:79.38079650845607%}.row-fluid .offset9:first-child{margin-left:76.92307692307693%;*margin-left:76.81669394435352%}.row-fluid .offset8{margin-left:70.94017094017094%;*margin-left:70.83378796144753%}.row-fluid .offset8:first-child{margin-left:68.37606837606839%;*margin-left:68.26968539734497%}.row-fluid .offset7{margin-left:62.393162393162385%;*margin-left:62.28677941443899%}.row-fluid .offset7:first-child{margin-left:59.82905982905982%;*margin-left:59.72267685033642%}.row-fluid .offset6{margin-left:53.84615384615384%;*margin-left:53.739770867430444%}.row-fluid .offset6:first-child{margin-left:51.28205128205128%;*margin-left:51.175668303327875%}.row-fluid .offset5{margin-left:45.299145299145295%;*margin-left:45.1927623204219%}.row-fluid .offset5:first-child{margin-left:42.73504273504273%;*margin-left:42.62865975631933%}.row-fluid .offset4{margin-left:36.75213675213675%;*margin-left:36.645753773413354%}.row-fluid .offset4:first-child{margin-left:34.18803418803419%;*margin-left:34.081651209310785%}.row-fluid .offset3{margin-left:28.205128205128204%;*margin-left:28.0987452264048%}.row-fluid .offset3:first-child{margin-left:25.641025641025642%;*margin-left:25.53464266230224%}.row-fluid .offset2{margin-left:19.65811965811966%;*margin-left:19.551736679396257%}.row-fluid .offset2:first-child{margin-left:17.094017094017094%;*margin-left:16.98763411529369%}.row-fluid .offset1{margin-left:11.11111111111111%;*margin-left:11.004728132387708%}.row-fluid .offset1:first-child{margin-left:8.547008547008547%;*margin-left:8.440625568285142%}input,textarea,.uneditable-input{margin-left:0}.controls-row [class*="span"]+[class*="span"]{margin-left:30px}input.span12,textarea.span12,.uneditable-input.span12{width:1156px}input.span11,textarea.span11,.uneditable-input.span11{width:1056px}input.span10,textarea.span10,.uneditable-input.span10{width:956px}input.span9,textarea.span9,.uneditable-input.span9{width:856px}input.span8,textarea.span8,.uneditable-input.span8{width:756px}input.span7,textarea.span7,.uneditable-input.span7{width:656px}input.span6,textarea.span6,.uneditable-input.span6{width:556px}input.span5,textarea.span5,.uneditable-input.span5{width:456px}input.span4,textarea.span4,.uneditable-input.span4{width:356px}input.span3,textarea.span3,.uneditable-input.span3{width:256px}input.span2,textarea.span2,.uneditable-input.span2{width:156px}input.span1,textarea.span1,.uneditable-input.span1{width:56px}.thumbnails{margin-left:-30px}.thumbnails>li{margin-left:30px}.row-fluid .thumbnails{margin-left:0}}@media(min-width:768px) and (max-width:979px){.row{margin-left:-20px;*zoom:1}.row:before,.row:after{display:table;line-height:0;content:""}.row:after{clear:both}[class*="span"]{float:left;min-height:1px;margin-left:20px}.container,.navbar-static-top .container,.navbar-fixed-top .container,.navbar-fixed-bottom .container{width:724px}.span12{width:724px}.span11{width:662px}.span10{width:600px}.span9{width:538px}.span8{width:476px}.span7{width:414px}.span6{width:352px}.span5{width:290px}.span4{width:228px}.span3{width:166px}.span2{width:104px}.span1{width:42px}.offset12{margin-left:764px}.offset11{margin-left:702px}.offset10{margin-left:640px}.offset9{margin-left:578px}.offset8{margin-left:516px}.offset7{margin-left:454px}.offset6{margin-left:392px}.offset5{margin-left:330px}.offset4{margin-left:268px}.offset3{margin-left:206px}.offset2{margin-left:144px}.offset1{margin-left:82px}.row-fluid{width:100%;*zoom:1}.row-fluid:before,.row-fluid:after{display:table;line-height:0;content:""}.row-fluid:after{clear:both}.row-fluid [class*="span"]{display:block;float:left;width:100%;min-height:30px;margin-left:2.7624309392265194%;*margin-left:2.709239449864817%;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}.row-fluid [class*="span"]:first-child{margin-left:0}.row-fluid .controls-row [class*="span"]+[class*="span"]{margin-left:2.7624309392265194%}.row-fluid .span12{width:100%;*width:99.94680851063829%}.row-fluid .span11{width:91.43646408839778%;*width:91.38327259903608%}.row-fluid .span10{width:82.87292817679558%;*width:82.81973668743387%}.row-fluid .span9{width:74.30939226519337%;*width:74.25620077583166%}.row-fluid .span8{width:65.74585635359117%;*width:65.69266486422946%}.row-fluid .span7{width:57.18232044198895%;*width:57.12912895262725%}.row-fluid .span6{width:48.61878453038674%;*width:48.56559304102504%}.row-fluid .span5{width:40.05524861878453%;*width:40.00205712942283%}.row-fluid .span4{width:31.491712707182323%;*width:31.43852121782062%}.row-fluid .span3{width:22.92817679558011%;*width:22.87498530621841%}.row-fluid .span2{width:14.3646408839779%;*width:14.311449394616199%}.row-fluid .span1{width:5.801104972375691%;*width:5.747913483013988%}.row-fluid .offset12{margin-left:105.52486187845304%;*margin-left:105.41847889972962%}.row-fluid .offset12:first-child{margin-left:102.76243093922652%;*margin-left:102.6560479605031%}.row-fluid .offset11{margin-left:96.96132596685082%;*margin-left:96.8549429881274%}.row-fluid .offset11:first-child{margin-left:94.1988950276243%;*margin-left:94.09251204890089%}.row-fluid .offset10{margin-left:88.39779005524862%;*margin-left:88.2914070765252%}.row-fluid .offset10:first-child{margin-left:85.6353591160221%;*margin-left:85.52897613729868%}.row-fluid .offset9{margin-left:79.8342541436464%;*margin-left:79.72787116492299%}.row-fluid .offset9:first-child{margin-left:77.07182320441989%;*margin-left:76.96544022569647%}.row-fluid .offset8{margin-left:71.2707182320442%;*margin-left:71.16433525332079%}.row-fluid .offset8:first-child{margin-left:68.50828729281768%;*margin-left:68.40190431409427%}.row-fluid .offset7{margin-left:62.70718232044199%;*margin-left:62.600799341718584%}.row-fluid .offset7:first-child{margin-left:59.94475138121547%;*margin-left:59.838368402492065%}.row-fluid .offset6{margin-left:54.14364640883978%;*margin-left:54.037263430116376%}.row-fluid .offset6:first-child{margin-left:51.38121546961326%;*margin-left:51.27483249088986%}.row-fluid .offset5{margin-left:45.58011049723757%;*margin-left:45.47372751851417%}.row-fluid .offset5:first-child{margin-left:42.81767955801105%;*margin-left:42.71129657928765%}.row-fluid .offset4{margin-left:37.01657458563536%;*margin-left:36.91019160691196%}.row-fluid .offset4:first-child{margin-left:34.25414364640884%;*margin-left:34.14776066768544%}.row-fluid .offset3{margin-left:28.45303867403315%;*margin-left:28.346655695309746%}.row-fluid .offset3:first-child{margin-left:25.69060773480663%;*margin-left:25.584224756083227%}.row-fluid .offset2{margin-left:19.88950276243094%;*margin-left:19.783119783707537%}.row-fluid .offset2:first-child{margin-left:17.12707182320442%;*margin-left:17.02068884448102%}.row-fluid .offset1{margin-left:11.32596685082873%;*margin-left:11.219583872105325%}.row-fluid .offset1:first-child{margin-left:8.56353591160221%;*margin-left:8.457152932878806%}input,textarea,.uneditable-input{margin-left:0}.controls-row [class*="span"]+[class*="span"]{margin-left:20px}input.span12,textarea.span12,.uneditable-input.span12{width:710px}input.span11,textarea.span11,.uneditable-input.span11{width:648px}input.span10,textarea.span10,.uneditable-input.span10{width:586px}input.span9,textarea.span9,.uneditable-input.span9{width:524px}input.span8,textarea.span8,.uneditable-input.span8{width:462px}input.span7,textarea.span7,.uneditable-input.span7{width:400px}input.span6,textarea.span6,.uneditable-input.span6{width:338px}input.span5,textarea.span5,.uneditable-input.span5{width:276px}input.span4,textarea.span4,.uneditable-input.span4{width:214px}input.span3,textarea.span3,.uneditable-input.span3{width:152px}input.span2,textarea.span2,.uneditable-input.span2{width:90px}input.span1,textarea.span1,.uneditable-input.span1{width:28px}}@media(max-width:767px){body{padding-right:20px;padding-left:20px}.navbar-fixed-top,.navbar-fixed-bottom,.navbar-static-top{margin-right:-20px;margin-left:-20px}.container-fluid{padding:0}.dl-horizontal dt{float:none;width:auto;clear:none;text-align:left}.dl-horizontal dd{margin-left:0}.container{width:auto}.row-fluid{width:100%}.row,.thumbnails{margin-left:0}.thumbnails>li{float:none;margin-left:0}[class*="span"],.uneditable-input[class*="span"],.row-fluid [class*="span"]{display:block;float:none;width:100%;margin-left:0;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}.span12,.row-fluid .span12{width:100%;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}.row-fluid [class*="offset"]:first-child{margin-left:0}.input-large,.input-xlarge,.input-xxlarge,input[class*="span"],select[class*="span"],textarea[class*="span"],.uneditable-input{display:block;width:100%;min-height:30px;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}.input-prepend input,.input-append input,.input-prepend input[class*="span"],.input-append input[class*="span"]{display:inline-block;width:auto}.controls-row [class*="span"]+[class*="span"]{margin-left:0}.modal{position:fixed;top:20px;right:20px;left:20px;width:auto;margin:0}.modal.fade{top:-100px}.modal.fade.in{top:20px}}@media(max-width:480px){.nav-collapse{-webkit-transform:translate3d(0,0,0)}.page-header h1 small{display:block;line-height:20px}input[type="checkbox"],input[type="radio"]{border:1px solid #ccc}.form-horizontal .control-label{float:none;width:auto;padding-top:0;text-align:left}.form-horizontal .controls{margin-left:0}.form-horizontal .control-list{padding-top:0}.form-horizontal .form-actions{padding-right:10px;padding-left:10px}.media .pull-left,.media .pull-right{display:block;float:none;margin-bottom:10px}.media-object{margin-right:0;margin-left:0}.modal{top:10px;right:10px;left:10px}.modal-header .close{padding:10px;margin:-10px}.carousel-caption{position:static}}@media(max-width:979px){body{padding-top:0}.navbar-fixed-top,.navbar-fixed-bottom{position:static}.navbar-fixed-top{margin-bottom:20px}.navbar-fixed-bottom{margin-top:20px}.navbar-fixed-top .navbar-inner,.navbar-fixed-bottom .navbar-inner{padding:5px}.navbar .container{width:auto;padding:0}.navbar .brand{padding-right:10px;padding-left:10px;margin:0 0 0 -5px}.nav-collapse{clear:both}.nav-collapse .nav{float:none;margin:0 0 10px}.nav-collapse .nav>li{float:none}.nav-collapse .nav>li>a{margin-bottom:2px}.nav-collapse .nav>.divider-vertical{display:none}.nav-collapse .nav .nav-header{color:#777;text-shadow:none}.nav-collapse .nav>li>a,.nav-collapse .dropdown-menu a{padding:9px 15px;font-weight:bold;color:#777;-webkit-border-radius:3px;-moz-border-radius:3px;border-radius:3px}.nav-collapse .btn{padding:4px 10px 4px;font-weight:normal;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}.nav-collapse .dropdown-menu li+li a{margin-bottom:2px}.nav-collapse .nav>li>a:hover,.nav-collapse .nav>li>a:focus,.nav-collapse .dropdown-menu a:hover,.nav-collapse .dropdown-menu a:focus{background-color:#f2f2f2}.navbar-inverse .nav-collapse .nav>li>a,.navbar-inverse .nav-collapse .dropdown-menu a{color:#999}.navbar-inverse .nav-collapse .nav>li>a:hover,.navbar-inverse .nav-collapse .nav>li>a:focus,.navbar-inverse .nav-collapse .dropdown-menu a:hover,.navbar-inverse .nav-collapse .dropdown-menu a:focus{background-color:#111}.nav-collapse.in .btn-group{padding:0;margin-top:5px}.nav-collapse .dropdown-menu{position:static;top:auto;left:auto;display:none;float:none;max-width:none;padding:0;margin:0 15px;background-color:transparent;border:0;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0;-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none}.nav-collapse .open>.dropdown-menu{display:block}.nav-collapse .dropdown-menu:before,.nav-collapse .dropdown-menu:after{display:none}.nav-collapse .dropdown-menu .divider{display:none}.nav-collapse .nav>li>.dropdown-menu:before,.nav-collapse .nav>li>.dropdown-menu:after{display:none}.nav-collapse .navbar-form,.nav-collapse .navbar-search{float:none;padding:10px 15px;margin:10px 0;border-top:1px solid #f2f2f2;border-bottom:1px solid #f2f2f2;-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,0.1),0 1px 0 rgba(255,255,255,0.1);-moz-box-shadow:inset 0 1px 0 rgba(255,255,255,0.1),0 1px 0 rgba(255,255,255,0.1);box-shadow:inset 0 1px 0 rgba(255,255,255,0.1),0 1px 0 rgba(255,255,255,0.1)}.navbar-inverse .nav-collapse .navbar-form,.navbar-inverse .nav-collapse .navbar-search{border-top-color:#111;border-bottom-color:#111}.navbar .nav-collapse .nav.pull-right{float:none;margin-left:0}.nav-collapse,.nav-collapse.collapse{height:0;overflow:hidden}.navbar .btn-navbar{display:block}.navbar-static .navbar-inner{padding-right:10px;padding-left:10px}}@media(min-width:980px){.nav-collapse.collapse{height:auto!important;overflow:visible!important}}
diff --git a/website/static/bootstrap.min.js b/website/static/bootstrap.min.js
new file mode 100644
index 0000000000..95c5ac5ee6
--- /dev/null
+++ b/website/static/bootstrap.min.js
@@ -0,0 +1,6 @@
+/*!
+* Bootstrap.js by @fat & @mdo
+* Copyright 2012 Twitter, Inc.
+* http://www.apache.org/licenses/LICENSE-2.0.txt
+*/
+!function(e){"use strict";e(function(){e.support.transition=function(){var e=function(){var e=document.createElement("bootstrap"),t={WebkitTransition:"webkitTransitionEnd",MozTransition:"transitionend",OTransition:"oTransitionEnd otransitionend",transition:"transitionend"},n;for(n in t)if(e.style[n]!==undefined)return t[n]}();return e&&{end:e}}()})}(window.jQuery),!function(e){"use strict";var t='[data-dismiss="alert"]',n=function(n){e(n).on("click",t,this.close)};n.prototype.close=function(t){function s(){i.trigger("closed").remove()}var n=e(this),r=n.attr("data-target"),i;r||(r=n.attr("href"),r=r&&r.replace(/.*(?=#[^\s]*$)/,"")),i=e(r),t&&t.preventDefault(),i.length||(i=n.hasClass("alert")?n:n.parent()),i.trigger(t=e.Event("close"));if(t.isDefaultPrevented())return;i.removeClass("in"),e.support.transition&&i.hasClass("fade")?i.on(e.support.transition.end,s):s()};var r=e.fn.alert;e.fn.alert=function(t){return this.each(function(){var r=e(this),i=r.data("alert");i||r.data("alert",i=new n(this)),typeof t=="string"&&i[t].call(r)})},e.fn.alert.Constructor=n,e.fn.alert.noConflict=function(){return e.fn.alert=r,this},e(document).on("click.alert.data-api",t,n.prototype.close)}(window.jQuery),!function(e){"use strict";var t=function(t,n){this.$element=e(t),this.options=e.extend({},e.fn.button.defaults,n)};t.prototype.setState=function(e){var t="disabled",n=this.$element,r=n.data(),i=n.is("input")?"val":"html";e+="Text",r.resetText||n.data("resetText",n[i]()),n[i](r[e]||this.options[e]),setTimeout(function(){e=="loadingText"?n.addClass(t).attr(t,t):n.removeClass(t).removeAttr(t)},0)},t.prototype.toggle=function(){var e=this.$element.closest('[data-toggle="buttons-radio"]');e&&e.find(".active").removeClass("active"),this.$element.toggleClass("active")};var n=e.fn.button;e.fn.button=function(n){return this.each(function(){var r=e(this),i=r.data("button"),s=typeof n=="object"&&n;i||r.data("button",i=new t(this,s)),n=="toggle"?i.toggle():n&&i.setState(n)})},e.fn.button.defaults={loadingText:"loading..."},e.fn.button.Constructor=t,e.fn.button.noConflict=function(){return e.fn.button=n,this},e(document).on("click.button.data-api","[data-toggle^=button]",function(t){var n=e(t.target);n.hasClass("btn")||(n=n.closest(".btn")),n.button("toggle")})}(window.jQuery),!function(e){"use strict";var t=function(t,n){this.$element=e(t),this.$indicators=this.$element.find(".carousel-indicators"),this.options=n,this.options.pause=="hover"&&this.$element.on("mouseenter",e.proxy(this.pause,this)).on("mouseleave",e.proxy(this.cycle,this))};t.prototype={cycle:function(t){return t||(this.paused=!1),this.interval&&clearInterval(this.interval),this.options.interval&&!this.paused&&(this.interval=setInterval(e.proxy(this.next,this),this.options.interval)),this},getActiveIndex:function(){return this.$active=this.$element.find(".item.active"),this.$items=this.$active.parent().children(),this.$items.index(this.$active)},to:function(t){var n=this.getActiveIndex(),r=this;if(t>this.$items.length-1||t<0)return;return this.sliding?this.$element.one("slid",function(){r.to(t)}):n==t?this.pause().cycle():this.slide(t>n?"next":"prev",e(this.$items[t]))},pause:function(t){return t||(this.paused=!0),this.$element.find(".next, .prev").length&&e.support.transition.end&&(this.$element.trigger(e.support.transition.end),this.cycle(!0)),clearInterval(this.interval),this.interval=null,this},next:function(){if(this.sliding)return;return this.slide("next")},prev:function(){if(this.sliding)return;return this.slide("prev")},slide:function(t,n){var r=this.$element.find(".item.active"),i=n||r[t](),s=this.interval,o=t=="next"?"left":"right",u=t=="next"?"first":"last",a=this,f;this.sliding=!0,s&&this.pause(),i=i.length?i:this.$element.find(".item")[u](),f=e.Event("slide",{relatedTarget:i[0],direction:o});if(i.hasClass("active"))return;this.$indicators.length&&(this.$indicators.find(".active").removeClass("active"),this.$element.one("slid",function(){var t=e(a.$indicators.children()[a.getActiveIndex()]);t&&t.addClass("active")}));if(e.support.transition&&this.$element.hasClass("slide")){this.$element.trigger(f);if(f.isDefaultPrevented())return;i.addClass(t),i[0].offsetWidth,r.addClass(o),i.addClass(o),this.$element.one(e.support.transition.end,function(){i.removeClass([t,o].join(" ")).addClass("active"),r.removeClass(["active",o].join(" ")),a.sliding=!1,setTimeout(function(){a.$element.trigger("slid")},0)})}else{this.$element.trigger(f);if(f.isDefaultPrevented())return;r.removeClass("active"),i.addClass("active"),this.sliding=!1,this.$element.trigger("slid")}return s&&this.cycle(),this}};var n=e.fn.carousel;e.fn.carousel=function(n){return this.each(function(){var r=e(this),i=r.data("carousel"),s=e.extend({},e.fn.carousel.defaults,typeof n=="object"&&n),o=typeof n=="string"?n:s.slide;i||r.data("carousel",i=new t(this,s)),typeof n=="number"?i.to(n):o?i[o]():s.interval&&i.pause().cycle()})},e.fn.carousel.defaults={interval:5e3,pause:"hover"},e.fn.carousel.Constructor=t,e.fn.carousel.noConflict=function(){return e.fn.carousel=n,this},e(document).on("click.carousel.data-api","[data-slide], [data-slide-to]",function(t){var n=e(this),r,i=e(n.attr("data-target")||(r=n.attr("href"))&&r.replace(/.*(?=#[^\s]+$)/,"")),s=e.extend({},i.data(),n.data()),o;i.carousel(s),(o=n.attr("data-slide-to"))&&i.data("carousel").pause().to(o).cycle(),t.preventDefault()})}(window.jQuery),!function(e){"use strict";var t=function(t,n){this.$element=e(t),this.options=e.extend({},e.fn.collapse.defaults,n),this.options.parent&&(this.$parent=e(this.options.parent)),this.options.toggle&&this.toggle()};t.prototype={constructor:t,dimension:function(){var e=this.$element.hasClass("width");return e?"width":"height"},show:function(){var t,n,r,i;if(this.transitioning||this.$element.hasClass("in"))return;t=this.dimension(),n=e.camelCase(["scroll",t].join("-")),r=this.$parent&&this.$parent.find("> .accordion-group > .in");if(r&&r.length){i=r.data("collapse");if(i&&i.transitioning)return;r.collapse("hide"),i||r.data("collapse",null)}this.$element[t](0),this.transition("addClass",e.Event("show"),"shown"),e.support.transition&&this.$element[t](this.$element[0][n])},hide:function(){var t;if(this.transitioning||!this.$element.hasClass("in"))return;t=this.dimension(),this.reset(this.$element[t]()),this.transition("removeClass",e.Event("hide"),"hidden"),this.$element[t](0)},reset:function(e){var t=this.dimension();return this.$element.removeClass("collapse")[t](e||"auto")[0].offsetWidth,this.$element[e!==null?"addClass":"removeClass"]("collapse"),this},transition:function(t,n,r){var i=this,s=function(){n.type=="show"&&i.reset(),i.transitioning=0,i.$element.trigger(r)};this.$element.trigger(n);if(n.isDefaultPrevented())return;this.transitioning=1,this.$element[t]("in"),e.support.transition&&this.$element.hasClass("collapse")?this.$element.one(e.support.transition.end,s):s()},toggle:function(){this[this.$element.hasClass("in")?"hide":"show"]()}};var n=e.fn.collapse;e.fn.collapse=function(n){return this.each(function(){var r=e(this),i=r.data("collapse"),s=e.extend({},e.fn.collapse.defaults,r.data(),typeof n=="object"&&n);i||r.data("collapse",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.collapse.defaults={toggle:!0},e.fn.collapse.Constructor=t,e.fn.collapse.noConflict=function(){return e.fn.collapse=n,this},e(document).on("click.collapse.data-api","[data-toggle=collapse]",function(t){var n=e(this),r,i=n.attr("data-target")||t.preventDefault()||(r=n.attr("href"))&&r.replace(/.*(?=#[^\s]+$)/,""),s=e(i).data("collapse")?"toggle":n.data();n[e(i).hasClass("in")?"addClass":"removeClass"]("collapsed"),e(i).collapse(s)})}(window.jQuery),!function(e){"use strict";function r(){e(t).each(function(){i(e(this)).removeClass("open")})}function i(t){var n=t.attr("data-target"),r;n||(n=t.attr("href"),n=n&&/#/.test(n)&&n.replace(/.*(?=#[^\s]*$)/,"")),r=n&&e(n);if(!r||!r.length)r=t.parent();return r}var t="[data-toggle=dropdown]",n=function(t){var n=e(t).on("click.dropdown.data-api",this.toggle);e("html").on("click.dropdown.data-api",function(){n.parent().removeClass("open")})};n.prototype={constructor:n,toggle:function(t){var n=e(this),s,o;if(n.is(".disabled, :disabled"))return;return s=i(n),o=s.hasClass("open"),r(),o||s.toggleClass("open"),n.focus(),!1},keydown:function(n){var r,s,o,u,a,f;if(!/(38|40|27)/.test(n.keyCode))return;r=e(this),n.preventDefault(),n.stopPropagation();if(r.is(".disabled, :disabled"))return;u=i(r),a=u.hasClass("open");if(!a||a&&n.keyCode==27)return n.which==27&&u.find(t).focus(),r.click();s=e("[role=menu] li:not(.divider):visible a",u);if(!s.length)return;f=s.index(s.filter(":focus")),n.keyCode==38&&f>0&&f--,n.keyCode==40&&f<s.length-1&&f++,~f||(f=0),s.eq(f).focus()}};var s=e.fn.dropdown;e.fn.dropdown=function(t){return this.each(function(){var r=e(this),i=r.data("dropdown");i||r.data("dropdown",i=new n(this)),typeof t=="string"&&i[t].call(r)})},e.fn.dropdown.Constructor=n,e.fn.dropdown.noConflict=function(){return e.fn.dropdown=s,this},e(document).on("click.dropdown.data-api",r).on("click.dropdown.data-api",".dropdown form",function(e){e.stopPropagation()}).on("click.dropdown-menu",function(e){e.stopPropagation()}).on("click.dropdown.data-api",t,n.prototype.toggle).on("keydown.dropdown.data-api",t+", [role=menu]",n.prototype.keydown)}(window.jQuery),!function(e){"use strict";var t=function(t,n){this.options=n,this.$element=e(t).delegate('[data-dismiss="modal"]',"click.dismiss.modal",e.proxy(this.hide,this)),this.options.remote&&this.$element.find(".modal-body").load(this.options.remote)};t.prototype={constructor:t,toggle:function(){return this[this.isShown?"hide":"show"]()},show:function(){var t=this,n=e.Event("show");this.$element.trigger(n);if(this.isShown||n.isDefaultPrevented())return;this.isShown=!0,this.escape(),this.backdrop(function(){var n=e.support.transition&&t.$element.hasClass("fade");t.$element.parent().length||t.$element.appendTo(document.body),t.$element.show(),n&&t.$element[0].offsetWidth,t.$element.addClass("in").attr("aria-hidden",!1),t.enforceFocus(),n?t.$element.one(e.support.transition.end,function(){t.$element.focus().trigger("shown")}):t.$element.focus().trigger("shown")})},hide:function(t){t&&t.preventDefault();var n=this;t=e.Event("hide"),this.$element.trigger(t);if(!this.isShown||t.isDefaultPrevented())return;this.isShown=!1,this.escape(),e(document).off("focusin.modal"),this.$element.removeClass("in").attr("aria-hidden",!0),e.support.transition&&this.$element.hasClass("fade")?this.hideWithTransition():this.hideModal()},enforceFocus:function(){var t=this;e(document).on("focusin.modal",function(e){t.$element[0]!==e.target&&!t.$element.has(e.target).length&&t.$element.focus()})},escape:function(){var e=this;this.isShown&&this.options.keyboard?this.$element.on("keyup.dismiss.modal",function(t){t.which==27&&e.hide()}):this.isShown||this.$element.off("keyup.dismiss.modal")},hideWithTransition:function(){var t=this,n=setTimeout(function(){t.$element.off(e.support.transition.end),t.hideModal()},500);this.$element.one(e.support.transition.end,function(){clearTimeout(n),t.hideModal()})},hideModal:function(){var e=this;this.$element.hide(),this.backdrop(function(){e.removeBackdrop(),e.$element.trigger("hidden")})},removeBackdrop:function(){this.$backdrop&&this.$backdrop.remove(),this.$backdrop=null},backdrop:function(t){var n=this,r=this.$element.hasClass("fade")?"fade":"";if(this.isShown&&this.options.backdrop){var i=e.support.transition&&r;this.$backdrop=e('<div class="modal-backdrop '+r+'" />').appendTo(document.body),this.$backdrop.click(this.options.backdrop=="static"?e.proxy(this.$element[0].focus,this.$element[0]):e.proxy(this.hide,this)),i&&this.$backdrop[0].offsetWidth,this.$backdrop.addClass("in");if(!t)return;i?this.$backdrop.one(e.support.transition.end,t):t()}else!this.isShown&&this.$backdrop?(this.$backdrop.removeClass("in"),e.support.transition&&this.$element.hasClass("fade")?this.$backdrop.one(e.support.transition.end,t):t()):t&&t()}};var n=e.fn.modal;e.fn.modal=function(n){return this.each(function(){var r=e(this),i=r.data("modal"),s=e.extend({},e.fn.modal.defaults,r.data(),typeof n=="object"&&n);i||r.data("modal",i=new t(this,s)),typeof n=="string"?i[n]():s.show&&i.show()})},e.fn.modal.defaults={backdrop:!0,keyboard:!0,show:!0},e.fn.modal.Constructor=t,e.fn.modal.noConflict=function(){return e.fn.modal=n,this},e(document).on("click.modal.data-api",'[data-toggle="modal"]',function(t){var n=e(this),r=n.attr("href"),i=e(n.attr("data-target")||r&&r.replace(/.*(?=#[^\s]+$)/,"")),s=i.data("modal")?"toggle":e.extend({remote:!/#/.test(r)&&r},i.data(),n.data());t.preventDefault(),i.modal(s).one("hide",function(){n.focus()})})}(window.jQuery),!function(e){"use strict";var t=function(e,t){this.init("tooltip",e,t)};t.prototype={constructor:t,init:function(t,n,r){var i,s,o,u,a;this.type=t,this.$element=e(n),this.options=this.getOptions(r),this.enabled=!0,o=this.options.trigger.split(" ");for(a=o.length;a--;)u=o[a],u=="click"?this.$element.on("click."+this.type,this.options.selector,e.proxy(this.toggle,this)):u!="manual"&&(i=u=="hover"?"mouseenter":"focus",s=u=="hover"?"mouseleave":"blur",this.$element.on(i+"."+this.type,this.options.selector,e.proxy(this.enter,this)),this.$element.on(s+"."+this.type,this.options.selector,e.proxy(this.leave,this)));this.options.selector?this._options=e.extend({},this.options,{trigger:"manual",selector:""}):this.fixTitle()},getOptions:function(t){return t=e.extend({},e.fn[this.type].defaults,this.$element.data(),t),t.delay&&typeof t.delay=="number"&&(t.delay={show:t.delay,hide:t.delay}),t},enter:function(t){var n=e.fn[this.type].defaults,r={},i;this._options&&e.each(this._options,function(e,t){n[e]!=t&&(r[e]=t)},this),i=e(t.currentTarget)[this.type](r).data(this.type);if(!i.options.delay||!i.options.delay.show)return i.show();clearTimeout(this.timeout),i.hoverState="in",this.timeout=setTimeout(function(){i.hoverState=="in"&&i.show()},i.options.delay.show)},leave:function(t){var n=e(t.currentTarget)[this.type](this._options).data(this.type);this.timeout&&clearTimeout(this.timeout);if(!n.options.delay||!n.options.delay.hide)return n.hide();n.hoverState="out",this.timeout=setTimeout(function(){n.hoverState=="out"&&n.hide()},n.options.delay.hide)},show:function(){var t,n,r,i,s,o,u=e.Event("show");if(this.hasContent()&&this.enabled){this.$element.trigger(u);if(u.isDefaultPrevented())return;t=this.tip(),this.setContent(),this.options.animation&&t.addClass("fade"),s=typeof this.options.placement=="function"?this.options.placement.call(this,t[0],this.$element[0]):this.options.placement,t.detach().css({top:0,left:0,display:"block"}),this.options.container?t.appendTo(this.options.container):t.insertAfter(this.$element),n=this.getPosition(),r=t[0].offsetWidth,i=t[0].offsetHeight;switch(s){case"bottom":o={top:n.top+n.height,left:n.left+n.width/2-r/2};break;case"top":o={top:n.top-i,left:n.left+n.width/2-r/2};break;case"left":o={top:n.top+n.height/2-i/2,left:n.left-r};break;case"right":o={top:n.top+n.height/2-i/2,left:n.left+n.width}}this.applyPlacement(o,s),this.$element.trigger("shown")}},applyPlacement:function(e,t){var n=this.tip(),r=n[0].offsetWidth,i=n[0].offsetHeight,s,o,u,a;n.offset(e).addClass(t).addClass("in"),s=n[0].offsetWidth,o=n[0].offsetHeight,t=="top"&&o!=i&&(e.top=e.top+i-o,a=!0),t=="bottom"||t=="top"?(u=0,e.left<0&&(u=e.left*-2,e.left=0,n.offset(e),s=n[0].offsetWidth,o=n[0].offsetHeight),this.replaceArrow(u-r+s,s,"left")):this.replaceArrow(o-i,o,"top"),a&&n.offset(e)},replaceArrow:function(e,t,n){this.arrow().css(n,e?50*(1-e/t)+"%":"")},setContent:function(){var e=this.tip(),t=this.getTitle();e.find(".tooltip-inner")[this.options.html?"html":"text"](t),e.removeClass("fade in top bottom left right")},hide:function(){function i(){var t=setTimeout(function(){n.off(e.support.transition.end).detach()},500);n.one(e.support.transition.end,function(){clearTimeout(t),n.detach()})}var t=this,n=this.tip(),r=e.Event("hide");this.$element.trigger(r);if(r.isDefaultPrevented())return;return n.removeClass("in"),e.support.transition&&this.$tip.hasClass("fade")?i():n.detach(),this.$element.trigger("hidden"),this},fixTitle:function(){var e=this.$element;(e.attr("title")||typeof e.attr("data-original-title")!="string")&&e.attr("data-original-title",e.attr("title")||"").attr("title","")},hasContent:function(){return this.getTitle()},getPosition:function(){var t=this.$element[0];return e.extend({},typeof t.getBoundingClientRect=="function"?t.getBoundingClientRect():{width:t.offsetWidth,height:t.offsetHeight},this.$element.offset())},getTitle:function(){var e,t=this.$element,n=this.options;return e=t.attr("data-original-title")||(typeof n.title=="function"?n.title.call(t[0]):n.title),e},tip:function(){return this.$tip=this.$tip||e(this.options.template)},arrow:function(){return this.$arrow=this.$arrow||this.tip().find(".tooltip-arrow")},validate:function(){this.$element[0].parentNode||(this.hide(),this.$element=null,this.options=null)},enable:function(){this.enabled=!0},disable:function(){this.enabled=!1},toggleEnabled:function(){this.enabled=!this.enabled},toggle:function(t){var n=t?e(t.currentTarget)[this.type](this._options).data(this.type):this;n.tip().hasClass("in")?n.hide():n.show()},destroy:function(){this.hide().$element.off("."+this.type).removeData(this.type)}};var n=e.fn.tooltip;e.fn.tooltip=function(n){return this.each(function(){var r=e(this),i=r.data("tooltip"),s=typeof n=="object"&&n;i||r.data("tooltip",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.tooltip.Constructor=t,e.fn.tooltip.defaults={animation:!0,placement:"top",selector:!1,template:'<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',trigger:"hover focus",title:"",delay:0,html:!1,container:!1},e.fn.tooltip.noConflict=function(){return e.fn.tooltip=n,this}}(window.jQuery),!function(e){"use strict";var t=function(e,t){this.init("popover",e,t)};t.prototype=e.extend({},e.fn.tooltip.Constructor.prototype,{constructor:t,setContent:function(){var e=this.tip(),t=this.getTitle(),n=this.getContent();e.find(".popover-title")[this.options.html?"html":"text"](t),e.find(".popover-content")[this.options.html?"html":"text"](n),e.removeClass("fade top bottom left right in")},hasContent:function(){return this.getTitle()||this.getContent()},getContent:function(){var e,t=this.$element,n=this.options;return e=(typeof n.content=="function"?n.content.call(t[0]):n.content)||t.attr("data-content"),e},tip:function(){return this.$tip||(this.$tip=e(this.options.template)),this.$tip},destroy:function(){this.hide().$element.off("."+this.type).removeData(this.type)}});var n=e.fn.popover;e.fn.popover=function(n){return this.each(function(){var r=e(this),i=r.data("popover"),s=typeof n=="object"&&n;i||r.data("popover",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.popover.Constructor=t,e.fn.popover.defaults=e.extend({},e.fn.tooltip.defaults,{placement:"right",trigger:"click",content:"",template:'<div class="popover"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'}),e.fn.popover.noConflict=function(){return e.fn.popover=n,this}}(window.jQuery),!function(e){"use strict";function t(t,n){var r=e.proxy(this.process,this),i=e(t).is("body")?e(window):e(t),s;this.options=e.extend({},e.fn.scrollspy.defaults,n),this.$scrollElement=i.on("scroll.scroll-spy.data-api",r),this.selector=(this.options.target||(s=e(t).attr("href"))&&s.replace(/.*(?=#[^\s]+$)/,"")||"")+" .nav li > a",this.$body=e("body"),this.refresh(),this.process()}t.prototype={constructor:t,refresh:function(){var t=this,n;this.offsets=e([]),this.targets=e([]),n=this.$body.find(this.selector).map(function(){var n=e(this),r=n.data("target")||n.attr("href"),i=/^#\w/.test(r)&&e(r);return i&&i.length&&[[i.position().top+(!e.isWindow(t.$scrollElement.get(0))&&t.$scrollElement.scrollTop()),r]]||null}).sort(function(e,t){return e[0]-t[0]}).each(function(){t.offsets.push(this[0]),t.targets.push(this[1])})},process:function(){var e=this.$scrollElement.scrollTop()+this.options.offset,t=this.$scrollElement[0].scrollHeight||this.$body[0].scrollHeight,n=t-this.$scrollElement.height(),r=this.offsets,i=this.targets,s=this.activeTarget,o;if(e>=n)return s!=(o=i.last()[0])&&this.activate(o);for(o=r.length;o--;)s!=i[o]&&e>=r[o]&&(!r[o+1]||e<=r[o+1])&&this.activate(i[o])},activate:function(t){var n,r;this.activeTarget=t,e(this.selector).parent(".active").removeClass("active"),r=this.selector+'[data-target="'+t+'"],'+this.selector+'[href="'+t+'"]',n=e(r).parent("li").addClass("active"),n.parent(".dropdown-menu").length&&(n=n.closest("li.dropdown").addClass("active")),n.trigger("activate")}};var n=e.fn.scrollspy;e.fn.scrollspy=function(n){return this.each(function(){var r=e(this),i=r.data("scrollspy"),s=typeof n=="object"&&n;i||r.data("scrollspy",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.scrollspy.Constructor=t,e.fn.scrollspy.defaults={offset:10},e.fn.scrollspy.noConflict=function(){return e.fn.scrollspy=n,this},e(window).on("load",function(){e('[data-spy="scroll"]').each(function(){var t=e(this);t.scrollspy(t.data())})})}(window.jQuery),!function(e){"use strict";var t=function(t){this.element=e(t)};t.prototype={constructor:t,show:function(){var t=this.element,n=t.closest("ul:not(.dropdown-menu)"),r=t.attr("data-target"),i,s,o;r||(r=t.attr("href"),r=r&&r.replace(/.*(?=#[^\s]*$)/,""));if(t.parent("li").hasClass("active"))return;i=n.find(".active:last a")[0],o=e.Event("show",{relatedTarget:i}),t.trigger(o);if(o.isDefaultPrevented())return;s=e(r),this.activate(t.parent("li"),n),this.activate(s,s.parent(),function(){t.trigger({type:"shown",relatedTarget:i})})},activate:function(t,n,r){function o(){i.removeClass("active").find("> .dropdown-menu > .active").removeClass("active"),t.addClass("active"),s?(t[0].offsetWidth,t.addClass("in")):t.removeClass("fade"),t.parent(".dropdown-menu")&&t.closest("li.dropdown").addClass("active"),r&&r()}var i=n.find("> .active"),s=r&&e.support.transition&&i.hasClass("fade");s?i.one(e.support.transition.end,o):o(),i.removeClass("in")}};var n=e.fn.tab;e.fn.tab=function(n){return this.each(function(){var r=e(this),i=r.data("tab");i||r.data("tab",i=new t(this)),typeof n=="string"&&i[n]()})},e.fn.tab.Constructor=t,e.fn.tab.noConflict=function(){return e.fn.tab=n,this},e(document).on("click.tab.data-api",'[data-toggle="tab"], [data-toggle="pill"]',function(t){t.preventDefault(),e(this).tab("show")})}(window.jQuery),!function(e){"use strict";var t=function(t,n){this.$element=e(t),this.options=e.extend({},e.fn.typeahead.defaults,n),this.matcher=this.options.matcher||this.matcher,this.sorter=this.options.sorter||this.sorter,this.highlighter=this.options.highlighter||this.highlighter,this.updater=this.options.updater||this.updater,this.source=this.options.source,this.$menu=e(this.options.menu),this.shown=!1,this.listen()};t.prototype={constructor:t,select:function(){var e=this.$menu.find(".active").attr("data-value");return this.$element.val(this.updater(e)).change(),this.hide()},updater:function(e){return e},show:function(){var t=e.extend({},this.$element.position(),{height:this.$element[0].offsetHeight});return this.$menu.insertAfter(this.$element).css({top:t.top+t.height,left:t.left}).show(),this.shown=!0,this},hide:function(){return this.$menu.hide(),this.shown=!1,this},lookup:function(t){var n;return this.query=this.$element.val(),!this.query||this.query.length<this.options.minLength?this.shown?this.hide():this:(n=e.isFunction(this.source)?this.source(this.query,e.proxy(this.process,this)):this.source,n?this.process(n):this)},process:function(t){var n=this;return t=e.grep(t,function(e){return n.matcher(e)}),t=this.sorter(t),t.length?this.render(t.slice(0,this.options.items)).show():this.shown?this.hide():this},matcher:function(e){return~e.toLowerCase().indexOf(this.query.toLowerCase())},sorter:function(e){var t=[],n=[],r=[],i;while(i=e.shift())i.toLowerCase().indexOf(this.query.toLowerCase())?~i.indexOf(this.query)?n.push(i):r.push(i):t.push(i);return t.concat(n,r)},highlighter:function(e){var t=this.query.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&");return e.replace(new RegExp("("+t+")","ig"),function(e,t){return"<strong>"+t+"</strong>"})},render:function(t){var n=this;return t=e(t).map(function(t,r){return t=e(n.options.item).attr("data-value",r),t.find("a").html(n.highlighter(r)),t[0]}),t.first().addClass("active"),this.$menu.html(t),this},next:function(t){var n=this.$menu.find(".active").removeClass("active"),r=n.next();r.length||(r=e(this.$menu.find("li")[0])),r.addClass("active")},prev:function(e){var t=this.$menu.find(".active").removeClass("active"),n=t.prev();n.length||(n=this.$menu.find("li").last()),n.addClass("active")},listen:function(){this.$element.on("focus",e.proxy(this.focus,this)).on("blur",e.proxy(this.blur,this)).on("keypress",e.proxy(this.keypress,this)).on("keyup",e.proxy(this.keyup,this)),this.eventSupported("keydown")&&this.$element.on("keydown",e.proxy(this.keydown,this)),this.$menu.on("click",e.proxy(this.click,this)).on("mouseenter","li",e.proxy(this.mouseenter,this)).on("mouseleave","li",e.proxy(this.mouseleave,this))},eventSupported:function(e){var t=e in this.$element;return t||(this.$element.setAttribute(e,"return;"),t=typeof this.$element[e]=="function"),t},move:function(e){if(!this.shown)return;switch(e.keyCode){case 9:case 13:case 27:e.preventDefault();break;case 38:e.preventDefault(),this.prev();break;case 40:e.preventDefault(),this.next()}e.stopPropagation()},keydown:function(t){this.suppressKeyPressRepeat=~e.inArray(t.keyCode,[40,38,9,13,27]),this.move(t)},keypress:function(e){if(this.suppressKeyPressRepeat)return;this.move(e)},keyup:function(e){switch(e.keyCode){case 40:case 38:case 16:case 17:case 18:break;case 9:case 13:if(!this.shown)return;this.select();break;case 27:if(!this.shown)return;this.hide();break;default:this.lookup()}e.stopPropagation(),e.preventDefault()},focus:function(e){this.focused=!0},blur:function(e){this.focused=!1,!this.mousedover&&this.shown&&this.hide()},click:function(e){e.stopPropagation(),e.preventDefault(),this.select(),this.$element.focus()},mouseenter:function(t){this.mousedover=!0,this.$menu.find(".active").removeClass("active"),e(t.currentTarget).addClass("active")},mouseleave:function(e){this.mousedover=!1,!this.focused&&this.shown&&this.hide()}};var n=e.fn.typeahead;e.fn.typeahead=function(n){return this.each(function(){var r=e(this),i=r.data("typeahead"),s=typeof n=="object"&&n;i||r.data("typeahead",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.typeahead.defaults={source:[],items:8,menu:'<ul class="typeahead dropdown-menu"></ul>',item:'<li><a href="#"></a></li>',minLength:1},e.fn.typeahead.Constructor=t,e.fn.typeahead.noConflict=function(){return e.fn.typeahead=n,this},e(document).on("focus.typeahead.data-api",'[data-provide="typeahead"]',function(t){var n=e(this);if(n.data("typeahead"))return;n.typeahead(n.data())})}(window.jQuery),!function(e){"use strict";var t=function(t,n){this.options=e.extend({},e.fn.affix.defaults,n),this.$window=e(window).on("scroll.affix.data-api",e.proxy(this.checkPosition,this)).on("click.affix.data-api",e.proxy(function(){setTimeout(e.proxy(this.checkPosition,this),1)},this)),this.$element=e(t),this.checkPosition()};t.prototype.checkPosition=function(){if(!this.$element.is(":visible"))return;var t=e(document).height(),n=this.$window.scrollTop(),r=this.$element.offset(),i=this.options.offset,s=i.bottom,o=i.top,u="affix affix-top affix-bottom",a;typeof i!="object"&&(s=o=i),typeof o=="function"&&(o=i.top()),typeof s=="function"&&(s=i.bottom()),a=this.unpin!=null&&n+this.unpin<=r.top?!1:s!=null&&r.top+this.$element.height()>=t-s?"bottom":o!=null&&n<=o?"top":!1;if(this.affixed===a)return;this.affixed=a,this.unpin=a=="bottom"?r.top-n:null,this.$element.removeClass(u).addClass("affix"+(a?"-"+a:""))};var n=e.fn.affix;e.fn.affix=function(n){return this.each(function(){var r=e(this),i=r.data("affix"),s=typeof n=="object"&&n;i||r.data("affix",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.affix.Constructor=t,e.fn.affix.defaults={offset:0},e.fn.affix.noConflict=function(){return e.fn.affix=n,this},e(window).on("load",function(){e('[data-spy="affix"]').each(function(){var t=e(this),n=t.data();n.offset=n.offset||{},n.offsetBottom&&(n.offset.bottom=n.offsetBottom),n.offsetTop&&(n.offset.top=n.offsetTop),t.affix(n)})})}(window.jQuery);
\ No newline at end of file
diff --git a/website/static/html5shiv.min.js b/website/static/html5shiv.min.js
new file mode 100644
index 0000000000..784f221caf
--- /dev/null
+++ b/website/static/html5shiv.min.js
@@ -0,0 +1,8 @@
+/*
+ HTML5 Shiv v3.6.2pre | @afarkas @jdalton @jon_neal @rem | MIT/GPL2 Licensed
+*/
+(function(l,f){function m(){var a=e.elements;return"string"==typeof a?a.split(" "):a}function i(a){var b=n[a[o]];b||(b={},h++,a[o]=h,n[h]=b);return b}function p(a,b,c){b||(b=f);if(g)return b.createElement(a);c||(c=i(b));b=c.cache[a]?c.cache[a].cloneNode():r.test(a)?(c.cache[a]=c.createElem(a)).cloneNode():c.createElem(a);return b.canHaveChildren&&!s.test(a)?c.frag.appendChild(b):b}function t(a,b){if(!b.cache)b.cache={},b.createElem=a.createElement,b.createFrag=a.createDocumentFragment,b.frag=b.createFrag();
+a.createElement=function(c){return!e.shivMethods?b.createElem(c):p(c,a,b)};a.createDocumentFragment=Function("h,f","return function(){var n=f.cloneNode(),c=n.createElement;h.shivMethods&&("+m().join().replace(/\w+/g,function(a){b.createElem(a);b.frag.createElement(a);return'c("'+a+'")'})+");return n}")(e,b.frag)}function q(a){a||(a=f);var b=i(a);if(e.shivCSS&&!j&&!b.hasCSS){var c,d=a;c=d.createElement("p");d=d.getElementsByTagName("head")[0]||d.documentElement;c.innerHTML="x<style>article,aside,figcaption,figure,footer,header,hgroup,nav,section{display:block}mark{background:#FF0;color:#000}</style>";
+c=d.insertBefore(c.lastChild,d.firstChild);b.hasCSS=!!c}g||t(a,b);return a}var k=l.html5||{},s=/^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i,r=/^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i,j,o="_html5shiv",h=0,n={},g;(function(){try{var a=f.createElement("a");a.innerHTML="<xyz></xyz>";j="hidden"in a;var b;if(!(b=1==a.childNodes.length)){f.createElement("a");var c=f.createDocumentFragment();b="undefined"==typeof c.cloneNode||
+"undefined"==typeof c.createDocumentFragment||"undefined"==typeof c.createElement}g=b}catch(d){g=j=!0}})();var e={elements:k.elements||"abbr article aside audio bdi canvas data datalist details figcaption figure footer header hgroup mark meter nav output progress section summary time video",version:"3.6.2pre",shivCSS:!1!==k.shivCSS,supportsUnknownElements:g,shivMethods:!1!==k.shivMethods,type:"default",shivDocument:q,createElement:p,createDocumentFragment:function(a,b){a||(a=f);if(g)return a.createDocumentFragment();
+for(var b=b||i(a),c=b.frag.cloneNode(),d=0,e=m(),h=e.length;d<h;d++)c.createElement(e[d]);return c}};l.html5=e;q(f)})(this,document);
diff --git a/website/static/icon-github.png b/website/static/icon-github.png
new file mode 100644
index 0000000000..a9c6940069
Binary files /dev/null and b/website/static/icon-github.png differ
diff --git a/website/static/icon-square.png b/website/static/icon-square.png
new file mode 100644
index 0000000000..bdc98d1c2f
Binary files /dev/null and b/website/static/icon-square.png differ
diff --git a/website/static/jquery-maven-artifact.min.js b/website/static/jquery-maven-artifact.min.js
new file mode 100644
index 0000000000..4b78fe23ac
--- /dev/null
+++ b/website/static/jquery-maven-artifact.min.js
@@ -0,0 +1,7 @@
+/**
+ * jQuery Maven Artifact Plugin
+ *
+ * Version: 2.0.0
+ * Author: Jake Wharton
+ * License: Apache 2.0
+ */(function(e){function n(e,t){var n=e.groupId.replace(/\./g,"/"),r="http://repo1.maven.org/maven2/"+n+"/"+e.artifactId+"/"+t+"/"+e.artifactId+"-"+t;return typeof e.classifier!="undefined"&&(r+="-"+e.classifier),r+="."+e.packaging,r}function r(e){var t={groupId:"g",artifactId:"a",packaging:"p",classifier:"l"},n="";for(var r in t)t.hasOwnProperty(r)&&e.hasOwnProperty(r)&&(n!==""&&(n+="+AND+"),n+=t[r]+':"'+e[r]+'"');return n}var t={packaging:"jar"};e.fn.artifactVersion=function(i,s){if(typeof i=="undefined"){alert("Error: config object is required.");return}if(typeof s=="undefined"){alert("Error: callback function required.");return}var i=e.extend({},t,i),o="http://search.maven.org/solrsearch/select/?q="+r(i)+"&wt=json&json.wrf=?";e.getJSON(o,function(e){var t=e.response.docs;if(t.length==0)return;var r=t[0].latestVersion||t[0].v,o=n(i,r);s(r,o)})},e.fn.artifactVersions=function(i,s){if(typeof i=="undefined"){alert("Error: config object is required.");return}if(typeof s=="undefined"){alert("Error: callback function required.");return}var i=e.extend({},t,i),o="http://search.maven.org/solrsearch/select/?q="+r(i)+"&wt=json&rows=10&core=gav&json.wrf=?";e.getJSON(o,function(e){var t=e.response.docs;if(t.length==0)return;t.sort(function(e,t){return e.v>t.v?-1:1});var r=[];for(var o=0;o<t.length;o++){var u=t[o].v;r.push({name:u,url:n(i,u)})}s(r)})}})(jQuery);
\ No newline at end of file
diff --git a/website/static/jquery.smooth-scroll.min.js b/website/static/jquery.smooth-scroll.min.js
new file mode 100644
index 0000000000..2af596ee83
--- /dev/null
+++ b/website/static/jquery.smooth-scroll.min.js
@@ -0,0 +1,7 @@
+/*!
+ * Smooth Scroll - v1.4.10 - 2013-03-02
+ * https://github.com/kswedberg/jquery-smooth-scroll
+ * Copyright (c) 2013 Karl Swedberg
+ * Licensed MIT (https://github.com/kswedberg/jquery-smooth-scroll/blob/master/LICENSE-MIT)
+ */
+(function(l){function t(l){return l.replace(/(:|\.)/g,"\\$1")}var e="1.4.10",o={exclude:[],excludeWithin:[],offset:0,direction:"top",scrollElement:null,scrollTarget:null,beforeScroll:function(){},afterScroll:function(){},easing:"swing",speed:400,autoCoefficent:2},r=function(t){var e=[],o=!1,r=t.dir&&"left"==t.dir?"scrollLeft":"scrollTop";return this.each(function(){if(this!=document&&this!=window){var t=l(this);t[r]()>0?e.push(this):(t[r](1),o=t[r]()>0,o&&e.push(this),t[r](0))}}),e.length||this.each(function(){"BODY"===this.nodeName&&(e=[this])}),"first"===t.el&&e.length>1&&(e=[e[0]]),e};l.fn.extend({scrollable:function(l){var t=r.call(this,{dir:l});return this.pushStack(t)},firstScrollable:function(l){var t=r.call(this,{el:"first",dir:l});return this.pushStack(t)},smoothScroll:function(e){e=e||{};var o=l.extend({},l.fn.smoothScroll.defaults,e),r=l.smoothScroll.filterPath(location.pathname);return this.unbind("click.smoothscroll").bind("click.smoothscroll",function(e){var n=this,s=l(this),c=o.exclude,i=o.excludeWithin,a=0,f=0,h=!0,u={},d=location.hostname===n.hostname||!n.hostname,m=o.scrollTarget||(l.smoothScroll.filterPath(n.pathname)||r)===r,p=t(n.hash);if(o.scrollTarget||d&&m&&p){for(;h&&c.length>a;)s.is(t(c[a++]))&&(h=!1);for(;h&&i.length>f;)s.closest(i[f++]).length&&(h=!1)}else h=!1;h&&(e.preventDefault(),l.extend(u,o,{scrollTarget:o.scrollTarget||p,link:n}),l.smoothScroll(u))}),this}}),l.smoothScroll=function(t,e){var o,r,n,s,c=0,i="offset",a="scrollTop",f={},h={};"number"==typeof t?(o=l.fn.smoothScroll.defaults,n=t):(o=l.extend({},l.fn.smoothScroll.defaults,t||{}),o.scrollElement&&(i="position","static"==o.scrollElement.css("position")&&o.scrollElement.css("position","relative"))),o=l.extend({link:null},o),a="left"==o.direction?"scrollLeft":a,o.scrollElement?(r=o.scrollElement,c=r[a]()):r=l("html, body").firstScrollable(),o.beforeScroll.call(r,o),n="number"==typeof t?t:e||l(o.scrollTarget)[i]()&&l(o.scrollTarget)[i]()[o.direction]||0,f[a]=n+c+o.offset,s=o.speed,"auto"===s&&(s=f[a]||r.scrollTop(),s/=o.autoCoefficent),h={duration:s,easing:o.easing,complete:function(){o.afterScroll.call(o.link,o)}},o.step&&(h.step=o.step),r.length?r.stop().animate(f,h):o.afterScroll.call(o.link,o)},l.smoothScroll.version=e,l.smoothScroll.filterPath=function(l){return l.replace(/^\//,"").replace(/(index|default).[a-zA-Z]{3,4}$/,"").replace(/\/$/,"")},l.fn.smoothScroll.defaults=o})(jQuery);
\ No newline at end of file
diff --git a/website/static/logo-square.png b/website/static/logo-square.png
new file mode 100644
index 0000000000..788b301adb
Binary files /dev/null and b/website/static/logo-square.png differ
diff --git a/website/static/prettify.js b/website/static/prettify.js
new file mode 100644
index 0000000000..7b990496dd
--- /dev/null
+++ b/website/static/prettify.js
@@ -0,0 +1,30 @@
+!function(){var q=null;window.PR_SHOULD_USE_CONTINUATION=!0;
+(function(){function S(a){function d(e){var b=e.charCodeAt(0);if(b!==92)return b;var a=e.charAt(1);return(b=r[a])?b:"0"<=a&&a<="7"?parseInt(e.substring(1),8):a==="u"||a==="x"?parseInt(e.substring(2),16):e.charCodeAt(1)}function g(e){if(e<32)return(e<16?"\\x0":"\\x")+e.toString(16);e=String.fromCharCode(e);return e==="\\"||e==="-"||e==="]"||e==="^"?"\\"+e:e}function b(e){var b=e.substring(1,e.length-1).match(/\\u[\dA-Fa-f]{4}|\\x[\dA-Fa-f]{2}|\\[0-3][0-7]{0,2}|\\[0-7]{1,2}|\\[\S\s]|[^\\]/g),e=[],a=
+b[0]==="^",c=["["];a&&c.push("^");for(var a=a?1:0,f=b.length;a<f;++a){var h=b[a];if(/\\[bdsw]/i.test(h))c.push(h);else{var h=d(h),l;a+2<f&&"-"===b[a+1]?(l=d(b[a+2]),a+=2):l=h;e.push([h,l]);l<65||h>122||(l<65||h>90||e.push([Math.max(65,h)|32,Math.min(l,90)|32]),l<97||h>122||e.push([Math.max(97,h)&-33,Math.min(l,122)&-33]))}}e.sort(function(e,a){return e[0]-a[0]||a[1]-e[1]});b=[];f=[];for(a=0;a<e.length;++a)h=e[a],h[0]<=f[1]+1?f[1]=Math.max(f[1],h[1]):b.push(f=h);for(a=0;a<b.length;++a)h=b[a],c.push(g(h[0])),
+h[1]>h[0]&&(h[1]+1>h[0]&&c.push("-"),c.push(g(h[1])));c.push("]");return c.join("")}function s(e){for(var a=e.source.match(/\[(?:[^\\\]]|\\[\S\s])*]|\\u[\dA-Fa-f]{4}|\\x[\dA-Fa-f]{2}|\\\d+|\\[^\dux]|\(\?[!:=]|[()^]|[^()[\\^]+/g),c=a.length,d=[],f=0,h=0;f<c;++f){var l=a[f];l==="("?++h:"\\"===l.charAt(0)&&(l=+l.substring(1))&&(l<=h?d[l]=-1:a[f]=g(l))}for(f=1;f<d.length;++f)-1===d[f]&&(d[f]=++x);for(h=f=0;f<c;++f)l=a[f],l==="("?(++h,d[h]||(a[f]="(?:")):"\\"===l.charAt(0)&&(l=+l.substring(1))&&l<=h&&
+(a[f]="\\"+d[l]);for(f=0;f<c;++f)"^"===a[f]&&"^"!==a[f+1]&&(a[f]="");if(e.ignoreCase&&m)for(f=0;f<c;++f)l=a[f],e=l.charAt(0),l.length>=2&&e==="["?a[f]=b(l):e!=="\\"&&(a[f]=l.replace(/[A-Za-z]/g,function(a){a=a.charCodeAt(0);return"["+String.fromCharCode(a&-33,a|32)+"]"}));return a.join("")}for(var x=0,m=!1,j=!1,k=0,c=a.length;k<c;++k){var i=a[k];if(i.ignoreCase)j=!0;else if(/[a-z]/i.test(i.source.replace(/\\u[\da-f]{4}|\\x[\da-f]{2}|\\[^UXux]/gi,""))){m=!0;j=!1;break}}for(var r={b:8,t:9,n:10,v:11,
+f:12,r:13},n=[],k=0,c=a.length;k<c;++k){i=a[k];if(i.global||i.multiline)throw Error(""+i);n.push("(?:"+s(i)+")")}return RegExp(n.join("|"),j?"gi":"g")}function T(a,d){function g(a){var c=a.nodeType;if(c==1){if(!b.test(a.className)){for(c=a.firstChild;c;c=c.nextSibling)g(c);c=a.nodeName.toLowerCase();if("br"===c||"li"===c)s[j]="\n",m[j<<1]=x++,m[j++<<1|1]=a}}else if(c==3||c==4)c=a.nodeValue,c.length&&(c=d?c.replace(/\r\n?/g,"\n"):c.replace(/[\t\n\r ]+/g," "),s[j]=c,m[j<<1]=x,x+=c.length,m[j++<<1|1]=
+a)}var b=/(?:^|\s)nocode(?:\s|$)/,s=[],x=0,m=[],j=0;g(a);return{a:s.join("").replace(/\n$/,""),d:m}}function H(a,d,g,b){d&&(a={a:d,e:a},g(a),b.push.apply(b,a.g))}function U(a){for(var d=void 0,g=a.firstChild;g;g=g.nextSibling)var b=g.nodeType,d=b===1?d?a:g:b===3?V.test(g.nodeValue)?a:d:d;return d===a?void 0:d}function C(a,d){function g(a){for(var j=a.e,k=[j,"pln"],c=0,i=a.a.match(s)||[],r={},n=0,e=i.length;n<e;++n){var z=i[n],w=r[z],t=void 0,f;if(typeof w==="string")f=!1;else{var h=b[z.charAt(0)];
+if(h)t=z.match(h[1]),w=h[0];else{for(f=0;f<x;++f)if(h=d[f],t=z.match(h[1])){w=h[0];break}t||(w="pln")}if((f=w.length>=5&&"lang-"===w.substring(0,5))&&!(t&&typeof t[1]==="string"))f=!1,w="src";f||(r[z]=w)}h=c;c+=z.length;if(f){f=t[1];var l=z.indexOf(f),B=l+f.length;t[2]&&(B=z.length-t[2].length,l=B-f.length);w=w.substring(5);H(j+h,z.substring(0,l),g,k);H(j+h+l,f,I(w,f),k);H(j+h+B,z.substring(B),g,k)}else k.push(j+h,w)}a.g=k}var b={},s;(function(){for(var g=a.concat(d),j=[],k={},c=0,i=g.length;c<i;++c){var r=
+g[c],n=r[3];if(n)for(var e=n.length;--e>=0;)b[n.charAt(e)]=r;r=r[1];n=""+r;k.hasOwnProperty(n)||(j.push(r),k[n]=q)}j.push(/[\S\s]/);s=S(j)})();var x=d.length;return g}function v(a){var d=[],g=[];a.tripleQuotedStrings?d.push(["str",/^(?:'''(?:[^'\\]|\\[\S\s]|''?(?=[^']))*(?:'''|$)|"""(?:[^"\\]|\\[\S\s]|""?(?=[^"]))*(?:"""|$)|'(?:[^'\\]|\\[\S\s])*(?:'|$)|"(?:[^"\\]|\\[\S\s])*(?:"|$))/,q,"'\""]):a.multiLineStrings?d.push(["str",/^(?:'(?:[^'\\]|\\[\S\s])*(?:'|$)|"(?:[^"\\]|\\[\S\s])*(?:"|$)|`(?:[^\\`]|\\[\S\s])*(?:`|$))/,
+q,"'\"`"]):d.push(["str",/^(?:'(?:[^\n\r'\\]|\\.)*(?:'|$)|"(?:[^\n\r"\\]|\\.)*(?:"|$))/,q,"\"'"]);a.verbatimStrings&&g.push(["str",/^@"(?:[^"]|"")*(?:"|$)/,q]);var b=a.hashComments;b&&(a.cStyleComments?(b>1?d.push(["com",/^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/,q,"#"]):d.push(["com",/^#(?:(?:define|e(?:l|nd)if|else|error|ifn?def|include|line|pragma|undef|warning)\b|[^\n\r]*)/,q,"#"]),g.push(["str",/^<(?:(?:(?:\.\.\/)*|\/?)(?:[\w-]+(?:\/[\w-]+)+)?[\w-]+\.h(?:h|pp|\+\+)?|[a-z]\w*)>/,q])):d.push(["com",
+/^#[^\n\r]*/,q,"#"]));a.cStyleComments&&(g.push(["com",/^\/\/[^\n\r]*/,q]),g.push(["com",/^\/\*[\S\s]*?(?:\*\/|$)/,q]));if(b=a.regexLiterals){var s=(b=b>1?"":"\n\r")?".":"[\\S\\s]";g.push(["lang-regex",RegExp("^(?:^^\\.?|[+-]|[!=]=?=?|\\#|%=?|&&?=?|\\(|\\*=?|[+\\-]=|->|\\/=?|::?|<<?=?|>>?>?=?|,|;|\\?|@|\\[|~|{|\\^\\^?=?|\\|\\|?=?|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\s*("+("/(?=[^/*"+b+"])(?:[^/\\x5B\\x5C"+b+"]|\\x5C"+s+"|\\x5B(?:[^\\x5C\\x5D"+b+"]|\\x5C"+
+s+")*(?:\\x5D|$))+/")+")")])}(b=a.types)&&g.push(["typ",b]);b=(""+a.keywords).replace(/^ | $/g,"");b.length&&g.push(["kwd",RegExp("^(?:"+b.replace(/[\s,]+/g,"|")+")\\b"),q]);d.push(["pln",/^\s+/,q," \r\n\t\u00a0"]);b="^.[^\\s\\w.$@'\"`/\\\\]*";a.regexLiterals&&(b+="(?!s*/)");g.push(["lit",/^@[$_a-z][\w$@]*/i,q],["typ",/^(?:[@_]?[A-Z]+[a-z][\w$@]*|\w+_t\b)/,q],["pln",/^[$_a-z][\w$@]*/i,q],["lit",/^(?:0x[\da-f]+|(?:\d(?:_\d+)*\d*(?:\.\d*)?|\.\d\+)(?:e[+-]?\d+)?)[a-z]*/i,q,"0123456789"],["pln",/^\\[\S\s]?/,
+q],["pun",RegExp(b),q]);return C(d,g)}function J(a,d,g){function b(a){var c=a.nodeType;if(c==1&&!x.test(a.className))if("br"===a.nodeName)s(a),a.parentNode&&a.parentNode.removeChild(a);else for(a=a.firstChild;a;a=a.nextSibling)b(a);else if((c==3||c==4)&&g){var d=a.nodeValue,i=d.match(m);if(i)c=d.substring(0,i.index),a.nodeValue=c,(d=d.substring(i.index+i[0].length))&&a.parentNode.insertBefore(j.createTextNode(d),a.nextSibling),s(a),c||a.parentNode.removeChild(a)}}function s(a){function b(a,c){var d=
+c?a.cloneNode(!1):a,e=a.parentNode;if(e){var e=b(e,1),g=a.nextSibling;e.appendChild(d);for(var i=g;i;i=g)g=i.nextSibling,e.appendChild(i)}return d}for(;!a.nextSibling;)if(a=a.parentNode,!a)return;for(var a=b(a.nextSibling,0),d;(d=a.parentNode)&&d.nodeType===1;)a=d;c.push(a)}for(var x=/(?:^|\s)nocode(?:\s|$)/,m=/\r\n?|\n/,j=a.ownerDocument,k=j.createElement("li");a.firstChild;)k.appendChild(a.firstChild);for(var c=[k],i=0;i<c.length;++i)b(c[i]);d===(d|0)&&c[0].setAttribute("value",d);var r=j.createElement("ol");
+r.className="linenums";for(var d=Math.max(0,d-1|0)||0,i=0,n=c.length;i<n;++i)k=c[i],k.className="L"+(i+d)%10,k.firstChild||k.appendChild(j.createTextNode("\u00a0")),r.appendChild(k);a.appendChild(r)}function p(a,d){for(var g=d.length;--g>=0;){var b=d[g];F.hasOwnProperty(b)?D.console&&console.warn("cannot override language handler %s",b):F[b]=a}}function I(a,d){if(!a||!F.hasOwnProperty(a))a=/^\s*</.test(d)?"default-markup":"default-code";return F[a]}function K(a){var d=a.h;try{var g=T(a.c,a.i),b=g.a;
+a.a=b;a.d=g.d;a.e=0;I(d,b)(a);var s=/\bMSIE\s(\d+)/.exec(navigator.userAgent),s=s&&+s[1]<=8,d=/\n/g,x=a.a,m=x.length,g=0,j=a.d,k=j.length,b=0,c=a.g,i=c.length,r=0;c[i]=m;var n,e;for(e=n=0;e<i;)c[e]!==c[e+2]?(c[n++]=c[e++],c[n++]=c[e++]):e+=2;i=n;for(e=n=0;e<i;){for(var p=c[e],w=c[e+1],t=e+2;t+2<=i&&c[t+1]===w;)t+=2;c[n++]=p;c[n++]=w;e=t}c.length=n;var f=a.c,h;if(f)h=f.style.display,f.style.display="none";try{for(;b<k;){var l=j[b+2]||m,B=c[r+2]||m,t=Math.min(l,B),A=j[b+1],G;if(A.nodeType!==1&&(G=x.substring(g,
+t))){s&&(G=G.replace(d,"\r"));A.nodeValue=G;var L=A.ownerDocument,o=L.createElement("span");o.className=c[r+1];var v=A.parentNode;v.replaceChild(o,A);o.appendChild(A);g<l&&(j[b+1]=A=L.createTextNode(x.substring(t,l)),v.insertBefore(A,o.nextSibling))}g=t;g>=l&&(b+=2);g>=B&&(r+=2)}}finally{if(f)f.style.display=h}}catch(u){D.console&&console.log(u&&u.stack||u)}}var D=window,y=["break,continue,do,else,for,if,return,while"],E=[[y,"auto,case,char,const,default,double,enum,extern,float,goto,inline,int,long,register,short,signed,sizeof,static,struct,switch,typedef,union,unsigned,void,volatile"],
+"catch,class,delete,false,import,new,operator,private,protected,public,this,throw,true,try,typeof"],M=[E,"alignof,align_union,asm,axiom,bool,concept,concept_map,const_cast,constexpr,decltype,delegate,dynamic_cast,explicit,export,friend,generic,late_check,mutable,namespace,nullptr,property,reinterpret_cast,static_assert,static_cast,template,typeid,typename,using,virtual,where"],N=[E,"abstract,assert,boolean,byte,extends,final,finally,implements,import,instanceof,interface,null,native,package,strictfp,super,synchronized,throws,transient"],
+O=[N,"as,base,by,checked,decimal,delegate,descending,dynamic,event,fixed,foreach,from,group,implicit,in,internal,into,is,let,lock,object,out,override,orderby,params,partial,readonly,ref,sbyte,sealed,stackalloc,string,select,uint,ulong,unchecked,unsafe,ushort,var,virtual,where"],E=[E,"debugger,eval,export,function,get,null,set,undefined,var,with,Infinity,NaN"],P=[y,"and,as,assert,class,def,del,elif,except,exec,finally,from,global,import,in,is,lambda,nonlocal,not,or,pass,print,raise,try,with,yield,False,True,None"],
+Q=[y,"alias,and,begin,case,class,def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,rescue,retry,self,super,then,true,undef,unless,until,when,yield,BEGIN,END"],W=[y,"as,assert,const,copy,drop,enum,extern,fail,false,fn,impl,let,log,loop,match,mod,move,mut,priv,pub,pure,ref,self,static,struct,true,trait,type,unsafe,use"],y=[y,"case,done,elif,esac,eval,fi,function,in,local,set,then,until"],R=/^(DIR|FILE|vector|(de|priority_)?queue|list|stack|(const_)?iterator|(multi)?(set|map)|bitset|u?(int|float)\d*)\b/,
+V=/\S/,X=v({keywords:[M,O,E,"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END",P,Q,y],hashComments:!0,cStyleComments:!0,multiLineStrings:!0,regexLiterals:!0}),F={};p(X,["default-code"]);p(C([],[["pln",/^[^<?]+/],["dec",/^<!\w[^>]*(?:>|$)/],["com",/^<\!--[\S\s]*?(?:--\>|$)/],["lang-",/^<\?([\S\s]+?)(?:\?>|$)/],["lang-",/^<%([\S\s]+?)(?:%>|$)/],["pun",/^(?:<[%?]|[%?]>)/],["lang-",
+/^<xmp\b[^>]*>([\S\s]+?)<\/xmp\b[^>]*>/i],["lang-js",/^<script\b[^>]*>([\S\s]*?)(<\/script\b[^>]*>)/i],["lang-css",/^<style\b[^>]*>([\S\s]*?)(<\/style\b[^>]*>)/i],["lang-in.tag",/^(<\/?[a-z][^<>]*>)/i]]),["default-markup","htm","html","mxml","xhtml","xml","xsl"]);p(C([["pln",/^\s+/,q," \t\r\n"],["atv",/^(?:"[^"]*"?|'[^']*'?)/,q,"\"'"]],[["tag",/^^<\/?[a-z](?:[\w-.:]*\w)?|\/?>$/i],["atn",/^(?!style[\s=]|on)[a-z](?:[\w:-]*\w)?/i],["lang-uq.val",/^=\s*([^\s"'>]*(?:[^\s"'/>]|\/(?=\s)))/],["pun",/^[/<->]+/],
+["lang-js",/^on\w+\s*=\s*"([^"]+)"/i],["lang-js",/^on\w+\s*=\s*'([^']+)'/i],["lang-js",/^on\w+\s*=\s*([^\s"'>]+)/i],["lang-css",/^style\s*=\s*"([^"]+)"/i],["lang-css",/^style\s*=\s*'([^']+)'/i],["lang-css",/^style\s*=\s*([^\s"'>]+)/i]]),["in.tag"]);p(C([],[["atv",/^[\S\s]+/]]),["uq.val"]);p(v({keywords:M,hashComments:!0,cStyleComments:!0,types:R}),["c","cc","cpp","cxx","cyc","m"]);p(v({keywords:"null,true,false"}),["json"]);p(v({keywords:O,hashComments:!0,cStyleComments:!0,verbatimStrings:!0,types:R}),
+["cs"]);p(v({keywords:N,cStyleComments:!0}),["java"]);p(v({keywords:y,hashComments:!0,multiLineStrings:!0}),["bash","bsh","csh","sh"]);p(v({keywords:P,hashComments:!0,multiLineStrings:!0,tripleQuotedStrings:!0}),["cv","py","python"]);p(v({keywords:"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END",hashComments:!0,multiLineStrings:!0,regexLiterals:2}),["perl","pl","pm"]);p(v({keywords:Q,
+hashComments:!0,multiLineStrings:!0,regexLiterals:!0}),["rb","ruby"]);p(v({keywords:E,cStyleComments:!0,regexLiterals:!0}),["javascript","js"]);p(v({keywords:"all,and,by,catch,class,else,extends,false,finally,for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,throw,true,try,unless,until,when,while,yes",hashComments:3,cStyleComments:!0,multilineStrings:!0,tripleQuotedStrings:!0,regexLiterals:!0}),["coffee"]);p(v({keywords:W,cStyleComments:!0,multilineStrings:!0}),["rc","rs","rust"]);
+p(C([],[["str",/^[\S\s]+/]]),["regex"]);var Y=D.PR={createSimpleLexer:C,registerLangHandler:p,sourceDecorator:v,PR_ATTRIB_NAME:"atn",PR_ATTRIB_VALUE:"atv",PR_COMMENT:"com",PR_DECLARATION:"dec",PR_KEYWORD:"kwd",PR_LITERAL:"lit",PR_NOCODE:"nocode",PR_PLAIN:"pln",PR_PUNCTUATION:"pun",PR_SOURCE:"src",PR_STRING:"str",PR_TAG:"tag",PR_TYPE:"typ",prettyPrintOne:D.prettyPrintOne=function(a,d,g){var b=document.createElement("div");b.innerHTML="<pre>"+a+"</pre>";b=b.firstChild;g&&J(b,g,!0);K({h:d,j:g,c:b,i:1});
+return b.innerHTML},prettyPrint:D.prettyPrint=function(a,d){function g(){for(var b=D.PR_SHOULD_USE_CONTINUATION?c.now()+250:Infinity;i<p.length&&c.now()<b;i++){for(var d=p[i],j=h,k=d;k=k.previousSibling;){var m=k.nodeType,o=(m===7||m===8)&&k.nodeValue;if(o?!/^\??prettify\b/.test(o):m!==3||/\S/.test(k.nodeValue))break;if(o){j={};o.replace(/\b(\w+)=([\w%+\-.:]+)/g,function(a,b,c){j[b]=c});break}}k=d.className;if((j!==h||e.test(k))&&!v.test(k)){m=!1;for(o=d.parentNode;o;o=o.parentNode)if(f.test(o.tagName)&&
+o.className&&e.test(o.className)){m=!0;break}if(!m){d.className+=" prettyprinted";m=j.lang;if(!m){var m=k.match(n),y;if(!m&&(y=U(d))&&t.test(y.tagName))m=y.className.match(n);m&&(m=m[1])}if(w.test(d.tagName))o=1;else var o=d.currentStyle,u=s.defaultView,o=(o=o?o.whiteSpace:u&&u.getComputedStyle?u.getComputedStyle(d,q).getPropertyValue("white-space"):0)&&"pre"===o.substring(0,3);u=j.linenums;if(!(u=u==="true"||+u))u=(u=k.match(/\blinenums\b(?::(\d+))?/))?u[1]&&u[1].length?+u[1]:!0:!1;u&&J(d,u,o);r=
+{h:m,c:d,j:u,i:o};K(r)}}}i<p.length?setTimeout(g,250):"function"===typeof a&&a()}for(var b=d||document.body,s=b.ownerDocument||document,b=[b.getElementsByTagName("pre"),b.getElementsByTagName("code"),b.getElementsByTagName("xmp")],p=[],m=0;m<b.length;++m)for(var j=0,k=b[m].length;j<k;++j)p.push(b[m][j]);var b=q,c=Date;c.now||(c={now:function(){return+new Date}});var i=0,r,n=/\blang(?:uage)?-([\w.]+)(?!\S)/,e=/\bprettyprint\b/,v=/\bprettyprinted\b/,w=/pre|xmp/i,t=/^code$/i,f=/^(?:pre|code|xmp)$/i,
+h={};g()}};typeof define==="function"&&define.amd&&define("google-code-prettify",[],function(){return Y})})();}()
