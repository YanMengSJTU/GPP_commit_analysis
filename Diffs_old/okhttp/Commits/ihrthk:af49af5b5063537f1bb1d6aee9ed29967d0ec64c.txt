diff --git a/okhttp/src/main/java-templates/com/squareup/okhttp/internal/Version.java b/okhttp/src/main/java-templates/com/squareup/okhttp/internal/Version.java
index 59fece92bf..980e894910 100644
--- a/okhttp/src/main/java-templates/com/squareup/okhttp/internal/Version.java
+++ b/okhttp/src/main/java-templates/com/squareup/okhttp/internal/Version.java
@@ -16,10 +16,10 @@
 package com.squareup.okhttp.internal;
 
 public final class Version {
-  public static String userAgent() {
-    return "okhttp/${project.version}";
-  }
+    public static String userAgent() {
+        return "okhttp/${project.version}";
+    }
 
-  private Version() {
-  }
+    private Version() {
+    }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Address.java b/okhttp/src/main/java/com/squareup/okhttp/Address.java
index 6f6ce08d5f..5deb8a8b9b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Address.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Address.java
@@ -16,9 +16,11 @@
 package com.squareup.okhttp;
 
 import com.squareup.okhttp.internal.Util;
+
 import java.net.Proxy;
 import java.net.ProxySelector;
 import java.util.List;
+
 import javax.net.SocketFactory;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLSocketFactory;
@@ -31,150 +33,156 @@
  * {@linkplain Proxy#NO_PROXY no proxy} is explicitly requested), this also includes
  * that proxy information. For secure connections the address also includes the
  * SSL socket factory and hostname verifier.
- *
+ * <p/>
  * <p>HTTP requests that share the same {@code Address} may also share the same
  * {@link Connection}.
  */
 public final class Address {
-  final Proxy proxy;
-  final String uriHost;
-  final int uriPort;
-  final SocketFactory socketFactory;
-  final SSLSocketFactory sslSocketFactory;
-  final HostnameVerifier hostnameVerifier;
-  final CertificatePinner certificatePinner;
-  final Authenticator authenticator;
-  final List<Protocol> protocols;
-  final List<ConnectionSpec> connectionSpecs;
-  final ProxySelector proxySelector;
-
-  public Address(String uriHost, int uriPort, SocketFactory socketFactory,
-      SSLSocketFactory sslSocketFactory, HostnameVerifier hostnameVerifier,
-      CertificatePinner certificatePinner, Authenticator authenticator, Proxy proxy,
-      List<Protocol> protocols, List<ConnectionSpec> connectionSpecs, ProxySelector proxySelector) {
-    if (uriHost == null) throw new NullPointerException("uriHost == null");
-    if (uriPort <= 0) throw new IllegalArgumentException("uriPort <= 0: " + uriPort);
-    if (authenticator == null) throw new IllegalArgumentException("authenticator == null");
-    if (protocols == null) throw new IllegalArgumentException("protocols == null");
-    if (proxySelector == null) throw new IllegalArgumentException("proxySelector == null");
-    this.proxy = proxy;
-    this.uriHost = uriHost;
-    this.uriPort = uriPort;
-    this.socketFactory = socketFactory;
-    this.sslSocketFactory = sslSocketFactory;
-    this.hostnameVerifier = hostnameVerifier;
-    this.certificatePinner = certificatePinner;
-    this.authenticator = authenticator;
-    this.protocols = Util.immutableList(protocols);
-    this.connectionSpecs = Util.immutableList(connectionSpecs);
-    this.proxySelector = proxySelector;
-  }
-
-  /** Returns the hostname of the origin server. */
-  public String getUriHost() {
-    return uriHost;
-  }
-
-  /**
-   * Returns the port of the origin server; typically 80 or 443. Unlike
-   * may {@code getPort()} accessors, this method never returns -1.
-   */
-  public int getUriPort() {
-    return uriPort;
-  }
-
-  /** Returns the socket factory for new connections. */
-  public SocketFactory getSocketFactory() {
-    return socketFactory;
-  }
-
-  /**
-   * Returns the SSL socket factory, or null if this is not an HTTPS
-   * address.
-   */
-  public SSLSocketFactory getSslSocketFactory() {
-    return sslSocketFactory;
-  }
-
-  /**
-   * Returns the hostname verifier, or null if this is not an HTTPS
-   * address.
-   */
-  public HostnameVerifier getHostnameVerifier() {
-    return hostnameVerifier;
-  }
-
-  /**
-   * Returns the client's authenticator. This method never returns null.
-   */
-  public Authenticator getAuthenticator() {
-    return authenticator;
-  }
-
-  /**
-   * Returns the protocols the client supports. This method always returns a
-   * non-null list that contains minimally {@link Protocol#HTTP_1_1}.
-   */
-  public List<Protocol> getProtocols() {
-    return protocols;
-  }
-
-  public List<ConnectionSpec> getConnectionSpecs() {
-    return connectionSpecs;
-  }
-
-  /**
-   * Returns this address's explicitly-specified HTTP proxy, or null to
-   * delegate to the {@linkplain #getProxySelector proxy selector}.
-   */
-  public Proxy getProxy() {
-    return proxy;
-  }
-
-  /**
-   * Returns this address's proxy selector. Only used if the proxy is null. If none of this
-   * selector's proxies are reachable, a direct connection will be attempted.
-   */
-  public ProxySelector getProxySelector() {
-    return proxySelector;
-  }
-
-  /**
-   * Returns this address's certificate pinner. Only used for secure connections.
-   */
-  public CertificatePinner getCertificatePinner() {
-    return certificatePinner;
-  }
-
-  @Override public boolean equals(Object other) {
-    if (other instanceof Address) {
-      Address that = (Address) other;
-      return equal(this.proxy, that.proxy)
-          && this.uriHost.equals(that.uriHost)
-          && this.uriPort == that.uriPort
-          && equal(this.sslSocketFactory, that.sslSocketFactory)
-          && equal(this.hostnameVerifier, that.hostnameVerifier)
-          && equal(this.certificatePinner, that.certificatePinner)
-          && equal(this.authenticator, that.authenticator)
-          && equal(this.protocols, that.protocols)
-          && equal(this.connectionSpecs, that.connectionSpecs)
-          && equal(this.proxySelector, that.proxySelector);
+    final Proxy proxy;
+    final String uriHost;
+    final int uriPort;
+    final SocketFactory socketFactory;
+    final SSLSocketFactory sslSocketFactory;
+    final HostnameVerifier hostnameVerifier;
+    final CertificatePinner certificatePinner;
+    final Authenticator authenticator;
+    final List<Protocol> protocols;
+    final List<ConnectionSpec> connectionSpecs;
+    final ProxySelector proxySelector;
+
+    public Address(String uriHost, int uriPort, SocketFactory socketFactory,
+                   SSLSocketFactory sslSocketFactory, HostnameVerifier hostnameVerifier,
+                   CertificatePinner certificatePinner, Authenticator authenticator, Proxy proxy,
+                   List<Protocol> protocols, List<ConnectionSpec> connectionSpecs, ProxySelector proxySelector) {
+        if (uriHost == null) throw new NullPointerException("uriHost == null");
+        if (uriPort <= 0) throw new IllegalArgumentException("uriPort <= 0: " + uriPort);
+        if (authenticator == null) throw new IllegalArgumentException("authenticator == null");
+        if (protocols == null) throw new IllegalArgumentException("protocols == null");
+        if (proxySelector == null) throw new IllegalArgumentException("proxySelector == null");
+        this.proxy = proxy;
+        this.uriHost = uriHost;
+        this.uriPort = uriPort;
+        this.socketFactory = socketFactory;
+        this.sslSocketFactory = sslSocketFactory;
+        this.hostnameVerifier = hostnameVerifier;
+        this.certificatePinner = certificatePinner;
+        this.authenticator = authenticator;
+        this.protocols = Util.immutableList(protocols);
+        this.connectionSpecs = Util.immutableList(connectionSpecs);
+        this.proxySelector = proxySelector;
+    }
+
+    /**
+     * Returns the hostname of the origin server.
+     */
+    public String getUriHost() {
+        return uriHost;
+    }
+
+    /**
+     * Returns the port of the origin server; typically 80 or 443. Unlike
+     * may {@code getPort()} accessors, this method never returns -1.
+     */
+    public int getUriPort() {
+        return uriPort;
+    }
+
+    /**
+     * Returns the socket factory for new connections.
+     */
+    public SocketFactory getSocketFactory() {
+        return socketFactory;
+    }
+
+    /**
+     * Returns the SSL socket factory, or null if this is not an HTTPS
+     * address.
+     */
+    public SSLSocketFactory getSslSocketFactory() {
+        return sslSocketFactory;
+    }
+
+    /**
+     * Returns the hostname verifier, or null if this is not an HTTPS
+     * address.
+     */
+    public HostnameVerifier getHostnameVerifier() {
+        return hostnameVerifier;
+    }
+
+    /**
+     * Returns the client's authenticator. This method never returns null.
+     */
+    public Authenticator getAuthenticator() {
+        return authenticator;
+    }
+
+    /**
+     * Returns the protocols the client supports. This method always returns a
+     * non-null list that contains minimally {@link Protocol#HTTP_1_1}.
+     */
+    public List<Protocol> getProtocols() {
+        return protocols;
+    }
+
+    public List<ConnectionSpec> getConnectionSpecs() {
+        return connectionSpecs;
+    }
+
+    /**
+     * Returns this address's explicitly-specified HTTP proxy, or null to
+     * delegate to the {@linkplain #getProxySelector proxy selector}.
+     */
+    public Proxy getProxy() {
+        return proxy;
+    }
+
+    /**
+     * Returns this address's proxy selector. Only used if the proxy is null. If none of this
+     * selector's proxies are reachable, a direct connection will be attempted.
+     */
+    public ProxySelector getProxySelector() {
+        return proxySelector;
+    }
+
+    /**
+     * Returns this address's certificate pinner. Only used for secure connections.
+     */
+    public CertificatePinner getCertificatePinner() {
+        return certificatePinner;
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (other instanceof Address) {
+            Address that = (Address) other;
+            return equal(this.proxy, that.proxy)
+                    && this.uriHost.equals(that.uriHost)
+                    && this.uriPort == that.uriPort
+                    && equal(this.sslSocketFactory, that.sslSocketFactory)
+                    && equal(this.hostnameVerifier, that.hostnameVerifier)
+                    && equal(this.certificatePinner, that.certificatePinner)
+                    && equal(this.authenticator, that.authenticator)
+                    && equal(this.protocols, that.protocols)
+                    && equal(this.connectionSpecs, that.connectionSpecs)
+                    && equal(this.proxySelector, that.proxySelector);
+        }
+        return false;
+    }
+
+    @Override
+    public int hashCode() {
+        int result = 17;
+        result = 31 * result + (proxy != null ? proxy.hashCode() : 0);
+        result = 31 * result + uriHost.hashCode();
+        result = 31 * result + uriPort;
+        result = 31 * result + (sslSocketFactory != null ? sslSocketFactory.hashCode() : 0);
+        result = 31 * result + (hostnameVerifier != null ? hostnameVerifier.hashCode() : 0);
+        result = 31 * result + (certificatePinner != null ? certificatePinner.hashCode() : 0);
+        result = 31 * result + authenticator.hashCode();
+        result = 31 * result + protocols.hashCode();
+        result = 31 * result + connectionSpecs.hashCode();
+        result = 31 * result + proxySelector.hashCode();
+        return result;
     }
-    return false;
-  }
-
-  @Override public int hashCode() {
-    int result = 17;
-    result = 31 * result + (proxy != null ? proxy.hashCode() : 0);
-    result = 31 * result + uriHost.hashCode();
-    result = 31 * result + uriPort;
-    result = 31 * result + (sslSocketFactory != null ? sslSocketFactory.hashCode() : 0);
-    result = 31 * result + (hostnameVerifier != null ? hostnameVerifier.hashCode() : 0);
-    result = 31 * result + (certificatePinner != null ? certificatePinner.hashCode() : 0);
-    result = 31 * result + authenticator.hashCode();
-    result = 31 * result + protocols.hashCode();
-    result = 31 * result + connectionSpecs.hashCode();
-    result = 31 * result + proxySelector.hashCode();
-    return result;
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Authenticator.java b/okhttp/src/main/java/com/squareup/okhttp/Authenticator.java
index cb66dc6249..4e4ccbd870 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Authenticator.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Authenticator.java
@@ -22,39 +22,39 @@
  * Responds to authentication challenges from the remote web or proxy server.
  */
 public interface Authenticator {
-  /**
-   * Returns a request that includes a credential to satisfy an authentication
-   * challenge in {@code response}. Returns null if the challenge cannot be
-   * satisfied. This method is called in response to an HTTP 401 unauthorized
-   * status code sent by the origin server.
-   *
-   * <p>Typical implementations will look up a credential and create a request
-   * derived from the initial request by setting the "Authorization" header.
-   * <pre>   {@code
-   *
-   *    String credential = Credentials.basic(...)
-   *    return response.request().newBuilder()
-   *        .header("Authorization", credential)
-   *        .build();
-   * }</pre>
-   */
-  Request authenticate(Proxy proxy, Response response) throws IOException;
+    /**
+     * Returns a request that includes a credential to satisfy an authentication
+     * challenge in {@code response}. Returns null if the challenge cannot be
+     * satisfied. This method is called in response to an HTTP 401 unauthorized
+     * status code sent by the origin server.
+     * <p/>
+     * <p>Typical implementations will look up a credential and create a request
+     * derived from the initial request by setting the "Authorization" header.
+     * <pre>   {@code
+     * <p/>
+     *    String credential = Credentials.basic(...)
+     *    return response.request().newBuilder()
+     *        .header("Authorization", credential)
+     *        .build();
+     * }</pre>
+     */
+    Request authenticate(Proxy proxy, Response response) throws IOException;
 
-  /**
-   * Returns a request that includes a credential to satisfy an authentication
-   * challenge made by {@code response}. Returns null if the challenge cannot be
-   * satisfied. This method is called in response to an HTTP 407 unauthorized
-   * status code sent by the proxy server.
-   *
-   * <p>Typical implementations will look up a credential and create a request
-   * derived from the initial request by setting the "Proxy-Authorization"
-   * header. <pre>   {@code
-   *
-   *    String credential = Credentials.basic(...)
-   *    return response.request().newBuilder()
-   *        .header("Proxy-Authorization", credential)
-   *        .build();
-   * }</pre>
-   */
-  Request authenticateProxy(Proxy proxy, Response response) throws IOException;
+    /**
+     * Returns a request that includes a credential to satisfy an authentication
+     * challenge made by {@code response}. Returns null if the challenge cannot be
+     * satisfied. This method is called in response to an HTTP 407 unauthorized
+     * status code sent by the proxy server.
+     * <p/>
+     * <p>Typical implementations will look up a credential and create a request
+     * derived from the initial request by setting the "Proxy-Authorization"
+     * header. <pre>   {@code
+     * <p/>
+     *    String credential = Credentials.basic(...)
+     *    return response.request().newBuilder()
+     *        .header("Proxy-Authorization", credential)
+     *        .build();
+     * }</pre>
+     */
+    Request authenticateProxy(Proxy proxy, Response response) throws IOException;
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Cache.java b/okhttp/src/main/java/com/squareup/okhttp/Cache.java
index 03c37a55d7..e572efabc6 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Cache.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Cache.java
@@ -25,6 +25,7 @@
 import com.squareup.okhttp.internal.http.OkHeaders;
 import com.squareup.okhttp.internal.http.StatusLine;
 import com.squareup.okhttp.internal.io.FileSystem;
+
 import java.io.File;
 import java.io.IOException;
 import java.security.cert.Certificate;
@@ -36,6 +37,7 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.NoSuchElementException;
+
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -49,42 +51,42 @@
 /**
  * Caches HTTP and HTTPS responses to the filesystem so they may be reused, saving time and
  * bandwidth.
- *
+ * <p/>
  * <h3>Cache Optimization</h3>
  * To measure cache effectiveness, this class tracks three statistics:
  * <ul>
- *   <li><strong>{@linkplain #getRequestCount() Request Count:}</strong> the number of HTTP
- *     requests issued since this cache was created.
- *   <li><strong>{@linkplain #getNetworkCount() Network Count:}</strong> the number of those
- *     requests that required network use.
- *   <li><strong>{@linkplain #getHitCount() Hit Count:}</strong> the number of those requests whose
- *     responses were served by the cache.
+ * <li><strong>{@linkplain #getRequestCount() Request Count:}</strong> the number of HTTP
+ * requests issued since this cache was created.
+ * <li><strong>{@linkplain #getNetworkCount() Network Count:}</strong> the number of those
+ * requests that required network use.
+ * <li><strong>{@linkplain #getHitCount() Hit Count:}</strong> the number of those requests whose
+ * responses were served by the cache.
  * </ul>
- *
+ * <p/>
  * Sometimes a request will result in a conditional cache hit. If the cache contains a stale copy of
  * the response, the client will issue a conditional {@code GET}. The server will then send either
  * the updated response if it has changed, or a short 'not modified' response if the client's copy
  * is still valid. Such responses increment both the network count and hit count.
- *
+ * <p/>
  * <p>The best way to improve the cache hit rate is by configuring the web server to return
  * cacheable responses. Although this client honors all <a
  * href="http://tools.ietf.org/html/rfc7234">HTTP/1.1 (RFC 7234)</a> cache headers, it doesn't cache
  * partial responses.
- *
+ * <p/>
  * <h3>Force a Network Response</h3>
  * In some situations, such as after a user clicks a 'refresh' button, it may be necessary to skip
  * the cache, and fetch data directly from the server. To force a full refresh, add the {@code
  * no-cache} directive: <pre>   {@code
- *
+ * <p/>
  *   Request request = new Request.Builder()
  *       .cacheControl(new CacheControl.Builder().noCache().build())
  *       .url("http://publicobject.com/helloworld.txt")
  *       .build();
  * }</pre>
- *
+ * <p/>
  * If it is only necessary to force a cached response to be validated by the server, use the more
  * efficient {@code max-age=0} directive instead: <pre>   {@code
- *
+ * <p/>
  *   Request request = new Request.Builder()
  *       .cacheControl(new CacheControl.Builder()
  *           .maxAge(0, TimeUnit.SECONDS)
@@ -92,13 +94,13 @@
  *       .url("http://publicobject.com/helloworld.txt")
  *       .build();
  * }</pre>
- *
+ * <p/>
  * <h3>Force a Cache Response</h3>
  * Sometimes you'll want to show resources if they are available immediately, but not otherwise.
  * This can be used so your application can show <i>something</i> while waiting for the latest data
  * to be downloaded. To restrict a request to locally-cached resources, add the {@code
  * only-if-cached} directive: <pre>   {@code
- *
+ * <p/>
  *     Request request = new Request.Builder()
  *         .cacheControl(new CacheControl.Builder()
  *             .onlyIfCached()
@@ -115,7 +117,7 @@
  * This technique works even better in situations where a stale response is better than no response.
  * To permit stale cached responses, use the {@code max-stale} directive with the maximum staleness
  * in seconds: <pre>   {@code
- *
+ * <p/>
  *   Request request = new Request.Builder()
  *       .cacheControl(new CacheControl.Builder()
  *           .maxStale(365, TimeUnit.DAYS)
@@ -123,586 +125,608 @@
  *       .url("http://publicobject.com/helloworld.txt")
  *       .build();
  * }</pre>
- *
+ * <p/>
  * <p>The {@link CacheControl} class can configure request caching directives and parse response
  * caching directives. It even offers convenient constants {@link CacheControl#FORCE_NETWORK} and
  * {@link CacheControl#FORCE_CACHE} that address the use cases above.
  */
 public final class Cache {
-  private static final int VERSION = 201105;
-  private static final int ENTRY_METADATA = 0;
-  private static final int ENTRY_BODY = 1;
-  private static final int ENTRY_COUNT = 2;
-
-  final InternalCache internalCache = new InternalCache() {
-    @Override public Response get(Request request) throws IOException {
-      return Cache.this.get(request);
-    }
-    @Override public CacheRequest put(Response response) throws IOException {
-      return Cache.this.put(response);
-    }
-    @Override public void remove(Request request) throws IOException {
-      Cache.this.remove(request);
-    }
-    @Override public void update(Response cached, Response network) throws IOException {
-      Cache.this.update(cached, network);
-    }
-    @Override public void trackConditionalCacheHit() {
-      Cache.this.trackConditionalCacheHit();
-    }
-    @Override public void trackResponse(CacheStrategy cacheStrategy) {
-      Cache.this.trackResponse(cacheStrategy);
-    }
-  };
-
-  private final DiskLruCache cache;
-
-  /* read and write statistics, all guarded by 'this' */
-  private int writeSuccessCount;
-  private int writeAbortCount;
-  private int networkCount;
-  private int hitCount;
-  private int requestCount;
-
-  public Cache(File directory, long maxSize) {
-    cache = DiskLruCache.create(FileSystem.SYSTEM, directory, VERSION, ENTRY_COUNT, maxSize);
-  }
-
-  private static String urlToKey(Request request) {
-    return Util.md5Hex(request.urlString());
-  }
-
-  Response get(Request request) {
-    String key = urlToKey(request);
-    DiskLruCache.Snapshot snapshot;
-    Entry entry;
-    try {
-      snapshot = cache.get(key);
-      if (snapshot == null) {
-        return null;
-      }
-    } catch (IOException e) {
-      // Give up because the cache cannot be read.
-      return null;
-    }
+    private static final int VERSION = 201105;
+    private static final int ENTRY_METADATA = 0;
+    private static final int ENTRY_BODY = 1;
+    private static final int ENTRY_COUNT = 2;
+
+    final InternalCache internalCache = new InternalCache() {
+        @Override
+        public Response get(Request request) throws IOException {
+            return Cache.this.get(request);
+        }
 
-    try {
-      entry = new Entry(snapshot.getSource(ENTRY_METADATA));
-    } catch (IOException e) {
-      Util.closeQuietly(snapshot);
-      return null;
-    }
+        @Override
+        public CacheRequest put(Response response) throws IOException {
+            return Cache.this.put(response);
+        }
 
-    Response response = entry.response(request, snapshot);
+        @Override
+        public void remove(Request request) throws IOException {
+            Cache.this.remove(request);
+        }
 
-    if (!entry.matches(request, response)) {
-      Util.closeQuietly(response.body());
-      return null;
-    }
+        @Override
+        public void update(Response cached, Response network) throws IOException {
+            Cache.this.update(cached, network);
+        }
 
-    return response;
-  }
+        @Override
+        public void trackConditionalCacheHit() {
+            Cache.this.trackConditionalCacheHit();
+        }
+
+        @Override
+        public void trackResponse(CacheStrategy cacheStrategy) {
+            Cache.this.trackResponse(cacheStrategy);
+        }
+    };
 
-  private CacheRequest put(Response response) throws IOException {
-    String requestMethod = response.request().method();
+    private final DiskLruCache cache;
 
-    if (HttpMethod.invalidatesCache(response.request().method())) {
-      try {
-        remove(response.request());
-      } catch (IOException ignored) {
-        // The cache cannot be written.
-      }
-      return null;
-    }
-    if (!requestMethod.equals("GET")) {
-      // Don't cache non-GET responses. We're technically allowed to cache
-      // HEAD requests and some POST requests, but the complexity of doing
-      // so is high and the benefit is low.
-      return null;
-    }
+    /* read and write statistics, all guarded by 'this' */
+    private int writeSuccessCount;
+    private int writeAbortCount;
+    private int networkCount;
+    private int hitCount;
+    private int requestCount;
 
-    if (OkHeaders.hasVaryAll(response)) {
-      return null;
+    public Cache(File directory, long maxSize) {
+        cache = DiskLruCache.create(FileSystem.SYSTEM, directory, VERSION, ENTRY_COUNT, maxSize);
     }
 
-    Entry entry = new Entry(response);
-    DiskLruCache.Editor editor = null;
-    try {
-      editor = cache.edit(urlToKey(response.request()));
-      if (editor == null) {
-        return null;
-      }
-      entry.writeTo(editor);
-      return new CacheRequestImpl(editor);
-    } catch (IOException e) {
-      abortQuietly(editor);
-      return null;
-    }
-  }
-
-  private void remove(Request request) throws IOException {
-    cache.remove(urlToKey(request));
-  }
-
-  private void update(Response cached, Response network) {
-    Entry entry = new Entry(network);
-    DiskLruCache.Snapshot snapshot = ((CacheResponseBody) cached.body()).snapshot;
-    DiskLruCache.Editor editor = null;
-    try {
-      editor = snapshot.edit(); // Returns null if snapshot is not current.
-      if (editor != null) {
-        entry.writeTo(editor);
-        editor.commit();
-      }
-    } catch (IOException e) {
-      abortQuietly(editor);
+    private static String urlToKey(Request request) {
+        return Util.md5Hex(request.urlString());
     }
-  }
-
-  private void abortQuietly(DiskLruCache.Editor editor) {
-    // Give up because the cache cannot be written.
-    try {
-      if (editor != null) {
-        editor.abort();
-      }
-    } catch (IOException ignored) {
-    }
-  }
-
-  /**
-   * Closes the cache and deletes all of its stored values. This will delete
-   * all files in the cache directory including files that weren't created by
-   * the cache.
-   */
-  public void delete() throws IOException {
-    cache.delete();
-  }
-
-  /**
-   * Deletes all values stored in the cache. In-flight writes to the cache will
-   * complete normally, but the corresponding responses will not be stored.
-   */
-  public void evictAll() throws IOException {
-    cache.evictAll();
-  }
-
-  /**
-   * Returns an iterator over the URLs in this cache. This iterator doesn't throw {@code
-   * ConcurrentModificationException}, but if new responses are added while iterating, their URLs
-   * will not be returned. If existing responses are evicted during iteration, they will be absent
-   * (unless they were already returned).
-   *
-   * <p>The iterator supports {@linkplain Iterator#remove}. Removing a URL from the iterator evicts
-   * the corresponding response from the cache. Use this to evict selected responses.
-   */
-  public Iterator<String> urls() throws IOException {
-    return new Iterator<String>() {
-      final Iterator<DiskLruCache.Snapshot> delegate = cache.snapshots();
-
-      String nextUrl;
-      boolean canRemove;
-
-      @Override public boolean hasNext() {
-        if (nextUrl != null) return true;
-
-        canRemove = false; // Prevent delegate.remove() on the wrong item!
-        while (delegate.hasNext()) {
-          DiskLruCache.Snapshot snapshot = delegate.next();
-          try {
-            BufferedSource metadata = Okio.buffer(snapshot.getSource(ENTRY_METADATA));
-            nextUrl = metadata.readUtf8LineStrict();
-            return true;
-          } catch (IOException ignored) {
-            // We couldn't read the metadata for this snapshot; possibly because the host filesystem
-            // has disappeared! Skip it.
-          } finally {
-            snapshot.close();
-          }
-        }
-
-        return false;
-      }
-
-      @Override public String next() {
-        if (!hasNext()) throw new NoSuchElementException();
-        String result = nextUrl;
-        nextUrl = null;
-        canRemove = true;
-        return result;
-      }
-
-      @Override public void remove() {
-        if (!canRemove) throw new IllegalStateException("remove() before next()");
-        delegate.remove();
-      }
-    };
-  }
 
-  public synchronized int getWriteAbortCount() {
-    return writeAbortCount;
-  }
+    Response get(Request request) {
+        String key = urlToKey(request);
+        DiskLruCache.Snapshot snapshot;
+        Entry entry;
+        try {
+            snapshot = cache.get(key);
+            if (snapshot == null) {
+                return null;
+            }
+        } catch (IOException e) {
+            // Give up because the cache cannot be read.
+            return null;
+        }
 
-  public synchronized int getWriteSuccessCount() {
-    return writeSuccessCount;
-  }
+        try {
+            entry = new Entry(snapshot.getSource(ENTRY_METADATA));
+        } catch (IOException e) {
+            Util.closeQuietly(snapshot);
+            return null;
+        }
 
-  public long getSize() throws IOException {
-    return cache.size();
-  }
+        Response response = entry.response(request, snapshot);
 
-  public long getMaxSize() {
-    return cache.getMaxSize();
-  }
+        if (!entry.matches(request, response)) {
+            Util.closeQuietly(response.body());
+            return null;
+        }
 
-  public void flush() throws IOException {
-    cache.flush();
-  }
+        return response;
+    }
 
-  public void close() throws IOException {
-    cache.close();
-  }
+    private CacheRequest put(Response response) throws IOException {
+        String requestMethod = response.request().method();
 
-  public File getDirectory() {
-    return cache.getDirectory();
-  }
+        if (HttpMethod.invalidatesCache(response.request().method())) {
+            try {
+                remove(response.request());
+            } catch (IOException ignored) {
+                // The cache cannot be written.
+            }
+            return null;
+        }
+        if (!requestMethod.equals("GET")) {
+            // Don't cache non-GET responses. We're technically allowed to cache
+            // HEAD requests and some POST requests, but the complexity of doing
+            // so is high and the benefit is low.
+            return null;
+        }
 
-  public boolean isClosed() {
-    return cache.isClosed();
-  }
+        if (OkHeaders.hasVaryAll(response)) {
+            return null;
+        }
 
-  private synchronized void trackResponse(CacheStrategy cacheStrategy) {
-    requestCount++;
+        Entry entry = new Entry(response);
+        DiskLruCache.Editor editor = null;
+        try {
+            editor = cache.edit(urlToKey(response.request()));
+            if (editor == null) {
+                return null;
+            }
+            entry.writeTo(editor);
+            return new CacheRequestImpl(editor);
+        } catch (IOException e) {
+            abortQuietly(editor);
+            return null;
+        }
+    }
 
-    if (cacheStrategy.networkRequest != null) {
-      // If this is a conditional request, we'll increment hitCount if/when it hits.
-      networkCount++;
+    private void remove(Request request) throws IOException {
+        cache.remove(urlToKey(request));
+    }
 
-    } else if (cacheStrategy.cacheResponse != null) {
-      // This response uses the cache and not the network. That's a cache hit.
-      hitCount++;
+    private void update(Response cached, Response network) {
+        Entry entry = new Entry(network);
+        DiskLruCache.Snapshot snapshot = ((CacheResponseBody) cached.body()).snapshot;
+        DiskLruCache.Editor editor = null;
+        try {
+            editor = snapshot.edit(); // Returns null if snapshot is not current.
+            if (editor != null) {
+                entry.writeTo(editor);
+                editor.commit();
+            }
+        } catch (IOException e) {
+            abortQuietly(editor);
+        }
     }
-  }
-
-  private synchronized void trackConditionalCacheHit() {
-    hitCount++;
-  }
-
-  public synchronized int getNetworkCount() {
-    return networkCount;
-  }
-
-  public synchronized int getHitCount() {
-    return hitCount;
-  }
-
-  public synchronized int getRequestCount() {
-    return requestCount;
-  }
-
-  private final class CacheRequestImpl implements CacheRequest {
-    private final DiskLruCache.Editor editor;
-    private Sink cacheOut;
-    private boolean done;
-    private Sink body;
-
-    public CacheRequestImpl(final DiskLruCache.Editor editor) throws IOException {
-      this.editor = editor;
-      this.cacheOut = editor.newSink(ENTRY_BODY);
-      this.body = new ForwardingSink(cacheOut) {
-        @Override public void close() throws IOException {
-          synchronized (Cache.this) {
-            if (done) {
-              return;
+
+    private void abortQuietly(DiskLruCache.Editor editor) {
+        // Give up because the cache cannot be written.
+        try {
+            if (editor != null) {
+                editor.abort();
             }
-            done = true;
-            writeSuccessCount++;
-          }
-          super.close();
-          editor.commit();
+        } catch (IOException ignored) {
         }
-      };
     }
 
-    @Override public void abort() {
-      synchronized (Cache.this) {
-        if (done) {
-          return;
-        }
-        done = true;
-        writeAbortCount++;
-      }
-      Util.closeQuietly(cacheOut);
-      try {
-        editor.abort();
-      } catch (IOException ignored) {
-      }
+    /**
+     * Closes the cache and deletes all of its stored values. This will delete
+     * all files in the cache directory including files that weren't created by
+     * the cache.
+     */
+    public void delete() throws IOException {
+        cache.delete();
     }
 
-    @Override public Sink body() {
-      return body;
+    /**
+     * Deletes all values stored in the cache. In-flight writes to the cache will
+     * complete normally, but the corresponding responses will not be stored.
+     */
+    public void evictAll() throws IOException {
+        cache.evictAll();
     }
-  }
-
-  private static final class Entry {
-    private final String url;
-    private final Headers varyHeaders;
-    private final String requestMethod;
-    private final Protocol protocol;
-    private final int code;
-    private final String message;
-    private final Headers responseHeaders;
-    private final Handshake handshake;
 
     /**
-     * Reads an entry from an input stream. A typical entry looks like this:
-     * <pre>{@code
-     *   http://google.com/foo
-     *   GET
-     *   2
-     *   Accept-Language: fr-CA
-     *   Accept-Charset: UTF-8
-     *   HTTP/1.1 200 OK
-     *   3
-     *   Content-Type: image/png
-     *   Content-Length: 100
-     *   Cache-Control: max-age=600
-     * }</pre>
-     *
-     * <p>A typical HTTPS file looks like this:
-     * <pre>{@code
-     *   https://google.com/foo
-     *   GET
-     *   2
-     *   Accept-Language: fr-CA
-     *   Accept-Charset: UTF-8
-     *   HTTP/1.1 200 OK
-     *   3
-     *   Content-Type: image/png
-     *   Content-Length: 100
-     *   Cache-Control: max-age=600
-     *
-     *   AES_256_WITH_MD5
-     *   2
-     *   base64-encoded peerCertificate[0]
-     *   base64-encoded peerCertificate[1]
-     *   -1
-     * }</pre>
-     * The file is newline separated. The first two lines are the URL and
-     * the request method. Next is the number of HTTP Vary request header
-     * lines, followed by those lines.
-     *
-     * <p>Next is the response status line, followed by the number of HTTP
-     * response header lines, followed by those lines.
-     *
-     * <p>HTTPS responses also contain SSL session information. This begins
-     * with a blank line, and then a line containing the cipher suite. Next
-     * is the length of the peer certificate chain. These certificates are
-     * base64-encoded and appear each on their own line. The next line
-     * contains the length of the local certificate chain. These
-     * certificates are also base64-encoded and appear each on their own
-     * line. A length of -1 is used to encode a null array.
+     * Returns an iterator over the URLs in this cache. This iterator doesn't throw {@code
+     * ConcurrentModificationException}, but if new responses are added while iterating, their URLs
+     * will not be returned. If existing responses are evicted during iteration, they will be absent
+     * (unless they were already returned).
+     * <p/>
+     * <p>The iterator supports {@linkplain Iterator#remove}. Removing a URL from the iterator evicts
+     * the corresponding response from the cache. Use this to evict selected responses.
      */
-    public Entry(Source in) throws IOException {
-      try {
-        BufferedSource source = Okio.buffer(in);
-        url = source.readUtf8LineStrict();
-        requestMethod = source.readUtf8LineStrict();
-        Headers.Builder varyHeadersBuilder = new Headers.Builder();
-        int varyRequestHeaderLineCount = readInt(source);
-        for (int i = 0; i < varyRequestHeaderLineCount; i++) {
-          varyHeadersBuilder.addLenient(source.readUtf8LineStrict());
-        }
-        varyHeaders = varyHeadersBuilder.build();
-
-        StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict());
-        protocol = statusLine.protocol;
-        code = statusLine.code;
-        message = statusLine.message;
-        Headers.Builder responseHeadersBuilder = new Headers.Builder();
-        int responseHeaderLineCount = readInt(source);
-        for (int i = 0; i < responseHeaderLineCount; i++) {
-          responseHeadersBuilder.addLenient(source.readUtf8LineStrict());
-        }
-        responseHeaders = responseHeadersBuilder.build();
-
-        if (isHttps()) {
-          String blank = source.readUtf8LineStrict();
-          if (blank.length() > 0) {
-            throw new IOException("expected \"\" but was \"" + blank + "\"");
-          }
-          String cipherSuite = source.readUtf8LineStrict();
-          List<Certificate> peerCertificates = readCertificateList(source);
-          List<Certificate> localCertificates = readCertificateList(source);
-          handshake = Handshake.get(cipherSuite, peerCertificates, localCertificates);
-        } else {
-          handshake = null;
-        }
-      } finally {
-        in.close();
-      }
+    public Iterator<String> urls() throws IOException {
+        return new Iterator<String>() {
+            final Iterator<DiskLruCache.Snapshot> delegate = cache.snapshots();
+
+            String nextUrl;
+            boolean canRemove;
+
+            @Override
+            public boolean hasNext() {
+                if (nextUrl != null) return true;
+
+                canRemove = false; // Prevent delegate.remove() on the wrong item!
+                while (delegate.hasNext()) {
+                    DiskLruCache.Snapshot snapshot = delegate.next();
+                    try {
+                        BufferedSource metadata = Okio.buffer(snapshot.getSource(ENTRY_METADATA));
+                        nextUrl = metadata.readUtf8LineStrict();
+                        return true;
+                    } catch (IOException ignored) {
+                        // We couldn't read the metadata for this snapshot; possibly because the host filesystem
+                        // has disappeared! Skip it.
+                    } finally {
+                        snapshot.close();
+                    }
+                }
+
+                return false;
+            }
+
+            @Override
+            public String next() {
+                if (!hasNext()) throw new NoSuchElementException();
+                String result = nextUrl;
+                nextUrl = null;
+                canRemove = true;
+                return result;
+            }
+
+            @Override
+            public void remove() {
+                if (!canRemove) throw new IllegalStateException("remove() before next()");
+                delegate.remove();
+            }
+        };
+    }
+
+    public synchronized int getWriteAbortCount() {
+        return writeAbortCount;
     }
 
-    public Entry(Response response) {
-      this.url = response.request().urlString();
-      this.varyHeaders = OkHeaders.varyHeaders(response);
-      this.requestMethod = response.request().method();
-      this.protocol = response.protocol();
-      this.code = response.code();
-      this.message = response.message();
-      this.responseHeaders = response.headers();
-      this.handshake = response.handshake();
+    public synchronized int getWriteSuccessCount() {
+        return writeSuccessCount;
     }
 
-    public void writeTo(DiskLruCache.Editor editor) throws IOException {
-      BufferedSink sink = Okio.buffer(editor.newSink(ENTRY_METADATA));
-
-      sink.writeUtf8(url);
-      sink.writeByte('\n');
-      sink.writeUtf8(requestMethod);
-      sink.writeByte('\n');
-      sink.writeDecimalLong(varyHeaders.size());
-      sink.writeByte('\n');
-      for (int i = 0, size = varyHeaders.size(); i < size; i++) {
-        sink.writeUtf8(varyHeaders.name(i));
-        sink.writeUtf8(": ");
-        sink.writeUtf8(varyHeaders.value(i));
-        sink.writeByte('\n');
-      }
-
-      sink.writeUtf8(new StatusLine(protocol, code, message).toString());
-      sink.writeByte('\n');
-      sink.writeDecimalLong(responseHeaders.size());
-      sink.writeByte('\n');
-      for (int i = 0, size = responseHeaders.size(); i < size; i++) {
-        sink.writeUtf8(responseHeaders.name(i));
-        sink.writeUtf8(": ");
-        sink.writeUtf8(responseHeaders.value(i));
-        sink.writeByte('\n');
-      }
-
-      if (isHttps()) {
-        sink.writeByte('\n');
-        sink.writeUtf8(handshake.cipherSuite());
-        sink.writeByte('\n');
-        writeCertList(sink, handshake.peerCertificates());
-        writeCertList(sink, handshake.localCertificates());
-      }
-      sink.close();
+    public long getSize() throws IOException {
+        return cache.size();
     }
 
-    private boolean isHttps() {
-      return url.startsWith("https://");
+    public long getMaxSize() {
+        return cache.getMaxSize();
     }
 
-    private List<Certificate> readCertificateList(BufferedSource source) throws IOException {
-      int length = readInt(source);
-      if (length == -1) return Collections.emptyList(); // OkHttp v1.2 used -1 to indicate null.
-
-      try {
-        CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
-        List<Certificate> result = new ArrayList<>(length);
-        for (int i = 0; i < length; i++) {
-          String line = source.readUtf8LineStrict();
-          Buffer bytes = new Buffer();
-          bytes.write(ByteString.decodeBase64(line));
-          result.add(certificateFactory.generateCertificate(bytes.inputStream()));
-        }
-        return result;
-      } catch (CertificateException e) {
-        throw new IOException(e.getMessage());
-      }
+    public void flush() throws IOException {
+        cache.flush();
     }
 
-    private void writeCertList(BufferedSink sink, List<Certificate> certificates)
-        throws IOException {
-      try {
-        sink.writeDecimalLong(certificates.size());
-        sink.writeByte('\n');
-        for (int i = 0, size = certificates.size(); i < size; i++) {
-          byte[] bytes = certificates.get(i).getEncoded();
-          String line = ByteString.of(bytes).base64();
-          sink.writeUtf8(line);
-          sink.writeByte('\n');
-        }
-      } catch (CertificateEncodingException e) {
-        throw new IOException(e.getMessage());
-      }
+    public void close() throws IOException {
+        cache.close();
     }
 
-    public boolean matches(Request request, Response response) {
-      return url.equals(request.urlString())
-          && requestMethod.equals(request.method())
-          && OkHeaders.varyMatches(response, varyHeaders, request);
+    public File getDirectory() {
+        return cache.getDirectory();
     }
 
-    public Response response(Request request, DiskLruCache.Snapshot snapshot) {
-      String contentType = responseHeaders.get("Content-Type");
-      String contentLength = responseHeaders.get("Content-Length");
-      Request cacheRequest = new Request.Builder()
-          .url(url)
-          .method(requestMethod, null)
-          .headers(varyHeaders)
-          .build();
-      return new Response.Builder()
-          .request(cacheRequest)
-          .protocol(protocol)
-          .code(code)
-          .message(message)
-          .headers(responseHeaders)
-          .body(new CacheResponseBody(snapshot, contentType, contentLength))
-          .handshake(handshake)
-          .build();
+    public boolean isClosed() {
+        return cache.isClosed();
     }
-  }
-
-  private static int readInt(BufferedSource source) throws IOException {
-    try {
-      long result = source.readDecimalLong();
-      String line = source.readUtf8LineStrict();
-      if (result < 0 || result > Integer.MAX_VALUE || !line.isEmpty()) {
-        throw new IOException("expected an int but was \"" + result + line + "\"");
-      }
-      return (int) result;
-    } catch (NumberFormatException e) {
-      throw new IOException(e.getMessage());
+
+    private synchronized void trackResponse(CacheStrategy cacheStrategy) {
+        requestCount++;
+
+        if (cacheStrategy.networkRequest != null) {
+            // If this is a conditional request, we'll increment hitCount if/when it hits.
+            networkCount++;
+
+        } else if (cacheStrategy.cacheResponse != null) {
+            // This response uses the cache and not the network. That's a cache hit.
+            hitCount++;
+        }
     }
-  }
-
-  private static class CacheResponseBody extends ResponseBody {
-    private final DiskLruCache.Snapshot snapshot;
-    private final BufferedSource bodySource;
-    private final String contentType;
-    private final String contentLength;
-
-    public CacheResponseBody(final DiskLruCache.Snapshot snapshot,
-        String contentType, String contentLength) {
-      this.snapshot = snapshot;
-      this.contentType = contentType;
-      this.contentLength = contentLength;
-
-      Source source = snapshot.getSource(ENTRY_BODY);
-      bodySource = Okio.buffer(new ForwardingSource(source) {
-        @Override public void close() throws IOException {
-          snapshot.close();
-          super.close();
-        }
-      });
+
+    private synchronized void trackConditionalCacheHit() {
+        hitCount++;
+    }
+
+    public synchronized int getNetworkCount() {
+        return networkCount;
+    }
+
+    public synchronized int getHitCount() {
+        return hitCount;
+    }
+
+    public synchronized int getRequestCount() {
+        return requestCount;
     }
 
-    @Override public MediaType contentType() {
-      return contentType != null ? MediaType.parse(contentType) : null;
+    private final class CacheRequestImpl implements CacheRequest {
+        private final DiskLruCache.Editor editor;
+        private Sink cacheOut;
+        private boolean done;
+        private Sink body;
+
+        public CacheRequestImpl(final DiskLruCache.Editor editor) throws IOException {
+            this.editor = editor;
+            this.cacheOut = editor.newSink(ENTRY_BODY);
+            this.body = new ForwardingSink(cacheOut) {
+                @Override
+                public void close() throws IOException {
+                    synchronized (Cache.this) {
+                        if (done) {
+                            return;
+                        }
+                        done = true;
+                        writeSuccessCount++;
+                    }
+                    super.close();
+                    editor.commit();
+                }
+            };
+        }
+
+        @Override
+        public void abort() {
+            synchronized (Cache.this) {
+                if (done) {
+                    return;
+                }
+                done = true;
+                writeAbortCount++;
+            }
+            Util.closeQuietly(cacheOut);
+            try {
+                editor.abort();
+            } catch (IOException ignored) {
+            }
+        }
+
+        @Override
+        public Sink body() {
+            return body;
+        }
+    }
+
+    private static final class Entry {
+        private final String url;
+        private final Headers varyHeaders;
+        private final String requestMethod;
+        private final Protocol protocol;
+        private final int code;
+        private final String message;
+        private final Headers responseHeaders;
+        private final Handshake handshake;
+
+        /**
+         * Reads an entry from an input stream. A typical entry looks like this:
+         * <pre>{@code
+         *   http://google.com/foo
+         *   GET
+         *   2
+         *   Accept-Language: fr-CA
+         *   Accept-Charset: UTF-8
+         *   HTTP/1.1 200 OK
+         *   3
+         *   Content-Type: image/png
+         *   Content-Length: 100
+         *   Cache-Control: max-age=600
+         * }</pre>
+         * <p/>
+         * <p>A typical HTTPS file looks like this:
+         * <pre>{@code
+         *   https://google.com/foo
+         *   GET
+         *   2
+         *   Accept-Language: fr-CA
+         *   Accept-Charset: UTF-8
+         *   HTTP/1.1 200 OK
+         *   3
+         *   Content-Type: image/png
+         *   Content-Length: 100
+         *   Cache-Control: max-age=600
+         * <p/>
+         *   AES_256_WITH_MD5
+         *   2
+         *   base64-encoded peerCertificate[0]
+         *   base64-encoded peerCertificate[1]
+         *   -1
+         * }</pre>
+         * The file is newline separated. The first two lines are the URL and
+         * the request method. Next is the number of HTTP Vary request header
+         * lines, followed by those lines.
+         * <p/>
+         * <p>Next is the response status line, followed by the number of HTTP
+         * response header lines, followed by those lines.
+         * <p/>
+         * <p>HTTPS responses also contain SSL session information. This begins
+         * with a blank line, and then a line containing the cipher suite. Next
+         * is the length of the peer certificate chain. These certificates are
+         * base64-encoded and appear each on their own line. The next line
+         * contains the length of the local certificate chain. These
+         * certificates are also base64-encoded and appear each on their own
+         * line. A length of -1 is used to encode a null array.
+         */
+        public Entry(Source in) throws IOException {
+            try {
+                BufferedSource source = Okio.buffer(in);
+                url = source.readUtf8LineStrict();
+                requestMethod = source.readUtf8LineStrict();
+                Headers.Builder varyHeadersBuilder = new Headers.Builder();
+                int varyRequestHeaderLineCount = readInt(source);
+                for (int i = 0; i < varyRequestHeaderLineCount; i++) {
+                    varyHeadersBuilder.addLenient(source.readUtf8LineStrict());
+                }
+                varyHeaders = varyHeadersBuilder.build();
+
+                StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict());
+                protocol = statusLine.protocol;
+                code = statusLine.code;
+                message = statusLine.message;
+                Headers.Builder responseHeadersBuilder = new Headers.Builder();
+                int responseHeaderLineCount = readInt(source);
+                for (int i = 0; i < responseHeaderLineCount; i++) {
+                    responseHeadersBuilder.addLenient(source.readUtf8LineStrict());
+                }
+                responseHeaders = responseHeadersBuilder.build();
+
+                if (isHttps()) {
+                    String blank = source.readUtf8LineStrict();
+                    if (blank.length() > 0) {
+                        throw new IOException("expected \"\" but was \"" + blank + "\"");
+                    }
+                    String cipherSuite = source.readUtf8LineStrict();
+                    List<Certificate> peerCertificates = readCertificateList(source);
+                    List<Certificate> localCertificates = readCertificateList(source);
+                    handshake = Handshake.get(cipherSuite, peerCertificates, localCertificates);
+                } else {
+                    handshake = null;
+                }
+            } finally {
+                in.close();
+            }
+        }
+
+        public Entry(Response response) {
+            this.url = response.request().urlString();
+            this.varyHeaders = OkHeaders.varyHeaders(response);
+            this.requestMethod = response.request().method();
+            this.protocol = response.protocol();
+            this.code = response.code();
+            this.message = response.message();
+            this.responseHeaders = response.headers();
+            this.handshake = response.handshake();
+        }
+
+        public void writeTo(DiskLruCache.Editor editor) throws IOException {
+            BufferedSink sink = Okio.buffer(editor.newSink(ENTRY_METADATA));
+
+            sink.writeUtf8(url);
+            sink.writeByte('\n');
+            sink.writeUtf8(requestMethod);
+            sink.writeByte('\n');
+            sink.writeDecimalLong(varyHeaders.size());
+            sink.writeByte('\n');
+            for (int i = 0, size = varyHeaders.size(); i < size; i++) {
+                sink.writeUtf8(varyHeaders.name(i));
+                sink.writeUtf8(": ");
+                sink.writeUtf8(varyHeaders.value(i));
+                sink.writeByte('\n');
+            }
+
+            sink.writeUtf8(new StatusLine(protocol, code, message).toString());
+            sink.writeByte('\n');
+            sink.writeDecimalLong(responseHeaders.size());
+            sink.writeByte('\n');
+            for (int i = 0, size = responseHeaders.size(); i < size; i++) {
+                sink.writeUtf8(responseHeaders.name(i));
+                sink.writeUtf8(": ");
+                sink.writeUtf8(responseHeaders.value(i));
+                sink.writeByte('\n');
+            }
+
+            if (isHttps()) {
+                sink.writeByte('\n');
+                sink.writeUtf8(handshake.cipherSuite());
+                sink.writeByte('\n');
+                writeCertList(sink, handshake.peerCertificates());
+                writeCertList(sink, handshake.localCertificates());
+            }
+            sink.close();
+        }
+
+        private boolean isHttps() {
+            return url.startsWith("https://");
+        }
+
+        private List<Certificate> readCertificateList(BufferedSource source) throws IOException {
+            int length = readInt(source);
+            if (length == -1)
+                return Collections.emptyList(); // OkHttp v1.2 used -1 to indicate null.
+
+            try {
+                CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
+                List<Certificate> result = new ArrayList<>(length);
+                for (int i = 0; i < length; i++) {
+                    String line = source.readUtf8LineStrict();
+                    Buffer bytes = new Buffer();
+                    bytes.write(ByteString.decodeBase64(line));
+                    result.add(certificateFactory.generateCertificate(bytes.inputStream()));
+                }
+                return result;
+            } catch (CertificateException e) {
+                throw new IOException(e.getMessage());
+            }
+        }
+
+        private void writeCertList(BufferedSink sink, List<Certificate> certificates)
+                throws IOException {
+            try {
+                sink.writeDecimalLong(certificates.size());
+                sink.writeByte('\n');
+                for (int i = 0, size = certificates.size(); i < size; i++) {
+                    byte[] bytes = certificates.get(i).getEncoded();
+                    String line = ByteString.of(bytes).base64();
+                    sink.writeUtf8(line);
+                    sink.writeByte('\n');
+                }
+            } catch (CertificateEncodingException e) {
+                throw new IOException(e.getMessage());
+            }
+        }
+
+        public boolean matches(Request request, Response response) {
+            return url.equals(request.urlString())
+                    && requestMethod.equals(request.method())
+                    && OkHeaders.varyMatches(response, varyHeaders, request);
+        }
+
+        public Response response(Request request, DiskLruCache.Snapshot snapshot) {
+            String contentType = responseHeaders.get("Content-Type");
+            String contentLength = responseHeaders.get("Content-Length");
+            Request cacheRequest = new Request.Builder()
+                    .url(url)
+                    .method(requestMethod, null)
+                    .headers(varyHeaders)
+                    .build();
+            return new Response.Builder()
+                    .request(cacheRequest)
+                    .protocol(protocol)
+                    .code(code)
+                    .message(message)
+                    .headers(responseHeaders)
+                    .body(new CacheResponseBody(snapshot, contentType, contentLength))
+                    .handshake(handshake)
+                    .build();
+        }
     }
 
-    @Override public long contentLength() {
-      try {
-        return contentLength != null ? Long.parseLong(contentLength) : -1;
-      } catch (NumberFormatException e) {
-        return -1;
-      }
+    private static int readInt(BufferedSource source) throws IOException {
+        try {
+            long result = source.readDecimalLong();
+            String line = source.readUtf8LineStrict();
+            if (result < 0 || result > Integer.MAX_VALUE || !line.isEmpty()) {
+                throw new IOException("expected an int but was \"" + result + line + "\"");
+            }
+            return (int) result;
+        } catch (NumberFormatException e) {
+            throw new IOException(e.getMessage());
+        }
     }
 
-    @Override public BufferedSource source() {
-      return bodySource;
+    private static class CacheResponseBody extends ResponseBody {
+        private final DiskLruCache.Snapshot snapshot;
+        private final BufferedSource bodySource;
+        private final String contentType;
+        private final String contentLength;
+
+        public CacheResponseBody(final DiskLruCache.Snapshot snapshot,
+                                 String contentType, String contentLength) {
+            this.snapshot = snapshot;
+            this.contentType = contentType;
+            this.contentLength = contentLength;
+
+            Source source = snapshot.getSource(ENTRY_BODY);
+            bodySource = Okio.buffer(new ForwardingSource(source) {
+                @Override
+                public void close() throws IOException {
+                    snapshot.close();
+                    super.close();
+                }
+            });
+        }
+
+        @Override
+        public MediaType contentType() {
+            return contentType != null ? MediaType.parse(contentType) : null;
+        }
+
+        @Override
+        public long contentLength() {
+            try {
+                return contentLength != null ? Long.parseLong(contentLength) : -1;
+            } catch (NumberFormatException e) {
+                return -1;
+            }
+        }
+
+        @Override
+        public BufferedSource source() {
+            return bodySource;
+        }
     }
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/CacheControl.java b/okhttp/src/main/java/com/squareup/okhttp/CacheControl.java
index 2ee8982b0c..9ecda0604d 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/CacheControl.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/CacheControl.java
@@ -1,366 +1,378 @@
 package com.squareup.okhttp;
 
 import com.squareup.okhttp.internal.http.HeaderParser;
+
 import java.util.concurrent.TimeUnit;
 
 /**
  * A Cache-Control header with cache directives from a server or client. These
  * directives set policy on what responses can be stored, and which requests can
  * be satisfied by those stored responses.
- *
+ * <p/>
  * <p>See <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9">RFC
  * 2616, 14.9</a>.
  */
 public final class CacheControl {
-  /**
-   * Cache control request directives that require network validation of
-   * responses. Note that such requests may be assisted by the cache via
-   * conditional GET requests.
-   */
-  public static final CacheControl FORCE_NETWORK = new Builder().noCache().build();
-
-  /**
-   * Cache control request directives that uses the cache only, even if the
-   * cached response is stale. If the response isn't available in the cache or
-   * requires server validation, the call will fail with a {@code 504
-   * Unsatisfiable Request}.
-   */
-  public static final CacheControl FORCE_CACHE = new Builder()
-      .onlyIfCached()
-      .maxStale(Integer.MAX_VALUE, TimeUnit.SECONDS)
-      .build();
-
-  private final boolean noCache;
-  private final boolean noStore;
-  private final int maxAgeSeconds;
-  private final int sMaxAgeSeconds;
-  private final boolean isPrivate;
-  private final boolean isPublic;
-  private final boolean mustRevalidate;
-  private final int maxStaleSeconds;
-  private final int minFreshSeconds;
-  private final boolean onlyIfCached;
-  private final boolean noTransform;
-
-  String headerValue; // Lazily computed, if absent.
-
-  private CacheControl(boolean noCache, boolean noStore, int maxAgeSeconds, int sMaxAgeSeconds,
-      boolean isPrivate, boolean isPublic, boolean mustRevalidate, int maxStaleSeconds,
-      int minFreshSeconds, boolean onlyIfCached, boolean noTransform, String headerValue) {
-    this.noCache = noCache;
-    this.noStore = noStore;
-    this.maxAgeSeconds = maxAgeSeconds;
-    this.sMaxAgeSeconds = sMaxAgeSeconds;
-    this.isPrivate = isPrivate;
-    this.isPublic = isPublic;
-    this.mustRevalidate = mustRevalidate;
-    this.maxStaleSeconds = maxStaleSeconds;
-    this.minFreshSeconds = minFreshSeconds;
-    this.onlyIfCached = onlyIfCached;
-    this.noTransform = noTransform;
-    this.headerValue = headerValue;
-  }
-
-  private CacheControl(Builder builder) {
-    this.noCache = builder.noCache;
-    this.noStore = builder.noStore;
-    this.maxAgeSeconds = builder.maxAgeSeconds;
-    this.sMaxAgeSeconds = -1;
-    this.isPrivate = false;
-    this.isPublic = false;
-    this.mustRevalidate = false;
-    this.maxStaleSeconds = builder.maxStaleSeconds;
-    this.minFreshSeconds = builder.minFreshSeconds;
-    this.onlyIfCached = builder.onlyIfCached;
-    this.noTransform = builder.noTransform;
-  }
-
-  /**
-   * In a response, this field's name "no-cache" is misleading. It doesn't
-   * prevent us from caching the response; it only means we have to validate the
-   * response with the origin server before returning it. We can do this with a
-   * conditional GET.
-   *
-   * <p>In a request, it means do not use a cache to satisfy the request.
-   */
-  public boolean noCache() {
-    return noCache;
-  }
-
-  /** If true, this response should not be cached. */
-  public boolean noStore() {
-    return noStore;
-  }
-
-  /**
-   * The duration past the response's served date that it can be served without
-   * validation.
-   */
-  public int maxAgeSeconds() {
-    return maxAgeSeconds;
-  }
-
-  /**
-   * The "s-maxage" directive is the max age for shared caches. Not to be
-   * confused with "max-age" for non-shared caches, As in Firefox and Chrome,
-   * this directive is not honored by this cache.
-   */
-  public int sMaxAgeSeconds() {
-    return sMaxAgeSeconds;
-  }
-
-  public boolean isPrivate() {
-    return isPrivate;
-  }
-
-  public boolean isPublic() {
-    return isPublic;
-  }
-
-  public boolean mustRevalidate() {
-    return mustRevalidate;
-  }
-
-  public int maxStaleSeconds() {
-    return maxStaleSeconds;
-  }
-
-  public int minFreshSeconds() {
-    return minFreshSeconds;
-  }
-
-  /**
-   * This field's name "only-if-cached" is misleading. It actually means "do
-   * not use the network". It is set by a client who only wants to make a
-   * request if it can be fully satisfied by the cache. Cached responses that
-   * would require validation (ie. conditional gets) are not permitted if this
-   * header is set.
-   */
-  public boolean onlyIfCached() {
-    return onlyIfCached;
-  }
-
-  public boolean noTransform() {
-    return noTransform;
-  }
-
-  /**
-   * Returns the cache directives of {@code headers}. This honors both
-   * Cache-Control and Pragma headers if they are present.
-   */
-  public static CacheControl parse(Headers headers) {
-    boolean noCache = false;
-    boolean noStore = false;
-    int maxAgeSeconds = -1;
-    int sMaxAgeSeconds = -1;
-    boolean isPrivate = false;
-    boolean isPublic = false;
-    boolean mustRevalidate = false;
-    int maxStaleSeconds = -1;
-    int minFreshSeconds = -1;
-    boolean onlyIfCached = false;
-    boolean noTransform = false;
-
-    boolean canUseHeaderValue = true;
-    String headerValue = null;
-
-    for (int i = 0, size = headers.size(); i < size; i++) {
-      String name = headers.name(i);
-      String value = headers.value(i);
-
-      if (name.equalsIgnoreCase("Cache-Control")) {
-        if (headerValue != null) {
-          // Multiple cache-control headers means we can't use the raw value.
-          canUseHeaderValue = false;
-        } else {
-          headerValue = value;
-        }
-      } else if (name.equalsIgnoreCase("Pragma")) {
-        // Might specify additional cache-control params. We invalidate just in case.
-        canUseHeaderValue = false;
-      } else {
-        continue;
-      }
-
-      int pos = 0;
-      while (pos < value.length()) {
-        int tokenStart = pos;
-        pos = HeaderParser.skipUntil(value, pos, "=,;");
-        String directive = value.substring(tokenStart, pos).trim();
-        String parameter;
-
-        if (pos == value.length() || value.charAt(pos) == ',' || value.charAt(pos) == ';') {
-          pos++; // consume ',' or ';' (if necessary)
-          parameter = null;
-        } else {
-          pos++; // consume '='
-          pos = HeaderParser.skipWhitespace(value, pos);
-
-          // quoted string
-          if (pos < value.length() && value.charAt(pos) == '\"') {
-            pos++; // consume '"' open quote
-            int parameterStart = pos;
-            pos = HeaderParser.skipUntil(value, pos, "\"");
-            parameter = value.substring(parameterStart, pos);
-            pos++; // consume '"' close quote (if necessary)
-
-            // unquoted string
-          } else {
-            int parameterStart = pos;
-            pos = HeaderParser.skipUntil(value, pos, ",;");
-            parameter = value.substring(parameterStart, pos).trim();
-          }
-        }
+    /**
+     * Cache control request directives that require network validation of
+     * responses. Note that such requests may be assisted by the cache via
+     * conditional GET requests.
+     */
+    public static final CacheControl FORCE_NETWORK = new Builder().noCache().build();
 
-        if ("no-cache".equalsIgnoreCase(directive)) {
-          noCache = true;
-        } else if ("no-store".equalsIgnoreCase(directive)) {
-          noStore = true;
-        } else if ("max-age".equalsIgnoreCase(directive)) {
-          maxAgeSeconds = HeaderParser.parseSeconds(parameter, -1);
-        } else if ("s-maxage".equalsIgnoreCase(directive)) {
-          sMaxAgeSeconds = HeaderParser.parseSeconds(parameter, -1);
-        } else if ("private".equalsIgnoreCase(directive)) {
-          isPrivate = true;
-        } else if ("public".equalsIgnoreCase(directive)) {
-          isPublic = true;
-        } else if ("must-revalidate".equalsIgnoreCase(directive)) {
-          mustRevalidate = true;
-        } else if ("max-stale".equalsIgnoreCase(directive)) {
-          maxStaleSeconds = HeaderParser.parseSeconds(parameter, Integer.MAX_VALUE);
-        } else if ("min-fresh".equalsIgnoreCase(directive)) {
-          minFreshSeconds = HeaderParser.parseSeconds(parameter, -1);
-        } else if ("only-if-cached".equalsIgnoreCase(directive)) {
-          onlyIfCached = true;
-        } else if ("no-transform".equalsIgnoreCase(directive)) {
-          noTransform = true;
-        }
-      }
+    /**
+     * Cache control request directives that uses the cache only, even if the
+     * cached response is stale. If the response isn't available in the cache or
+     * requires server validation, the call will fail with a {@code 504
+     * Unsatisfiable Request}.
+     */
+    public static final CacheControl FORCE_CACHE = new Builder()
+            .onlyIfCached()
+            .maxStale(Integer.MAX_VALUE, TimeUnit.SECONDS)
+            .build();
+
+    private final boolean noCache;
+    private final boolean noStore;
+    private final int maxAgeSeconds;
+    private final int sMaxAgeSeconds;
+    private final boolean isPrivate;
+    private final boolean isPublic;
+    private final boolean mustRevalidate;
+    private final int maxStaleSeconds;
+    private final int minFreshSeconds;
+    private final boolean onlyIfCached;
+    private final boolean noTransform;
+
+    String headerValue; // Lazily computed, if absent.
+
+    private CacheControl(boolean noCache, boolean noStore, int maxAgeSeconds, int sMaxAgeSeconds,
+                         boolean isPrivate, boolean isPublic, boolean mustRevalidate, int maxStaleSeconds,
+                         int minFreshSeconds, boolean onlyIfCached, boolean noTransform, String headerValue) {
+        this.noCache = noCache;
+        this.noStore = noStore;
+        this.maxAgeSeconds = maxAgeSeconds;
+        this.sMaxAgeSeconds = sMaxAgeSeconds;
+        this.isPrivate = isPrivate;
+        this.isPublic = isPublic;
+        this.mustRevalidate = mustRevalidate;
+        this.maxStaleSeconds = maxStaleSeconds;
+        this.minFreshSeconds = minFreshSeconds;
+        this.onlyIfCached = onlyIfCached;
+        this.noTransform = noTransform;
+        this.headerValue = headerValue;
     }
 
-    if (!canUseHeaderValue) {
-      headerValue = null;
+    private CacheControl(Builder builder) {
+        this.noCache = builder.noCache;
+        this.noStore = builder.noStore;
+        this.maxAgeSeconds = builder.maxAgeSeconds;
+        this.sMaxAgeSeconds = -1;
+        this.isPrivate = false;
+        this.isPublic = false;
+        this.mustRevalidate = false;
+        this.maxStaleSeconds = builder.maxStaleSeconds;
+        this.minFreshSeconds = builder.minFreshSeconds;
+        this.onlyIfCached = builder.onlyIfCached;
+        this.noTransform = builder.noTransform;
     }
-    return new CacheControl(noCache, noStore, maxAgeSeconds, sMaxAgeSeconds, isPrivate, isPublic,
-        mustRevalidate, maxStaleSeconds, minFreshSeconds, onlyIfCached, noTransform, headerValue);
-  }
-
-  @Override public String toString() {
-    String result = headerValue;
-    return result != null ? result : (headerValue = headerValue());
-  }
-
-  private String headerValue() {
-    StringBuilder result = new StringBuilder();
-    if (noCache) result.append("no-cache, ");
-    if (noStore) result.append("no-store, ");
-    if (maxAgeSeconds != -1) result.append("max-age=").append(maxAgeSeconds).append(", ");
-    if (sMaxAgeSeconds != -1) result.append("s-maxage=").append(sMaxAgeSeconds).append(", ");
-    if (isPrivate) result.append("private, ");
-    if (isPublic) result.append("public, ");
-    if (mustRevalidate) result.append("must-revalidate, ");
-    if (maxStaleSeconds != -1) result.append("max-stale=").append(maxStaleSeconds).append(", ");
-    if (minFreshSeconds != -1) result.append("min-fresh=").append(minFreshSeconds).append(", ");
-    if (onlyIfCached) result.append("only-if-cached, ");
-    if (noTransform) result.append("no-transform, ");
-    if (result.length() == 0) return "";
-    result.delete(result.length() - 2, result.length());
-    return result.toString();
-  }
-
-  /** Builds a {@code Cache-Control} request header. */
-  public static final class Builder {
-    boolean noCache;
-    boolean noStore;
-    int maxAgeSeconds = -1;
-    int maxStaleSeconds = -1;
-    int minFreshSeconds = -1;
-    boolean onlyIfCached;
-    boolean noTransform;
-
-    /** Don't accept an unvalidated cached response. */
-    public Builder noCache() {
-      this.noCache = true;
-      return this;
+
+    /**
+     * In a response, this field's name "no-cache" is misleading. It doesn't
+     * prevent us from caching the response; it only means we have to validate the
+     * response with the origin server before returning it. We can do this with a
+     * conditional GET.
+     * <p/>
+     * <p>In a request, it means do not use a cache to satisfy the request.
+     */
+    public boolean noCache() {
+        return noCache;
     }
 
-    /** Don't store the server's response in any cache. */
-    public Builder noStore() {
-      this.noStore = true;
-      return this;
+    /**
+     * If true, this response should not be cached.
+     */
+    public boolean noStore() {
+        return noStore;
     }
 
     /**
-     * Sets the maximum age of a cached response. If the cache response's age
-     * exceeds {@code maxAge}, it will not be used and a network request will
-     * be made.
-     *
-     * @param maxAge a non-negative integer. This is stored and transmitted with
-     *     {@link TimeUnit#SECONDS} precision; finer precision will be lost.
+     * The duration past the response's served date that it can be served without
+     * validation.
      */
-    public Builder maxAge(int maxAge, TimeUnit timeUnit) {
-      if (maxAge < 0) throw new IllegalArgumentException("maxAge < 0: " + maxAge);
-      long maxAgeSecondsLong = timeUnit.toSeconds(maxAge);
-      this.maxAgeSeconds = maxAgeSecondsLong > Integer.MAX_VALUE
-          ? Integer.MAX_VALUE
-          : (int) maxAgeSecondsLong;
-      return this;
+    public int maxAgeSeconds() {
+        return maxAgeSeconds;
     }
 
     /**
-     * Accept cached responses that have exceeded their freshness lifetime by
-     * up to {@code maxStale}. If unspecified, stale cache responses will not be
-     * used.
-     *
-     * @param maxStale a non-negative integer. This is stored and transmitted
-     *     with {@link TimeUnit#SECONDS} precision; finer precision will be
-     *     lost.
+     * The "s-maxage" directive is the max age for shared caches. Not to be
+     * confused with "max-age" for non-shared caches, As in Firefox and Chrome,
+     * this directive is not honored by this cache.
      */
-    public Builder maxStale(int maxStale, TimeUnit timeUnit) {
-      if (maxStale < 0) throw new IllegalArgumentException("maxStale < 0: " + maxStale);
-      long maxStaleSecondsLong = timeUnit.toSeconds(maxStale);
-      this.maxStaleSeconds = maxStaleSecondsLong > Integer.MAX_VALUE
-          ? Integer.MAX_VALUE
-          : (int) maxStaleSecondsLong;
-      return this;
+    public int sMaxAgeSeconds() {
+        return sMaxAgeSeconds;
+    }
+
+    public boolean isPrivate() {
+        return isPrivate;
+    }
+
+    public boolean isPublic() {
+        return isPublic;
+    }
+
+    public boolean mustRevalidate() {
+        return mustRevalidate;
+    }
+
+    public int maxStaleSeconds() {
+        return maxStaleSeconds;
+    }
+
+    public int minFreshSeconds() {
+        return minFreshSeconds;
     }
 
     /**
-     * Sets the minimum number of seconds that a response will continue to be
-     * fresh for. If the response will be stale when {@code minFresh} have
-     * elapsed, the cached response will not be used and a network request will
-     * be made.
-     *
-     * @param minFresh a non-negative integer. This is stored and transmitted
-     *     with {@link TimeUnit#SECONDS} precision; finer precision will be
-     *     lost.
+     * This field's name "only-if-cached" is misleading. It actually means "do
+     * not use the network". It is set by a client who only wants to make a
+     * request if it can be fully satisfied by the cache. Cached responses that
+     * would require validation (ie. conditional gets) are not permitted if this
+     * header is set.
      */
-    public Builder minFresh(int minFresh, TimeUnit timeUnit) {
-      if (minFresh < 0) throw new IllegalArgumentException("minFresh < 0: " + minFresh);
-      long minFreshSecondsLong = timeUnit.toSeconds(minFresh);
-      this.minFreshSeconds = minFreshSecondsLong > Integer.MAX_VALUE
-          ? Integer.MAX_VALUE
-          : (int) minFreshSecondsLong;
-      return this;
+    public boolean onlyIfCached() {
+        return onlyIfCached;
+    }
+
+    public boolean noTransform() {
+        return noTransform;
     }
 
     /**
-     * Only accept the response if it is in the cache. If the response isn't
-     * cached, a {@code 504 Unsatisfiable Request} response will be returned.
+     * Returns the cache directives of {@code headers}. This honors both
+     * Cache-Control and Pragma headers if they are present.
      */
-    public Builder onlyIfCached() {
-      this.onlyIfCached = true;
-      return this;
+    public static CacheControl parse(Headers headers) {
+        boolean noCache = false;
+        boolean noStore = false;
+        int maxAgeSeconds = -1;
+        int sMaxAgeSeconds = -1;
+        boolean isPrivate = false;
+        boolean isPublic = false;
+        boolean mustRevalidate = false;
+        int maxStaleSeconds = -1;
+        int minFreshSeconds = -1;
+        boolean onlyIfCached = false;
+        boolean noTransform = false;
+
+        boolean canUseHeaderValue = true;
+        String headerValue = null;
+
+        for (int i = 0, size = headers.size(); i < size; i++) {
+            String name = headers.name(i);
+            String value = headers.value(i);
+
+            if (name.equalsIgnoreCase("Cache-Control")) {
+                if (headerValue != null) {
+                    // Multiple cache-control headers means we can't use the raw value.
+                    canUseHeaderValue = false;
+                } else {
+                    headerValue = value;
+                }
+            } else if (name.equalsIgnoreCase("Pragma")) {
+                // Might specify additional cache-control params. We invalidate just in case.
+                canUseHeaderValue = false;
+            } else {
+                continue;
+            }
+
+            int pos = 0;
+            while (pos < value.length()) {
+                int tokenStart = pos;
+                pos = HeaderParser.skipUntil(value, pos, "=,;");
+                String directive = value.substring(tokenStart, pos).trim();
+                String parameter;
+
+                if (pos == value.length() || value.charAt(pos) == ',' || value.charAt(pos) == ';') {
+                    pos++; // consume ',' or ';' (if necessary)
+                    parameter = null;
+                } else {
+                    pos++; // consume '='
+                    pos = HeaderParser.skipWhitespace(value, pos);
+
+                    // quoted string
+                    if (pos < value.length() && value.charAt(pos) == '\"') {
+                        pos++; // consume '"' open quote
+                        int parameterStart = pos;
+                        pos = HeaderParser.skipUntil(value, pos, "\"");
+                        parameter = value.substring(parameterStart, pos);
+                        pos++; // consume '"' close quote (if necessary)
+
+                        // unquoted string
+                    } else {
+                        int parameterStart = pos;
+                        pos = HeaderParser.skipUntil(value, pos, ",;");
+                        parameter = value.substring(parameterStart, pos).trim();
+                    }
+                }
+
+                if ("no-cache".equalsIgnoreCase(directive)) {
+                    noCache = true;
+                } else if ("no-store".equalsIgnoreCase(directive)) {
+                    noStore = true;
+                } else if ("max-age".equalsIgnoreCase(directive)) {
+                    maxAgeSeconds = HeaderParser.parseSeconds(parameter, -1);
+                } else if ("s-maxage".equalsIgnoreCase(directive)) {
+                    sMaxAgeSeconds = HeaderParser.parseSeconds(parameter, -1);
+                } else if ("private".equalsIgnoreCase(directive)) {
+                    isPrivate = true;
+                } else if ("public".equalsIgnoreCase(directive)) {
+                    isPublic = true;
+                } else if ("must-revalidate".equalsIgnoreCase(directive)) {
+                    mustRevalidate = true;
+                } else if ("max-stale".equalsIgnoreCase(directive)) {
+                    maxStaleSeconds = HeaderParser.parseSeconds(parameter, Integer.MAX_VALUE);
+                } else if ("min-fresh".equalsIgnoreCase(directive)) {
+                    minFreshSeconds = HeaderParser.parseSeconds(parameter, -1);
+                } else if ("only-if-cached".equalsIgnoreCase(directive)) {
+                    onlyIfCached = true;
+                } else if ("no-transform".equalsIgnoreCase(directive)) {
+                    noTransform = true;
+                }
+            }
+        }
+
+        if (!canUseHeaderValue) {
+            headerValue = null;
+        }
+        return new CacheControl(noCache, noStore, maxAgeSeconds, sMaxAgeSeconds, isPrivate, isPublic,
+                mustRevalidate, maxStaleSeconds, minFreshSeconds, onlyIfCached, noTransform, headerValue);
+    }
+
+    @Override
+    public String toString() {
+        String result = headerValue;
+        return result != null ? result : (headerValue = headerValue());
     }
 
-    /** Don't accept a transformed response. */
-    public Builder noTransform() {
-      this.noTransform = true;
-      return this;
+    private String headerValue() {
+        StringBuilder result = new StringBuilder();
+        if (noCache) result.append("no-cache, ");
+        if (noStore) result.append("no-store, ");
+        if (maxAgeSeconds != -1) result.append("max-age=").append(maxAgeSeconds).append(", ");
+        if (sMaxAgeSeconds != -1) result.append("s-maxage=").append(sMaxAgeSeconds).append(", ");
+        if (isPrivate) result.append("private, ");
+        if (isPublic) result.append("public, ");
+        if (mustRevalidate) result.append("must-revalidate, ");
+        if (maxStaleSeconds != -1) result.append("max-stale=").append(maxStaleSeconds).append(", ");
+        if (minFreshSeconds != -1) result.append("min-fresh=").append(minFreshSeconds).append(", ");
+        if (onlyIfCached) result.append("only-if-cached, ");
+        if (noTransform) result.append("no-transform, ");
+        if (result.length() == 0) return "";
+        result.delete(result.length() - 2, result.length());
+        return result.toString();
     }
 
-    public CacheControl build() {
-      return new CacheControl(this);
+    /**
+     * Builds a {@code Cache-Control} request header.
+     */
+    public static final class Builder {
+        boolean noCache;
+        boolean noStore;
+        int maxAgeSeconds = -1;
+        int maxStaleSeconds = -1;
+        int minFreshSeconds = -1;
+        boolean onlyIfCached;
+        boolean noTransform;
+
+        /**
+         * Don't accept an unvalidated cached response.
+         */
+        public Builder noCache() {
+            this.noCache = true;
+            return this;
+        }
+
+        /**
+         * Don't store the server's response in any cache.
+         */
+        public Builder noStore() {
+            this.noStore = true;
+            return this;
+        }
+
+        /**
+         * Sets the maximum age of a cached response. If the cache response's age
+         * exceeds {@code maxAge}, it will not be used and a network request will
+         * be made.
+         *
+         * @param maxAge a non-negative integer. This is stored and transmitted with
+         *               {@link TimeUnit#SECONDS} precision; finer precision will be lost.
+         */
+        public Builder maxAge(int maxAge, TimeUnit timeUnit) {
+            if (maxAge < 0) throw new IllegalArgumentException("maxAge < 0: " + maxAge);
+            long maxAgeSecondsLong = timeUnit.toSeconds(maxAge);
+            this.maxAgeSeconds = maxAgeSecondsLong > Integer.MAX_VALUE
+                    ? Integer.MAX_VALUE
+                    : (int) maxAgeSecondsLong;
+            return this;
+        }
+
+        /**
+         * Accept cached responses that have exceeded their freshness lifetime by
+         * up to {@code maxStale}. If unspecified, stale cache responses will not be
+         * used.
+         *
+         * @param maxStale a non-negative integer. This is stored and transmitted
+         *                 with {@link TimeUnit#SECONDS} precision; finer precision will be
+         *                 lost.
+         */
+        public Builder maxStale(int maxStale, TimeUnit timeUnit) {
+            if (maxStale < 0) throw new IllegalArgumentException("maxStale < 0: " + maxStale);
+            long maxStaleSecondsLong = timeUnit.toSeconds(maxStale);
+            this.maxStaleSeconds = maxStaleSecondsLong > Integer.MAX_VALUE
+                    ? Integer.MAX_VALUE
+                    : (int) maxStaleSecondsLong;
+            return this;
+        }
+
+        /**
+         * Sets the minimum number of seconds that a response will continue to be
+         * fresh for. If the response will be stale when {@code minFresh} have
+         * elapsed, the cached response will not be used and a network request will
+         * be made.
+         *
+         * @param minFresh a non-negative integer. This is stored and transmitted
+         *                 with {@link TimeUnit#SECONDS} precision; finer precision will be
+         *                 lost.
+         */
+        public Builder minFresh(int minFresh, TimeUnit timeUnit) {
+            if (minFresh < 0) throw new IllegalArgumentException("minFresh < 0: " + minFresh);
+            long minFreshSecondsLong = timeUnit.toSeconds(minFresh);
+            this.minFreshSeconds = minFreshSecondsLong > Integer.MAX_VALUE
+                    ? Integer.MAX_VALUE
+                    : (int) minFreshSecondsLong;
+            return this;
+        }
+
+        /**
+         * Only accept the response if it is in the cache. If the response isn't
+         * cached, a {@code 504 Unsatisfiable Request} response will be returned.
+         */
+        public Builder onlyIfCached() {
+            this.onlyIfCached = true;
+            return this;
+        }
+
+        /**
+         * Don't accept a transformed response.
+         */
+        public Builder noTransform() {
+            this.noTransform = true;
+            return this;
+        }
+
+        public CacheControl build() {
+            return new CacheControl(this);
+        }
     }
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Call.java b/okhttp/src/main/java/com/squareup/okhttp/Call.java
index 3fa9abd402..d4876c0222 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Call.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Call.java
@@ -16,9 +16,10 @@
 package com.squareup.okhttp;
 
 import com.squareup.okhttp.internal.NamedRunnable;
-import com.squareup.okhttp.internal.http.RouteException;
 import com.squareup.okhttp.internal.http.HttpEngine;
 import com.squareup.okhttp.internal.http.RequestException;
+import com.squareup.okhttp.internal.http.RouteException;
+
 import java.io.IOException;
 import java.net.MalformedURLException;
 import java.net.ProtocolException;
@@ -34,290 +35,295 @@
  * it cannot be executed twice.
  */
 public class Call {
-  private final OkHttpClient client;
-
-  // Guarded by this.
-  private boolean executed;
-  volatile boolean canceled;
-
-  /** The application's original request unadulterated by redirects or auth headers. */
-  Request originalRequest;
-  HttpEngine engine;
-
-  protected Call(OkHttpClient client, Request originalRequest) {
-    // Copy the client. Otherwise changes (socket factory, redirect policy,
-    // etc.) may incorrectly be reflected in the request when it is executed.
-    this.client = client.copyWithDefaults();
-    this.originalRequest = originalRequest;
-  }
-
-  /**
-   * Invokes the request immediately, and blocks until the response can be
-   * processed or is in error.
-   *
-   * <p>The caller may read the response body with the response's
-   * {@link Response#body} method.  To facilitate connection recycling, callers
-   * should always {@link ResponseBody#close() close the response body}.
-   *
-   * <p>Note that transport-layer success (receiving a HTTP response code,
-   * headers and body) does not necessarily indicate application-layer success:
-   * {@code response} may still indicate an unhappy HTTP response code like 404
-   * or 500.
-   *
-   * @throws IOException if the request could not be executed due to
-   *     cancellation, a connectivity problem or timeout. Because networks can
-   *     fail during an exchange, it is possible that the remote server
-   *     accepted the request before the failure.
-   *
-   * @throws IllegalStateException when the call has already been executed.
-   */
-  public Response execute() throws IOException {
-    synchronized (this) {
-      if (executed) throw new IllegalStateException("Already Executed");
-      executed = true;
-    }
-    try {
-      client.getDispatcher().executed(this);
-      Response result = getResponseWithInterceptorChain(false);
-      if (result == null) throw new IOException("Canceled");
-      return result;
-    } finally {
-      client.getDispatcher().finished(this);
-    }
-  }
-
-  Object tag() {
-    return originalRequest.tag();
-  }
-
-  /**
-   * Schedules the request to be executed at some point in the future.
-   *
-   * <p>The {@link OkHttpClient#getDispatcher dispatcher} defines when the
-   * request will run: usually immediately unless there are several other
-   * requests currently being executed.
-   *
-   * <p>This client will later call back {@code responseCallback} with either
-   * an HTTP response or a failure exception. If you {@link #cancel} a request
-   * before it completes the callback will not be invoked.
-   *
-   * @throws IllegalStateException when the call has already been executed.
-   */
-  public void enqueue(Callback responseCallback) {
-    enqueue(responseCallback, false);
-  }
-
-  void enqueue(Callback responseCallback, boolean forWebSocket) {
-    synchronized (this) {
-      if (executed) throw new IllegalStateException("Already Executed");
-      executed = true;
+    private final OkHttpClient client;
+
+    // Guarded by this.
+    private boolean executed;
+    volatile boolean canceled;
+
+    /**
+     * The application's original request unadulterated by redirects or auth headers.
+     */
+    Request originalRequest;
+    HttpEngine engine;
+
+    protected Call(OkHttpClient client, Request originalRequest) {
+        // Copy the client. Otherwise changes (socket factory, redirect policy,
+        // etc.) may incorrectly be reflected in the request when it is executed.
+        this.client = client.copyWithDefaults();
+        this.originalRequest = originalRequest;
     }
-    client.getDispatcher().enqueue(new AsyncCall(responseCallback, forWebSocket));
-  }
-
-  /**
-   * Cancels the request, if possible. Requests that are already complete
-   * cannot be canceled.
-   */
-  public void cancel() {
-    canceled = true;
-    if (engine != null) engine.disconnect();
-  }
-
-  public boolean isCanceled() {
-    return canceled;
-  }
-
-  final class AsyncCall extends NamedRunnable {
-    private final Callback responseCallback;
-    private final boolean forWebSocket;
-
-    private AsyncCall(Callback responseCallback, boolean forWebSocket) {
-      super("OkHttp %s", originalRequest.urlString());
-      this.responseCallback = responseCallback;
-      this.forWebSocket = forWebSocket;
+
+    /**
+     * Invokes the request immediately, and blocks until the response can be
+     * processed or is in error.
+     * <p/>
+     * <p>The caller may read the response body with the response's
+     * {@link Response#body} method.  To facilitate connection recycling, callers
+     * should always {@link ResponseBody#close() close the response body}.
+     * <p/>
+     * <p>Note that transport-layer success (receiving a HTTP response code,
+     * headers and body) does not necessarily indicate application-layer success:
+     * {@code response} may still indicate an unhappy HTTP response code like 404
+     * or 500.
+     *
+     * @throws IOException           if the request could not be executed due to
+     *                               cancellation, a connectivity problem or timeout. Because networks can
+     *                               fail during an exchange, it is possible that the remote server
+     *                               accepted the request before the failure.
+     * @throws IllegalStateException when the call has already been executed.
+     */
+    public Response execute() throws IOException {
+        synchronized (this) {
+            if (executed) throw new IllegalStateException("Already Executed");
+            executed = true;
+        }
+        try {
+            client.getDispatcher().executed(this);
+            Response result = getResponseWithInterceptorChain(false);
+            if (result == null) throw new IOException("Canceled");
+            return result;
+        } finally {
+            client.getDispatcher().finished(this);
+        }
     }
 
-    String host() {
-      return originalRequest.url().getHost();
+    Object tag() {
+        return originalRequest.tag();
     }
 
-    Request request() {
-      return originalRequest;
+    /**
+     * Schedules the request to be executed at some point in the future.
+     * <p/>
+     * <p>The {@link OkHttpClient#getDispatcher dispatcher} defines when the
+     * request will run: usually immediately unless there are several other
+     * requests currently being executed.
+     * <p/>
+     * <p>This client will later call back {@code responseCallback} with either
+     * an HTTP response or a failure exception. If you {@link #cancel} a request
+     * before it completes the callback will not be invoked.
+     *
+     * @throws IllegalStateException when the call has already been executed.
+     */
+    public void enqueue(Callback responseCallback) {
+        enqueue(responseCallback, false);
     }
 
-    Object tag() {
-      return originalRequest.tag();
+    void enqueue(Callback responseCallback, boolean forWebSocket) {
+        synchronized (this) {
+            if (executed) throw new IllegalStateException("Already Executed");
+            executed = true;
+        }
+        client.getDispatcher().enqueue(new AsyncCall(responseCallback, forWebSocket));
     }
 
-    void cancel() {
-      Call.this.cancel();
+    /**
+     * Cancels the request, if possible. Requests that are already complete
+     * cannot be canceled.
+     */
+    public void cancel() {
+        canceled = true;
+        if (engine != null) engine.disconnect();
     }
 
-    Call get() {
-      return Call.this;
+    public boolean isCanceled() {
+        return canceled;
     }
 
-    @Override protected void execute() {
-      boolean signalledCallback = false;
-      try {
-        Response response = getResponseWithInterceptorChain(forWebSocket);
-        if (canceled) {
-          signalledCallback = true;
-          responseCallback.onFailure(originalRequest, new IOException("Canceled"));
-        } else {
-          signalledCallback = true;
-          responseCallback.onResponse(response);
+    final class AsyncCall extends NamedRunnable {
+        private final Callback responseCallback;
+        private final boolean forWebSocket;
+
+        private AsyncCall(Callback responseCallback, boolean forWebSocket) {
+            super("OkHttp %s", originalRequest.urlString());
+            this.responseCallback = responseCallback;
+            this.forWebSocket = forWebSocket;
         }
-      } catch (IOException e) {
-        if (signalledCallback) {
-          // Do not signal the callback twice!
-          logger.log(Level.INFO, "Callback failure for " + toLoggableString(), e);
-        } else {
-          responseCallback.onFailure(engine.getRequest(), e);
+
+        String host() {
+            return originalRequest.url().getHost();
         }
-      } finally {
-        client.getDispatcher().finished(this);
-      }
-    }
-  }
-
-  /**
-   * Returns a string that describes this call. Doesn't include a full URL as that might contain
-   * sensitive information.
-   */
-  private String toLoggableString() {
-    String string = canceled ? "canceled call" : "call";
-    try {
-      String redactedUrl = new URL(originalRequest.url(), "/...").toString();
-      return string + " to " + redactedUrl;
-    } catch (MalformedURLException e) {
-      return string;
-    }
-  }
-
-  private Response getResponseWithInterceptorChain(boolean forWebSocket) throws IOException {
-    Interceptor.Chain chain = new ApplicationInterceptorChain(0, originalRequest, forWebSocket);
-    return chain.proceed(originalRequest);
-  }
-
-  class ApplicationInterceptorChain implements Interceptor.Chain {
-    private final int index;
-    private final Request request;
-    private final boolean forWebSocket;
-
-    ApplicationInterceptorChain(int index, Request request, boolean forWebSocket) {
-      this.index = index;
-      this.request = request;
-      this.forWebSocket = forWebSocket;
-    }
 
-    @Override public Connection connection() {
-      return null;
-    }
+        Request request() {
+            return originalRequest;
+        }
 
-    @Override public Request request() {
-      return request;
+        Object tag() {
+            return originalRequest.tag();
+        }
+
+        void cancel() {
+            Call.this.cancel();
+        }
+
+        Call get() {
+            return Call.this;
+        }
+
+        @Override
+        protected void execute() {
+            boolean signalledCallback = false;
+            try {
+                Response response = getResponseWithInterceptorChain(forWebSocket);
+                if (canceled) {
+                    signalledCallback = true;
+                    responseCallback.onFailure(originalRequest, new IOException("Canceled"));
+                } else {
+                    signalledCallback = true;
+                    responseCallback.onResponse(response);
+                }
+            } catch (IOException e) {
+                if (signalledCallback) {
+                    // Do not signal the callback twice!
+                    logger.log(Level.INFO, "Callback failure for " + toLoggableString(), e);
+                } else {
+                    responseCallback.onFailure(engine.getRequest(), e);
+                }
+            } finally {
+                client.getDispatcher().finished(this);
+            }
+        }
     }
 
-    @Override public Response proceed(Request request) throws IOException {
-      if (index < client.interceptors().size()) {
-        // There's another interceptor in the chain. Call that.
-        Interceptor.Chain chain = new ApplicationInterceptorChain(index + 1, request, forWebSocket);
-        return client.interceptors().get(index).intercept(chain);
-      } else {
-        // No more interceptors. Do HTTP.
-        return getResponse(request, forWebSocket);
-      }
+    /**
+     * Returns a string that describes this call. Doesn't include a full URL as that might contain
+     * sensitive information.
+     */
+    private String toLoggableString() {
+        String string = canceled ? "canceled call" : "call";
+        try {
+            String redactedUrl = new URL(originalRequest.url(), "/...").toString();
+            return string + " to " + redactedUrl;
+        } catch (MalformedURLException e) {
+            return string;
+        }
     }
-  }
-
-  /**
-   * Performs the request and returns the response. May return null if this
-   * call was canceled.
-   */
-  Response getResponse(Request request, boolean forWebSocket) throws IOException {
-    // Copy body metadata to the appropriate request headers.
-    RequestBody body = request.body();
-    if (body != null) {
-      Request.Builder requestBuilder = request.newBuilder();
-
-      MediaType contentType = body.contentType();
-      if (contentType != null) {
-        requestBuilder.header("Content-Type", contentType.toString());
-      }
-
-      long contentLength = body.contentLength();
-      if (contentLength != -1) {
-        requestBuilder.header("Content-Length", Long.toString(contentLength));
-        requestBuilder.removeHeader("Transfer-Encoding");
-      } else {
-        requestBuilder.header("Transfer-Encoding", "chunked");
-        requestBuilder.removeHeader("Content-Length");
-      }
-
-      request = requestBuilder.build();
+
+    private Response getResponseWithInterceptorChain(boolean forWebSocket) throws IOException {
+        Interceptor.Chain chain = new ApplicationInterceptorChain(0, originalRequest, forWebSocket);
+        return chain.proceed(originalRequest);
     }
 
-    // Create the initial HTTP engine. Retries and redirects need new engine for each attempt.
-    engine = new HttpEngine(client, request, false, false, forWebSocket, null, null, null, null);
-
-    int followUpCount = 0;
-    while (true) {
-      if (canceled) {
-        engine.releaseConnection();
-        throw new IOException("Canceled");
-      }
-
-      try {
-        engine.sendRequest();
-        engine.readResponse();
-      } catch (RequestException e) {
-        // The attempt to interpret the request failed. Give up.
-        throw e.getCause();
-      } catch (RouteException e) {
-        // The attempt to connect via a route failed. The request will not have been sent.
-        HttpEngine retryEngine = engine.recover(e);
-        if (retryEngine != null) {
-          engine = retryEngine;
-          continue;
-        }
-        // Give up; recovery is not possible.
-        throw e.getLastConnectException();
-      } catch (IOException e) {
-        // An attempt to communicate with a server failed. The request may have been sent.
-        HttpEngine retryEngine = engine.recover(e, null);
-        if (retryEngine != null) {
-          engine = retryEngine;
-          continue;
-        }
+    class ApplicationInterceptorChain implements Interceptor.Chain {
+        private final int index;
+        private final Request request;
+        private final boolean forWebSocket;
 
-        // Give up; recovery is not possible.
-        throw e;
-      }
+        ApplicationInterceptorChain(int index, Request request, boolean forWebSocket) {
+            this.index = index;
+            this.request = request;
+            this.forWebSocket = forWebSocket;
+        }
 
-      Response response = engine.getResponse();
-      Request followUp = engine.followUpRequest();
+        @Override
+        public Connection connection() {
+            return null;
+        }
 
-      if (followUp == null) {
-        if (!forWebSocket) {
-          engine.releaseConnection();
+        @Override
+        public Request request() {
+            return request;
         }
-        return response;
-      }
 
-      if (++followUpCount > MAX_FOLLOW_UPS) {
-        throw new ProtocolException("Too many follow-up requests: " + followUpCount);
-      }
+        @Override
+        public Response proceed(Request request) throws IOException {
+            if (index < client.interceptors().size()) {
+                // There's another interceptor in the chain. Call that.
+                Interceptor.Chain chain = new ApplicationInterceptorChain(index + 1, request, forWebSocket);
+                return client.interceptors().get(index).intercept(chain);
+            } else {
+                // No more interceptors. Do HTTP.
+                return getResponse(request, forWebSocket);
+            }
+        }
+    }
 
-      if (!engine.sameConnection(followUp.url())) {
-        engine.releaseConnection();
-      }
+    /**
+     * Performs the request and returns the response. May return null if this
+     * call was canceled.
+     */
+    Response getResponse(Request request, boolean forWebSocket) throws IOException {
+        // Copy body metadata to the appropriate request headers.
+        RequestBody body = request.body();
+        if (body != null) {
+            Request.Builder requestBuilder = request.newBuilder();
+
+            MediaType contentType = body.contentType();
+            if (contentType != null) {
+                requestBuilder.header("Content-Type", contentType.toString());
+            }
+
+            long contentLength = body.contentLength();
+            if (contentLength != -1) {
+                requestBuilder.header("Content-Length", Long.toString(contentLength));
+                requestBuilder.removeHeader("Transfer-Encoding");
+            } else {
+                requestBuilder.header("Transfer-Encoding", "chunked");
+                requestBuilder.removeHeader("Content-Length");
+            }
+
+            request = requestBuilder.build();
+        }
 
-      Connection connection = engine.close();
-      request = followUp;
-      engine = new HttpEngine(client, request, false, false, forWebSocket, connection, null, null,
-          response);
+        // Create the initial HTTP engine. Retries and redirects need new engine for each attempt.
+        engine = new HttpEngine(client, request, false, false, forWebSocket, null, null, null, null);
+
+        int followUpCount = 0;
+        while (true) {
+            if (canceled) {
+                engine.releaseConnection();
+                throw new IOException("Canceled");
+            }
+
+            try {
+                engine.sendRequest();
+                engine.readResponse();
+            } catch (RequestException e) {
+                // The attempt to interpret the request failed. Give up.
+                throw e.getCause();
+            } catch (RouteException e) {
+                // The attempt to connect via a route failed. The request will not have been sent.
+                HttpEngine retryEngine = engine.recover(e);
+                if (retryEngine != null) {
+                    engine = retryEngine;
+                    continue;
+                }
+                // Give up; recovery is not possible.
+                throw e.getLastConnectException();
+            } catch (IOException e) {
+                // An attempt to communicate with a server failed. The request may have been sent.
+                HttpEngine retryEngine = engine.recover(e, null);
+                if (retryEngine != null) {
+                    engine = retryEngine;
+                    continue;
+                }
+
+                // Give up; recovery is not possible.
+                throw e;
+            }
+
+            Response response = engine.getResponse();
+            Request followUp = engine.followUpRequest();
+
+            if (followUp == null) {
+                if (!forWebSocket) {
+                    engine.releaseConnection();
+                }
+                return response;
+            }
+
+            if (++followUpCount > MAX_FOLLOW_UPS) {
+                throw new ProtocolException("Too many follow-up requests: " + followUpCount);
+            }
+
+            if (!engine.sameConnection(followUp.url())) {
+                engine.releaseConnection();
+            }
+
+            Connection connection = engine.close();
+            request = followUp;
+            engine = new HttpEngine(client, request, false, false, forWebSocket, connection, null, null,
+                    response);
+        }
     }
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Callback.java b/okhttp/src/main/java/com/squareup/okhttp/Callback.java
index d86960fe05..4433701b4a 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Callback.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Callback.java
@@ -18,25 +18,25 @@
 import java.io.IOException;
 
 public interface Callback {
-  /**
-   * Called when the request could not be executed due to cancellation, a
-   * connectivity problem or timeout. Because networks can fail during an
-   * exchange, it is possible that the remote server accepted the request
-   * before the failure.
-   */
-  void onFailure(Request request, IOException e);
+    /**
+     * Called when the request could not be executed due to cancellation, a
+     * connectivity problem or timeout. Because networks can fail during an
+     * exchange, it is possible that the remote server accepted the request
+     * before the failure.
+     */
+    void onFailure(Request request, IOException e);
 
-  /**
-   * Called when the HTTP response was successfully returned by the remote
-   * server. The callback may proceed to read the response body with {@link
-   * Response#body}. The response is still live until its response body is
-   * closed with {@code response.body().close()}. The recipient of the callback
-   * may even consume the response body on another thread.
-   *
-   * <p>Note that transport-layer success (receiving a HTTP response code,
-   * headers and body) does not necessarily indicate application-layer
-   * success: {@code response} may still indicate an unhappy HTTP response
-   * code like 404 or 500.
-   */
-  void onResponse(Response response) throws IOException;
+    /**
+     * Called when the HTTP response was successfully returned by the remote
+     * server. The callback may proceed to read the response body with {@link
+     * Response#body}. The response is still live until its response body is
+     * closed with {@code response.body().close()}. The recipient of the callback
+     * may even consume the response body on another thread.
+     * <p/>
+     * <p>Note that transport-layer success (receiving a HTTP response code,
+     * headers and body) does not necessarily indicate application-layer
+     * success: {@code response} may still indicate an unhappy HTTP response
+     * code like 404 or 500.
+     */
+    void onResponse(Response response) throws IOException;
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/CertificatePinner.java b/okhttp/src/main/java/com/squareup/okhttp/CertificatePinner.java
index 15a29527dc..f8c229aa2e 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/CertificatePinner.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/CertificatePinner.java
@@ -16,6 +16,7 @@
 package com.squareup.okhttp;
 
 import com.squareup.okhttp.internal.Util;
+
 import java.security.cert.Certificate;
 import java.security.cert.X509Certificate;
 import java.util.Arrays;
@@ -24,7 +25,9 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+
 import javax.net.ssl.SSLPeerUnverifiedException;
+
 import okio.ByteString;
 
 import static java.util.Collections.unmodifiableSet;
@@ -34,39 +37,39 @@
  * against attacks on certificate authorities. It also prevents connections
  * through man-in-the-middle certificate authorities either known or unknown to
  * the application's user.
- *
+ * <p/>
  * <p>This class currently pins a certificate's Subject Public Key Info as
  * described on <a href="http://goo.gl/AIx3e5">Adam Langley's Weblog</a>. Pins
  * are base-64 SHA-1 hashes, consistent with the format Chromium uses for <a
  * href="http://goo.gl/XDh6je">static certificates</a>. See Chromium's <a
  * href="http://goo.gl/4CCnGs">pinsets</a> for hostnames that are pinned in that
  * browser.
- *
+ * <p/>
  * <h3>Setting up Certificate Pinning</h3>
  * The easiest way to pin a host is turn on pinning with a broken configuration
  * and read the expected configuration when the connection fails. Be sure to
  * do this on a trusted network, and without man-in-the-middle tools like <a
  * href="http://charlesproxy.com">Charles</a> or <a
  * href="http://fiddlertool.com">Fiddler</a>.
- *
+ * <p/>
  * <p>For example, to pin {@code https://publicobject.com}, start with a broken
  * configuration: <pre>   {@code
- *
+ * <p/>
  *     String hostname = "publicobject.com";
  *     CertificatePinner certificatePinner = new CertificatePinner.Builder()
  *         .add(hostname, "sha1/BOGUSPIN")
  *         .build();
  *     OkHttpClient client = new OkHttpClient();
  *     client.setCertificatePinner(certificatePinner);
- *
+ * <p/>
  *     Request request = new Request.Builder()
  *         .url("https://" + hostname)
  *         .build();
  *     client.newCall(request).execute();
  * }</pre>
- *
+ * <p/>
  * As expected, this fails with a certificate pinning exception: <pre>   {@code
- *
+ * <p/>
  * javax.net.ssl.SSLPeerUnverifiedException: Certificate pinning failure!
  *   Peer certificate chain:
  *     sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=: CN=publicobject.com, OU=PositiveSSL
@@ -80,10 +83,10 @@
  *   at com.squareup.okhttp.Connection.connect(Connection.java)
  *   at com.squareup.okhttp.Connection.connectAndSetOwner(Connection.java)
  * }</pre>
- *
+ * <p/>
  * Follow up by pasting the public key hashes from the exception into the
  * certificate pinner's configuration: <pre>   {@code
- *
+ * <p/>
  *     CertificatePinner certificatePinner = new CertificatePinner.Builder()
  *       .add("publicobject.com", "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=")
  *       .add("publicobject.com", "sha1/SXxoaOSEzPC6BgGmxAt/EAcsajw=")
@@ -91,182 +94,186 @@
  *       .add("publicobject.com", "sha1/T5x9IXmcrQ7YuQxXnxoCmeeQ84c=")
  *       .build();
  * }</pre>
- *
+ * <p/>
  * Pinning is per-hostname and/or per-wildcard pattern. To pin both
  * {@code publicobject.com} and {@code www.publicobject.com}, you must
  * configure both hostnames.
- *
+ * <p/>
  * <p>Wildcard pattern rules:
  * <ol>
- *   <li>Asterisk {@code *} is only permitted in the left-most
- *       domain name label and must be the only character in that label
- *       (i.e., must match the whole left-most label). For example,
- *       {@code *.example.com} is permitted, while {@code *a.example.com},
- *       {@code a*.example.com}, {@code a*b.example.com}, {@code a.*.example.com}
- *       are not permitted.
- *   <li>Asterisk {@code *} cannot match across domain name labels.
- *       For example, {@code *.example.com} matches {@code test.example.com}
- *       but does not match {@code sub.test.example.com}.
- *   <li>Wildcard patterns for single-label domain names are not permitted.
+ * <li>Asterisk {@code *} is only permitted in the left-most
+ * domain name label and must be the only character in that label
+ * (i.e., must match the whole left-most label). For example,
+ * {@code *.example.com} is permitted, while {@code *a.example.com},
+ * {@code a*.example.com}, {@code a*b.example.com}, {@code a.*.example.com}
+ * are not permitted.
+ * <li>Asterisk {@code *} cannot match across domain name labels.
+ * For example, {@code *.example.com} matches {@code test.example.com}
+ * but does not match {@code sub.test.example.com}.
+ * <li>Wildcard patterns for single-label domain names are not permitted.
  * </ol>
- *
+ * <p/>
  * If hostname pinned directly and via wildcard pattern, both
  * direct and wildcard pins will be used. For example: {@code *.example.com} pinned
  * with {@code pin1} and {@code a.example.com} pinned with {@code pin2},
  * to check {@code a.example.com} both {@code pin1} and {@code pin2} will be used.
- *
+ * <p/>
  * <h3>Warning: Certificate Pinning is Dangerous!</h3>
  * Pinning certificates limits your server team's abilities to update their TLS
  * certificates. By pinning certificates, you take on additional operational
  * complexity and limit your ability to migrate between certificate authorities.
  * Do not use certificate pinning without the blessing of your server's TLS
  * administrator!
- *
+ * <p/>
  * <h4>Note about self-signed certificates</h4>
  * {@link CertificatePinner} can not be used to pin self-signed certificate
  * if such certificate is not accepted by {@link javax.net.ssl.TrustManager}.
  *
  * @see <a href="https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning">
- *     OWASP: Certificate and Public Key Pinning</a>
+ * OWASP: Certificate and Public Key Pinning</a>
  */
 public final class CertificatePinner {
-  public static final CertificatePinner DEFAULT = new Builder().build();
+    public static final CertificatePinner DEFAULT = new Builder().build();
 
-  private final Map<String, Set<ByteString>> hostnameToPins;
+    private final Map<String, Set<ByteString>> hostnameToPins;
 
-  private CertificatePinner(Builder builder) {
-    hostnameToPins = Util.immutableMap(builder.hostnameToPins);
-  }
+    private CertificatePinner(Builder builder) {
+        hostnameToPins = Util.immutableMap(builder.hostnameToPins);
+    }
 
-  /**
-   * Confirms that at least one of the certificates pinned for {@code hostname}
-   * is in {@code peerCertificates}. Does nothing if there are no certificates
-   * pinned for {@code hostname}. OkHttp calls this after a successful TLS
-   * handshake, but before the connection is used.
-   *
-   * @throws SSLPeerUnverifiedException if {@code peerCertificates} don't match
-   *     the certificates pinned for {@code hostname}.
-   */
-  public void check(String hostname, List<Certificate> peerCertificates)
-      throws SSLPeerUnverifiedException {
+    /**
+     * Confirms that at least one of the certificates pinned for {@code hostname}
+     * is in {@code peerCertificates}. Does nothing if there are no certificates
+     * pinned for {@code hostname}. OkHttp calls this after a successful TLS
+     * handshake, but before the connection is used.
+     *
+     * @throws SSLPeerUnverifiedException if {@code peerCertificates} don't match
+     *                                    the certificates pinned for {@code hostname}.
+     */
+    public void check(String hostname, List<Certificate> peerCertificates)
+            throws SSLPeerUnverifiedException {
 
-    Set<ByteString> pins = findMatchingPins(hostname);
+        Set<ByteString> pins = findMatchingPins(hostname);
 
-    if (pins == null) return;
+        if (pins == null) return;
 
-    for (int i = 0, size = peerCertificates.size(); i < size; i++) {
-      X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(i);
-      if (pins.contains(sha1(x509Certificate))) return; // Success!
-    }
+        for (int i = 0, size = peerCertificates.size(); i < size; i++) {
+            X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(i);
+            if (pins.contains(sha1(x509Certificate))) return; // Success!
+        }
 
-    // If we couldn't find a matching pin, format a nice exception.
-    StringBuilder message = new StringBuilder()
-        .append("Certificate pinning failure!")
-        .append("\n  Peer certificate chain:");
-    for (int i = 0, size = peerCertificates.size(); i < size; i++) {
-      X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(i);
-      message.append("\n    ").append(pin(x509Certificate))
-          .append(": ").append(x509Certificate.getSubjectDN().getName());
-    }
-    message.append("\n  Pinned certificates for ").append(hostname).append(":");
-    for (ByteString pin : pins) {
-      message.append("\n    sha1/").append(pin.base64());
+        // If we couldn't find a matching pin, format a nice exception.
+        StringBuilder message = new StringBuilder()
+                .append("Certificate pinning failure!")
+                .append("\n  Peer certificate chain:");
+        for (int i = 0, size = peerCertificates.size(); i < size; i++) {
+            X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(i);
+            message.append("\n    ").append(pin(x509Certificate))
+                    .append(": ").append(x509Certificate.getSubjectDN().getName());
+        }
+        message.append("\n  Pinned certificates for ").append(hostname).append(":");
+        for (ByteString pin : pins) {
+            message.append("\n    sha1/").append(pin.base64());
+        }
+        throw new SSLPeerUnverifiedException(message.toString());
     }
-    throw new SSLPeerUnverifiedException(message.toString());
-  }
-
-  /** @deprecated replaced with {@link #check(String, List)}. */
-  public void check(String hostname, Certificate... peerCertificates)
-      throws SSLPeerUnverifiedException {
-    check(hostname, Arrays.asList(peerCertificates));
-  }
 
-  /**
-   * Returns list of matching certificates' pins for the hostname
-   * or {@code null} if hostname does not have pinned certificates.
-   */
-  Set<ByteString> findMatchingPins(String hostname) {
-    Set<ByteString> directPins   = hostnameToPins.get(hostname);
-    Set<ByteString> wildcardPins = null;
+    /**
+     * @deprecated replaced with {@link #check(String, List)}.
+     */
+    public void check(String hostname, Certificate... peerCertificates)
+            throws SSLPeerUnverifiedException {
+        check(hostname, Arrays.asList(peerCertificates));
+    }
 
-    int indexOfFirstDot = hostname.indexOf('.');
-    int indexOfLastDot  = hostname.lastIndexOf('.');
+    /**
+     * Returns list of matching certificates' pins for the hostname
+     * or {@code null} if hostname does not have pinned certificates.
+     */
+    Set<ByteString> findMatchingPins(String hostname) {
+        Set<ByteString> directPins = hostnameToPins.get(hostname);
+        Set<ByteString> wildcardPins = null;
 
-    // Skip hostnames with one dot symbol for wildcard pattern search
-    //   example.com   will  be skipped
-    //   a.example.com won't be skipped
-    if (indexOfFirstDot != indexOfLastDot) {
-      // a.example.com -> search for wildcard pattern *.example.com
-      wildcardPins = hostnameToPins.get("*." + hostname.substring(indexOfFirstDot + 1));
-    }
+        int indexOfFirstDot = hostname.indexOf('.');
+        int indexOfLastDot = hostname.lastIndexOf('.');
 
-    if (directPins == null && wildcardPins == null) return null;
+        // Skip hostnames with one dot symbol for wildcard pattern search
+        //   example.com   will  be skipped
+        //   a.example.com won't be skipped
+        if (indexOfFirstDot != indexOfLastDot) {
+            // a.example.com -> search for wildcard pattern *.example.com
+            wildcardPins = hostnameToPins.get("*." + hostname.substring(indexOfFirstDot + 1));
+        }
 
-    if (directPins != null && wildcardPins != null) {
-      Set<ByteString> pins = new LinkedHashSet<>();
-      pins.addAll(directPins);
-      pins.addAll(wildcardPins);
-      return pins;
-    }
+        if (directPins == null && wildcardPins == null) return null;
 
-    if (directPins != null) return directPins;
+        if (directPins != null && wildcardPins != null) {
+            Set<ByteString> pins = new LinkedHashSet<>();
+            pins.addAll(directPins);
+            pins.addAll(wildcardPins);
+            return pins;
+        }
 
-    return wildcardPins;
-  }
+        if (directPins != null) return directPins;
 
-  /**
-   * Returns the SHA-1 of {@code certificate}'s public key. This uses the
-   * mechanism Moxie Marlinspike describes in <a
-   * href="https://github.com/moxie0/AndroidPinning">Android Pinning</a>.
-   */
-  public static String pin(Certificate certificate) {
-    if (!(certificate instanceof X509Certificate)) {
-      throw new IllegalArgumentException("Certificate pinning requires X509 certificates");
+        return wildcardPins;
     }
-    return "sha1/" + sha1((X509Certificate) certificate).base64();
-  }
 
-  private static ByteString sha1(X509Certificate x509Certificate) {
-    return Util.sha1(ByteString.of(x509Certificate.getPublicKey().getEncoded()));
-  }
+    /**
+     * Returns the SHA-1 of {@code certificate}'s public key. This uses the
+     * mechanism Moxie Marlinspike describes in <a
+     * href="https://github.com/moxie0/AndroidPinning">Android Pinning</a>.
+     */
+    public static String pin(Certificate certificate) {
+        if (!(certificate instanceof X509Certificate)) {
+            throw new IllegalArgumentException("Certificate pinning requires X509 certificates");
+        }
+        return "sha1/" + sha1((X509Certificate) certificate).base64();
+    }
 
-  /** Builds a configured certificate pinner. */
-  public static final class Builder {
-    private final Map<String, Set<ByteString>> hostnameToPins = new LinkedHashMap<>();
+    private static ByteString sha1(X509Certificate x509Certificate) {
+        return Util.sha1(ByteString.of(x509Certificate.getPublicKey().getEncoded()));
+    }
 
     /**
-     * Pins certificates for {@code hostname}.
-     *
-     * @param hostname lower-case host name or wildcard pattern such as {@code *.example.com}.
-     * @param pins SHA-1 hashes. Each pin is a SHA-1 hash of a
-     *     certificate's Subject Public Key Info, base64-encoded and prefixed with
-     *     {@code sha1/}.
+     * Builds a configured certificate pinner.
      */
-    public Builder add(String hostname, String... pins) {
-      if (hostname == null) throw new IllegalArgumentException("hostname == null");
+    public static final class Builder {
+        private final Map<String, Set<ByteString>> hostnameToPins = new LinkedHashMap<>();
 
-      Set<ByteString> hostPins = new LinkedHashSet<>();
-      Set<ByteString> previousPins = hostnameToPins.put(hostname, unmodifiableSet(hostPins));
-      if (previousPins != null) {
-        hostPins.addAll(previousPins);
-      }
+        /**
+         * Pins certificates for {@code hostname}.
+         *
+         * @param hostname lower-case host name or wildcard pattern such as {@code *.example.com}.
+         * @param pins     SHA-1 hashes. Each pin is a SHA-1 hash of a
+         *                 certificate's Subject Public Key Info, base64-encoded and prefixed with
+         *                 {@code sha1/}.
+         */
+        public Builder add(String hostname, String... pins) {
+            if (hostname == null) throw new IllegalArgumentException("hostname == null");
 
-      for (String pin : pins) {
-        if (!pin.startsWith("sha1/")) {
-          throw new IllegalArgumentException("pins must start with 'sha1/': " + pin);
-        }
-        ByteString decodedPin = ByteString.decodeBase64(pin.substring("sha1/".length()));
-        if (decodedPin == null) {
-          throw new IllegalArgumentException("pins must be base64: " + pin);
-        }
-        hostPins.add(decodedPin);
-      }
+            Set<ByteString> hostPins = new LinkedHashSet<>();
+            Set<ByteString> previousPins = hostnameToPins.put(hostname, unmodifiableSet(hostPins));
+            if (previousPins != null) {
+                hostPins.addAll(previousPins);
+            }
 
-      return this;
-    }
+            for (String pin : pins) {
+                if (!pin.startsWith("sha1/")) {
+                    throw new IllegalArgumentException("pins must start with 'sha1/': " + pin);
+                }
+                ByteString decodedPin = ByteString.decodeBase64(pin.substring("sha1/".length()));
+                if (decodedPin == null) {
+                    throw new IllegalArgumentException("pins must be base64: " + pin);
+                }
+                hostPins.add(decodedPin);
+            }
 
-    public CertificatePinner build() {
-      return new CertificatePinner(this);
+            return this;
+        }
+
+        public CertificatePinner build() {
+            return new CertificatePinner(this);
+        }
     }
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Challenge.java b/okhttp/src/main/java/com/squareup/okhttp/Challenge.java
index a1ef7145a0..060afe9f97 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Challenge.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Challenge.java
@@ -17,40 +17,49 @@
 
 import static com.squareup.okhttp.internal.Util.equal;
 
-/** An RFC 2617 challenge. */
+/**
+ * An RFC 2617 challenge.
+ */
 public final class Challenge {
-  private final String scheme;
-  private final String realm;
-
-  public Challenge(String scheme, String realm) {
-    this.scheme = scheme;
-    this.realm = realm;
-  }
-
-  /** Returns the authentication scheme, like {@code Basic}. */
-  public String getScheme() {
-    return scheme;
-  }
-
-  /** Returns the protection space. */
-  public String getRealm() {
-    return realm;
-  }
-
-  @Override public boolean equals(Object o) {
-    return o instanceof Challenge
-        && equal(scheme, ((Challenge) o).scheme)
-        && equal(realm, ((Challenge) o).realm);
-  }
-
-  @Override public int hashCode() {
-    int result = 29;
-    result = 31 * result + (realm != null ? realm.hashCode() : 0);
-    result = 31 * result + (scheme != null ? scheme.hashCode() : 0);
-    return result;
-  }
-
-  @Override public String toString() {
-    return scheme + " realm=\"" + realm + "\"";
-  }
+    private final String scheme;
+    private final String realm;
+
+    public Challenge(String scheme, String realm) {
+        this.scheme = scheme;
+        this.realm = realm;
+    }
+
+    /**
+     * Returns the authentication scheme, like {@code Basic}.
+     */
+    public String getScheme() {
+        return scheme;
+    }
+
+    /**
+     * Returns the protection space.
+     */
+    public String getRealm() {
+        return realm;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        return o instanceof Challenge
+                && equal(scheme, ((Challenge) o).scheme)
+                && equal(realm, ((Challenge) o).realm);
+    }
+
+    @Override
+    public int hashCode() {
+        int result = 29;
+        result = 31 * result + (realm != null ? realm.hashCode() : 0);
+        result = 31 * result + (scheme != null ? scheme.hashCode() : 0);
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        return scheme + " realm=\"" + realm + "\"";
+    }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/CipherSuite.java b/okhttp/src/main/java/com/squareup/okhttp/CipherSuite.java
index 13344578be..78c4788b08 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/CipherSuite.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/CipherSuite.java
@@ -20,356 +20,356 @@
 /**
  * <a href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml">TLS cipher
  * suites</a>.
- *
+ * <p/>
  * <p><strong>Not all cipher suites are supported on all platforms.</strong> As newer cipher suites
  * are created (for stronger privacy, better performance, etc.) they will be adopted by the platform
  * and then exposed here. Cipher suites that are not available on either Android (through API level
  * 20) or Java (through JDK 8) are omitted for brevity.
- *
+ * <p/>
  * <p>See also <a href="https://android.googlesource.com/platform/external/conscrypt/+/master/src/main/java/org/conscrypt/NativeCrypto.java">NativeCrypto.java</a>
  * from conscrypt, which lists the cipher suites supported by Android.
  */
 public enum CipherSuite {
-  // Last updated 2014-11-11 using cipher suites from Android 21 and Java 8.
+    // Last updated 2014-11-11 using cipher suites from Android 21 and Java 8.
 
-  // TLS_NULL_WITH_NULL_NULL("TLS_NULL_WITH_NULL_NULL", 0x0000, 5246, MAX_VALUE, MAX_VALUE),
-  TLS_RSA_WITH_NULL_MD5("SSL_RSA_WITH_NULL_MD5", 0x0001, 5246, 6, 10),
-  TLS_RSA_WITH_NULL_SHA("SSL_RSA_WITH_NULL_SHA", 0x0002, 5246, 6, 10),
-  TLS_RSA_EXPORT_WITH_RC4_40_MD5("SSL_RSA_EXPORT_WITH_RC4_40_MD5", 0x0003, 4346, 6, 10),
-  TLS_RSA_WITH_RC4_128_MD5("SSL_RSA_WITH_RC4_128_MD5", 0x0004, 5246, 6, 10),
-  TLS_RSA_WITH_RC4_128_SHA("SSL_RSA_WITH_RC4_128_SHA", 0x0005, 5246, 6, 10),
-  // TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5("SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5", 0x0006, 4346, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_IDEA_CBC_SHA("TLS_RSA_WITH_IDEA_CBC_SHA", 0x0007, 5469, MAX_VALUE, MAX_VALUE),
-  TLS_RSA_EXPORT_WITH_DES40_CBC_SHA("SSL_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0008, 4346, 6, 10),
-  TLS_RSA_WITH_DES_CBC_SHA("SSL_RSA_WITH_DES_CBC_SHA", 0x0009, 5469, 6, 10),
-  TLS_RSA_WITH_3DES_EDE_CBC_SHA("SSL_RSA_WITH_3DES_EDE_CBC_SHA", 0x000a, 5246, 6, 10),
-  // TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA("SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x000b, 4346, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_DES_CBC_SHA("TLS_DH_DSS_WITH_DES_CBC_SHA", 0x000c, 5469, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA("TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA", 0x000d, 5246, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA("SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x000e, 4346, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_DES_CBC_SHA("TLS_DH_RSA_WITH_DES_CBC_SHA", 0x000f, 5469, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA("TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA", 0x0010, 5246, MAX_VALUE, MAX_VALUE),
-  TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA("SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x0011, 4346, 6, 10),
-  TLS_DHE_DSS_WITH_DES_CBC_SHA("SSL_DHE_DSS_WITH_DES_CBC_SHA", 0x0012, 5469, 6, 10),
-  TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA("SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA", 0x0013, 5246, 6, 10),
-  TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA("SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0014, 4346, 6, 10),
-  TLS_DHE_RSA_WITH_DES_CBC_SHA("SSL_DHE_RSA_WITH_DES_CBC_SHA", 0x0015, 5469, 6, 10),
-  TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA("SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA", 0x0016, 5246, 6, 10),
-  TLS_DH_anon_EXPORT_WITH_RC4_40_MD5("SSL_DH_anon_EXPORT_WITH_RC4_40_MD5", 0x0017, 4346, 6, 10),
-  TLS_DH_anon_WITH_RC4_128_MD5("SSL_DH_anon_WITH_RC4_128_MD5", 0x0018, 5246, 6, 10),
-  TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA("SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA", 0x0019, 4346, 6, 10),
-  TLS_DH_anon_WITH_DES_CBC_SHA("SSL_DH_anon_WITH_DES_CBC_SHA", 0x001a, 5469, 6, 10),
-  TLS_DH_anon_WITH_3DES_EDE_CBC_SHA("SSL_DH_anon_WITH_3DES_EDE_CBC_SHA", 0x001b, 5246, 6, 10),
-  TLS_KRB5_WITH_DES_CBC_SHA("TLS_KRB5_WITH_DES_CBC_SHA", 0x001e, 2712, 6, MAX_VALUE),
-  TLS_KRB5_WITH_3DES_EDE_CBC_SHA("TLS_KRB5_WITH_3DES_EDE_CBC_SHA", 0x001f, 2712, 6, MAX_VALUE),
-  TLS_KRB5_WITH_RC4_128_SHA("TLS_KRB5_WITH_RC4_128_SHA", 0x0020, 2712, 6, MAX_VALUE),
-  // TLS_KRB5_WITH_IDEA_CBC_SHA("TLS_KRB5_WITH_IDEA_CBC_SHA", 0x0021, 2712, MAX_VALUE, MAX_VALUE),
-  TLS_KRB5_WITH_DES_CBC_MD5("TLS_KRB5_WITH_DES_CBC_MD5", 0x0022, 2712, 6, MAX_VALUE),
-  TLS_KRB5_WITH_3DES_EDE_CBC_MD5("TLS_KRB5_WITH_3DES_EDE_CBC_MD5", 0x0023, 2712, 6, MAX_VALUE),
-  TLS_KRB5_WITH_RC4_128_MD5("TLS_KRB5_WITH_RC4_128_MD5", 0x0024, 2712, 6, MAX_VALUE),
-  // TLS_KRB5_WITH_IDEA_CBC_MD5("TLS_KRB5_WITH_IDEA_CBC_MD5", 0x0025, 2712, MAX_VALUE, MAX_VALUE),
-  TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA("TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA", 0x0026, 2712, 6, MAX_VALUE),
-  // TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA", 0x0027, 2712, MAX_VALUE, MAX_VALUE),
-  TLS_KRB5_EXPORT_WITH_RC4_40_SHA("TLS_KRB5_EXPORT_WITH_RC4_40_SHA", 0x0028, 2712, 6, MAX_VALUE),
-  TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5("TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5", 0x0029, 2712, 6, MAX_VALUE),
-  // TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5", 0x002a, 2712, MAX_VALUE, MAX_VALUE),
-  TLS_KRB5_EXPORT_WITH_RC4_40_MD5("TLS_KRB5_EXPORT_WITH_RC4_40_MD5", 0x002b, 2712, 6, MAX_VALUE),
-  // TLS_PSK_WITH_NULL_SHA("TLS_PSK_WITH_NULL_SHA", 0x002c, 4785, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_NULL_SHA("TLS_DHE_PSK_WITH_NULL_SHA", 0x002d, 4785, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_NULL_SHA("TLS_RSA_PSK_WITH_NULL_SHA", 0x002e, 4785, MAX_VALUE, MAX_VALUE),
-  TLS_RSA_WITH_AES_128_CBC_SHA("TLS_RSA_WITH_AES_128_CBC_SHA", 0x002f, 5246, 6, 10),
-  // TLS_DH_DSS_WITH_AES_128_CBC_SHA("TLS_DH_DSS_WITH_AES_128_CBC_SHA", 0x0030, 5246, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_AES_128_CBC_SHA("TLS_DH_RSA_WITH_AES_128_CBC_SHA", 0x0031, 5246, MAX_VALUE, MAX_VALUE),
-  TLS_DHE_DSS_WITH_AES_128_CBC_SHA("TLS_DHE_DSS_WITH_AES_128_CBC_SHA", 0x0032, 5246, 6, 10),
-  TLS_DHE_RSA_WITH_AES_128_CBC_SHA("TLS_DHE_RSA_WITH_AES_128_CBC_SHA", 0x0033, 5246, 6, 10),
-  TLS_DH_anon_WITH_AES_128_CBC_SHA("TLS_DH_anon_WITH_AES_128_CBC_SHA", 0x0034, 5246, 6, 10),
-  TLS_RSA_WITH_AES_256_CBC_SHA("TLS_RSA_WITH_AES_256_CBC_SHA", 0x0035, 5246, 6, 10),
-  // TLS_DH_DSS_WITH_AES_256_CBC_SHA("TLS_DH_DSS_WITH_AES_256_CBC_SHA", 0x0036, 5246, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_AES_256_CBC_SHA("TLS_DH_RSA_WITH_AES_256_CBC_SHA", 0x0037, 5246, MAX_VALUE, MAX_VALUE),
-  TLS_DHE_DSS_WITH_AES_256_CBC_SHA("TLS_DHE_DSS_WITH_AES_256_CBC_SHA", 0x0038, 5246, 6, 10),
-  TLS_DHE_RSA_WITH_AES_256_CBC_SHA("TLS_DHE_RSA_WITH_AES_256_CBC_SHA", 0x0039, 5246, 6, 10),
-  TLS_DH_anon_WITH_AES_256_CBC_SHA("TLS_DH_anon_WITH_AES_256_CBC_SHA", 0x003a, 5246, 6, 10),
-  TLS_RSA_WITH_NULL_SHA256("TLS_RSA_WITH_NULL_SHA256", 0x003b, 5246, 7, 21),
-  TLS_RSA_WITH_AES_128_CBC_SHA256("TLS_RSA_WITH_AES_128_CBC_SHA256", 0x003c, 5246, 7, 21),
-  TLS_RSA_WITH_AES_256_CBC_SHA256("TLS_RSA_WITH_AES_256_CBC_SHA256", 0x003d, 5246, 7, 21),
-  // TLS_DH_DSS_WITH_AES_128_CBC_SHA256("TLS_DH_DSS_WITH_AES_128_CBC_SHA256", 0x003e, 5246, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_AES_128_CBC_SHA256("TLS_DH_RSA_WITH_AES_128_CBC_SHA256", 0x003f, 5246, MAX_VALUE, MAX_VALUE),
-  TLS_DHE_DSS_WITH_AES_128_CBC_SHA256("TLS_DHE_DSS_WITH_AES_128_CBC_SHA256", 0x0040, 5246, 7, 21),
-  // TLS_RSA_WITH_CAMELLIA_128_CBC_SHA("TLS_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0041, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA("TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0042, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA("TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0043, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA("TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0044, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA("TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0045, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA("TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA", 0x0046, 5932, MAX_VALUE, MAX_VALUE),
-  TLS_DHE_RSA_WITH_AES_128_CBC_SHA256("TLS_DHE_RSA_WITH_AES_128_CBC_SHA256", 0x0067, 5246, 7, 21),
-  // TLS_DH_DSS_WITH_AES_256_CBC_SHA256("TLS_DH_DSS_WITH_AES_256_CBC_SHA256", 0x0068, 5246, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_AES_256_CBC_SHA256("TLS_DH_RSA_WITH_AES_256_CBC_SHA256", 0x0069, 5246, MAX_VALUE, MAX_VALUE),
-  TLS_DHE_DSS_WITH_AES_256_CBC_SHA256("TLS_DHE_DSS_WITH_AES_256_CBC_SHA256", 0x006a, 5246, 7, 21),
-  TLS_DHE_RSA_WITH_AES_256_CBC_SHA256("TLS_DHE_RSA_WITH_AES_256_CBC_SHA256", 0x006b, 5246, 7, 21),
-  TLS_DH_anon_WITH_AES_128_CBC_SHA256("TLS_DH_anon_WITH_AES_128_CBC_SHA256", 0x006c, 5246, 7, 21),
-  TLS_DH_anon_WITH_AES_256_CBC_SHA256("TLS_DH_anon_WITH_AES_256_CBC_SHA256", 0x006d, 5246, 7, 21),
-  // TLS_RSA_WITH_CAMELLIA_256_CBC_SHA("TLS_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0084, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA("TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0085, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA("TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0086, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA("TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0087, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA("TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0088, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA("TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA", 0x0089, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_RC4_128_SHA("TLS_PSK_WITH_RC4_128_SHA", 0x008a, 4279, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_3DES_EDE_CBC_SHA("TLS_PSK_WITH_3DES_EDE_CBC_SHA", 0x008b, 4279, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_AES_128_CBC_SHA("TLS_PSK_WITH_AES_128_CBC_SHA", 0x008c, 4279, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_AES_256_CBC_SHA("TLS_PSK_WITH_AES_256_CBC_SHA", 0x008d, 4279, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_RC4_128_SHA("TLS_DHE_PSK_WITH_RC4_128_SHA", 0x008e, 4279, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA("TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA", 0x008f, 4279, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_AES_128_CBC_SHA("TLS_DHE_PSK_WITH_AES_128_CBC_SHA", 0x0090, 4279, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_AES_256_CBC_SHA("TLS_DHE_PSK_WITH_AES_256_CBC_SHA", 0x0091, 4279, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_RC4_128_SHA("TLS_RSA_PSK_WITH_RC4_128_SHA", 0x0092, 4279, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA("TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA", 0x0093, 4279, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_AES_128_CBC_SHA("TLS_RSA_PSK_WITH_AES_128_CBC_SHA", 0x0094, 4279, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_AES_256_CBC_SHA("TLS_RSA_PSK_WITH_AES_256_CBC_SHA", 0x0095, 4279, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_SEED_CBC_SHA("TLS_RSA_WITH_SEED_CBC_SHA", 0x0096, 4162, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_SEED_CBC_SHA("TLS_DH_DSS_WITH_SEED_CBC_SHA", 0x0097, 4162, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_SEED_CBC_SHA("TLS_DH_RSA_WITH_SEED_CBC_SHA", 0x0098, 4162, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_DSS_WITH_SEED_CBC_SHA("TLS_DHE_DSS_WITH_SEED_CBC_SHA", 0x0099, 4162, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_SEED_CBC_SHA("TLS_DHE_RSA_WITH_SEED_CBC_SHA", 0x009a, 4162, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_anon_WITH_SEED_CBC_SHA("TLS_DH_anon_WITH_SEED_CBC_SHA", 0x009b, 4162, MAX_VALUE, MAX_VALUE),
-  TLS_RSA_WITH_AES_128_GCM_SHA256("TLS_RSA_WITH_AES_128_GCM_SHA256", 0x009c, 5288, 8, 21),
-  TLS_RSA_WITH_AES_256_GCM_SHA384("TLS_RSA_WITH_AES_256_GCM_SHA384", 0x009d, 5288, 8, 21),
-  TLS_DHE_RSA_WITH_AES_128_GCM_SHA256("TLS_DHE_RSA_WITH_AES_128_GCM_SHA256", 0x009e, 5288, 8, 21),
-  TLS_DHE_RSA_WITH_AES_256_GCM_SHA384("TLS_DHE_RSA_WITH_AES_256_GCM_SHA384", 0x009f, 5288, 8, 21),
-  // TLS_DH_RSA_WITH_AES_128_GCM_SHA256("TLS_DH_RSA_WITH_AES_128_GCM_SHA256", 0x00a0, 5288, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_AES_256_GCM_SHA384("TLS_DH_RSA_WITH_AES_256_GCM_SHA384", 0x00a1, 5288, MAX_VALUE, MAX_VALUE),
-  TLS_DHE_DSS_WITH_AES_128_GCM_SHA256("TLS_DHE_DSS_WITH_AES_128_GCM_SHA256", 0x00a2, 5288, 8, 21),
-  TLS_DHE_DSS_WITH_AES_256_GCM_SHA384("TLS_DHE_DSS_WITH_AES_256_GCM_SHA384", 0x00a3, 5288, 8, 21),
-  // TLS_DH_DSS_WITH_AES_128_GCM_SHA256("TLS_DH_DSS_WITH_AES_128_GCM_SHA256", 0x00a4, 5288, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_AES_256_GCM_SHA384("TLS_DH_DSS_WITH_AES_256_GCM_SHA384", 0x00a5, 5288, MAX_VALUE, MAX_VALUE),
-  TLS_DH_anon_WITH_AES_128_GCM_SHA256("TLS_DH_anon_WITH_AES_128_GCM_SHA256", 0x00a6, 5288, 8, 21),
-  TLS_DH_anon_WITH_AES_256_GCM_SHA384("TLS_DH_anon_WITH_AES_256_GCM_SHA384", 0x00a7, 5288, 8, 21),
-  // TLS_PSK_WITH_AES_128_GCM_SHA256("TLS_PSK_WITH_AES_128_GCM_SHA256", 0x00a8, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_AES_256_GCM_SHA384("TLS_PSK_WITH_AES_256_GCM_SHA384", 0x00a9, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_AES_128_GCM_SHA256("TLS_DHE_PSK_WITH_AES_128_GCM_SHA256", 0x00aa, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_AES_256_GCM_SHA384("TLS_DHE_PSK_WITH_AES_256_GCM_SHA384", 0x00ab, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_AES_128_GCM_SHA256("TLS_RSA_PSK_WITH_AES_128_GCM_SHA256", 0x00ac, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_AES_256_GCM_SHA384("TLS_RSA_PSK_WITH_AES_256_GCM_SHA384", 0x00ad, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_AES_128_CBC_SHA256("TLS_PSK_WITH_AES_128_CBC_SHA256", 0x00ae, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_AES_256_CBC_SHA384("TLS_PSK_WITH_AES_256_CBC_SHA384", 0x00af, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_NULL_SHA256("TLS_PSK_WITH_NULL_SHA256", 0x00b0, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_NULL_SHA384("TLS_PSK_WITH_NULL_SHA384", 0x00b1, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_AES_128_CBC_SHA256("TLS_DHE_PSK_WITH_AES_128_CBC_SHA256", 0x00b2, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_AES_256_CBC_SHA384("TLS_DHE_PSK_WITH_AES_256_CBC_SHA384", 0x00b3, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_NULL_SHA256("TLS_DHE_PSK_WITH_NULL_SHA256", 0x00b4, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_NULL_SHA384("TLS_DHE_PSK_WITH_NULL_SHA384", 0x00b5, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_AES_128_CBC_SHA256("TLS_RSA_PSK_WITH_AES_128_CBC_SHA256", 0x00b6, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_AES_256_CBC_SHA384("TLS_RSA_PSK_WITH_AES_256_CBC_SHA384", 0x00b7, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_NULL_SHA256("TLS_RSA_PSK_WITH_NULL_SHA256", 0x00b8, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_NULL_SHA384("TLS_RSA_PSK_WITH_NULL_SHA384", 0x00b9, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256("TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00ba, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256("TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256", 0x00bb, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256("TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00bc, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256("TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256", 0x00bd, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256("TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00be, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256("TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256", 0x00bf, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256("TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c0, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256("TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256", 0x00c1, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256("TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c2, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256("TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256", 0x00c3, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256("TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c4, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256("TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256", 0x00c5, 5932, MAX_VALUE, MAX_VALUE),
-  TLS_EMPTY_RENEGOTIATION_INFO_SCSV("TLS_EMPTY_RENEGOTIATION_INFO_SCSV", 0x00ff, 5746, 6, 14),
-  TLS_ECDH_ECDSA_WITH_NULL_SHA("TLS_ECDH_ECDSA_WITH_NULL_SHA", 0xc001, 4492, 7, 14),
-  TLS_ECDH_ECDSA_WITH_RC4_128_SHA("TLS_ECDH_ECDSA_WITH_RC4_128_SHA", 0xc002, 4492, 7, 14),
-  TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA("TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA", 0xc003, 4492, 7, 14),
-  TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA", 0xc004, 4492, 7, 14),
-  TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA", 0xc005, 4492, 7, 14),
-  TLS_ECDHE_ECDSA_WITH_NULL_SHA("TLS_ECDHE_ECDSA_WITH_NULL_SHA", 0xc006, 4492, 7, 14),
-  TLS_ECDHE_ECDSA_WITH_RC4_128_SHA("TLS_ECDHE_ECDSA_WITH_RC4_128_SHA", 0xc007, 4492, 7, 14),
-  TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA("TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA", 0xc008, 4492, 7, 14),
-  TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA", 0xc009, 4492, 7, 14),
-  TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA", 0xc00a, 4492, 7, 14),
-  TLS_ECDH_RSA_WITH_NULL_SHA("TLS_ECDH_RSA_WITH_NULL_SHA", 0xc00b, 4492, 7, 14),
-  TLS_ECDH_RSA_WITH_RC4_128_SHA("TLS_ECDH_RSA_WITH_RC4_128_SHA", 0xc00c, 4492, 7, 14),
-  TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA("TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA", 0xc00d, 4492, 7, 14),
-  TLS_ECDH_RSA_WITH_AES_128_CBC_SHA("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA", 0xc00e, 4492, 7, 14),
-  TLS_ECDH_RSA_WITH_AES_256_CBC_SHA("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA", 0xc00f, 4492, 7, 14),
-  TLS_ECDHE_RSA_WITH_NULL_SHA("TLS_ECDHE_RSA_WITH_NULL_SHA", 0xc010, 4492, 7, 14),
-  TLS_ECDHE_RSA_WITH_RC4_128_SHA("TLS_ECDHE_RSA_WITH_RC4_128_SHA", 0xc011, 4492, 7, 14),
-  TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA("TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA", 0xc012, 4492, 7, 14),
-  TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA", 0xc013, 4492, 7, 14),
-  TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA", 0xc014, 4492, 7, 14),
-  TLS_ECDH_anon_WITH_NULL_SHA("TLS_ECDH_anon_WITH_NULL_SHA", 0xc015, 4492, 7, 14),
-  TLS_ECDH_anon_WITH_RC4_128_SHA("TLS_ECDH_anon_WITH_RC4_128_SHA", 0xc016, 4492, 7, 14),
-  TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA("TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA", 0xc017, 4492, 7, 14),
-  TLS_ECDH_anon_WITH_AES_128_CBC_SHA("TLS_ECDH_anon_WITH_AES_128_CBC_SHA", 0xc018, 4492, 7, 14),
-  TLS_ECDH_anon_WITH_AES_256_CBC_SHA("TLS_ECDH_anon_WITH_AES_256_CBC_SHA", 0xc019, 4492, 7, 14),
-  // TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA("TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA", 0xc01a, 5054, MAX_VALUE, MAX_VALUE),
-  // TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA("TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA", 0xc01b, 5054, MAX_VALUE, MAX_VALUE),
-  // TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA("TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA", 0xc01c, 5054, MAX_VALUE, MAX_VALUE),
-  // TLS_SRP_SHA_WITH_AES_128_CBC_SHA("TLS_SRP_SHA_WITH_AES_128_CBC_SHA", 0xc01d, 5054, MAX_VALUE, MAX_VALUE),
-  // TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA("TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA", 0xc01e, 5054, MAX_VALUE, MAX_VALUE),
-  // TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA("TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA", 0xc01f, 5054, MAX_VALUE, MAX_VALUE),
-  // TLS_SRP_SHA_WITH_AES_256_CBC_SHA("TLS_SRP_SHA_WITH_AES_256_CBC_SHA", 0xc020, 5054, MAX_VALUE, MAX_VALUE),
-  // TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA("TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA", 0xc021, 5054, MAX_VALUE, MAX_VALUE),
-  // TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA("TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA", 0xc022, 5054, MAX_VALUE, MAX_VALUE),
-  TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256", 0xc023, 5289, 7, 21),
-  TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384", 0xc024, 5289, 7, 21),
-  TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256", 0xc025, 5289, 7, 21),
-  TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384", 0xc026, 5289, 7, 21),
-  TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256", 0xc027, 5289, 7, 21),
-  TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384", 0xc028, 5289, 7, 21),
-  TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256", 0xc029, 5289, 7, 21),
-  TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384", 0xc02a, 5289, 7, 21),
-  TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256("TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02b, 5289, 8, 21),
-  TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384("TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02c, 5289, 8, 21),
-  TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256("TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02d, 5289, 8, 21),
-  TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384("TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02e, 5289, 8, 21),
-  TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256("TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256", 0xc02f, 5289, 8, 21),
-  TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384("TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384", 0xc030, 5289, 8, 21),
-  TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256("TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256", 0xc031, 5289, 8, 21),
-  TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384("TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384", 0xc032, 5289, 8, 21),
-  // TLS_ECDHE_PSK_WITH_RC4_128_SHA("TLS_ECDHE_PSK_WITH_RC4_128_SHA", 0xc033, 5489, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA("TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA", 0xc034, 5489, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA("TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA", 0xc035, 5489, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA("TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA", 0xc036, 5489, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256("TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256", 0xc037, 5489, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384("TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384", 0xc038, 5489, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_PSK_WITH_NULL_SHA("TLS_ECDHE_PSK_WITH_NULL_SHA", 0xc039, 5489, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_PSK_WITH_NULL_SHA256("TLS_ECDHE_PSK_WITH_NULL_SHA256", 0xc03a, 5489, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_PSK_WITH_NULL_SHA384("TLS_ECDHE_PSK_WITH_NULL_SHA384", 0xc03b, 5489, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_ARIA_128_CBC_SHA256("TLS_RSA_WITH_ARIA_128_CBC_SHA256", 0xc03c, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_ARIA_256_CBC_SHA384("TLS_RSA_WITH_ARIA_256_CBC_SHA384", 0xc03d, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256("TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256", 0xc03e, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384("TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384", 0xc03f, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256("TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256", 0xc040, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384("TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384", 0xc041, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256("TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256", 0xc042, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384("TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384", 0xc043, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256("TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256", 0xc044, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384("TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384", 0xc045, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_anon_WITH_ARIA_128_CBC_SHA256("TLS_DH_anon_WITH_ARIA_128_CBC_SHA256", 0xc046, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_anon_WITH_ARIA_256_CBC_SHA384("TLS_DH_anon_WITH_ARIA_256_CBC_SHA384", 0xc047, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256("TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256", 0xc048, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384("TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384", 0xc049, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256("TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256", 0xc04a, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384("TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384", 0xc04b, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256("TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256", 0xc04c, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384("TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384", 0xc04d, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256("TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256", 0xc04e, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384("TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384", 0xc04f, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_ARIA_128_GCM_SHA256("TLS_RSA_WITH_ARIA_128_GCM_SHA256", 0xc050, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_ARIA_256_GCM_SHA384("TLS_RSA_WITH_ARIA_256_GCM_SHA384", 0xc051, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256("TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256", 0xc052, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384("TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384", 0xc053, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256("TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256", 0xc054, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384("TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384", 0xc055, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256("TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256", 0xc056, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384("TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384", 0xc057, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256("TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256", 0xc058, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384("TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384", 0xc059, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_anon_WITH_ARIA_128_GCM_SHA256("TLS_DH_anon_WITH_ARIA_128_GCM_SHA256", 0xc05a, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_anon_WITH_ARIA_256_GCM_SHA384("TLS_DH_anon_WITH_ARIA_256_GCM_SHA384", 0xc05b, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256("TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256", 0xc05c, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384("TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384", 0xc05d, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256("TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256", 0xc05e, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384("TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384", 0xc05f, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256("TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256", 0xc060, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384("TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384", 0xc061, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256("TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256", 0xc062, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384("TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384", 0xc063, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_ARIA_128_CBC_SHA256("TLS_PSK_WITH_ARIA_128_CBC_SHA256", 0xc064, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_ARIA_256_CBC_SHA384("TLS_PSK_WITH_ARIA_256_CBC_SHA384", 0xc065, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256("TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256", 0xc066, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384("TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384", 0xc067, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256("TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256", 0xc068, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384("TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384", 0xc069, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_ARIA_128_GCM_SHA256("TLS_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06a, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_ARIA_256_GCM_SHA384("TLS_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06b, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256("TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06c, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384("TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06d, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256("TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06e, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384("TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06f, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256("TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256", 0xc070, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384("TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384", 0xc071, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256("TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc072, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384("TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc073, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256("TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc074, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384("TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc075, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256("TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc076, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384("TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc077, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256("TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc078, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384("TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc079, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256("TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07a, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384("TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07b, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256("TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07c, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384("TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07d, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256("TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07e, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384("TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07f, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256("TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256", 0xc080, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384("TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384", 0xc081, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256("TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256", 0xc082, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384("TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384", 0xc083, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256("TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256", 0xc084, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384("TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384", 0xc085, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256("TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc086, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384("TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc087, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256("TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc088, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384("TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc089, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256("TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc08a, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384("TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc08b, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256("TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc08c, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384("TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc08d, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256("TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc08e, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384("TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc08f, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256("TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc090, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384("TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc091, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256("TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc092, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384("TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc093, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256("TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc094, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384("TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc095, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256("TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc096, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384("TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc097, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256("TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc098, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384("TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc099, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256("TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc09a, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384("TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc09b, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_AES_128_CCM("TLS_RSA_WITH_AES_128_CCM", 0xc09c, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_AES_256_CCM("TLS_RSA_WITH_AES_256_CCM", 0xc09d, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_AES_128_CCM("TLS_DHE_RSA_WITH_AES_128_CCM", 0xc09e, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_AES_256_CCM("TLS_DHE_RSA_WITH_AES_256_CCM", 0xc09f, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_AES_128_CCM_8("TLS_RSA_WITH_AES_128_CCM_8", 0xc0a0, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_AES_256_CCM_8("TLS_RSA_WITH_AES_256_CCM_8", 0xc0a1, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_AES_128_CCM_8("TLS_DHE_RSA_WITH_AES_128_CCM_8", 0xc0a2, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_AES_256_CCM_8("TLS_DHE_RSA_WITH_AES_256_CCM_8", 0xc0a3, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_AES_128_CCM("TLS_PSK_WITH_AES_128_CCM", 0xc0a4, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_AES_256_CCM("TLS_PSK_WITH_AES_256_CCM", 0xc0a5, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_AES_128_CCM("TLS_DHE_PSK_WITH_AES_128_CCM", 0xc0a6, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_AES_256_CCM("TLS_DHE_PSK_WITH_AES_256_CCM", 0xc0a7, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_AES_128_CCM_8("TLS_PSK_WITH_AES_128_CCM_8", 0xc0a8, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_AES_256_CCM_8("TLS_PSK_WITH_AES_256_CCM_8", 0xc0a9, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_DHE_WITH_AES_128_CCM_8("TLS_PSK_DHE_WITH_AES_128_CCM_8", 0xc0aa, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_DHE_WITH_AES_256_CCM_8("TLS_PSK_DHE_WITH_AES_256_CCM_8", 0xc0ab, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_ECDSA_WITH_AES_128_CCM("TLS_ECDHE_ECDSA_WITH_AES_128_CCM", 0xc0ac, 7251, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_ECDSA_WITH_AES_256_CCM("TLS_ECDHE_ECDSA_WITH_AES_256_CCM", 0xc0ad, 7251, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8("TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8", 0xc0ae, 7251, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8("TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8", 0xc0af, 7251, MAX_VALUE, MAX_VALUE),
-  ;
+    // TLS_NULL_WITH_NULL_NULL("TLS_NULL_WITH_NULL_NULL", 0x0000, 5246, MAX_VALUE, MAX_VALUE),
+    TLS_RSA_WITH_NULL_MD5("SSL_RSA_WITH_NULL_MD5", 0x0001, 5246, 6, 10),
+    TLS_RSA_WITH_NULL_SHA("SSL_RSA_WITH_NULL_SHA", 0x0002, 5246, 6, 10),
+    TLS_RSA_EXPORT_WITH_RC4_40_MD5("SSL_RSA_EXPORT_WITH_RC4_40_MD5", 0x0003, 4346, 6, 10),
+    TLS_RSA_WITH_RC4_128_MD5("SSL_RSA_WITH_RC4_128_MD5", 0x0004, 5246, 6, 10),
+    TLS_RSA_WITH_RC4_128_SHA("SSL_RSA_WITH_RC4_128_SHA", 0x0005, 5246, 6, 10),
+    // TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5("SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5", 0x0006, 4346, MAX_VALUE, MAX_VALUE),
+    // TLS_RSA_WITH_IDEA_CBC_SHA("TLS_RSA_WITH_IDEA_CBC_SHA", 0x0007, 5469, MAX_VALUE, MAX_VALUE),
+    TLS_RSA_EXPORT_WITH_DES40_CBC_SHA("SSL_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0008, 4346, 6, 10),
+    TLS_RSA_WITH_DES_CBC_SHA("SSL_RSA_WITH_DES_CBC_SHA", 0x0009, 5469, 6, 10),
+    TLS_RSA_WITH_3DES_EDE_CBC_SHA("SSL_RSA_WITH_3DES_EDE_CBC_SHA", 0x000a, 5246, 6, 10),
+    // TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA("SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x000b, 4346, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_DSS_WITH_DES_CBC_SHA("TLS_DH_DSS_WITH_DES_CBC_SHA", 0x000c, 5469, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA("TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA", 0x000d, 5246, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA("SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x000e, 4346, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_RSA_WITH_DES_CBC_SHA("TLS_DH_RSA_WITH_DES_CBC_SHA", 0x000f, 5469, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA("TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA", 0x0010, 5246, MAX_VALUE, MAX_VALUE),
+    TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA("SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x0011, 4346, 6, 10),
+    TLS_DHE_DSS_WITH_DES_CBC_SHA("SSL_DHE_DSS_WITH_DES_CBC_SHA", 0x0012, 5469, 6, 10),
+    TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA("SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA", 0x0013, 5246, 6, 10),
+    TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA("SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0014, 4346, 6, 10),
+    TLS_DHE_RSA_WITH_DES_CBC_SHA("SSL_DHE_RSA_WITH_DES_CBC_SHA", 0x0015, 5469, 6, 10),
+    TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA("SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA", 0x0016, 5246, 6, 10),
+    TLS_DH_anon_EXPORT_WITH_RC4_40_MD5("SSL_DH_anon_EXPORT_WITH_RC4_40_MD5", 0x0017, 4346, 6, 10),
+    TLS_DH_anon_WITH_RC4_128_MD5("SSL_DH_anon_WITH_RC4_128_MD5", 0x0018, 5246, 6, 10),
+    TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA("SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA", 0x0019, 4346, 6, 10),
+    TLS_DH_anon_WITH_DES_CBC_SHA("SSL_DH_anon_WITH_DES_CBC_SHA", 0x001a, 5469, 6, 10),
+    TLS_DH_anon_WITH_3DES_EDE_CBC_SHA("SSL_DH_anon_WITH_3DES_EDE_CBC_SHA", 0x001b, 5246, 6, 10),
+    TLS_KRB5_WITH_DES_CBC_SHA("TLS_KRB5_WITH_DES_CBC_SHA", 0x001e, 2712, 6, MAX_VALUE),
+    TLS_KRB5_WITH_3DES_EDE_CBC_SHA("TLS_KRB5_WITH_3DES_EDE_CBC_SHA", 0x001f, 2712, 6, MAX_VALUE),
+    TLS_KRB5_WITH_RC4_128_SHA("TLS_KRB5_WITH_RC4_128_SHA", 0x0020, 2712, 6, MAX_VALUE),
+    // TLS_KRB5_WITH_IDEA_CBC_SHA("TLS_KRB5_WITH_IDEA_CBC_SHA", 0x0021, 2712, MAX_VALUE, MAX_VALUE),
+    TLS_KRB5_WITH_DES_CBC_MD5("TLS_KRB5_WITH_DES_CBC_MD5", 0x0022, 2712, 6, MAX_VALUE),
+    TLS_KRB5_WITH_3DES_EDE_CBC_MD5("TLS_KRB5_WITH_3DES_EDE_CBC_MD5", 0x0023, 2712, 6, MAX_VALUE),
+    TLS_KRB5_WITH_RC4_128_MD5("TLS_KRB5_WITH_RC4_128_MD5", 0x0024, 2712, 6, MAX_VALUE),
+    // TLS_KRB5_WITH_IDEA_CBC_MD5("TLS_KRB5_WITH_IDEA_CBC_MD5", 0x0025, 2712, MAX_VALUE, MAX_VALUE),
+    TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA("TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA", 0x0026, 2712, 6, MAX_VALUE),
+    // TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA", 0x0027, 2712, MAX_VALUE, MAX_VALUE),
+    TLS_KRB5_EXPORT_WITH_RC4_40_SHA("TLS_KRB5_EXPORT_WITH_RC4_40_SHA", 0x0028, 2712, 6, MAX_VALUE),
+    TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5("TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5", 0x0029, 2712, 6, MAX_VALUE),
+    // TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5", 0x002a, 2712, MAX_VALUE, MAX_VALUE),
+    TLS_KRB5_EXPORT_WITH_RC4_40_MD5("TLS_KRB5_EXPORT_WITH_RC4_40_MD5", 0x002b, 2712, 6, MAX_VALUE),
+    // TLS_PSK_WITH_NULL_SHA("TLS_PSK_WITH_NULL_SHA", 0x002c, 4785, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_PSK_WITH_NULL_SHA("TLS_DHE_PSK_WITH_NULL_SHA", 0x002d, 4785, MAX_VALUE, MAX_VALUE),
+    // TLS_RSA_PSK_WITH_NULL_SHA("TLS_RSA_PSK_WITH_NULL_SHA", 0x002e, 4785, MAX_VALUE, MAX_VALUE),
+    TLS_RSA_WITH_AES_128_CBC_SHA("TLS_RSA_WITH_AES_128_CBC_SHA", 0x002f, 5246, 6, 10),
+    // TLS_DH_DSS_WITH_AES_128_CBC_SHA("TLS_DH_DSS_WITH_AES_128_CBC_SHA", 0x0030, 5246, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_RSA_WITH_AES_128_CBC_SHA("TLS_DH_RSA_WITH_AES_128_CBC_SHA", 0x0031, 5246, MAX_VALUE, MAX_VALUE),
+    TLS_DHE_DSS_WITH_AES_128_CBC_SHA("TLS_DHE_DSS_WITH_AES_128_CBC_SHA", 0x0032, 5246, 6, 10),
+    TLS_DHE_RSA_WITH_AES_128_CBC_SHA("TLS_DHE_RSA_WITH_AES_128_CBC_SHA", 0x0033, 5246, 6, 10),
+    TLS_DH_anon_WITH_AES_128_CBC_SHA("TLS_DH_anon_WITH_AES_128_CBC_SHA", 0x0034, 5246, 6, 10),
+    TLS_RSA_WITH_AES_256_CBC_SHA("TLS_RSA_WITH_AES_256_CBC_SHA", 0x0035, 5246, 6, 10),
+    // TLS_DH_DSS_WITH_AES_256_CBC_SHA("TLS_DH_DSS_WITH_AES_256_CBC_SHA", 0x0036, 5246, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_RSA_WITH_AES_256_CBC_SHA("TLS_DH_RSA_WITH_AES_256_CBC_SHA", 0x0037, 5246, MAX_VALUE, MAX_VALUE),
+    TLS_DHE_DSS_WITH_AES_256_CBC_SHA("TLS_DHE_DSS_WITH_AES_256_CBC_SHA", 0x0038, 5246, 6, 10),
+    TLS_DHE_RSA_WITH_AES_256_CBC_SHA("TLS_DHE_RSA_WITH_AES_256_CBC_SHA", 0x0039, 5246, 6, 10),
+    TLS_DH_anon_WITH_AES_256_CBC_SHA("TLS_DH_anon_WITH_AES_256_CBC_SHA", 0x003a, 5246, 6, 10),
+    TLS_RSA_WITH_NULL_SHA256("TLS_RSA_WITH_NULL_SHA256", 0x003b, 5246, 7, 21),
+    TLS_RSA_WITH_AES_128_CBC_SHA256("TLS_RSA_WITH_AES_128_CBC_SHA256", 0x003c, 5246, 7, 21),
+    TLS_RSA_WITH_AES_256_CBC_SHA256("TLS_RSA_WITH_AES_256_CBC_SHA256", 0x003d, 5246, 7, 21),
+    // TLS_DH_DSS_WITH_AES_128_CBC_SHA256("TLS_DH_DSS_WITH_AES_128_CBC_SHA256", 0x003e, 5246, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_RSA_WITH_AES_128_CBC_SHA256("TLS_DH_RSA_WITH_AES_128_CBC_SHA256", 0x003f, 5246, MAX_VALUE, MAX_VALUE),
+    TLS_DHE_DSS_WITH_AES_128_CBC_SHA256("TLS_DHE_DSS_WITH_AES_128_CBC_SHA256", 0x0040, 5246, 7, 21),
+    // TLS_RSA_WITH_CAMELLIA_128_CBC_SHA("TLS_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0041, 5932, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA("TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0042, 5932, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA("TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0043, 5932, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA("TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0044, 5932, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA("TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0045, 5932, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA("TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA", 0x0046, 5932, MAX_VALUE, MAX_VALUE),
+    TLS_DHE_RSA_WITH_AES_128_CBC_SHA256("TLS_DHE_RSA_WITH_AES_128_CBC_SHA256", 0x0067, 5246, 7, 21),
+    // TLS_DH_DSS_WITH_AES_256_CBC_SHA256("TLS_DH_DSS_WITH_AES_256_CBC_SHA256", 0x0068, 5246, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_RSA_WITH_AES_256_CBC_SHA256("TLS_DH_RSA_WITH_AES_256_CBC_SHA256", 0x0069, 5246, MAX_VALUE, MAX_VALUE),
+    TLS_DHE_DSS_WITH_AES_256_CBC_SHA256("TLS_DHE_DSS_WITH_AES_256_CBC_SHA256", 0x006a, 5246, 7, 21),
+    TLS_DHE_RSA_WITH_AES_256_CBC_SHA256("TLS_DHE_RSA_WITH_AES_256_CBC_SHA256", 0x006b, 5246, 7, 21),
+    TLS_DH_anon_WITH_AES_128_CBC_SHA256("TLS_DH_anon_WITH_AES_128_CBC_SHA256", 0x006c, 5246, 7, 21),
+    TLS_DH_anon_WITH_AES_256_CBC_SHA256("TLS_DH_anon_WITH_AES_256_CBC_SHA256", 0x006d, 5246, 7, 21),
+    // TLS_RSA_WITH_CAMELLIA_256_CBC_SHA("TLS_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0084, 5932, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA("TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0085, 5932, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA("TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0086, 5932, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA("TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0087, 5932, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA("TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0088, 5932, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA("TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA", 0x0089, 5932, MAX_VALUE, MAX_VALUE),
+    // TLS_PSK_WITH_RC4_128_SHA("TLS_PSK_WITH_RC4_128_SHA", 0x008a, 4279, MAX_VALUE, MAX_VALUE),
+    // TLS_PSK_WITH_3DES_EDE_CBC_SHA("TLS_PSK_WITH_3DES_EDE_CBC_SHA", 0x008b, 4279, MAX_VALUE, MAX_VALUE),
+    // TLS_PSK_WITH_AES_128_CBC_SHA("TLS_PSK_WITH_AES_128_CBC_SHA", 0x008c, 4279, MAX_VALUE, MAX_VALUE),
+    // TLS_PSK_WITH_AES_256_CBC_SHA("TLS_PSK_WITH_AES_256_CBC_SHA", 0x008d, 4279, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_PSK_WITH_RC4_128_SHA("TLS_DHE_PSK_WITH_RC4_128_SHA", 0x008e, 4279, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA("TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA", 0x008f, 4279, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_PSK_WITH_AES_128_CBC_SHA("TLS_DHE_PSK_WITH_AES_128_CBC_SHA", 0x0090, 4279, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_PSK_WITH_AES_256_CBC_SHA("TLS_DHE_PSK_WITH_AES_256_CBC_SHA", 0x0091, 4279, MAX_VALUE, MAX_VALUE),
+    // TLS_RSA_PSK_WITH_RC4_128_SHA("TLS_RSA_PSK_WITH_RC4_128_SHA", 0x0092, 4279, MAX_VALUE, MAX_VALUE),
+    // TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA("TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA", 0x0093, 4279, MAX_VALUE, MAX_VALUE),
+    // TLS_RSA_PSK_WITH_AES_128_CBC_SHA("TLS_RSA_PSK_WITH_AES_128_CBC_SHA", 0x0094, 4279, MAX_VALUE, MAX_VALUE),
+    // TLS_RSA_PSK_WITH_AES_256_CBC_SHA("TLS_RSA_PSK_WITH_AES_256_CBC_SHA", 0x0095, 4279, MAX_VALUE, MAX_VALUE),
+    // TLS_RSA_WITH_SEED_CBC_SHA("TLS_RSA_WITH_SEED_CBC_SHA", 0x0096, 4162, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_DSS_WITH_SEED_CBC_SHA("TLS_DH_DSS_WITH_SEED_CBC_SHA", 0x0097, 4162, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_RSA_WITH_SEED_CBC_SHA("TLS_DH_RSA_WITH_SEED_CBC_SHA", 0x0098, 4162, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_DSS_WITH_SEED_CBC_SHA("TLS_DHE_DSS_WITH_SEED_CBC_SHA", 0x0099, 4162, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_RSA_WITH_SEED_CBC_SHA("TLS_DHE_RSA_WITH_SEED_CBC_SHA", 0x009a, 4162, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_anon_WITH_SEED_CBC_SHA("TLS_DH_anon_WITH_SEED_CBC_SHA", 0x009b, 4162, MAX_VALUE, MAX_VALUE),
+    TLS_RSA_WITH_AES_128_GCM_SHA256("TLS_RSA_WITH_AES_128_GCM_SHA256", 0x009c, 5288, 8, 21),
+    TLS_RSA_WITH_AES_256_GCM_SHA384("TLS_RSA_WITH_AES_256_GCM_SHA384", 0x009d, 5288, 8, 21),
+    TLS_DHE_RSA_WITH_AES_128_GCM_SHA256("TLS_DHE_RSA_WITH_AES_128_GCM_SHA256", 0x009e, 5288, 8, 21),
+    TLS_DHE_RSA_WITH_AES_256_GCM_SHA384("TLS_DHE_RSA_WITH_AES_256_GCM_SHA384", 0x009f, 5288, 8, 21),
+    // TLS_DH_RSA_WITH_AES_128_GCM_SHA256("TLS_DH_RSA_WITH_AES_128_GCM_SHA256", 0x00a0, 5288, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_RSA_WITH_AES_256_GCM_SHA384("TLS_DH_RSA_WITH_AES_256_GCM_SHA384", 0x00a1, 5288, MAX_VALUE, MAX_VALUE),
+    TLS_DHE_DSS_WITH_AES_128_GCM_SHA256("TLS_DHE_DSS_WITH_AES_128_GCM_SHA256", 0x00a2, 5288, 8, 21),
+    TLS_DHE_DSS_WITH_AES_256_GCM_SHA384("TLS_DHE_DSS_WITH_AES_256_GCM_SHA384", 0x00a3, 5288, 8, 21),
+    // TLS_DH_DSS_WITH_AES_128_GCM_SHA256("TLS_DH_DSS_WITH_AES_128_GCM_SHA256", 0x00a4, 5288, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_DSS_WITH_AES_256_GCM_SHA384("TLS_DH_DSS_WITH_AES_256_GCM_SHA384", 0x00a5, 5288, MAX_VALUE, MAX_VALUE),
+    TLS_DH_anon_WITH_AES_128_GCM_SHA256("TLS_DH_anon_WITH_AES_128_GCM_SHA256", 0x00a6, 5288, 8, 21),
+    TLS_DH_anon_WITH_AES_256_GCM_SHA384("TLS_DH_anon_WITH_AES_256_GCM_SHA384", 0x00a7, 5288, 8, 21),
+    // TLS_PSK_WITH_AES_128_GCM_SHA256("TLS_PSK_WITH_AES_128_GCM_SHA256", 0x00a8, 5487, MAX_VALUE, MAX_VALUE),
+    // TLS_PSK_WITH_AES_256_GCM_SHA384("TLS_PSK_WITH_AES_256_GCM_SHA384", 0x00a9, 5487, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_PSK_WITH_AES_128_GCM_SHA256("TLS_DHE_PSK_WITH_AES_128_GCM_SHA256", 0x00aa, 5487, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_PSK_WITH_AES_256_GCM_SHA384("TLS_DHE_PSK_WITH_AES_256_GCM_SHA384", 0x00ab, 5487, MAX_VALUE, MAX_VALUE),
+    // TLS_RSA_PSK_WITH_AES_128_GCM_SHA256("TLS_RSA_PSK_WITH_AES_128_GCM_SHA256", 0x00ac, 5487, MAX_VALUE, MAX_VALUE),
+    // TLS_RSA_PSK_WITH_AES_256_GCM_SHA384("TLS_RSA_PSK_WITH_AES_256_GCM_SHA384", 0x00ad, 5487, MAX_VALUE, MAX_VALUE),
+    // TLS_PSK_WITH_AES_128_CBC_SHA256("TLS_PSK_WITH_AES_128_CBC_SHA256", 0x00ae, 5487, MAX_VALUE, MAX_VALUE),
+    // TLS_PSK_WITH_AES_256_CBC_SHA384("TLS_PSK_WITH_AES_256_CBC_SHA384", 0x00af, 5487, MAX_VALUE, MAX_VALUE),
+    // TLS_PSK_WITH_NULL_SHA256("TLS_PSK_WITH_NULL_SHA256", 0x00b0, 5487, MAX_VALUE, MAX_VALUE),
+    // TLS_PSK_WITH_NULL_SHA384("TLS_PSK_WITH_NULL_SHA384", 0x00b1, 5487, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_PSK_WITH_AES_128_CBC_SHA256("TLS_DHE_PSK_WITH_AES_128_CBC_SHA256", 0x00b2, 5487, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_PSK_WITH_AES_256_CBC_SHA384("TLS_DHE_PSK_WITH_AES_256_CBC_SHA384", 0x00b3, 5487, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_PSK_WITH_NULL_SHA256("TLS_DHE_PSK_WITH_NULL_SHA256", 0x00b4, 5487, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_PSK_WITH_NULL_SHA384("TLS_DHE_PSK_WITH_NULL_SHA384", 0x00b5, 5487, MAX_VALUE, MAX_VALUE),
+    // TLS_RSA_PSK_WITH_AES_128_CBC_SHA256("TLS_RSA_PSK_WITH_AES_128_CBC_SHA256", 0x00b6, 5487, MAX_VALUE, MAX_VALUE),
+    // TLS_RSA_PSK_WITH_AES_256_CBC_SHA384("TLS_RSA_PSK_WITH_AES_256_CBC_SHA384", 0x00b7, 5487, MAX_VALUE, MAX_VALUE),
+    // TLS_RSA_PSK_WITH_NULL_SHA256("TLS_RSA_PSK_WITH_NULL_SHA256", 0x00b8, 5487, MAX_VALUE, MAX_VALUE),
+    // TLS_RSA_PSK_WITH_NULL_SHA384("TLS_RSA_PSK_WITH_NULL_SHA384", 0x00b9, 5487, MAX_VALUE, MAX_VALUE),
+    // TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256("TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00ba, 5932, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256("TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256", 0x00bb, 5932, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256("TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00bc, 5932, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256("TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256", 0x00bd, 5932, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256("TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00be, 5932, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256("TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256", 0x00bf, 5932, MAX_VALUE, MAX_VALUE),
+    // TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256("TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c0, 5932, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256("TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256", 0x00c1, 5932, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256("TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c2, 5932, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256("TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256", 0x00c3, 5932, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256("TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c4, 5932, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256("TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256", 0x00c5, 5932, MAX_VALUE, MAX_VALUE),
+    TLS_EMPTY_RENEGOTIATION_INFO_SCSV("TLS_EMPTY_RENEGOTIATION_INFO_SCSV", 0x00ff, 5746, 6, 14),
+    TLS_ECDH_ECDSA_WITH_NULL_SHA("TLS_ECDH_ECDSA_WITH_NULL_SHA", 0xc001, 4492, 7, 14),
+    TLS_ECDH_ECDSA_WITH_RC4_128_SHA("TLS_ECDH_ECDSA_WITH_RC4_128_SHA", 0xc002, 4492, 7, 14),
+    TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA("TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA", 0xc003, 4492, 7, 14),
+    TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA", 0xc004, 4492, 7, 14),
+    TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA", 0xc005, 4492, 7, 14),
+    TLS_ECDHE_ECDSA_WITH_NULL_SHA("TLS_ECDHE_ECDSA_WITH_NULL_SHA", 0xc006, 4492, 7, 14),
+    TLS_ECDHE_ECDSA_WITH_RC4_128_SHA("TLS_ECDHE_ECDSA_WITH_RC4_128_SHA", 0xc007, 4492, 7, 14),
+    TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA("TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA", 0xc008, 4492, 7, 14),
+    TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA", 0xc009, 4492, 7, 14),
+    TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA", 0xc00a, 4492, 7, 14),
+    TLS_ECDH_RSA_WITH_NULL_SHA("TLS_ECDH_RSA_WITH_NULL_SHA", 0xc00b, 4492, 7, 14),
+    TLS_ECDH_RSA_WITH_RC4_128_SHA("TLS_ECDH_RSA_WITH_RC4_128_SHA", 0xc00c, 4492, 7, 14),
+    TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA("TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA", 0xc00d, 4492, 7, 14),
+    TLS_ECDH_RSA_WITH_AES_128_CBC_SHA("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA", 0xc00e, 4492, 7, 14),
+    TLS_ECDH_RSA_WITH_AES_256_CBC_SHA("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA", 0xc00f, 4492, 7, 14),
+    TLS_ECDHE_RSA_WITH_NULL_SHA("TLS_ECDHE_RSA_WITH_NULL_SHA", 0xc010, 4492, 7, 14),
+    TLS_ECDHE_RSA_WITH_RC4_128_SHA("TLS_ECDHE_RSA_WITH_RC4_128_SHA", 0xc011, 4492, 7, 14),
+    TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA("TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA", 0xc012, 4492, 7, 14),
+    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA", 0xc013, 4492, 7, 14),
+    TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA", 0xc014, 4492, 7, 14),
+    TLS_ECDH_anon_WITH_NULL_SHA("TLS_ECDH_anon_WITH_NULL_SHA", 0xc015, 4492, 7, 14),
+    TLS_ECDH_anon_WITH_RC4_128_SHA("TLS_ECDH_anon_WITH_RC4_128_SHA", 0xc016, 4492, 7, 14),
+    TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA("TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA", 0xc017, 4492, 7, 14),
+    TLS_ECDH_anon_WITH_AES_128_CBC_SHA("TLS_ECDH_anon_WITH_AES_128_CBC_SHA", 0xc018, 4492, 7, 14),
+    TLS_ECDH_anon_WITH_AES_256_CBC_SHA("TLS_ECDH_anon_WITH_AES_256_CBC_SHA", 0xc019, 4492, 7, 14),
+    // TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA("TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA", 0xc01a, 5054, MAX_VALUE, MAX_VALUE),
+    // TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA("TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA", 0xc01b, 5054, MAX_VALUE, MAX_VALUE),
+    // TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA("TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA", 0xc01c, 5054, MAX_VALUE, MAX_VALUE),
+    // TLS_SRP_SHA_WITH_AES_128_CBC_SHA("TLS_SRP_SHA_WITH_AES_128_CBC_SHA", 0xc01d, 5054, MAX_VALUE, MAX_VALUE),
+    // TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA("TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA", 0xc01e, 5054, MAX_VALUE, MAX_VALUE),
+    // TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA("TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA", 0xc01f, 5054, MAX_VALUE, MAX_VALUE),
+    // TLS_SRP_SHA_WITH_AES_256_CBC_SHA("TLS_SRP_SHA_WITH_AES_256_CBC_SHA", 0xc020, 5054, MAX_VALUE, MAX_VALUE),
+    // TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA("TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA", 0xc021, 5054, MAX_VALUE, MAX_VALUE),
+    // TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA("TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA", 0xc022, 5054, MAX_VALUE, MAX_VALUE),
+    TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256", 0xc023, 5289, 7, 21),
+    TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384", 0xc024, 5289, 7, 21),
+    TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256", 0xc025, 5289, 7, 21),
+    TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384", 0xc026, 5289, 7, 21),
+    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256", 0xc027, 5289, 7, 21),
+    TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384", 0xc028, 5289, 7, 21),
+    TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256", 0xc029, 5289, 7, 21),
+    TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384", 0xc02a, 5289, 7, 21),
+    TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256("TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02b, 5289, 8, 21),
+    TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384("TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02c, 5289, 8, 21),
+    TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256("TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02d, 5289, 8, 21),
+    TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384("TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02e, 5289, 8, 21),
+    TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256("TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256", 0xc02f, 5289, 8, 21),
+    TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384("TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384", 0xc030, 5289, 8, 21),
+    TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256("TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256", 0xc031, 5289, 8, 21),
+    TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384("TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384", 0xc032, 5289, 8, 21),
+    // TLS_ECDHE_PSK_WITH_RC4_128_SHA("TLS_ECDHE_PSK_WITH_RC4_128_SHA", 0xc033, 5489, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA("TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA", 0xc034, 5489, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA("TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA", 0xc035, 5489, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA("TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA", 0xc036, 5489, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256("TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256", 0xc037, 5489, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384("TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384", 0xc038, 5489, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDHE_PSK_WITH_NULL_SHA("TLS_ECDHE_PSK_WITH_NULL_SHA", 0xc039, 5489, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDHE_PSK_WITH_NULL_SHA256("TLS_ECDHE_PSK_WITH_NULL_SHA256", 0xc03a, 5489, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDHE_PSK_WITH_NULL_SHA384("TLS_ECDHE_PSK_WITH_NULL_SHA384", 0xc03b, 5489, MAX_VALUE, MAX_VALUE),
+    // TLS_RSA_WITH_ARIA_128_CBC_SHA256("TLS_RSA_WITH_ARIA_128_CBC_SHA256", 0xc03c, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_RSA_WITH_ARIA_256_CBC_SHA384("TLS_RSA_WITH_ARIA_256_CBC_SHA384", 0xc03d, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256("TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256", 0xc03e, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384("TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384", 0xc03f, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256("TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256", 0xc040, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384("TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384", 0xc041, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256("TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256", 0xc042, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384("TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384", 0xc043, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256("TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256", 0xc044, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384("TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384", 0xc045, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_anon_WITH_ARIA_128_CBC_SHA256("TLS_DH_anon_WITH_ARIA_128_CBC_SHA256", 0xc046, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_anon_WITH_ARIA_256_CBC_SHA384("TLS_DH_anon_WITH_ARIA_256_CBC_SHA384", 0xc047, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256("TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256", 0xc048, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384("TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384", 0xc049, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256("TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256", 0xc04a, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384("TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384", 0xc04b, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256("TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256", 0xc04c, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384("TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384", 0xc04d, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256("TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256", 0xc04e, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384("TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384", 0xc04f, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_RSA_WITH_ARIA_128_GCM_SHA256("TLS_RSA_WITH_ARIA_128_GCM_SHA256", 0xc050, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_RSA_WITH_ARIA_256_GCM_SHA384("TLS_RSA_WITH_ARIA_256_GCM_SHA384", 0xc051, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256("TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256", 0xc052, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384("TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384", 0xc053, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256("TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256", 0xc054, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384("TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384", 0xc055, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256("TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256", 0xc056, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384("TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384", 0xc057, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256("TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256", 0xc058, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384("TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384", 0xc059, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_anon_WITH_ARIA_128_GCM_SHA256("TLS_DH_anon_WITH_ARIA_128_GCM_SHA256", 0xc05a, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_anon_WITH_ARIA_256_GCM_SHA384("TLS_DH_anon_WITH_ARIA_256_GCM_SHA384", 0xc05b, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256("TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256", 0xc05c, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384("TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384", 0xc05d, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256("TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256", 0xc05e, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384("TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384", 0xc05f, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256("TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256", 0xc060, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384("TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384", 0xc061, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256("TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256", 0xc062, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384("TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384", 0xc063, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_PSK_WITH_ARIA_128_CBC_SHA256("TLS_PSK_WITH_ARIA_128_CBC_SHA256", 0xc064, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_PSK_WITH_ARIA_256_CBC_SHA384("TLS_PSK_WITH_ARIA_256_CBC_SHA384", 0xc065, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256("TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256", 0xc066, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384("TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384", 0xc067, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256("TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256", 0xc068, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384("TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384", 0xc069, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_PSK_WITH_ARIA_128_GCM_SHA256("TLS_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06a, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_PSK_WITH_ARIA_256_GCM_SHA384("TLS_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06b, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256("TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06c, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384("TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06d, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256("TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06e, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384("TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06f, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256("TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256", 0xc070, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384("TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384", 0xc071, 6209, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256("TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc072, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384("TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc073, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256("TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc074, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384("TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc075, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256("TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc076, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384("TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc077, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256("TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc078, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384("TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc079, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256("TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07a, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384("TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07b, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256("TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07c, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384("TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07d, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256("TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07e, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384("TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07f, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256("TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256", 0xc080, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384("TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384", 0xc081, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256("TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256", 0xc082, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384("TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384", 0xc083, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256("TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256", 0xc084, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384("TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384", 0xc085, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256("TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc086, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384("TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc087, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256("TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc088, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384("TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc089, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256("TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc08a, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384("TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc08b, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256("TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc08c, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384("TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc08d, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256("TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc08e, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384("TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc08f, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256("TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc090, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384("TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc091, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256("TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc092, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384("TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc093, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256("TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc094, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384("TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc095, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256("TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc096, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384("TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc097, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256("TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc098, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384("TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc099, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256("TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc09a, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384("TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc09b, 6367, MAX_VALUE, MAX_VALUE),
+    // TLS_RSA_WITH_AES_128_CCM("TLS_RSA_WITH_AES_128_CCM", 0xc09c, 6655, MAX_VALUE, MAX_VALUE),
+    // TLS_RSA_WITH_AES_256_CCM("TLS_RSA_WITH_AES_256_CCM", 0xc09d, 6655, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_RSA_WITH_AES_128_CCM("TLS_DHE_RSA_WITH_AES_128_CCM", 0xc09e, 6655, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_RSA_WITH_AES_256_CCM("TLS_DHE_RSA_WITH_AES_256_CCM", 0xc09f, 6655, MAX_VALUE, MAX_VALUE),
+    // TLS_RSA_WITH_AES_128_CCM_8("TLS_RSA_WITH_AES_128_CCM_8", 0xc0a0, 6655, MAX_VALUE, MAX_VALUE),
+    // TLS_RSA_WITH_AES_256_CCM_8("TLS_RSA_WITH_AES_256_CCM_8", 0xc0a1, 6655, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_RSA_WITH_AES_128_CCM_8("TLS_DHE_RSA_WITH_AES_128_CCM_8", 0xc0a2, 6655, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_RSA_WITH_AES_256_CCM_8("TLS_DHE_RSA_WITH_AES_256_CCM_8", 0xc0a3, 6655, MAX_VALUE, MAX_VALUE),
+    // TLS_PSK_WITH_AES_128_CCM("TLS_PSK_WITH_AES_128_CCM", 0xc0a4, 6655, MAX_VALUE, MAX_VALUE),
+    // TLS_PSK_WITH_AES_256_CCM("TLS_PSK_WITH_AES_256_CCM", 0xc0a5, 6655, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_PSK_WITH_AES_128_CCM("TLS_DHE_PSK_WITH_AES_128_CCM", 0xc0a6, 6655, MAX_VALUE, MAX_VALUE),
+    // TLS_DHE_PSK_WITH_AES_256_CCM("TLS_DHE_PSK_WITH_AES_256_CCM", 0xc0a7, 6655, MAX_VALUE, MAX_VALUE),
+    // TLS_PSK_WITH_AES_128_CCM_8("TLS_PSK_WITH_AES_128_CCM_8", 0xc0a8, 6655, MAX_VALUE, MAX_VALUE),
+    // TLS_PSK_WITH_AES_256_CCM_8("TLS_PSK_WITH_AES_256_CCM_8", 0xc0a9, 6655, MAX_VALUE, MAX_VALUE),
+    // TLS_PSK_DHE_WITH_AES_128_CCM_8("TLS_PSK_DHE_WITH_AES_128_CCM_8", 0xc0aa, 6655, MAX_VALUE, MAX_VALUE),
+    // TLS_PSK_DHE_WITH_AES_256_CCM_8("TLS_PSK_DHE_WITH_AES_256_CCM_8", 0xc0ab, 6655, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDHE_ECDSA_WITH_AES_128_CCM("TLS_ECDHE_ECDSA_WITH_AES_128_CCM", 0xc0ac, 7251, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDHE_ECDSA_WITH_AES_256_CCM("TLS_ECDHE_ECDSA_WITH_AES_256_CCM", 0xc0ad, 7251, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8("TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8", 0xc0ae, 7251, MAX_VALUE, MAX_VALUE),
+    // TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8("TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8", 0xc0af, 7251, MAX_VALUE, MAX_VALUE),
+    ;
 
-  final String javaName;
+    final String javaName;
 
-  /**
-   * @param javaName the name used by Java APIs for this cipher suite. Different than the IANA name
-   *     for older cipher suites because the prefix is {@code SSL_} instead of {@code TLS_}.
-   * @param value the integer identifier for this cipher suite. (Documentation only.)
-   * @param rfc the RFC describing this cipher suite. (Documentation only.)
-   * @param sinceJavaVersion the first major Java release supporting this cipher suite.
-   * @param sinceAndroidVersion the first Android SDK version supporting this cipher suite.
-   */
-  private CipherSuite(
-      String javaName, int value, int rfc, int sinceJavaVersion, int sinceAndroidVersion) {
-    this.javaName = javaName;
-  }
+    /**
+     * @param javaName            the name used by Java APIs for this cipher suite. Different than the IANA name
+     *                            for older cipher suites because the prefix is {@code SSL_} instead of {@code TLS_}.
+     * @param value               the integer identifier for this cipher suite. (Documentation only.)
+     * @param rfc                 the RFC describing this cipher suite. (Documentation only.)
+     * @param sinceJavaVersion    the first major Java release supporting this cipher suite.
+     * @param sinceAndroidVersion the first Android SDK version supporting this cipher suite.
+     */
+    private CipherSuite(
+            String javaName, int value, int rfc, int sinceJavaVersion, int sinceAndroidVersion) {
+        this.javaName = javaName;
+    }
 
-  public static CipherSuite forJavaName(String javaName) {
-    return javaName.startsWith("SSL_")
-        ? valueOf("TLS_" + javaName.substring(4))
-        : valueOf(javaName);
-  }
+    public static CipherSuite forJavaName(String javaName) {
+        return javaName.startsWith("SSL_")
+                ? valueOf("TLS_" + javaName.substring(4))
+                : valueOf(javaName);
+    }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Connection.java b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
index d04a311f1b..953112eb1e 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Connection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
@@ -16,18 +16,20 @@
  */
 package com.squareup.okhttp;
 
+import com.squareup.okhttp.internal.framed.FramedConnection;
+import com.squareup.okhttp.internal.http.FramedTransport;
 import com.squareup.okhttp.internal.http.HttpConnection;
 import com.squareup.okhttp.internal.http.HttpEngine;
 import com.squareup.okhttp.internal.http.HttpTransport;
 import com.squareup.okhttp.internal.http.RouteException;
 import com.squareup.okhttp.internal.http.SocketConnector;
-import com.squareup.okhttp.internal.http.FramedTransport;
 import com.squareup.okhttp.internal.http.Transport;
-import com.squareup.okhttp.internal.framed.FramedConnection;
+
 import java.io.IOException;
 import java.net.Socket;
 import java.net.UnknownServiceException;
 import java.util.List;
+
 import okio.BufferedSink;
 import okio.BufferedSource;
 
@@ -35,22 +37,22 @@
  * The sockets and streams of an HTTP, HTTPS, or HTTPS+SPDY connection. May be
  * used for multiple HTTP request/response exchanges. Connections may be direct
  * to the origin server or via a proxy.
- *
+ * <p/>
  * <p>Typically instances of this class are created, connected and exercised
  * automatically by the HTTP client. Applications may use this class to monitor
  * HTTP connections as members of a {@linkplain ConnectionPool connection pool}.
- *
+ * <p/>
  * <p>Do not confuse this class with the misnamed {@code HttpURLConnection},
  * which isn't so much a connection as a single request/response exchange.
- *
+ * <p/>
  * <h3>Modern TLS</h3>
  * There are tradeoffs when selecting which options to include when negotiating
  * a secure connection to a remote host. Newer TLS options are quite useful:
  * <ul>
- *   <li>Server Name Indication (SNI) enables one IP address to negotiate secure
- *       connections for multiple domain names.
- *   <li>Application Layer Protocol Negotiation (ALPN) enables the HTTPS port
- *       (443) to be used for different HTTP and SPDY protocols.
+ * <li>Server Name Indication (SNI) enables one IP address to negotiate secure
+ * connections for multiple domain names.
+ * <li>Application Layer Protocol Negotiation (ALPN) enables the HTTPS port
+ * (443) to be used for different HTTP and SPDY protocols.
  * </ul>
  * Unfortunately, older HTTPS servers refuse to connect when such options are
  * presented. Rather than avoiding these options entirely, this class allows a
@@ -58,276 +60,288 @@
  * should the attempt fail.
  */
 public final class Connection {
-  private final ConnectionPool pool;
-  private final Route route;
-
-  private Socket socket;
-  private boolean connected = false;
-  private HttpConnection httpConnection;
-  private FramedConnection framedConnection;
-  private Protocol protocol = Protocol.HTTP_1_1;
-  private long idleStartTimeNs;
-  private Handshake handshake;
-  private int recycleCount;
-
-  /**
-   * The object that owns this connection. Null if it is shared (for SPDY),
-   * belongs to a pool, or has been discarded. Guarded by {@code pool}, which
-   * clears the owner when an incoming connection is recycled.
-   */
-  private Object owner;
-
-  public Connection(ConnectionPool pool, Route route) {
-    this.pool = pool;
-    this.route = route;
-  }
-
-  Object getOwner() {
-    synchronized (pool) {
-      return owner;
+    private final ConnectionPool pool;
+    private final Route route;
+
+    private Socket socket;
+    private boolean connected = false;
+    private HttpConnection httpConnection;
+    private FramedConnection framedConnection;
+    private Protocol protocol = Protocol.HTTP_1_1;
+    private long idleStartTimeNs;
+    private Handshake handshake;
+    private int recycleCount;
+
+    /**
+     * The object that owns this connection. Null if it is shared (for SPDY),
+     * belongs to a pool, or has been discarded. Guarded by {@code pool}, which
+     * clears the owner when an incoming connection is recycled.
+     */
+    private Object owner;
+
+    public Connection(ConnectionPool pool, Route route) {
+        this.pool = pool;
+        this.route = route;
+    }
+
+    Object getOwner() {
+        synchronized (pool) {
+            return owner;
+        }
+    }
+
+    void setOwner(Object owner) {
+        if (isFramed()) return; // Framed connections are shared.
+        synchronized (pool) {
+            if (this.owner != null)
+                throw new IllegalStateException("Connection already has an owner!");
+            this.owner = owner;
+        }
+    }
+
+    /**
+     * Attempts to clears the owner of this connection. Returns true if the owner
+     * was cleared and the connection can be pooled or reused. This will return
+     * false if the connection cannot be pooled or reused, such as if it was
+     * closed with {@link #closeIfOwnedBy}.
+     */
+    boolean clearOwner() {
+        synchronized (pool) {
+            if (owner == null) {
+                // No owner? Don't reuse this connection.
+                return false;
+            }
+
+            owner = null;
+            return true;
+        }
+    }
+
+    /**
+     * Closes this connection if it is currently owned by {@code owner}. This also
+     * strips the ownership of the connection so it cannot be pooled or reused.
+     */
+    void closeIfOwnedBy(Object owner) throws IOException {
+        if (isFramed()) throw new IllegalStateException();
+        synchronized (pool) {
+            if (this.owner != owner) {
+                return; // Wrong owner. Perhaps a late disconnect?
+            }
+
+            this.owner = null; // Drop the owner so the connection won't be reused.
+        }
+
+        // Don't close() inside the synchronized block.
+        socket.close();
+    }
+
+    void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request,
+                 List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {
+        if (connected) throw new IllegalStateException("already connected");
+
+        SocketConnector socketConnector = new SocketConnector(this, pool);
+        SocketConnector.ConnectedSocket connectedSocket;
+        if (route.address.getSslSocketFactory() != null) {
+            // https:// communication
+            connectedSocket = socketConnector.connectTls(connectTimeout, readTimeout, writeTimeout,
+                    request, route, connectionSpecs, connectionRetryEnabled);
+        } else {
+            // http:// communication.
+            if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {
+                throw new RouteException(
+                        new UnknownServiceException(
+                                "CLEARTEXT communication not supported: " + connectionSpecs));
+            }
+            connectedSocket = socketConnector.connectCleartext(connectTimeout, readTimeout, route);
+        }
+
+        socket = connectedSocket.socket;
+        handshake = connectedSocket.handshake;
+        protocol = connectedSocket.alpnProtocol == null
+                ? Protocol.HTTP_1_1 : connectedSocket.alpnProtocol;
+
+        try {
+            if (protocol == Protocol.SPDY_3 || protocol == Protocol.HTTP_2) {
+                socket.setSoTimeout(0); // Framed connection timeouts are set per-stream.
+                framedConnection = new FramedConnection.Builder(route.address.uriHost, true, socket)
+                        .protocol(protocol).build();
+                framedConnection.sendConnectionPreface();
+            } else {
+                httpConnection = new HttpConnection(pool, this, socket);
+            }
+        } catch (IOException e) {
+            throw new RouteException(e);
+        }
+        connected = true;
+    }
+
+    /**
+     * Connects this connection if it isn't already. This creates tunnels, shares
+     * the connection with the connection pool, and configures timeouts.
+     */
+    void connectAndSetOwner(OkHttpClient client, Object owner, Request request)
+            throws RouteException {
+        setOwner(owner);
+
+        if (!isConnected()) {
+            List<ConnectionSpec> connectionSpecs = route.address.getConnectionSpecs();
+            connect(client.getConnectTimeout(), client.getReadTimeout(), client.getWriteTimeout(),
+                    request, connectionSpecs, client.getRetryOnConnectionFailure());
+            if (isFramed()) {
+                client.getConnectionPool().share(this);
+            }
+            client.routeDatabase().connected(getRoute());
+        }
+
+        setTimeouts(client.getReadTimeout(), client.getWriteTimeout());
+    }
+
+    /**
+     * Returns true if {@link #connect} has been attempted on this connection.
+     */
+    boolean isConnected() {
+        return connected;
+    }
+
+    /**
+     * Returns the route used by this connection.
+     */
+    public Route getRoute() {
+        return route;
+    }
+
+    /**
+     * Returns the socket that this connection uses, or null if the connection
+     * is not currently connected.
+     */
+    public Socket getSocket() {
+        return socket;
+    }
+
+    BufferedSource rawSource() {
+        if (httpConnection == null) throw new UnsupportedOperationException();
+        return httpConnection.rawSource();
+    }
+
+    BufferedSink rawSink() {
+        if (httpConnection == null) throw new UnsupportedOperationException();
+        return httpConnection.rawSink();
+    }
+
+    /**
+     * Returns true if this connection is alive.
+     */
+    boolean isAlive() {
+        return !socket.isClosed() && !socket.isInputShutdown() && !socket.isOutputShutdown();
+    }
+
+    /**
+     * Returns true if we are confident that we can read data from this
+     * connection. This is more expensive and more accurate than {@link
+     * #isAlive()}; callers should check {@link #isAlive()} first.
+     */
+    boolean isReadable() {
+        if (httpConnection != null) return httpConnection.isReadable();
+        return true; // Framed connections, and connections before connect() are both optimistic.
+    }
+
+    void resetIdleStartTime() {
+        if (framedConnection != null) throw new IllegalStateException("framedConnection != null");
+        this.idleStartTimeNs = System.nanoTime();
+    }
+
+    /**
+     * Returns true if this connection is idle.
+     */
+    boolean isIdle() {
+        return framedConnection == null || framedConnection.isIdle();
+    }
+
+    /**
+     * Returns the time in ns when this connection became idle. Undefined if
+     * this connection is not idle.
+     */
+    long getIdleStartTimeNs() {
+        return framedConnection == null ? idleStartTimeNs : framedConnection.getIdleStartTimeNs();
+    }
+
+    public Handshake getHandshake() {
+        return handshake;
+    }
+
+    /**
+     * Returns the transport appropriate for this connection.
+     */
+    Transport newTransport(HttpEngine httpEngine) throws IOException {
+        return (framedConnection != null)
+                ? new FramedTransport(httpEngine, framedConnection)
+                : new HttpTransport(httpEngine, httpConnection);
     }
-  }
 
-  void setOwner(Object owner) {
-    if (isFramed()) return; // Framed connections are shared.
-    synchronized (pool) {
-      if (this.owner != null) throw new IllegalStateException("Connection already has an owner!");
-      this.owner = owner;
+    /**
+     * Returns true if this is a SPDY connection. Such connections can be used
+     * in multiple HTTP requests simultaneously.
+     */
+    boolean isFramed() {
+        return framedConnection != null;
     }
-  }
-
-  /**
-   * Attempts to clears the owner of this connection. Returns true if the owner
-   * was cleared and the connection can be pooled or reused. This will return
-   * false if the connection cannot be pooled or reused, such as if it was
-   * closed with {@link #closeIfOwnedBy}.
-   */
-  boolean clearOwner() {
-    synchronized (pool) {
-      if (owner == null) {
-        // No owner? Don't reuse this connection.
-        return false;
-      }
-
-      owner = null;
-      return true;
+
+    /**
+     * Returns the protocol negotiated by this connection, or {@link
+     * Protocol#HTTP_1_1} if no protocol has been negotiated.
+     */
+    public Protocol getProtocol() {
+        return protocol;
     }
-  }
-
-  /**
-   * Closes this connection if it is currently owned by {@code owner}. This also
-   * strips the ownership of the connection so it cannot be pooled or reused.
-   */
-  void closeIfOwnedBy(Object owner) throws IOException {
-    if (isFramed()) throw new IllegalStateException();
-    synchronized (pool) {
-      if (this.owner != owner) {
-        return; // Wrong owner. Perhaps a late disconnect?
-      }
-
-      this.owner = null; // Drop the owner so the connection won't be reused.
+
+    /**
+     * Sets the protocol negotiated by this connection. Typically this is used
+     * when an HTTP/1.1 request is sent and an HTTP/1.0 response is received.
+     */
+    void setProtocol(Protocol protocol) {
+        if (protocol == null) throw new IllegalArgumentException("protocol == null");
+        this.protocol = protocol;
     }
 
-    // Don't close() inside the synchronized block.
-    socket.close();
-  }
-
-  void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request,
-      List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {
-    if (connected) throw new IllegalStateException("already connected");
-
-    SocketConnector socketConnector = new SocketConnector(this, pool);
-    SocketConnector.ConnectedSocket connectedSocket;
-    if (route.address.getSslSocketFactory() != null) {
-      // https:// communication
-      connectedSocket = socketConnector.connectTls(connectTimeout, readTimeout, writeTimeout,
-          request, route, connectionSpecs, connectionRetryEnabled);
-    } else {
-      // http:// communication.
-      if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {
-        throw new RouteException(
-            new UnknownServiceException(
-                "CLEARTEXT communication not supported: " + connectionSpecs));
-      }
-      connectedSocket = socketConnector.connectCleartext(connectTimeout, readTimeout, route);
+    void setTimeouts(int readTimeoutMillis, int writeTimeoutMillis)
+            throws RouteException {
+        if (!connected) throw new IllegalStateException("setTimeouts - not connected");
+
+        // Don't set timeouts on shared SPDY connections.
+        if (httpConnection != null) {
+            try {
+                socket.setSoTimeout(readTimeoutMillis);
+            } catch (IOException e) {
+                throw new RouteException(e);
+            }
+            httpConnection.setTimeouts(readTimeoutMillis, writeTimeoutMillis);
+        }
     }
 
-    socket = connectedSocket.socket;
-    handshake = connectedSocket.handshake;
-    protocol = connectedSocket.alpnProtocol == null
-        ? Protocol.HTTP_1_1 : connectedSocket.alpnProtocol;
-
-    try {
-      if (protocol == Protocol.SPDY_3 || protocol == Protocol.HTTP_2) {
-        socket.setSoTimeout(0); // Framed connection timeouts are set per-stream.
-        framedConnection = new FramedConnection.Builder(route.address.uriHost, true, socket)
-            .protocol(protocol).build();
-        framedConnection.sendConnectionPreface();
-      } else {
-        httpConnection = new HttpConnection(pool, this, socket);
-      }
-    } catch (IOException e) {
-      throw new RouteException(e);
+    void incrementRecycleCount() {
+        recycleCount++;
     }
-    connected = true;
-  }
-
-  /**
-   * Connects this connection if it isn't already. This creates tunnels, shares
-   * the connection with the connection pool, and configures timeouts.
-   */
-  void connectAndSetOwner(OkHttpClient client, Object owner, Request request)
-      throws RouteException {
-    setOwner(owner);
-
-    if (!isConnected()) {
-      List<ConnectionSpec> connectionSpecs = route.address.getConnectionSpecs();
-      connect(client.getConnectTimeout(), client.getReadTimeout(), client.getWriteTimeout(),
-          request, connectionSpecs, client.getRetryOnConnectionFailure());
-      if (isFramed()) {
-        client.getConnectionPool().share(this);
-      }
-      client.routeDatabase().connected(getRoute());
+
+    /**
+     * Returns the number of times this connection has been returned to the
+     * connection pool.
+     */
+    int recycleCount() {
+        return recycleCount;
     }
 
-    setTimeouts(client.getReadTimeout(), client.getWriteTimeout());
-  }
-
-  /** Returns true if {@link #connect} has been attempted on this connection. */
-  boolean isConnected() {
-    return connected;
-  }
-
-  /** Returns the route used by this connection. */
-  public Route getRoute() {
-    return route;
-  }
-
-  /**
-   * Returns the socket that this connection uses, or null if the connection
-   * is not currently connected.
-   */
-  public Socket getSocket() {
-    return socket;
-  }
-
-  BufferedSource rawSource() {
-    if (httpConnection == null) throw new UnsupportedOperationException();
-    return httpConnection.rawSource();
-  }
-
-  BufferedSink rawSink() {
-    if (httpConnection == null) throw new UnsupportedOperationException();
-    return httpConnection.rawSink();
-  }
-
-  /** Returns true if this connection is alive. */
-  boolean isAlive() {
-    return !socket.isClosed() && !socket.isInputShutdown() && !socket.isOutputShutdown();
-  }
-
-  /**
-   * Returns true if we are confident that we can read data from this
-   * connection. This is more expensive and more accurate than {@link
-   * #isAlive()}; callers should check {@link #isAlive()} first.
-   */
-  boolean isReadable() {
-    if (httpConnection != null) return httpConnection.isReadable();
-    return true; // Framed connections, and connections before connect() are both optimistic.
-  }
-
-  void resetIdleStartTime() {
-    if (framedConnection != null) throw new IllegalStateException("framedConnection != null");
-    this.idleStartTimeNs = System.nanoTime();
-  }
-
-  /** Returns true if this connection is idle. */
-  boolean isIdle() {
-    return framedConnection == null || framedConnection.isIdle();
-  }
-
-  /**
-   * Returns the time in ns when this connection became idle. Undefined if
-   * this connection is not idle.
-   */
-  long getIdleStartTimeNs() {
-    return framedConnection == null ? idleStartTimeNs : framedConnection.getIdleStartTimeNs();
-  }
-
-  public Handshake getHandshake() {
-    return handshake;
-  }
-
-  /** Returns the transport appropriate for this connection. */
-  Transport newTransport(HttpEngine httpEngine) throws IOException {
-    return (framedConnection != null)
-        ? new FramedTransport(httpEngine, framedConnection)
-        : new HttpTransport(httpEngine, httpConnection);
-  }
-
-  /**
-   * Returns true if this is a SPDY connection. Such connections can be used
-   * in multiple HTTP requests simultaneously.
-   */
-  boolean isFramed() {
-    return framedConnection != null;
-  }
-
-  /**
-   * Returns the protocol negotiated by this connection, or {@link
-   * Protocol#HTTP_1_1} if no protocol has been negotiated.
-   */
-  public Protocol getProtocol() {
-    return protocol;
-  }
-
-  /**
-   * Sets the protocol negotiated by this connection. Typically this is used
-   * when an HTTP/1.1 request is sent and an HTTP/1.0 response is received.
-   */
-  void setProtocol(Protocol protocol) {
-    if (protocol == null) throw new IllegalArgumentException("protocol == null");
-    this.protocol = protocol;
-  }
-
-  void setTimeouts(int readTimeoutMillis, int writeTimeoutMillis)
-      throws RouteException {
-    if (!connected) throw new IllegalStateException("setTimeouts - not connected");
-
-    // Don't set timeouts on shared SPDY connections.
-    if (httpConnection != null) {
-      try {
-        socket.setSoTimeout(readTimeoutMillis);
-      } catch (IOException e) {
-        throw new RouteException(e);
-      }
-      httpConnection.setTimeouts(readTimeoutMillis, writeTimeoutMillis);
+    @Override
+    public String toString() {
+        return "Connection{"
+                + route.address.uriHost + ":" + route.address.uriPort
+                + ", proxy="
+                + route.proxy
+                + " hostAddress="
+                + route.inetSocketAddress.getAddress().getHostAddress()
+                + " cipherSuite="
+                + (handshake != null ? handshake.cipherSuite() : "none")
+                + " protocol="
+                + protocol
+                + '}';
     }
-  }
-
-  void incrementRecycleCount() {
-    recycleCount++;
-  }
-
-  /**
-   * Returns the number of times this connection has been returned to the
-   * connection pool.
-   */
-  int recycleCount() {
-    return recycleCount;
-  }
-
-  @Override public String toString() {
-    return "Connection{"
-        + route.address.uriHost + ":" + route.address.uriPort
-        + ", proxy="
-        + route.proxy
-        + " hostAddress="
-        + route.inetSocketAddress.getAddress().getHostAddress()
-        + " cipherSuite="
-        + (handshake != null ? handshake.cipherSuite() : "none")
-        + " protocol="
-        + protocol
-        + '}';
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java b/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
index da3ac73c4d..865911a777 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
@@ -18,6 +18,7 @@
 
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
+
 import java.net.SocketException;
 import java.util.ArrayList;
 import java.util.LinkedList;
@@ -33,305 +34,320 @@
  * requests that share the same {@link com.squareup.okhttp.Address} may share a
  * {@link com.squareup.okhttp.Connection}. This class implements the policy of
  * which connections to keep open for future use.
- *
+ * <p/>
  * <p>The {@link #getDefault() system-wide default} uses system properties for
  * tuning parameters:
  * <ul>
- *     <li>{@code http.keepAlive} true if HTTP and SPDY connections should be
- *         pooled at all. Default is true.
- *     <li>{@code http.maxConnections} maximum number of idle connections to
- *         each to keep in the pool. Default is 5.
- *     <li>{@code http.keepAliveDuration} Time in milliseconds to keep the
- *         connection alive in the pool before closing it. Default is 5 minutes.
- *         This property isn't used by {@code HttpURLConnection}.
+ * <li>{@code http.keepAlive} true if HTTP and SPDY connections should be
+ * pooled at all. Default is true.
+ * <li>{@code http.maxConnections} maximum number of idle connections to
+ * each to keep in the pool. Default is 5.
+ * <li>{@code http.keepAliveDuration} Time in milliseconds to keep the
+ * connection alive in the pool before closing it. Default is 5 minutes.
+ * This property isn't used by {@code HttpURLConnection}.
  * </ul>
- *
+ * <p/>
  * <p>The default instance <i>doesn't</i> adjust its configuration as system
  * properties are changed. This assumes that the applications that set these
  * parameters do so before making HTTP connections, and that this class is
  * initialized lazily.
  */
 public final class ConnectionPool {
-  private static final long DEFAULT_KEEP_ALIVE_DURATION_MS = 5 * 60 * 1000; // 5 min
-
-  private static final ConnectionPool systemDefault;
-
-  static {
-    String keepAlive = System.getProperty("http.keepAlive");
-    String keepAliveDuration = System.getProperty("http.keepAliveDuration");
-    String maxIdleConnections = System.getProperty("http.maxConnections");
-    long keepAliveDurationMs = keepAliveDuration != null ? Long.parseLong(keepAliveDuration)
-        : DEFAULT_KEEP_ALIVE_DURATION_MS;
-    if (keepAlive != null && !Boolean.parseBoolean(keepAlive)) {
-      systemDefault = new ConnectionPool(0, keepAliveDurationMs);
-    } else if (maxIdleConnections != null) {
-      systemDefault = new ConnectionPool(Integer.parseInt(maxIdleConnections), keepAliveDurationMs);
-    } else {
-      systemDefault = new ConnectionPool(5, keepAliveDurationMs);
-    }
-  }
-
-  /** The maximum number of idle connections for each address. */
-  private final int maxIdleConnections;
-  private final long keepAliveDurationNs;
-
-  private final LinkedList<Connection> connections = new LinkedList<>();
-
-  /**
-   * A background thread is used to cleanup expired connections. There will be, at most, a single
-   * thread running per connection pool.
-   *
-   * <p>A {@link ThreadPoolExecutor} is used and not a
-   * {@link java.util.concurrent.ScheduledThreadPoolExecutor}; ScheduledThreadPoolExecutors do not
-   * shrink. This executor shrinks the thread pool after a period of inactivity, and starts threads
-   * as needed. Delays are instead handled by the {@link #connectionsCleanupRunnable}. It is
-   * important that the {@link #connectionsCleanupRunnable} stops eventually, otherwise it will pin
-   * the thread, and thus the connection pool, in memory.
-   */
-  private Executor executor = new ThreadPoolExecutor(
-      0 /* corePoolSize */, 1 /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS,
-      new LinkedBlockingQueue<Runnable>(), Util.threadFactory("OkHttp ConnectionPool", true));
-
-  private final Runnable connectionsCleanupRunnable = new Runnable() {
-    @Override public void run() {
-      runCleanupUntilPoolIsEmpty();
-    }
-  };
-
-  public ConnectionPool(int maxIdleConnections, long keepAliveDurationMs) {
-    this.maxIdleConnections = maxIdleConnections;
-    this.keepAliveDurationNs = keepAliveDurationMs * 1000 * 1000;
-  }
-
-  public static ConnectionPool getDefault() {
-    return systemDefault;
-  }
-
-  /** Returns total number of connections in the pool. */
-  public synchronized int getConnectionCount() {
-    return connections.size();
-  }
-
-  /** @deprecated Use {@link #getMultiplexedConnectionCount()}. */
-  @Deprecated
-  public synchronized int getSpdyConnectionCount() {
-    return getMultiplexedConnectionCount();
-  }
-
-  /** Returns total number of multiplexed connections in the pool. */
-  public synchronized int getMultiplexedConnectionCount() {
-    int total = 0;
-    for (Connection connection : connections) {
-      if (connection.isFramed()) total++;
-    }
-    return total;
-  }
-
-  /** Returns total number of http connections in the pool. */
-  public synchronized int getHttpConnectionCount() {
-    return connections.size() - getMultiplexedConnectionCount();
-  }
-
-  /** Returns a recycled connection to {@code address}, or null if no such connection exists. */
-  public synchronized Connection get(Address address) {
-    Connection foundConnection = null;
-    for (ListIterator<Connection> i = connections.listIterator(connections.size());
-        i.hasPrevious(); ) {
-      Connection connection = i.previous();
-      if (!connection.getRoute().getAddress().equals(address)
-          || !connection.isAlive()
-          || System.nanoTime() - connection.getIdleStartTimeNs() >= keepAliveDurationNs) {
-        continue;
-      }
-      i.remove();
-      if (!connection.isFramed()) {
-        try {
-          Platform.get().tagSocket(connection.getSocket());
-        } catch (SocketException e) {
-          Util.closeQuietly(connection.getSocket());
-          // When unable to tag, skip recycling and close
-          Platform.get().logW("Unable to tagSocket(): " + e);
-          continue;
+    private static final long DEFAULT_KEEP_ALIVE_DURATION_MS = 5 * 60 * 1000; // 5 min
+
+    private static final ConnectionPool systemDefault;
+
+    static {
+        String keepAlive = System.getProperty("http.keepAlive");
+        String keepAliveDuration = System.getProperty("http.keepAliveDuration");
+        String maxIdleConnections = System.getProperty("http.maxConnections");
+        long keepAliveDurationMs = keepAliveDuration != null ? Long.parseLong(keepAliveDuration)
+                : DEFAULT_KEEP_ALIVE_DURATION_MS;
+        if (keepAlive != null && !Boolean.parseBoolean(keepAlive)) {
+            systemDefault = new ConnectionPool(0, keepAliveDurationMs);
+        } else if (maxIdleConnections != null) {
+            systemDefault = new ConnectionPool(Integer.parseInt(maxIdleConnections), keepAliveDurationMs);
+        } else {
+            systemDefault = new ConnectionPool(5, keepAliveDurationMs);
         }
-      }
-      foundConnection = connection;
-      break;
     }
 
-    if (foundConnection != null && foundConnection.isFramed()) {
-      connections.addFirst(foundConnection); // Add it back after iteration.
+    /**
+     * The maximum number of idle connections for each address.
+     */
+    private final int maxIdleConnections;
+    private final long keepAliveDurationNs;
+
+    private final LinkedList<Connection> connections = new LinkedList<>();
+
+    /**
+     * A background thread is used to cleanup expired connections. There will be, at most, a single
+     * thread running per connection pool.
+     * <p/>
+     * <p>A {@link ThreadPoolExecutor} is used and not a
+     * {@link java.util.concurrent.ScheduledThreadPoolExecutor}; ScheduledThreadPoolExecutors do not
+     * shrink. This executor shrinks the thread pool after a period of inactivity, and starts threads
+     * as needed. Delays are instead handled by the {@link #connectionsCleanupRunnable}. It is
+     * important that the {@link #connectionsCleanupRunnable} stops eventually, otherwise it will pin
+     * the thread, and thus the connection pool, in memory.
+     */
+    private Executor executor = new ThreadPoolExecutor(
+            0 /* corePoolSize */, 1 /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS,
+            new LinkedBlockingQueue<Runnable>(), Util.threadFactory("OkHttp ConnectionPool", true));
+
+    private final Runnable connectionsCleanupRunnable = new Runnable() {
+        @Override
+        public void run() {
+            runCleanupUntilPoolIsEmpty();
+        }
+    };
+
+    public ConnectionPool(int maxIdleConnections, long keepAliveDurationMs) {
+        this.maxIdleConnections = maxIdleConnections;
+        this.keepAliveDurationNs = keepAliveDurationMs * 1000 * 1000;
     }
 
-    return foundConnection;
-  }
-
-  /**
-   * Gives {@code connection} to the pool. The pool may store the connection,
-   * or close it, as its policy describes.
-   *
-   * <p>It is an error to use {@code connection} after calling this method.
-   */
-  void recycle(Connection connection) {
-    if (connection.isFramed()) {
-      return;
+    public static ConnectionPool getDefault() {
+        return systemDefault;
     }
 
-    if (!connection.clearOwner()) {
-      return; // This connection isn't eligible for reuse.
+    /**
+     * Returns total number of connections in the pool.
+     */
+    public synchronized int getConnectionCount() {
+        return connections.size();
     }
 
-    if (!connection.isAlive()) {
-      Util.closeQuietly(connection.getSocket());
-      return;
+    /**
+     * @deprecated Use {@link #getMultiplexedConnectionCount()}.
+     */
+    @Deprecated
+    public synchronized int getSpdyConnectionCount() {
+        return getMultiplexedConnectionCount();
     }
 
-    try {
-      Platform.get().untagSocket(connection.getSocket());
-    } catch (SocketException e) {
-      // When unable to remove tagging, skip recycling and close.
-      Platform.get().logW("Unable to untagSocket(): " + e);
-      Util.closeQuietly(connection.getSocket());
-      return;
+    /**
+     * Returns total number of multiplexed connections in the pool.
+     */
+    public synchronized int getMultiplexedConnectionCount() {
+        int total = 0;
+        for (Connection connection : connections) {
+            if (connection.isFramed()) total++;
+        }
+        return total;
     }
 
-    synchronized (this) {
-      addConnection(connection);
-      connection.incrementRecycleCount();
-      connection.resetIdleStartTime();
+    /**
+     * Returns total number of http connections in the pool.
+     */
+    public synchronized int getHttpConnectionCount() {
+        return connections.size() - getMultiplexedConnectionCount();
     }
-  }
-
-  private void addConnection(Connection connection) {
-    boolean empty = connections.isEmpty();
-    connections.addFirst(connection);
-    if (empty) {
-      executor.execute(connectionsCleanupRunnable);
-    } else {
-      notifyAll();
+
+    /**
+     * Returns a recycled connection to {@code address}, or null if no such connection exists.
+     */
+    public synchronized Connection get(Address address) {
+        Connection foundConnection = null;
+        for (ListIterator<Connection> i = connections.listIterator(connections.size());
+             i.hasPrevious(); ) {
+            Connection connection = i.previous();
+            if (!connection.getRoute().getAddress().equals(address)
+                    || !connection.isAlive()
+                    || System.nanoTime() - connection.getIdleStartTimeNs() >= keepAliveDurationNs) {
+                continue;
+            }
+            i.remove();
+            if (!connection.isFramed()) {
+                try {
+                    Platform.get().tagSocket(connection.getSocket());
+                } catch (SocketException e) {
+                    Util.closeQuietly(connection.getSocket());
+                    // When unable to tag, skip recycling and close
+                    Platform.get().logW("Unable to tagSocket(): " + e);
+                    continue;
+                }
+            }
+            foundConnection = connection;
+            break;
+        }
+
+        if (foundConnection != null && foundConnection.isFramed()) {
+            connections.addFirst(foundConnection); // Add it back after iteration.
+        }
+
+        return foundConnection;
     }
-  }
-
-  /**
-   * Shares the SPDY connection with the pool. Callers to this method may
-   * continue to use {@code connection}.
-   */
-  void share(Connection connection) {
-    if (!connection.isFramed()) throw new IllegalArgumentException();
-    if (!connection.isAlive()) return;
-    synchronized (this) {
-      addConnection(connection);
+
+    /**
+     * Gives {@code connection} to the pool. The pool may store the connection,
+     * or close it, as its policy describes.
+     * <p/>
+     * <p>It is an error to use {@code connection} after calling this method.
+     */
+    void recycle(Connection connection) {
+        if (connection.isFramed()) {
+            return;
+        }
+
+        if (!connection.clearOwner()) {
+            return; // This connection isn't eligible for reuse.
+        }
+
+        if (!connection.isAlive()) {
+            Util.closeQuietly(connection.getSocket());
+            return;
+        }
+
+        try {
+            Platform.get().untagSocket(connection.getSocket());
+        } catch (SocketException e) {
+            // When unable to remove tagging, skip recycling and close.
+            Platform.get().logW("Unable to untagSocket(): " + e);
+            Util.closeQuietly(connection.getSocket());
+            return;
+        }
+
+        synchronized (this) {
+            addConnection(connection);
+            connection.incrementRecycleCount();
+            connection.resetIdleStartTime();
+        }
     }
-  }
-
-  /** Close and remove all connections in the pool. */
-  public void evictAll() {
-    List<Connection> toEvict;
-    synchronized (this) {
-      toEvict = new ArrayList<>(connections);
-      connections.clear();
-      notifyAll();
+
+    private void addConnection(Connection connection) {
+        boolean empty = connections.isEmpty();
+        connections.addFirst(connection);
+        if (empty) {
+            executor.execute(connectionsCleanupRunnable);
+        } else {
+            notifyAll();
+        }
     }
 
-    for (int i = 0, size = toEvict.size(); i < size; i++) {
-      Util.closeQuietly(toEvict.get(i).getSocket());
+    /**
+     * Shares the SPDY connection with the pool. Callers to this method may
+     * continue to use {@code connection}.
+     */
+    void share(Connection connection) {
+        if (!connection.isFramed()) throw new IllegalArgumentException();
+        if (!connection.isAlive()) return;
+        synchronized (this) {
+            addConnection(connection);
+        }
     }
-  }
 
-  private void runCleanupUntilPoolIsEmpty() {
-    while (true) {
-      if (!performCleanup()) return; // Halt cleanup.
+    /**
+     * Close and remove all connections in the pool.
+     */
+    public void evictAll() {
+        List<Connection> toEvict;
+        synchronized (this) {
+            toEvict = new ArrayList<>(connections);
+            connections.clear();
+            notifyAll();
+        }
+
+        for (int i = 0, size = toEvict.size(); i < size; i++) {
+            Util.closeQuietly(toEvict.get(i).getSocket());
+        }
     }
-  }
-
-  /**
-   * Attempts to make forward progress on connection eviction. There are three possible outcomes:
-   *
-   * <h3>The pool is empty.</h3>
-   * In this case, this method returns false and the eviction job should exit because there are no
-   * further cleanup tasks coming. (If additional connections are added to the pool, another cleanup
-   * job must be enqueued.)
-   *
-   * <h3>Connections were evicted.</h3>
-   * At least one connections was eligible for immediate eviction and was evicted. The method
-   * returns true and cleanup should continue.
-   *
-   * <h3>We waited to evict.</h3>
-   * None of the pooled connections were eligible for immediate eviction. Instead, we waited until
-   * either a connection became eligible for eviction, or the connections list changed. In either
-   * case, the method returns true and cleanup should continue.
-   */
-  // VisibleForTesting
-  boolean performCleanup() {
-    List<Connection> evictableConnections;
-
-    synchronized (this) {
-      if (connections.isEmpty()) return false; // Halt cleanup.
-
-      evictableConnections = new ArrayList<>();
-      int idleConnectionCount = 0;
-      long now = System.nanoTime();
-      long nanosUntilNextEviction = keepAliveDurationNs;
-
-      // Collect connections eligible for immediate eviction.
-      for (ListIterator<Connection> i = connections.listIterator(connections.size());
-          i.hasPrevious(); ) {
-        Connection connection = i.previous();
-        long nanosUntilEviction = connection.getIdleStartTimeNs() + keepAliveDurationNs - now;
-        if (nanosUntilEviction <= 0 || !connection.isAlive()) {
-          i.remove();
-          evictableConnections.add(connection);
-        } else if (connection.isIdle()) {
-          idleConnectionCount++;
-          nanosUntilNextEviction = Math.min(nanosUntilNextEviction, nanosUntilEviction);
+
+    private void runCleanupUntilPoolIsEmpty() {
+        while (true) {
+            if (!performCleanup()) return; // Halt cleanup.
         }
-      }
-
-      // If the pool has too many idle connections, gather more! Oldest to newest.
-      for (ListIterator<Connection> i = connections.listIterator(connections.size());
-          i.hasPrevious() && idleConnectionCount > maxIdleConnections; ) {
-        Connection connection = i.previous();
-        if (connection.isIdle()) {
-          evictableConnections.add(connection);
-          i.remove();
-          --idleConnectionCount;
+    }
+
+    /**
+     * Attempts to make forward progress on connection eviction. There are three possible outcomes:
+     * <p/>
+     * <h3>The pool is empty.</h3>
+     * In this case, this method returns false and the eviction job should exit because there are no
+     * further cleanup tasks coming. (If additional connections are added to the pool, another cleanup
+     * job must be enqueued.)
+     * <p/>
+     * <h3>Connections were evicted.</h3>
+     * At least one connections was eligible for immediate eviction and was evicted. The method
+     * returns true and cleanup should continue.
+     * <p/>
+     * <h3>We waited to evict.</h3>
+     * None of the pooled connections were eligible for immediate eviction. Instead, we waited until
+     * either a connection became eligible for eviction, or the connections list changed. In either
+     * case, the method returns true and cleanup should continue.
+     */
+    // VisibleForTesting
+    boolean performCleanup() {
+        List<Connection> evictableConnections;
+
+        synchronized (this) {
+            if (connections.isEmpty()) return false; // Halt cleanup.
+
+            evictableConnections = new ArrayList<>();
+            int idleConnectionCount = 0;
+            long now = System.nanoTime();
+            long nanosUntilNextEviction = keepAliveDurationNs;
+
+            // Collect connections eligible for immediate eviction.
+            for (ListIterator<Connection> i = connections.listIterator(connections.size());
+                 i.hasPrevious(); ) {
+                Connection connection = i.previous();
+                long nanosUntilEviction = connection.getIdleStartTimeNs() + keepAliveDurationNs - now;
+                if (nanosUntilEviction <= 0 || !connection.isAlive()) {
+                    i.remove();
+                    evictableConnections.add(connection);
+                } else if (connection.isIdle()) {
+                    idleConnectionCount++;
+                    nanosUntilNextEviction = Math.min(nanosUntilNextEviction, nanosUntilEviction);
+                }
+            }
+
+            // If the pool has too many idle connections, gather more! Oldest to newest.
+            for (ListIterator<Connection> i = connections.listIterator(connections.size());
+                 i.hasPrevious() && idleConnectionCount > maxIdleConnections; ) {
+                Connection connection = i.previous();
+                if (connection.isIdle()) {
+                    evictableConnections.add(connection);
+                    i.remove();
+                    --idleConnectionCount;
+                }
+            }
+
+            // If there's nothing to evict, wait. (This will be interrupted if connections are added.)
+            if (evictableConnections.isEmpty()) {
+                try {
+                    long millisUntilNextEviction = nanosUntilNextEviction / (1000 * 1000);
+                    long remainderNanos = nanosUntilNextEviction - millisUntilNextEviction * (1000 * 1000);
+                    this.wait(millisUntilNextEviction, (int) remainderNanos);
+                    return true; // Cleanup continues.
+                } catch (InterruptedException ignored) {
+                }
+            }
         }
-      }
 
-      // If there's nothing to evict, wait. (This will be interrupted if connections are added.)
-      if (evictableConnections.isEmpty()) {
-        try {
-          long millisUntilNextEviction = nanosUntilNextEviction / (1000 * 1000);
-          long remainderNanos = nanosUntilNextEviction - millisUntilNextEviction * (1000 * 1000);
-          this.wait(millisUntilNextEviction, (int) remainderNanos);
-          return true; // Cleanup continues.
-        } catch (InterruptedException ignored) {
+        // Actually do the eviction. Note that we avoid synchronized() when closing sockets.
+        for (int i = 0, size = evictableConnections.size(); i < size; i++) {
+            Connection expiredConnection = evictableConnections.get(i);
+            Util.closeQuietly(expiredConnection.getSocket());
         }
-      }
+
+        return true; // Cleanup continues.
     }
 
-    // Actually do the eviction. Note that we avoid synchronized() when closing sockets.
-    for (int i = 0, size = evictableConnections.size(); i < size; i++) {
-      Connection expiredConnection = evictableConnections.get(i);
-      Util.closeQuietly(expiredConnection.getSocket());
+    /**
+     * Replace the default {@link Executor} with a different one. Only use in tests.
+     */
+    // VisibleForTesting
+    void replaceCleanupExecutorForTests(Executor cleanupExecutor) {
+        this.executor = cleanupExecutor;
     }
 
-    return true; // Cleanup continues.
-  }
-
-  /**
-   * Replace the default {@link Executor} with a different one. Only use in tests.
-   */
-  // VisibleForTesting
-  void replaceCleanupExecutorForTests(Executor cleanupExecutor) {
-    this.executor = cleanupExecutor;
-  }
-
-  /**
-   * Returns a snapshot of the connections in this pool, ordered from newest to
-   * oldest. Only use in tests.
-   */
-  // VisibleForTesting
-  synchronized List<Connection> getConnections() {
-    return new ArrayList<>(connections);
-  }
+    /**
+     * Returns a snapshot of the connections in this pool, ordered from newest to
+     * oldest. Only use in tests.
+     */
+    // VisibleForTesting
+    synchronized List<Connection> getConnections() {
+        return new ArrayList<>(connections);
+    }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/ConnectionSpec.java b/okhttp/src/main/java/com/squareup/okhttp/ConnectionSpec.java
index 5e0f7d868a..be1f3e71e8 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/ConnectionSpec.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/ConnectionSpec.java
@@ -16,8 +16,10 @@
 package com.squareup.okhttp;
 
 import com.squareup.okhttp.internal.Util;
+
 import java.util.Arrays;
 import java.util.List;
+
 import javax.net.ssl.SSLSocket;
 
 /**
@@ -27,325 +29,339 @@
  */
 public final class ConnectionSpec {
 
-  // This is a subset of the cipher suites supported in Chrome 37, current as of 2014-10-5.
-  // All of these suites are available on Android 5.0; earlier releases support a subset of
-  // these suites. https://github.com/square/okhttp/issues/330
-  private static final CipherSuite[] APPROVED_CIPHER_SUITES = new CipherSuite[] {
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
-      CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
-      CipherSuite.TLS_DHE_RSA_WITH_AES_128_GCM_SHA256,
-
-      // Note that the following cipher suites are all on HTTP/2's bad cipher suites list. We'll
-      // continue to include them until better suites are commonly available. For example, none
-      // of the better cipher suites listed above shipped with Android 4.4 or Java 7.
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
-      CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
-      CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
-      CipherSuite.TLS_DHE_RSA_WITH_AES_128_CBC_SHA,
-      CipherSuite.TLS_DHE_DSS_WITH_AES_128_CBC_SHA,
-      CipherSuite.TLS_DHE_RSA_WITH_AES_256_CBC_SHA,
-      CipherSuite.TLS_RSA_WITH_AES_128_GCM_SHA256,
-      CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA,
-      CipherSuite.TLS_RSA_WITH_AES_256_CBC_SHA,
-      CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
-  };
-
-  /** A modern TLS connection with extensions like SNI and ALPN available. */
-  public static final ConnectionSpec MODERN_TLS = new Builder(true)
-      .cipherSuites(APPROVED_CIPHER_SUITES)
-      .tlsVersions(TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0)
-      .supportsTlsExtensions(true)
-      .build();
-
-  /** A backwards-compatible fallback connection for interop with obsolete servers. */
-  public static final ConnectionSpec COMPATIBLE_TLS = new Builder(MODERN_TLS)
-      .tlsVersions(TlsVersion.TLS_1_0)
-      .supportsTlsExtensions(true)
-      .build();
-
-  /** Unencrypted, unauthenticated connections for {@code http:} URLs. */
-  public static final ConnectionSpec CLEARTEXT = new Builder(false).build();
-
-  final boolean tls;
-
-  /**
-   * Used if tls == true. The cipher suites to set on the SSLSocket. {@code null} means "use
-   * default set".
-   */
-  private final String[] cipherSuites;
-
-  /** Used if tls == true. The TLS protocol versions to use. */
-  private final String[] tlsVersions;
-
-  final boolean supportsTlsExtensions;
-
-  private ConnectionSpec(Builder builder) {
-    this.tls = builder.tls;
-    this.cipherSuites = builder.cipherSuites;
-    this.tlsVersions = builder.tlsVersions;
-    this.supportsTlsExtensions = builder.supportsTlsExtensions;
-  }
-
-  public boolean isTls() {
-    return tls;
-  }
-
-  /**
-   * Returns the cipher suites to use for a connection. This method can return {@code null} if the
-   * cipher suites enabled by default should be used.
-   */
-  public List<CipherSuite> cipherSuites() {
-    if (cipherSuites == null) {
-      return null;
+    // This is a subset of the cipher suites supported in Chrome 37, current as of 2014-10-5.
+    // All of these suites are available on Android 5.0; earlier releases support a subset of
+    // these suites. https://github.com/square/okhttp/issues/330
+    private static final CipherSuite[] APPROVED_CIPHER_SUITES = new CipherSuite[]{
+            CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+            CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+            CipherSuite.TLS_DHE_RSA_WITH_AES_128_GCM_SHA256,
+
+            // Note that the following cipher suites are all on HTTP/2's bad cipher suites list. We'll
+            // continue to include them until better suites are commonly available. For example, none
+            // of the better cipher suites listed above shipped with Android 4.4 or Java 7.
+            CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
+            CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
+            CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
+            CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
+            CipherSuite.TLS_DHE_RSA_WITH_AES_128_CBC_SHA,
+            CipherSuite.TLS_DHE_DSS_WITH_AES_128_CBC_SHA,
+            CipherSuite.TLS_DHE_RSA_WITH_AES_256_CBC_SHA,
+            CipherSuite.TLS_RSA_WITH_AES_128_GCM_SHA256,
+            CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA,
+            CipherSuite.TLS_RSA_WITH_AES_256_CBC_SHA,
+            CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
+    };
+
+    /**
+     * A modern TLS connection with extensions like SNI and ALPN available.
+     */
+    public static final ConnectionSpec MODERN_TLS = new Builder(true)
+            .cipherSuites(APPROVED_CIPHER_SUITES)
+            .tlsVersions(TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0)
+            .supportsTlsExtensions(true)
+            .build();
+
+    /**
+     * A backwards-compatible fallback connection for interop with obsolete servers.
+     */
+    public static final ConnectionSpec COMPATIBLE_TLS = new Builder(MODERN_TLS)
+            .tlsVersions(TlsVersion.TLS_1_0)
+            .supportsTlsExtensions(true)
+            .build();
+
+    /**
+     * Unencrypted, unauthenticated connections for {@code http:} URLs.
+     */
+    public static final ConnectionSpec CLEARTEXT = new Builder(false).build();
+
+    final boolean tls;
+
+    /**
+     * Used if tls == true. The cipher suites to set on the SSLSocket. {@code null} means "use
+     * default set".
+     */
+    private final String[] cipherSuites;
+
+    /**
+     * Used if tls == true. The TLS protocol versions to use.
+     */
+    private final String[] tlsVersions;
+
+    final boolean supportsTlsExtensions;
+
+    private ConnectionSpec(Builder builder) {
+        this.tls = builder.tls;
+        this.cipherSuites = builder.cipherSuites;
+        this.tlsVersions = builder.tlsVersions;
+        this.supportsTlsExtensions = builder.supportsTlsExtensions;
     }
-    CipherSuite[] result = new CipherSuite[cipherSuites.length];
-    for (int i = 0; i < cipherSuites.length; i++) {
-      result[i] = CipherSuite.forJavaName(cipherSuites[i]);
-    }
-    return Util.immutableList(result);
-  }
 
-  public List<TlsVersion> tlsVersions() {
-    TlsVersion[] result = new TlsVersion[tlsVersions.length];
-    for (int i = 0; i < tlsVersions.length; i++) {
-      result[i] = TlsVersion.forJavaName(tlsVersions[i]);
+    public boolean isTls() {
+        return tls;
     }
-    return Util.immutableList(result);
-  }
-
-  public boolean supportsTlsExtensions() {
-    return supportsTlsExtensions;
-  }
 
-  /** Applies this spec to {@code sslSocket}. */
-  void apply(SSLSocket sslSocket, boolean isFallback) {
-    ConnectionSpec specToApply = supportedSpec(sslSocket, isFallback);
-
-    sslSocket.setEnabledProtocols(specToApply.tlsVersions);
-
-    String[] cipherSuitesToEnable = specToApply.cipherSuites;
-    // null means "use default set".
-    if (cipherSuitesToEnable != null) {
-      sslSocket.setEnabledCipherSuites(cipherSuitesToEnable);
-    }
-  }
-
-  /**
-   * Returns a copy of this that omits cipher suites and TLS versions not enabled by
-   * {@code sslSocket}.
-   */
-  private ConnectionSpec supportedSpec(SSLSocket sslSocket, boolean isFallback) {
-    String[] cipherSuitesToEnable = null;
-    if (cipherSuites != null) {
-      String[] cipherSuitesToSelectFrom = sslSocket.getEnabledCipherSuites();
-      cipherSuitesToEnable =
-          Util.intersect(String.class, cipherSuites, cipherSuitesToSelectFrom);
+    /**
+     * Returns the cipher suites to use for a connection. This method can return {@code null} if the
+     * cipher suites enabled by default should be used.
+     */
+    public List<CipherSuite> cipherSuites() {
+        if (cipherSuites == null) {
+            return null;
+        }
+        CipherSuite[] result = new CipherSuite[cipherSuites.length];
+        for (int i = 0; i < cipherSuites.length; i++) {
+            result[i] = CipherSuite.forJavaName(cipherSuites[i]);
+        }
+        return Util.immutableList(result);
     }
 
-    if (isFallback) {
-      // In accordance with https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00
-      // the SCSV cipher is added to signal that a protocol fallback has taken place.
-      final String fallbackScsv = "TLS_FALLBACK_SCSV";
-      boolean socketSupportsFallbackScsv =
-          Arrays.asList(sslSocket.getSupportedCipherSuites()).contains(fallbackScsv);
-
-      if (socketSupportsFallbackScsv) {
-        // Add the SCSV cipher to the set of enabled cipher suites iff it is supported.
-        String[] oldEnabledCipherSuites = cipherSuitesToEnable != null
-            ? cipherSuitesToEnable
-            : sslSocket.getEnabledCipherSuites();
-        String[] newEnabledCipherSuites = new String[oldEnabledCipherSuites.length + 1];
-        System.arraycopy(oldEnabledCipherSuites, 0,
-            newEnabledCipherSuites, 0, oldEnabledCipherSuites.length);
-        newEnabledCipherSuites[newEnabledCipherSuites.length - 1] = fallbackScsv;
-        cipherSuitesToEnable = newEnabledCipherSuites;
-      }
+    public List<TlsVersion> tlsVersions() {
+        TlsVersion[] result = new TlsVersion[tlsVersions.length];
+        for (int i = 0; i < tlsVersions.length; i++) {
+            result[i] = TlsVersion.forJavaName(tlsVersions[i]);
+        }
+        return Util.immutableList(result);
     }
 
-    String[] protocolsToSelectFrom = sslSocket.getEnabledProtocols();
-    String[] protocolsToEnable = Util.intersect(String.class, tlsVersions, protocolsToSelectFrom);
-    return new Builder(this)
-        .cipherSuites(cipherSuitesToEnable)
-        .tlsVersions(protocolsToEnable)
-        .build();
-  }
-
-  /**
-   * Returns {@code true} if the socket, as currently configured, supports this ConnectionSpec.
-   * In order for a socket to be compatible the enabled cipher suites and protocols must intersect.
-   *
-   * <p>For cipher suites, at least one of the {@link #cipherSuites() required cipher suites} must
-   * match the socket's enabled cipher suites. If there are no required cipher suites the socket
-   * must have at least one cipher suite enabled.
-   *
-   * <p>For protocols, at least one of the {@link #tlsVersions() required protocols} must match the
-   * socket's enabled protocols.
-   */
-  public boolean isCompatible(SSLSocket socket) {
-    if (!tls) {
-      return false;
+    public boolean supportsTlsExtensions() {
+        return supportsTlsExtensions;
     }
 
-    String[] enabledProtocols = socket.getEnabledProtocols();
-    boolean requiredProtocolsEnabled = nonEmptyIntersection(tlsVersions, enabledProtocols);
-    if (!requiredProtocolsEnabled) {
-      return false;
-    }
+    /**
+     * Applies this spec to {@code sslSocket}.
+     */
+    void apply(SSLSocket sslSocket, boolean isFallback) {
+        ConnectionSpec specToApply = supportedSpec(sslSocket, isFallback);
 
-    boolean requiredCiphersEnabled;
-    if (cipherSuites == null) {
-      requiredCiphersEnabled = socket.getEnabledCipherSuites().length > 0;
-    } else {
-      String[] enabledCipherSuites = socket.getEnabledCipherSuites();
-      requiredCiphersEnabled = nonEmptyIntersection(cipherSuites, enabledCipherSuites);
-    }
-    return requiredCiphersEnabled;
-  }
-
-  /**
-   * An N*M intersection that terminates if any intersection is found. The sizes of both
-   * arguments are assumed to be so small, and the likelihood of an intersection so great, that it
-   * is not worth the CPU cost of sorting or the memory cost of hashing.
-   */
-  private static boolean nonEmptyIntersection(String[] a, String[] b) {
-    if (a == null || b == null || a.length == 0 || b.length == 0) {
-      return false;
-    }
-    for (String toFind : a) {
-      if (contains(b, toFind)) {
-        return true;
-      }
-    }
-    return false;
-  }
+        sslSocket.setEnabledProtocols(specToApply.tlsVersions);
 
-  private static <T> boolean contains(T[] array, T value) {
-    for (T arrayValue : array) {
-      if (Util.equal(value, arrayValue)) {
-        return true;
-      }
+        String[] cipherSuitesToEnable = specToApply.cipherSuites;
+        // null means "use default set".
+        if (cipherSuitesToEnable != null) {
+            sslSocket.setEnabledCipherSuites(cipherSuitesToEnable);
+        }
     }
-    return false;
-  }
 
-  @Override public boolean equals(Object other) {
-    if (!(other instanceof ConnectionSpec)) return false;
-    if (other == this) return true;
-
-    ConnectionSpec that = (ConnectionSpec) other;
-    if (this.tls != that.tls) return false;
-
-    if (tls) {
-      if (!Arrays.equals(this.cipherSuites, that.cipherSuites)) return false;
-      if (!Arrays.equals(this.tlsVersions, that.tlsVersions)) return false;
-      if (this.supportsTlsExtensions != that.supportsTlsExtensions) return false;
-    }
-
-    return true;
-  }
-
-  @Override public int hashCode() {
-    int result = 17;
-    if (tls) {
-      result = 31 * result + Arrays.hashCode(cipherSuites);
-      result = 31 * result + Arrays.hashCode(tlsVersions);
-      result = 31 * result + (supportsTlsExtensions ? 0 : 1);
-    }
-    return result;
-  }
-
-  @Override public String toString() {
-    if (tls) {
-      List<CipherSuite> cipherSuites = cipherSuites();
-      String cipherSuitesString = cipherSuites == null ? "[use default]" : cipherSuites.toString();
-      return "ConnectionSpec(cipherSuites=" + cipherSuitesString
-          + ", tlsVersions=" + tlsVersions()
-          + ", supportsTlsExtensions=" + supportsTlsExtensions
-          + ")";
-    } else {
-      return "ConnectionSpec()";
+    /**
+     * Returns a copy of this that omits cipher suites and TLS versions not enabled by
+     * {@code sslSocket}.
+     */
+    private ConnectionSpec supportedSpec(SSLSocket sslSocket, boolean isFallback) {
+        String[] cipherSuitesToEnable = null;
+        if (cipherSuites != null) {
+            String[] cipherSuitesToSelectFrom = sslSocket.getEnabledCipherSuites();
+            cipherSuitesToEnable =
+                    Util.intersect(String.class, cipherSuites, cipherSuitesToSelectFrom);
+        }
+
+        if (isFallback) {
+            // In accordance with https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00
+            // the SCSV cipher is added to signal that a protocol fallback has taken place.
+            final String fallbackScsv = "TLS_FALLBACK_SCSV";
+            boolean socketSupportsFallbackScsv =
+                    Arrays.asList(sslSocket.getSupportedCipherSuites()).contains(fallbackScsv);
+
+            if (socketSupportsFallbackScsv) {
+                // Add the SCSV cipher to the set of enabled cipher suites iff it is supported.
+                String[] oldEnabledCipherSuites = cipherSuitesToEnable != null
+                        ? cipherSuitesToEnable
+                        : sslSocket.getEnabledCipherSuites();
+                String[] newEnabledCipherSuites = new String[oldEnabledCipherSuites.length + 1];
+                System.arraycopy(oldEnabledCipherSuites, 0,
+                        newEnabledCipherSuites, 0, oldEnabledCipherSuites.length);
+                newEnabledCipherSuites[newEnabledCipherSuites.length - 1] = fallbackScsv;
+                cipherSuitesToEnable = newEnabledCipherSuites;
+            }
+        }
+
+        String[] protocolsToSelectFrom = sslSocket.getEnabledProtocols();
+        String[] protocolsToEnable = Util.intersect(String.class, tlsVersions, protocolsToSelectFrom);
+        return new Builder(this)
+                .cipherSuites(cipherSuitesToEnable)
+                .tlsVersions(protocolsToEnable)
+                .build();
     }
-  }
 
-  public static final class Builder {
-    private boolean tls;
-    private String[] cipherSuites;
-    private String[] tlsVersions;
-    private boolean supportsTlsExtensions;
-
-    Builder(boolean tls) {
-      this.tls = tls;
+    /**
+     * Returns {@code true} if the socket, as currently configured, supports this ConnectionSpec.
+     * In order for a socket to be compatible the enabled cipher suites and protocols must intersect.
+     * <p/>
+     * <p>For cipher suites, at least one of the {@link #cipherSuites() required cipher suites} must
+     * match the socket's enabled cipher suites. If there are no required cipher suites the socket
+     * must have at least one cipher suite enabled.
+     * <p/>
+     * <p>For protocols, at least one of the {@link #tlsVersions() required protocols} must match the
+     * socket's enabled protocols.
+     */
+    public boolean isCompatible(SSLSocket socket) {
+        if (!tls) {
+            return false;
+        }
+
+        String[] enabledProtocols = socket.getEnabledProtocols();
+        boolean requiredProtocolsEnabled = nonEmptyIntersection(tlsVersions, enabledProtocols);
+        if (!requiredProtocolsEnabled) {
+            return false;
+        }
+
+        boolean requiredCiphersEnabled;
+        if (cipherSuites == null) {
+            requiredCiphersEnabled = socket.getEnabledCipherSuites().length > 0;
+        } else {
+            String[] enabledCipherSuites = socket.getEnabledCipherSuites();
+            requiredCiphersEnabled = nonEmptyIntersection(cipherSuites, enabledCipherSuites);
+        }
+        return requiredCiphersEnabled;
     }
 
-    public Builder(ConnectionSpec connectionSpec) {
-      this.tls = connectionSpec.tls;
-      this.cipherSuites = connectionSpec.cipherSuites;
-      this.tlsVersions = connectionSpec.tlsVersions;
-      this.supportsTlsExtensions = connectionSpec.supportsTlsExtensions;
+    /**
+     * An N*M intersection that terminates if any intersection is found. The sizes of both
+     * arguments are assumed to be so small, and the likelihood of an intersection so great, that it
+     * is not worth the CPU cost of sorting or the memory cost of hashing.
+     */
+    private static boolean nonEmptyIntersection(String[] a, String[] b) {
+        if (a == null || b == null || a.length == 0 || b.length == 0) {
+            return false;
+        }
+        for (String toFind : a) {
+            if (contains(b, toFind)) {
+                return true;
+            }
+        }
+        return false;
     }
 
-    public Builder cipherSuites(CipherSuite... cipherSuites) {
-      if (!tls) throw new IllegalStateException("no cipher suites for cleartext connections");
-
-      // Convert enums to the string names Java wants. This makes a defensive copy!
-      String[] strings = new String[cipherSuites.length];
-      for (int i = 0; i < cipherSuites.length; i++) {
-        strings[i] = cipherSuites[i].javaName;
-      }
-      this.cipherSuites = strings;
-      return this;
+    private static <T> boolean contains(T[] array, T value) {
+        for (T arrayValue : array) {
+            if (Util.equal(value, arrayValue)) {
+                return true;
+            }
+        }
+        return false;
     }
 
-    public Builder cipherSuites(String... cipherSuites) {
-      if (!tls) throw new IllegalStateException("no cipher suites for cleartext connections");
+    @Override
+    public boolean equals(Object other) {
+        if (!(other instanceof ConnectionSpec)) return false;
+        if (other == this) return true;
 
-      if (cipherSuites == null) {
-        this.cipherSuites = null;
-      } else {
-        // This makes a defensive copy!
-        this.cipherSuites = cipherSuites.clone();
-      }
+        ConnectionSpec that = (ConnectionSpec) other;
+        if (this.tls != that.tls) return false;
 
-      return this;
-    }
+        if (tls) {
+            if (!Arrays.equals(this.cipherSuites, that.cipherSuites)) return false;
+            if (!Arrays.equals(this.tlsVersions, that.tlsVersions)) return false;
+            if (this.supportsTlsExtensions != that.supportsTlsExtensions) return false;
+        }
 
-    public Builder tlsVersions(TlsVersion... tlsVersions) {
-      if (!tls) throw new IllegalStateException("no TLS versions for cleartext connections");
-      if (tlsVersions.length == 0) {
-        throw new IllegalArgumentException("At least one TlsVersion is required");
-      }
-
-      // Convert enums to the string names Java wants. This makes a defensive copy!
-      String[] strings = new String[tlsVersions.length];
-      for (int i = 0; i < tlsVersions.length; i++) {
-        strings[i] = tlsVersions[i].javaName;
-      }
-      this.tlsVersions = strings;
-      return this;
+        return true;
     }
 
-    public Builder tlsVersions(String... tlsVersions) {
-      if (!tls) throw new IllegalStateException("no TLS versions for cleartext connections");
-
-      if (tlsVersions == null) {
-        this.tlsVersions = null;
-      } else {
-        // This makes a defensive copy!
-        this.tlsVersions = tlsVersions.clone();
-      }
-
-      return this;
+    @Override
+    public int hashCode() {
+        int result = 17;
+        if (tls) {
+            result = 31 * result + Arrays.hashCode(cipherSuites);
+            result = 31 * result + Arrays.hashCode(tlsVersions);
+            result = 31 * result + (supportsTlsExtensions ? 0 : 1);
+        }
+        return result;
     }
 
-    public Builder supportsTlsExtensions(boolean supportsTlsExtensions) {
-      if (!tls) throw new IllegalStateException("no TLS extensions for cleartext connections");
-      this.supportsTlsExtensions = supportsTlsExtensions;
-      return this;
+    @Override
+    public String toString() {
+        if (tls) {
+            List<CipherSuite> cipherSuites = cipherSuites();
+            String cipherSuitesString = cipherSuites == null ? "[use default]" : cipherSuites.toString();
+            return "ConnectionSpec(cipherSuites=" + cipherSuitesString
+                    + ", tlsVersions=" + tlsVersions()
+                    + ", supportsTlsExtensions=" + supportsTlsExtensions
+                    + ")";
+        } else {
+            return "ConnectionSpec()";
+        }
     }
 
-    public ConnectionSpec build() {
-      return new ConnectionSpec(this);
+    public static final class Builder {
+        private boolean tls;
+        private String[] cipherSuites;
+        private String[] tlsVersions;
+        private boolean supportsTlsExtensions;
+
+        Builder(boolean tls) {
+            this.tls = tls;
+        }
+
+        public Builder(ConnectionSpec connectionSpec) {
+            this.tls = connectionSpec.tls;
+            this.cipherSuites = connectionSpec.cipherSuites;
+            this.tlsVersions = connectionSpec.tlsVersions;
+            this.supportsTlsExtensions = connectionSpec.supportsTlsExtensions;
+        }
+
+        public Builder cipherSuites(CipherSuite... cipherSuites) {
+            if (!tls) throw new IllegalStateException("no cipher suites for cleartext connections");
+
+            // Convert enums to the string names Java wants. This makes a defensive copy!
+            String[] strings = new String[cipherSuites.length];
+            for (int i = 0; i < cipherSuites.length; i++) {
+                strings[i] = cipherSuites[i].javaName;
+            }
+            this.cipherSuites = strings;
+            return this;
+        }
+
+        public Builder cipherSuites(String... cipherSuites) {
+            if (!tls) throw new IllegalStateException("no cipher suites for cleartext connections");
+
+            if (cipherSuites == null) {
+                this.cipherSuites = null;
+            } else {
+                // This makes a defensive copy!
+                this.cipherSuites = cipherSuites.clone();
+            }
+
+            return this;
+        }
+
+        public Builder tlsVersions(TlsVersion... tlsVersions) {
+            if (!tls) throw new IllegalStateException("no TLS versions for cleartext connections");
+            if (tlsVersions.length == 0) {
+                throw new IllegalArgumentException("At least one TlsVersion is required");
+            }
+
+            // Convert enums to the string names Java wants. This makes a defensive copy!
+            String[] strings = new String[tlsVersions.length];
+            for (int i = 0; i < tlsVersions.length; i++) {
+                strings[i] = tlsVersions[i].javaName;
+            }
+            this.tlsVersions = strings;
+            return this;
+        }
+
+        public Builder tlsVersions(String... tlsVersions) {
+            if (!tls) throw new IllegalStateException("no TLS versions for cleartext connections");
+
+            if (tlsVersions == null) {
+                this.tlsVersions = null;
+            } else {
+                // This makes a defensive copy!
+                this.tlsVersions = tlsVersions.clone();
+            }
+
+            return this;
+        }
+
+        public Builder supportsTlsExtensions(boolean supportsTlsExtensions) {
+            if (!tls)
+                throw new IllegalStateException("no TLS extensions for cleartext connections");
+            this.supportsTlsExtensions = supportsTlsExtensions;
+            return this;
+        }
+
+        public ConnectionSpec build() {
+            return new ConnectionSpec(this);
+        }
     }
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Credentials.java b/okhttp/src/main/java/com/squareup/okhttp/Credentials.java
index 92c128f568..6b8ee161bb 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Credentials.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Credentials.java
@@ -16,22 +16,27 @@
 package com.squareup.okhttp;
 
 import java.io.UnsupportedEncodingException;
+
 import okio.ByteString;
 
-/** Factory for HTTP authorization credentials. */
+/**
+ * Factory for HTTP authorization credentials.
+ */
 public final class Credentials {
-  private Credentials() {
-  }
+    private Credentials() {
+    }
 
-  /** Returns an auth credential for the Basic scheme. */
-  public static String basic(String userName, String password) {
-    try {
-      String usernameAndPassword = userName + ":" + password;
-      byte[] bytes = usernameAndPassword.getBytes("ISO-8859-1");
-      String encoded = ByteString.of(bytes).base64();
-      return "Basic " + encoded;
-    } catch (UnsupportedEncodingException e) {
-      throw new AssertionError();
+    /**
+     * Returns an auth credential for the Basic scheme.
+     */
+    public static String basic(String userName, String password) {
+        try {
+            String usernameAndPassword = userName + ":" + password;
+            byte[] bytes = usernameAndPassword.getBytes("ISO-8859-1");
+            String encoded = ByteString.of(bytes).base64();
+            return "Basic " + encoded;
+        } catch (UnsupportedEncodingException e) {
+            throw new AssertionError();
+        }
     }
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
index a9346701fb..312aeb4591 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
@@ -18,6 +18,7 @@
 import com.squareup.okhttp.Call.AsyncCall;
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.http.HttpEngine;
+
 import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.Iterator;
@@ -28,161 +29,179 @@
 
 /**
  * Policy on when async requests are executed.
- *
+ * <p/>
  * <p>Each dispatcher uses an {@link ExecutorService} to run calls internally. If you
  * supply your own executor, it should be able to run {@linkplain #getMaxRequests the
  * configured maximum} number of calls concurrently.
  */
 public final class Dispatcher {
-  private int maxRequests = 64;
-  private int maxRequestsPerHost = 5;
-
-  /** Executes calls. Created lazily. */
-  private ExecutorService executorService;
-
-  /** Ready calls in the order they'll be run. */
-  private final Deque<AsyncCall> readyCalls = new ArrayDeque<>();
-
-  /** Running calls. Includes canceled calls that haven't finished yet. */
-  private final Deque<AsyncCall> runningCalls = new ArrayDeque<>();
-
-  /** In-flight synchronous calls. Includes canceled calls that haven't finished yet. */
-  private final Deque<Call> executedCalls = new ArrayDeque<>();
-
-  public Dispatcher(ExecutorService executorService) {
-    this.executorService = executorService;
-  }
-
-  public Dispatcher() {
-  }
-
-  public synchronized ExecutorService getExecutorService() {
-    if (executorService == null) {
-      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,
-          new SynchronousQueue<Runnable>(), Util.threadFactory("OkHttp Dispatcher", false));
-    }
-    return executorService;
-  }
-
-  /**
-   * Set the maximum number of requests to execute concurrently. Above this
-   * requests queue in memory, waiting for the running calls to complete.
-   *
-   * <p>If more than {@code maxRequests} requests are in flight when this is
-   * invoked, those requests will remain in flight.
-   */
-  public synchronized void setMaxRequests(int maxRequests) {
-    if (maxRequests < 1) {
-      throw new IllegalArgumentException("max < 1: " + maxRequests);
-    }
-    this.maxRequests = maxRequests;
-    promoteCalls();
-  }
-
-  public synchronized int getMaxRequests() {
-    return maxRequests;
-  }
-
-  /**
-   * Set the maximum number of requests for each host to execute concurrently.
-   * This limits requests by the URL's host name. Note that concurrent requests
-   * to a single IP address may still exceed this limit: multiple hostnames may
-   * share an IP address or be routed through the same HTTP proxy.
-   *
-   * <p>If more than {@code maxRequestsPerHost} requests are in flight when this
-   * is invoked, those requests will remain in flight.
-   */
-  public synchronized void setMaxRequestsPerHost(int maxRequestsPerHost) {
-    if (maxRequestsPerHost < 1) {
-      throw new IllegalArgumentException("max < 1: " + maxRequestsPerHost);
-    }
-    this.maxRequestsPerHost = maxRequestsPerHost;
-    promoteCalls();
-  }
-
-  public synchronized int getMaxRequestsPerHost() {
-    return maxRequestsPerHost;
-  }
-
-  synchronized void enqueue(AsyncCall call) {
-    if (runningCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {
-      runningCalls.add(call);
-      getExecutorService().execute(call);
-    } else {
-      readyCalls.add(call);
-    }
-  }
-
-  /** Cancel all calls with the tag {@code tag}. */
-  public synchronized void cancel(Object tag) {
-    for (AsyncCall call : readyCalls) {
-      if (Util.equal(tag, call.tag())) {
-        call.cancel();
-      }
-    }
-
-    for (AsyncCall call : runningCalls) {
-      if (Util.equal(tag, call.tag())) {
-        call.get().canceled = true;
-        HttpEngine engine = call.get().engine;
-        if (engine != null) engine.disconnect();
-      }
-    }
-
-    for (Call call : executedCalls) {
-      if (Util.equal(tag, call.tag())) {
-        call.cancel();
-      }
-    }
-  }
-
-  /** Used by {@code AsyncCall#run} to signal completion. */
-  synchronized void finished(AsyncCall call) {
-    if (!runningCalls.remove(call)) throw new AssertionError("AsyncCall wasn't running!");
-    promoteCalls();
-  }
-
-  private void promoteCalls() {
-    if (runningCalls.size() >= maxRequests) return; // Already running max capacity.
-    if (readyCalls.isEmpty()) return; // No ready calls to promote.
-
-    for (Iterator<AsyncCall> i = readyCalls.iterator(); i.hasNext(); ) {
-      AsyncCall call = i.next();
-
-      if (runningCallsForHost(call) < maxRequestsPerHost) {
-        i.remove();
-        runningCalls.add(call);
-        getExecutorService().execute(call);
-      }
-
-      if (runningCalls.size() >= maxRequests) return; // Reached max capacity.
-    }
-  }
-
-  /** Returns the number of running calls that share a host with {@code call}. */
-  private int runningCallsForHost(AsyncCall call) {
-    int result = 0;
-    for (AsyncCall c : runningCalls) {
-      if (c.host().equals(call.host())) result++;
-    }
-    return result;
-  }
-
-  /** Used by {@code Call#execute} to signal it is in-flight. */
-  synchronized void executed(Call call) {
-    executedCalls.add(call);
-  }
-
-  /** Used by {@code Call#execute} to signal completion. */
-  synchronized void finished(Call call) {
-    if (!executedCalls.remove(call)) throw new AssertionError("Call wasn't in-flight!");
-  }
-
-  public synchronized int getRunningCallCount() {
-    return runningCalls.size();
-  }
-
-  public synchronized int getQueuedCallCount() {
-    return readyCalls.size();
-  }
+    private int maxRequests = 64;
+    private int maxRequestsPerHost = 5;
+
+    /**
+     * Executes calls. Created lazily.
+     */
+    private ExecutorService executorService;
+
+    /**
+     * Ready calls in the order they'll be run.
+     */
+    private final Deque<AsyncCall> readyCalls = new ArrayDeque<>();
+
+    /**
+     * Running calls. Includes canceled calls that haven't finished yet.
+     */
+    private final Deque<AsyncCall> runningCalls = new ArrayDeque<>();
+
+    /**
+     * In-flight synchronous calls. Includes canceled calls that haven't finished yet.
+     */
+    private final Deque<Call> executedCalls = new ArrayDeque<>();
+
+    public Dispatcher(ExecutorService executorService) {
+        this.executorService = executorService;
+    }
+
+    public Dispatcher() {
+    }
+
+    public synchronized ExecutorService getExecutorService() {
+        if (executorService == null) {
+            executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,
+                    new SynchronousQueue<Runnable>(), Util.threadFactory("OkHttp Dispatcher", false));
+        }
+        return executorService;
+    }
+
+    /**
+     * Set the maximum number of requests to execute concurrently. Above this
+     * requests queue in memory, waiting for the running calls to complete.
+     * <p/>
+     * <p>If more than {@code maxRequests} requests are in flight when this is
+     * invoked, those requests will remain in flight.
+     */
+    public synchronized void setMaxRequests(int maxRequests) {
+        if (maxRequests < 1) {
+            throw new IllegalArgumentException("max < 1: " + maxRequests);
+        }
+        this.maxRequests = maxRequests;
+        promoteCalls();
+    }
+
+    public synchronized int getMaxRequests() {
+        return maxRequests;
+    }
+
+    /**
+     * Set the maximum number of requests for each host to execute concurrently.
+     * This limits requests by the URL's host name. Note that concurrent requests
+     * to a single IP address may still exceed this limit: multiple hostnames may
+     * share an IP address or be routed through the same HTTP proxy.
+     * <p/>
+     * <p>If more than {@code maxRequestsPerHost} requests are in flight when this
+     * is invoked, those requests will remain in flight.
+     */
+    public synchronized void setMaxRequestsPerHost(int maxRequestsPerHost) {
+        if (maxRequestsPerHost < 1) {
+            throw new IllegalArgumentException("max < 1: " + maxRequestsPerHost);
+        }
+        this.maxRequestsPerHost = maxRequestsPerHost;
+        promoteCalls();
+    }
+
+    public synchronized int getMaxRequestsPerHost() {
+        return maxRequestsPerHost;
+    }
+
+    synchronized void enqueue(AsyncCall call) {
+        if (runningCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {
+            runningCalls.add(call);
+            getExecutorService().execute(call);
+        } else {
+            readyCalls.add(call);
+        }
+    }
+
+    /**
+     * Cancel all calls with the tag {@code tag}.
+     */
+    public synchronized void cancel(Object tag) {
+        for (AsyncCall call : readyCalls) {
+            if (Util.equal(tag, call.tag())) {
+                call.cancel();
+            }
+        }
+
+        for (AsyncCall call : runningCalls) {
+            if (Util.equal(tag, call.tag())) {
+                call.get().canceled = true;
+                HttpEngine engine = call.get().engine;
+                if (engine != null) engine.disconnect();
+            }
+        }
+
+        for (Call call : executedCalls) {
+            if (Util.equal(tag, call.tag())) {
+                call.cancel();
+            }
+        }
+    }
+
+    /**
+     * Used by {@code AsyncCall#run} to signal completion.
+     */
+    synchronized void finished(AsyncCall call) {
+        if (!runningCalls.remove(call)) throw new AssertionError("AsyncCall wasn't running!");
+        promoteCalls();
+    }
+
+    private void promoteCalls() {
+        if (runningCalls.size() >= maxRequests) return; // Already running max capacity.
+        if (readyCalls.isEmpty()) return; // No ready calls to promote.
+
+        for (Iterator<AsyncCall> i = readyCalls.iterator(); i.hasNext(); ) {
+            AsyncCall call = i.next();
+
+            if (runningCallsForHost(call) < maxRequestsPerHost) {
+                i.remove();
+                runningCalls.add(call);
+                getExecutorService().execute(call);
+            }
+
+            if (runningCalls.size() >= maxRequests) return; // Reached max capacity.
+        }
+    }
+
+    /**
+     * Returns the number of running calls that share a host with {@code call}.
+     */
+    private int runningCallsForHost(AsyncCall call) {
+        int result = 0;
+        for (AsyncCall c : runningCalls) {
+            if (c.host().equals(call.host())) result++;
+        }
+        return result;
+    }
+
+    /**
+     * Used by {@code Call#execute} to signal it is in-flight.
+     */
+    synchronized void executed(Call call) {
+        executedCalls.add(call);
+    }
+
+    /**
+     * Used by {@code Call#execute} to signal completion.
+     */
+    synchronized void finished(Call call) {
+        if (!executedCalls.remove(call)) throw new AssertionError("Call wasn't in-flight!");
+    }
+
+    public synchronized int getRunningCallCount() {
+        return runningCalls.size();
+    }
+
+    public synchronized int getQueuedCallCount() {
+        return readyCalls.size();
+    }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/FormEncodingBuilder.java b/okhttp/src/main/java/com/squareup/okhttp/FormEncodingBuilder.java
index 6f4b93c179..8c667bde28 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/FormEncodingBuilder.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/FormEncodingBuilder.java
@@ -22,38 +22,42 @@
  * 2.0</a>-compliant form data.
  */
 public final class FormEncodingBuilder {
-  private static final MediaType CONTENT_TYPE =
-      MediaType.parse("application/x-www-form-urlencoded");
+    private static final MediaType CONTENT_TYPE =
+            MediaType.parse("application/x-www-form-urlencoded");
 
-  private final Buffer content = new Buffer();
+    private final Buffer content = new Buffer();
 
-  /** Add new key-value pair. */
-  public FormEncodingBuilder add(String name, String value) {
-    if (content.size() > 0) {
-      content.writeByte('&');
+    /**
+     * Add new key-value pair.
+     */
+    public FormEncodingBuilder add(String name, String value) {
+        if (content.size() > 0) {
+            content.writeByte('&');
+        }
+        HttpUrl.canonicalize(content, name, 0, name.length(),
+                HttpUrl.FORM_ENCODE_SET, false, true);
+        content.writeByte('=');
+        HttpUrl.canonicalize(content, value, 0, value.length(),
+                HttpUrl.FORM_ENCODE_SET, false, true);
+        return this;
     }
-    HttpUrl.canonicalize(content, name, 0, name.length(),
-        HttpUrl.FORM_ENCODE_SET, false, true);
-    content.writeByte('=');
-    HttpUrl.canonicalize(content, value, 0, value.length(),
-        HttpUrl.FORM_ENCODE_SET, false, true);
-    return this;
-  }
 
-  /** Add new key-value pair. */
-  public FormEncodingBuilder addEncoded(String name, String value) {
-    if (content.size() > 0) {
-      content.writeByte('&');
+    /**
+     * Add new key-value pair.
+     */
+    public FormEncodingBuilder addEncoded(String name, String value) {
+        if (content.size() > 0) {
+            content.writeByte('&');
+        }
+        HttpUrl.canonicalize(content, name, 0, name.length(),
+                HttpUrl.FORM_ENCODE_SET, true, true);
+        content.writeByte('=');
+        HttpUrl.canonicalize(content, value, 0, value.length(),
+                HttpUrl.FORM_ENCODE_SET, true, true);
+        return this;
     }
-    HttpUrl.canonicalize(content, name, 0, name.length(),
-        HttpUrl.FORM_ENCODE_SET, true, true);
-    content.writeByte('=');
-    HttpUrl.canonicalize(content, value, 0, value.length(),
-        HttpUrl.FORM_ENCODE_SET, true, true);
-    return this;
-  }
 
-  public RequestBody build() {
-    return RequestBody.create(CONTENT_TYPE, content.snapshot());
-  }
+    public RequestBody build() {
+        return RequestBody.create(CONTENT_TYPE, content.snapshot());
+    }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Handshake.java b/okhttp/src/main/java/com/squareup/okhttp/Handshake.java
index d9f5366757..6643d7f630 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Handshake.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Handshake.java
@@ -17,104 +17,118 @@
 package com.squareup.okhttp;
 
 import com.squareup.okhttp.internal.Util;
+
 import java.security.Principal;
 import java.security.cert.Certificate;
 import java.security.cert.X509Certificate;
 import java.util.Collections;
 import java.util.List;
+
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSession;
 
 /**
  * A record of a TLS handshake. For HTTPS clients, the client is <i>local</i>
  * and the remote server is its <i>peer</i>.
- *
+ * <p/>
  * <p>This value object describes a completed handshake. Use {@link
  * javax.net.ssl.SSLSocketFactory} to set policy for new handshakes.
  */
 public final class Handshake {
-  private final String cipherSuite;
-  private final List<Certificate> peerCertificates;
-  private final List<Certificate> localCertificates;
-
-  private Handshake(
-      String cipherSuite, List<Certificate> peerCertificates, List<Certificate> localCertificates) {
-    this.cipherSuite = cipherSuite;
-    this.peerCertificates = peerCertificates;
-    this.localCertificates = localCertificates;
-  }
-
-  public static Handshake get(SSLSession session) {
-    String cipherSuite = session.getCipherSuite();
-    if (cipherSuite == null) throw new IllegalStateException("cipherSuite == null");
-
-    Certificate[] peerCertificates;
-    try {
-      peerCertificates = session.getPeerCertificates();
-    } catch (SSLPeerUnverifiedException ignored) {
-      peerCertificates = null;
+    private final String cipherSuite;
+    private final List<Certificate> peerCertificates;
+    private final List<Certificate> localCertificates;
+
+    private Handshake(
+            String cipherSuite, List<Certificate> peerCertificates, List<Certificate> localCertificates) {
+        this.cipherSuite = cipherSuite;
+        this.peerCertificates = peerCertificates;
+        this.localCertificates = localCertificates;
+    }
+
+    public static Handshake get(SSLSession session) {
+        String cipherSuite = session.getCipherSuite();
+        if (cipherSuite == null) throw new IllegalStateException("cipherSuite == null");
+
+        Certificate[] peerCertificates;
+        try {
+            peerCertificates = session.getPeerCertificates();
+        } catch (SSLPeerUnverifiedException ignored) {
+            peerCertificates = null;
+        }
+        List<Certificate> peerCertificatesList = peerCertificates != null
+                ? Util.immutableList(peerCertificates)
+                : Collections.<Certificate>emptyList();
+
+        Certificate[] localCertificates = session.getLocalCertificates();
+        List<Certificate> localCertificatesList = localCertificates != null
+                ? Util.immutableList(localCertificates)
+                : Collections.<Certificate>emptyList();
+
+        return new Handshake(cipherSuite, peerCertificatesList, localCertificatesList);
+    }
+
+    public static Handshake get(
+            String cipherSuite, List<Certificate> peerCertificates, List<Certificate> localCertificates) {
+        if (cipherSuite == null) throw new IllegalArgumentException("cipherSuite == null");
+        return new Handshake(cipherSuite, Util.immutableList(peerCertificates),
+                Util.immutableList(localCertificates));
+    }
+
+    /**
+     * Returns a cipher suite name like "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA".
+     */
+    public String cipherSuite() {
+        return cipherSuite;
+    }
+
+    /**
+     * Returns a possibly-empty list of certificates that identify the remote peer.
+     */
+    public List<Certificate> peerCertificates() {
+        return peerCertificates;
+    }
+
+    /**
+     * Returns the remote peer's principle, or null if that peer is anonymous.
+     */
+    public Principal peerPrincipal() {
+        return !peerCertificates.isEmpty()
+                ? ((X509Certificate) peerCertificates.get(0)).getSubjectX500Principal()
+                : null;
+    }
+
+    /**
+     * Returns a possibly-empty list of certificates that identify this peer.
+     */
+    public List<Certificate> localCertificates() {
+        return localCertificates;
+    }
+
+    /**
+     * Returns the local principle, or null if this peer is anonymous.
+     */
+    public Principal localPrincipal() {
+        return !localCertificates.isEmpty()
+                ? ((X509Certificate) localCertificates.get(0)).getSubjectX500Principal()
+                : null;
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (!(other instanceof Handshake)) return false;
+        Handshake that = (Handshake) other;
+        return cipherSuite.equals(that.cipherSuite)
+                && peerCertificates.equals(that.peerCertificates)
+                && localCertificates.equals(that.localCertificates);
+    }
+
+    @Override
+    public int hashCode() {
+        int result = 17;
+        result = 31 * result + cipherSuite.hashCode();
+        result = 31 * result + peerCertificates.hashCode();
+        result = 31 * result + localCertificates.hashCode();
+        return result;
     }
-    List<Certificate> peerCertificatesList = peerCertificates != null
-        ? Util.immutableList(peerCertificates)
-        : Collections.<Certificate>emptyList();
-
-    Certificate[] localCertificates = session.getLocalCertificates();
-    List<Certificate> localCertificatesList = localCertificates != null
-        ? Util.immutableList(localCertificates)
-        : Collections.<Certificate>emptyList();
-
-    return new Handshake(cipherSuite, peerCertificatesList, localCertificatesList);
-  }
-
-  public static Handshake get(
-      String cipherSuite, List<Certificate> peerCertificates, List<Certificate> localCertificates) {
-    if (cipherSuite == null) throw new IllegalArgumentException("cipherSuite == null");
-    return new Handshake(cipherSuite, Util.immutableList(peerCertificates),
-        Util.immutableList(localCertificates));
-  }
-
-  /** Returns a cipher suite name like "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA". */
-  public String cipherSuite() {
-    return cipherSuite;
-  }
-
-  /** Returns a possibly-empty list of certificates that identify the remote peer. */
-  public List<Certificate> peerCertificates() {
-    return peerCertificates;
-  }
-
-  /** Returns the remote peer's principle, or null if that peer is anonymous. */
-  public Principal peerPrincipal() {
-    return !peerCertificates.isEmpty()
-        ? ((X509Certificate) peerCertificates.get(0)).getSubjectX500Principal()
-        : null;
-  }
-
-  /** Returns a possibly-empty list of certificates that identify this peer. */
-  public List<Certificate> localCertificates() {
-    return localCertificates;
-  }
-
-  /** Returns the local principle, or null if this peer is anonymous. */
-  public Principal localPrincipal() {
-    return !localCertificates.isEmpty()
-        ? ((X509Certificate) localCertificates.get(0)).getSubjectX500Principal()
-        : null;
-  }
-
-  @Override public boolean equals(Object other) {
-    if (!(other instanceof Handshake)) return false;
-    Handshake that = (Handshake) other;
-    return cipherSuite.equals(that.cipherSuite)
-        && peerCertificates.equals(that.peerCertificates)
-        && localCertificates.equals(that.localCertificates);
-  }
-
-  @Override public int hashCode() {
-    int result = 17;
-    result = 31 * result + cipherSuite.hashCode();
-    result = 31 * result + peerCertificates.hashCode();
-    result = 31 * result + localCertificates.hashCode();
-    return result;
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Headers.java b/okhttp/src/main/java/com/squareup/okhttp/Headers.java
index 29d9dc82ca..3c7607f836 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Headers.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Headers.java
@@ -18,6 +18,7 @@
 package com.squareup.okhttp;
 
 import com.squareup.okhttp.internal.http.HttpDate;
+
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Date;
@@ -31,268 +32,288 @@
  * The header fields of a single HTTP message. Values are uninterpreted strings;
  * use {@code Request} and {@code Response} for interpreted headers. This class
  * maintains the order of the header fields within the HTTP message.
- *
+ * <p/>
  * <p>This class tracks header values line-by-line. A field with multiple comma-
  * separated values on the same line will be treated as a field with a single
  * value by this class. It is the caller's responsibility to detect and split
  * on commas if their field permits multiple values. This simplifies use of
  * single-valued fields whose values routinely contain commas, such as cookies
  * or dates.
- *
+ * <p/>
  * <p>This class trims whitespace from values. It never returns values with
  * leading or trailing whitespace.
- *
+ * <p/>
  * <p>Instances of this class are immutable. Use {@link Builder} to create
  * instances.
  */
 public final class Headers {
-  private final String[] namesAndValues;
-
-  private Headers(Builder builder) {
-    this.namesAndValues = builder.namesAndValues.toArray(new String[builder.namesAndValues.size()]);
-  }
-
-  private Headers(String[] namesAndValues) {
-    this.namesAndValues = namesAndValues;
-  }
-
-  /** Returns the last value corresponding to the specified field, or null. */
-  public String get(String name) {
-    return get(namesAndValues, name);
-  }
-
-  /**
-   * Returns the last value corresponding to the specified field parsed as an
-   * HTTP date, or null if either the field is absent or cannot be parsed as a
-   * date.
-   */
-  public Date getDate(String name) {
-    String value = get(name);
-    return value != null ? HttpDate.parse(value) : null;
-  }
-
-  /** Returns the number of field values. */
-  public int size() {
-    return namesAndValues.length / 2;
-  }
-
-  /** Returns the field at {@code position} or null if that is out of range. */
-  public String name(int index) {
-    int nameIndex = index * 2;
-    if (nameIndex < 0 || nameIndex >= namesAndValues.length) {
-      return null;
-    }
-    return namesAndValues[nameIndex];
-  }
-
-  /** Returns the value at {@code index} or null if that is out of range. */
-  public String value(int index) {
-    int valueIndex = index * 2 + 1;
-    if (valueIndex < 0 || valueIndex >= namesAndValues.length) {
-      return null;
-    }
-    return namesAndValues[valueIndex];
-  }
-
-  /** Returns an immutable case-insensitive set of header names. */
-  public Set<String> names() {
-    TreeSet<String> result = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
-    for (int i = 0, size = size(); i < size; i++) {
-      result.add(name(i));
-    }
-    return Collections.unmodifiableSet(result);
-  }
-
-  /** Returns an immutable list of the header values for {@code name}. */
-  public List<String> values(String name) {
-    List<String> result = null;
-    for (int i = 0, size = size(); i < size; i++) {
-      if (name.equalsIgnoreCase(name(i))) {
-        if (result == null) result = new ArrayList<>(2);
-        result.add(value(i));
-      }
-    }
-    return result != null
-        ? Collections.unmodifiableList(result)
-        : Collections.<String>emptyList();
-  }
-
-  public Builder newBuilder() {
-    Builder result = new Builder();
-    Collections.addAll(result.namesAndValues, namesAndValues);
-    return result;
-  }
-
-  @Override public String toString() {
-    StringBuilder result = new StringBuilder();
-    for (int i = 0, size = size(); i < size; i++) {
-      result.append(name(i)).append(": ").append(value(i)).append("\n");
-    }
-    return result.toString();
-  }
-
-  public Map<String, List<String>> toMultimap() {
-    Map<String, List<String>> result = new LinkedHashMap<String, List<String>>();
-    for (int i = 0, size = size(); i < size; i++) {
-      String name = name(i);
-      List<String> values = result.get(name);
-      if (values == null) {
-        values = new ArrayList<>(2);
-        result.put(name, values);
-      }
-      values.add(value(i));
-    }
-    return result;
-  }
-
-  private static String get(String[] namesAndValues, String name) {
-    for (int i = namesAndValues.length - 2; i >= 0; i -= 2) {
-      if (name.equalsIgnoreCase(namesAndValues[i])) {
-        return namesAndValues[i + 1];
-      }
-    }
-    return null;
-  }
-
-  /**
-   * Returns headers for the alternating header names and values. There must be
-   * an even number of arguments, and they must alternate between header names
-   * and values.
-   */
-  public static Headers of(String... namesAndValues) {
-    if (namesAndValues == null || namesAndValues.length % 2 != 0) {
-      throw new IllegalArgumentException("Expected alternating header names and values");
+    private final String[] namesAndValues;
+
+    private Headers(Builder builder) {
+        this.namesAndValues = builder.namesAndValues.toArray(new String[builder.namesAndValues.size()]);
     }
 
-    // Make a defensive copy and clean it up.
-    namesAndValues = namesAndValues.clone();
-    for (int i = 0; i < namesAndValues.length; i++) {
-      if (namesAndValues[i] == null) throw new IllegalArgumentException("Headers cannot be null");
-      namesAndValues[i] = namesAndValues[i].trim();
+    private Headers(String[] namesAndValues) {
+        this.namesAndValues = namesAndValues;
     }
 
-    // Check for malformed headers.
-    for (int i = 0; i < namesAndValues.length; i += 2) {
-      String name = namesAndValues[i];
-      String value = namesAndValues[i + 1];
-      if (name.length() == 0 || name.indexOf('\0') != -1 || value.indexOf('\0') != -1) {
-        throw new IllegalArgumentException("Unexpected header: " + name + ": " + value);
-      }
+    /**
+     * Returns the last value corresponding to the specified field, or null.
+     */
+    public String get(String name) {
+        return get(namesAndValues, name);
     }
 
-    return new Headers(namesAndValues);
-  }
+    /**
+     * Returns the last value corresponding to the specified field parsed as an
+     * HTTP date, or null if either the field is absent or cannot be parsed as a
+     * date.
+     */
+    public Date getDate(String name) {
+        String value = get(name);
+        return value != null ? HttpDate.parse(value) : null;
+    }
 
-  /**
-   * Returns headers for the header names and values in the {@link Map}.
-   */
-  public static Headers of(Map<String, String> headers) {
-    if (headers == null) {
-      throw new IllegalArgumentException("Expected map with header names and values");
+    /**
+     * Returns the number of field values.
+     */
+    public int size() {
+        return namesAndValues.length / 2;
     }
 
-    // Make a defensive copy and clean it up.
-    String[] namesAndValues = new String[headers.size() * 2];
-    int i = 0;
-    for (Map.Entry<String, String> header : headers.entrySet()) {
-      if (header.getKey() == null || header.getValue() == null) {
-        throw new IllegalArgumentException("Headers cannot be null");
-      }
-      String name = header.getKey().trim();
-      String value = header.getValue().trim();
-      if (name.length() == 0 || name.indexOf('\0') != -1 || value.indexOf('\0') != -1) {
-        throw new IllegalArgumentException("Unexpected header: " + name + ": " + value);
-      }
-      namesAndValues[i] = name;
-      namesAndValues[i + 1] = value;
-      i += 2;
+    /**
+     * Returns the field at {@code position} or null if that is out of range.
+     */
+    public String name(int index) {
+        int nameIndex = index * 2;
+        if (nameIndex < 0 || nameIndex >= namesAndValues.length) {
+            return null;
+        }
+        return namesAndValues[nameIndex];
     }
 
-    return new Headers(namesAndValues);
-  }
+    /**
+     * Returns the value at {@code index} or null if that is out of range.
+     */
+    public String value(int index) {
+        int valueIndex = index * 2 + 1;
+        if (valueIndex < 0 || valueIndex >= namesAndValues.length) {
+            return null;
+        }
+        return namesAndValues[valueIndex];
+    }
 
-  public static final class Builder {
-    private final List<String> namesAndValues = new ArrayList<>(20);
+    /**
+     * Returns an immutable case-insensitive set of header names.
+     */
+    public Set<String> names() {
+        TreeSet<String> result = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
+        for (int i = 0, size = size(); i < size; i++) {
+            result.add(name(i));
+        }
+        return Collections.unmodifiableSet(result);
+    }
 
     /**
-     * Add a header line without any validation. Only appropriate for headers from the remote peer
-     * or cache.
+     * Returns an immutable list of the header values for {@code name}.
      */
-    Builder addLenient(String line) {
-      int index = line.indexOf(":", 1);
-      if (index != -1) {
-        return addLenient(line.substring(0, index), line.substring(index + 1));
-      } else if (line.startsWith(":")) {
-        // Work around empty header names and header names that start with a
-        // colon (created by old broken SPDY versions of the response cache).
-        return addLenient("", line.substring(1)); // Empty header name.
-      } else {
-        return addLenient("", line); // No header name.
-      }
+    public List<String> values(String name) {
+        List<String> result = null;
+        for (int i = 0, size = size(); i < size; i++) {
+            if (name.equalsIgnoreCase(name(i))) {
+                if (result == null) result = new ArrayList<>(2);
+                result.add(value(i));
+            }
+        }
+        return result != null
+                ? Collections.unmodifiableList(result)
+                : Collections.<String>emptyList();
     }
 
-    /** Add an header line containing a field name, a literal colon, and a value. */
-    public Builder add(String line) {
-      int index = line.indexOf(":");
-      if (index == -1) {
-        throw new IllegalArgumentException("Unexpected header: " + line);
-      }
-      return add(line.substring(0, index).trim(), line.substring(index + 1));
+    public Builder newBuilder() {
+        Builder result = new Builder();
+        Collections.addAll(result.namesAndValues, namesAndValues);
+        return result;
     }
 
-    /** Add a field with the specified value. */
-    public Builder add(String name, String value) {
-      if (name == null) throw new IllegalArgumentException("name == null");
-      if (value == null) throw new IllegalArgumentException("value == null");
-      if (name.length() == 0 || name.indexOf('\0') != -1 || value.indexOf('\0') != -1) {
-        throw new IllegalArgumentException("Unexpected header: " + name + ": " + value);
-      }
-      return addLenient(name, value);
+    @Override
+    public String toString() {
+        StringBuilder result = new StringBuilder();
+        for (int i = 0, size = size(); i < size; i++) {
+            result.append(name(i)).append(": ").append(value(i)).append("\n");
+        }
+        return result.toString();
     }
 
-    /**
-     * Add a field with the specified value without any validation. Only
-     * appropriate for headers from the remote peer or cache.
-     */
-    Builder addLenient(String name, String value) {
-      namesAndValues.add(name);
-      namesAndValues.add(value.trim());
-      return this;
+    public Map<String, List<String>> toMultimap() {
+        Map<String, List<String>> result = new LinkedHashMap<String, List<String>>();
+        for (int i = 0, size = size(); i < size; i++) {
+            String name = name(i);
+            List<String> values = result.get(name);
+            if (values == null) {
+                values = new ArrayList<>(2);
+                result.put(name, values);
+            }
+            values.add(value(i));
+        }
+        return result;
     }
 
-    public Builder removeAll(String name) {
-      for (int i = 0; i < namesAndValues.size(); i += 2) {
-        if (name.equalsIgnoreCase(namesAndValues.get(i))) {
-          namesAndValues.remove(i); // name
-          namesAndValues.remove(i); // value
-          i -= 2;
+    private static String get(String[] namesAndValues, String name) {
+        for (int i = namesAndValues.length - 2; i >= 0; i -= 2) {
+            if (name.equalsIgnoreCase(namesAndValues[i])) {
+                return namesAndValues[i + 1];
+            }
         }
-      }
-      return this;
+        return null;
     }
 
     /**
-     * Set a field with the specified value. If the field is not found, it is
-     * added. If the field is found, the existing values are replaced.
+     * Returns headers for the alternating header names and values. There must be
+     * an even number of arguments, and they must alternate between header names
+     * and values.
      */
-    public Builder set(String name, String value) {
-      removeAll(name);
-      add(name, value);
-      return this;
+    public static Headers of(String... namesAndValues) {
+        if (namesAndValues == null || namesAndValues.length % 2 != 0) {
+            throw new IllegalArgumentException("Expected alternating header names and values");
+        }
+
+        // Make a defensive copy and clean it up.
+        namesAndValues = namesAndValues.clone();
+        for (int i = 0; i < namesAndValues.length; i++) {
+            if (namesAndValues[i] == null)
+                throw new IllegalArgumentException("Headers cannot be null");
+            namesAndValues[i] = namesAndValues[i].trim();
+        }
+
+        // Check for malformed headers.
+        for (int i = 0; i < namesAndValues.length; i += 2) {
+            String name = namesAndValues[i];
+            String value = namesAndValues[i + 1];
+            if (name.length() == 0 || name.indexOf('\0') != -1 || value.indexOf('\0') != -1) {
+                throw new IllegalArgumentException("Unexpected header: " + name + ": " + value);
+            }
+        }
+
+        return new Headers(namesAndValues);
     }
 
-    /** Equivalent to {@code build().get(name)}, but potentially faster. */
-    public String get(String name) {
-      for (int i = namesAndValues.size() - 2; i >= 0; i -= 2) {
-        if (name.equalsIgnoreCase(namesAndValues.get(i))) {
-          return namesAndValues.get(i + 1);
+    /**
+     * Returns headers for the header names and values in the {@link Map}.
+     */
+    public static Headers of(Map<String, String> headers) {
+        if (headers == null) {
+            throw new IllegalArgumentException("Expected map with header names and values");
+        }
+
+        // Make a defensive copy and clean it up.
+        String[] namesAndValues = new String[headers.size() * 2];
+        int i = 0;
+        for (Map.Entry<String, String> header : headers.entrySet()) {
+            if (header.getKey() == null || header.getValue() == null) {
+                throw new IllegalArgumentException("Headers cannot be null");
+            }
+            String name = header.getKey().trim();
+            String value = header.getValue().trim();
+            if (name.length() == 0 || name.indexOf('\0') != -1 || value.indexOf('\0') != -1) {
+                throw new IllegalArgumentException("Unexpected header: " + name + ": " + value);
+            }
+            namesAndValues[i] = name;
+            namesAndValues[i + 1] = value;
+            i += 2;
         }
-      }
-      return null;
+
+        return new Headers(namesAndValues);
     }
 
-    public Headers build() {
-      return new Headers(this);
+    public static final class Builder {
+        private final List<String> namesAndValues = new ArrayList<>(20);
+
+        /**
+         * Add a header line without any validation. Only appropriate for headers from the remote peer
+         * or cache.
+         */
+        Builder addLenient(String line) {
+            int index = line.indexOf(":", 1);
+            if (index != -1) {
+                return addLenient(line.substring(0, index), line.substring(index + 1));
+            } else if (line.startsWith(":")) {
+                // Work around empty header names and header names that start with a
+                // colon (created by old broken SPDY versions of the response cache).
+                return addLenient("", line.substring(1)); // Empty header name.
+            } else {
+                return addLenient("", line); // No header name.
+            }
+        }
+
+        /**
+         * Add an header line containing a field name, a literal colon, and a value.
+         */
+        public Builder add(String line) {
+            int index = line.indexOf(":");
+            if (index == -1) {
+                throw new IllegalArgumentException("Unexpected header: " + line);
+            }
+            return add(line.substring(0, index).trim(), line.substring(index + 1));
+        }
+
+        /**
+         * Add a field with the specified value.
+         */
+        public Builder add(String name, String value) {
+            if (name == null) throw new IllegalArgumentException("name == null");
+            if (value == null) throw new IllegalArgumentException("value == null");
+            if (name.length() == 0 || name.indexOf('\0') != -1 || value.indexOf('\0') != -1) {
+                throw new IllegalArgumentException("Unexpected header: " + name + ": " + value);
+            }
+            return addLenient(name, value);
+        }
+
+        /**
+         * Add a field with the specified value without any validation. Only
+         * appropriate for headers from the remote peer or cache.
+         */
+        Builder addLenient(String name, String value) {
+            namesAndValues.add(name);
+            namesAndValues.add(value.trim());
+            return this;
+        }
+
+        public Builder removeAll(String name) {
+            for (int i = 0; i < namesAndValues.size(); i += 2) {
+                if (name.equalsIgnoreCase(namesAndValues.get(i))) {
+                    namesAndValues.remove(i); // name
+                    namesAndValues.remove(i); // value
+                    i -= 2;
+                }
+            }
+            return this;
+        }
+
+        /**
+         * Set a field with the specified value. If the field is not found, it is
+         * added. If the field is found, the existing values are replaced.
+         */
+        public Builder set(String name, String value) {
+            removeAll(name);
+            add(name, value);
+            return this;
+        }
+
+        /**
+         * Equivalent to {@code build().get(name)}, but potentially faster.
+         */
+        public String get(String name) {
+            for (int i = namesAndValues.size() - 2; i >= 0; i -= 2) {
+                if (name.equalsIgnoreCase(namesAndValues.get(i))) {
+                    return namesAndValues.get(i + 1);
+                }
+            }
+            return null;
+        }
+
+        public Headers build() {
+            return new Headers(this);
+        }
     }
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/HttpUrl.java b/okhttp/src/main/java/com/squareup/okhttp/HttpUrl.java
index 2440ea8b95..2ee2718cd4 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/HttpUrl.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/HttpUrl.java
@@ -29,13 +29,14 @@
 import java.util.List;
 import java.util.Locale;
 import java.util.Set;
+
 import okio.Buffer;
 
 /**
  * A uniform resource locator (URL) with a scheme of either {@code http} or {@code https}. Use this
  * class to compose and decompose Internet addresses. For example, this code will compose and print
  * a URL for Google search: <pre>   {@code
- *
+ * <p/>
  *   HttpUrl url = new HttpUrl.Builder()
  *       .scheme("https")
  *       .host("www.google.com")
@@ -44,106 +45,106 @@
  *       .build();
  *   System.out.println(url);
  * }</pre>
- *
+ * <p/>
  * which prints: <pre>   {@code
- *
+ * <p/>
  *     https://www.google.com/search?q=polar%20bears
  * }</pre>
- *
+ * <p/>
  * As another example, this code prints the human-readable query parameters of a Twitter search:
  * <pre>   {@code
- *
+ * <p/>
  *   HttpUrl url = HttpUrl.parse("https://twitter.com/search?q=cute%20%23puppies&f=images");
  *   for (int i = 0, size = url.querySize(); i < size; i++) {
  *     System.out.println(url.queryParameterName(i) + ": " + url.queryParameterValue(i));
  *   }
  * }</pre>
- *
+ * <p/>
  * which prints: <pre>   {@code
- *
+ * <p/>
  *   q: cute #puppies
  *   f: images
  * }</pre>
- *
+ * <p/>
  * In addition to composing URLs from their component parts and decomposing URLs into their
  * component parts, this class implements relative URL resolution: what address you'd reach by
  * clicking a relative link on a specified page. For example: <pre>   {@code
- *
+ * <p/>
  *   HttpUrl base = HttpUrl.parse("https://www.youtube.com/user/WatchTheDaily/videos");
  *   HttpUrl link = base.resolve("../../watch?v=cbP2N1BQdYc");
  *   System.out.println(link);
  * }</pre>
- *
+ * <p/>
  * which prints: <pre>   {@code
- *
+ * <p/>
  *   https://www.youtube.com/watch?v=cbP2N1BQdYc
  * }</pre>
- *
+ * <p/>
  * <h3>What's in a URL?</h3>
- *
+ * <p/>
  * A URL has several components.
- *
+ * <p/>
  * <h4>Scheme</h4>
  * Sometimes referred to as <i>protocol</i>, A URL's scheme describes what mechanism should be used
  * to retrieve the resource. Although URLs have many schemes ({@code mailto}, {@code file}, {@code
  * ftp}), this class only supports {@code http} and {@code https}. Use {@link URI java.net.URI} for
  * URLs with arbitrary schemes.
- *
+ * <p/>
  * <h4>Username and Password</h4>
  * Username and password are either present, or the empty string {@code ""} if absent. This class
  * offers no mechanism to differentiate empty from absent. Neither of these components are popular
  * in practice. Typically HTTP applications use other mechanisms for user identification and
  * authentication.
- *
+ * <p/>
  * <h4>Host</h4>
  * The host identifies the webserver that serves the URL's resource. It is either a hostname like
  * {@code square.com} or {@code localhost}, an IPv4 address like {@code 192.168.0.1}, or an IPv6
  * address like {@code ::1}.
- *
+ * <p/>
  * <p>Usually a webserver is reachable with multiple identifiers: its IP addresses, registered
  * domain names, and even {@code localhost} when connecting from the server itself. Each of a
  * webserver's names is a distinct URL and they are not interchangeable. For example, even if
  * {@code http://square.github.io/dagger} and {@code http://google.github.io/dagger} are served by
  * the same IP address, the two URLs identify different resources.
- *
+ * <p/>
  * <h4>Port</h4>
  * The port used to connect to the webserver. By default this is 80 for HTTP and 443 for HTTPS. This
  * class never returns -1 for the port: if no port is explicitly specified in the URL then the
  * scheme's default is used.
- *
+ * <p/>
  * <h4>Path</h4>
  * The path identifies a specific resource on the host. Paths have a hierarchical structure like
  * "/square/okhttp/issues/1486". Each path segment is prefixed with "/". This class offers methods
  * to compose and decompose paths by segment. If a path's last segment is the empty string, then the
  * path ends with "/". This class always builds non-empty paths: if the path is omitted it defaults
  * to "/", which is a path whose only segment is the empty string.
- *
+ * <p/>
  * <h4>Query</h4>
  * The query is optional: it can be null, empty, or non-empty. For many HTTP URLs the query string
  * is subdivided into a collection of name-value parameters. This class offers methods to set the
  * query as the single string, or as individual name-value parameters. With name-value parameters
  * the values are optional and names may be repeated.
- *
+ * <p/>
  * <h4>Fragment</h4>
  * The fragment is optional: it can be null, empty, or non-empty. Unlike host, port, path, and query
  * the fragment is not sent to the webserver: it's private to the client.
- *
+ * <p/>
  * <h3>Encoding</h3>
  * Each component must be encoded before it is embedded in the complete URL. As we saw above, the
  * string {@code cute #puppies} is encoded as {@code cute%20%23puppies} when used as a query
  * parameter value.
- *
+ * <p/>
  * <h4>Percent encoding</h4>
  * Percent encoding replaces a character (like {@code \ud83c\udf69}) with its UTF-8 hex bytes (like
  * {@code %F0%9F%8D%A9}). This approach works for whitespace characters, control characters,
  * non-ASCII characters, and characters that already have another meaning in a particular context.
- *
+ * <p/>
  * <p>Percent encoding is used in every URL component except for the hostname. But the set of
  * characters that need to be encoded is different for each component. For example, the path
  * component must escape all of its {@code ?} characters, otherwise it could be interpreted as the
  * start of the URL's query. But within the query and fragment components, the {@code ?} character
  * doesn't delimit anything and doesn't need to be escaped. <pre>   {@code
- *
+ * <p/>
  *   HttpUrl url = HttpUrl.parse("http://who-let-the-dogs.out").newBuilder()
  *       .addPathSegment("_Who?_")
  *       .query("_Who?_")
@@ -151,19 +152,19 @@
  *       .build();
  *   System.out.println(url);
  * }</pre>
- *
+ * <p/>
  * This prints: <pre>   {@code
- *
+ * <p/>
  *   http://who-let-the-dogs.out/_Who%3F_?_Who?_#_Who?_
  * }</pre>
- *
+ * <p/>
  * When parsing URLs that lack percent encoding where it is required, this class will percent encode
  * the offending characters.
- *
+ * <p/>
  * <h4>IDNA Mapping and Punycode encoding</h4>
  * Hostnames have different requirements and use a different encoding scheme. It consists of IDNA
  * mapping and Punycode encoding.
- *
+ * <p/>
  * <p>In order to avoid confusion and discourage phishing attacks,
  * <a href="http://www.unicode.org/reports/tr46/#ToASCII">IDNA Mapping</a> transforms names to avoid
  * confusing characters. This includes basic case folding: transforming shouting {@code SQUARE.COM}
@@ -172,1304 +173,1356 @@
  * To mitigate this, the single character (™) maps to the string (tm). There is similar policy for
  * all of the 1.1 million Unicode code points. Note that some code points such as "\ud83c\udf69" are
  * not mapped and cannot be used in a hostname.
- *
+ * <p/>
  * <p><a href="http://ietf.org/rfc/rfc3492.txt">Punycode</a> converts a Unicode string to an ASCII
  * string to make international domain names work everywhere. For example, "σ" encodes as
  * "xn--4xa". The encoded string is not human readable, but can be used with classes like {@link
  * InetAddress} to establish connections.
- *
+ * <p/>
  * <h3>Why another URL model?</h3>
  * Java includes both {@link URL java.net.URL} and {@link URI java.net.URI}. We offer a new URL
  * model to address problems that the others don't.
- *
+ * <p/>
  * <h4>Different URLs should be different</h4>
  * Although they have different content, {@code java.net.URL} considers the following two URLs
  * equal, and the {@link Object#equals equals()} method between them returns true:
  * <ul>
- *   <li>http://square.github.io/
- *   <li>http://google.github.io/
+ * <li>http://square.github.io/
+ * <li>http://google.github.io/
  * </ul>
  * This is because those two hosts share the same IP address. This is an old, bad design decision
  * that makes {@code java.net.URL} unusable for many things. It shouldn't be used as a {@link
  * java.util.Map Map} key or in a {@link Set}. Doing so is both inefficient because equality may
  * require a DNS lookup, and incorrect because unequal URLs may be equal because of how they are
  * hosted.
- *
+ * <p/>
  * <h4>Equal URLs should be equal</h4>
  * These two URLs are semantically identical, but {@code java.net.URI} disagrees:
  * <ul>
- *   <li>http://host:80/
- *   <li>http://host
+ * <li>http://host:80/
+ * <li>http://host
  * </ul>
  * Both the unnecessary port specification ({@code :80}) and the absent trailing slash ({@code /})
  * cause URI to bucket the two URLs separately. This harms URI's usefulness in collections. Any
  * application that stores information-per-URL will need to either canonicalize manually, or suffer
  * unnecessary redundancy for such URLs.
- *
+ * <p/>
  * <p>Because they don't attempt canonical form, these classes are surprisingly difficult to use
  * securely. Suppose you're building a webservice that checks that incoming paths are prefixed
  * "/static/images/" before serving the corresponding assets from the filesystem. <pre>   {@code
- *
+ * <p/>
  *   String attack = "http://example.com/static/images/../../../../../etc/passwd";
  *   System.out.println(new URL(attack).getPath());
  *   System.out.println(new URI(attack).getPath());
  *   System.out.println(HttpUrl.parse(attack).path());
  * }</pre>
- *
+ * <p/>
  * By canonicalizing the input paths, they are complicit in directory traversal attacks. Code that
  * checks only the path prefix may suffer!
  * <pre>   {@code
- *
+ * <p/>
  *    /static/images/../../../../../etc/passwd
  *    /static/images/../../../../../etc/passwd
  *    /etc/passwd
  * }</pre>
- *
+ * <p/>
  * <h4>If it works on the web, it should work in your application</h4>
  * The {@code java.net.URI} class is strict around what URLs it accepts. It rejects URLs like
  * "http://example.com/abc|def" because the '|' character is unsupported. This class is more
  * forgiving: it will automatically percent-encode the '|', yielding "http://example.com/abc%7Cdef".
  * This kind behavior is consistent with web browsers. {@code HttpUrl} prefers consistency with
  * major web browsers over consistency with obsolete specifications.
- *
+ * <p/>
  * <h4>Paths and Queries should decompose</h4>
  * Neither of the built-in URL models offer direct access to path segments or query parameters.
  * Manually using {@code StringBuilder} to assemble these components is cumbersome: do '+'
  * characters get silently replaced with spaces? If a query parameter contains a '&amp;', does that
  * get escaped? By offering methods to read and write individual query parameters directly,
  * application developers are saved from the hassles of encoding and decoding.
- *
+ * <p/>
  * <h4>Plus a modern API</h4>
  * The URL (JDK1.0) and URI (Java 1.4) classes predate builders and instead use telescoping
  * constructors. For example, there's no API to compose a URI with a custom port without also
  * providing a query and fragment.
- *
+ * <p/>
  * <p>Instances of {@link HttpUrl} are well-formed and always have a scheme, host, and path. With
  * {@code java.net.URL} it's possible to create an awkward URL like {@code http:/} with scheme and
  * path but no hostname. Building APIs that consume such malformed values is difficult!
- *
+ * <p/>
  * <p>This class has a modern API. It avoids punitive checked exceptions: {@link #parse parse()}
  * returns null if the input is an invalid URL. You can even be explicit about whether each
  * component has been encoded already.
  */
 public final class HttpUrl {
-  private static final char[] HEX_DIGITS =
-      { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
-  static final String USERNAME_ENCODE_SET = " \"':;<=>@[]^`{}|/\\?#";
-  static final String PASSWORD_ENCODE_SET = " \"':;<=>@[]^`{}|/\\?#";
-  static final String PATH_SEGMENT_ENCODE_SET = " \"<>^`{}|/\\?#";
-  static final String QUERY_ENCODE_SET = " \"'<>#";
-  static final String QUERY_COMPONENT_ENCODE_SET = " \"'<>#&=";
-  static final String FORM_ENCODE_SET = " \"':;<=>@[]^`{}|/\\?#&!$(),~";
-  static final String FRAGMENT_ENCODE_SET = "";
-
-  /** Either "http" or "https". */
-  private final String scheme;
-
-  /** Decoded username. */
-  private final String username;
-
-  /** Decoded password. */
-  private final String password;
-
-  /** Canonical hostname. */
-  private final String host;
-
-  /** Either 80, 443 or a user-specified port. In range [1..65535]. */
-  private final int port;
-
-  /**
-   * A list of canonical path segments. This list always contains at least one element, which may
-   * be the empty string. Each segment is formatted with a leading '/', so if path segments were
-   * ["a", "b", ""], then the encoded path would be "/a/b/".
-   */
-  private final List<String> pathSegments;
-
-  /**
-   * Alternating, decoded query names and values, or null for no query. Names may be empty or
-   * non-empty, but never null. Values are null if the name has no corresponding '=' separator, or
-   * empty, or non-empty.
-   */
-  private final List<String> queryNamesAndValues;
-
-  /** Decoded fragment. */
-  private final String fragment;
-
-  /** Canonical URL. */
-  private final String url;
-
-  private HttpUrl(Builder builder) {
-    this.scheme = builder.scheme;
-    this.username = percentDecode(builder.encodedUsername);
-    this.password = percentDecode(builder.encodedPassword);
-    this.host = builder.host;
-    this.port = builder.effectivePort();
-    this.pathSegments = percentDecode(builder.encodedPathSegments);
-    this.queryNamesAndValues = builder.encodedQueryNamesAndValues != null
-        ? percentDecode(builder.encodedQueryNamesAndValues)
-        : null;
-    this.fragment = builder.encodedFragment != null
-        ? percentDecode(builder.encodedFragment)
-        : null;
-    this.url = builder.toString();
-  }
-
-  /** Returns this URL as a {@link URL java.net.URL}. */
-  public URL url() {
-    try {
-      return new URL(url);
-    } catch (MalformedURLException e) {
-      throw new RuntimeException(e); // Unexpected!
+    private static final char[] HEX_DIGITS =
+            {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
+    static final String USERNAME_ENCODE_SET = " \"':;<=>@[]^`{}|/\\?#";
+    static final String PASSWORD_ENCODE_SET = " \"':;<=>@[]^`{}|/\\?#";
+    static final String PATH_SEGMENT_ENCODE_SET = " \"<>^`{}|/\\?#";
+    static final String QUERY_ENCODE_SET = " \"'<>#";
+    static final String QUERY_COMPONENT_ENCODE_SET = " \"'<>#&=";
+    static final String FORM_ENCODE_SET = " \"':;<=>@[]^`{}|/\\?#&!$(),~";
+    static final String FRAGMENT_ENCODE_SET = "";
+
+    /**
+     * Either "http" or "https".
+     */
+    private final String scheme;
+
+    /**
+     * Decoded username.
+     */
+    private final String username;
+
+    /**
+     * Decoded password.
+     */
+    private final String password;
+
+    /**
+     * Canonical hostname.
+     */
+    private final String host;
+
+    /**
+     * Either 80, 443 or a user-specified port. In range [1..65535].
+     */
+    private final int port;
+
+    /**
+     * A list of canonical path segments. This list always contains at least one element, which may
+     * be the empty string. Each segment is formatted with a leading '/', so if path segments were
+     * ["a", "b", ""], then the encoded path would be "/a/b/".
+     */
+    private final List<String> pathSegments;
+
+    /**
+     * Alternating, decoded query names and values, or null for no query. Names may be empty or
+     * non-empty, but never null. Values are null if the name has no corresponding '=' separator, or
+     * empty, or non-empty.
+     */
+    private final List<String> queryNamesAndValues;
+
+    /**
+     * Decoded fragment.
+     */
+    private final String fragment;
+
+    /**
+     * Canonical URL.
+     */
+    private final String url;
+
+    private HttpUrl(Builder builder) {
+        this.scheme = builder.scheme;
+        this.username = percentDecode(builder.encodedUsername);
+        this.password = percentDecode(builder.encodedPassword);
+        this.host = builder.host;
+        this.port = builder.effectivePort();
+        this.pathSegments = percentDecode(builder.encodedPathSegments);
+        this.queryNamesAndValues = builder.encodedQueryNamesAndValues != null
+                ? percentDecode(builder.encodedQueryNamesAndValues)
+                : null;
+        this.fragment = builder.encodedFragment != null
+                ? percentDecode(builder.encodedFragment)
+                : null;
+        this.url = builder.toString();
     }
-  }
-
-  /**
-   * Attempt to convert this URL to a {@link URI java.net.URI}. This method throws an unchecked
-   * {@link IllegalStateException} if the URL it holds isn't valid by URI's overly-stringent
-   * standard. For example, URI rejects paths containing the '[' character. Consult that class for
-   * the exact rules of what URLs are permitted.
-   */
-  public URI uri() {
-    try {
-      return new URI(url);
-    } catch (URISyntaxException e) {
-      throw new IllegalStateException("not valid as a java.net.URI: " + url);
+
+    /**
+     * Returns this URL as a {@link URL java.net.URL}.
+     */
+    public URL url() {
+        try {
+            return new URL(url);
+        } catch (MalformedURLException e) {
+            throw new RuntimeException(e); // Unexpected!
+        }
     }
-  }
-
-  /** Returns either "http" or "https". */
-  public String scheme() {
-    return scheme;
-  }
-
-  public boolean isHttps() {
-    return scheme.equals("https");
-  }
-
-  /** Returns the username, or an empty string if none is set. */
-  public String encodedUsername() {
-    if (username.isEmpty()) return "";
-    int usernameStart = scheme.length() + 3; // "://".length() == 3.
-    int usernameEnd = delimiterOffset(url, usernameStart, url.length(), ":@");
-    return url.substring(usernameStart, usernameEnd);
-  }
-
-  public String username() {
-    return username;
-  }
-
-  /** Returns the password, or an empty string if none is set. */
-  public String encodedPassword() {
-    if (password.isEmpty()) return "";
-    int passwordStart = url.indexOf(':', scheme.length() + 3) + 1;
-    int passwordEnd = url.indexOf('@');
-    return url.substring(passwordStart, passwordEnd);
-  }
-
-  /** Returns the decoded password, or an empty string if none is present. */
-  public String password() {
-    return password;
-  }
-
-  /**
-   * Returns the host address suitable for use with {@link InetAddress#getAllByName(String)}. May
-   * be:
-   * <ul>
-   *   <li>A regular host name, like {@code android.com}.
-   *   <li>An IPv4 address, like {@code 127.0.0.1}.
-   *   <li>An IPv6 address, like {@code ::1}. Note that there are no square braces.
-   *   <li>An encoded IDN, like {@code xn--n3h.net}.
-   * </ul>
-   */
-  public String host() {
-    return host;
-  }
-
-  /**
-   * Returns the explicitly-specified port if one was provided, or the default port for this URL's
-   * scheme. For example, this returns 8443 for {@code https://square.com:8443/} and 443 for {@code
-   * https://square.com/}. The result is in {@code [1..65535]}.
-   */
-  public int port() {
-    return port;
-  }
-
-  /**
-   * Returns 80 if {@code scheme.equals("http")}, 443 if {@code scheme.equals("https")} and -1
-   * otherwise.
-   */
-  public static int defaultPort(String scheme) {
-    if (scheme.equals("http")) {
-      return 80;
-    } else if (scheme.equals("https")) {
-      return 443;
-    } else {
-      return -1;
+
+    /**
+     * Attempt to convert this URL to a {@link URI java.net.URI}. This method throws an unchecked
+     * {@link IllegalStateException} if the URL it holds isn't valid by URI's overly-stringent
+     * standard. For example, URI rejects paths containing the '[' character. Consult that class for
+     * the exact rules of what URLs are permitted.
+     */
+    public URI uri() {
+        try {
+            return new URI(url);
+        } catch (URISyntaxException e) {
+            throw new IllegalStateException("not valid as a java.net.URI: " + url);
+        }
     }
-  }
-
-  public int pathSize() {
-    return pathSegments.size();
-  }
-
-  /**
-   * Returns the entire path of this URL, encoded for use in HTTP resource resolution. The
-   * returned path is always nonempty and is prefixed with {@code /}.
-   */
-  public String encodedPath() {
-    int pathStart = url.indexOf('/', scheme.length() + 3); // "://".length() == 3.
-    int pathEnd = delimiterOffset(url, pathStart, url.length(), "?#");
-    return url.substring(pathStart, pathEnd);
-  }
-
-  static void pathSegmentsToString(StringBuilder out, List<String> pathSegments) {
-    for (int i = 0, size = pathSegments.size(); i < size; i++) {
-      out.append('/');
-      out.append(pathSegments.get(i));
+
+    /**
+     * Returns either "http" or "https".
+     */
+    public String scheme() {
+        return scheme;
     }
-  }
-
-  public List<String> encodedPathSegments() {
-    int pathStart = url.indexOf('/', scheme.length() + 3);
-    int pathEnd = delimiterOffset(url, pathStart, url.length(), "?#");
-    List<String> result = new ArrayList<>();
-    for (int i = pathStart; i < pathEnd; ) {
-      i++; // Skip the '/'.
-      int segmentEnd = delimiterOffset(url, i, pathEnd, "/");
-      result.add(url.substring(i, segmentEnd));
-      i = segmentEnd;
+
+    public boolean isHttps() {
+        return scheme.equals("https");
     }
-    return result;
-  }
-
-  public List<String> pathSegments() {
-    return pathSegments;
-  }
-
-  /**
-   * Returns the query of this URL, encoded for use in HTTP resource resolution. The returned string
-   * may be null (for URLs with no query), empty (for URLs with an empty query) or non-empty (all
-   * other URLs).
-   */
-  public String encodedQuery() {
-    if (queryNamesAndValues == null) return null; // No query.
-    int queryStart = url.indexOf('?') + 1;
-    int queryEnd = delimiterOffset(url, queryStart + 1, url.length(), "#");
-    return url.substring(queryStart, queryEnd);
-  }
-
-  static void namesAndValuesToQueryString(StringBuilder out, List<String> namesAndValues) {
-    for (int i = 0, size = namesAndValues.size(); i < size; i += 2) {
-      String name = namesAndValues.get(i);
-      String value = namesAndValues.get(i + 1);
-      if (i > 0) out.append('&');
-      out.append(name);
-      if (value != null) {
-        out.append('=');
-        out.append(value);
-      }
+
+    /**
+     * Returns the username, or an empty string if none is set.
+     */
+    public String encodedUsername() {
+        if (username.isEmpty()) return "";
+        int usernameStart = scheme.length() + 3; // "://".length() == 3.
+        int usernameEnd = delimiterOffset(url, usernameStart, url.length(), ":@");
+        return url.substring(usernameStart, usernameEnd);
     }
-  }
-
-  /**
-   * Cuts {@code encodedQuery} up into alternating parameter names and values. This divides a
-   * query string like {@code subject=math&easy&problem=5-2=3} into the list {@code ["subject",
-   * "math", "easy", null, "problem", "5-2=3"]}. Note that values may be null and may contain
-   * '=' characters.
-   */
-  static List<String> queryStringToNamesAndValues(String encodedQuery) {
-    List<String> result = new ArrayList<>();
-    for (int pos = 0; pos <= encodedQuery.length(); ) {
-      int ampersandOffset = encodedQuery.indexOf('&', pos);
-      if (ampersandOffset == -1) ampersandOffset = encodedQuery.length();
-
-      int equalsOffset = encodedQuery.indexOf('=', pos);
-      if (equalsOffset == -1 || equalsOffset > ampersandOffset) {
-        result.add(encodedQuery.substring(pos, ampersandOffset));
-        result.add(null); // No value for this name.
-      } else {
-        result.add(encodedQuery.substring(pos, equalsOffset));
-        result.add(encodedQuery.substring(equalsOffset + 1, ampersandOffset));
-      }
-      pos = ampersandOffset + 1;
+
+    public String username() {
+        return username;
     }
-    return result;
-  }
-
-  public String query() {
-    if (queryNamesAndValues == null) return null; // No query.
-    StringBuilder result = new StringBuilder();
-    namesAndValuesToQueryString(result, queryNamesAndValues);
-    return result.toString();
-  }
-
-  public int querySize() {
-    return queryNamesAndValues != null ? queryNamesAndValues.size() / 2 : 0;
-  }
-
-  /**
-   * Returns the first query parameter named {@code name} decoded using UTF-8, or null if there is
-   * no such query parameter.
-   */
-  public String queryParameter(String name) {
-    if (queryNamesAndValues == null) return null;
-    for (int i = 0, size = queryNamesAndValues.size(); i < size; i += 2) {
-      if (name.equals(queryNamesAndValues.get(i))) {
-        return queryNamesAndValues.get(i + 1);
-      }
+
+    /**
+     * Returns the password, or an empty string if none is set.
+     */
+    public String encodedPassword() {
+        if (password.isEmpty()) return "";
+        int passwordStart = url.indexOf(':', scheme.length() + 3) + 1;
+        int passwordEnd = url.indexOf('@');
+        return url.substring(passwordStart, passwordEnd);
     }
-    return null;
-  }
-
-  public Set<String> queryParameterNames() {
-    if (queryNamesAndValues == null) return Collections.emptySet();
-    Set<String> result = new LinkedHashSet<>();
-    for (int i = 0, size = queryNamesAndValues.size(); i < size; i += 2) {
-      result.add(queryNamesAndValues.get(i));
+
+    /**
+     * Returns the decoded password, or an empty string if none is present.
+     */
+    public String password() {
+        return password;
     }
-    return Collections.unmodifiableSet(result);
-  }
-
-  public List<String> queryParameterValues(String name) {
-    if (queryNamesAndValues == null) return Collections.emptyList();
-    List<String> result = new ArrayList<>();
-    for (int i = 0, size = queryNamesAndValues.size(); i < size; i += 2) {
-      if (name.equals(queryNamesAndValues.get(i))) {
-        result.add(queryNamesAndValues.get(i + 1));
-      }
+
+    /**
+     * Returns the host address suitable for use with {@link InetAddress#getAllByName(String)}. May
+     * be:
+     * <ul>
+     * <li>A regular host name, like {@code android.com}.
+     * <li>An IPv4 address, like {@code 127.0.0.1}.
+     * <li>An IPv6 address, like {@code ::1}. Note that there are no square braces.
+     * <li>An encoded IDN, like {@code xn--n3h.net}.
+     * </ul>
+     */
+    public String host() {
+        return host;
     }
-    return Collections.unmodifiableList(result);
-  }
-
-  public String queryParameterName(int index) {
-    return queryNamesAndValues.get(index * 2);
-  }
-
-  public String queryParameterValue(int index) {
-    return queryNamesAndValues.get(index * 2 + 1);
-  }
-
-  public String encodedFragment() {
-    if (fragment == null) return null;
-    int fragmentStart = url.indexOf('#') + 1;
-    return url.substring(fragmentStart);
-  }
-
-  public String fragment() {
-    return fragment;
-  }
-
-  /** Returns the URL that would be retrieved by following {@code link} from this URL. */
-  public HttpUrl resolve(String link) {
-    return new Builder().parse(this, link);
-  }
-
-  public Builder newBuilder() {
-    Builder result = new Builder();
-    result.scheme = scheme;
-    result.encodedUsername = encodedUsername();
-    result.encodedPassword = encodedPassword();
-    result.host = host;
-    result.port = port;
-    result.encodedPathSegments.clear();
-    result.encodedPathSegments.addAll(encodedPathSegments());
-    result.encodedQuery(encodedQuery());
-    result.encodedFragment = encodedFragment();
-    return result;
-  }
-
-  /**
-   * Returns a new {@code OkUrl} representing {@code url} if it is a well-formed HTTP or HTTPS URL,
-   * or null if it isn't.
-   */
-  public static HttpUrl parse(String url) {
-    return new Builder().parse(null, url);
-  }
-
-  /**
-   * Returns an {@link HttpUrl} for {@code url} if its protocol is {@code http} or {@code https}, or
-   * null if it has any other protocol.
-   */
-  public static HttpUrl get(URL url) {
-    return parse(url.toString());
-  }
-
-  public static HttpUrl get(URI uri) {
-    return parse(uri.toString());
-  }
-
-  @Override public boolean equals(Object o) {
-    return o instanceof HttpUrl && ((HttpUrl) o).url.equals(url);
-  }
-
-  @Override public int hashCode() {
-    return url.hashCode();
-  }
-
-  @Override public String toString() {
-    return url;
-  }
-
-  public static final class Builder {
-    String scheme;
-    String encodedUsername = "";
-    String encodedPassword = "";
-    String host;
-    int port = -1;
-    final List<String> encodedPathSegments = new ArrayList<>();
-    List<String> encodedQueryNamesAndValues;
-    String encodedFragment;
-
-    public Builder() {
-      encodedPathSegments.add(""); // The default path is '/' which needs a trailing space.
+
+    /**
+     * Returns the explicitly-specified port if one was provided, or the default port for this URL's
+     * scheme. For example, this returns 8443 for {@code https://square.com:8443/} and 443 for {@code
+     * https://square.com/}. The result is in {@code [1..65535]}.
+     */
+    public int port() {
+        return port;
     }
 
-    public Builder scheme(String scheme) {
-      if (scheme == null) {
-        throw new IllegalArgumentException("scheme == null");
-      } else if (scheme.equalsIgnoreCase("http")) {
-        this.scheme = "http";
-      } else if (scheme.equalsIgnoreCase("https")) {
-        this.scheme = "https";
-      } else {
-        throw new IllegalArgumentException("unexpected scheme: " + scheme);
-      }
-      return this;
+    /**
+     * Returns 80 if {@code scheme.equals("http")}, 443 if {@code scheme.equals("https")} and -1
+     * otherwise.
+     */
+    public static int defaultPort(String scheme) {
+        if (scheme.equals("http")) {
+            return 80;
+        } else if (scheme.equals("https")) {
+            return 443;
+        } else {
+            return -1;
+        }
     }
 
-    public Builder username(String username) {
-      if (username == null) throw new IllegalArgumentException("username == null");
-      this.encodedUsername = canonicalize(username, USERNAME_ENCODE_SET, false, false);
-      return this;
+    public int pathSize() {
+        return pathSegments.size();
     }
 
-    public Builder encodedUsername(String encodedUsername) {
-      if (encodedUsername == null) throw new IllegalArgumentException("encodedUsername == null");
-      this.encodedUsername = canonicalize(encodedUsername, USERNAME_ENCODE_SET, true, false);
-      return this;
+    /**
+     * Returns the entire path of this URL, encoded for use in HTTP resource resolution. The
+     * returned path is always nonempty and is prefixed with {@code /}.
+     */
+    public String encodedPath() {
+        int pathStart = url.indexOf('/', scheme.length() + 3); // "://".length() == 3.
+        int pathEnd = delimiterOffset(url, pathStart, url.length(), "?#");
+        return url.substring(pathStart, pathEnd);
     }
 
-    public Builder password(String password) {
-      if (password == null) throw new IllegalArgumentException("password == null");
-      this.encodedPassword = canonicalize(password, PASSWORD_ENCODE_SET, false, false);
-      return this;
+    static void pathSegmentsToString(StringBuilder out, List<String> pathSegments) {
+        for (int i = 0, size = pathSegments.size(); i < size; i++) {
+            out.append('/');
+            out.append(pathSegments.get(i));
+        }
     }
 
-    public Builder encodedPassword(String encodedPassword) {
-      if (encodedPassword == null) throw new IllegalArgumentException("encodedPassword == null");
-      this.encodedPassword = canonicalize(encodedPassword, PASSWORD_ENCODE_SET, true, false);
-      return this;
+    public List<String> encodedPathSegments() {
+        int pathStart = url.indexOf('/', scheme.length() + 3);
+        int pathEnd = delimiterOffset(url, pathStart, url.length(), "?#");
+        List<String> result = new ArrayList<>();
+        for (int i = pathStart; i < pathEnd; ) {
+            i++; // Skip the '/'.
+            int segmentEnd = delimiterOffset(url, i, pathEnd, "/");
+            result.add(url.substring(i, segmentEnd));
+            i = segmentEnd;
+        }
+        return result;
+    }
+
+    public List<String> pathSegments() {
+        return pathSegments;
     }
 
     /**
-     * @param host either a regular hostname, International Domain Name, IPv4 address, or IPv6
-     *     address.
+     * Returns the query of this URL, encoded for use in HTTP resource resolution. The returned string
+     * may be null (for URLs with no query), empty (for URLs with an empty query) or non-empty (all
+     * other URLs).
      */
-    public Builder host(String host) {
-      if (host == null) throw new IllegalArgumentException("host == null");
-      String encoded = canonicalizeHost(host, 0, host.length());
-      if (encoded == null) throw new IllegalArgumentException("unexpected host: " + host);
-      this.host = encoded;
-      return this;
+    public String encodedQuery() {
+        if (queryNamesAndValues == null) return null; // No query.
+        int queryStart = url.indexOf('?') + 1;
+        int queryEnd = delimiterOffset(url, queryStart + 1, url.length(), "#");
+        return url.substring(queryStart, queryEnd);
     }
 
-    public Builder port(int port) {
-      if (port <= 0 || port > 65535) throw new IllegalArgumentException("unexpected port: " + port);
-      this.port = port;
-      return this;
+    static void namesAndValuesToQueryString(StringBuilder out, List<String> namesAndValues) {
+        for (int i = 0, size = namesAndValues.size(); i < size; i += 2) {
+            String name = namesAndValues.get(i);
+            String value = namesAndValues.get(i + 1);
+            if (i > 0) out.append('&');
+            out.append(name);
+            if (value != null) {
+                out.append('=');
+                out.append(value);
+            }
+        }
     }
 
-    int effectivePort() {
-      return port != -1 ? port : defaultPort(scheme);
+    /**
+     * Cuts {@code encodedQuery} up into alternating parameter names and values. This divides a
+     * query string like {@code subject=math&easy&problem=5-2=3} into the list {@code ["subject",
+     * "math", "easy", null, "problem", "5-2=3"]}. Note that values may be null and may contain
+     * '=' characters.
+     */
+    static List<String> queryStringToNamesAndValues(String encodedQuery) {
+        List<String> result = new ArrayList<>();
+        for (int pos = 0; pos <= encodedQuery.length(); ) {
+            int ampersandOffset = encodedQuery.indexOf('&', pos);
+            if (ampersandOffset == -1) ampersandOffset = encodedQuery.length();
+
+            int equalsOffset = encodedQuery.indexOf('=', pos);
+            if (equalsOffset == -1 || equalsOffset > ampersandOffset) {
+                result.add(encodedQuery.substring(pos, ampersandOffset));
+                result.add(null); // No value for this name.
+            } else {
+                result.add(encodedQuery.substring(pos, equalsOffset));
+                result.add(encodedQuery.substring(equalsOffset + 1, ampersandOffset));
+            }
+            pos = ampersandOffset + 1;
+        }
+        return result;
     }
 
-    public Builder addPathSegment(String pathSegment) {
-      if (pathSegment == null) throw new IllegalArgumentException("pathSegment == null");
-      push(pathSegment, 0, pathSegment.length(), false, false);
-      return this;
+    public String query() {
+        if (queryNamesAndValues == null) return null; // No query.
+        StringBuilder result = new StringBuilder();
+        namesAndValuesToQueryString(result, queryNamesAndValues);
+        return result.toString();
     }
 
-    public Builder addEncodedPathSegment(String encodedPathSegment) {
-      if (encodedPathSegment == null) {
-        throw new IllegalArgumentException("encodedPathSegment == null");
-      }
-      push(encodedPathSegment, 0, encodedPathSegment.length(), false, true);
-      return this;
+    public int querySize() {
+        return queryNamesAndValues != null ? queryNamesAndValues.size() / 2 : 0;
     }
 
-    public Builder setPathSegment(int index, String pathSegment) {
-      if (pathSegment == null) throw new IllegalArgumentException("pathSegment == null");
-      String canonicalPathSegment = canonicalize(
-          pathSegment, 0, pathSegment.length(), PATH_SEGMENT_ENCODE_SET, false, false);
-      if (isDot(canonicalPathSegment) || isDotDot(canonicalPathSegment)) {
-        throw new IllegalArgumentException("unexpected path segment: " + pathSegment);
-      }
-      encodedPathSegments.set(index, canonicalPathSegment);
-      return this;
+    /**
+     * Returns the first query parameter named {@code name} decoded using UTF-8, or null if there is
+     * no such query parameter.
+     */
+    public String queryParameter(String name) {
+        if (queryNamesAndValues == null) return null;
+        for (int i = 0, size = queryNamesAndValues.size(); i < size; i += 2) {
+            if (name.equals(queryNamesAndValues.get(i))) {
+                return queryNamesAndValues.get(i + 1);
+            }
+        }
+        return null;
     }
 
-    public Builder setEncodedPathSegment(int index, String encodedPathSegment) {
-      if (encodedPathSegment == null) {
-        throw new IllegalArgumentException("encodedPathSegment == null");
-      }
-      String canonicalPathSegment = canonicalize(encodedPathSegment,
-          0, encodedPathSegment.length(), PATH_SEGMENT_ENCODE_SET, true, false);
-      encodedPathSegments.set(index, canonicalPathSegment);
-      if (isDot(canonicalPathSegment) || isDotDot(canonicalPathSegment)) {
-        throw new IllegalArgumentException("unexpected path segment: " + encodedPathSegment);
-      }
-      return this;
+    public Set<String> queryParameterNames() {
+        if (queryNamesAndValues == null) return Collections.emptySet();
+        Set<String> result = new LinkedHashSet<>();
+        for (int i = 0, size = queryNamesAndValues.size(); i < size; i += 2) {
+            result.add(queryNamesAndValues.get(i));
+        }
+        return Collections.unmodifiableSet(result);
     }
 
-    public Builder removePathSegment(int index) {
-      encodedPathSegments.remove(index);
-      if (encodedPathSegments.isEmpty()) {
-        encodedPathSegments.add(""); // Always leave at least one '/'.
-      }
-      return this;
+    public List<String> queryParameterValues(String name) {
+        if (queryNamesAndValues == null) return Collections.emptyList();
+        List<String> result = new ArrayList<>();
+        for (int i = 0, size = queryNamesAndValues.size(); i < size; i += 2) {
+            if (name.equals(queryNamesAndValues.get(i))) {
+                result.add(queryNamesAndValues.get(i + 1));
+            }
+        }
+        return Collections.unmodifiableList(result);
     }
 
-    public Builder encodedPath(String encodedPath) {
-      if (encodedPath == null) throw new IllegalArgumentException("encodedPath == null");
-      if (!encodedPath.startsWith("/")) {
-        throw new IllegalArgumentException("unexpected encodedPath: " + encodedPath);
-      }
-      resolvePath(encodedPath, 0, encodedPath.length());
-      return this;
+    public String queryParameterName(int index) {
+        return queryNamesAndValues.get(index * 2);
     }
 
-    public Builder query(String query) {
-      this.encodedQueryNamesAndValues = query != null
-          ? queryStringToNamesAndValues(canonicalize(query, QUERY_ENCODE_SET, false, true))
-          : null;
-      return this;
+    public String queryParameterValue(int index) {
+        return queryNamesAndValues.get(index * 2 + 1);
     }
 
-    public Builder encodedQuery(String encodedQuery) {
-      this.encodedQueryNamesAndValues = encodedQuery != null
-          ? queryStringToNamesAndValues(canonicalize(encodedQuery, QUERY_ENCODE_SET, true, true))
-          : null;
-      return this;
+    public String encodedFragment() {
+        if (fragment == null) return null;
+        int fragmentStart = url.indexOf('#') + 1;
+        return url.substring(fragmentStart);
     }
 
-    /** Encodes the query parameter using UTF-8 and adds it to this URL's query string. */
-    public Builder addQueryParameter(String name, String value) {
-      if (name == null) throw new IllegalArgumentException("name == null");
-      if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = new ArrayList<>();
-      encodedQueryNamesAndValues.add(canonicalize(name, QUERY_COMPONENT_ENCODE_SET, false, true));
-      encodedQueryNamesAndValues.add(value != null
-          ? canonicalize(value, QUERY_COMPONENT_ENCODE_SET, false, true)
-          : null);
-      return this;
+    public String fragment() {
+        return fragment;
     }
 
-    /** Adds the pre-encoded query parameter to this URL's query string. */
-    public Builder addEncodedQueryParameter(String encodedName, String encodedValue) {
-      if (encodedName == null) throw new IllegalArgumentException("encodedName == null");
-      if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = new ArrayList<>();
-      encodedQueryNamesAndValues.add(
-          canonicalize(encodedName, QUERY_COMPONENT_ENCODE_SET, true, true));
-      encodedQueryNamesAndValues.add(encodedValue != null
-          ? canonicalize(encodedValue, QUERY_COMPONENT_ENCODE_SET, true, true)
-          : null);
-      return this;
+    /**
+     * Returns the URL that would be retrieved by following {@code link} from this URL.
+     */
+    public HttpUrl resolve(String link) {
+        return new Builder().parse(this, link);
     }
 
-    public Builder setQueryParameter(String name, String value) {
-      removeAllQueryParameters(name);
-      addQueryParameter(name, value);
-      return this;
+    public Builder newBuilder() {
+        Builder result = new Builder();
+        result.scheme = scheme;
+        result.encodedUsername = encodedUsername();
+        result.encodedPassword = encodedPassword();
+        result.host = host;
+        result.port = port;
+        result.encodedPathSegments.clear();
+        result.encodedPathSegments.addAll(encodedPathSegments());
+        result.encodedQuery(encodedQuery());
+        result.encodedFragment = encodedFragment();
+        return result;
     }
 
-    public Builder setEncodedQueryParameter(String encodedName, String encodedValue) {
-      removeAllEncodedQueryParameters(encodedName);
-      addEncodedQueryParameter(encodedName, encodedValue);
-      return this;
+    /**
+     * Returns a new {@code OkUrl} representing {@code url} if it is a well-formed HTTP or HTTPS URL,
+     * or null if it isn't.
+     */
+    public static HttpUrl parse(String url) {
+        return new Builder().parse(null, url);
     }
 
-    public Builder removeAllQueryParameters(String name) {
-      if (name == null) throw new IllegalArgumentException("name == null");
-      if (encodedQueryNamesAndValues == null) return this;
-      String nameToRemove = canonicalize(name, QUERY_COMPONENT_ENCODE_SET, false, true);
-      removeAllCanonicalQueryParameters(nameToRemove);
-      return this;
+    /**
+     * Returns an {@link HttpUrl} for {@code url} if its protocol is {@code http} or {@code https}, or
+     * null if it has any other protocol.
+     */
+    public static HttpUrl get(URL url) {
+        return parse(url.toString());
     }
 
-    public Builder removeAllEncodedQueryParameters(String encodedName) {
-      if (encodedName == null) throw new IllegalArgumentException("encodedName == null");
-      if (encodedQueryNamesAndValues == null) return this;
-      removeAllCanonicalQueryParameters(
-          canonicalize(encodedName, QUERY_COMPONENT_ENCODE_SET, true, true));
-      return this;
+    public static HttpUrl get(URI uri) {
+        return parse(uri.toString());
     }
 
-    private void removeAllCanonicalQueryParameters(String canonicalName) {
-      for (int i = encodedQueryNamesAndValues.size() - 2; i >= 0; i -= 2) {
-        if (canonicalName.equals(encodedQueryNamesAndValues.get(i))) {
-          encodedQueryNamesAndValues.remove(i + 1);
-          encodedQueryNamesAndValues.remove(i);
-          if (encodedQueryNamesAndValues.isEmpty()) {
-            encodedQueryNamesAndValues = null;
-            return;
-          }
-        }
-      }
+    @Override
+    public boolean equals(Object o) {
+        return o instanceof HttpUrl && ((HttpUrl) o).url.equals(url);
     }
 
-    public Builder fragment(String fragment) {
-      if (fragment == null) throw new IllegalArgumentException("fragment == null");
-      this.encodedFragment = canonicalize(fragment, FRAGMENT_ENCODE_SET, false, false);
-      return this;
+    @Override
+    public int hashCode() {
+        return url.hashCode();
     }
 
-    public Builder encodedFragment(String encodedFragment) {
-      if (encodedFragment == null) throw new IllegalArgumentException("encodedFragment == null");
-      this.encodedFragment = canonicalize(encodedFragment, FRAGMENT_ENCODE_SET, true, false);
-      return this;
+    @Override
+    public String toString() {
+        return url;
     }
 
-    public HttpUrl build() {
-      if (scheme == null) throw new IllegalStateException("scheme == null");
-      if (host == null) throw new IllegalStateException("host == null");
-      return new HttpUrl(this);
-    }
+    public static final class Builder {
+        String scheme;
+        String encodedUsername = "";
+        String encodedPassword = "";
+        String host;
+        int port = -1;
+        final List<String> encodedPathSegments = new ArrayList<>();
+        List<String> encodedQueryNamesAndValues;
+        String encodedFragment;
+
+        public Builder() {
+            encodedPathSegments.add(""); // The default path is '/' which needs a trailing space.
+        }
+
+        public Builder scheme(String scheme) {
+            if (scheme == null) {
+                throw new IllegalArgumentException("scheme == null");
+            } else if (scheme.equalsIgnoreCase("http")) {
+                this.scheme = "http";
+            } else if (scheme.equalsIgnoreCase("https")) {
+                this.scheme = "https";
+            } else {
+                throw new IllegalArgumentException("unexpected scheme: " + scheme);
+            }
+            return this;
+        }
 
-    @Override public String toString() {
-      StringBuilder result = new StringBuilder();
-      result.append(scheme);
-      result.append("://");
+        public Builder username(String username) {
+            if (username == null) throw new IllegalArgumentException("username == null");
+            this.encodedUsername = canonicalize(username, USERNAME_ENCODE_SET, false, false);
+            return this;
+        }
 
-      if (!encodedUsername.isEmpty() || !encodedPassword.isEmpty()) {
-        result.append(encodedUsername);
-        if (!encodedPassword.isEmpty()) {
-          result.append(':');
-          result.append(encodedPassword);
+        public Builder encodedUsername(String encodedUsername) {
+            if (encodedUsername == null)
+                throw new IllegalArgumentException("encodedUsername == null");
+            this.encodedUsername = canonicalize(encodedUsername, USERNAME_ENCODE_SET, true, false);
+            return this;
         }
-        result.append('@');
-      }
-
-      if (host.indexOf(':') != -1) {
-        // Host is an IPv6 address.
-        result.append('[');
-        result.append(host);
-        result.append(']');
-      } else {
-        result.append(host);
-      }
-
-      int effectivePort = effectivePort();
-      if (effectivePort != defaultPort(scheme)) {
-        result.append(':');
-        result.append(effectivePort);
-      }
-
-      pathSegmentsToString(result, encodedPathSegments);
-
-      if (encodedQueryNamesAndValues != null) {
-        result.append('?');
-        namesAndValuesToQueryString(result, encodedQueryNamesAndValues);
-      }
-
-      if (encodedFragment != null) {
-        result.append('#');
-        result.append(encodedFragment);
-      }
-
-      return result.toString();
-    }
 
-    HttpUrl parse(HttpUrl base, String input) {
-      int pos = skipLeadingAsciiWhitespace(input, 0, input.length());
-      int limit = skipTrailingAsciiWhitespace(input, pos, input.length());
-
-      // Scheme.
-      int schemeDelimiterOffset = schemeDelimiterOffset(input, pos, limit);
-      if (schemeDelimiterOffset != -1) {
-        if (input.regionMatches(true, pos, "https:", 0, 6)) {
-          this.scheme = "https";
-          pos += "https:".length();
-        } else if (input.regionMatches(true, pos, "http:", 0, 5)) {
-          this.scheme = "http";
-          pos += "http:".length();
-        } else {
-          return null; // Not an HTTP scheme.
+        public Builder password(String password) {
+            if (password == null) throw new IllegalArgumentException("password == null");
+            this.encodedPassword = canonicalize(password, PASSWORD_ENCODE_SET, false, false);
+            return this;
+        }
+
+        public Builder encodedPassword(String encodedPassword) {
+            if (encodedPassword == null)
+                throw new IllegalArgumentException("encodedPassword == null");
+            this.encodedPassword = canonicalize(encodedPassword, PASSWORD_ENCODE_SET, true, false);
+            return this;
+        }
+
+        /**
+         * @param host either a regular hostname, International Domain Name, IPv4 address, or IPv6
+         *             address.
+         */
+        public Builder host(String host) {
+            if (host == null) throw new IllegalArgumentException("host == null");
+            String encoded = canonicalizeHost(host, 0, host.length());
+            if (encoded == null) throw new IllegalArgumentException("unexpected host: " + host);
+            this.host = encoded;
+            return this;
+        }
+
+        public Builder port(int port) {
+            if (port <= 0 || port > 65535)
+                throw new IllegalArgumentException("unexpected port: " + port);
+            this.port = port;
+            return this;
+        }
+
+        int effectivePort() {
+            return port != -1 ? port : defaultPort(scheme);
+        }
+
+        public Builder addPathSegment(String pathSegment) {
+            if (pathSegment == null) throw new IllegalArgumentException("pathSegment == null");
+            push(pathSegment, 0, pathSegment.length(), false, false);
+            return this;
+        }
+
+        public Builder addEncodedPathSegment(String encodedPathSegment) {
+            if (encodedPathSegment == null) {
+                throw new IllegalArgumentException("encodedPathSegment == null");
+            }
+            push(encodedPathSegment, 0, encodedPathSegment.length(), false, true);
+            return this;
+        }
+
+        public Builder setPathSegment(int index, String pathSegment) {
+            if (pathSegment == null) throw new IllegalArgumentException("pathSegment == null");
+            String canonicalPathSegment = canonicalize(
+                    pathSegment, 0, pathSegment.length(), PATH_SEGMENT_ENCODE_SET, false, false);
+            if (isDot(canonicalPathSegment) || isDotDot(canonicalPathSegment)) {
+                throw new IllegalArgumentException("unexpected path segment: " + pathSegment);
+            }
+            encodedPathSegments.set(index, canonicalPathSegment);
+            return this;
+        }
+
+        public Builder setEncodedPathSegment(int index, String encodedPathSegment) {
+            if (encodedPathSegment == null) {
+                throw new IllegalArgumentException("encodedPathSegment == null");
+            }
+            String canonicalPathSegment = canonicalize(encodedPathSegment,
+                    0, encodedPathSegment.length(), PATH_SEGMENT_ENCODE_SET, true, false);
+            encodedPathSegments.set(index, canonicalPathSegment);
+            if (isDot(canonicalPathSegment) || isDotDot(canonicalPathSegment)) {
+                throw new IllegalArgumentException("unexpected path segment: " + encodedPathSegment);
+            }
+            return this;
+        }
+
+        public Builder removePathSegment(int index) {
+            encodedPathSegments.remove(index);
+            if (encodedPathSegments.isEmpty()) {
+                encodedPathSegments.add(""); // Always leave at least one '/'.
+            }
+            return this;
+        }
+
+        public Builder encodedPath(String encodedPath) {
+            if (encodedPath == null) throw new IllegalArgumentException("encodedPath == null");
+            if (!encodedPath.startsWith("/")) {
+                throw new IllegalArgumentException("unexpected encodedPath: " + encodedPath);
+            }
+            resolvePath(encodedPath, 0, encodedPath.length());
+            return this;
+        }
+
+        public Builder query(String query) {
+            this.encodedQueryNamesAndValues = query != null
+                    ? queryStringToNamesAndValues(canonicalize(query, QUERY_ENCODE_SET, false, true))
+                    : null;
+            return this;
+        }
+
+        public Builder encodedQuery(String encodedQuery) {
+            this.encodedQueryNamesAndValues = encodedQuery != null
+                    ? queryStringToNamesAndValues(canonicalize(encodedQuery, QUERY_ENCODE_SET, true, true))
+                    : null;
+            return this;
+        }
+
+        /**
+         * Encodes the query parameter using UTF-8 and adds it to this URL's query string.
+         */
+        public Builder addQueryParameter(String name, String value) {
+            if (name == null) throw new IllegalArgumentException("name == null");
+            if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = new ArrayList<>();
+            encodedQueryNamesAndValues.add(canonicalize(name, QUERY_COMPONENT_ENCODE_SET, false, true));
+            encodedQueryNamesAndValues.add(value != null
+                    ? canonicalize(value, QUERY_COMPONENT_ENCODE_SET, false, true)
+                    : null);
+            return this;
+        }
+
+        /**
+         * Adds the pre-encoded query parameter to this URL's query string.
+         */
+        public Builder addEncodedQueryParameter(String encodedName, String encodedValue) {
+            if (encodedName == null) throw new IllegalArgumentException("encodedName == null");
+            if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = new ArrayList<>();
+            encodedQueryNamesAndValues.add(
+                    canonicalize(encodedName, QUERY_COMPONENT_ENCODE_SET, true, true));
+            encodedQueryNamesAndValues.add(encodedValue != null
+                    ? canonicalize(encodedValue, QUERY_COMPONENT_ENCODE_SET, true, true)
+                    : null);
+            return this;
         }
-      } else if (base != null) {
-        this.scheme = base.scheme;
-      } else {
-        return null; // No scheme.
-      }
-
-      // Authority.
-      boolean hasUsername = false;
-      boolean hasPassword = false;
-      int slashCount = slashCount(input, pos, limit);
-      if (slashCount >= 2 || base == null || !base.scheme.equals(this.scheme)) {
-        // Read an authority if either:
-        //  * The input starts with 2 or more slashes. These follow the scheme if it exists.
-        //  * The input scheme exists and is different from the base URL's scheme.
-        //
-        // The structure of an authority is:
-        //   username:password@host:port
-        //
-        // Username, password and port are optional.
-        //   [username[:password]@]host[:port]
-        pos += slashCount;
-        authority:
-        while (true) {
-          int componentDelimiterOffset = delimiterOffset(input, pos, limit, "@/\\?#");
-          int c = componentDelimiterOffset != limit
-              ? input.charAt(componentDelimiterOffset)
-              : -1;
-          switch (c) {
-            case '@':
-              // User info precedes.
-              if (!hasPassword) {
-                int passwordColonOffset = delimiterOffset(
-                    input, pos, componentDelimiterOffset, ":");
-                String canonicalUsername = canonicalize(
-                    input, pos, passwordColonOffset, USERNAME_ENCODE_SET, true, false);
-                this.encodedUsername = hasUsername
-                    ? this.encodedUsername + "%40" + canonicalUsername
-                    : canonicalUsername;
-                if (passwordColonOffset != componentDelimiterOffset) {
-                  hasPassword = true;
-                  this.encodedPassword = canonicalize(input, passwordColonOffset + 1,
-                      componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false);
+
+        public Builder setQueryParameter(String name, String value) {
+            removeAllQueryParameters(name);
+            addQueryParameter(name, value);
+            return this;
+        }
+
+        public Builder setEncodedQueryParameter(String encodedName, String encodedValue) {
+            removeAllEncodedQueryParameters(encodedName);
+            addEncodedQueryParameter(encodedName, encodedValue);
+            return this;
+        }
+
+        public Builder removeAllQueryParameters(String name) {
+            if (name == null) throw new IllegalArgumentException("name == null");
+            if (encodedQueryNamesAndValues == null) return this;
+            String nameToRemove = canonicalize(name, QUERY_COMPONENT_ENCODE_SET, false, true);
+            removeAllCanonicalQueryParameters(nameToRemove);
+            return this;
+        }
+
+        public Builder removeAllEncodedQueryParameters(String encodedName) {
+            if (encodedName == null) throw new IllegalArgumentException("encodedName == null");
+            if (encodedQueryNamesAndValues == null) return this;
+            removeAllCanonicalQueryParameters(
+                    canonicalize(encodedName, QUERY_COMPONENT_ENCODE_SET, true, true));
+            return this;
+        }
+
+        private void removeAllCanonicalQueryParameters(String canonicalName) {
+            for (int i = encodedQueryNamesAndValues.size() - 2; i >= 0; i -= 2) {
+                if (canonicalName.equals(encodedQueryNamesAndValues.get(i))) {
+                    encodedQueryNamesAndValues.remove(i + 1);
+                    encodedQueryNamesAndValues.remove(i);
+                    if (encodedQueryNamesAndValues.isEmpty()) {
+                        encodedQueryNamesAndValues = null;
+                        return;
+                    }
                 }
-                hasUsername = true;
-              } else {
-                this.encodedPassword = this.encodedPassword + "%40" + canonicalize(
-                    input, pos, componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false);
-              }
-              pos = componentDelimiterOffset + 1;
-              break;
-
-            case -1:
-            case '/':
-            case '\\':
-            case '?':
-            case '#':
-              // Host info precedes.
-              int portColonOffset = portColonOffset(input, pos, componentDelimiterOffset);
-              if (portColonOffset + 1 < componentDelimiterOffset) {
-                this.host = canonicalizeHost(input, pos, portColonOffset);
-                this.port = parsePort(input, portColonOffset + 1, componentDelimiterOffset);
-                if (this.port == -1) return null; // Invalid port.
-              } else {
-                this.host = canonicalizeHost(input, pos, portColonOffset);
-                this.port = defaultPort(this.scheme);
-              }
-              if (this.host == null) return null; // Invalid host.
-              pos = componentDelimiterOffset;
-              break authority;
-          }
+            }
         }
-      } else {
-        // This is a relative link. Copy over all authority components. Also maybe the path & query.
-        this.encodedUsername = base.encodedUsername();
-        this.encodedPassword = base.encodedPassword();
-        this.host = base.host;
-        this.port = base.port;
-        this.encodedPathSegments.clear();
-        this.encodedPathSegments.addAll(base.encodedPathSegments());
-        if (pos == limit || input.charAt(pos) == '#') {
-          encodedQuery(base.encodedQuery());
+
+        public Builder fragment(String fragment) {
+            if (fragment == null) throw new IllegalArgumentException("fragment == null");
+            this.encodedFragment = canonicalize(fragment, FRAGMENT_ENCODE_SET, false, false);
+            return this;
         }
-      }
-
-      // Resolve the relative path.
-      int pathDelimiterOffset = delimiterOffset(input, pos, limit, "?#");
-      resolvePath(input, pos, pathDelimiterOffset);
-      pos = pathDelimiterOffset;
-
-      // Query.
-      if (pos < limit && input.charAt(pos) == '?') {
-        int queryDelimiterOffset = delimiterOffset(input, pos, limit, "#");
-        this.encodedQueryNamesAndValues = queryStringToNamesAndValues(canonicalize(
-            input, pos + 1, queryDelimiterOffset, QUERY_ENCODE_SET, true, true));
-        pos = queryDelimiterOffset;
-      }
-
-      // Fragment.
-      if (pos < limit && input.charAt(pos) == '#') {
-        this.encodedFragment = canonicalize(
-            input, pos + 1, limit, FRAGMENT_ENCODE_SET, true, false);
-      }
-
-      return build();
-    }
 
-    private void resolvePath(String input, int pos, int limit) {
-      // Read a delimiter.
-      if (pos == limit) {
-        // Empty path: keep the base path as-is.
-        return;
-      }
-      char c = input.charAt(pos);
-      if (c == '/' || c == '\\') {
-        // Absolute path: reset to the default "/".
-        encodedPathSegments.clear();
-        encodedPathSegments.add("");
-        pos++;
-      } else {
-        // Relative path: clear everything after the last '/'.
-        encodedPathSegments.set(encodedPathSegments.size() - 1, "");
-      }
-
-      // Read path segments.
-      for (int i = pos; i < limit; ) {
-        int pathSegmentDelimiterOffset = delimiterOffset(input, i, limit, "/\\");
-        boolean segmentHasTrailingSlash = pathSegmentDelimiterOffset < limit;
-        push(input, i, pathSegmentDelimiterOffset, segmentHasTrailingSlash, true);
-        i = pathSegmentDelimiterOffset;
-        if (segmentHasTrailingSlash) i++;
-      }
-    }
+        public Builder encodedFragment(String encodedFragment) {
+            if (encodedFragment == null)
+                throw new IllegalArgumentException("encodedFragment == null");
+            this.encodedFragment = canonicalize(encodedFragment, FRAGMENT_ENCODE_SET, true, false);
+            return this;
+        }
 
-    /** Adds a path segment. If the input is ".." or equivalent, this pops a path segment. */
-    private void push(String input, int pos, int limit, boolean addTrailingSlash,
-        boolean alreadyEncoded) {
-      String segment = canonicalize(
-          input, pos, limit, PATH_SEGMENT_ENCODE_SET, alreadyEncoded, false);
-      if (isDot(segment)) {
-        return; // Skip '.' path segments.
-      }
-      if (isDotDot(segment)) {
-        pop();
-        return;
-      }
-      if (encodedPathSegments.get(encodedPathSegments.size() - 1).isEmpty()) {
-        encodedPathSegments.set(encodedPathSegments.size() - 1, segment);
-      } else {
-        encodedPathSegments.add(segment);
-      }
-      if (addTrailingSlash) {
-        encodedPathSegments.add("");
-      }
-    }
+        public HttpUrl build() {
+            if (scheme == null) throw new IllegalStateException("scheme == null");
+            if (host == null) throw new IllegalStateException("host == null");
+            return new HttpUrl(this);
+        }
 
-    private boolean isDot(String input) {
-      return input.equals(".") || input.equalsIgnoreCase("%2e");
-    }
+        @Override
+        public String toString() {
+            StringBuilder result = new StringBuilder();
+            result.append(scheme);
+            result.append("://");
+
+            if (!encodedUsername.isEmpty() || !encodedPassword.isEmpty()) {
+                result.append(encodedUsername);
+                if (!encodedPassword.isEmpty()) {
+                    result.append(':');
+                    result.append(encodedPassword);
+                }
+                result.append('@');
+            }
 
-    private boolean isDotDot(String input) {
-      return input.equals("..")
-          || input.equalsIgnoreCase("%2e.")
-          || input.equalsIgnoreCase(".%2e")
-          || input.equalsIgnoreCase("%2e%2e");
-    }
+            if (host.indexOf(':') != -1) {
+                // Host is an IPv6 address.
+                result.append('[');
+                result.append(host);
+                result.append(']');
+            } else {
+                result.append(host);
+            }
 
-    /**
-     * Removes a path segment. When this method returns the last segment is always "", which means
-     * the encoded path will have a trailing '/'.
-     *
-     * <p>Popping "/a/b/c/" yields "/a/b/". In this case the list of path segments goes from
-     * ["a", "b", "c", ""] to ["a", "b", ""].
-     *
-     * <p>Popping "/a/b/c" also yields "/a/b/". The list of path segments goes from ["a", "b", "c"]
-     * to ["a", "b", ""].
-     */
-    private void pop() {
-      String removed = encodedPathSegments.remove(encodedPathSegments.size() - 1);
-
-      // Make sure the path ends with a '/' by either adding an empty string or clearing a segment.
-      if (removed.isEmpty() && !encodedPathSegments.isEmpty()) {
-        encodedPathSegments.set(encodedPathSegments.size() - 1, "");
-      } else {
-        encodedPathSegments.add("");
-      }
-    }
+            int effectivePort = effectivePort();
+            if (effectivePort != defaultPort(scheme)) {
+                result.append(':');
+                result.append(effectivePort);
+            }
 
-    /**
-     * Increments {@code pos} until {@code input[pos]} is not ASCII whitespace. Stops at {@code
-     * limit}.
-     */
-    private int skipLeadingAsciiWhitespace(String input, int pos, int limit) {
-      for (int i = pos; i < limit; i++) {
-        switch (input.charAt(i)) {
-          case '\t':
-          case '\n':
-          case '\f':
-          case '\r':
-          case ' ':
-            continue;
-          default:
-            return i;
+            pathSegmentsToString(result, encodedPathSegments);
+
+            if (encodedQueryNamesAndValues != null) {
+                result.append('?');
+                namesAndValuesToQueryString(result, encodedQueryNamesAndValues);
+            }
+
+            if (encodedFragment != null) {
+                result.append('#');
+                result.append(encodedFragment);
+            }
+
+            return result.toString();
         }
-      }
-      return limit;
-    }
 
-    /**
-     * Decrements {@code limit} until {@code input[limit - 1]} is not ASCII whitespace. Stops at
-     * {@code pos}.
-     */
-    private int skipTrailingAsciiWhitespace(String input, int pos, int limit) {
-      for (int i = limit - 1; i >= pos; i--) {
-        switch (input.charAt(i)) {
-          case '\t':
-          case '\n':
-          case '\f':
-          case '\r':
-          case ' ':
-            continue;
-          default:
-            return i + 1;
+        HttpUrl parse(HttpUrl base, String input) {
+            int pos = skipLeadingAsciiWhitespace(input, 0, input.length());
+            int limit = skipTrailingAsciiWhitespace(input, pos, input.length());
+
+            // Scheme.
+            int schemeDelimiterOffset = schemeDelimiterOffset(input, pos, limit);
+            if (schemeDelimiterOffset != -1) {
+                if (input.regionMatches(true, pos, "https:", 0, 6)) {
+                    this.scheme = "https";
+                    pos += "https:".length();
+                } else if (input.regionMatches(true, pos, "http:", 0, 5)) {
+                    this.scheme = "http";
+                    pos += "http:".length();
+                } else {
+                    return null; // Not an HTTP scheme.
+                }
+            } else if (base != null) {
+                this.scheme = base.scheme;
+            } else {
+                return null; // No scheme.
+            }
+
+            // Authority.
+            boolean hasUsername = false;
+            boolean hasPassword = false;
+            int slashCount = slashCount(input, pos, limit);
+            if (slashCount >= 2 || base == null || !base.scheme.equals(this.scheme)) {
+                // Read an authority if either:
+                //  * The input starts with 2 or more slashes. These follow the scheme if it exists.
+                //  * The input scheme exists and is different from the base URL's scheme.
+                //
+                // The structure of an authority is:
+                //   username:password@host:port
+                //
+                // Username, password and port are optional.
+                //   [username[:password]@]host[:port]
+                pos += slashCount;
+                authority:
+                while (true) {
+                    int componentDelimiterOffset = delimiterOffset(input, pos, limit, "@/\\?#");
+                    int c = componentDelimiterOffset != limit
+                            ? input.charAt(componentDelimiterOffset)
+                            : -1;
+                    switch (c) {
+                        case '@':
+                            // User info precedes.
+                            if (!hasPassword) {
+                                int passwordColonOffset = delimiterOffset(
+                                        input, pos, componentDelimiterOffset, ":");
+                                String canonicalUsername = canonicalize(
+                                        input, pos, passwordColonOffset, USERNAME_ENCODE_SET, true, false);
+                                this.encodedUsername = hasUsername
+                                        ? this.encodedUsername + "%40" + canonicalUsername
+                                        : canonicalUsername;
+                                if (passwordColonOffset != componentDelimiterOffset) {
+                                    hasPassword = true;
+                                    this.encodedPassword = canonicalize(input, passwordColonOffset + 1,
+                                            componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false);
+                                }
+                                hasUsername = true;
+                            } else {
+                                this.encodedPassword = this.encodedPassword + "%40" + canonicalize(
+                                        input, pos, componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false);
+                            }
+                            pos = componentDelimiterOffset + 1;
+                            break;
+
+                        case -1:
+                        case '/':
+                        case '\\':
+                        case '?':
+                        case '#':
+                            // Host info precedes.
+                            int portColonOffset = portColonOffset(input, pos, componentDelimiterOffset);
+                            if (portColonOffset + 1 < componentDelimiterOffset) {
+                                this.host = canonicalizeHost(input, pos, portColonOffset);
+                                this.port = parsePort(input, portColonOffset + 1, componentDelimiterOffset);
+                                if (this.port == -1) return null; // Invalid port.
+                            } else {
+                                this.host = canonicalizeHost(input, pos, portColonOffset);
+                                this.port = defaultPort(this.scheme);
+                            }
+                            if (this.host == null) return null; // Invalid host.
+                            pos = componentDelimiterOffset;
+                            break authority;
+                    }
+                }
+            } else {
+                // This is a relative link. Copy over all authority components. Also maybe the path & query.
+                this.encodedUsername = base.encodedUsername();
+                this.encodedPassword = base.encodedPassword();
+                this.host = base.host;
+                this.port = base.port;
+                this.encodedPathSegments.clear();
+                this.encodedPathSegments.addAll(base.encodedPathSegments());
+                if (pos == limit || input.charAt(pos) == '#') {
+                    encodedQuery(base.encodedQuery());
+                }
+            }
+
+            // Resolve the relative path.
+            int pathDelimiterOffset = delimiterOffset(input, pos, limit, "?#");
+            resolvePath(input, pos, pathDelimiterOffset);
+            pos = pathDelimiterOffset;
+
+            // Query.
+            if (pos < limit && input.charAt(pos) == '?') {
+                int queryDelimiterOffset = delimiterOffset(input, pos, limit, "#");
+                this.encodedQueryNamesAndValues = queryStringToNamesAndValues(canonicalize(
+                        input, pos + 1, queryDelimiterOffset, QUERY_ENCODE_SET, true, true));
+                pos = queryDelimiterOffset;
+            }
+
+            // Fragment.
+            if (pos < limit && input.charAt(pos) == '#') {
+                this.encodedFragment = canonicalize(
+                        input, pos + 1, limit, FRAGMENT_ENCODE_SET, true, false);
+            }
+
+            return build();
         }
-      }
-      return pos;
-    }
 
-    /**
-     * Returns the index of the ':' in {@code input} that is after scheme characters. Returns -1 if
-     * {@code input} does not have a scheme that starts at {@code pos}.
-     */
-    private static int schemeDelimiterOffset(String input, int pos, int limit) {
-      if (limit - pos < 2) return -1;
-
-      char c0 = input.charAt(pos);
-      if ((c0 < 'a' || c0 > 'z') && (c0 < 'A' || c0 > 'Z')) return -1; // Not a scheme start char.
-
-      for (int i = pos + 1; i < limit; i++) {
-        char c = input.charAt(i);
-
-        if ((c >= 'a' && c <= 'z')
-            || (c >= 'A' && c <= 'Z')
-            || c == '+'
-            || c == '-'
-            || c == '.') {
-          continue; // Scheme character. Keep going.
-        } else if (c == ':') {
-          return i; // Scheme prefix!
-        } else {
-          return -1; // Non-scheme character before the first ':'.
+        private void resolvePath(String input, int pos, int limit) {
+            // Read a delimiter.
+            if (pos == limit) {
+                // Empty path: keep the base path as-is.
+                return;
+            }
+            char c = input.charAt(pos);
+            if (c == '/' || c == '\\') {
+                // Absolute path: reset to the default "/".
+                encodedPathSegments.clear();
+                encodedPathSegments.add("");
+                pos++;
+            } else {
+                // Relative path: clear everything after the last '/'.
+                encodedPathSegments.set(encodedPathSegments.size() - 1, "");
+            }
+
+            // Read path segments.
+            for (int i = pos; i < limit; ) {
+                int pathSegmentDelimiterOffset = delimiterOffset(input, i, limit, "/\\");
+                boolean segmentHasTrailingSlash = pathSegmentDelimiterOffset < limit;
+                push(input, i, pathSegmentDelimiterOffset, segmentHasTrailingSlash, true);
+                i = pathSegmentDelimiterOffset;
+                if (segmentHasTrailingSlash) i++;
+            }
         }
-      }
 
-      return -1; // No ':'; doesn't start with a scheme.
-    }
+        /**
+         * Adds a path segment. If the input is ".." or equivalent, this pops a path segment.
+         */
+        private void push(String input, int pos, int limit, boolean addTrailingSlash,
+                          boolean alreadyEncoded) {
+            String segment = canonicalize(
+                    input, pos, limit, PATH_SEGMENT_ENCODE_SET, alreadyEncoded, false);
+            if (isDot(segment)) {
+                return; // Skip '.' path segments.
+            }
+            if (isDotDot(segment)) {
+                pop();
+                return;
+            }
+            if (encodedPathSegments.get(encodedPathSegments.size() - 1).isEmpty()) {
+                encodedPathSegments.set(encodedPathSegments.size() - 1, segment);
+            } else {
+                encodedPathSegments.add(segment);
+            }
+            if (addTrailingSlash) {
+                encodedPathSegments.add("");
+            }
+        }
 
-    /** Returns the number of '/' and '\' slashes in {@code input}, starting at {@code pos}. */
-    private static int slashCount(String input, int pos, int limit) {
-      int slashCount = 0;
-      while (pos < limit) {
-        char c = input.charAt(pos);
-        if (c == '\\' || c == '/') {
-          slashCount++;
-          pos++;
-        } else {
-          break;
+        private boolean isDot(String input) {
+            return input.equals(".") || input.equalsIgnoreCase("%2e");
+        }
+
+        private boolean isDotDot(String input) {
+            return input.equals("..")
+                    || input.equalsIgnoreCase("%2e.")
+                    || input.equalsIgnoreCase(".%2e")
+                    || input.equalsIgnoreCase("%2e%2e");
         }
-      }
-      return slashCount;
-    }
 
-    /** Finds the first ':' in {@code input}, skipping characters between square braces "[...]". */
-    private static int portColonOffset(String input, int pos, int limit) {
-      for (int i = pos; i < limit; i++) {
-        switch (input.charAt(i)) {
-          case '[':
-            while (++i < limit) {
-              if (input.charAt(i) == ']') break;
+        /**
+         * Removes a path segment. When this method returns the last segment is always "", which means
+         * the encoded path will have a trailing '/'.
+         * <p/>
+         * <p>Popping "/a/b/c/" yields "/a/b/". In this case the list of path segments goes from
+         * ["a", "b", "c", ""] to ["a", "b", ""].
+         * <p/>
+         * <p>Popping "/a/b/c" also yields "/a/b/". The list of path segments goes from ["a", "b", "c"]
+         * to ["a", "b", ""].
+         */
+        private void pop() {
+            String removed = encodedPathSegments.remove(encodedPathSegments.size() - 1);
+
+            // Make sure the path ends with a '/' by either adding an empty string or clearing a segment.
+            if (removed.isEmpty() && !encodedPathSegments.isEmpty()) {
+                encodedPathSegments.set(encodedPathSegments.size() - 1, "");
+            } else {
+                encodedPathSegments.add("");
             }
-            break;
-          case ':':
-            return i;
         }
-      }
-      return limit; // No colon.
-    }
 
-    private static String canonicalizeHost(String input, int pos, int limit) {
-      // Start by percent decoding the host. The WHATWG spec suggests doing this only after we've
-      // checked for IPv6 square braces. But Chrome does it first, and that's more lenient.
-      String percentDecoded = percentDecode(input, pos, limit);
+        /**
+         * Increments {@code pos} until {@code input[pos]} is not ASCII whitespace. Stops at {@code
+         * limit}.
+         */
+        private int skipLeadingAsciiWhitespace(String input, int pos, int limit) {
+            for (int i = pos; i < limit; i++) {
+                switch (input.charAt(i)) {
+                    case '\t':
+                    case '\n':
+                    case '\f':
+                    case '\r':
+                    case ' ':
+                        continue;
+                    default:
+                        return i;
+                }
+            }
+            return limit;
+        }
 
-      // If the input is encased in square braces "[...]", drop 'em. We have an IPv6 address.
-      if (percentDecoded.startsWith("[") && percentDecoded.endsWith("]")) {
-        InetAddress inetAddress = decodeIpv6(percentDecoded, 1, percentDecoded.length() - 1);
-        return inetAddress != null ? inetAddress.getHostAddress() : null;
-      }
+        /**
+         * Decrements {@code limit} until {@code input[limit - 1]} is not ASCII whitespace. Stops at
+         * {@code pos}.
+         */
+        private int skipTrailingAsciiWhitespace(String input, int pos, int limit) {
+            for (int i = limit - 1; i >= pos; i--) {
+                switch (input.charAt(i)) {
+                    case '\t':
+                    case '\n':
+                    case '\f':
+                    case '\r':
+                    case ' ':
+                        continue;
+                    default:
+                        return i + 1;
+                }
+            }
+            return pos;
+        }
 
-      // Do IDN decoding. This converts {@code ☃.net} to {@code xn--n3h.net}.
-      String idnDecoded = domainToAscii(percentDecoded);
-      if (idnDecoded == null) return null;
+        /**
+         * Returns the index of the ':' in {@code input} that is after scheme characters. Returns -1 if
+         * {@code input} does not have a scheme that starts at {@code pos}.
+         */
+        private static int schemeDelimiterOffset(String input, int pos, int limit) {
+            if (limit - pos < 2) return -1;
+
+            char c0 = input.charAt(pos);
+            if ((c0 < 'a' || c0 > 'z') && (c0 < 'A' || c0 > 'Z'))
+                return -1; // Not a scheme start char.
+
+            for (int i = pos + 1; i < limit; i++) {
+                char c = input.charAt(i);
+
+                if ((c >= 'a' && c <= 'z')
+                        || (c >= 'A' && c <= 'Z')
+                        || c == '+'
+                        || c == '-'
+                        || c == '.') {
+                    continue; // Scheme character. Keep going.
+                } else if (c == ':') {
+                    return i; // Scheme prefix!
+                } else {
+                    return -1; // Non-scheme character before the first ':'.
+                }
+            }
 
-      // Confirm that the decoded result doesn't contain any illegal characters.
-      int length = idnDecoded.length();
-      if (delimiterOffset(idnDecoded, 0, length, "\u0000\t\n\r #%/:?@[\\]") != length) {
-        return null;
-      }
+            return -1; // No ':'; doesn't start with a scheme.
+        }
 
-      return idnDecoded;
-    }
+        /**
+         * Returns the number of '/' and '\' slashes in {@code input}, starting at {@code pos}.
+         */
+        private static int slashCount(String input, int pos, int limit) {
+            int slashCount = 0;
+            while (pos < limit) {
+                char c = input.charAt(pos);
+                if (c == '\\' || c == '/') {
+                    slashCount++;
+                    pos++;
+                } else {
+                    break;
+                }
+            }
+            return slashCount;
+        }
 
-    /** Decodes an IPv6 address like 1111:2222:3333:4444:5555:6666:7777:8888 or ::1. */
-    private static InetAddress decodeIpv6(String input, int pos, int limit) {
-      byte[] address = new byte[16];
-      int b = 0;
-      int compress = -1;
-      int groupOffset = -1;
-
-      for (int i = pos; i < limit; ) {
-        if (b == address.length) return null; // Too many groups.
-
-        // Read a delimiter.
-        if (i + 2 <= limit && input.regionMatches(i, "::", 0, 2)) {
-          // Compression "::" delimiter, which is anywhere in the input, including its prefix.
-          if (compress != -1) return null; // Multiple "::" delimiters.
-          i += 2;
-          b += 2;
-          compress = b;
-          if (i == limit) break;
-        } else if (b != 0) {
-          // Group separator ":" delimiter.
-          if (input.regionMatches(i, ":", 0, 1)) {
-            i++;
-          } else if (input.regionMatches(i, ".", 0, 1)) {
-            // If we see a '.', rewind to the beginning of the previous group and parse as IPv4.
-            if (!decodeIpv4Suffix(input, groupOffset, limit, address, b - 2)) return null;
-            b += 2; // We rewound two bytes and then added four.
-            break;
-          } else {
-            return null; // Wrong delimiter.
-          }
+        /**
+         * Finds the first ':' in {@code input}, skipping characters between square braces "[...]".
+         */
+        private static int portColonOffset(String input, int pos, int limit) {
+            for (int i = pos; i < limit; i++) {
+                switch (input.charAt(i)) {
+                    case '[':
+                        while (++i < limit) {
+                            if (input.charAt(i) == ']') break;
+                        }
+                        break;
+                    case ':':
+                        return i;
+                }
+            }
+            return limit; // No colon.
         }
 
-        // Read a group, one to four hex digits.
-        int value = 0;
-        groupOffset = i;
-        for (; i < limit; i++) {
-          char c = input.charAt(i);
-          int hexDigit = decodeHexDigit(c);
-          if (hexDigit == -1) break;
-          value = (value << 4) + hexDigit;
+        private static String canonicalizeHost(String input, int pos, int limit) {
+            // Start by percent decoding the host. The WHATWG spec suggests doing this only after we've
+            // checked for IPv6 square braces. But Chrome does it first, and that's more lenient.
+            String percentDecoded = percentDecode(input, pos, limit);
+
+            // If the input is encased in square braces "[...]", drop 'em. We have an IPv6 address.
+            if (percentDecoded.startsWith("[") && percentDecoded.endsWith("]")) {
+                InetAddress inetAddress = decodeIpv6(percentDecoded, 1, percentDecoded.length() - 1);
+                return inetAddress != null ? inetAddress.getHostAddress() : null;
+            }
+
+            // Do IDN decoding. This converts {@code ☃.net} to {@code xn--n3h.net}.
+            String idnDecoded = domainToAscii(percentDecoded);
+            if (idnDecoded == null) return null;
+
+            // Confirm that the decoded result doesn't contain any illegal characters.
+            int length = idnDecoded.length();
+            if (delimiterOffset(idnDecoded, 0, length, "\u0000\t\n\r #%/:?@[\\]") != length) {
+                return null;
+            }
+
+            return idnDecoded;
         }
-        int groupLength = i - groupOffset;
-        if (groupLength == 0 || groupLength > 4) return null; // Group is the wrong size.
-
-        // We've successfully read a group. Assign its value to our byte array.
-        address[b++] = (byte) ((value >>> 8) & 0xff);
-        address[b++] = (byte) (value & 0xff);
-      }
-
-      // All done. If compression happened, we need to move bytes to the right place in the
-      // address. Here's a sample:
-      //
-      //      input: "1111:2222:3333::7777:8888"
-      //     before: { 11, 11, 22, 22, 33, 33, 00, 00, 77, 77, 88, 88, 00, 00, 00, 00  }
-      //   compress: 6
-      //          b: 10
-      //      after: { 11, 11, 22, 22, 33, 33, 00, 00, 00, 00, 00, 00, 77, 77, 88, 88 }
-      //
-      if (b != address.length) {
-        if (compress == -1) return null; // Address didn't have compression or enough groups.
-        System.arraycopy(address, compress, address, address.length - (b - compress), b - compress);
-        Arrays.fill(address, compress, compress + (address.length - b), (byte) 0);
-      }
-
-      try {
-        return InetAddress.getByAddress(address);
-      } catch (UnknownHostException e) {
-        throw new AssertionError();
-      }
-    }
 
-    /** Decodes an IPv4 address suffix of an IPv6 address, like 1111::5555:6666:192.168.0.1. */
-    private static boolean decodeIpv4Suffix(
-        String input, int pos, int limit, byte[] address, int addressOffset) {
-      int b = addressOffset;
+        /**
+         * Decodes an IPv6 address like 1111:2222:3333:4444:5555:6666:7777:8888 or ::1.
+         */
+        private static InetAddress decodeIpv6(String input, int pos, int limit) {
+            byte[] address = new byte[16];
+            int b = 0;
+            int compress = -1;
+            int groupOffset = -1;
+
+            for (int i = pos; i < limit; ) {
+                if (b == address.length) return null; // Too many groups.
+
+                // Read a delimiter.
+                if (i + 2 <= limit && input.regionMatches(i, "::", 0, 2)) {
+                    // Compression "::" delimiter, which is anywhere in the input, including its prefix.
+                    if (compress != -1) return null; // Multiple "::" delimiters.
+                    i += 2;
+                    b += 2;
+                    compress = b;
+                    if (i == limit) break;
+                } else if (b != 0) {
+                    // Group separator ":" delimiter.
+                    if (input.regionMatches(i, ":", 0, 1)) {
+                        i++;
+                    } else if (input.regionMatches(i, ".", 0, 1)) {
+                        // If we see a '.', rewind to the beginning of the previous group and parse as IPv4.
+                        if (!decodeIpv4Suffix(input, groupOffset, limit, address, b - 2))
+                            return null;
+                        b += 2; // We rewound two bytes and then added four.
+                        break;
+                    } else {
+                        return null; // Wrong delimiter.
+                    }
+                }
 
-      for (int i = pos; i < limit; ) {
-        if (b == address.length) return false; // Too many groups.
+                // Read a group, one to four hex digits.
+                int value = 0;
+                groupOffset = i;
+                for (; i < limit; i++) {
+                    char c = input.charAt(i);
+                    int hexDigit = decodeHexDigit(c);
+                    if (hexDigit == -1) break;
+                    value = (value << 4) + hexDigit;
+                }
+                int groupLength = i - groupOffset;
+                if (groupLength == 0 || groupLength > 4) return null; // Group is the wrong size.
 
-        // Read a delimiter.
-        if (b != addressOffset) {
-          if (input.charAt(i) != '.') return false; // Wrong delimiter.
-          i++;
+                // We've successfully read a group. Assign its value to our byte array.
+                address[b++] = (byte) ((value >>> 8) & 0xff);
+                address[b++] = (byte) (value & 0xff);
+            }
+
+            // All done. If compression happened, we need to move bytes to the right place in the
+            // address. Here's a sample:
+            //
+            //      input: "1111:2222:3333::7777:8888"
+            //     before: { 11, 11, 22, 22, 33, 33, 00, 00, 77, 77, 88, 88, 00, 00, 00, 00  }
+            //   compress: 6
+            //          b: 10
+            //      after: { 11, 11, 22, 22, 33, 33, 00, 00, 00, 00, 00, 00, 77, 77, 88, 88 }
+            //
+            if (b != address.length) {
+                if (compress == -1)
+                    return null; // Address didn't have compression or enough groups.
+                System.arraycopy(address, compress, address, address.length - (b - compress), b - compress);
+                Arrays.fill(address, compress, compress + (address.length - b), (byte) 0);
+            }
+
+            try {
+                return InetAddress.getByAddress(address);
+            } catch (UnknownHostException e) {
+                throw new AssertionError();
+            }
         }
 
-        // Read 1 or more decimal digits for a value in 0..255.
-        int value = 0;
-        int groupOffset = i;
-        for (; i < limit; i++) {
-          char c = input.charAt(i);
-          if (c < '0' || c > '9') break;
-          if (value == 0 && groupOffset != i) return false; // Reject unnecessary leading '0's.
-          value = (value * 10) + c - '0';
-          if (value > 255) return false; // Value out of range.
+        /**
+         * Decodes an IPv4 address suffix of an IPv6 address, like 1111::5555:6666:192.168.0.1.
+         */
+        private static boolean decodeIpv4Suffix(
+                String input, int pos, int limit, byte[] address, int addressOffset) {
+            int b = addressOffset;
+
+            for (int i = pos; i < limit; ) {
+                if (b == address.length) return false; // Too many groups.
+
+                // Read a delimiter.
+                if (b != addressOffset) {
+                    if (input.charAt(i) != '.') return false; // Wrong delimiter.
+                    i++;
+                }
+
+                // Read 1 or more decimal digits for a value in 0..255.
+                int value = 0;
+                int groupOffset = i;
+                for (; i < limit; i++) {
+                    char c = input.charAt(i);
+                    if (c < '0' || c > '9') break;
+                    if (value == 0 && groupOffset != i)
+                        return false; // Reject unnecessary leading '0's.
+                    value = (value * 10) + c - '0';
+                    if (value > 255) return false; // Value out of range.
+                }
+                int groupLength = i - groupOffset;
+                if (groupLength == 0) return false; // No digits.
+
+                // We've successfully read a byte.
+                address[b++] = (byte) value;
+            }
+
+            if (b != addressOffset + 4) return false; // Too few groups. We wanted exactly four.
+            return true; // Success.
         }
-        int groupLength = i - groupOffset;
-        if (groupLength == 0) return false; // No digits.
 
-        // We've successfully read a byte.
-        address[b++] = (byte) value;
-      }
+        private static String domainToAscii(String input) {
+            try {
+                String result = IDN.toASCII(input).toLowerCase(Locale.US);
+                if (result.isEmpty()) return null;
+                // TODO: implement all label limits.
+                return result;
+            } catch (IllegalArgumentException e) {
+                return null;
+            }
+        }
 
-      if (b != addressOffset + 4) return false; // Too few groups. We wanted exactly four.
-      return true; // Success.
+        private static int parsePort(String input, int pos, int limit) {
+            try {
+                // Canonicalize the port string to skip '\n' etc.
+                String portString = canonicalize(input, pos, limit, "", false, false);
+                int i = Integer.parseInt(portString);
+                if (i > 0 && i <= 65535) return i;
+                return -1;
+            } catch (NumberFormatException e) {
+                return -1; // Invalid port.
+            }
+        }
     }
 
-    private static String domainToAscii(String input) {
-      try {
-        String result = IDN.toASCII(input).toLowerCase(Locale.US);
-        if (result.isEmpty()) return null;
-        // TODO: implement all label limits.
-        return result;
-      } catch (IllegalArgumentException e) {
-        return null;
-      }
+    /**
+     * Returns the index of the first character in {@code input} that contains a character in {@code
+     * delimiters}. Returns limit if there is no such character.
+     */
+    private static int delimiterOffset(String input, int pos, int limit, String delimiters) {
+        for (int i = pos; i < limit; i++) {
+            if (delimiters.indexOf(input.charAt(i)) != -1) return i;
+        }
+        return limit;
     }
 
-    private static int parsePort(String input, int pos, int limit) {
-      try {
-        // Canonicalize the port string to skip '\n' etc.
-        String portString = canonicalize(input, pos, limit, "", false, false);
-        int i = Integer.parseInt(portString);
-        if (i > 0 && i <= 65535) return i;
-        return -1;
-      } catch (NumberFormatException e) {
-        return -1; // Invalid port.
-      }
+    static String percentDecode(String encoded) {
+        return percentDecode(encoded, 0, encoded.length());
     }
-  }
-
-  /**
-   * Returns the index of the first character in {@code input} that contains a character in {@code
-   * delimiters}. Returns limit if there is no such character.
-   */
-  private static int delimiterOffset(String input, int pos, int limit, String delimiters) {
-    for (int i = pos; i < limit; i++) {
-      if (delimiters.indexOf(input.charAt(i)) != -1) return i;
+
+    private List<String> percentDecode(List<String> list) {
+        List<String> result = new ArrayList<>(list.size());
+        for (String s : list) {
+            result.add(s != null ? percentDecode(s) : null);
+        }
+        return Collections.unmodifiableList(result);
     }
-    return limit;
-  }
 
-  static String percentDecode(String encoded) {
-    return percentDecode(encoded, 0, encoded.length());
-  }
+    static String percentDecode(String encoded, int pos, int limit) {
+        for (int i = pos; i < limit; i++) {
+            char c = encoded.charAt(i);
+            if (c == '%') {
+                // Slow path: the character at i requires decoding!
+                Buffer out = new Buffer();
+                out.writeUtf8(encoded, pos, i);
+                percentDecode(out, encoded, i, limit);
+                return out.readUtf8();
+            }
+        }
 
-  private List<String> percentDecode(List<String> list) {
-    List<String> result = new ArrayList<>(list.size());
-    for (String s : list) {
-      result.add(s != null ? percentDecode(s) : null);
-    }
-    return Collections.unmodifiableList(result);
-  }
-
-  static String percentDecode(String encoded, int pos, int limit) {
-    for (int i = pos; i < limit; i++) {
-      char c = encoded.charAt(i);
-      if (c == '%') {
-        // Slow path: the character at i requires decoding!
-        Buffer out = new Buffer();
-        out.writeUtf8(encoded, pos, i);
-        percentDecode(out, encoded, i, limit);
-        return out.readUtf8();
-      }
+        // Fast path: no characters in [pos..limit) required decoding.
+        return encoded.substring(pos, limit);
     }
 
-    // Fast path: no characters in [pos..limit) required decoding.
-    return encoded.substring(pos, limit);
-  }
-
-  static void percentDecode(Buffer out, String encoded, int pos, int limit) {
-    int codePoint;
-    for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
-      codePoint = encoded.codePointAt(i);
-      if (codePoint == '%' && i + 2 < limit) {
-        int d1 = decodeHexDigit(encoded.charAt(i + 1));
-        int d2 = decodeHexDigit(encoded.charAt(i + 2));
-        if (d1 != -1 && d2 != -1) {
-          out.writeByte((d1 << 4) + d2);
-          i += 2;
-          continue;
+    static void percentDecode(Buffer out, String encoded, int pos, int limit) {
+        int codePoint;
+        for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
+            codePoint = encoded.codePointAt(i);
+            if (codePoint == '%' && i + 2 < limit) {
+                int d1 = decodeHexDigit(encoded.charAt(i + 1));
+                int d2 = decodeHexDigit(encoded.charAt(i + 2));
+                if (d1 != -1 && d2 != -1) {
+                    out.writeByte((d1 << 4) + d2);
+                    i += 2;
+                    continue;
+                }
+            }
+            out.writeUtf8CodePoint(codePoint);
         }
-      }
-      out.writeUtf8CodePoint(codePoint);
     }
-  }
-
-  static int decodeHexDigit(char c) {
-    if (c >= '0' && c <= '9') return c - '0';
-    if (c >= 'a' && c <= 'f') return c - 'a' + 10;
-    if (c >= 'A' && c <= 'F') return c - 'A' + 10;
-    return -1;
-  }
-
-  /**
-   * Returns a substring of {@code input} on the range {@code [pos..limit)} with the following
-   * transformations:
-   * <ul>
-   *   <li>Tabs, newlines, form feeds and carriage returns are skipped.
-   *   <li>In queries, ' ' is encoded to '+' and '+' is encoded to "%2B".
-   *   <li>Characters in {@code encodeSet} are percent-encoded.
-   *   <li>Control characters and non-ASCII characters are percent-encoded.
-   *   <li>All other characters are copied without transformation.
-   * </ul>
-   *
-   * @param alreadyEncoded true to leave '%' as-is; false to convert it to '%25'.
-   * @param query true if to encode ' ' as '+', and '+' as "%2B".
-   */
-  static String canonicalize(String input, int pos, int limit, String encodeSet,
-      boolean alreadyEncoded, boolean query) {
-    int codePoint;
-    for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
-      codePoint = input.codePointAt(i);
-      if (codePoint < 0x20
-          || codePoint >= 0x7f
-          || encodeSet.indexOf(codePoint) != -1
-          || (codePoint == '%' && !alreadyEncoded)
-          || (query && codePoint == '+')) {
-        // Slow path: the character at i requires encoding!
-        Buffer out = new Buffer();
-        out.writeUtf8(input, pos, i);
-        canonicalize(out, input, i, limit, encodeSet, alreadyEncoded, query);
-        return out.readUtf8();
-      }
+
+    static int decodeHexDigit(char c) {
+        if (c >= '0' && c <= '9') return c - '0';
+        if (c >= 'a' && c <= 'f') return c - 'a' + 10;
+        if (c >= 'A' && c <= 'F') return c - 'A' + 10;
+        return -1;
     }
 
-    // Fast path: no characters in [pos..limit) required encoding.
-    return input.substring(pos, limit);
-  }
-
-  static void canonicalize(Buffer out, String input, int pos, int limit,
-      String encodeSet, boolean alreadyEncoded, boolean query) {
-    Buffer utf8Buffer = null; // Lazily allocated.
-    int codePoint;
-    for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
-      codePoint = input.codePointAt(i);
-      if (alreadyEncoded
-          && (codePoint == '\t' || codePoint == '\n' || codePoint == '\f' || codePoint == '\r')) {
-        // Skip this character.
-      } else if (query && codePoint == '+') {
-        // HTML permits space to be encoded as '+'. We use '%20' to avoid special cases.
-        out.writeUtf8(alreadyEncoded ? "%20" : "%2B");
-      } else if (codePoint < 0x20
-          || codePoint >= 0x7f
-          || encodeSet.indexOf(codePoint) != -1
-          || (codePoint == '%' && !alreadyEncoded)) {
-        // Percent encode this character.
-        if (utf8Buffer == null) {
-          utf8Buffer = new Buffer();
+    /**
+     * Returns a substring of {@code input} on the range {@code [pos..limit)} with the following
+     * transformations:
+     * <ul>
+     * <li>Tabs, newlines, form feeds and carriage returns are skipped.
+     * <li>In queries, ' ' is encoded to '+' and '+' is encoded to "%2B".
+     * <li>Characters in {@code encodeSet} are percent-encoded.
+     * <li>Control characters and non-ASCII characters are percent-encoded.
+     * <li>All other characters are copied without transformation.
+     * </ul>
+     *
+     * @param alreadyEncoded true to leave '%' as-is; false to convert it to '%25'.
+     * @param query          true if to encode ' ' as '+', and '+' as "%2B".
+     */
+    static String canonicalize(String input, int pos, int limit, String encodeSet,
+                               boolean alreadyEncoded, boolean query) {
+        int codePoint;
+        for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
+            codePoint = input.codePointAt(i);
+            if (codePoint < 0x20
+                    || codePoint >= 0x7f
+                    || encodeSet.indexOf(codePoint) != -1
+                    || (codePoint == '%' && !alreadyEncoded)
+                    || (query && codePoint == '+')) {
+                // Slow path: the character at i requires encoding!
+                Buffer out = new Buffer();
+                out.writeUtf8(input, pos, i);
+                canonicalize(out, input, i, limit, encodeSet, alreadyEncoded, query);
+                return out.readUtf8();
+            }
         }
-        utf8Buffer.writeUtf8CodePoint(codePoint);
-        while (!utf8Buffer.exhausted()) {
-          int b = utf8Buffer.readByte() & 0xff;
-          out.writeByte('%');
-          out.writeByte(HEX_DIGITS[(b >> 4) & 0xf]);
-          out.writeByte(HEX_DIGITS[b & 0xf]);
+
+        // Fast path: no characters in [pos..limit) required encoding.
+        return input.substring(pos, limit);
+    }
+
+    static void canonicalize(Buffer out, String input, int pos, int limit,
+                             String encodeSet, boolean alreadyEncoded, boolean query) {
+        Buffer utf8Buffer = null; // Lazily allocated.
+        int codePoint;
+        for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
+            codePoint = input.codePointAt(i);
+            if (alreadyEncoded
+                    && (codePoint == '\t' || codePoint == '\n' || codePoint == '\f' || codePoint == '\r')) {
+                // Skip this character.
+            } else if (query && codePoint == '+') {
+                // HTML permits space to be encoded as '+'. We use '%20' to avoid special cases.
+                out.writeUtf8(alreadyEncoded ? "%20" : "%2B");
+            } else if (codePoint < 0x20
+                    || codePoint >= 0x7f
+                    || encodeSet.indexOf(codePoint) != -1
+                    || (codePoint == '%' && !alreadyEncoded)) {
+                // Percent encode this character.
+                if (utf8Buffer == null) {
+                    utf8Buffer = new Buffer();
+                }
+                utf8Buffer.writeUtf8CodePoint(codePoint);
+                while (!utf8Buffer.exhausted()) {
+                    int b = utf8Buffer.readByte() & 0xff;
+                    out.writeByte('%');
+                    out.writeByte(HEX_DIGITS[(b >> 4) & 0xf]);
+                    out.writeByte(HEX_DIGITS[b & 0xf]);
+                }
+            } else {
+                // This character doesn't need encoding. Just copy it over.
+                out.writeUtf8CodePoint(codePoint);
+            }
         }
-      } else {
-        // This character doesn't need encoding. Just copy it over.
-        out.writeUtf8CodePoint(codePoint);
-      }
     }
-  }
 
-  static String canonicalize(
-      String input, String encodeSet, boolean alreadyEncoded, boolean query) {
-    return canonicalize(input, 0, input.length(), encodeSet, alreadyEncoded, query);
-  }
+    static String canonicalize(
+            String input, String encodeSet, boolean alreadyEncoded, boolean query) {
+        return canonicalize(input, 0, input.length(), encodeSet, alreadyEncoded, query);
+    }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Interceptor.java b/okhttp/src/main/java/com/squareup/okhttp/Interceptor.java
index 03325be973..2dd71e8b4e 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Interceptor.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Interceptor.java
@@ -23,11 +23,13 @@
  * on the request or response.
  */
 public interface Interceptor {
-  Response intercept(Chain chain) throws IOException;
+    Response intercept(Chain chain) throws IOException;
 
-  interface Chain {
-    Request request();
-    Response proceed(Request request) throws IOException;
-    Connection connection();
-  }
+    interface Chain {
+        Request request();
+
+        Response proceed(Request request) throws IOException;
+
+        Connection connection();
+    }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/MediaType.java b/okhttp/src/main/java/com/squareup/okhttp/MediaType.java
index 4d2f1fcf44..5526fe70d4 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/MediaType.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/MediaType.java
@@ -25,99 +25,102 @@
  * appropriate to describe the content type of an HTTP request or response body.
  */
 public final class MediaType {
-  private static final String TOKEN = "([a-zA-Z0-9-!#$%&'*+.^_`{|}~]+)";
-  private static final String QUOTED = "\"([^\"]*)\"";
-  private static final Pattern TYPE_SUBTYPE = Pattern.compile(TOKEN + "/" + TOKEN);
-  private static final Pattern PARAMETER = Pattern.compile(
-      ";\\s*(?:" + TOKEN + "=(?:" + TOKEN + "|" + QUOTED + "))?");
+    private static final String TOKEN = "([a-zA-Z0-9-!#$%&'*+.^_`{|}~]+)";
+    private static final String QUOTED = "\"([^\"]*)\"";
+    private static final Pattern TYPE_SUBTYPE = Pattern.compile(TOKEN + "/" + TOKEN);
+    private static final Pattern PARAMETER = Pattern.compile(
+            ";\\s*(?:" + TOKEN + "=(?:" + TOKEN + "|" + QUOTED + "))?");
 
-  private final String mediaType;
-  private final String type;
-  private final String subtype;
-  private final String charset;
+    private final String mediaType;
+    private final String type;
+    private final String subtype;
+    private final String charset;
 
-  private MediaType(String mediaType, String type, String subtype, String charset) {
-    this.mediaType = mediaType;
-    this.type = type;
-    this.subtype = subtype;
-    this.charset = charset;
-  }
+    private MediaType(String mediaType, String type, String subtype, String charset) {
+        this.mediaType = mediaType;
+        this.type = type;
+        this.subtype = subtype;
+        this.charset = charset;
+    }
 
-  /**
-   * Returns a media type for {@code string}, or null if {@code string} is not a
-   * well-formed media type.
-   */
-  public static MediaType parse(String string) {
-    Matcher typeSubtype = TYPE_SUBTYPE.matcher(string);
-    if (!typeSubtype.lookingAt()) return null;
-    String type = typeSubtype.group(1).toLowerCase(Locale.US);
-    String subtype = typeSubtype.group(2).toLowerCase(Locale.US);
+    /**
+     * Returns a media type for {@code string}, or null if {@code string} is not a
+     * well-formed media type.
+     */
+    public static MediaType parse(String string) {
+        Matcher typeSubtype = TYPE_SUBTYPE.matcher(string);
+        if (!typeSubtype.lookingAt()) return null;
+        String type = typeSubtype.group(1).toLowerCase(Locale.US);
+        String subtype = typeSubtype.group(2).toLowerCase(Locale.US);
 
-    String charset = null;
-    Matcher parameter = PARAMETER.matcher(string);
-    for (int s = typeSubtype.end(); s < string.length(); s = parameter.end()) {
-      parameter.region(s, string.length());
-      if (!parameter.lookingAt()) return null; // This is not a well-formed media type.
+        String charset = null;
+        Matcher parameter = PARAMETER.matcher(string);
+        for (int s = typeSubtype.end(); s < string.length(); s = parameter.end()) {
+            parameter.region(s, string.length());
+            if (!parameter.lookingAt()) return null; // This is not a well-formed media type.
 
-      String name = parameter.group(1);
-      if (name == null || !name.equalsIgnoreCase("charset")) continue;
-      String charsetParameter = parameter.group(2) != null
-          ? parameter.group(2)  // Value is a token.
-          : parameter.group(3); // Value is a quoted string.
-      if (charset != null && !charsetParameter.equalsIgnoreCase(charset)) {
-        throw new IllegalArgumentException("Multiple different charsets: " + string);
-      }
-      charset = charsetParameter;
-    }
+            String name = parameter.group(1);
+            if (name == null || !name.equalsIgnoreCase("charset")) continue;
+            String charsetParameter = parameter.group(2) != null
+                    ? parameter.group(2)  // Value is a token.
+                    : parameter.group(3); // Value is a quoted string.
+            if (charset != null && !charsetParameter.equalsIgnoreCase(charset)) {
+                throw new IllegalArgumentException("Multiple different charsets: " + string);
+            }
+            charset = charsetParameter;
+        }
 
-    return new MediaType(string, type, subtype, charset);
-  }
+        return new MediaType(string, type, subtype, charset);
+    }
 
-  /**
-   * Returns the high-level media type, such as "text", "image", "audio",
-   * "video", or "application".
-   */
-  public String type() {
-    return type;
-  }
+    /**
+     * Returns the high-level media type, such as "text", "image", "audio",
+     * "video", or "application".
+     */
+    public String type() {
+        return type;
+    }
 
-  /**
-   * Returns a specific media subtype, such as "plain" or "png", "mpeg",
-   * "mp4" or "xml".
-   */
-  public String subtype() {
-    return subtype;
-  }
+    /**
+     * Returns a specific media subtype, such as "plain" or "png", "mpeg",
+     * "mp4" or "xml".
+     */
+    public String subtype() {
+        return subtype;
+    }
 
-  /**
-   * Returns the charset of this media type, or null if this media type doesn't
-   * specify a charset.
-   */
-  public Charset charset() {
-    return charset != null ? Charset.forName(charset) : null;
-  }
+    /**
+     * Returns the charset of this media type, or null if this media type doesn't
+     * specify a charset.
+     */
+    public Charset charset() {
+        return charset != null ? Charset.forName(charset) : null;
+    }
 
-  /**
-   * Returns the charset of this media type, or {@code defaultValue} if this
-   * media type doesn't specify a charset.
-   */
-  public Charset charset(Charset defaultValue) {
-    return charset != null ? Charset.forName(charset) : defaultValue;
-  }
+    /**
+     * Returns the charset of this media type, or {@code defaultValue} if this
+     * media type doesn't specify a charset.
+     */
+    public Charset charset(Charset defaultValue) {
+        return charset != null ? Charset.forName(charset) : defaultValue;
+    }
 
-  /**
-   * Returns the encoded media type, like "text/plain; charset=utf-8",
-   * appropriate for use in a Content-Type header.
-   */
-  @Override public String toString() {
-    return mediaType;
-  }
+    /**
+     * Returns the encoded media type, like "text/plain; charset=utf-8",
+     * appropriate for use in a Content-Type header.
+     */
+    @Override
+    public String toString() {
+        return mediaType;
+    }
 
-  @Override public boolean equals(Object o) {
-    return o instanceof MediaType && ((MediaType) o).mediaType.equals(mediaType);
-  }
+    @Override
+    public boolean equals(Object o) {
+        return o instanceof MediaType && ((MediaType) o).mediaType.equals(mediaType);
+    }
 
-  @Override public int hashCode() {
-    return mediaType.hashCode();
-  }
+    @Override
+    public int hashCode() {
+        return mediaType.hashCode();
+    }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/MultipartBuilder.java b/okhttp/src/main/java/com/squareup/okhttp/MultipartBuilder.java
index 5b160b6741..0dc4623e37 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/MultipartBuilder.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/MultipartBuilder.java
@@ -16,10 +16,12 @@
 package com.squareup.okhttp;
 
 import com.squareup.okhttp.internal.Util;
+
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.UUID;
+
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.ByteString;
@@ -29,272 +31,287 @@
  * 2387</a>-compliant request bodies.
  */
 public final class MultipartBuilder {
-  /**
-   * The "mixed" subtype of "multipart" is intended for use when the body
-   * parts are independent and need to be bundled in a particular order. Any
-   * "multipart" subtypes that an implementation does not recognize must be
-   * treated as being of subtype "mixed".
-   */
-  public static final MediaType MIXED = MediaType.parse("multipart/mixed");
-
-  /**
-   * The "multipart/alternative" type is syntactically identical to
-   * "multipart/mixed", but the semantics are different. In particular, each
-   * of the body parts is an "alternative" version of the same information.
-   */
-  public static final MediaType ALTERNATIVE = MediaType.parse("multipart/alternative");
-
-  /**
-   * This type is syntactically identical to "multipart/mixed", but the
-   * semantics are different. In particular, in a digest, the default {@code
-   * Content-Type} value for a body part is changed from "text/plain" to
-   * "message/rfc822".
-   */
-  public static final MediaType DIGEST = MediaType.parse("multipart/digest");
-
-  /**
-   * This type is syntactically identical to "multipart/mixed", but the
-   * semantics are different. In particular, in a parallel entity, the order
-   * of body parts is not significant.
-   */
-  public static final MediaType PARALLEL = MediaType.parse("multipart/parallel");
-
-  /**
-   * The media-type multipart/form-data follows the rules of all multipart
-   * MIME data streams as outlined in RFC 2046. In forms, there are a series
-   * of fields to be supplied by the user who fills out the form. Each field
-   * has a name. Within a given form, the names are unique.
-   */
-  public static final MediaType FORM = MediaType.parse("multipart/form-data");
-
-  private static final byte[] COLONSPACE = { ':', ' ' };
-  private static final byte[] CRLF = { '\r', '\n' };
-  private static final byte[] DASHDASH = { '-', '-' };
-
-  private final ByteString boundary;
-  private MediaType type = MIXED;
-
-  // Parallel lists of nullable headers and non-null bodies.
-  private final List<Headers> partHeaders = new ArrayList<>();
-  private final List<RequestBody> partBodies = new ArrayList<>();
-
-  /** Creates a new multipart builder that uses a random boundary token. */
-  public MultipartBuilder() {
-    this(UUID.randomUUID().toString());
-  }
-
-  /**
-   * Creates a new multipart builder that uses {@code boundary} to separate
-   * parts. Prefer the no-argument constructor to defend against injection
-   * attacks.
-   */
-  public MultipartBuilder(String boundary) {
-    this.boundary = ByteString.encodeUtf8(boundary);
-  }
-
-  /**
-   * Set the MIME type. Expected values for {@code type} are {@link #MIXED} (the
-   * default), {@link #ALTERNATIVE}, {@link #DIGEST}, {@link #PARALLEL} and
-   * {@link #FORM}.
-   */
-  public MultipartBuilder type(MediaType type) {
-    if (type == null) {
-      throw new NullPointerException("type == null");
-    }
-    if (!type.type().equals("multipart")) {
-      throw new IllegalArgumentException("multipart != " + type);
-    }
-    this.type = type;
-    return this;
-  }
-
-  /** Add a part to the body. */
-  public MultipartBuilder addPart(RequestBody body) {
-    return addPart(null, body);
-  }
-
-  /** Add a part to the body. */
-  public MultipartBuilder addPart(Headers headers, RequestBody body) {
-    if (body == null) {
-      throw new NullPointerException("body == null");
-    }
-    if (headers != null && headers.get("Content-Type") != null) {
-      throw new IllegalArgumentException("Unexpected header: Content-Type");
-    }
-    if (headers != null && headers.get("Content-Length") != null) {
-      throw new IllegalArgumentException("Unexpected header: Content-Length");
-    }
+    /**
+     * The "mixed" subtype of "multipart" is intended for use when the body
+     * parts are independent and need to be bundled in a particular order. Any
+     * "multipart" subtypes that an implementation does not recognize must be
+     * treated as being of subtype "mixed".
+     */
+    public static final MediaType MIXED = MediaType.parse("multipart/mixed");
 
-    partHeaders.add(headers);
-    partBodies.add(body);
-    return this;
-  }
-
-  /**
-   * Appends a quoted-string to a StringBuilder.
-   *
-   * <p>RFC 2388 is rather vague about how one should escape special characters
-   * in form-data parameters, and as it turns out Firefox and Chrome actually
-   * do rather different things, and both say in their comments that they're
-   * not really sure what the right approach is. We go with Chrome's behavior
-   * (which also experimentally seems to match what IE does), but if you
-   * actually want to have a good chance of things working, please avoid
-   * double-quotes, newlines, percent signs, and the like in your field names.
-   */
-  private static StringBuilder appendQuotedString(StringBuilder target, String key) {
-    target.append('"');
-    for (int i = 0, len = key.length(); i < len; i++) {
-      char ch = key.charAt(i);
-      switch (ch) {
-        case '\n':
-          target.append("%0A");
-          break;
-        case '\r':
-          target.append("%0D");
-          break;
-        case '"':
-          target.append("%22");
-          break;
-        default:
-          target.append(ch);
-          break;
-      }
-    }
-    target.append('"');
-    return target;
-  }
-
-  /** Add a form data part to the body. */
-  public MultipartBuilder addFormDataPart(String name, String value) {
-    return addFormDataPart(name, null, RequestBody.create(null, value));
-  }
-
-  /** Add a form data part to the body. */
-  public MultipartBuilder addFormDataPart(String name, String filename, RequestBody value) {
-    if (name == null) {
-      throw new NullPointerException("name == null");
-    }
-    StringBuilder disposition = new StringBuilder("form-data; name=");
-    appendQuotedString(disposition, name);
+    /**
+     * The "multipart/alternative" type is syntactically identical to
+     * "multipart/mixed", but the semantics are different. In particular, each
+     * of the body parts is an "alternative" version of the same information.
+     */
+    public static final MediaType ALTERNATIVE = MediaType.parse("multipart/alternative");
 
-    if (filename != null) {
-      disposition.append("; filename=");
-      appendQuotedString(disposition, filename);
-    }
+    /**
+     * This type is syntactically identical to "multipart/mixed", but the
+     * semantics are different. In particular, in a digest, the default {@code
+     * Content-Type} value for a body part is changed from "text/plain" to
+     * "message/rfc822".
+     */
+    public static final MediaType DIGEST = MediaType.parse("multipart/digest");
 
-    return addPart(Headers.of("Content-Disposition", disposition.toString()), value);
-  }
+    /**
+     * This type is syntactically identical to "multipart/mixed", but the
+     * semantics are different. In particular, in a parallel entity, the order
+     * of body parts is not significant.
+     */
+    public static final MediaType PARALLEL = MediaType.parse("multipart/parallel");
 
-  /** Assemble the specified parts into a request body. */
-  public RequestBody build() {
-    if (partHeaders.isEmpty()) {
-      throw new IllegalStateException("Multipart body must have at least one part.");
-    }
-    return new MultipartRequestBody(type, boundary, partHeaders, partBodies);
-  }
+    /**
+     * The media-type multipart/form-data follows the rules of all multipart
+     * MIME data streams as outlined in RFC 2046. In forms, there are a series
+     * of fields to be supplied by the user who fills out the form. Each field
+     * has a name. Within a given form, the names are unique.
+     */
+    public static final MediaType FORM = MediaType.parse("multipart/form-data");
+
+    private static final byte[] COLONSPACE = {':', ' '};
+    private static final byte[] CRLF = {'\r', '\n'};
+    private static final byte[] DASHDASH = {'-', '-'};
 
-  private static final class MultipartRequestBody extends RequestBody {
     private final ByteString boundary;
-    private final MediaType contentType;
-    private final List<Headers> partHeaders;
-    private final List<RequestBody> partBodies;
-    private long contentLength = -1L;
-
-    public MultipartRequestBody(MediaType type, ByteString boundary, List<Headers> partHeaders,
-        List<RequestBody> partBodies) {
-      if (type == null) throw new NullPointerException("type == null");
-
-      this.boundary = boundary;
-      this.contentType = MediaType.parse(type + "; boundary=" + boundary.utf8());
-      this.partHeaders = Util.immutableList(partHeaders);
-      this.partBodies = Util.immutableList(partBodies);
+    private MediaType type = MIXED;
+
+    // Parallel lists of nullable headers and non-null bodies.
+    private final List<Headers> partHeaders = new ArrayList<>();
+    private final List<RequestBody> partBodies = new ArrayList<>();
+
+    /**
+     * Creates a new multipart builder that uses a random boundary token.
+     */
+    public MultipartBuilder() {
+        this(UUID.randomUUID().toString());
     }
 
-    @Override public MediaType contentType() {
-      return contentType;
+    /**
+     * Creates a new multipart builder that uses {@code boundary} to separate
+     * parts. Prefer the no-argument constructor to defend against injection
+     * attacks.
+     */
+    public MultipartBuilder(String boundary) {
+        this.boundary = ByteString.encodeUtf8(boundary);
     }
 
-    @Override public long contentLength() throws IOException {
-      long result = contentLength;
-      if (result != -1L) return result;
-      return contentLength = writeOrCountBytes(null, true);
+    /**
+     * Set the MIME type. Expected values for {@code type} are {@link #MIXED} (the
+     * default), {@link #ALTERNATIVE}, {@link #DIGEST}, {@link #PARALLEL} and
+     * {@link #FORM}.
+     */
+    public MultipartBuilder type(MediaType type) {
+        if (type == null) {
+            throw new NullPointerException("type == null");
+        }
+        if (!type.type().equals("multipart")) {
+            throw new IllegalArgumentException("multipart != " + type);
+        }
+        this.type = type;
+        return this;
+    }
+
+    /**
+     * Add a part to the body.
+     */
+    public MultipartBuilder addPart(RequestBody body) {
+        return addPart(null, body);
     }
 
     /**
-     * Either writes this request to {@code sink} or measures its content length. We have one method
-     * do double-duty to make sure the counting and content are consistent, particularly when it
-     * comes to awkward operations like measuring the encoded length of header strings, or the
-     * length-in-digits of an encoded integer.
+     * Add a part to the body.
      */
-    private long writeOrCountBytes(BufferedSink sink, boolean countBytes) throws IOException {
-      long byteCount = 0L;
-
-      Buffer byteCountBuffer = null;
-      if (countBytes) {
-        sink = byteCountBuffer = new Buffer();
-      }
-
-      for (int p = 0, partCount = partHeaders.size(); p < partCount; p++) {
-        Headers headers = partHeaders.get(p);
-        RequestBody body = partBodies.get(p);
-
-        sink.write(DASHDASH);
-        sink.write(boundary);
-        sink.write(CRLF);
-
-        if (headers != null) {
-          for (int h = 0, headerCount = headers.size(); h < headerCount; h++) {
-            sink.writeUtf8(headers.name(h))
-                .write(COLONSPACE)
-                .writeUtf8(headers.value(h))
-                .write(CRLF);
-          }
+    public MultipartBuilder addPart(Headers headers, RequestBody body) {
+        if (body == null) {
+            throw new NullPointerException("body == null");
+        }
+        if (headers != null && headers.get("Content-Type") != null) {
+            throw new IllegalArgumentException("Unexpected header: Content-Type");
         }
+        if (headers != null && headers.get("Content-Length") != null) {
+            throw new IllegalArgumentException("Unexpected header: Content-Length");
+        }
+
+        partHeaders.add(headers);
+        partBodies.add(body);
+        return this;
+    }
+
+    /**
+     * Appends a quoted-string to a StringBuilder.
+     * <p/>
+     * <p>RFC 2388 is rather vague about how one should escape special characters
+     * in form-data parameters, and as it turns out Firefox and Chrome actually
+     * do rather different things, and both say in their comments that they're
+     * not really sure what the right approach is. We go with Chrome's behavior
+     * (which also experimentally seems to match what IE does), but if you
+     * actually want to have a good chance of things working, please avoid
+     * double-quotes, newlines, percent signs, and the like in your field names.
+     */
+    private static StringBuilder appendQuotedString(StringBuilder target, String key) {
+        target.append('"');
+        for (int i = 0, len = key.length(); i < len; i++) {
+            char ch = key.charAt(i);
+            switch (ch) {
+                case '\n':
+                    target.append("%0A");
+                    break;
+                case '\r':
+                    target.append("%0D");
+                    break;
+                case '"':
+                    target.append("%22");
+                    break;
+                default:
+                    target.append(ch);
+                    break;
+            }
+        }
+        target.append('"');
+        return target;
+    }
+
+    /**
+     * Add a form data part to the body.
+     */
+    public MultipartBuilder addFormDataPart(String name, String value) {
+        return addFormDataPart(name, null, RequestBody.create(null, value));
+    }
 
-        MediaType contentType = body.contentType();
-        if (contentType != null) {
-          sink.writeUtf8("Content-Type: ")
-              .writeUtf8(contentType.toString())
-              .write(CRLF);
+    /**
+     * Add a form data part to the body.
+     */
+    public MultipartBuilder addFormDataPart(String name, String filename, RequestBody value) {
+        if (name == null) {
+            throw new NullPointerException("name == null");
         }
+        StringBuilder disposition = new StringBuilder("form-data; name=");
+        appendQuotedString(disposition, name);
 
-        long contentLength = body.contentLength();
-        if (contentLength != -1) {
-          sink.writeUtf8("Content-Length: ")
-              .writeDecimalLong(contentLength)
-              .write(CRLF);
-        } else if (countBytes) {
-          // We can't measure the body's size without the sizes of its components.
-          byteCountBuffer.clear();
-          return -1L;
+        if (filename != null) {
+            disposition.append("; filename=");
+            appendQuotedString(disposition, filename);
         }
 
-        sink.write(CRLF);
+        return addPart(Headers.of("Content-Disposition", disposition.toString()), value);
+    }
 
-        if (countBytes) {
-          byteCount += contentLength;
-        } else {
-          partBodies.get(p).writeTo(sink);
+    /**
+     * Assemble the specified parts into a request body.
+     */
+    public RequestBody build() {
+        if (partHeaders.isEmpty()) {
+            throw new IllegalStateException("Multipart body must have at least one part.");
         }
+        return new MultipartRequestBody(type, boundary, partHeaders, partBodies);
+    }
 
-        sink.write(CRLF);
-      }
+    private static final class MultipartRequestBody extends RequestBody {
+        private final ByteString boundary;
+        private final MediaType contentType;
+        private final List<Headers> partHeaders;
+        private final List<RequestBody> partBodies;
+        private long contentLength = -1L;
+
+        public MultipartRequestBody(MediaType type, ByteString boundary, List<Headers> partHeaders,
+                                    List<RequestBody> partBodies) {
+            if (type == null) throw new NullPointerException("type == null");
+
+            this.boundary = boundary;
+            this.contentType = MediaType.parse(type + "; boundary=" + boundary.utf8());
+            this.partHeaders = Util.immutableList(partHeaders);
+            this.partBodies = Util.immutableList(partBodies);
+        }
 
-      sink.write(DASHDASH);
-      sink.write(boundary);
-      sink.write(DASHDASH);
-      sink.write(CRLF);
+        @Override
+        public MediaType contentType() {
+            return contentType;
+        }
 
-      if (countBytes) {
-        byteCount += byteCountBuffer.size();
-        byteCountBuffer.clear();
-      }
+        @Override
+        public long contentLength() throws IOException {
+            long result = contentLength;
+            if (result != -1L) return result;
+            return contentLength = writeOrCountBytes(null, true);
+        }
 
-      return byteCount;
-    }
+        /**
+         * Either writes this request to {@code sink} or measures its content length. We have one method
+         * do double-duty to make sure the counting and content are consistent, particularly when it
+         * comes to awkward operations like measuring the encoded length of header strings, or the
+         * length-in-digits of an encoded integer.
+         */
+        private long writeOrCountBytes(BufferedSink sink, boolean countBytes) throws IOException {
+            long byteCount = 0L;
+
+            Buffer byteCountBuffer = null;
+            if (countBytes) {
+                sink = byteCountBuffer = new Buffer();
+            }
+
+            for (int p = 0, partCount = partHeaders.size(); p < partCount; p++) {
+                Headers headers = partHeaders.get(p);
+                RequestBody body = partBodies.get(p);
+
+                sink.write(DASHDASH);
+                sink.write(boundary);
+                sink.write(CRLF);
+
+                if (headers != null) {
+                    for (int h = 0, headerCount = headers.size(); h < headerCount; h++) {
+                        sink.writeUtf8(headers.name(h))
+                                .write(COLONSPACE)
+                                .writeUtf8(headers.value(h))
+                                .write(CRLF);
+                    }
+                }
+
+                MediaType contentType = body.contentType();
+                if (contentType != null) {
+                    sink.writeUtf8("Content-Type: ")
+                            .writeUtf8(contentType.toString())
+                            .write(CRLF);
+                }
+
+                long contentLength = body.contentLength();
+                if (contentLength != -1) {
+                    sink.writeUtf8("Content-Length: ")
+                            .writeDecimalLong(contentLength)
+                            .write(CRLF);
+                } else if (countBytes) {
+                    // We can't measure the body's size without the sizes of its components.
+                    byteCountBuffer.clear();
+                    return -1L;
+                }
+
+                sink.write(CRLF);
+
+                if (countBytes) {
+                    byteCount += contentLength;
+                } else {
+                    partBodies.get(p).writeTo(sink);
+                }
+
+                sink.write(CRLF);
+            }
+
+            sink.write(DASHDASH);
+            sink.write(boundary);
+            sink.write(DASHDASH);
+            sink.write(CRLF);
+
+            if (countBytes) {
+                byteCount += byteCountBuffer.size();
+                byteCountBuffer.clear();
+            }
+
+            return byteCount;
+        }
 
-    @Override public void writeTo(BufferedSink sink) throws IOException {
-      writeOrCountBytes(sink, false);
+        @Override
+        public void writeTo(BufferedSink sink) throws IOException {
+            writeOrCountBytes(sink, false);
+        }
     }
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
index 1ef79b0f67..8a0eec669a 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
@@ -25,6 +25,7 @@
 import com.squareup.okhttp.internal.http.RouteException;
 import com.squareup.okhttp.internal.http.Transport;
 import com.squareup.okhttp.internal.tls.OkHostnameVerifier;
+
 import java.io.IOException;
 import java.net.CookieHandler;
 import java.net.Proxy;
@@ -34,11 +35,13 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
+
 import javax.net.SocketFactory;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
+
 import okio.BufferedSink;
 import okio.BufferedSource;
 
@@ -46,7 +49,7 @@
  * Configures and creates HTTP connections. Most applications can use a single
  * OkHttpClient for all of their HTTP requests - benefiting from a shared
  * response cache, thread pool, connection re-use, etc.
- *
+ * <p/>
  * <p>Instances of OkHttpClient are intended to be fully configured before they're
  * shared - once shared they should be treated as immutable and can safely be used
  * to concurrently open new connections. If required, threads can call
@@ -54,624 +57,662 @@
  * safely modified with further configuration changes.
  */
 public class OkHttpClient implements Cloneable {
-  private static final List<Protocol> DEFAULT_PROTOCOLS = Util.immutableList(
-      Protocol.HTTP_2, Protocol.SPDY_3, Protocol.HTTP_1_1);
-
-  private static final List<ConnectionSpec> DEFAULT_CONNECTION_SPECS = Util.immutableList(
-      ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS, ConnectionSpec.CLEARTEXT);
-
-  static {
-    Internal.instance = new Internal() {
-      @Override public Transport newTransport(
-          Connection connection, HttpEngine httpEngine) throws IOException {
-        return connection.newTransport(httpEngine);
-      }
-
-      @Override public boolean clearOwner(Connection connection) {
-        return connection.clearOwner();
-      }
-
-      @Override public void closeIfOwnedBy(Connection connection, Object owner) throws IOException {
-        connection.closeIfOwnedBy(owner);
-      }
-
-      @Override public int recycleCount(Connection connection) {
-        return connection.recycleCount();
-      }
-
-      @Override public void setProtocol(Connection connection, Protocol protocol) {
-        connection.setProtocol(protocol);
-      }
-
-      @Override public void setOwner(Connection connection, HttpEngine httpEngine) {
-        connection.setOwner(httpEngine);
-      }
-
-      @Override public boolean isReadable(Connection pooled) {
-        return pooled.isReadable();
-      }
-
-      @Override public void addLenient(Headers.Builder builder, String line) {
-        builder.addLenient(line);
-      }
-
-      @Override public void addLenient(Headers.Builder builder, String name, String value) {
-        builder.addLenient(name, value);
-      }
-
-      @Override public void setCache(OkHttpClient client, InternalCache internalCache) {
-        client.setInternalCache(internalCache);
-      }
-
-      @Override public InternalCache internalCache(OkHttpClient client) {
-        return client.internalCache();
-      }
-
-      @Override public void recycle(ConnectionPool pool, Connection connection) {
-        pool.recycle(connection);
-      }
-
-      @Override public RouteDatabase routeDatabase(OkHttpClient client) {
-        return client.routeDatabase();
-      }
-
-      @Override public Network network(OkHttpClient client) {
-        return client.network;
-      }
-
-      @Override public void setNetwork(OkHttpClient client, Network network) {
-        client.network = network;
-      }
-
-      @Override public void connectAndSetOwner(OkHttpClient client, Connection connection,
-          HttpEngine owner, Request request) throws RouteException {
-        connection.connectAndSetOwner(client, owner, request);
-      }
-
-      @Override
-      public void callEnqueue(Call call, Callback responseCallback, boolean forWebSocket) {
-        call.enqueue(responseCallback, forWebSocket);
-      }
-
-      @Override public void callEngineReleaseConnection(Call call) throws IOException {
-        call.engine.releaseConnection();
-      }
-
-      @Override public Connection callEngineGetConnection(Call call) {
-        return call.engine.getConnection();
-      }
-
-      @Override public BufferedSource connectionRawSource(Connection connection) {
-        return connection.rawSource();
-      }
-
-      @Override public BufferedSink connectionRawSink(Connection connection) {
-        return connection.rawSink();
-      }
-
-      @Override public void connectionSetOwner(Connection connection, Object owner) {
-        connection.setOwner(owner);
-      }
-
-      @Override
-      public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean isFallback) {
-        tlsConfiguration.apply(sslSocket, isFallback);
-      }
-    };
-  }
-
-  /** Lazily-initialized. */
-  private static SSLSocketFactory defaultSslSocketFactory;
-
-  private final RouteDatabase routeDatabase;
-  private Dispatcher dispatcher;
-  private Proxy proxy;
-  private List<Protocol> protocols;
-  private List<ConnectionSpec> connectionSpecs;
-  private final List<Interceptor> interceptors = new ArrayList<>();
-  private final List<Interceptor> networkInterceptors = new ArrayList<>();
-  private ProxySelector proxySelector;
-  private CookieHandler cookieHandler;
-
-  /** Non-null if this client is caching; possibly by {@code cache}. */
-  private InternalCache internalCache;
-  private Cache cache;
-
-  private SocketFactory socketFactory;
-  private SSLSocketFactory sslSocketFactory;
-  private HostnameVerifier hostnameVerifier;
-  private CertificatePinner certificatePinner;
-  private Authenticator authenticator;
-  private ConnectionPool connectionPool;
-  private Network network;
-  private boolean followSslRedirects = true;
-  private boolean followRedirects = true;
-  private boolean retryOnConnectionFailure = true;
-  private int connectTimeout = 10_000;
-  private int readTimeout = 10_000;
-  private int writeTimeout = 10_000;
-
-  public OkHttpClient() {
-    routeDatabase = new RouteDatabase();
-    dispatcher = new Dispatcher();
-  }
-
-  private OkHttpClient(OkHttpClient okHttpClient) {
-    this.routeDatabase = okHttpClient.routeDatabase;
-    this.dispatcher = okHttpClient.dispatcher;
-    this.proxy = okHttpClient.proxy;
-    this.protocols = okHttpClient.protocols;
-    this.connectionSpecs = okHttpClient.connectionSpecs;
-    this.interceptors.addAll(okHttpClient.interceptors);
-    this.networkInterceptors.addAll(okHttpClient.networkInterceptors);
-    this.proxySelector = okHttpClient.proxySelector;
-    this.cookieHandler = okHttpClient.cookieHandler;
-    this.cache = okHttpClient.cache;
-    this.internalCache = cache != null ? cache.internalCache : okHttpClient.internalCache;
-    this.socketFactory = okHttpClient.socketFactory;
-    this.sslSocketFactory = okHttpClient.sslSocketFactory;
-    this.hostnameVerifier = okHttpClient.hostnameVerifier;
-    this.certificatePinner = okHttpClient.certificatePinner;
-    this.authenticator = okHttpClient.authenticator;
-    this.connectionPool = okHttpClient.connectionPool;
-    this.network = okHttpClient.network;
-    this.followSslRedirects = okHttpClient.followSslRedirects;
-    this.followRedirects = okHttpClient.followRedirects;
-    this.retryOnConnectionFailure = okHttpClient.retryOnConnectionFailure;
-    this.connectTimeout = okHttpClient.connectTimeout;
-    this.readTimeout = okHttpClient.readTimeout;
-    this.writeTimeout = okHttpClient.writeTimeout;
-  }
-
-  /**
-   * Sets the default connect timeout for new connections. A value of 0 means no timeout, otherwise
-   * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
-   *
-   * @see URLConnection#setConnectTimeout(int)
-   */
-  public void setConnectTimeout(long timeout, TimeUnit unit) {
-    if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
-    if (unit == null) throw new IllegalArgumentException("unit == null");
-    long millis = unit.toMillis(timeout);
-    if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
-    if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
-    connectTimeout = (int) millis;
-  }
-
-  /** Default connect timeout (in milliseconds). */
-  public int getConnectTimeout() {
-    return connectTimeout;
-  }
-
-  /**
-   * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
-   * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
-   *
-   * @see URLConnection#setReadTimeout(int)
-   */
-  public void setReadTimeout(long timeout, TimeUnit unit) {
-    if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
-    if (unit == null) throw new IllegalArgumentException("unit == null");
-    long millis = unit.toMillis(timeout);
-    if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
-    if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
-    readTimeout = (int) millis;
-  }
-
-  /** Default read timeout (in milliseconds). */
-  public int getReadTimeout() {
-    return readTimeout;
-  }
-
-  /**
-   * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
-   * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
-   */
-  public void setWriteTimeout(long timeout, TimeUnit unit) {
-    if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
-    if (unit == null) throw new IllegalArgumentException("unit == null");
-    long millis = unit.toMillis(timeout);
-    if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
-    if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
-    writeTimeout = (int) millis;
-  }
-
-  /** Default write timeout (in milliseconds). */
-  public int getWriteTimeout() {
-    return writeTimeout;
-  }
-
-  /**
-   * Sets the HTTP proxy that will be used by connections created by this
-   * client. This takes precedence over {@link #setProxySelector}, which is
-   * only honored when this proxy is null (which it is by default). To disable
-   * proxy use completely, call {@code setProxy(Proxy.NO_PROXY)}.
-   */
-  public OkHttpClient setProxy(Proxy proxy) {
-    this.proxy = proxy;
-    return this;
-  }
-
-  public Proxy getProxy() {
-    return proxy;
-  }
-
-  /**
-   * Sets the proxy selection policy to be used if no {@link #setProxy proxy}
-   * is specified explicitly. The proxy selector may return multiple proxies;
-   * in that case they will be tried in sequence until a successful connection
-   * is established.
-   *
-   * <p>If unset, the {@link ProxySelector#getDefault() system-wide default}
-   * proxy selector will be used.
-   */
-  public OkHttpClient setProxySelector(ProxySelector proxySelector) {
-    this.proxySelector = proxySelector;
-    return this;
-  }
-
-  public ProxySelector getProxySelector() {
-    return proxySelector;
-  }
-
-  /**
-   * Sets the cookie handler to be used to read outgoing cookies and write
-   * incoming cookies.
-   *
-   * <p>If unset, the {@link CookieHandler#getDefault() system-wide default}
-   * cookie handler will be used.
-   */
-  public OkHttpClient setCookieHandler(CookieHandler cookieHandler) {
-    this.cookieHandler = cookieHandler;
-    return this;
-  }
-
-  public CookieHandler getCookieHandler() {
-    return cookieHandler;
-  }
-
-  /** Sets the response cache to be used to read and write cached responses. */
-  void setInternalCache(InternalCache internalCache) {
-    this.internalCache = internalCache;
-    this.cache = null;
-  }
-
-  InternalCache internalCache() {
-    return internalCache;
-  }
-
-  public OkHttpClient setCache(Cache cache) {
-    this.cache = cache;
-    this.internalCache = null;
-    return this;
-  }
-
-  public Cache getCache() {
-    return cache;
-  }
-
-  /**
-   * Sets the socket factory used to create connections. OkHttp only uses
-   * the parameterless {@link SocketFactory#createSocket() createSocket()}
-   * method to create unconnected sockets. Overriding this method,
-   * e. g., allows the socket to be bound to a specific local address.
-   *
-   * <p>If unset, the {@link SocketFactory#getDefault() system-wide default}
-   * socket factory will be used.
-   */
-  public OkHttpClient setSocketFactory(SocketFactory socketFactory) {
-    this.socketFactory = socketFactory;
-    return this;
-  }
-
-  public SocketFactory getSocketFactory() {
-    return socketFactory;
-  }
-
-  /**
-   * Sets the socket factory used to secure HTTPS connections.
-   *
-   * <p>If unset, a lazily created SSL socket factory will be used.
-   */
-  public OkHttpClient setSslSocketFactory(SSLSocketFactory sslSocketFactory) {
-    this.sslSocketFactory = sslSocketFactory;
-    return this;
-  }
-
-  public SSLSocketFactory getSslSocketFactory() {
-    return sslSocketFactory;
-  }
-
-  /**
-   * Sets the verifier used to confirm that response certificates apply to
-   * requested hostnames for HTTPS connections.
-   *
-   * <p>If unset, a default hostname verifier will be used.
-   */
-  public OkHttpClient setHostnameVerifier(HostnameVerifier hostnameVerifier) {
-    this.hostnameVerifier = hostnameVerifier;
-    return this;
-  }
-
-  public HostnameVerifier getHostnameVerifier() {
-    return hostnameVerifier;
-  }
-
-  /**
-   * Sets the certificate pinner that constrains which certificates are trusted.
-   * By default HTTPS connections rely on only the {@link #setSslSocketFactory
-   * SSL socket factory} to establish trust. Pinning certificates avoids the
-   * need to trust certificate authorities.
-   */
-  public OkHttpClient setCertificatePinner(CertificatePinner certificatePinner) {
-    this.certificatePinner = certificatePinner;
-    return this;
-  }
-
-  public CertificatePinner getCertificatePinner() {
-    return certificatePinner;
-  }
-
-  /**
-   * Sets the authenticator used to respond to challenges from the remote web
-   * server or proxy server.
-   *
-   * <p>If unset, the {@link java.net.Authenticator#setDefault system-wide default}
-   * authenticator will be used.
-   */
-  public OkHttpClient setAuthenticator(Authenticator authenticator) {
-    this.authenticator = authenticator;
-    return this;
-  }
-
-  public Authenticator getAuthenticator() {
-    return authenticator;
-  }
-
-  /**
-   * Sets the connection pool used to recycle HTTP and HTTPS connections.
-   *
-   * <p>If unset, the {@link ConnectionPool#getDefault() system-wide
-   * default} connection pool will be used.
-   */
-  public OkHttpClient setConnectionPool(ConnectionPool connectionPool) {
-    this.connectionPool = connectionPool;
-    return this;
-  }
-
-  public ConnectionPool getConnectionPool() {
-    return connectionPool;
-  }
-
-  /**
-   * Configure this client to follow redirects from HTTPS to HTTP and from HTTP
-   * to HTTPS.
-   *
-   * <p>If unset, protocol redirects will be followed. This is different than
-   * the built-in {@code HttpURLConnection}'s default.
-   */
-  public OkHttpClient setFollowSslRedirects(boolean followProtocolRedirects) {
-    this.followSslRedirects = followProtocolRedirects;
-    return this;
-  }
-
-  public boolean getFollowSslRedirects() {
-    return followSslRedirects;
-  }
-
-  /** Configure this client to follow redirects. If unset, redirects be followed. */
-  public void setFollowRedirects(boolean followRedirects) {
-    this.followRedirects = followRedirects;
-  }
-
-  public boolean getFollowRedirects() {
-    return followRedirects;
-  }
-
-  /**
-   * Configure this client to retry or not when a connectivity problem is encountered. By default,
-   * this client silently recovers from the following problems:
-   *
-   * <ul>
-   *   <li><strong>Unreachable IP addresses.</strong> If the URL's host has multiple IP addresses,
-   *       failure to reach any individual IP address doesn't fail the overall request. This can
-   *       increase availability of multi-homed services.
-   *   <li><strong>Stale pooled connections.</strong> The {@link ConnectionPool} reuses sockets
-   *       to decrease request latency, but these connections will occasionally time out.
-   *   <li><strong>Unreachable proxy servers.</strong> A {@link ProxySelector} can be used to
-   *       attempt multiple proxy servers in sequence, eventually falling back to a direct
-   *       connection.
-   * </ul>
-   *
-   * Set this to false to avoid retrying requests when doing so is destructive. In this case the
-   * calling application should do its own recovery of connectivity failures.
-   */
-  public void setRetryOnConnectionFailure(boolean retryOnConnectionFailure) {
-    this.retryOnConnectionFailure = retryOnConnectionFailure;
-  }
-
-  public boolean getRetryOnConnectionFailure() {
-    return retryOnConnectionFailure;
-  }
-
-  RouteDatabase routeDatabase() {
-    return routeDatabase;
-  }
-
-  /**
-   * Sets the dispatcher used to set policy and execute asynchronous requests.
-   * Must not be null.
-   */
-  public OkHttpClient setDispatcher(Dispatcher dispatcher) {
-    if (dispatcher == null) throw new IllegalArgumentException("dispatcher == null");
-    this.dispatcher = dispatcher;
-    return this;
-  }
-
-  public Dispatcher getDispatcher() {
-    return dispatcher;
-  }
-
-  /**
-   * Configure the protocols used by this client to communicate with remote
-   * servers. By default this client will prefer the most efficient transport
-   * available, falling back to more ubiquitous protocols. Applications should
-   * only call this method to avoid specific compatibility problems, such as web
-   * servers that behave incorrectly when SPDY is enabled.
-   *
-   * <p>The following protocols are currently supported:
-   * <ul>
-   *   <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>
-   *   <li><a href="http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1">spdy/3.1</a>
-   *   <li><a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-17">h2</a>
-   * </ul>
-   *
-   * <p><strong>This is an evolving set.</strong> Future releases include
-   * support for transitional protocols. The http/1.1 transport will never be
-   * dropped.
-   *
-   * <p>If multiple protocols are specified, <a
-   * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a>
-   * will be used to negotiate a transport.
-   *
-   * <p>{@link Protocol#HTTP_1_0} is not supported in this set. Requests are
-   * initiated with {@code HTTP/1.1} only. If the server responds with {@code
-   * HTTP/1.0}, that will be exposed by {@link Response#protocol()}.
-   *
-   * @param protocols the protocols to use, in order of preference. The list
-   *     must contain {@link Protocol#HTTP_1_1}. It must not contain null or
-   *     {@link Protocol#HTTP_1_0}.
-   */
-  public OkHttpClient setProtocols(List<Protocol> protocols) {
-    protocols = Util.immutableList(protocols);
-    if (!protocols.contains(Protocol.HTTP_1_1)) {
-      throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
-    }
-    if (protocols.contains(Protocol.HTTP_1_0)) {
-      throw new IllegalArgumentException("protocols must not contain http/1.0: " + protocols);
-    }
-    if (protocols.contains(null)) {
-      throw new IllegalArgumentException("protocols must not contain null");
-    }
-    this.protocols = Util.immutableList(protocols);
-    return this;
-  }
-
-  public List<Protocol> getProtocols() {
-    return protocols;
-  }
-
-  public OkHttpClient setConnectionSpecs(List<ConnectionSpec> connectionSpecs) {
-    this.connectionSpecs = Util.immutableList(connectionSpecs);
-    return this;
-  }
-
-  public List<ConnectionSpec> getConnectionSpecs() {
-    return connectionSpecs;
-  }
-
-  /**
-   * Returns a modifiable list of interceptors that observe the full span of each call: from before
-   * the connection is established (if any) until after the response source is selected (either the
-   * origin server, cache, or both).
-   */
-  public List<Interceptor> interceptors() {
-    return interceptors;
-  }
-
-  /**
-   * Returns a modifiable list of interceptors that observe a single network request and response.
-   * These interceptors must call {@link Interceptor.Chain#proceed} exactly once: it is an error for
-   * a network interceptor to short-circuit or repeat a network request.
-   */
-  public List<Interceptor> networkInterceptors() {
-    return networkInterceptors;
-  }
-
-  /**
-   * Prepares the {@code request} to be executed at some point in the future.
-   */
-  public Call newCall(Request request) {
-    return new Call(this, request);
-  }
-
-  /**
-   * Cancels all scheduled or in-flight calls tagged with {@code tag}. Requests
-   * that are already complete cannot be canceled.
-   */
-  public OkHttpClient cancel(Object tag) {
-    getDispatcher().cancel(tag);
-    return this;
-  }
-
-  /**
-   * Returns a shallow copy of this OkHttpClient that uses the system-wide
-   * default for each field that hasn't been explicitly configured.
-   */
-  OkHttpClient copyWithDefaults() {
-    OkHttpClient result = new OkHttpClient(this);
-    if (result.proxySelector == null) {
-      result.proxySelector = ProxySelector.getDefault();
-    }
-    if (result.cookieHandler == null) {
-      result.cookieHandler = CookieHandler.getDefault();
-    }
-    if (result.socketFactory == null) {
-      result.socketFactory = SocketFactory.getDefault();
-    }
-    if (result.sslSocketFactory == null) {
-      result.sslSocketFactory = getDefaultSSLSocketFactory();
-    }
-    if (result.hostnameVerifier == null) {
-      result.hostnameVerifier = OkHostnameVerifier.INSTANCE;
-    }
-    if (result.certificatePinner == null) {
-      result.certificatePinner = CertificatePinner.DEFAULT;
-    }
-    if (result.authenticator == null) {
-      result.authenticator = AuthenticatorAdapter.INSTANCE;
-    }
-    if (result.connectionPool == null) {
-      result.connectionPool = ConnectionPool.getDefault();
-    }
-    if (result.protocols == null) {
-      result.protocols = DEFAULT_PROTOCOLS;
-    }
-    if (result.connectionSpecs == null) {
-      result.connectionSpecs = DEFAULT_CONNECTION_SPECS;
-    }
-    if (result.network == null) {
-      result.network = Network.DEFAULT;
-    }
-    return result;
-  }
-
-  /**
-   * Java and Android programs default to using a single global SSL context,
-   * accessible to HTTP clients as {@link SSLSocketFactory#getDefault()}. If we
-   * used the shared SSL context, when OkHttp enables ALPN for its SPDY-related
-   * stuff, it would also enable ALPN for other usages, which might crash them
-   * because ALPN is enabled when it isn't expected to be.
-   *
-   * <p>This code avoids that by defaulting to an OkHttp-created SSL context.
-   * The drawback of this approach is that apps that customize the global SSL
-   * context will lose these customizations.
-   */
-  private synchronized SSLSocketFactory getDefaultSSLSocketFactory() {
-    if (defaultSslSocketFactory == null) {
-      try {
-        SSLContext sslContext = SSLContext.getInstance("TLS");
-        sslContext.init(null, null, null);
-        defaultSslSocketFactory = sslContext.getSocketFactory();
-      } catch (GeneralSecurityException e) {
-        throw new AssertionError(); // The system has no TLS. Just give up.
-      }
-    }
-    return defaultSslSocketFactory;
-  }
-
-  /** Returns a shallow copy of this OkHttpClient. */
-  @Override public OkHttpClient clone() {
-    return new OkHttpClient(this);
-  }
+    private static final List<Protocol> DEFAULT_PROTOCOLS = Util.immutableList(
+            Protocol.HTTP_2, Protocol.SPDY_3, Protocol.HTTP_1_1);
+
+    private static final List<ConnectionSpec> DEFAULT_CONNECTION_SPECS = Util.immutableList(
+            ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS, ConnectionSpec.CLEARTEXT);
+
+    static {
+        Internal.instance = new Internal() {
+            @Override
+            public Transport newTransport(
+                    Connection connection, HttpEngine httpEngine) throws IOException {
+                return connection.newTransport(httpEngine);
+            }
+
+            @Override
+            public boolean clearOwner(Connection connection) {
+                return connection.clearOwner();
+            }
+
+            @Override
+            public void closeIfOwnedBy(Connection connection, Object owner) throws IOException {
+                connection.closeIfOwnedBy(owner);
+            }
+
+            @Override
+            public int recycleCount(Connection connection) {
+                return connection.recycleCount();
+            }
+
+            @Override
+            public void setProtocol(Connection connection, Protocol protocol) {
+                connection.setProtocol(protocol);
+            }
+
+            @Override
+            public void setOwner(Connection connection, HttpEngine httpEngine) {
+                connection.setOwner(httpEngine);
+            }
+
+            @Override
+            public boolean isReadable(Connection pooled) {
+                return pooled.isReadable();
+            }
+
+            @Override
+            public void addLenient(Headers.Builder builder, String line) {
+                builder.addLenient(line);
+            }
+
+            @Override
+            public void addLenient(Headers.Builder builder, String name, String value) {
+                builder.addLenient(name, value);
+            }
+
+            @Override
+            public void setCache(OkHttpClient client, InternalCache internalCache) {
+                client.setInternalCache(internalCache);
+            }
+
+            @Override
+            public InternalCache internalCache(OkHttpClient client) {
+                return client.internalCache();
+            }
+
+            @Override
+            public void recycle(ConnectionPool pool, Connection connection) {
+                pool.recycle(connection);
+            }
+
+            @Override
+            public RouteDatabase routeDatabase(OkHttpClient client) {
+                return client.routeDatabase();
+            }
+
+            @Override
+            public Network network(OkHttpClient client) {
+                return client.network;
+            }
+
+            @Override
+            public void setNetwork(OkHttpClient client, Network network) {
+                client.network = network;
+            }
+
+            @Override
+            public void connectAndSetOwner(OkHttpClient client, Connection connection,
+                                           HttpEngine owner, Request request) throws RouteException {
+                connection.connectAndSetOwner(client, owner, request);
+            }
+
+            @Override
+            public void callEnqueue(Call call, Callback responseCallback, boolean forWebSocket) {
+                call.enqueue(responseCallback, forWebSocket);
+            }
+
+            @Override
+            public void callEngineReleaseConnection(Call call) throws IOException {
+                call.engine.releaseConnection();
+            }
+
+            @Override
+            public Connection callEngineGetConnection(Call call) {
+                return call.engine.getConnection();
+            }
+
+            @Override
+            public BufferedSource connectionRawSource(Connection connection) {
+                return connection.rawSource();
+            }
+
+            @Override
+            public BufferedSink connectionRawSink(Connection connection) {
+                return connection.rawSink();
+            }
+
+            @Override
+            public void connectionSetOwner(Connection connection, Object owner) {
+                connection.setOwner(owner);
+            }
+
+            @Override
+            public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean isFallback) {
+                tlsConfiguration.apply(sslSocket, isFallback);
+            }
+        };
+    }
+
+    /**
+     * Lazily-initialized.
+     */
+    private static SSLSocketFactory defaultSslSocketFactory;
+
+    private final RouteDatabase routeDatabase;
+    private Dispatcher dispatcher;
+    private Proxy proxy;
+    private List<Protocol> protocols;
+    private List<ConnectionSpec> connectionSpecs;
+    private final List<Interceptor> interceptors = new ArrayList<>();
+    private final List<Interceptor> networkInterceptors = new ArrayList<>();
+    private ProxySelector proxySelector;
+    private CookieHandler cookieHandler;
+
+    /**
+     * Non-null if this client is caching; possibly by {@code cache}.
+     */
+    private InternalCache internalCache;
+    private Cache cache;
+
+    private SocketFactory socketFactory;
+    private SSLSocketFactory sslSocketFactory;
+    private HostnameVerifier hostnameVerifier;
+    private CertificatePinner certificatePinner;
+    private Authenticator authenticator;
+    private ConnectionPool connectionPool;
+    private Network network;
+    private boolean followSslRedirects = true;
+    private boolean followRedirects = true;
+    private boolean retryOnConnectionFailure = true;
+    private int connectTimeout = 10_000;
+    private int readTimeout = 10_000;
+    private int writeTimeout = 10_000;
+
+    public OkHttpClient() {
+        routeDatabase = new RouteDatabase();
+        dispatcher = new Dispatcher();
+    }
+
+    private OkHttpClient(OkHttpClient okHttpClient) {
+        this.routeDatabase = okHttpClient.routeDatabase;
+        this.dispatcher = okHttpClient.dispatcher;
+        this.proxy = okHttpClient.proxy;
+        this.protocols = okHttpClient.protocols;
+        this.connectionSpecs = okHttpClient.connectionSpecs;
+        this.interceptors.addAll(okHttpClient.interceptors);
+        this.networkInterceptors.addAll(okHttpClient.networkInterceptors);
+        this.proxySelector = okHttpClient.proxySelector;
+        this.cookieHandler = okHttpClient.cookieHandler;
+        this.cache = okHttpClient.cache;
+        this.internalCache = cache != null ? cache.internalCache : okHttpClient.internalCache;
+        this.socketFactory = okHttpClient.socketFactory;
+        this.sslSocketFactory = okHttpClient.sslSocketFactory;
+        this.hostnameVerifier = okHttpClient.hostnameVerifier;
+        this.certificatePinner = okHttpClient.certificatePinner;
+        this.authenticator = okHttpClient.authenticator;
+        this.connectionPool = okHttpClient.connectionPool;
+        this.network = okHttpClient.network;
+        this.followSslRedirects = okHttpClient.followSslRedirects;
+        this.followRedirects = okHttpClient.followRedirects;
+        this.retryOnConnectionFailure = okHttpClient.retryOnConnectionFailure;
+        this.connectTimeout = okHttpClient.connectTimeout;
+        this.readTimeout = okHttpClient.readTimeout;
+        this.writeTimeout = okHttpClient.writeTimeout;
+    }
+
+    /**
+     * Sets the default connect timeout for new connections. A value of 0 means no timeout, otherwise
+     * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+     *
+     * @see URLConnection#setConnectTimeout(int)
+     */
+    public void setConnectTimeout(long timeout, TimeUnit unit) {
+        if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
+        if (unit == null) throw new IllegalArgumentException("unit == null");
+        long millis = unit.toMillis(timeout);
+        if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
+        if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
+        connectTimeout = (int) millis;
+    }
+
+    /**
+     * Default connect timeout (in milliseconds).
+     */
+    public int getConnectTimeout() {
+        return connectTimeout;
+    }
+
+    /**
+     * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
+     * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+     *
+     * @see URLConnection#setReadTimeout(int)
+     */
+    public void setReadTimeout(long timeout, TimeUnit unit) {
+        if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
+        if (unit == null) throw new IllegalArgumentException("unit == null");
+        long millis = unit.toMillis(timeout);
+        if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
+        if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
+        readTimeout = (int) millis;
+    }
+
+    /**
+     * Default read timeout (in milliseconds).
+     */
+    public int getReadTimeout() {
+        return readTimeout;
+    }
+
+    /**
+     * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
+     * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+     */
+    public void setWriteTimeout(long timeout, TimeUnit unit) {
+        if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
+        if (unit == null) throw new IllegalArgumentException("unit == null");
+        long millis = unit.toMillis(timeout);
+        if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
+        if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
+        writeTimeout = (int) millis;
+    }
+
+    /**
+     * Default write timeout (in milliseconds).
+     */
+    public int getWriteTimeout() {
+        return writeTimeout;
+    }
+
+    /**
+     * Sets the HTTP proxy that will be used by connections created by this
+     * client. This takes precedence over {@link #setProxySelector}, which is
+     * only honored when this proxy is null (which it is by default). To disable
+     * proxy use completely, call {@code setProxy(Proxy.NO_PROXY)}.
+     */
+    public OkHttpClient setProxy(Proxy proxy) {
+        this.proxy = proxy;
+        return this;
+    }
+
+    public Proxy getProxy() {
+        return proxy;
+    }
+
+    /**
+     * Sets the proxy selection policy to be used if no {@link #setProxy proxy}
+     * is specified explicitly. The proxy selector may return multiple proxies;
+     * in that case they will be tried in sequence until a successful connection
+     * is established.
+     * <p/>
+     * <p>If unset, the {@link ProxySelector#getDefault() system-wide default}
+     * proxy selector will be used.
+     */
+    public OkHttpClient setProxySelector(ProxySelector proxySelector) {
+        this.proxySelector = proxySelector;
+        return this;
+    }
+
+    public ProxySelector getProxySelector() {
+        return proxySelector;
+    }
+
+    /**
+     * Sets the cookie handler to be used to read outgoing cookies and write
+     * incoming cookies.
+     * <p/>
+     * <p>If unset, the {@link CookieHandler#getDefault() system-wide default}
+     * cookie handler will be used.
+     */
+    public OkHttpClient setCookieHandler(CookieHandler cookieHandler) {
+        this.cookieHandler = cookieHandler;
+        return this;
+    }
+
+    public CookieHandler getCookieHandler() {
+        return cookieHandler;
+    }
+
+    /**
+     * Sets the response cache to be used to read and write cached responses.
+     */
+    void setInternalCache(InternalCache internalCache) {
+        this.internalCache = internalCache;
+        this.cache = null;
+    }
+
+    InternalCache internalCache() {
+        return internalCache;
+    }
+
+    public OkHttpClient setCache(Cache cache) {
+        this.cache = cache;
+        this.internalCache = null;
+        return this;
+    }
+
+    public Cache getCache() {
+        return cache;
+    }
+
+    /**
+     * Sets the socket factory used to create connections. OkHttp only uses
+     * the parameterless {@link SocketFactory#createSocket() createSocket()}
+     * method to create unconnected sockets. Overriding this method,
+     * e. g., allows the socket to be bound to a specific local address.
+     * <p/>
+     * <p>If unset, the {@link SocketFactory#getDefault() system-wide default}
+     * socket factory will be used.
+     */
+    public OkHttpClient setSocketFactory(SocketFactory socketFactory) {
+        this.socketFactory = socketFactory;
+        return this;
+    }
+
+    public SocketFactory getSocketFactory() {
+        return socketFactory;
+    }
+
+    /**
+     * Sets the socket factory used to secure HTTPS connections.
+     * <p/>
+     * <p>If unset, a lazily created SSL socket factory will be used.
+     */
+    public OkHttpClient setSslSocketFactory(SSLSocketFactory sslSocketFactory) {
+        this.sslSocketFactory = sslSocketFactory;
+        return this;
+    }
+
+    public SSLSocketFactory getSslSocketFactory() {
+        return sslSocketFactory;
+    }
+
+    /**
+     * Sets the verifier used to confirm that response certificates apply to
+     * requested hostnames for HTTPS connections.
+     * <p/>
+     * <p>If unset, a default hostname verifier will be used.
+     */
+    public OkHttpClient setHostnameVerifier(HostnameVerifier hostnameVerifier) {
+        this.hostnameVerifier = hostnameVerifier;
+        return this;
+    }
+
+    public HostnameVerifier getHostnameVerifier() {
+        return hostnameVerifier;
+    }
+
+    /**
+     * Sets the certificate pinner that constrains which certificates are trusted.
+     * By default HTTPS connections rely on only the {@link #setSslSocketFactory
+     * SSL socket factory} to establish trust. Pinning certificates avoids the
+     * need to trust certificate authorities.
+     */
+    public OkHttpClient setCertificatePinner(CertificatePinner certificatePinner) {
+        this.certificatePinner = certificatePinner;
+        return this;
+    }
+
+    public CertificatePinner getCertificatePinner() {
+        return certificatePinner;
+    }
+
+    /**
+     * Sets the authenticator used to respond to challenges from the remote web
+     * server or proxy server.
+     * <p/>
+     * <p>If unset, the {@link java.net.Authenticator#setDefault system-wide default}
+     * authenticator will be used.
+     */
+    public OkHttpClient setAuthenticator(Authenticator authenticator) {
+        this.authenticator = authenticator;
+        return this;
+    }
+
+    public Authenticator getAuthenticator() {
+        return authenticator;
+    }
+
+    /**
+     * Sets the connection pool used to recycle HTTP and HTTPS connections.
+     * <p/>
+     * <p>If unset, the {@link ConnectionPool#getDefault() system-wide
+     * default} connection pool will be used.
+     */
+    public OkHttpClient setConnectionPool(ConnectionPool connectionPool) {
+        this.connectionPool = connectionPool;
+        return this;
+    }
+
+    public ConnectionPool getConnectionPool() {
+        return connectionPool;
+    }
+
+    /**
+     * Configure this client to follow redirects from HTTPS to HTTP and from HTTP
+     * to HTTPS.
+     * <p/>
+     * <p>If unset, protocol redirects will be followed. This is different than
+     * the built-in {@code HttpURLConnection}'s default.
+     */
+    public OkHttpClient setFollowSslRedirects(boolean followProtocolRedirects) {
+        this.followSslRedirects = followProtocolRedirects;
+        return this;
+    }
+
+    public boolean getFollowSslRedirects() {
+        return followSslRedirects;
+    }
+
+    /**
+     * Configure this client to follow redirects. If unset, redirects be followed.
+     */
+    public void setFollowRedirects(boolean followRedirects) {
+        this.followRedirects = followRedirects;
+    }
+
+    public boolean getFollowRedirects() {
+        return followRedirects;
+    }
+
+    /**
+     * Configure this client to retry or not when a connectivity problem is encountered. By default,
+     * this client silently recovers from the following problems:
+     * <p/>
+     * <ul>
+     * <li><strong>Unreachable IP addresses.</strong> If the URL's host has multiple IP addresses,
+     * failure to reach any individual IP address doesn't fail the overall request. This can
+     * increase availability of multi-homed services.
+     * <li><strong>Stale pooled connections.</strong> The {@link ConnectionPool} reuses sockets
+     * to decrease request latency, but these connections will occasionally time out.
+     * <li><strong>Unreachable proxy servers.</strong> A {@link ProxySelector} can be used to
+     * attempt multiple proxy servers in sequence, eventually falling back to a direct
+     * connection.
+     * </ul>
+     * <p/>
+     * Set this to false to avoid retrying requests when doing so is destructive. In this case the
+     * calling application should do its own recovery of connectivity failures.
+     */
+    public void setRetryOnConnectionFailure(boolean retryOnConnectionFailure) {
+        this.retryOnConnectionFailure = retryOnConnectionFailure;
+    }
+
+    public boolean getRetryOnConnectionFailure() {
+        return retryOnConnectionFailure;
+    }
+
+    RouteDatabase routeDatabase() {
+        return routeDatabase;
+    }
+
+    /**
+     * Sets the dispatcher used to set policy and execute asynchronous requests.
+     * Must not be null.
+     */
+    public OkHttpClient setDispatcher(Dispatcher dispatcher) {
+        if (dispatcher == null) throw new IllegalArgumentException("dispatcher == null");
+        this.dispatcher = dispatcher;
+        return this;
+    }
+
+    public Dispatcher getDispatcher() {
+        return dispatcher;
+    }
+
+    /**
+     * Configure the protocols used by this client to communicate with remote
+     * servers. By default this client will prefer the most efficient transport
+     * available, falling back to more ubiquitous protocols. Applications should
+     * only call this method to avoid specific compatibility problems, such as web
+     * servers that behave incorrectly when SPDY is enabled.
+     * <p/>
+     * <p>The following protocols are currently supported:
+     * <ul>
+     * <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>
+     * <li><a href="http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1">spdy/3.1</a>
+     * <li><a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-17">h2</a>
+     * </ul>
+     * <p/>
+     * <p><strong>This is an evolving set.</strong> Future releases include
+     * support for transitional protocols. The http/1.1 transport will never be
+     * dropped.
+     * <p/>
+     * <p>If multiple protocols are specified, <a
+     * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a>
+     * will be used to negotiate a transport.
+     * <p/>
+     * <p>{@link Protocol#HTTP_1_0} is not supported in this set. Requests are
+     * initiated with {@code HTTP/1.1} only. If the server responds with {@code
+     * HTTP/1.0}, that will be exposed by {@link Response#protocol()}.
+     *
+     * @param protocols the protocols to use, in order of preference. The list
+     *                  must contain {@link Protocol#HTTP_1_1}. It must not contain null or
+     *                  {@link Protocol#HTTP_1_0}.
+     */
+    public OkHttpClient setProtocols(List<Protocol> protocols) {
+        protocols = Util.immutableList(protocols);
+        if (!protocols.contains(Protocol.HTTP_1_1)) {
+            throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
+        }
+        if (protocols.contains(Protocol.HTTP_1_0)) {
+            throw new IllegalArgumentException("protocols must not contain http/1.0: " + protocols);
+        }
+        if (protocols.contains(null)) {
+            throw new IllegalArgumentException("protocols must not contain null");
+        }
+        this.protocols = Util.immutableList(protocols);
+        return this;
+    }
+
+    public List<Protocol> getProtocols() {
+        return protocols;
+    }
+
+    public OkHttpClient setConnectionSpecs(List<ConnectionSpec> connectionSpecs) {
+        this.connectionSpecs = Util.immutableList(connectionSpecs);
+        return this;
+    }
+
+    public List<ConnectionSpec> getConnectionSpecs() {
+        return connectionSpecs;
+    }
+
+    /**
+     * Returns a modifiable list of interceptors that observe the full span of each call: from before
+     * the connection is established (if any) until after the response source is selected (either the
+     * origin server, cache, or both).
+     */
+    public List<Interceptor> interceptors() {
+        return interceptors;
+    }
+
+    /**
+     * Returns a modifiable list of interceptors that observe a single network request and response.
+     * These interceptors must call {@link Interceptor.Chain#proceed} exactly once: it is an error for
+     * a network interceptor to short-circuit or repeat a network request.
+     */
+    public List<Interceptor> networkInterceptors() {
+        return networkInterceptors;
+    }
+
+    /**
+     * Prepares the {@code request} to be executed at some point in the future.
+     */
+    public Call newCall(Request request) {
+        return new Call(this, request);
+    }
+
+    /**
+     * Cancels all scheduled or in-flight calls tagged with {@code tag}. Requests
+     * that are already complete cannot be canceled.
+     */
+    public OkHttpClient cancel(Object tag) {
+        getDispatcher().cancel(tag);
+        return this;
+    }
+
+    /**
+     * Returns a shallow copy of this OkHttpClient that uses the system-wide
+     * default for each field that hasn't been explicitly configured.
+     */
+    OkHttpClient copyWithDefaults() {
+        OkHttpClient result = new OkHttpClient(this);
+        if (result.proxySelector == null) {
+            result.proxySelector = ProxySelector.getDefault();
+        }
+        if (result.cookieHandler == null) {
+            result.cookieHandler = CookieHandler.getDefault();
+        }
+        if (result.socketFactory == null) {
+            result.socketFactory = SocketFactory.getDefault();
+        }
+        if (result.sslSocketFactory == null) {
+            result.sslSocketFactory = getDefaultSSLSocketFactory();
+        }
+        if (result.hostnameVerifier == null) {
+            result.hostnameVerifier = OkHostnameVerifier.INSTANCE;
+        }
+        if (result.certificatePinner == null) {
+            result.certificatePinner = CertificatePinner.DEFAULT;
+        }
+        if (result.authenticator == null) {
+            result.authenticator = AuthenticatorAdapter.INSTANCE;
+        }
+        if (result.connectionPool == null) {
+            result.connectionPool = ConnectionPool.getDefault();
+        }
+        if (result.protocols == null) {
+            result.protocols = DEFAULT_PROTOCOLS;
+        }
+        if (result.connectionSpecs == null) {
+            result.connectionSpecs = DEFAULT_CONNECTION_SPECS;
+        }
+        if (result.network == null) {
+            result.network = Network.DEFAULT;
+        }
+        return result;
+    }
+
+    /**
+     * Java and Android programs default to using a single global SSL context,
+     * accessible to HTTP clients as {@link SSLSocketFactory#getDefault()}. If we
+     * used the shared SSL context, when OkHttp enables ALPN for its SPDY-related
+     * stuff, it would also enable ALPN for other usages, which might crash them
+     * because ALPN is enabled when it isn't expected to be.
+     * <p/>
+     * <p>This code avoids that by defaulting to an OkHttp-created SSL context.
+     * The drawback of this approach is that apps that customize the global SSL
+     * context will lose these customizations.
+     */
+    private synchronized SSLSocketFactory getDefaultSSLSocketFactory() {
+        if (defaultSslSocketFactory == null) {
+            try {
+                SSLContext sslContext = SSLContext.getInstance("TLS");
+                sslContext.init(null, null, null);
+                defaultSslSocketFactory = sslContext.getSocketFactory();
+            } catch (GeneralSecurityException e) {
+                throw new AssertionError(); // The system has no TLS. Just give up.
+            }
+        }
+        return defaultSslSocketFactory;
+    }
+
+    /**
+     * Returns a shallow copy of this OkHttpClient.
+     */
+    @Override
+    public OkHttpClient clone() {
+        return new OkHttpClient(this);
+    }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Protocol.java b/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
index 6b02098133..13f72d2409 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
@@ -21,7 +21,7 @@
  * Protocols that OkHttp implements for <a
  * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a>
  * selection.
- *
+ * <p/>
  * <h3>Protocol vs Scheme</h3>
  * Despite its name, {@link java.net.URL#getProtocol()} returns the
  * {@linkplain java.net.URI#getScheme() scheme} (http, https, etc.) of the URL, not
@@ -29,69 +29,71 @@
  * to identify how HTTP messages are framed.
  */
 public enum Protocol {
-  /**
-   * An obsolete plaintext framing that does not use persistent sockets by
-   * default.
-   */
-  HTTP_1_0("http/1.0"),
+    /**
+     * An obsolete plaintext framing that does not use persistent sockets by
+     * default.
+     */
+    HTTP_1_0("http/1.0"),
 
-  /**
-   * A plaintext framing that includes persistent connections.
-   *
-   * <p>This version of OkHttp implements <a
-   * href="http://www.ietf.org/rfc/rfc2616.txt">RFC 2616</a>, and tracks
-   * revisions to that spec.
-   */
-  HTTP_1_1("http/1.1"),
+    /**
+     * A plaintext framing that includes persistent connections.
+     * <p/>
+     * <p>This version of OkHttp implements <a
+     * href="http://www.ietf.org/rfc/rfc2616.txt">RFC 2616</a>, and tracks
+     * revisions to that spec.
+     */
+    HTTP_1_1("http/1.1"),
 
-  /**
-   * Chromium's binary-framed protocol that includes header compression,
-   * multiplexing multiple requests on the same socket, and server-push.
-   * HTTP/1.1 semantics are layered on SPDY/3.
-   *
-   * <p>This version of OkHttp implements SPDY 3 <a
-   * href="http://dev.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1">draft
-   * 3.1</a>. Future releases of OkHttp may use this identifier for a newer draft
-   * of the SPDY spec.
-   */
-  SPDY_3("spdy/3.1"),
+    /**
+     * Chromium's binary-framed protocol that includes header compression,
+     * multiplexing multiple requests on the same socket, and server-push.
+     * HTTP/1.1 semantics are layered on SPDY/3.
+     * <p/>
+     * <p>This version of OkHttp implements SPDY 3 <a
+     * href="http://dev.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1">draft
+     * 3.1</a>. Future releases of OkHttp may use this identifier for a newer draft
+     * of the SPDY spec.
+     */
+    SPDY_3("spdy/3.1"),
 
-  /**
-   * The IETF's binary-framed protocol that includes header compression,
-   * multiplexing multiple requests on the same socket, and server-push.
-   * HTTP/1.1 semantics are layered on HTTP/2.
-   *
-   * <p>HTTP/2 requires deployments of HTTP/2 that use TLS 1.2 support
-   * {@linkplain com.squareup.okhttp.CipherSuite#TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256}
-   * , present in Java 8+ and Android 5+. Servers that enforce this may send an
-   * exception message including the string {@code INADEQUATE_SECURITY}.
-   */
-  HTTP_2("h2");
+    /**
+     * The IETF's binary-framed protocol that includes header compression,
+     * multiplexing multiple requests on the same socket, and server-push.
+     * HTTP/1.1 semantics are layered on HTTP/2.
+     * <p/>
+     * <p>HTTP/2 requires deployments of HTTP/2 that use TLS 1.2 support
+     * {@linkplain com.squareup.okhttp.CipherSuite#TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256}
+     * , present in Java 8+ and Android 5+. Servers that enforce this may send an
+     * exception message including the string {@code INADEQUATE_SECURITY}.
+     */
+    HTTP_2("h2");
 
-  private final String protocol;
+    private final String protocol;
 
-  Protocol(String protocol) {
-    this.protocol = protocol;
-  }
+    Protocol(String protocol) {
+        this.protocol = protocol;
+    }
 
-  /**
-   * Returns the protocol identified by {@code protocol}.
-   * @throws IOException if {@code protocol} is unknown.
-   */
-  public static Protocol get(String protocol) throws IOException {
-    // Unroll the loop over values() to save an allocation.
-    if (protocol.equals(HTTP_1_0.protocol)) return HTTP_1_0;
-    if (protocol.equals(HTTP_1_1.protocol)) return HTTP_1_1;
-    if (protocol.equals(HTTP_2.protocol)) return HTTP_2;
-    if (protocol.equals(SPDY_3.protocol)) return SPDY_3;
-    throw new IOException("Unexpected protocol: " + protocol);
-  }
+    /**
+     * Returns the protocol identified by {@code protocol}.
+     *
+     * @throws IOException if {@code protocol} is unknown.
+     */
+    public static Protocol get(String protocol) throws IOException {
+        // Unroll the loop over values() to save an allocation.
+        if (protocol.equals(HTTP_1_0.protocol)) return HTTP_1_0;
+        if (protocol.equals(HTTP_1_1.protocol)) return HTTP_1_1;
+        if (protocol.equals(HTTP_2.protocol)) return HTTP_2;
+        if (protocol.equals(SPDY_3.protocol)) return SPDY_3;
+        throw new IOException("Unexpected protocol: " + protocol);
+    }
 
-  /**
-   * Returns the string used to identify this protocol for ALPN, like
-   * "http/1.1", "spdy/3.1" or "h2".
-   */
-  @Override public String toString() {
-    return protocol;
-  }
+    /**
+     * Returns the string used to identify this protocol for ALPN, like
+     * "http/1.1", "spdy/3.1" or "h2".
+     */
+    @Override
+    public String toString() {
+        return protocol;
+    }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Request.java b/okhttp/src/main/java/com/squareup/okhttp/Request.java
index 2417c132aa..e65bc12eaf 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Request.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Request.java
@@ -16,6 +16,7 @@
 package com.squareup.okhttp;
 
 import com.squareup.okhttp.internal.http.HttpMethod;
+
 import java.io.IOException;
 import java.net.URI;
 import java.net.URL;
@@ -26,253 +27,256 @@
  * is null or itself immutable.
  */
 public final class Request {
-  private final HttpUrl url;
-  private final String method;
-  private final Headers headers;
-  private final RequestBody body;
-  private final Object tag;
-
-  private volatile URL javaNetUrl; // Lazily initialized.
-  private volatile URI javaNetUri; // Lazily initialized.
-  private volatile CacheControl cacheControl; // Lazily initialized.
-
-  private Request(Builder builder) {
-    this.url = builder.url;
-    this.method = builder.method;
-    this.headers = builder.headers.build();
-    this.body = builder.body;
-    this.tag = builder.tag != null ? builder.tag : this;
-  }
-
-  public HttpUrl httpUrl() {
-    return url;
-  }
-
-  public URL url() {
-    URL result = javaNetUrl;
-    return result != null ? result : (javaNetUrl = url.url());
-  }
-
-  public URI uri() throws IOException {
-    try {
-      URI result = javaNetUri;
-      return result != null ? result : (javaNetUri = url.uri());
-    } catch (IllegalStateException e) {
-      throw new IOException(e.getMessage());
-    }
-  }
-
-  public String urlString() {
-    return url.toString();
-  }
-
-  public String method() {
-    return method;
-  }
-
-  public Headers headers() {
-    return headers;
-  }
-
-  public String header(String name) {
-    return headers.get(name);
-  }
-
-  public List<String> headers(String name) {
-    return headers.values(name);
-  }
-
-  public RequestBody body() {
-    return body;
-  }
-
-  public Object tag() {
-    return tag;
-  }
-
-  public Builder newBuilder() {
-    return new Builder(this);
-  }
-
-  /**
-   * Returns the cache control directives for this response. This is never null,
-   * even if this response contains no {@code Cache-Control} header.
-   */
-  public CacheControl cacheControl() {
-    CacheControl result = cacheControl;
-    return result != null ? result : (cacheControl = CacheControl.parse(headers));
-  }
-
-  public boolean isHttps() {
-    return url.isHttps();
-  }
-
-  @Override public String toString() {
-    return "Request{method="
-        + method
-        + ", url="
-        + url
-        + ", tag="
-        + (tag != this ? tag : null)
-        + '}';
-  }
-
-  public static class Builder {
-    private HttpUrl url;
-    private String method;
-    private Headers.Builder headers;
-    private RequestBody body;
-    private Object tag;
-
-    public Builder() {
-      this.method = "GET";
-      this.headers = new Headers.Builder();
-    }
-
-    private Builder(Request request) {
-      this.url = request.url;
-      this.method = request.method;
-      this.body = request.body;
-      this.tag = request.tag;
-      this.headers = request.headers.newBuilder();
-    }
-
-    public Builder url(HttpUrl url) {
-      if (url == null) throw new IllegalArgumentException("url == null");
-      this.url = url;
-      return this;
-    }
-
-    /**
-     * Sets the URL target of this request.
-     *
-     * @throws IllegalArgumentException if {@code url} is not a valid HTTP or HTTPS URL. Avoid this
-     *     exception by calling {@link HttpUrl#parse}; it returns null for invalid URLs.
-     */
-    public Builder url(String url) {
-      if (url == null) throw new IllegalArgumentException("url == null");
-
-      // Silently replace websocket URLs with HTTP URLs.
-      if (url.regionMatches(true, 0, "ws:", 0, 3)) {
-        url = "http:" + url.substring(3);
-      } else if (url.regionMatches(true, 0, "wss:", 0, 4)) {
-        url = "https:" + url.substring(4);
-      }
-
-      HttpUrl parsed = HttpUrl.parse(url);
-      if (parsed == null) throw new IllegalArgumentException("unexpected url: " + url);
-      return url(parsed);
-    }
-
-    /**
-     * Sets the URL target of this request.
-     *
-     * @throws IllegalArgumentException if the scheme of {@code url} is not {@code http} or {@code
-     *     https}.
-     */
-    public Builder url(URL url) {
-      if (url == null) throw new IllegalArgumentException("url == null");
-      HttpUrl parsed = HttpUrl.get(url);
-      if (parsed == null) throw new IllegalArgumentException("unexpected url: " + url);
-      return url(parsed);
+    private final HttpUrl url;
+    private final String method;
+    private final Headers headers;
+    private final RequestBody body;
+    private final Object tag;
+
+    private volatile URL javaNetUrl; // Lazily initialized.
+    private volatile URI javaNetUri; // Lazily initialized.
+    private volatile CacheControl cacheControl; // Lazily initialized.
+
+    private Request(Builder builder) {
+        this.url = builder.url;
+        this.method = builder.method;
+        this.headers = builder.headers.build();
+        this.body = builder.body;
+        this.tag = builder.tag != null ? builder.tag : this;
     }
 
-    /**
-     * Sets the header named {@code name} to {@code value}. If this request
-     * already has any headers with that name, they are all replaced.
-     */
-    public Builder header(String name, String value) {
-      headers.set(name, value);
-      return this;
+    public HttpUrl httpUrl() {
+        return url;
     }
 
-    /**
-     * Adds a header with {@code name} and {@code value}. Prefer this method for
-     * multiply-valued headers like "Cookie".
-     */
-    public Builder addHeader(String name, String value) {
-      headers.add(name, value);
-      return this;
+    public URL url() {
+        URL result = javaNetUrl;
+        return result != null ? result : (javaNetUrl = url.url());
     }
 
-    public Builder removeHeader(String name) {
-      headers.removeAll(name);
-      return this;
+    public URI uri() throws IOException {
+        try {
+            URI result = javaNetUri;
+            return result != null ? result : (javaNetUri = url.uri());
+        } catch (IllegalStateException e) {
+            throw new IOException(e.getMessage());
+        }
     }
 
-    /** Removes all headers on this builder and adds {@code headers}. */
-    public Builder headers(Headers headers) {
-      this.headers = headers.newBuilder();
-      return this;
+    public String urlString() {
+        return url.toString();
     }
 
-    /**
-     * Sets this request's {@code Cache-Control} header, replacing any cache
-     * control headers already present. If {@code cacheControl} doesn't define
-     * any directives, this clears this request's cache-control headers.
-     */
-    public Builder cacheControl(CacheControl cacheControl) {
-      String value = cacheControl.toString();
-      if (value.isEmpty()) return removeHeader("Cache-Control");
-      return header("Cache-Control", value);
+    public String method() {
+        return method;
     }
 
-    public Builder get() {
-      return method("GET", null);
+    public Headers headers() {
+        return headers;
     }
 
-    public Builder head() {
-      return method("HEAD", null);
+    public String header(String name) {
+        return headers.get(name);
     }
 
-    public Builder post(RequestBody body) {
-      return method("POST", body);
+    public List<String> headers(String name) {
+        return headers.values(name);
     }
 
-    public Builder delete(RequestBody body) {
-      return method("DELETE", body);
+    public RequestBody body() {
+        return body;
     }
 
-    public Builder delete() {
-      return delete(RequestBody.create(null, new byte[0]));
+    public Object tag() {
+        return tag;
     }
 
-    public Builder put(RequestBody body) {
-      return method("PUT", body);
+    public Builder newBuilder() {
+        return new Builder(this);
     }
 
-    public Builder patch(RequestBody body) {
-      return method("PATCH", body);
+    /**
+     * Returns the cache control directives for this response. This is never null,
+     * even if this response contains no {@code Cache-Control} header.
+     */
+    public CacheControl cacheControl() {
+        CacheControl result = cacheControl;
+        return result != null ? result : (cacheControl = CacheControl.parse(headers));
     }
 
-    public Builder method(String method, RequestBody body) {
-      if (method == null || method.length() == 0) {
-        throw new IllegalArgumentException("method == null || method.length() == 0");
-      }
-      if (body != null && !HttpMethod.permitsRequestBody(method)) {
-        throw new IllegalArgumentException("method " + method + " must not have a request body.");
-      }
-      if (body == null && HttpMethod.requiresRequestBody(method)) {
-        throw new IllegalArgumentException("method " + method + " must have a request body.");
-      }
-      this.method = method;
-      this.body = body;
-      return this;
+    public boolean isHttps() {
+        return url.isHttps();
     }
 
-    /**
-     * Attaches {@code tag} to the request. It can be used later to cancel the
-     * request. If the tag is unspecified or null, the request is canceled by
-     * using the request itself as the tag.
-     */
-    public Builder tag(Object tag) {
-      this.tag = tag;
-      return this;
+    @Override
+    public String toString() {
+        return "Request{method="
+                + method
+                + ", url="
+                + url
+                + ", tag="
+                + (tag != this ? tag : null)
+                + '}';
     }
 
-    public Request build() {
-      if (url == null) throw new IllegalStateException("url == null");
-      return new Request(this);
+    public static class Builder {
+        private HttpUrl url;
+        private String method;
+        private Headers.Builder headers;
+        private RequestBody body;
+        private Object tag;
+
+        public Builder() {
+            this.method = "GET";
+            this.headers = new Headers.Builder();
+        }
+
+        private Builder(Request request) {
+            this.url = request.url;
+            this.method = request.method;
+            this.body = request.body;
+            this.tag = request.tag;
+            this.headers = request.headers.newBuilder();
+        }
+
+        public Builder url(HttpUrl url) {
+            if (url == null) throw new IllegalArgumentException("url == null");
+            this.url = url;
+            return this;
+        }
+
+        /**
+         * Sets the URL target of this request.
+         *
+         * @throws IllegalArgumentException if {@code url} is not a valid HTTP or HTTPS URL. Avoid this
+         *                                  exception by calling {@link HttpUrl#parse}; it returns null for invalid URLs.
+         */
+        public Builder url(String url) {
+            if (url == null) throw new IllegalArgumentException("url == null");
+
+            // Silently replace websocket URLs with HTTP URLs.
+            if (url.regionMatches(true, 0, "ws:", 0, 3)) {
+                url = "http:" + url.substring(3);
+            } else if (url.regionMatches(true, 0, "wss:", 0, 4)) {
+                url = "https:" + url.substring(4);
+            }
+
+            HttpUrl parsed = HttpUrl.parse(url);
+            if (parsed == null) throw new IllegalArgumentException("unexpected url: " + url);
+            return url(parsed);
+        }
+
+        /**
+         * Sets the URL target of this request.
+         *
+         * @throws IllegalArgumentException if the scheme of {@code url} is not {@code http} or {@code
+         *                                  https}.
+         */
+        public Builder url(URL url) {
+            if (url == null) throw new IllegalArgumentException("url == null");
+            HttpUrl parsed = HttpUrl.get(url);
+            if (parsed == null) throw new IllegalArgumentException("unexpected url: " + url);
+            return url(parsed);
+        }
+
+        /**
+         * Sets the header named {@code name} to {@code value}. If this request
+         * already has any headers with that name, they are all replaced.
+         */
+        public Builder header(String name, String value) {
+            headers.set(name, value);
+            return this;
+        }
+
+        /**
+         * Adds a header with {@code name} and {@code value}. Prefer this method for
+         * multiply-valued headers like "Cookie".
+         */
+        public Builder addHeader(String name, String value) {
+            headers.add(name, value);
+            return this;
+        }
+
+        public Builder removeHeader(String name) {
+            headers.removeAll(name);
+            return this;
+        }
+
+        /**
+         * Removes all headers on this builder and adds {@code headers}.
+         */
+        public Builder headers(Headers headers) {
+            this.headers = headers.newBuilder();
+            return this;
+        }
+
+        /**
+         * Sets this request's {@code Cache-Control} header, replacing any cache
+         * control headers already present. If {@code cacheControl} doesn't define
+         * any directives, this clears this request's cache-control headers.
+         */
+        public Builder cacheControl(CacheControl cacheControl) {
+            String value = cacheControl.toString();
+            if (value.isEmpty()) return removeHeader("Cache-Control");
+            return header("Cache-Control", value);
+        }
+
+        public Builder get() {
+            return method("GET", null);
+        }
+
+        public Builder head() {
+            return method("HEAD", null);
+        }
+
+        public Builder post(RequestBody body) {
+            return method("POST", body);
+        }
+
+        public Builder delete(RequestBody body) {
+            return method("DELETE", body);
+        }
+
+        public Builder delete() {
+            return delete(RequestBody.create(null, new byte[0]));
+        }
+
+        public Builder put(RequestBody body) {
+            return method("PUT", body);
+        }
+
+        public Builder patch(RequestBody body) {
+            return method("PATCH", body);
+        }
+
+        public Builder method(String method, RequestBody body) {
+            if (method == null || method.length() == 0) {
+                throw new IllegalArgumentException("method == null || method.length() == 0");
+            }
+            if (body != null && !HttpMethod.permitsRequestBody(method)) {
+                throw new IllegalArgumentException("method " + method + " must not have a request body.");
+            }
+            if (body == null && HttpMethod.requiresRequestBody(method)) {
+                throw new IllegalArgumentException("method " + method + " must have a request body.");
+            }
+            this.method = method;
+            this.body = body;
+            return this;
+        }
+
+        /**
+         * Attaches {@code tag} to the request. It can be used later to cancel the
+         * request. If the tag is unspecified or null, the request is canceled by
+         * using the request itself as the tag.
+         */
+        public Builder tag(Object tag) {
+            this.tag = tag;
+            return this;
+        }
+
+        public Request build() {
+            if (url == null) throw new IllegalStateException("url == null");
+            return new Request(this);
+        }
     }
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/RequestBody.java b/okhttp/src/main/java/com/squareup/okhttp/RequestBody.java
index 50933f71fd..586b84e302 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/RequestBody.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/RequestBody.java
@@ -16,110 +16,133 @@
 package com.squareup.okhttp;
 
 import com.squareup.okhttp.internal.Util;
+
 import java.io.File;
 import java.io.IOException;
 import java.nio.charset.Charset;
+
 import okio.BufferedSink;
 import okio.ByteString;
 import okio.Okio;
 import okio.Source;
 
 public abstract class RequestBody {
-  /** Returns the Content-Type header for this body. */
-  public abstract MediaType contentType();
-
-  /**
-   * Returns the number of bytes that will be written to {@code out} in a call
-   * to {@link #writeTo}, or -1 if that count is unknown.
-   */
-  public long contentLength() throws IOException {
-    return -1;
-  }
-
-  /** Writes the content of this request to {@code out}. */
-  public abstract void writeTo(BufferedSink sink) throws IOException;
-
-  /**
-   * Returns a new request body that transmits {@code content}. If {@code
-   * contentType} is non-null and lacks a charset, this will use UTF-8.
-   */
-  public static RequestBody create(MediaType contentType, String content) {
-    Charset charset = Util.UTF_8;
-    if (contentType != null) {
-      charset = contentType.charset();
-      if (charset == null) {
-        charset = Util.UTF_8;
-        contentType = MediaType.parse(contentType + "; charset=utf-8");
-      }
+    /**
+     * Returns the Content-Type header for this body.
+     */
+    public abstract MediaType contentType();
+
+    /**
+     * Returns the number of bytes that will be written to {@code out} in a call
+     * to {@link #writeTo}, or -1 if that count is unknown.
+     */
+    public long contentLength() throws IOException {
+        return -1;
     }
-    byte[] bytes = content.getBytes(charset);
-    return create(contentType, bytes);
-  }
-
-  /** Returns a new request body that transmits {@code content}. */
-  public static RequestBody create(final MediaType contentType, final ByteString content) {
-    return new RequestBody() {
-      @Override public MediaType contentType() {
-        return contentType;
-      }
-
-      @Override public long contentLength() throws IOException {
-        return content.size();
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        sink.write(content);
-      }
-    };
-  }
-
-  /** Returns a new request body that transmits {@code content}. */
-  public static RequestBody create(final MediaType contentType, final byte[] content) {
-    return create(contentType, content, 0, content.length);
-  }
-
-  /** Returns a new request body that transmits {@code content}. */
-  public static RequestBody create(final MediaType contentType, final byte[] content,
-      final int offset, final int byteCount) {
-    if (content == null) throw new NullPointerException("content == null");
-    Util.checkOffsetAndCount(content.length, offset, byteCount);
-    return new RequestBody() {
-      @Override public MediaType contentType() {
-        return contentType;
-      }
-
-      @Override public long contentLength() {
-        return byteCount;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        sink.write(content, offset, byteCount);
-      }
-    };
-  }
-
-  /** Returns a new request body that transmits the content of {@code file}. */
-  public static RequestBody create(final MediaType contentType, final File file) {
-    if (file == null) throw new NullPointerException("content == null");
-
-    return new RequestBody() {
-      @Override public MediaType contentType() {
-        return contentType;
-      }
-
-      @Override public long contentLength() {
-        return file.length();
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        Source source = null;
-        try {
-          source = Okio.source(file);
-          sink.writeAll(source);
-        } finally {
-          Util.closeQuietly(source);
+
+    /**
+     * Writes the content of this request to {@code out}.
+     */
+    public abstract void writeTo(BufferedSink sink) throws IOException;
+
+    /**
+     * Returns a new request body that transmits {@code content}. If {@code
+     * contentType} is non-null and lacks a charset, this will use UTF-8.
+     */
+    public static RequestBody create(MediaType contentType, String content) {
+        Charset charset = Util.UTF_8;
+        if (contentType != null) {
+            charset = contentType.charset();
+            if (charset == null) {
+                charset = Util.UTF_8;
+                contentType = MediaType.parse(contentType + "; charset=utf-8");
+            }
         }
-      }
-    };
-  }
+        byte[] bytes = content.getBytes(charset);
+        return create(contentType, bytes);
+    }
+
+    /**
+     * Returns a new request body that transmits {@code content}.
+     */
+    public static RequestBody create(final MediaType contentType, final ByteString content) {
+        return new RequestBody() {
+            @Override
+            public MediaType contentType() {
+                return contentType;
+            }
+
+            @Override
+            public long contentLength() throws IOException {
+                return content.size();
+            }
+
+            @Override
+            public void writeTo(BufferedSink sink) throws IOException {
+                sink.write(content);
+            }
+        };
+    }
+
+    /**
+     * Returns a new request body that transmits {@code content}.
+     */
+    public static RequestBody create(final MediaType contentType, final byte[] content) {
+        return create(contentType, content, 0, content.length);
+    }
+
+    /**
+     * Returns a new request body that transmits {@code content}.
+     */
+    public static RequestBody create(final MediaType contentType, final byte[] content,
+                                     final int offset, final int byteCount) {
+        if (content == null) throw new NullPointerException("content == null");
+        Util.checkOffsetAndCount(content.length, offset, byteCount);
+        return new RequestBody() {
+            @Override
+            public MediaType contentType() {
+                return contentType;
+            }
+
+            @Override
+            public long contentLength() {
+                return byteCount;
+            }
+
+            @Override
+            public void writeTo(BufferedSink sink) throws IOException {
+                sink.write(content, offset, byteCount);
+            }
+        };
+    }
+
+    /**
+     * Returns a new request body that transmits the content of {@code file}.
+     */
+    public static RequestBody create(final MediaType contentType, final File file) {
+        if (file == null) throw new NullPointerException("content == null");
+
+        return new RequestBody() {
+            @Override
+            public MediaType contentType() {
+                return contentType;
+            }
+
+            @Override
+            public long contentLength() {
+                return file.length();
+            }
+
+            @Override
+            public void writeTo(BufferedSink sink) throws IOException {
+                Source source = null;
+                try {
+                    source = Okio.source(file);
+                    sink.writeAll(source);
+                } finally {
+                    Util.closeQuietly(source);
+                }
+            }
+        };
+    }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Response.java b/okhttp/src/main/java/com/squareup/okhttp/Response.java
index bf52795341..80a33bad84 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Response.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Response.java
@@ -16,6 +16,7 @@
 package com.squareup.okhttp;
 
 import com.squareup.okhttp.internal.http.OkHeaders;
+
 import java.util.Collections;
 import java.util.List;
 
@@ -34,319 +35,328 @@
  * are immutable.
  */
 public final class Response {
-  private final Request request;
-  private final Protocol protocol;
-  private final int code;
-  private final String message;
-  private final Handshake handshake;
-  private final Headers headers;
-  private final ResponseBody body;
-  private Response networkResponse;
-  private Response cacheResponse;
-  private final Response priorResponse;
-
-  private volatile CacheControl cacheControl; // Lazily initialized.
-
-  private Response(Builder builder) {
-    this.request = builder.request;
-    this.protocol = builder.protocol;
-    this.code = builder.code;
-    this.message = builder.message;
-    this.handshake = builder.handshake;
-    this.headers = builder.headers.build();
-    this.body = builder.body;
-    this.networkResponse = builder.networkResponse;
-    this.cacheResponse = builder.cacheResponse;
-    this.priorResponse = builder.priorResponse;
-  }
-
-  /**
-   * The wire-level request that initiated this HTTP response. This is not
-   * necessarily the same request issued by the application:
-   * <ul>
-   *     <li>It may be transformed by the HTTP client. For example, the client
-   *         may copy headers like {@code Content-Length} from the request body.
-   *     <li>It may be the request generated in response to an HTTP redirect or
-   *         authentication challenge. In this case the request URL may be
-   *         different than the initial request URL.
-   * </ul>
-   */
-  public Request request() {
-    return request;
-  }
-
-  /**
-   * Returns the HTTP protocol, such as {@link Protocol#HTTP_1_1} or {@link
-   * Protocol#HTTP_1_0}.
-   */
-  public Protocol protocol() {
-    return protocol;
-  }
-
-  /** Returns the HTTP status code. */
-  public int code() {
-    return code;
-  }
-
-  /**
-   * Returns true if the code is in [200..300), which means the request was
-   * successfully received, understood, and accepted.
-   */
-  public boolean isSuccessful() {
-    return code >= 200 && code < 300;
-  }
-
-  /** Returns the HTTP status message or null if it is unknown. */
-  public String message() {
-    return message;
-  }
-
-  /**
-   * Returns the TLS handshake of the connection that carried this response, or
-   * null if the response was received without TLS.
-   */
-  public Handshake handshake() {
-    return handshake;
-  }
-
-  public List<String> headers(String name) {
-    return headers.values(name);
-  }
-
-  public String header(String name) {
-    return header(name, null);
-  }
-
-  public String header(String name, String defaultValue) {
-    String result = headers.get(name);
-    return result != null ? result : defaultValue;
-  }
-
-  public Headers headers() {
-    return headers;
-  }
-
-  public ResponseBody body() {
-    return body;
-  }
-
-  public Builder newBuilder() {
-    return new Builder(this);
-  }
-
-  /** Returns true if this response redirects to another resource. */
-  public boolean isRedirect() {
-    switch (code) {
-      case HTTP_PERM_REDIRECT:
-      case HTTP_TEMP_REDIRECT:
-      case HTTP_MULT_CHOICE:
-      case HTTP_MOVED_PERM:
-      case HTTP_MOVED_TEMP:
-      case HTTP_SEE_OTHER:
-        return true;
-      default:
-        return false;
-    }
-  }
-
-  /**
-   * Returns the raw response received from the network. Will be null if this
-   * response didn't use the network, such as when the response is fully cached.
-   * The body of the returned response should not be read.
-   */
-  public Response networkResponse() {
-    return networkResponse;
-  }
-
-  /**
-   * Returns the raw response received from the cache. Will be null if this
-   * response didn't use the cache. For conditional get requests the cache
-   * response and network response may both be non-null. The body of the
-   * returned response should not be read.
-   */
-  public Response cacheResponse() {
-    return cacheResponse;
-  }
-
-  /**
-   * Returns the response for the HTTP redirect or authorization challenge that
-   * triggered this response, or null if this response wasn't triggered by an
-   * automatic retry. The body of the returned response should not be read
-   * because it has already been consumed by the redirecting client.
-   */
-  public Response priorResponse() {
-    return priorResponse;
-  }
-
-  /**
-   * Returns the authorization challenges appropriate for this response's code.
-   * If the response code is 401 unauthorized, this returns the
-   * "WWW-Authenticate" challenges. If the response code is 407 proxy
-   * unauthorized, this returns the "Proxy-Authenticate" challenges. Otherwise
-   * this returns an empty list of challenges.
-   */
-  public List<Challenge> challenges() {
-    String responseField;
-    if (code == HTTP_UNAUTHORIZED) {
-      responseField = "WWW-Authenticate";
-    } else if (code == HTTP_PROXY_AUTH) {
-      responseField = "Proxy-Authenticate";
-    } else {
-      return Collections.emptyList();
-    }
-    return OkHeaders.parseChallenges(headers(), responseField);
-  }
-
-  /**
-   * Returns the cache control directives for this response. This is never null,
-   * even if this response contains no {@code Cache-Control} header.
-   */
-  public CacheControl cacheControl() {
-    CacheControl result = cacheControl;
-    return result != null ? result : (cacheControl = CacheControl.parse(headers));
-  }
-
-  @Override public String toString() {
-    return "Response{protocol="
-        + protocol
-        + ", code="
-        + code
-        + ", message="
-        + message
-        + ", url="
-        + request.urlString()
-        + '}';
-  }
-
-  public static class Builder {
-    private Request request;
-    private Protocol protocol;
-    private int code = -1;
-    private String message;
-    private Handshake handshake;
-    private Headers.Builder headers;
-    private ResponseBody body;
+    private final Request request;
+    private final Protocol protocol;
+    private final int code;
+    private final String message;
+    private final Handshake handshake;
+    private final Headers headers;
+    private final ResponseBody body;
     private Response networkResponse;
     private Response cacheResponse;
-    private Response priorResponse;
+    private final Response priorResponse;
+
+    private volatile CacheControl cacheControl; // Lazily initialized.
+
+    private Response(Builder builder) {
+        this.request = builder.request;
+        this.protocol = builder.protocol;
+        this.code = builder.code;
+        this.message = builder.message;
+        this.handshake = builder.handshake;
+        this.headers = builder.headers.build();
+        this.body = builder.body;
+        this.networkResponse = builder.networkResponse;
+        this.cacheResponse = builder.cacheResponse;
+        this.priorResponse = builder.priorResponse;
+    }
 
-    public Builder() {
-      headers = new Headers.Builder();
+    /**
+     * The wire-level request that initiated this HTTP response. This is not
+     * necessarily the same request issued by the application:
+     * <ul>
+     * <li>It may be transformed by the HTTP client. For example, the client
+     * may copy headers like {@code Content-Length} from the request body.
+     * <li>It may be the request generated in response to an HTTP redirect or
+     * authentication challenge. In this case the request URL may be
+     * different than the initial request URL.
+     * </ul>
+     */
+    public Request request() {
+        return request;
     }
 
-    private Builder(Response response) {
-      this.request = response.request;
-      this.protocol = response.protocol;
-      this.code = response.code;
-      this.message = response.message;
-      this.handshake = response.handshake;
-      this.headers = response.headers.newBuilder();
-      this.body = response.body;
-      this.networkResponse = response.networkResponse;
-      this.cacheResponse = response.cacheResponse;
-      this.priorResponse = response.priorResponse;
+    /**
+     * Returns the HTTP protocol, such as {@link Protocol#HTTP_1_1} or {@link
+     * Protocol#HTTP_1_0}.
+     */
+    public Protocol protocol() {
+        return protocol;
     }
 
-    public Builder request(Request request) {
-      this.request = request;
-      return this;
+    /**
+     * Returns the HTTP status code.
+     */
+    public int code() {
+        return code;
     }
 
-    public Builder protocol(Protocol protocol) {
-      this.protocol = protocol;
-      return this;
+    /**
+     * Returns true if the code is in [200..300), which means the request was
+     * successfully received, understood, and accepted.
+     */
+    public boolean isSuccessful() {
+        return code >= 200 && code < 300;
     }
 
-    public Builder code(int code) {
-      this.code = code;
-      return this;
+    /**
+     * Returns the HTTP status message or null if it is unknown.
+     */
+    public String message() {
+        return message;
     }
 
-    public Builder message(String message) {
-      this.message = message;
-      return this;
+    /**
+     * Returns the TLS handshake of the connection that carried this response, or
+     * null if the response was received without TLS.
+     */
+    public Handshake handshake() {
+        return handshake;
     }
 
-    public Builder handshake(Handshake handshake) {
-      this.handshake = handshake;
-      return this;
+    public List<String> headers(String name) {
+        return headers.values(name);
     }
 
-    /**
-     * Sets the header named {@code name} to {@code value}. If this request
-     * already has any headers with that name, they are all replaced.
-     */
-    public Builder header(String name, String value) {
-      headers.set(name, value);
-      return this;
+    public String header(String name) {
+        return header(name, null);
     }
 
-    /**
-     * Adds a header with {@code name} and {@code value}. Prefer this method for
-     * multiply-valued headers like "Set-Cookie".
-     */
-    public Builder addHeader(String name, String value) {
-      headers.add(name, value);
-      return this;
+    public String header(String name, String defaultValue) {
+        String result = headers.get(name);
+        return result != null ? result : defaultValue;
     }
 
-    public Builder removeHeader(String name) {
-      headers.removeAll(name);
-      return this;
+    public Headers headers() {
+        return headers;
     }
 
-    /** Removes all headers on this builder and adds {@code headers}. */
-    public Builder headers(Headers headers) {
-      this.headers = headers.newBuilder();
-      return this;
+    public ResponseBody body() {
+        return body;
     }
 
-    public Builder body(ResponseBody body) {
-      this.body = body;
-      return this;
+    public Builder newBuilder() {
+        return new Builder(this);
+    }
+
+    /**
+     * Returns true if this response redirects to another resource.
+     */
+    public boolean isRedirect() {
+        switch (code) {
+            case HTTP_PERM_REDIRECT:
+            case HTTP_TEMP_REDIRECT:
+            case HTTP_MULT_CHOICE:
+            case HTTP_MOVED_PERM:
+            case HTTP_MOVED_TEMP:
+            case HTTP_SEE_OTHER:
+                return true;
+            default:
+                return false;
+        }
+    }
+
+    /**
+     * Returns the raw response received from the network. Will be null if this
+     * response didn't use the network, such as when the response is fully cached.
+     * The body of the returned response should not be read.
+     */
+    public Response networkResponse() {
+        return networkResponse;
     }
 
-    public Builder networkResponse(Response networkResponse) {
-      if (networkResponse != null) checkSupportResponse("networkResponse", networkResponse);
-      this.networkResponse = networkResponse;
-      return this;
+    /**
+     * Returns the raw response received from the cache. Will be null if this
+     * response didn't use the cache. For conditional get requests the cache
+     * response and network response may both be non-null. The body of the
+     * returned response should not be read.
+     */
+    public Response cacheResponse() {
+        return cacheResponse;
     }
 
-    public Builder cacheResponse(Response cacheResponse) {
-      if (cacheResponse != null) checkSupportResponse("cacheResponse", cacheResponse);
-      this.cacheResponse = cacheResponse;
-      return this;
+    /**
+     * Returns the response for the HTTP redirect or authorization challenge that
+     * triggered this response, or null if this response wasn't triggered by an
+     * automatic retry. The body of the returned response should not be read
+     * because it has already been consumed by the redirecting client.
+     */
+    public Response priorResponse() {
+        return priorResponse;
     }
 
-    private void checkSupportResponse(String name, Response response) {
-      if (response.body != null) {
-        throw new IllegalArgumentException(name + ".body != null");
-      } else if (response.networkResponse != null) {
-        throw new IllegalArgumentException(name + ".networkResponse != null");
-      } else if (response.cacheResponse != null) {
-        throw new IllegalArgumentException(name + ".cacheResponse != null");
-      } else if (response.priorResponse != null) {
-        throw new IllegalArgumentException(name + ".priorResponse != null");
-      }
+    /**
+     * Returns the authorization challenges appropriate for this response's code.
+     * If the response code is 401 unauthorized, this returns the
+     * "WWW-Authenticate" challenges. If the response code is 407 proxy
+     * unauthorized, this returns the "Proxy-Authenticate" challenges. Otherwise
+     * this returns an empty list of challenges.
+     */
+    public List<Challenge> challenges() {
+        String responseField;
+        if (code == HTTP_UNAUTHORIZED) {
+            responseField = "WWW-Authenticate";
+        } else if (code == HTTP_PROXY_AUTH) {
+            responseField = "Proxy-Authenticate";
+        } else {
+            return Collections.emptyList();
+        }
+        return OkHeaders.parseChallenges(headers(), responseField);
     }
 
-    public Builder priorResponse(Response priorResponse) {
-      if (priorResponse != null) checkPriorResponse(priorResponse);
-      this.priorResponse = priorResponse;
-      return this;
+    /**
+     * Returns the cache control directives for this response. This is never null,
+     * even if this response contains no {@code Cache-Control} header.
+     */
+    public CacheControl cacheControl() {
+        CacheControl result = cacheControl;
+        return result != null ? result : (cacheControl = CacheControl.parse(headers));
     }
 
-    private void checkPriorResponse(Response response) {
-      if (response.body != null) {
-        throw new IllegalArgumentException("priorResponse.body != null");
-      }
+    @Override
+    public String toString() {
+        return "Response{protocol="
+                + protocol
+                + ", code="
+                + code
+                + ", message="
+                + message
+                + ", url="
+                + request.urlString()
+                + '}';
     }
 
-    public Response build() {
-      if (request == null) throw new IllegalStateException("request == null");
-      if (protocol == null) throw new IllegalStateException("protocol == null");
-      if (code < 0) throw new IllegalStateException("code < 0: " + code);
-      return new Response(this);
+    public static class Builder {
+        private Request request;
+        private Protocol protocol;
+        private int code = -1;
+        private String message;
+        private Handshake handshake;
+        private Headers.Builder headers;
+        private ResponseBody body;
+        private Response networkResponse;
+        private Response cacheResponse;
+        private Response priorResponse;
+
+        public Builder() {
+            headers = new Headers.Builder();
+        }
+
+        private Builder(Response response) {
+            this.request = response.request;
+            this.protocol = response.protocol;
+            this.code = response.code;
+            this.message = response.message;
+            this.handshake = response.handshake;
+            this.headers = response.headers.newBuilder();
+            this.body = response.body;
+            this.networkResponse = response.networkResponse;
+            this.cacheResponse = response.cacheResponse;
+            this.priorResponse = response.priorResponse;
+        }
+
+        public Builder request(Request request) {
+            this.request = request;
+            return this;
+        }
+
+        public Builder protocol(Protocol protocol) {
+            this.protocol = protocol;
+            return this;
+        }
+
+        public Builder code(int code) {
+            this.code = code;
+            return this;
+        }
+
+        public Builder message(String message) {
+            this.message = message;
+            return this;
+        }
+
+        public Builder handshake(Handshake handshake) {
+            this.handshake = handshake;
+            return this;
+        }
+
+        /**
+         * Sets the header named {@code name} to {@code value}. If this request
+         * already has any headers with that name, they are all replaced.
+         */
+        public Builder header(String name, String value) {
+            headers.set(name, value);
+            return this;
+        }
+
+        /**
+         * Adds a header with {@code name} and {@code value}. Prefer this method for
+         * multiply-valued headers like "Set-Cookie".
+         */
+        public Builder addHeader(String name, String value) {
+            headers.add(name, value);
+            return this;
+        }
+
+        public Builder removeHeader(String name) {
+            headers.removeAll(name);
+            return this;
+        }
+
+        /**
+         * Removes all headers on this builder and adds {@code headers}.
+         */
+        public Builder headers(Headers headers) {
+            this.headers = headers.newBuilder();
+            return this;
+        }
+
+        public Builder body(ResponseBody body) {
+            this.body = body;
+            return this;
+        }
+
+        public Builder networkResponse(Response networkResponse) {
+            if (networkResponse != null) checkSupportResponse("networkResponse", networkResponse);
+            this.networkResponse = networkResponse;
+            return this;
+        }
+
+        public Builder cacheResponse(Response cacheResponse) {
+            if (cacheResponse != null) checkSupportResponse("cacheResponse", cacheResponse);
+            this.cacheResponse = cacheResponse;
+            return this;
+        }
+
+        private void checkSupportResponse(String name, Response response) {
+            if (response.body != null) {
+                throw new IllegalArgumentException(name + ".body != null");
+            } else if (response.networkResponse != null) {
+                throw new IllegalArgumentException(name + ".networkResponse != null");
+            } else if (response.cacheResponse != null) {
+                throw new IllegalArgumentException(name + ".cacheResponse != null");
+            } else if (response.priorResponse != null) {
+                throw new IllegalArgumentException(name + ".priorResponse != null");
+            }
+        }
+
+        public Builder priorResponse(Response priorResponse) {
+            if (priorResponse != null) checkPriorResponse(priorResponse);
+            this.priorResponse = priorResponse;
+            return this;
+        }
+
+        private void checkPriorResponse(Response response) {
+            if (response.body != null) {
+                throw new IllegalArgumentException("priorResponse.body != null");
+            }
+        }
+
+        public Response build() {
+            if (request == null) throw new IllegalStateException("request == null");
+            if (protocol == null) throw new IllegalStateException("protocol == null");
+            if (code < 0) throw new IllegalStateException("code < 0: " + code);
+            return new Response(this);
+        }
     }
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/ResponseBody.java b/okhttp/src/main/java/com/squareup/okhttp/ResponseBody.java
index bdd98b4c69..dc30fb4129 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/ResponseBody.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/ResponseBody.java
@@ -16,121 +16,133 @@
 package com.squareup.okhttp;
 
 import com.squareup.okhttp.internal.Util;
+
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.Reader;
 import java.nio.charset.Charset;
+
 import okio.Buffer;
 import okio.BufferedSource;
 
 import static com.squareup.okhttp.internal.Util.UTF_8;
 
 public abstract class ResponseBody implements Closeable {
-  /** Multiple calls to {@link #charStream()} must return the same instance. */
-  private Reader reader;
+    /**
+     * Multiple calls to {@link #charStream()} must return the same instance.
+     */
+    private Reader reader;
+
+    public abstract MediaType contentType();
+
+    /**
+     * Returns the number of bytes in that will returned by {@link #bytes}, or
+     * {@link #byteStream}, or -1 if unknown.
+     */
+    public abstract long contentLength() throws IOException;
+
+    public final InputStream byteStream() throws IOException {
+        return source().inputStream();
+    }
 
-  public abstract MediaType contentType();
+    public abstract BufferedSource source() throws IOException;
+
+    public final byte[] bytes() throws IOException {
+        long contentLength = contentLength();
+        if (contentLength > Integer.MAX_VALUE) {
+            throw new IOException("Cannot buffer entire body for content length: " + contentLength);
+        }
+
+        BufferedSource source = source();
+        byte[] bytes;
+        try {
+            bytes = source.readByteArray();
+        } finally {
+            Util.closeQuietly(source);
+        }
+        if (contentLength != -1 && contentLength != bytes.length) {
+            throw new IOException("Content-Length and stream length disagree");
+        }
+        return bytes;
+    }
 
-  /**
-   * Returns the number of bytes in that will returned by {@link #bytes}, or
-   * {@link #byteStream}, or -1 if unknown.
-   */
-  public abstract long contentLength() throws IOException;
+    /**
+     * Returns the response as a character stream decoded with the charset
+     * of the Content-Type header. If that header is either absent or lacks a
+     * charset, this will attempt to decode the response body as UTF-8.
+     */
+    public final Reader charStream() throws IOException {
+        Reader r = reader;
+        return r != null ? r : (reader = new InputStreamReader(byteStream(), charset()));
+    }
 
-  public final InputStream byteStream() throws IOException {
-    return source().inputStream();
-  }
+    /**
+     * Returns the response as a string decoded with the charset of the
+     * Content-Type header. If that header is either absent or lacks a charset,
+     * this will attempt to decode the response body as UTF-8.
+     */
+    public final String string() throws IOException {
+        return new String(bytes(), charset().name());
+    }
 
-  public abstract BufferedSource source() throws IOException;
+    private Charset charset() {
+        MediaType contentType = contentType();
+        return contentType != null ? contentType.charset(UTF_8) : UTF_8;
+    }
 
-  public final byte[] bytes() throws IOException {
-    long contentLength = contentLength();
-    if (contentLength > Integer.MAX_VALUE) {
-      throw new IOException("Cannot buffer entire body for content length: " + contentLength);
+    @Override
+    public void close() throws IOException {
+        source().close();
     }
 
-    BufferedSource source = source();
-    byte[] bytes;
-    try {
-      bytes = source.readByteArray();
-    } finally {
-      Util.closeQuietly(source);
+    /**
+     * Returns a new response body that transmits {@code content}. If {@code
+     * contentType} is non-null and lacks a charset, this will use UTF-8.
+     */
+    public static ResponseBody create(MediaType contentType, String content) {
+        Charset charset = Util.UTF_8;
+        if (contentType != null) {
+            charset = contentType.charset();
+            if (charset == null) {
+                charset = Util.UTF_8;
+                contentType = MediaType.parse(contentType + "; charset=utf-8");
+            }
+        }
+        Buffer buffer = new Buffer().writeString(content, charset);
+        return create(contentType, buffer.size(), buffer);
     }
-    if (contentLength != -1 && contentLength != bytes.length) {
-      throw new IOException("Content-Length and stream length disagree");
+
+    /**
+     * Returns a new response body that transmits {@code content}.
+     */
+    public static ResponseBody create(final MediaType contentType, byte[] content) {
+        Buffer buffer = new Buffer().write(content);
+        return create(contentType, content.length, buffer);
     }
-    return bytes;
-  }
-
-  /**
-   * Returns the response as a character stream decoded with the charset
-   * of the Content-Type header. If that header is either absent or lacks a
-   * charset, this will attempt to decode the response body as UTF-8.
-   */
-  public final Reader charStream() throws IOException {
-    Reader r = reader;
-    return r != null ? r : (reader = new InputStreamReader(byteStream(), charset()));
-  }
-
-  /**
-   * Returns the response as a string decoded with the charset of the
-   * Content-Type header. If that header is either absent or lacks a charset,
-   * this will attempt to decode the response body as UTF-8.
-   */
-  public final String string() throws IOException {
-    return new String(bytes(), charset().name());
-  }
-
-  private Charset charset() {
-    MediaType contentType = contentType();
-    return contentType != null ? contentType.charset(UTF_8) : UTF_8;
-  }
-
-  @Override public void close() throws IOException {
-    source().close();
-  }
-
-  /**
-   * Returns a new response body that transmits {@code content}. If {@code
-   * contentType} is non-null and lacks a charset, this will use UTF-8.
-   */
-  public static ResponseBody create(MediaType contentType, String content) {
-    Charset charset = Util.UTF_8;
-    if (contentType != null) {
-      charset = contentType.charset();
-      if (charset == null) {
-        charset = Util.UTF_8;
-        contentType = MediaType.parse(contentType + "; charset=utf-8");
-      }
+
+    /**
+     * Returns a new response body that transmits {@code content}.
+     */
+    public static ResponseBody create(
+            final MediaType contentType, final long contentLength, final BufferedSource content) {
+        if (content == null) throw new NullPointerException("source == null");
+        return new ResponseBody() {
+            @Override
+            public MediaType contentType() {
+                return contentType;
+            }
+
+            @Override
+            public long contentLength() {
+                return contentLength;
+            }
+
+            @Override
+            public BufferedSource source() {
+                return content;
+            }
+        };
     }
-    Buffer buffer = new Buffer().writeString(content, charset);
-    return create(contentType, buffer.size(), buffer);
-  }
-
-  /** Returns a new response body that transmits {@code content}. */
-  public static ResponseBody create(final MediaType contentType, byte[] content) {
-    Buffer buffer = new Buffer().write(content);
-    return create(contentType, content.length, buffer);
-  }
-
-  /** Returns a new response body that transmits {@code content}. */
-  public static ResponseBody create(
-      final MediaType contentType, final long contentLength, final BufferedSource content) {
-    if (content == null) throw new NullPointerException("source == null");
-    return new ResponseBody() {
-      @Override public MediaType contentType() {
-        return contentType;
-      }
-
-      @Override public long contentLength() {
-        return contentLength;
-      }
-
-      @Override public BufferedSource source() {
-        return content;
-      }
-    };
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Route.java b/okhttp/src/main/java/com/squareup/okhttp/Route.java
index 2d27a03090..ad35d01e8e 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Route.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Route.java
@@ -22,77 +22,79 @@
  * The concrete route used by a connection to reach an abstract origin server.
  * When creating a connection the client has many options:
  * <ul>
- *   <li><strong>HTTP proxy:</strong> a proxy server may be explicitly
- *       configured for the client. Otherwise the {@linkplain java.net.ProxySelector
- *       proxy selector} is used. It may return multiple proxies to attempt.
- *   <li><strong>IP address:</strong> whether connecting directly to an origin
- *       server or a proxy, opening a socket requires an IP address. The DNS
- *       server may return multiple IP addresses to attempt.
+ * <li><strong>HTTP proxy:</strong> a proxy server may be explicitly
+ * configured for the client. Otherwise the {@linkplain java.net.ProxySelector
+ * proxy selector} is used. It may return multiple proxies to attempt.
+ * <li><strong>IP address:</strong> whether connecting directly to an origin
+ * server or a proxy, opening a socket requires an IP address. The DNS
+ * server may return multiple IP addresses to attempt.
  * </ul>
  * Each route is a specific selection of these options.
  */
 public final class Route {
-  final Address address;
-  final Proxy proxy;
-  final InetSocketAddress inetSocketAddress;
+    final Address address;
+    final Proxy proxy;
+    final InetSocketAddress inetSocketAddress;
 
-  public Route(Address address, Proxy proxy, InetSocketAddress inetSocketAddress) {
-    if (address == null) {
-      throw new NullPointerException("address == null");
+    public Route(Address address, Proxy proxy, InetSocketAddress inetSocketAddress) {
+        if (address == null) {
+            throw new NullPointerException("address == null");
+        }
+        if (proxy == null) {
+            throw new NullPointerException("proxy == null");
+        }
+        if (inetSocketAddress == null) {
+            throw new NullPointerException("inetSocketAddress == null");
+        }
+        this.address = address;
+        this.proxy = proxy;
+        this.inetSocketAddress = inetSocketAddress;
     }
-    if (proxy == null) {
-      throw new NullPointerException("proxy == null");
-    }
-    if (inetSocketAddress == null) {
-      throw new NullPointerException("inetSocketAddress == null");
-    }
-    this.address = address;
-    this.proxy = proxy;
-    this.inetSocketAddress = inetSocketAddress;
-  }
 
-  public Address getAddress() {
-    return address;
-  }
+    public Address getAddress() {
+        return address;
+    }
 
-  /**
-   * Returns the {@link Proxy} of this route.
-   *
-   * <strong>Warning:</strong> This may disagree with {@link Address#getProxy}
-   * when it is null. When the address's proxy is null, the proxy selector is
-   * used.
-   */
-  public Proxy getProxy() {
-    return proxy;
-  }
+    /**
+     * Returns the {@link Proxy} of this route.
+     * <p/>
+     * <strong>Warning:</strong> This may disagree with {@link Address#getProxy}
+     * when it is null. When the address's proxy is null, the proxy selector is
+     * used.
+     */
+    public Proxy getProxy() {
+        return proxy;
+    }
 
-  public InetSocketAddress getSocketAddress() {
-    return inetSocketAddress;
-  }
+    public InetSocketAddress getSocketAddress() {
+        return inetSocketAddress;
+    }
 
-  /**
-   * Returns true if this route tunnels HTTPS through an HTTP proxy. See <a
-   * href="http://www.ietf.org/rfc/rfc2817.txt">RFC 2817, Section 5.2</a>.
-   */
-  public boolean requiresTunnel() {
-    return address.sslSocketFactory != null && proxy.type() == Proxy.Type.HTTP;
-  }
+    /**
+     * Returns true if this route tunnels HTTPS through an HTTP proxy. See <a
+     * href="http://www.ietf.org/rfc/rfc2817.txt">RFC 2817, Section 5.2</a>.
+     */
+    public boolean requiresTunnel() {
+        return address.sslSocketFactory != null && proxy.type() == Proxy.Type.HTTP;
+    }
 
-  @Override public boolean equals(Object obj) {
-    if (obj instanceof Route) {
-      Route other = (Route) obj;
-      return address.equals(other.address)
-          && proxy.equals(other.proxy)
-          && inetSocketAddress.equals(other.inetSocketAddress);
+    @Override
+    public boolean equals(Object obj) {
+        if (obj instanceof Route) {
+            Route other = (Route) obj;
+            return address.equals(other.address)
+                    && proxy.equals(other.proxy)
+                    && inetSocketAddress.equals(other.inetSocketAddress);
+        }
+        return false;
     }
-    return false;
-  }
 
-  @Override public int hashCode() {
-    int result = 17;
-    result = 31 * result + address.hashCode();
-    result = 31 * result + proxy.hashCode();
-    result = 31 * result + inetSocketAddress.hashCode();
-    return result;
-  }
+    @Override
+    public int hashCode() {
+        int result = 17;
+        result = 31 * result + address.hashCode();
+        result = 31 * result + proxy.hashCode();
+        result = 31 * result + inetSocketAddress.hashCode();
+        return result;
+    }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/TlsVersion.java b/okhttp/src/main/java/com/squareup/okhttp/TlsVersion.java
index bfa95c410b..f4ea4abe12 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/TlsVersion.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/TlsVersion.java
@@ -22,29 +22,33 @@
  * {@link SSLSocket#setEnabledProtocols}.
  */
 public enum TlsVersion {
-  TLS_1_2("TLSv1.2"), // 2008.
-  TLS_1_1("TLSv1.1"), // 2006.
-  TLS_1_0("TLSv1"),   // 1999.
-  SSL_3_0("SSLv3"),   // 1996.
-  ;
+    TLS_1_2("TLSv1.2"), // 2008.
+    TLS_1_1("TLSv1.1"), // 2006.
+    TLS_1_0("TLSv1"),   // 1999.
+    SSL_3_0("SSLv3"),   // 1996.
+    ;
 
-  final String javaName;
+    final String javaName;
 
-  private TlsVersion(String javaName) {
-    this.javaName = javaName;
-  }
+    private TlsVersion(String javaName) {
+        this.javaName = javaName;
+    }
 
-  public static TlsVersion forJavaName(String javaName) {
-    switch (javaName) {
-      case "TLSv1.2": return TLS_1_2;
-      case "TLSv1.1": return TLS_1_1;
-      case "TLSv1": return TLS_1_0;
-      case "SSLv3": return SSL_3_0;
+    public static TlsVersion forJavaName(String javaName) {
+        switch (javaName) {
+            case "TLSv1.2":
+                return TLS_1_2;
+            case "TLSv1.1":
+                return TLS_1_1;
+            case "TLSv1":
+                return TLS_1_0;
+            case "SSLv3":
+                return SSL_3_0;
+        }
+        throw new IllegalArgumentException("Unexpected TLS version: " + javaName);
     }
-    throw new IllegalArgumentException("Unexpected TLS version: " + javaName);
-  }
 
-  public String javaName() {
-    return javaName;
-  }
+    public String javaName() {
+        return javaName;
+    }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/ConnectionSpecSelector.java b/okhttp/src/main/java/com/squareup/okhttp/internal/ConnectionSpecSelector.java
index dabe8b26e5..d597464500 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/ConnectionSpecSelector.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/ConnectionSpecSelector.java
@@ -25,6 +25,7 @@
 import java.security.cert.CertificateException;
 import java.util.Arrays;
 import java.util.List;
+
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLProtocolException;
@@ -37,105 +38,105 @@
  */
 public final class ConnectionSpecSelector {
 
-  private final List<ConnectionSpec> connectionSpecs;
-  private int nextModeIndex;
-  private boolean isFallbackPossible;
-  private boolean isFallback;
-
-  public ConnectionSpecSelector(List<ConnectionSpec> connectionSpecs) {
-    this.nextModeIndex = 0;
-    this.connectionSpecs = connectionSpecs;
-  }
-
-  /**
-   * Configures the supplied {@link SSLSocket} to connect to the specified host using an appropriate
-   * {@link ConnectionSpec}. Returns the chosen {@link ConnectionSpec}, never {@code null}.
-   *
-   * @throws IOException if the socket does not support any of the TLS modes available
-   */
-  public ConnectionSpec configureSecureSocket(SSLSocket sslSocket) throws IOException {
-    ConnectionSpec tlsConfiguration = null;
-    for (int i = nextModeIndex, size = connectionSpecs.size(); i < size; i++) {
-      ConnectionSpec connectionSpec = connectionSpecs.get(i);
-      if (connectionSpec.isCompatible(sslSocket)) {
-        tlsConfiguration = connectionSpec;
-        nextModeIndex = i + 1;
-        break;
-      }
-    }
+    private final List<ConnectionSpec> connectionSpecs;
+    private int nextModeIndex;
+    private boolean isFallbackPossible;
+    private boolean isFallback;
 
-    if (tlsConfiguration == null) {
-      // This may be the first time a connection has been attempted and the socket does not support
-      // any the required protocols, or it may be a retry (but this socket supports fewer
-      // protocols than was suggested by a prior socket).
-      throw new UnknownServiceException(
-          "Unable to find acceptable protocols. isFallback=" + isFallback
-              + ", modes=" + connectionSpecs
-              + ", supported protocols=" + Arrays.toString(sslSocket.getEnabledProtocols()));
+    public ConnectionSpecSelector(List<ConnectionSpec> connectionSpecs) {
+        this.nextModeIndex = 0;
+        this.connectionSpecs = connectionSpecs;
     }
 
-    isFallbackPossible = isFallbackPossible(sslSocket);
-
-    Internal.instance.apply(tlsConfiguration, sslSocket, isFallback);
-
-    return tlsConfiguration;
-  }
-
-  /**
-   * Reports a failure to complete a connection. Determines the next {@link ConnectionSpec} to
-   * try, if any.
-   *
-   * @return {@code true} if the connection should be retried using
-   *     {@link #configureSecureSocket(SSLSocket)} or {@code false} if not
-   */
-  public boolean connectionFailed(IOException e) {
-    // Any future attempt to connect using this strategy will be a fallback attempt.
-    isFallback = true;
-
-    // TODO(nfuller): This is the same logic as in HttpEngine.
-    // If there was a protocol problem, don't recover.
-    if (e instanceof ProtocolException) {
-      return false;
+    /**
+     * Configures the supplied {@link SSLSocket} to connect to the specified host using an appropriate
+     * {@link ConnectionSpec}. Returns the chosen {@link ConnectionSpec}, never {@code null}.
+     *
+     * @throws IOException if the socket does not support any of the TLS modes available
+     */
+    public ConnectionSpec configureSecureSocket(SSLSocket sslSocket) throws IOException {
+        ConnectionSpec tlsConfiguration = null;
+        for (int i = nextModeIndex, size = connectionSpecs.size(); i < size; i++) {
+            ConnectionSpec connectionSpec = connectionSpecs.get(i);
+            if (connectionSpec.isCompatible(sslSocket)) {
+                tlsConfiguration = connectionSpec;
+                nextModeIndex = i + 1;
+                break;
+            }
+        }
+
+        if (tlsConfiguration == null) {
+            // This may be the first time a connection has been attempted and the socket does not support
+            // any the required protocols, or it may be a retry (but this socket supports fewer
+            // protocols than was suggested by a prior socket).
+            throw new UnknownServiceException(
+                    "Unable to find acceptable protocols. isFallback=" + isFallback
+                            + ", modes=" + connectionSpecs
+                            + ", supported protocols=" + Arrays.toString(sslSocket.getEnabledProtocols()));
+        }
+
+        isFallbackPossible = isFallbackPossible(sslSocket);
+
+        Internal.instance.apply(tlsConfiguration, sslSocket, isFallback);
+
+        return tlsConfiguration;
     }
 
-    // If there was an interruption or timeout, don't recover.
-    if (e instanceof InterruptedIOException) {
-      return false;
+    /**
+     * Reports a failure to complete a connection. Determines the next {@link ConnectionSpec} to
+     * try, if any.
+     *
+     * @return {@code true} if the connection should be retried using
+     * {@link #configureSecureSocket(SSLSocket)} or {@code false} if not
+     */
+    public boolean connectionFailed(IOException e) {
+        // Any future attempt to connect using this strategy will be a fallback attempt.
+        isFallback = true;
+
+        // TODO(nfuller): This is the same logic as in HttpEngine.
+        // If there was a protocol problem, don't recover.
+        if (e instanceof ProtocolException) {
+            return false;
+        }
+
+        // If there was an interruption or timeout, don't recover.
+        if (e instanceof InterruptedIOException) {
+            return false;
+        }
+
+        // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
+        // again with a different connection spec.
+        if (e instanceof SSLHandshakeException) {
+            // If the problem was a CertificateException from the X509TrustManager,
+            // do not retry.
+            if (e.getCause() instanceof CertificateException) {
+                return false;
+            }
+        }
+        if (e instanceof SSLPeerUnverifiedException) {
+            // e.g. a certificate pinning error.
+            return false;
+        }
+        // TODO(nfuller): End of common code.
+
+
+        // On Android, SSLProtocolExceptions can be caused by TLS_FALLBACK_SCSV failures, which means we
+        // retry those when we probably should not.
+        return ((e instanceof SSLHandshakeException || e instanceof SSLProtocolException))
+                && isFallbackPossible;
     }
 
-    // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
-    // again with a different connection spec.
-    if (e instanceof SSLHandshakeException) {
-      // If the problem was a CertificateException from the X509TrustManager,
-      // do not retry.
-      if (e.getCause() instanceof CertificateException) {
+    /**
+     * Returns {@code true} if any later {@link ConnectionSpec} in the fallback strategy looks
+     * possible based on the supplied {@link SSLSocket}. It assumes that a future socket will have the
+     * same capabilities as the supplied socket.
+     */
+    private boolean isFallbackPossible(SSLSocket socket) {
+        for (int i = nextModeIndex; i < connectionSpecs.size(); i++) {
+            if (connectionSpecs.get(i).isCompatible(socket)) {
+                return true;
+            }
+        }
         return false;
-      }
-    }
-    if (e instanceof SSLPeerUnverifiedException) {
-      // e.g. a certificate pinning error.
-      return false;
-    }
-    // TODO(nfuller): End of common code.
-
-
-    // On Android, SSLProtocolExceptions can be caused by TLS_FALLBACK_SCSV failures, which means we
-    // retry those when we probably should not.
-    return ((e instanceof SSLHandshakeException || e instanceof SSLProtocolException))
-        && isFallbackPossible;
-  }
-
-  /**
-   * Returns {@code true} if any later {@link ConnectionSpec} in the fallback strategy looks
-   * possible based on the supplied {@link SSLSocket}. It assumes that a future socket will have the
-   * same capabilities as the supplied socket.
-   */
-  private boolean isFallbackPossible(SSLSocket socket) {
-    for (int i = nextModeIndex; i < connectionSpecs.size(); i++) {
-      if (connectionSpecs.get(i).isCompatible(socket)) {
-        return true;
-      }
     }
-    return false;
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java b/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
index 284771fc34..ccbd518759 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
@@ -17,6 +17,7 @@
 package com.squareup.okhttp.internal;
 
 import com.squareup.okhttp.internal.io.FileSystem;
+
 import java.io.Closeable;
 import java.io.EOFException;
 import java.io.File;
@@ -33,6 +34,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -47,38 +49,38 @@
  * the regex <strong>[a-z0-9_-]{1,64}</strong>. Values are byte sequences,
  * accessible as streams or files. Each value must be between {@code 0} and
  * {@code Integer.MAX_VALUE} bytes in length.
- *
+ * <p/>
  * <p>The cache stores its data in a directory on the filesystem. This
  * directory must be exclusive to the cache; the cache may delete or overwrite
  * files from its directory. It is an error for multiple processes to use the
  * same cache directory at the same time.
- *
+ * <p/>
  * <p>This cache limits the number of bytes that it will store on the
  * filesystem. When the number of stored bytes exceeds the limit, the cache will
  * remove entries in the background until the limit is satisfied. The limit is
  * not strict: the cache may temporarily exceed it while waiting for files to be
  * deleted. The limit does not include filesystem overhead or the cache
  * journal so space-sensitive applications should set a conservative limit.
- *
+ * <p/>
  * <p>Clients call {@link #edit} to create or update the values of an entry. An
  * entry may have only one editor at one time; if a value is not available to be
  * edited then {@link #edit} will return null.
  * <ul>
- *     <li>When an entry is being <strong>created</strong> it is necessary to
- *         supply a full set of values; the empty value should be used as a
- *         placeholder if necessary.
- *     <li>When an entry is being <strong>edited</strong>, it is not necessary
- *         to supply data for every value; values default to their previous
- *         value.
+ * <li>When an entry is being <strong>created</strong> it is necessary to
+ * supply a full set of values; the empty value should be used as a
+ * placeholder if necessary.
+ * <li>When an entry is being <strong>edited</strong>, it is not necessary
+ * to supply data for every value; values default to their previous
+ * value.
  * </ul>
  * Every {@link #edit} call must be matched by a call to {@link Editor#commit}
  * or {@link Editor#abort}. Committing is atomic: a read observes the full set
  * of values as they were before or after the commit, but never a mix of values.
- *
+ * <p/>
  * <p>Clients call {@link #get} to read a snapshot of an entry. The read will
  * observe the value at the time that {@link #get} was called. Updates and
  * removals after the call do not impact ongoing reads.
- *
+ * <p/>
  * <p>This class is tolerant of some I/O errors. If files are missing from the
  * filesystem, the corresponding entries will be dropped from the cache. If
  * an error occurs while writing a cache value, the edit will fail silently.
@@ -86,17 +88,17 @@
  * responding appropriately.
  */
 public final class DiskLruCache implements Closeable {
-  static final String JOURNAL_FILE = "journal";
-  static final String JOURNAL_FILE_TEMP = "journal.tmp";
-  static final String JOURNAL_FILE_BACKUP = "journal.bkp";
-  static final String MAGIC = "libcore.io.DiskLruCache";
-  static final String VERSION_1 = "1";
-  static final long ANY_SEQUENCE_NUMBER = -1;
-  static final Pattern LEGAL_KEY_PATTERN = Pattern.compile("[a-z0-9_-]{1,120}");
-  private static final String CLEAN = "CLEAN";
-  private static final String DIRTY = "DIRTY";
-  private static final String REMOVE = "REMOVE";
-  private static final String READ = "READ";
+    static final String JOURNAL_FILE = "journal";
+    static final String JOURNAL_FILE_TEMP = "journal.tmp";
+    static final String JOURNAL_FILE_BACKUP = "journal.bkp";
+    static final String MAGIC = "libcore.io.DiskLruCache";
+    static final String VERSION_1 = "1";
+    static final long ANY_SEQUENCE_NUMBER = -1;
+    static final Pattern LEGAL_KEY_PATTERN = Pattern.compile("[a-z0-9_-]{1,120}");
+    private static final String CLEAN = "CLEAN";
+    private static final String DIRTY = "DIRTY";
+    private static final String REMOVE = "REMOVE";
+    private static final String READ = "READ";
 
     /*
      * This cache uses a journal file named "journal". A typical journal file
@@ -138,881 +140,921 @@
      * it exists when the cache is opened.
      */
 
-  private final FileSystem fileSystem;
-  private final File directory;
-  private final File journalFile;
-  private final File journalFileTmp;
-  private final File journalFileBackup;
-  private final int appVersion;
-  private long maxSize;
-  private final int valueCount;
-  private long size = 0;
-  private BufferedSink journalWriter;
-  private final LinkedHashMap<String, Entry> lruEntries = new LinkedHashMap<>(0, 0.75f, true);
-  private int redundantOpCount;
-  private boolean hasJournalErrors;
-
-  // Must be read and written when synchronized on 'this'.
-  private boolean initialized;
-  private boolean closed;
-
-  /**
-   * To differentiate between old and current snapshots, each entry is given
-   * a sequence number each time an edit is committed. A snapshot is stale if
-   * its sequence number is not equal to its entry's sequence number.
-   */
-  private long nextSequenceNumber = 0;
-
-  /** Used to run 'cleanupRunnable' for journal rebuilds. */
-  private final Executor executor;
-  private final Runnable cleanupRunnable = new Runnable() {
-    public void run() {
-      synchronized (DiskLruCache.this) {
-        if (!initialized | closed) {
-          return; // Nothing to do
+    private final FileSystem fileSystem;
+    private final File directory;
+    private final File journalFile;
+    private final File journalFileTmp;
+    private final File journalFileBackup;
+    private final int appVersion;
+    private long maxSize;
+    private final int valueCount;
+    private long size = 0;
+    private BufferedSink journalWriter;
+    private final LinkedHashMap<String, Entry> lruEntries = new LinkedHashMap<>(0, 0.75f, true);
+    private int redundantOpCount;
+    private boolean hasJournalErrors;
+
+    // Must be read and written when synchronized on 'this'.
+    private boolean initialized;
+    private boolean closed;
+
+    /**
+     * To differentiate between old and current snapshots, each entry is given
+     * a sequence number each time an edit is committed. A snapshot is stale if
+     * its sequence number is not equal to its entry's sequence number.
+     */
+    private long nextSequenceNumber = 0;
+
+    /**
+     * Used to run 'cleanupRunnable' for journal rebuilds.
+     */
+    private final Executor executor;
+    private final Runnable cleanupRunnable = new Runnable() {
+        public void run() {
+            synchronized (DiskLruCache.this) {
+                if (!initialized | closed) {
+                    return; // Nothing to do
+                }
+                try {
+                    trimToSize();
+                    if (journalRebuildRequired()) {
+                        rebuildJournal();
+                        redundantOpCount = 0;
+                    }
+                } catch (IOException e) {
+                    throw new RuntimeException(e);
+                }
+            }
         }
-        try {
-          trimToSize();
-          if (journalRebuildRequired()) {
-            rebuildJournal();
-            redundantOpCount = 0;
-          }
-        } catch (IOException e) {
-          throw new RuntimeException(e);
-        }
-      }
-    }
-  };
-
-  DiskLruCache(FileSystem fileSystem, File directory, int appVersion, int valueCount, long maxSize,
-      Executor executor) {
-    this.fileSystem = fileSystem;
-    this.directory = directory;
-    this.appVersion = appVersion;
-    this.journalFile = new File(directory, JOURNAL_FILE);
-    this.journalFileTmp = new File(directory, JOURNAL_FILE_TEMP);
-    this.journalFileBackup = new File(directory, JOURNAL_FILE_BACKUP);
-    this.valueCount = valueCount;
-    this.maxSize = maxSize;
-    this.executor = executor;
-  }
-
-  // Visible for testing.
-  void initialize() throws IOException {
-    assert Thread.holdsLock(this);
-
-    if (initialized) {
-      return; // Already initialized.
-    }
+    };
 
-    // If a bkp file exists, use it instead.
-    if (fileSystem.exists(journalFileBackup)) {
-      // If journal file also exists just delete backup file.
-      if (fileSystem.exists(journalFile)) {
-        fileSystem.delete(journalFileBackup);
-      } else {
-        fileSystem.rename(journalFileBackup, journalFile);
-      }
+    DiskLruCache(FileSystem fileSystem, File directory, int appVersion, int valueCount, long maxSize,
+                 Executor executor) {
+        this.fileSystem = fileSystem;
+        this.directory = directory;
+        this.appVersion = appVersion;
+        this.journalFile = new File(directory, JOURNAL_FILE);
+        this.journalFileTmp = new File(directory, JOURNAL_FILE_TEMP);
+        this.journalFileBackup = new File(directory, JOURNAL_FILE_BACKUP);
+        this.valueCount = valueCount;
+        this.maxSize = maxSize;
+        this.executor = executor;
     }
 
-    // Prefer to pick up where we left off.
-    if (fileSystem.exists(journalFile)) {
-      try {
-        readJournal();
-        processJournal();
-        initialized = true;
-        return;
-      } catch (IOException journalIsCorrupt) {
-        Platform.get().logW("DiskLruCache " + directory + " is corrupt: "
-            + journalIsCorrupt.getMessage() + ", removing");
-        delete();
-        closed = false;
-      }
-    }
+    // Visible for testing.
+    void initialize() throws IOException {
+        assert Thread.holdsLock(this);
 
-    rebuildJournal();
-
-    initialized = true;
-  }
-
-  /**
-   * Create a cache which will reside in {@code directory}. This cache is lazily initialized on
-   * first access and will be created if it does not exist.
-   *
-   * @param directory a writable directory
-   * @param valueCount the number of values per cache entry. Must be positive.
-   * @param maxSize the maximum number of bytes this cache should use to store
-   */
-  public static DiskLruCache create(FileSystem fileSystem, File directory, int appVersion,
-      int valueCount, long maxSize) {
-    if (maxSize <= 0) {
-      throw new IllegalArgumentException("maxSize <= 0");
-    }
-    if (valueCount <= 0) {
-      throw new IllegalArgumentException("valueCount <= 0");
-    }
+        if (initialized) {
+            return; // Already initialized.
+        }
 
-    // Use a single background thread to evict entries.
-    Executor executor = new ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS,
-        new LinkedBlockingQueue<Runnable>(), Util.threadFactory("OkHttp DiskLruCache", true));
-
-    return new DiskLruCache(fileSystem, directory, appVersion, valueCount, maxSize, executor);
-  }
-
-  private void readJournal() throws IOException {
-    BufferedSource source = Okio.buffer(fileSystem.source(journalFile));
-    try {
-      String magic = source.readUtf8LineStrict();
-      String version = source.readUtf8LineStrict();
-      String appVersionString = source.readUtf8LineStrict();
-      String valueCountString = source.readUtf8LineStrict();
-      String blank = source.readUtf8LineStrict();
-      if (!MAGIC.equals(magic)
-          || !VERSION_1.equals(version)
-          || !Integer.toString(appVersion).equals(appVersionString)
-          || !Integer.toString(valueCount).equals(valueCountString)
-          || !"".equals(blank)) {
-        throw new IOException("unexpected journal header: [" + magic + ", " + version + ", "
-            + valueCountString + ", " + blank + "]");
-      }
-
-      int lineCount = 0;
-      while (true) {
-        try {
-          readJournalLine(source.readUtf8LineStrict());
-          lineCount++;
-        } catch (EOFException endOfJournal) {
-          break;
+        // If a bkp file exists, use it instead.
+        if (fileSystem.exists(journalFileBackup)) {
+            // If journal file also exists just delete backup file.
+            if (fileSystem.exists(journalFile)) {
+                fileSystem.delete(journalFileBackup);
+            } else {
+                fileSystem.rename(journalFileBackup, journalFile);
+            }
+        }
+
+        // Prefer to pick up where we left off.
+        if (fileSystem.exists(journalFile)) {
+            try {
+                readJournal();
+                processJournal();
+                initialized = true;
+                return;
+            } catch (IOException journalIsCorrupt) {
+                Platform.get().logW("DiskLruCache " + directory + " is corrupt: "
+                        + journalIsCorrupt.getMessage() + ", removing");
+                delete();
+                closed = false;
+            }
         }
-      }
-      redundantOpCount = lineCount - lruEntries.size();
 
-      // If we ended on a truncated line, rebuild the journal before appending to it.
-      if (!source.exhausted()) {
         rebuildJournal();
-      } else {
-        journalWriter = newJournalWriter();
-      }
-    } finally {
-      Util.closeQuietly(source);
-    }
-  }
-
-  private BufferedSink newJournalWriter() throws FileNotFoundException {
-    Sink fileSink = fileSystem.appendingSink(journalFile);
-    Sink faultHidingSink = new FaultHidingSink(fileSink) {
-      @Override protected void onException(IOException e) {
-        assert (Thread.holdsLock(DiskLruCache.this));
-        hasJournalErrors = true;
-      }
-    };
-    return Okio.buffer(faultHidingSink);
-  }
 
-  private void readJournalLine(String line) throws IOException {
-    int firstSpace = line.indexOf(' ');
-    if (firstSpace == -1) {
-      throw new IOException("unexpected journal line: " + line);
+        initialized = true;
     }
 
-    int keyBegin = firstSpace + 1;
-    int secondSpace = line.indexOf(' ', keyBegin);
-    final String key;
-    if (secondSpace == -1) {
-      key = line.substring(keyBegin);
-      if (firstSpace == REMOVE.length() && line.startsWith(REMOVE)) {
-        lruEntries.remove(key);
-        return;
-      }
-    } else {
-      key = line.substring(keyBegin, secondSpace);
-    }
+    /**
+     * Create a cache which will reside in {@code directory}. This cache is lazily initialized on
+     * first access and will be created if it does not exist.
+     *
+     * @param directory  a writable directory
+     * @param valueCount the number of values per cache entry. Must be positive.
+     * @param maxSize    the maximum number of bytes this cache should use to store
+     */
+    public static DiskLruCache create(FileSystem fileSystem, File directory, int appVersion,
+                                      int valueCount, long maxSize) {
+        if (maxSize <= 0) {
+            throw new IllegalArgumentException("maxSize <= 0");
+        }
+        if (valueCount <= 0) {
+            throw new IllegalArgumentException("valueCount <= 0");
+        }
 
-    Entry entry = lruEntries.get(key);
-    if (entry == null) {
-      entry = new Entry(key);
-      lruEntries.put(key, entry);
-    }
+        // Use a single background thread to evict entries.
+        Executor executor = new ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS,
+                new LinkedBlockingQueue<Runnable>(), Util.threadFactory("OkHttp DiskLruCache", true));
 
-    if (secondSpace != -1 && firstSpace == CLEAN.length() && line.startsWith(CLEAN)) {
-      String[] parts = line.substring(secondSpace + 1).split(" ");
-      entry.readable = true;
-      entry.currentEditor = null;
-      entry.setLengths(parts);
-    } else if (secondSpace == -1 && firstSpace == DIRTY.length() && line.startsWith(DIRTY)) {
-      entry.currentEditor = new Editor(entry);
-    } else if (secondSpace == -1 && firstSpace == READ.length() && line.startsWith(READ)) {
-      // This work was already done by calling lruEntries.get().
-    } else {
-      throw new IOException("unexpected journal line: " + line);
+        return new DiskLruCache(fileSystem, directory, appVersion, valueCount, maxSize, executor);
     }
-  }
-
-  /**
-   * Computes the initial size and collects garbage as a part of opening the
-   * cache. Dirty entries are assumed to be inconsistent and will be deleted.
-   */
-  private void processJournal() throws IOException {
-    fileSystem.delete(journalFileTmp);
-    for (Iterator<Entry> i = lruEntries.values().iterator(); i.hasNext(); ) {
-      Entry entry = i.next();
-      if (entry.currentEditor == null) {
-        for (int t = 0; t < valueCount; t++) {
-          size += entry.lengths[t];
-        }
-      } else {
-        entry.currentEditor = null;
-        for (int t = 0; t < valueCount; t++) {
-          fileSystem.delete(entry.cleanFiles[t]);
-          fileSystem.delete(entry.dirtyFiles[t]);
+
+    private void readJournal() throws IOException {
+        BufferedSource source = Okio.buffer(fileSystem.source(journalFile));
+        try {
+            String magic = source.readUtf8LineStrict();
+            String version = source.readUtf8LineStrict();
+            String appVersionString = source.readUtf8LineStrict();
+            String valueCountString = source.readUtf8LineStrict();
+            String blank = source.readUtf8LineStrict();
+            if (!MAGIC.equals(magic)
+                    || !VERSION_1.equals(version)
+                    || !Integer.toString(appVersion).equals(appVersionString)
+                    || !Integer.toString(valueCount).equals(valueCountString)
+                    || !"".equals(blank)) {
+                throw new IOException("unexpected journal header: [" + magic + ", " + version + ", "
+                        + valueCountString + ", " + blank + "]");
+            }
+
+            int lineCount = 0;
+            while (true) {
+                try {
+                    readJournalLine(source.readUtf8LineStrict());
+                    lineCount++;
+                } catch (EOFException endOfJournal) {
+                    break;
+                }
+            }
+            redundantOpCount = lineCount - lruEntries.size();
+
+            // If we ended on a truncated line, rebuild the journal before appending to it.
+            if (!source.exhausted()) {
+                rebuildJournal();
+            } else {
+                journalWriter = newJournalWriter();
+            }
+        } finally {
+            Util.closeQuietly(source);
         }
-        i.remove();
-      }
     }
-  }
-
-  /**
-   * Creates a new journal that omits redundant information. This replaces the
-   * current journal if it exists.
-   */
-  private synchronized void rebuildJournal() throws IOException {
-    if (journalWriter != null) {
-      journalWriter.close();
+
+    private BufferedSink newJournalWriter() throws FileNotFoundException {
+        Sink fileSink = fileSystem.appendingSink(journalFile);
+        Sink faultHidingSink = new FaultHidingSink(fileSink) {
+            @Override
+            protected void onException(IOException e) {
+                assert (Thread.holdsLock(DiskLruCache.this));
+                hasJournalErrors = true;
+            }
+        };
+        return Okio.buffer(faultHidingSink);
     }
 
-    BufferedSink writer = Okio.buffer(fileSystem.sink(journalFileTmp));
-    try {
-      writer.writeUtf8(MAGIC).writeByte('\n');
-      writer.writeUtf8(VERSION_1).writeByte('\n');
-      writer.writeDecimalLong(appVersion).writeByte('\n');
-      writer.writeDecimalLong(valueCount).writeByte('\n');
-      writer.writeByte('\n');
+    private void readJournalLine(String line) throws IOException {
+        int firstSpace = line.indexOf(' ');
+        if (firstSpace == -1) {
+            throw new IOException("unexpected journal line: " + line);
+        }
 
-      for (Entry entry : lruEntries.values()) {
-        if (entry.currentEditor != null) {
-          writer.writeUtf8(DIRTY).writeByte(' ');
-          writer.writeUtf8(entry.key);
-          writer.writeByte('\n');
+        int keyBegin = firstSpace + 1;
+        int secondSpace = line.indexOf(' ', keyBegin);
+        final String key;
+        if (secondSpace == -1) {
+            key = line.substring(keyBegin);
+            if (firstSpace == REMOVE.length() && line.startsWith(REMOVE)) {
+                lruEntries.remove(key);
+                return;
+            }
         } else {
-          writer.writeUtf8(CLEAN).writeByte(' ');
-          writer.writeUtf8(entry.key);
-          entry.writeLengths(writer);
-          writer.writeByte('\n');
-        }
-      }
-    } finally {
-      writer.close();
-    }
+            key = line.substring(keyBegin, secondSpace);
+        }
 
-    if (fileSystem.exists(journalFile)) {
-      fileSystem.rename(journalFile, journalFileBackup);
-    }
-    fileSystem.rename(journalFileTmp, journalFile);
-    fileSystem.delete(journalFileBackup);
-
-    journalWriter = newJournalWriter();
-    hasJournalErrors = false;
-  }
-
-  /**
-   * Returns a snapshot of the entry named {@code key}, or null if it doesn't
-   * exist is not currently readable. If a value is returned, it is moved to
-   * the head of the LRU queue.
-   */
-  public synchronized Snapshot get(String key) throws IOException {
-    initialize();
-
-    checkNotClosed();
-    validateKey(key);
-    Entry entry = lruEntries.get(key);
-    if (entry == null || !entry.readable) return null;
-
-    Snapshot snapshot = entry.snapshot();
-    if (snapshot == null) return null;
-
-    redundantOpCount++;
-    journalWriter.writeUtf8(READ).writeByte(' ').writeUtf8(key).writeByte('\n');
-    if (journalRebuildRequired()) {
-      executor.execute(cleanupRunnable);
-    }
+        Entry entry = lruEntries.get(key);
+        if (entry == null) {
+            entry = new Entry(key);
+            lruEntries.put(key, entry);
+        }
 
-    return snapshot;
-  }
-
-  /**
-   * Returns an editor for the entry named {@code key}, or null if another
-   * edit is in progress.
-   */
-  public Editor edit(String key) throws IOException {
-    return edit(key, ANY_SEQUENCE_NUMBER);
-  }
-
-  private synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException {
-    initialize();
-
-    checkNotClosed();
-    validateKey(key);
-    Entry entry = lruEntries.get(key);
-    if (expectedSequenceNumber != ANY_SEQUENCE_NUMBER && (entry == null
-        || entry.sequenceNumber != expectedSequenceNumber)) {
-      return null; // Snapshot is stale.
+        if (secondSpace != -1 && firstSpace == CLEAN.length() && line.startsWith(CLEAN)) {
+            String[] parts = line.substring(secondSpace + 1).split(" ");
+            entry.readable = true;
+            entry.currentEditor = null;
+            entry.setLengths(parts);
+        } else if (secondSpace == -1 && firstSpace == DIRTY.length() && line.startsWith(DIRTY)) {
+            entry.currentEditor = new Editor(entry);
+        } else if (secondSpace == -1 && firstSpace == READ.length() && line.startsWith(READ)) {
+            // This work was already done by calling lruEntries.get().
+        } else {
+            throw new IOException("unexpected journal line: " + line);
+        }
     }
-    if (entry != null && entry.currentEditor != null) {
-      return null; // Another edit is in progress.
+
+    /**
+     * Computes the initial size and collects garbage as a part of opening the
+     * cache. Dirty entries are assumed to be inconsistent and will be deleted.
+     */
+    private void processJournal() throws IOException {
+        fileSystem.delete(journalFileTmp);
+        for (Iterator<Entry> i = lruEntries.values().iterator(); i.hasNext(); ) {
+            Entry entry = i.next();
+            if (entry.currentEditor == null) {
+                for (int t = 0; t < valueCount; t++) {
+                    size += entry.lengths[t];
+                }
+            } else {
+                entry.currentEditor = null;
+                for (int t = 0; t < valueCount; t++) {
+                    fileSystem.delete(entry.cleanFiles[t]);
+                    fileSystem.delete(entry.dirtyFiles[t]);
+                }
+                i.remove();
+            }
+        }
     }
 
-    // Flush the journal before creating files to prevent file leaks.
-    journalWriter.writeUtf8(DIRTY).writeByte(' ').writeUtf8(key).writeByte('\n');
-    journalWriter.flush();
+    /**
+     * Creates a new journal that omits redundant information. This replaces the
+     * current journal if it exists.
+     */
+    private synchronized void rebuildJournal() throws IOException {
+        if (journalWriter != null) {
+            journalWriter.close();
+        }
+
+        BufferedSink writer = Okio.buffer(fileSystem.sink(journalFileTmp));
+        try {
+            writer.writeUtf8(MAGIC).writeByte('\n');
+            writer.writeUtf8(VERSION_1).writeByte('\n');
+            writer.writeDecimalLong(appVersion).writeByte('\n');
+            writer.writeDecimalLong(valueCount).writeByte('\n');
+            writer.writeByte('\n');
+
+            for (Entry entry : lruEntries.values()) {
+                if (entry.currentEditor != null) {
+                    writer.writeUtf8(DIRTY).writeByte(' ');
+                    writer.writeUtf8(entry.key);
+                    writer.writeByte('\n');
+                } else {
+                    writer.writeUtf8(CLEAN).writeByte(' ');
+                    writer.writeUtf8(entry.key);
+                    entry.writeLengths(writer);
+                    writer.writeByte('\n');
+                }
+            }
+        } finally {
+            writer.close();
+        }
 
-    if (hasJournalErrors) {
-      return null; // Don't edit; the journal can't be written.
-    }
+        if (fileSystem.exists(journalFile)) {
+            fileSystem.rename(journalFile, journalFileBackup);
+        }
+        fileSystem.rename(journalFileTmp, journalFile);
+        fileSystem.delete(journalFileBackup);
 
-    if (entry == null) {
-      entry = new Entry(key);
-      lruEntries.put(key, entry);
+        journalWriter = newJournalWriter();
+        hasJournalErrors = false;
     }
-    Editor editor = new Editor(entry);
-    entry.currentEditor = editor;
-    return editor;
-  }
-
-  /** Returns the directory where this cache stores its data. */
-  public File getDirectory() {
-    return directory;
-  }
-
-  /**
-   * Returns the maximum number of bytes that this cache should use to store
-   * its data.
-   */
-  public synchronized long getMaxSize() {
-    return maxSize;
-  }
-
-  /**
-   * Changes the maximum number of bytes the cache can store and queues a job
-   * to trim the existing store, if necessary.
-   */
-  public synchronized void setMaxSize(long maxSize) {
-    this.maxSize = maxSize;
-    if (initialized) {
-      executor.execute(cleanupRunnable);
+
+    /**
+     * Returns a snapshot of the entry named {@code key}, or null if it doesn't
+     * exist is not currently readable. If a value is returned, it is moved to
+     * the head of the LRU queue.
+     */
+    public synchronized Snapshot get(String key) throws IOException {
+        initialize();
+
+        checkNotClosed();
+        validateKey(key);
+        Entry entry = lruEntries.get(key);
+        if (entry == null || !entry.readable) return null;
+
+        Snapshot snapshot = entry.snapshot();
+        if (snapshot == null) return null;
+
+        redundantOpCount++;
+        journalWriter.writeUtf8(READ).writeByte(' ').writeUtf8(key).writeByte('\n');
+        if (journalRebuildRequired()) {
+            executor.execute(cleanupRunnable);
+        }
+
+        return snapshot;
     }
-  }
-
-  /**
-   * Returns the number of bytes currently being used to store the values in
-   * this cache. This may be greater than the max size if a background
-   * deletion is pending.
-   */
-  public synchronized long size() throws IOException {
-    initialize();
-    return size;
-  }
-
-  private synchronized void completeEdit(Editor editor, boolean success) throws IOException {
-    Entry entry = editor.entry;
-    if (entry.currentEditor != editor) {
-      throw new IllegalStateException();
+
+    /**
+     * Returns an editor for the entry named {@code key}, or null if another
+     * edit is in progress.
+     */
+    public Editor edit(String key) throws IOException {
+        return edit(key, ANY_SEQUENCE_NUMBER);
     }
 
-    // If this edit is creating the entry for the first time, every index must have a value.
-    if (success && !entry.readable) {
-      for (int i = 0; i < valueCount; i++) {
-        if (!editor.written[i]) {
-          editor.abort();
-          throw new IllegalStateException("Newly created entry didn't create value for index " + i);
+    private synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException {
+        initialize();
+
+        checkNotClosed();
+        validateKey(key);
+        Entry entry = lruEntries.get(key);
+        if (expectedSequenceNumber != ANY_SEQUENCE_NUMBER && (entry == null
+                || entry.sequenceNumber != expectedSequenceNumber)) {
+            return null; // Snapshot is stale.
         }
-        if (!fileSystem.exists(entry.dirtyFiles[i])) {
-          editor.abort();
-          return;
+        if (entry != null && entry.currentEditor != null) {
+            return null; // Another edit is in progress.
         }
-      }
-    }
 
-    for (int i = 0; i < valueCount; i++) {
-      File dirty = entry.dirtyFiles[i];
-      if (success) {
-        if (fileSystem.exists(dirty)) {
-          File clean = entry.cleanFiles[i];
-          fileSystem.rename(dirty, clean);
-          long oldLength = entry.lengths[i];
-          long newLength = fileSystem.size(clean);
-          entry.lengths[i] = newLength;
-          size = size - oldLength + newLength;
-        }
-      } else {
-        fileSystem.delete(dirty);
-      }
+        // Flush the journal before creating files to prevent file leaks.
+        journalWriter.writeUtf8(DIRTY).writeByte(' ').writeUtf8(key).writeByte('\n');
+        journalWriter.flush();
+
+        if (hasJournalErrors) {
+            return null; // Don't edit; the journal can't be written.
+        }
+
+        if (entry == null) {
+            entry = new Entry(key);
+            lruEntries.put(key, entry);
+        }
+        Editor editor = new Editor(entry);
+        entry.currentEditor = editor;
+        return editor;
     }
 
-    redundantOpCount++;
-    entry.currentEditor = null;
-    if (entry.readable | success) {
-      entry.readable = true;
-      journalWriter.writeUtf8(CLEAN).writeByte(' ');
-      journalWriter.writeUtf8(entry.key);
-      entry.writeLengths(journalWriter);
-      journalWriter.writeByte('\n');
-      if (success) {
-        entry.sequenceNumber = nextSequenceNumber++;
-      }
-    } else {
-      lruEntries.remove(entry.key);
-      journalWriter.writeUtf8(REMOVE).writeByte(' ');
-      journalWriter.writeUtf8(entry.key);
-      journalWriter.writeByte('\n');
+    /**
+     * Returns the directory where this cache stores its data.
+     */
+    public File getDirectory() {
+        return directory;
     }
-    journalWriter.flush();
 
-    if (size > maxSize || journalRebuildRequired()) {
-      executor.execute(cleanupRunnable);
+    /**
+     * Returns the maximum number of bytes that this cache should use to store
+     * its data.
+     */
+    public synchronized long getMaxSize() {
+        return maxSize;
     }
-  }
-
-  /**
-   * We only rebuild the journal when it will halve the size of the journal
-   * and eliminate at least 2000 ops.
-   */
-  private boolean journalRebuildRequired() {
-    final int redundantOpCompactThreshold = 2000;
-    return redundantOpCount >= redundantOpCompactThreshold
-        && redundantOpCount >= lruEntries.size();
-  }
-
-  /**
-   * Drops the entry for {@code key} if it exists and can be removed. If the
-   * entry for {@code key} is currently being edited, that edit will complete
-   * normally but its value will not be stored.
-   *
-   * @return true if an entry was removed.
-   */
-  public synchronized boolean remove(String key) throws IOException {
-    initialize();
-
-    checkNotClosed();
-    validateKey(key);
-    Entry entry = lruEntries.get(key);
-    if (entry == null) return false;
-    return removeEntry(entry);
-  }
-
-  private boolean removeEntry(Entry entry) throws IOException {
-    if (entry.currentEditor != null) {
-      entry.currentEditor.hasErrors = true; // Prevent the edit from completing normally.
+
+    /**
+     * Changes the maximum number of bytes the cache can store and queues a job
+     * to trim the existing store, if necessary.
+     */
+    public synchronized void setMaxSize(long maxSize) {
+        this.maxSize = maxSize;
+        if (initialized) {
+            executor.execute(cleanupRunnable);
+        }
     }
 
-    for (int i = 0; i < valueCount; i++) {
-      fileSystem.delete(entry.cleanFiles[i]);
-      size -= entry.lengths[i];
-      entry.lengths[i] = 0;
+    /**
+     * Returns the number of bytes currently being used to store the values in
+     * this cache. This may be greater than the max size if a background
+     * deletion is pending.
+     */
+    public synchronized long size() throws IOException {
+        initialize();
+        return size;
     }
 
-    redundantOpCount++;
-    journalWriter.writeUtf8(REMOVE).writeByte(' ').writeUtf8(entry.key).writeByte('\n');
-    lruEntries.remove(entry.key);
+    private synchronized void completeEdit(Editor editor, boolean success) throws IOException {
+        Entry entry = editor.entry;
+        if (entry.currentEditor != editor) {
+            throw new IllegalStateException();
+        }
 
-    if (journalRebuildRequired()) {
-      executor.execute(cleanupRunnable);
-    }
+        // If this edit is creating the entry for the first time, every index must have a value.
+        if (success && !entry.readable) {
+            for (int i = 0; i < valueCount; i++) {
+                if (!editor.written[i]) {
+                    editor.abort();
+                    throw new IllegalStateException("Newly created entry didn't create value for index " + i);
+                }
+                if (!fileSystem.exists(entry.dirtyFiles[i])) {
+                    editor.abort();
+                    return;
+                }
+            }
+        }
 
-    return true;
-  }
+        for (int i = 0; i < valueCount; i++) {
+            File dirty = entry.dirtyFiles[i];
+            if (success) {
+                if (fileSystem.exists(dirty)) {
+                    File clean = entry.cleanFiles[i];
+                    fileSystem.rename(dirty, clean);
+                    long oldLength = entry.lengths[i];
+                    long newLength = fileSystem.size(clean);
+                    entry.lengths[i] = newLength;
+                    size = size - oldLength + newLength;
+                }
+            } else {
+                fileSystem.delete(dirty);
+            }
+        }
 
-  /** Returns true if this cache has been closed. */
-  public synchronized boolean isClosed() {
-    return closed;
-  }
+        redundantOpCount++;
+        entry.currentEditor = null;
+        if (entry.readable | success) {
+            entry.readable = true;
+            journalWriter.writeUtf8(CLEAN).writeByte(' ');
+            journalWriter.writeUtf8(entry.key);
+            entry.writeLengths(journalWriter);
+            journalWriter.writeByte('\n');
+            if (success) {
+                entry.sequenceNumber = nextSequenceNumber++;
+            }
+        } else {
+            lruEntries.remove(entry.key);
+            journalWriter.writeUtf8(REMOVE).writeByte(' ');
+            journalWriter.writeUtf8(entry.key);
+            journalWriter.writeByte('\n');
+        }
+        journalWriter.flush();
 
-  private synchronized void checkNotClosed() {
-    if (isClosed()) {
-      throw new IllegalStateException("cache is closed");
-    }
-  }
-
-  /** Force buffered operations to the filesystem. */
-  public synchronized void flush() throws IOException {
-    if (!initialized) return;
-
-    checkNotClosed();
-    trimToSize();
-    journalWriter.flush();
-  }
-
-  /** Closes this cache. Stored values will remain on the filesystem. */
-  public synchronized void close() throws IOException {
-    if (!initialized || closed) {
-      closed = true;
-      return;
-    }
-    // Copying for safe iteration.
-    for (Entry entry : lruEntries.values().toArray(new Entry[lruEntries.size()])) {
-      if (entry.currentEditor != null) {
-        entry.currentEditor.abort();
-      }
-    }
-    trimToSize();
-    journalWriter.close();
-    journalWriter = null;
-    closed = true;
-  }
-
-  private void trimToSize() throws IOException {
-    while (size > maxSize) {
-      Entry toEvict = lruEntries.values().iterator().next();
-      removeEntry(toEvict);
+        if (size > maxSize || journalRebuildRequired()) {
+            executor.execute(cleanupRunnable);
+        }
     }
-  }
-
-  /**
-   * Closes the cache and deletes all of its stored values. This will delete
-   * all files in the cache directory including files that weren't created by
-   * the cache.
-   */
-  public void delete() throws IOException {
-    close();
-    fileSystem.deleteContents(directory);
-  }
-
-  /**
-   * Deletes all stored values from the cache. In-flight edits will complete
-   * normally but their values will not be stored.
-   */
-  public synchronized void evictAll() throws IOException {
-    initialize();
-    // Copying for safe iteration.
-    for (Entry entry : lruEntries.values().toArray(new Entry[lruEntries.size()])) {
-      removeEntry(entry);
+
+    /**
+     * We only rebuild the journal when it will halve the size of the journal
+     * and eliminate at least 2000 ops.
+     */
+    private boolean journalRebuildRequired() {
+        final int redundantOpCompactThreshold = 2000;
+        return redundantOpCount >= redundantOpCompactThreshold
+                && redundantOpCount >= lruEntries.size();
     }
-  }
 
-  private void validateKey(String key) {
-    Matcher matcher = LEGAL_KEY_PATTERN.matcher(key);
-    if (!matcher.matches()) {
-      throw new IllegalArgumentException(
-          "keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"");
+    /**
+     * Drops the entry for {@code key} if it exists and can be removed. If the
+     * entry for {@code key} is currently being edited, that edit will complete
+     * normally but its value will not be stored.
+     *
+     * @return true if an entry was removed.
+     */
+    public synchronized boolean remove(String key) throws IOException {
+        initialize();
+
+        checkNotClosed();
+        validateKey(key);
+        Entry entry = lruEntries.get(key);
+        if (entry == null) return false;
+        return removeEntry(entry);
     }
-  }
-
-  /**
-   * Returns an iterator over the cache's current entries. This iterator doesn't throw {@code
-   * ConcurrentModificationException}, but if new entries are added while iterating, those new
-   * entries will not be returned by the iterator. If existing entries are removed during iteration,
-   * they will be absent (unless they were already returned).
-   *
-   * <p>If there are I/O problems during iteration, this iterator fails silently. For example, if
-   * the hosting filesystem becomes unreachable, the iterator will omit elements rather than
-   * throwing exceptions.
-   *
-   * <p><strong>The caller must {@link Snapshot#close close}</strong> each snapshot returned by
-   * {@link Iterator#next}. Failing to do so leaks open files!
-   *
-   * <p>The returned iterator supports {@link Iterator#remove}.
-   */
-  public synchronized Iterator<Snapshot> snapshots() throws IOException {
-    initialize();
-    return new Iterator<Snapshot>() {
-      /** Iterate a copy of the entries to defend against concurrent modification errors. */
-      final Iterator<Entry> delegate = new ArrayList<>(lruEntries.values()).iterator();
-
-      /** The snapshot to return from {@link #next}. Null if we haven't computed that yet. */
-      Snapshot nextSnapshot;
-
-      /** The snapshot to remove with {@link #remove}. Null if removal is illegal. */
-      Snapshot removeSnapshot;
-
-      @Override public boolean hasNext() {
-        if (nextSnapshot != null) return true;
-
-        synchronized (DiskLruCache.this) {
-          // If the cache is closed, truncate the iterator.
-          if (closed) return false;
-
-          while (delegate.hasNext()) {
-            Entry entry = delegate.next();
-            Snapshot snapshot = entry.snapshot();
-            if (snapshot == null) continue; // Evicted since we copied the entries.
-            nextSnapshot = snapshot;
-            return true;
-          }
-        }
-
-        return false;
-      }
-
-      @Override public Snapshot next() {
-        if (!hasNext()) throw new NoSuchElementException();
-        removeSnapshot = nextSnapshot;
-        nextSnapshot = null;
-        return removeSnapshot;
-      }
-
-      @Override public void remove() {
-        if (removeSnapshot == null) throw new IllegalStateException("remove() before next()");
-        try {
-          DiskLruCache.this.remove(removeSnapshot.key);
-        } catch (IOException ignored) {
-          // Nothing useful to do here. We failed to remove from the cache. Most likely that's
-          // because we couldn't update the journal, but the cached entry will still be gone.
-        } finally {
-          removeSnapshot = null;
+
+    private boolean removeEntry(Entry entry) throws IOException {
+        if (entry.currentEditor != null) {
+            entry.currentEditor.hasErrors = true; // Prevent the edit from completing normally.
+        }
+
+        for (int i = 0; i < valueCount; i++) {
+            fileSystem.delete(entry.cleanFiles[i]);
+            size -= entry.lengths[i];
+            entry.lengths[i] = 0;
+        }
+
+        redundantOpCount++;
+        journalWriter.writeUtf8(REMOVE).writeByte(' ').writeUtf8(entry.key).writeByte('\n');
+        lruEntries.remove(entry.key);
+
+        if (journalRebuildRequired()) {
+            executor.execute(cleanupRunnable);
         }
-      }
-    };
-  }
-
-  /** A snapshot of the values for an entry. */
-  public final class Snapshot implements Closeable {
-    private final String key;
-    private final long sequenceNumber;
-    private final Source[] sources;
-    private final long[] lengths;
-
-    private Snapshot(String key, long sequenceNumber, Source[] sources, long[] lengths) {
-      this.key = key;
-      this.sequenceNumber = sequenceNumber;
-      this.sources = sources;
-      this.lengths = lengths;
-    }
 
-    public String key() {
-      return key;
+        return true;
     }
 
     /**
-     * Returns an editor for this snapshot's entry, or null if either the
-     * entry has changed since this snapshot was created or if another edit
-     * is in progress.
+     * Returns true if this cache has been closed.
      */
-    public Editor edit() throws IOException {
-      return DiskLruCache.this.edit(key, sequenceNumber);
+    public synchronized boolean isClosed() {
+        return closed;
     }
 
-    /** Returns the unbuffered stream with the value for {@code index}. */
-    public Source getSource(int index) {
-      return sources[index];
+    private synchronized void checkNotClosed() {
+        if (isClosed()) {
+            throw new IllegalStateException("cache is closed");
+        }
     }
 
-    /** Returns the byte length of the value for {@code index}. */
-    public long getLength(int index) {
-      return lengths[index];
+    /**
+     * Force buffered operations to the filesystem.
+     */
+    public synchronized void flush() throws IOException {
+        if (!initialized) return;
+
+        checkNotClosed();
+        trimToSize();
+        journalWriter.flush();
     }
 
-    public void close() {
-      for (Source in : sources) {
-        Util.closeQuietly(in);
-      }
+    /**
+     * Closes this cache. Stored values will remain on the filesystem.
+     */
+    public synchronized void close() throws IOException {
+        if (!initialized || closed) {
+            closed = true;
+            return;
+        }
+        // Copying for safe iteration.
+        for (Entry entry : lruEntries.values().toArray(new Entry[lruEntries.size()])) {
+            if (entry.currentEditor != null) {
+                entry.currentEditor.abort();
+            }
+        }
+        trimToSize();
+        journalWriter.close();
+        journalWriter = null;
+        closed = true;
     }
-  }
 
-  private static final Sink NULL_SINK = new Sink() {
-    @Override public void write(Buffer source, long byteCount) throws IOException {
-      source.skip(byteCount);
+    private void trimToSize() throws IOException {
+        while (size > maxSize) {
+            Entry toEvict = lruEntries.values().iterator().next();
+            removeEntry(toEvict);
+        }
     }
 
-    @Override public void flush() throws IOException {
+    /**
+     * Closes the cache and deletes all of its stored values. This will delete
+     * all files in the cache directory including files that weren't created by
+     * the cache.
+     */
+    public void delete() throws IOException {
+        close();
+        fileSystem.deleteContents(directory);
     }
 
-    @Override public Timeout timeout() {
-      return Timeout.NONE;
+    /**
+     * Deletes all stored values from the cache. In-flight edits will complete
+     * normally but their values will not be stored.
+     */
+    public synchronized void evictAll() throws IOException {
+        initialize();
+        // Copying for safe iteration.
+        for (Entry entry : lruEntries.values().toArray(new Entry[lruEntries.size()])) {
+            removeEntry(entry);
+        }
     }
 
-    @Override public void close() throws IOException {
+    private void validateKey(String key) {
+        Matcher matcher = LEGAL_KEY_PATTERN.matcher(key);
+        if (!matcher.matches()) {
+            throw new IllegalArgumentException(
+                    "keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"");
+        }
     }
-  };
-
-  /** Edits the values for an entry. */
-  public final class Editor {
-    private final Entry entry;
-    private final boolean[] written;
-    private boolean hasErrors;
-    private boolean committed;
-
-    private Editor(Entry entry) {
-      this.entry = entry;
-      this.written = (entry.readable) ? null : new boolean[valueCount];
+
+    /**
+     * Returns an iterator over the cache's current entries. This iterator doesn't throw {@code
+     * ConcurrentModificationException}, but if new entries are added while iterating, those new
+     * entries will not be returned by the iterator. If existing entries are removed during iteration,
+     * they will be absent (unless they were already returned).
+     * <p/>
+     * <p>If there are I/O problems during iteration, this iterator fails silently. For example, if
+     * the hosting filesystem becomes unreachable, the iterator will omit elements rather than
+     * throwing exceptions.
+     * <p/>
+     * <p><strong>The caller must {@link Snapshot#close close}</strong> each snapshot returned by
+     * {@link Iterator#next}. Failing to do so leaks open files!
+     * <p/>
+     * <p>The returned iterator supports {@link Iterator#remove}.
+     */
+    public synchronized Iterator<Snapshot> snapshots() throws IOException {
+        initialize();
+        return new Iterator<Snapshot>() {
+            /** Iterate a copy of the entries to defend against concurrent modification errors. */
+            final Iterator<Entry> delegate = new ArrayList<>(lruEntries.values()).iterator();
+
+            /** The snapshot to return from {@link #next}. Null if we haven't computed that yet. */
+            Snapshot nextSnapshot;
+
+            /** The snapshot to remove with {@link #remove}. Null if removal is illegal. */
+            Snapshot removeSnapshot;
+
+            @Override
+            public boolean hasNext() {
+                if (nextSnapshot != null) return true;
+
+                synchronized (DiskLruCache.this) {
+                    // If the cache is closed, truncate the iterator.
+                    if (closed) return false;
+
+                    while (delegate.hasNext()) {
+                        Entry entry = delegate.next();
+                        Snapshot snapshot = entry.snapshot();
+                        if (snapshot == null) continue; // Evicted since we copied the entries.
+                        nextSnapshot = snapshot;
+                        return true;
+                    }
+                }
+
+                return false;
+            }
+
+            @Override
+            public Snapshot next() {
+                if (!hasNext()) throw new NoSuchElementException();
+                removeSnapshot = nextSnapshot;
+                nextSnapshot = null;
+                return removeSnapshot;
+            }
+
+            @Override
+            public void remove() {
+                if (removeSnapshot == null)
+                    throw new IllegalStateException("remove() before next()");
+                try {
+                    DiskLruCache.this.remove(removeSnapshot.key);
+                } catch (IOException ignored) {
+                    // Nothing useful to do here. We failed to remove from the cache. Most likely that's
+                    // because we couldn't update the journal, but the cached entry will still be gone.
+                } finally {
+                    removeSnapshot = null;
+                }
+            }
+        };
     }
 
     /**
-     * Returns an unbuffered input stream to read the last committed value,
-     * or null if no value has been committed.
+     * A snapshot of the values for an entry.
      */
-    public Source newSource(int index) throws IOException {
-      synchronized (DiskLruCache.this) {
-        if (entry.currentEditor != this) {
-          throw new IllegalStateException();
+    public final class Snapshot implements Closeable {
+        private final String key;
+        private final long sequenceNumber;
+        private final Source[] sources;
+        private final long[] lengths;
+
+        private Snapshot(String key, long sequenceNumber, Source[] sources, long[] lengths) {
+            this.key = key;
+            this.sequenceNumber = sequenceNumber;
+            this.sources = sources;
+            this.lengths = lengths;
         }
-        if (!entry.readable) {
-          return null;
+
+        public String key() {
+            return key;
         }
-        try {
-          return fileSystem.source(entry.cleanFiles[index]);
-        } catch (FileNotFoundException e) {
-          return null;
+
+        /**
+         * Returns an editor for this snapshot's entry, or null if either the
+         * entry has changed since this snapshot was created or if another edit
+         * is in progress.
+         */
+        public Editor edit() throws IOException {
+            return DiskLruCache.this.edit(key, sequenceNumber);
+        }
+
+        /**
+         * Returns the unbuffered stream with the value for {@code index}.
+         */
+        public Source getSource(int index) {
+            return sources[index];
+        }
+
+        /**
+         * Returns the byte length of the value for {@code index}.
+         */
+        public long getLength(int index) {
+            return lengths[index];
+        }
+
+        public void close() {
+            for (Source in : sources) {
+                Util.closeQuietly(in);
+            }
         }
-      }
     }
 
+    private static final Sink NULL_SINK = new Sink() {
+        @Override
+        public void write(Buffer source, long byteCount) throws IOException {
+            source.skip(byteCount);
+        }
+
+        @Override
+        public void flush() throws IOException {
+        }
+
+        @Override
+        public Timeout timeout() {
+            return Timeout.NONE;
+        }
+
+        @Override
+        public void close() throws IOException {
+        }
+    };
+
     /**
-     * Returns a new unbuffered output stream to write the value at
-     * {@code index}. If the underlying output stream encounters errors
-     * when writing to the filesystem, this edit will be aborted when
-     * {@link #commit} is called. The returned output stream does not throw
-     * IOExceptions.
+     * Edits the values for an entry.
      */
-    public Sink newSink(int index) throws IOException {
-      synchronized (DiskLruCache.this) {
-        if (entry.currentEditor != this) {
-          throw new IllegalStateException();
+    public final class Editor {
+        private final Entry entry;
+        private final boolean[] written;
+        private boolean hasErrors;
+        private boolean committed;
+
+        private Editor(Entry entry) {
+            this.entry = entry;
+            this.written = (entry.readable) ? null : new boolean[valueCount];
         }
-        if (!entry.readable) {
-          written[index] = true;
+
+        /**
+         * Returns an unbuffered input stream to read the last committed value,
+         * or null if no value has been committed.
+         */
+        public Source newSource(int index) throws IOException {
+            synchronized (DiskLruCache.this) {
+                if (entry.currentEditor != this) {
+                    throw new IllegalStateException();
+                }
+                if (!entry.readable) {
+                    return null;
+                }
+                try {
+                    return fileSystem.source(entry.cleanFiles[index]);
+                } catch (FileNotFoundException e) {
+                    return null;
+                }
+            }
         }
-        File dirtyFile = entry.dirtyFiles[index];
-        Sink sink;
-        try {
-          sink = fileSystem.sink(dirtyFile);
-        } catch (FileNotFoundException e) {
-          return NULL_SINK;
+
+        /**
+         * Returns a new unbuffered output stream to write the value at
+         * {@code index}. If the underlying output stream encounters errors
+         * when writing to the filesystem, this edit will be aborted when
+         * {@link #commit} is called. The returned output stream does not throw
+         * IOExceptions.
+         */
+        public Sink newSink(int index) throws IOException {
+            synchronized (DiskLruCache.this) {
+                if (entry.currentEditor != this) {
+                    throw new IllegalStateException();
+                }
+                if (!entry.readable) {
+                    written[index] = true;
+                }
+                File dirtyFile = entry.dirtyFiles[index];
+                Sink sink;
+                try {
+                    sink = fileSystem.sink(dirtyFile);
+                } catch (FileNotFoundException e) {
+                    return NULL_SINK;
+                }
+                return new FaultHidingSink(sink) {
+                    @Override
+                    protected void onException(IOException e) {
+                        synchronized (DiskLruCache.this) {
+                            hasErrors = true;
+                        }
+                    }
+                };
+            }
         }
-        return new FaultHidingSink(sink) {
-          @Override protected void onException(IOException e) {
+
+        /**
+         * Commits this edit so it is visible to readers.  This releases the
+         * edit lock so another edit may be started on the same key.
+         */
+        public void commit() throws IOException {
             synchronized (DiskLruCache.this) {
-              hasErrors = true;
+                if (hasErrors) {
+                    completeEdit(this, false);
+                    removeEntry(entry); // The previous entry is stale.
+                } else {
+                    completeEdit(this, true);
+                }
+                committed = true;
             }
-          }
-        };
-      }
-    }
+        }
 
-    /**
-     * Commits this edit so it is visible to readers.  This releases the
-     * edit lock so another edit may be started on the same key.
-     */
-    public void commit() throws IOException {
-      synchronized (DiskLruCache.this) {
-        if (hasErrors) {
-          completeEdit(this, false);
-          removeEntry(entry); // The previous entry is stale.
-        } else {
-          completeEdit(this, true);
+        /**
+         * Aborts this edit. This releases the edit lock so another edit may be
+         * started on the same key.
+         */
+        public void abort() throws IOException {
+            synchronized (DiskLruCache.this) {
+                completeEdit(this, false);
+            }
         }
-        committed = true;
-      }
-    }
 
-    /**
-     * Aborts this edit. This releases the edit lock so another edit may be
-     * started on the same key.
-     */
-    public void abort() throws IOException {
-      synchronized (DiskLruCache.this) {
-        completeEdit(this, false);
-      }
+        public void abortUnlessCommitted() {
+            synchronized (DiskLruCache.this) {
+                if (!committed) {
+                    try {
+                        completeEdit(this, false);
+                    } catch (IOException ignored) {
+                    }
+                }
+            }
+        }
     }
 
-    public void abortUnlessCommitted() {
-      synchronized (DiskLruCache.this) {
-        if (!committed) {
-          try {
-            completeEdit(this, false);
-          } catch (IOException ignored) {
-          }
+    private final class Entry {
+        private final String key;
+
+        /**
+         * Lengths of this entry's files.
+         */
+        private final long[] lengths;
+        private final File[] cleanFiles;
+        private final File[] dirtyFiles;
+
+        /**
+         * True if this entry has ever been published.
+         */
+        private boolean readable;
+
+        /**
+         * The ongoing edit or null if this entry is not being edited.
+         */
+        private Editor currentEditor;
+
+        /**
+         * The sequence number of the most recently committed edit to this entry.
+         */
+        private long sequenceNumber;
+
+        private Entry(String key) {
+            this.key = key;
+
+            lengths = new long[valueCount];
+            cleanFiles = new File[valueCount];
+            dirtyFiles = new File[valueCount];
+
+            // The names are repetitive so re-use the same builder to avoid allocations.
+            StringBuilder fileBuilder = new StringBuilder(key).append('.');
+            int truncateTo = fileBuilder.length();
+            for (int i = 0; i < valueCount; i++) {
+                fileBuilder.append(i);
+                cleanFiles[i] = new File(directory, fileBuilder.toString());
+                fileBuilder.append(".tmp");
+                dirtyFiles[i] = new File(directory, fileBuilder.toString());
+                fileBuilder.setLength(truncateTo);
+            }
         }
-      }
-    }
-  }
-
-  private final class Entry {
-    private final String key;
-
-    /** Lengths of this entry's files. */
-    private final long[] lengths;
-    private final File[] cleanFiles;
-    private final File[] dirtyFiles;
-
-    /** True if this entry has ever been published. */
-    private boolean readable;
-
-    /** The ongoing edit or null if this entry is not being edited. */
-    private Editor currentEditor;
-
-    /** The sequence number of the most recently committed edit to this entry. */
-    private long sequenceNumber;
-
-    private Entry(String key) {
-      this.key = key;
-
-      lengths = new long[valueCount];
-      cleanFiles = new File[valueCount];
-      dirtyFiles = new File[valueCount];
-
-      // The names are repetitive so re-use the same builder to avoid allocations.
-      StringBuilder fileBuilder = new StringBuilder(key).append('.');
-      int truncateTo = fileBuilder.length();
-      for (int i = 0; i < valueCount; i++) {
-        fileBuilder.append(i);
-        cleanFiles[i] = new File(directory, fileBuilder.toString());
-        fileBuilder.append(".tmp");
-        dirtyFiles[i] = new File(directory, fileBuilder.toString());
-        fileBuilder.setLength(truncateTo);
-      }
-    }
 
-    /** Set lengths using decimal numbers like "10123". */
-    private void setLengths(String[] strings) throws IOException {
-      if (strings.length != valueCount) {
-        throw invalidLengths(strings);
-      }
+        /**
+         * Set lengths using decimal numbers like "10123".
+         */
+        private void setLengths(String[] strings) throws IOException {
+            if (strings.length != valueCount) {
+                throw invalidLengths(strings);
+            }
 
-      try {
-        for (int i = 0; i < strings.length; i++) {
-          lengths[i] = Long.parseLong(strings[i]);
+            try {
+                for (int i = 0; i < strings.length; i++) {
+                    lengths[i] = Long.parseLong(strings[i]);
+                }
+            } catch (NumberFormatException e) {
+                throw invalidLengths(strings);
+            }
         }
-      } catch (NumberFormatException e) {
-        throw invalidLengths(strings);
-      }
-    }
-
-    /** Append space-prefixed lengths to {@code writer}. */
-    void writeLengths(BufferedSink writer) throws IOException {
-      for (long length : lengths) {
-        writer.writeByte(' ').writeDecimalLong(length);
-      }
-    }
 
-    private IOException invalidLengths(String[] strings) throws IOException {
-      throw new IOException("unexpected journal line: " + Arrays.toString(strings));
-    }
+        /**
+         * Append space-prefixed lengths to {@code writer}.
+         */
+        void writeLengths(BufferedSink writer) throws IOException {
+            for (long length : lengths) {
+                writer.writeByte(' ').writeDecimalLong(length);
+            }
+        }
 
-    /**
-     * Returns a snapshot of this entry. This opens all streams eagerly to guarantee that we see a
-     * single published snapshot. If we opened streams lazily then the streams could come from
-     * different edits.
-     */
-    Snapshot snapshot() {
-      if (!Thread.holdsLock(DiskLruCache.this)) throw new AssertionError();
+        private IOException invalidLengths(String[] strings) throws IOException {
+            throw new IOException("unexpected journal line: " + Arrays.toString(strings));
+        }
 
-      Source[] sources = new Source[valueCount];
-      long[] lengths = this.lengths.clone(); // Defensive copy since these can be zeroed out.
-      try {
-        for (int i = 0; i < valueCount; i++) {
-          sources[i] = fileSystem.source(cleanFiles[i]);
+        /**
+         * Returns a snapshot of this entry. This opens all streams eagerly to guarantee that we see a
+         * single published snapshot. If we opened streams lazily then the streams could come from
+         * different edits.
+         */
+        Snapshot snapshot() {
+            if (!Thread.holdsLock(DiskLruCache.this)) throw new AssertionError();
+
+            Source[] sources = new Source[valueCount];
+            long[] lengths = this.lengths.clone(); // Defensive copy since these can be zeroed out.
+            try {
+                for (int i = 0; i < valueCount; i++) {
+                    sources[i] = fileSystem.source(cleanFiles[i]);
+                }
+                return new Snapshot(key, sequenceNumber, sources, lengths);
+            } catch (FileNotFoundException e) {
+                // A file must have been deleted manually!
+                for (int i = 0; i < valueCount; i++) {
+                    if (sources[i] != null) {
+                        Util.closeQuietly(sources[i]);
+                    } else {
+                        break;
+                    }
+                }
+                return null;
+            }
         }
-        return new Snapshot(key, sequenceNumber, sources, lengths);
-      } catch (FileNotFoundException e) {
-        // A file must have been deleted manually!
-        for (int i = 0; i < valueCount; i++) {
-          if (sources[i] != null) {
-            Util.closeQuietly(sources[i]);
-          } else {
-            break;
-          }
-        }
-        return null;
-      }
     }
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/FaultHidingSink.java b/okhttp/src/main/java/com/squareup/okhttp/internal/FaultHidingSink.java
index 91e990db8d..951eaf8813 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/FaultHidingSink.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/FaultHidingSink.java
@@ -1,51 +1,57 @@
 package com.squareup.okhttp.internal;
 
 import java.io.IOException;
+
 import okio.Buffer;
 import okio.ForwardingSink;
 import okio.Sink;
 
-/** A sink that never throws IOExceptions, even if the underlying sink does. */
+/**
+ * A sink that never throws IOExceptions, even if the underlying sink does.
+ */
 class FaultHidingSink extends ForwardingSink {
-  private boolean hasErrors;
-
-  public FaultHidingSink(Sink delegate) {
-    super(delegate);
-  }
+    private boolean hasErrors;
 
-  @Override public void write(Buffer source, long byteCount) throws IOException {
-    if (hasErrors) {
-      source.skip(byteCount);
-      return;
+    public FaultHidingSink(Sink delegate) {
+        super(delegate);
     }
-    try {
-      super.write(source, byteCount);
-    } catch (IOException e) {
-      hasErrors = true;
-      onException(e);
+
+    @Override
+    public void write(Buffer source, long byteCount) throws IOException {
+        if (hasErrors) {
+            source.skip(byteCount);
+            return;
+        }
+        try {
+            super.write(source, byteCount);
+        } catch (IOException e) {
+            hasErrors = true;
+            onException(e);
+        }
     }
-  }
-
-  @Override public void flush() throws IOException {
-    if (hasErrors) return;
-    try {
-      super.flush();
-    } catch (IOException e) {
-      hasErrors = true;
-      onException(e);
+
+    @Override
+    public void flush() throws IOException {
+        if (hasErrors) return;
+        try {
+            super.flush();
+        } catch (IOException e) {
+            hasErrors = true;
+            onException(e);
+        }
     }
-  }
-
-  @Override public void close() throws IOException {
-    if (hasErrors) return;
-    try {
-      super.close();
-    } catch (IOException e) {
-      hasErrors = true;
-      onException(e);
+
+    @Override
+    public void close() throws IOException {
+        if (hasErrors) return;
+        try {
+            super.close();
+        } catch (IOException e) {
+            hasErrors = true;
+            onException(e);
+        }
     }
-  }
 
-  protected void onException(IOException e) {
-  }
+    protected void onException(IOException e) {
+    }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Internal.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Internal.java
index 1e583ba1b3..231a5159da 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Internal.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/Internal.java
@@ -27,9 +27,12 @@
 import com.squareup.okhttp.internal.http.HttpEngine;
 import com.squareup.okhttp.internal.http.RouteException;
 import com.squareup.okhttp.internal.http.Transport;
+
 import java.io.IOException;
 import java.util.logging.Logger;
+
 import javax.net.ssl.SSLSocket;
+
 import okio.BufferedSink;
 import okio.BufferedSource;
 
@@ -39,57 +42,62 @@
  * interface is in {@link com.squareup.okhttp.OkHttpClient}.
  */
 public abstract class Internal {
-  public static final Logger logger = Logger.getLogger(OkHttpClient.class.getName());
+    public static final Logger logger = Logger.getLogger(OkHttpClient.class.getName());
+
+    public static void initializeInstanceForTests() {
+        // Needed in tests to ensure that the instance is actually pointing to something.
+        new OkHttpClient();
+    }
+
+    public static Internal instance;
+
+    public abstract Transport newTransport(Connection connection, HttpEngine httpEngine)
+            throws IOException;
+
+    public abstract boolean clearOwner(Connection connection);
+
+    public abstract void closeIfOwnedBy(Connection connection, Object owner) throws IOException;
 
-  public static void initializeInstanceForTests() {
-    // Needed in tests to ensure that the instance is actually pointing to something.
-    new OkHttpClient();
-  }
+    public abstract int recycleCount(Connection connection);
 
-  public static Internal instance;
+    public abstract void setProtocol(Connection connection, Protocol protocol);
 
-  public abstract Transport newTransport(Connection connection, HttpEngine httpEngine)
-      throws IOException;
+    public abstract void setOwner(Connection connection, HttpEngine httpEngine);
 
-  public abstract boolean clearOwner(Connection connection);
+    public abstract boolean isReadable(Connection pooled);
 
-  public abstract void closeIfOwnedBy(Connection connection, Object owner) throws IOException;
+    public abstract void addLenient(Headers.Builder builder, String line);
 
-  public abstract int recycleCount(Connection connection);
+    public abstract void addLenient(Headers.Builder builder, String name, String value);
 
-  public abstract void setProtocol(Connection connection, Protocol protocol);
+    public abstract void setCache(OkHttpClient client, InternalCache internalCache);
 
-  public abstract void setOwner(Connection connection, HttpEngine httpEngine);
+    public abstract InternalCache internalCache(OkHttpClient client);
 
-  public abstract boolean isReadable(Connection pooled);
+    public abstract void recycle(ConnectionPool pool, Connection connection);
 
-  public abstract void addLenient(Headers.Builder builder, String line);
+    public abstract RouteDatabase routeDatabase(OkHttpClient client);
 
-  public abstract void addLenient(Headers.Builder builder, String name, String value);
+    public abstract Network network(OkHttpClient client);
 
-  public abstract void setCache(OkHttpClient client, InternalCache internalCache);
+    public abstract void setNetwork(OkHttpClient client, Network network);
 
-  public abstract InternalCache internalCache(OkHttpClient client);
+    public abstract void connectAndSetOwner(OkHttpClient client, Connection connection,
+                                            HttpEngine owner, Request request) throws RouteException;
 
-  public abstract void recycle(ConnectionPool pool, Connection connection);
+    public abstract void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket,
+                               boolean isFallback);
 
-  public abstract RouteDatabase routeDatabase(OkHttpClient client);
+    // TODO delete the following when web sockets move into the main package.
+    public abstract void callEnqueue(Call call, Callback responseCallback, boolean forWebSocket);
 
-  public abstract Network network(OkHttpClient client);
+    public abstract void callEngineReleaseConnection(Call call) throws IOException;
 
-  public abstract void setNetwork(OkHttpClient client, Network network);
+    public abstract Connection callEngineGetConnection(Call call);
 
-  public abstract void connectAndSetOwner(OkHttpClient client, Connection connection,
-      HttpEngine owner, Request request) throws RouteException;
+    public abstract BufferedSource connectionRawSource(Connection connection);
 
-  public abstract void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket,
-      boolean isFallback);
+    public abstract BufferedSink connectionRawSink(Connection connection);
 
-  // TODO delete the following when web sockets move into the main package.
-  public abstract void callEnqueue(Call call, Callback responseCallback, boolean forWebSocket);
-  public abstract void callEngineReleaseConnection(Call call) throws IOException;
-  public abstract Connection callEngineGetConnection(Call call);
-  public abstract BufferedSource connectionRawSource(Connection connection);
-  public abstract BufferedSink connectionRawSink(Connection connection);
-  public abstract void connectionSetOwner(Connection connection, Object owner);
+    public abstract void connectionSetOwner(Connection connection, Object owner);
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/InternalCache.java b/okhttp/src/main/java/com/squareup/okhttp/internal/InternalCache.java
index 4925358225..6250e84518 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/InternalCache.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/InternalCache.java
@@ -19,6 +19,7 @@
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.internal.http.CacheRequest;
 import com.squareup.okhttp.internal.http.CacheStrategy;
+
 import java.io.IOException;
 
 /**
@@ -26,27 +27,31 @@
  * instead use {@link com.squareup.okhttp.Cache}.
  */
 public interface InternalCache {
-  Response get(Request request) throws IOException;
+    Response get(Request request) throws IOException;
 
-  CacheRequest put(Response response) throws IOException;
+    CacheRequest put(Response response) throws IOException;
 
-  /**
-   * Remove any cache entries for the supplied {@code request}. This is invoked
-   * when the client invalidates the cache, such as when making POST requests.
-   */
-  void remove(Request request) throws IOException;
+    /**
+     * Remove any cache entries for the supplied {@code request}. This is invoked
+     * when the client invalidates the cache, such as when making POST requests.
+     */
+    void remove(Request request) throws IOException;
 
-  /**
-   * Handles a conditional request hit by updating the stored cache response
-   * with the headers from {@code network}. The cached response body is not
-   * updated. If the stored response has changed since {@code cached} was
-   * returned, this does nothing.
-   */
-  void update(Response cached, Response network) throws IOException;
+    /**
+     * Handles a conditional request hit by updating the stored cache response
+     * with the headers from {@code network}. The cached response body is not
+     * updated. If the stored response has changed since {@code cached} was
+     * returned, this does nothing.
+     */
+    void update(Response cached, Response network) throws IOException;
 
-  /** Track an conditional GET that was satisfied by this cache. */
-  void trackConditionalCacheHit();
+    /**
+     * Track an conditional GET that was satisfied by this cache.
+     */
+    void trackConditionalCacheHit();
 
-  /** Track an HTTP response being satisfied with {@code cacheStrategy}. */
-  void trackResponse(CacheStrategy cacheStrategy);
+    /**
+     * Track an HTTP response being satisfied with {@code cacheStrategy}.
+     */
+    void trackResponse(CacheStrategy cacheStrategy);
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/NamedRunnable.java b/okhttp/src/main/java/com/squareup/okhttp/internal/NamedRunnable.java
index 7a02ecfbde..7822a1161c 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/NamedRunnable.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/NamedRunnable.java
@@ -20,21 +20,22 @@
  * Runnable implementation which always sets its thread name.
  */
 public abstract class NamedRunnable implements Runnable {
-  protected final String name;
+    protected final String name;
 
-  public NamedRunnable(String format, Object... args) {
-    this.name = String.format(format, args);
-  }
+    public NamedRunnable(String format, Object... args) {
+        this.name = String.format(format, args);
+    }
 
-  @Override public final void run() {
-    String oldName = Thread.currentThread().getName();
-    Thread.currentThread().setName(name);
-    try {
-      execute();
-    } finally {
-      Thread.currentThread().setName(oldName);
+    @Override
+    public final void run() {
+        String oldName = Thread.currentThread().getName();
+        Thread.currentThread().setName(name);
+        try {
+            execute();
+        } finally {
+            Thread.currentThread().setName(oldName);
+        }
     }
-  }
 
-  protected abstract void execute();
+    protected abstract void execute();
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Network.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Network.java
index a0070651b2..a7d351ea0f 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Network.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/Network.java
@@ -23,12 +23,13 @@
  * InetAddress#getAllByName} to make code more testable.
  */
 public interface Network {
-  Network DEFAULT = new Network() {
-    @Override public InetAddress[] resolveInetAddresses(String host) throws UnknownHostException {
-      if (host == null) throw new UnknownHostException("host == null");
-      return InetAddress.getAllByName(host);
-    }
-  };
+    Network DEFAULT = new Network() {
+        @Override
+        public InetAddress[] resolveInetAddresses(String host) throws UnknownHostException {
+            if (host == null) throw new UnknownHostException("host == null");
+            return InetAddress.getAllByName(host);
+        }
+    };
 
-  InetAddress[] resolveInetAddresses(String host) throws UnknownHostException;
+    InetAddress[] resolveInetAddresses(String host) throws UnknownHostException;
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/OptionalMethod.java b/okhttp/src/main/java/com/squareup/okhttp/internal/OptionalMethod.java
index 21b31cc491..cea98c7906 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/OptionalMethod.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/OptionalMethod.java
@@ -28,149 +28,151 @@
  */
 class OptionalMethod<T> {
 
-  /** The return type of the method. null means "don't care". */
-  private final Class<?> returnType;
-
-  private final String methodName;
-
-  private final Class[] methodParams;
-
-  /**
-   * Creates an optional method.
-   *
-   * @param returnType the return type to required, null if it does not matter
-   * @param methodName the name of the method
-   * @param methodParams the method parameter types
-   */
-  public OptionalMethod(Class<?> returnType, String methodName, Class... methodParams) {
-    this.returnType = returnType;
-    this.methodName = methodName;
-    this.methodParams = methodParams;
-  }
-
-  /**
-   * Returns true if the method exists on the supplied {@code target}.
-   */
-  public boolean isSupported(T target) {
-    return getMethod(target.getClass()) != null;
-  }
-
-  /**
-   * Invokes the method on {@code target} with {@code args}. If the method does not exist or is not
-   * public then {@code null} is returned. See also
-   * {@link #invokeOptionalWithoutCheckedException(Object, Object...)}.
-   *
-   * @throws IllegalArgumentException if the arguments are invalid
-   * @throws InvocationTargetException if the invocation throws an exception
-   */
-  public Object invokeOptional(T target, Object... args) throws InvocationTargetException {
-    Method m = getMethod(target.getClass());
-    if (m == null) {
-      return null;
+    /**
+     * The return type of the method. null means "don't care".
+     */
+    private final Class<?> returnType;
+
+    private final String methodName;
+
+    private final Class[] methodParams;
+
+    /**
+     * Creates an optional method.
+     *
+     * @param returnType   the return type to required, null if it does not matter
+     * @param methodName   the name of the method
+     * @param methodParams the method parameter types
+     */
+    public OptionalMethod(Class<?> returnType, String methodName, Class... methodParams) {
+        this.returnType = returnType;
+        this.methodName = methodName;
+        this.methodParams = methodParams;
     }
-    try {
-      return m.invoke(target, args);
-    } catch (IllegalAccessException e) {
-      return null;
+
+    /**
+     * Returns true if the method exists on the supplied {@code target}.
+     */
+    public boolean isSupported(T target) {
+        return getMethod(target.getClass()) != null;
     }
-  }
-
-  /**
-   * Invokes the method on {@code target}.  If the method does not exist or is not
-   * public then {@code null} is returned. Any RuntimeException thrown by the method is thrown,
-   * checked exceptions are wrapped in an {@link AssertionError}.
-   *
-   * @throws IllegalArgumentException if the arguments are invalid
-   */
-  public Object invokeOptionalWithoutCheckedException(T target, Object... args) {
-    try {
-      return invokeOptional(target, args);
-    } catch (InvocationTargetException e) {
-      Throwable targetException = e.getTargetException();
-      if (targetException instanceof RuntimeException) {
-        throw (RuntimeException) targetException;
-      }
-      AssertionError error = new AssertionError("Unexpected exception");
-      error.initCause(targetException);
-      throw error;
+
+    /**
+     * Invokes the method on {@code target} with {@code args}. If the method does not exist or is not
+     * public then {@code null} is returned. See also
+     * {@link #invokeOptionalWithoutCheckedException(Object, Object...)}.
+     *
+     * @throws IllegalArgumentException  if the arguments are invalid
+     * @throws InvocationTargetException if the invocation throws an exception
+     */
+    public Object invokeOptional(T target, Object... args) throws InvocationTargetException {
+        Method m = getMethod(target.getClass());
+        if (m == null) {
+            return null;
+        }
+        try {
+            return m.invoke(target, args);
+        } catch (IllegalAccessException e) {
+            return null;
+        }
     }
-  }
-
-  /**
-   * Invokes the method on {@code target} with {@code args}. Throws an error if the method is not
-   * supported. See also {@link #invokeWithoutCheckedException(Object, Object...)}.
-   *
-   * @throws IllegalArgumentException if the arguments are invalid
-   * @throws InvocationTargetException if the invocation throws an exception
-   */
-  public Object invoke(T target, Object... args) throws InvocationTargetException {
-    Method m = getMethod(target.getClass());
-    if (m == null) {
-      throw new AssertionError("Method " + methodName + " not supported for object " + target);
+
+    /**
+     * Invokes the method on {@code target}.  If the method does not exist or is not
+     * public then {@code null} is returned. Any RuntimeException thrown by the method is thrown,
+     * checked exceptions are wrapped in an {@link AssertionError}.
+     *
+     * @throws IllegalArgumentException if the arguments are invalid
+     */
+    public Object invokeOptionalWithoutCheckedException(T target, Object... args) {
+        try {
+            return invokeOptional(target, args);
+        } catch (InvocationTargetException e) {
+            Throwable targetException = e.getTargetException();
+            if (targetException instanceof RuntimeException) {
+                throw (RuntimeException) targetException;
+            }
+            AssertionError error = new AssertionError("Unexpected exception");
+            error.initCause(targetException);
+            throw error;
+        }
     }
-    try {
-      return m.invoke(target, args);
-    } catch (IllegalAccessException e) {
-      // Method should be public: we checked.
-      AssertionError error = new AssertionError("Unexpectedly could not call: " + m);
-      error.initCause(e);
-      throw error;
+
+    /**
+     * Invokes the method on {@code target} with {@code args}. Throws an error if the method is not
+     * supported. See also {@link #invokeWithoutCheckedException(Object, Object...)}.
+     *
+     * @throws IllegalArgumentException  if the arguments are invalid
+     * @throws InvocationTargetException if the invocation throws an exception
+     */
+    public Object invoke(T target, Object... args) throws InvocationTargetException {
+        Method m = getMethod(target.getClass());
+        if (m == null) {
+            throw new AssertionError("Method " + methodName + " not supported for object " + target);
+        }
+        try {
+            return m.invoke(target, args);
+        } catch (IllegalAccessException e) {
+            // Method should be public: we checked.
+            AssertionError error = new AssertionError("Unexpectedly could not call: " + m);
+            error.initCause(e);
+            throw error;
+        }
     }
-  }
-
-  /**
-   * Invokes the method on {@code target}. Throws an error if the method is not supported. Any
-   * RuntimeException thrown by the method is thrown, checked exceptions are wrapped in
-   * an {@link AssertionError}.
-   *
-   * @throws IllegalArgumentException if the arguments are invalid
-   */
-  public Object invokeWithoutCheckedException(T target, Object... args) {
-    try {
-      return invoke(target, args);
-    } catch (InvocationTargetException e) {
-      Throwable targetException = e.getTargetException();
-      if (targetException instanceof RuntimeException) {
-        throw (RuntimeException) targetException;
-      }
-      AssertionError error = new AssertionError("Unexpected exception");
-      error.initCause(targetException);
-      throw error;
+
+    /**
+     * Invokes the method on {@code target}. Throws an error if the method is not supported. Any
+     * RuntimeException thrown by the method is thrown, checked exceptions are wrapped in
+     * an {@link AssertionError}.
+     *
+     * @throws IllegalArgumentException if the arguments are invalid
+     */
+    public Object invokeWithoutCheckedException(T target, Object... args) {
+        try {
+            return invoke(target, args);
+        } catch (InvocationTargetException e) {
+            Throwable targetException = e.getTargetException();
+            if (targetException instanceof RuntimeException) {
+                throw (RuntimeException) targetException;
+            }
+            AssertionError error = new AssertionError("Unexpected exception");
+            error.initCause(targetException);
+            throw error;
+        }
     }
-  }
-
-  /**
-   * Perform a lookup for the method. No caching.
-   * In order to return a method the method name and arguments must match those specified when
-   * the {@link OptionalMethod} was created. If the return type is specified (i.e. non-null) it
-   * must also be compatible. The method must also be public.
-   */
-  private Method getMethod(Class<?> clazz) {
-    Method method = null;
-    if (methodName != null) {
-      method = getPublicMethod(clazz, methodName, methodParams);
-      if (method != null
-          && returnType != null
-          && !returnType.isAssignableFrom(method.getReturnType())) {
-
-        // If the return type is non-null it must be compatible.
-        method = null;
-      }
+
+    /**
+     * Perform a lookup for the method. No caching.
+     * In order to return a method the method name and arguments must match those specified when
+     * the {@link OptionalMethod} was created. If the return type is specified (i.e. non-null) it
+     * must also be compatible. The method must also be public.
+     */
+    private Method getMethod(Class<?> clazz) {
+        Method method = null;
+        if (methodName != null) {
+            method = getPublicMethod(clazz, methodName, methodParams);
+            if (method != null
+                    && returnType != null
+                    && !returnType.isAssignableFrom(method.getReturnType())) {
+
+                // If the return type is non-null it must be compatible.
+                method = null;
+            }
+        }
+        return method;
     }
-    return method;
-  }
-
-  private static Method getPublicMethod(Class<?> clazz, String methodName, Class[] parameterTypes) {
-    Method method = null;
-    try {
-      method = clazz.getMethod(methodName, parameterTypes);
-      if ((method.getModifiers() & Modifier.PUBLIC) == 0) {
-        method = null;
-      }
-    } catch (NoSuchMethodException e) {
-      // None.
+
+    private static Method getPublicMethod(Class<?> clazz, String methodName, Class[] parameterTypes) {
+        Method method = null;
+        try {
+            method = clazz.getMethod(methodName, parameterTypes);
+            if ((method.getModifiers() & Modifier.PUBLIC) == 0) {
+                method = null;
+            }
+        } catch (NoSuchMethodException e) {
+            // None.
+        }
+        return method;
     }
-    return method;
-  }
 }
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
index b9064959e0..ee6e8e885c 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
@@ -17,6 +17,7 @@
 package com.squareup.okhttp.internal;
 
 import com.squareup.okhttp.Protocol;
+
 import java.io.IOException;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.InvocationTargetException;
@@ -28,344 +29,369 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.logging.Level;
+
 import javax.net.ssl.SSLSocket;
+
 import okio.Buffer;
 
 import static com.squareup.okhttp.internal.Internal.logger;
 
 /**
  * Access to platform-specific features.
- *
+ * <p/>
  * <h3>Server name indication (SNI)</h3>
  * Supported on Android 2.3+.
- *
+ * <p/>
  * <h3>Session Tickets</h3>
  * Supported on Android 2.3+.
- *
+ * <p/>
  * <h3>Android Traffic Stats (Socket Tagging)</h3>
  * Supported on Android 4.0+.
- *
+ * <p/>
  * <h3>ALPN (Application Layer Protocol Negotiation)</h3>
  * Supported on Android 5.0+. The APIs were present in Android 4.4, but that implementation was
  * unstable.
- *
+ * <p/>
  * Supported on OpenJDK 7 and 8 (via the JettyALPN-boot library).
  */
 public class Platform {
-  private static final Platform PLATFORM = findPlatform();
-
-  public static Platform get() {
-    return PLATFORM;
-  }
-
-  /** Prefix used on custom headers. */
-  public String getPrefix() {
-    return "OkHttp";
-  }
-
-  public void logW(String warning) {
-    System.out.println(warning);
-  }
-
-  public void tagSocket(Socket socket) throws SocketException {
-  }
-
-  public void untagSocket(Socket socket) throws SocketException {
-  }
-
-  /**
-   * Configure TLS extensions on {@code sslSocket} for {@code route}.
-   *
-   * @param hostname non-null for client-side handshakes; null for
-   *     server-side handshakes.
-   */
-  public void configureTlsExtensions(SSLSocket sslSocket, String hostname,
-      List<Protocol> protocols) {
-  }
-
-  /**
-   * Called after the TLS handshake to release resources allocated by {@link
-   * #configureTlsExtensions}.
-   */
-  public void afterHandshake(SSLSocket sslSocket) {
-  }
-
-  /** Returns the negotiated protocol, or null if no protocol was negotiated. */
-  public String getSelectedProtocol(SSLSocket socket) {
-    return null;
-  }
-
-  public void connectSocket(Socket socket, InetSocketAddress address,
-      int connectTimeout) throws IOException {
-    socket.connect(address, connectTimeout);
-  }
-
-  /** Attempt to match the host runtime to a capable Platform implementation. */
-  private static Platform findPlatform() {
-    // Attempt to find Android 2.3+ APIs.
-    try {
-      try {
-        Class.forName("com.android.org.conscrypt.OpenSSLSocketImpl");
-      } catch (ClassNotFoundException e) {
-        // Older platform before being unbundled.
-        Class.forName("org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl");
-      }
-
-      OptionalMethod<Socket> setUseSessionTickets
-          = new OptionalMethod<>(null, "setUseSessionTickets", boolean.class);
-      OptionalMethod<Socket> setHostname
-          = new OptionalMethod<>(null, "setHostname", String.class);
-      Method trafficStatsTagSocket = null;
-      Method trafficStatsUntagSocket = null;
-      OptionalMethod<Socket> getAlpnSelectedProtocol = null;
-      OptionalMethod<Socket> setAlpnProtocols = null;
-
-      // Attempt to find Android 4.0+ APIs.
-      try {
-        Class<?> trafficStats = Class.forName("android.net.TrafficStats");
-        trafficStatsTagSocket = trafficStats.getMethod("tagSocket", Socket.class);
-        trafficStatsUntagSocket = trafficStats.getMethod("untagSocket", Socket.class);
-
-        // Attempt to find Android 5.0+ APIs.
-        try {
-          Class.forName("android.net.Network"); // Arbitrary class added in Android 5.0.
-          getAlpnSelectedProtocol = new OptionalMethod<>(byte[].class, "getAlpnSelectedProtocol");
-          setAlpnProtocols = new OptionalMethod<>(null, "setAlpnProtocols", byte[].class);
-        } catch (ClassNotFoundException ignored) {
-        }
-      } catch (ClassNotFoundException | NoSuchMethodException ignored) {
-      }
+    private static final Platform PLATFORM = findPlatform();
 
-      return new Android(setUseSessionTickets, setHostname, trafficStatsTagSocket,
-          trafficStatsUntagSocket, getAlpnSelectedProtocol, setAlpnProtocols);
-    } catch (ClassNotFoundException ignored) {
-      // This isn't an Android runtime.
+    public static Platform get() {
+        return PLATFORM;
     }
 
-    // Find Jetty's ALPN extension for OpenJDK.
-    try {
-      String negoClassName = "org.eclipse.jetty.alpn.ALPN";
-      Class<?> negoClass = Class.forName(negoClassName);
-      Class<?> providerClass = Class.forName(negoClassName + "$Provider");
-      Class<?> clientProviderClass = Class.forName(negoClassName + "$ClientProvider");
-      Class<?> serverProviderClass = Class.forName(negoClassName + "$ServerProvider");
-      Method putMethod = negoClass.getMethod("put", SSLSocket.class, providerClass);
-      Method getMethod = negoClass.getMethod("get", SSLSocket.class);
-      Method removeMethod = negoClass.getMethod("remove", SSLSocket.class);
-      return new JdkWithJettyBootPlatform(
-          putMethod, getMethod, removeMethod, clientProviderClass, serverProviderClass);
-    } catch (ClassNotFoundException | NoSuchMethodException ignored) {
+    /**
+     * Prefix used on custom headers.
+     */
+    public String getPrefix() {
+        return "OkHttp";
     }
 
-    return new Platform();
-  }
-
-  /** Android 2.3 or better. */
-  private static class Android extends Platform {
-    private final OptionalMethod<Socket> setUseSessionTickets;
-    private final OptionalMethod<Socket> setHostname;
-
-    // Non-null on Android 4.0+.
-    private final Method trafficStatsTagSocket;
-    private final Method trafficStatsUntagSocket;
-
-    // Non-null on Android 5.0+.
-    private final OptionalMethod<Socket> getAlpnSelectedProtocol;
-    private final OptionalMethod<Socket> setAlpnProtocols;
-
-    public Android(OptionalMethod<Socket> setUseSessionTickets, OptionalMethod<Socket> setHostname,
-        Method trafficStatsTagSocket, Method trafficStatsUntagSocket,
-        OptionalMethod<Socket> getAlpnSelectedProtocol, OptionalMethod<Socket> setAlpnProtocols) {
-      this.setUseSessionTickets = setUseSessionTickets;
-      this.setHostname = setHostname;
-      this.trafficStatsTagSocket = trafficStatsTagSocket;
-      this.trafficStatsUntagSocket = trafficStatsUntagSocket;
-      this.getAlpnSelectedProtocol = getAlpnSelectedProtocol;
-      this.setAlpnProtocols = setAlpnProtocols;
+    public void logW(String warning) {
+        System.out.println(warning);
     }
 
-    @Override public void connectSocket(Socket socket, InetSocketAddress address,
-        int connectTimeout) throws IOException {
-      try {
-        socket.connect(address, connectTimeout);
-      } catch (SecurityException se) {
-        // Before android 4.3, socket.connect could throw a SecurityException
-        // if opening a socket resulted in an EACCES error.
-        IOException ioException = new IOException("Exception in connect");
-        ioException.initCause(se);
-        throw ioException;
-      }
+    public void tagSocket(Socket socket) throws SocketException {
     }
 
-    @Override public void configureTlsExtensions(
-        SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
-      // Enable SNI and session tickets.
-      if (hostname != null) {
-        setUseSessionTickets.invokeOptionalWithoutCheckedException(sslSocket, true);
-        setHostname.invokeOptionalWithoutCheckedException(sslSocket, hostname);
-      }
-
-      // Enable ALPN.
-      if (setAlpnProtocols != null && setAlpnProtocols.isSupported(sslSocket)) {
-        Object[] parameters = { concatLengthPrefixed(protocols) };
-        setAlpnProtocols.invokeWithoutCheckedException(sslSocket, parameters);
-      }
+    public void untagSocket(Socket socket) throws SocketException {
     }
 
-    @Override public String getSelectedProtocol(SSLSocket socket) {
-      if (getAlpnSelectedProtocol == null) return null;
-      if (!getAlpnSelectedProtocol.isSupported(socket)) return null;
+    /**
+     * Configure TLS extensions on {@code sslSocket} for {@code route}.
+     *
+     * @param hostname non-null for client-side handshakes; null for
+     *                 server-side handshakes.
+     */
+    public void configureTlsExtensions(SSLSocket sslSocket, String hostname,
+                                       List<Protocol> protocols) {
+    }
 
-      byte[] alpnResult = (byte[]) getAlpnSelectedProtocol.invokeWithoutCheckedException(socket);
-      return alpnResult != null ? new String(alpnResult, Util.UTF_8) : null;
+    /**
+     * Called after the TLS handshake to release resources allocated by {@link
+     * #configureTlsExtensions}.
+     */
+    public void afterHandshake(SSLSocket sslSocket) {
     }
 
-    @Override public void tagSocket(Socket socket) throws SocketException {
-      if (trafficStatsTagSocket == null) return;
+    /**
+     * Returns the negotiated protocol, or null if no protocol was negotiated.
+     */
+    public String getSelectedProtocol(SSLSocket socket) {
+        return null;
+    }
 
-      try {
-        trafficStatsTagSocket.invoke(null, socket);
-      } catch (IllegalAccessException e) {
-        throw new RuntimeException(e);
-      } catch (InvocationTargetException e) {
-        throw new RuntimeException(e.getCause());
-      }
+    public void connectSocket(Socket socket, InetSocketAddress address,
+                              int connectTimeout) throws IOException {
+        socket.connect(address, connectTimeout);
     }
 
-    @Override public void untagSocket(Socket socket) throws SocketException {
-      if (trafficStatsUntagSocket == null) return;
+    /**
+     * Attempt to match the host runtime to a capable Platform implementation.
+     */
+    private static Platform findPlatform() {
+        // Attempt to find Android 2.3+ APIs.
+        try {
+            try {
+                Class.forName("com.android.org.conscrypt.OpenSSLSocketImpl");
+            } catch (ClassNotFoundException e) {
+                // Older platform before being unbundled.
+                Class.forName("org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl");
+            }
+
+            OptionalMethod<Socket> setUseSessionTickets
+                    = new OptionalMethod<>(null, "setUseSessionTickets", boolean.class);
+            OptionalMethod<Socket> setHostname
+                    = new OptionalMethod<>(null, "setHostname", String.class);
+            Method trafficStatsTagSocket = null;
+            Method trafficStatsUntagSocket = null;
+            OptionalMethod<Socket> getAlpnSelectedProtocol = null;
+            OptionalMethod<Socket> setAlpnProtocols = null;
+
+            // Attempt to find Android 4.0+ APIs.
+            try {
+                Class<?> trafficStats = Class.forName("android.net.TrafficStats");
+                trafficStatsTagSocket = trafficStats.getMethod("tagSocket", Socket.class);
+                trafficStatsUntagSocket = trafficStats.getMethod("untagSocket", Socket.class);
+
+                // Attempt to find Android 5.0+ APIs.
+                try {
+                    Class.forName("android.net.Network"); // Arbitrary class added in Android 5.0.
+                    getAlpnSelectedProtocol = new OptionalMethod<>(byte[].class, "getAlpnSelectedProtocol");
+                    setAlpnProtocols = new OptionalMethod<>(null, "setAlpnProtocols", byte[].class);
+                } catch (ClassNotFoundException ignored) {
+                }
+            } catch (ClassNotFoundException | NoSuchMethodException ignored) {
+            }
+
+            return new Android(setUseSessionTickets, setHostname, trafficStatsTagSocket,
+                    trafficStatsUntagSocket, getAlpnSelectedProtocol, setAlpnProtocols);
+        } catch (ClassNotFoundException ignored) {
+            // This isn't an Android runtime.
+        }
 
-      try {
-        trafficStatsUntagSocket.invoke(null, socket);
-      } catch (IllegalAccessException e) {
-        throw new RuntimeException(e);
-      } catch (InvocationTargetException e) {
-        throw new RuntimeException(e.getCause());
-      }
-    }
-  }
-
-  /**
-   * OpenJDK 7+ with {@code org.mortbay.jetty.alpn/alpn-boot} in the boot class path.
-   */
-  private static class JdkWithJettyBootPlatform extends Platform {
-    private final Method putMethod;
-    private final Method getMethod;
-    private final Method removeMethod;
-    private final Class<?> clientProviderClass;
-    private final Class<?> serverProviderClass;
-
-    public JdkWithJettyBootPlatform(Method putMethod, Method getMethod, Method removeMethod,
-        Class<?> clientProviderClass, Class<?> serverProviderClass) {
-      this.putMethod = putMethod;
-      this.getMethod = getMethod;
-      this.removeMethod = removeMethod;
-      this.clientProviderClass = clientProviderClass;
-      this.serverProviderClass = serverProviderClass;
-    }
+        // Find Jetty's ALPN extension for OpenJDK.
+        try {
+            String negoClassName = "org.eclipse.jetty.alpn.ALPN";
+            Class<?> negoClass = Class.forName(negoClassName);
+            Class<?> providerClass = Class.forName(negoClassName + "$Provider");
+            Class<?> clientProviderClass = Class.forName(negoClassName + "$ClientProvider");
+            Class<?> serverProviderClass = Class.forName(negoClassName + "$ServerProvider");
+            Method putMethod = negoClass.getMethod("put", SSLSocket.class, providerClass);
+            Method getMethod = negoClass.getMethod("get", SSLSocket.class);
+            Method removeMethod = negoClass.getMethod("remove", SSLSocket.class);
+            return new JdkWithJettyBootPlatform(
+                    putMethod, getMethod, removeMethod, clientProviderClass, serverProviderClass);
+        } catch (ClassNotFoundException | NoSuchMethodException ignored) {
+        }
 
-    @Override public void configureTlsExtensions(
-        SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
-      List<String> names = new ArrayList<>(protocols.size());
-      for (int i = 0, size = protocols.size(); i < size; i++) {
-        Protocol protocol = protocols.get(i);
-        if (protocol == Protocol.HTTP_1_0) continue; // No HTTP/1.0 for ALPN.
-        names.add(protocol.toString());
-      }
-      try {
-        Object provider = Proxy.newProxyInstance(Platform.class.getClassLoader(),
-            new Class[] { clientProviderClass, serverProviderClass }, new JettyNegoProvider(names));
-        putMethod.invoke(null, sslSocket, provider);
-      } catch (InvocationTargetException | IllegalAccessException e) {
-        throw new AssertionError(e);
-      }
+        return new Platform();
     }
 
-    @Override public void afterHandshake(SSLSocket sslSocket) {
-      try {
-        removeMethod.invoke(null, sslSocket);
-      } catch (IllegalAccessException | InvocationTargetException ignored) {
-        throw new AssertionError();
-      }
-    }
+    /**
+     * Android 2.3 or better.
+     */
+    private static class Android extends Platform {
+        private final OptionalMethod<Socket> setUseSessionTickets;
+        private final OptionalMethod<Socket> setHostname;
+
+        // Non-null on Android 4.0+.
+        private final Method trafficStatsTagSocket;
+        private final Method trafficStatsUntagSocket;
+
+        // Non-null on Android 5.0+.
+        private final OptionalMethod<Socket> getAlpnSelectedProtocol;
+        private final OptionalMethod<Socket> setAlpnProtocols;
+
+        public Android(OptionalMethod<Socket> setUseSessionTickets, OptionalMethod<Socket> setHostname,
+                       Method trafficStatsTagSocket, Method trafficStatsUntagSocket,
+                       OptionalMethod<Socket> getAlpnSelectedProtocol, OptionalMethod<Socket> setAlpnProtocols) {
+            this.setUseSessionTickets = setUseSessionTickets;
+            this.setHostname = setHostname;
+            this.trafficStatsTagSocket = trafficStatsTagSocket;
+            this.trafficStatsUntagSocket = trafficStatsUntagSocket;
+            this.getAlpnSelectedProtocol = getAlpnSelectedProtocol;
+            this.setAlpnProtocols = setAlpnProtocols;
+        }
+
+        @Override
+        public void connectSocket(Socket socket, InetSocketAddress address,
+                                  int connectTimeout) throws IOException {
+            try {
+                socket.connect(address, connectTimeout);
+            } catch (SecurityException se) {
+                // Before android 4.3, socket.connect could throw a SecurityException
+                // if opening a socket resulted in an EACCES error.
+                IOException ioException = new IOException("Exception in connect");
+                ioException.initCause(se);
+                throw ioException;
+            }
+        }
+
+        @Override
+        public void configureTlsExtensions(
+                SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
+            // Enable SNI and session tickets.
+            if (hostname != null) {
+                setUseSessionTickets.invokeOptionalWithoutCheckedException(sslSocket, true);
+                setHostname.invokeOptionalWithoutCheckedException(sslSocket, hostname);
+            }
+
+            // Enable ALPN.
+            if (setAlpnProtocols != null && setAlpnProtocols.isSupported(sslSocket)) {
+                Object[] parameters = {concatLengthPrefixed(protocols)};
+                setAlpnProtocols.invokeWithoutCheckedException(sslSocket, parameters);
+            }
+        }
+
+        @Override
+        public String getSelectedProtocol(SSLSocket socket) {
+            if (getAlpnSelectedProtocol == null) return null;
+            if (!getAlpnSelectedProtocol.isSupported(socket)) return null;
 
-    @Override public String getSelectedProtocol(SSLSocket socket) {
-      try {
-        JettyNegoProvider provider =
-            (JettyNegoProvider) Proxy.getInvocationHandler(getMethod.invoke(null, socket));
-        if (!provider.unsupported && provider.selected == null) {
-          logger.log(Level.INFO, "ALPN callback dropped: SPDY and HTTP/2 are disabled. "
-              + "Is alpn-boot on the boot class path?");
-          return null;
+            byte[] alpnResult = (byte[]) getAlpnSelectedProtocol.invokeWithoutCheckedException(socket);
+            return alpnResult != null ? new String(alpnResult, Util.UTF_8) : null;
+        }
+
+        @Override
+        public void tagSocket(Socket socket) throws SocketException {
+            if (trafficStatsTagSocket == null) return;
+
+            try {
+                trafficStatsTagSocket.invoke(null, socket);
+            } catch (IllegalAccessException e) {
+                throw new RuntimeException(e);
+            } catch (InvocationTargetException e) {
+                throw new RuntimeException(e.getCause());
+            }
+        }
+
+        @Override
+        public void untagSocket(Socket socket) throws SocketException {
+            if (trafficStatsUntagSocket == null) return;
+
+            try {
+                trafficStatsUntagSocket.invoke(null, socket);
+            } catch (IllegalAccessException e) {
+                throw new RuntimeException(e);
+            } catch (InvocationTargetException e) {
+                throw new RuntimeException(e.getCause());
+            }
         }
-        return provider.unsupported ? null : provider.selected;
-      } catch (InvocationTargetException | IllegalAccessException e) {
-        throw new AssertionError();
-      }
     }
-  }
-
-  /**
-   * Handle the methods of ALPN's ClientProvider and ServerProvider
-   * without a compile-time dependency on those interfaces.
-   */
-  private static class JettyNegoProvider implements InvocationHandler {
-    /** This peer's supported protocols. */
-    private final List<String> protocols;
-    /** Set when remote peer notifies ALPN is unsupported. */
-    private boolean unsupported;
-    /** The protocol the server selected. */
-    private String selected;
-
-    public JettyNegoProvider(List<String> protocols) {
-      this.protocols = protocols;
+
+    /**
+     * OpenJDK 7+ with {@code org.mortbay.jetty.alpn/alpn-boot} in the boot class path.
+     */
+    private static class JdkWithJettyBootPlatform extends Platform {
+        private final Method putMethod;
+        private final Method getMethod;
+        private final Method removeMethod;
+        private final Class<?> clientProviderClass;
+        private final Class<?> serverProviderClass;
+
+        public JdkWithJettyBootPlatform(Method putMethod, Method getMethod, Method removeMethod,
+                                        Class<?> clientProviderClass, Class<?> serverProviderClass) {
+            this.putMethod = putMethod;
+            this.getMethod = getMethod;
+            this.removeMethod = removeMethod;
+            this.clientProviderClass = clientProviderClass;
+            this.serverProviderClass = serverProviderClass;
+        }
+
+        @Override
+        public void configureTlsExtensions(
+                SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
+            List<String> names = new ArrayList<>(protocols.size());
+            for (int i = 0, size = protocols.size(); i < size; i++) {
+                Protocol protocol = protocols.get(i);
+                if (protocol == Protocol.HTTP_1_0) continue; // No HTTP/1.0 for ALPN.
+                names.add(protocol.toString());
+            }
+            try {
+                Object provider = Proxy.newProxyInstance(Platform.class.getClassLoader(),
+                        new Class[]{clientProviderClass, serverProviderClass}, new JettyNegoProvider(names));
+                putMethod.invoke(null, sslSocket, provider);
+            } catch (InvocationTargetException | IllegalAccessException e) {
+                throw new AssertionError(e);
+            }
+        }
+
+        @Override
+        public void afterHandshake(SSLSocket sslSocket) {
+            try {
+                removeMethod.invoke(null, sslSocket);
+            } catch (IllegalAccessException | InvocationTargetException ignored) {
+                throw new AssertionError();
+            }
+        }
+
+        @Override
+        public String getSelectedProtocol(SSLSocket socket) {
+            try {
+                JettyNegoProvider provider =
+                        (JettyNegoProvider) Proxy.getInvocationHandler(getMethod.invoke(null, socket));
+                if (!provider.unsupported && provider.selected == null) {
+                    logger.log(Level.INFO, "ALPN callback dropped: SPDY and HTTP/2 are disabled. "
+                            + "Is alpn-boot on the boot class path?");
+                    return null;
+                }
+                return provider.unsupported ? null : provider.selected;
+            } catch (InvocationTargetException | IllegalAccessException e) {
+                throw new AssertionError();
+            }
+        }
     }
 
-    @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
-      String methodName = method.getName();
-      Class<?> returnType = method.getReturnType();
-      if (args == null) {
-        args = Util.EMPTY_STRING_ARRAY;
-      }
-      if (methodName.equals("supports") && boolean.class == returnType) {
-        return true; // ALPN is supported.
-      } else if (methodName.equals("unsupported") && void.class == returnType) {
-        this.unsupported = true; // Peer doesn't support ALPN.
-        return null;
-      } else if (methodName.equals("protocols") && args.length == 0) {
-        return protocols; // Client advertises these protocols.
-      } else if ((methodName.equals("selectProtocol") || methodName.equals("select"))
-          && String.class == returnType && args.length == 1 && args[0] instanceof List) {
-        List<String> peerProtocols = (List) args[0];
-        // Pick the first known protocol the peer advertises.
-        for (int i = 0, size = peerProtocols.size(); i < size; i++) {
-          if (protocols.contains(peerProtocols.get(i))) {
-            return selected = peerProtocols.get(i);
-          }
+    /**
+     * Handle the methods of ALPN's ClientProvider and ServerProvider
+     * without a compile-time dependency on those interfaces.
+     */
+    private static class JettyNegoProvider implements InvocationHandler {
+        /**
+         * This peer's supported protocols.
+         */
+        private final List<String> protocols;
+        /**
+         * Set when remote peer notifies ALPN is unsupported.
+         */
+        private boolean unsupported;
+        /**
+         * The protocol the server selected.
+         */
+        private String selected;
+
+        public JettyNegoProvider(List<String> protocols) {
+            this.protocols = protocols;
+        }
+
+        @Override
+        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
+            String methodName = method.getName();
+            Class<?> returnType = method.getReturnType();
+            if (args == null) {
+                args = Util.EMPTY_STRING_ARRAY;
+            }
+            if (methodName.equals("supports") && boolean.class == returnType) {
+                return true; // ALPN is supported.
+            } else if (methodName.equals("unsupported") && void.class == returnType) {
+                this.unsupported = true; // Peer doesn't support ALPN.
+                return null;
+            } else if (methodName.equals("protocols") && args.length == 0) {
+                return protocols; // Client advertises these protocols.
+            } else if ((methodName.equals("selectProtocol") || methodName.equals("select"))
+                    && String.class == returnType && args.length == 1 && args[0] instanceof List) {
+                List<String> peerProtocols = (List) args[0];
+                // Pick the first known protocol the peer advertises.
+                for (int i = 0, size = peerProtocols.size(); i < size; i++) {
+                    if (protocols.contains(peerProtocols.get(i))) {
+                        return selected = peerProtocols.get(i);
+                    }
+                }
+                return selected = protocols.get(0); // On no intersection, try peer's first protocol.
+            } else if ((methodName.equals("protocolSelected") || methodName.equals("selected"))
+                    && args.length == 1) {
+                this.selected = (String) args[0]; // Server selected this protocol.
+                return null;
+            } else {
+                return method.invoke(this, args);
+            }
         }
-        return selected = protocols.get(0); // On no intersection, try peer's first protocol.
-      } else if ((methodName.equals("protocolSelected") || methodName.equals("selected"))
-          && args.length == 1) {
-        this.selected = (String) args[0]; // Server selected this protocol.
-        return null;
-      } else {
-        return method.invoke(this, args);
-      }
     }
-  }
-
-  /**
-   * Returns the concatenation of 8-bit, length prefixed protocol names.
-   * http://tools.ietf.org/html/draft-agl-tls-nextprotoneg-04#page-4
-   */
-  static byte[] concatLengthPrefixed(List<Protocol> protocols) {
-    Buffer result = new Buffer();
-    for (int i = 0, size = protocols.size(); i < size; i++) {
-      Protocol protocol = protocols.get(i);
-      if (protocol == Protocol.HTTP_1_0) continue; // No HTTP/1.0 for ALPN.
-      result.writeByte(protocol.toString().length());
-      result.writeUtf8(protocol.toString());
+
+    /**
+     * Returns the concatenation of 8-bit, length prefixed protocol names.
+     * http://tools.ietf.org/html/draft-agl-tls-nextprotoneg-04#page-4
+     */
+    static byte[] concatLengthPrefixed(List<Protocol> protocols) {
+        Buffer result = new Buffer();
+        for (int i = 0, size = protocols.size(); i < size; i++) {
+            Protocol protocol = protocols.get(i);
+            if (protocol == Protocol.HTTP_1_0) continue; // No HTTP/1.0 for ALPN.
+            result.writeByte(protocol.toString().length());
+            result.writeUtf8(protocol.toString());
+        }
+        return result.readByteArray();
     }
-    return result.readByteArray();
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/RouteDatabase.java b/okhttp/src/main/java/com/squareup/okhttp/internal/RouteDatabase.java
index 1c96c7f6b2..5790841345 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/RouteDatabase.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/RouteDatabase.java
@@ -16,6 +16,7 @@
 package com.squareup.okhttp.internal;
 
 import com.squareup.okhttp.Route;
+
 import java.util.LinkedHashSet;
 import java.util.Set;
 
@@ -26,24 +27,30 @@
  * server, that failure is remembered and alternate routes are preferred.
  */
 public final class RouteDatabase {
-  private final Set<Route> failedRoutes = new LinkedHashSet<>();
+    private final Set<Route> failedRoutes = new LinkedHashSet<>();
 
-  /** Records a failure connecting to {@code failedRoute}. */
-  public synchronized void failed(Route failedRoute) {
-    failedRoutes.add(failedRoute);
-  }
+    /**
+     * Records a failure connecting to {@code failedRoute}.
+     */
+    public synchronized void failed(Route failedRoute) {
+        failedRoutes.add(failedRoute);
+    }
 
-  /** Records success connecting to {@code failedRoute}. */
-  public synchronized void connected(Route route) {
-    failedRoutes.remove(route);
-  }
+    /**
+     * Records success connecting to {@code failedRoute}.
+     */
+    public synchronized void connected(Route route) {
+        failedRoutes.remove(route);
+    }
 
-  /** Returns true if {@code route} has failed recently and should be avoided. */
-  public synchronized boolean shouldPostpone(Route route) {
-    return failedRoutes.contains(route);
-  }
+    /**
+     * Returns true if {@code route} has failed recently and should be avoided.
+     */
+    public synchronized boolean shouldPostpone(Route route) {
+        return failedRoutes.contains(route);
+    }
 
-  public synchronized int failedRoutesCount() {
-    return failedRoutes.size();
-  }
+    public synchronized int failedRoutesCount() {
+        return failedRoutes.size();
+    }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java
index eee686f104..5d0fab8e6f 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java
@@ -36,240 +36,260 @@
 import java.util.Map;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.TimeUnit;
+
 import okio.Buffer;
 import okio.ByteString;
 import okio.Source;
 
-/** Junk drawer of utility methods. */
+/**
+ * Junk drawer of utility methods.
+ */
 public final class Util {
-  public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
-  public static final String[] EMPTY_STRING_ARRAY = new String[0];
+    public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
+    public static final String[] EMPTY_STRING_ARRAY = new String[0];
 
-  /** A cheap and type-safe constant for the UTF-8 Charset. */
-  public static final Charset UTF_8 = Charset.forName("UTF-8");
+    /**
+     * A cheap and type-safe constant for the UTF-8 Charset.
+     */
+    public static final Charset UTF_8 = Charset.forName("UTF-8");
 
-  private Util() {
-  }
-
-  public static int getEffectivePort(URI uri) {
-    return getEffectivePort(uri.getScheme(), uri.getPort());
-  }
+    private Util() {
+    }
 
-  public static int getEffectivePort(URL url) {
-    return getEffectivePort(url.getProtocol(), url.getPort());
-  }
+    public static int getEffectivePort(URI uri) {
+        return getEffectivePort(uri.getScheme(), uri.getPort());
+    }
 
-  private static int getEffectivePort(String scheme, int specifiedPort) {
-    return specifiedPort != -1 ? specifiedPort : getDefaultPort(scheme);
-  }
+    public static int getEffectivePort(URL url) {
+        return getEffectivePort(url.getProtocol(), url.getPort());
+    }
 
-  public static int getDefaultPort(String protocol) {
-    if ("http".equals(protocol)) return 80;
-    if ("https".equals(protocol)) return 443;
-    return -1;
-  }
+    private static int getEffectivePort(String scheme, int specifiedPort) {
+        return specifiedPort != -1 ? specifiedPort : getDefaultPort(scheme);
+    }
 
-  public static void checkOffsetAndCount(long arrayLength, long offset, long count) {
-    if ((offset | count) < 0 || offset > arrayLength || arrayLength - offset < count) {
-      throw new ArrayIndexOutOfBoundsException();
+    public static int getDefaultPort(String protocol) {
+        if ("http".equals(protocol)) return 80;
+        if ("https".equals(protocol)) return 443;
+        return -1;
     }
-  }
 
-  /** Returns true if two possibly-null objects are equal. */
-  public static boolean equal(Object a, Object b) {
-    return a == b || (a != null && a.equals(b));
-  }
+    public static void checkOffsetAndCount(long arrayLength, long offset, long count) {
+        if ((offset | count) < 0 || offset > arrayLength || arrayLength - offset < count) {
+            throw new ArrayIndexOutOfBoundsException();
+        }
+    }
 
-  /**
-   * Closes {@code closeable}, ignoring any checked exceptions. Does nothing
-   * if {@code closeable} is null.
-   */
-  public static void closeQuietly(Closeable closeable) {
-    if (closeable != null) {
-      try {
-        closeable.close();
-      } catch (RuntimeException rethrown) {
-        throw rethrown;
-      } catch (Exception ignored) {
-      }
+    /**
+     * Returns true if two possibly-null objects are equal.
+     */
+    public static boolean equal(Object a, Object b) {
+        return a == b || (a != null && a.equals(b));
     }
-  }
 
-  /**
-   * Closes {@code socket}, ignoring any checked exceptions. Does nothing if
-   * {@code socket} is null.
-   */
-  public static void closeQuietly(Socket socket) {
-    if (socket != null) {
-      try {
-        socket.close();
-      } catch (RuntimeException rethrown) {
-        throw rethrown;
-      } catch (Exception ignored) {
-      }
+    /**
+     * Closes {@code closeable}, ignoring any checked exceptions. Does nothing
+     * if {@code closeable} is null.
+     */
+    public static void closeQuietly(Closeable closeable) {
+        if (closeable != null) {
+            try {
+                closeable.close();
+            } catch (RuntimeException rethrown) {
+                throw rethrown;
+            } catch (Exception ignored) {
+            }
+        }
     }
-  }
 
-  /**
-   * Closes {@code serverSocket}, ignoring any checked exceptions. Does nothing if
-   * {@code serverSocket} is null.
-   */
-  public static void closeQuietly(ServerSocket serverSocket) {
-    if (serverSocket != null) {
-      try {
-        serverSocket.close();
-      } catch (RuntimeException rethrown) {
-        throw rethrown;
-      } catch (Exception ignored) {
-      }
+    /**
+     * Closes {@code socket}, ignoring any checked exceptions. Does nothing if
+     * {@code socket} is null.
+     */
+    public static void closeQuietly(Socket socket) {
+        if (socket != null) {
+            try {
+                socket.close();
+            } catch (RuntimeException rethrown) {
+                throw rethrown;
+            } catch (Exception ignored) {
+            }
+        }
     }
-  }
 
-  /**
-   * Closes {@code a} and {@code b}. If either close fails, this completes
-   * the other close and rethrows the first encountered exception.
-   */
-  public static void closeAll(Closeable a, Closeable b) throws IOException {
-    Throwable thrown = null;
-    try {
-      a.close();
-    } catch (Throwable e) {
-      thrown = e;
+    /**
+     * Closes {@code serverSocket}, ignoring any checked exceptions. Does nothing if
+     * {@code serverSocket} is null.
+     */
+    public static void closeQuietly(ServerSocket serverSocket) {
+        if (serverSocket != null) {
+            try {
+                serverSocket.close();
+            } catch (RuntimeException rethrown) {
+                throw rethrown;
+            } catch (Exception ignored) {
+            }
+        }
     }
-    try {
-      b.close();
-    } catch (Throwable e) {
-      if (thrown == null) thrown = e;
+
+    /**
+     * Closes {@code a} and {@code b}. If either close fails, this completes
+     * the other close and rethrows the first encountered exception.
+     */
+    public static void closeAll(Closeable a, Closeable b) throws IOException {
+        Throwable thrown = null;
+        try {
+            a.close();
+        } catch (Throwable e) {
+            thrown = e;
+        }
+        try {
+            b.close();
+        } catch (Throwable e) {
+            if (thrown == null) thrown = e;
+        }
+        if (thrown == null) return;
+        if (thrown instanceof IOException) throw (IOException) thrown;
+        if (thrown instanceof RuntimeException) throw (RuntimeException) thrown;
+        if (thrown instanceof Error) throw (Error) thrown;
+        throw new AssertionError(thrown);
     }
-    if (thrown == null) return;
-    if (thrown instanceof IOException) throw (IOException) thrown;
-    if (thrown instanceof RuntimeException) throw (RuntimeException) thrown;
-    if (thrown instanceof Error) throw (Error) thrown;
-    throw new AssertionError(thrown);
-  }
 
-  /**
-   * Attempts to exhaust {@code source}, returning true if successful. This is useful when reading
-   * a complete source is helpful, such as when doing so completes a cache body or frees a socket
-   * connection for reuse.
-   */
-  public static boolean discard(Source source, int timeout, TimeUnit timeUnit) {
-    try {
-      return skipAll(source, timeout, timeUnit);
-    } catch (IOException e) {
-      return false;
+    /**
+     * Attempts to exhaust {@code source}, returning true if successful. This is useful when reading
+     * a complete source is helpful, such as when doing so completes a cache body or frees a socket
+     * connection for reuse.
+     */
+    public static boolean discard(Source source, int timeout, TimeUnit timeUnit) {
+        try {
+            return skipAll(source, timeout, timeUnit);
+        } catch (IOException e) {
+            return false;
+        }
     }
-  }
 
-  /**
-   * Reads until {@code in} is exhausted or the deadline has been reached. This is careful to not
-   * extend the deadline if one exists already.
-   */
-  public static boolean skipAll(Source source, int duration, TimeUnit timeUnit) throws IOException {
-    long now = System.nanoTime();
-    long originalDuration = source.timeout().hasDeadline()
-        ? source.timeout().deadlineNanoTime() - now
-        : Long.MAX_VALUE;
-    source.timeout().deadlineNanoTime(now + Math.min(originalDuration, timeUnit.toNanos(duration)));
-    try {
-      Buffer skipBuffer = new Buffer();
-      while (source.read(skipBuffer, 2048) != -1) {
-        skipBuffer.clear();
-      }
-      return true; // Success! The source has been exhausted.
-    } catch (InterruptedIOException e) {
-      return false; // We ran out of time before exhausting the source.
-    } finally {
-      if (originalDuration == Long.MAX_VALUE) {
-        source.timeout().clearDeadline();
-      } else {
-        source.timeout().deadlineNanoTime(now + originalDuration);
-      }
+    /**
+     * Reads until {@code in} is exhausted or the deadline has been reached. This is careful to not
+     * extend the deadline if one exists already.
+     */
+    public static boolean skipAll(Source source, int duration, TimeUnit timeUnit) throws IOException {
+        long now = System.nanoTime();
+        long originalDuration = source.timeout().hasDeadline()
+                ? source.timeout().deadlineNanoTime() - now
+                : Long.MAX_VALUE;
+        source.timeout().deadlineNanoTime(now + Math.min(originalDuration, timeUnit.toNanos(duration)));
+        try {
+            Buffer skipBuffer = new Buffer();
+            while (source.read(skipBuffer, 2048) != -1) {
+                skipBuffer.clear();
+            }
+            return true; // Success! The source has been exhausted.
+        } catch (InterruptedIOException e) {
+            return false; // We ran out of time before exhausting the source.
+        } finally {
+            if (originalDuration == Long.MAX_VALUE) {
+                source.timeout().clearDeadline();
+            } else {
+                source.timeout().deadlineNanoTime(now + originalDuration);
+            }
+        }
     }
-  }
 
-  /** Returns a 32 character string containing an MD5 hash of {@code s}. */
-  public static String md5Hex(String s) {
-    try {
-      MessageDigest messageDigest = MessageDigest.getInstance("MD5");
-      byte[] md5bytes = messageDigest.digest(s.getBytes("UTF-8"));
-      return ByteString.of(md5bytes).hex();
-    } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {
-      throw new AssertionError(e);
+    /**
+     * Returns a 32 character string containing an MD5 hash of {@code s}.
+     */
+    public static String md5Hex(String s) {
+        try {
+            MessageDigest messageDigest = MessageDigest.getInstance("MD5");
+            byte[] md5bytes = messageDigest.digest(s.getBytes("UTF-8"));
+            return ByteString.of(md5bytes).hex();
+        } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {
+            throw new AssertionError(e);
+        }
     }
-  }
 
-  /** Returns a Base 64-encoded string containing a SHA-1 hash of {@code s}. */
-  public static String shaBase64(String s) {
-    try {
-      MessageDigest messageDigest = MessageDigest.getInstance("SHA-1");
-      byte[] sha1Bytes = messageDigest.digest(s.getBytes("UTF-8"));
-      return ByteString.of(sha1Bytes).base64();
-    } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {
-      throw new AssertionError(e);
+    /**
+     * Returns a Base 64-encoded string containing a SHA-1 hash of {@code s}.
+     */
+    public static String shaBase64(String s) {
+        try {
+            MessageDigest messageDigest = MessageDigest.getInstance("SHA-1");
+            byte[] sha1Bytes = messageDigest.digest(s.getBytes("UTF-8"));
+            return ByteString.of(sha1Bytes).base64();
+        } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {
+            throw new AssertionError(e);
+        }
     }
-  }
 
-  /** Returns a SHA-1 hash of {@code s}. */
-  public static ByteString sha1(ByteString s) {
-    try {
-      MessageDigest messageDigest = MessageDigest.getInstance("SHA-1");
-      byte[] sha1Bytes = messageDigest.digest(s.toByteArray());
-      return ByteString.of(sha1Bytes);
-    } catch (NoSuchAlgorithmException e) {
-      throw new AssertionError(e);
+    /**
+     * Returns a SHA-1 hash of {@code s}.
+     */
+    public static ByteString sha1(ByteString s) {
+        try {
+            MessageDigest messageDigest = MessageDigest.getInstance("SHA-1");
+            byte[] sha1Bytes = messageDigest.digest(s.toByteArray());
+            return ByteString.of(sha1Bytes);
+        } catch (NoSuchAlgorithmException e) {
+            throw new AssertionError(e);
+        }
     }
-  }
 
-  /** Returns an immutable copy of {@code list}. */
-  public static <T> List<T> immutableList(List<T> list) {
-    return Collections.unmodifiableList(new ArrayList<>(list));
-  }
+    /**
+     * Returns an immutable copy of {@code list}.
+     */
+    public static <T> List<T> immutableList(List<T> list) {
+        return Collections.unmodifiableList(new ArrayList<>(list));
+    }
 
-  /** Returns an immutable list containing {@code elements}. */
-  public static <T> List<T> immutableList(T... elements) {
-    return Collections.unmodifiableList(Arrays.asList(elements.clone()));
-  }
+    /**
+     * Returns an immutable list containing {@code elements}.
+     */
+    public static <T> List<T> immutableList(T... elements) {
+        return Collections.unmodifiableList(Arrays.asList(elements.clone()));
+    }
 
-  /** Returns an immutable copy of {@code map}. */
-  public static <K, V> Map<K, V> immutableMap(Map<K, V> map) {
-    return Collections.unmodifiableMap(new LinkedHashMap<>(map));
-  }
+    /**
+     * Returns an immutable copy of {@code map}.
+     */
+    public static <K, V> Map<K, V> immutableMap(Map<K, V> map) {
+        return Collections.unmodifiableMap(new LinkedHashMap<>(map));
+    }
 
-  public static ThreadFactory threadFactory(final String name, final boolean daemon) {
-    return new ThreadFactory() {
-      @Override public Thread newThread(Runnable runnable) {
-        Thread result = new Thread(runnable, name);
-        result.setDaemon(daemon);
-        return result;
-      }
-    };
-  }
+    public static ThreadFactory threadFactory(final String name, final boolean daemon) {
+        return new ThreadFactory() {
+            @Override
+            public Thread newThread(Runnable runnable) {
+                Thread result = new Thread(runnable, name);
+                result.setDaemon(daemon);
+                return result;
+            }
+        };
+    }
 
-  /**
-   * Returns an array containing containing only elements found in {@code first}  and also in
-   * {@code second}. The returned elements are in the same order as in {@code first}.
-   */
-  @SuppressWarnings("unchecked")
-  public static <T> T[] intersect(Class<T> arrayType, T[] first, T[] second) {
-    List<T> result = intersect(first, second);
-    return result.toArray((T[]) Array.newInstance(arrayType, result.size()));
-  }
+    /**
+     * Returns an array containing containing only elements found in {@code first}  and also in
+     * {@code second}. The returned elements are in the same order as in {@code first}.
+     */
+    @SuppressWarnings("unchecked")
+    public static <T> T[] intersect(Class<T> arrayType, T[] first, T[] second) {
+        List<T> result = intersect(first, second);
+        return result.toArray((T[]) Array.newInstance(arrayType, result.size()));
+    }
 
-  /**
-   * Returns a list containing containing only elements found in {@code first}  and also in
-   * {@code second}. The returned elements are in the same order as in {@code first}.
-   */
-  private static <T> List<T> intersect(T[] first, T[] second) {
-    List<T> result = new ArrayList<>();
-    for (T a : first) {
-      for (T b : second) {
-        if (a.equals(b)) {
-          result.add(b);
-          break;
+    /**
+     * Returns a list containing containing only elements found in {@code first}  and also in
+     * {@code second}. The returned elements are in the same order as in {@code first}.
+     */
+    private static <T> List<T> intersect(T[] first, T[] second) {
+        List<T> result = new ArrayList<>();
+        for (T a : first) {
+            for (T b : second) {
+                if (a.equals(b)) {
+                    result.add(b);
+                    break;
+                }
+            }
         }
-      }
+        return result;
     }
-    return result;
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/ErrorCode.java b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/ErrorCode.java
index 0edd5ef74f..6cee80de5f 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/ErrorCode.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/ErrorCode.java
@@ -17,75 +17,85 @@
 
 // http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-7
 public enum ErrorCode {
-  /** Not an error! For SPDY stream resets, prefer null over NO_ERROR. */
-  NO_ERROR(0, -1, 0),
+    /**
+     * Not an error! For SPDY stream resets, prefer null over NO_ERROR.
+     */
+    NO_ERROR(0, -1, 0),
 
-  PROTOCOL_ERROR(1, 1, 1),
+    PROTOCOL_ERROR(1, 1, 1),
 
-  /** A subtype of PROTOCOL_ERROR used by SPDY. */
-  INVALID_STREAM(1, 2, -1),
+    /**
+     * A subtype of PROTOCOL_ERROR used by SPDY.
+     */
+    INVALID_STREAM(1, 2, -1),
 
-  /** A subtype of PROTOCOL_ERROR used by SPDY. */
-  UNSUPPORTED_VERSION(1, 4, -1),
+    /**
+     * A subtype of PROTOCOL_ERROR used by SPDY.
+     */
+    UNSUPPORTED_VERSION(1, 4, -1),
 
-  /** A subtype of PROTOCOL_ERROR used by SPDY. */
-  STREAM_IN_USE(1, 8, -1),
+    /**
+     * A subtype of PROTOCOL_ERROR used by SPDY.
+     */
+    STREAM_IN_USE(1, 8, -1),
 
-  /** A subtype of PROTOCOL_ERROR used by SPDY. */
-  STREAM_ALREADY_CLOSED(1, 9, -1),
+    /**
+     * A subtype of PROTOCOL_ERROR used by SPDY.
+     */
+    STREAM_ALREADY_CLOSED(1, 9, -1),
 
-  INTERNAL_ERROR(2, 6, 2),
+    INTERNAL_ERROR(2, 6, 2),
 
-  FLOW_CONTROL_ERROR(3, 7, -1),
+    FLOW_CONTROL_ERROR(3, 7, -1),
 
-  STREAM_CLOSED(5, -1, -1),
+    STREAM_CLOSED(5, -1, -1),
 
-  FRAME_TOO_LARGE(6, 11, -1),
+    FRAME_TOO_LARGE(6, 11, -1),
 
-  REFUSED_STREAM(7, 3, -1),
+    REFUSED_STREAM(7, 3, -1),
 
-  CANCEL(8, 5, -1),
+    CANCEL(8, 5, -1),
 
-  COMPRESSION_ERROR(9, -1, -1),
+    COMPRESSION_ERROR(9, -1, -1),
 
-  CONNECT_ERROR(10, -1, -1),
+    CONNECT_ERROR(10, -1, -1),
 
-  ENHANCE_YOUR_CALM(11, -1, -1),
+    ENHANCE_YOUR_CALM(11, -1, -1),
 
-  INADEQUATE_SECURITY(12, -1, -1),
+    INADEQUATE_SECURITY(12, -1, -1),
 
-  HTTP_1_1_REQUIRED(13, -1, -1),
+    HTTP_1_1_REQUIRED(13, -1, -1),
 
-  INVALID_CREDENTIALS(-1, 10, -1);
+    INVALID_CREDENTIALS(-1, 10, -1);
 
-  public final int httpCode;
-  public final int spdyRstCode;
-  public final int spdyGoAwayCode;
+    public final int httpCode;
+    public final int spdyRstCode;
+    public final int spdyGoAwayCode;
 
-  private ErrorCode(int httpCode, int spdyRstCode, int spdyGoAwayCode) {
-    this.httpCode = httpCode;
-    this.spdyRstCode = spdyRstCode;
-    this.spdyGoAwayCode = spdyGoAwayCode;
-  }
+    private ErrorCode(int httpCode, int spdyRstCode, int spdyGoAwayCode) {
+        this.httpCode = httpCode;
+        this.spdyRstCode = spdyRstCode;
+        this.spdyGoAwayCode = spdyGoAwayCode;
+    }
 
-  public static ErrorCode fromSpdy3Rst(int code) {
-    for (ErrorCode errorCode : ErrorCode.values()) {
-      if (errorCode.spdyRstCode == code) return errorCode;
+    public static ErrorCode fromSpdy3Rst(int code) {
+        for (ErrorCode errorCode : ErrorCode.values()) {
+            if (errorCode.spdyRstCode == code) return errorCode;
+        }
+        return null;
     }
-    return null;
-  }
 
-  public static ErrorCode fromHttp2(int code) {
-    for (ErrorCode errorCode : ErrorCode.values()) {
-      if (errorCode.httpCode == code) return errorCode;
+    public static ErrorCode fromHttp2(int code) {
+        for (ErrorCode errorCode : ErrorCode.values()) {
+            if (errorCode.httpCode == code) return errorCode;
+        }
+        return null;
     }
-    return null;
-  }
 
-  public static ErrorCode fromSpdyGoAway(int code) {
-    for (ErrorCode errorCode : ErrorCode.values()) {
-      if (errorCode.spdyGoAwayCode == code) return errorCode;
+    public static ErrorCode fromSpdyGoAway(int code) {
+        for (ErrorCode errorCode : ErrorCode.values()) {
+            if (errorCode.spdyGoAwayCode == code) return errorCode;
+        }
+        return null;
     }
-    return null;
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/FrameReader.java b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/FrameReader.java
index 9f7f0868b2..54193272f8 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/FrameReader.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/FrameReader.java
@@ -19,119 +19,127 @@
 import java.io.Closeable;
 import java.io.IOException;
 import java.util.List;
+
 import okio.BufferedSource;
 import okio.ByteString;
 
-/** Reads transport frames for SPDY/3 or HTTP/2. */
+/**
+ * Reads transport frames for SPDY/3 or HTTP/2.
+ */
 public interface FrameReader extends Closeable {
-  void readConnectionPreface() throws IOException;
-  boolean nextFrame(Handler handler) throws IOException;
-
-  interface Handler {
-    void data(boolean inFinished, int streamId, BufferedSource source, int length)
-        throws IOException;
-
-    /**
-     * Create or update incoming headers, creating the corresponding streams
-     * if necessary. Frames that trigger this are SPDY SYN_STREAM, HEADERS, and
-     * SYN_REPLY, and HTTP/2 HEADERS and PUSH_PROMISE.
-     *
-     * @param outFinished true if the receiver should not send further frames.
-     * @param inFinished true if the sender will not send further frames.
-     * @param streamId the stream owning these headers.
-     * @param associatedStreamId the stream that triggered the sender to create
-     *     this stream.
-     */
-    void headers(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
-        List<Header> headerBlock, HeadersMode headersMode);
-    void rstStream(int streamId, ErrorCode errorCode);
-    void settings(boolean clearPrevious, Settings settings);
-
-    /** HTTP/2 only. */
-    void ackSettings();
-
-    /**
-     *  Read a connection-level ping from the peer.  {@code ack} indicates this
-     *  is a reply.  Payload parameters are different between SPDY/3 and HTTP/2.
-     *  <p>
-     *  In SPDY/3, only the first {@code payload1} parameter is set.  If the
-     *  reader is a client, it is an unsigned even number.  Likewise, a server
-     *  will receive an odd number.
-     *  <p>
-     *  In HTTP/2, both {@code payload1} and {@code payload2} parameters are
-     *  set. The data is opaque binary, and there are no rules on the content.
-     */
-    void ping(boolean ack, int payload1, int payload2);
-
-    /**
-     * The peer tells us to stop creating streams.  It is safe to replay
-     * streams with {@code ID > lastGoodStreamId} on a new connection.  In-
-     * flight streams with {@code ID <= lastGoodStreamId} can only be replayed
-     * on a new connection if they are idempotent.
-     *
-     * @param lastGoodStreamId the last stream ID the peer processed before
-     *     sending this message. If {@code lastGoodStreamId} is zero, the peer
-     *     processed no frames.
-     * @param errorCode reason for closing the connection.
-     * @param debugData only valid for HTTP/2; opaque debug data to send.
-     */
-    void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData);
-
-    /**
-     * Notifies that an additional {@code windowSizeIncrement} bytes can be
-     * sent on {@code streamId}, or the connection if {@code streamId} is zero.
-     */
-    void windowUpdate(int streamId, long windowSizeIncrement);
-
-    /**
-     * Called when reading a headers or priority frame. This may be used to
-     * change the stream's weight from the default (16) to a new value.
-     *
-     * @param streamId stream which has a priority change.
-     * @param streamDependency the stream ID this stream is dependent on.
-     * @param weight relative proportion of priority in [1..256].
-     * @param exclusive inserts this stream ID as the sole child of
-     *     {@code streamDependency}.
-     */
-    void priority(int streamId, int streamDependency, int weight, boolean exclusive);
-
-    /**
-     * HTTP/2 only. Receive a push promise header block.
-     * <p>
-     * A push promise contains all the headers that pertain to a server-initiated
-     * request, and a {@code promisedStreamId} to which response frames will be
-     * delivered. Push promise frames are sent as a part of the response to
-     * {@code streamId}.
-     *
-     * @param streamId client-initiated stream ID.  Must be an odd number.
-     * @param promisedStreamId server-initiated stream ID.  Must be an even
-     * number.
-     * @param requestHeaders minimally includes {@code :method}, {@code :scheme},
-     * {@code :authority}, and (@code :path}.
-     */
-    void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
-        throws IOException;
-
-    /**
-     * HTTP/2 only. Expresses that resources for the connection or a client-
-     * initiated stream are available from a different network location or
-     * protocol configuration.
-     *
-     * <p>See <a href="http://tools.ietf.org/html/draft-ietf-httpbis-alt-svc-01">alt-svc</a>
-     *
-     * @param streamId when a client-initiated stream ID (odd number), the
-     *     origin of this alternate service is the origin of the stream. When
-     *     zero, the origin is specified in the {@code origin} parameter.
-     * @param origin when present, the
-     *     <a href="http://tools.ietf.org/html/rfc6454">origin</a> is typically
-     *     represented as a combination of scheme, host and port. When empty,
-     *     the origin is that of the {@code streamId}.
-     * @param protocol an ALPN protocol, such as {@code h2}.
-     * @param host an IP address or hostname.
-     * @param port the IP port associated with the service.
-     * @param maxAge time in seconds that this alternative is considered fresh.
-     */
-    void alternateService(int streamId, String origin, ByteString protocol, String host, int port,
-        long maxAge);
-  }
+    void readConnectionPreface() throws IOException;
+
+    boolean nextFrame(Handler handler) throws IOException;
+
+    interface Handler {
+        void data(boolean inFinished, int streamId, BufferedSource source, int length)
+                throws IOException;
+
+        /**
+         * Create or update incoming headers, creating the corresponding streams
+         * if necessary. Frames that trigger this are SPDY SYN_STREAM, HEADERS, and
+         * SYN_REPLY, and HTTP/2 HEADERS and PUSH_PROMISE.
+         *
+         * @param outFinished        true if the receiver should not send further frames.
+         * @param inFinished         true if the sender will not send further frames.
+         * @param streamId           the stream owning these headers.
+         * @param associatedStreamId the stream that triggered the sender to create
+         *                           this stream.
+         */
+        void headers(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
+                     List<Header> headerBlock, HeadersMode headersMode);
+
+        void rstStream(int streamId, ErrorCode errorCode);
+
+        void settings(boolean clearPrevious, Settings settings);
+
+        /**
+         * HTTP/2 only.
+         */
+        void ackSettings();
+
+        /**
+         * Read a connection-level ping from the peer.  {@code ack} indicates this
+         * is a reply.  Payload parameters are different between SPDY/3 and HTTP/2.
+         * <p/>
+         * In SPDY/3, only the first {@code payload1} parameter is set.  If the
+         * reader is a client, it is an unsigned even number.  Likewise, a server
+         * will receive an odd number.
+         * <p/>
+         * In HTTP/2, both {@code payload1} and {@code payload2} parameters are
+         * set. The data is opaque binary, and there are no rules on the content.
+         */
+        void ping(boolean ack, int payload1, int payload2);
+
+        /**
+         * The peer tells us to stop creating streams.  It is safe to replay
+         * streams with {@code ID > lastGoodStreamId} on a new connection.  In-
+         * flight streams with {@code ID <= lastGoodStreamId} can only be replayed
+         * on a new connection if they are idempotent.
+         *
+         * @param lastGoodStreamId the last stream ID the peer processed before
+         *                         sending this message. If {@code lastGoodStreamId} is zero, the peer
+         *                         processed no frames.
+         * @param errorCode        reason for closing the connection.
+         * @param debugData        only valid for HTTP/2; opaque debug data to send.
+         */
+        void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData);
+
+        /**
+         * Notifies that an additional {@code windowSizeIncrement} bytes can be
+         * sent on {@code streamId}, or the connection if {@code streamId} is zero.
+         */
+        void windowUpdate(int streamId, long windowSizeIncrement);
+
+        /**
+         * Called when reading a headers or priority frame. This may be used to
+         * change the stream's weight from the default (16) to a new value.
+         *
+         * @param streamId         stream which has a priority change.
+         * @param streamDependency the stream ID this stream is dependent on.
+         * @param weight           relative proportion of priority in [1..256].
+         * @param exclusive        inserts this stream ID as the sole child of
+         *                         {@code streamDependency}.
+         */
+        void priority(int streamId, int streamDependency, int weight, boolean exclusive);
+
+        /**
+         * HTTP/2 only. Receive a push promise header block.
+         * <p/>
+         * A push promise contains all the headers that pertain to a server-initiated
+         * request, and a {@code promisedStreamId} to which response frames will be
+         * delivered. Push promise frames are sent as a part of the response to
+         * {@code streamId}.
+         *
+         * @param streamId         client-initiated stream ID.  Must be an odd number.
+         * @param promisedStreamId server-initiated stream ID.  Must be an even
+         *                         number.
+         * @param requestHeaders   minimally includes {@code :method}, {@code :scheme},
+         *                         {@code :authority}, and (@code :path}.
+         */
+        void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
+                throws IOException;
+
+        /**
+         * HTTP/2 only. Expresses that resources for the connection or a client-
+         * initiated stream are available from a different network location or
+         * protocol configuration.
+         * <p/>
+         * <p>See <a href="http://tools.ietf.org/html/draft-ietf-httpbis-alt-svc-01">alt-svc</a>
+         *
+         * @param streamId when a client-initiated stream ID (odd number), the
+         *                 origin of this alternate service is the origin of the stream. When
+         *                 zero, the origin is specified in the {@code origin} parameter.
+         * @param origin   when present, the
+         *                 <a href="http://tools.ietf.org/html/rfc6454">origin</a> is typically
+         *                 represented as a combination of scheme, host and port. When empty,
+         *                 the origin is that of the {@code streamId}.
+         * @param protocol an ALPN protocol, such as {@code h2}.
+         * @param host     an IP address or hostname.
+         * @param port     the IP port associated with the service.
+         * @param maxAge   time in seconds that this alternative is considered fresh.
+         */
+        void alternateService(int streamId, String origin, ByteString protocol, String host, int port,
+                              long maxAge);
+    }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/FrameWriter.java b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/FrameWriter.java
index dcaaf3ac90..12faf994c9 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/FrameWriter.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/FrameWriter.java
@@ -19,85 +19,103 @@
 import java.io.Closeable;
 import java.io.IOException;
 import java.util.List;
+
 import okio.Buffer;
 
-/** Writes transport frames for SPDY/3 or HTTP/2. */
+/**
+ * Writes transport frames for SPDY/3 or HTTP/2.
+ */
 public interface FrameWriter extends Closeable {
-  /** HTTP/2 only. */
-  void connectionPreface() throws IOException;
-  /** Informs the peer that we've applied its latest settings. */
-  void ackSettings(Settings peerSettings) throws IOException;
-
-  /**
-   * HTTP/2 only. Send a push promise header block.
-   * <p>
-   * A push promise contains all the headers that pertain to a server-initiated
-   * request, and a {@code promisedStreamId} to which response frames will be
-   * delivered. Push promise frames are sent as a part of the response to
-   * {@code streamId}.  The {@code promisedStreamId} has a priority of one
-   * greater than {@code streamId}.
-   *
-   * @param streamId client-initiated stream ID.  Must be an odd number.
-   * @param promisedStreamId server-initiated stream ID.  Must be an even
-   * number.
-   * @param requestHeaders minimally includes {@code :method}, {@code :scheme},
-   * {@code :authority}, and (@code :path}.
-   */
-  void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
-      throws IOException;
-
-  /** SPDY/3 only. */
-  void flush() throws IOException;
-  void synStream(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
-      List<Header> headerBlock) throws IOException;
-  void synReply(boolean outFinished, int streamId, List<Header> headerBlock)
-      throws IOException;
-  void headers(int streamId, List<Header> headerBlock) throws IOException;
-  void rstStream(int streamId, ErrorCode errorCode) throws IOException;
-
-  /** The maximum size of bytes that may be sent in a single call to {@link #data}. */
-  int maxDataLength();
-
-  /**
-   * {@code source.length} may be longer than the max length of the variant's data frame.
-   * Implementations must send multiple frames as necessary.
-   *
-   * @param source the buffer to draw bytes from. May be null if byteCount is 0.
-   * @param byteCount must be between 0 and the minimum of {code source.length}
-   * and {@link #maxDataLength}.
-   */
-  void data(boolean outFinished, int streamId, Buffer source, int byteCount) throws IOException;
-
-  /** Write okhttp's settings to the peer. */
-  void settings(Settings okHttpSettings) throws IOException;
-
-  /**
-   *  Send a connection-level ping to the peer.  {@code ack} indicates this is
-   *  a reply.  Payload parameters are different between SPDY/3 and HTTP/2.
-   *  <p>
-   *  In SPDY/3, only the first {@code payload1} parameter is sent.  If the
-   *  sender is a client, it is an unsigned odd number.  Likewise, a server
-   *  will send an even number.
-   *  <p>
-   *  In HTTP/2, both {@code payload1} and {@code payload2} parameters are
-   *  sent.  The data is opaque binary, and there are no rules on the content.
-   */
-  void ping(boolean ack, int payload1, int payload2) throws IOException;
-
-  /**
-   * Tell the peer to stop creating streams and that we last processed
-   * {@code lastGoodStreamId}, or zero if no streams were processed.
-   *
-   * @param lastGoodStreamId the last stream ID processed, or zero if no
-   * streams were processed.
-   * @param errorCode reason for closing the connection.
-   * @param debugData only valid for HTTP/2; opaque debug data to send.
-   */
-  void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) throws IOException;
-
-  /**
-   * Inform peer that an additional {@code windowSizeIncrement} bytes can be
-   * sent on {@code streamId}, or the connection if {@code streamId} is zero.
-   */
-  void windowUpdate(int streamId, long windowSizeIncrement) throws IOException;
+    /**
+     * HTTP/2 only.
+     */
+    void connectionPreface() throws IOException;
+
+    /**
+     * Informs the peer that we've applied its latest settings.
+     */
+    void ackSettings(Settings peerSettings) throws IOException;
+
+    /**
+     * HTTP/2 only. Send a push promise header block.
+     * <p/>
+     * A push promise contains all the headers that pertain to a server-initiated
+     * request, and a {@code promisedStreamId} to which response frames will be
+     * delivered. Push promise frames are sent as a part of the response to
+     * {@code streamId}.  The {@code promisedStreamId} has a priority of one
+     * greater than {@code streamId}.
+     *
+     * @param streamId         client-initiated stream ID.  Must be an odd number.
+     * @param promisedStreamId server-initiated stream ID.  Must be an even
+     *                         number.
+     * @param requestHeaders   minimally includes {@code :method}, {@code :scheme},
+     *                         {@code :authority}, and (@code :path}.
+     */
+    void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
+            throws IOException;
+
+    /**
+     * SPDY/3 only.
+     */
+    void flush() throws IOException;
+
+    void synStream(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
+                   List<Header> headerBlock) throws IOException;
+
+    void synReply(boolean outFinished, int streamId, List<Header> headerBlock)
+            throws IOException;
+
+    void headers(int streamId, List<Header> headerBlock) throws IOException;
+
+    void rstStream(int streamId, ErrorCode errorCode) throws IOException;
+
+    /**
+     * The maximum size of bytes that may be sent in a single call to {@link #data}.
+     */
+    int maxDataLength();
+
+    /**
+     * {@code source.length} may be longer than the max length of the variant's data frame.
+     * Implementations must send multiple frames as necessary.
+     *
+     * @param source    the buffer to draw bytes from. May be null if byteCount is 0.
+     * @param byteCount must be between 0 and the minimum of {code source.length}
+     *                  and {@link #maxDataLength}.
+     */
+    void data(boolean outFinished, int streamId, Buffer source, int byteCount) throws IOException;
+
+    /**
+     * Write okhttp's settings to the peer.
+     */
+    void settings(Settings okHttpSettings) throws IOException;
+
+    /**
+     * Send a connection-level ping to the peer.  {@code ack} indicates this is
+     * a reply.  Payload parameters are different between SPDY/3 and HTTP/2.
+     * <p/>
+     * In SPDY/3, only the first {@code payload1} parameter is sent.  If the
+     * sender is a client, it is an unsigned odd number.  Likewise, a server
+     * will send an even number.
+     * <p/>
+     * In HTTP/2, both {@code payload1} and {@code payload2} parameters are
+     * sent.  The data is opaque binary, and there are no rules on the content.
+     */
+    void ping(boolean ack, int payload1, int payload2) throws IOException;
+
+    /**
+     * Tell the peer to stop creating streams and that we last processed
+     * {@code lastGoodStreamId}, or zero if no streams were processed.
+     *
+     * @param lastGoodStreamId the last stream ID processed, or zero if no
+     *                         streams were processed.
+     * @param errorCode        reason for closing the connection.
+     * @param debugData        only valid for HTTP/2; opaque debug data to send.
+     */
+    void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) throws IOException;
+
+    /**
+     * Inform peer that an additional {@code windowSizeIncrement} bytes can be
+     * sent on {@code streamId}, or the connection if {@code streamId} is zero.
+     */
+    void windowUpdate(int streamId, long windowSizeIncrement) throws IOException;
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/FramedConnection.java b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/FramedConnection.java
index a86924b897..9d232e3fe2 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/FramedConnection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/FramedConnection.java
@@ -18,6 +18,7 @@
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.internal.NamedRunnable;
 import com.squareup.okhttp.internal.Util;
+
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.InterruptedIOException;
@@ -34,6 +35,7 @@
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 import java.util.logging.Level;
+
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.ByteString;
@@ -45,7 +47,7 @@
 /**
  * A socket connection to a remote peer. A connection hosts streams which can
  * send and receive data.
- *
+ * <p/>
  * <p>Many methods in this API are <strong>synchronous:</strong> the call is
  * completed before the method returns. This is typical for Java but atypical
  * for SPDY. This is motivated by exception transparency: an IOException that
@@ -53,829 +55,870 @@
  */
 public final class FramedConnection implements Closeable {
 
-  // Internal state of this connection is guarded by 'this'. No blocking
-  // operations may be performed while holding this lock!
-  //
-  // Socket writes are guarded by frameWriter.
-  //
-  // Socket reads are unguarded but are only made by the reader thread.
-  //
-  // Certain operations (like SYN_STREAM) need to synchronize on both the
-  // frameWriter (to do blocking I/O) and this (to create streams). Such
-  // operations must synchronize on 'this' last. This ensures that we never
-  // wait for a blocking operation while holding 'this'.
-
-  private static final ExecutorService executor = new ThreadPoolExecutor(0,
-      Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),
-      Util.threadFactory("OkHttp FramedConnection", true));
-
-  /** The protocol variant, like {@link com.squareup.okhttp.internal.framed.Spdy3}. */
-  final Protocol protocol;
-
-  /** True if this peer initiated the connection. */
-  final boolean client;
-
-  /**
-   * User code to run in response to an incoming stream. Callbacks must not be
-   * run on the callback executor.
-   */
-  private final IncomingStreamHandler handler;
-  private final Map<Integer, FramedStream> streams = new HashMap<>();
-  private final String hostName;
-  private int lastGoodStreamId;
-  private int nextStreamId;
-  private boolean shutdown;
-  private long idleStartTimeNs = System.nanoTime();
-
-  /** Ensures push promise callbacks events are sent in order per stream. */
-  private final ExecutorService pushExecutor;
-
-  /** Lazily-created map of in-flight pings awaiting a response. Guarded by this. */
-  private Map<Integer, Ping> pings;
-  /** User code to run in response to push promise events. */
-  private final PushObserver pushObserver;
-  private int nextPingId;
-
-  /**
-   * The total number of bytes consumed by the application, but not yet
-   * acknowledged by sending a {@code WINDOW_UPDATE} frame on this connection.
-   */
-  // Visible for testing
-  long unacknowledgedBytesRead = 0;
-
-  /**
-   * Count of bytes that can be written on the connection before receiving a
-   * window update.
-   */
-  // Visible for testing
-  long bytesLeftInWriteWindow;
-
-  /** Settings we communicate to the peer. */
-  // TODO: Do we want to dynamically adjust settings, or KISS and only set once?
-  final Settings okHttpSettings = new Settings();
-      // okHttpSettings.set(Settings.MAX_CONCURRENT_STREAMS, 0, max);
-  private static final int OKHTTP_CLIENT_WINDOW_SIZE = 16 * 1024 * 1024;
-
-  /** Settings we receive from the peer. */
-  // TODO: MWS will need to guard on this setting before attempting to push.
-  final Settings peerSettings = new Settings();
-
-  private boolean receivedInitialPeerSettings = false;
-  final Variant variant;
-  final Socket socket;
-  final FrameWriter frameWriter;
-
-  // Visible for testing
-  final Reader readerRunnable;
-
-  private FramedConnection(Builder builder) throws IOException {
-    protocol = builder.protocol;
-    pushObserver = builder.pushObserver;
-    client = builder.client;
-    handler = builder.handler;
-    // http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-5.1.1
-    nextStreamId = builder.client ? 1 : 2;
-    if (builder.client && protocol == Protocol.HTTP_2) {
-      nextStreamId += 2; // In HTTP/2, 1 on client is reserved for Upgrade.
-    }
-
-    nextPingId = builder.client ? 1 : 2;
-
-    // Flow control was designed more for servers, or proxies than edge clients.
-    // If we are a client, set the flow control window to 16MiB.  This avoids
-    // thrashing window updates every 64KiB, yet small enough to avoid blowing
-    // up the heap.
-    if (builder.client) {
-      okHttpSettings.set(Settings.INITIAL_WINDOW_SIZE, 0, OKHTTP_CLIENT_WINDOW_SIZE);
-    }
-
-    hostName = builder.hostName;
-
-    if (protocol == Protocol.HTTP_2) {
-      variant = new Http2();
-      // Like newSingleThreadExecutor, except lazy creates the thread.
-      pushExecutor = new ThreadPoolExecutor(0, 1, 60, TimeUnit.SECONDS,
-          new LinkedBlockingQueue<Runnable>(),
-          Util.threadFactory(String.format("OkHttp %s Push Observer", hostName), true));
-      // 1 less than SPDY http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-6.9.2
-      peerSettings.set(Settings.INITIAL_WINDOW_SIZE, 0, 65535);
-      peerSettings.set(Settings.MAX_FRAME_SIZE, 0, Http2.INITIAL_MAX_FRAME_SIZE);
-    } else if (protocol == Protocol.SPDY_3) {
-      variant = new Spdy3();
-      pushExecutor = null;
-    } else {
-      throw new AssertionError(protocol);
-    }
-    bytesLeftInWriteWindow = peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE);
-    socket = builder.socket;
-    frameWriter = variant.newWriter(Okio.buffer(Okio.sink(builder.socket)), client);
-
-    readerRunnable = new Reader();
-    new Thread(readerRunnable).start(); // Not a daemon thread.
-  }
-
-  /** The protocol as selected using ALPN. */
-  public Protocol getProtocol() {
-    return protocol;
-  }
-
-  /**
-   * Returns the number of {@link FramedStream#isOpen() open streams} on this
-   * connection.
-   */
-  public synchronized int openStreamCount() {
-    return streams.size();
-  }
-
-  synchronized FramedStream getStream(int id) {
-    return streams.get(id);
-  }
-
-  synchronized FramedStream removeStream(int streamId) {
-    FramedStream stream = streams.remove(streamId);
-    if (stream != null && streams.isEmpty()) {
-      setIdle(true);
-    }
-    notifyAll(); // The removed stream may be blocked on a connection-wide window update.
-    return stream;
-  }
-
-  private synchronized void setIdle(boolean value) {
-    idleStartTimeNs = value ? System.nanoTime() : Long.MAX_VALUE;
-  }
-
-  /** Returns true if this connection is idle. */
-  public synchronized boolean isIdle() {
-    return idleStartTimeNs != Long.MAX_VALUE;
-  }
-
-  /**
-   * Returns the time in ns when this connection became idle or Long.MAX_VALUE
-   * if connection is not idle.
-   */
-  public synchronized long getIdleStartTimeNs() {
-    return idleStartTimeNs;
-  }
-
-  /**
-   * Returns a new server-initiated stream.
-   *
-   * @param associatedStreamId the stream that triggered the sender to create
-   *     this stream.
-   * @param out true to create an output stream that we can use to send data
-   *     to the remote peer. Corresponds to {@code FLAG_FIN}.
-   */
-  public FramedStream pushStream(int associatedStreamId, List<Header> requestHeaders, boolean out)
-      throws IOException {
-    if (client) throw new IllegalStateException("Client cannot push requests.");
-    if (protocol != Protocol.HTTP_2) throw new IllegalStateException("protocol != HTTP_2");
-    return newStream(associatedStreamId, requestHeaders, out, false);
-  }
-
-  /**
-   * Returns a new locally-initiated stream.
-   *
-   * @param out true to create an output stream that we can use to send data to the remote peer.
-   *     Corresponds to {@code FLAG_FIN}.
-   * @param in true to create an input stream that the remote peer can use to send data to us.
-   *     Corresponds to {@code FLAG_UNIDIRECTIONAL}.
-   */
-  public FramedStream newStream(List<Header> requestHeaders, boolean out, boolean in)
-      throws IOException {
-    return newStream(0, requestHeaders, out, in);
-  }
-
-  private FramedStream newStream(int associatedStreamId, List<Header> requestHeaders, boolean out,
-      boolean in) throws IOException {
-    boolean outFinished = !out;
-    boolean inFinished = !in;
-    FramedStream stream;
-    int streamId;
-
-    synchronized (frameWriter) {
-      synchronized (this) {
-        if (shutdown) {
-          throw new IOException("shutdown");
-        }
-        streamId = nextStreamId;
-        nextStreamId += 2;
-        stream = new FramedStream(streamId, this, outFinished, inFinished, requestHeaders);
-        if (stream.isOpen()) {
-          streams.put(streamId, stream);
-          setIdle(false);
-        }
-      }
-      if (associatedStreamId == 0) {
-        frameWriter.synStream(outFinished, inFinished, streamId, associatedStreamId,
-            requestHeaders);
-      } else if (client) {
-        throw new IllegalArgumentException("client streams shouldn't have associated stream IDs");
-      } else { // HTTP/2 has a PUSH_PROMISE frame.
-        frameWriter.pushPromise(associatedStreamId, streamId, requestHeaders);
-      }
-    }
-
-    if (!out) {
-      frameWriter.flush();
-    }
-
-    return stream;
-  }
-
-  void writeSynReply(int streamId, boolean outFinished, List<Header> alternating)
-      throws IOException {
-    frameWriter.synReply(outFinished, streamId, alternating);
-  }
-
-  /**
-   * Callers of this method are not thread safe, and sometimes on application threads. Most often,
-   * this method will be called to send a buffer worth of data to the peer.
-   *
-   * <p>Writes are subject to the write window of the stream and the connection. Until there is a
-   * window sufficient to send {@code byteCount}, the caller will block. For example, a user of
-   * {@code HttpURLConnection} who flushes more bytes to the output stream than the connection's
-   * write window will block.
-   *
-   * <p>Zero {@code byteCount} writes are not subject to flow control and will not block. The only
-   * use case for zero {@code byteCount} is closing a flushed output stream.
-   */
-  public void writeData(int streamId, boolean outFinished, Buffer buffer, long byteCount)
-      throws IOException {
-    if (byteCount == 0) { // Empty data frames are not flow-controlled.
-      frameWriter.data(outFinished, streamId, buffer, 0);
-      return;
-    }
-
-    while (byteCount > 0) {
-      int toWrite;
-      synchronized (FramedConnection.this) {
-        try {
-          while (bytesLeftInWriteWindow <= 0) {
-            // Before blocking, confirm that the stream we're writing is still open. It's possible
-            // that the stream has since been closed (such as if this write timed out.)
-            if (!streams.containsKey(streamId)) {
-              throw new IOException("stream closed");
-            }
-            FramedConnection.this.wait(); // Wait until we receive a WINDOW_UPDATE.
-          }
-        } catch (InterruptedException e) {
-          throw new InterruptedIOException();
-        }
-
-        toWrite = (int) Math.min(byteCount, bytesLeftInWriteWindow);
-        toWrite = Math.min(toWrite, frameWriter.maxDataLength());
-        bytesLeftInWriteWindow -= toWrite;
-      }
-
-      byteCount -= toWrite;
-      frameWriter.data(outFinished && byteCount == 0, streamId, buffer, toWrite);
-    }
-  }
-
-  /**
-   * {@code delta} will be negative if a settings frame initial window is
-   * smaller than the last.
-   */
-  void addBytesToWriteWindow(long delta) {
-    bytesLeftInWriteWindow += delta;
-    if (delta > 0) FramedConnection.this.notifyAll();
-  }
-
-  void writeSynResetLater(final int streamId, final ErrorCode errorCode) {
-    executor.submit(new NamedRunnable("OkHttp %s stream %d", hostName, streamId) {
-      @Override public void execute() {
-        try {
-          writeSynReset(streamId, errorCode);
-        } catch (IOException ignored) {
+    // Internal state of this connection is guarded by 'this'. No blocking
+    // operations may be performed while holding this lock!
+    //
+    // Socket writes are guarded by frameWriter.
+    //
+    // Socket reads are unguarded but are only made by the reader thread.
+    //
+    // Certain operations (like SYN_STREAM) need to synchronize on both the
+    // frameWriter (to do blocking I/O) and this (to create streams). Such
+    // operations must synchronize on 'this' last. This ensures that we never
+    // wait for a blocking operation while holding 'this'.
+
+    private static final ExecutorService executor = new ThreadPoolExecutor(0,
+            Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),
+            Util.threadFactory("OkHttp FramedConnection", true));
+
+    /**
+     * The protocol variant, like {@link com.squareup.okhttp.internal.framed.Spdy3}.
+     */
+    final Protocol protocol;
+
+    /**
+     * True if this peer initiated the connection.
+     */
+    final boolean client;
+
+    /**
+     * User code to run in response to an incoming stream. Callbacks must not be
+     * run on the callback executor.
+     */
+    private final IncomingStreamHandler handler;
+    private final Map<Integer, FramedStream> streams = new HashMap<>();
+    private final String hostName;
+    private int lastGoodStreamId;
+    private int nextStreamId;
+    private boolean shutdown;
+    private long idleStartTimeNs = System.nanoTime();
+
+    /**
+     * Ensures push promise callbacks events are sent in order per stream.
+     */
+    private final ExecutorService pushExecutor;
+
+    /**
+     * Lazily-created map of in-flight pings awaiting a response. Guarded by this.
+     */
+    private Map<Integer, Ping> pings;
+    /**
+     * User code to run in response to push promise events.
+     */
+    private final PushObserver pushObserver;
+    private int nextPingId;
+
+    /**
+     * The total number of bytes consumed by the application, but not yet
+     * acknowledged by sending a {@code WINDOW_UPDATE} frame on this connection.
+     */
+    // Visible for testing
+    long unacknowledgedBytesRead = 0;
+
+    /**
+     * Count of bytes that can be written on the connection before receiving a
+     * window update.
+     */
+    // Visible for testing
+    long bytesLeftInWriteWindow;
+
+    /**
+     * Settings we communicate to the peer.
+     */
+    // TODO: Do we want to dynamically adjust settings, or KISS and only set once?
+    final Settings okHttpSettings = new Settings();
+    // okHttpSettings.set(Settings.MAX_CONCURRENT_STREAMS, 0, max);
+    private static final int OKHTTP_CLIENT_WINDOW_SIZE = 16 * 1024 * 1024;
+
+    /**
+     * Settings we receive from the peer.
+     */
+    // TODO: MWS will need to guard on this setting before attempting to push.
+    final Settings peerSettings = new Settings();
+
+    private boolean receivedInitialPeerSettings = false;
+    final Variant variant;
+    final Socket socket;
+    final FrameWriter frameWriter;
+
+    // Visible for testing
+    final Reader readerRunnable;
+
+    private FramedConnection(Builder builder) throws IOException {
+        protocol = builder.protocol;
+        pushObserver = builder.pushObserver;
+        client = builder.client;
+        handler = builder.handler;
+        // http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-5.1.1
+        nextStreamId = builder.client ? 1 : 2;
+        if (builder.client && protocol == Protocol.HTTP_2) {
+            nextStreamId += 2; // In HTTP/2, 1 on client is reserved for Upgrade.
         }
-      }
-    });
-  }
 
-  void writeSynReset(int streamId, ErrorCode statusCode) throws IOException {
-    frameWriter.rstStream(streamId, statusCode);
-  }
+        nextPingId = builder.client ? 1 : 2;
 
-  void writeWindowUpdateLater(final int streamId, final long unacknowledgedBytesRead) {
-    executor.execute(new NamedRunnable("OkHttp Window Update %s stream %d", hostName, streamId) {
-      @Override public void execute() {
-        try {
-          frameWriter.windowUpdate(streamId, unacknowledgedBytesRead);
-        } catch (IOException ignored) {
-        }
-      }
-    });
-  }
-
-  /**
-   * Sends a ping frame to the peer. Use the returned object to await the
-   * ping's response and observe its round trip time.
-   */
-  public Ping ping() throws IOException {
-    Ping ping = new Ping();
-    int pingId;
-    synchronized (this) {
-      if (shutdown) {
-        throw new IOException("shutdown");
-      }
-      pingId = nextPingId;
-      nextPingId += 2;
-      if (pings == null) pings = new HashMap<>();
-      pings.put(pingId, ping);
-    }
-    writePing(false, pingId, 0x4f4b6f6b /* ASCII "OKok" */, ping);
-    return ping;
-  }
-
-  private void writePingLater(
-      final boolean reply, final int payload1, final int payload2, final Ping ping) {
-    executor.execute(new NamedRunnable("OkHttp %s ping %08x%08x",
-        hostName, payload1, payload2) {
-      @Override public void execute() {
-        try {
-          writePing(reply, payload1, payload2, ping);
-        } catch (IOException ignored) {
-        }
-      }
-    });
-  }
-
-  private void writePing(boolean reply, int payload1, int payload2, Ping ping) throws IOException {
-    synchronized (frameWriter) {
-      // Observe the sent time immediately before performing I/O.
-      if (ping != null) ping.send();
-      frameWriter.ping(reply, payload1, payload2);
-    }
-  }
-
-  private synchronized Ping removePing(int id) {
-    return pings != null ? pings.remove(id) : null;
-  }
-
-  public void flush() throws IOException {
-    frameWriter.flush();
-  }
-
-  /**
-   * Degrades this connection such that new streams can neither be created
-   * locally, nor accepted from the remote peer. Existing streams are not
-   * impacted. This is intended to permit an endpoint to gracefully stop
-   * accepting new requests without harming previously established streams.
-   */
-  public void shutdown(ErrorCode statusCode) throws IOException {
-    synchronized (frameWriter) {
-      int lastGoodStreamId;
-      synchronized (this) {
-        if (shutdown) {
-          return;
-        }
-        shutdown = true;
-        lastGoodStreamId = this.lastGoodStreamId;
-      }
-      // TODO: propagate exception message into debugData
-      frameWriter.goAway(lastGoodStreamId, statusCode, Util.EMPTY_BYTE_ARRAY);
-    }
-  }
-
-  /**
-   * Closes this connection. This cancels all open streams and unanswered
-   * pings. It closes the underlying input and output streams and shuts down
-   * internal executor services.
-   */
-  @Override public void close() throws IOException {
-    close(ErrorCode.NO_ERROR, ErrorCode.CANCEL);
-  }
-
-  private void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOException {
-    assert (!Thread.holdsLock(this));
-    IOException thrown = null;
-    try {
-      shutdown(connectionCode);
-    } catch (IOException e) {
-      thrown = e;
-    }
-
-    FramedStream[] streamsToClose = null;
-    Ping[] pingsToCancel = null;
-    synchronized (this) {
-      if (!streams.isEmpty()) {
-        streamsToClose = streams.values().toArray(new FramedStream[streams.size()]);
-        streams.clear();
-        setIdle(false);
-      }
-      if (pings != null) {
-        pingsToCancel = pings.values().toArray(new Ping[pings.size()]);
-        pings = null;
-      }
-    }
-
-    if (streamsToClose != null) {
-      for (FramedStream stream : streamsToClose) {
-        try {
-          stream.close(streamCode);
-        } catch (IOException e) {
-          if (thrown != null) thrown = e;
+        // Flow control was designed more for servers, or proxies than edge clients.
+        // If we are a client, set the flow control window to 16MiB.  This avoids
+        // thrashing window updates every 64KiB, yet small enough to avoid blowing
+        // up the heap.
+        if (builder.client) {
+            okHttpSettings.set(Settings.INITIAL_WINDOW_SIZE, 0, OKHTTP_CLIENT_WINDOW_SIZE);
         }
-      }
+
+        hostName = builder.hostName;
+
+        if (protocol == Protocol.HTTP_2) {
+            variant = new Http2();
+            // Like newSingleThreadExecutor, except lazy creates the thread.
+            pushExecutor = new ThreadPoolExecutor(0, 1, 60, TimeUnit.SECONDS,
+                    new LinkedBlockingQueue<Runnable>(),
+                    Util.threadFactory(String.format("OkHttp %s Push Observer", hostName), true));
+            // 1 less than SPDY http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-6.9.2
+            peerSettings.set(Settings.INITIAL_WINDOW_SIZE, 0, 65535);
+            peerSettings.set(Settings.MAX_FRAME_SIZE, 0, Http2.INITIAL_MAX_FRAME_SIZE);
+        } else if (protocol == Protocol.SPDY_3) {
+            variant = new Spdy3();
+            pushExecutor = null;
+        } else {
+            throw new AssertionError(protocol);
+        }
+        bytesLeftInWriteWindow = peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE);
+        socket = builder.socket;
+        frameWriter = variant.newWriter(Okio.buffer(Okio.sink(builder.socket)), client);
+
+        readerRunnable = new Reader();
+        new Thread(readerRunnable).start(); // Not a daemon thread.
     }
 
-    if (pingsToCancel != null) {
-      for (Ping ping : pingsToCancel) {
-        ping.cancel();
-      }
+    /**
+     * The protocol as selected using ALPN.
+     */
+    public Protocol getProtocol() {
+        return protocol;
     }
 
-    // Close the writer to release its resources (such as deflaters).
-    try {
-      frameWriter.close();
-    } catch (IOException e) {
-      if (thrown == null) thrown = e;
+    /**
+     * Returns the number of {@link FramedStream#isOpen() open streams} on this
+     * connection.
+     */
+    public synchronized int openStreamCount() {
+        return streams.size();
     }
 
-    // Close the socket to break out the reader thread, which will clean up after itself.
-    try {
-      socket.close();
-    } catch (IOException e) {
-      thrown = e;
+    synchronized FramedStream getStream(int id) {
+        return streams.get(id);
     }
 
-    if (thrown != null) throw thrown;
-  }
+    synchronized FramedStream removeStream(int streamId) {
+        FramedStream stream = streams.remove(streamId);
+        if (stream != null && streams.isEmpty()) {
+            setIdle(true);
+        }
+        notifyAll(); // The removed stream may be blocked on a connection-wide window update.
+        return stream;
+    }
 
-  /**
-   * Sends a connection header if the current variant requires it. This should
-   * be called after {@link Builder#build} for all new connections.
-   */
-  public void sendConnectionPreface() throws IOException {
-    frameWriter.connectionPreface();
-    frameWriter.settings(okHttpSettings);
-    int windowSize = okHttpSettings.getInitialWindowSize(Settings.DEFAULT_INITIAL_WINDOW_SIZE);
-    if (windowSize != Settings.DEFAULT_INITIAL_WINDOW_SIZE) {
-      frameWriter.windowUpdate(0, windowSize - Settings.DEFAULT_INITIAL_WINDOW_SIZE);
+    private synchronized void setIdle(boolean value) {
+        idleStartTimeNs = value ? System.nanoTime() : Long.MAX_VALUE;
     }
-  }
 
-  public static class Builder {
-    private String hostName;
-    private Socket socket;
-    private IncomingStreamHandler handler = IncomingStreamHandler.REFUSE_INCOMING_STREAMS;
-    private Protocol protocol = Protocol.SPDY_3;
-    private PushObserver pushObserver = PushObserver.CANCEL;
-    private boolean client;
+    /**
+     * Returns true if this connection is idle.
+     */
+    public synchronized boolean isIdle() {
+        return idleStartTimeNs != Long.MAX_VALUE;
+    }
+
+    /**
+     * Returns the time in ns when this connection became idle or Long.MAX_VALUE
+     * if connection is not idle.
+     */
+    public synchronized long getIdleStartTimeNs() {
+        return idleStartTimeNs;
+    }
 
-    public Builder(boolean client, Socket socket) throws IOException {
-      this(((InetSocketAddress) socket.getRemoteSocketAddress()).getHostName(), client, socket);
+    /**
+     * Returns a new server-initiated stream.
+     *
+     * @param associatedStreamId the stream that triggered the sender to create
+     *                           this stream.
+     * @param out                true to create an output stream that we can use to send data
+     *                           to the remote peer. Corresponds to {@code FLAG_FIN}.
+     */
+    public FramedStream pushStream(int associatedStreamId, List<Header> requestHeaders, boolean out)
+            throws IOException {
+        if (client) throw new IllegalStateException("Client cannot push requests.");
+        if (protocol != Protocol.HTTP_2) throw new IllegalStateException("protocol != HTTP_2");
+        return newStream(associatedStreamId, requestHeaders, out, false);
     }
 
     /**
-     * @param client true if this peer initiated the connection; false if this
-     *     peer accepted the connection.
+     * Returns a new locally-initiated stream.
+     *
+     * @param out true to create an output stream that we can use to send data to the remote peer.
+     *            Corresponds to {@code FLAG_FIN}.
+     * @param in  true to create an input stream that the remote peer can use to send data to us.
+     *            Corresponds to {@code FLAG_UNIDIRECTIONAL}.
      */
-    public Builder(String hostName, boolean client, Socket socket) throws IOException {
-      this.hostName = hostName;
-      this.client = client;
-      this.socket = socket;
+    public FramedStream newStream(List<Header> requestHeaders, boolean out, boolean in)
+            throws IOException {
+        return newStream(0, requestHeaders, out, in);
+    }
+
+    private FramedStream newStream(int associatedStreamId, List<Header> requestHeaders, boolean out,
+                                   boolean in) throws IOException {
+        boolean outFinished = !out;
+        boolean inFinished = !in;
+        FramedStream stream;
+        int streamId;
+
+        synchronized (frameWriter) {
+            synchronized (this) {
+                if (shutdown) {
+                    throw new IOException("shutdown");
+                }
+                streamId = nextStreamId;
+                nextStreamId += 2;
+                stream = new FramedStream(streamId, this, outFinished, inFinished, requestHeaders);
+                if (stream.isOpen()) {
+                    streams.put(streamId, stream);
+                    setIdle(false);
+                }
+            }
+            if (associatedStreamId == 0) {
+                frameWriter.synStream(outFinished, inFinished, streamId, associatedStreamId,
+                        requestHeaders);
+            } else if (client) {
+                throw new IllegalArgumentException("client streams shouldn't have associated stream IDs");
+            } else { // HTTP/2 has a PUSH_PROMISE frame.
+                frameWriter.pushPromise(associatedStreamId, streamId, requestHeaders);
+            }
+        }
+
+        if (!out) {
+            frameWriter.flush();
+        }
+
+        return stream;
     }
 
-    public Builder handler(IncomingStreamHandler handler) {
-      this.handler = handler;
-      return this;
+    void writeSynReply(int streamId, boolean outFinished, List<Header> alternating)
+            throws IOException {
+        frameWriter.synReply(outFinished, streamId, alternating);
     }
 
-    public Builder protocol(Protocol protocol) {
-      this.protocol = protocol;
-      return this;
+    /**
+     * Callers of this method are not thread safe, and sometimes on application threads. Most often,
+     * this method will be called to send a buffer worth of data to the peer.
+     * <p/>
+     * <p>Writes are subject to the write window of the stream and the connection. Until there is a
+     * window sufficient to send {@code byteCount}, the caller will block. For example, a user of
+     * {@code HttpURLConnection} who flushes more bytes to the output stream than the connection's
+     * write window will block.
+     * <p/>
+     * <p>Zero {@code byteCount} writes are not subject to flow control and will not block. The only
+     * use case for zero {@code byteCount} is closing a flushed output stream.
+     */
+    public void writeData(int streamId, boolean outFinished, Buffer buffer, long byteCount)
+            throws IOException {
+        if (byteCount == 0) { // Empty data frames are not flow-controlled.
+            frameWriter.data(outFinished, streamId, buffer, 0);
+            return;
+        }
+
+        while (byteCount > 0) {
+            int toWrite;
+            synchronized (FramedConnection.this) {
+                try {
+                    while (bytesLeftInWriteWindow <= 0) {
+                        // Before blocking, confirm that the stream we're writing is still open. It's possible
+                        // that the stream has since been closed (such as if this write timed out.)
+                        if (!streams.containsKey(streamId)) {
+                            throw new IOException("stream closed");
+                        }
+                        FramedConnection.this.wait(); // Wait until we receive a WINDOW_UPDATE.
+                    }
+                } catch (InterruptedException e) {
+                    throw new InterruptedIOException();
+                }
+
+                toWrite = (int) Math.min(byteCount, bytesLeftInWriteWindow);
+                toWrite = Math.min(toWrite, frameWriter.maxDataLength());
+                bytesLeftInWriteWindow -= toWrite;
+            }
+
+            byteCount -= toWrite;
+            frameWriter.data(outFinished && byteCount == 0, streamId, buffer, toWrite);
+        }
     }
 
-    public Builder pushObserver(PushObserver pushObserver) {
-      this.pushObserver = pushObserver;
-      return this;
+    /**
+     * {@code delta} will be negative if a settings frame initial window is
+     * smaller than the last.
+     */
+    void addBytesToWriteWindow(long delta) {
+        bytesLeftInWriteWindow += delta;
+        if (delta > 0) FramedConnection.this.notifyAll();
     }
 
-    public FramedConnection build() throws IOException {
-      return new FramedConnection(this);
+    void writeSynResetLater(final int streamId, final ErrorCode errorCode) {
+        executor.submit(new NamedRunnable("OkHttp %s stream %d", hostName, streamId) {
+            @Override
+            public void execute() {
+                try {
+                    writeSynReset(streamId, errorCode);
+                } catch (IOException ignored) {
+                }
+            }
+        });
     }
-  }
 
-  /**
-   * Methods in this class must not lock FrameWriter.  If a method needs to
-   * write a frame, create an async task to do so.
-   */
-  class Reader extends NamedRunnable implements FrameReader.Handler {
-    FrameReader frameReader;
+    void writeSynReset(int streamId, ErrorCode statusCode) throws IOException {
+        frameWriter.rstStream(streamId, statusCode);
+    }
 
-    private Reader() {
-      super("OkHttp %s", hostName);
+    void writeWindowUpdateLater(final int streamId, final long unacknowledgedBytesRead) {
+        executor.execute(new NamedRunnable("OkHttp Window Update %s stream %d", hostName, streamId) {
+            @Override
+            public void execute() {
+                try {
+                    frameWriter.windowUpdate(streamId, unacknowledgedBytesRead);
+                } catch (IOException ignored) {
+                }
+            }
+        });
     }
 
-    @Override protected void execute() {
-      ErrorCode connectionErrorCode = ErrorCode.INTERNAL_ERROR;
-      ErrorCode streamErrorCode = ErrorCode.INTERNAL_ERROR;
-      try {
-        frameReader = variant.newReader(Okio.buffer(Okio.source(socket)), client);
-        if (!client) {
-          frameReader.readConnectionPreface();
-        }
-        while (frameReader.nextFrame(this)) {
+    /**
+     * Sends a ping frame to the peer. Use the returned object to await the
+     * ping's response and observe its round trip time.
+     */
+    public Ping ping() throws IOException {
+        Ping ping = new Ping();
+        int pingId;
+        synchronized (this) {
+            if (shutdown) {
+                throw new IOException("shutdown");
+            }
+            pingId = nextPingId;
+            nextPingId += 2;
+            if (pings == null) pings = new HashMap<>();
+            pings.put(pingId, ping);
         }
-        connectionErrorCode = ErrorCode.NO_ERROR;
-        streamErrorCode = ErrorCode.CANCEL;
-      } catch (IOException e) {
-        connectionErrorCode = ErrorCode.PROTOCOL_ERROR;
-        streamErrorCode = ErrorCode.PROTOCOL_ERROR;
-      } finally {
-        try {
-          close(connectionErrorCode, streamErrorCode);
-        } catch (IOException ignored) {
-        }
-        Util.closeQuietly(frameReader);
-      }
-    }
-
-    @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
-        throws IOException {
-      if (pushedStream(streamId)) {
-        pushDataLater(streamId, source, length, inFinished);
-        return;
-      }
-      FramedStream dataStream = getStream(streamId);
-      if (dataStream == null) {
-        writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);
-        source.skip(length);
-        return;
-      }
-      dataStream.receiveData(source, length);
-      if (inFinished) {
-        dataStream.receiveFin();
-      }
-    }
-
-    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
-        int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {
-      if (pushedStream(streamId)) {
-        pushHeadersLater(streamId, headerBlock, inFinished);
-        return;
-      }
-      FramedStream stream;
-      synchronized (FramedConnection.this) {
-        // If we're shutdown, don't bother with this stream.
-        if (shutdown) return;
-
-        stream = getStream(streamId);
-
-        if (stream == null) {
-          // The headers claim to be for an existing stream, but we don't have one.
-          if (headersMode.failIfStreamAbsent()) {
-            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);
-            return;
-          }
-
-          // If the stream ID is less than the last created ID, assume it's already closed.
-          if (streamId <= lastGoodStreamId) return;
-
-          // If the stream ID is in the client's namespace, assume it's already closed.
-          if (streamId % 2 == nextStreamId % 2) return;
-
-          // Create a stream.
-          final FramedStream
-              newStream = new FramedStream(streamId, FramedConnection.this, outFinished,
-              inFinished, headerBlock);
-          lastGoodStreamId = streamId;
-          streams.put(streamId, newStream);
-          executor.execute(new NamedRunnable("OkHttp %s stream %d", hostName, streamId) {
-            @Override public void execute() {
-              try {
-                handler.receive(newStream);
-              } catch (IOException e) {
-                logger.log(Level.INFO, "StreamHandler failure for " + hostName, e);
+        writePing(false, pingId, 0x4f4b6f6b /* ASCII "OKok" */, ping);
+        return ping;
+    }
+
+    private void writePingLater(
+            final boolean reply, final int payload1, final int payload2, final Ping ping) {
+        executor.execute(new NamedRunnable("OkHttp %s ping %08x%08x",
+                hostName, payload1, payload2) {
+            @Override
+            public void execute() {
                 try {
-                  newStream.close(ErrorCode.PROTOCOL_ERROR);
+                    writePing(reply, payload1, payload2, ping);
                 } catch (IOException ignored) {
                 }
-              }
-            }
-          });
-          return;
-        }
-      }
-
-      // The headers claim to be for a new stream, but we already have one.
-      if (headersMode.failIfStreamPresent()) {
-        stream.closeLater(ErrorCode.PROTOCOL_ERROR);
-        removeStream(streamId);
-        return;
-      }
-
-      // Update an existing stream.
-      stream.receiveHeaders(headerBlock, headersMode);
-      if (inFinished) stream.receiveFin();
-    }
-
-    @Override public void rstStream(int streamId, ErrorCode errorCode) {
-      if (pushedStream(streamId)) {
-        pushResetLater(streamId, errorCode);
-        return;
-      }
-      FramedStream rstStream = removeStream(streamId);
-      if (rstStream != null) {
-        rstStream.receiveRstStream(errorCode);
-      }
+            }
+        });
     }
 
-    @Override public void settings(boolean clearPrevious, Settings newSettings) {
-      long delta = 0;
-      FramedStream[] streamsToNotify = null;
-      synchronized (FramedConnection.this) {
-        int priorWriteWindowSize = peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE);
-        if (clearPrevious) peerSettings.clear();
-        peerSettings.merge(newSettings);
-        if (getProtocol() == Protocol.HTTP_2) {
-          ackSettingsLater(newSettings);
-        }
-        int peerInitialWindowSize = peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE);
-        if (peerInitialWindowSize != -1 && peerInitialWindowSize != priorWriteWindowSize) {
-          delta = peerInitialWindowSize - priorWriteWindowSize;
-          if (!receivedInitialPeerSettings) {
-            addBytesToWriteWindow(delta);
-            receivedInitialPeerSettings = true;
-          }
-          if (!streams.isEmpty()) {
-            streamsToNotify = streams.values().toArray(new FramedStream[streams.size()]);
-          }
+    private void writePing(boolean reply, int payload1, int payload2, Ping ping) throws IOException {
+        synchronized (frameWriter) {
+            // Observe the sent time immediately before performing I/O.
+            if (ping != null) ping.send();
+            frameWriter.ping(reply, payload1, payload2);
         }
-      }
-      if (streamsToNotify != null && delta != 0) {
-        for (FramedStream stream : streamsToNotify) {
-          synchronized (stream) {
-            stream.addBytesToWriteWindow(delta);
-          }
-        }
-      }
     }
 
-    private void ackSettingsLater(final Settings peerSettings) {
-      executor.execute(new NamedRunnable("OkHttp %s ACK Settings", hostName) {
-        @Override public void execute() {
-          try {
-            frameWriter.ackSettings(peerSettings);
-          } catch (IOException ignored) {
-          }
-        }
-      });
+    private synchronized Ping removePing(int id) {
+        return pings != null ? pings.remove(id) : null;
     }
 
-    @Override public void ackSettings() {
-      // TODO: If we don't get this callback after sending settings to the peer, SETTINGS_TIMEOUT.
+    public void flush() throws IOException {
+        frameWriter.flush();
     }
 
-    @Override public void ping(boolean reply, int payload1, int payload2) {
-      if (reply) {
-        Ping ping = removePing(payload1);
-        if (ping != null) {
-          ping.receive();
+    /**
+     * Degrades this connection such that new streams can neither be created
+     * locally, nor accepted from the remote peer. Existing streams are not
+     * impacted. This is intended to permit an endpoint to gracefully stop
+     * accepting new requests without harming previously established streams.
+     */
+    public void shutdown(ErrorCode statusCode) throws IOException {
+        synchronized (frameWriter) {
+            int lastGoodStreamId;
+            synchronized (this) {
+                if (shutdown) {
+                    return;
+                }
+                shutdown = true;
+                lastGoodStreamId = this.lastGoodStreamId;
+            }
+            // TODO: propagate exception message into debugData
+            frameWriter.goAway(lastGoodStreamId, statusCode, Util.EMPTY_BYTE_ARRAY);
         }
-      } else {
-        // Send a reply to a client ping if this is a server and vice versa.
-        writePingLater(true, payload1, payload2, null);
-      }
     }
 
-    @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
-      if (debugData.size() > 0) { // TODO: log the debugData
-      }
+    /**
+     * Closes this connection. This cancels all open streams and unanswered
+     * pings. It closes the underlying input and output streams and shuts down
+     * internal executor services.
+     */
+    @Override
+    public void close() throws IOException {
+        close(ErrorCode.NO_ERROR, ErrorCode.CANCEL);
+    }
 
-      // Copy the streams first. We don't want to hold a lock when we call receiveRstStream().
-      FramedStream[] streamsCopy;
-      synchronized (FramedConnection.this) {
-        streamsCopy = streams.values().toArray(new FramedStream[streams.size()]);
-        shutdown = true;
-      }
+    private void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOException {
+        assert (!Thread.holdsLock(this));
+        IOException thrown = null;
+        try {
+            shutdown(connectionCode);
+        } catch (IOException e) {
+            thrown = e;
+        }
 
-      // Fail all streams created after the last good stream ID.
-      for (FramedStream framedStream : streamsCopy) {
-        if (framedStream.getId() > lastGoodStreamId && framedStream.isLocallyInitiated()) {
-          framedStream.receiveRstStream(ErrorCode.REFUSED_STREAM);
-          removeStream(framedStream.getId());
+        FramedStream[] streamsToClose = null;
+        Ping[] pingsToCancel = null;
+        synchronized (this) {
+            if (!streams.isEmpty()) {
+                streamsToClose = streams.values().toArray(new FramedStream[streams.size()]);
+                streams.clear();
+                setIdle(false);
+            }
+            if (pings != null) {
+                pingsToCancel = pings.values().toArray(new Ping[pings.size()]);
+                pings = null;
+            }
         }
-      }
-    }
-
-    @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
-      if (streamId == 0) {
-        synchronized (FramedConnection.this) {
-          bytesLeftInWriteWindow += windowSizeIncrement;
-          FramedConnection.this.notifyAll();
+
+        if (streamsToClose != null) {
+            for (FramedStream stream : streamsToClose) {
+                try {
+                    stream.close(streamCode);
+                } catch (IOException e) {
+                    if (thrown != null) thrown = e;
+                }
+            }
         }
-      } else {
-        FramedStream stream = getStream(streamId);
-        if (stream != null) {
-          synchronized (stream) {
-            stream.addBytesToWriteWindow(windowSizeIncrement);
-          }
-        }
-      }
-    }
 
-    @Override public void priority(int streamId, int streamDependency, int weight,
-        boolean exclusive) {
-      // TODO: honor priority.
-    }
+        if (pingsToCancel != null) {
+            for (Ping ping : pingsToCancel) {
+                ping.cancel();
+            }
+        }
 
-    @Override
-    public void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders) {
-      pushRequestLater(promisedStreamId, requestHeaders);
+        // Close the writer to release its resources (such as deflaters).
+        try {
+            frameWriter.close();
+        } catch (IOException e) {
+            if (thrown == null) thrown = e;
+        }
+
+        // Close the socket to break out the reader thread, which will clean up after itself.
+        try {
+            socket.close();
+        } catch (IOException e) {
+            thrown = e;
+        }
+
+        if (thrown != null) throw thrown;
     }
 
-    @Override public void alternateService(int streamId, String origin, ByteString protocol,
-        String host, int port, long maxAge) {
-      // TODO: register alternate service.
+    /**
+     * Sends a connection header if the current variant requires it. This should
+     * be called after {@link Builder#build} for all new connections.
+     */
+    public void sendConnectionPreface() throws IOException {
+        frameWriter.connectionPreface();
+        frameWriter.settings(okHttpSettings);
+        int windowSize = okHttpSettings.getInitialWindowSize(Settings.DEFAULT_INITIAL_WINDOW_SIZE);
+        if (windowSize != Settings.DEFAULT_INITIAL_WINDOW_SIZE) {
+            frameWriter.windowUpdate(0, windowSize - Settings.DEFAULT_INITIAL_WINDOW_SIZE);
+        }
     }
-  }
 
-  /** Even, positive numbered streams are pushed streams in HTTP/2. */
-  private boolean pushedStream(int streamId) {
-    return protocol == Protocol.HTTP_2 && streamId != 0 && (streamId & 1) == 0;
-  }
+    public static class Builder {
+        private String hostName;
+        private Socket socket;
+        private IncomingStreamHandler handler = IncomingStreamHandler.REFUSE_INCOMING_STREAMS;
+        private Protocol protocol = Protocol.SPDY_3;
+        private PushObserver pushObserver = PushObserver.CANCEL;
+        private boolean client;
 
-  // Guarded by this.
-  private final Set<Integer> currentPushRequests = new LinkedHashSet<>();
+        public Builder(boolean client, Socket socket) throws IOException {
+            this(((InetSocketAddress) socket.getRemoteSocketAddress()).getHostName(), client, socket);
+        }
+
+        /**
+         * @param client true if this peer initiated the connection; false if this
+         *               peer accepted the connection.
+         */
+        public Builder(String hostName, boolean client, Socket socket) throws IOException {
+            this.hostName = hostName;
+            this.client = client;
+            this.socket = socket;
+        }
+
+        public Builder handler(IncomingStreamHandler handler) {
+            this.handler = handler;
+            return this;
+        }
+
+        public Builder protocol(Protocol protocol) {
+            this.protocol = protocol;
+            return this;
+        }
 
-  private void pushRequestLater(final int streamId, final List<Header> requestHeaders) {
-    synchronized (this) {
-      if (currentPushRequests.contains(streamId)) {
-        writeSynResetLater(streamId, ErrorCode.PROTOCOL_ERROR);
-        return;
-      }
-      currentPushRequests.add(streamId);
+        public Builder pushObserver(PushObserver pushObserver) {
+            this.pushObserver = pushObserver;
+            return this;
+        }
+
+        public FramedConnection build() throws IOException {
+            return new FramedConnection(this);
+        }
     }
-    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Request[%s]", hostName, streamId) {
-      @Override public void execute() {
-        boolean cancel = pushObserver.onRequest(streamId, requestHeaders);
-        try {
-          if (cancel) {
-            frameWriter.rstStream(streamId, ErrorCode.CANCEL);
+
+    /**
+     * Methods in this class must not lock FrameWriter.  If a method needs to
+     * write a frame, create an async task to do so.
+     */
+    class Reader extends NamedRunnable implements FrameReader.Handler {
+        FrameReader frameReader;
+
+        private Reader() {
+            super("OkHttp %s", hostName);
+        }
+
+        @Override
+        protected void execute() {
+            ErrorCode connectionErrorCode = ErrorCode.INTERNAL_ERROR;
+            ErrorCode streamErrorCode = ErrorCode.INTERNAL_ERROR;
+            try {
+                frameReader = variant.newReader(Okio.buffer(Okio.source(socket)), client);
+                if (!client) {
+                    frameReader.readConnectionPreface();
+                }
+                while (frameReader.nextFrame(this)) {
+                }
+                connectionErrorCode = ErrorCode.NO_ERROR;
+                streamErrorCode = ErrorCode.CANCEL;
+            } catch (IOException e) {
+                connectionErrorCode = ErrorCode.PROTOCOL_ERROR;
+                streamErrorCode = ErrorCode.PROTOCOL_ERROR;
+            } finally {
+                try {
+                    close(connectionErrorCode, streamErrorCode);
+                } catch (IOException ignored) {
+                }
+                Util.closeQuietly(frameReader);
+            }
+        }
+
+        @Override
+        public void data(boolean inFinished, int streamId, BufferedSource source, int length)
+                throws IOException {
+            if (pushedStream(streamId)) {
+                pushDataLater(streamId, source, length, inFinished);
+                return;
+            }
+            FramedStream dataStream = getStream(streamId);
+            if (dataStream == null) {
+                writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);
+                source.skip(length);
+                return;
+            }
+            dataStream.receiveData(source, length);
+            if (inFinished) {
+                dataStream.receiveFin();
+            }
+        }
+
+        @Override
+        public void headers(boolean outFinished, boolean inFinished, int streamId,
+                            int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {
+            if (pushedStream(streamId)) {
+                pushHeadersLater(streamId, headerBlock, inFinished);
+                return;
+            }
+            FramedStream stream;
             synchronized (FramedConnection.this) {
-              currentPushRequests.remove(streamId);
+                // If we're shutdown, don't bother with this stream.
+                if (shutdown) return;
+
+                stream = getStream(streamId);
+
+                if (stream == null) {
+                    // The headers claim to be for an existing stream, but we don't have one.
+                    if (headersMode.failIfStreamAbsent()) {
+                        writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);
+                        return;
+                    }
+
+                    // If the stream ID is less than the last created ID, assume it's already closed.
+                    if (streamId <= lastGoodStreamId) return;
+
+                    // If the stream ID is in the client's namespace, assume it's already closed.
+                    if (streamId % 2 == nextStreamId % 2) return;
+
+                    // Create a stream.
+                    final FramedStream
+                            newStream = new FramedStream(streamId, FramedConnection.this, outFinished,
+                            inFinished, headerBlock);
+                    lastGoodStreamId = streamId;
+                    streams.put(streamId, newStream);
+                    executor.execute(new NamedRunnable("OkHttp %s stream %d", hostName, streamId) {
+                        @Override
+                        public void execute() {
+                            try {
+                                handler.receive(newStream);
+                            } catch (IOException e) {
+                                logger.log(Level.INFO, "StreamHandler failure for " + hostName, e);
+                                try {
+                                    newStream.close(ErrorCode.PROTOCOL_ERROR);
+                                } catch (IOException ignored) {
+                                }
+                            }
+                        }
+                    });
+                    return;
+                }
+            }
+
+            // The headers claim to be for a new stream, but we already have one.
+            if (headersMode.failIfStreamPresent()) {
+                stream.closeLater(ErrorCode.PROTOCOL_ERROR);
+                removeStream(streamId);
+                return;
             }
-          }
-        } catch (IOException ignored) {
+
+            // Update an existing stream.
+            stream.receiveHeaders(headerBlock, headersMode);
+            if (inFinished) stream.receiveFin();
         }
-      }
-    });
-  }
 
-  private void pushHeadersLater(final int streamId, final List<Header> requestHeaders,
-      final boolean inFinished) {
-    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Headers[%s]", hostName, streamId) {
-      @Override public void execute() {
-        boolean cancel = pushObserver.onHeaders(streamId, requestHeaders, inFinished);
-        try {
-          if (cancel) frameWriter.rstStream(streamId, ErrorCode.CANCEL);
-          if (cancel || inFinished) {
+        @Override
+        public void rstStream(int streamId, ErrorCode errorCode) {
+            if (pushedStream(streamId)) {
+                pushResetLater(streamId, errorCode);
+                return;
+            }
+            FramedStream rstStream = removeStream(streamId);
+            if (rstStream != null) {
+                rstStream.receiveRstStream(errorCode);
+            }
+        }
+
+        @Override
+        public void settings(boolean clearPrevious, Settings newSettings) {
+            long delta = 0;
+            FramedStream[] streamsToNotify = null;
             synchronized (FramedConnection.this) {
-              currentPushRequests.remove(streamId);
-            }
-          }
-        } catch (IOException ignored) {
-        }
-      }
-    });
-  }
-
-  /**
-   * Eagerly reads {@code byteCount} bytes from the source before launching a background task to
-   * process the data.  This avoids corrupting the stream.
-   */
-  private void pushDataLater(final int streamId, final BufferedSource source, final int byteCount,
-      final boolean inFinished) throws IOException {
-    final Buffer buffer = new Buffer();
-    source.require(byteCount); // Eagerly read the frame before firing client thread.
-    source.read(buffer, byteCount);
-    if (buffer.size() != byteCount) throw new IOException(buffer.size() + " != " + byteCount);
-    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Data[%s]", hostName, streamId) {
-      @Override public void execute() {
-        try {
-          boolean cancel = pushObserver.onData(streamId, buffer, byteCount, inFinished);
-          if (cancel) frameWriter.rstStream(streamId, ErrorCode.CANCEL);
-          if (cancel || inFinished) {
+                int priorWriteWindowSize = peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE);
+                if (clearPrevious) peerSettings.clear();
+                peerSettings.merge(newSettings);
+                if (getProtocol() == Protocol.HTTP_2) {
+                    ackSettingsLater(newSettings);
+                }
+                int peerInitialWindowSize = peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE);
+                if (peerInitialWindowSize != -1 && peerInitialWindowSize != priorWriteWindowSize) {
+                    delta = peerInitialWindowSize - priorWriteWindowSize;
+                    if (!receivedInitialPeerSettings) {
+                        addBytesToWriteWindow(delta);
+                        receivedInitialPeerSettings = true;
+                    }
+                    if (!streams.isEmpty()) {
+                        streamsToNotify = streams.values().toArray(new FramedStream[streams.size()]);
+                    }
+                }
+            }
+            if (streamsToNotify != null && delta != 0) {
+                for (FramedStream stream : streamsToNotify) {
+                    synchronized (stream) {
+                        stream.addBytesToWriteWindow(delta);
+                    }
+                }
+            }
+        }
+
+        private void ackSettingsLater(final Settings peerSettings) {
+            executor.execute(new NamedRunnable("OkHttp %s ACK Settings", hostName) {
+                @Override
+                public void execute() {
+                    try {
+                        frameWriter.ackSettings(peerSettings);
+                    } catch (IOException ignored) {
+                    }
+                }
+            });
+        }
+
+        @Override
+        public void ackSettings() {
+            // TODO: If we don't get this callback after sending settings to the peer, SETTINGS_TIMEOUT.
+        }
+
+        @Override
+        public void ping(boolean reply, int payload1, int payload2) {
+            if (reply) {
+                Ping ping = removePing(payload1);
+                if (ping != null) {
+                    ping.receive();
+                }
+            } else {
+                // Send a reply to a client ping if this is a server and vice versa.
+                writePingLater(true, payload1, payload2, null);
+            }
+        }
+
+        @Override
+        public void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
+            if (debugData.size() > 0) { // TODO: log the debugData
+            }
+
+            // Copy the streams first. We don't want to hold a lock when we call receiveRstStream().
+            FramedStream[] streamsCopy;
             synchronized (FramedConnection.this) {
-              currentPushRequests.remove(streamId);
+                streamsCopy = streams.values().toArray(new FramedStream[streams.size()]);
+                shutdown = true;
+            }
+
+            // Fail all streams created after the last good stream ID.
+            for (FramedStream framedStream : streamsCopy) {
+                if (framedStream.getId() > lastGoodStreamId && framedStream.isLocallyInitiated()) {
+                    framedStream.receiveRstStream(ErrorCode.REFUSED_STREAM);
+                    removeStream(framedStream.getId());
+                }
+            }
+        }
+
+        @Override
+        public void windowUpdate(int streamId, long windowSizeIncrement) {
+            if (streamId == 0) {
+                synchronized (FramedConnection.this) {
+                    bytesLeftInWriteWindow += windowSizeIncrement;
+                    FramedConnection.this.notifyAll();
+                }
+            } else {
+                FramedStream stream = getStream(streamId);
+                if (stream != null) {
+                    synchronized (stream) {
+                        stream.addBytesToWriteWindow(windowSizeIncrement);
+                    }
+                }
             }
-          }
-        } catch (IOException ignored) {
         }
-      }
-    });
-  }
 
-  private void pushResetLater(final int streamId, final ErrorCode errorCode) {
-    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Reset[%s]", hostName, streamId) {
-      @Override public void execute() {
-        pushObserver.onReset(streamId, errorCode);
-        synchronized (FramedConnection.this) {
-          currentPushRequests.remove(streamId);
+        @Override
+        public void priority(int streamId, int streamDependency, int weight,
+                             boolean exclusive) {
+            // TODO: honor priority.
         }
-      }
-    });
-  }
+
+        @Override
+        public void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders) {
+            pushRequestLater(promisedStreamId, requestHeaders);
+        }
+
+        @Override
+        public void alternateService(int streamId, String origin, ByteString protocol,
+                                     String host, int port, long maxAge) {
+            // TODO: register alternate service.
+        }
+    }
+
+    /**
+     * Even, positive numbered streams are pushed streams in HTTP/2.
+     */
+    private boolean pushedStream(int streamId) {
+        return protocol == Protocol.HTTP_2 && streamId != 0 && (streamId & 1) == 0;
+    }
+
+    // Guarded by this.
+    private final Set<Integer> currentPushRequests = new LinkedHashSet<>();
+
+    private void pushRequestLater(final int streamId, final List<Header> requestHeaders) {
+        synchronized (this) {
+            if (currentPushRequests.contains(streamId)) {
+                writeSynResetLater(streamId, ErrorCode.PROTOCOL_ERROR);
+                return;
+            }
+            currentPushRequests.add(streamId);
+        }
+        pushExecutor.execute(new NamedRunnable("OkHttp %s Push Request[%s]", hostName, streamId) {
+            @Override
+            public void execute() {
+                boolean cancel = pushObserver.onRequest(streamId, requestHeaders);
+                try {
+                    if (cancel) {
+                        frameWriter.rstStream(streamId, ErrorCode.CANCEL);
+                        synchronized (FramedConnection.this) {
+                            currentPushRequests.remove(streamId);
+                        }
+                    }
+                } catch (IOException ignored) {
+                }
+            }
+        });
+    }
+
+    private void pushHeadersLater(final int streamId, final List<Header> requestHeaders,
+                                  final boolean inFinished) {
+        pushExecutor.execute(new NamedRunnable("OkHttp %s Push Headers[%s]", hostName, streamId) {
+            @Override
+            public void execute() {
+                boolean cancel = pushObserver.onHeaders(streamId, requestHeaders, inFinished);
+                try {
+                    if (cancel) frameWriter.rstStream(streamId, ErrorCode.CANCEL);
+                    if (cancel || inFinished) {
+                        synchronized (FramedConnection.this) {
+                            currentPushRequests.remove(streamId);
+                        }
+                    }
+                } catch (IOException ignored) {
+                }
+            }
+        });
+    }
+
+    /**
+     * Eagerly reads {@code byteCount} bytes from the source before launching a background task to
+     * process the data.  This avoids corrupting the stream.
+     */
+    private void pushDataLater(final int streamId, final BufferedSource source, final int byteCount,
+                               final boolean inFinished) throws IOException {
+        final Buffer buffer = new Buffer();
+        source.require(byteCount); // Eagerly read the frame before firing client thread.
+        source.read(buffer, byteCount);
+        if (buffer.size() != byteCount) throw new IOException(buffer.size() + " != " + byteCount);
+        pushExecutor.execute(new NamedRunnable("OkHttp %s Push Data[%s]", hostName, streamId) {
+            @Override
+            public void execute() {
+                try {
+                    boolean cancel = pushObserver.onData(streamId, buffer, byteCount, inFinished);
+                    if (cancel) frameWriter.rstStream(streamId, ErrorCode.CANCEL);
+                    if (cancel || inFinished) {
+                        synchronized (FramedConnection.this) {
+                            currentPushRequests.remove(streamId);
+                        }
+                    }
+                } catch (IOException ignored) {
+                }
+            }
+        });
+    }
+
+    private void pushResetLater(final int streamId, final ErrorCode errorCode) {
+        pushExecutor.execute(new NamedRunnable("OkHttp %s Push Reset[%s]", hostName, streamId) {
+            @Override
+            public void execute() {
+                pushObserver.onReset(streamId, errorCode);
+                synchronized (FramedConnection.this) {
+                    currentPushRequests.remove(streamId);
+                }
+            }
+        });
+    }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/FramedStream.java b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/FramedStream.java
index a47b12e627..942842663b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/FramedStream.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/FramedStream.java
@@ -22,6 +22,7 @@
 import java.net.SocketTimeoutException;
 import java.util.ArrayList;
 import java.util.List;
+
 import okio.AsyncTimeout;
 import okio.Buffer;
 import okio.BufferedSource;
@@ -31,586 +32,617 @@
 
 import static com.squareup.okhttp.internal.framed.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
 
-/** A logical bidirectional stream. */
+/**
+ * A logical bidirectional stream.
+ */
 public final class FramedStream {
-  // Internal state is guarded by this. No long-running or potentially
-  // blocking operations are performed while the lock is held.
-
-  /**
-   * The total number of bytes consumed by the application (with {@link
-   * FramedDataSource#read}), but not yet acknowledged by sending a {@code
-   * WINDOW_UPDATE} frame on this stream.
-   */
-  // Visible for testing
-  long unacknowledgedBytesRead = 0;
-
-  /**
-   * Count of bytes that can be written on the stream before receiving a
-   * window update. Even if this is positive, writes will block until there
-   * available bytes in {@code connection.bytesLeftInWriteWindow}.
-   */
-  // guarded by this
-  long bytesLeftInWriteWindow;
-
-  private final int id;
-  private final FramedConnection connection;
-
-  /** Headers sent by the stream initiator. Immutable and non null. */
-  private final List<Header> requestHeaders;
-
-  /** Headers sent in the stream reply. Null if reply is either not sent or not sent yet. */
-  private List<Header> responseHeaders;
-
-  private final FramedDataSource source;
-  final FramedDataSink sink;
-  private final StreamTimeout readTimeout = new StreamTimeout();
-  private final StreamTimeout writeTimeout = new StreamTimeout();
-
-  /**
-   * The reason why this stream was abnormally closed. If there are multiple
-   * reasons to abnormally close this stream (such as both peers closing it
-   * near-simultaneously) then this is the first reason known to this peer.
-   */
-  private ErrorCode errorCode = null;
-
-  FramedStream(int id, FramedConnection connection, boolean outFinished, boolean inFinished,
-      List<Header> requestHeaders) {
-    if (connection == null) throw new NullPointerException("connection == null");
-    if (requestHeaders == null) throw new NullPointerException("requestHeaders == null");
-    this.id = id;
-    this.connection = connection;
-    this.bytesLeftInWriteWindow =
-        connection.peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE);
-    this.source = new FramedDataSource(
-        connection.okHttpSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE));
-    this.sink = new FramedDataSink();
-    this.source.finished = inFinished;
-    this.sink.finished = outFinished;
-    this.requestHeaders = requestHeaders;
-  }
-
-  public int getId() {
-    return id;
-  }
-
-  /**
-   * Returns true if this stream is open. A stream is open until either:
-   * <ul>
-   * <li>A {@code SYN_RESET} frame abnormally terminates the stream.
-   * <li>Both input and output streams have transmitted all data and
-   * headers.
-   * </ul>
-   * Note that the input stream may continue to yield data even after a stream
-   * reports itself as not open. This is because input data is buffered.
-   */
-  public synchronized boolean isOpen() {
-    if (errorCode != null) {
-      return false;
-    }
-    if ((source.finished || source.closed)
-        && (sink.finished || sink.closed)
-        && responseHeaders != null) {
-      return false;
-    }
-    return true;
-  }
-
-  /** Returns true if this stream was created by this peer. */
-  public boolean isLocallyInitiated() {
-    boolean streamIsClient = ((id & 1) == 1);
-    return connection.client == streamIsClient;
-  }
-
-  public FramedConnection getConnection() {
-    return connection;
-  }
-
-  public List<Header> getRequestHeaders() {
-    return requestHeaders;
-  }
-
-  /**
-   * Returns the stream's response headers, blocking if necessary if they
-   * have not been received yet.
-   */
-  public synchronized List<Header> getResponseHeaders() throws IOException {
-    readTimeout.enter();
-    try {
-      while (responseHeaders == null && errorCode == null) {
-        waitForIo();
-      }
-    } finally {
-      readTimeout.exitAndThrowIfTimedOut();
-    }
-    if (responseHeaders != null) return responseHeaders;
-    throw new IOException("stream was reset: " + errorCode);
-  }
-
-  /**
-   * Returns the reason why this stream was closed, or null if it closed
-   * normally or has not yet been closed.
-   */
-  public synchronized ErrorCode getErrorCode() {
-    return errorCode;
-  }
-
-  /**
-   * Sends a reply to an incoming stream.
-   *
-   * @param out true to create an output stream that we can use to send data
-   * to the remote peer. Corresponds to {@code FLAG_FIN}.
-   */
-  public void reply(List<Header> responseHeaders, boolean out) throws IOException {
-    assert (!Thread.holdsLock(FramedStream.this));
-    boolean outFinished = false;
-    synchronized (this) {
-      if (responseHeaders == null) {
-        throw new NullPointerException("responseHeaders == null");
-      }
-      if (this.responseHeaders != null) {
-        throw new IllegalStateException("reply already sent");
-      }
-      this.responseHeaders = responseHeaders;
-      if (!out) {
-        this.sink.finished = true;
-        outFinished = true;
-      }
-    }
-    connection.writeSynReply(id, outFinished, responseHeaders);
+    // Internal state is guarded by this. No long-running or potentially
+    // blocking operations are performed while the lock is held.
 
-    if (outFinished) {
-      connection.flush();
-    }
-  }
-
-  public Timeout readTimeout() {
-    return readTimeout;
-  }
-
-  public Timeout writeTimeout() {
-    return writeTimeout;
-  }
-
-  /** Returns a source that reads data from the peer. */
-  public Source getSource() {
-    return source;
-  }
-
-  /**
-   * Returns a sink that can be used to write data to the peer.
-   *
-   * @throws IllegalStateException if this stream was initiated by the peer
-   *     and a {@link #reply} has not yet been sent.
-   */
-  public Sink getSink() {
-    synchronized (this) {
-      if (responseHeaders == null && !isLocallyInitiated()) {
-        throw new IllegalStateException("reply before requesting the sink");
-      }
-    }
-    return sink;
-  }
-
-  /**
-   * Abnormally terminate this stream. This blocks until the {@code RST_STREAM}
-   * frame has been transmitted.
-   */
-  public void close(ErrorCode rstStatusCode) throws IOException {
-    if (!closeInternal(rstStatusCode)) {
-      return; // Already closed.
+    /**
+     * The total number of bytes consumed by the application (with {@link
+     * FramedDataSource#read}), but not yet acknowledged by sending a {@code
+     * WINDOW_UPDATE} frame on this stream.
+     */
+    // Visible for testing
+    long unacknowledgedBytesRead = 0;
+
+    /**
+     * Count of bytes that can be written on the stream before receiving a
+     * window update. Even if this is positive, writes will block until there
+     * available bytes in {@code connection.bytesLeftInWriteWindow}.
+     */
+    // guarded by this
+    long bytesLeftInWriteWindow;
+
+    private final int id;
+    private final FramedConnection connection;
+
+    /**
+     * Headers sent by the stream initiator. Immutable and non null.
+     */
+    private final List<Header> requestHeaders;
+
+    /**
+     * Headers sent in the stream reply. Null if reply is either not sent or not sent yet.
+     */
+    private List<Header> responseHeaders;
+
+    private final FramedDataSource source;
+    final FramedDataSink sink;
+    private final StreamTimeout readTimeout = new StreamTimeout();
+    private final StreamTimeout writeTimeout = new StreamTimeout();
+
+    /**
+     * The reason why this stream was abnormally closed. If there are multiple
+     * reasons to abnormally close this stream (such as both peers closing it
+     * near-simultaneously) then this is the first reason known to this peer.
+     */
+    private ErrorCode errorCode = null;
+
+    FramedStream(int id, FramedConnection connection, boolean outFinished, boolean inFinished,
+                 List<Header> requestHeaders) {
+        if (connection == null) throw new NullPointerException("connection == null");
+        if (requestHeaders == null) throw new NullPointerException("requestHeaders == null");
+        this.id = id;
+        this.connection = connection;
+        this.bytesLeftInWriteWindow =
+                connection.peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE);
+        this.source = new FramedDataSource(
+                connection.okHttpSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE));
+        this.sink = new FramedDataSink();
+        this.source.finished = inFinished;
+        this.sink.finished = outFinished;
+        this.requestHeaders = requestHeaders;
     }
-    connection.writeSynReset(id, rstStatusCode);
-  }
-
-  /**
-   * Abnormally terminate this stream. This enqueues a {@code RST_STREAM}
-   * frame and returns immediately.
-   */
-  public void closeLater(ErrorCode errorCode) {
-    if (!closeInternal(errorCode)) {
-      return; // Already closed.
+
+    public int getId() {
+        return id;
     }
-    connection.writeSynResetLater(id, errorCode);
-  }
-
-  /** Returns true if this stream was closed. */
-  private boolean closeInternal(ErrorCode errorCode) {
-    assert (!Thread.holdsLock(this));
-    synchronized (this) {
-      if (this.errorCode != null) {
-        return false;
-      }
-      if (source.finished && sink.finished) {
-        return false;
-      }
-      this.errorCode = errorCode;
-      notifyAll();
+
+    /**
+     * Returns true if this stream is open. A stream is open until either:
+     * <ul>
+     * <li>A {@code SYN_RESET} frame abnormally terminates the stream.
+     * <li>Both input and output streams have transmitted all data and
+     * headers.
+     * </ul>
+     * Note that the input stream may continue to yield data even after a stream
+     * reports itself as not open. This is because input data is buffered.
+     */
+    public synchronized boolean isOpen() {
+        if (errorCode != null) {
+            return false;
+        }
+        if ((source.finished || source.closed)
+                && (sink.finished || sink.closed)
+                && responseHeaders != null) {
+            return false;
+        }
+        return true;
     }
-    connection.removeStream(id);
-    return true;
-  }
-
-  void receiveHeaders(List<Header> headers, HeadersMode headersMode) {
-    assert (!Thread.holdsLock(FramedStream.this));
-    ErrorCode errorCode = null;
-    boolean open = true;
-    synchronized (this) {
-      if (responseHeaders == null) {
-        if (headersMode.failIfHeadersAbsent()) {
-          errorCode = ErrorCode.PROTOCOL_ERROR;
-        } else {
-          responseHeaders = headers;
-          open = isOpen();
-          notifyAll();
-        }
-      } else {
-        if (headersMode.failIfHeadersPresent()) {
-          errorCode = ErrorCode.STREAM_IN_USE;
-        } else {
-          List<Header> newHeaders = new ArrayList<>();
-          newHeaders.addAll(responseHeaders);
-          newHeaders.addAll(headers);
-          this.responseHeaders = newHeaders;
-        }
-      }
+
+    /**
+     * Returns true if this stream was created by this peer.
+     */
+    public boolean isLocallyInitiated() {
+        boolean streamIsClient = ((id & 1) == 1);
+        return connection.client == streamIsClient;
     }
-    if (errorCode != null) {
-      closeLater(errorCode);
-    } else if (!open) {
-      connection.removeStream(id);
+
+    public FramedConnection getConnection() {
+        return connection;
     }
-  }
-
-  void receiveData(BufferedSource in, int length) throws IOException {
-    assert (!Thread.holdsLock(FramedStream.this));
-    this.source.receive(in, length);
-  }
-
-  void receiveFin() {
-    assert (!Thread.holdsLock(FramedStream.this));
-    boolean open;
-    synchronized (this) {
-      this.source.finished = true;
-      open = isOpen();
-      notifyAll();
+
+    public List<Header> getRequestHeaders() {
+        return requestHeaders;
     }
-    if (!open) {
-      connection.removeStream(id);
+
+    /**
+     * Returns the stream's response headers, blocking if necessary if they
+     * have not been received yet.
+     */
+    public synchronized List<Header> getResponseHeaders() throws IOException {
+        readTimeout.enter();
+        try {
+            while (responseHeaders == null && errorCode == null) {
+                waitForIo();
+            }
+        } finally {
+            readTimeout.exitAndThrowIfTimedOut();
+        }
+        if (responseHeaders != null) return responseHeaders;
+        throw new IOException("stream was reset: " + errorCode);
     }
-  }
 
-  synchronized void receiveRstStream(ErrorCode errorCode) {
-    if (this.errorCode == null) {
-      this.errorCode = errorCode;
-      notifyAll();
+    /**
+     * Returns the reason why this stream was closed, or null if it closed
+     * normally or has not yet been closed.
+     */
+    public synchronized ErrorCode getErrorCode() {
+        return errorCode;
     }
-  }
 
-  /**
-   * A source that reads the incoming data frames of a stream. Although this
-   * class uses synchronization to safely receive incoming data frames, it is
-   * not intended for use by multiple readers.
-   */
-  private final class FramedDataSource implements Source {
-    /** Buffer to receive data from the network into. Only accessed by the reader thread. */
-    private final Buffer receiveBuffer = new Buffer();
+    /**
+     * Sends a reply to an incoming stream.
+     *
+     * @param out true to create an output stream that we can use to send data
+     *            to the remote peer. Corresponds to {@code FLAG_FIN}.
+     */
+    public void reply(List<Header> responseHeaders, boolean out) throws IOException {
+        assert (!Thread.holdsLock(FramedStream.this));
+        boolean outFinished = false;
+        synchronized (this) {
+            if (responseHeaders == null) {
+                throw new NullPointerException("responseHeaders == null");
+            }
+            if (this.responseHeaders != null) {
+                throw new IllegalStateException("reply already sent");
+            }
+            this.responseHeaders = responseHeaders;
+            if (!out) {
+                this.sink.finished = true;
+                outFinished = true;
+            }
+        }
+        connection.writeSynReply(id, outFinished, responseHeaders);
 
-    /** Buffer with readable data. Guarded by FramedStream.this. */
-    private final Buffer readBuffer = new Buffer();
+        if (outFinished) {
+            connection.flush();
+        }
+    }
 
-    /** Maximum number of bytes to buffer before reporting a flow control error. */
-    private final long maxByteCount;
+    public Timeout readTimeout() {
+        return readTimeout;
+    }
 
-    /** True if the caller has closed this stream. */
-    private boolean closed;
+    public Timeout writeTimeout() {
+        return writeTimeout;
+    }
 
     /**
-     * True if either side has cleanly shut down this stream. We will
-     * receive no more bytes beyond those already in the buffer.
+     * Returns a source that reads data from the peer.
      */
-    private boolean finished;
-
-    private FramedDataSource(long maxByteCount) {
-      this.maxByteCount = maxByteCount;
+    public Source getSource() {
+        return source;
     }
 
-    @Override public long read(Buffer sink, long byteCount)
-        throws IOException {
-      if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
-
-      long read;
-      synchronized (FramedStream.this) {
-        waitUntilReadable();
-        checkNotClosed();
-        if (readBuffer.size() == 0) return -1; // This source is exhausted.
+    /**
+     * Returns a sink that can be used to write data to the peer.
+     *
+     * @throws IllegalStateException if this stream was initiated by the peer
+     *                               and a {@link #reply} has not yet been sent.
+     */
+    public Sink getSink() {
+        synchronized (this) {
+            if (responseHeaders == null && !isLocallyInitiated()) {
+                throw new IllegalStateException("reply before requesting the sink");
+            }
+        }
+        return sink;
+    }
 
-        // Move bytes from the read buffer into the caller's buffer.
-        read = readBuffer.read(sink, Math.min(byteCount, readBuffer.size()));
+    /**
+     * Abnormally terminate this stream. This blocks until the {@code RST_STREAM}
+     * frame has been transmitted.
+     */
+    public void close(ErrorCode rstStatusCode) throws IOException {
+        if (!closeInternal(rstStatusCode)) {
+            return; // Already closed.
+        }
+        connection.writeSynReset(id, rstStatusCode);
+    }
 
-        // Flow control: notify the peer that we're ready for more data!
-        unacknowledgedBytesRead += read;
-        if (unacknowledgedBytesRead
-            >= connection.okHttpSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE) / 2) {
-          connection.writeWindowUpdateLater(id, unacknowledgedBytesRead);
-          unacknowledgedBytesRead = 0;
+    /**
+     * Abnormally terminate this stream. This enqueues a {@code RST_STREAM}
+     * frame and returns immediately.
+     */
+    public void closeLater(ErrorCode errorCode) {
+        if (!closeInternal(errorCode)) {
+            return; // Already closed.
         }
-      }
+        connection.writeSynResetLater(id, errorCode);
+    }
 
-      // Update connection.unacknowledgedBytesRead outside the stream lock.
-      synchronized (connection) { // Multiple application threads may hit this section.
-        connection.unacknowledgedBytesRead += read;
-        if (connection.unacknowledgedBytesRead
-            >= connection.okHttpSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE) / 2) {
-          connection.writeWindowUpdateLater(0, connection.unacknowledgedBytesRead);
-          connection.unacknowledgedBytesRead = 0;
+    /**
+     * Returns true if this stream was closed.
+     */
+    private boolean closeInternal(ErrorCode errorCode) {
+        assert (!Thread.holdsLock(this));
+        synchronized (this) {
+            if (this.errorCode != null) {
+                return false;
+            }
+            if (source.finished && sink.finished) {
+                return false;
+            }
+            this.errorCode = errorCode;
+            notifyAll();
+        }
+        connection.removeStream(id);
+        return true;
+    }
+
+    void receiveHeaders(List<Header> headers, HeadersMode headersMode) {
+        assert (!Thread.holdsLock(FramedStream.this));
+        ErrorCode errorCode = null;
+        boolean open = true;
+        synchronized (this) {
+            if (responseHeaders == null) {
+                if (headersMode.failIfHeadersAbsent()) {
+                    errorCode = ErrorCode.PROTOCOL_ERROR;
+                } else {
+                    responseHeaders = headers;
+                    open = isOpen();
+                    notifyAll();
+                }
+            } else {
+                if (headersMode.failIfHeadersPresent()) {
+                    errorCode = ErrorCode.STREAM_IN_USE;
+                } else {
+                    List<Header> newHeaders = new ArrayList<>();
+                    newHeaders.addAll(responseHeaders);
+                    newHeaders.addAll(headers);
+                    this.responseHeaders = newHeaders;
+                }
+            }
         }
-      }
+        if (errorCode != null) {
+            closeLater(errorCode);
+        } else if (!open) {
+            connection.removeStream(id);
+        }
+    }
 
-      return read;
+    void receiveData(BufferedSource in, int length) throws IOException {
+        assert (!Thread.holdsLock(FramedStream.this));
+        this.source.receive(in, length);
     }
 
-    /** Returns once the source is either readable or finished. */
-    private void waitUntilReadable() throws IOException {
-      readTimeout.enter();
-      try {
-        while (readBuffer.size() == 0 && !finished && !closed && errorCode == null) {
-          waitForIo();
+    void receiveFin() {
+        assert (!Thread.holdsLock(FramedStream.this));
+        boolean open;
+        synchronized (this) {
+            this.source.finished = true;
+            open = isOpen();
+            notifyAll();
+        }
+        if (!open) {
+            connection.removeStream(id);
         }
-      } finally {
-        readTimeout.exitAndThrowIfTimedOut();
-      }
     }
 
-    void receive(BufferedSource in, long byteCount) throws IOException {
-      assert (!Thread.holdsLock(FramedStream.this));
+    synchronized void receiveRstStream(ErrorCode errorCode) {
+        if (this.errorCode == null) {
+            this.errorCode = errorCode;
+            notifyAll();
+        }
+    }
 
-      while (byteCount > 0) {
-        boolean finished;
-        boolean flowControlError;
-        synchronized (FramedStream.this) {
-          finished = this.finished;
-          flowControlError = byteCount + readBuffer.size() > maxByteCount;
+    /**
+     * A source that reads the incoming data frames of a stream. Although this
+     * class uses synchronization to safely receive incoming data frames, it is
+     * not intended for use by multiple readers.
+     */
+    private final class FramedDataSource implements Source {
+        /**
+         * Buffer to receive data from the network into. Only accessed by the reader thread.
+         */
+        private final Buffer receiveBuffer = new Buffer();
+
+        /**
+         * Buffer with readable data. Guarded by FramedStream.this.
+         */
+        private final Buffer readBuffer = new Buffer();
+
+        /**
+         * Maximum number of bytes to buffer before reporting a flow control error.
+         */
+        private final long maxByteCount;
+
+        /**
+         * True if the caller has closed this stream.
+         */
+        private boolean closed;
+
+        /**
+         * True if either side has cleanly shut down this stream. We will
+         * receive no more bytes beyond those already in the buffer.
+         */
+        private boolean finished;
+
+        private FramedDataSource(long maxByteCount) {
+            this.maxByteCount = maxByteCount;
         }
 
-        // If the peer sends more data than we can handle, discard it and close the connection.
-        if (flowControlError) {
-          in.skip(byteCount);
-          closeLater(ErrorCode.FLOW_CONTROL_ERROR);
-          return;
+        @Override
+        public long read(Buffer sink, long byteCount)
+                throws IOException {
+            if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
+
+            long read;
+            synchronized (FramedStream.this) {
+                waitUntilReadable();
+                checkNotClosed();
+                if (readBuffer.size() == 0) return -1; // This source is exhausted.
+
+                // Move bytes from the read buffer into the caller's buffer.
+                read = readBuffer.read(sink, Math.min(byteCount, readBuffer.size()));
+
+                // Flow control: notify the peer that we're ready for more data!
+                unacknowledgedBytesRead += read;
+                if (unacknowledgedBytesRead
+                        >= connection.okHttpSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE) / 2) {
+                    connection.writeWindowUpdateLater(id, unacknowledgedBytesRead);
+                    unacknowledgedBytesRead = 0;
+                }
+            }
+
+            // Update connection.unacknowledgedBytesRead outside the stream lock.
+            synchronized (connection) { // Multiple application threads may hit this section.
+                connection.unacknowledgedBytesRead += read;
+                if (connection.unacknowledgedBytesRead
+                        >= connection.okHttpSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE) / 2) {
+                    connection.writeWindowUpdateLater(0, connection.unacknowledgedBytesRead);
+                    connection.unacknowledgedBytesRead = 0;
+                }
+            }
+
+            return read;
         }
 
-        // Discard data received after the stream is finished. It's probably a benign race.
-        if (finished) {
-          in.skip(byteCount);
-          return;
+        /**
+         * Returns once the source is either readable or finished.
+         */
+        private void waitUntilReadable() throws IOException {
+            readTimeout.enter();
+            try {
+                while (readBuffer.size() == 0 && !finished && !closed && errorCode == null) {
+                    waitForIo();
+                }
+            } finally {
+                readTimeout.exitAndThrowIfTimedOut();
+            }
         }
 
-        // Fill the receive buffer without holding any locks.
-        long read = in.read(receiveBuffer, byteCount);
-        if (read == -1) throw new EOFException();
-        byteCount -= read;
+        void receive(BufferedSource in, long byteCount) throws IOException {
+            assert (!Thread.holdsLock(FramedStream.this));
+
+            while (byteCount > 0) {
+                boolean finished;
+                boolean flowControlError;
+                synchronized (FramedStream.this) {
+                    finished = this.finished;
+                    flowControlError = byteCount + readBuffer.size() > maxByteCount;
+                }
+
+                // If the peer sends more data than we can handle, discard it and close the connection.
+                if (flowControlError) {
+                    in.skip(byteCount);
+                    closeLater(ErrorCode.FLOW_CONTROL_ERROR);
+                    return;
+                }
+
+                // Discard data received after the stream is finished. It's probably a benign race.
+                if (finished) {
+                    in.skip(byteCount);
+                    return;
+                }
+
+                // Fill the receive buffer without holding any locks.
+                long read = in.read(receiveBuffer, byteCount);
+                if (read == -1) throw new EOFException();
+                byteCount -= read;
+
+                // Move the received data to the read buffer to the reader can read it.
+                synchronized (FramedStream.this) {
+                    boolean wasEmpty = readBuffer.size() == 0;
+                    readBuffer.writeAll(receiveBuffer);
+                    if (wasEmpty) {
+                        FramedStream.this.notifyAll();
+                    }
+                }
+            }
+        }
 
-        // Move the received data to the read buffer to the reader can read it.
-        synchronized (FramedStream.this) {
-          boolean wasEmpty = readBuffer.size() == 0;
-          readBuffer.writeAll(receiveBuffer);
-          if (wasEmpty) {
-            FramedStream.this.notifyAll();
-          }
+        @Override
+        public Timeout timeout() {
+            return readTimeout;
         }
-      }
-    }
 
-    @Override public Timeout timeout() {
-      return readTimeout;
-    }
+        @Override
+        public void close() throws IOException {
+            synchronized (FramedStream.this) {
+                closed = true;
+                readBuffer.clear();
+                FramedStream.this.notifyAll();
+            }
+            cancelStreamIfNecessary();
+        }
 
-    @Override public void close() throws IOException {
-      synchronized (FramedStream.this) {
-        closed = true;
-        readBuffer.clear();
-        FramedStream.this.notifyAll();
-      }
-      cancelStreamIfNecessary();
+        private void checkNotClosed() throws IOException {
+            if (closed) {
+                throw new IOException("stream closed");
+            }
+            if (errorCode != null) {
+                throw new IOException("stream was reset: " + errorCode);
+            }
+        }
     }
 
-    private void checkNotClosed() throws IOException {
-      if (closed) {
-        throw new IOException("stream closed");
-      }
-      if (errorCode != null) {
-        throw new IOException("stream was reset: " + errorCode);
-      }
-    }
-  }
-
-  private void cancelStreamIfNecessary() throws IOException {
-    assert (!Thread.holdsLock(FramedStream.this));
-    boolean open;
-    boolean cancel;
-    synchronized (this) {
-      cancel = !source.finished && source.closed && (sink.finished || sink.closed);
-      open = isOpen();
-    }
-    if (cancel) {
-      // RST this stream to prevent additional data from being sent. This
-      // is safe because the input stream is closed (we won't use any
-      // further bytes) and the output stream is either finished or closed
-      // (so RSTing both streams doesn't cause harm).
-      FramedStream.this.close(ErrorCode.CANCEL);
-    } else if (!open) {
-      connection.removeStream(id);
+    private void cancelStreamIfNecessary() throws IOException {
+        assert (!Thread.holdsLock(FramedStream.this));
+        boolean open;
+        boolean cancel;
+        synchronized (this) {
+            cancel = !source.finished && source.closed && (sink.finished || sink.closed);
+            open = isOpen();
+        }
+        if (cancel) {
+            // RST this stream to prevent additional data from being sent. This
+            // is safe because the input stream is closed (we won't use any
+            // further bytes) and the output stream is either finished or closed
+            // (so RSTing both streams doesn't cause harm).
+            FramedStream.this.close(ErrorCode.CANCEL);
+        } else if (!open) {
+            connection.removeStream(id);
+        }
     }
-  }
-
-  /**
-   * A sink that writes outgoing data frames of a stream. This class is not
-   * thread safe.
-   */
-  final class FramedDataSink implements Sink {
-    private static final long EMIT_BUFFER_SIZE = 16384;
 
     /**
-     * Buffer of outgoing data. This batches writes of small writes into this sink as larges
-     * frames written to the outgoing connection. Batching saves the (small) framing overhead.
+     * A sink that writes outgoing data frames of a stream. This class is not
+     * thread safe.
      */
-    private final Buffer sendBuffer = new Buffer();
+    final class FramedDataSink implements Sink {
+        private static final long EMIT_BUFFER_SIZE = 16384;
+
+        /**
+         * Buffer of outgoing data. This batches writes of small writes into this sink as larges
+         * frames written to the outgoing connection. Batching saves the (small) framing overhead.
+         */
+        private final Buffer sendBuffer = new Buffer();
+
+        private boolean closed;
+
+        /**
+         * True if either side has cleanly shut down this stream. We shall send
+         * no more bytes.
+         */
+        private boolean finished;
+
+        @Override
+        public void write(Buffer source, long byteCount) throws IOException {
+            assert (!Thread.holdsLock(FramedStream.this));
+            sendBuffer.write(source, byteCount);
+            while (sendBuffer.size() >= EMIT_BUFFER_SIZE) {
+                emitDataFrame(false);
+            }
+        }
+
+        /**
+         * Emit a single data frame to the connection. The frame's size be limited by this stream's
+         * write window. This method will block until the write window is nonempty.
+         */
+        private void emitDataFrame(boolean outFinished) throws IOException {
+            long toWrite;
+            synchronized (FramedStream.this) {
+                writeTimeout.enter();
+                try {
+                    while (bytesLeftInWriteWindow <= 0 && !finished && !closed && errorCode == null) {
+                        waitForIo(); // Wait until we receive a WINDOW_UPDATE for this stream.
+                    }
+                } finally {
+                    writeTimeout.exitAndThrowIfTimedOut();
+                }
+
+                checkOutNotClosed(); // Kick out if the stream was reset or closed while waiting.
+                toWrite = Math.min(bytesLeftInWriteWindow, sendBuffer.size());
+                bytesLeftInWriteWindow -= toWrite;
+            }
+
+            writeTimeout.enter();
+            try {
+                connection.writeData(id, outFinished && toWrite == sendBuffer.size(), sendBuffer, toWrite);
+            } finally {
+                writeTimeout.exitAndThrowIfTimedOut();
+            }
+        }
+
+        @Override
+        public void flush() throws IOException {
+            assert (!Thread.holdsLock(FramedStream.this));
+            synchronized (FramedStream.this) {
+                checkOutNotClosed();
+            }
+            while (sendBuffer.size() > 0) {
+                emitDataFrame(false);
+                connection.flush();
+            }
+        }
+
+        @Override
+        public Timeout timeout() {
+            return writeTimeout;
+        }
 
-    private boolean closed;
+        @Override
+        public void close() throws IOException {
+            assert (!Thread.holdsLock(FramedStream.this));
+            synchronized (FramedStream.this) {
+                if (closed) return;
+            }
+            if (!sink.finished) {
+                // Emit the remaining data, setting the END_STREAM flag on the last frame.
+                if (sendBuffer.size() > 0) {
+                    while (sendBuffer.size() > 0) {
+                        emitDataFrame(true);
+                    }
+                } else {
+                    // Send an empty frame just so we can set the END_STREAM flag.
+                    connection.writeData(id, true, null, 0);
+                }
+            }
+            synchronized (FramedStream.this) {
+                closed = true;
+            }
+            connection.flush();
+            cancelStreamIfNecessary();
+        }
+    }
 
     /**
-     * True if either side has cleanly shut down this stream. We shall send
-     * no more bytes.
+     * {@code delta} will be negative if a settings frame initial window is
+     * smaller than the last.
      */
-    private boolean finished;
-
-    @Override public void write(Buffer source, long byteCount) throws IOException {
-      assert (!Thread.holdsLock(FramedStream.this));
-      sendBuffer.write(source, byteCount);
-      while (sendBuffer.size() >= EMIT_BUFFER_SIZE) {
-        emitDataFrame(false);
-      }
+    void addBytesToWriteWindow(long delta) {
+        bytesLeftInWriteWindow += delta;
+        if (delta > 0) FramedStream.this.notifyAll();
+    }
+
+    private void checkOutNotClosed() throws IOException {
+        if (sink.closed) {
+            throw new IOException("stream closed");
+        } else if (sink.finished) {
+            throw new IOException("stream finished");
+        } else if (errorCode != null) {
+            throw new IOException("stream was reset: " + errorCode);
+        }
     }
 
     /**
-     * Emit a single data frame to the connection. The frame's size be limited by this stream's
-     * write window. This method will block until the write window is nonempty.
+     * Like {@link #wait}, but throws an {@code InterruptedIOException} when
+     * interrupted instead of the more awkward {@link InterruptedException}.
      */
-    private void emitDataFrame(boolean outFinished) throws IOException {
-      long toWrite;
-      synchronized (FramedStream.this) {
-        writeTimeout.enter();
+    private void waitForIo() throws InterruptedIOException {
         try {
-          while (bytesLeftInWriteWindow <= 0 && !finished && !closed && errorCode == null) {
-            waitForIo(); // Wait until we receive a WINDOW_UPDATE for this stream.
-          }
-        } finally {
-          writeTimeout.exitAndThrowIfTimedOut();
+            wait();
+        } catch (InterruptedException e) {
+            throw new InterruptedIOException();
         }
-
-        checkOutNotClosed(); // Kick out if the stream was reset or closed while waiting.
-        toWrite = Math.min(bytesLeftInWriteWindow, sendBuffer.size());
-        bytesLeftInWriteWindow -= toWrite;
-      }
-
-      writeTimeout.enter();
-      try {
-        connection.writeData(id, outFinished && toWrite == sendBuffer.size(), sendBuffer, toWrite);
-      } finally {
-        writeTimeout.exitAndThrowIfTimedOut();
-      }
     }
 
-    @Override public void flush() throws IOException {
-      assert (!Thread.holdsLock(FramedStream.this));
-      synchronized (FramedStream.this) {
-        checkOutNotClosed();
-      }
-      while (sendBuffer.size() > 0) {
-        emitDataFrame(false);
-        connection.flush();
-      }
-    }
-
-    @Override public Timeout timeout() {
-      return writeTimeout;
-    }
-
-    @Override public void close() throws IOException {
-      assert (!Thread.holdsLock(FramedStream.this));
-      synchronized (FramedStream.this) {
-        if (closed) return;
-      }
-      if (!sink.finished) {
-        // Emit the remaining data, setting the END_STREAM flag on the last frame.
-        if (sendBuffer.size() > 0) {
-          while (sendBuffer.size() > 0) {
-            emitDataFrame(true);
-          }
-        } else {
-          // Send an empty frame just so we can set the END_STREAM flag.
-          connection.writeData(id, true, null, 0);
-        }
-      }
-      synchronized (FramedStream.this) {
-        closed = true;
-      }
-      connection.flush();
-      cancelStreamIfNecessary();
-    }
-  }
-
-  /**
-   * {@code delta} will be negative if a settings frame initial window is
-   * smaller than the last.
-   */
-  void addBytesToWriteWindow(long delta) {
-    bytesLeftInWriteWindow += delta;
-    if (delta > 0) FramedStream.this.notifyAll();
-  }
-
-  private void checkOutNotClosed() throws IOException {
-    if (sink.closed) {
-      throw new IOException("stream closed");
-    } else if (sink.finished) {
-      throw new IOException("stream finished");
-    } else if (errorCode != null) {
-      throw new IOException("stream was reset: " + errorCode);
-    }
-  }
-
-  /**
-   * Like {@link #wait}, but throws an {@code InterruptedIOException} when
-   * interrupted instead of the more awkward {@link InterruptedException}.
-   */
-  private void waitForIo() throws InterruptedIOException {
-    try {
-      wait();
-    } catch (InterruptedException e) {
-      throw new InterruptedIOException();
-    }
-  }
-
-  /**
-   * The Okio timeout watchdog will call {@link #timedOut} if the timeout is
-   * reached. In that case we close the stream (asynchronously) which will
-   * notify the waiting thread.
-   */
-  class StreamTimeout extends AsyncTimeout {
-    @Override protected void timedOut() {
-      closeLater(ErrorCode.CANCEL);
-    }
+    /**
+     * The Okio timeout watchdog will call {@link #timedOut} if the timeout is
+     * reached. In that case we close the stream (asynchronously) which will
+     * notify the waiting thread.
+     */
+    class StreamTimeout extends AsyncTimeout {
+        @Override
+        protected void timedOut() {
+            closeLater(ErrorCode.CANCEL);
+        }
 
-    @Override protected IOException newTimeoutException(IOException cause) {
-      SocketTimeoutException socketTimeoutException = new SocketTimeoutException("timeout");
-      if (cause != null) {
-        socketTimeoutException.initCause(cause);
-      }
-      return socketTimeoutException;
-    }
+        @Override
+        protected IOException newTimeoutException(IOException cause) {
+            SocketTimeoutException socketTimeoutException = new SocketTimeoutException("timeout");
+            if (cause != null) {
+                socketTimeoutException.initCause(cause);
+            }
+            return socketTimeoutException;
+        }
 
-    public void exitAndThrowIfTimedOut() throws IOException {
-      if (exit()) throw newTimeoutException(null /* cause */);
+        public void exitAndThrowIfTimedOut() throws IOException {
+            if (exit()) throw newTimeoutException(null /* cause */);
+        }
     }
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Header.java b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Header.java
index af5594f614..ad655905c9 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Header.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Header.java
@@ -2,55 +2,64 @@
 
 import okio.ByteString;
 
-/** HTTP header: the name is an ASCII string, but the value can be UTF-8. */
+/**
+ * HTTP header: the name is an ASCII string, but the value can be UTF-8.
+ */
 public final class Header {
-  // Special header names defined in the SPDY and HTTP/2 specs.
-  public static final ByteString RESPONSE_STATUS = ByteString.encodeUtf8(":status");
-  public static final ByteString TARGET_METHOD = ByteString.encodeUtf8(":method");
-  public static final ByteString TARGET_PATH = ByteString.encodeUtf8(":path");
-  public static final ByteString TARGET_SCHEME = ByteString.encodeUtf8(":scheme");
-  public static final ByteString TARGET_AUTHORITY = ByteString.encodeUtf8(":authority"); // HTTP/2
-  public static final ByteString TARGET_HOST = ByteString.encodeUtf8(":host"); // spdy/3
-  public static final ByteString VERSION = ByteString.encodeUtf8(":version"); // spdy/3
-
-  /** Name in case-insensitive ASCII encoding. */
-  public final ByteString name;
-  /** Value in UTF-8 encoding. */
-  public final ByteString value;
-  final int hpackSize;
-
-  // TODO: search for toLowerCase and consider moving logic here.
-  public Header(String name, String value) {
-    this(ByteString.encodeUtf8(name), ByteString.encodeUtf8(value));
-  }
-
-  public Header(ByteString name, String value) {
-    this(name, ByteString.encodeUtf8(value));
-  }
-
-  public Header(ByteString name, ByteString value) {
-    this.name = name;
-    this.value = value;
-    this.hpackSize = 32 + name.size() + value.size();
-  }
-
-  @Override public boolean equals(Object other) {
-    if (other instanceof Header) {
-      Header that = (Header) other;
-      return this.name.equals(that.name)
-          && this.value.equals(that.value);
+    // Special header names defined in the SPDY and HTTP/2 specs.
+    public static final ByteString RESPONSE_STATUS = ByteString.encodeUtf8(":status");
+    public static final ByteString TARGET_METHOD = ByteString.encodeUtf8(":method");
+    public static final ByteString TARGET_PATH = ByteString.encodeUtf8(":path");
+    public static final ByteString TARGET_SCHEME = ByteString.encodeUtf8(":scheme");
+    public static final ByteString TARGET_AUTHORITY = ByteString.encodeUtf8(":authority"); // HTTP/2
+    public static final ByteString TARGET_HOST = ByteString.encodeUtf8(":host"); // spdy/3
+    public static final ByteString VERSION = ByteString.encodeUtf8(":version"); // spdy/3
+
+    /**
+     * Name in case-insensitive ASCII encoding.
+     */
+    public final ByteString name;
+    /**
+     * Value in UTF-8 encoding.
+     */
+    public final ByteString value;
+    final int hpackSize;
+
+    // TODO: search for toLowerCase and consider moving logic here.
+    public Header(String name, String value) {
+        this(ByteString.encodeUtf8(name), ByteString.encodeUtf8(value));
+    }
+
+    public Header(ByteString name, String value) {
+        this(name, ByteString.encodeUtf8(value));
+    }
+
+    public Header(ByteString name, ByteString value) {
+        this.name = name;
+        this.value = value;
+        this.hpackSize = 32 + name.size() + value.size();
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (other instanceof Header) {
+            Header that = (Header) other;
+            return this.name.equals(that.name)
+                    && this.value.equals(that.value);
+        }
+        return false;
+    }
+
+    @Override
+    public int hashCode() {
+        int result = 17;
+        result = 31 * result + name.hashCode();
+        result = 31 * result + value.hashCode();
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        return String.format("%s: %s", name.utf8(), value.utf8());
     }
-    return false;
-  }
-
-  @Override public int hashCode() {
-    int result = 17;
-    result = 31 * result + name.hashCode();
-    result = 31 * result + value.hashCode();
-    return result;
-  }
-
-  @Override public String toString() {
-    return String.format("%s: %s", name.utf8(), value.utf8());
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/HeadersMode.java b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/HeadersMode.java
index b42915b610..dfc58a3089 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/HeadersMode.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/HeadersMode.java
@@ -16,34 +16,38 @@
 package com.squareup.okhttp.internal.framed;
 
 public enum HeadersMode {
-  SPDY_SYN_STREAM,
-  SPDY_REPLY,
-  SPDY_HEADERS,
-  HTTP_20_HEADERS;
+    SPDY_SYN_STREAM,
+    SPDY_REPLY,
+    SPDY_HEADERS,
+    HTTP_20_HEADERS;
 
-  /** Returns true if it is an error these headers to create a new stream. */
-  public boolean failIfStreamAbsent() {
-    return this == SPDY_REPLY || this == SPDY_HEADERS;
-  }
+    /**
+     * Returns true if it is an error these headers to create a new stream.
+     */
+    public boolean failIfStreamAbsent() {
+        return this == SPDY_REPLY || this == SPDY_HEADERS;
+    }
 
-  /** Returns true if it is an error these headers to update an existing stream. */
-  public boolean failIfStreamPresent() {
-    return this == SPDY_SYN_STREAM;
-  }
+    /**
+     * Returns true if it is an error these headers to update an existing stream.
+     */
+    public boolean failIfStreamPresent() {
+        return this == SPDY_SYN_STREAM;
+    }
 
-  /**
-   * Returns true if it is an error these headers to be the initial headers of a
-   * response.
-   */
-  public boolean failIfHeadersAbsent() {
-    return this == SPDY_HEADERS;
-  }
+    /**
+     * Returns true if it is an error these headers to be the initial headers of a
+     * response.
+     */
+    public boolean failIfHeadersAbsent() {
+        return this == SPDY_HEADERS;
+    }
 
-  /**
-   * Returns true if it is an error these headers to be update existing headers
-   * of a response.
-   */
-  public boolean failIfHeadersPresent() {
-    return this == SPDY_REPLY;
-  }
+    /**
+     * Returns true if it is an error these headers to be update existing headers
+     * of a response.
+     */
+    public boolean failIfHeadersPresent() {
+        return this == SPDY_REPLY;
+    }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Hpack.java b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Hpack.java
index 171516f7af..56c5ffda97 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Hpack.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Hpack.java
@@ -22,6 +22,7 @@
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.ByteString;
@@ -30,406 +31,414 @@
 
 /**
  * Read and write HPACK v10.
- *
+ * <p/>
  * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12
- *
+ * <p/>
  * This implementation uses an array for the dynamic table and a list for
  * indexed entries.  Dynamic entries are added to the array, starting in the
  * last position moving forward.  When the array fills, it is doubled.
  */
 final class Hpack {
-  private static final int PREFIX_4_BITS = 0x0f;
-  private static final int PREFIX_5_BITS = 0x1f;
-  private static final int PREFIX_6_BITS = 0x3f;
-  private static final int PREFIX_7_BITS = 0x7f;
-
-  private static final Header[] STATIC_HEADER_TABLE = new Header[] {
-      new Header(Header.TARGET_AUTHORITY, ""),
-      new Header(Header.TARGET_METHOD, "GET"),
-      new Header(Header.TARGET_METHOD, "POST"),
-      new Header(Header.TARGET_PATH, "/"),
-      new Header(Header.TARGET_PATH, "/index.html"),
-      new Header(Header.TARGET_SCHEME, "http"),
-      new Header(Header.TARGET_SCHEME, "https"),
-      new Header(Header.RESPONSE_STATUS, "200"),
-      new Header(Header.RESPONSE_STATUS, "204"),
-      new Header(Header.RESPONSE_STATUS, "206"),
-      new Header(Header.RESPONSE_STATUS, "304"),
-      new Header(Header.RESPONSE_STATUS, "400"),
-      new Header(Header.RESPONSE_STATUS, "404"),
-      new Header(Header.RESPONSE_STATUS, "500"),
-      new Header("accept-charset", ""),
-      new Header("accept-encoding", "gzip, deflate"),
-      new Header("accept-language", ""),
-      new Header("accept-ranges", ""),
-      new Header("accept", ""),
-      new Header("access-control-allow-origin", ""),
-      new Header("age", ""),
-      new Header("allow", ""),
-      new Header("authorization", ""),
-      new Header("cache-control", ""),
-      new Header("content-disposition", ""),
-      new Header("content-encoding", ""),
-      new Header("content-language", ""),
-      new Header("content-length", ""),
-      new Header("content-location", ""),
-      new Header("content-range", ""),
-      new Header("content-type", ""),
-      new Header("cookie", ""),
-      new Header("date", ""),
-      new Header("etag", ""),
-      new Header("expect", ""),
-      new Header("expires", ""),
-      new Header("from", ""),
-      new Header("host", ""),
-      new Header("if-match", ""),
-      new Header("if-modified-since", ""),
-      new Header("if-none-match", ""),
-      new Header("if-range", ""),
-      new Header("if-unmodified-since", ""),
-      new Header("last-modified", ""),
-      new Header("link", ""),
-      new Header("location", ""),
-      new Header("max-forwards", ""),
-      new Header("proxy-authenticate", ""),
-      new Header("proxy-authorization", ""),
-      new Header("range", ""),
-      new Header("referer", ""),
-      new Header("refresh", ""),
-      new Header("retry-after", ""),
-      new Header("server", ""),
-      new Header("set-cookie", ""),
-      new Header("strict-transport-security", ""),
-      new Header("transfer-encoding", ""),
-      new Header("user-agent", ""),
-      new Header("vary", ""),
-      new Header("via", ""),
-      new Header("www-authenticate", "")
-  };
-
-  private Hpack() {
-  }
-
-  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-3.1
-  static final class Reader {
-
-    private final List<Header> headerList = new ArrayList<>();
-    private final BufferedSource source;
-
-    private int headerTableSizeSetting;
-    private int maxDynamicTableByteCount;
-    // Visible for testing.
-    Header[] dynamicTable = new Header[8];
-    // Array is populated back to front, so new entries always have lowest index.
-    int nextHeaderIndex = dynamicTable.length - 1;
-    int headerCount = 0;
-    int dynamicTableByteCount = 0;
-
-    Reader(int headerTableSizeSetting, Source source) {
-      this.headerTableSizeSetting = headerTableSizeSetting;
-      this.maxDynamicTableByteCount = headerTableSizeSetting;
-      this.source = Okio.buffer(source);
+    private static final int PREFIX_4_BITS = 0x0f;
+    private static final int PREFIX_5_BITS = 0x1f;
+    private static final int PREFIX_6_BITS = 0x3f;
+    private static final int PREFIX_7_BITS = 0x7f;
+
+    private static final Header[] STATIC_HEADER_TABLE = new Header[]{
+            new Header(Header.TARGET_AUTHORITY, ""),
+            new Header(Header.TARGET_METHOD, "GET"),
+            new Header(Header.TARGET_METHOD, "POST"),
+            new Header(Header.TARGET_PATH, "/"),
+            new Header(Header.TARGET_PATH, "/index.html"),
+            new Header(Header.TARGET_SCHEME, "http"),
+            new Header(Header.TARGET_SCHEME, "https"),
+            new Header(Header.RESPONSE_STATUS, "200"),
+            new Header(Header.RESPONSE_STATUS, "204"),
+            new Header(Header.RESPONSE_STATUS, "206"),
+            new Header(Header.RESPONSE_STATUS, "304"),
+            new Header(Header.RESPONSE_STATUS, "400"),
+            new Header(Header.RESPONSE_STATUS, "404"),
+            new Header(Header.RESPONSE_STATUS, "500"),
+            new Header("accept-charset", ""),
+            new Header("accept-encoding", "gzip, deflate"),
+            new Header("accept-language", ""),
+            new Header("accept-ranges", ""),
+            new Header("accept", ""),
+            new Header("access-control-allow-origin", ""),
+            new Header("age", ""),
+            new Header("allow", ""),
+            new Header("authorization", ""),
+            new Header("cache-control", ""),
+            new Header("content-disposition", ""),
+            new Header("content-encoding", ""),
+            new Header("content-language", ""),
+            new Header("content-length", ""),
+            new Header("content-location", ""),
+            new Header("content-range", ""),
+            new Header("content-type", ""),
+            new Header("cookie", ""),
+            new Header("date", ""),
+            new Header("etag", ""),
+            new Header("expect", ""),
+            new Header("expires", ""),
+            new Header("from", ""),
+            new Header("host", ""),
+            new Header("if-match", ""),
+            new Header("if-modified-since", ""),
+            new Header("if-none-match", ""),
+            new Header("if-range", ""),
+            new Header("if-unmodified-since", ""),
+            new Header("last-modified", ""),
+            new Header("link", ""),
+            new Header("location", ""),
+            new Header("max-forwards", ""),
+            new Header("proxy-authenticate", ""),
+            new Header("proxy-authorization", ""),
+            new Header("range", ""),
+            new Header("referer", ""),
+            new Header("refresh", ""),
+            new Header("retry-after", ""),
+            new Header("server", ""),
+            new Header("set-cookie", ""),
+            new Header("strict-transport-security", ""),
+            new Header("transfer-encoding", ""),
+            new Header("user-agent", ""),
+            new Header("vary", ""),
+            new Header("via", ""),
+            new Header("www-authenticate", "")
+    };
+
+    private Hpack() {
     }
 
-    int maxDynamicTableByteCount() {
-      return maxDynamicTableByteCount;
-    }
+    // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-3.1
+    static final class Reader {
+
+        private final List<Header> headerList = new ArrayList<>();
+        private final BufferedSource source;
+
+        private int headerTableSizeSetting;
+        private int maxDynamicTableByteCount;
+        // Visible for testing.
+        Header[] dynamicTable = new Header[8];
+        // Array is populated back to front, so new entries always have lowest index.
+        int nextHeaderIndex = dynamicTable.length - 1;
+        int headerCount = 0;
+        int dynamicTableByteCount = 0;
+
+        Reader(int headerTableSizeSetting, Source source) {
+            this.headerTableSizeSetting = headerTableSizeSetting;
+            this.maxDynamicTableByteCount = headerTableSizeSetting;
+            this.source = Okio.buffer(source);
+        }
 
-    /**
-     * Called by the reader when the peer sent {@link Settings#HEADER_TABLE_SIZE}.
-     * While this establishes the maximum dynamic table size, the
-     * {@link #maxDynamicTableByteCount} set during processing may limit the
-     * table size to a smaller amount.
-     * <p> Evicts entries or clears the table as needed.
-     */
-    void headerTableSizeSetting(int headerTableSizeSetting) {
-      this.headerTableSizeSetting = headerTableSizeSetting;
-      this.maxDynamicTableByteCount = headerTableSizeSetting;
-      adjustDynamicTableByteCount();
-    }
+        int maxDynamicTableByteCount() {
+            return maxDynamicTableByteCount;
+        }
 
-    private void adjustDynamicTableByteCount() {
-      if (maxDynamicTableByteCount < dynamicTableByteCount) {
-        if (maxDynamicTableByteCount == 0) {
-          clearDynamicTable();
-        } else {
-          evictToRecoverBytes(dynamicTableByteCount - maxDynamicTableByteCount);
+        /**
+         * Called by the reader when the peer sent {@link Settings#HEADER_TABLE_SIZE}.
+         * While this establishes the maximum dynamic table size, the
+         * {@link #maxDynamicTableByteCount} set during processing may limit the
+         * table size to a smaller amount.
+         * <p> Evicts entries or clears the table as needed.
+         */
+        void headerTableSizeSetting(int headerTableSizeSetting) {
+            this.headerTableSizeSetting = headerTableSizeSetting;
+            this.maxDynamicTableByteCount = headerTableSizeSetting;
+            adjustDynamicTableByteCount();
         }
-      }
-    }
 
-    private void clearDynamicTable() {
-      headerList.clear();
-      Arrays.fill(dynamicTable, null);
-      nextHeaderIndex = dynamicTable.length - 1;
-      headerCount = 0;
-      dynamicTableByteCount = 0;
-    }
+        private void adjustDynamicTableByteCount() {
+            if (maxDynamicTableByteCount < dynamicTableByteCount) {
+                if (maxDynamicTableByteCount == 0) {
+                    clearDynamicTable();
+                } else {
+                    evictToRecoverBytes(dynamicTableByteCount - maxDynamicTableByteCount);
+                }
+            }
+        }
 
-    /** Returns the count of entries evicted. */
-    private int evictToRecoverBytes(int bytesToRecover) {
-      int entriesToEvict = 0;
-      if (bytesToRecover > 0) {
-        // determine how many headers need to be evicted.
-        for (int j = dynamicTable.length - 1; j >= nextHeaderIndex && bytesToRecover > 0; j--) {
-          bytesToRecover -= dynamicTable[j].hpackSize;
-          dynamicTableByteCount -= dynamicTable[j].hpackSize;
-          headerCount--;
-          entriesToEvict++;
+        private void clearDynamicTable() {
+            headerList.clear();
+            Arrays.fill(dynamicTable, null);
+            nextHeaderIndex = dynamicTable.length - 1;
+            headerCount = 0;
+            dynamicTableByteCount = 0;
         }
-        System.arraycopy(dynamicTable, nextHeaderIndex + 1, dynamicTable,
-            nextHeaderIndex + 1 + entriesToEvict, headerCount);
-        nextHeaderIndex += entriesToEvict;
-      }
-      return entriesToEvict;
-    }
 
-    /**
-     * Read {@code byteCount} bytes of headers from the source stream. This
-     * implementation does not propagate the never indexed flag of a header.
-     */
-    void readHeaders() throws IOException {
-      while (!source.exhausted()) {
-        int b = source.readByte() & 0xff;
-        if (b == 0x80) { // 10000000
-          throw new IOException("index == 0");
-        } else if ((b & 0x80) == 0x80) { // 1NNNNNNN
-          int index = readInt(b, PREFIX_7_BITS);
-          readIndexedHeader(index - 1);
-        } else if (b == 0x40) { // 01000000
-          readLiteralHeaderWithIncrementalIndexingNewName();
-        } else if ((b & 0x40) == 0x40) {  // 01NNNNNN
-          int index = readInt(b, PREFIX_6_BITS);
-          readLiteralHeaderWithIncrementalIndexingIndexedName(index - 1);
-        } else if ((b & 0x20) == 0x20) {  // 001NNNNN
-          maxDynamicTableByteCount = readInt(b, PREFIX_5_BITS);
-          if (maxDynamicTableByteCount < 0
-              || maxDynamicTableByteCount > headerTableSizeSetting) {
-            throw new IOException("Invalid dynamic table size update " + maxDynamicTableByteCount);
-          }
-          adjustDynamicTableByteCount();
-        } else if (b == 0x10 || b == 0) { // 000?0000 - Ignore never indexed bit.
-          readLiteralHeaderWithoutIndexingNewName();
-        } else { // 000?NNNN - Ignore never indexed bit.
-          int index = readInt(b, PREFIX_4_BITS);
-          readLiteralHeaderWithoutIndexingIndexedName(index - 1);
+        /**
+         * Returns the count of entries evicted.
+         */
+        private int evictToRecoverBytes(int bytesToRecover) {
+            int entriesToEvict = 0;
+            if (bytesToRecover > 0) {
+                // determine how many headers need to be evicted.
+                for (int j = dynamicTable.length - 1; j >= nextHeaderIndex && bytesToRecover > 0; j--) {
+                    bytesToRecover -= dynamicTable[j].hpackSize;
+                    dynamicTableByteCount -= dynamicTable[j].hpackSize;
+                    headerCount--;
+                    entriesToEvict++;
+                }
+                System.arraycopy(dynamicTable, nextHeaderIndex + 1, dynamicTable,
+                        nextHeaderIndex + 1 + entriesToEvict, headerCount);
+                nextHeaderIndex += entriesToEvict;
+            }
+            return entriesToEvict;
         }
-      }
-    }
 
-    public List<Header> getAndResetHeaderList() {
-      List<Header> result = new ArrayList<>(headerList);
-      headerList.clear();
-      return result;
-    }
+        /**
+         * Read {@code byteCount} bytes of headers from the source stream. This
+         * implementation does not propagate the never indexed flag of a header.
+         */
+        void readHeaders() throws IOException {
+            while (!source.exhausted()) {
+                int b = source.readByte() & 0xff;
+                if (b == 0x80) { // 10000000
+                    throw new IOException("index == 0");
+                } else if ((b & 0x80) == 0x80) { // 1NNNNNNN
+                    int index = readInt(b, PREFIX_7_BITS);
+                    readIndexedHeader(index - 1);
+                } else if (b == 0x40) { // 01000000
+                    readLiteralHeaderWithIncrementalIndexingNewName();
+                } else if ((b & 0x40) == 0x40) {  // 01NNNNNN
+                    int index = readInt(b, PREFIX_6_BITS);
+                    readLiteralHeaderWithIncrementalIndexingIndexedName(index - 1);
+                } else if ((b & 0x20) == 0x20) {  // 001NNNNN
+                    maxDynamicTableByteCount = readInt(b, PREFIX_5_BITS);
+                    if (maxDynamicTableByteCount < 0
+                            || maxDynamicTableByteCount > headerTableSizeSetting) {
+                        throw new IOException("Invalid dynamic table size update " + maxDynamicTableByteCount);
+                    }
+                    adjustDynamicTableByteCount();
+                } else if (b == 0x10 || b == 0) { // 000?0000 - Ignore never indexed bit.
+                    readLiteralHeaderWithoutIndexingNewName();
+                } else { // 000?NNNN - Ignore never indexed bit.
+                    int index = readInt(b, PREFIX_4_BITS);
+                    readLiteralHeaderWithoutIndexingIndexedName(index - 1);
+                }
+            }
+        }
 
-    private void readIndexedHeader(int index) throws IOException {
-      if (isStaticHeader(index)) {
-        Header staticEntry = STATIC_HEADER_TABLE[index];
-        headerList.add(staticEntry);
-      } else {
-        int dynamicTableIndex = dynamicTableIndex(index - STATIC_HEADER_TABLE.length);
-        if (dynamicTableIndex < 0 || dynamicTableIndex > dynamicTable.length - 1) {
-          throw new IOException("Header index too large " + (index + 1));
+        public List<Header> getAndResetHeaderList() {
+            List<Header> result = new ArrayList<>(headerList);
+            headerList.clear();
+            return result;
         }
-        headerList.add(dynamicTable[dynamicTableIndex]);
-      }
-    }
 
-    // referencedHeaders is relative to nextHeaderIndex + 1.
-    private int dynamicTableIndex(int index) {
-      return nextHeaderIndex + 1 + index;
-    }
+        private void readIndexedHeader(int index) throws IOException {
+            if (isStaticHeader(index)) {
+                Header staticEntry = STATIC_HEADER_TABLE[index];
+                headerList.add(staticEntry);
+            } else {
+                int dynamicTableIndex = dynamicTableIndex(index - STATIC_HEADER_TABLE.length);
+                if (dynamicTableIndex < 0 || dynamicTableIndex > dynamicTable.length - 1) {
+                    throw new IOException("Header index too large " + (index + 1));
+                }
+                headerList.add(dynamicTable[dynamicTableIndex]);
+            }
+        }
 
-    private void readLiteralHeaderWithoutIndexingIndexedName(int index) throws IOException {
-      ByteString name = getName(index);
-      ByteString value = readByteString();
-      headerList.add(new Header(name, value));
-    }
+        // referencedHeaders is relative to nextHeaderIndex + 1.
+        private int dynamicTableIndex(int index) {
+            return nextHeaderIndex + 1 + index;
+        }
 
-    private void readLiteralHeaderWithoutIndexingNewName() throws IOException {
-      ByteString name = checkLowercase(readByteString());
-      ByteString value = readByteString();
-      headerList.add(new Header(name, value));
-    }
+        private void readLiteralHeaderWithoutIndexingIndexedName(int index) throws IOException {
+            ByteString name = getName(index);
+            ByteString value = readByteString();
+            headerList.add(new Header(name, value));
+        }
 
-    private void readLiteralHeaderWithIncrementalIndexingIndexedName(int nameIndex)
-        throws IOException {
-      ByteString name = getName(nameIndex);
-      ByteString value = readByteString();
-      insertIntoDynamicTable(-1, new Header(name, value));
-    }
+        private void readLiteralHeaderWithoutIndexingNewName() throws IOException {
+            ByteString name = checkLowercase(readByteString());
+            ByteString value = readByteString();
+            headerList.add(new Header(name, value));
+        }
 
-    private void readLiteralHeaderWithIncrementalIndexingNewName() throws IOException {
-      ByteString name = checkLowercase(readByteString());
-      ByteString value = readByteString();
-      insertIntoDynamicTable(-1, new Header(name, value));
-    }
+        private void readLiteralHeaderWithIncrementalIndexingIndexedName(int nameIndex)
+                throws IOException {
+            ByteString name = getName(nameIndex);
+            ByteString value = readByteString();
+            insertIntoDynamicTable(-1, new Header(name, value));
+        }
 
-    private ByteString getName(int index) {
-      if (isStaticHeader(index)) {
-        return STATIC_HEADER_TABLE[index].name;
-      } else {
-        return dynamicTable[dynamicTableIndex(index - STATIC_HEADER_TABLE.length)].name;
-      }
-    }
+        private void readLiteralHeaderWithIncrementalIndexingNewName() throws IOException {
+            ByteString name = checkLowercase(readByteString());
+            ByteString value = readByteString();
+            insertIntoDynamicTable(-1, new Header(name, value));
+        }
 
-    private boolean isStaticHeader(int index) {
-      return index >= 0 && index <= STATIC_HEADER_TABLE.length - 1;
-    }
+        private ByteString getName(int index) {
+            if (isStaticHeader(index)) {
+                return STATIC_HEADER_TABLE[index].name;
+            } else {
+                return dynamicTable[dynamicTableIndex(index - STATIC_HEADER_TABLE.length)].name;
+            }
+        }
 
-    /** index == -1 when new. */
-    private void insertIntoDynamicTable(int index, Header entry) {
-      headerList.add(entry);
-
-      int delta = entry.hpackSize;
-      if (index != -1) { // Index -1 == new header.
-        delta -= dynamicTable[dynamicTableIndex(index)].hpackSize;
-      }
-
-      // if the new or replacement header is too big, drop all entries.
-      if (delta > maxDynamicTableByteCount) {
-        clearDynamicTable();
-        return;
-      }
-
-      // Evict headers to the required length.
-      int bytesToRecover = (dynamicTableByteCount + delta) - maxDynamicTableByteCount;
-      int entriesEvicted = evictToRecoverBytes(bytesToRecover);
-
-      if (index == -1) { // Adding a value to the dynamic table.
-        if (headerCount + 1 > dynamicTable.length) { // Need to grow the dynamic table.
-          Header[] doubled = new Header[dynamicTable.length * 2];
-          System.arraycopy(dynamicTable, 0, doubled, dynamicTable.length, dynamicTable.length);
-          nextHeaderIndex = dynamicTable.length - 1;
-          dynamicTable = doubled;
+        private boolean isStaticHeader(int index) {
+            return index >= 0 && index <= STATIC_HEADER_TABLE.length - 1;
         }
-        index = nextHeaderIndex--;
-        dynamicTable[index] = entry;
-        headerCount++;
-      } else { // Replace value at same position.
-        index += dynamicTableIndex(index) + entriesEvicted;
-        dynamicTable[index] = entry;
-      }
-      dynamicTableByteCount += delta;
-    }
 
-    private int readByte() throws IOException {
-      return source.readByte() & 0xff;
-    }
+        /**
+         * index == -1 when new.
+         */
+        private void insertIntoDynamicTable(int index, Header entry) {
+            headerList.add(entry);
+
+            int delta = entry.hpackSize;
+            if (index != -1) { // Index -1 == new header.
+                delta -= dynamicTable[dynamicTableIndex(index)].hpackSize;
+            }
+
+            // if the new or replacement header is too big, drop all entries.
+            if (delta > maxDynamicTableByteCount) {
+                clearDynamicTable();
+                return;
+            }
+
+            // Evict headers to the required length.
+            int bytesToRecover = (dynamicTableByteCount + delta) - maxDynamicTableByteCount;
+            int entriesEvicted = evictToRecoverBytes(bytesToRecover);
+
+            if (index == -1) { // Adding a value to the dynamic table.
+                if (headerCount + 1 > dynamicTable.length) { // Need to grow the dynamic table.
+                    Header[] doubled = new Header[dynamicTable.length * 2];
+                    System.arraycopy(dynamicTable, 0, doubled, dynamicTable.length, dynamicTable.length);
+                    nextHeaderIndex = dynamicTable.length - 1;
+                    dynamicTable = doubled;
+                }
+                index = nextHeaderIndex--;
+                dynamicTable[index] = entry;
+                headerCount++;
+            } else { // Replace value at same position.
+                index += dynamicTableIndex(index) + entriesEvicted;
+                dynamicTable[index] = entry;
+            }
+            dynamicTableByteCount += delta;
+        }
 
-    int readInt(int firstByte, int prefixMask) throws IOException {
-      int prefix = firstByte & prefixMask;
-      if (prefix < prefixMask) {
-        return prefix; // This was a single byte value.
-      }
-
-      // This is a multibyte value. Read 7 bits at a time.
-      int result = prefixMask;
-      int shift = 0;
-      while (true) {
-        int b = readByte();
-        if ((b & 0x80) != 0) { // Equivalent to (b >= 128) since b is in [0..255].
-          result += (b & 0x7f) << shift;
-          shift += 7;
-        } else {
-          result += b << shift; // Last byte.
-          break;
+        private int readByte() throws IOException {
+            return source.readByte() & 0xff;
+        }
+
+        int readInt(int firstByte, int prefixMask) throws IOException {
+            int prefix = firstByte & prefixMask;
+            if (prefix < prefixMask) {
+                return prefix; // This was a single byte value.
+            }
+
+            // This is a multibyte value. Read 7 bits at a time.
+            int result = prefixMask;
+            int shift = 0;
+            while (true) {
+                int b = readByte();
+                if ((b & 0x80) != 0) { // Equivalent to (b >= 128) since b is in [0..255].
+                    result += (b & 0x7f) << shift;
+                    shift += 7;
+                } else {
+                    result += b << shift; // Last byte.
+                    break;
+                }
+            }
+            return result;
         }
-      }
-      return result;
-    }
 
-    /** Reads a potentially Huffman encoded byte string. */
-    ByteString readByteString() throws IOException {
-      int firstByte = readByte();
-      boolean huffmanDecode = (firstByte & 0x80) == 0x80; // 1NNNNNNN
-      int length = readInt(firstByte, PREFIX_7_BITS);
-
-      if (huffmanDecode) {
-        return ByteString.of(Huffman.get().decode(source.readByteArray(length)));
-      } else {
-        return source.readByteString(length);
-      }
+        /**
+         * Reads a potentially Huffman encoded byte string.
+         */
+        ByteString readByteString() throws IOException {
+            int firstByte = readByte();
+            boolean huffmanDecode = (firstByte & 0x80) == 0x80; // 1NNNNNNN
+            int length = readInt(firstByte, PREFIX_7_BITS);
+
+            if (huffmanDecode) {
+                return ByteString.of(Huffman.get().decode(source.readByteArray(length)));
+            } else {
+                return source.readByteString(length);
+            }
+        }
     }
-  }
 
-  private static final Map<ByteString, Integer> NAME_TO_FIRST_INDEX = nameToFirstIndex();
+    private static final Map<ByteString, Integer> NAME_TO_FIRST_INDEX = nameToFirstIndex();
 
-  private static Map<ByteString, Integer> nameToFirstIndex() {
-    Map<ByteString, Integer> result = new LinkedHashMap<>(STATIC_HEADER_TABLE.length);
-    for (int i = 0; i < STATIC_HEADER_TABLE.length; i++) {
-      if (!result.containsKey(STATIC_HEADER_TABLE[i].name)) {
-        result.put(STATIC_HEADER_TABLE[i].name, i);
-      }
+    private static Map<ByteString, Integer> nameToFirstIndex() {
+        Map<ByteString, Integer> result = new LinkedHashMap<>(STATIC_HEADER_TABLE.length);
+        for (int i = 0; i < STATIC_HEADER_TABLE.length; i++) {
+            if (!result.containsKey(STATIC_HEADER_TABLE[i].name)) {
+                result.put(STATIC_HEADER_TABLE[i].name, i);
+            }
+        }
+        return Collections.unmodifiableMap(result);
     }
-    return Collections.unmodifiableMap(result);
-  }
 
-  static final class Writer {
-    private final Buffer out;
+    static final class Writer {
+        private final Buffer out;
 
-    Writer(Buffer out) {
-      this.out = out;
-    }
+        Writer(Buffer out) {
+            this.out = out;
+        }
 
-    /** This does not use "never indexed" semantics for sensitive headers. */
-    // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-6.2.3
-    void writeHeaders(List<Header> headerBlock) throws IOException {
-      // TODO: implement index tracking
-      for (int i = 0, size = headerBlock.size(); i < size; i++) {
-        ByteString name = headerBlock.get(i).name.toAsciiLowercase();
-        Integer staticIndex = NAME_TO_FIRST_INDEX.get(name);
-        if (staticIndex != null) {
-          // Literal Header Field without Indexing - Indexed Name.
-          writeInt(staticIndex + 1, PREFIX_4_BITS, 0);
-          writeByteString(headerBlock.get(i).value);
-        } else {
-          out.writeByte(0x00); // Literal Header without Indexing - New Name.
-          writeByteString(name);
-          writeByteString(headerBlock.get(i).value);
+        /**
+         * This does not use "never indexed" semantics for sensitive headers.
+         */
+        // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-6.2.3
+        void writeHeaders(List<Header> headerBlock) throws IOException {
+            // TODO: implement index tracking
+            for (int i = 0, size = headerBlock.size(); i < size; i++) {
+                ByteString name = headerBlock.get(i).name.toAsciiLowercase();
+                Integer staticIndex = NAME_TO_FIRST_INDEX.get(name);
+                if (staticIndex != null) {
+                    // Literal Header Field without Indexing - Indexed Name.
+                    writeInt(staticIndex + 1, PREFIX_4_BITS, 0);
+                    writeByteString(headerBlock.get(i).value);
+                } else {
+                    out.writeByte(0x00); // Literal Header without Indexing - New Name.
+                    writeByteString(name);
+                    writeByteString(headerBlock.get(i).value);
+                }
+            }
         }
-      }
-    }
 
-    // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-4.1.1
-    void writeInt(int value, int prefixMask, int bits) throws IOException {
-      // Write the raw value for a single byte value.
-      if (value < prefixMask) {
-        out.writeByte(bits | value);
-        return;
-      }
-
-      // Write the mask to start a multibyte value.
-      out.writeByte(bits | prefixMask);
-      value -= prefixMask;
-
-      // Write 7 bits at a time 'til we're done.
-      while (value >= 0x80) {
-        int b = value & 0x7f;
-        out.writeByte(b | 0x80);
-        value >>>= 7;
-      }
-      out.writeByte(value);
-    }
+        // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-4.1.1
+        void writeInt(int value, int prefixMask, int bits) throws IOException {
+            // Write the raw value for a single byte value.
+            if (value < prefixMask) {
+                out.writeByte(bits | value);
+                return;
+            }
+
+            // Write the mask to start a multibyte value.
+            out.writeByte(bits | prefixMask);
+            value -= prefixMask;
+
+            // Write 7 bits at a time 'til we're done.
+            while (value >= 0x80) {
+                int b = value & 0x7f;
+                out.writeByte(b | 0x80);
+                value >>>= 7;
+            }
+            out.writeByte(value);
+        }
 
-    void writeByteString(ByteString data) throws IOException {
-      writeInt(data.size(), PREFIX_7_BITS, 0);
-      out.write(data);
+        void writeByteString(ByteString data) throws IOException {
+            writeInt(data.size(), PREFIX_7_BITS, 0);
+            out.write(data);
+        }
     }
-  }
-
-  /**
-   * An HTTP/2 response cannot contain uppercase header characters and must
-   * be treated as malformed.
-   */
-  private static ByteString checkLowercase(ByteString name) throws IOException {
-    for (int i = 0, length = name.size(); i < length; i++) {
-      byte c = name.getByte(i);
-      if (c >= 'A' && c <= 'Z') {
-        throw new IOException("PROTOCOL_ERROR response malformed: mixed case name: " + name.utf8());
-      }
+
+    /**
+     * An HTTP/2 response cannot contain uppercase header characters and must
+     * be treated as malformed.
+     */
+    private static ByteString checkLowercase(ByteString name) throws IOException {
+        for (int i = 0, length = name.size(); i < length; i++) {
+            byte c = name.getByte(i);
+            if (c >= 'A' && c <= 'Z') {
+                throw new IOException("PROTOCOL_ERROR response malformed: mixed case name: " + name.utf8());
+            }
+        }
+        return name;
     }
-    return name;
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Http2.java b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Http2.java
index fb05b5bd50..8aba914ac1 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Http2.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Http2.java
@@ -16,9 +16,11 @@
 package com.squareup.okhttp.internal.framed;
 
 import com.squareup.okhttp.Protocol;
+
 import java.io.IOException;
 import java.util.List;
 import java.util.logging.Logger;
+
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -33,87 +35,95 @@
 
 /**
  * Read and write HTTP/2 frames.
- * <p>
+ * <p/>
  * This implementation assumes we do not send an increased
  * {@link Settings#getMaxFrameSize frame size setting} to the peer. Hence, we
  * expect all frames to have a max length of {@link #INITIAL_MAX_FRAME_SIZE}.
  * <p>http://tools.ietf.org/html/draft-ietf-httpbis-http2-17
  */
 public final class Http2 implements Variant {
-  private static final Logger logger = Logger.getLogger(FrameLogger.class.getName());
-
-  @Override public Protocol getProtocol() {
-    return Protocol.HTTP_2;
-  }
-
-  private static final ByteString CONNECTION_PREFACE
-      = ByteString.encodeUtf8("PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n");
-
-  /** The initial max frame size, applied independently writing to, or reading from the peer. */
-  static final int INITIAL_MAX_FRAME_SIZE = 0x4000; // 16384
-
-  static final byte TYPE_DATA = 0x0;
-  static final byte TYPE_HEADERS = 0x1;
-  static final byte TYPE_PRIORITY = 0x2;
-  static final byte TYPE_RST_STREAM = 0x3;
-  static final byte TYPE_SETTINGS = 0x4;
-  static final byte TYPE_PUSH_PROMISE = 0x5;
-  static final byte TYPE_PING = 0x6;
-  static final byte TYPE_GOAWAY = 0x7;
-  static final byte TYPE_WINDOW_UPDATE = 0x8;
-  static final byte TYPE_CONTINUATION = 0x9;
-
-  static final byte FLAG_NONE = 0x0;
-  static final byte FLAG_ACK = 0x1; // Used for settings and ping.
-  static final byte FLAG_END_STREAM = 0x1; // Used for headers and data.
-  static final byte FLAG_END_HEADERS = 0x4; // Used for headers and continuation.
-  static final byte FLAG_END_PUSH_PROMISE = 0x4;
-  static final byte FLAG_PADDED = 0x8; // Used for headers and data.
-  static final byte FLAG_PRIORITY = 0x20; // Used for headers.
-  static final byte FLAG_COMPRESSED = 0x20; // Used for data.
-
-  /**
-   * Creates a frame reader with max header table size of 4096 and data frame
-   * compression disabled.
-   */
-  @Override public FrameReader newReader(BufferedSource source, boolean client) {
-    return new Reader(source, 4096, client);
-  }
-
-  @Override public FrameWriter newWriter(BufferedSink sink, boolean client) {
-    return new Writer(sink, client);
-  }
-
-  static final class Reader implements FrameReader {
-    private final BufferedSource source;
-    private final ContinuationSource continuation;
-    private final boolean client;
-
-    // Visible for testing.
-    final Hpack.Reader hpackReader;
-
-    Reader(BufferedSource source, int headerTableSize, boolean client) {
-      this.source = source;
-      this.client = client;
-      this.continuation = new ContinuationSource(this.source);
-      this.hpackReader = new Hpack.Reader(headerTableSize, continuation);
+    private static final Logger logger = Logger.getLogger(FrameLogger.class.getName());
+
+    @Override
+    public Protocol getProtocol() {
+        return Protocol.HTTP_2;
     }
 
-    @Override public void readConnectionPreface() throws IOException {
-      if (client) return; // Nothing to read; servers doesn't send a connection preface!
-      ByteString connectionPreface = source.readByteString(CONNECTION_PREFACE.size());
-      if (logger.isLoggable(FINE)) logger.fine(format("<< CONNECTION %s", connectionPreface.hex()));
-      if (!CONNECTION_PREFACE.equals(connectionPreface)) {
-        throw ioException("Expected a connection header but was %s", connectionPreface.utf8());
-      }
+    private static final ByteString CONNECTION_PREFACE
+            = ByteString.encodeUtf8("PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n");
+
+    /**
+     * The initial max frame size, applied independently writing to, or reading from the peer.
+     */
+    static final int INITIAL_MAX_FRAME_SIZE = 0x4000; // 16384
+
+    static final byte TYPE_DATA = 0x0;
+    static final byte TYPE_HEADERS = 0x1;
+    static final byte TYPE_PRIORITY = 0x2;
+    static final byte TYPE_RST_STREAM = 0x3;
+    static final byte TYPE_SETTINGS = 0x4;
+    static final byte TYPE_PUSH_PROMISE = 0x5;
+    static final byte TYPE_PING = 0x6;
+    static final byte TYPE_GOAWAY = 0x7;
+    static final byte TYPE_WINDOW_UPDATE = 0x8;
+    static final byte TYPE_CONTINUATION = 0x9;
+
+    static final byte FLAG_NONE = 0x0;
+    static final byte FLAG_ACK = 0x1; // Used for settings and ping.
+    static final byte FLAG_END_STREAM = 0x1; // Used for headers and data.
+    static final byte FLAG_END_HEADERS = 0x4; // Used for headers and continuation.
+    static final byte FLAG_END_PUSH_PROMISE = 0x4;
+    static final byte FLAG_PADDED = 0x8; // Used for headers and data.
+    static final byte FLAG_PRIORITY = 0x20; // Used for headers.
+    static final byte FLAG_COMPRESSED = 0x20; // Used for data.
+
+    /**
+     * Creates a frame reader with max header table size of 4096 and data frame
+     * compression disabled.
+     */
+    @Override
+    public FrameReader newReader(BufferedSource source, boolean client) {
+        return new Reader(source, 4096, client);
     }
 
-    @Override public boolean nextFrame(Handler handler) throws IOException {
-      try {
-        source.require(9); // Frame header size
-      } catch (IOException e) {
-        return false; // This might be a normal socket close.
-      }
+    @Override
+    public FrameWriter newWriter(BufferedSink sink, boolean client) {
+        return new Writer(sink, client);
+    }
+
+    static final class Reader implements FrameReader {
+        private final BufferedSource source;
+        private final ContinuationSource continuation;
+        private final boolean client;
+
+        // Visible for testing.
+        final Hpack.Reader hpackReader;
+
+        Reader(BufferedSource source, int headerTableSize, boolean client) {
+            this.source = source;
+            this.client = client;
+            this.continuation = new ContinuationSource(this.source);
+            this.hpackReader = new Hpack.Reader(headerTableSize, continuation);
+        }
+
+        @Override
+        public void readConnectionPreface() throws IOException {
+            if (client) return; // Nothing to read; servers doesn't send a connection preface!
+            ByteString connectionPreface = source.readByteString(CONNECTION_PREFACE.size());
+            if (logger.isLoggable(FINE))
+                logger.fine(format("<< CONNECTION %s", connectionPreface.hex()));
+            if (!CONNECTION_PREFACE.equals(connectionPreface)) {
+                throw ioException("Expected a connection header but was %s", connectionPreface.utf8());
+            }
+        }
+
+        @Override
+        public boolean nextFrame(Handler handler) throws IOException {
+            try {
+                source.require(9); // Frame header size
+            } catch (IOException e) {
+                return false; // This might be a normal socket close.
+            }
 
       /*  0                   1                   2                   3
        *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
@@ -127,647 +137,673 @@
        * |                   Frame Payload (0...)                      ...
        * +---------------------------------------------------------------+
        */
-      int length = readMedium(source);
-      if (length < 0 || length > INITIAL_MAX_FRAME_SIZE) {
-        throw ioException("FRAME_SIZE_ERROR: %s", length);
-      }
-      byte type = (byte) (source.readByte() & 0xff);
-      byte flags = (byte) (source.readByte() & 0xff);
-      int streamId = (source.readInt() & 0x7fffffff); // Ignore reserved bit.
-      if (logger.isLoggable(FINE)) logger.fine(formatHeader(true, streamId, length, type, flags));
-
-      switch (type) {
-        case TYPE_DATA:
-          readData(handler, length, flags, streamId);
-          break;
-
-        case TYPE_HEADERS:
-          readHeaders(handler, length, flags, streamId);
-          break;
-
-        case TYPE_PRIORITY:
-          readPriority(handler, length, flags, streamId);
-          break;
-
-        case TYPE_RST_STREAM:
-          readRstStream(handler, length, flags, streamId);
-          break;
-
-        case TYPE_SETTINGS:
-          readSettings(handler, length, flags, streamId);
-          break;
-
-        case TYPE_PUSH_PROMISE:
-          readPushPromise(handler, length, flags, streamId);
-          break;
-
-        case TYPE_PING:
-          readPing(handler, length, flags, streamId);
-          break;
-
-        case TYPE_GOAWAY:
-          readGoAway(handler, length, flags, streamId);
-          break;
-
-        case TYPE_WINDOW_UPDATE:
-          readWindowUpdate(handler, length, flags, streamId);
-          break;
-
-        default:
-          // Implementations MUST discard frames that have unknown or unsupported types.
-          source.skip(length);
-      }
-      return true;
-    }
+            int length = readMedium(source);
+            if (length < 0 || length > INITIAL_MAX_FRAME_SIZE) {
+                throw ioException("FRAME_SIZE_ERROR: %s", length);
+            }
+            byte type = (byte) (source.readByte() & 0xff);
+            byte flags = (byte) (source.readByte() & 0xff);
+            int streamId = (source.readInt() & 0x7fffffff); // Ignore reserved bit.
+            if (logger.isLoggable(FINE))
+                logger.fine(formatHeader(true, streamId, length, type, flags));
+
+            switch (type) {
+                case TYPE_DATA:
+                    readData(handler, length, flags, streamId);
+                    break;
+
+                case TYPE_HEADERS:
+                    readHeaders(handler, length, flags, streamId);
+                    break;
+
+                case TYPE_PRIORITY:
+                    readPriority(handler, length, flags, streamId);
+                    break;
+
+                case TYPE_RST_STREAM:
+                    readRstStream(handler, length, flags, streamId);
+                    break;
+
+                case TYPE_SETTINGS:
+                    readSettings(handler, length, flags, streamId);
+                    break;
+
+                case TYPE_PUSH_PROMISE:
+                    readPushPromise(handler, length, flags, streamId);
+                    break;
+
+                case TYPE_PING:
+                    readPing(handler, length, flags, streamId);
+                    break;
+
+                case TYPE_GOAWAY:
+                    readGoAway(handler, length, flags, streamId);
+                    break;
+
+                case TYPE_WINDOW_UPDATE:
+                    readWindowUpdate(handler, length, flags, streamId);
+                    break;
+
+                default:
+                    // Implementations MUST discard frames that have unknown or unsupported types.
+                    source.skip(length);
+            }
+            return true;
+        }
 
-    private void readHeaders(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      if (streamId == 0) throw ioException("PROTOCOL_ERROR: TYPE_HEADERS streamId == 0");
+        private void readHeaders(Handler handler, int length, byte flags, int streamId)
+                throws IOException {
+            if (streamId == 0) throw ioException("PROTOCOL_ERROR: TYPE_HEADERS streamId == 0");
 
-      boolean endStream = (flags & FLAG_END_STREAM) != 0;
+            boolean endStream = (flags & FLAG_END_STREAM) != 0;
 
-      short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
+            short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
 
-      if ((flags & FLAG_PRIORITY) != 0) {
-        readPriority(handler, streamId);
-        length -= 5; // account for above read.
-      }
+            if ((flags & FLAG_PRIORITY) != 0) {
+                readPriority(handler, streamId);
+                length -= 5; // account for above read.
+            }
 
-      length = lengthWithoutPadding(length, flags, padding);
+            length = lengthWithoutPadding(length, flags, padding);
 
-      List<Header> headerBlock = readHeaderBlock(length, padding, flags, streamId);
+            List<Header> headerBlock = readHeaderBlock(length, padding, flags, streamId);
 
-      handler.headers(false, endStream, streamId, -1, headerBlock, HeadersMode.HTTP_20_HEADERS);
-    }
+            handler.headers(false, endStream, streamId, -1, headerBlock, HeadersMode.HTTP_20_HEADERS);
+        }
 
-    private List<Header> readHeaderBlock(int length, short padding, byte flags, int streamId)
-        throws IOException {
-      continuation.length = continuation.left = length;
-      continuation.padding = padding;
-      continuation.flags = flags;
-      continuation.streamId = streamId;
-
-      // TODO: Concat multi-value headers with 0x0, except COOKIE, which uses 0x3B, 0x20.
-      // http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-8.1.2.5
-      hpackReader.readHeaders();
-      return hpackReader.getAndResetHeaderList();
-    }
+        private List<Header> readHeaderBlock(int length, short padding, byte flags, int streamId)
+                throws IOException {
+            continuation.length = continuation.left = length;
+            continuation.padding = padding;
+            continuation.flags = flags;
+            continuation.streamId = streamId;
+
+            // TODO: Concat multi-value headers with 0x0, except COOKIE, which uses 0x3B, 0x20.
+            // http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-8.1.2.5
+            hpackReader.readHeaders();
+            return hpackReader.getAndResetHeaderList();
+        }
 
-    private void readData(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      // TODO: checkState open or half-closed (local) or raise STREAM_CLOSED
-      boolean inFinished = (flags & FLAG_END_STREAM) != 0;
-      boolean gzipped = (flags & FLAG_COMPRESSED) != 0;
-      if (gzipped) {
-        throw ioException("PROTOCOL_ERROR: FLAG_COMPRESSED without SETTINGS_COMPRESS_DATA");
-      }
+        private void readData(Handler handler, int length, byte flags, int streamId)
+                throws IOException {
+            // TODO: checkState open or half-closed (local) or raise STREAM_CLOSED
+            boolean inFinished = (flags & FLAG_END_STREAM) != 0;
+            boolean gzipped = (flags & FLAG_COMPRESSED) != 0;
+            if (gzipped) {
+                throw ioException("PROTOCOL_ERROR: FLAG_COMPRESSED without SETTINGS_COMPRESS_DATA");
+            }
 
-      short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
-      length = lengthWithoutPadding(length, flags, padding);
+            short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
+            length = lengthWithoutPadding(length, flags, padding);
 
-      handler.data(inFinished, streamId, source, length);
-      source.skip(padding);
-    }
+            handler.data(inFinished, streamId, source, length);
+            source.skip(padding);
+        }
 
-    private void readPriority(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      if (length != 5) throw ioException("TYPE_PRIORITY length: %d != 5", length);
-      if (streamId == 0) throw ioException("TYPE_PRIORITY streamId == 0");
-      readPriority(handler, streamId);
-    }
+        private void readPriority(Handler handler, int length, byte flags, int streamId)
+                throws IOException {
+            if (length != 5) throw ioException("TYPE_PRIORITY length: %d != 5", length);
+            if (streamId == 0) throw ioException("TYPE_PRIORITY streamId == 0");
+            readPriority(handler, streamId);
+        }
 
-    private void readPriority(Handler handler, int streamId) throws IOException {
-      int w1 = source.readInt();
-      boolean exclusive = (w1 & 0x80000000) != 0;
-      int streamDependency = (w1 & 0x7fffffff);
-      int weight = (source.readByte() & 0xff) + 1;
-      handler.priority(streamId, streamDependency, weight, exclusive);
-    }
+        private void readPriority(Handler handler, int streamId) throws IOException {
+            int w1 = source.readInt();
+            boolean exclusive = (w1 & 0x80000000) != 0;
+            int streamDependency = (w1 & 0x7fffffff);
+            int weight = (source.readByte() & 0xff) + 1;
+            handler.priority(streamId, streamDependency, weight, exclusive);
+        }
 
-    private void readRstStream(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      if (length != 4) throw ioException("TYPE_RST_STREAM length: %d != 4", length);
-      if (streamId == 0) throw ioException("TYPE_RST_STREAM streamId == 0");
-      int errorCodeInt = source.readInt();
-      ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
-      if (errorCode == null) {
-        throw ioException("TYPE_RST_STREAM unexpected error code: %d", errorCodeInt);
-      }
-      handler.rstStream(streamId, errorCode);
-    }
+        private void readRstStream(Handler handler, int length, byte flags, int streamId)
+                throws IOException {
+            if (length != 4) throw ioException("TYPE_RST_STREAM length: %d != 4", length);
+            if (streamId == 0) throw ioException("TYPE_RST_STREAM streamId == 0");
+            int errorCodeInt = source.readInt();
+            ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
+            if (errorCode == null) {
+                throw ioException("TYPE_RST_STREAM unexpected error code: %d", errorCodeInt);
+            }
+            handler.rstStream(streamId, errorCode);
+        }
 
-    private void readSettings(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      if (streamId != 0) throw ioException("TYPE_SETTINGS streamId != 0");
-      if ((flags & FLAG_ACK) != 0) {
-        if (length != 0) throw ioException("FRAME_SIZE_ERROR ack frame should be empty!");
-        handler.ackSettings();
-        return;
-      }
-
-      if (length % 6 != 0) throw ioException("TYPE_SETTINGS length %% 6 != 0: %s", length);
-      Settings settings = new Settings();
-      for (int i = 0; i < length; i += 6) {
-        short id = source.readShort();
-        int value = source.readInt();
-
-        switch (id) {
-          case 1: // SETTINGS_HEADER_TABLE_SIZE
-            break;
-          case 2: // SETTINGS_ENABLE_PUSH
-            if (value != 0 && value != 1) {
-              throw ioException("PROTOCOL_ERROR SETTINGS_ENABLE_PUSH != 0 or 1");
+        private void readSettings(Handler handler, int length, byte flags, int streamId)
+                throws IOException {
+            if (streamId != 0) throw ioException("TYPE_SETTINGS streamId != 0");
+            if ((flags & FLAG_ACK) != 0) {
+                if (length != 0) throw ioException("FRAME_SIZE_ERROR ack frame should be empty!");
+                handler.ackSettings();
+                return;
             }
-            break;
-          case 3: // SETTINGS_MAX_CONCURRENT_STREAMS
-            id = 4; // Renumbered in draft 10.
-            break;
-          case 4: // SETTINGS_INITIAL_WINDOW_SIZE
-            id = 7; // Renumbered in draft 10.
-            if (value < 0) {
-              throw ioException("PROTOCOL_ERROR SETTINGS_INITIAL_WINDOW_SIZE > 2^31 - 1");
+
+            if (length % 6 != 0) throw ioException("TYPE_SETTINGS length %% 6 != 0: %s", length);
+            Settings settings = new Settings();
+            for (int i = 0; i < length; i += 6) {
+                short id = source.readShort();
+                int value = source.readInt();
+
+                switch (id) {
+                    case 1: // SETTINGS_HEADER_TABLE_SIZE
+                        break;
+                    case 2: // SETTINGS_ENABLE_PUSH
+                        if (value != 0 && value != 1) {
+                            throw ioException("PROTOCOL_ERROR SETTINGS_ENABLE_PUSH != 0 or 1");
+                        }
+                        break;
+                    case 3: // SETTINGS_MAX_CONCURRENT_STREAMS
+                        id = 4; // Renumbered in draft 10.
+                        break;
+                    case 4: // SETTINGS_INITIAL_WINDOW_SIZE
+                        id = 7; // Renumbered in draft 10.
+                        if (value < 0) {
+                            throw ioException("PROTOCOL_ERROR SETTINGS_INITIAL_WINDOW_SIZE > 2^31 - 1");
+                        }
+                        break;
+                    case 5: // SETTINGS_MAX_FRAME_SIZE
+                        if (value < INITIAL_MAX_FRAME_SIZE || value > 16777215) {
+                            throw ioException("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: %s", value);
+                        }
+                        break;
+                    case 6: // SETTINGS_MAX_HEADER_LIST_SIZE
+                        break; // Advisory only, so ignored.
+                    default:
+                        throw ioException("PROTOCOL_ERROR invalid settings id: %s", id);
+                }
+                settings.set(id, 0, value);
             }
-            break;
-          case 5: // SETTINGS_MAX_FRAME_SIZE
-            if (value < INITIAL_MAX_FRAME_SIZE || value > 16777215) {
-              throw ioException("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: %s", value);
+            handler.settings(false, settings);
+            if (settings.getHeaderTableSize() >= 0) {
+                hpackReader.headerTableSizeSetting(settings.getHeaderTableSize());
             }
-            break;
-          case 6: // SETTINGS_MAX_HEADER_LIST_SIZE
-            break; // Advisory only, so ignored.
-          default:
-            throw ioException("PROTOCOL_ERROR invalid settings id: %s", id);
-        }
-        settings.set(id, 0, value);
-      }
-      handler.settings(false, settings);
-      if (settings.getHeaderTableSize() >= 0) {
-        hpackReader.headerTableSizeSetting(settings.getHeaderTableSize());
-      }
-    }
+        }
 
-    private void readPushPromise(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      if (streamId == 0) {
-        throw ioException("PROTOCOL_ERROR: TYPE_PUSH_PROMISE streamId == 0");
-      }
-      short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
-      int promisedStreamId = source.readInt() & 0x7fffffff;
-      length -= 4; // account for above read.
-      length = lengthWithoutPadding(length, flags, padding);
-      List<Header> headerBlock = readHeaderBlock(length, padding, flags, streamId);
-      handler.pushPromise(streamId, promisedStreamId, headerBlock);
-    }
+        private void readPushPromise(Handler handler, int length, byte flags, int streamId)
+                throws IOException {
+            if (streamId == 0) {
+                throw ioException("PROTOCOL_ERROR: TYPE_PUSH_PROMISE streamId == 0");
+            }
+            short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
+            int promisedStreamId = source.readInt() & 0x7fffffff;
+            length -= 4; // account for above read.
+            length = lengthWithoutPadding(length, flags, padding);
+            List<Header> headerBlock = readHeaderBlock(length, padding, flags, streamId);
+            handler.pushPromise(streamId, promisedStreamId, headerBlock);
+        }
 
-    private void readPing(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      if (length != 8) throw ioException("TYPE_PING length != 8: %s", length);
-      if (streamId != 0) throw ioException("TYPE_PING streamId != 0");
-      int payload1 = source.readInt();
-      int payload2 = source.readInt();
-      boolean ack = (flags & FLAG_ACK) != 0;
-      handler.ping(ack, payload1, payload2);
-    }
+        private void readPing(Handler handler, int length, byte flags, int streamId)
+                throws IOException {
+            if (length != 8) throw ioException("TYPE_PING length != 8: %s", length);
+            if (streamId != 0) throw ioException("TYPE_PING streamId != 0");
+            int payload1 = source.readInt();
+            int payload2 = source.readInt();
+            boolean ack = (flags & FLAG_ACK) != 0;
+            handler.ping(ack, payload1, payload2);
+        }
 
-    private void readGoAway(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      if (length < 8) throw ioException("TYPE_GOAWAY length < 8: %s", length);
-      if (streamId != 0) throw ioException("TYPE_GOAWAY streamId != 0");
-      int lastStreamId = source.readInt();
-      int errorCodeInt = source.readInt();
-      int opaqueDataLength = length - 8;
-      ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
-      if (errorCode == null) {
-        throw ioException("TYPE_GOAWAY unexpected error code: %d", errorCodeInt);
-      }
-      ByteString debugData = EMPTY;
-      if (opaqueDataLength > 0) { // Must read debug data in order to not corrupt the connection.
-        debugData = source.readByteString(opaqueDataLength);
-      }
-      handler.goAway(lastStreamId, errorCode, debugData);
-    }
+        private void readGoAway(Handler handler, int length, byte flags, int streamId)
+                throws IOException {
+            if (length < 8) throw ioException("TYPE_GOAWAY length < 8: %s", length);
+            if (streamId != 0) throw ioException("TYPE_GOAWAY streamId != 0");
+            int lastStreamId = source.readInt();
+            int errorCodeInt = source.readInt();
+            int opaqueDataLength = length - 8;
+            ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
+            if (errorCode == null) {
+                throw ioException("TYPE_GOAWAY unexpected error code: %d", errorCodeInt);
+            }
+            ByteString debugData = EMPTY;
+            if (opaqueDataLength > 0) { // Must read debug data in order to not corrupt the connection.
+                debugData = source.readByteString(opaqueDataLength);
+            }
+            handler.goAway(lastStreamId, errorCode, debugData);
+        }
 
-    private void readWindowUpdate(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      if (length != 4) throw ioException("TYPE_WINDOW_UPDATE length !=4: %s", length);
-      long increment = (source.readInt() & 0x7fffffffL);
-      if (increment == 0) throw ioException("windowSizeIncrement was 0", increment);
-      handler.windowUpdate(streamId, increment);
-    }
+        private void readWindowUpdate(Handler handler, int length, byte flags, int streamId)
+                throws IOException {
+            if (length != 4) throw ioException("TYPE_WINDOW_UPDATE length !=4: %s", length);
+            long increment = (source.readInt() & 0x7fffffffL);
+            if (increment == 0) throw ioException("windowSizeIncrement was 0", increment);
+            handler.windowUpdate(streamId, increment);
+        }
 
-    @Override public void close() throws IOException {
-      source.close();
-    }
-  }
-
-  static final class Writer implements FrameWriter {
-    private final BufferedSink sink;
-    private final boolean client;
-    private final Buffer hpackBuffer;
-    private final Hpack.Writer hpackWriter;
-    private int maxFrameSize;
-    private boolean closed;
-
-    Writer(BufferedSink sink, boolean client) {
-      this.sink = sink;
-      this.client = client;
-      this.hpackBuffer = new Buffer();
-      this.hpackWriter = new Hpack.Writer(hpackBuffer);
-      this.maxFrameSize = INITIAL_MAX_FRAME_SIZE;
+        @Override
+        public void close() throws IOException {
+            source.close();
+        }
     }
 
-    @Override public synchronized void flush() throws IOException {
-      if (closed) throw new IOException("closed");
-      sink.flush();
-    }
+    static final class Writer implements FrameWriter {
+        private final BufferedSink sink;
+        private final boolean client;
+        private final Buffer hpackBuffer;
+        private final Hpack.Writer hpackWriter;
+        private int maxFrameSize;
+        private boolean closed;
+
+        Writer(BufferedSink sink, boolean client) {
+            this.sink = sink;
+            this.client = client;
+            this.hpackBuffer = new Buffer();
+            this.hpackWriter = new Hpack.Writer(hpackBuffer);
+            this.maxFrameSize = INITIAL_MAX_FRAME_SIZE;
+        }
 
-    @Override public synchronized void ackSettings(Settings peerSettings) throws IOException {
-      if (closed) throw new IOException("closed");
-      this.maxFrameSize = peerSettings.getMaxFrameSize(maxFrameSize);
-      int length = 0;
-      byte type = TYPE_SETTINGS;
-      byte flags = FLAG_ACK;
-      int streamId = 0;
-      frameHeader(streamId, length, type, flags);
-      sink.flush();
-    }
+        @Override
+        public synchronized void flush() throws IOException {
+            if (closed) throw new IOException("closed");
+            sink.flush();
+        }
 
-    @Override public synchronized void connectionPreface() throws IOException {
-      if (closed) throw new IOException("closed");
-      if (!client) return; // Nothing to write; servers don't send connection headers!
-      if (logger.isLoggable(FINE)) {
-        logger.fine(format(">> CONNECTION %s", CONNECTION_PREFACE.hex()));
-      }
-      sink.write(CONNECTION_PREFACE.toByteArray());
-      sink.flush();
-    }
+        @Override
+        public synchronized void ackSettings(Settings peerSettings) throws IOException {
+            if (closed) throw new IOException("closed");
+            this.maxFrameSize = peerSettings.getMaxFrameSize(maxFrameSize);
+            int length = 0;
+            byte type = TYPE_SETTINGS;
+            byte flags = FLAG_ACK;
+            int streamId = 0;
+            frameHeader(streamId, length, type, flags);
+            sink.flush();
+        }
 
-    @Override public synchronized void synStream(boolean outFinished, boolean inFinished,
-        int streamId, int associatedStreamId, List<Header> headerBlock)
-        throws IOException {
-      if (inFinished) throw new UnsupportedOperationException();
-      if (closed) throw new IOException("closed");
-      headers(outFinished, streamId, headerBlock);
-    }
+        @Override
+        public synchronized void connectionPreface() throws IOException {
+            if (closed) throw new IOException("closed");
+            if (!client) return; // Nothing to write; servers don't send connection headers!
+            if (logger.isLoggable(FINE)) {
+                logger.fine(format(">> CONNECTION %s", CONNECTION_PREFACE.hex()));
+            }
+            sink.write(CONNECTION_PREFACE.toByteArray());
+            sink.flush();
+        }
 
-    @Override public synchronized void synReply(boolean outFinished, int streamId,
-        List<Header> headerBlock) throws IOException {
-      if (closed) throw new IOException("closed");
-      headers(outFinished, streamId, headerBlock);
-    }
+        @Override
+        public synchronized void synStream(boolean outFinished, boolean inFinished,
+                                           int streamId, int associatedStreamId, List<Header> headerBlock)
+                throws IOException {
+            if (inFinished) throw new UnsupportedOperationException();
+            if (closed) throw new IOException("closed");
+            headers(outFinished, streamId, headerBlock);
+        }
 
-    @Override public synchronized void headers(int streamId, List<Header> headerBlock)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      headers(false, streamId, headerBlock);
-    }
+        @Override
+        public synchronized void synReply(boolean outFinished, int streamId,
+                                          List<Header> headerBlock) throws IOException {
+            if (closed) throw new IOException("closed");
+            headers(outFinished, streamId, headerBlock);
+        }
 
-    @Override public synchronized void pushPromise(int streamId, int promisedStreamId,
-        List<Header> requestHeaders) throws IOException {
-      if (closed) throw new IOException("closed");
-      if (hpackBuffer.size() != 0) throw new IllegalStateException();
-      hpackWriter.writeHeaders(requestHeaders);
-
-      long byteCount = hpackBuffer.size();
-      int length = (int) Math.min(maxFrameSize - 4, byteCount);
-      byte type = TYPE_PUSH_PROMISE;
-      byte flags = byteCount == length ? FLAG_END_HEADERS : 0;
-      frameHeader(streamId, length + 4, type, flags);
-      sink.writeInt(promisedStreamId & 0x7fffffff);
-      sink.write(hpackBuffer, length);
-
-      if (byteCount > length) writeContinuationFrames(streamId, byteCount - length);
-    }
+        @Override
+        public synchronized void headers(int streamId, List<Header> headerBlock)
+                throws IOException {
+            if (closed) throw new IOException("closed");
+            headers(false, streamId, headerBlock);
+        }
 
-    void headers(boolean outFinished, int streamId, List<Header> headerBlock) throws IOException {
-      if (closed) throw new IOException("closed");
-      if (hpackBuffer.size() != 0) throw new IllegalStateException();
-      hpackWriter.writeHeaders(headerBlock);
+        @Override
+        public synchronized void pushPromise(int streamId, int promisedStreamId,
+                                             List<Header> requestHeaders) throws IOException {
+            if (closed) throw new IOException("closed");
+            if (hpackBuffer.size() != 0) throw new IllegalStateException();
+            hpackWriter.writeHeaders(requestHeaders);
+
+            long byteCount = hpackBuffer.size();
+            int length = (int) Math.min(maxFrameSize - 4, byteCount);
+            byte type = TYPE_PUSH_PROMISE;
+            byte flags = byteCount == length ? FLAG_END_HEADERS : 0;
+            frameHeader(streamId, length + 4, type, flags);
+            sink.writeInt(promisedStreamId & 0x7fffffff);
+            sink.write(hpackBuffer, length);
+
+            if (byteCount > length) writeContinuationFrames(streamId, byteCount - length);
+        }
 
-      long byteCount = hpackBuffer.size();
-      int length = (int) Math.min(maxFrameSize, byteCount);
-      byte type = TYPE_HEADERS;
-      byte flags = byteCount == length ? FLAG_END_HEADERS : 0;
-      if (outFinished) flags |= FLAG_END_STREAM;
-      frameHeader(streamId, length, type, flags);
-      sink.write(hpackBuffer, length);
+        void headers(boolean outFinished, int streamId, List<Header> headerBlock) throws IOException {
+            if (closed) throw new IOException("closed");
+            if (hpackBuffer.size() != 0) throw new IllegalStateException();
+            hpackWriter.writeHeaders(headerBlock);
 
-      if (byteCount > length) writeContinuationFrames(streamId, byteCount - length);
-    }
+            long byteCount = hpackBuffer.size();
+            int length = (int) Math.min(maxFrameSize, byteCount);
+            byte type = TYPE_HEADERS;
+            byte flags = byteCount == length ? FLAG_END_HEADERS : 0;
+            if (outFinished) flags |= FLAG_END_STREAM;
+            frameHeader(streamId, length, type, flags);
+            sink.write(hpackBuffer, length);
 
-    private void writeContinuationFrames(int streamId, long byteCount) throws IOException {
-      while (byteCount > 0) {
-        int length = (int) Math.min(maxFrameSize, byteCount);
-        byteCount -= length;
-        frameHeader(streamId, length, TYPE_CONTINUATION, byteCount == 0 ? FLAG_END_HEADERS : 0);
-        sink.write(hpackBuffer, length);
-      }
-    }
+            if (byteCount > length) writeContinuationFrames(streamId, byteCount - length);
+        }
 
-    @Override public synchronized void rstStream(int streamId, ErrorCode errorCode)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      if (errorCode.httpCode == -1) throw new IllegalArgumentException();
-
-      int length = 4;
-      byte type = TYPE_RST_STREAM;
-      byte flags = FLAG_NONE;
-      frameHeader(streamId, length, type, flags);
-      sink.writeInt(errorCode.httpCode);
-      sink.flush();
-    }
+        private void writeContinuationFrames(int streamId, long byteCount) throws IOException {
+            while (byteCount > 0) {
+                int length = (int) Math.min(maxFrameSize, byteCount);
+                byteCount -= length;
+                frameHeader(streamId, length, TYPE_CONTINUATION, byteCount == 0 ? FLAG_END_HEADERS : 0);
+                sink.write(hpackBuffer, length);
+            }
+        }
 
-    @Override public int maxDataLength() {
-      return maxFrameSize;
-    }
+        @Override
+        public synchronized void rstStream(int streamId, ErrorCode errorCode)
+                throws IOException {
+            if (closed) throw new IOException("closed");
+            if (errorCode.httpCode == -1) throw new IllegalArgumentException();
+
+            int length = 4;
+            byte type = TYPE_RST_STREAM;
+            byte flags = FLAG_NONE;
+            frameHeader(streamId, length, type, flags);
+            sink.writeInt(errorCode.httpCode);
+            sink.flush();
+        }
 
-    @Override public synchronized void data(boolean outFinished, int streamId, Buffer source,
-        int byteCount) throws IOException {
-      if (closed) throw new IOException("closed");
-      byte flags = FLAG_NONE;
-      if (outFinished) flags |= FLAG_END_STREAM;
-      dataFrame(streamId, flags, source, byteCount);
-    }
+        @Override
+        public int maxDataLength() {
+            return maxFrameSize;
+        }
 
-    void dataFrame(int streamId, byte flags, Buffer buffer, int byteCount) throws IOException {
-      byte type = TYPE_DATA;
-      frameHeader(streamId, byteCount, type, flags);
-      if (byteCount > 0) {
-        sink.write(buffer, byteCount);
-      }
-    }
+        @Override
+        public synchronized void data(boolean outFinished, int streamId, Buffer source,
+                                      int byteCount) throws IOException {
+            if (closed) throw new IOException("closed");
+            byte flags = FLAG_NONE;
+            if (outFinished) flags |= FLAG_END_STREAM;
+            dataFrame(streamId, flags, source, byteCount);
+        }
 
-    @Override public synchronized void settings(Settings settings) throws IOException {
-      if (closed) throw new IOException("closed");
-      int length = settings.size() * 6;
-      byte type = TYPE_SETTINGS;
-      byte flags = FLAG_NONE;
-      int streamId = 0;
-      frameHeader(streamId, length, type, flags);
-      for (int i = 0; i < Settings.COUNT; i++) {
-        if (!settings.isSet(i)) continue;
-        int id = i;
-        if (id == 4) id = 3; // SETTINGS_MAX_CONCURRENT_STREAMS renumbered.
-        else if (id == 7) id = 4; // SETTINGS_INITIAL_WINDOW_SIZE renumbered.
-        sink.writeShort(id);
-        sink.writeInt(settings.get(i));
-      }
-      sink.flush();
-    }
+        void dataFrame(int streamId, byte flags, Buffer buffer, int byteCount) throws IOException {
+            byte type = TYPE_DATA;
+            frameHeader(streamId, byteCount, type, flags);
+            if (byteCount > 0) {
+                sink.write(buffer, byteCount);
+            }
+        }
 
-    @Override public synchronized void ping(boolean ack, int payload1, int payload2)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      int length = 8;
-      byte type = TYPE_PING;
-      byte flags = ack ? FLAG_ACK : FLAG_NONE;
-      int streamId = 0;
-      frameHeader(streamId, length, type, flags);
-      sink.writeInt(payload1);
-      sink.writeInt(payload2);
-      sink.flush();
-    }
+        @Override
+        public synchronized void settings(Settings settings) throws IOException {
+            if (closed) throw new IOException("closed");
+            int length = settings.size() * 6;
+            byte type = TYPE_SETTINGS;
+            byte flags = FLAG_NONE;
+            int streamId = 0;
+            frameHeader(streamId, length, type, flags);
+            for (int i = 0; i < Settings.COUNT; i++) {
+                if (!settings.isSet(i)) continue;
+                int id = i;
+                if (id == 4) id = 3; // SETTINGS_MAX_CONCURRENT_STREAMS renumbered.
+                else if (id == 7) id = 4; // SETTINGS_INITIAL_WINDOW_SIZE renumbered.
+                sink.writeShort(id);
+                sink.writeInt(settings.get(i));
+            }
+            sink.flush();
+        }
 
-    @Override public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode,
-        byte[] debugData) throws IOException {
-      if (closed) throw new IOException("closed");
-      if (errorCode.httpCode == -1) throw illegalArgument("errorCode.httpCode == -1");
-      int length = 8 + debugData.length;
-      byte type = TYPE_GOAWAY;
-      byte flags = FLAG_NONE;
-      int streamId = 0;
-      frameHeader(streamId, length, type, flags);
-      sink.writeInt(lastGoodStreamId);
-      sink.writeInt(errorCode.httpCode);
-      if (debugData.length > 0) {
-        sink.write(debugData);
-      }
-      sink.flush();
-    }
+        @Override
+        public synchronized void ping(boolean ack, int payload1, int payload2)
+                throws IOException {
+            if (closed) throw new IOException("closed");
+            int length = 8;
+            byte type = TYPE_PING;
+            byte flags = ack ? FLAG_ACK : FLAG_NONE;
+            int streamId = 0;
+            frameHeader(streamId, length, type, flags);
+            sink.writeInt(payload1);
+            sink.writeInt(payload2);
+            sink.flush();
+        }
 
-    @Override public synchronized void windowUpdate(int streamId, long windowSizeIncrement)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      if (windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL) {
-        throw illegalArgument("windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: %s",
-            windowSizeIncrement);
-      }
-      int length = 4;
-      byte type = TYPE_WINDOW_UPDATE;
-      byte flags = FLAG_NONE;
-      frameHeader(streamId, length, type, flags);
-      sink.writeInt((int) windowSizeIncrement);
-      sink.flush();
-    }
+        @Override
+        public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode,
+                                        byte[] debugData) throws IOException {
+            if (closed) throw new IOException("closed");
+            if (errorCode.httpCode == -1) throw illegalArgument("errorCode.httpCode == -1");
+            int length = 8 + debugData.length;
+            byte type = TYPE_GOAWAY;
+            byte flags = FLAG_NONE;
+            int streamId = 0;
+            frameHeader(streamId, length, type, flags);
+            sink.writeInt(lastGoodStreamId);
+            sink.writeInt(errorCode.httpCode);
+            if (debugData.length > 0) {
+                sink.write(debugData);
+            }
+            sink.flush();
+        }
 
-    @Override public synchronized void close() throws IOException {
-      closed = true;
-      sink.close();
-    }
+        @Override
+        public synchronized void windowUpdate(int streamId, long windowSizeIncrement)
+                throws IOException {
+            if (closed) throw new IOException("closed");
+            if (windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL) {
+                throw illegalArgument("windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: %s",
+                        windowSizeIncrement);
+            }
+            int length = 4;
+            byte type = TYPE_WINDOW_UPDATE;
+            byte flags = FLAG_NONE;
+            frameHeader(streamId, length, type, flags);
+            sink.writeInt((int) windowSizeIncrement);
+            sink.flush();
+        }
+
+        @Override
+        public synchronized void close() throws IOException {
+            closed = true;
+            sink.close();
+        }
 
-    void frameHeader(int streamId, int length, byte type, byte flags) throws IOException {
-      if (logger.isLoggable(FINE)) logger.fine(formatHeader(false, streamId, length, type, flags));
-      if (length > maxFrameSize) {
-        throw illegalArgument("FRAME_SIZE_ERROR length > %d: %d", maxFrameSize, length);
-      }
-      if ((streamId & 0x80000000) != 0) throw illegalArgument("reserved bit set: %s", streamId);
-      writeMedium(sink, length);
-      sink.writeByte(type & 0xff);
-      sink.writeByte(flags & 0xff);
-      sink.writeInt(streamId & 0x7fffffff);
+        void frameHeader(int streamId, int length, byte type, byte flags) throws IOException {
+            if (logger.isLoggable(FINE))
+                logger.fine(formatHeader(false, streamId, length, type, flags));
+            if (length > maxFrameSize) {
+                throw illegalArgument("FRAME_SIZE_ERROR length > %d: %d", maxFrameSize, length);
+            }
+            if ((streamId & 0x80000000) != 0)
+                throw illegalArgument("reserved bit set: %s", streamId);
+            writeMedium(sink, length);
+            sink.writeByte(type & 0xff);
+            sink.writeByte(flags & 0xff);
+            sink.writeInt(streamId & 0x7fffffff);
+        }
     }
-  }
 
-  private static IllegalArgumentException illegalArgument(String message, Object... args) {
-    throw new IllegalArgumentException(format(message, args));
-  }
+    private static IllegalArgumentException illegalArgument(String message, Object... args) {
+        throw new IllegalArgumentException(format(message, args));
+    }
 
-  private static IOException ioException(String message, Object... args) throws IOException {
-    throw new IOException(format(message, args));
-  }
+    private static IOException ioException(String message, Object... args) throws IOException {
+        throw new IOException(format(message, args));
+    }
 
-  /**
-   * Decompression of the header block occurs above the framing layer. This
-   * class lazily reads continuation frames as they are needed by {@link
-   * Hpack.Reader#readHeaders()}.
-   */
-  static final class ContinuationSource implements Source {
-    private final BufferedSource source;
+    /**
+     * Decompression of the header block occurs above the framing layer. This
+     * class lazily reads continuation frames as they are needed by {@link
+     * Hpack.Reader#readHeaders()}.
+     */
+    static final class ContinuationSource implements Source {
+        private final BufferedSource source;
 
-    int length;
-    byte flags;
-    int streamId;
+        int length;
+        byte flags;
+        int streamId;
 
-    int left;
-    short padding;
+        int left;
+        short padding;
 
-    public ContinuationSource(BufferedSource source) {
-      this.source = source;
-    }
+        public ContinuationSource(BufferedSource source) {
+            this.source = source;
+        }
 
-    @Override public long read(Buffer sink, long byteCount) throws IOException {
-      while (left == 0) {
-        source.skip(padding);
-        padding = 0;
-        if ((flags & FLAG_END_HEADERS) != 0) return -1;
-        readContinuationHeader();
-        // TODO: test case for empty continuation header?
-      }
-
-      long read = source.read(sink, Math.min(byteCount, left));
-      if (read == -1) return -1;
-      left -= read;
-      return read;
-    }
+        @Override
+        public long read(Buffer sink, long byteCount) throws IOException {
+            while (left == 0) {
+                source.skip(padding);
+                padding = 0;
+                if ((flags & FLAG_END_HEADERS) != 0) return -1;
+                readContinuationHeader();
+                // TODO: test case for empty continuation header?
+            }
 
-    @Override public Timeout timeout() {
-      return source.timeout();
-    }
+            long read = source.read(sink, Math.min(byteCount, left));
+            if (read == -1) return -1;
+            left -= read;
+            return read;
+        }
 
-    @Override public void close() throws IOException {
-    }
+        @Override
+        public Timeout timeout() {
+            return source.timeout();
+        }
 
-    private void readContinuationHeader() throws IOException {
-      int previousStreamId = streamId;
+        @Override
+        public void close() throws IOException {
+        }
 
-      length = left = readMedium(source);
-      byte type = (byte) (source.readByte() & 0xff);
-      flags = (byte) (source.readByte() & 0xff);
-      if (logger.isLoggable(FINE)) logger.fine(formatHeader(true, streamId, length, type, flags));
-      streamId = (source.readInt() & 0x7fffffff);
-      if (type != TYPE_CONTINUATION) throw ioException("%s != TYPE_CONTINUATION", type);
-      if (streamId != previousStreamId) throw ioException("TYPE_CONTINUATION streamId changed");
+        private void readContinuationHeader() throws IOException {
+            int previousStreamId = streamId;
+
+            length = left = readMedium(source);
+            byte type = (byte) (source.readByte() & 0xff);
+            flags = (byte) (source.readByte() & 0xff);
+            if (logger.isLoggable(FINE))
+                logger.fine(formatHeader(true, streamId, length, type, flags));
+            streamId = (source.readInt() & 0x7fffffff);
+            if (type != TYPE_CONTINUATION) throw ioException("%s != TYPE_CONTINUATION", type);
+            if (streamId != previousStreamId)
+                throw ioException("TYPE_CONTINUATION streamId changed");
+        }
     }
-  }
 
-  private static int lengthWithoutPadding(int length, byte flags, short padding)
-      throws IOException {
-    if ((flags & FLAG_PADDED) != 0) length--; // Account for reading the padding length.
-    if (padding > length) {
-      throw ioException("PROTOCOL_ERROR padding %s > remaining length %s", padding, length);
-    }
-    return (short) (length - padding);
-  }
-
-  /**
-   * Logs a human-readable representation of HTTP/2 frame headers.
-   *
-   * <p>The format is:
-   *
-   * <pre>
-   *   direction streamID length type flags
-   * </pre>
-   * Where direction is {@code <<} for inbound and {@code >>} for outbound.
-   *
-   * <p> For example, the following would indicate a HEAD request sent from
-   * the client.
-   * <pre>
-   * {@code
-   *   << 0x0000000f    12 HEADERS       END_HEADERS|END_STREAM
-   * }
-   * </pre>
-   */
-  static final class FrameLogger {
-
-    static String formatHeader(boolean inbound, int streamId, int length, byte type, byte flags) {
-      String formattedType = type < TYPES.length ? TYPES[type] : format("0x%02x", type);
-      String formattedFlags = formatFlags(type, flags);
-      return format("%s 0x%08x %5d %-13s %s", inbound ? "<<" : ">>", streamId, length,
-          formattedType, formattedFlags);
+    private static int lengthWithoutPadding(int length, byte flags, short padding)
+            throws IOException {
+        if ((flags & FLAG_PADDED) != 0) length--; // Account for reading the padding length.
+        if (padding > length) {
+            throw ioException("PROTOCOL_ERROR padding %s > remaining length %s", padding, length);
+        }
+        return (short) (length - padding);
     }
 
     /**
-     * Looks up valid string representing flags from the table. Invalid
-     * combinations are represented in binary.
+     * Logs a human-readable representation of HTTP/2 frame headers.
+     * <p/>
+     * <p>The format is:
+     * <p/>
+     * <pre>
+     *   direction streamID length type flags
+     * </pre>
+     * Where direction is {@code <<} for inbound and {@code >>} for outbound.
+     * <p/>
+     * <p> For example, the following would indicate a HEAD request sent from
+     * the client.
+     * <pre>
+     * {@code
+     *   << 0x0000000f    12 HEADERS       END_HEADERS|END_STREAM
+     * }
+     * </pre>
      */
-    // Visible for testing.
-    static String formatFlags(byte type, byte flags) {
-      if (flags == 0) return "";
-      switch (type) { // Special case types that have 0 or 1 flag.
-        case TYPE_SETTINGS:
-        case TYPE_PING:
-          return flags == FLAG_ACK ? "ACK" : BINARY[flags];
-        case TYPE_PRIORITY:
-        case TYPE_RST_STREAM:
-        case TYPE_GOAWAY:
-        case TYPE_WINDOW_UPDATE:
-          return BINARY[flags];
-      }
-      String result = flags < FLAGS.length ? FLAGS[flags] : BINARY[flags];
-      // Special case types that have overlap flag values.
-      if (type == TYPE_PUSH_PROMISE && (flags & FLAG_END_PUSH_PROMISE) != 0) {
-        return result.replace("HEADERS", "PUSH_PROMISE"); // TODO: Avoid allocation.
-      } else if (type == TYPE_DATA && (flags & FLAG_COMPRESSED) != 0) {
-        return result.replace("PRIORITY", "COMPRESSED"); // TODO: Avoid allocation.
-      }
-      return result;
-    }
+    static final class FrameLogger {
 
-    /** Lookup table for valid frame types. */
-    private static final String[] TYPES = new String[] {
-        "DATA",
-        "HEADERS",
-        "PRIORITY",
-        "RST_STREAM",
-        "SETTINGS",
-        "PUSH_PROMISE",
-        "PING",
-        "GOAWAY",
-        "WINDOW_UPDATE",
-        "CONTINUATION"
-    };
+        static String formatHeader(boolean inbound, int streamId, int length, byte type, byte flags) {
+            String formattedType = type < TYPES.length ? TYPES[type] : format("0x%02x", type);
+            String formattedFlags = formatFlags(type, flags);
+            return format("%s 0x%08x %5d %-13s %s", inbound ? "<<" : ">>", streamId, length,
+                    formattedType, formattedFlags);
+        }
 
-    /**
-     * Lookup table for valid flags for DATA, HEADERS, CONTINUATION. Invalid
-     * combinations are represented in binary.
-     */
-    private static final String[] FLAGS = new String[0x40]; // Highest bit flag is 0x20.
-    private static final String[] BINARY = new String[256];
+        /**
+         * Looks up valid string representing flags from the table. Invalid
+         * combinations are represented in binary.
+         */
+        // Visible for testing.
+        static String formatFlags(byte type, byte flags) {
+            if (flags == 0) return "";
+            switch (type) { // Special case types that have 0 or 1 flag.
+                case TYPE_SETTINGS:
+                case TYPE_PING:
+                    return flags == FLAG_ACK ? "ACK" : BINARY[flags];
+                case TYPE_PRIORITY:
+                case TYPE_RST_STREAM:
+                case TYPE_GOAWAY:
+                case TYPE_WINDOW_UPDATE:
+                    return BINARY[flags];
+            }
+            String result = flags < FLAGS.length ? FLAGS[flags] : BINARY[flags];
+            // Special case types that have overlap flag values.
+            if (type == TYPE_PUSH_PROMISE && (flags & FLAG_END_PUSH_PROMISE) != 0) {
+                return result.replace("HEADERS", "PUSH_PROMISE"); // TODO: Avoid allocation.
+            } else if (type == TYPE_DATA && (flags & FLAG_COMPRESSED) != 0) {
+                return result.replace("PRIORITY", "COMPRESSED"); // TODO: Avoid allocation.
+            }
+            return result;
+        }
 
-    static {
-      for (int i = 0; i < BINARY.length; i++) {
-        BINARY[i] = format("%8s", Integer.toBinaryString(i)).replace(' ', '0');
-      }
+        /**
+         * Lookup table for valid frame types.
+         */
+        private static final String[] TYPES = new String[]{
+                "DATA",
+                "HEADERS",
+                "PRIORITY",
+                "RST_STREAM",
+                "SETTINGS",
+                "PUSH_PROMISE",
+                "PING",
+                "GOAWAY",
+                "WINDOW_UPDATE",
+                "CONTINUATION"
+        };
+
+        /**
+         * Lookup table for valid flags for DATA, HEADERS, CONTINUATION. Invalid
+         * combinations are represented in binary.
+         */
+        private static final String[] FLAGS = new String[0x40]; // Highest bit flag is 0x20.
+        private static final String[] BINARY = new String[256];
+
+        static {
+            for (int i = 0; i < BINARY.length; i++) {
+                BINARY[i] = format("%8s", Integer.toBinaryString(i)).replace(' ', '0');
+            }
 
-      FLAGS[FLAG_NONE] = "";
-      FLAGS[FLAG_END_STREAM] = "END_STREAM";
+            FLAGS[FLAG_NONE] = "";
+            FLAGS[FLAG_END_STREAM] = "END_STREAM";
 
-      int[] prefixFlags = new int[] {FLAG_END_STREAM};
+            int[] prefixFlags = new int[]{FLAG_END_STREAM};
 
-      FLAGS[FLAG_PADDED] = "PADDED";
-      for (int prefixFlag : prefixFlags) {
-         FLAGS[prefixFlag | FLAG_PADDED] = FLAGS[prefixFlag] + "|PADDED";
-      }
+            FLAGS[FLAG_PADDED] = "PADDED";
+            for (int prefixFlag : prefixFlags) {
+                FLAGS[prefixFlag | FLAG_PADDED] = FLAGS[prefixFlag] + "|PADDED";
+            }
 
-      FLAGS[FLAG_END_HEADERS] = "END_HEADERS"; // Same as END_PUSH_PROMISE.
-      FLAGS[FLAG_PRIORITY] = "PRIORITY"; // Same as FLAG_COMPRESSED.
-      FLAGS[FLAG_END_HEADERS | FLAG_PRIORITY] = "END_HEADERS|PRIORITY"; // Only valid on HEADERS.
-      int[] frameFlags =
-          new int[] {FLAG_END_HEADERS, FLAG_PRIORITY, FLAG_END_HEADERS | FLAG_PRIORITY};
+            FLAGS[FLAG_END_HEADERS] = "END_HEADERS"; // Same as END_PUSH_PROMISE.
+            FLAGS[FLAG_PRIORITY] = "PRIORITY"; // Same as FLAG_COMPRESSED.
+            FLAGS[FLAG_END_HEADERS | FLAG_PRIORITY] = "END_HEADERS|PRIORITY"; // Only valid on HEADERS.
+            int[] frameFlags =
+                    new int[]{FLAG_END_HEADERS, FLAG_PRIORITY, FLAG_END_HEADERS | FLAG_PRIORITY};
+
+            for (int frameFlag : frameFlags) {
+                for (int prefixFlag : prefixFlags) {
+                    FLAGS[prefixFlag | frameFlag] = FLAGS[prefixFlag] + '|' + FLAGS[frameFlag];
+                    FLAGS[prefixFlag | frameFlag | FLAG_PADDED] =
+                            FLAGS[prefixFlag] + '|' + FLAGS[frameFlag] + "|PADDED";
+                }
+            }
 
-      for (int frameFlag : frameFlags) {
-        for (int prefixFlag : prefixFlags) {
-          FLAGS[prefixFlag | frameFlag] = FLAGS[prefixFlag] + '|' + FLAGS[frameFlag];
-          FLAGS[prefixFlag | frameFlag | FLAG_PADDED] =
-              FLAGS[prefixFlag] + '|' + FLAGS[frameFlag] + "|PADDED";
+            for (int i = 0; i < FLAGS.length; i++) { // Fill in holes with binary representation.
+                if (FLAGS[i] == null) FLAGS[i] = BINARY[i];
+            }
         }
-      }
+    }
+
+    private static int readMedium(BufferedSource source) throws IOException {
+        return (source.readByte() & 0xff) << 16
+                | (source.readByte() & 0xff) << 8
+                | (source.readByte() & 0xff);
+    }
 
-      for (int i = 0; i < FLAGS.length; i++) { // Fill in holes with binary representation.
-        if (FLAGS[i] == null) FLAGS[i] = BINARY[i];
-      }
+    private static void writeMedium(BufferedSink sink, int i) throws IOException {
+        sink.writeByte((i >>> 16) & 0xff);
+        sink.writeByte((i >>> 8) & 0xff);
+        sink.writeByte(i & 0xff);
     }
-  }
-
-  private static int readMedium(BufferedSource source) throws IOException {
-    return (source.readByte() & 0xff) << 16
-        |  (source.readByte() & 0xff) <<  8
-        |  (source.readByte() & 0xff);
-  }
-
-  private static void writeMedium(BufferedSink sink, int i) throws IOException {
-    sink.writeByte((i >>> 16) & 0xff);
-    sink.writeByte((i >>>  8) & 0xff);
-    sink.writeByte(i          & 0xff);
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Huffman.java b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Huffman.java
index f21a16ded0..3b84eaffbb 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Huffman.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Huffman.java
@@ -30,196 +30,198 @@
  */
 class Huffman {
 
-  // Appendix C: Huffman Codes
-  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#appendix-B
-  private static final int[] CODES = {
-      0x1ff8, 0x7fffd8, 0xfffffe2, 0xfffffe3, 0xfffffe4, 0xfffffe5, 0xfffffe6, 0xfffffe7, 0xfffffe8,
-      0xffffea, 0x3ffffffc, 0xfffffe9, 0xfffffea, 0x3ffffffd, 0xfffffeb, 0xfffffec, 0xfffffed,
-      0xfffffee, 0xfffffef, 0xffffff0, 0xffffff1, 0xffffff2, 0x3ffffffe, 0xffffff3, 0xffffff4,
-      0xffffff5, 0xffffff6, 0xffffff7, 0xffffff8, 0xffffff9, 0xffffffa, 0xffffffb, 0x14, 0x3f8,
-      0x3f9, 0xffa, 0x1ff9, 0x15, 0xf8, 0x7fa, 0x3fa, 0x3fb, 0xf9, 0x7fb, 0xfa, 0x16, 0x17, 0x18,
-      0x0, 0x1, 0x2, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x5c, 0xfb, 0x7ffc, 0x20, 0xffb,
-      0x3fc, 0x1ffa, 0x21, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
-      0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0xfc, 0x73, 0xfd, 0x1ffb, 0x7fff0,
-      0x1ffc, 0x3ffc, 0x22, 0x7ffd, 0x3, 0x23, 0x4, 0x24, 0x5, 0x25, 0x26, 0x27, 0x6, 0x74, 0x75,
-      0x28, 0x29, 0x2a, 0x7, 0x2b, 0x76, 0x2c, 0x8, 0x9, 0x2d, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7ffe,
-      0x7fc, 0x3ffd, 0x1ffd, 0xffffffc, 0xfffe6, 0x3fffd2, 0xfffe7, 0xfffe8, 0x3fffd3, 0x3fffd4,
-      0x3fffd5, 0x7fffd9, 0x3fffd6, 0x7fffda, 0x7fffdb, 0x7fffdc, 0x7fffdd, 0x7fffde, 0xffffeb,
-      0x7fffdf, 0xffffec, 0xffffed, 0x3fffd7, 0x7fffe0, 0xffffee, 0x7fffe1, 0x7fffe2, 0x7fffe3,
-      0x7fffe4, 0x1fffdc, 0x3fffd8, 0x7fffe5, 0x3fffd9, 0x7fffe6, 0x7fffe7, 0xffffef, 0x3fffda,
-      0x1fffdd, 0xfffe9, 0x3fffdb, 0x3fffdc, 0x7fffe8, 0x7fffe9, 0x1fffde, 0x7fffea, 0x3fffdd,
-      0x3fffde, 0xfffff0, 0x1fffdf, 0x3fffdf, 0x7fffeb, 0x7fffec, 0x1fffe0, 0x1fffe1, 0x3fffe0,
-      0x1fffe2, 0x7fffed, 0x3fffe1, 0x7fffee, 0x7fffef, 0xfffea, 0x3fffe2, 0x3fffe3, 0x3fffe4,
-      0x7ffff0, 0x3fffe5, 0x3fffe6, 0x7ffff1, 0x3ffffe0, 0x3ffffe1, 0xfffeb, 0x7fff1, 0x3fffe7,
-      0x7ffff2, 0x3fffe8, 0x1ffffec, 0x3ffffe2, 0x3ffffe3, 0x3ffffe4, 0x7ffffde, 0x7ffffdf,
-      0x3ffffe5, 0xfffff1, 0x1ffffed, 0x7fff2, 0x1fffe3, 0x3ffffe6, 0x7ffffe0, 0x7ffffe1, 0x3ffffe7,
-      0x7ffffe2, 0xfffff2, 0x1fffe4, 0x1fffe5, 0x3ffffe8, 0x3ffffe9, 0xffffffd, 0x7ffffe3,
-      0x7ffffe4, 0x7ffffe5, 0xfffec, 0xfffff3, 0xfffed, 0x1fffe6, 0x3fffe9, 0x1fffe7, 0x1fffe8,
-      0x7ffff3, 0x3fffea, 0x3fffeb, 0x1ffffee, 0x1ffffef, 0xfffff4, 0xfffff5, 0x3ffffea, 0x7ffff4,
-      0x3ffffeb, 0x7ffffe6, 0x3ffffec, 0x3ffffed, 0x7ffffe7, 0x7ffffe8, 0x7ffffe9, 0x7ffffea,
-      0x7ffffeb, 0xffffffe, 0x7ffffec, 0x7ffffed, 0x7ffffee, 0x7ffffef, 0x7fffff0, 0x3ffffee
-  };
-
-  private static final byte[] CODE_LENGTHS = {
-      13, 23, 28, 28, 28, 28, 28, 28, 28, 24, 30, 28, 28, 30, 28, 28, 28, 28, 28, 28, 28, 28, 30,
-      28, 28, 28, 28, 28, 28, 28, 28, 28, 6, 10, 10, 12, 13, 6, 8, 11, 10, 10, 8, 11, 8, 6, 6, 6, 5,
-      5, 5, 6, 6, 6, 6, 6, 6, 6, 7, 8, 15, 6, 12, 10, 13, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
-      7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 8, 13, 19, 13, 14, 6, 15, 5, 6, 5, 6, 5, 6, 6, 6, 5, 7, 7, 6,
-      6, 6, 5, 6, 7, 6, 5, 5, 6, 7, 7, 7, 7, 7, 15, 11, 14, 13, 28, 20, 22, 20, 20, 22, 22, 22, 23,
-      22, 23, 23, 23, 23, 23, 24, 23, 24, 24, 22, 23, 24, 23, 23, 23, 23, 21, 22, 23, 22, 23, 23,
-      24, 22, 21, 20, 22, 22, 23, 23, 21, 23, 22, 22, 24, 21, 22, 23, 23, 21, 21, 22, 21, 23, 22,
-      23, 23, 20, 22, 22, 22, 23, 22, 22, 23, 26, 26, 20, 19, 22, 23, 22, 25, 26, 26, 26, 27, 27,
-      26, 24, 25, 19, 21, 26, 27, 27, 26, 27, 24, 21, 21, 26, 26, 28, 27, 27, 27, 20, 24, 20, 21,
-      22, 21, 21, 23, 22, 22, 25, 25, 24, 24, 26, 23, 26, 27, 26, 26, 27, 27, 27, 27, 27, 28, 27,
-      27, 27, 27, 27, 26
-  };
-
-  private static final Huffman INSTANCE = new Huffman();
-
-  public static Huffman get() {
-    return INSTANCE;
-  }
-
-  private final Node root = new Node();
-
-  private Huffman() {
-    buildTree();
-  }
-
-  void encode(byte[] data, OutputStream out) throws IOException {
-    long current = 0;
-    int n = 0;
-
-    for (int i = 0; i < data.length; i++) {
-      int b = data[i] & 0xFF;
-      int code = CODES[b];
-      int nbits = CODE_LENGTHS[b];
-
-      current <<= nbits;
-      current |= code;
-      n += nbits;
-
-      while (n >= 8) {
-        n -= 8;
-        out.write(((int) (current >> n)));
-      }
+    // Appendix C: Huffman Codes
+    // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#appendix-B
+    private static final int[] CODES = {
+            0x1ff8, 0x7fffd8, 0xfffffe2, 0xfffffe3, 0xfffffe4, 0xfffffe5, 0xfffffe6, 0xfffffe7, 0xfffffe8,
+            0xffffea, 0x3ffffffc, 0xfffffe9, 0xfffffea, 0x3ffffffd, 0xfffffeb, 0xfffffec, 0xfffffed,
+            0xfffffee, 0xfffffef, 0xffffff0, 0xffffff1, 0xffffff2, 0x3ffffffe, 0xffffff3, 0xffffff4,
+            0xffffff5, 0xffffff6, 0xffffff7, 0xffffff8, 0xffffff9, 0xffffffa, 0xffffffb, 0x14, 0x3f8,
+            0x3f9, 0xffa, 0x1ff9, 0x15, 0xf8, 0x7fa, 0x3fa, 0x3fb, 0xf9, 0x7fb, 0xfa, 0x16, 0x17, 0x18,
+            0x0, 0x1, 0x2, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x5c, 0xfb, 0x7ffc, 0x20, 0xffb,
+            0x3fc, 0x1ffa, 0x21, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
+            0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0xfc, 0x73, 0xfd, 0x1ffb, 0x7fff0,
+            0x1ffc, 0x3ffc, 0x22, 0x7ffd, 0x3, 0x23, 0x4, 0x24, 0x5, 0x25, 0x26, 0x27, 0x6, 0x74, 0x75,
+            0x28, 0x29, 0x2a, 0x7, 0x2b, 0x76, 0x2c, 0x8, 0x9, 0x2d, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7ffe,
+            0x7fc, 0x3ffd, 0x1ffd, 0xffffffc, 0xfffe6, 0x3fffd2, 0xfffe7, 0xfffe8, 0x3fffd3, 0x3fffd4,
+            0x3fffd5, 0x7fffd9, 0x3fffd6, 0x7fffda, 0x7fffdb, 0x7fffdc, 0x7fffdd, 0x7fffde, 0xffffeb,
+            0x7fffdf, 0xffffec, 0xffffed, 0x3fffd7, 0x7fffe0, 0xffffee, 0x7fffe1, 0x7fffe2, 0x7fffe3,
+            0x7fffe4, 0x1fffdc, 0x3fffd8, 0x7fffe5, 0x3fffd9, 0x7fffe6, 0x7fffe7, 0xffffef, 0x3fffda,
+            0x1fffdd, 0xfffe9, 0x3fffdb, 0x3fffdc, 0x7fffe8, 0x7fffe9, 0x1fffde, 0x7fffea, 0x3fffdd,
+            0x3fffde, 0xfffff0, 0x1fffdf, 0x3fffdf, 0x7fffeb, 0x7fffec, 0x1fffe0, 0x1fffe1, 0x3fffe0,
+            0x1fffe2, 0x7fffed, 0x3fffe1, 0x7fffee, 0x7fffef, 0xfffea, 0x3fffe2, 0x3fffe3, 0x3fffe4,
+            0x7ffff0, 0x3fffe5, 0x3fffe6, 0x7ffff1, 0x3ffffe0, 0x3ffffe1, 0xfffeb, 0x7fff1, 0x3fffe7,
+            0x7ffff2, 0x3fffe8, 0x1ffffec, 0x3ffffe2, 0x3ffffe3, 0x3ffffe4, 0x7ffffde, 0x7ffffdf,
+            0x3ffffe5, 0xfffff1, 0x1ffffed, 0x7fff2, 0x1fffe3, 0x3ffffe6, 0x7ffffe0, 0x7ffffe1, 0x3ffffe7,
+            0x7ffffe2, 0xfffff2, 0x1fffe4, 0x1fffe5, 0x3ffffe8, 0x3ffffe9, 0xffffffd, 0x7ffffe3,
+            0x7ffffe4, 0x7ffffe5, 0xfffec, 0xfffff3, 0xfffed, 0x1fffe6, 0x3fffe9, 0x1fffe7, 0x1fffe8,
+            0x7ffff3, 0x3fffea, 0x3fffeb, 0x1ffffee, 0x1ffffef, 0xfffff4, 0xfffff5, 0x3ffffea, 0x7ffff4,
+            0x3ffffeb, 0x7ffffe6, 0x3ffffec, 0x3ffffed, 0x7ffffe7, 0x7ffffe8, 0x7ffffe9, 0x7ffffea,
+            0x7ffffeb, 0xffffffe, 0x7ffffec, 0x7ffffed, 0x7ffffee, 0x7ffffef, 0x7fffff0, 0x3ffffee
+    };
+
+    private static final byte[] CODE_LENGTHS = {
+            13, 23, 28, 28, 28, 28, 28, 28, 28, 24, 30, 28, 28, 30, 28, 28, 28, 28, 28, 28, 28, 28, 30,
+            28, 28, 28, 28, 28, 28, 28, 28, 28, 6, 10, 10, 12, 13, 6, 8, 11, 10, 10, 8, 11, 8, 6, 6, 6, 5,
+            5, 5, 6, 6, 6, 6, 6, 6, 6, 7, 8, 15, 6, 12, 10, 13, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
+            7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 8, 13, 19, 13, 14, 6, 15, 5, 6, 5, 6, 5, 6, 6, 6, 5, 7, 7, 6,
+            6, 6, 5, 6, 7, 6, 5, 5, 6, 7, 7, 7, 7, 7, 15, 11, 14, 13, 28, 20, 22, 20, 20, 22, 22, 22, 23,
+            22, 23, 23, 23, 23, 23, 24, 23, 24, 24, 22, 23, 24, 23, 23, 23, 23, 21, 22, 23, 22, 23, 23,
+            24, 22, 21, 20, 22, 22, 23, 23, 21, 23, 22, 22, 24, 21, 22, 23, 23, 21, 21, 22, 21, 23, 22,
+            23, 23, 20, 22, 22, 22, 23, 22, 22, 23, 26, 26, 20, 19, 22, 23, 22, 25, 26, 26, 26, 27, 27,
+            26, 24, 25, 19, 21, 26, 27, 27, 26, 27, 24, 21, 21, 26, 26, 28, 27, 27, 27, 20, 24, 20, 21,
+            22, 21, 21, 23, 22, 22, 25, 25, 24, 24, 26, 23, 26, 27, 26, 26, 27, 27, 27, 27, 27, 28, 27,
+            27, 27, 27, 27, 26
+    };
+
+    private static final Huffman INSTANCE = new Huffman();
+
+    public static Huffman get() {
+        return INSTANCE;
     }
 
-    if (n > 0) {
-      current <<= (8 - n);
-      current |= (0xFF >>> n);
-      out.write((int) current);
+    private final Node root = new Node();
+
+    private Huffman() {
+        buildTree();
     }
-  }
 
-  int encodedLength(byte[] bytes) {
-    long len = 0;
+    void encode(byte[] data, OutputStream out) throws IOException {
+        long current = 0;
+        int n = 0;
 
-    for (int i = 0; i < bytes.length; i++) {
-      int b = bytes[i] & 0xFF;
-      len += CODE_LENGTHS[b];
-    }
+        for (int i = 0; i < data.length; i++) {
+            int b = data[i] & 0xFF;
+            int code = CODES[b];
+            int nbits = CODE_LENGTHS[b];
+
+            current <<= nbits;
+            current |= code;
+            n += nbits;
+
+            while (n >= 8) {
+                n -= 8;
+                out.write(((int) (current >> n)));
+            }
+        }
 
-    return (int) ((len + 7) >> 3);
-  }
-
-  byte[] decode(byte[] buf) throws IOException {
-    ByteArrayOutputStream baos = new ByteArrayOutputStream();
-    Node node = root;
-    int current = 0;
-    int nbits = 0;
-    for (int i = 0; i < buf.length; i++) {
-      int b = buf[i] & 0xFF;
-      current = (current << 8) | b;
-      nbits += 8;
-      while (nbits >= 8) {
-        int c = (current >>> (nbits - 8)) & 0xFF;
-        node = node.children[c];
-        if (node.children == null) {
-          // terminal node
-          baos.write(node.symbol);
-          nbits -= node.terminalBits;
-          node = root;
-        } else {
-          // non-terminal node
-          nbits -= 8;
+        if (n > 0) {
+            current <<= (8 - n);
+            current |= (0xFF >>> n);
+            out.write((int) current);
         }
-      }
     }
 
-    while (nbits > 0) {
-      int c = (current << (8 - nbits)) & 0xFF;
-      node = node.children[c];
-      if (node.children != null || node.terminalBits > nbits) {
-        break;
-      }
-      baos.write(node.symbol);
-      nbits -= node.terminalBits;
-      node = root;
+    int encodedLength(byte[] bytes) {
+        long len = 0;
+
+        for (int i = 0; i < bytes.length; i++) {
+            int b = bytes[i] & 0xFF;
+            len += CODE_LENGTHS[b];
+        }
+
+        return (int) ((len + 7) >> 3);
     }
 
-    return baos.toByteArray();
-  }
+    byte[] decode(byte[] buf) throws IOException {
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        Node node = root;
+        int current = 0;
+        int nbits = 0;
+        for (int i = 0; i < buf.length; i++) {
+            int b = buf[i] & 0xFF;
+            current = (current << 8) | b;
+            nbits += 8;
+            while (nbits >= 8) {
+                int c = (current >>> (nbits - 8)) & 0xFF;
+                node = node.children[c];
+                if (node.children == null) {
+                    // terminal node
+                    baos.write(node.symbol);
+                    nbits -= node.terminalBits;
+                    node = root;
+                } else {
+                    // non-terminal node
+                    nbits -= 8;
+                }
+            }
+        }
 
-  private void buildTree() {
-    for (int i = 0; i < CODE_LENGTHS.length; i++) {
-      addCode(i, CODES[i], CODE_LENGTHS[i]);
+        while (nbits > 0) {
+            int c = (current << (8 - nbits)) & 0xFF;
+            node = node.children[c];
+            if (node.children != null || node.terminalBits > nbits) {
+                break;
+            }
+            baos.write(node.symbol);
+            nbits -= node.terminalBits;
+            node = root;
+        }
+
+        return baos.toByteArray();
     }
-  }
-
-  private void addCode(int sym, int code, byte len) {
-    Node terminal = new Node(sym, len);
-
-    Node current = root;
-    while (len > 8) {
-      len -= 8;
-      int i = ((code >>> len) & 0xFF);
-      if (current.children == null) {
-        throw new IllegalStateException("invalid dictionary: prefix not unique");
-      }
-      if (current.children[i] == null) {
-        current.children[i] = new Node();
-      }
-      current = current.children[i];
+
+    private void buildTree() {
+        for (int i = 0; i < CODE_LENGTHS.length; i++) {
+            addCode(i, CODES[i], CODE_LENGTHS[i]);
+        }
     }
 
-    int shift = 8 - len;
-    int start = (code << shift) & 0xFF;
-    int end = 1 << shift;
-    for (int i = start; i < start + end; i++) {
-      current.children[i] = terminal;
+    private void addCode(int sym, int code, byte len) {
+        Node terminal = new Node(sym, len);
+
+        Node current = root;
+        while (len > 8) {
+            len -= 8;
+            int i = ((code >>> len) & 0xFF);
+            if (current.children == null) {
+                throw new IllegalStateException("invalid dictionary: prefix not unique");
+            }
+            if (current.children[i] == null) {
+                current.children[i] = new Node();
+            }
+            current = current.children[i];
+        }
+
+        int shift = 8 - len;
+        int start = (code << shift) & 0xFF;
+        int end = 1 << shift;
+        for (int i = start; i < start + end; i++) {
+            current.children[i] = terminal;
+        }
     }
-  }
 
-  private static final class Node {
+    private static final class Node {
 
-    // Null if terminal.
-    private final Node[] children;
+        // Null if terminal.
+        private final Node[] children;
 
-    // Terminal nodes have a symbol.
-    private final int symbol;
+        // Terminal nodes have a symbol.
+        private final int symbol;
 
-    // Number of bits represented in the terminal node.
-    private final int terminalBits;
+        // Number of bits represented in the terminal node.
+        private final int terminalBits;
 
-    /** Construct an internal node. */
-    Node() {
-      this.children = new Node[256];
-      this.symbol = 0; // Not read.
-      this.terminalBits = 0; // Not read.
-    }
+        /**
+         * Construct an internal node.
+         */
+        Node() {
+            this.children = new Node[256];
+            this.symbol = 0; // Not read.
+            this.terminalBits = 0; // Not read.
+        }
 
-    /**
-     * Construct a terminal node.
-     *
-     * @param symbol symbol the node represents
-     * @param bits length of Huffman code in bits
-     */
-    Node(int symbol, int bits) {
-      this.children = null;
-      this.symbol = symbol;
-      int b = bits & 0x07;
-      this.terminalBits = b == 0 ? 8 : b;
+        /**
+         * Construct a terminal node.
+         *
+         * @param symbol symbol the node represents
+         * @param bits   length of Huffman code in bits
+         */
+        Node(int symbol, int bits) {
+            this.children = null;
+            this.symbol = symbol;
+            int b = bits & 0x07;
+            this.terminalBits = b == 0 ? 8 : b;
+        }
     }
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/IncomingStreamHandler.java b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/IncomingStreamHandler.java
index 57863df113..c492ad5dfa 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/IncomingStreamHandler.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/IncomingStreamHandler.java
@@ -18,19 +18,22 @@
 
 import java.io.IOException;
 
-/** Listener to be notified when a connected peer creates a new stream. */
+/**
+ * Listener to be notified when a connected peer creates a new stream.
+ */
 public interface IncomingStreamHandler {
-  IncomingStreamHandler REFUSE_INCOMING_STREAMS = new IncomingStreamHandler() {
-    @Override public void receive(FramedStream stream) throws IOException {
-      stream.close(ErrorCode.REFUSED_STREAM);
-    }
-  };
+    IncomingStreamHandler REFUSE_INCOMING_STREAMS = new IncomingStreamHandler() {
+        @Override
+        public void receive(FramedStream stream) throws IOException {
+            stream.close(ErrorCode.REFUSED_STREAM);
+        }
+    };
 
-  /**
-   * Handle a new stream from this connection's peer. Implementations should
-   * respond by either {@link FramedStream#reply replying to the stream} or
-   * {@link FramedStream#close closing it}. This response does not need to be
-   * synchronous.
-   */
-  void receive(FramedStream stream) throws IOException;
+    /**
+     * Handle a new stream from this connection's peer. Implementations should
+     * respond by either {@link FramedStream#reply replying to the stream} or
+     * {@link FramedStream#close closing it}. This response does not need to be
+     * synchronous.
+     */
+    void receive(FramedStream stream) throws IOException;
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/NameValueBlockReader.java b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/NameValueBlockReader.java
index d9554a361b..185372dd56 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/NameValueBlockReader.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/NameValueBlockReader.java
@@ -20,6 +20,7 @@
 import java.util.List;
 import java.util.zip.DataFormatException;
 import java.util.zip.Inflater;
+
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.ByteString;
@@ -35,84 +36,91 @@
  * bytes.
  */
 class NameValueBlockReader {
-  /** This source transforms compressed bytes into uncompressed bytes. */
-  private final InflaterSource inflaterSource;
+    /**
+     * This source transforms compressed bytes into uncompressed bytes.
+     */
+    private final InflaterSource inflaterSource;
 
-  /**
-   * How many compressed bytes must be read into inflaterSource before
-   * {@link #readNameValueBlock} returns.
-   */
-  private int compressedLimit;
+    /**
+     * How many compressed bytes must be read into inflaterSource before
+     * {@link #readNameValueBlock} returns.
+     */
+    private int compressedLimit;
 
-  /** This source holds inflated bytes. */
-  private final BufferedSource source;
+    /**
+     * This source holds inflated bytes.
+     */
+    private final BufferedSource source;
 
-  public NameValueBlockReader(BufferedSource source) {
-    // Limit the inflater input stream to only those bytes in the Name/Value
-    // block. We cut the inflater off at its source because we can't predict the
-    // ratio of compressed bytes to uncompressed bytes.
-    Source throttleSource = new ForwardingSource(source) {
-      @Override public long read(Buffer sink, long byteCount) throws IOException {
-        if (compressedLimit == 0) return -1; // Out of data for the current block.
-        long read = super.read(sink, Math.min(byteCount, compressedLimit));
-        if (read == -1) return -1;
-        compressedLimit -= read;
-        return read;
-      }
-    };
+    public NameValueBlockReader(BufferedSource source) {
+        // Limit the inflater input stream to only those bytes in the Name/Value
+        // block. We cut the inflater off at its source because we can't predict the
+        // ratio of compressed bytes to uncompressed bytes.
+        Source throttleSource = new ForwardingSource(source) {
+            @Override
+            public long read(Buffer sink, long byteCount) throws IOException {
+                if (compressedLimit == 0) return -1; // Out of data for the current block.
+                long read = super.read(sink, Math.min(byteCount, compressedLimit));
+                if (read == -1) return -1;
+                compressedLimit -= read;
+                return read;
+            }
+        };
 
-    // Subclass inflater to install a dictionary when it's needed.
-    Inflater inflater = new Inflater() {
-      @Override public int inflate(byte[] buffer, int offset, int count)
-          throws DataFormatException {
-        int result = super.inflate(buffer, offset, count);
-        if (result == 0 && needsDictionary()) {
-          setDictionary(Spdy3.DICTIONARY);
-          result = super.inflate(buffer, offset, count);
-        }
-        return result;
-      }
-    };
+        // Subclass inflater to install a dictionary when it's needed.
+        Inflater inflater = new Inflater() {
+            @Override
+            public int inflate(byte[] buffer, int offset, int count)
+                    throws DataFormatException {
+                int result = super.inflate(buffer, offset, count);
+                if (result == 0 && needsDictionary()) {
+                    setDictionary(Spdy3.DICTIONARY);
+                    result = super.inflate(buffer, offset, count);
+                }
+                return result;
+            }
+        };
 
-    this.inflaterSource = new InflaterSource(throttleSource, inflater);
-    this.source = Okio.buffer(inflaterSource);
-  }
+        this.inflaterSource = new InflaterSource(throttleSource, inflater);
+        this.source = Okio.buffer(inflaterSource);
+    }
 
-  public List<Header> readNameValueBlock(int length) throws IOException {
-    this.compressedLimit += length;
+    public List<Header> readNameValueBlock(int length) throws IOException {
+        this.compressedLimit += length;
 
-    int numberOfPairs = source.readInt();
-    if (numberOfPairs < 0) throw new IOException("numberOfPairs < 0: " + numberOfPairs);
-    if (numberOfPairs > 1024) throw new IOException("numberOfPairs > 1024: " + numberOfPairs);
+        int numberOfPairs = source.readInt();
+        if (numberOfPairs < 0) throw new IOException("numberOfPairs < 0: " + numberOfPairs);
+        if (numberOfPairs > 1024) throw new IOException("numberOfPairs > 1024: " + numberOfPairs);
 
-    List<Header> entries = new ArrayList<>(numberOfPairs);
-    for (int i = 0; i < numberOfPairs; i++) {
-      ByteString name = readByteString().toAsciiLowercase();
-      ByteString values = readByteString();
-      if (name.size() == 0) throw new IOException("name.size == 0");
-      entries.add(new Header(name, values));
-    }
+        List<Header> entries = new ArrayList<>(numberOfPairs);
+        for (int i = 0; i < numberOfPairs; i++) {
+            ByteString name = readByteString().toAsciiLowercase();
+            ByteString values = readByteString();
+            if (name.size() == 0) throw new IOException("name.size == 0");
+            entries.add(new Header(name, values));
+        }
 
-    doneReading();
-    return entries;
-  }
+        doneReading();
+        return entries;
+    }
 
-  private ByteString readByteString() throws IOException {
-    int length = source.readInt();
-    return source.readByteString(length);
-  }
+    private ByteString readByteString() throws IOException {
+        int length = source.readInt();
+        return source.readByteString(length);
+    }
 
-  private void doneReading() throws IOException {
-    // Move any outstanding unread bytes into the inflater. One side-effect of
-    // deflate compression is that sometimes there are bytes remaining in the
-    // stream after we've consumed all of the content.
-    if (compressedLimit > 0) {
-      inflaterSource.refill();
-      if (compressedLimit != 0) throw new IOException("compressedLimit > 0: " + compressedLimit);
+    private void doneReading() throws IOException {
+        // Move any outstanding unread bytes into the inflater. One side-effect of
+        // deflate compression is that sometimes there are bytes remaining in the
+        // stream after we've consumed all of the content.
+        if (compressedLimit > 0) {
+            inflaterSource.refill();
+            if (compressedLimit != 0)
+                throw new IOException("compressedLimit > 0: " + compressedLimit);
+        }
     }
-  }
 
-  public void close() throws IOException {
-    source.close();
-  }
+    public void close() throws IOException {
+        source.close();
+    }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Ping.java b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Ping.java
index 35f9cf5be6..1a2173f57f 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Ping.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Ping.java
@@ -22,50 +22,50 @@
  * A locally-originated ping.
  */
 public final class Ping {
-  private final CountDownLatch latch = new CountDownLatch(1);
-  private long sent = -1;
-  private long received = -1;
+    private final CountDownLatch latch = new CountDownLatch(1);
+    private long sent = -1;
+    private long received = -1;
 
-  Ping() {
-  }
+    Ping() {
+    }
 
-  void send() {
-    if (sent != -1) throw new IllegalStateException();
-    sent = System.nanoTime();
-  }
+    void send() {
+        if (sent != -1) throw new IllegalStateException();
+        sent = System.nanoTime();
+    }
 
-  void receive() {
-    if (received != -1 || sent == -1) throw new IllegalStateException();
-    received = System.nanoTime();
-    latch.countDown();
-  }
+    void receive() {
+        if (received != -1 || sent == -1) throw new IllegalStateException();
+        received = System.nanoTime();
+        latch.countDown();
+    }
 
-  void cancel() {
-    if (received != -1 || sent == -1) throw new IllegalStateException();
-    received = sent - 1;
-    latch.countDown();
-  }
+    void cancel() {
+        if (received != -1 || sent == -1) throw new IllegalStateException();
+        received = sent - 1;
+        latch.countDown();
+    }
 
-  /**
-   * Returns the round trip time for this ping in nanoseconds, waiting for the
-   * response to arrive if necessary. Returns -1 if the response was
-   * canceled.
-   */
-  public long roundTripTime() throws InterruptedException {
-    latch.await();
-    return received - sent;
-  }
+    /**
+     * Returns the round trip time for this ping in nanoseconds, waiting for the
+     * response to arrive if necessary. Returns -1 if the response was
+     * canceled.
+     */
+    public long roundTripTime() throws InterruptedException {
+        latch.await();
+        return received - sent;
+    }
 
-  /**
-   * Returns the round trip time for this ping in nanoseconds, or -1 if the
-   * response was canceled, or -2 if the timeout elapsed before the round
-   * trip completed.
-   */
-  public long roundTripTime(long timeout, TimeUnit unit) throws InterruptedException {
-    if (latch.await(timeout, unit)) {
-      return received - sent;
-    } else {
-      return -2;
+    /**
+     * Returns the round trip time for this ping in nanoseconds, or -1 if the
+     * response was canceled, or -2 if the timeout elapsed before the round
+     * trip completed.
+     */
+    public long roundTripTime(long timeout, TimeUnit unit) throws InterruptedException {
+        if (latch.await(timeout, unit)) {
+            return received - sent;
+        } else {
+            return -2;
+        }
     }
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/PushObserver.java b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/PushObserver.java
index 33ebc617e3..30cd2892f9 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/PushObserver.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/PushObserver.java
@@ -17,79 +17,86 @@
 
 import java.io.IOException;
 import java.util.List;
+
 import okio.BufferedSource;
 
 /**
  * {@link com.squareup.okhttp.Protocol#HTTP_2 HTTP/2} only.
  * Processes server-initiated HTTP requests on the client. Implementations must
  * quickly dispatch callbacks to avoid creating a bottleneck.
- *
+ * <p/>
  * <p>While {@link #onReset} may occur at any time, the following callbacks are
  * expected in order, correlated by stream ID.
  * <ul>
- *   <li>{@link #onRequest}</li>
- *   <li>{@link #onHeaders} (unless canceled)</li>
- *   <li>{@link #onData} (optional sequence of data frames)</li>
+ * <li>{@link #onRequest}</li>
+ * <li>{@link #onHeaders} (unless canceled)</li>
+ * <li>{@link #onData} (optional sequence of data frames)</li>
  * </ul>
- *
+ * <p/>
  * <p>As a stream ID is scoped to a single HTTP/2 connection, implementations
  * which target multiple connections should expect repetition of stream IDs.
- *
+ * <p/>
  * <p>Return true to request cancellation of a pushed stream.  Note that this
  * does not guarantee future frames won't arrive on the stream ID.
  */
 public interface PushObserver {
-  /**
-   * Describes the request that the server intends to push a response for.
-   *
-   * @param streamId server-initiated stream ID: an even number.
-   * @param requestHeaders minimally includes {@code :method}, {@code :scheme},
-   * {@code :authority}, and (@code :path}.
-   */
-  boolean onRequest(int streamId, List<Header> requestHeaders);
+    /**
+     * Describes the request that the server intends to push a response for.
+     *
+     * @param streamId       server-initiated stream ID: an even number.
+     * @param requestHeaders minimally includes {@code :method}, {@code :scheme},
+     *                       {@code :authority}, and (@code :path}.
+     */
+    boolean onRequest(int streamId, List<Header> requestHeaders);
 
-  /**
-   * The response headers corresponding to a pushed request.  When {@code last}
-   * is true, there are no data frames to follow.
-   *
-   * @param streamId server-initiated stream ID: an even number.
-   * @param responseHeaders minimally includes {@code :status}.
-   * @param last when true, there is no response data.
-   */
-  boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last);
+    /**
+     * The response headers corresponding to a pushed request.  When {@code last}
+     * is true, there are no data frames to follow.
+     *
+     * @param streamId        server-initiated stream ID: an even number.
+     * @param responseHeaders minimally includes {@code :status}.
+     * @param last            when true, there is no response data.
+     */
+    boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last);
 
-  /**
-   * A chunk of response data corresponding to a pushed request.  This data
-   * must either be read or skipped.
-   *
-   * @param streamId server-initiated stream ID: an even number.
-   * @param source location of data corresponding with this stream ID.
-   * @param byteCount number of bytes to read or skip from the source.
-   * @param last when true, there are no data frames to follow.
-   */
-  boolean onData(int streamId, BufferedSource source, int byteCount, boolean last)
-      throws IOException;
+    /**
+     * A chunk of response data corresponding to a pushed request.  This data
+     * must either be read or skipped.
+     *
+     * @param streamId  server-initiated stream ID: an even number.
+     * @param source    location of data corresponding with this stream ID.
+     * @param byteCount number of bytes to read or skip from the source.
+     * @param last      when true, there are no data frames to follow.
+     */
+    boolean onData(int streamId, BufferedSource source, int byteCount, boolean last)
+            throws IOException;
 
-  /** Indicates the reason why this stream was canceled. */
-  void onReset(int streamId, ErrorCode errorCode);
+    /**
+     * Indicates the reason why this stream was canceled.
+     */
+    void onReset(int streamId, ErrorCode errorCode);
 
-  PushObserver CANCEL = new PushObserver() {
+    PushObserver CANCEL = new PushObserver() {
 
-    @Override public boolean onRequest(int streamId, List<Header> requestHeaders) {
-      return true;
-    }
+        @Override
+        public boolean onRequest(int streamId, List<Header> requestHeaders) {
+            return true;
+        }
 
-    @Override public boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last) {
-      return true;
-    }
+        @Override
+        public boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last) {
+            return true;
+        }
 
-    @Override public boolean onData(int streamId, BufferedSource source, int byteCount,
-        boolean last) throws IOException {
-      source.skip(byteCount);
-      return true;
-    }
+        @Override
+        public boolean onData(int streamId, BufferedSource source, int byteCount,
+                              boolean last) throws IOException {
+            source.skip(byteCount);
+            return true;
+        }
 
-    @Override public void onReset(int streamId, ErrorCode errorCode) {
-    }
-  };
+        @Override
+        public void onReset(int streamId, ErrorCode errorCode) {
+        }
+    };
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Settings.java b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Settings.java
index 935d489045..6729bc3b06 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Settings.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Settings.java
@@ -22,218 +22,292 @@
  * Settings are {@link FramedConnection connection} scoped.
  */
 public final class Settings {
-  /**
-   * From the SPDY/3 and HTTP/2 specs, the default initial window size for all
-   * streams is 64 KiB. (Chrome 25 uses 10 MiB).
-   */
-  static final int DEFAULT_INITIAL_WINDOW_SIZE = 64 * 1024;
-
-  /** Peer request to clear durable settings. */
-  static final int FLAG_CLEAR_PREVIOUSLY_PERSISTED_SETTINGS = 0x1;
-
-  /** Sent by servers only. The peer requests this setting persisted for future connections. */
-  static final int PERSIST_VALUE = 0x1;
-  /** Sent by clients only. The client is reminding the server of a persisted value. */
-  static final int PERSISTED = 0x2;
-
-  /** spdy/3: Sender's estimate of max incoming kbps. */
-  static final int UPLOAD_BANDWIDTH = 1;
-  /** HTTP/2: Size in bytes of the table used to decode the sender's header blocks. */
-  static final int HEADER_TABLE_SIZE = 1;
-  /** spdy/3: Sender's estimate of max outgoing kbps. */
-  static final int DOWNLOAD_BANDWIDTH = 2;
-  /** HTTP/2: The peer must not send a PUSH_PROMISE frame when this is 0. */
-  static final int ENABLE_PUSH = 2;
-  /** spdy/3: Sender's estimate of millis between sending a request and receiving a response. */
-  static final int ROUND_TRIP_TIME = 3;
-  /** Sender's maximum number of concurrent streams. */
-  static final int MAX_CONCURRENT_STREAMS = 4;
-  /** spdy/3: Current CWND in Packets. */
-  static final int CURRENT_CWND = 5;
-  /** HTTP/2: Size in bytes of the largest frame payload the sender will accept. */
-  static final int MAX_FRAME_SIZE = 5;
-  /** spdy/3: Retransmission rate. Percentage */
-  static final int DOWNLOAD_RETRANS_RATE = 6;
-  /** HTTP/2: Advisory only. Size in bytes of the largest header list the sender will accept. */
-  static final int MAX_HEADER_LIST_SIZE = 6;
-  /** Window size in bytes. */
-  static final int INITIAL_WINDOW_SIZE = 7;
-  /** spdy/3: Size of the client certificate vector. Unsupported. */
-  static final int CLIENT_CERTIFICATE_VECTOR_SIZE = 8;
-  /** Flow control options. */
-  static final int FLOW_CONTROL_OPTIONS = 10;
-
-  /** Total number of settings. */
-  static final int COUNT = 10;
-
-  /** If set, flow control is disabled for streams directed to the sender of these settings. */
-  static final int FLOW_CONTROL_OPTIONS_DISABLED = 0x1;
-
-  /** Bitfield of which flags that values. */
-  private int set;
-
-  /** Bitfield of flags that have {@link #PERSIST_VALUE}. */
-  private int persistValue;
-
-  /** Bitfield of flags that have {@link #PERSISTED}. */
-  private int persisted;
-
-  /** Flag values. */
-  private final int[] values = new int[COUNT];
-
-  void clear() {
-    set = persistValue = persisted = 0;
-    Arrays.fill(values, 0);
-  }
-
-  Settings set(int id, int idFlags, int value) {
-    if (id >= values.length) {
-      return this; // Discard unknown settings.
-    }
-
-    int bit = 1 << id;
-    set |= bit;
-    if ((idFlags & PERSIST_VALUE) != 0) {
-      persistValue |= bit;
-    } else {
-      persistValue &= ~bit;
-    }
-    if ((idFlags & PERSISTED) != 0) {
-      persisted |= bit;
-    } else {
-      persisted &= ~bit;
-    }
-
-    values[id] = value;
-    return this;
-  }
-
-  /** Returns true if a value has been assigned for the setting {@code id}. */
-  boolean isSet(int id) {
-    int bit = 1 << id;
-    return (set & bit) != 0;
-  }
-
-  /** Returns the value for the setting {@code id}, or 0 if unset. */
-  int get(int id) {
-    return values[id];
-  }
-
-  /** Returns the flags for the setting {@code id}, or 0 if unset. */
-  int flags(int id) {
-    int result = 0;
-    if (isPersisted(id)) result |= Settings.PERSISTED;
-    if (persistValue(id)) result |= Settings.PERSIST_VALUE;
-    return result;
-  }
-
-  /** Returns the number of settings that have values assigned. */
-  int size() {
-    return Integer.bitCount(set);
-  }
-
-  /** spdy/3 only. */
-  int getUploadBandwidth(int defaultValue) {
-    int bit = 1 << UPLOAD_BANDWIDTH;
-    return (bit & set) != 0 ? values[UPLOAD_BANDWIDTH] : defaultValue;
-  }
-
-  /** HTTP/2 only. Returns -1 if unset. */
-  int getHeaderTableSize() {
-    int bit = 1 << HEADER_TABLE_SIZE;
-    return (bit & set) != 0 ? values[HEADER_TABLE_SIZE] : -1;
-  }
-
-  /** spdy/3 only. */
-  int getDownloadBandwidth(int defaultValue) {
-    int bit = 1 << DOWNLOAD_BANDWIDTH;
-    return (bit & set) != 0 ? values[DOWNLOAD_BANDWIDTH] : defaultValue;
-  }
-
-  /** HTTP/2 only. */
-  // TODO: honor this setting in HTTP/2.
-  boolean getEnablePush(boolean defaultValue) {
-    int bit = 1 << ENABLE_PUSH;
-    return ((bit & set) != 0 ? values[ENABLE_PUSH] : defaultValue ? 1 : 0) == 1;
-  }
-
-  /** spdy/3 only. */
-  int getRoundTripTime(int defaultValue) {
-    int bit = 1 << ROUND_TRIP_TIME;
-    return (bit & set) != 0 ? values[ROUND_TRIP_TIME] : defaultValue;
-  }
-
-  // TODO: honor this setting in spdy/3 and HTTP/2.
-  int getMaxConcurrentStreams(int defaultValue) {
-    int bit = 1 << MAX_CONCURRENT_STREAMS;
-    return (bit & set) != 0 ? values[MAX_CONCURRENT_STREAMS] : defaultValue;
-  }
-
-  /** spdy/3 only. */
-  int getCurrentCwnd(int defaultValue) {
-    int bit = 1 << CURRENT_CWND;
-    return (bit & set) != 0 ? values[CURRENT_CWND] : defaultValue;
-  }
-
-  /** HTTP/2 only. */
-  int getMaxFrameSize(int defaultValue) {
-    int bit = 1 << MAX_FRAME_SIZE;
-    return (bit & set) != 0 ? values[MAX_FRAME_SIZE] : defaultValue;
-  }
-
-  /** spdy/3 only. */
-  int getDownloadRetransRate(int defaultValue) {
-    int bit = 1 << DOWNLOAD_RETRANS_RATE;
-    return (bit & set) != 0 ? values[DOWNLOAD_RETRANS_RATE] : defaultValue;
-  }
-
-  /** HTTP/2 only. */
-  int getMaxHeaderListSize(int defaultValue) {
-    int bit = 1 << MAX_HEADER_LIST_SIZE;
-    return (bit & set) != 0 ? values[MAX_HEADER_LIST_SIZE] : defaultValue;
-  }
-
-  int getInitialWindowSize(int defaultValue) {
-    int bit = 1 << INITIAL_WINDOW_SIZE;
-    return (bit & set) != 0 ? values[INITIAL_WINDOW_SIZE] : defaultValue;
-  }
-
-  /** spdy/3 only. */
-  int getClientCertificateVectorSize(int defaultValue) {
-    int bit = 1 << CLIENT_CERTIFICATE_VECTOR_SIZE;
-    return (bit & set) != 0 ? values[CLIENT_CERTIFICATE_VECTOR_SIZE] : defaultValue;
-  }
-
-  // TODO: honor this setting in spdy/3 and HTTP/2.
-  boolean isFlowControlDisabled() {
-    int bit = 1 << FLOW_CONTROL_OPTIONS;
-    int value = (bit & set) != 0 ? values[FLOW_CONTROL_OPTIONS] : 0;
-    return (value & FLOW_CONTROL_OPTIONS_DISABLED) != 0;
-  }
-
-  /**
-   * Returns true if this user agent should use this setting in future spdy/3
-   * connections to the same host.
-   */
-  boolean persistValue(int id) {
-    int bit = 1 << id;
-    return (persistValue & bit) != 0;
-  }
-
-  /** Returns true if this setting was persisted. */
-  boolean isPersisted(int id) {
-    int bit = 1 << id;
-    return (persisted & bit) != 0;
-  }
-
-  /**
-   * Writes {@code other} into this. If any setting is populated by this and
-   * {@code other}, the value and flags from {@code other} will be kept.
-   */
-  void merge(Settings other) {
-    for (int i = 0; i < COUNT; i++) {
-      if (!other.isSet(i)) continue;
-      set(i, other.flags(i), other.get(i));
-    }
-  }
+    /**
+     * From the SPDY/3 and HTTP/2 specs, the default initial window size for all
+     * streams is 64 KiB. (Chrome 25 uses 10 MiB).
+     */
+    static final int DEFAULT_INITIAL_WINDOW_SIZE = 64 * 1024;
+
+    /**
+     * Peer request to clear durable settings.
+     */
+    static final int FLAG_CLEAR_PREVIOUSLY_PERSISTED_SETTINGS = 0x1;
+
+    /**
+     * Sent by servers only. The peer requests this setting persisted for future connections.
+     */
+    static final int PERSIST_VALUE = 0x1;
+    /**
+     * Sent by clients only. The client is reminding the server of a persisted value.
+     */
+    static final int PERSISTED = 0x2;
+
+    /**
+     * spdy/3: Sender's estimate of max incoming kbps.
+     */
+    static final int UPLOAD_BANDWIDTH = 1;
+    /**
+     * HTTP/2: Size in bytes of the table used to decode the sender's header blocks.
+     */
+    static final int HEADER_TABLE_SIZE = 1;
+    /**
+     * spdy/3: Sender's estimate of max outgoing kbps.
+     */
+    static final int DOWNLOAD_BANDWIDTH = 2;
+    /**
+     * HTTP/2: The peer must not send a PUSH_PROMISE frame when this is 0.
+     */
+    static final int ENABLE_PUSH = 2;
+    /**
+     * spdy/3: Sender's estimate of millis between sending a request and receiving a response.
+     */
+    static final int ROUND_TRIP_TIME = 3;
+    /**
+     * Sender's maximum number of concurrent streams.
+     */
+    static final int MAX_CONCURRENT_STREAMS = 4;
+    /**
+     * spdy/3: Current CWND in Packets.
+     */
+    static final int CURRENT_CWND = 5;
+    /**
+     * HTTP/2: Size in bytes of the largest frame payload the sender will accept.
+     */
+    static final int MAX_FRAME_SIZE = 5;
+    /**
+     * spdy/3: Retransmission rate. Percentage
+     */
+    static final int DOWNLOAD_RETRANS_RATE = 6;
+    /**
+     * HTTP/2: Advisory only. Size in bytes of the largest header list the sender will accept.
+     */
+    static final int MAX_HEADER_LIST_SIZE = 6;
+    /**
+     * Window size in bytes.
+     */
+    static final int INITIAL_WINDOW_SIZE = 7;
+    /**
+     * spdy/3: Size of the client certificate vector. Unsupported.
+     */
+    static final int CLIENT_CERTIFICATE_VECTOR_SIZE = 8;
+    /**
+     * Flow control options.
+     */
+    static final int FLOW_CONTROL_OPTIONS = 10;
+
+    /**
+     * Total number of settings.
+     */
+    static final int COUNT = 10;
+
+    /**
+     * If set, flow control is disabled for streams directed to the sender of these settings.
+     */
+    static final int FLOW_CONTROL_OPTIONS_DISABLED = 0x1;
+
+    /**
+     * Bitfield of which flags that values.
+     */
+    private int set;
+
+    /**
+     * Bitfield of flags that have {@link #PERSIST_VALUE}.
+     */
+    private int persistValue;
+
+    /**
+     * Bitfield of flags that have {@link #PERSISTED}.
+     */
+    private int persisted;
+
+    /**
+     * Flag values.
+     */
+    private final int[] values = new int[COUNT];
+
+    void clear() {
+        set = persistValue = persisted = 0;
+        Arrays.fill(values, 0);
+    }
+
+    Settings set(int id, int idFlags, int value) {
+        if (id >= values.length) {
+            return this; // Discard unknown settings.
+        }
+
+        int bit = 1 << id;
+        set |= bit;
+        if ((idFlags & PERSIST_VALUE) != 0) {
+            persistValue |= bit;
+        } else {
+            persistValue &= ~bit;
+        }
+        if ((idFlags & PERSISTED) != 0) {
+            persisted |= bit;
+        } else {
+            persisted &= ~bit;
+        }
+
+        values[id] = value;
+        return this;
+    }
+
+    /**
+     * Returns true if a value has been assigned for the setting {@code id}.
+     */
+    boolean isSet(int id) {
+        int bit = 1 << id;
+        return (set & bit) != 0;
+    }
+
+    /**
+     * Returns the value for the setting {@code id}, or 0 if unset.
+     */
+    int get(int id) {
+        return values[id];
+    }
+
+    /**
+     * Returns the flags for the setting {@code id}, or 0 if unset.
+     */
+    int flags(int id) {
+        int result = 0;
+        if (isPersisted(id)) result |= Settings.PERSISTED;
+        if (persistValue(id)) result |= Settings.PERSIST_VALUE;
+        return result;
+    }
+
+    /**
+     * Returns the number of settings that have values assigned.
+     */
+    int size() {
+        return Integer.bitCount(set);
+    }
+
+    /**
+     * spdy/3 only.
+     */
+    int getUploadBandwidth(int defaultValue) {
+        int bit = 1 << UPLOAD_BANDWIDTH;
+        return (bit & set) != 0 ? values[UPLOAD_BANDWIDTH] : defaultValue;
+    }
+
+    /**
+     * HTTP/2 only. Returns -1 if unset.
+     */
+    int getHeaderTableSize() {
+        int bit = 1 << HEADER_TABLE_SIZE;
+        return (bit & set) != 0 ? values[HEADER_TABLE_SIZE] : -1;
+    }
+
+    /**
+     * spdy/3 only.
+     */
+    int getDownloadBandwidth(int defaultValue) {
+        int bit = 1 << DOWNLOAD_BANDWIDTH;
+        return (bit & set) != 0 ? values[DOWNLOAD_BANDWIDTH] : defaultValue;
+    }
+
+    /**
+     * HTTP/2 only.
+     */
+    // TODO: honor this setting in HTTP/2.
+    boolean getEnablePush(boolean defaultValue) {
+        int bit = 1 << ENABLE_PUSH;
+        return ((bit & set) != 0 ? values[ENABLE_PUSH] : defaultValue ? 1 : 0) == 1;
+    }
+
+    /**
+     * spdy/3 only.
+     */
+    int getRoundTripTime(int defaultValue) {
+        int bit = 1 << ROUND_TRIP_TIME;
+        return (bit & set) != 0 ? values[ROUND_TRIP_TIME] : defaultValue;
+    }
+
+    // TODO: honor this setting in spdy/3 and HTTP/2.
+    int getMaxConcurrentStreams(int defaultValue) {
+        int bit = 1 << MAX_CONCURRENT_STREAMS;
+        return (bit & set) != 0 ? values[MAX_CONCURRENT_STREAMS] : defaultValue;
+    }
+
+    /**
+     * spdy/3 only.
+     */
+    int getCurrentCwnd(int defaultValue) {
+        int bit = 1 << CURRENT_CWND;
+        return (bit & set) != 0 ? values[CURRENT_CWND] : defaultValue;
+    }
+
+    /**
+     * HTTP/2 only.
+     */
+    int getMaxFrameSize(int defaultValue) {
+        int bit = 1 << MAX_FRAME_SIZE;
+        return (bit & set) != 0 ? values[MAX_FRAME_SIZE] : defaultValue;
+    }
+
+    /**
+     * spdy/3 only.
+     */
+    int getDownloadRetransRate(int defaultValue) {
+        int bit = 1 << DOWNLOAD_RETRANS_RATE;
+        return (bit & set) != 0 ? values[DOWNLOAD_RETRANS_RATE] : defaultValue;
+    }
+
+    /**
+     * HTTP/2 only.
+     */
+    int getMaxHeaderListSize(int defaultValue) {
+        int bit = 1 << MAX_HEADER_LIST_SIZE;
+        return (bit & set) != 0 ? values[MAX_HEADER_LIST_SIZE] : defaultValue;
+    }
+
+    int getInitialWindowSize(int defaultValue) {
+        int bit = 1 << INITIAL_WINDOW_SIZE;
+        return (bit & set) != 0 ? values[INITIAL_WINDOW_SIZE] : defaultValue;
+    }
+
+    /**
+     * spdy/3 only.
+     */
+    int getClientCertificateVectorSize(int defaultValue) {
+        int bit = 1 << CLIENT_CERTIFICATE_VECTOR_SIZE;
+        return (bit & set) != 0 ? values[CLIENT_CERTIFICATE_VECTOR_SIZE] : defaultValue;
+    }
+
+    // TODO: honor this setting in spdy/3 and HTTP/2.
+    boolean isFlowControlDisabled() {
+        int bit = 1 << FLOW_CONTROL_OPTIONS;
+        int value = (bit & set) != 0 ? values[FLOW_CONTROL_OPTIONS] : 0;
+        return (value & FLOW_CONTROL_OPTIONS_DISABLED) != 0;
+    }
+
+    /**
+     * Returns true if this user agent should use this setting in future spdy/3
+     * connections to the same host.
+     */
+    boolean persistValue(int id) {
+        int bit = 1 << id;
+        return (persistValue & bit) != 0;
+    }
+
+    /**
+     * Returns true if this setting was persisted.
+     */
+    boolean isPersisted(int id) {
+        int bit = 1 << id;
+        return (persisted & bit) != 0;
+    }
+
+    /**
+     * Writes {@code other} into this. If any setting is populated by this and
+     * {@code other}, the value and flags from {@code other} will be kept.
+     */
+    void merge(Settings other) {
+        for (int i = 0; i < COUNT; i++) {
+            if (!other.isSet(i)) continue;
+            set(i, other.flags(i), other.get(i));
+        }
+    }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Spdy3.java b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Spdy3.java
index cdb82c2a10..1ba9388330 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Spdy3.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Spdy3.java
@@ -17,11 +17,13 @@
 
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.internal.Util;
+
 import java.io.IOException;
 import java.io.UnsupportedEncodingException;
 import java.net.ProtocolException;
 import java.util.List;
 import java.util.zip.Deflater;
+
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -35,458 +37,483 @@
  */
 public final class Spdy3 implements Variant {
 
-  @Override public Protocol getProtocol() {
-    return Protocol.SPDY_3;
-  }
-
-  static final int TYPE_DATA = 0x0;
-  static final int TYPE_SYN_STREAM = 0x1;
-  static final int TYPE_SYN_REPLY = 0x2;
-  static final int TYPE_RST_STREAM = 0x3;
-  static final int TYPE_SETTINGS = 0x4;
-  static final int TYPE_PING = 0x6;
-  static final int TYPE_GOAWAY = 0x7;
-  static final int TYPE_HEADERS = 0x8;
-  static final int TYPE_WINDOW_UPDATE = 0x9;
-
-  static final int FLAG_FIN = 0x1;
-  static final int FLAG_UNIDIRECTIONAL = 0x2;
-
-  static final int VERSION = 3;
-
-  static final byte[] DICTIONARY;
-  static {
-    try {
-      DICTIONARY = ("\u0000\u0000\u0000\u0007options\u0000\u0000\u0000\u0004hea"
-          + "d\u0000\u0000\u0000\u0004post\u0000\u0000\u0000\u0003put\u0000\u0000\u0000\u0006dele"
-          + "te\u0000\u0000\u0000\u0005trace\u0000\u0000\u0000\u0006accept\u0000\u0000\u0000"
-          + "\u000Eaccept-charset\u0000\u0000\u0000\u000Faccept-encoding\u0000\u0000\u0000\u000Fa"
-          + "ccept-language\u0000\u0000\u0000\raccept-ranges\u0000\u0000\u0000\u0003age\u0000"
-          + "\u0000\u0000\u0005allow\u0000\u0000\u0000\rauthorization\u0000\u0000\u0000\rcache-co"
-          + "ntrol\u0000\u0000\u0000\nconnection\u0000\u0000\u0000\fcontent-base\u0000\u0000"
-          + "\u0000\u0010content-encoding\u0000\u0000\u0000\u0010content-language\u0000\u0000"
-          + "\u0000\u000Econtent-length\u0000\u0000\u0000\u0010content-location\u0000\u0000\u0000"
-          + "\u000Bcontent-md5\u0000\u0000\u0000\rcontent-range\u0000\u0000\u0000\fcontent-type"
-          + "\u0000\u0000\u0000\u0004date\u0000\u0000\u0000\u0004etag\u0000\u0000\u0000\u0006expe"
-          + "ct\u0000\u0000\u0000\u0007expires\u0000\u0000\u0000\u0004from\u0000\u0000\u0000"
-          + "\u0004host\u0000\u0000\u0000\bif-match\u0000\u0000\u0000\u0011if-modified-since"
-          + "\u0000\u0000\u0000\rif-none-match\u0000\u0000\u0000\bif-range\u0000\u0000\u0000"
-          + "\u0013if-unmodified-since\u0000\u0000\u0000\rlast-modified\u0000\u0000\u0000\blocati"
-          + "on\u0000\u0000\u0000\fmax-forwards\u0000\u0000\u0000\u0006pragma\u0000\u0000\u0000"
-          + "\u0012proxy-authenticate\u0000\u0000\u0000\u0013proxy-authorization\u0000\u0000"
-          + "\u0000\u0005range\u0000\u0000\u0000\u0007referer\u0000\u0000\u0000\u000Bretry-after"
-          + "\u0000\u0000\u0000\u0006server\u0000\u0000\u0000\u0002te\u0000\u0000\u0000\u0007trai"
-          + "ler\u0000\u0000\u0000\u0011transfer-encoding\u0000\u0000\u0000\u0007upgrade\u0000"
-          + "\u0000\u0000\nuser-agent\u0000\u0000\u0000\u0004vary\u0000\u0000\u0000\u0003via"
-          + "\u0000\u0000\u0000\u0007warning\u0000\u0000\u0000\u0010www-authenticate\u0000\u0000"
-          + "\u0000\u0006method\u0000\u0000\u0000\u0003get\u0000\u0000\u0000\u0006status\u0000"
-          + "\u0000\u0000\u0006200 OK\u0000\u0000\u0000\u0007version\u0000\u0000\u0000\bHTTP/1.1"
-          + "\u0000\u0000\u0000\u0003url\u0000\u0000\u0000\u0006public\u0000\u0000\u0000\nset-coo"
-          + "kie\u0000\u0000\u0000\nkeep-alive\u0000\u0000\u0000\u0006origin100101201202205206300"
-          + "302303304305306307402405406407408409410411412413414415416417502504505203 Non-Authori"
-          + "tative Information204 No Content301 Moved Permanently400 Bad Request401 Unauthorized"
-          + "403 Forbidden404 Not Found500 Internal Server Error501 Not Implemented503 Service Un"
-          + "availableJan Feb Mar Apr May Jun Jul Aug Sept Oct Nov Dec 00:00:00 Mon, Tue, Wed, Th"
-          + "u, Fri, Sat, Sun, GMTchunked,text/html,image/png,image/jpg,image/gif,application/xml"
-          + ",application/xhtml+xml,text/plain,text/javascript,publicprivatemax-age=gzip,deflate,"
-          + "sdchcharset=utf-8charset=iso-8859-1,utf-,*,enq=0.").getBytes(Util.UTF_8.name());
-    } catch (UnsupportedEncodingException e) {
-      throw new AssertionError();
+    @Override
+    public Protocol getProtocol() {
+        return Protocol.SPDY_3;
+    }
+
+    static final int TYPE_DATA = 0x0;
+    static final int TYPE_SYN_STREAM = 0x1;
+    static final int TYPE_SYN_REPLY = 0x2;
+    static final int TYPE_RST_STREAM = 0x3;
+    static final int TYPE_SETTINGS = 0x4;
+    static final int TYPE_PING = 0x6;
+    static final int TYPE_GOAWAY = 0x7;
+    static final int TYPE_HEADERS = 0x8;
+    static final int TYPE_WINDOW_UPDATE = 0x9;
+
+    static final int FLAG_FIN = 0x1;
+    static final int FLAG_UNIDIRECTIONAL = 0x2;
+
+    static final int VERSION = 3;
+
+    static final byte[] DICTIONARY;
+
+    static {
+        try {
+            DICTIONARY = ("\u0000\u0000\u0000\u0007options\u0000\u0000\u0000\u0004hea"
+                    + "d\u0000\u0000\u0000\u0004post\u0000\u0000\u0000\u0003put\u0000\u0000\u0000\u0006dele"
+                    + "te\u0000\u0000\u0000\u0005trace\u0000\u0000\u0000\u0006accept\u0000\u0000\u0000"
+                    + "\u000Eaccept-charset\u0000\u0000\u0000\u000Faccept-encoding\u0000\u0000\u0000\u000Fa"
+                    + "ccept-language\u0000\u0000\u0000\raccept-ranges\u0000\u0000\u0000\u0003age\u0000"
+                    + "\u0000\u0000\u0005allow\u0000\u0000\u0000\rauthorization\u0000\u0000\u0000\rcache-co"
+                    + "ntrol\u0000\u0000\u0000\nconnection\u0000\u0000\u0000\fcontent-base\u0000\u0000"
+                    + "\u0000\u0010content-encoding\u0000\u0000\u0000\u0010content-language\u0000\u0000"
+                    + "\u0000\u000Econtent-length\u0000\u0000\u0000\u0010content-location\u0000\u0000\u0000"
+                    + "\u000Bcontent-md5\u0000\u0000\u0000\rcontent-range\u0000\u0000\u0000\fcontent-type"
+                    + "\u0000\u0000\u0000\u0004date\u0000\u0000\u0000\u0004etag\u0000\u0000\u0000\u0006expe"
+                    + "ct\u0000\u0000\u0000\u0007expires\u0000\u0000\u0000\u0004from\u0000\u0000\u0000"
+                    + "\u0004host\u0000\u0000\u0000\bif-match\u0000\u0000\u0000\u0011if-modified-since"
+                    + "\u0000\u0000\u0000\rif-none-match\u0000\u0000\u0000\bif-range\u0000\u0000\u0000"
+                    + "\u0013if-unmodified-since\u0000\u0000\u0000\rlast-modified\u0000\u0000\u0000\blocati"
+                    + "on\u0000\u0000\u0000\fmax-forwards\u0000\u0000\u0000\u0006pragma\u0000\u0000\u0000"
+                    + "\u0012proxy-authenticate\u0000\u0000\u0000\u0013proxy-authorization\u0000\u0000"
+                    + "\u0000\u0005range\u0000\u0000\u0000\u0007referer\u0000\u0000\u0000\u000Bretry-after"
+                    + "\u0000\u0000\u0000\u0006server\u0000\u0000\u0000\u0002te\u0000\u0000\u0000\u0007trai"
+                    + "ler\u0000\u0000\u0000\u0011transfer-encoding\u0000\u0000\u0000\u0007upgrade\u0000"
+                    + "\u0000\u0000\nuser-agent\u0000\u0000\u0000\u0004vary\u0000\u0000\u0000\u0003via"
+                    + "\u0000\u0000\u0000\u0007warning\u0000\u0000\u0000\u0010www-authenticate\u0000\u0000"
+                    + "\u0000\u0006method\u0000\u0000\u0000\u0003get\u0000\u0000\u0000\u0006status\u0000"
+                    + "\u0000\u0000\u0006200 OK\u0000\u0000\u0000\u0007version\u0000\u0000\u0000\bHTTP/1.1"
+                    + "\u0000\u0000\u0000\u0003url\u0000\u0000\u0000\u0006public\u0000\u0000\u0000\nset-coo"
+                    + "kie\u0000\u0000\u0000\nkeep-alive\u0000\u0000\u0000\u0006origin100101201202205206300"
+                    + "302303304305306307402405406407408409410411412413414415416417502504505203 Non-Authori"
+                    + "tative Information204 No Content301 Moved Permanently400 Bad Request401 Unauthorized"
+                    + "403 Forbidden404 Not Found500 Internal Server Error501 Not Implemented503 Service Un"
+                    + "availableJan Feb Mar Apr May Jun Jul Aug Sept Oct Nov Dec 00:00:00 Mon, Tue, Wed, Th"
+                    + "u, Fri, Sat, Sun, GMTchunked,text/html,image/png,image/jpg,image/gif,application/xml"
+                    + ",application/xhtml+xml,text/plain,text/javascript,publicprivatemax-age=gzip,deflate,"
+                    + "sdchcharset=utf-8charset=iso-8859-1,utf-,*,enq=0.").getBytes(Util.UTF_8.name());
+        } catch (UnsupportedEncodingException e) {
+            throw new AssertionError();
+        }
     }
-  }
-
-  @Override public FrameReader newReader(BufferedSource source, boolean client) {
-    return new Reader(source, client);
-  }
-
-  @Override public FrameWriter newWriter(BufferedSink sink, boolean client) {
-    return new Writer(sink, client);
-  }
-
-  /** Read spdy/3 frames. */
-  static final class Reader implements FrameReader {
-    private final BufferedSource source;
-    private final boolean client;
-    private final NameValueBlockReader headerBlockReader;
-
-    Reader(BufferedSource source, boolean client) {
-      this.source = source;
-      this.headerBlockReader = new NameValueBlockReader(this.source);
-      this.client = client;
+
+    @Override
+    public FrameReader newReader(BufferedSource source, boolean client) {
+        return new Reader(source, client);
     }
 
-    @Override public void readConnectionPreface() {
+    @Override
+    public FrameWriter newWriter(BufferedSink sink, boolean client) {
+        return new Writer(sink, client);
     }
 
     /**
-     * Send the next frame to {@code handler}. Returns true unless there are no
-     * more frames on the stream.
+     * Read spdy/3 frames.
      */
-    @Override public boolean nextFrame(Handler handler) throws IOException {
-      int w1;
-      int w2;
-      try {
-        w1 = source.readInt();
-        w2 = source.readInt();
-      } catch (IOException e) {
-        return false; // This might be a normal socket close.
-      }
-
-      boolean control = (w1 & 0x80000000) != 0;
-      int flags = (w2 & 0xff000000) >>> 24;
-      int length = (w2 & 0xffffff);
-
-      if (control) {
-        int version = (w1 & 0x7fff0000) >>> 16;
-        int type = (w1 & 0xffff);
-
-        if (version != 3) {
-          throw new ProtocolException("version != 3: " + version);
-        }
-
-        switch (type) {
-          case TYPE_SYN_STREAM:
-            readSynStream(handler, flags, length);
-            return true;
-
-          case TYPE_SYN_REPLY:
-            readSynReply(handler, flags, length);
-            return true;
-
-          case TYPE_RST_STREAM:
-            readRstStream(handler, flags, length);
-            return true;
-
-          case TYPE_SETTINGS:
-            readSettings(handler, flags, length);
-            return true;
-
-          case TYPE_PING:
-            readPing(handler, flags, length);
-            return true;
-
-          case TYPE_GOAWAY:
-            readGoAway(handler, flags, length);
-            return true;
-
-          case TYPE_HEADERS:
-            readHeaders(handler, flags, length);
-            return true;
-
-          case TYPE_WINDOW_UPDATE:
-            readWindowUpdate(handler, flags, length);
-            return true;
-
-          default:
-            source.skip(length);
-            return true;
-        }
-      } else {
-        int streamId = w1 & 0x7fffffff;
-        boolean inFinished = (flags & FLAG_FIN) != 0;
-        handler.data(inFinished, streamId, source, length);
-        return true;
-      }
-    }
+    static final class Reader implements FrameReader {
+        private final BufferedSource source;
+        private final boolean client;
+        private final NameValueBlockReader headerBlockReader;
+
+        Reader(BufferedSource source, boolean client) {
+            this.source = source;
+            this.headerBlockReader = new NameValueBlockReader(this.source);
+            this.client = client;
+        }
 
-    private void readSynStream(Handler handler, int flags, int length) throws IOException {
-      int w1 = source.readInt();
-      int w2 = source.readInt();
-      int streamId = w1 & 0x7fffffff;
-      int associatedStreamId = w2 & 0x7fffffff;
-      source.readShort(); // int priority = (s3 & 0xe000) >>> 13; int slot = s3 & 0xff;
-      List<Header> headerBlock = headerBlockReader.readNameValueBlock(length - 10);
-
-      boolean inFinished = (flags & FLAG_FIN) != 0;
-      boolean outFinished = (flags & FLAG_UNIDIRECTIONAL) != 0;
-      handler.headers(outFinished, inFinished, streamId, associatedStreamId, headerBlock,
-          HeadersMode.SPDY_SYN_STREAM);
-    }
+        @Override
+        public void readConnectionPreface() {
+        }
 
-    private void readSynReply(Handler handler, int flags, int length) throws IOException {
-      int w1 = source.readInt();
-      int streamId = w1 & 0x7fffffff;
-      List<Header> headerBlock = headerBlockReader.readNameValueBlock(length - 4);
-      boolean inFinished = (flags & FLAG_FIN) != 0;
-      handler.headers(false, inFinished, streamId, -1, headerBlock, HeadersMode.SPDY_REPLY);
-    }
+        /**
+         * Send the next frame to {@code handler}. Returns true unless there are no
+         * more frames on the stream.
+         */
+        @Override
+        public boolean nextFrame(Handler handler) throws IOException {
+            int w1;
+            int w2;
+            try {
+                w1 = source.readInt();
+                w2 = source.readInt();
+            } catch (IOException e) {
+                return false; // This might be a normal socket close.
+            }
+
+            boolean control = (w1 & 0x80000000) != 0;
+            int flags = (w2 & 0xff000000) >>> 24;
+            int length = (w2 & 0xffffff);
+
+            if (control) {
+                int version = (w1 & 0x7fff0000) >>> 16;
+                int type = (w1 & 0xffff);
+
+                if (version != 3) {
+                    throw new ProtocolException("version != 3: " + version);
+                }
+
+                switch (type) {
+                    case TYPE_SYN_STREAM:
+                        readSynStream(handler, flags, length);
+                        return true;
+
+                    case TYPE_SYN_REPLY:
+                        readSynReply(handler, flags, length);
+                        return true;
+
+                    case TYPE_RST_STREAM:
+                        readRstStream(handler, flags, length);
+                        return true;
+
+                    case TYPE_SETTINGS:
+                        readSettings(handler, flags, length);
+                        return true;
+
+                    case TYPE_PING:
+                        readPing(handler, flags, length);
+                        return true;
+
+                    case TYPE_GOAWAY:
+                        readGoAway(handler, flags, length);
+                        return true;
+
+                    case TYPE_HEADERS:
+                        readHeaders(handler, flags, length);
+                        return true;
+
+                    case TYPE_WINDOW_UPDATE:
+                        readWindowUpdate(handler, flags, length);
+                        return true;
+
+                    default:
+                        source.skip(length);
+                        return true;
+                }
+            } else {
+                int streamId = w1 & 0x7fffffff;
+                boolean inFinished = (flags & FLAG_FIN) != 0;
+                handler.data(inFinished, streamId, source, length);
+                return true;
+            }
+        }
 
-    private void readRstStream(Handler handler, int flags, int length) throws IOException {
-      if (length != 8) throw ioException("TYPE_RST_STREAM length: %d != 8", length);
-      int streamId = source.readInt() & 0x7fffffff;
-      int errorCodeInt = source.readInt();
-      ErrorCode errorCode = ErrorCode.fromSpdy3Rst(errorCodeInt);
-      if (errorCode == null) {
-        throw ioException("TYPE_RST_STREAM unexpected error code: %d", errorCodeInt);
-      }
-      handler.rstStream(streamId, errorCode);
-    }
+        private void readSynStream(Handler handler, int flags, int length) throws IOException {
+            int w1 = source.readInt();
+            int w2 = source.readInt();
+            int streamId = w1 & 0x7fffffff;
+            int associatedStreamId = w2 & 0x7fffffff;
+            source.readShort(); // int priority = (s3 & 0xe000) >>> 13; int slot = s3 & 0xff;
+            List<Header> headerBlock = headerBlockReader.readNameValueBlock(length - 10);
+
+            boolean inFinished = (flags & FLAG_FIN) != 0;
+            boolean outFinished = (flags & FLAG_UNIDIRECTIONAL) != 0;
+            handler.headers(outFinished, inFinished, streamId, associatedStreamId, headerBlock,
+                    HeadersMode.SPDY_SYN_STREAM);
+        }
 
-    private void readHeaders(Handler handler, int flags, int length) throws IOException {
-      int w1 = source.readInt();
-      int streamId = w1 & 0x7fffffff;
-      List<Header> headerBlock = headerBlockReader.readNameValueBlock(length - 4);
-      handler.headers(false, false, streamId, -1, headerBlock, HeadersMode.SPDY_HEADERS);
-    }
+        private void readSynReply(Handler handler, int flags, int length) throws IOException {
+            int w1 = source.readInt();
+            int streamId = w1 & 0x7fffffff;
+            List<Header> headerBlock = headerBlockReader.readNameValueBlock(length - 4);
+            boolean inFinished = (flags & FLAG_FIN) != 0;
+            handler.headers(false, inFinished, streamId, -1, headerBlock, HeadersMode.SPDY_REPLY);
+        }
 
-    private void readWindowUpdate(Handler handler, int flags, int length) throws IOException {
-      if (length != 8) throw ioException("TYPE_WINDOW_UPDATE length: %d != 8", length);
-      int w1 = source.readInt();
-      int w2 = source.readInt();
-      int streamId = w1 & 0x7fffffff;
-      long increment = w2 & 0x7fffffff;
-      if (increment == 0) throw ioException("windowSizeIncrement was 0", increment);
-      handler.windowUpdate(streamId, increment);
-    }
+        private void readRstStream(Handler handler, int flags, int length) throws IOException {
+            if (length != 8) throw ioException("TYPE_RST_STREAM length: %d != 8", length);
+            int streamId = source.readInt() & 0x7fffffff;
+            int errorCodeInt = source.readInt();
+            ErrorCode errorCode = ErrorCode.fromSpdy3Rst(errorCodeInt);
+            if (errorCode == null) {
+                throw ioException("TYPE_RST_STREAM unexpected error code: %d", errorCodeInt);
+            }
+            handler.rstStream(streamId, errorCode);
+        }
 
-    private void readPing(Handler handler, int flags, int length) throws IOException {
-      if (length != 4) throw ioException("TYPE_PING length: %d != 4", length);
-      int id = source.readInt();
-      boolean ack = client == ((id & 1) == 1);
-      handler.ping(ack, id, 0);
-    }
+        private void readHeaders(Handler handler, int flags, int length) throws IOException {
+            int w1 = source.readInt();
+            int streamId = w1 & 0x7fffffff;
+            List<Header> headerBlock = headerBlockReader.readNameValueBlock(length - 4);
+            handler.headers(false, false, streamId, -1, headerBlock, HeadersMode.SPDY_HEADERS);
+        }
 
-    private void readGoAway(Handler handler, int flags, int length) throws IOException {
-      if (length != 8) throw ioException("TYPE_GOAWAY length: %d != 8", length);
-      int lastGoodStreamId = source.readInt() & 0x7fffffff;
-      int errorCodeInt = source.readInt();
-      ErrorCode errorCode = ErrorCode.fromSpdyGoAway(errorCodeInt);
-      if (errorCode == null) {
-        throw ioException("TYPE_GOAWAY unexpected error code: %d", errorCodeInt);
-      }
-      handler.goAway(lastGoodStreamId, errorCode, ByteString.EMPTY);
-    }
+        private void readWindowUpdate(Handler handler, int flags, int length) throws IOException {
+            if (length != 8) throw ioException("TYPE_WINDOW_UPDATE length: %d != 8", length);
+            int w1 = source.readInt();
+            int w2 = source.readInt();
+            int streamId = w1 & 0x7fffffff;
+            long increment = w2 & 0x7fffffff;
+            if (increment == 0) throw ioException("windowSizeIncrement was 0", increment);
+            handler.windowUpdate(streamId, increment);
+        }
 
-    private void readSettings(Handler handler, int flags, int length) throws IOException {
-      int numberOfEntries = source.readInt();
-      if (length != 4 + 8 * numberOfEntries) {
-        throw ioException("TYPE_SETTINGS length: %d != 4 + 8 * %d", length, numberOfEntries);
-      }
-      Settings settings = new Settings();
-      for (int i = 0; i < numberOfEntries; i++) {
-        int w1 = source.readInt();
-        int value = source.readInt();
-        int idFlags = (w1 & 0xff000000) >>> 24;
-        int id = w1 & 0xffffff;
-        settings.set(id, idFlags, value);
-      }
-      boolean clearPrevious = (flags & Settings.FLAG_CLEAR_PREVIOUSLY_PERSISTED_SETTINGS) != 0;
-      handler.settings(clearPrevious, settings);
-    }
+        private void readPing(Handler handler, int flags, int length) throws IOException {
+            if (length != 4) throw ioException("TYPE_PING length: %d != 4", length);
+            int id = source.readInt();
+            boolean ack = client == ((id & 1) == 1);
+            handler.ping(ack, id, 0);
+        }
 
-    private static IOException ioException(String message, Object... args) throws IOException {
-      throw new IOException(String.format(message, args));
-    }
+        private void readGoAway(Handler handler, int flags, int length) throws IOException {
+            if (length != 8) throw ioException("TYPE_GOAWAY length: %d != 8", length);
+            int lastGoodStreamId = source.readInt() & 0x7fffffff;
+            int errorCodeInt = source.readInt();
+            ErrorCode errorCode = ErrorCode.fromSpdyGoAway(errorCodeInt);
+            if (errorCode == null) {
+                throw ioException("TYPE_GOAWAY unexpected error code: %d", errorCodeInt);
+            }
+            handler.goAway(lastGoodStreamId, errorCode, ByteString.EMPTY);
+        }
 
-    @Override public void close() throws IOException {
-      headerBlockReader.close();
-    }
-  }
-
-  /** Write spdy/3 frames. */
-  static final class Writer implements FrameWriter {
-    private final BufferedSink sink;
-    private final Buffer headerBlockBuffer;
-    private final BufferedSink headerBlockOut;
-    private final boolean client;
-    private boolean closed;
-
-    Writer(BufferedSink sink, boolean client) {
-      this.sink = sink;
-      this.client = client;
-
-      Deflater deflater = new Deflater();
-      deflater.setDictionary(DICTIONARY);
-      headerBlockBuffer = new Buffer();
-      headerBlockOut = Okio.buffer(new DeflaterSink(headerBlockBuffer, deflater));
-    }
+        private void readSettings(Handler handler, int flags, int length) throws IOException {
+            int numberOfEntries = source.readInt();
+            if (length != 4 + 8 * numberOfEntries) {
+                throw ioException("TYPE_SETTINGS length: %d != 4 + 8 * %d", length, numberOfEntries);
+            }
+            Settings settings = new Settings();
+            for (int i = 0; i < numberOfEntries; i++) {
+                int w1 = source.readInt();
+                int value = source.readInt();
+                int idFlags = (w1 & 0xff000000) >>> 24;
+                int id = w1 & 0xffffff;
+                settings.set(id, idFlags, value);
+            }
+            boolean clearPrevious = (flags & Settings.FLAG_CLEAR_PREVIOUSLY_PERSISTED_SETTINGS) != 0;
+            handler.settings(clearPrevious, settings);
+        }
 
-    @Override public void ackSettings(Settings peerSettings) {
-      // Do nothing: no ACK for SPDY/3 settings.
-    }
+        private static IOException ioException(String message, Object... args) throws IOException {
+            throw new IOException(String.format(message, args));
+        }
 
-    @Override
-    public void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
-        throws IOException {
-      // Do nothing: no push promise for SPDY/3.
+        @Override
+        public void close() throws IOException {
+            headerBlockReader.close();
+        }
     }
 
-    @Override public synchronized void connectionPreface() {
-      // Do nothing: no connection preface for SPDY/3.
-    }
+    /**
+     * Write spdy/3 frames.
+     */
+    static final class Writer implements FrameWriter {
+        private final BufferedSink sink;
+        private final Buffer headerBlockBuffer;
+        private final BufferedSink headerBlockOut;
+        private final boolean client;
+        private boolean closed;
+
+        Writer(BufferedSink sink, boolean client) {
+            this.sink = sink;
+            this.client = client;
+
+            Deflater deflater = new Deflater();
+            deflater.setDictionary(DICTIONARY);
+            headerBlockBuffer = new Buffer();
+            headerBlockOut = Okio.buffer(new DeflaterSink(headerBlockBuffer, deflater));
+        }
 
-    @Override public synchronized void flush() throws IOException {
-      if (closed) throw new IOException("closed");
-      sink.flush();
-    }
+        @Override
+        public void ackSettings(Settings peerSettings) {
+            // Do nothing: no ACK for SPDY/3 settings.
+        }
 
-    @Override public synchronized void synStream(boolean outFinished, boolean inFinished,
-        int streamId, int associatedStreamId, List<Header> headerBlock)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      writeNameValueBlockToBuffer(headerBlock);
-      int length = (int) (10 + headerBlockBuffer.size());
-      int type = TYPE_SYN_STREAM;
-      int flags = (outFinished ? FLAG_FIN : 0) | (inFinished ? FLAG_UNIDIRECTIONAL : 0);
-
-      int unused = 0;
-      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      sink.writeInt(streamId & 0x7fffffff);
-      sink.writeInt(associatedStreamId & 0x7fffffff);
-      sink.writeShort((unused & 0x7) << 13 | (unused & 0x1f) << 8 | (unused & 0xff));
-      sink.writeAll(headerBlockBuffer);
-      sink.flush();
-    }
+        @Override
+        public void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
+                throws IOException {
+            // Do nothing: no push promise for SPDY/3.
+        }
 
-    @Override public synchronized void synReply(boolean outFinished, int streamId,
-        List<Header> headerBlock) throws IOException {
-      if (closed) throw new IOException("closed");
-      writeNameValueBlockToBuffer(headerBlock);
-      int type = TYPE_SYN_REPLY;
-      int flags = (outFinished ? FLAG_FIN : 0);
-      int length = (int) (headerBlockBuffer.size() + 4);
-
-      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      sink.writeInt(streamId & 0x7fffffff);
-      sink.writeAll(headerBlockBuffer);
-      sink.flush();
-    }
+        @Override
+        public synchronized void connectionPreface() {
+            // Do nothing: no connection preface for SPDY/3.
+        }
 
-    @Override public synchronized void headers(int streamId, List<Header> headerBlock)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      writeNameValueBlockToBuffer(headerBlock);
-      int flags = 0;
-      int type = TYPE_HEADERS;
-      int length = (int) (headerBlockBuffer.size() + 4);
-
-      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      sink.writeInt(streamId & 0x7fffffff);
-      sink.writeAll(headerBlockBuffer);
-    }
+        @Override
+        public synchronized void flush() throws IOException {
+            if (closed) throw new IOException("closed");
+            sink.flush();
+        }
 
-    @Override public synchronized void rstStream(int streamId, ErrorCode errorCode)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      if (errorCode.spdyRstCode == -1) throw new IllegalArgumentException();
-      int flags = 0;
-      int type = TYPE_RST_STREAM;
-      int length = 8;
-      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      sink.writeInt(streamId & 0x7fffffff);
-      sink.writeInt(errorCode.spdyRstCode);
-      sink.flush();
-    }
+        @Override
+        public synchronized void synStream(boolean outFinished, boolean inFinished,
+                                           int streamId, int associatedStreamId, List<Header> headerBlock)
+                throws IOException {
+            if (closed) throw new IOException("closed");
+            writeNameValueBlockToBuffer(headerBlock);
+            int length = (int) (10 + headerBlockBuffer.size());
+            int type = TYPE_SYN_STREAM;
+            int flags = (outFinished ? FLAG_FIN : 0) | (inFinished ? FLAG_UNIDIRECTIONAL : 0);
+
+            int unused = 0;
+            sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+            sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+            sink.writeInt(streamId & 0x7fffffff);
+            sink.writeInt(associatedStreamId & 0x7fffffff);
+            sink.writeShort((unused & 0x7) << 13 | (unused & 0x1f) << 8 | (unused & 0xff));
+            sink.writeAll(headerBlockBuffer);
+            sink.flush();
+        }
 
-    @Override public int maxDataLength() {
-      return 16383;
-    }
+        @Override
+        public synchronized void synReply(boolean outFinished, int streamId,
+                                          List<Header> headerBlock) throws IOException {
+            if (closed) throw new IOException("closed");
+            writeNameValueBlockToBuffer(headerBlock);
+            int type = TYPE_SYN_REPLY;
+            int flags = (outFinished ? FLAG_FIN : 0);
+            int length = (int) (headerBlockBuffer.size() + 4);
+
+            sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+            sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+            sink.writeInt(streamId & 0x7fffffff);
+            sink.writeAll(headerBlockBuffer);
+            sink.flush();
+        }
 
-    @Override public synchronized void data(boolean outFinished, int streamId, Buffer source,
-        int byteCount) throws IOException {
-      int flags = (outFinished ? FLAG_FIN : 0);
-      sendDataFrame(streamId, flags, source, byteCount);
-    }
+        @Override
+        public synchronized void headers(int streamId, List<Header> headerBlock)
+                throws IOException {
+            if (closed) throw new IOException("closed");
+            writeNameValueBlockToBuffer(headerBlock);
+            int flags = 0;
+            int type = TYPE_HEADERS;
+            int length = (int) (headerBlockBuffer.size() + 4);
+
+            sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+            sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+            sink.writeInt(streamId & 0x7fffffff);
+            sink.writeAll(headerBlockBuffer);
+        }
 
-    void sendDataFrame(int streamId, int flags, Buffer buffer, int byteCount)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      if (byteCount > 0xffffffL) {
-        throw new IllegalArgumentException("FRAME_TOO_LARGE max size is 16Mib: " + byteCount);
-      }
-      sink.writeInt(streamId & 0x7fffffff);
-      sink.writeInt((flags & 0xff) << 24 | byteCount & 0xffffff);
-      if (byteCount > 0) {
-        sink.write(buffer, byteCount);
-      }
-    }
+        @Override
+        public synchronized void rstStream(int streamId, ErrorCode errorCode)
+                throws IOException {
+            if (closed) throw new IOException("closed");
+            if (errorCode.spdyRstCode == -1) throw new IllegalArgumentException();
+            int flags = 0;
+            int type = TYPE_RST_STREAM;
+            int length = 8;
+            sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+            sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+            sink.writeInt(streamId & 0x7fffffff);
+            sink.writeInt(errorCode.spdyRstCode);
+            sink.flush();
+        }
 
-    private void writeNameValueBlockToBuffer(List<Header> headerBlock) throws IOException {
-      if (headerBlockBuffer.size() != 0) throw new IllegalStateException();
-      headerBlockOut.writeInt(headerBlock.size());
-      for (int i = 0, size = headerBlock.size(); i < size; i++) {
-        ByteString name = headerBlock.get(i).name;
-        headerBlockOut.writeInt(name.size());
-        headerBlockOut.write(name);
-        ByteString value = headerBlock.get(i).value;
-        headerBlockOut.writeInt(value.size());
-        headerBlockOut.write(value);
-      }
-      headerBlockOut.flush();
-    }
+        @Override
+        public int maxDataLength() {
+            return 16383;
+        }
 
-    @Override public synchronized void settings(Settings settings) throws IOException {
-      if (closed) throw new IOException("closed");
-      int type = TYPE_SETTINGS;
-      int flags = 0;
-      int size = settings.size();
-      int length = 4 + size * 8;
-      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      sink.writeInt(size);
-      for (int i = 0; i <= Settings.COUNT; i++) {
-        if (!settings.isSet(i)) continue;
-        int settingsFlags = settings.flags(i);
-        sink.writeInt((settingsFlags & 0xff) << 24 | (i & 0xffffff));
-        sink.writeInt(settings.get(i));
-      }
-      sink.flush();
-    }
+        @Override
+        public synchronized void data(boolean outFinished, int streamId, Buffer source,
+                                      int byteCount) throws IOException {
+            int flags = (outFinished ? FLAG_FIN : 0);
+            sendDataFrame(streamId, flags, source, byteCount);
+        }
 
-    @Override public synchronized void ping(boolean reply, int payload1, int payload2)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      boolean payloadIsReply = client != ((payload1 & 1) == 1);
-      if (reply != payloadIsReply) throw new IllegalArgumentException("payload != reply");
-      int type = TYPE_PING;
-      int flags = 0;
-      int length = 4;
-      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      sink.writeInt(payload1);
-      sink.flush();
-    }
+        void sendDataFrame(int streamId, int flags, Buffer buffer, int byteCount)
+                throws IOException {
+            if (closed) throw new IOException("closed");
+            if (byteCount > 0xffffffL) {
+                throw new IllegalArgumentException("FRAME_TOO_LARGE max size is 16Mib: " + byteCount);
+            }
+            sink.writeInt(streamId & 0x7fffffff);
+            sink.writeInt((flags & 0xff) << 24 | byteCount & 0xffffff);
+            if (byteCount > 0) {
+                sink.write(buffer, byteCount);
+            }
+        }
 
-    @Override public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode,
-        byte[] ignored) throws IOException {
-      if (closed) throw new IOException("closed");
-      if (errorCode.spdyGoAwayCode == -1) {
-        throw new IllegalArgumentException("errorCode.spdyGoAwayCode == -1");
-      }
-      int type = TYPE_GOAWAY;
-      int flags = 0;
-      int length = 8;
-      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      sink.writeInt(lastGoodStreamId);
-      sink.writeInt(errorCode.spdyGoAwayCode);
-      sink.flush();
-    }
+        private void writeNameValueBlockToBuffer(List<Header> headerBlock) throws IOException {
+            if (headerBlockBuffer.size() != 0) throw new IllegalStateException();
+            headerBlockOut.writeInt(headerBlock.size());
+            for (int i = 0, size = headerBlock.size(); i < size; i++) {
+                ByteString name = headerBlock.get(i).name;
+                headerBlockOut.writeInt(name.size());
+                headerBlockOut.write(name);
+                ByteString value = headerBlock.get(i).value;
+                headerBlockOut.writeInt(value.size());
+                headerBlockOut.write(value);
+            }
+            headerBlockOut.flush();
+        }
 
-    @Override public synchronized void windowUpdate(int streamId, long increment)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      if (increment == 0 || increment > 0x7fffffffL) {
-        throw new IllegalArgumentException(
-            "windowSizeIncrement must be between 1 and 0x7fffffff: " + increment);
-      }
-      int type = TYPE_WINDOW_UPDATE;
-      int flags = 0;
-      int length = 8;
-      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      sink.writeInt(streamId);
-      sink.writeInt((int) increment);
-      sink.flush();
-    }
+        @Override
+        public synchronized void settings(Settings settings) throws IOException {
+            if (closed) throw new IOException("closed");
+            int type = TYPE_SETTINGS;
+            int flags = 0;
+            int size = settings.size();
+            int length = 4 + size * 8;
+            sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+            sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+            sink.writeInt(size);
+            for (int i = 0; i <= Settings.COUNT; i++) {
+                if (!settings.isSet(i)) continue;
+                int settingsFlags = settings.flags(i);
+                sink.writeInt((settingsFlags & 0xff) << 24 | (i & 0xffffff));
+                sink.writeInt(settings.get(i));
+            }
+            sink.flush();
+        }
+
+        @Override
+        public synchronized void ping(boolean reply, int payload1, int payload2)
+                throws IOException {
+            if (closed) throw new IOException("closed");
+            boolean payloadIsReply = client != ((payload1 & 1) == 1);
+            if (reply != payloadIsReply) throw new IllegalArgumentException("payload != reply");
+            int type = TYPE_PING;
+            int flags = 0;
+            int length = 4;
+            sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+            sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+            sink.writeInt(payload1);
+            sink.flush();
+        }
+
+        @Override
+        public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode,
+                                        byte[] ignored) throws IOException {
+            if (closed) throw new IOException("closed");
+            if (errorCode.spdyGoAwayCode == -1) {
+                throw new IllegalArgumentException("errorCode.spdyGoAwayCode == -1");
+            }
+            int type = TYPE_GOAWAY;
+            int flags = 0;
+            int length = 8;
+            sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+            sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+            sink.writeInt(lastGoodStreamId);
+            sink.writeInt(errorCode.spdyGoAwayCode);
+            sink.flush();
+        }
+
+        @Override
+        public synchronized void windowUpdate(int streamId, long increment)
+                throws IOException {
+            if (closed) throw new IOException("closed");
+            if (increment == 0 || increment > 0x7fffffffL) {
+                throw new IllegalArgumentException(
+                        "windowSizeIncrement must be between 1 and 0x7fffffff: " + increment);
+            }
+            int type = TYPE_WINDOW_UPDATE;
+            int flags = 0;
+            int length = 8;
+            sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+            sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+            sink.writeInt(streamId);
+            sink.writeInt((int) increment);
+            sink.flush();
+        }
 
-    @Override public synchronized void close() throws IOException {
-      closed = true;
-      Util.closeAll(sink, headerBlockOut);
+        @Override
+        public synchronized void close() throws IOException {
+            closed = true;
+            Util.closeAll(sink, headerBlockOut);
+        }
     }
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Variant.java b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Variant.java
index 0782ba1a86..51b4516dd1 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Variant.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Variant.java
@@ -16,22 +16,27 @@
 package com.squareup.okhttp.internal.framed;
 
 import com.squareup.okhttp.Protocol;
+
 import okio.BufferedSink;
 import okio.BufferedSource;
 
-/** A version and dialect of the framed socket protocol. */
+/**
+ * A version and dialect of the framed socket protocol.
+ */
 public interface Variant {
 
-  /** The protocol as selected using ALPN. */
-  Protocol getProtocol();
+    /**
+     * The protocol as selected using ALPN.
+     */
+    Protocol getProtocol();
 
-  /**
-   * @param client true if this is the HTTP client's reader, reading frames from a server.
-   */
-  FrameReader newReader(BufferedSource source, boolean client);
+    /**
+     * @param client true if this is the HTTP client's reader, reading frames from a server.
+     */
+    FrameReader newReader(BufferedSource source, boolean client);
 
-  /**
-   * @param client true if this is the HTTP client's writer, writing frames to a server.
-   */
-  FrameWriter newWriter(BufferedSink sink, boolean client);
+    /**
+     * @param client true if this is the HTTP client's writer, writing frames to a server.
+     */
+    FrameWriter newWriter(BufferedSink sink, boolean client);
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/AuthenticatorAdapter.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/AuthenticatorAdapter.java
index 9ccbb032c8..e05251b2a5 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/AuthenticatorAdapter.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/AuthenticatorAdapter.java
@@ -21,6 +21,7 @@
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.internal.Util;
+
 import java.io.IOException;
 import java.net.Authenticator.RequestorType;
 import java.net.InetAddress;
@@ -30,60 +31,66 @@
 import java.net.URL;
 import java.util.List;
 
-/** Adapts {@link java.net.Authenticator} to {@link com.squareup.okhttp.Authenticator}. */
+/**
+ * Adapts {@link java.net.Authenticator} to {@link com.squareup.okhttp.Authenticator}.
+ */
 public final class AuthenticatorAdapter implements Authenticator {
-  /** Uses the global authenticator to get the password. */
-  public static final Authenticator INSTANCE = new AuthenticatorAdapter();
+    /**
+     * Uses the global authenticator to get the password.
+     */
+    public static final Authenticator INSTANCE = new AuthenticatorAdapter();
 
-  @Override public Request authenticate(Proxy proxy, Response response) throws IOException {
-    List<Challenge> challenges = response.challenges();
-    Request request = response.request();
-    URL url = request.url();
-    for (int i = 0, size = challenges.size(); i < size; i++) {
-      Challenge challenge = challenges.get(i);
-      if (!"Basic".equalsIgnoreCase(challenge.getScheme())) continue;
+    @Override
+    public Request authenticate(Proxy proxy, Response response) throws IOException {
+        List<Challenge> challenges = response.challenges();
+        Request request = response.request();
+        URL url = request.url();
+        for (int i = 0, size = challenges.size(); i < size; i++) {
+            Challenge challenge = challenges.get(i);
+            if (!"Basic".equalsIgnoreCase(challenge.getScheme())) continue;
 
-      PasswordAuthentication auth = java.net.Authenticator.requestPasswordAuthentication(
-          url.getHost(), getConnectToInetAddress(proxy, url), Util.getEffectivePort(url),
-          url.getProtocol(), challenge.getRealm(), challenge.getScheme(), url,
-          RequestorType.SERVER);
-      if (auth == null) continue;
+            PasswordAuthentication auth = java.net.Authenticator.requestPasswordAuthentication(
+                    url.getHost(), getConnectToInetAddress(proxy, url), Util.getEffectivePort(url),
+                    url.getProtocol(), challenge.getRealm(), challenge.getScheme(), url,
+                    RequestorType.SERVER);
+            if (auth == null) continue;
 
-      String credential = Credentials.basic(auth.getUserName(), new String(auth.getPassword()));
-      return request.newBuilder()
-          .header("Authorization", credential)
-          .build();
-    }
-    return null;
+            String credential = Credentials.basic(auth.getUserName(), new String(auth.getPassword()));
+            return request.newBuilder()
+                    .header("Authorization", credential)
+                    .build();
+        }
+        return null;
 
-  }
+    }
 
-  @Override public Request authenticateProxy(Proxy proxy, Response response) throws IOException {
-    List<Challenge> challenges = response.challenges();
-    Request request = response.request();
-    URL url = request.url();
-    for (int i = 0, size = challenges.size(); i < size; i++) {
-      Challenge challenge = challenges.get(i);
-      if (!"Basic".equalsIgnoreCase(challenge.getScheme())) continue;
+    @Override
+    public Request authenticateProxy(Proxy proxy, Response response) throws IOException {
+        List<Challenge> challenges = response.challenges();
+        Request request = response.request();
+        URL url = request.url();
+        for (int i = 0, size = challenges.size(); i < size; i++) {
+            Challenge challenge = challenges.get(i);
+            if (!"Basic".equalsIgnoreCase(challenge.getScheme())) continue;
 
-      InetSocketAddress proxyAddress = (InetSocketAddress) proxy.address();
-      PasswordAuthentication auth = java.net.Authenticator.requestPasswordAuthentication(
-          proxyAddress.getHostName(), getConnectToInetAddress(proxy, url), proxyAddress.getPort(),
-          url.getProtocol(), challenge.getRealm(), challenge.getScheme(), url,
-          RequestorType.PROXY);
-      if (auth == null) continue;
+            InetSocketAddress proxyAddress = (InetSocketAddress) proxy.address();
+            PasswordAuthentication auth = java.net.Authenticator.requestPasswordAuthentication(
+                    proxyAddress.getHostName(), getConnectToInetAddress(proxy, url), proxyAddress.getPort(),
+                    url.getProtocol(), challenge.getRealm(), challenge.getScheme(), url,
+                    RequestorType.PROXY);
+            if (auth == null) continue;
 
-      String credential = Credentials.basic(auth.getUserName(), new String(auth.getPassword()));
-      return request.newBuilder()
-          .header("Proxy-Authorization", credential)
-          .build();
+            String credential = Credentials.basic(auth.getUserName(), new String(auth.getPassword()));
+            return request.newBuilder()
+                    .header("Proxy-Authorization", credential)
+                    .build();
+        }
+        return null;
     }
-    return null;
-  }
 
-  private InetAddress getConnectToInetAddress(Proxy proxy, URL url) throws IOException {
-    return (proxy != null && proxy.type() != Proxy.Type.DIRECT)
-        ? ((InetSocketAddress) proxy.address()).getAddress()
-        : InetAddress.getByName(url.getHost());
-  }
+    private InetAddress getConnectToInetAddress(Proxy proxy, URL url) throws IOException {
+        return (proxy != null && proxy.type() != Proxy.Type.DIRECT)
+                ? ((InetSocketAddress) proxy.address()).getAddress()
+                : InetAddress.getByName(url.getHost());
+    }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheRequest.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheRequest.java
index b8153e4f07..1cb94620a4 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheRequest.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheRequest.java
@@ -16,9 +16,11 @@
 package com.squareup.okhttp.internal.http;
 
 import java.io.IOException;
+
 import okio.Sink;
 
 public interface CacheRequest {
-  Sink body() throws IOException;
-  void abort();
+    Sink body() throws IOException;
+
+    void abort();
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
index 3f07edd7e1..7026ee2f81 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
@@ -25,281 +25,295 @@
 /**
  * Given a request and cached response, this figures out whether to use the
  * network, the cache, or both.
- *
+ * <p/>
  * <p>Selecting a cache strategy may add conditions to the request (like the
  * "If-Modified-Since" header for conditional GETs) or warnings to the cached
  * response (if the cached data is potentially stale).
  */
 public final class CacheStrategy {
-  /** The request to send on the network, or null if this call doesn't use the network. */
-  public final Request networkRequest;
-
-  /** The cached response to return or validate; or null if this call doesn't use a cache. */
-  public final Response cacheResponse;
-
-  private CacheStrategy(Request networkRequest, Response cacheResponse) {
-    this.networkRequest = networkRequest;
-    this.cacheResponse = cacheResponse;
-  }
-
-  /**
-   * Returns true if {@code response} can be stored to later serve another
-   * request.
-   */
-  public static boolean isCacheable(Response response, Request request) {
-    // Always go to network for uncacheable response codes (RFC 7231 section 6.1),
-    // This implementation doesn't support caching partial content.
-    switch (response.code()) {
-      case HTTP_OK:
-      case HTTP_NOT_AUTHORITATIVE:
-      case HTTP_NO_CONTENT:
-      case HTTP_MULT_CHOICE:
-      case HTTP_MOVED_PERM:
-      case HTTP_NOT_FOUND:
-      case HTTP_BAD_METHOD:
-      case HTTP_GONE:
-      case HTTP_REQ_TOO_LONG:
-      case HTTP_NOT_IMPLEMENTED:
-      case HTTP_PERM_REDIRECT:
-      // These codes can be cached unless headers forbid it.
-      break;
-
-      case HTTP_MOVED_TEMP:
-      case HTTP_TEMP_REDIRECT:
-        // These codes can only be cached with the right response headers.
-        // http://tools.ietf.org/html/rfc7234#section-3
-        // s-maxage is not checked because OkHttp is a private cache that should ignore s-maxage.
-        if (response.header("Expires") != null
-            || response.cacheControl().maxAgeSeconds() != -1
-            || response.cacheControl().isPublic()
-            || response.cacheControl().isPrivate()) {
-          break;
-        }
-        // Fall-through.
-
-      default:
-        // All other codes cannot be cached.
-        return false;
-    }
-
-    // A 'no-store' directive on request or response prevents the response from being cached.
-    return !response.cacheControl().noStore() && !request.cacheControl().noStore();
-  }
-
-  public static class Factory {
-    final long nowMillis;
-    final Request request;
-    final Response cacheResponse;
-
-    /** The server's time when the cached response was served, if known. */
-    private Date servedDate;
-    private String servedDateString;
-
-    /** The last modified date of the cached response, if known. */
-    private Date lastModified;
-    private String lastModifiedString;
-
     /**
-     * The expiration date of the cached response, if known. If both this field
-     * and the max age are set, the max age is preferred.
+     * The request to send on the network, or null if this call doesn't use the network.
      */
-    private Date expires;
+    public final Request networkRequest;
 
     /**
-     * Extension header set by OkHttp specifying the timestamp when the cached
-     * HTTP request was first initiated.
+     * The cached response to return or validate; or null if this call doesn't use a cache.
      */
-    private long sentRequestMillis;
+    public final Response cacheResponse;
+
+    private CacheStrategy(Request networkRequest, Response cacheResponse) {
+        this.networkRequest = networkRequest;
+        this.cacheResponse = cacheResponse;
+    }
 
     /**
-     * Extension header set by OkHttp specifying the timestamp when the cached
-     * HTTP response was first received.
+     * Returns true if {@code response} can be stored to later serve another
+     * request.
      */
-    private long receivedResponseMillis;
-
-    /** Etag of the cached response. */
-    private String etag;
-
-    /** Age of the cached response. */
-    private int ageSeconds = -1;
-
-    public Factory(long nowMillis, Request request, Response cacheResponse) {
-      this.nowMillis = nowMillis;
-      this.request = request;
-      this.cacheResponse = cacheResponse;
-
-      if (cacheResponse != null) {
-        Headers headers = cacheResponse.headers();
-        for (int i = 0, size = headers.size(); i < size; i++) {
-          String fieldName = headers.name(i);
-          String value = headers.value(i);
-          if ("Date".equalsIgnoreCase(fieldName)) {
-            servedDate = HttpDate.parse(value);
-            servedDateString = value;
-          } else if ("Expires".equalsIgnoreCase(fieldName)) {
-            expires = HttpDate.parse(value);
-          } else if ("Last-Modified".equalsIgnoreCase(fieldName)) {
-            lastModified = HttpDate.parse(value);
-            lastModifiedString = value;
-          } else if ("ETag".equalsIgnoreCase(fieldName)) {
-            etag = value;
-          } else if ("Age".equalsIgnoreCase(fieldName)) {
-            ageSeconds = HeaderParser.parseSeconds(value, -1);
-          } else if (OkHeaders.SENT_MILLIS.equalsIgnoreCase(fieldName)) {
-            sentRequestMillis = Long.parseLong(value);
-          } else if (OkHeaders.RECEIVED_MILLIS.equalsIgnoreCase(fieldName)) {
-            receivedResponseMillis = Long.parseLong(value);
-          }
+    public static boolean isCacheable(Response response, Request request) {
+        // Always go to network for uncacheable response codes (RFC 7231 section 6.1),
+        // This implementation doesn't support caching partial content.
+        switch (response.code()) {
+            case HTTP_OK:
+            case HTTP_NOT_AUTHORITATIVE:
+            case HTTP_NO_CONTENT:
+            case HTTP_MULT_CHOICE:
+            case HTTP_MOVED_PERM:
+            case HTTP_NOT_FOUND:
+            case HTTP_BAD_METHOD:
+            case HTTP_GONE:
+            case HTTP_REQ_TOO_LONG:
+            case HTTP_NOT_IMPLEMENTED:
+            case HTTP_PERM_REDIRECT:
+                // These codes can be cached unless headers forbid it.
+                break;
+
+            case HTTP_MOVED_TEMP:
+            case HTTP_TEMP_REDIRECT:
+                // These codes can only be cached with the right response headers.
+                // http://tools.ietf.org/html/rfc7234#section-3
+                // s-maxage is not checked because OkHttp is a private cache that should ignore s-maxage.
+                if (response.header("Expires") != null
+                        || response.cacheControl().maxAgeSeconds() != -1
+                        || response.cacheControl().isPublic()
+                        || response.cacheControl().isPrivate()) {
+                    break;
+                }
+                // Fall-through.
+
+            default:
+                // All other codes cannot be cached.
+                return false;
         }
-      }
+
+        // A 'no-store' directive on request or response prevents the response from being cached.
+        return !response.cacheControl().noStore() && !request.cacheControl().noStore();
     }
 
-    /**
-     * Returns a strategy to satisfy {@code request} using the a cached response
-     * {@code response}.
-     */
-    public CacheStrategy get() {
-      CacheStrategy candidate = getCandidate();
+    public static class Factory {
+        final long nowMillis;
+        final Request request;
+        final Response cacheResponse;
+
+        /**
+         * The server's time when the cached response was served, if known.
+         */
+        private Date servedDate;
+        private String servedDateString;
+
+        /**
+         * The last modified date of the cached response, if known.
+         */
+        private Date lastModified;
+        private String lastModifiedString;
+
+        /**
+         * The expiration date of the cached response, if known. If both this field
+         * and the max age are set, the max age is preferred.
+         */
+        private Date expires;
+
+        /**
+         * Extension header set by OkHttp specifying the timestamp when the cached
+         * HTTP request was first initiated.
+         */
+        private long sentRequestMillis;
+
+        /**
+         * Extension header set by OkHttp specifying the timestamp when the cached
+         * HTTP response was first received.
+         */
+        private long receivedResponseMillis;
+
+        /**
+         * Etag of the cached response.
+         */
+        private String etag;
+
+        /**
+         * Age of the cached response.
+         */
+        private int ageSeconds = -1;
+
+        public Factory(long nowMillis, Request request, Response cacheResponse) {
+            this.nowMillis = nowMillis;
+            this.request = request;
+            this.cacheResponse = cacheResponse;
+
+            if (cacheResponse != null) {
+                Headers headers = cacheResponse.headers();
+                for (int i = 0, size = headers.size(); i < size; i++) {
+                    String fieldName = headers.name(i);
+                    String value = headers.value(i);
+                    if ("Date".equalsIgnoreCase(fieldName)) {
+                        servedDate = HttpDate.parse(value);
+                        servedDateString = value;
+                    } else if ("Expires".equalsIgnoreCase(fieldName)) {
+                        expires = HttpDate.parse(value);
+                    } else if ("Last-Modified".equalsIgnoreCase(fieldName)) {
+                        lastModified = HttpDate.parse(value);
+                        lastModifiedString = value;
+                    } else if ("ETag".equalsIgnoreCase(fieldName)) {
+                        etag = value;
+                    } else if ("Age".equalsIgnoreCase(fieldName)) {
+                        ageSeconds = HeaderParser.parseSeconds(value, -1);
+                    } else if (OkHeaders.SENT_MILLIS.equalsIgnoreCase(fieldName)) {
+                        sentRequestMillis = Long.parseLong(value);
+                    } else if (OkHeaders.RECEIVED_MILLIS.equalsIgnoreCase(fieldName)) {
+                        receivedResponseMillis = Long.parseLong(value);
+                    }
+                }
+            }
+        }
 
-      if (candidate.networkRequest != null && request.cacheControl().onlyIfCached()) {
-        // We're forbidden from using the network and the cache is insufficient.
-        return new CacheStrategy(null, null);
-      }
+        /**
+         * Returns a strategy to satisfy {@code request} using the a cached response
+         * {@code response}.
+         */
+        public CacheStrategy get() {
+            CacheStrategy candidate = getCandidate();
 
-      return candidate;
-    }
+            if (candidate.networkRequest != null && request.cacheControl().onlyIfCached()) {
+                // We're forbidden from using the network and the cache is insufficient.
+                return new CacheStrategy(null, null);
+            }
 
-    /** Returns a strategy to use assuming the request can use the network. */
-    private CacheStrategy getCandidate() {
-      // No cached response.
-      if (cacheResponse == null) {
-        return new CacheStrategy(request, null);
-      }
-
-      // Drop the cached response if it's missing a required handshake.
-      if (request.isHttps() && cacheResponse.handshake() == null) {
-        return new CacheStrategy(request, null);
-      }
-
-      // If this response shouldn't have been stored, it should never be used
-      // as a response source. This check should be redundant as long as the
-      // persistence store is well-behaved and the rules are constant.
-      if (!isCacheable(cacheResponse, request)) {
-        return new CacheStrategy(request, null);
-      }
-
-      CacheControl requestCaching = request.cacheControl();
-      if (requestCaching.noCache() || hasConditions(request)) {
-        return new CacheStrategy(request, null);
-      }
-
-      long ageMillis = cacheResponseAge();
-      long freshMillis = computeFreshnessLifetime();
-
-      if (requestCaching.maxAgeSeconds() != -1) {
-        freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));
-      }
-
-      long minFreshMillis = 0;
-      if (requestCaching.minFreshSeconds() != -1) {
-        minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());
-      }
-
-      long maxStaleMillis = 0;
-      CacheControl responseCaching = cacheResponse.cacheControl();
-      if (!responseCaching.mustRevalidate() && requestCaching.maxStaleSeconds() != -1) {
-        maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());
-      }
-
-      if (!responseCaching.noCache() && ageMillis + minFreshMillis < freshMillis + maxStaleMillis) {
-        Response.Builder builder = cacheResponse.newBuilder();
-        if (ageMillis + minFreshMillis >= freshMillis) {
-          builder.addHeader("Warning", "110 HttpURLConnection \"Response is stale\"");
+            return candidate;
         }
-        long oneDayMillis = 24 * 60 * 60 * 1000L;
-        if (ageMillis > oneDayMillis && isFreshnessLifetimeHeuristic()) {
-          builder.addHeader("Warning", "113 HttpURLConnection \"Heuristic expiration\"");
+
+        /**
+         * Returns a strategy to use assuming the request can use the network.
+         */
+        private CacheStrategy getCandidate() {
+            // No cached response.
+            if (cacheResponse == null) {
+                return new CacheStrategy(request, null);
+            }
+
+            // Drop the cached response if it's missing a required handshake.
+            if (request.isHttps() && cacheResponse.handshake() == null) {
+                return new CacheStrategy(request, null);
+            }
+
+            // If this response shouldn't have been stored, it should never be used
+            // as a response source. This check should be redundant as long as the
+            // persistence store is well-behaved and the rules are constant.
+            if (!isCacheable(cacheResponse, request)) {
+                return new CacheStrategy(request, null);
+            }
+
+            CacheControl requestCaching = request.cacheControl();
+            if (requestCaching.noCache() || hasConditions(request)) {
+                return new CacheStrategy(request, null);
+            }
+
+            long ageMillis = cacheResponseAge();
+            long freshMillis = computeFreshnessLifetime();
+
+            if (requestCaching.maxAgeSeconds() != -1) {
+                freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));
+            }
+
+            long minFreshMillis = 0;
+            if (requestCaching.minFreshSeconds() != -1) {
+                minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());
+            }
+
+            long maxStaleMillis = 0;
+            CacheControl responseCaching = cacheResponse.cacheControl();
+            if (!responseCaching.mustRevalidate() && requestCaching.maxStaleSeconds() != -1) {
+                maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());
+            }
+
+            if (!responseCaching.noCache() && ageMillis + minFreshMillis < freshMillis + maxStaleMillis) {
+                Response.Builder builder = cacheResponse.newBuilder();
+                if (ageMillis + minFreshMillis >= freshMillis) {
+                    builder.addHeader("Warning", "110 HttpURLConnection \"Response is stale\"");
+                }
+                long oneDayMillis = 24 * 60 * 60 * 1000L;
+                if (ageMillis > oneDayMillis && isFreshnessLifetimeHeuristic()) {
+                    builder.addHeader("Warning", "113 HttpURLConnection \"Heuristic expiration\"");
+                }
+                return new CacheStrategy(null, builder.build());
+            }
+
+            Request.Builder conditionalRequestBuilder = request.newBuilder();
+
+            if (etag != null) {
+                conditionalRequestBuilder.header("If-None-Match", etag);
+            } else if (lastModified != null) {
+                conditionalRequestBuilder.header("If-Modified-Since", lastModifiedString);
+            } else if (servedDate != null) {
+                conditionalRequestBuilder.header("If-Modified-Since", servedDateString);
+            }
+
+            Request conditionalRequest = conditionalRequestBuilder.build();
+            return hasConditions(conditionalRequest)
+                    ? new CacheStrategy(conditionalRequest, cacheResponse)
+                    : new CacheStrategy(conditionalRequest, null);
         }
-        return new CacheStrategy(null, builder.build());
-      }
-
-      Request.Builder conditionalRequestBuilder = request.newBuilder();
-
-      if (etag != null) {
-        conditionalRequestBuilder.header("If-None-Match", etag);
-      } else if (lastModified != null) {
-        conditionalRequestBuilder.header("If-Modified-Since", lastModifiedString);
-      } else if (servedDate != null) {
-        conditionalRequestBuilder.header("If-Modified-Since", servedDateString);
-      }
-
-      Request conditionalRequest = conditionalRequestBuilder.build();
-      return hasConditions(conditionalRequest)
-          ? new CacheStrategy(conditionalRequest, cacheResponse)
-          : new CacheStrategy(conditionalRequest, null);
-    }
 
-    /**
-     * Returns the number of milliseconds that the response was fresh for,
-     * starting from the served date.
-     */
-    private long computeFreshnessLifetime() {
-      CacheControl responseCaching = cacheResponse.cacheControl();
-      if (responseCaching.maxAgeSeconds() != -1) {
-        return SECONDS.toMillis(responseCaching.maxAgeSeconds());
-      } else if (expires != null) {
-        long servedMillis = servedDate != null
-            ? servedDate.getTime()
-            : receivedResponseMillis;
-        long delta = expires.getTime() - servedMillis;
-        return delta > 0 ? delta : 0;
-      } else if (lastModified != null
-          && cacheResponse.request().url().getQuery() == null) {
-        // As recommended by the HTTP RFC and implemented in Firefox, the
-        // max age of a document should be defaulted to 10% of the
-        // document's age at the time it was served. Default expiration
-        // dates aren't used for URIs containing a query.
-        long servedMillis = servedDate != null
-            ? servedDate.getTime()
-            : sentRequestMillis;
-        long delta = servedMillis - lastModified.getTime();
-        return delta > 0 ? (delta / 10) : 0;
-      }
-      return 0;
-    }
+        /**
+         * Returns the number of milliseconds that the response was fresh for,
+         * starting from the served date.
+         */
+        private long computeFreshnessLifetime() {
+            CacheControl responseCaching = cacheResponse.cacheControl();
+            if (responseCaching.maxAgeSeconds() != -1) {
+                return SECONDS.toMillis(responseCaching.maxAgeSeconds());
+            } else if (expires != null) {
+                long servedMillis = servedDate != null
+                        ? servedDate.getTime()
+                        : receivedResponseMillis;
+                long delta = expires.getTime() - servedMillis;
+                return delta > 0 ? delta : 0;
+            } else if (lastModified != null
+                    && cacheResponse.request().url().getQuery() == null) {
+                // As recommended by the HTTP RFC and implemented in Firefox, the
+                // max age of a document should be defaulted to 10% of the
+                // document's age at the time it was served. Default expiration
+                // dates aren't used for URIs containing a query.
+                long servedMillis = servedDate != null
+                        ? servedDate.getTime()
+                        : sentRequestMillis;
+                long delta = servedMillis - lastModified.getTime();
+                return delta > 0 ? (delta / 10) : 0;
+            }
+            return 0;
+        }
 
-    /**
-     * Returns the current age of the response, in milliseconds. The calculation
-     * is specified by RFC 2616, 13.2.3 Age Calculations.
-     */
-    private long cacheResponseAge() {
-      long apparentReceivedAge = servedDate != null
-          ? Math.max(0, receivedResponseMillis - servedDate.getTime())
-          : 0;
-      long receivedAge = ageSeconds != -1
-          ? Math.max(apparentReceivedAge, SECONDS.toMillis(ageSeconds))
-          : apparentReceivedAge;
-      long responseDuration = receivedResponseMillis - sentRequestMillis;
-      long residentDuration = nowMillis - receivedResponseMillis;
-      return receivedAge + responseDuration + residentDuration;
-    }
+        /**
+         * Returns the current age of the response, in milliseconds. The calculation
+         * is specified by RFC 2616, 13.2.3 Age Calculations.
+         */
+        private long cacheResponseAge() {
+            long apparentReceivedAge = servedDate != null
+                    ? Math.max(0, receivedResponseMillis - servedDate.getTime())
+                    : 0;
+            long receivedAge = ageSeconds != -1
+                    ? Math.max(apparentReceivedAge, SECONDS.toMillis(ageSeconds))
+                    : apparentReceivedAge;
+            long responseDuration = receivedResponseMillis - sentRequestMillis;
+            long residentDuration = nowMillis - receivedResponseMillis;
+            return receivedAge + responseDuration + residentDuration;
+        }
 
-    /**
-     * Returns true if computeFreshnessLifetime used a heuristic. If we used a
-     * heuristic to serve a cached response older than 24 hours, we are required
-     * to attach a warning.
-     */
-    private boolean isFreshnessLifetimeHeuristic() {
-      return cacheResponse.cacheControl().maxAgeSeconds() == -1 && expires == null;
-    }
+        /**
+         * Returns true if computeFreshnessLifetime used a heuristic. If we used a
+         * heuristic to serve a cached response older than 24 hours, we are required
+         * to attach a warning.
+         */
+        private boolean isFreshnessLifetimeHeuristic() {
+            return cacheResponse.cacheControl().maxAgeSeconds() == -1 && expires == null;
+        }
 
-    /**
-     * Returns true if the request contains conditions that save the server from
-     * sending a response that the client has locally. When a request is enqueued
-     * with its own conditions, the built-in response cache won't be used.
-     */
-    private static boolean hasConditions(Request request) {
-      return request.header("If-Modified-Since") != null || request.header("If-None-Match") != null;
+        /**
+         * Returns true if the request contains conditions that save the server from
+         * sending a response that the client has locally. When a request is enqueued
+         * with its own conditions, the built-in response cache won't be used.
+         */
+        private static boolean hasConditions(Request request) {
+            return request.header("If-Modified-Since") != null || request.header("If-None-Match") != null;
+        }
     }
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/FramedTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/FramedTransport.java
index 524c7a7e3c..6c425d97eb 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/FramedTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/FramedTransport.java
@@ -26,6 +26,7 @@
 import com.squareup.okhttp.internal.framed.FramedConnection;
 import com.squareup.okhttp.internal.framed.FramedStream;
 import com.squareup.okhttp.internal.framed.Header;
+
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.util.ArrayList;
@@ -34,6 +35,7 @@
 import java.util.Locale;
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
+
 import okio.ByteString;
 import okio.Okio;
 import okio.Sink;
@@ -47,186 +49,203 @@
 import static com.squareup.okhttp.internal.framed.Header.VERSION;
 
 public final class FramedTransport implements Transport {
-  /** See http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1#TOC-3.2.1-Request. */
-  private static final List<ByteString> SPDY_3_PROHIBITED_HEADERS = Util.immutableList(
-      ByteString.encodeUtf8("connection"),
-      ByteString.encodeUtf8("host"),
-      ByteString.encodeUtf8("keep-alive"),
-      ByteString.encodeUtf8("proxy-connection"),
-      ByteString.encodeUtf8("transfer-encoding"));
-
-  /** See http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-8.1.3. */
-  private static final List<ByteString> HTTP_2_PROHIBITED_HEADERS = Util.immutableList(
-      ByteString.encodeUtf8("connection"),
-      ByteString.encodeUtf8("host"),
-      ByteString.encodeUtf8("keep-alive"),
-      ByteString.encodeUtf8("proxy-connection"),
-      ByteString.encodeUtf8("te"),
-      ByteString.encodeUtf8("transfer-encoding"),
-      ByteString.encodeUtf8("encoding"),
-      ByteString.encodeUtf8("upgrade"));
-
-  private final HttpEngine httpEngine;
-  private final FramedConnection framedConnection;
-  private FramedStream stream;
-
-  public FramedTransport(HttpEngine httpEngine, FramedConnection framedConnection) {
-    this.httpEngine = httpEngine;
-    this.framedConnection = framedConnection;
-  }
-
-  @Override public Sink createRequestBody(Request request, long contentLength) throws IOException {
-    return stream.getSink();
-  }
-
-  @Override public void writeRequestHeaders(Request request) throws IOException {
-    if (stream != null) return;
-
-    httpEngine.writingRequestHeaders();
-    boolean permitsRequestBody = httpEngine.permitsRequestBody();
-    boolean hasResponseBody = true;
-    String version = RequestLine.version(httpEngine.getConnection().getProtocol());
-    stream = framedConnection.newStream(
-        writeNameValueBlock(request, framedConnection.getProtocol(), version), permitsRequestBody,
-        hasResponseBody);
-    stream.readTimeout().timeout(httpEngine.client.getReadTimeout(), TimeUnit.MILLISECONDS);
-  }
-
-  @Override public void writeRequestBody(RetryableSink requestBody) throws IOException {
-    requestBody.writeToSocket(stream.getSink());
-  }
-
-  @Override public void finishRequest() throws IOException {
-    stream.getSink().close();
-  }
-
-  @Override public Response.Builder readResponseHeaders() throws IOException {
-    return readNameValueBlock(stream.getResponseHeaders(), framedConnection.getProtocol());
-  }
-
-  /**
-   * Returns a list of alternating names and values containing a SPDY request.
-   * Names are all lowercase. No names are repeated. If any name has multiple
-   * values, they are concatenated using "\0" as a delimiter.
-   */
-  public static List<Header> writeNameValueBlock(Request request, Protocol protocol,
-      String version) {
-    Headers headers = request.headers();
-    List<Header> result = new ArrayList<>(headers.size() + 10);
-    result.add(new Header(TARGET_METHOD, request.method()));
-    result.add(new Header(TARGET_PATH, RequestLine.requestPath(request.url())));
-    String host = HttpEngine.hostHeader(request.url());
-    if (Protocol.SPDY_3 == protocol) {
-      result.add(new Header(VERSION, version));
-      result.add(new Header(TARGET_HOST, host));
-    } else if (Protocol.HTTP_2 == protocol) {
-      result.add(new Header(TARGET_AUTHORITY, host)); // Optional in HTTP/2
-    } else {
-      throw new AssertionError();
+    /**
+     * See http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1#TOC-3.2.1-Request.
+     */
+    private static final List<ByteString> SPDY_3_PROHIBITED_HEADERS = Util.immutableList(
+            ByteString.encodeUtf8("connection"),
+            ByteString.encodeUtf8("host"),
+            ByteString.encodeUtf8("keep-alive"),
+            ByteString.encodeUtf8("proxy-connection"),
+            ByteString.encodeUtf8("transfer-encoding"));
+
+    /**
+     * See http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-8.1.3.
+     */
+    private static final List<ByteString> HTTP_2_PROHIBITED_HEADERS = Util.immutableList(
+            ByteString.encodeUtf8("connection"),
+            ByteString.encodeUtf8("host"),
+            ByteString.encodeUtf8("keep-alive"),
+            ByteString.encodeUtf8("proxy-connection"),
+            ByteString.encodeUtf8("te"),
+            ByteString.encodeUtf8("transfer-encoding"),
+            ByteString.encodeUtf8("encoding"),
+            ByteString.encodeUtf8("upgrade"));
+
+    private final HttpEngine httpEngine;
+    private final FramedConnection framedConnection;
+    private FramedStream stream;
+
+    public FramedTransport(HttpEngine httpEngine, FramedConnection framedConnection) {
+        this.httpEngine = httpEngine;
+        this.framedConnection = framedConnection;
     }
-    result.add(new Header(TARGET_SCHEME, request.url().getProtocol()));
-
-    Set<ByteString> names = new LinkedHashSet<ByteString>();
-    for (int i = 0, size = headers.size(); i < size; i++) {
-      // header names must be lowercase.
-      ByteString name = ByteString.encodeUtf8(headers.name(i).toLowerCase(Locale.US));
-      String value = headers.value(i);
-
-      // Drop headers that are forbidden when layering HTTP over SPDY.
-      if (isProhibitedHeader(protocol, name)) continue;
-
-      // They shouldn't be set, but if they are, drop them. We've already written them!
-      if (name.equals(TARGET_METHOD)
-          || name.equals(TARGET_PATH)
-          || name.equals(TARGET_SCHEME)
-          || name.equals(TARGET_AUTHORITY)
-          || name.equals(TARGET_HOST)
-          || name.equals(VERSION)) {
-        continue;
-      }
-
-      // If we haven't seen this name before, add the pair to the end of the list...
-      if (names.add(name)) {
-        result.add(new Header(name, value));
-        continue;
-      }
-
-      // ...otherwise concatenate the existing values and this value.
-      for (int j = 0; j < result.size(); j++) {
-        if (result.get(j).name.equals(name)) {
-          String concatenated = joinOnNull(result.get(j).value.utf8(), value);
-          result.set(j, new Header(name, concatenated));
-          break;
-        }
-      }
+
+    @Override
+    public Sink createRequestBody(Request request, long contentLength) throws IOException {
+        return stream.getSink();
+    }
+
+    @Override
+    public void writeRequestHeaders(Request request) throws IOException {
+        if (stream != null) return;
+
+        httpEngine.writingRequestHeaders();
+        boolean permitsRequestBody = httpEngine.permitsRequestBody();
+        boolean hasResponseBody = true;
+        String version = RequestLine.version(httpEngine.getConnection().getProtocol());
+        stream = framedConnection.newStream(
+                writeNameValueBlock(request, framedConnection.getProtocol(), version), permitsRequestBody,
+                hasResponseBody);
+        stream.readTimeout().timeout(httpEngine.client.getReadTimeout(), TimeUnit.MILLISECONDS);
+    }
+
+    @Override
+    public void writeRequestBody(RetryableSink requestBody) throws IOException {
+        requestBody.writeToSocket(stream.getSink());
+    }
+
+    @Override
+    public void finishRequest() throws IOException {
+        stream.getSink().close();
     }
-    return result;
-  }
-
-  private static String joinOnNull(String first, String second) {
-    return new StringBuilder(first).append('\0').append(second).toString();
-  }
-
-  /** Returns headers for a name value block containing a SPDY response. */
-  public static Response.Builder readNameValueBlock(List<Header> headerBlock,
-      Protocol protocol) throws IOException {
-    String status = null;
-    String version = "HTTP/1.1"; // :version present only in spdy/3.
-
-    Headers.Builder headersBuilder = new Headers.Builder();
-    headersBuilder.set(OkHeaders.SELECTED_PROTOCOL, protocol.toString());
-    for (int i = 0, size = headerBlock.size(); i < size; i++) {
-      ByteString name = headerBlock.get(i).name;
-      String values = headerBlock.get(i).value.utf8();
-      for (int start = 0; start < values.length(); ) {
-        int end = values.indexOf('\0', start);
-        if (end == -1) {
-          end = values.length();
+
+    @Override
+    public Response.Builder readResponseHeaders() throws IOException {
+        return readNameValueBlock(stream.getResponseHeaders(), framedConnection.getProtocol());
+    }
+
+    /**
+     * Returns a list of alternating names and values containing a SPDY request.
+     * Names are all lowercase. No names are repeated. If any name has multiple
+     * values, they are concatenated using "\0" as a delimiter.
+     */
+    public static List<Header> writeNameValueBlock(Request request, Protocol protocol,
+                                                   String version) {
+        Headers headers = request.headers();
+        List<Header> result = new ArrayList<>(headers.size() + 10);
+        result.add(new Header(TARGET_METHOD, request.method()));
+        result.add(new Header(TARGET_PATH, RequestLine.requestPath(request.url())));
+        String host = HttpEngine.hostHeader(request.url());
+        if (Protocol.SPDY_3 == protocol) {
+            result.add(new Header(VERSION, version));
+            result.add(new Header(TARGET_HOST, host));
+        } else if (Protocol.HTTP_2 == protocol) {
+            result.add(new Header(TARGET_AUTHORITY, host)); // Optional in HTTP/2
+        } else {
+            throw new AssertionError();
+        }
+        result.add(new Header(TARGET_SCHEME, request.url().getProtocol()));
+
+        Set<ByteString> names = new LinkedHashSet<ByteString>();
+        for (int i = 0, size = headers.size(); i < size; i++) {
+            // header names must be lowercase.
+            ByteString name = ByteString.encodeUtf8(headers.name(i).toLowerCase(Locale.US));
+            String value = headers.value(i);
+
+            // Drop headers that are forbidden when layering HTTP over SPDY.
+            if (isProhibitedHeader(protocol, name)) continue;
+
+            // They shouldn't be set, but if they are, drop them. We've already written them!
+            if (name.equals(TARGET_METHOD)
+                    || name.equals(TARGET_PATH)
+                    || name.equals(TARGET_SCHEME)
+                    || name.equals(TARGET_AUTHORITY)
+                    || name.equals(TARGET_HOST)
+                    || name.equals(VERSION)) {
+                continue;
+            }
+
+            // If we haven't seen this name before, add the pair to the end of the list...
+            if (names.add(name)) {
+                result.add(new Header(name, value));
+                continue;
+            }
+
+            // ...otherwise concatenate the existing values and this value.
+            for (int j = 0; j < result.size(); j++) {
+                if (result.get(j).name.equals(name)) {
+                    String concatenated = joinOnNull(result.get(j).value.utf8(), value);
+                    result.set(j, new Header(name, concatenated));
+                    break;
+                }
+            }
         }
-        String value = values.substring(start, end);
-        if (name.equals(RESPONSE_STATUS)) {
-          status = value;
-        } else if (name.equals(VERSION)) {
-          version = value;
-        } else if (!isProhibitedHeader(protocol, name)) { // Don't write forbidden headers!
-          headersBuilder.add(name.utf8(), value);
+        return result;
+    }
+
+    private static String joinOnNull(String first, String second) {
+        return new StringBuilder(first).append('\0').append(second).toString();
+    }
+
+    /**
+     * Returns headers for a name value block containing a SPDY response.
+     */
+    public static Response.Builder readNameValueBlock(List<Header> headerBlock,
+                                                      Protocol protocol) throws IOException {
+        String status = null;
+        String version = "HTTP/1.1"; // :version present only in spdy/3.
+
+        Headers.Builder headersBuilder = new Headers.Builder();
+        headersBuilder.set(OkHeaders.SELECTED_PROTOCOL, protocol.toString());
+        for (int i = 0, size = headerBlock.size(); i < size; i++) {
+            ByteString name = headerBlock.get(i).name;
+            String values = headerBlock.get(i).value.utf8();
+            for (int start = 0; start < values.length(); ) {
+                int end = values.indexOf('\0', start);
+                if (end == -1) {
+                    end = values.length();
+                }
+                String value = values.substring(start, end);
+                if (name.equals(RESPONSE_STATUS)) {
+                    status = value;
+                } else if (name.equals(VERSION)) {
+                    version = value;
+                } else if (!isProhibitedHeader(protocol, name)) { // Don't write forbidden headers!
+                    headersBuilder.add(name.utf8(), value);
+                }
+                start = end + 1;
+            }
         }
-        start = end + 1;
-      }
+        if (status == null) throw new ProtocolException("Expected ':status' header not present");
+
+        StatusLine statusLine = StatusLine.parse(version + " " + status);
+        return new Response.Builder()
+                .protocol(protocol)
+                .code(statusLine.code)
+                .message(statusLine.message)
+                .headers(headersBuilder.build());
+    }
+
+    @Override
+    public ResponseBody openResponseBody(Response response) throws IOException {
+        return new RealResponseBody(response.headers(), Okio.buffer(stream.getSource()));
+    }
+
+    @Override
+    public void releaseConnectionOnIdle() {
+    }
+
+    @Override
+    public void disconnect(HttpEngine engine) throws IOException {
+        if (stream != null) stream.close(ErrorCode.CANCEL);
     }
-    if (status == null) throw new ProtocolException("Expected ':status' header not present");
-
-    StatusLine statusLine = StatusLine.parse(version + " " + status);
-    return new Response.Builder()
-        .protocol(protocol)
-        .code(statusLine.code)
-        .message(statusLine.message)
-        .headers(headersBuilder.build());
-  }
-
-  @Override public ResponseBody openResponseBody(Response response) throws IOException {
-    return new RealResponseBody(response.headers(), Okio.buffer(stream.getSource()));
-  }
-
-  @Override public void releaseConnectionOnIdle() {
-  }
-
-  @Override public void disconnect(HttpEngine engine) throws IOException {
-    if (stream != null) stream.close(ErrorCode.CANCEL);
-  }
-
-  @Override public boolean canReuseConnection() {
-    return true; // TODO: framedConnection.isClosed() ?
-  }
-
-  /** When true, this header should not be emitted or consumed. */
-  private static boolean isProhibitedHeader(Protocol protocol, ByteString name) {
-    if (protocol == Protocol.SPDY_3) {
-      return SPDY_3_PROHIBITED_HEADERS.contains(name);
-    } else if (protocol == Protocol.HTTP_2) {
-      return HTTP_2_PROHIBITED_HEADERS.contains(name);
-    } else {
-      throw new AssertionError(protocol);
+
+    @Override
+    public boolean canReuseConnection() {
+        return true; // TODO: framedConnection.isClosed() ?
+    }
+
+    /**
+     * When true, this header should not be emitted or consumed.
+     */
+    private static boolean isProhibitedHeader(Protocol protocol, ByteString name) {
+        if (protocol == Protocol.SPDY_3) {
+            return SPDY_3_PROHIBITED_HEADERS.contains(name);
+        } else if (protocol == Protocol.HTTP_2) {
+            return HTTP_2_PROHIBITED_HEADERS.contains(name);
+        } else {
+            throw new AssertionError(protocol);
+        }
     }
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HeaderParser.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HeaderParser.java
index 55f82ada47..7ec6acf214 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HeaderParser.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HeaderParser.java
@@ -17,53 +17,53 @@
 package com.squareup.okhttp.internal.http;
 
 public final class HeaderParser {
-  /**
-   * Returns the next index in {@code input} at or after {@code pos} that
-   * contains a character from {@code characters}. Returns the input length if
-   * none of the requested characters can be found.
-   */
-  public static int skipUntil(String input, int pos, String characters) {
-    for (; pos < input.length(); pos++) {
-      if (characters.indexOf(input.charAt(pos)) != -1) {
-        break;
-      }
+    /**
+     * Returns the next index in {@code input} at or after {@code pos} that
+     * contains a character from {@code characters}. Returns the input length if
+     * none of the requested characters can be found.
+     */
+    public static int skipUntil(String input, int pos, String characters) {
+        for (; pos < input.length(); pos++) {
+            if (characters.indexOf(input.charAt(pos)) != -1) {
+                break;
+            }
+        }
+        return pos;
     }
-    return pos;
-  }
 
-  /**
-   * Returns the next non-whitespace character in {@code input} that is white
-   * space. Result is undefined if input contains newline characters.
-   */
-  public static int skipWhitespace(String input, int pos) {
-    for (; pos < input.length(); pos++) {
-      char c = input.charAt(pos);
-      if (c != ' ' && c != '\t') {
-        break;
-      }
+    /**
+     * Returns the next non-whitespace character in {@code input} that is white
+     * space. Result is undefined if input contains newline characters.
+     */
+    public static int skipWhitespace(String input, int pos) {
+        for (; pos < input.length(); pos++) {
+            char c = input.charAt(pos);
+            if (c != ' ' && c != '\t') {
+                break;
+            }
+        }
+        return pos;
     }
-    return pos;
-  }
 
-  /**
-   * Returns {@code value} as a positive integer, or 0 if it is negative, or
-   * {@code defaultValue} if it cannot be parsed.
-   */
-  public static int parseSeconds(String value, int defaultValue) {
-    try {
-      long seconds = Long.parseLong(value);
-      if (seconds > Integer.MAX_VALUE) {
-        return Integer.MAX_VALUE;
-      } else if (seconds < 0) {
-        return 0;
-      } else {
-        return (int) seconds;
-      }
-    } catch (NumberFormatException e) {
-      return defaultValue;
+    /**
+     * Returns {@code value} as a positive integer, or 0 if it is negative, or
+     * {@code defaultValue} if it cannot be parsed.
+     */
+    public static int parseSeconds(String value, int defaultValue) {
+        try {
+            long seconds = Long.parseLong(value);
+            if (seconds > Integer.MAX_VALUE) {
+                return Integer.MAX_VALUE;
+            } else if (seconds < 0) {
+                return 0;
+            } else {
+                return (int) seconds;
+            }
+        } catch (NumberFormatException e) {
+            return defaultValue;
+        }
     }
-  }
 
-  private HeaderParser() {
-  }
+    private HeaderParser() {
+    }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
index 1bbde80b48..55c03bc6a9 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
@@ -22,11 +22,13 @@
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.Util;
+
 import java.io.EOFException;
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.net.Socket;
 import java.net.SocketTimeoutException;
+
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -45,15 +47,15 @@
  * A socket connection that can be used to send HTTP/1.1 messages. This class
  * strictly enforces the following lifecycle:
  * <ol>
- *   <li>{@link #writeRequest Send request headers}.
- *   <li>Open a sink to write the request body. Either {@link
- *       #newFixedLengthSink fixed-length} or {@link #newChunkedSink chunked}.
- *   <li>Write to and then close that sink.
- *   <li>{@link #readResponse Read response headers}.
- *   <li>Open a source to read the response body. Either {@link
- *       #newFixedLengthSource fixed-length}, {@link #newChunkedSource chunked}
- *       or {@link #newUnknownLengthSource unknown length}.
- *   <li>Read from and close that source.
+ * <li>{@link #writeRequest Send request headers}.
+ * <li>Open a sink to write the request body. Either {@link
+ * #newFixedLengthSink fixed-length} or {@link #newChunkedSink chunked}.
+ * <li>Write to and then close that sink.
+ * <li>{@link #readResponse Read response headers}.
+ * <li>Open a source to read the response body. Either {@link
+ * #newFixedLengthSource fixed-length}, {@link #newChunkedSource chunked}
+ * or {@link #newUnknownLengthSource unknown length}.
+ * <li>Read from and close that source.
  * </ol>
  * <p>Exchanges that do not have a request body may skip creating and closing
  * the request body. Exchanges that do not have a response body can call {@link
@@ -61,473 +63,511 @@
  * closing that source.
  */
 public final class HttpConnection {
-  private static final int STATE_IDLE = 0; // Idle connections are ready to write request headers.
-  private static final int STATE_OPEN_REQUEST_BODY = 1;
-  private static final int STATE_WRITING_REQUEST_BODY = 2;
-  private static final int STATE_READ_RESPONSE_HEADERS = 3;
-  private static final int STATE_OPEN_RESPONSE_BODY = 4;
-  private static final int STATE_READING_RESPONSE_BODY = 5;
-  private static final int STATE_CLOSED = 6;
-
-  private static final int ON_IDLE_HOLD = 0;
-  private static final int ON_IDLE_POOL = 1;
-  private static final int ON_IDLE_CLOSE = 2;
-
-  private final ConnectionPool pool;
-  private final Connection connection;
-  private final Socket socket;
-  private final BufferedSource source;
-  private final BufferedSink sink;
-
-  private int state = STATE_IDLE;
-  private int onIdle = ON_IDLE_HOLD;
-
-  public HttpConnection(ConnectionPool pool, Connection connection, Socket socket)
-      throws IOException {
-    this.pool = pool;
-    this.connection = connection;
-    this.socket = socket;
-    this.source = Okio.buffer(Okio.source(socket));
-    this.sink = Okio.buffer(Okio.sink(socket));
-  }
-
-  public void setTimeouts(int readTimeoutMillis, int writeTimeoutMillis) {
-    if (readTimeoutMillis != 0) {
-      source.timeout().timeout(readTimeoutMillis, MILLISECONDS);
-    }
-    if (writeTimeoutMillis != 0) {
-      sink.timeout().timeout(writeTimeoutMillis, MILLISECONDS);
+    private static final int STATE_IDLE = 0; // Idle connections are ready to write request headers.
+    private static final int STATE_OPEN_REQUEST_BODY = 1;
+    private static final int STATE_WRITING_REQUEST_BODY = 2;
+    private static final int STATE_READ_RESPONSE_HEADERS = 3;
+    private static final int STATE_OPEN_RESPONSE_BODY = 4;
+    private static final int STATE_READING_RESPONSE_BODY = 5;
+    private static final int STATE_CLOSED = 6;
+
+    private static final int ON_IDLE_HOLD = 0;
+    private static final int ON_IDLE_POOL = 1;
+    private static final int ON_IDLE_CLOSE = 2;
+
+    private final ConnectionPool pool;
+    private final Connection connection;
+    private final Socket socket;
+    private final BufferedSource source;
+    private final BufferedSink sink;
+
+    private int state = STATE_IDLE;
+    private int onIdle = ON_IDLE_HOLD;
+
+    public HttpConnection(ConnectionPool pool, Connection connection, Socket socket)
+            throws IOException {
+        this.pool = pool;
+        this.connection = connection;
+        this.socket = socket;
+        this.source = Okio.buffer(Okio.source(socket));
+        this.sink = Okio.buffer(Okio.sink(socket));
     }
-  }
-
-  /**
-   * Configure this connection to put itself back into the connection pool when
-   * the HTTP response body is exhausted.
-   */
-  public void poolOnIdle() {
-    onIdle = ON_IDLE_POOL;
-
-    // If we're already idle, go to the pool immediately.
-    if (state == STATE_IDLE) {
-      onIdle = ON_IDLE_HOLD; // Set the on idle policy back to the default.
-      Internal.instance.recycle(pool, connection);
-    }
-  }
-
-  /**
-   * Configure this connection to close itself when the HTTP response body is
-   * exhausted.
-   */
-  public void closeOnIdle() throws IOException {
-    onIdle = ON_IDLE_CLOSE;
-
-    // If we're already idle, close immediately.
-    if (state == STATE_IDLE) {
-      state = STATE_CLOSED;
-      connection.getSocket().close();
+
+    public void setTimeouts(int readTimeoutMillis, int writeTimeoutMillis) {
+        if (readTimeoutMillis != 0) {
+            source.timeout().timeout(readTimeoutMillis, MILLISECONDS);
+        }
+        if (writeTimeoutMillis != 0) {
+            sink.timeout().timeout(writeTimeoutMillis, MILLISECONDS);
+        }
     }
-  }
-
-  /** Returns true if this connection is closed. */
-  public boolean isClosed() {
-    return state == STATE_CLOSED;
-  }
-
-  public void closeIfOwnedBy(Object owner) throws IOException {
-    Internal.instance.closeIfOwnedBy(connection, owner);
-  }
-
-  public void flush() throws IOException {
-    sink.flush();
-  }
-
-  /** Returns the number of buffered bytes immediately readable. */
-  public long bufferSize() {
-    return source.buffer().size();
-  }
-
-  /** Test for a stale socket. */
-  public boolean isReadable() {
-    try {
-      int readTimeout = socket.getSoTimeout();
-      try {
-        socket.setSoTimeout(1);
-        if (source.exhausted()) {
-          return false; // Stream is exhausted; socket is closed.
+
+    /**
+     * Configure this connection to put itself back into the connection pool when
+     * the HTTP response body is exhausted.
+     */
+    public void poolOnIdle() {
+        onIdle = ON_IDLE_POOL;
+
+        // If we're already idle, go to the pool immediately.
+        if (state == STATE_IDLE) {
+            onIdle = ON_IDLE_HOLD; // Set the on idle policy back to the default.
+            Internal.instance.recycle(pool, connection);
         }
-        return true;
-      } finally {
-        socket.setSoTimeout(readTimeout);
-      }
-    } catch (SocketTimeoutException ignored) {
-      return true; // Read timed out; socket is good.
-    } catch (IOException e) {
-      return false; // Couldn't read; socket is closed.
     }
-  }
-
-  /** Returns bytes of a request header for sending on an HTTP transport. */
-  public void writeRequest(Headers headers, String requestLine) throws IOException {
-    if (state != STATE_IDLE) throw new IllegalStateException("state: " + state);
-    sink.writeUtf8(requestLine).writeUtf8("\r\n");
-    for (int i = 0, size = headers.size(); i < size; i ++) {
-      sink.writeUtf8(headers.name(i))
-          .writeUtf8(": ")
-          .writeUtf8(headers.value(i))
-          .writeUtf8("\r\n");
+
+    /**
+     * Configure this connection to close itself when the HTTP response body is
+     * exhausted.
+     */
+    public void closeOnIdle() throws IOException {
+        onIdle = ON_IDLE_CLOSE;
+
+        // If we're already idle, close immediately.
+        if (state == STATE_IDLE) {
+            state = STATE_CLOSED;
+            connection.getSocket().close();
+        }
     }
-    sink.writeUtf8("\r\n");
-    state = STATE_OPEN_REQUEST_BODY;
-  }
-
-  /** Parses bytes of a response header from an HTTP transport. */
-  public Response.Builder readResponse() throws IOException {
-    if (state != STATE_OPEN_REQUEST_BODY && state != STATE_READ_RESPONSE_HEADERS) {
-      throw new IllegalStateException("state: " + state);
+
+    /**
+     * Returns true if this connection is closed.
+     */
+    public boolean isClosed() {
+        return state == STATE_CLOSED;
     }
 
-    try {
-      while (true) {
-        StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict());
+    public void closeIfOwnedBy(Object owner) throws IOException {
+        Internal.instance.closeIfOwnedBy(connection, owner);
+    }
 
-        Response.Builder responseBuilder = new Response.Builder()
-            .protocol(statusLine.protocol)
-            .code(statusLine.code)
-            .message(statusLine.message);
+    public void flush() throws IOException {
+        sink.flush();
+    }
 
-        Headers.Builder headersBuilder = new Headers.Builder();
-        readHeaders(headersBuilder);
-        headersBuilder.add(OkHeaders.SELECTED_PROTOCOL, statusLine.protocol.toString());
-        responseBuilder.headers(headersBuilder.build());
+    /**
+     * Returns the number of buffered bytes immediately readable.
+     */
+    public long bufferSize() {
+        return source.buffer().size();
+    }
 
-        if (statusLine.code != HTTP_CONTINUE) {
-          state = STATE_OPEN_RESPONSE_BODY;
-          return responseBuilder;
+    /**
+     * Test for a stale socket.
+     */
+    public boolean isReadable() {
+        try {
+            int readTimeout = socket.getSoTimeout();
+            try {
+                socket.setSoTimeout(1);
+                if (source.exhausted()) {
+                    return false; // Stream is exhausted; socket is closed.
+                }
+                return true;
+            } finally {
+                socket.setSoTimeout(readTimeout);
+            }
+        } catch (SocketTimeoutException ignored) {
+            return true; // Read timed out; socket is good.
+        } catch (IOException e) {
+            return false; // Couldn't read; socket is closed.
         }
-      }
-    } catch (EOFException e) {
-      // Provide more context if the server ends the stream before sending a response.
-      IOException exception = new IOException("unexpected end of stream on " + connection
-          + " (recycle count=" + Internal.instance.recycleCount(connection) + ")");
-      exception.initCause(e);
-      throw exception;
     }
-  }
 
-  /** Reads headers or trailers into {@code builder}. */
-  public void readHeaders(Headers.Builder builder) throws IOException {
-    // parse the result headers until the first blank line
-    for (String line; (line = source.readUtf8LineStrict()).length() != 0; ) {
-      Internal.instance.addLenient(builder, line);
-    }
-  }
-
-  public Sink newChunkedSink() {
-    if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException("state: " + state);
-    state = STATE_WRITING_REQUEST_BODY;
-    return new ChunkedSink();
-  }
-
-  public Sink newFixedLengthSink(long contentLength) {
-    if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException("state: " + state);
-    state = STATE_WRITING_REQUEST_BODY;
-    return new FixedLengthSink(contentLength);
-  }
-
-  public void writeRequestBody(RetryableSink requestBody) throws IOException {
-    if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException("state: " + state);
-    state = STATE_READ_RESPONSE_HEADERS;
-    requestBody.writeToSocket(sink);
-  }
-
-  public Source newFixedLengthSource(long length) throws IOException {
-    if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
-    state = STATE_READING_RESPONSE_BODY;
-    return new FixedLengthSource(length);
-  }
-
-  public Source newChunkedSource(HttpEngine httpEngine) throws IOException {
-    if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
-    state = STATE_READING_RESPONSE_BODY;
-    return new ChunkedSource(httpEngine);
-  }
-
-  public Source newUnknownLengthSource() throws IOException {
-    if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
-    state = STATE_READING_RESPONSE_BODY;
-    return new UnknownLengthSource();
-  }
-
-  public BufferedSink rawSink() {
-    return sink;
-  }
-
-  public BufferedSource rawSource() {
-    return source;
-  }
-
-  /**
-   * Sets the delegate of {@code timeout} to {@link Timeout#NONE} and resets its underlying timeout
-   * to the default configuration. Use this to avoid unexpected sharing of timeouts between pooled
-   * connections.
-   */
-  private void detachTimeout(ForwardingTimeout timeout) {
-    Timeout oldDelegate = timeout.delegate();
-    timeout.setDelegate(Timeout.NONE);
-    oldDelegate.clearDeadline();
-    oldDelegate.clearTimeout();
-  }
-
-  /** An HTTP body with a fixed length known in advance. */
-  private final class FixedLengthSink implements Sink {
-    private final ForwardingTimeout timeout = new ForwardingTimeout(sink.timeout());
-    private boolean closed;
-    private long bytesRemaining;
-
-    private FixedLengthSink(long bytesRemaining) {
-      this.bytesRemaining = bytesRemaining;
+    /**
+     * Returns bytes of a request header for sending on an HTTP transport.
+     */
+    public void writeRequest(Headers headers, String requestLine) throws IOException {
+        if (state != STATE_IDLE) throw new IllegalStateException("state: " + state);
+        sink.writeUtf8(requestLine).writeUtf8("\r\n");
+        for (int i = 0, size = headers.size(); i < size; i++) {
+            sink.writeUtf8(headers.name(i))
+                    .writeUtf8(": ")
+                    .writeUtf8(headers.value(i))
+                    .writeUtf8("\r\n");
+        }
+        sink.writeUtf8("\r\n");
+        state = STATE_OPEN_REQUEST_BODY;
     }
 
-    @Override public Timeout timeout() {
-      return timeout;
-    }
+    /**
+     * Parses bytes of a response header from an HTTP transport.
+     */
+    public Response.Builder readResponse() throws IOException {
+        if (state != STATE_OPEN_REQUEST_BODY && state != STATE_READ_RESPONSE_HEADERS) {
+            throw new IllegalStateException("state: " + state);
+        }
 
-    @Override public void write(Buffer source, long byteCount) throws IOException {
-      if (closed) throw new IllegalStateException("closed");
-      checkOffsetAndCount(source.size(), 0, byteCount);
-      if (byteCount > bytesRemaining) {
-        throw new ProtocolException("expected " + bytesRemaining
-            + " bytes but received " + byteCount);
-      }
-      sink.write(source, byteCount);
-      bytesRemaining -= byteCount;
+        try {
+            while (true) {
+                StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict());
+
+                Response.Builder responseBuilder = new Response.Builder()
+                        .protocol(statusLine.protocol)
+                        .code(statusLine.code)
+                        .message(statusLine.message);
+
+                Headers.Builder headersBuilder = new Headers.Builder();
+                readHeaders(headersBuilder);
+                headersBuilder.add(OkHeaders.SELECTED_PROTOCOL, statusLine.protocol.toString());
+                responseBuilder.headers(headersBuilder.build());
+
+                if (statusLine.code != HTTP_CONTINUE) {
+                    state = STATE_OPEN_RESPONSE_BODY;
+                    return responseBuilder;
+                }
+            }
+        } catch (EOFException e) {
+            // Provide more context if the server ends the stream before sending a response.
+            IOException exception = new IOException("unexpected end of stream on " + connection
+                    + " (recycle count=" + Internal.instance.recycleCount(connection) + ")");
+            exception.initCause(e);
+            throw exception;
+        }
     }
 
-    @Override public void flush() throws IOException {
-      if (closed) return; // Don't throw; this stream might have been closed on the caller's behalf.
-      sink.flush();
+    /**
+     * Reads headers or trailers into {@code builder}.
+     */
+    public void readHeaders(Headers.Builder builder) throws IOException {
+        // parse the result headers until the first blank line
+        for (String line; (line = source.readUtf8LineStrict()).length() != 0; ) {
+            Internal.instance.addLenient(builder, line);
+        }
     }
 
-    @Override public void close() throws IOException {
-      if (closed) return;
-      closed = true;
-      if (bytesRemaining > 0) throw new ProtocolException("unexpected end of stream");
-      detachTimeout(timeout);
-      state = STATE_READ_RESPONSE_HEADERS;
+    public Sink newChunkedSink() {
+        if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException("state: " + state);
+        state = STATE_WRITING_REQUEST_BODY;
+        return new ChunkedSink();
     }
-  }
-
-  /**
-   * An HTTP body with alternating chunk sizes and chunk bodies. It is the
-   * caller's responsibility to buffer chunks; typically by using a buffered
-   * sink with this sink.
-   */
-  private final class ChunkedSink implements Sink {
-    private final ForwardingTimeout timeout = new ForwardingTimeout(sink.timeout());
-    private boolean closed;
-
-    @Override public Timeout timeout() {
-      return timeout;
+
+    public Sink newFixedLengthSink(long contentLength) {
+        if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException("state: " + state);
+        state = STATE_WRITING_REQUEST_BODY;
+        return new FixedLengthSink(contentLength);
     }
 
-    @Override public void write(Buffer source, long byteCount) throws IOException {
-      if (closed) throw new IllegalStateException("closed");
-      if (byteCount == 0) return;
+    public void writeRequestBody(RetryableSink requestBody) throws IOException {
+        if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException("state: " + state);
+        state = STATE_READ_RESPONSE_HEADERS;
+        requestBody.writeToSocket(sink);
+    }
 
-      sink.writeHexadecimalUnsignedLong(byteCount);
-      sink.writeUtf8("\r\n");
-      sink.write(source, byteCount);
-      sink.writeUtf8("\r\n");
+    public Source newFixedLengthSource(long length) throws IOException {
+        if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
+        state = STATE_READING_RESPONSE_BODY;
+        return new FixedLengthSource(length);
     }
 
-    @Override public synchronized void flush() throws IOException {
-      if (closed) return; // Don't throw; this stream might have been closed on the caller's behalf.
-      sink.flush();
+    public Source newChunkedSource(HttpEngine httpEngine) throws IOException {
+        if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
+        state = STATE_READING_RESPONSE_BODY;
+        return new ChunkedSource(httpEngine);
     }
 
-    @Override public synchronized void close() throws IOException {
-      if (closed) return;
-      closed = true;
-      sink.writeUtf8("0\r\n\r\n");
-      detachTimeout(timeout);
-      state = STATE_READ_RESPONSE_HEADERS;
+    public Source newUnknownLengthSource() throws IOException {
+        if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
+        state = STATE_READING_RESPONSE_BODY;
+        return new UnknownLengthSource();
     }
-  }
 
-  private abstract class AbstractSource implements Source {
-    protected final ForwardingTimeout timeout = new ForwardingTimeout(source.timeout());
-    protected boolean closed;
+    public BufferedSink rawSink() {
+        return sink;
+    }
 
-    @Override public Timeout timeout() {
-      return timeout;
+    public BufferedSource rawSource() {
+        return source;
     }
 
     /**
-     * Closes the cache entry and makes the socket available for reuse. This
-     * should be invoked when the end of the body has been reached.
+     * Sets the delegate of {@code timeout} to {@link Timeout#NONE} and resets its underlying timeout
+     * to the default configuration. Use this to avoid unexpected sharing of timeouts between pooled
+     * connections.
      */
-    protected final void endOfInput(boolean recyclable) throws IOException {
-      if (state != STATE_READING_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
-
-      detachTimeout(timeout);
-
-      state = STATE_IDLE;
-      if (recyclable && onIdle == ON_IDLE_POOL) {
-        onIdle = ON_IDLE_HOLD; // Set the on idle policy back to the default.
-        Internal.instance.recycle(pool, connection);
-      } else if (onIdle == ON_IDLE_CLOSE) {
-        state = STATE_CLOSED;
-        connection.getSocket().close();
-      }
+    private void detachTimeout(ForwardingTimeout timeout) {
+        Timeout oldDelegate = timeout.delegate();
+        timeout.setDelegate(Timeout.NONE);
+        oldDelegate.clearDeadline();
+        oldDelegate.clearTimeout();
     }
 
     /**
-     * Calls abort on the cache entry and disconnects the socket. This
-     * should be invoked when the connection is closed unexpectedly to
-     * invalidate the cache entry and to prevent the HTTP connection from
-     * being reused. HTTP messages are sent in serial so whenever a message
-     * cannot be read to completion, subsequent messages cannot be read
-     * either and the connection must be discarded.
-     *
-     * <p>An earlier implementation skipped the remaining bytes, but this
-     * requires that the entire transfer be completed. If the intention was
-     * to cancel the transfer, closing the connection is the only solution.
+     * An HTTP body with a fixed length known in advance.
      */
-    protected final void unexpectedEndOfInput() {
-      Util.closeQuietly(connection.getSocket());
-      state = STATE_CLOSED;
-    }
-  }
+    private final class FixedLengthSink implements Sink {
+        private final ForwardingTimeout timeout = new ForwardingTimeout(sink.timeout());
+        private boolean closed;
+        private long bytesRemaining;
 
-  /** An HTTP body with a fixed length specified in advance. */
-  private class FixedLengthSource extends AbstractSource {
-    private long bytesRemaining;
+        private FixedLengthSink(long bytesRemaining) {
+            this.bytesRemaining = bytesRemaining;
+        }
 
-    public FixedLengthSource(long length) throws IOException {
-      bytesRemaining = length;
-      if (bytesRemaining == 0) {
-        endOfInput(true);
-      }
-    }
+        @Override
+        public Timeout timeout() {
+            return timeout;
+        }
+
+        @Override
+        public void write(Buffer source, long byteCount) throws IOException {
+            if (closed) throw new IllegalStateException("closed");
+            checkOffsetAndCount(source.size(), 0, byteCount);
+            if (byteCount > bytesRemaining) {
+                throw new ProtocolException("expected " + bytesRemaining
+                        + " bytes but received " + byteCount);
+            }
+            sink.write(source, byteCount);
+            bytesRemaining -= byteCount;
+        }
 
-    @Override public long read(Buffer sink, long byteCount) throws IOException {
-      if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
-      if (closed) throw new IllegalStateException("closed");
-      if (bytesRemaining == 0) return -1;
-
-      long read = source.read(sink, Math.min(bytesRemaining, byteCount));
-      if (read == -1) {
-        unexpectedEndOfInput(); // The server didn't supply the promised content length.
-        throw new ProtocolException("unexpected end of stream");
-      }
-
-      bytesRemaining -= read;
-      if (bytesRemaining == 0) {
-        endOfInput(true);
-      }
-      return read;
+        @Override
+        public void flush() throws IOException {
+            if (closed)
+                return; // Don't throw; this stream might have been closed on the caller's behalf.
+            sink.flush();
+        }
+
+        @Override
+        public void close() throws IOException {
+            if (closed) return;
+            closed = true;
+            if (bytesRemaining > 0) throw new ProtocolException("unexpected end of stream");
+            detachTimeout(timeout);
+            state = STATE_READ_RESPONSE_HEADERS;
+        }
     }
 
-    @Override public void close() throws IOException {
-      if (closed) return;
+    /**
+     * An HTTP body with alternating chunk sizes and chunk bodies. It is the
+     * caller's responsibility to buffer chunks; typically by using a buffered
+     * sink with this sink.
+     */
+    private final class ChunkedSink implements Sink {
+        private final ForwardingTimeout timeout = new ForwardingTimeout(sink.timeout());
+        private boolean closed;
 
-      if (bytesRemaining != 0
-          && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-        unexpectedEndOfInput();
-      }
+        @Override
+        public Timeout timeout() {
+            return timeout;
+        }
 
-      closed = true;
-    }
-  }
+        @Override
+        public void write(Buffer source, long byteCount) throws IOException {
+            if (closed) throw new IllegalStateException("closed");
+            if (byteCount == 0) return;
+
+            sink.writeHexadecimalUnsignedLong(byteCount);
+            sink.writeUtf8("\r\n");
+            sink.write(source, byteCount);
+            sink.writeUtf8("\r\n");
+        }
 
-  /** An HTTP body with alternating chunk sizes and chunk bodies. */
-  private class ChunkedSource extends AbstractSource {
-    private static final long NO_CHUNK_YET = -1L;
-    private long bytesRemainingInChunk = NO_CHUNK_YET;
-    private boolean hasMoreChunks = true;
-    private final HttpEngine httpEngine;
+        @Override
+        public synchronized void flush() throws IOException {
+            if (closed)
+                return; // Don't throw; this stream might have been closed on the caller's behalf.
+            sink.flush();
+        }
 
-    ChunkedSource(HttpEngine httpEngine) throws IOException {
-      this.httpEngine = httpEngine;
+        @Override
+        public synchronized void close() throws IOException {
+            if (closed) return;
+            closed = true;
+            sink.writeUtf8("0\r\n\r\n");
+            detachTimeout(timeout);
+            state = STATE_READ_RESPONSE_HEADERS;
+        }
     }
 
-    @Override public long read(Buffer sink, long byteCount) throws IOException {
-      if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
-      if (closed) throw new IllegalStateException("closed");
-      if (!hasMoreChunks) return -1;
-
-      if (bytesRemainingInChunk == 0 || bytesRemainingInChunk == NO_CHUNK_YET) {
-        readChunkSize();
-        if (!hasMoreChunks) return -1;
-      }
-
-      long read = source.read(sink, Math.min(byteCount, bytesRemainingInChunk));
-      if (read == -1) {
-        unexpectedEndOfInput(); // The server didn't supply the promised chunk length.
-        throw new ProtocolException("unexpected end of stream");
-      }
-      bytesRemainingInChunk -= read;
-      return read;
-    }
+    private abstract class AbstractSource implements Source {
+        protected final ForwardingTimeout timeout = new ForwardingTimeout(source.timeout());
+        protected boolean closed;
+
+        @Override
+        public Timeout timeout() {
+            return timeout;
+        }
 
-    private void readChunkSize() throws IOException {
-      // Read the suffix of the previous chunk.
-      if (bytesRemainingInChunk != NO_CHUNK_YET) {
-        source.readUtf8LineStrict();
-      }
-      try {
-        bytesRemainingInChunk = source.readHexadecimalUnsignedLong();
-        String extensions = source.readUtf8LineStrict().trim();
-        if (bytesRemainingInChunk < 0 || (!extensions.isEmpty() && !extensions.startsWith(";"))) {
-          throw new ProtocolException("expected chunk size and optional extensions but was \""
-              + bytesRemainingInChunk + extensions + "\"");
+        /**
+         * Closes the cache entry and makes the socket available for reuse. This
+         * should be invoked when the end of the body has been reached.
+         */
+        protected final void endOfInput(boolean recyclable) throws IOException {
+            if (state != STATE_READING_RESPONSE_BODY)
+                throw new IllegalStateException("state: " + state);
+
+            detachTimeout(timeout);
+
+            state = STATE_IDLE;
+            if (recyclable && onIdle == ON_IDLE_POOL) {
+                onIdle = ON_IDLE_HOLD; // Set the on idle policy back to the default.
+                Internal.instance.recycle(pool, connection);
+            } else if (onIdle == ON_IDLE_CLOSE) {
+                state = STATE_CLOSED;
+                connection.getSocket().close();
+            }
+        }
+
+        /**
+         * Calls abort on the cache entry and disconnects the socket. This
+         * should be invoked when the connection is closed unexpectedly to
+         * invalidate the cache entry and to prevent the HTTP connection from
+         * being reused. HTTP messages are sent in serial so whenever a message
+         * cannot be read to completion, subsequent messages cannot be read
+         * either and the connection must be discarded.
+         * <p/>
+         * <p>An earlier implementation skipped the remaining bytes, but this
+         * requires that the entire transfer be completed. If the intention was
+         * to cancel the transfer, closing the connection is the only solution.
+         */
+        protected final void unexpectedEndOfInput() {
+            Util.closeQuietly(connection.getSocket());
+            state = STATE_CLOSED;
         }
-      } catch (NumberFormatException e) {
-        throw new ProtocolException(e.getMessage());
-      }
-      if (bytesRemainingInChunk == 0L) {
-        hasMoreChunks = false;
-        Headers.Builder trailersBuilder = new Headers.Builder();
-        readHeaders(trailersBuilder);
-        httpEngine.receiveHeaders(trailersBuilder.build());
-        endOfInput(true);
-      }
     }
 
-    @Override public void close() throws IOException {
-      if (closed) return;
-      if (hasMoreChunks && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-        unexpectedEndOfInput();
-      }
-      closed = true;
+    /**
+     * An HTTP body with a fixed length specified in advance.
+     */
+    private class FixedLengthSource extends AbstractSource {
+        private long bytesRemaining;
+
+        public FixedLengthSource(long length) throws IOException {
+            bytesRemaining = length;
+            if (bytesRemaining == 0) {
+                endOfInput(true);
+            }
+        }
+
+        @Override
+        public long read(Buffer sink, long byteCount) throws IOException {
+            if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
+            if (closed) throw new IllegalStateException("closed");
+            if (bytesRemaining == 0) return -1;
+
+            long read = source.read(sink, Math.min(bytesRemaining, byteCount));
+            if (read == -1) {
+                unexpectedEndOfInput(); // The server didn't supply the promised content length.
+                throw new ProtocolException("unexpected end of stream");
+            }
+
+            bytesRemaining -= read;
+            if (bytesRemaining == 0) {
+                endOfInput(true);
+            }
+            return read;
+        }
+
+        @Override
+        public void close() throws IOException {
+            if (closed) return;
+
+            if (bytesRemaining != 0
+                    && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
+                unexpectedEndOfInput();
+            }
+
+            closed = true;
+        }
     }
-  }
-
-  /** An HTTP message body terminated by the end of the underlying stream. */
-  private class UnknownLengthSource extends AbstractSource {
-    private boolean inputExhausted;
-
-    @Override public long read(Buffer sink, long byteCount)
-        throws IOException {
-      if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
-      if (closed) throw new IllegalStateException("closed");
-      if (inputExhausted) return -1;
-
-      long read = source.read(sink, byteCount);
-      if (read == -1) {
-        inputExhausted = true;
-        endOfInput(false);
-        return -1;
-      }
-      return read;
+
+    /**
+     * An HTTP body with alternating chunk sizes and chunk bodies.
+     */
+    private class ChunkedSource extends AbstractSource {
+        private static final long NO_CHUNK_YET = -1L;
+        private long bytesRemainingInChunk = NO_CHUNK_YET;
+        private boolean hasMoreChunks = true;
+        private final HttpEngine httpEngine;
+
+        ChunkedSource(HttpEngine httpEngine) throws IOException {
+            this.httpEngine = httpEngine;
+        }
+
+        @Override
+        public long read(Buffer sink, long byteCount) throws IOException {
+            if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
+            if (closed) throw new IllegalStateException("closed");
+            if (!hasMoreChunks) return -1;
+
+            if (bytesRemainingInChunk == 0 || bytesRemainingInChunk == NO_CHUNK_YET) {
+                readChunkSize();
+                if (!hasMoreChunks) return -1;
+            }
+
+            long read = source.read(sink, Math.min(byteCount, bytesRemainingInChunk));
+            if (read == -1) {
+                unexpectedEndOfInput(); // The server didn't supply the promised chunk length.
+                throw new ProtocolException("unexpected end of stream");
+            }
+            bytesRemainingInChunk -= read;
+            return read;
+        }
+
+        private void readChunkSize() throws IOException {
+            // Read the suffix of the previous chunk.
+            if (bytesRemainingInChunk != NO_CHUNK_YET) {
+                source.readUtf8LineStrict();
+            }
+            try {
+                bytesRemainingInChunk = source.readHexadecimalUnsignedLong();
+                String extensions = source.readUtf8LineStrict().trim();
+                if (bytesRemainingInChunk < 0 || (!extensions.isEmpty() && !extensions.startsWith(";"))) {
+                    throw new ProtocolException("expected chunk size and optional extensions but was \""
+                            + bytesRemainingInChunk + extensions + "\"");
+                }
+            } catch (NumberFormatException e) {
+                throw new ProtocolException(e.getMessage());
+            }
+            if (bytesRemainingInChunk == 0L) {
+                hasMoreChunks = false;
+                Headers.Builder trailersBuilder = new Headers.Builder();
+                readHeaders(trailersBuilder);
+                httpEngine.receiveHeaders(trailersBuilder.build());
+                endOfInput(true);
+            }
+        }
+
+        @Override
+        public void close() throws IOException {
+            if (closed) return;
+            if (hasMoreChunks && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
+                unexpectedEndOfInput();
+            }
+            closed = true;
+        }
     }
 
-    @Override public void close() throws IOException {
-      if (closed) return;
-      if (!inputExhausted) {
-        unexpectedEndOfInput();
-      }
-      closed = true;
+    /**
+     * An HTTP message body terminated by the end of the underlying stream.
+     */
+    private class UnknownLengthSource extends AbstractSource {
+        private boolean inputExhausted;
+
+        @Override
+        public long read(Buffer sink, long byteCount)
+                throws IOException {
+            if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
+            if (closed) throw new IllegalStateException("closed");
+            if (inputExhausted) return -1;
+
+            long read = source.read(sink, byteCount);
+            if (read == -1) {
+                inputExhausted = true;
+                endOfInput(false);
+                return -1;
+            }
+            return read;
+        }
+
+        @Override
+        public void close() throws IOException {
+            if (closed) return;
+            if (!inputExhausted) {
+                unexpectedEndOfInput();
+            }
+            closed = true;
+        }
     }
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpDate.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpDate.java
index 27511b37ca..73ee9dc52f 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpDate.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpDate.java
@@ -28,92 +28,99 @@
  */
 public final class HttpDate {
 
-  private static final TimeZone GMT = TimeZone.getTimeZone("GMT");
+    private static final TimeZone GMT = TimeZone.getTimeZone("GMT");
 
-  /**
-   * Most websites serve cookies in the blessed format. Eagerly create the parser to ensure such
-   * cookies are on the fast path.
-   */
-  private static final ThreadLocal<DateFormat> STANDARD_DATE_FORMAT =
-      new ThreadLocal<DateFormat>() {
-        @Override protected DateFormat initialValue() {
-          // RFC 2616 specified: RFC 822, updated by RFC 1123 format with fixed GMT.
-          DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss 'GMT'", Locale.US);
-          rfc1123.setLenient(false);
-          rfc1123.setTimeZone(GMT);
-          return rfc1123;
-        }
-      };
+    /**
+     * Most websites serve cookies in the blessed format. Eagerly create the parser to ensure such
+     * cookies are on the fast path.
+     */
+    private static final ThreadLocal<DateFormat> STANDARD_DATE_FORMAT =
+            new ThreadLocal<DateFormat>() {
+                @Override
+                protected DateFormat initialValue() {
+                    // RFC 2616 specified: RFC 822, updated by RFC 1123 format with fixed GMT.
+                    DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss 'GMT'", Locale.US);
+                    rfc1123.setLenient(false);
+                    rfc1123.setTimeZone(GMT);
+                    return rfc1123;
+                }
+            };
 
-  /** If we fail to parse a date in a non-standard format, try each of these formats in sequence. */
-  private static final String[] BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS = new String[] {
-      // HTTP formats required by RFC2616 but with any timezone.
-      "EEE, dd MMM yyyy HH:mm:ss zzz", // RFC 822, updated by RFC 1123 with any TZ
-      "EEEE, dd-MMM-yy HH:mm:ss zzz", // RFC 850, obsoleted by RFC 1036 with any TZ.
-      "EEE MMM d HH:mm:ss yyyy", // ANSI C's asctime() format
-       // Alternative formats.
-      "EEE, dd-MMM-yyyy HH:mm:ss z",
-      "EEE, dd-MMM-yyyy HH-mm-ss z",
-      "EEE, dd MMM yy HH:mm:ss z",
-      "EEE dd-MMM-yyyy HH:mm:ss z",
-      "EEE dd MMM yyyy HH:mm:ss z",
-      "EEE dd-MMM-yyyy HH-mm-ss z",
-      "EEE dd-MMM-yy HH:mm:ss z",
-      "EEE dd MMM yy HH:mm:ss z",
-      "EEE,dd-MMM-yy HH:mm:ss z",
-      "EEE,dd-MMM-yyyy HH:mm:ss z",
-      "EEE, dd-MM-yyyy HH:mm:ss z",
+    /**
+     * If we fail to parse a date in a non-standard format, try each of these formats in sequence.
+     */
+    private static final String[] BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS = new String[]{
+            // HTTP formats required by RFC2616 but with any timezone.
+            "EEE, dd MMM yyyy HH:mm:ss zzz", // RFC 822, updated by RFC 1123 with any TZ
+            "EEEE, dd-MMM-yy HH:mm:ss zzz", // RFC 850, obsoleted by RFC 1036 with any TZ.
+            "EEE MMM d HH:mm:ss yyyy", // ANSI C's asctime() format
+            // Alternative formats.
+            "EEE, dd-MMM-yyyy HH:mm:ss z",
+            "EEE, dd-MMM-yyyy HH-mm-ss z",
+            "EEE, dd MMM yy HH:mm:ss z",
+            "EEE dd-MMM-yyyy HH:mm:ss z",
+            "EEE dd MMM yyyy HH:mm:ss z",
+            "EEE dd-MMM-yyyy HH-mm-ss z",
+            "EEE dd-MMM-yy HH:mm:ss z",
+            "EEE dd MMM yy HH:mm:ss z",
+            "EEE,dd-MMM-yy HH:mm:ss z",
+            "EEE,dd-MMM-yyyy HH:mm:ss z",
+            "EEE, dd-MM-yyyy HH:mm:ss z",
 
       /* RI bug 6641315 claims a cookie of this format was once served by www.yahoo.com */
-      "EEE MMM d yyyy HH:mm:ss z",
-  };
+            "EEE MMM d yyyy HH:mm:ss z",
+    };
 
-  private static final DateFormat[] BROWSER_COMPATIBLE_DATE_FORMATS =
-      new DateFormat[BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS.length];
+    private static final DateFormat[] BROWSER_COMPATIBLE_DATE_FORMATS =
+            new DateFormat[BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS.length];
 
-  /** Returns the date for {@code value}. Returns null if the value couldn't be parsed. */
-  public static Date parse(String value) {
-    if (value.length() == 0) {
-      return null;
-    }
+    /**
+     * Returns the date for {@code value}. Returns null if the value couldn't be parsed.
+     */
+    public static Date parse(String value) {
+        if (value.length() == 0) {
+            return null;
+        }
 
-    ParsePosition position = new ParsePosition(0);
-    Date result = STANDARD_DATE_FORMAT.get().parse(value, position);
-    if (position.getIndex() == value.length()) {
-      // STANDARD_DATE_FORMAT must match exactly; all text must be consumed, e.g. no ignored
-      // non-standard trailing "+01:00". Those cases are covered below.
-      return result;
-    }
-    synchronized (BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS) {
-      for (int i = 0, count = BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS.length; i < count; i++) {
-        DateFormat format = BROWSER_COMPATIBLE_DATE_FORMATS[i];
-        if (format == null) {
-          format = new SimpleDateFormat(BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS[i], Locale.US);
-          // Set the timezone to use when interpreting formats that don't have a timezone. GMT is
-          // specified by RFC 2616.
-          format.setTimeZone(GMT);
-          BROWSER_COMPATIBLE_DATE_FORMATS[i] = format;
+        ParsePosition position = new ParsePosition(0);
+        Date result = STANDARD_DATE_FORMAT.get().parse(value, position);
+        if (position.getIndex() == value.length()) {
+            // STANDARD_DATE_FORMAT must match exactly; all text must be consumed, e.g. no ignored
+            // non-standard trailing "+01:00". Those cases are covered below.
+            return result;
         }
-        position.setIndex(0);
-        result = format.parse(value, position);
-        if (position.getIndex() != 0) {
-          // Something was parsed. It's possible the entire string was not consumed but we ignore
-          // that. If any of the BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS ended in "'GMT'" we'd have
-          // to also check that position.getIndex() == value.length() otherwise parsing might have
-          // terminated early, ignoring things like "+01:00". Leaving this as != 0 means that any
-          // trailing junk is ignored.
-          return result;
+        synchronized (BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS) {
+            for (int i = 0, count = BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS.length; i < count; i++) {
+                DateFormat format = BROWSER_COMPATIBLE_DATE_FORMATS[i];
+                if (format == null) {
+                    format = new SimpleDateFormat(BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS[i], Locale.US);
+                    // Set the timezone to use when interpreting formats that don't have a timezone. GMT is
+                    // specified by RFC 2616.
+                    format.setTimeZone(GMT);
+                    BROWSER_COMPATIBLE_DATE_FORMATS[i] = format;
+                }
+                position.setIndex(0);
+                result = format.parse(value, position);
+                if (position.getIndex() != 0) {
+                    // Something was parsed. It's possible the entire string was not consumed but we ignore
+                    // that. If any of the BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS ended in "'GMT'" we'd have
+                    // to also check that position.getIndex() == value.length() otherwise parsing might have
+                    // terminated early, ignoring things like "+01:00". Leaving this as != 0 means that any
+                    // trailing junk is ignored.
+                    return result;
+                }
+            }
         }
-      }
+        return null;
     }
-    return null;
-  }
 
-  /** Returns the string for {@code value}. */
-  public static String format(Date value) {
-    return STANDARD_DATE_FORMAT.get().format(value);
-  }
+    /**
+     * Returns the string for {@code value}.
+     */
+    public static String format(Date value) {
+        return STANDARD_DATE_FORMAT.get().format(value);
+    }
 
-  private HttpDate() {
-  }
+    private HttpDate() {
+    }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
index 42522c8059..05baafb108 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
@@ -34,6 +34,7 @@
 import com.squareup.okhttp.internal.InternalCache;
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.Version;
+
 import java.io.IOException;
 import java.io.InterruptedIOException;
 import java.net.CookieHandler;
@@ -45,10 +46,12 @@
 import java.util.Date;
 import java.util.List;
 import java.util.Map;
+
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSocketFactory;
+
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -88,1073 +91,1095 @@
  * All responses have a response body input stream, though in some
  * instances this stream is empty.
  * </ol>
- *
+ * <p/>
  * <p>The request and response may be served by the HTTP response cache, by the
  * network, or by both in the event of a conditional GET.
  */
 public final class HttpEngine {
-  /**
-   * How many redirects and auth challenges should we attempt? Chrome follows 21 redirects; Firefox,
-   * curl, and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5.
-   */
-  public static final int MAX_FOLLOW_UPS = 20;
-
-  private static final ResponseBody EMPTY_BODY = new ResponseBody() {
-    @Override public MediaType contentType() {
-      return null;
-    }
-    @Override public long contentLength() {
-      return 0;
-    }
-    @Override public BufferedSource source() {
-      return new Buffer();
-    }
-  };
-
-  final OkHttpClient client;
-
-  private Connection connection;
-  private Address address;
-  private RouteSelector routeSelector;
-  private Route route;
-  private final Response priorResponse;
-
-  private Transport transport;
-
-  /** The time when the request headers were written, or -1 if they haven't been written yet. */
-  long sentRequestMillis = -1;
-
-  /**
-   * True if this client added an "Accept-Encoding: gzip" header field and is
-   * therefore responsible for also decompressing the transfer stream.
-   */
-  private boolean transparentGzip;
-
-  /**
-   * True if the request body must be completely buffered before transmission;
-   * false if it can be streamed. Buffering has two advantages: we don't need
-   * the content-length in advance and we can retransmit if necessary. The
-   * upside of streaming is that we can save memory.
-   */
-  public final boolean bufferRequestBody;
-
-  /**
-   * The original application-provided request. Never modified by OkHttp. When
-   * follow-up requests are necessary, they are derived from this request.
-   */
-  private final Request userRequest;
-
-  /**
-   * The request to send on the network, or null for no network request. This is
-   * derived from the user request, and customized to support OkHttp features
-   * like compression and caching.
-   */
-  private Request networkRequest;
-
-  /**
-   * The cached response, or null if the cache doesn't exist or cannot be used
-   * for this request. Conditional caching means this may be non-null even when
-   * the network request is non-null. Never modified by OkHttp.
-   */
-  private Response cacheResponse;
-
-  /**
-   * The user-visible response. This is derived from either the network
-   * response, cache response, or both. It is customized to support OkHttp
-   * features like compression and caching.
-   */
-  private Response userResponse;
-
-  private Sink requestBodyOut;
-  private BufferedSink bufferedRequestBody;
-  private final boolean callerWritesRequestBody;
-  private final boolean forWebSocket;
-
-  /** The cache request currently being populated from a network response. */
-  private CacheRequest storeRequest;
-  private CacheStrategy cacheStrategy;
-
-  /**
-   * @param request the HTTP request without a body. The body must be written via the engine's
-   *     request body stream.
-   * @param callerWritesRequestBody true for the {@code HttpURLConnection}-style interaction
-   *     model where control flow is returned to the calling application to write the request body
-   *     before the response body is readable.
-   * @param connection the connection used for an intermediate response immediately prior to this
-   *     request/response pair, such as a same-host redirect. This engine assumes ownership of the
-   *     connection and must release it when it is unneeded.
-   * @param routeSelector the route selector used for a failed attempt immediately preceding this
-   */
-  public HttpEngine(OkHttpClient client, Request request, boolean bufferRequestBody,
-      boolean callerWritesRequestBody, boolean forWebSocket, Connection connection,
-      RouteSelector routeSelector, RetryableSink requestBodyOut, Response priorResponse) {
-    this.client = client;
-    this.userRequest = request;
-    this.bufferRequestBody = bufferRequestBody;
-    this.callerWritesRequestBody = callerWritesRequestBody;
-    this.forWebSocket = forWebSocket;
-    this.connection = connection;
-    this.routeSelector = routeSelector;
-    this.requestBodyOut = requestBodyOut;
-    this.priorResponse = priorResponse;
-
-    if (connection != null) {
-      Internal.instance.setOwner(connection, this);
-      this.route = connection.getRoute();
-    } else {
-      this.route = null;
-    }
-  }
-
-  /**
-   * Figures out what the response source will be, and opens a socket to that
-   * source if necessary. Prepares the request headers and gets ready to start
-   * writing the request body if it exists.
-   *
-   * @throws RequestException if there was a problem with request setup. Unrecoverable.
-   * @throws RouteException if the was a problem during connection via a specific route. Sometimes
-   *     recoverable. See {@link #recover(RouteException)}.
-   * @throws IOException if there was a problem while making a request. Sometimes recoverable. See
-   *     {@link #recover(IOException)}.
-   *
-   */
-  public void sendRequest() throws RequestException, RouteException, IOException {
-    if (cacheStrategy != null) return; // Already sent.
-    if (transport != null) throw new IllegalStateException();
-
-    Request request = networkRequest(userRequest);
-
-    InternalCache responseCache = Internal.instance.internalCache(client);
-    Response cacheCandidate = responseCache != null
-        ? responseCache.get(request)
-        : null;
-
-    long now = System.currentTimeMillis();
-    cacheStrategy = new CacheStrategy.Factory(now, request, cacheCandidate).get();
-    networkRequest = cacheStrategy.networkRequest;
-    cacheResponse = cacheStrategy.cacheResponse;
-
-    if (responseCache != null) {
-      responseCache.trackResponse(cacheStrategy);
-    }
+    /**
+     * How many redirects and auth challenges should we attempt? Chrome follows 21 redirects; Firefox,
+     * curl, and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5.
+     */
+    public static final int MAX_FOLLOW_UPS = 20;
+
+    private static final ResponseBody EMPTY_BODY = new ResponseBody() {
+        @Override
+        public MediaType contentType() {
+            return null;
+        }
 
-    if (cacheCandidate != null && cacheResponse == null) {
-      closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.
-    }
+        @Override
+        public long contentLength() {
+            return 0;
+        }
 
-    if (networkRequest != null) {
-      // Open a connection unless we inherited one from a redirect.
-      if (connection == null) {
-        connect();
-      }
-
-      transport = Internal.instance.newTransport(connection, this);
-
-      // If the caller's control flow writes the request body, we need to create that stream
-      // immediately. And that means we need to immediately write the request headers, so we can
-      // start streaming the request body. (We may already have a request body if we're retrying a
-      // failed POST.)
-      if (callerWritesRequestBody && permitsRequestBody() && requestBodyOut == null) {
-        long contentLength = OkHeaders.contentLength(request);
-        if (bufferRequestBody) {
-          if (contentLength > Integer.MAX_VALUE) {
-            throw new IllegalStateException("Use setFixedLengthStreamingMode() or "
-                + "setChunkedStreamingMode() for requests larger than 2 GiB.");
-          }
-
-          if (contentLength != -1) {
-            // Buffer a request body of a known length.
-            transport.writeRequestHeaders(networkRequest);
-            requestBodyOut = new RetryableSink((int) contentLength);
-          } else {
-            // Buffer a request body of an unknown length. Don't write request
-            // headers until the entire body is ready; otherwise we can't set the
-            // Content-Length header correctly.
-            requestBodyOut = new RetryableSink();
-          }
-        } else {
-          transport.writeRequestHeaders(networkRequest);
-          requestBodyOut = transport.createRequestBody(networkRequest, contentLength);
+        @Override
+        public BufferedSource source() {
+            return new Buffer();
         }
-      }
+    };
 
-    } else {
-      // We aren't using the network. Recycle a connection we may have inherited from a redirect.
-      if (connection != null) {
-        Internal.instance.recycle(client.getConnectionPool(), connection);
-        connection = null;
-      }
-
-      if (cacheResponse != null) {
-        // We have a valid cached response. Promote it to the user response immediately.
-        this.userResponse = cacheResponse.newBuilder()
-            .request(userRequest)
-            .priorResponse(stripBody(priorResponse))
-            .cacheResponse(stripBody(cacheResponse))
-            .build();
-      } else {
-        // We're forbidden from using the network, and the cache is insufficient.
-        this.userResponse = new Response.Builder()
-            .request(userRequest)
-            .priorResponse(stripBody(priorResponse))
-            .protocol(Protocol.HTTP_1_1)
-            .code(504)
-            .message("Unsatisfiable Request (only-if-cached)")
-            .body(EMPTY_BODY)
-            .build();
-      }
-
-      userResponse = unzip(userResponse);
-    }
-  }
-
-  private static Response stripBody(Response response) {
-    return response != null && response.body() != null
-        ? response.newBuilder().body(null).build()
-        : response;
-  }
-
-  /** Connect to the origin server either directly or via a proxy. */
-  private void connect() throws RequestException, RouteException {
-    if (connection != null) throw new IllegalStateException();
-
-    if (routeSelector == null) {
-      address = createAddress(client, networkRequest);
-      try {
-        routeSelector = RouteSelector.get(address, networkRequest, client);
-      } catch (IOException e) {
-        throw new RequestException(e);
-      }
+    final OkHttpClient client;
+
+    private Connection connection;
+    private Address address;
+    private RouteSelector routeSelector;
+    private Route route;
+    private final Response priorResponse;
+
+    private Transport transport;
+
+    /**
+     * The time when the request headers were written, or -1 if they haven't been written yet.
+     */
+    long sentRequestMillis = -1;
+
+    /**
+     * True if this client added an "Accept-Encoding: gzip" header field and is
+     * therefore responsible for also decompressing the transfer stream.
+     */
+    private boolean transparentGzip;
+
+    /**
+     * True if the request body must be completely buffered before transmission;
+     * false if it can be streamed. Buffering has two advantages: we don't need
+     * the content-length in advance and we can retransmit if necessary. The
+     * upside of streaming is that we can save memory.
+     */
+    public final boolean bufferRequestBody;
+
+    /**
+     * The original application-provided request. Never modified by OkHttp. When
+     * follow-up requests are necessary, they are derived from this request.
+     */
+    private final Request userRequest;
+
+    /**
+     * The request to send on the network, or null for no network request. This is
+     * derived from the user request, and customized to support OkHttp features
+     * like compression and caching.
+     */
+    private Request networkRequest;
+
+    /**
+     * The cached response, or null if the cache doesn't exist or cannot be used
+     * for this request. Conditional caching means this may be non-null even when
+     * the network request is non-null. Never modified by OkHttp.
+     */
+    private Response cacheResponse;
+
+    /**
+     * The user-visible response. This is derived from either the network
+     * response, cache response, or both. It is customized to support OkHttp
+     * features like compression and caching.
+     */
+    private Response userResponse;
+
+    private Sink requestBodyOut;
+    private BufferedSink bufferedRequestBody;
+    private final boolean callerWritesRequestBody;
+    private final boolean forWebSocket;
+
+    /**
+     * The cache request currently being populated from a network response.
+     */
+    private CacheRequest storeRequest;
+    private CacheStrategy cacheStrategy;
+
+    /**
+     * @param request                 the HTTP request without a body. The body must be written via the engine's
+     *                                request body stream.
+     * @param callerWritesRequestBody true for the {@code HttpURLConnection}-style interaction
+     *                                model where control flow is returned to the calling application to write the request body
+     *                                before the response body is readable.
+     * @param connection              the connection used for an intermediate response immediately prior to this
+     *                                request/response pair, such as a same-host redirect. This engine assumes ownership of the
+     *                                connection and must release it when it is unneeded.
+     * @param routeSelector           the route selector used for a failed attempt immediately preceding this
+     */
+    public HttpEngine(OkHttpClient client, Request request, boolean bufferRequestBody,
+                      boolean callerWritesRequestBody, boolean forWebSocket, Connection connection,
+                      RouteSelector routeSelector, RetryableSink requestBodyOut, Response priorResponse) {
+        this.client = client;
+        this.userRequest = request;
+        this.bufferRequestBody = bufferRequestBody;
+        this.callerWritesRequestBody = callerWritesRequestBody;
+        this.forWebSocket = forWebSocket;
+        this.connection = connection;
+        this.routeSelector = routeSelector;
+        this.requestBodyOut = requestBodyOut;
+        this.priorResponse = priorResponse;
+
+        if (connection != null) {
+            Internal.instance.setOwner(connection, this);
+            this.route = connection.getRoute();
+        } else {
+            this.route = null;
+        }
     }
 
-    connection = nextConnection();
-    route = connection.getRoute();
-  }
-
-  /**
-   * Returns the next connection to attempt.
-   *
-   * @throws java.util.NoSuchElementException if there are no more routes to attempt.
-   */
-  private Connection nextConnection() throws RouteException {
-    Connection connection = createNextConnection();
-    Internal.instance.connectAndSetOwner(client, connection, this, networkRequest);
-    return connection;
-  }
-
-  private Connection createNextConnection() throws RouteException {
-    ConnectionPool pool = client.getConnectionPool();
-
-    // Always prefer pooled connections over new connections.
-    for (Connection pooled; (pooled = pool.get(address)) != null; ) {
-      if (networkRequest.method().equals("GET") || Internal.instance.isReadable(pooled)) {
-        return pooled;
-      }
-      closeQuietly(pooled.getSocket());
-    }
+    /**
+     * Figures out what the response source will be, and opens a socket to that
+     * source if necessary. Prepares the request headers and gets ready to start
+     * writing the request body if it exists.
+     *
+     * @throws RequestException if there was a problem with request setup. Unrecoverable.
+     * @throws RouteException   if the was a problem during connection via a specific route. Sometimes
+     *                          recoverable. See {@link #recover(RouteException)}.
+     * @throws IOException      if there was a problem while making a request. Sometimes recoverable. See
+     *                          {@link #recover(IOException)}.
+     */
+    public void sendRequest() throws RequestException, RouteException, IOException {
+        if (cacheStrategy != null) return; // Already sent.
+        if (transport != null) throw new IllegalStateException();
+
+        Request request = networkRequest(userRequest);
 
-    try {
-      Route route = routeSelector.next();
-      return new Connection(pool, route);
-    } catch (IOException e) {
-      throw new RouteException(e);
-    }
-  }
-
-  /**
-   * Called immediately before the transport transmits HTTP request headers.
-   * This is used to observe the sent time should the request be cached.
-   */
-  public void writingRequestHeaders() {
-    if (sentRequestMillis != -1) throw new IllegalStateException();
-    sentRequestMillis = System.currentTimeMillis();
-  }
-
-  boolean permitsRequestBody() {
-    return HttpMethod.permitsRequestBody(userRequest.method());
-  }
-
-  /** Returns the request body or null if this request doesn't have a body. */
-  public Sink getRequestBody() {
-    if (cacheStrategy == null) throw new IllegalStateException();
-    return requestBodyOut;
-  }
-
-  public BufferedSink getBufferedRequestBody() {
-    BufferedSink result = bufferedRequestBody;
-    if (result != null) return result;
-    Sink requestBody = getRequestBody();
-    return requestBody != null
-        ? (bufferedRequestBody = Okio.buffer(requestBody))
-        : null;
-  }
-
-  public boolean hasResponse() {
-    return userResponse != null;
-  }
-
-  public Request getRequest() {
-    return userRequest;
-  }
-
-  /** Returns the engine's response. */
-  // TODO: the returned body will always be null.
-  public Response getResponse() {
-    if (userResponse == null) throw new IllegalStateException();
-    return userResponse;
-  }
-
-  public Connection getConnection() {
-    return connection;
-  }
-
-  /**
-   * Attempt to recover from failure to connect via a route. Returns a new HTTP engine
-   * that should be used for the retry if there are other routes to try, or null if
-   * there are no more routes to try.
-   */
-  public HttpEngine recover(RouteException e) {
-    if (routeSelector != null && connection != null) {
-      connectFailed(routeSelector, e.getLastConnectException());
+        InternalCache responseCache = Internal.instance.internalCache(client);
+        Response cacheCandidate = responseCache != null
+                ? responseCache.get(request)
+                : null;
+
+        long now = System.currentTimeMillis();
+        cacheStrategy = new CacheStrategy.Factory(now, request, cacheCandidate).get();
+        networkRequest = cacheStrategy.networkRequest;
+        cacheResponse = cacheStrategy.cacheResponse;
+
+        if (responseCache != null) {
+            responseCache.trackResponse(cacheStrategy);
+        }
+
+        if (cacheCandidate != null && cacheResponse == null) {
+            closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.
+        }
+
+        if (networkRequest != null) {
+            // Open a connection unless we inherited one from a redirect.
+            if (connection == null) {
+                connect();
+            }
+
+            transport = Internal.instance.newTransport(connection, this);
+
+            // If the caller's control flow writes the request body, we need to create that stream
+            // immediately. And that means we need to immediately write the request headers, so we can
+            // start streaming the request body. (We may already have a request body if we're retrying a
+            // failed POST.)
+            if (callerWritesRequestBody && permitsRequestBody() && requestBodyOut == null) {
+                long contentLength = OkHeaders.contentLength(request);
+                if (bufferRequestBody) {
+                    if (contentLength > Integer.MAX_VALUE) {
+                        throw new IllegalStateException("Use setFixedLengthStreamingMode() or "
+                                + "setChunkedStreamingMode() for requests larger than 2 GiB.");
+                    }
+
+                    if (contentLength != -1) {
+                        // Buffer a request body of a known length.
+                        transport.writeRequestHeaders(networkRequest);
+                        requestBodyOut = new RetryableSink((int) contentLength);
+                    } else {
+                        // Buffer a request body of an unknown length. Don't write request
+                        // headers until the entire body is ready; otherwise we can't set the
+                        // Content-Length header correctly.
+                        requestBodyOut = new RetryableSink();
+                    }
+                } else {
+                    transport.writeRequestHeaders(networkRequest);
+                    requestBodyOut = transport.createRequestBody(networkRequest, contentLength);
+                }
+            }
+
+        } else {
+            // We aren't using the network. Recycle a connection we may have inherited from a redirect.
+            if (connection != null) {
+                Internal.instance.recycle(client.getConnectionPool(), connection);
+                connection = null;
+            }
+
+            if (cacheResponse != null) {
+                // We have a valid cached response. Promote it to the user response immediately.
+                this.userResponse = cacheResponse.newBuilder()
+                        .request(userRequest)
+                        .priorResponse(stripBody(priorResponse))
+                        .cacheResponse(stripBody(cacheResponse))
+                        .build();
+            } else {
+                // We're forbidden from using the network, and the cache is insufficient.
+                this.userResponse = new Response.Builder()
+                        .request(userRequest)
+                        .priorResponse(stripBody(priorResponse))
+                        .protocol(Protocol.HTTP_1_1)
+                        .code(504)
+                        .message("Unsatisfiable Request (only-if-cached)")
+                        .body(EMPTY_BODY)
+                        .build();
+            }
+
+            userResponse = unzip(userResponse);
+        }
     }
 
-    if (routeSelector == null && connection == null // No connection.
-        || routeSelector != null && !routeSelector.hasNext() // No more routes to attempt.
-        || !isRecoverable(e)) {
-      return null;
+    private static Response stripBody(Response response) {
+        return response != null && response.body() != null
+                ? response.newBuilder().body(null).build()
+                : response;
     }
 
-    Connection connection = close();
+    /**
+     * Connect to the origin server either directly or via a proxy.
+     */
+    private void connect() throws RequestException, RouteException {
+        if (connection != null) throw new IllegalStateException();
+
+        if (routeSelector == null) {
+            address = createAddress(client, networkRequest);
+            try {
+                routeSelector = RouteSelector.get(address, networkRequest, client);
+            } catch (IOException e) {
+                throw new RequestException(e);
+            }
+        }
 
-    // For failure recovery, use the same route selector with a new connection.
-    return new HttpEngine(client, userRequest, bufferRequestBody, callerWritesRequestBody,
-        forWebSocket, connection, routeSelector, (RetryableSink) requestBodyOut, priorResponse);
-  }
+        connection = nextConnection();
+        route = connection.getRoute();
+    }
 
-  private boolean isRecoverable(RouteException e) {
-    // If the application has opted-out of recovery, don't recover.
-    if (!client.getRetryOnConnectionFailure()) {
-      return false;
+    /**
+     * Returns the next connection to attempt.
+     *
+     * @throws java.util.NoSuchElementException if there are no more routes to attempt.
+     */
+    private Connection nextConnection() throws RouteException {
+        Connection connection = createNextConnection();
+        Internal.instance.connectAndSetOwner(client, connection, this, networkRequest);
+        return connection;
     }
 
-    // Problems with a route may mean the connection can be retried with a new route, or may
-    // indicate a client-side or server-side issue that should not be retried. To tell, we must look
-    // at the cause.
+    private Connection createNextConnection() throws RouteException {
+        ConnectionPool pool = client.getConnectionPool();
 
-    IOException ioe = e.getLastConnectException();
+        // Always prefer pooled connections over new connections.
+        for (Connection pooled; (pooled = pool.get(address)) != null; ) {
+            if (networkRequest.method().equals("GET") || Internal.instance.isReadable(pooled)) {
+                return pooled;
+            }
+            closeQuietly(pooled.getSocket());
+        }
 
-    // TODO(nfuller): This is the same logic as in ConnectionSpecSelector
-    // If there was a protocol problem, don't recover.
-    if (ioe instanceof ProtocolException) {
-      return false;
+        try {
+            Route route = routeSelector.next();
+            return new Connection(pool, route);
+        } catch (IOException e) {
+            throw new RouteException(e);
+        }
     }
 
-    // If there was an interruption or timeout, don't recover.
-    if (ioe instanceof InterruptedIOException) {
-      return false;
+    /**
+     * Called immediately before the transport transmits HTTP request headers.
+     * This is used to observe the sent time should the request be cached.
+     */
+    public void writingRequestHeaders() {
+        if (sentRequestMillis != -1) throw new IllegalStateException();
+        sentRequestMillis = System.currentTimeMillis();
     }
 
-    // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
-    // again with a different route.
-    if (ioe instanceof SSLHandshakeException) {
-      // If the problem was a CertificateException from the X509TrustManager,
-      // do not retry.
-      if (ioe.getCause() instanceof CertificateException) {
-        return false;
-      }
+    boolean permitsRequestBody() {
+        return HttpMethod.permitsRequestBody(userRequest.method());
     }
-    if (ioe instanceof SSLPeerUnverifiedException) {
-      // e.g. a certificate pinning error.
-      return false;
+
+    /**
+     * Returns the request body or null if this request doesn't have a body.
+     */
+    public Sink getRequestBody() {
+        if (cacheStrategy == null) throw new IllegalStateException();
+        return requestBodyOut;
     }
-    // TODO(nfuller): End of common code.
-
-    // An example of one we might want to retry with a different route is a problem connecting to a
-    // proxy and would manifest as a standard IOException. Unless it is one we know we should not
-    // retry, we return true and try a new route.
-    return true;
-  }
-
-  /**
-   * Report and attempt to recover from a failure to communicate with a server. Returns a new
-   * HTTP engine that should be used for the retry if {@code e} is recoverable, or null if
-   * the failure is permanent. Requests with a body can only be recovered if the
-   * body is buffered.
-   */
-  public HttpEngine recover(IOException e, Sink requestBodyOut) {
-    if (routeSelector != null && connection != null) {
-      connectFailed(routeSelector, e);
+
+    public BufferedSink getBufferedRequestBody() {
+        BufferedSink result = bufferedRequestBody;
+        if (result != null) return result;
+        Sink requestBody = getRequestBody();
+        return requestBody != null
+                ? (bufferedRequestBody = Okio.buffer(requestBody))
+                : null;
     }
 
-    boolean canRetryRequestBody = requestBodyOut == null || requestBodyOut instanceof RetryableSink;
-    if (routeSelector == null && connection == null // No connection.
-        || routeSelector != null && !routeSelector.hasNext() // No more routes to attempt.
-        || !isRecoverable(e)
-        || !canRetryRequestBody) {
-      return null;
+    public boolean hasResponse() {
+        return userResponse != null;
     }
 
-    Connection connection = close();
+    public Request getRequest() {
+        return userRequest;
+    }
 
-    // For failure recovery, use the same route selector with a new connection.
-    return new HttpEngine(client, userRequest, bufferRequestBody, callerWritesRequestBody,
-        forWebSocket, connection, routeSelector, (RetryableSink) requestBodyOut, priorResponse);
-  }
+    /**
+     * Returns the engine's response.
+     */
+    // TODO: the returned body will always be null.
+    public Response getResponse() {
+        if (userResponse == null) throw new IllegalStateException();
+        return userResponse;
+    }
 
-  private void connectFailed(RouteSelector routeSelector, IOException e) {
-    // If this is a recycled connection, don't count its failure against the route.
-    if (Internal.instance.recycleCount(connection) > 0) return;
-    Route failedRoute = connection.getRoute();
-    routeSelector.connectFailed(failedRoute, e);
-  }
+    public Connection getConnection() {
+        return connection;
+    }
 
-  public HttpEngine recover(IOException e) {
-    return recover(e, requestBodyOut);
-  }
+    /**
+     * Attempt to recover from failure to connect via a route. Returns a new HTTP engine
+     * that should be used for the retry if there are other routes to try, or null if
+     * there are no more routes to try.
+     */
+    public HttpEngine recover(RouteException e) {
+        if (routeSelector != null && connection != null) {
+            connectFailed(routeSelector, e.getLastConnectException());
+        }
 
-  private boolean isRecoverable(IOException e) {
-    // If the application has opted-out of recovery, don't recover.
-    if (!client.getRetryOnConnectionFailure()) {
-      return false;
-    }
+        if (routeSelector == null && connection == null // No connection.
+                || routeSelector != null && !routeSelector.hasNext() // No more routes to attempt.
+                || !isRecoverable(e)) {
+            return null;
+        }
 
-    // If there was a protocol problem, don't recover.
-    if (e instanceof ProtocolException) {
-      return false;
-    }
+        Connection connection = close();
 
-    // If there was an interruption or timeout, don't recover.
-    if (e instanceof InterruptedIOException) {
-      return false;
+        // For failure recovery, use the same route selector with a new connection.
+        return new HttpEngine(client, userRequest, bufferRequestBody, callerWritesRequestBody,
+                forWebSocket, connection, routeSelector, (RetryableSink) requestBodyOut, priorResponse);
     }
 
-    return true;
-  }
+    private boolean isRecoverable(RouteException e) {
+        // If the application has opted-out of recovery, don't recover.
+        if (!client.getRetryOnConnectionFailure()) {
+            return false;
+        }
 
-  /**
-   * Returns the route used to retrieve the response. Null if we haven't
-   * connected yet, or if no connection was necessary.
-   */
-  public Route getRoute() {
-    return route;
-  }
+        // Problems with a route may mean the connection can be retried with a new route, or may
+        // indicate a client-side or server-side issue that should not be retried. To tell, we must look
+        // at the cause.
 
-  private void maybeCache() throws IOException {
-    InternalCache responseCache = Internal.instance.internalCache(client);
-    if (responseCache == null) return;
+        IOException ioe = e.getLastConnectException();
 
-    // Should we cache this response for this request?
-    if (!CacheStrategy.isCacheable(userResponse, networkRequest)) {
-      if (HttpMethod.invalidatesCache(networkRequest.method())) {
-        try {
-          responseCache.remove(networkRequest);
-        } catch (IOException ignored) {
-          // The cache cannot be written.
+        // TODO(nfuller): This is the same logic as in ConnectionSpecSelector
+        // If there was a protocol problem, don't recover.
+        if (ioe instanceof ProtocolException) {
+            return false;
         }
-      }
-      return;
-    }
-
-    // Offer this request to the cache.
-    storeRequest = responseCache.put(stripBody(userResponse));
-  }
-
-  /**
-   * Configure the socket connection to be either pooled or closed when it is
-   * either exhausted or closed. If it is unneeded when this is called, it will
-   * be released immediately.
-   */
-  public void releaseConnection() throws IOException {
-    if (transport != null && connection != null) {
-      transport.releaseConnectionOnIdle();
-    }
-    connection = null;
-  }
-
-  /**
-   * Immediately closes the socket connection if it's currently held by this
-   * engine. Use this to interrupt an in-flight request from any thread. It's
-   * the caller's responsibility to close the request body and response body
-   * streams; otherwise resources may be leaked.
-   */
-  public void disconnect() {
-    if (transport != null) {
-      try {
-        transport.disconnect(this);
-      } catch (IOException ignored) {
-      }
-    }
-  }
-
-  /**
-   * Release any resources held by this engine. If a connection is still held by
-   * this engine, it is returned.
-   */
-  public Connection close() {
-    if (bufferedRequestBody != null) {
-      // This also closes the wrapped requestBodyOut.
-      closeQuietly(bufferedRequestBody);
-    } else if (requestBodyOut != null) {
-      closeQuietly(requestBodyOut);
-    }
 
-    // If this engine never achieved a response body, its connection cannot be reused.
-    if (userResponse == null) {
-      if (connection != null) closeQuietly(connection.getSocket()); // TODO: does this break SPDY?
-      connection = null;
-      return null;
-    }
+        // If there was an interruption or timeout, don't recover.
+        if (ioe instanceof InterruptedIOException) {
+            return false;
+        }
 
-    // Close the response body. This will recycle the connection if it is eligible.
-    closeQuietly(userResponse.body());
+        // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
+        // again with a different route.
+        if (ioe instanceof SSLHandshakeException) {
+            // If the problem was a CertificateException from the X509TrustManager,
+            // do not retry.
+            if (ioe.getCause() instanceof CertificateException) {
+                return false;
+            }
+        }
+        if (ioe instanceof SSLPeerUnverifiedException) {
+            // e.g. a certificate pinning error.
+            return false;
+        }
+        // TODO(nfuller): End of common code.
 
-    // Close the connection if it cannot be reused.
-    if (transport != null && connection != null && !transport.canReuseConnection()) {
-      closeQuietly(connection.getSocket());
-      connection = null;
-      return null;
+        // An example of one we might want to retry with a different route is a problem connecting to a
+        // proxy and would manifest as a standard IOException. Unless it is one we know we should not
+        // retry, we return true and try a new route.
+        return true;
     }
 
-    // Prevent this engine from disconnecting a connection it no longer owns.
-    if (connection != null && !Internal.instance.clearOwner(connection)) {
-      connection = null;
-    }
+    /**
+     * Report and attempt to recover from a failure to communicate with a server. Returns a new
+     * HTTP engine that should be used for the retry if {@code e} is recoverable, or null if
+     * the failure is permanent. Requests with a body can only be recovered if the
+     * body is buffered.
+     */
+    public HttpEngine recover(IOException e, Sink requestBodyOut) {
+        if (routeSelector != null && connection != null) {
+            connectFailed(routeSelector, e);
+        }
 
-    Connection result = connection;
-    connection = null;
-    return result;
-  }
-
-  /**
-   * Returns a new response that does gzip decompression on {@code response}, if transparent gzip
-   * was both offered by OkHttp and used by the origin server.
-   *
-   * <p>In addition to decompression, this will also strip the corresponding headers. We strip the
-   * Content-Encoding header to prevent the application from attempting to double decompress. We
-   * strip the Content-Length header because it is the length of the compressed content, but the
-   * application is only interested in the length of the uncompressed content.
-   *
-   * <p>This method should only be used for non-empty response bodies. Response codes like "304 Not
-   * Modified" can include "Content-Encoding: gzip" without a response body and we will crash if we
-   * attempt to decompress the zero-byte source.
-   */
-  private Response unzip(final Response response) throws IOException {
-    if (!transparentGzip || !"gzip".equalsIgnoreCase(userResponse.header("Content-Encoding"))) {
-      return response;
-    }
+        boolean canRetryRequestBody = requestBodyOut == null || requestBodyOut instanceof RetryableSink;
+        if (routeSelector == null && connection == null // No connection.
+                || routeSelector != null && !routeSelector.hasNext() // No more routes to attempt.
+                || !isRecoverable(e)
+                || !canRetryRequestBody) {
+            return null;
+        }
 
-    if (response.body() == null) {
-      return response;
-    }
+        Connection connection = close();
 
-    GzipSource responseBody = new GzipSource(response.body().source());
-    Headers strippedHeaders = response.headers().newBuilder()
-        .removeAll("Content-Encoding")
-        .removeAll("Content-Length")
-        .build();
-    return response.newBuilder()
-        .headers(strippedHeaders)
-        .body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)))
-        .build();
-  }
-
-  /**
-   * Returns true if the response must have a (possibly 0-length) body.
-   * See RFC 2616 section 4.3.
-   */
-  public static boolean hasBody(Response response) {
-    // HEAD requests never yield a body regardless of the response headers.
-    if (response.request().method().equals("HEAD")) {
-      return false;
+        // For failure recovery, use the same route selector with a new connection.
+        return new HttpEngine(client, userRequest, bufferRequestBody, callerWritesRequestBody,
+                forWebSocket, connection, routeSelector, (RetryableSink) requestBodyOut, priorResponse);
     }
 
-    int responseCode = response.code();
-    if ((responseCode < HTTP_CONTINUE || responseCode >= 200)
-        && responseCode != HTTP_NO_CONTENT
-        && responseCode != HTTP_NOT_MODIFIED) {
-      return true;
+    private void connectFailed(RouteSelector routeSelector, IOException e) {
+        // If this is a recycled connection, don't count its failure against the route.
+        if (Internal.instance.recycleCount(connection) > 0) return;
+        Route failedRoute = connection.getRoute();
+        routeSelector.connectFailed(failedRoute, e);
     }
 
-    // If the Content-Length or Transfer-Encoding headers disagree with the
-    // response code, the response is malformed. For best compatibility, we
-    // honor the headers.
-    if (OkHeaders.contentLength(response) != -1
-        || "chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {
-      return true;
+    public HttpEngine recover(IOException e) {
+        return recover(e, requestBodyOut);
     }
 
-    return false;
-  }
+    private boolean isRecoverable(IOException e) {
+        // If the application has opted-out of recovery, don't recover.
+        if (!client.getRetryOnConnectionFailure()) {
+            return false;
+        }
 
-  /**
-   * Populates request with defaults and cookies.
-   *
-   * <p>This client doesn't specify a default {@code Accept} header because it
-   * doesn't know what content types the application is interested in.
-   */
-  private Request networkRequest(Request request) throws IOException {
-    Request.Builder result = request.newBuilder();
+        // If there was a protocol problem, don't recover.
+        if (e instanceof ProtocolException) {
+            return false;
+        }
 
-    if (request.header("Host") == null) {
-      result.header("Host", hostHeader(request.url()));
-    }
+        // If there was an interruption or timeout, don't recover.
+        if (e instanceof InterruptedIOException) {
+            return false;
+        }
 
-    if ((connection == null || connection.getProtocol() != Protocol.HTTP_1_0)
-        && request.header("Connection") == null) {
-      result.header("Connection", "Keep-Alive");
+        return true;
     }
 
-    if (request.header("Accept-Encoding") == null) {
-      transparentGzip = true;
-      result.header("Accept-Encoding", "gzip");
+    /**
+     * Returns the route used to retrieve the response. Null if we haven't
+     * connected yet, or if no connection was necessary.
+     */
+    public Route getRoute() {
+        return route;
     }
 
-    CookieHandler cookieHandler = client.getCookieHandler();
-    if (cookieHandler != null) {
-      // Capture the request headers added so far so that they can be offered to the CookieHandler.
-      // This is mostly to stay close to the RI; it is unlikely any of the headers above would
-      // affect cookie choice besides "Host".
-      Map<String, List<String>> headers = OkHeaders.toMultimap(result.build().headers(), null);
-
-      Map<String, List<String>> cookies = cookieHandler.get(request.uri(), headers);
+    private void maybeCache() throws IOException {
+        InternalCache responseCache = Internal.instance.internalCache(client);
+        if (responseCache == null) return;
+
+        // Should we cache this response for this request?
+        if (!CacheStrategy.isCacheable(userResponse, networkRequest)) {
+            if (HttpMethod.invalidatesCache(networkRequest.method())) {
+                try {
+                    responseCache.remove(networkRequest);
+                } catch (IOException ignored) {
+                    // The cache cannot be written.
+                }
+            }
+            return;
+        }
 
-      // Add any new cookies to the request.
-      OkHeaders.addCookies(result, cookies);
+        // Offer this request to the cache.
+        storeRequest = responseCache.put(stripBody(userResponse));
     }
 
-    if (request.header("User-Agent") == null) {
-      result.header("User-Agent", Version.userAgent());
+    /**
+     * Configure the socket connection to be either pooled or closed when it is
+     * either exhausted or closed. If it is unneeded when this is called, it will
+     * be released immediately.
+     */
+    public void releaseConnection() throws IOException {
+        if (transport != null && connection != null) {
+            transport.releaseConnectionOnIdle();
+        }
+        connection = null;
     }
 
-    return result.build();
-  }
-
-  public static String hostHeader(URL url) {
-    return getEffectivePort(url) != getDefaultPort(url.getProtocol())
-        ? url.getHost() + ":" + url.getPort()
-        : url.getHost();
-  }
-
-  /**
-   * Flushes the remaining request header and body, parses the HTTP response
-   * headers and starts reading the HTTP response body if it exists.
-   */
-  public void readResponse() throws IOException {
-    if (userResponse != null) {
-      return; // Already ready.
-    }
-    if (networkRequest == null && cacheResponse == null) {
-      throw new IllegalStateException("call sendRequest() first!");
-    }
-    if (networkRequest == null) {
-      return; // No network response to read.
+    /**
+     * Immediately closes the socket connection if it's currently held by this
+     * engine. Use this to interrupt an in-flight request from any thread. It's
+     * the caller's responsibility to close the request body and response body
+     * streams; otherwise resources may be leaked.
+     */
+    public void disconnect() {
+        if (transport != null) {
+            try {
+                transport.disconnect(this);
+            } catch (IOException ignored) {
+            }
+        }
     }
 
-    Response networkResponse;
-
-    if (forWebSocket) {
-      transport.writeRequestHeaders(networkRequest);
-      networkResponse = readNetworkResponse();
-
-    } else if (!callerWritesRequestBody) {
-      networkResponse = new NetworkInterceptorChain(0, networkRequest).proceed(networkRequest);
-
-    } else {
-      // Emit the request body's buffer so that everything is in requestBodyOut.
-      if (bufferedRequestBody != null && bufferedRequestBody.buffer().size() > 0) {
-        bufferedRequestBody.emit();
-      }
-
-      // Emit the request headers if we haven't yet. We might have just learned the Content-Length.
-      if (sentRequestMillis == -1) {
-        if (OkHeaders.contentLength(networkRequest) == -1
-            && requestBodyOut instanceof RetryableSink) {
-          long contentLength = ((RetryableSink) requestBodyOut).contentLength();
-          networkRequest = networkRequest.newBuilder()
-              .header("Content-Length", Long.toString(contentLength))
-              .build();
+    /**
+     * Release any resources held by this engine. If a connection is still held by
+     * this engine, it is returned.
+     */
+    public Connection close() {
+        if (bufferedRequestBody != null) {
+            // This also closes the wrapped requestBodyOut.
+            closeQuietly(bufferedRequestBody);
+        } else if (requestBodyOut != null) {
+            closeQuietly(requestBodyOut);
         }
-        transport.writeRequestHeaders(networkRequest);
-      }
 
-      // Write the request body to the socket.
-      if (requestBodyOut != null) {
-        if (bufferedRequestBody != null) {
-          // This also closes the wrapped requestBodyOut.
-          bufferedRequestBody.close();
-        } else {
-          requestBodyOut.close();
+        // If this engine never achieved a response body, its connection cannot be reused.
+        if (userResponse == null) {
+            if (connection != null)
+                closeQuietly(connection.getSocket()); // TODO: does this break SPDY?
+            connection = null;
+            return null;
         }
-        if (requestBodyOut instanceof RetryableSink) {
-          transport.writeRequestBody((RetryableSink) requestBodyOut);
+
+        // Close the response body. This will recycle the connection if it is eligible.
+        closeQuietly(userResponse.body());
+
+        // Close the connection if it cannot be reused.
+        if (transport != null && connection != null && !transport.canReuseConnection()) {
+            closeQuietly(connection.getSocket());
+            connection = null;
+            return null;
         }
-      }
 
-      networkResponse = readNetworkResponse();
-    }
+        // Prevent this engine from disconnecting a connection it no longer owns.
+        if (connection != null && !Internal.instance.clearOwner(connection)) {
+            connection = null;
+        }
 
-    receiveHeaders(networkResponse.headers());
-
-    // If we have a cache response too, then we're doing a conditional get.
-    if (cacheResponse != null) {
-      if (validate(cacheResponse, networkResponse)) {
-        userResponse = cacheResponse.newBuilder()
-            .request(userRequest)
-            .priorResponse(stripBody(priorResponse))
-            .headers(combine(cacheResponse.headers(), networkResponse.headers()))
-            .cacheResponse(stripBody(cacheResponse))
-            .networkResponse(stripBody(networkResponse))
-            .build();
-        networkResponse.body().close();
-        releaseConnection();
-
-        // Update the cache after combining headers but before stripping the
-        // Content-Encoding header (as performed by initContentStream()).
-        InternalCache responseCache = Internal.instance.internalCache(client);
-        responseCache.trackConditionalCacheHit();
-        responseCache.update(cacheResponse, stripBody(userResponse));
-        userResponse = unzip(userResponse);
-        return;
-      } else {
-        closeQuietly(cacheResponse.body());
-      }
+        Connection result = connection;
+        connection = null;
+        return result;
     }
 
-    userResponse = networkResponse.newBuilder()
-        .request(userRequest)
-        .priorResponse(stripBody(priorResponse))
-        .cacheResponse(stripBody(cacheResponse))
-        .networkResponse(stripBody(networkResponse))
-        .build();
+    /**
+     * Returns a new response that does gzip decompression on {@code response}, if transparent gzip
+     * was both offered by OkHttp and used by the origin server.
+     * <p/>
+     * <p>In addition to decompression, this will also strip the corresponding headers. We strip the
+     * Content-Encoding header to prevent the application from attempting to double decompress. We
+     * strip the Content-Length header because it is the length of the compressed content, but the
+     * application is only interested in the length of the uncompressed content.
+     * <p/>
+     * <p>This method should only be used for non-empty response bodies. Response codes like "304 Not
+     * Modified" can include "Content-Encoding: gzip" without a response body and we will crash if we
+     * attempt to decompress the zero-byte source.
+     */
+    private Response unzip(final Response response) throws IOException {
+        if (!transparentGzip || !"gzip".equalsIgnoreCase(userResponse.header("Content-Encoding"))) {
+            return response;
+        }
 
-    if (hasBody(userResponse)) {
-      maybeCache();
-      userResponse = unzip(cacheWritingResponse(storeRequest, userResponse));
+        if (response.body() == null) {
+            return response;
+        }
+
+        GzipSource responseBody = new GzipSource(response.body().source());
+        Headers strippedHeaders = response.headers().newBuilder()
+                .removeAll("Content-Encoding")
+                .removeAll("Content-Length")
+                .build();
+        return response.newBuilder()
+                .headers(strippedHeaders)
+                .body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)))
+                .build();
     }
-  }
 
-  class NetworkInterceptorChain implements Interceptor.Chain {
-    private final int index;
-    private final Request request;
-    private int calls;
+    /**
+     * Returns true if the response must have a (possibly 0-length) body.
+     * See RFC 2616 section 4.3.
+     */
+    public static boolean hasBody(Response response) {
+        // HEAD requests never yield a body regardless of the response headers.
+        if (response.request().method().equals("HEAD")) {
+            return false;
+        }
 
-    NetworkInterceptorChain(int index, Request request) {
-      this.index = index;
-      this.request = request;
-    }
+        int responseCode = response.code();
+        if ((responseCode < HTTP_CONTINUE || responseCode >= 200)
+                && responseCode != HTTP_NO_CONTENT
+                && responseCode != HTTP_NOT_MODIFIED) {
+            return true;
+        }
 
-    @Override public Connection connection() {
-      return connection;
-    }
+        // If the Content-Length or Transfer-Encoding headers disagree with the
+        // response code, the response is malformed. For best compatibility, we
+        // honor the headers.
+        if (OkHeaders.contentLength(response) != -1
+                || "chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {
+            return true;
+        }
 
-    @Override public Request request() {
-      return request;
+        return false;
     }
 
-    @Override public Response proceed(Request request) throws IOException {
-      calls++;
+    /**
+     * Populates request with defaults and cookies.
+     * <p/>
+     * <p>This client doesn't specify a default {@code Accept} header because it
+     * doesn't know what content types the application is interested in.
+     */
+    private Request networkRequest(Request request) throws IOException {
+        Request.Builder result = request.newBuilder();
+
+        if (request.header("Host") == null) {
+            result.header("Host", hostHeader(request.url()));
+        }
 
-      if (index > 0) {
-        Interceptor caller = client.networkInterceptors().get(index - 1);
-        Address address = connection().getRoute().getAddress();
+        if ((connection == null || connection.getProtocol() != Protocol.HTTP_1_0)
+                && request.header("Connection") == null) {
+            result.header("Connection", "Keep-Alive");
+        }
 
-        // Confirm that the interceptor uses the connection we've already prepared.
-        if (!request.url().getHost().equals(address.getUriHost())
-            || getEffectivePort(request.url()) != address.getUriPort()) {
-          throw new IllegalStateException("network interceptor " + caller
-              + " must retain the same host and port");
+        if (request.header("Accept-Encoding") == null) {
+            transparentGzip = true;
+            result.header("Accept-Encoding", "gzip");
         }
 
-        // Confirm that this is the interceptor's first call to chain.proceed().
-        if (calls > 1) {
-          throw new IllegalStateException("network interceptor " + caller
-              + " must call proceed() exactly once");
+        CookieHandler cookieHandler = client.getCookieHandler();
+        if (cookieHandler != null) {
+            // Capture the request headers added so far so that they can be offered to the CookieHandler.
+            // This is mostly to stay close to the RI; it is unlikely any of the headers above would
+            // affect cookie choice besides "Host".
+            Map<String, List<String>> headers = OkHeaders.toMultimap(result.build().headers(), null);
+
+            Map<String, List<String>> cookies = cookieHandler.get(request.uri(), headers);
+
+            // Add any new cookies to the request.
+            OkHeaders.addCookies(result, cookies);
         }
-      }
-
-      if (index < client.networkInterceptors().size()) {
-        // There's another interceptor in the chain. Call that.
-        NetworkInterceptorChain chain = new NetworkInterceptorChain(index + 1, request);
-        Interceptor interceptor = client.networkInterceptors().get(index);
-        Response interceptedResponse = interceptor.intercept(chain);
-
-        // Confirm that the interceptor made the required call to chain.proceed().
-        if (chain.calls != 1) {
-          throw new IllegalStateException("network interceptor " + interceptor
-              + " must call proceed() exactly once");
+
+        if (request.header("User-Agent") == null) {
+            result.header("User-Agent", Version.userAgent());
         }
 
-        return interceptedResponse;
-      }
+        return result.build();
+    }
 
-      transport.writeRequestHeaders(request);
+    public static String hostHeader(URL url) {
+        return getEffectivePort(url) != getDefaultPort(url.getProtocol())
+                ? url.getHost() + ":" + url.getPort()
+                : url.getHost();
+    }
 
-      //Update the networkRequest with the possibly updated interceptor request.
-      networkRequest = request;
+    /**
+     * Flushes the remaining request header and body, parses the HTTP response
+     * headers and starts reading the HTTP response body if it exists.
+     */
+    public void readResponse() throws IOException {
+        if (userResponse != null) {
+            return; // Already ready.
+        }
+        if (networkRequest == null && cacheResponse == null) {
+            throw new IllegalStateException("call sendRequest() first!");
+        }
+        if (networkRequest == null) {
+            return; // No network response to read.
+        }
 
-      if (permitsRequestBody() && request.body() != null) {
-        Sink requestBodyOut = transport.createRequestBody(request, request.body().contentLength());
-        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
-        request.body().writeTo(bufferedRequestBody);
-        bufferedRequestBody.close();
-      }
+        Response networkResponse;
 
-      Response response = readNetworkResponse();
+        if (forWebSocket) {
+            transport.writeRequestHeaders(networkRequest);
+            networkResponse = readNetworkResponse();
 
-      int code = response.code();
-      if ((code == 204 || code == 205) && response.body().contentLength() > 0) {
-        throw new ProtocolException(
-            "HTTP " + code + " had non-zero Content-Length: " + response.body().contentLength());
-      }
+        } else if (!callerWritesRequestBody) {
+            networkResponse = new NetworkInterceptorChain(0, networkRequest).proceed(networkRequest);
 
-      return response;
-    }
-  }
-
-  private Response readNetworkResponse() throws IOException {
-    transport.finishRequest();
-
-    Response networkResponse = transport.readResponseHeaders()
-        .request(networkRequest)
-        .handshake(connection.getHandshake())
-        .header(OkHeaders.SENT_MILLIS, Long.toString(sentRequestMillis))
-        .header(OkHeaders.RECEIVED_MILLIS, Long.toString(System.currentTimeMillis()))
-        .build();
-
-    if (!forWebSocket) {
-      networkResponse = networkResponse.newBuilder()
-          .body(transport.openResponseBody(networkResponse))
-          .build();
-    }
+        } else {
+            // Emit the request body's buffer so that everything is in requestBodyOut.
+            if (bufferedRequestBody != null && bufferedRequestBody.buffer().size() > 0) {
+                bufferedRequestBody.emit();
+            }
+
+            // Emit the request headers if we haven't yet. We might have just learned the Content-Length.
+            if (sentRequestMillis == -1) {
+                if (OkHeaders.contentLength(networkRequest) == -1
+                        && requestBodyOut instanceof RetryableSink) {
+                    long contentLength = ((RetryableSink) requestBodyOut).contentLength();
+                    networkRequest = networkRequest.newBuilder()
+                            .header("Content-Length", Long.toString(contentLength))
+                            .build();
+                }
+                transport.writeRequestHeaders(networkRequest);
+            }
+
+            // Write the request body to the socket.
+            if (requestBodyOut != null) {
+                if (bufferedRequestBody != null) {
+                    // This also closes the wrapped requestBodyOut.
+                    bufferedRequestBody.close();
+                } else {
+                    requestBodyOut.close();
+                }
+                if (requestBodyOut instanceof RetryableSink) {
+                    transport.writeRequestBody((RetryableSink) requestBodyOut);
+                }
+            }
+
+            networkResponse = readNetworkResponse();
+        }
 
-    Internal.instance.setProtocol(connection, networkResponse.protocol());
-    return networkResponse;
-  }
-
-  /**
-   * Returns a new source that writes bytes to {@code cacheRequest} as they are read by the source
-   * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we
-   * may never exhaust the source stream and therefore not complete the cached response.
-   */
-  private Response cacheWritingResponse(final CacheRequest cacheRequest, Response response)
-      throws IOException {
-    // Some apps return a null body; for compatibility we treat that like a null cache request.
-    if (cacheRequest == null) return response;
-    Sink cacheBodyUnbuffered = cacheRequest.body();
-    if (cacheBodyUnbuffered == null) return response;
-
-    final BufferedSource source = response.body().source();
-    final BufferedSink cacheBody = Okio.buffer(cacheBodyUnbuffered);
-
-    Source cacheWritingSource = new Source() {
-      boolean cacheRequestClosed;
-
-      @Override public long read(Buffer sink, long byteCount) throws IOException {
-        long bytesRead;
-        try {
-          bytesRead = source.read(sink, byteCount);
-        } catch (IOException e) {
-          if (!cacheRequestClosed) {
-            cacheRequestClosed = true;
-            cacheRequest.abort(); // Failed to write a complete cache response.
-          }
-          throw e;
+        receiveHeaders(networkResponse.headers());
+
+        // If we have a cache response too, then we're doing a conditional get.
+        if (cacheResponse != null) {
+            if (validate(cacheResponse, networkResponse)) {
+                userResponse = cacheResponse.newBuilder()
+                        .request(userRequest)
+                        .priorResponse(stripBody(priorResponse))
+                        .headers(combine(cacheResponse.headers(), networkResponse.headers()))
+                        .cacheResponse(stripBody(cacheResponse))
+                        .networkResponse(stripBody(networkResponse))
+                        .build();
+                networkResponse.body().close();
+                releaseConnection();
+
+                // Update the cache after combining headers but before stripping the
+                // Content-Encoding header (as performed by initContentStream()).
+                InternalCache responseCache = Internal.instance.internalCache(client);
+                responseCache.trackConditionalCacheHit();
+                responseCache.update(cacheResponse, stripBody(userResponse));
+                userResponse = unzip(userResponse);
+                return;
+            } else {
+                closeQuietly(cacheResponse.body());
+            }
         }
 
-        if (bytesRead == -1) {
-          if (!cacheRequestClosed) {
-            cacheRequestClosed = true;
-            cacheBody.close(); // The cache response is complete!
-          }
-          return -1;
+        userResponse = networkResponse.newBuilder()
+                .request(userRequest)
+                .priorResponse(stripBody(priorResponse))
+                .cacheResponse(stripBody(cacheResponse))
+                .networkResponse(stripBody(networkResponse))
+                .build();
+
+        if (hasBody(userResponse)) {
+            maybeCache();
+            userResponse = unzip(cacheWritingResponse(storeRequest, userResponse));
         }
+    }
 
-        sink.copyTo(cacheBody.buffer(), sink.size() - bytesRead, bytesRead);
-        cacheBody.emitCompleteSegments();
-        return bytesRead;
-      }
+    class NetworkInterceptorChain implements Interceptor.Chain {
+        private final int index;
+        private final Request request;
+        private int calls;
 
-      @Override public Timeout timeout() {
-        return source.timeout();
-      }
+        NetworkInterceptorChain(int index, Request request) {
+            this.index = index;
+            this.request = request;
+        }
 
-      @Override public void close() throws IOException {
-        if (!cacheRequestClosed
-            && !Util.discard(this, Transport.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-          cacheRequestClosed = true;
-          cacheRequest.abort();
+        @Override
+        public Connection connection() {
+            return connection;
         }
-        source.close();
-      }
-    };
 
-    return response.newBuilder()
-        .body(new RealResponseBody(response.headers(), Okio.buffer(cacheWritingSource)))
-        .build();
-  }
-
-  /**
-   * Returns true if {@code cached} should be used; false if {@code network}
-   * response should be used.
-   */
-  private static boolean validate(Response cached, Response network) {
-    if (network.code() == HTTP_NOT_MODIFIED) {
-      return true;
-    }
+        @Override
+        public Request request() {
+            return request;
+        }
 
-    // The HTTP spec says that if the network's response is older than our
-    // cached response, we may return the cache's response. Like Chrome (but
-    // unlike Firefox), this client prefers to return the newer response.
-    Date lastModified = cached.headers().getDate("Last-Modified");
-    if (lastModified != null) {
-      Date networkLastModified = network.headers().getDate("Last-Modified");
-      if (networkLastModified != null
-          && networkLastModified.getTime() < lastModified.getTime()) {
-        return true;
-      }
+        @Override
+        public Response proceed(Request request) throws IOException {
+            calls++;
+
+            if (index > 0) {
+                Interceptor caller = client.networkInterceptors().get(index - 1);
+                Address address = connection().getRoute().getAddress();
+
+                // Confirm that the interceptor uses the connection we've already prepared.
+                if (!request.url().getHost().equals(address.getUriHost())
+                        || getEffectivePort(request.url()) != address.getUriPort()) {
+                    throw new IllegalStateException("network interceptor " + caller
+                            + " must retain the same host and port");
+                }
+
+                // Confirm that this is the interceptor's first call to chain.proceed().
+                if (calls > 1) {
+                    throw new IllegalStateException("network interceptor " + caller
+                            + " must call proceed() exactly once");
+                }
+            }
+
+            if (index < client.networkInterceptors().size()) {
+                // There's another interceptor in the chain. Call that.
+                NetworkInterceptorChain chain = new NetworkInterceptorChain(index + 1, request);
+                Interceptor interceptor = client.networkInterceptors().get(index);
+                Response interceptedResponse = interceptor.intercept(chain);
+
+                // Confirm that the interceptor made the required call to chain.proceed().
+                if (chain.calls != 1) {
+                    throw new IllegalStateException("network interceptor " + interceptor
+                            + " must call proceed() exactly once");
+                }
+
+                return interceptedResponse;
+            }
+
+            transport.writeRequestHeaders(request);
+
+            //Update the networkRequest with the possibly updated interceptor request.
+            networkRequest = request;
+
+            if (permitsRequestBody() && request.body() != null) {
+                Sink requestBodyOut = transport.createRequestBody(request, request.body().contentLength());
+                BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
+                request.body().writeTo(bufferedRequestBody);
+                bufferedRequestBody.close();
+            }
+
+            Response response = readNetworkResponse();
+
+            int code = response.code();
+            if ((code == 204 || code == 205) && response.body().contentLength() > 0) {
+                throw new ProtocolException(
+                        "HTTP " + code + " had non-zero Content-Length: " + response.body().contentLength());
+            }
+
+            return response;
+        }
     }
 
-    return false;
-  }
-
-  /**
-   * Combines cached headers with a network headers as defined by RFC 2616,
-   * 13.5.3.
-   */
-  private static Headers combine(Headers cachedHeaders, Headers networkHeaders) throws IOException {
-    Headers.Builder result = new Headers.Builder();
-
-    for (int i = 0, size = cachedHeaders.size(); i < size; i++) {
-      String fieldName = cachedHeaders.name(i);
-      String value = cachedHeaders.value(i);
-      if ("Warning".equalsIgnoreCase(fieldName) && value.startsWith("1")) {
-        continue; // Drop 100-level freshness warnings.
-      }
-      if (!OkHeaders.isEndToEnd(fieldName) || networkHeaders.get(fieldName) == null) {
-        result.add(fieldName, value);
-      }
-    }
+    private Response readNetworkResponse() throws IOException {
+        transport.finishRequest();
 
-    for (int i = 0, size = networkHeaders.size(); i < size; i++) {
-      String fieldName = networkHeaders.name(i);
-      if ("Content-Length".equalsIgnoreCase(fieldName)) {
-        continue; // Ignore content-length headers of validating responses.
-      }
-      if (OkHeaders.isEndToEnd(fieldName)) {
-        result.add(fieldName, networkHeaders.value(i));
-      }
-    }
+        Response networkResponse = transport.readResponseHeaders()
+                .request(networkRequest)
+                .handshake(connection.getHandshake())
+                .header(OkHeaders.SENT_MILLIS, Long.toString(sentRequestMillis))
+                .header(OkHeaders.RECEIVED_MILLIS, Long.toString(System.currentTimeMillis()))
+                .build();
+
+        if (!forWebSocket) {
+            networkResponse = networkResponse.newBuilder()
+                    .body(transport.openResponseBody(networkResponse))
+                    .build();
+        }
 
-    return result.build();
-  }
+        Internal.instance.setProtocol(connection, networkResponse.protocol());
+        return networkResponse;
+    }
 
-  public void receiveHeaders(Headers headers) throws IOException {
-    CookieHandler cookieHandler = client.getCookieHandler();
-    if (cookieHandler != null) {
-      cookieHandler.put(userRequest.uri(), OkHeaders.toMultimap(headers, null));
+    /**
+     * Returns a new source that writes bytes to {@code cacheRequest} as they are read by the source
+     * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we
+     * may never exhaust the source stream and therefore not complete the cached response.
+     */
+    private Response cacheWritingResponse(final CacheRequest cacheRequest, Response response)
+            throws IOException {
+        // Some apps return a null body; for compatibility we treat that like a null cache request.
+        if (cacheRequest == null) return response;
+        Sink cacheBodyUnbuffered = cacheRequest.body();
+        if (cacheBodyUnbuffered == null) return response;
+
+        final BufferedSource source = response.body().source();
+        final BufferedSink cacheBody = Okio.buffer(cacheBodyUnbuffered);
+
+        Source cacheWritingSource = new Source() {
+            boolean cacheRequestClosed;
+
+            @Override
+            public long read(Buffer sink, long byteCount) throws IOException {
+                long bytesRead;
+                try {
+                    bytesRead = source.read(sink, byteCount);
+                } catch (IOException e) {
+                    if (!cacheRequestClosed) {
+                        cacheRequestClosed = true;
+                        cacheRequest.abort(); // Failed to write a complete cache response.
+                    }
+                    throw e;
+                }
+
+                if (bytesRead == -1) {
+                    if (!cacheRequestClosed) {
+                        cacheRequestClosed = true;
+                        cacheBody.close(); // The cache response is complete!
+                    }
+                    return -1;
+                }
+
+                sink.copyTo(cacheBody.buffer(), sink.size() - bytesRead, bytesRead);
+                cacheBody.emitCompleteSegments();
+                return bytesRead;
+            }
+
+            @Override
+            public Timeout timeout() {
+                return source.timeout();
+            }
+
+            @Override
+            public void close() throws IOException {
+                if (!cacheRequestClosed
+                        && !Util.discard(this, Transport.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
+                    cacheRequestClosed = true;
+                    cacheRequest.abort();
+                }
+                source.close();
+            }
+        };
+
+        return response.newBuilder()
+                .body(new RealResponseBody(response.headers(), Okio.buffer(cacheWritingSource)))
+                .build();
     }
-  }
-
-  /**
-   * Figures out the HTTP request to make in response to receiving this engine's
-   * response. This will either add authentication headers or follow redirects.
-   * If a follow-up is either unnecessary or not applicable, this returns null.
-   */
-  public Request followUpRequest() throws IOException {
-    if (userResponse == null) throw new IllegalStateException();
-    Proxy selectedProxy = getRoute() != null
-        ? getRoute().getProxy()
-        : client.getProxy();
-    int responseCode = userResponse.code();
-
-    switch (responseCode) {
-      case HTTP_PROXY_AUTH:
-        if (selectedProxy.type() != Proxy.Type.HTTP) {
-          throw new ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy");
+
+    /**
+     * Returns true if {@code cached} should be used; false if {@code network}
+     * response should be used.
+     */
+    private static boolean validate(Response cached, Response network) {
+        if (network.code() == HTTP_NOT_MODIFIED) {
+            return true;
         }
-        // fall-through
-      case HTTP_UNAUTHORIZED:
-        return OkHeaders.processAuthHeader(client.getAuthenticator(), userResponse, selectedProxy);
-
-      case HTTP_PERM_REDIRECT:
-      case HTTP_TEMP_REDIRECT:
-        // "If the 307 or 308 status code is received in response to a request other than GET
-        // or HEAD, the user agent MUST NOT automatically redirect the request"
-        if (!userRequest.method().equals("GET") && !userRequest.method().equals("HEAD")) {
-            return null;
+
+        // The HTTP spec says that if the network's response is older than our
+        // cached response, we may return the cache's response. Like Chrome (but
+        // unlike Firefox), this client prefers to return the newer response.
+        Date lastModified = cached.headers().getDate("Last-Modified");
+        if (lastModified != null) {
+            Date networkLastModified = network.headers().getDate("Last-Modified");
+            if (networkLastModified != null
+                    && networkLastModified.getTime() < lastModified.getTime()) {
+                return true;
+            }
         }
-        // fall-through
-      case HTTP_MULT_CHOICE:
-      case HTTP_MOVED_PERM:
-      case HTTP_MOVED_TEMP:
-      case HTTP_SEE_OTHER:
-        // Does the client allow redirects?
-        if (!client.getFollowRedirects()) return null;
-
-        String location = userResponse.header("Location");
-        if (location == null) return null;
-        URL url = new URL(userRequest.url(), location);
-
-        // Don't follow redirects to unsupported protocols.
-        if (!url.getProtocol().equals("https") && !url.getProtocol().equals("http")) return null;
-
-        // If configured, don't follow redirects between SSL and non-SSL.
-        boolean sameProtocol = url.getProtocol().equals(userRequest.url().getProtocol());
-        if (!sameProtocol && !client.getFollowSslRedirects()) return null;
-
-        // Redirects don't include a request body.
-        Request.Builder requestBuilder = userRequest.newBuilder();
-        if (HttpMethod.permitsRequestBody(userRequest.method())) {
-          requestBuilder.method("GET", null);
-          requestBuilder.removeHeader("Transfer-Encoding");
-          requestBuilder.removeHeader("Content-Length");
-          requestBuilder.removeHeader("Content-Type");
+
+        return false;
+    }
+
+    /**
+     * Combines cached headers with a network headers as defined by RFC 2616,
+     * 13.5.3.
+     */
+    private static Headers combine(Headers cachedHeaders, Headers networkHeaders) throws IOException {
+        Headers.Builder result = new Headers.Builder();
+
+        for (int i = 0, size = cachedHeaders.size(); i < size; i++) {
+            String fieldName = cachedHeaders.name(i);
+            String value = cachedHeaders.value(i);
+            if ("Warning".equalsIgnoreCase(fieldName) && value.startsWith("1")) {
+                continue; // Drop 100-level freshness warnings.
+            }
+            if (!OkHeaders.isEndToEnd(fieldName) || networkHeaders.get(fieldName) == null) {
+                result.add(fieldName, value);
+            }
         }
 
-        // When redirecting across hosts, drop all authentication headers. This
-        // is potentially annoying to the application layer since they have no
-        // way to retain them.
-        if (!sameConnection(url)) {
-          requestBuilder.removeHeader("Authorization");
+        for (int i = 0, size = networkHeaders.size(); i < size; i++) {
+            String fieldName = networkHeaders.name(i);
+            if ("Content-Length".equalsIgnoreCase(fieldName)) {
+                continue; // Ignore content-length headers of validating responses.
+            }
+            if (OkHeaders.isEndToEnd(fieldName)) {
+                result.add(fieldName, networkHeaders.value(i));
+            }
         }
 
-        return requestBuilder.url(url).build();
+        return result.build();
+    }
 
-      default:
-        return null;
+    public void receiveHeaders(Headers headers) throws IOException {
+        CookieHandler cookieHandler = client.getCookieHandler();
+        if (cookieHandler != null) {
+            cookieHandler.put(userRequest.uri(), OkHeaders.toMultimap(headers, null));
+        }
     }
-  }
-
-  /**
-   * Returns true if an HTTP request for {@code followUp} can reuse the
-   * connection used by this engine.
-   */
-  public boolean sameConnection(URL followUp) {
-    URL url = userRequest.url();
-    return url.getHost().equals(followUp.getHost())
-        && getEffectivePort(url) == getEffectivePort(followUp)
-        && url.getProtocol().equals(followUp.getProtocol());
-  }
-
-  private static Address createAddress(OkHttpClient client, Request request)
-      throws RequestException {
-    String uriHost = request.url().getHost();
-    if (uriHost == null || uriHost.length() == 0) {
-      throw new RequestException(new UnknownHostException(request.url().toString()));
+
+    /**
+     * Figures out the HTTP request to make in response to receiving this engine's
+     * response. This will either add authentication headers or follow redirects.
+     * If a follow-up is either unnecessary or not applicable, this returns null.
+     */
+    public Request followUpRequest() throws IOException {
+        if (userResponse == null) throw new IllegalStateException();
+        Proxy selectedProxy = getRoute() != null
+                ? getRoute().getProxy()
+                : client.getProxy();
+        int responseCode = userResponse.code();
+
+        switch (responseCode) {
+            case HTTP_PROXY_AUTH:
+                if (selectedProxy.type() != Proxy.Type.HTTP) {
+                    throw new ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy");
+                }
+                // fall-through
+            case HTTP_UNAUTHORIZED:
+                return OkHeaders.processAuthHeader(client.getAuthenticator(), userResponse, selectedProxy);
+
+            case HTTP_PERM_REDIRECT:
+            case HTTP_TEMP_REDIRECT:
+                // "If the 307 or 308 status code is received in response to a request other than GET
+                // or HEAD, the user agent MUST NOT automatically redirect the request"
+                if (!userRequest.method().equals("GET") && !userRequest.method().equals("HEAD")) {
+                    return null;
+                }
+                // fall-through
+            case HTTP_MULT_CHOICE:
+            case HTTP_MOVED_PERM:
+            case HTTP_MOVED_TEMP:
+            case HTTP_SEE_OTHER:
+                // Does the client allow redirects?
+                if (!client.getFollowRedirects()) return null;
+
+                String location = userResponse.header("Location");
+                if (location == null) return null;
+                URL url = new URL(userRequest.url(), location);
+
+                // Don't follow redirects to unsupported protocols.
+                if (!url.getProtocol().equals("https") && !url.getProtocol().equals("http"))
+                    return null;
+
+                // If configured, don't follow redirects between SSL and non-SSL.
+                boolean sameProtocol = url.getProtocol().equals(userRequest.url().getProtocol());
+                if (!sameProtocol && !client.getFollowSslRedirects()) return null;
+
+                // Redirects don't include a request body.
+                Request.Builder requestBuilder = userRequest.newBuilder();
+                if (HttpMethod.permitsRequestBody(userRequest.method())) {
+                    requestBuilder.method("GET", null);
+                    requestBuilder.removeHeader("Transfer-Encoding");
+                    requestBuilder.removeHeader("Content-Length");
+                    requestBuilder.removeHeader("Content-Type");
+                }
+
+                // When redirecting across hosts, drop all authentication headers. This
+                // is potentially annoying to the application layer since they have no
+                // way to retain them.
+                if (!sameConnection(url)) {
+                    requestBuilder.removeHeader("Authorization");
+                }
+
+                return requestBuilder.url(url).build();
+
+            default:
+                return null;
+        }
     }
 
-    SSLSocketFactory sslSocketFactory = null;
-    HostnameVerifier hostnameVerifier = null;
-    CertificatePinner certificatePinner = null;
-    if (request.isHttps()) {
-      sslSocketFactory = client.getSslSocketFactory();
-      hostnameVerifier = client.getHostnameVerifier();
-      certificatePinner = client.getCertificatePinner();
+    /**
+     * Returns true if an HTTP request for {@code followUp} can reuse the
+     * connection used by this engine.
+     */
+    public boolean sameConnection(URL followUp) {
+        URL url = userRequest.url();
+        return url.getHost().equals(followUp.getHost())
+                && getEffectivePort(url) == getEffectivePort(followUp)
+                && url.getProtocol().equals(followUp.getProtocol());
     }
 
-    return new Address(uriHost, getEffectivePort(request.url()),
-        client.getSocketFactory(), sslSocketFactory, hostnameVerifier, certificatePinner,
-        client.getAuthenticator(), client.getProxy(), client.getProtocols(),
-        client.getConnectionSpecs(), client.getProxySelector());
-  }
+    private static Address createAddress(OkHttpClient client, Request request)
+            throws RequestException {
+        String uriHost = request.url().getHost();
+        if (uriHost == null || uriHost.length() == 0) {
+            throw new RequestException(new UnknownHostException(request.url().toString()));
+        }
+
+        SSLSocketFactory sslSocketFactory = null;
+        HostnameVerifier hostnameVerifier = null;
+        CertificatePinner certificatePinner = null;
+        if (request.isHttps()) {
+            sslSocketFactory = client.getSslSocketFactory();
+            hostnameVerifier = client.getHostnameVerifier();
+            certificatePinner = client.getCertificatePinner();
+        }
+
+        return new Address(uriHost, getEffectivePort(request.url()),
+                client.getSocketFactory(), sslSocketFactory, hostnameVerifier, certificatePinner,
+                client.getAuthenticator(), client.getProxy(), client.getProtocols(),
+                client.getConnectionSpecs(), client.getProxySelector());
+    }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpMethod.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpMethod.java
index b5f2a48f86..3db8355ca9 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpMethod.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpMethod.java
@@ -16,24 +16,24 @@
 package com.squareup.okhttp.internal.http;
 
 public final class HttpMethod {
-  public static boolean invalidatesCache(String method) {
-    return method.equals("POST")
-        || method.equals("PATCH")
-        || method.equals("PUT")
-        || method.equals("DELETE");
-  }
+    public static boolean invalidatesCache(String method) {
+        return method.equals("POST")
+                || method.equals("PATCH")
+                || method.equals("PUT")
+                || method.equals("DELETE");
+    }
 
-  public static boolean requiresRequestBody(String method) {
-    return method.equals("POST")
-        || method.equals("PUT")
-        || method.equals("PATCH");
-  }
+    public static boolean requiresRequestBody(String method) {
+        return method.equals("POST")
+                || method.equals("PUT")
+                || method.equals("PATCH");
+    }
 
-  public static boolean permitsRequestBody(String method) {
-    return requiresRequestBody(method)
-        || method.equals("DELETE"); // Permitted as spec is ambiguous.
-  }
+    public static boolean permitsRequestBody(String method) {
+        return requiresRequestBody(method)
+                || method.equals("DELETE"); // Permitted as spec is ambiguous.
+    }
 
-  private HttpMethod() {
-  }
+    private HttpMethod() {
+    }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
index d02e1e56d1..e04913fae4 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
@@ -19,119 +19,129 @@
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.ResponseBody;
+
 import java.io.IOException;
+
 import okio.Okio;
 import okio.Sink;
 import okio.Source;
 
 public final class HttpTransport implements Transport {
-  private final HttpEngine httpEngine;
-  private final HttpConnection httpConnection;
-
-  public HttpTransport(HttpEngine httpEngine, HttpConnection httpConnection) {
-    this.httpEngine = httpEngine;
-    this.httpConnection = httpConnection;
-  }
-
-  @Override public Sink createRequestBody(Request request, long contentLength) throws IOException {
-    if ("chunked".equalsIgnoreCase(request.header("Transfer-Encoding"))) {
-      // Stream a request body of unknown length.
-      return httpConnection.newChunkedSink();
+    private final HttpEngine httpEngine;
+    private final HttpConnection httpConnection;
+
+    public HttpTransport(HttpEngine httpEngine, HttpConnection httpConnection) {
+        this.httpEngine = httpEngine;
+        this.httpConnection = httpConnection;
     }
 
-    if (contentLength != -1) {
-      // Stream a request body of a known length.
-      return httpConnection.newFixedLengthSink(contentLength);
+    @Override
+    public Sink createRequestBody(Request request, long contentLength) throws IOException {
+        if ("chunked".equalsIgnoreCase(request.header("Transfer-Encoding"))) {
+            // Stream a request body of unknown length.
+            return httpConnection.newChunkedSink();
+        }
+
+        if (contentLength != -1) {
+            // Stream a request body of a known length.
+            return httpConnection.newFixedLengthSink(contentLength);
+        }
+
+        throw new IllegalStateException(
+                "Cannot stream a request body without chunked encoding or a known content length!");
     }
 
-    throw new IllegalStateException(
-        "Cannot stream a request body without chunked encoding or a known content length!");
-  }
-
-  @Override public void finishRequest() throws IOException {
-    httpConnection.flush();
-  }
-
-  @Override public void writeRequestBody(RetryableSink requestBody) throws IOException {
-    httpConnection.writeRequestBody(requestBody);
-  }
-
-  /**
-   * Prepares the HTTP headers and sends them to the server.
-   *
-   * <p>For streaming requests with a body, headers must be prepared
-   * <strong>before</strong> the output stream has been written to. Otherwise
-   * the body would need to be buffered!
-   *
-   * <p>For non-streaming requests with a body, headers must be prepared
-   * <strong>after</strong> the output stream has been written to and closed.
-   * This ensures that the {@code Content-Length} header field receives the
-   * proper value.
-   */
-  public void writeRequestHeaders(Request request) throws IOException {
-    httpEngine.writingRequestHeaders();
-    String requestLine = RequestLine.get(request,
-        httpEngine.getConnection().getRoute().getProxy().type(),
-        httpEngine.getConnection().getProtocol());
-    httpConnection.writeRequest(request.headers(), requestLine);
-  }
-
-  @Override public Response.Builder readResponseHeaders() throws IOException {
-    return httpConnection.readResponse();
-  }
-
-  @Override public void releaseConnectionOnIdle() throws IOException {
-    if (canReuseConnection()) {
-      httpConnection.poolOnIdle();
-    } else {
-      httpConnection.closeOnIdle();
+    @Override
+    public void finishRequest() throws IOException {
+        httpConnection.flush();
     }
-  }
 
-  @Override public boolean canReuseConnection() {
-    // If the request specified that the connection shouldn't be reused, don't reuse it.
-    if ("close".equalsIgnoreCase(httpEngine.getRequest().header("Connection"))) {
-      return false;
+    @Override
+    public void writeRequestBody(RetryableSink requestBody) throws IOException {
+        httpConnection.writeRequestBody(requestBody);
     }
 
-    // If the response specified that the connection shouldn't be reused, don't reuse it.
-    if ("close".equalsIgnoreCase(httpEngine.getResponse().header("Connection"))) {
-      return false;
+    /**
+     * Prepares the HTTP headers and sends them to the server.
+     * <p/>
+     * <p>For streaming requests with a body, headers must be prepared
+     * <strong>before</strong> the output stream has been written to. Otherwise
+     * the body would need to be buffered!
+     * <p/>
+     * <p>For non-streaming requests with a body, headers must be prepared
+     * <strong>after</strong> the output stream has been written to and closed.
+     * This ensures that the {@code Content-Length} header field receives the
+     * proper value.
+     */
+    public void writeRequestHeaders(Request request) throws IOException {
+        httpEngine.writingRequestHeaders();
+        String requestLine = RequestLine.get(request,
+                httpEngine.getConnection().getRoute().getProxy().type(),
+                httpEngine.getConnection().getProtocol());
+        httpConnection.writeRequest(request.headers(), requestLine);
     }
 
-    if (httpConnection.isClosed()) {
-      return false;
+    @Override
+    public Response.Builder readResponseHeaders() throws IOException {
+        return httpConnection.readResponse();
     }
 
-    return true;
-  }
+    @Override
+    public void releaseConnectionOnIdle() throws IOException {
+        if (canReuseConnection()) {
+            httpConnection.poolOnIdle();
+        } else {
+            httpConnection.closeOnIdle();
+        }
+    }
 
-  @Override public ResponseBody openResponseBody(Response response) throws IOException {
-    Source source = getTransferStream(response);
-    return new RealResponseBody(response.headers(), Okio.buffer(source));
-  }
+    @Override
+    public boolean canReuseConnection() {
+        // If the request specified that the connection shouldn't be reused, don't reuse it.
+        if ("close".equalsIgnoreCase(httpEngine.getRequest().header("Connection"))) {
+            return false;
+        }
 
-  private Source getTransferStream(Response response) throws IOException {
-    if (!HttpEngine.hasBody(response)) {
-      return httpConnection.newFixedLengthSource(0);
-    }
+        // If the response specified that the connection shouldn't be reused, don't reuse it.
+        if ("close".equalsIgnoreCase(httpEngine.getResponse().header("Connection"))) {
+            return false;
+        }
 
-    if ("chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {
-      return httpConnection.newChunkedSource(httpEngine);
+        if (httpConnection.isClosed()) {
+            return false;
+        }
+
+        return true;
     }
 
-    long contentLength = OkHeaders.contentLength(response);
-    if (contentLength != -1) {
-      return httpConnection.newFixedLengthSource(contentLength);
+    @Override
+    public ResponseBody openResponseBody(Response response) throws IOException {
+        Source source = getTransferStream(response);
+        return new RealResponseBody(response.headers(), Okio.buffer(source));
     }
 
-    // Wrap the input stream from the connection (rather than just returning
-    // "socketIn" directly here), so that we can control its use after the
-    // reference escapes.
-    return httpConnection.newUnknownLengthSource();
-  }
+    private Source getTransferStream(Response response) throws IOException {
+        if (!HttpEngine.hasBody(response)) {
+            return httpConnection.newFixedLengthSource(0);
+        }
+
+        if ("chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {
+            return httpConnection.newChunkedSource(httpEngine);
+        }
+
+        long contentLength = OkHeaders.contentLength(response);
+        if (contentLength != -1) {
+            return httpConnection.newFixedLengthSource(contentLength);
+        }
 
-  @Override public void disconnect(HttpEngine engine) throws IOException {
-    httpConnection.closeIfOwnedBy(engine);
-  }
+        // Wrap the input stream from the connection (rather than just returning
+        // "socketIn" directly here), so that we can control its use after the
+        // reference escapes.
+        return httpConnection.newUnknownLengthSource();
+    }
+
+    @Override
+    public void disconnect(HttpEngine engine) throws IOException {
+        httpConnection.closeIfOwnedBy(engine);
+    }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java
index c381c47562..24d91485a2 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java
@@ -6,6 +6,7 @@
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.internal.Platform;
+
 import java.io.IOException;
 import java.net.Proxy;
 import java.util.ArrayList;
@@ -20,268 +21,271 @@
 import static com.squareup.okhttp.internal.Util.equal;
 import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
 
-/** Headers and utilities for internal use by OkHttp. */
+/**
+ * Headers and utilities for internal use by OkHttp.
+ */
 public final class OkHeaders {
-  private static final Comparator<String> FIELD_NAME_COMPARATOR = new Comparator<String>() {
-    // @FindBugsSuppressWarnings("ES_COMPARING_PARAMETER_STRING_WITH_EQ")
-    @Override public int compare(String a, String b) {
-      if (a == b) {
-        return 0;
-      } else if (a == null) {
-        return -1;
-      } else if (b == null) {
-        return 1;
-      } else {
-        return String.CASE_INSENSITIVE_ORDER.compare(a, b);
-      }
+    private static final Comparator<String> FIELD_NAME_COMPARATOR = new Comparator<String>() {
+        // @FindBugsSuppressWarnings("ES_COMPARING_PARAMETER_STRING_WITH_EQ")
+        @Override
+        public int compare(String a, String b) {
+            if (a == b) {
+                return 0;
+            } else if (a == null) {
+                return -1;
+            } else if (b == null) {
+                return 1;
+            } else {
+                return String.CASE_INSENSITIVE_ORDER.compare(a, b);
+            }
+        }
+    };
+
+    static final String PREFIX = Platform.get().getPrefix();
+
+    /**
+     * Synthetic response header: the local time when the request was sent.
+     */
+    public static final String SENT_MILLIS = PREFIX + "-Sent-Millis";
+
+    /**
+     * Synthetic response header: the local time when the response was received.
+     */
+    public static final String RECEIVED_MILLIS = PREFIX + "-Received-Millis";
+
+    /**
+     * Synthetic response header: the selected
+     * {@link com.squareup.okhttp.Protocol protocol} ("spdy/3.1", "http/1.1", etc).
+     */
+    public static final String SELECTED_PROTOCOL = PREFIX + "-Selected-Protocol";
+
+    private OkHeaders() {
     }
-  };
-
-  static final String PREFIX = Platform.get().getPrefix();
-
-  /**
-   * Synthetic response header: the local time when the request was sent.
-   */
-  public static final String SENT_MILLIS = PREFIX + "-Sent-Millis";
-
-  /**
-   * Synthetic response header: the local time when the response was received.
-   */
-  public static final String RECEIVED_MILLIS = PREFIX + "-Received-Millis";
-
-  /**
-   * Synthetic response header: the selected
-   * {@link com.squareup.okhttp.Protocol protocol} ("spdy/3.1", "http/1.1", etc).
-   */
-  public static final String SELECTED_PROTOCOL = PREFIX + "-Selected-Protocol";
-
-  private OkHeaders() {
-  }
-
-  public static long contentLength(Request request) {
-    return contentLength(request.headers());
-  }
-
-  public static long contentLength(Response response) {
-    return contentLength(response.headers());
-  }
-
-  public static long contentLength(Headers headers) {
-    return stringToLong(headers.get("Content-Length"));
-  }
-
-  private static long stringToLong(String s) {
-    if (s == null) return -1;
-    try {
-      return Long.parseLong(s);
-    } catch (NumberFormatException e) {
-      return -1;
+
+    public static long contentLength(Request request) {
+        return contentLength(request.headers());
     }
-  }
-
-  /**
-   * Returns an immutable map containing each field to its list of values.
-   *
-   * @param valueForNullKey the request line for requests, or the status line
-   *     for responses. If non-null, this value is mapped to the null key.
-   */
-  public static Map<String, List<String>> toMultimap(Headers headers, String valueForNullKey) {
-    Map<String, List<String>> result = new TreeMap<>(FIELD_NAME_COMPARATOR);
-    for (int i = 0, size = headers.size(); i < size; i++) {
-      String fieldName = headers.name(i);
-      String value = headers.value(i);
-
-      List<String> allValues = new ArrayList<>();
-      List<String> otherValues = result.get(fieldName);
-      if (otherValues != null) {
-        allValues.addAll(otherValues);
-      }
-      allValues.add(value);
-      result.put(fieldName, Collections.unmodifiableList(allValues));
+
+    public static long contentLength(Response response) {
+        return contentLength(response.headers());
     }
-    if (valueForNullKey != null) {
-      result.put(null, Collections.unmodifiableList(Collections.singletonList(valueForNullKey)));
+
+    public static long contentLength(Headers headers) {
+        return stringToLong(headers.get("Content-Length"));
     }
-    return Collections.unmodifiableMap(result);
-  }
-
-  public static void addCookies(Request.Builder builder, Map<String, List<String>> cookieHeaders) {
-    for (Map.Entry<String, List<String>> entry : cookieHeaders.entrySet()) {
-      String key = entry.getKey();
-      if (("Cookie".equalsIgnoreCase(key) || "Cookie2".equalsIgnoreCase(key))
-          && !entry.getValue().isEmpty()) {
-        builder.addHeader(key, buildCookieHeader(entry.getValue()));
-      }
+
+    private static long stringToLong(String s) {
+        if (s == null) return -1;
+        try {
+            return Long.parseLong(s);
+        } catch (NumberFormatException e) {
+            return -1;
+        }
     }
-  }
-
-  /**
-   * Send all cookies in one big header, as recommended by
-   * <a href="http://tools.ietf.org/html/rfc6265#section-4.2.1">RFC 6265</a>.
-   */
-  private static String buildCookieHeader(List<String> cookies) {
-    if (cookies.size() == 1) return cookies.get(0);
-    StringBuilder sb = new StringBuilder();
-    for (int i = 0, size = cookies.size(); i < size; i++) {
-      if (i > 0) sb.append("; ");
-      sb.append(cookies.get(i));
+
+    /**
+     * Returns an immutable map containing each field to its list of values.
+     *
+     * @param valueForNullKey the request line for requests, or the status line
+     *                        for responses. If non-null, this value is mapped to the null key.
+     */
+    public static Map<String, List<String>> toMultimap(Headers headers, String valueForNullKey) {
+        Map<String, List<String>> result = new TreeMap<>(FIELD_NAME_COMPARATOR);
+        for (int i = 0, size = headers.size(); i < size; i++) {
+            String fieldName = headers.name(i);
+            String value = headers.value(i);
+
+            List<String> allValues = new ArrayList<>();
+            List<String> otherValues = result.get(fieldName);
+            if (otherValues != null) {
+                allValues.addAll(otherValues);
+            }
+            allValues.add(value);
+            result.put(fieldName, Collections.unmodifiableList(allValues));
+        }
+        if (valueForNullKey != null) {
+            result.put(null, Collections.unmodifiableList(Collections.singletonList(valueForNullKey)));
+        }
+        return Collections.unmodifiableMap(result);
     }
-    return sb.toString();
-  }
-
-  /**
-   * Returns true if none of the Vary headers have changed between {@code
-   * cachedRequest} and {@code newRequest}.
-   */
-  public static boolean varyMatches(
-      Response cachedResponse, Headers cachedRequest, Request newRequest) {
-    for (String field : varyFields(cachedResponse)) {
-      if (!equal(cachedRequest.values(field), newRequest.headers(field))) return false;
+
+    public static void addCookies(Request.Builder builder, Map<String, List<String>> cookieHeaders) {
+        for (Map.Entry<String, List<String>> entry : cookieHeaders.entrySet()) {
+            String key = entry.getKey();
+            if (("Cookie".equalsIgnoreCase(key) || "Cookie2".equalsIgnoreCase(key))
+                    && !entry.getValue().isEmpty()) {
+                builder.addHeader(key, buildCookieHeader(entry.getValue()));
+            }
+        }
     }
-    return true;
-  }
-
-  /**
-   * Returns true if a Vary header contains an asterisk. Such responses cannot
-   * be cached.
-   */
-  public static boolean hasVaryAll(Response response) {
-    return hasVaryAll(response.headers());
-  }
-
-  /**
-   * Returns true if a Vary header contains an asterisk. Such responses cannot
-   * be cached.
-   */
-  public static boolean hasVaryAll(Headers responseHeaders) {
-    return varyFields(responseHeaders).contains("*");
-  }
-
-  private static Set<String> varyFields(Response response) {
-    return varyFields(response.headers());
-  }
-
-  /**
-   * Returns the names of the request headers that need to be checked for
-   * equality when caching.
-   */
-  public static Set<String> varyFields(Headers responseHeaders) {
-    Set<String> result = Collections.emptySet();
-    for (int i = 0, size = responseHeaders.size(); i < size; i++) {
-      if (!"Vary".equalsIgnoreCase(responseHeaders.name(i))) continue;
-
-      String value = responseHeaders.value(i);
-      if (result.isEmpty()) {
-        result = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
-      }
-      for (String varyField : value.split(",")) {
-        result.add(varyField.trim());
-      }
+
+    /**
+     * Send all cookies in one big header, as recommended by
+     * <a href="http://tools.ietf.org/html/rfc6265#section-4.2.1">RFC 6265</a>.
+     */
+    private static String buildCookieHeader(List<String> cookies) {
+        if (cookies.size() == 1) return cookies.get(0);
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0, size = cookies.size(); i < size; i++) {
+            if (i > 0) sb.append("; ");
+            sb.append(cookies.get(i));
+        }
+        return sb.toString();
     }
-    return result;
-  }
-
-  /**
-   * Returns the subset of the headers in {@code response}'s request that
-   * impact the content of response's body.
-   */
-  public static Headers varyHeaders(Response response) {
-    // Use the request headers sent over the network, since that's what the
-    // response varies on. Otherwise OkHttp-supplied headers like
-    // "Accept-Encoding: gzip" may be lost.
-    Headers requestHeaders = response.networkResponse().request().headers();
-    Headers responseHeaders = response.headers();
-    return varyHeaders(requestHeaders, responseHeaders);
-  }
-
-  /**
-   * Returns the subset of the headers in {@code requestHeaders} that
-   * impact the content of response's body.
-   */
-  public static Headers varyHeaders(Headers requestHeaders, Headers responseHeaders) {
-    Set<String> varyFields = varyFields(responseHeaders);
-    if (varyFields.isEmpty()) return new Headers.Builder().build();
-
-    Headers.Builder result = new Headers.Builder();
-    for (int i = 0, size = requestHeaders.size(); i < size; i++) {
-      String fieldName = requestHeaders.name(i);
-      if (varyFields.contains(fieldName)) {
-        result.add(fieldName, requestHeaders.value(i));
-      }
+
+    /**
+     * Returns true if none of the Vary headers have changed between {@code
+     * cachedRequest} and {@code newRequest}.
+     */
+    public static boolean varyMatches(
+            Response cachedResponse, Headers cachedRequest, Request newRequest) {
+        for (String field : varyFields(cachedResponse)) {
+            if (!equal(cachedRequest.values(field), newRequest.headers(field))) return false;
+        }
+        return true;
+    }
+
+    /**
+     * Returns true if a Vary header contains an asterisk. Such responses cannot
+     * be cached.
+     */
+    public static boolean hasVaryAll(Response response) {
+        return hasVaryAll(response.headers());
+    }
+
+    /**
+     * Returns true if a Vary header contains an asterisk. Such responses cannot
+     * be cached.
+     */
+    public static boolean hasVaryAll(Headers responseHeaders) {
+        return varyFields(responseHeaders).contains("*");
     }
-    return result.build();
-  }
-
-  /**
-   * Returns true if {@code fieldName} is an end-to-end HTTP header, as
-   * defined by RFC 2616, 13.5.1.
-   */
-  static boolean isEndToEnd(String fieldName) {
-    return !"Connection".equalsIgnoreCase(fieldName)
-        && !"Keep-Alive".equalsIgnoreCase(fieldName)
-        && !"Proxy-Authenticate".equalsIgnoreCase(fieldName)
-        && !"Proxy-Authorization".equalsIgnoreCase(fieldName)
-        && !"TE".equalsIgnoreCase(fieldName)
-        && !"Trailers".equalsIgnoreCase(fieldName)
-        && !"Transfer-Encoding".equalsIgnoreCase(fieldName)
-        && !"Upgrade".equalsIgnoreCase(fieldName);
-  }
-
-  /**
-   * Parse RFC 2617 challenges. This API is only interested in the scheme
-   * name and realm.
-   */
-  public static List<Challenge> parseChallenges(Headers responseHeaders, String challengeHeader) {
-    // auth-scheme = token
-    // auth-param  = token "=" ( token | quoted-string )
-    // challenge   = auth-scheme 1*SP 1#auth-param
-    // realm       = "realm" "=" realm-value
-    // realm-value = quoted-string
-    List<Challenge> result = new ArrayList<>();
-    for (int i = 0, size = responseHeaders.size(); i < size; i++) {
-      if (!challengeHeader.equalsIgnoreCase(responseHeaders.name(i))) {
-        continue;
-      }
-      String value = responseHeaders.value(i);
-      int pos = 0;
-      while (pos < value.length()) {
-        int tokenStart = pos;
-        pos = HeaderParser.skipUntil(value, pos, " ");
-
-        String scheme = value.substring(tokenStart, pos).trim();
-        pos = HeaderParser.skipWhitespace(value, pos);
-
-        // TODO: This currently only handles schemes with a 'realm' parameter;
-        //       It needs to be fixed to handle any scheme and any parameters
-        //       http://code.google.com/p/android/issues/detail?id=11140
-
-        if (!value.regionMatches(true, pos, "realm=\"", 0, "realm=\"".length())) {
-          break; // Unexpected challenge parameter; give up!
+
+    private static Set<String> varyFields(Response response) {
+        return varyFields(response.headers());
+    }
+
+    /**
+     * Returns the names of the request headers that need to be checked for
+     * equality when caching.
+     */
+    public static Set<String> varyFields(Headers responseHeaders) {
+        Set<String> result = Collections.emptySet();
+        for (int i = 0, size = responseHeaders.size(); i < size; i++) {
+            if (!"Vary".equalsIgnoreCase(responseHeaders.name(i))) continue;
+
+            String value = responseHeaders.value(i);
+            if (result.isEmpty()) {
+                result = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
+            }
+            for (String varyField : value.split(",")) {
+                result.add(varyField.trim());
+            }
         }
+        return result;
+    }
+
+    /**
+     * Returns the subset of the headers in {@code response}'s request that
+     * impact the content of response's body.
+     */
+    public static Headers varyHeaders(Response response) {
+        // Use the request headers sent over the network, since that's what the
+        // response varies on. Otherwise OkHttp-supplied headers like
+        // "Accept-Encoding: gzip" may be lost.
+        Headers requestHeaders = response.networkResponse().request().headers();
+        Headers responseHeaders = response.headers();
+        return varyHeaders(requestHeaders, responseHeaders);
+    }
+
+    /**
+     * Returns the subset of the headers in {@code requestHeaders} that
+     * impact the content of response's body.
+     */
+    public static Headers varyHeaders(Headers requestHeaders, Headers responseHeaders) {
+        Set<String> varyFields = varyFields(responseHeaders);
+        if (varyFields.isEmpty()) return new Headers.Builder().build();
+
+        Headers.Builder result = new Headers.Builder();
+        for (int i = 0, size = requestHeaders.size(); i < size; i++) {
+            String fieldName = requestHeaders.name(i);
+            if (varyFields.contains(fieldName)) {
+                result.add(fieldName, requestHeaders.value(i));
+            }
+        }
+        return result.build();
+    }
+
+    /**
+     * Returns true if {@code fieldName} is an end-to-end HTTP header, as
+     * defined by RFC 2616, 13.5.1.
+     */
+    static boolean isEndToEnd(String fieldName) {
+        return !"Connection".equalsIgnoreCase(fieldName)
+                && !"Keep-Alive".equalsIgnoreCase(fieldName)
+                && !"Proxy-Authenticate".equalsIgnoreCase(fieldName)
+                && !"Proxy-Authorization".equalsIgnoreCase(fieldName)
+                && !"TE".equalsIgnoreCase(fieldName)
+                && !"Trailers".equalsIgnoreCase(fieldName)
+                && !"Transfer-Encoding".equalsIgnoreCase(fieldName)
+                && !"Upgrade".equalsIgnoreCase(fieldName);
+    }
+
+    /**
+     * Parse RFC 2617 challenges. This API is only interested in the scheme
+     * name and realm.
+     */
+    public static List<Challenge> parseChallenges(Headers responseHeaders, String challengeHeader) {
+        // auth-scheme = token
+        // auth-param  = token "=" ( token | quoted-string )
+        // challenge   = auth-scheme 1*SP 1#auth-param
+        // realm       = "realm" "=" realm-value
+        // realm-value = quoted-string
+        List<Challenge> result = new ArrayList<>();
+        for (int i = 0, size = responseHeaders.size(); i < size; i++) {
+            if (!challengeHeader.equalsIgnoreCase(responseHeaders.name(i))) {
+                continue;
+            }
+            String value = responseHeaders.value(i);
+            int pos = 0;
+            while (pos < value.length()) {
+                int tokenStart = pos;
+                pos = HeaderParser.skipUntil(value, pos, " ");
+
+                String scheme = value.substring(tokenStart, pos).trim();
+                pos = HeaderParser.skipWhitespace(value, pos);
+
+                // TODO: This currently only handles schemes with a 'realm' parameter;
+                //       It needs to be fixed to handle any scheme and any parameters
+                //       http://code.google.com/p/android/issues/detail?id=11140
+
+                if (!value.regionMatches(true, pos, "realm=\"", 0, "realm=\"".length())) {
+                    break; // Unexpected challenge parameter; give up!
+                }
+
+                pos += "realm=\"".length();
+                int realmStart = pos;
+                pos = HeaderParser.skipUntil(value, pos, "\"");
+                String realm = value.substring(realmStart, pos);
+                pos++; // Consume '"' close quote.
+                pos = HeaderParser.skipUntil(value, pos, ",");
+                pos++; // Consume ',' comma.
+                pos = HeaderParser.skipWhitespace(value, pos);
+                result.add(new Challenge(scheme, realm));
+            }
+        }
+        return result;
+    }
 
-        pos += "realm=\"".length();
-        int realmStart = pos;
-        pos = HeaderParser.skipUntil(value, pos, "\"");
-        String realm = value.substring(realmStart, pos);
-        pos++; // Consume '"' close quote.
-        pos = HeaderParser.skipUntil(value, pos, ",");
-        pos++; // Consume ',' comma.
-        pos = HeaderParser.skipWhitespace(value, pos);
-        result.add(new Challenge(scheme, realm));
-      }
+    /**
+     * React to a failed authorization response by looking up new credentials.
+     * Returns a request for a subsequent attempt, or null if no further attempts
+     * should be made.
+     */
+    public static Request processAuthHeader(Authenticator authenticator, Response response,
+                                            Proxy proxy) throws IOException {
+        return response.code() == HTTP_PROXY_AUTH
+                ? authenticator.authenticateProxy(proxy, response)
+                : authenticator.authenticate(proxy, response);
     }
-    return result;
-  }
-
-  /**
-   * React to a failed authorization response by looking up new credentials.
-   * Returns a request for a subsequent attempt, or null if no further attempts
-   * should be made.
-   */
-  public static Request processAuthHeader(Authenticator authenticator, Response response,
-      Proxy proxy) throws IOException {
-    return response.code() == HTTP_PROXY_AUTH
-        ? authenticator.authenticateProxy(proxy, response)
-        : authenticator.authenticate(proxy, response);
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RealResponseBody.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RealResponseBody.java
index 18d026f11a..f36f0835a3 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RealResponseBody.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RealResponseBody.java
@@ -18,27 +18,31 @@
 import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.ResponseBody;
+
 import okio.BufferedSource;
 
 public final class RealResponseBody extends ResponseBody {
-  private final Headers headers;
-  private final BufferedSource source;
+    private final Headers headers;
+    private final BufferedSource source;
 
-  public RealResponseBody(Headers headers, BufferedSource source) {
-    this.headers = headers;
-    this.source = source;
-  }
+    public RealResponseBody(Headers headers, BufferedSource source) {
+        this.headers = headers;
+        this.source = source;
+    }
 
-  @Override public MediaType contentType() {
-    String contentType = headers.get("Content-Type");
-    return contentType != null ? MediaType.parse(contentType) : null;
-  }
+    @Override
+    public MediaType contentType() {
+        String contentType = headers.get("Content-Type");
+        return contentType != null ? MediaType.parse(contentType) : null;
+    }
 
-  @Override public long contentLength() {
-    return OkHeaders.contentLength(headers);
-  }
+    @Override
+    public long contentLength() {
+        return OkHeaders.contentLength(headers);
+    }
 
-  @Override public BufferedSource source() {
-    return source;
-  }
+    @Override
+    public BufferedSource source() {
+        return source;
+    }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestException.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestException.java
index 16893acdfb..99e0bb5c68 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestException.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestException.java
@@ -23,12 +23,12 @@
  */
 public final class RequestException extends Exception {
 
-  public RequestException(IOException cause) {
-    super(cause);
-  }
+    public RequestException(IOException cause) {
+        super(cause);
+    }
 
-  @Override
-  public IOException getCause() {
-    return (IOException) super.getCause();
-  }
+    @Override
+    public IOException getCause() {
+        return (IOException) super.getCause();
+    }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestLine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestLine.java
index f764afd326..9b8c8a1ae3 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestLine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestLine.java
@@ -2,56 +2,57 @@
 
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
+
 import java.net.HttpURLConnection;
 import java.net.Proxy;
 import java.net.URL;
 
 public final class RequestLine {
-  private RequestLine() {
-  }
-
-  /**
-   * Returns the request status line, like "GET / HTTP/1.1". This is exposed
-   * to the application by {@link HttpURLConnection#getHeaderFields}, so it
-   * needs to be set even if the transport is SPDY.
-   */
-  static String get(Request request, Proxy.Type proxyType, Protocol protocol) {
-    StringBuilder result = new StringBuilder();
-    result.append(request.method());
-    result.append(' ');
-
-    if (includeAuthorityInRequestLine(request, proxyType)) {
-      result.append(request.url());
-    } else {
-      result.append(requestPath(request.url()));
+    private RequestLine() {
+    }
+
+    /**
+     * Returns the request status line, like "GET / HTTP/1.1". This is exposed
+     * to the application by {@link HttpURLConnection#getHeaderFields}, so it
+     * needs to be set even if the transport is SPDY.
+     */
+    static String get(Request request, Proxy.Type proxyType, Protocol protocol) {
+        StringBuilder result = new StringBuilder();
+        result.append(request.method());
+        result.append(' ');
+
+        if (includeAuthorityInRequestLine(request, proxyType)) {
+            result.append(request.url());
+        } else {
+            result.append(requestPath(request.url()));
+        }
+
+        result.append(' ');
+        result.append(version(protocol));
+        return result.toString();
+    }
+
+    /**
+     * Returns true if the request line should contain the full URL with host
+     * and port (like "GET http://android.com/foo HTTP/1.1") or only the path
+     * (like "GET /foo HTTP/1.1").
+     */
+    private static boolean includeAuthorityInRequestLine(Request request, Proxy.Type proxyType) {
+        return !request.isHttps() && proxyType == Proxy.Type.HTTP;
+    }
+
+    /**
+     * Returns the path to request, like the '/' in 'GET / HTTP/1.1'. Never empty,
+     * even if the request URL is. Includes the query component if it exists.
+     */
+    public static String requestPath(URL url) {
+        String pathAndQuery = url.getFile();
+        if (pathAndQuery == null) return "/";
+        if (!pathAndQuery.startsWith("/")) return "/" + pathAndQuery;
+        return pathAndQuery;
     }
 
-    result.append(' ');
-    result.append(version(protocol));
-    return result.toString();
-  }
-
-  /**
-   * Returns true if the request line should contain the full URL with host
-   * and port (like "GET http://android.com/foo HTTP/1.1") or only the path
-   * (like "GET /foo HTTP/1.1").
-   */
-  private static boolean includeAuthorityInRequestLine(Request request, Proxy.Type proxyType) {
-    return !request.isHttps() && proxyType == Proxy.Type.HTTP;
-  }
-
-  /**
-   * Returns the path to request, like the '/' in 'GET / HTTP/1.1'. Never empty,
-   * even if the request URL is. Includes the query component if it exists.
-   */
-  public static String requestPath(URL url) {
-    String pathAndQuery = url.getFile();
-    if (pathAndQuery == null) return "/";
-    if (!pathAndQuery.startsWith("/")) return "/" + pathAndQuery;
-    return pathAndQuery;
-  }
-
-  public static String version(Protocol protocol) {
-    return protocol == Protocol.HTTP_1_0 ? "HTTP/1.0" : "HTTP/1.1";
-  }
+    public static String version(Protocol protocol) {
+        return protocol == Protocol.HTTP_1_0 ? "HTTP/1.0" : "HTTP/1.1";
+    }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableSink.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableSink.java
index 371769f66e..b4a083e050 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableSink.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableSink.java
@@ -18,6 +18,7 @@
 
 import java.io.IOException;
 import java.net.ProtocolException;
+
 import okio.Buffer;
 import okio.Sink;
 import okio.Timeout;
@@ -30,51 +31,55 @@
  * sent multiple times.
  */
 public final class RetryableSink implements Sink {
-  private boolean closed;
-  private final int limit;
-  private final Buffer content = new Buffer();
+    private boolean closed;
+    private final int limit;
+    private final Buffer content = new Buffer();
 
-  public RetryableSink(int limit) {
-    this.limit = limit;
-  }
+    public RetryableSink(int limit) {
+        this.limit = limit;
+    }
 
-  public RetryableSink() {
-    this(-1);
-  }
+    public RetryableSink() {
+        this(-1);
+    }
 
-  @Override public void close() throws IOException {
-    if (closed) return;
-    closed = true;
-    if (content.size() < limit) {
-      throw new ProtocolException(
-          "content-length promised " + limit + " bytes, but received " + content.size());
+    @Override
+    public void close() throws IOException {
+        if (closed) return;
+        closed = true;
+        if (content.size() < limit) {
+            throw new ProtocolException(
+                    "content-length promised " + limit + " bytes, but received " + content.size());
+        }
     }
-  }
 
-  @Override public void write(Buffer source, long byteCount) throws IOException {
-    if (closed) throw new IllegalStateException("closed");
-    checkOffsetAndCount(source.size(), 0, byteCount);
-    if (limit != -1 && content.size() > limit - byteCount) {
-      throw new ProtocolException("exceeded content-length limit of " + limit + " bytes");
+    @Override
+    public void write(Buffer source, long byteCount) throws IOException {
+        if (closed) throw new IllegalStateException("closed");
+        checkOffsetAndCount(source.size(), 0, byteCount);
+        if (limit != -1 && content.size() > limit - byteCount) {
+            throw new ProtocolException("exceeded content-length limit of " + limit + " bytes");
+        }
+        content.write(source, byteCount);
     }
-    content.write(source, byteCount);
-  }
 
-  @Override public void flush() throws IOException {
-  }
+    @Override
+    public void flush() throws IOException {
+    }
 
-  @Override public Timeout timeout() {
-    return Timeout.NONE;
-  }
+    @Override
+    public Timeout timeout() {
+        return Timeout.NONE;
+    }
 
-  public long contentLength() throws IOException {
-    return content.size();
-  }
+    public long contentLength() throws IOException {
+        return content.size();
+    }
 
-  public void writeToSocket(Sink socketOut) throws IOException {
-    // Copy the content; otherwise we won't have data to retry.
-    Buffer buffer = new Buffer();
-    content.copyTo(buffer, 0, content.size());
-    socketOut.write(buffer, buffer.size());
-  }
+    public void writeToSocket(Sink socketOut) throws IOException {
+        // Copy the content; otherwise we won't have data to retry.
+        Buffer buffer = new Buffer();
+        content.copyTo(buffer, 0, content.size());
+        socketOut.write(buffer, buffer.size());
+    }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteException.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteException.java
index 62b31751e9..fcdc3739f6 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteException.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteException.java
@@ -24,38 +24,40 @@
  * have been made with alternative protocols, none of which were successful.
  */
 public final class RouteException extends Exception {
-  private static final Method addSuppressedExceptionMethod;
-  static {
-    Method m;
-    try {
-      m = Throwable.class.getDeclaredMethod("addSuppressed", Throwable.class);
-    } catch (Exception e) {
-      m = null;
+    private static final Method addSuppressedExceptionMethod;
+
+    static {
+        Method m;
+        try {
+            m = Throwable.class.getDeclaredMethod("addSuppressed", Throwable.class);
+        } catch (Exception e) {
+            m = null;
+        }
+        addSuppressedExceptionMethod = m;
     }
-    addSuppressedExceptionMethod = m;
-  }
-  private IOException lastException;
-
-  public RouteException(IOException cause) {
-    super(cause);
-    lastException = cause;
-  }
-
-  public IOException getLastConnectException() {
-    return lastException;
-  }
-
-  public void addConnectException(IOException e) {
-    addSuppressedIfPossible(e, lastException);
-    lastException = e;
-  }
-
-  private void addSuppressedIfPossible(IOException e, IOException suppressed) {
-    if (addSuppressedExceptionMethod != null) {
-      try {
-        addSuppressedExceptionMethod.invoke(e, suppressed);
-      } catch (InvocationTargetException | IllegalAccessException ignored) {
-      }
+
+    private IOException lastException;
+
+    public RouteException(IOException cause) {
+        super(cause);
+        lastException = cause;
+    }
+
+    public IOException getLastConnectException() {
+        return lastException;
+    }
+
+    public void addConnectException(IOException e) {
+        addSuppressedIfPossible(e, lastException);
+        lastException = e;
+    }
+
+    private void addSuppressedIfPossible(IOException e, IOException suppressed) {
+        if (addSuppressedExceptionMethod != null) {
+            try {
+                addSuppressedExceptionMethod.invoke(e, suppressed);
+            } catch (InvocationTargetException | IllegalAccessException ignored) {
+            }
+        }
     }
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java
index 16448e4dea..76d42db4ab 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java
@@ -22,6 +22,7 @@
 import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.Network;
 import com.squareup.okhttp.internal.RouteDatabase;
+
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
@@ -42,195 +43,211 @@
  * recycled.
  */
 public final class RouteSelector {
-  private final Address address;
-  private final URI uri;
-  private final Network network;
-  private final OkHttpClient client;
-  private final RouteDatabase routeDatabase;
-
-  /* The most recently attempted route. */
-  private Proxy lastProxy;
-  private InetSocketAddress lastInetSocketAddress;
-
-  /* State for negotiating the next proxy to use. */
-  private List<Proxy> proxies = Collections.emptyList();
-  private int nextProxyIndex;
-
-  /* State for negotiating the next socket address to use. */
-  private List<InetSocketAddress> inetSocketAddresses = Collections.emptyList();
-  private int nextInetSocketAddressIndex;
-
-  /* State for negotiating failed routes */
-  private final List<Route> postponedRoutes = new ArrayList<>();
-
-  private RouteSelector(Address address, URI uri, OkHttpClient client) {
-    this.address = address;
-    this.uri = uri;
-    this.client = client;
-    this.routeDatabase = Internal.instance.routeDatabase(client);
-    this.network = Internal.instance.network(client);
-
-    resetNextProxy(uri, address.getProxy());
-  }
-
-  public static RouteSelector get(Address address, Request request, OkHttpClient client)
-      throws IOException {
-    return new RouteSelector(address, request.uri(), client);
-  }
-
-  /**
-   * Returns true if there's another route to attempt. Every address has at
-   * least one route.
-   */
-  public boolean hasNext() {
-    return hasNextInetSocketAddress()
-        || hasNextProxy()
-        || hasNextPostponed();
-  }
-
-  public Route next() throws IOException {
-    // Compute the next route to attempt.
-    if (!hasNextInetSocketAddress()) {
-      if (!hasNextProxy()) {
-        if (!hasNextPostponed()) {
-          throw new NoSuchElementException();
+    private final Address address;
+    private final URI uri;
+    private final Network network;
+    private final OkHttpClient client;
+    private final RouteDatabase routeDatabase;
+
+    /* The most recently attempted route. */
+    private Proxy lastProxy;
+    private InetSocketAddress lastInetSocketAddress;
+
+    /* State for negotiating the next proxy to use. */
+    private List<Proxy> proxies = Collections.emptyList();
+    private int nextProxyIndex;
+
+    /* State for negotiating the next socket address to use. */
+    private List<InetSocketAddress> inetSocketAddresses = Collections.emptyList();
+    private int nextInetSocketAddressIndex;
+
+    /* State for negotiating failed routes */
+    private final List<Route> postponedRoutes = new ArrayList<>();
+
+    private RouteSelector(Address address, URI uri, OkHttpClient client) {
+        this.address = address;
+        this.uri = uri;
+        this.client = client;
+        this.routeDatabase = Internal.instance.routeDatabase(client);
+        this.network = Internal.instance.network(client);
+
+        resetNextProxy(uri, address.getProxy());
+    }
+
+    public static RouteSelector get(Address address, Request request, OkHttpClient client)
+            throws IOException {
+        return new RouteSelector(address, request.uri(), client);
+    }
+
+    /**
+     * Returns true if there's another route to attempt. Every address has at
+     * least one route.
+     */
+    public boolean hasNext() {
+        return hasNextInetSocketAddress()
+                || hasNextProxy()
+                || hasNextPostponed();
+    }
+
+    public Route next() throws IOException {
+        // Compute the next route to attempt.
+        if (!hasNextInetSocketAddress()) {
+            if (!hasNextProxy()) {
+                if (!hasNextPostponed()) {
+                    throw new NoSuchElementException();
+                }
+                return nextPostponed();
+            }
+            lastProxy = nextProxy();
         }
-        return nextPostponed();
-      }
-      lastProxy = nextProxy();
+        lastInetSocketAddress = nextInetSocketAddress();
+
+        Route route = new Route(address, lastProxy, lastInetSocketAddress);
+        if (routeDatabase.shouldPostpone(route)) {
+            postponedRoutes.add(route);
+            // We will only recurse in order to skip previously failed routes. They will be tried last.
+            return next();
+        }
+
+        return route;
     }
-    lastInetSocketAddress = nextInetSocketAddress();
 
-    Route route = new Route(address, lastProxy, lastInetSocketAddress);
-    if (routeDatabase.shouldPostpone(route)) {
-      postponedRoutes.add(route);
-      // We will only recurse in order to skip previously failed routes. They will be tried last.
-      return next();
+    /**
+     * Clients should invoke this method when they encounter a connectivity
+     * failure on a connection returned by this route selector.
+     */
+    public void connectFailed(Route failedRoute, IOException failure) {
+        if (failedRoute.getProxy().type() != Proxy.Type.DIRECT && address.getProxySelector() != null) {
+            // Tell the proxy selector when we fail to connect on a fresh connection.
+            address.getProxySelector().connectFailed(uri, failedRoute.getProxy().address(), failure);
+        }
+
+        routeDatabase.failed(failedRoute);
     }
 
-    return route;
-  }
-
-  /**
-   * Clients should invoke this method when they encounter a connectivity
-   * failure on a connection returned by this route selector.
-   */
-  public void connectFailed(Route failedRoute, IOException failure) {
-    if (failedRoute.getProxy().type() != Proxy.Type.DIRECT && address.getProxySelector() != null) {
-      // Tell the proxy selector when we fail to connect on a fresh connection.
-      address.getProxySelector().connectFailed(uri, failedRoute.getProxy().address(), failure);
+    /**
+     * Prepares the proxy servers to try.
+     */
+    private void resetNextProxy(URI uri, Proxy proxy) {
+        if (proxy != null) {
+            // If the user specifies a proxy, try that and only that.
+            proxies = Collections.singletonList(proxy);
+        } else {
+            // Try each of the ProxySelector choices until one connection succeeds. If none succeed
+            // then we'll try a direct connection below.
+            proxies = new ArrayList<>();
+            List<Proxy> selectedProxies = client.getProxySelector().select(uri);
+            if (selectedProxies != null) proxies.addAll(selectedProxies);
+            // Finally try a direct connection. We only try it once!
+            proxies.removeAll(Collections.singleton(Proxy.NO_PROXY));
+            proxies.add(Proxy.NO_PROXY);
+        }
+        nextProxyIndex = 0;
     }
 
-    routeDatabase.failed(failedRoute);
-  }
-
-  /** Prepares the proxy servers to try. */
-  private void resetNextProxy(URI uri, Proxy proxy) {
-    if (proxy != null) {
-      // If the user specifies a proxy, try that and only that.
-      proxies = Collections.singletonList(proxy);
-    } else {
-      // Try each of the ProxySelector choices until one connection succeeds. If none succeed
-      // then we'll try a direct connection below.
-      proxies = new ArrayList<>();
-      List<Proxy> selectedProxies = client.getProxySelector().select(uri);
-      if (selectedProxies != null) proxies.addAll(selectedProxies);
-      // Finally try a direct connection. We only try it once!
-      proxies.removeAll(Collections.singleton(Proxy.NO_PROXY));
-      proxies.add(Proxy.NO_PROXY);
+    /**
+     * Returns true if there's another proxy to try.
+     */
+    private boolean hasNextProxy() {
+        return nextProxyIndex < proxies.size();
     }
-    nextProxyIndex = 0;
-  }
-
-  /** Returns true if there's another proxy to try. */
-  private boolean hasNextProxy() {
-    return nextProxyIndex < proxies.size();
-  }
-
-  /** Returns the next proxy to try. May be PROXY.NO_PROXY but never null. */
-  private Proxy nextProxy() throws IOException {
-    if (!hasNextProxy()) {
-      throw new SocketException("No route to " + address.getUriHost()
-          + "; exhausted proxy configurations: " + proxies);
+
+    /**
+     * Returns the next proxy to try. May be PROXY.NO_PROXY but never null.
+     */
+    private Proxy nextProxy() throws IOException {
+        if (!hasNextProxy()) {
+            throw new SocketException("No route to " + address.getUriHost()
+                    + "; exhausted proxy configurations: " + proxies);
+        }
+        Proxy result = proxies.get(nextProxyIndex++);
+        resetNextInetSocketAddress(result);
+        return result;
     }
-    Proxy result = proxies.get(nextProxyIndex++);
-    resetNextInetSocketAddress(result);
-    return result;
-  }
-
-  /** Prepares the socket addresses to attempt for the current proxy or host. */
-  private void resetNextInetSocketAddress(Proxy proxy) throws IOException {
-    // Clear the addresses. Necessary if getAllByName() below throws!
-    inetSocketAddresses = new ArrayList<>();
-
-    String socketHost;
-    int socketPort;
-    if (proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.SOCKS) {
-      socketHost = address.getUriHost();
-      socketPort = getEffectivePort(uri);
-    } else {
-      SocketAddress proxyAddress = proxy.address();
-      if (!(proxyAddress instanceof InetSocketAddress)) {
-        throw new IllegalArgumentException(
-            "Proxy.address() is not an " + "InetSocketAddress: " + proxyAddress.getClass());
-      }
-      InetSocketAddress proxySocketAddress = (InetSocketAddress) proxyAddress;
-      socketHost = getHostString(proxySocketAddress);
-      socketPort = proxySocketAddress.getPort();
+
+    /**
+     * Prepares the socket addresses to attempt for the current proxy or host.
+     */
+    private void resetNextInetSocketAddress(Proxy proxy) throws IOException {
+        // Clear the addresses. Necessary if getAllByName() below throws!
+        inetSocketAddresses = new ArrayList<>();
+
+        String socketHost;
+        int socketPort;
+        if (proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.SOCKS) {
+            socketHost = address.getUriHost();
+            socketPort = getEffectivePort(uri);
+        } else {
+            SocketAddress proxyAddress = proxy.address();
+            if (!(proxyAddress instanceof InetSocketAddress)) {
+                throw new IllegalArgumentException(
+                        "Proxy.address() is not an " + "InetSocketAddress: " + proxyAddress.getClass());
+            }
+            InetSocketAddress proxySocketAddress = (InetSocketAddress) proxyAddress;
+            socketHost = getHostString(proxySocketAddress);
+            socketPort = proxySocketAddress.getPort();
+        }
+
+        if (socketPort < 1 || socketPort > 65535) {
+            throw new SocketException("No route to " + socketHost + ":" + socketPort
+                    + "; port is out of range");
+        }
+
+        // Try each address for best behavior in mixed IPv4/IPv6 environments.
+        for (InetAddress inetAddress : network.resolveInetAddresses(socketHost)) {
+            inetSocketAddresses.add(new InetSocketAddress(inetAddress, socketPort));
+        }
+
+        nextInetSocketAddressIndex = 0;
+    }
+
+    /**
+     * Obtain a "host" from an {@link InetSocketAddress}. This returns a string containing either an
+     * actual host name or a numeric IP address.
+     */
+    // Visible for testing
+    static String getHostString(InetSocketAddress socketAddress) {
+        InetAddress address = socketAddress.getAddress();
+        if (address == null) {
+            // The InetSocketAddress was specified with a string (either a numeric IP or a host name). If
+            // it is a name, all IPs for that name should be tried. If it is an IP address, only that IP
+            // address should be tried.
+            return socketAddress.getHostName();
+        }
+        // The InetSocketAddress has a specific address: we should only try that address. Therefore we
+        // return the address and ignore any host name that may be available.
+        return address.getHostAddress();
     }
 
-    if (socketPort < 1 || socketPort > 65535) {
-      throw new SocketException("No route to " + socketHost + ":" + socketPort
-          + "; port is out of range");
+    /**
+     * Returns true if there's another socket address to try.
+     */
+    private boolean hasNextInetSocketAddress() {
+        return nextInetSocketAddressIndex < inetSocketAddresses.size();
     }
 
-    // Try each address for best behavior in mixed IPv4/IPv6 environments.
-    for (InetAddress inetAddress : network.resolveInetAddresses(socketHost)) {
-      inetSocketAddresses.add(new InetSocketAddress(inetAddress, socketPort));
+    /**
+     * Returns the next socket address to try.
+     */
+    private InetSocketAddress nextInetSocketAddress() throws IOException {
+        if (!hasNextInetSocketAddress()) {
+            throw new SocketException("No route to " + address.getUriHost()
+                    + "; exhausted inet socket addresses: " + inetSocketAddresses);
+        }
+        return inetSocketAddresses.get(nextInetSocketAddressIndex++);
     }
 
-    nextInetSocketAddressIndex = 0;
-  }
-
-  /**
-   * Obtain a "host" from an {@link InetSocketAddress}. This returns a string containing either an
-   * actual host name or a numeric IP address.
-   */
-  // Visible for testing
-  static String getHostString(InetSocketAddress socketAddress) {
-    InetAddress address = socketAddress.getAddress();
-    if (address == null) {
-      // The InetSocketAddress was specified with a string (either a numeric IP or a host name). If
-      // it is a name, all IPs for that name should be tried. If it is an IP address, only that IP
-      // address should be tried.
-      return socketAddress.getHostName();
+    /**
+     * Returns true if there is another postponed route to try.
+     */
+    private boolean hasNextPostponed() {
+        return !postponedRoutes.isEmpty();
     }
-    // The InetSocketAddress has a specific address: we should only try that address. Therefore we
-    // return the address and ignore any host name that may be available.
-    return address.getHostAddress();
-  }
-
-  /** Returns true if there's another socket address to try. */
-  private boolean hasNextInetSocketAddress() {
-    return nextInetSocketAddressIndex < inetSocketAddresses.size();
-  }
-
-  /** Returns the next socket address to try. */
-  private InetSocketAddress nextInetSocketAddress() throws IOException {
-    if (!hasNextInetSocketAddress()) {
-      throw new SocketException("No route to " + address.getUriHost()
-          + "; exhausted inet socket addresses: " + inetSocketAddresses);
+
+    /**
+     * Returns the next postponed route to try.
+     */
+    private Route nextPostponed() {
+        return postponedRoutes.remove(0);
     }
-    return inetSocketAddresses.get(nextInetSocketAddressIndex++);
-  }
-
-  /** Returns true if there is another postponed route to try. */
-  private boolean hasNextPostponed() {
-    return !postponedRoutes.isEmpty();
-  }
-
-  /** Returns the next postponed route to try. */
-  private Route nextPostponed() {
-    return postponedRoutes.remove(0);
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SocketConnector.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SocketConnector.java
index c1159bc19b..d76a4311ce 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SocketConnector.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SocketConnector.java
@@ -25,8 +25,8 @@
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.Route;
-import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.ConnectionSpecSelector;
+import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.tls.OkHostnameVerifier;
 
@@ -37,6 +37,7 @@
 import java.security.cert.X509Certificate;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
+
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
@@ -54,227 +55,231 @@
  * specified {@link ConnectionSpec} set. A {@link SocketConnector} can be used multiple times.
  */
 public class SocketConnector {
-  private final Connection connection;
-  private final ConnectionPool connectionPool;
+    private final Connection connection;
+    private final ConnectionPool connectionPool;
 
-  public SocketConnector(Connection connection, ConnectionPool connectionPool) {
-    this.connection = connection;
-    this.connectionPool = connectionPool;
-  }
+    public SocketConnector(Connection connection, ConnectionPool connectionPool) {
+        this.connection = connection;
+        this.connectionPool = connectionPool;
+    }
 
-  public ConnectedSocket connectCleartext(int connectTimeout, int readTimeout, Route route)
-      throws RouteException {
-    Socket socket = connectRawSocket(readTimeout, connectTimeout, route);
-    return new ConnectedSocket(route, socket);
-  }
+    public ConnectedSocket connectCleartext(int connectTimeout, int readTimeout, Route route)
+            throws RouteException {
+        Socket socket = connectRawSocket(readTimeout, connectTimeout, route);
+        return new ConnectedSocket(route, socket);
+    }
 
-  public ConnectedSocket connectTls(int connectTimeout, int readTimeout,
-      int writeTimeout, Request request, Route route, List<ConnectionSpec> connectionSpecs,
-      boolean connectionRetryEnabled) throws RouteException {
+    public ConnectedSocket connectTls(int connectTimeout, int readTimeout,
+                                      int writeTimeout, Request request, Route route, List<ConnectionSpec> connectionSpecs,
+                                      boolean connectionRetryEnabled) throws RouteException {
 
-    Address address = route.getAddress();
-    ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);
-    RouteException routeException = null;
-    do {
-      Socket socket = connectRawSocket(readTimeout, connectTimeout, route);
-      if (route.requiresTunnel()) {
-        createTunnel(readTimeout, writeTimeout, request, route, socket);
-      }
+        Address address = route.getAddress();
+        ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);
+        RouteException routeException = null;
+        do {
+            Socket socket = connectRawSocket(readTimeout, connectTimeout, route);
+            if (route.requiresTunnel()) {
+                createTunnel(readTimeout, writeTimeout, request, route, socket);
+            }
 
-      SSLSocket sslSocket = null;
-      try {
-        SSLSocketFactory sslSocketFactory = address.getSslSocketFactory();
+            SSLSocket sslSocket = null;
+            try {
+                SSLSocketFactory sslSocketFactory = address.getSslSocketFactory();
 
-        // Create the wrapper over the connected socket.
-        sslSocket = (SSLSocket) sslSocketFactory
-            .createSocket(socket, address.getUriHost(), address.getUriPort(), true /* autoClose */);
+                // Create the wrapper over the connected socket.
+                sslSocket = (SSLSocket) sslSocketFactory
+                        .createSocket(socket, address.getUriHost(), address.getUriPort(), true /* autoClose */);
 
-        // Configure the socket's ciphers, TLS versions, and extensions.
-        ConnectionSpec connectionSpec = connectionSpecSelector.configureSecureSocket(sslSocket);
-        Platform platform = Platform.get();
-        Handshake handshake = null;
-        Protocol alpnProtocol = null;
-        try {
-          if (connectionSpec.supportsTlsExtensions()) {
-            platform.configureTlsExtensions(
-                sslSocket, address.getUriHost(), address.getProtocols());
-          }
-          // Force handshake. This can throw!
-          sslSocket.startHandshake();
+                // Configure the socket's ciphers, TLS versions, and extensions.
+                ConnectionSpec connectionSpec = connectionSpecSelector.configureSecureSocket(sslSocket);
+                Platform platform = Platform.get();
+                Handshake handshake = null;
+                Protocol alpnProtocol = null;
+                try {
+                    if (connectionSpec.supportsTlsExtensions()) {
+                        platform.configureTlsExtensions(
+                                sslSocket, address.getUriHost(), address.getProtocols());
+                    }
+                    // Force handshake. This can throw!
+                    sslSocket.startHandshake();
 
-          handshake = Handshake.get(sslSocket.getSession());
+                    handshake = Handshake.get(sslSocket.getSession());
 
-          String maybeProtocol;
-          if (connectionSpec.supportsTlsExtensions()
-              && (maybeProtocol = platform.getSelectedProtocol(sslSocket)) != null) {
-            alpnProtocol = Protocol.get(maybeProtocol); // Throws IOE on unknown.
-          }
-        } finally {
-          platform.afterHandshake(sslSocket);
-        }
+                    String maybeProtocol;
+                    if (connectionSpec.supportsTlsExtensions()
+                            && (maybeProtocol = platform.getSelectedProtocol(sslSocket)) != null) {
+                        alpnProtocol = Protocol.get(maybeProtocol); // Throws IOE on unknown.
+                    }
+                } finally {
+                    platform.afterHandshake(sslSocket);
+                }
 
-        // Verify that the socket's certificates are acceptable for the target host.
-        if (!address.getHostnameVerifier().verify(address.getUriHost(), sslSocket.getSession())) {
-          X509Certificate cert = (X509Certificate) sslSocket.getSession()
-              .getPeerCertificates()[0];
-          throw new SSLPeerUnverifiedException(
-              "Hostname " + address.getUriHost() + " not verified:"
-              + "\n    certificate: " + CertificatePinner.pin(cert)
-              + "\n    DN: " + cert.getSubjectDN().getName()
-              + "\n    subjectAltNames: " + OkHostnameVerifier.allSubjectAltNames(cert));
-        }
+                // Verify that the socket's certificates are acceptable for the target host.
+                if (!address.getHostnameVerifier().verify(address.getUriHost(), sslSocket.getSession())) {
+                    X509Certificate cert = (X509Certificate) sslSocket.getSession()
+                            .getPeerCertificates()[0];
+                    throw new SSLPeerUnverifiedException(
+                            "Hostname " + address.getUriHost() + " not verified:"
+                                    + "\n    certificate: " + CertificatePinner.pin(cert)
+                                    + "\n    DN: " + cert.getSubjectDN().getName()
+                                    + "\n    subjectAltNames: " + OkHostnameVerifier.allSubjectAltNames(cert));
+                }
 
-        // Check that the certificate pinner is satisfied by the certificates presented.
-        address.getCertificatePinner().check(address.getUriHost(), handshake.peerCertificates());
+                // Check that the certificate pinner is satisfied by the certificates presented.
+                address.getCertificatePinner().check(address.getUriHost(), handshake.peerCertificates());
 
-        return new ConnectedSocket(route, sslSocket, alpnProtocol, handshake);
-      } catch (IOException e) {
-        boolean canRetry = connectionRetryEnabled && connectionSpecSelector.connectionFailed(e);
-        closeQuietly(sslSocket);
-        closeQuietly(socket);
-        if (routeException == null) {
-          routeException = new RouteException(e);
-        } else {
-          routeException.addConnectException(e);
-        }
-        if (!canRetry) {
-          throw routeException;
-        }
-      }
-    } while (true);
-  }
+                return new ConnectedSocket(route, sslSocket, alpnProtocol, handshake);
+            } catch (IOException e) {
+                boolean canRetry = connectionRetryEnabled && connectionSpecSelector.connectionFailed(e);
+                closeQuietly(sslSocket);
+                closeQuietly(socket);
+                if (routeException == null) {
+                    routeException = new RouteException(e);
+                } else {
+                    routeException.addConnectException(e);
+                }
+                if (!canRetry) {
+                    throw routeException;
+                }
+            }
+        } while (true);
+    }
 
-  private Socket connectRawSocket(int soTimeout, int connectTimeout, Route route)
-      throws RouteException {
-    Platform platform = Platform.get();
-    try {
-      Proxy proxy = route.getProxy();
-      Address address = route.getAddress();
-      Socket socket;
-      if (proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP) {
-        socket = address.getSocketFactory().createSocket();
-      } else {
-        socket = new Socket(proxy);
-      }
-      socket.setSoTimeout(soTimeout);
-      platform.connectSocket(socket, route.getSocketAddress(), connectTimeout);
+    private Socket connectRawSocket(int soTimeout, int connectTimeout, Route route)
+            throws RouteException {
+        Platform platform = Platform.get();
+        try {
+            Proxy proxy = route.getProxy();
+            Address address = route.getAddress();
+            Socket socket;
+            if (proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP) {
+                socket = address.getSocketFactory().createSocket();
+            } else {
+                socket = new Socket(proxy);
+            }
+            socket.setSoTimeout(soTimeout);
+            platform.connectSocket(socket, route.getSocketAddress(), connectTimeout);
 
-      return socket;
-    } catch (IOException e) {
-      throw new RouteException(e);
+            return socket;
+        } catch (IOException e) {
+            throw new RouteException(e);
+        }
     }
-  }
 
-  /**
-   * To make an HTTPS connection over an HTTP proxy, send an unencrypted
-   * CONNECT request to create the proxy connection. This may need to be
-   * retried if the proxy requires authorization.
-   */
-  private void createTunnel(int readTimeout, int writeTimeout, Request request, Route route,
-      Socket socket) throws RouteException {
-    // Make an SSL Tunnel on the first message pair of each SSL + proxy connection.
-    try {
-      Request tunnelRequest = createTunnelRequest(request);
-      HttpConnection tunnelConnection = new HttpConnection(connectionPool, connection, socket);
-      tunnelConnection.setTimeouts(readTimeout, writeTimeout);
-      URL url = tunnelRequest.url();
-      String requestLine = "CONNECT " + url.getHost() + ":" + getEffectivePort(url) + " HTTP/1.1";
-      while (true) {
-        tunnelConnection.writeRequest(tunnelRequest.headers(), requestLine);
-        tunnelConnection.flush();
-        Response response = tunnelConnection.readResponse().request(tunnelRequest).build();
-        // The response body from a CONNECT should be empty, but if it is not then we should consume
-        // it before proceeding.
-        long contentLength = OkHeaders.contentLength(response);
-        if (contentLength == -1L) {
-          contentLength = 0L;
-        }
-        Source body = tunnelConnection.newFixedLengthSource(contentLength);
-        Util.skipAll(body, Integer.MAX_VALUE, TimeUnit.MILLISECONDS);
-        body.close();
+    /**
+     * To make an HTTPS connection over an HTTP proxy, send an unencrypted
+     * CONNECT request to create the proxy connection. This may need to be
+     * retried if the proxy requires authorization.
+     */
+    private void createTunnel(int readTimeout, int writeTimeout, Request request, Route route,
+                              Socket socket) throws RouteException {
+        // Make an SSL Tunnel on the first message pair of each SSL + proxy connection.
+        try {
+            Request tunnelRequest = createTunnelRequest(request);
+            HttpConnection tunnelConnection = new HttpConnection(connectionPool, connection, socket);
+            tunnelConnection.setTimeouts(readTimeout, writeTimeout);
+            URL url = tunnelRequest.url();
+            String requestLine = "CONNECT " + url.getHost() + ":" + getEffectivePort(url) + " HTTP/1.1";
+            while (true) {
+                tunnelConnection.writeRequest(tunnelRequest.headers(), requestLine);
+                tunnelConnection.flush();
+                Response response = tunnelConnection.readResponse().request(tunnelRequest).build();
+                // The response body from a CONNECT should be empty, but if it is not then we should consume
+                // it before proceeding.
+                long contentLength = OkHeaders.contentLength(response);
+                if (contentLength == -1L) {
+                    contentLength = 0L;
+                }
+                Source body = tunnelConnection.newFixedLengthSource(contentLength);
+                Util.skipAll(body, Integer.MAX_VALUE, TimeUnit.MILLISECONDS);
+                body.close();
 
-        switch (response.code()) {
-          case HTTP_OK:
-            // Assume the server won't send a TLS ServerHello until we send a TLS ClientHello. If
-            // that happens, then we will have buffered bytes that are needed by the SSLSocket!
-            // This check is imperfect: it doesn't tell us whether a handshake will succeed, just
-            // that it will almost certainly fail because the proxy has sent unexpected data.
-            if (tunnelConnection.bufferSize() > 0) {
-              throw new IOException("TLS tunnel buffered too many bytes!");
-            }
-            return;
+                switch (response.code()) {
+                    case HTTP_OK:
+                        // Assume the server won't send a TLS ServerHello until we send a TLS ClientHello. If
+                        // that happens, then we will have buffered bytes that are needed by the SSLSocket!
+                        // This check is imperfect: it doesn't tell us whether a handshake will succeed, just
+                        // that it will almost certainly fail because the proxy has sent unexpected data.
+                        if (tunnelConnection.bufferSize() > 0) {
+                            throw new IOException("TLS tunnel buffered too many bytes!");
+                        }
+                        return;
 
-          case HTTP_PROXY_AUTH:
-            tunnelRequest = OkHeaders.processAuthHeader(
-                route.getAddress().getAuthenticator(), response, route.getProxy());
-            if (tunnelRequest != null) continue;
-            throw new IOException("Failed to authenticate with proxy");
+                    case HTTP_PROXY_AUTH:
+                        tunnelRequest = OkHeaders.processAuthHeader(
+                                route.getAddress().getAuthenticator(), response, route.getProxy());
+                        if (tunnelRequest != null) continue;
+                        throw new IOException("Failed to authenticate with proxy");
 
-          default:
-            throw new IOException(
-                "Unexpected response code for CONNECT: " + response.code());
+                    default:
+                        throw new IOException(
+                                "Unexpected response code for CONNECT: " + response.code());
+                }
+            }
+        } catch (IOException e) {
+            throw new RouteException(e);
         }
-      }
-    } catch (IOException e) {
-      throw new RouteException(e);
     }
-  }
 
-  /**
-   * Returns a request that creates a TLS tunnel via an HTTP proxy, or null if
-   * no tunnel is necessary. Everything in the tunnel request is sent
-   * unencrypted to the proxy server, so tunnels include only the minimum set of
-   * headers. This avoids sending potentially sensitive data like HTTP cookies
-   * to the proxy unencrypted.
-   */
-  private Request createTunnelRequest(Request request) throws IOException {
-    String host = request.url().getHost();
-    int port = getEffectivePort(request.url());
-    String authority = (port == getDefaultPort("https")) ? host : (host + ":" + port);
-    Request.Builder result = new Request.Builder()
-        .url(new URL("https", host, port, "/"))
-        .header("Host", authority)
-        .header("Proxy-Connection", "Keep-Alive"); // For HTTP/1.0 proxies like Squid.
+    /**
+     * Returns a request that creates a TLS tunnel via an HTTP proxy, or null if
+     * no tunnel is necessary. Everything in the tunnel request is sent
+     * unencrypted to the proxy server, so tunnels include only the minimum set of
+     * headers. This avoids sending potentially sensitive data like HTTP cookies
+     * to the proxy unencrypted.
+     */
+    private Request createTunnelRequest(Request request) throws IOException {
+        String host = request.url().getHost();
+        int port = getEffectivePort(request.url());
+        String authority = (port == getDefaultPort("https")) ? host : (host + ":" + port);
+        Request.Builder result = new Request.Builder()
+                .url(new URL("https", host, port, "/"))
+                .header("Host", authority)
+                .header("Proxy-Connection", "Keep-Alive"); // For HTTP/1.0 proxies like Squid.
 
-    // Copy over the User-Agent header if it exists.
-    String userAgent = request.header("User-Agent");
-    if (userAgent != null) {
-      result.header("User-Agent", userAgent);
-    }
+        // Copy over the User-Agent header if it exists.
+        String userAgent = request.header("User-Agent");
+        if (userAgent != null) {
+            result.header("User-Agent", userAgent);
+        }
 
-    // Copy over the Proxy-Authorization header if it exists.
-    String proxyAuthorization = request.header("Proxy-Authorization");
-    if (proxyAuthorization != null) {
-      result.header("Proxy-Authorization", proxyAuthorization);
-    }
+        // Copy over the Proxy-Authorization header if it exists.
+        String proxyAuthorization = request.header("Proxy-Authorization");
+        if (proxyAuthorization != null) {
+            result.header("Proxy-Authorization", proxyAuthorization);
+        }
 
-    return result.build();
-  }
+        return result.build();
+    }
 
-  /**
-   * A connected socket with metadata.
-   */
-  public static class ConnectedSocket {
-    public final Route route;
-    public final Socket socket;
-    public final Protocol alpnProtocol;
-    public final Handshake handshake;
+    /**
+     * A connected socket with metadata.
+     */
+    public static class ConnectedSocket {
+        public final Route route;
+        public final Socket socket;
+        public final Protocol alpnProtocol;
+        public final Handshake handshake;
 
-    /** A connected plain / raw (i.e. unencrypted communication) socket. */
-    public ConnectedSocket(Route route, Socket socket) {
-      this.route = route;
-      this.socket = socket;
-      alpnProtocol = null;
-      handshake = null;
-    }
+        /**
+         * A connected plain / raw (i.e. unencrypted communication) socket.
+         */
+        public ConnectedSocket(Route route, Socket socket) {
+            this.route = route;
+            this.socket = socket;
+            alpnProtocol = null;
+            handshake = null;
+        }
 
-    /** A connected {@link SSLSocket}. */
-    public ConnectedSocket(Route route, SSLSocket socket, Protocol alpnProtocol,
-        Handshake handshake) {
-      this.route = route;
-      this.socket = socket;
-      this.alpnProtocol = alpnProtocol;
-      this.handshake = handshake;
+        /**
+         * A connected {@link SSLSocket}.
+         */
+        public ConnectedSocket(Route route, SSLSocket socket, Protocol alpnProtocol,
+                               Handshake handshake) {
+            this.route = route;
+            this.socket = socket;
+            this.alpnProtocol = alpnProtocol;
+            this.handshake = handshake;
+        }
     }
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java
index ab9ebc1535..4c196d2686 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java
@@ -2,89 +2,95 @@
 
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Response;
+
 import java.io.IOException;
 import java.net.ProtocolException;
 
-/** An HTTP response status line like "HTTP/1.1 200 OK". */
+/**
+ * An HTTP response status line like "HTTP/1.1 200 OK".
+ */
 public final class StatusLine {
-  /** Numeric status code, 307: Temporary Redirect. */
-  public static final int HTTP_TEMP_REDIRECT = 307;
-  public static final int HTTP_PERM_REDIRECT = 308;
-  public static final int HTTP_CONTINUE = 100;
+    /**
+     * Numeric status code, 307: Temporary Redirect.
+     */
+    public static final int HTTP_TEMP_REDIRECT = 307;
+    public static final int HTTP_PERM_REDIRECT = 308;
+    public static final int HTTP_CONTINUE = 100;
 
-  public final Protocol protocol;
-  public final int code;
-  public final String message;
+    public final Protocol protocol;
+    public final int code;
+    public final String message;
 
-  public StatusLine(Protocol protocol, int code, String message) {
-    this.protocol = protocol;
-    this.code = code;
-    this.message = message;
-  }
+    public StatusLine(Protocol protocol, int code, String message) {
+        this.protocol = protocol;
+        this.code = code;
+        this.message = message;
+    }
 
-  public static StatusLine get(Response response) {
-    return new StatusLine(response.protocol(), response.code(), response.message());
-  }
+    public static StatusLine get(Response response) {
+        return new StatusLine(response.protocol(), response.code(), response.message());
+    }
 
-  public static StatusLine parse(String statusLine) throws IOException {
-    // H T T P / 1 . 1   2 0 0   T e m p o r a r y   R e d i r e c t
-    // 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0
+    public static StatusLine parse(String statusLine) throws IOException {
+        // H T T P / 1 . 1   2 0 0   T e m p o r a r y   R e d i r e c t
+        // 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0
 
-    // Parse protocol like "HTTP/1.1" followed by a space.
-    int codeStart;
-    Protocol protocol;
-    if (statusLine.startsWith("HTTP/1.")) {
-      if (statusLine.length() < 9 || statusLine.charAt(8) != ' ') {
-        throw new ProtocolException("Unexpected status line: " + statusLine);
-      }
-      int httpMinorVersion = statusLine.charAt(7) - '0';
-      codeStart = 9;
-      if (httpMinorVersion == 0) {
-        protocol = Protocol.HTTP_1_0;
-      } else if (httpMinorVersion == 1) {
-        protocol = Protocol.HTTP_1_1;
-      } else {
-        throw new ProtocolException("Unexpected status line: " + statusLine);
-      }
-    } else if (statusLine.startsWith("ICY ")) {
-      // Shoutcast uses ICY instead of "HTTP/1.0".
-      protocol = Protocol.HTTP_1_0;
-      codeStart = 4;
-    } else {
-      throw new ProtocolException("Unexpected status line: " + statusLine);
-    }
+        // Parse protocol like "HTTP/1.1" followed by a space.
+        int codeStart;
+        Protocol protocol;
+        if (statusLine.startsWith("HTTP/1.")) {
+            if (statusLine.length() < 9 || statusLine.charAt(8) != ' ') {
+                throw new ProtocolException("Unexpected status line: " + statusLine);
+            }
+            int httpMinorVersion = statusLine.charAt(7) - '0';
+            codeStart = 9;
+            if (httpMinorVersion == 0) {
+                protocol = Protocol.HTTP_1_0;
+            } else if (httpMinorVersion == 1) {
+                protocol = Protocol.HTTP_1_1;
+            } else {
+                throw new ProtocolException("Unexpected status line: " + statusLine);
+            }
+        } else if (statusLine.startsWith("ICY ")) {
+            // Shoutcast uses ICY instead of "HTTP/1.0".
+            protocol = Protocol.HTTP_1_0;
+            codeStart = 4;
+        } else {
+            throw new ProtocolException("Unexpected status line: " + statusLine);
+        }
 
-    // Parse response code like "200". Always 3 digits.
-    if (statusLine.length() < codeStart + 3) {
-      throw new ProtocolException("Unexpected status line: " + statusLine);
-    }
-    int code;
-    try {
-      code = Integer.parseInt(statusLine.substring(codeStart, codeStart + 3));
-    } catch (NumberFormatException e) {
-      throw new ProtocolException("Unexpected status line: " + statusLine);
-    }
+        // Parse response code like "200". Always 3 digits.
+        if (statusLine.length() < codeStart + 3) {
+            throw new ProtocolException("Unexpected status line: " + statusLine);
+        }
+        int code;
+        try {
+            code = Integer.parseInt(statusLine.substring(codeStart, codeStart + 3));
+        } catch (NumberFormatException e) {
+            throw new ProtocolException("Unexpected status line: " + statusLine);
+        }
 
-    // Parse an optional response message like "OK" or "Not Modified". If it
-    // exists, it is separated from the response code by a space.
-    String message = "";
-    if (statusLine.length() > codeStart + 3) {
-      if (statusLine.charAt(codeStart + 3) != ' ') {
-        throw new ProtocolException("Unexpected status line: " + statusLine);
-      }
-      message = statusLine.substring(codeStart + 4);
-    }
+        // Parse an optional response message like "OK" or "Not Modified". If it
+        // exists, it is separated from the response code by a space.
+        String message = "";
+        if (statusLine.length() > codeStart + 3) {
+            if (statusLine.charAt(codeStart + 3) != ' ') {
+                throw new ProtocolException("Unexpected status line: " + statusLine);
+            }
+            message = statusLine.substring(codeStart + 4);
+        }
 
-    return new StatusLine(protocol, code, message);
-  }
+        return new StatusLine(protocol, code, message);
+    }
 
-  @Override public String toString() {
-    StringBuilder result = new StringBuilder();
-    result.append(protocol == Protocol.HTTP_1_0 ? "HTTP/1.0" : "HTTP/1.1");
-    result.append(' ').append(code);
-    if (message != null) {
-      result.append(' ').append(message);
+    @Override
+    public String toString() {
+        StringBuilder result = new StringBuilder();
+        result.append(protocol == Protocol.HTTP_1_0 ? "HTTP/1.0" : "HTTP/1.1");
+        result.append(' ').append(code);
+        if (message != null) {
+            result.append(' ').append(message);
+        }
+        return result.toString();
     }
-    return result.toString();
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java
index 77f7c9e746..08f44c93a5 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java
@@ -19,49 +19,61 @@
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.ResponseBody;
+
 import java.io.IOException;
+
 import okio.Sink;
 
 public interface Transport {
-  /**
-   * The timeout to use while discarding a stream of input data. Since this is
-   * used for connection reuse, this timeout should be significantly less than
-   * the time it takes to establish a new connection.
-   */
-  int DISCARD_STREAM_TIMEOUT_MILLIS = 100;
+    /**
+     * The timeout to use while discarding a stream of input data. Since this is
+     * used for connection reuse, this timeout should be significantly less than
+     * the time it takes to establish a new connection.
+     */
+    int DISCARD_STREAM_TIMEOUT_MILLIS = 100;
 
-  /** Returns an output stream where the request body can be streamed. */
-  Sink createRequestBody(Request request, long contentLength) throws IOException;
+    /**
+     * Returns an output stream where the request body can be streamed.
+     */
+    Sink createRequestBody(Request request, long contentLength) throws IOException;
 
-  /** This should update the HTTP engine's sentRequestMillis field. */
-  void writeRequestHeaders(Request request) throws IOException;
+    /**
+     * This should update the HTTP engine's sentRequestMillis field.
+     */
+    void writeRequestHeaders(Request request) throws IOException;
 
-  /**
-   * Sends the request body returned by {@link #createRequestBody} to the
-   * remote peer.
-   */
-  void writeRequestBody(RetryableSink requestBody) throws IOException;
+    /**
+     * Sends the request body returned by {@link #createRequestBody} to the
+     * remote peer.
+     */
+    void writeRequestBody(RetryableSink requestBody) throws IOException;
 
-  /** Flush the request to the underlying socket. */
-  void finishRequest() throws IOException;
+    /**
+     * Flush the request to the underlying socket.
+     */
+    void finishRequest() throws IOException;
 
-  /** Read and return response headers. */
-  Response.Builder readResponseHeaders() throws IOException;
+    /**
+     * Read and return response headers.
+     */
+    Response.Builder readResponseHeaders() throws IOException;
 
-  /** Returns a stream that reads the response body. */
-  ResponseBody openResponseBody(Response response) throws IOException;
+    /**
+     * Returns a stream that reads the response body.
+     */
+    ResponseBody openResponseBody(Response response) throws IOException;
 
-  /**
-   * Configures the response body to pool or close the socket connection when
-   * the response body is closed.
-   */
-  void releaseConnectionOnIdle() throws IOException;
+    /**
+     * Configures the response body to pool or close the socket connection when
+     * the response body is closed.
+     */
+    void releaseConnectionOnIdle() throws IOException;
 
-  void disconnect(HttpEngine engine) throws IOException;
+    void disconnect(HttpEngine engine) throws IOException;
 
-  /**
-   * Returns true if the socket connection held by this transport can be reused
-   * for a follow-up exchange.
-   */
-  boolean canReuseConnection();
+    /**
+     * Returns true if the socket connection held by this transport can be reused
+     * for a follow-up exchange.
+     */
+    boolean canReuseConnection();
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/io/FileSystem.java b/okhttp/src/main/java/com/squareup/okhttp/internal/io/FileSystem.java
index 74245997a5..a2c3fc0912 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/io/FileSystem.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/io/FileSystem.java
@@ -18,6 +18,7 @@
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
+
 import okio.Okio;
 import okio.Sink;
 import okio.Source;
@@ -27,111 +28,131 @@
  * #SYSTEM} implementation, which uses the host machine's local file system. Alternate
  * implementations may be used to inject faults (for testing) or to transform stored data (to add
  * encryption, for example).
- *
+ * <p/>
  * <p>All operations on a file system are racy. For example, guarding a call to {@link #source}
  * with {@link #exists} does not guarantee that {@link FileNotFoundException} will not be thrown.
  * The file may be moved between the two calls!
- *
+ * <p/>
  * <p>This interface is less ambitious than {@link java.nio.file.FileSystem} introduced in Java 7.
  * It lacks important features like file watching, metadata, permissions, and disk space
  * information. In exchange for these limitations, this interface is easier to implement and works
  * on all versions of Java and Android.
  */
 public interface FileSystem {
-  /** The host machine's local file system. */
-  FileSystem SYSTEM = new FileSystem() {
-    @Override public Source source(File file) throws FileNotFoundException {
-      return Okio.source(file);
-    }
-
-    @Override public Sink sink(File file) throws FileNotFoundException {
-      try {
-        return Okio.sink(file);
-      } catch (FileNotFoundException e) {
-        // Maybe the parent directory doesn't exist? Try creating it first.
-        file.getParentFile().mkdirs();
-        return Okio.sink(file);
-      }
-    }
-
-    @Override public Sink appendingSink(File file) throws FileNotFoundException {
-      try {
-        return Okio.appendingSink(file);
-      } catch (FileNotFoundException e) {
-        // Maybe the parent directory doesn't exist? Try creating it first.
-        file.getParentFile().mkdirs();
-        return Okio.appendingSink(file);
-      }
-    }
-
-    @Override public void delete(File file) throws IOException {
-      // If delete() fails, make sure it's because the file didn't exist!
-      if (!file.delete() && file.exists()) {
-        throw new IOException("failed to delete " + file);
-      }
-    }
-
-    @Override public boolean exists(File file) throws IOException {
-      return file.exists();
-    }
-
-    @Override public long size(File file) {
-      return file.length();
-    }
-
-    @Override public void rename(File from, File to) throws IOException {
-      delete(to);
-      if (!from.renameTo(to)) {
-        throw new IOException("failed to rename " + from + " to " + to);
-      }
-    }
-
-    @Override public void deleteContents(File directory) throws IOException {
-      File[] files = directory.listFiles();
-      if (files == null) {
-        throw new IOException("not a readable directory: " + directory);
-      }
-      for (File file : files) {
-        if (file.isDirectory()) {
-          deleteContents(file);
+    /**
+     * The host machine's local file system.
+     */
+    FileSystem SYSTEM = new FileSystem() {
+        @Override
+        public Source source(File file) throws FileNotFoundException {
+            return Okio.source(file);
+        }
+
+        @Override
+        public Sink sink(File file) throws FileNotFoundException {
+            try {
+                return Okio.sink(file);
+            } catch (FileNotFoundException e) {
+                // Maybe the parent directory doesn't exist? Try creating it first.
+                file.getParentFile().mkdirs();
+                return Okio.sink(file);
+            }
+        }
+
+        @Override
+        public Sink appendingSink(File file) throws FileNotFoundException {
+            try {
+                return Okio.appendingSink(file);
+            } catch (FileNotFoundException e) {
+                // Maybe the parent directory doesn't exist? Try creating it first.
+                file.getParentFile().mkdirs();
+                return Okio.appendingSink(file);
+            }
+        }
+
+        @Override
+        public void delete(File file) throws IOException {
+            // If delete() fails, make sure it's because the file didn't exist!
+            if (!file.delete() && file.exists()) {
+                throw new IOException("failed to delete " + file);
+            }
+        }
+
+        @Override
+        public boolean exists(File file) throws IOException {
+            return file.exists();
+        }
+
+        @Override
+        public long size(File file) {
+            return file.length();
+        }
+
+        @Override
+        public void rename(File from, File to) throws IOException {
+            delete(to);
+            if (!from.renameTo(to)) {
+                throw new IOException("failed to rename " + from + " to " + to);
+            }
         }
-        if (!file.delete()) {
-          throw new IOException("failed to delete " + file);
+
+        @Override
+        public void deleteContents(File directory) throws IOException {
+            File[] files = directory.listFiles();
+            if (files == null) {
+                throw new IOException("not a readable directory: " + directory);
+            }
+            for (File file : files) {
+                if (file.isDirectory()) {
+                    deleteContents(file);
+                }
+                if (!file.delete()) {
+                    throw new IOException("failed to delete " + file);
+                }
+            }
         }
-      }
-    }
-  };
-
-  /** Reads from {@code file}. */
-  Source source(File file) throws FileNotFoundException;
-
-  /**
-   * Writes to {@code file}, discarding any data already present. Creates parent directories if
-   * necessary.
-   */
-  Sink sink(File file) throws FileNotFoundException;
-
-  /**
-   * Writes to {@code file}, appending if data is already present. Creates parent directories if
-   * necessary.
-   */
-  Sink appendingSink(File file) throws FileNotFoundException;
-
-  /** Deletes {@code file} if it exists. Throws if the file exists and cannot be deleted. */
-  void delete(File file) throws IOException;
-
-  /** Returns true if {@code file} exists on the file system. */
-  boolean exists(File file) throws IOException;
-
-  /** Returns the number of bytes stored in {@code file}, or 0 if it does not exist. */
-  long size(File file);
-
-  /** Renames {@code from} to {@code to}. Throws if the file cannot be renamed. */
-  void rename(File from, File to) throws IOException;
-
-  /**
-   * Recursively delete the contents of {@code directory}. Throws an IOException if any file could
-   * not be deleted, or if {@code dir} is not a readable directory.
-   */
-  void deleteContents(File directory) throws IOException;
+    };
+
+    /**
+     * Reads from {@code file}.
+     */
+    Source source(File file) throws FileNotFoundException;
+
+    /**
+     * Writes to {@code file}, discarding any data already present. Creates parent directories if
+     * necessary.
+     */
+    Sink sink(File file) throws FileNotFoundException;
+
+    /**
+     * Writes to {@code file}, appending if data is already present. Creates parent directories if
+     * necessary.
+     */
+    Sink appendingSink(File file) throws FileNotFoundException;
+
+    /**
+     * Deletes {@code file} if it exists. Throws if the file exists and cannot be deleted.
+     */
+    void delete(File file) throws IOException;
+
+    /**
+     * Returns true if {@code file} exists on the file system.
+     */
+    boolean exists(File file) throws IOException;
+
+    /**
+     * Returns the number of bytes stored in {@code file}, or 0 if it does not exist.
+     */
+    long size(File file);
+
+    /**
+     * Renames {@code from} to {@code to}. Throws if the file cannot be renamed.
+     */
+    void rename(File from, File to) throws IOException;
+
+    /**
+     * Recursively delete the contents of {@code directory}. Throws an IOException if any file could
+     * not be deleted, or if {@code dir} is not a readable directory.
+     */
+    void deleteContents(File directory) throws IOException;
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/tls/DistinguishedNameParser.java b/okhttp/src/main/java/com/squareup/okhttp/internal/tls/DistinguishedNameParser.java
index e0aef14916..9c8f4e90a5 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/tls/DistinguishedNameParser.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/tls/DistinguishedNameParser.java
@@ -24,384 +24,388 @@
  * string value from a DN. It doesn't support values in the hex-string style.
  */
 final class DistinguishedNameParser {
-  private final String dn;
-  private final int length;
-  private int pos;
-  private int beg;
-  private int end;
-
-  /** Temporary variable to store positions of the currently parsed item. */
-  private int cur;
-
-  /** Distinguished name characters. */
-  private char[] chars;
-
-  public DistinguishedNameParser(X500Principal principal) {
-    // RFC2253 is used to ensure we get attributes in the reverse
-    // order of the underlying ASN.1 encoding, so that the most
-    // significant values of repeated attributes occur first.
-    this.dn = principal.getName(X500Principal.RFC2253);
-    this.length = this.dn.length();
-  }
-
-  // gets next attribute type: (ALPHA 1*keychar) / oid
-  private String nextAT() {
-    // skip preceding space chars, they can present after
-    // comma or semicolon (compatibility with RFC 1779)
-    for (; pos < length && chars[pos] == ' '; pos++) {
-    }
-    if (pos == length) {
-      return null; // reached the end of DN
-    }
-
-    // mark the beginning of attribute type
-    beg = pos;
-
-    // attribute type chars
-    pos++;
-    for (; pos < length && chars[pos] != '=' && chars[pos] != ' '; pos++) {
-      // we don't follow exact BNF syntax here:
-      // accept any char except space and '='
-    }
-    if (pos >= length) {
-      throw new IllegalStateException("Unexpected end of DN: " + dn);
-    }
-
-    // mark the end of attribute type
-    end = pos;
-
-    // skip trailing space chars between attribute type and '='
-    // (compatibility with RFC 1779)
-    if (chars[pos] == ' ') {
-      for (; pos < length && chars[pos] != '=' && chars[pos] == ' '; pos++) {
-      }
-
-      if (chars[pos] != '=' || pos == length) {
-        throw new IllegalStateException("Unexpected end of DN: " + dn);
-      }
+    private final String dn;
+    private final int length;
+    private int pos;
+    private int beg;
+    private int end;
+
+    /**
+     * Temporary variable to store positions of the currently parsed item.
+     */
+    private int cur;
+
+    /**
+     * Distinguished name characters.
+     */
+    private char[] chars;
+
+    public DistinguishedNameParser(X500Principal principal) {
+        // RFC2253 is used to ensure we get attributes in the reverse
+        // order of the underlying ASN.1 encoding, so that the most
+        // significant values of repeated attributes occur first.
+        this.dn = principal.getName(X500Principal.RFC2253);
+        this.length = this.dn.length();
     }
 
-    pos++; //skip '=' char
+    // gets next attribute type: (ALPHA 1*keychar) / oid
+    private String nextAT() {
+        // skip preceding space chars, they can present after
+        // comma or semicolon (compatibility with RFC 1779)
+        for (; pos < length && chars[pos] == ' '; pos++) {
+        }
+        if (pos == length) {
+            return null; // reached the end of DN
+        }
 
-    // skip space chars between '=' and attribute value
-    // (compatibility with RFC 1779)
-    for (; pos < length && chars[pos] == ' '; pos++) {
-    }
+        // mark the beginning of attribute type
+        beg = pos;
 
-    // in case of oid attribute type skip its prefix: "oid." or "OID."
-    // (compatibility with RFC 1779)
-    if ((end - beg > 4) && (chars[beg + 3] == '.')
-        && (chars[beg] == 'O' || chars[beg] == 'o')
-        && (chars[beg + 1] == 'I' || chars[beg + 1] == 'i')
-        && (chars[beg + 2] == 'D' || chars[beg + 2] == 'd')) {
-      beg += 4;
-    }
+        // attribute type chars
+        pos++;
+        for (; pos < length && chars[pos] != '=' && chars[pos] != ' '; pos++) {
+            // we don't follow exact BNF syntax here:
+            // accept any char except space and '='
+        }
+        if (pos >= length) {
+            throw new IllegalStateException("Unexpected end of DN: " + dn);
+        }
 
-    return new String(chars, beg, end - beg);
-  }
+        // mark the end of attribute type
+        end = pos;
 
-  // gets quoted attribute value: QUOTATION *( quotechar / pair ) QUOTATION
-  private String quotedAV() {
-    pos++;
-    beg = pos;
-    end = beg;
-    while (true) {
+        // skip trailing space chars between attribute type and '='
+        // (compatibility with RFC 1779)
+        if (chars[pos] == ' ') {
+            for (; pos < length && chars[pos] != '=' && chars[pos] == ' '; pos++) {
+            }
 
-      if (pos == length) {
-        throw new IllegalStateException("Unexpected end of DN: " + dn);
-      }
+            if (chars[pos] != '=' || pos == length) {
+                throw new IllegalStateException("Unexpected end of DN: " + dn);
+            }
+        }
 
-      if (chars[pos] == '"') {
-        // enclosing quotation was found
-        pos++;
-        break;
-      } else if (chars[pos] == '\\') {
-        chars[end] = getEscaped();
-      } else {
-        // shift char: required for string with escaped chars
-        chars[end] = chars[pos];
-      }
-      pos++;
-      end++;
-    }
+        pos++; //skip '=' char
 
-    // skip trailing space chars before comma or semicolon.
-    // (compatibility with RFC 1779)
-    for (; pos < length && chars[pos] == ' '; pos++) {
-    }
+        // skip space chars between '=' and attribute value
+        // (compatibility with RFC 1779)
+        for (; pos < length && chars[pos] == ' '; pos++) {
+        }
 
-    return new String(chars, beg, end - beg);
-  }
+        // in case of oid attribute type skip its prefix: "oid." or "OID."
+        // (compatibility with RFC 1779)
+        if ((end - beg > 4) && (chars[beg + 3] == '.')
+                && (chars[beg] == 'O' || chars[beg] == 'o')
+                && (chars[beg + 1] == 'I' || chars[beg + 1] == 'i')
+                && (chars[beg + 2] == 'D' || chars[beg + 2] == 'd')) {
+            beg += 4;
+        }
 
-  // gets hex string attribute value: "#" hexstring
-  private String hexAV() {
-    if (pos + 4 >= length) {
-      // encoded byte array  must be not less then 4 c
-      throw new IllegalStateException("Unexpected end of DN: " + dn);
+        return new String(chars, beg, end - beg);
     }
 
-    beg = pos; // store '#' position
-    pos++;
-    while (true) {
-
-      // check for end of attribute value
-      // looks for space and component separators
-      if (pos == length || chars[pos] == '+' || chars[pos] == ','
-          || chars[pos] == ';') {
-        end = pos;
-        break;
-      }
-
-      if (chars[pos] == ' ') {
-        end = pos;
+    // gets quoted attribute value: QUOTATION *( quotechar / pair ) QUOTATION
+    private String quotedAV() {
         pos++;
+        beg = pos;
+        end = beg;
+        while (true) {
+
+            if (pos == length) {
+                throw new IllegalStateException("Unexpected end of DN: " + dn);
+            }
+
+            if (chars[pos] == '"') {
+                // enclosing quotation was found
+                pos++;
+                break;
+            } else if (chars[pos] == '\\') {
+                chars[end] = getEscaped();
+            } else {
+                // shift char: required for string with escaped chars
+                chars[end] = chars[pos];
+            }
+            pos++;
+            end++;
+        }
+
         // skip trailing space chars before comma or semicolon.
         // (compatibility with RFC 1779)
         for (; pos < length && chars[pos] == ' '; pos++) {
         }
-        break;
-      } else if (chars[pos] >= 'A' && chars[pos] <= 'F') {
-        chars[pos] += 32; //to low case
-      }
 
-      pos++;
+        return new String(chars, beg, end - beg);
     }
 
-    // verify length of hex string
-    // encoded byte array  must be not less then 4 and must be even number
-    int hexLen = end - beg; // skip first '#' char
-    if (hexLen < 5 || (hexLen & 1) == 0) {
-      throw new IllegalStateException("Unexpected end of DN: " + dn);
-    }
+    // gets hex string attribute value: "#" hexstring
+    private String hexAV() {
+        if (pos + 4 >= length) {
+            // encoded byte array  must be not less then 4 c
+            throw new IllegalStateException("Unexpected end of DN: " + dn);
+        }
 
-    // get byte encoding from string representation
-    byte[] encoded = new byte[hexLen / 2];
-    for (int i = 0, p = beg + 1; i < encoded.length; p += 2, i++) {
-      encoded[i] = (byte) getByte(p);
-    }
+        beg = pos; // store '#' position
+        pos++;
+        while (true) {
+
+            // check for end of attribute value
+            // looks for space and component separators
+            if (pos == length || chars[pos] == '+' || chars[pos] == ','
+                    || chars[pos] == ';') {
+                end = pos;
+                break;
+            }
+
+            if (chars[pos] == ' ') {
+                end = pos;
+                pos++;
+                // skip trailing space chars before comma or semicolon.
+                // (compatibility with RFC 1779)
+                for (; pos < length && chars[pos] == ' '; pos++) {
+                }
+                break;
+            } else if (chars[pos] >= 'A' && chars[pos] <= 'F') {
+                chars[pos] += 32; //to low case
+            }
+
+            pos++;
+        }
 
-    return new String(chars, beg, hexLen);
-  }
+        // verify length of hex string
+        // encoded byte array  must be not less then 4 and must be even number
+        int hexLen = end - beg; // skip first '#' char
+        if (hexLen < 5 || (hexLen & 1) == 0) {
+            throw new IllegalStateException("Unexpected end of DN: " + dn);
+        }
 
-  // gets string attribute value: *( stringchar / pair )
-  private String escapedAV() {
-    beg = pos;
-    end = pos;
-    while (true) {
-      if (pos >= length) {
-        // the end of DN has been found
-        return new String(chars, beg, end - beg);
-      }
-
-      switch (chars[pos]) {
-        case '+':
-        case ',':
-        case ';':
-          // separator char has been found
-          return new String(chars, beg, end - beg);
-        case '\\':
-          // escaped char
-          chars[end++] = getEscaped();
-          pos++;
-          break;
-        case ' ':
-          // need to figure out whether space defines
-          // the end of attribute value or not
-          cur = end;
-
-          pos++;
-          chars[end++] = ' ';
-
-          for (; pos < length && chars[pos] == ' '; pos++) {
-            chars[end++] = ' ';
-          }
-          if (pos == length || chars[pos] == ',' || chars[pos] == '+'
-              || chars[pos] == ';') {
-            // separator char or the end of DN has been found
-            return new String(chars, beg, cur - beg);
-          }
-          break;
-        default:
-          chars[end++] = chars[pos];
-          pos++;
-      }
-    }
-  }
+        // get byte encoding from string representation
+        byte[] encoded = new byte[hexLen / 2];
+        for (int i = 0, p = beg + 1; i < encoded.length; p += 2, i++) {
+            encoded[i] = (byte) getByte(p);
+        }
 
-  // returns escaped char
-  private char getEscaped() {
-    pos++;
-    if (pos == length) {
-      throw new IllegalStateException("Unexpected end of DN: " + dn);
+        return new String(chars, beg, hexLen);
     }
 
-    switch (chars[pos]) {
-      case '"':
-      case '\\':
-      case ',':
-      case '=':
-      case '+':
-      case '<':
-      case '>':
-      case '#':
-      case ';':
-      case ' ':
-      case '*':
-      case '%':
-      case '_':
-        //FIXME: escaping is allowed only for leading or trailing space char
-        return chars[pos];
-      default:
-        // RFC doesn't explicitly say that escaped hex pair is
-        // interpreted as UTF-8 char. It only contains an example of such DN.
-        return getUTF8();
+    // gets string attribute value: *( stringchar / pair )
+    private String escapedAV() {
+        beg = pos;
+        end = pos;
+        while (true) {
+            if (pos >= length) {
+                // the end of DN has been found
+                return new String(chars, beg, end - beg);
+            }
+
+            switch (chars[pos]) {
+                case '+':
+                case ',':
+                case ';':
+                    // separator char has been found
+                    return new String(chars, beg, end - beg);
+                case '\\':
+                    // escaped char
+                    chars[end++] = getEscaped();
+                    pos++;
+                    break;
+                case ' ':
+                    // need to figure out whether space defines
+                    // the end of attribute value or not
+                    cur = end;
+
+                    pos++;
+                    chars[end++] = ' ';
+
+                    for (; pos < length && chars[pos] == ' '; pos++) {
+                        chars[end++] = ' ';
+                    }
+                    if (pos == length || chars[pos] == ',' || chars[pos] == '+'
+                            || chars[pos] == ';') {
+                        // separator char or the end of DN has been found
+                        return new String(chars, beg, cur - beg);
+                    }
+                    break;
+                default:
+                    chars[end++] = chars[pos];
+                    pos++;
+            }
+        }
     }
-  }
-
-  // decodes UTF-8 char
-  // see http://www.unicode.org for UTF-8 bit distribution table
-  private char getUTF8() {
-    int res = getByte(pos);
-    pos++; //FIXME tmp
-
-    if (res < 128) { // one byte: 0-7F
-      return (char) res;
-    } else if (res >= 192 && res <= 247) {
-
-      int count;
-      if (res <= 223) { // two bytes: C0-DF
-        count = 1;
-        res = res & 0x1F;
-      } else if (res <= 239) { // three bytes: E0-EF
-        count = 2;
-        res = res & 0x0F;
-      } else { // four bytes: F0-F7
-        count = 3;
-        res = res & 0x07;
-      }
-
-      int b;
-      for (int i = 0; i < count; i++) {
+
+    // returns escaped char
+    private char getEscaped() {
         pos++;
-        if (pos == length || chars[pos] != '\\') {
-          return 0x3F; //FIXME failed to decode UTF-8 char - return '?'
+        if (pos == length) {
+            throw new IllegalStateException("Unexpected end of DN: " + dn);
         }
-        pos++;
 
-        b = getByte(pos);
-        pos++; //FIXME tmp
-        if ((b & 0xC0) != 0x80) {
-          return 0x3F; //FIXME failed to decode UTF-8 char - return '?'
+        switch (chars[pos]) {
+            case '"':
+            case '\\':
+            case ',':
+            case '=':
+            case '+':
+            case '<':
+            case '>':
+            case '#':
+            case ';':
+            case ' ':
+            case '*':
+            case '%':
+            case '_':
+                //FIXME: escaping is allowed only for leading or trailing space char
+                return chars[pos];
+            default:
+                // RFC doesn't explicitly say that escaped hex pair is
+                // interpreted as UTF-8 char. It only contains an example of such DN.
+                return getUTF8();
         }
-
-        res = (res << 6) + (b & 0x3F);
-      }
-      return (char) res;
-    } else {
-      return 0x3F; //FIXME failed to decode UTF-8 char - return '?'
-    }
-  }
-
-  // Returns byte representation of a char pair
-  // The char pair is composed of DN char in
-  // specified 'position' and the next char
-  // According to BNF syntax:
-  // hexchar    = DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
-  //                    / "a" / "b" / "c" / "d" / "e" / "f"
-  private int getByte(int position) {
-    if (position + 1 >= length) {
-      throw new IllegalStateException("Malformed DN: " + dn);
     }
 
-    int b1, b2;
-
-    b1 = chars[position];
-    if (b1 >= '0' && b1 <= '9') {
-      b1 = b1 - '0';
-    } else if (b1 >= 'a' && b1 <= 'f') {
-      b1 = b1 - 87; // 87 = 'a' - 10
-    } else if (b1 >= 'A' && b1 <= 'F') {
-      b1 = b1 - 55; // 55 = 'A' - 10
-    } else {
-      throw new IllegalStateException("Malformed DN: " + dn);
-    }
+    // decodes UTF-8 char
+    // see http://www.unicode.org for UTF-8 bit distribution table
+    private char getUTF8() {
+        int res = getByte(pos);
+        pos++; //FIXME tmp
 
-    b2 = chars[position + 1];
-    if (b2 >= '0' && b2 <= '9') {
-      b2 = b2 - '0';
-    } else if (b2 >= 'a' && b2 <= 'f') {
-      b2 = b2 - 87; // 87 = 'a' - 10
-    } else if (b2 >= 'A' && b2 <= 'F') {
-      b2 = b2 - 55; // 55 = 'A' - 10
-    } else {
-      throw new IllegalStateException("Malformed DN: " + dn);
+        if (res < 128) { // one byte: 0-7F
+            return (char) res;
+        } else if (res >= 192 && res <= 247) {
+
+            int count;
+            if (res <= 223) { // two bytes: C0-DF
+                count = 1;
+                res = res & 0x1F;
+            } else if (res <= 239) { // three bytes: E0-EF
+                count = 2;
+                res = res & 0x0F;
+            } else { // four bytes: F0-F7
+                count = 3;
+                res = res & 0x07;
+            }
+
+            int b;
+            for (int i = 0; i < count; i++) {
+                pos++;
+                if (pos == length || chars[pos] != '\\') {
+                    return 0x3F; //FIXME failed to decode UTF-8 char - return '?'
+                }
+                pos++;
+
+                b = getByte(pos);
+                pos++; //FIXME tmp
+                if ((b & 0xC0) != 0x80) {
+                    return 0x3F; //FIXME failed to decode UTF-8 char - return '?'
+                }
+
+                res = (res << 6) + (b & 0x3F);
+            }
+            return (char) res;
+        } else {
+            return 0x3F; //FIXME failed to decode UTF-8 char - return '?'
+        }
     }
 
-    return (b1 << 4) + b2;
-  }
-
-  /**
-   * Parses the DN and returns the most significant attribute value
-   * for an attribute type, or null if none found.
-   *
-   * @param attributeType attribute type to look for (e.g. "ca")
-   */
-  public String findMostSpecific(String attributeType) {
-    // Initialize internal state.
-    pos = 0;
-    beg = 0;
-    end = 0;
-    cur = 0;
-    chars = dn.toCharArray();
-
-    String attType = nextAT();
-    if (attType == null) {
-      return null;
+    // Returns byte representation of a char pair
+    // The char pair is composed of DN char in
+    // specified 'position' and the next char
+    // According to BNF syntax:
+    // hexchar    = DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
+    //                    / "a" / "b" / "c" / "d" / "e" / "f"
+    private int getByte(int position) {
+        if (position + 1 >= length) {
+            throw new IllegalStateException("Malformed DN: " + dn);
+        }
+
+        int b1, b2;
+
+        b1 = chars[position];
+        if (b1 >= '0' && b1 <= '9') {
+            b1 = b1 - '0';
+        } else if (b1 >= 'a' && b1 <= 'f') {
+            b1 = b1 - 87; // 87 = 'a' - 10
+        } else if (b1 >= 'A' && b1 <= 'F') {
+            b1 = b1 - 55; // 55 = 'A' - 10
+        } else {
+            throw new IllegalStateException("Malformed DN: " + dn);
+        }
+
+        b2 = chars[position + 1];
+        if (b2 >= '0' && b2 <= '9') {
+            b2 = b2 - '0';
+        } else if (b2 >= 'a' && b2 <= 'f') {
+            b2 = b2 - 87; // 87 = 'a' - 10
+        } else if (b2 >= 'A' && b2 <= 'F') {
+            b2 = b2 - 55; // 55 = 'A' - 10
+        } else {
+            throw new IllegalStateException("Malformed DN: " + dn);
+        }
+
+        return (b1 << 4) + b2;
     }
-    while (true) {
-      String attValue = "";
-
-      if (pos == length) {
-        return null;
-      }
-
-      switch (chars[pos]) {
-        case '"':
-          attValue = quotedAV();
-          break;
-        case '#':
-          attValue = hexAV();
-          break;
-        case '+':
-        case ',':
-        case ';': // compatibility with RFC 1779: semicolon can separate RDNs
-          //empty attribute value
-          break;
-        default:
-          attValue = escapedAV();
-      }
-
-      // Values are ordered from most specific to least specific
-      // due to the RFC2253 formatting. So take the first match
-      // we see.
-      if (attributeType.equalsIgnoreCase(attType)) {
-        return attValue;
-      }
-
-      if (pos >= length) {
-        return null;
-      }
-
-      if (chars[pos] == ',' || chars[pos] == ';') {
-      } else if (chars[pos] != '+') {
-        throw new IllegalStateException("Malformed DN: " + dn);
-      }
-
-      pos++;
-      attType = nextAT();
-      if (attType == null) {
-        throw new IllegalStateException("Malformed DN: " + dn);
-      }
+
+    /**
+     * Parses the DN and returns the most significant attribute value
+     * for an attribute type, or null if none found.
+     *
+     * @param attributeType attribute type to look for (e.g. "ca")
+     */
+    public String findMostSpecific(String attributeType) {
+        // Initialize internal state.
+        pos = 0;
+        beg = 0;
+        end = 0;
+        cur = 0;
+        chars = dn.toCharArray();
+
+        String attType = nextAT();
+        if (attType == null) {
+            return null;
+        }
+        while (true) {
+            String attValue = "";
+
+            if (pos == length) {
+                return null;
+            }
+
+            switch (chars[pos]) {
+                case '"':
+                    attValue = quotedAV();
+                    break;
+                case '#':
+                    attValue = hexAV();
+                    break;
+                case '+':
+                case ',':
+                case ';': // compatibility with RFC 1779: semicolon can separate RDNs
+                    //empty attribute value
+                    break;
+                default:
+                    attValue = escapedAV();
+            }
+
+            // Values are ordered from most specific to least specific
+            // due to the RFC2253 formatting. So take the first match
+            // we see.
+            if (attributeType.equalsIgnoreCase(attType)) {
+                return attValue;
+            }
+
+            if (pos >= length) {
+                return null;
+            }
+
+            if (chars[pos] == ',' || chars[pos] == ';') {
+            } else if (chars[pos] != '+') {
+                throw new IllegalStateException("Malformed DN: " + dn);
+            }
+
+            pos++;
+            attType = nextAT();
+            if (attType == null) {
+                throw new IllegalStateException("Malformed DN: " + dn);
+            }
+        }
     }
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/tls/OkHostnameVerifier.java b/okhttp/src/main/java/com/squareup/okhttp/internal/tls/OkHostnameVerifier.java
index 740de1bcdf..fa1243225b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/tls/OkHostnameVerifier.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/tls/OkHostnameVerifier.java
@@ -26,6 +26,7 @@
 import java.util.List;
 import java.util.Locale;
 import java.util.regex.Pattern;
+
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLException;
 import javax.net.ssl.SSLSession;
@@ -36,217 +37,217 @@
  * href="http://www.ietf.org/rfc/rfc2818.txt">RFC 2818</a>.
  */
 public final class OkHostnameVerifier implements HostnameVerifier {
-  public static final OkHostnameVerifier INSTANCE = new OkHostnameVerifier();
-
-  /**
-   * Quick and dirty pattern to differentiate IP addresses from hostnames. This
-   * is an approximation of Android's private InetAddress#isNumeric API.
-   *
-   * <p>This matches IPv6 addresses as a hex string containing at least one
-   * colon, and possibly including dots after the first colon. It matches IPv4
-   * addresses as strings containing only decimal digits and dots. This pattern
-   * matches strings like "a:.23" and "54" that are neither IP addresses nor
-   * hostnames; they will be verified as IP addresses (which is a more strict
-   * verification).
-   */
-  private static final Pattern VERIFY_AS_IP_ADDRESS = Pattern.compile(
-      "([0-9a-fA-F]*:[0-9a-fA-F:.]*)|([\\d.]+)");
-
-  private static final int ALT_DNS_NAME = 2;
-  private static final int ALT_IPA_NAME = 7;
-
-  private OkHostnameVerifier() {
-  }
-
-  @Override
-  public boolean verify(String host, SSLSession session) {
-    try {
-      Certificate[] certificates = session.getPeerCertificates();
-      return verify(host, (X509Certificate) certificates[0]);
-    } catch (SSLException e) {
-      return false;
+    public static final OkHostnameVerifier INSTANCE = new OkHostnameVerifier();
+
+    /**
+     * Quick and dirty pattern to differentiate IP addresses from hostnames. This
+     * is an approximation of Android's private InetAddress#isNumeric API.
+     * <p/>
+     * <p>This matches IPv6 addresses as a hex string containing at least one
+     * colon, and possibly including dots after the first colon. It matches IPv4
+     * addresses as strings containing only decimal digits and dots. This pattern
+     * matches strings like "a:.23" and "54" that are neither IP addresses nor
+     * hostnames; they will be verified as IP addresses (which is a more strict
+     * verification).
+     */
+    private static final Pattern VERIFY_AS_IP_ADDRESS = Pattern.compile(
+            "([0-9a-fA-F]*:[0-9a-fA-F:.]*)|([\\d.]+)");
+
+    private static final int ALT_DNS_NAME = 2;
+    private static final int ALT_IPA_NAME = 7;
+
+    private OkHostnameVerifier() {
     }
-  }
-
-  public boolean verify(String host, X509Certificate certificate) {
-    return verifyAsIpAddress(host)
-        ? verifyIpAddress(host, certificate)
-        : verifyHostName(host, certificate);
-  }
-
-  static boolean verifyAsIpAddress(String host) {
-    return VERIFY_AS_IP_ADDRESS.matcher(host).matches();
-  }
-
-  /**
-   * Returns true if {@code certificate} matches {@code ipAddress}.
-   */
-  private boolean verifyIpAddress(String ipAddress, X509Certificate certificate) {
-    List<String> altNames = getSubjectAltNames(certificate, ALT_IPA_NAME);
-    for (int i = 0, size = altNames.size(); i < size; i++) {
-      if (ipAddress.equalsIgnoreCase(altNames.get(i))) {
-        return true;
-      }
+
+    @Override
+    public boolean verify(String host, SSLSession session) {
+        try {
+            Certificate[] certificates = session.getPeerCertificates();
+            return verify(host, (X509Certificate) certificates[0]);
+        } catch (SSLException e) {
+            return false;
+        }
     }
-    return false;
-  }
-
-  /**
-   * Returns true if {@code certificate} matches {@code hostName}.
-   */
-  private boolean verifyHostName(String hostName, X509Certificate certificate) {
-    hostName = hostName.toLowerCase(Locale.US);
-    boolean hasDns = false;
-    List<String> altNames = getSubjectAltNames(certificate, ALT_DNS_NAME);
-    for (int i = 0, size = altNames.size(); i < size; i++) {
-      hasDns = true;
-      if (verifyHostName(hostName, altNames.get(i))) {
-        return true;
-      }
+
+    public boolean verify(String host, X509Certificate certificate) {
+        return verifyAsIpAddress(host)
+                ? verifyIpAddress(host, certificate)
+                : verifyHostName(host, certificate);
     }
 
-    if (!hasDns) {
-      X500Principal principal = certificate.getSubjectX500Principal();
-      // RFC 2818 advises using the most specific name for matching.
-      String cn = new DistinguishedNameParser(principal).findMostSpecific("cn");
-      if (cn != null) {
-        return verifyHostName(hostName, cn);
-      }
+    static boolean verifyAsIpAddress(String host) {
+        return VERIFY_AS_IP_ADDRESS.matcher(host).matches();
     }
 
-    return false;
-  }
-
-  public static List<String> allSubjectAltNames(X509Certificate certificate) {
-    List<String> altIpaNames = getSubjectAltNames(certificate, ALT_IPA_NAME);
-    List<String> altDnsNames = getSubjectAltNames(certificate, ALT_DNS_NAME);
-    List<String> result = new ArrayList<>(altIpaNames.size() + altDnsNames.size());
-    result.addAll(altIpaNames);
-    result.addAll(altDnsNames);
-    return result;
-  }
-
-  private static List<String> getSubjectAltNames(X509Certificate certificate, int type) {
-    List<String> result = new ArrayList<>();
-    try {
-      Collection<?> subjectAltNames = certificate.getSubjectAlternativeNames();
-      if (subjectAltNames == null) {
-        return Collections.emptyList();
-      }
-      for (Object subjectAltName : subjectAltNames) {
-        List<?> entry = (List<?>) subjectAltName;
-        if (entry == null || entry.size() < 2) {
-          continue;
+    /**
+     * Returns true if {@code certificate} matches {@code ipAddress}.
+     */
+    private boolean verifyIpAddress(String ipAddress, X509Certificate certificate) {
+        List<String> altNames = getSubjectAltNames(certificate, ALT_IPA_NAME);
+        for (int i = 0, size = altNames.size(); i < size; i++) {
+            if (ipAddress.equalsIgnoreCase(altNames.get(i))) {
+                return true;
+            }
         }
-        Integer altNameType = (Integer) entry.get(0);
-        if (altNameType == null) {
-          continue;
+        return false;
+    }
+
+    /**
+     * Returns true if {@code certificate} matches {@code hostName}.
+     */
+    private boolean verifyHostName(String hostName, X509Certificate certificate) {
+        hostName = hostName.toLowerCase(Locale.US);
+        boolean hasDns = false;
+        List<String> altNames = getSubjectAltNames(certificate, ALT_DNS_NAME);
+        for (int i = 0, size = altNames.size(); i < size; i++) {
+            hasDns = true;
+            if (verifyHostName(hostName, altNames.get(i))) {
+                return true;
+            }
         }
-        if (altNameType == type) {
-          String altName = (String) entry.get(1);
-          if (altName != null) {
-            result.add(altName);
-          }
+
+        if (!hasDns) {
+            X500Principal principal = certificate.getSubjectX500Principal();
+            // RFC 2818 advises using the most specific name for matching.
+            String cn = new DistinguishedNameParser(principal).findMostSpecific("cn");
+            if (cn != null) {
+                return verifyHostName(hostName, cn);
+            }
         }
-      }
-      return result;
-    } catch (CertificateParsingException e) {
-      return Collections.emptyList();
-    }
-  }
-
-  /**
-   * Returns {@code true} iff {@code hostName} matches the domain name {@code pattern}.
-   *
-   * @param hostName lower-case host name.
-   * @param pattern domain name pattern from certificate. May be a wildcard pattern such as
-   *        {@code *.android.com}.
-   */
-  private boolean verifyHostName(String hostName, String pattern) {
-    // Basic sanity checks
-    // Check length == 0 instead of .isEmpty() to support Java 5.
-    if ((hostName == null) || (hostName.length() == 0) || (hostName.startsWith("."))
-        || (hostName.endsWith(".."))) {
-      // Invalid domain name
-      return false;
-    }
-    if ((pattern == null) || (pattern.length() == 0) || (pattern.startsWith("."))
-        || (pattern.endsWith(".."))) {
-      // Invalid pattern/domain name
-      return false;
+
+        return false;
     }
 
-    // Normalize hostName and pattern by turning them into absolute domain names if they are not
-    // yet absolute. This is needed because server certificates do not normally contain absolute
-    // names or patterns, but they should be treated as absolute. At the same time, any hostName
-    // presented to this method should also be treated as absolute for the purposes of matching
-    // to the server certificate.
-    //   www.android.com  matches www.android.com
-    //   www.android.com  matches www.android.com.
-    //   www.android.com. matches www.android.com.
-    //   www.android.com. matches www.android.com
-    if (!hostName.endsWith(".")) {
-      hostName += '.';
+    public static List<String> allSubjectAltNames(X509Certificate certificate) {
+        List<String> altIpaNames = getSubjectAltNames(certificate, ALT_IPA_NAME);
+        List<String> altDnsNames = getSubjectAltNames(certificate, ALT_DNS_NAME);
+        List<String> result = new ArrayList<>(altIpaNames.size() + altDnsNames.size());
+        result.addAll(altIpaNames);
+        result.addAll(altDnsNames);
+        return result;
     }
-    if (!pattern.endsWith(".")) {
-      pattern += '.';
+
+    private static List<String> getSubjectAltNames(X509Certificate certificate, int type) {
+        List<String> result = new ArrayList<>();
+        try {
+            Collection<?> subjectAltNames = certificate.getSubjectAlternativeNames();
+            if (subjectAltNames == null) {
+                return Collections.emptyList();
+            }
+            for (Object subjectAltName : subjectAltNames) {
+                List<?> entry = (List<?>) subjectAltName;
+                if (entry == null || entry.size() < 2) {
+                    continue;
+                }
+                Integer altNameType = (Integer) entry.get(0);
+                if (altNameType == null) {
+                    continue;
+                }
+                if (altNameType == type) {
+                    String altName = (String) entry.get(1);
+                    if (altName != null) {
+                        result.add(altName);
+                    }
+                }
+            }
+            return result;
+        } catch (CertificateParsingException e) {
+            return Collections.emptyList();
+        }
     }
-    // hostName and pattern are now absolute domain names.
 
-    pattern = pattern.toLowerCase(Locale.US);
-    // hostName and pattern are now in lower case -- domain names are case-insensitive.
+    /**
+     * Returns {@code true} iff {@code hostName} matches the domain name {@code pattern}.
+     *
+     * @param hostName lower-case host name.
+     * @param pattern  domain name pattern from certificate. May be a wildcard pattern such as
+     *                 {@code *.android.com}.
+     */
+    private boolean verifyHostName(String hostName, String pattern) {
+        // Basic sanity checks
+        // Check length == 0 instead of .isEmpty() to support Java 5.
+        if ((hostName == null) || (hostName.length() == 0) || (hostName.startsWith("."))
+                || (hostName.endsWith(".."))) {
+            // Invalid domain name
+            return false;
+        }
+        if ((pattern == null) || (pattern.length() == 0) || (pattern.startsWith("."))
+                || (pattern.endsWith(".."))) {
+            // Invalid pattern/domain name
+            return false;
+        }
 
-    if (!pattern.contains("*")) {
-      // Not a wildcard pattern -- hostName and pattern must match exactly.
-      return hostName.equals(pattern);
-    }
-    // Wildcard pattern
-
-    // WILDCARD PATTERN RULES:
-    // 1. Asterisk (*) is only permitted in the left-most domain name label and must be the
-    //    only character in that label (i.e., must match the whole left-most label).
-    //    For example, *.example.com is permitted, while *a.example.com, a*.example.com,
-    //    a*b.example.com, a.*.example.com are not permitted.
-    // 2. Asterisk (*) cannot match across domain name labels.
-    //    For example, *.example.com matches test.example.com but does not match
-    //    sub.test.example.com.
-    // 3. Wildcard patterns for single-label domain names are not permitted.
-
-    if ((!pattern.startsWith("*.")) || (pattern.indexOf('*', 1) != -1)) {
-      // Asterisk (*) is only permitted in the left-most domain name label and must be the only
-      // character in that label
-      return false;
-    }
+        // Normalize hostName and pattern by turning them into absolute domain names if they are not
+        // yet absolute. This is needed because server certificates do not normally contain absolute
+        // names or patterns, but they should be treated as absolute. At the same time, any hostName
+        // presented to this method should also be treated as absolute for the purposes of matching
+        // to the server certificate.
+        //   www.android.com  matches www.android.com
+        //   www.android.com  matches www.android.com.
+        //   www.android.com. matches www.android.com.
+        //   www.android.com. matches www.android.com
+        if (!hostName.endsWith(".")) {
+            hostName += '.';
+        }
+        if (!pattern.endsWith(".")) {
+            pattern += '.';
+        }
+        // hostName and pattern are now absolute domain names.
 
-    // Optimization: check whether hostName is too short to match the pattern. hostName must be at
-    // least as long as the pattern because asterisk must match the whole left-most label and
-    // hostName starts with a non-empty label. Thus, asterisk has to match one or more characters.
-    if (hostName.length() < pattern.length()) {
-      // hostName too short to match the pattern.
-      return false;
-    }
+        pattern = pattern.toLowerCase(Locale.US);
+        // hostName and pattern are now in lower case -- domain names are case-insensitive.
 
-    if ("*.".equals(pattern)) {
-      // Wildcard pattern for single-label domain name -- not permitted.
-      return false;
-    }
+        if (!pattern.contains("*")) {
+            // Not a wildcard pattern -- hostName and pattern must match exactly.
+            return hostName.equals(pattern);
+        }
+        // Wildcard pattern
+
+        // WILDCARD PATTERN RULES:
+        // 1. Asterisk (*) is only permitted in the left-most domain name label and must be the
+        //    only character in that label (i.e., must match the whole left-most label).
+        //    For example, *.example.com is permitted, while *a.example.com, a*.example.com,
+        //    a*b.example.com, a.*.example.com are not permitted.
+        // 2. Asterisk (*) cannot match across domain name labels.
+        //    For example, *.example.com matches test.example.com but does not match
+        //    sub.test.example.com.
+        // 3. Wildcard patterns for single-label domain names are not permitted.
+
+        if ((!pattern.startsWith("*.")) || (pattern.indexOf('*', 1) != -1)) {
+            // Asterisk (*) is only permitted in the left-most domain name label and must be the only
+            // character in that label
+            return false;
+        }
 
-    // hostName must end with the region of pattern following the asterisk.
-    String suffix = pattern.substring(1);
-    if (!hostName.endsWith(suffix)) {
-      // hostName does not end with the suffix
-      return false;
-    }
+        // Optimization: check whether hostName is too short to match the pattern. hostName must be at
+        // least as long as the pattern because asterisk must match the whole left-most label and
+        // hostName starts with a non-empty label. Thus, asterisk has to match one or more characters.
+        if (hostName.length() < pattern.length()) {
+            // hostName too short to match the pattern.
+            return false;
+        }
 
-    // Check that asterisk did not match across domain name labels.
-    int suffixStartIndexInHostName = hostName.length() - suffix.length();
-    if ((suffixStartIndexInHostName > 0)
-        && (hostName.lastIndexOf('.', suffixStartIndexInHostName - 1) != -1)) {
-      // Asterisk is matching across domain name labels -- not permitted.
-      return false;
-    }
+        if ("*.".equals(pattern)) {
+            // Wildcard pattern for single-label domain name -- not permitted.
+            return false;
+        }
+
+        // hostName must end with the region of pattern following the asterisk.
+        String suffix = pattern.substring(1);
+        if (!hostName.endsWith(suffix)) {
+            // hostName does not end with the suffix
+            return false;
+        }
 
-    // hostName matches pattern
-    return true;
-  }
+        // Check that asterisk did not match across domain name labels.
+        int suffixStartIndexInHostName = hostName.length() - suffix.length();
+        if ((suffixStartIndexInHostName > 0)
+                && (hostName.lastIndexOf('.', suffixStartIndexInHostName - 1) != -1)) {
+            // Asterisk is matching across domain name labels -- not permitted.
+            return false;
+        }
+
+        // hostName matches pattern
+        return true;
+    }
 }
