diff --git a/.buildscript/deploy_snapshot.sh b/.buildscript/deploy_snapshot.sh
deleted file mode 100755
index a6508e6bf8..0000000000
--- a/.buildscript/deploy_snapshot.sh
+++ /dev/null
@@ -1,26 +0,0 @@
-#!/bin/bash
-#
-# Deploy a jar, source jar, and javadoc jar to Sonatype's snapshot repo.
-#
-# Adapted from https://coderwall.com/p/9b_lfq and
-# https://benlimmer.com/2013/12/26/automatically-publish-javadoc-to-gh-pages-with-travis-ci/
-
-SLUG="square/okhttp"
-JDK="oraclejdk8"
-BRANCH="master"
-
-set -e
-
-if [ "$TRAVIS_REPO_SLUG" != "$SLUG" ]; then
-  echo "Skipping snapshot deployment: wrong repository. Expected '$SLUG' but was '$TRAVIS_REPO_SLUG'."
-elif [ "$TRAVIS_JDK_VERSION" != "$JDK" ]; then
-  echo "Skipping snapshot deployment: wrong JDK. Expected '$JDK' but was '$TRAVIS_JDK_VERSION'."
-elif [ "$TRAVIS_PULL_REQUEST" != "false" ]; then
-  echo "Skipping snapshot deployment: was pull request."
-elif [ "$TRAVIS_BRANCH" != "$BRANCH" ]; then
-  echo "Skipping snapshot deployment: wrong branch. Expected '$BRANCH' but was '$TRAVIS_BRANCH'."
-else
-  echo "Deploying snapshot..."
-  ./mvnw clean source:jar javadoc:jar deploy --settings=".buildscript/settings.xml" -DskipTests -B
-  echo "Snapshot deployed!"
-fi
diff --git a/.buildscript/settings.xml b/.buildscript/settings.xml
deleted file mode 100644
index 91f444b228..0000000000
--- a/.buildscript/settings.xml
+++ /dev/null
@@ -1,9 +0,0 @@
-<settings>
-  <servers>
-    <server>
-      <id>sonatype-nexus-snapshots</id>
-      <username>${env.CI_DEPLOY_USERNAME}</username>
-      <password>${env.CI_DEPLOY_PASSWORD}</password>
-    </server>
-  </servers>
-</settings>
diff --git a/.circleci/config.yml b/.circleci/config.yml
deleted file mode 100644
index 3ef36270a9..0000000000
--- a/.circleci/config.yml
+++ /dev/null
@@ -1,13 +0,0 @@
-version: 2
-jobs:
-  build:
-    docker:
-      - image: circleci/openjdk:8u171-jdk
-    steps:
-      - checkout
-      - run:
-          name: "Pull Submodules"
-          command: |
-            git submodule init
-            git submodule update --remote      
-      - run: mvn test
diff --git a/.github/CONTRIBUTING.md b/.github/CONTRIBUTING.md
deleted file mode 100644
index 7543438302..0000000000
--- a/.github/CONTRIBUTING.md
+++ /dev/null
@@ -1,25 +0,0 @@
-Contributing
-============
-
-If you would like to contribute code to OkHttp you can do so through GitHub by
-forking the repository and sending a pull request.
-
-When submitting code, please make every effort to follow existing conventions
-and style in order to keep the code as readable as possible. Please also make
-sure your code compiles by running `mvn clean verify`. Checkstyle failures
-during compilation indicate errors in your style and can be viewed in the
-`checkstyle-result.xml` file.
-
-Some general advice
-
-- Don‚Äôt change public API lightly, avoid if possible, and include your reasoning in the PR if essential.  It causes pain for developers who use OkHttp and sometimes runtime errors.
-- Favour a working external library if appropriate.  There are many examples of OkHttp libraries that can sit on top or hook in via existing APIs.
-- Get working code on a personal branch with tests before you submit a PR.
-- OkHttp is a small and light dependency.  Don't introduce new dependencies or major new functionality.
-- OkHttp targets the intersection of RFC correct *and* widely implemented.  Incorrect implementations that are very widely implemented e.g. a bug in Apache, Nginx, Google, Firefox should also be handled.
-
-Before your code can be accepted into the project you must also sign the
-[Individual Contributor License Agreement (CLA)][1].
-
-
- [1]: https://spreadsheets.google.com/spreadsheet/viewform?formkey=dDViT2xzUHAwRkI3X3k5Z0lQM091OGc6MQ&ndplr=1
diff --git a/.github/ISSUE_TEMPLATE/bug_report.md b/.github/ISSUE_TEMPLATE/bug_report.md
deleted file mode 100644
index 8b276c7dea..0000000000
--- a/.github/ISSUE_TEMPLATE/bug_report.md
+++ /dev/null
@@ -1,13 +0,0 @@
----
-name: Bug report
-about: A reproducible problem
-title: ''
-labels: bug
-assignees: ''
-
----
-
-Good bug reports include a failing test! Writing a test helps you to isolate and describe the problem, and it helps us to fix it fast. Bug reports without a failing test or reproduction steps are likely to be closed.
-
-Here‚Äôs an example test to get you started.
-https://gist.github.com/swankjesse/981fcae102f513eb13ed
diff --git a/.github/ISSUE_TEMPLATE/feature_request.md b/.github/ISSUE_TEMPLATE/feature_request.md
deleted file mode 100644
index e320e37f4a..0000000000
--- a/.github/ISSUE_TEMPLATE/feature_request.md
+++ /dev/null
@@ -1,12 +0,0 @@
----
-name: Feature request
-about: Suggest an idea
-title: ''
-labels: enhancement
-assignees: ''
-
----
-
-Start by telling us what problem you‚Äôre trying to solve. Often a solution already exists!
-
-Don‚Äôt send pull requests to implement new features without first getting our support. Sometimes we leave features out on purpose to keep the project small.
diff --git a/.github/ISSUE_TEMPLATE/question.md b/.github/ISSUE_TEMPLATE/question.md
deleted file mode 100644
index 73f2b5c1af..0000000000
--- a/.github/ISSUE_TEMPLATE/question.md
+++ /dev/null
@@ -1,16 +0,0 @@
----
-name: Question
-about: Use Stack Overflow instead
-title: "\U0001F649"
-labels: ''
-assignees: ''
-
----
-
-üõë ùôéùôèùôäùôã
-
-This issue tracker is not the place for questions!
-
-If you want to ask how to do something, or to understand why something isn't working the way you expect it to, use Stack Overflow. https://stackoverflow.com/questions/tagged/okhttp
-
-We close all questions without reading them.
diff --git a/.gitignore b/.gitignore
index 226a3f3d65..27b093e663 100644
--- a/.gitignore
+++ b/.gitignore
@@ -12,6 +12,7 @@ lib
 target
 pom.xml.*
 release.properties
+publicsuffixes.gz
 
 .idea
 *.iml
diff --git a/.gitmodules b/.gitmodules
deleted file mode 100644
index d29f0b1218..0000000000
--- a/.gitmodules
+++ /dev/null
@@ -1,3 +0,0 @@
-[submodule "okhttp-hpacktests/src/test/resources/hpack-test-case"]
-	path = okhttp-hpacktests/src/test/resources/hpack-test-case
-	url = git://github.com/http2jp/hpack-test-case.git
diff --git a/.travis.yml b/.travis.yml
deleted file mode 100644
index aab1208a98..0000000000
--- a/.travis.yml
+++ /dev/null
@@ -1,40 +0,0 @@
-language: java
-
-jdk:
-  - oraclejdk8
-  - openjdk8
-  - openjdk11
-
-before_install:
-  - mvn -N io.takari:maven:wrapper -Dmaven=3.6.0
-  - echo "MAVEN_OPTS='-Dmaven.repo.local=$HOME/.m2/repository -Xmx1g -Dorg.slf4j.simpleLogger.showDateTime=true -Dorg.slf4j.simpleLogger.dateTimeFormat=HH:mm:ss:SSS'" > ~/.mavenrc
-
-install:
-  - ./mvnw dependency:resolve -B || true
-
-script:
-  - ./mvnw install -DskipTests
-  - ./mvnw checkstyle:check -B
-  - ./mvnw test -B
-  - ./mvnw javadoc:jar source:jar -B
-
-after_success:
-  - .buildscript/deploy_snapshot.sh
-
-env:
-  global:
-    - secure: "S0BTJVrF4fUCwhTdmoQY6LYr5r1wgXZ/p8lc5bIgUUsc1Ckalwt7s/GDwPuLJ4702sI5t56Eye2iEIMUjeFJKqebZRsX1C5oYsYFxGi3BGlepstYpmj0gLXuSWqCLniS9zmHXCxLhLkC6KxPVjhDlbq76XQx0o3K1J8oEIj/PCE="
-    - secure: "awV7yLXURjlPbTOladsNDZk74KYCNXoiZpAP0gQFfK4Sc0fc7+kg8z/yhdWXeTxjsIZ6m0dVDHTqnH8ytnydwXpBam8JdQJ+EAWA6R3Svq1BR1bzl/PcZUoz+Xn8lMXdU3yA1p4qtQlUhMxwsE3MOVe24HSDJPAu4XeWFj1j3qo="
-
-branches:
-  except:
-    - gh-pages
-
-notifications:
-  email: false
-
-sudo: false
-
-cache:
-  directories:
-    - $HOME/.m2
diff --git a/BUG-BOUNTY.md b/BUG-BOUNTY.md
deleted file mode 100644
index b2c35b2da0..0000000000
--- a/BUG-BOUNTY.md
+++ /dev/null
@@ -1,10 +0,0 @@
-Serious about security
-======================
-
-Square recognizes the important contributions the security research community
-can make. We therefore encourage reporting security issues with the code
-contained in this repository.
-
-If you believe you have discovered a security vulnerability, please follow the
-guidelines at https://hackerone.com/square-open-source
-
diff --git a/CALLS.md b/CALLS.md
deleted file mode 100644
index 4fa1b9cae9..0000000000
--- a/CALLS.md
+++ /dev/null
@@ -1,62 +0,0 @@
-Calls
-=====
-
-The HTTP client‚Äôs job is to accept your request and produce its response. This is simple in theory but it gets tricky in practice.
-
-#### [Requests](http://square.github.io/okhttp/3.x/okhttp/okhttp3/Request.html)
-
-Each HTTP request contains a URL, a method (like `GET` or `POST`), and a list of headers. Requests may also contain a body: a data stream of a specific content type.
-
-#### [Responses](http://square.github.io/okhttp/3.x/okhttp/okhttp3/Response.html)
-
-The response answers the request with a code (like 200 for success or 404 for not found), headers, and its own optional body.
-
-#### Rewriting Requests
-
-When you provide OkHttp with an HTTP request, you‚Äôre describing the request at a high-level: _‚Äúfetch me this URL with these headers.‚Äù_ For correctness and efficiency, OkHttp rewrites your request before transmitting it.
-
-OkHttp may add headers that are absent from the original request, including `Content-Length`, `Transfer-Encoding`, `User-Agent`, `Host`, `Connection`, and `Content-Type`. It will add an `Accept-Encoding` header for transparent response compression unless the header is already present. If you‚Äôve got cookies, OkHttp will add a `Cookie` header with them.
-
-Some requests will have a cached response. When this cached response isn‚Äôt fresh, OkHttp can do a _conditional GET_ to download an updated response if it‚Äôs newer than what‚Äôs cached. This requires headers like `If-Modified-Since` and `If-None-Match` to be added.
-
-#### Rewriting Responses
-
-If transparent compression was used, OkHttp will drop the corresponding response headers `Content-Encoding` and `Content-Length` because they don‚Äôt apply to the decompressed response body.
-
-If a conditional GET was successful, responses from the network and cache are merged as directed by the spec.
-
-#### Follow-up Requests
-
-When your requested URL has moved, the webserver will return a response code like `302` to indicate the document‚Äôs new URL. OkHttp will follow the redirect to retrieve a final response.
-
-If the response issues an authorization challenge, OkHttp will ask the [`Authenticator`](http://square.github.io/okhttp/3.x/okhttp/okhttp3/Authenticator.html) (if one is configured) to satisfy the challenge. If the authenticator supplies a credential, the request is retried with that credential included.
-
-#### Retrying Requests
-
-Sometimes connections fail: either a pooled connection was stale and disconnected, or the webserver itself couldn‚Äôt be reached. OkHttp will retry the request with a different route if one is available.
-
-#### [Calls](http://square.github.io/okhttp/3.x/okhttp/okhttp3/Call.html)
-
-With rewrites, redirects, follow-ups and retries, your simple request may yield many requests and responses. OkHttp uses `Call` to model the task of satisfying your request through however many intermediate requests and responses are necessary. Typically this isn‚Äôt many! But it‚Äôs comforting to know that your code will continue to work if your URLs are redirected or if you failover to an alternate IP address.
-
-Calls are executed in one of two ways:
-
- * **Synchronous:** your thread blocks until the response is readable.
- * **Asynchronous:** you enqueue the request on any thread, and get [called back](http://square.github.io/okhttp/3.x/okhttp/okhttp3/Callback.html) on another thread when the response is readable.
-
-Calls can be canceled from any thread. This will fail the call if it hasn‚Äôt yet completed! Code that is writing the request body or reading the response body will suffer an `IOException` when its call is canceled.
-
-#### Dispatch
-
-For synchronous calls, you bring your own thread and are responsible for managing how many simultaneous requests you make. Too many simultaneous connections wastes resources; too few harms latency.
-
-For asynchronous calls, [`Dispatcher`](http://square.github.io/okhttp/3.x/okhttp/okhttp3/Dispatcher.html) implements policy for maximum simultaneous requests. You can set maximums per-webserver (default is 5), and overall (default is 64).
-
-
------
-
-<table><tr>
-  <td width="25%" align="left"><a href="README.md">‚Üê Home</a></td>
-  <td width="50%" align="center">OkHttp User's Guide</td>
-  <td width="25%" align="right"><a href="CONNECTIONS.md">Connections ‚Üí</a></td>
-</tr></table>
diff --git a/CONCURRENCY.md b/CONCURRENCY.md
deleted file mode 100644
index eeb0fa219a..0000000000
--- a/CONCURRENCY.md
+++ /dev/null
@@ -1,98 +0,0 @@
-Concurrency
-===========
-
-This document describes the concurrency considerations for http/2 connections and the connection pool within OkHttp.
-
-## HTTP/2 Connections
-
-The HttpURLConnection API is a blocking API. You make a blocking write to send a request, and a blocking read to receive the response.
-
-#### Blocking APIs
-
-Blocking APIs are convenient because you get top-to-bottom procedural code without indirection. Network calls work like regular method calls: ask for data and it is returned. If the request fails, you get a stacktrace right were the call was made.
-
-Blocking APIs may be inefficient because you hold a thread idle while waiting on the network. Threads are expensive because they have both a memory overhead and a context-switching overhead.
-
-#### Framed protocols
-
-Framed protocols like http/2 don't lend themselves to blocking APIs. Each application-layer thread wants to do blocking I/O for a specific stream, but the streams are multiplexed on the socket. You can't just talk to the socket, you need to cooperate with the other application-layer threads that you're sharing it with.
-
-Framing rules make it impractical to implement http/2 correctly on a single blocking thread. The flow-control features introduce feedback between reads and writes, requiring writes to acknowledge reads and reads to throttle writes.
-
-In OkHttp we expose a blocking API over a framed protocol. This document explains the code and policy that makes that work.
-
-### Threads
-
-#### Application's calling thread
-
-The application-layer must block on writing I/O. We can't return from a write until we've pushed its bytes onto the socket. Otherwise, if the write fails we are unable to deliver its IOException to the application. We would have told the application layer that the write succeeded, but it didn't!
-
-The application-layer can also do blocking reads. If the application asks to read and there's nothing available, we need to hold that thread until either the bytes arrive, the stream is closed, or a timeout elapses. If we get bytes but there's nobody asking for them, we buffer them. We don't consider bytes as delivered for flow control until they're consumed by the application.
-
-Consider an application streaming a video over http/2. Perhaps the user pauses the video and the application stops reading bytes from this stream. The buffer will fill up, and flow control prevents the server from sending more data on this stream. When the user unpauses her video the buffer drains, the read is acknowledged, and the server proceeds to stream data.
-
-#### Shared reader thread
-
-We can't rely on application threads to read data from the socket. Application threads are transient: sometimes they're reading and writing and sometimes they're off doing application-layer things. But the socket is permanent, and it needs constant attention: we dispatch all incoming frames so the connection is good-to-go when the application layer needs it.
-
-So we have a dedicated thread for every socket that just reads frames and dispatches them.
-
-The reader thread must never run application-layer code. Otherwise one slow stream can hold up the entire connection.
-
-Similarly, the reader thread must never block on writing because this can deadlock the connection. Consider a client and server that both violate this rule. If you get unlucky, they could fill up their TCP buffers (so that writes block) and then use their reader threads to write a frame. Nobody is reading on either end, and the buffers are never drained.
-
-#### Do-stuff-later pool
-
-Sometimes there's an action required like calling the application layer or responding to a ping, and the thread discovering the action is not the thread that should do the work. We enqueue a runnable on this executor and it gets handled by one of the executor's threads.
-
-### Locks
-
-We have 3 different things that we synchronize on.
-
-#### Http2Connection
-
-This lock guards internal state of each connection. This lock is never held for blocking operations. That means that we acquire the lock, read or write a few fields and release the lock. No I/O and no application-layer callbacks.
-
-#### Http2Stream
-
-This lock guards the internal state of each stream. As above, it is never held for blocking operations. When we need to hold an application thread to block a read, we use wait/notify on this lock. This works because the lock is released while `wait()` is waiting.
-
-#### Http2Writer
-
-Socket writes are guarded by the Http2Writer. Only one stream can write at a time so that messages are not interleaved. Writes are either made by application-layer threads or the do-stuff-later pool.
-
-### Holding multiple locks
-
-You're allowed to take the Http2Connection lock while holding the Http2Writer lock. But not vice-versa. Because taking the Http2Writer lock can block.
-
-This is necessary for bookkeeping when creating new streams. Correct framing requires that stream IDs are sequential on the socket, so we need to bundle assigning the ID with sending the `SYN_STREAM` frame.
-
-## Connection Pool
-
-### Background
-
-A primary responsibility for any HTTP client is to efficiently manage network connections. Creating and establishing new connections require a fair amount of overhead and added latency. OkHttp will make every effort to reuse existing connections to avoid this overhead and added latency.
-
-Every OkHttpClient uses a connection pool. Its job is to maintain a reference to all open connections. When an HTTP request is started, OkHttp will attempt to reuse an existing connection from the pool. If there are no existing connections, a new one is created and put into the connection pool. For http/2, the connection can be reused immediately. For http/1, the request must be completed before it can be reused.
-
-Since HTTP requests frequently happen in parallel, the connection pool implementation must be thread-safe.
-
-### ConnectionPool, RealConnection, and StreamAllocation
-
-The primary classes involved with establishing, sharing and terminating connections are ConnectionPool, RealConnection and StreamAllocation.
-
-**ConnectionPool**: Manages reuse of HTTP and HTTP/2 connections for reduced latency. Every OkHttpClient has one, and its lifetime spans the lifetime of the OkHttpClient.
-
-**RealConnection**: The socket and streams of an HTTP and HTTP/2 connection. These are created on demand to fulfill HTTP requests. They may be reused for many HTTP request/response exchanges. Their lifetime is typically shorter than ConnectionPool.
-
-**StreamAllocation**: Coordinates the relationship between connections, streams and calls. These are created for a single HTTP request/response exchange. Their lifetime is typically shorter than RealConnection.
-
-### Locks
-
-A single lock is used to synchronize and guard the state of ConnectionPool, RealConnection and StreamAllocation.
-
-### ConnectionPool
-
-The fields in ConnectionPool, RealConnection and StreamAllocation are all guarded by the connection pool instance. This lock is never held while doing I/O (even closing a socket) to prevent contention.
-
-A single lock is preferred to avoid deadlock scenarios and the added overhead of aggregate lock/unlock that would occur if multiple locks were used.
\ No newline at end of file
diff --git a/CONNECTIONS.md b/CONNECTIONS.md
deleted file mode 100644
index a80e0b5cd6..0000000000
--- a/CONNECTIONS.md
+++ /dev/null
@@ -1,52 +0,0 @@
-Connections
-===========
-
-Although you provide only the URL, OkHttp plans its connection to your webserver using three types: URL, Address, and Route.
-
-#### [URLs](http://square.github.io/okhttp/3.x/okhttp/okhttp3/HttpUrl.html)
-
-URLs (like `https://github.com/square/okhttp`) are fundamental to HTTP and the Internet. In addition to being a universal, decentralized naming scheme for everything on the web, they also specify how to access web resources.
-
-URLs are abstract:
-
- * They specify that the call may be plaintext (`http`) or encrypted (`https`), but not which cryptographic algorithms should be used. Nor do they specify how to verify the peer's certificates (the [HostnameVerifier](http://developer.android.com/reference/javax/net/ssl/HostnameVerifier.html)) or which certificates can be trusted (the [SSLSocketFactory](http://developer.android.com/reference/org/apache/http/conn/ssl/SSLSocketFactory.html)).
- * They don't specify whether a specific proxy server should be used or how to authenticate with that proxy server.
-
-They're also concrete: each URL identifies a specific path (like `/square/okhttp`) and query (like `?q=sharks&lang=en`). Each webserver hosts many URLs.
-
-#### [Addresses](http://square.github.io/okhttp/3.x/okhttp/okhttp3/Address.html)
-
-Addresses specify a webserver (like `github.com`) and all of the **static** configuration necessary to connect to that server: the port number, HTTPS settings, and preferred network protocols (like HTTP/2 or SPDY).
-
-URLs that share the same address may also share the same underlying TCP socket connection. Sharing a connection has substantial performance benefits: lower latency, higher throughput (due to [TCP slow start](http://www.igvita.com/2011/10/20/faster-web-vs-tcp-slow-start/)) and conserved battery. OkHttp uses a [ConnectionPool](http://square.github.io/okhttp/3.x/okhttp/okhttp3/ConnectionPool.html) that automatically reuses HTTP/1.x connections and multiplexes HTTP/2 and SPDY connections.
-
-In OkHttp some fields of the address come from the URL (scheme, hostname, port) and the rest come from the [OkHttpClient](http://square.github.io/okhttp/3.x/okhttp/okhttp3/OkHttpClient.html).
-
-#### [Routes](http://square.github.io/okhttp/3.x/okhttp/okhttp3/Route.html)
-
-Routes supply the **dynamic** information necessary to actually connect to a webserver. This is the specific IP address to attempt (as discovered by a DNS query), the exact proxy server to use (if a [ProxySelector](http://developer.android.com/reference/java/net/ProxySelector.html) is in use), and which version of TLS to negotiate (for HTTPS connections).
-
-There may be many routes for a single address. For example, a webserver that is hosted in multiple datacenters may yield multiple IP addresses in its DNS response.
-
-#### [Connections](http://square.github.io/okhttp/3.x/okhttp/okhttp3/Connection.html)
-
-When you request a URL with OkHttp, here's what it does:
-
- 1. It uses the URL and configured OkHttpClient to create an **address**. This address specifies how we'll connect to the webserver.
- 2. It attempts to retrieve a connection with that address from the **connection pool**.
- 3. If it doesn't find a connection in the pool, it selects a **route** to attempt. This usually means making a DNS request to get the server's IP addresses. It then selects a TLS version and proxy server if necessary.
- 4. If it's a new route, it connects by building either a direct socket connection, a TLS tunnel (for HTTPS over an HTTP proxy), or a direct TLS connection. It does TLS handshakes as necessary.
- 5. It sends the HTTP request and reads the response.
-
-If there's a problem with the connection, OkHttp will select another route and try again. This allows OkHttp to recover when a subset of a server's addresses are unreachable. It's also useful when a pooled connection is stale or if the attempted TLS version is unsupported.
-
-Once the response has been received, the connection will be returned to the pool so it can be reused for a future request. Connections are evicted from the pool after a period of inactivity.
-
-
-----
-
-<table><tr>
-  <td width="25%" align="left"><a href="CALLS.md">‚Üê Calls</a></td>
-  <td width="50%" align="center">OkHttp User's Guide</td>
-  <td width="25%" align="right"><a href="RECIPES.md">Recipes ‚Üí</a></td>
-</tr></table>
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
deleted file mode 100644
index 99e1e86cce..0000000000
--- a/CONTRIBUTING.md
+++ /dev/null
@@ -1,39 +0,0 @@
-Contributing
-============
-
-Keeping the project small and stable limits our ability to accept new contributors. We are not
-seeking new committers at this time, but some small contributions are welcome.
-
-If you've found a security problem, please follow our [bug bounty](BUG-BOUNTY.md) program.
-
-If you've found a bug, please contribute a failing test case so we can study and fix it.
-
-If you have a new feature idea, please build it in an external library. There are
-[many libraries](WORKS_WITH_OKHTTP.md) that sit on top or hook in via existing APIs. If you build
-something that integrates with OkHttp, tell us so that we can link it!
-
-Before code can be accepted all contributors must complete our
-[Individual Contributor License Agreement (CLA)](https://spreadsheets.google.com/spreadsheet/viewform?formkey=dDViT2xzUHAwRkI3X3k5Z0lQM091OGc6MQ&ndplr=1).
-
-
-Code Contributions
-------------------
-
-Get working code on a personal branch with tests passing before you submit a PR:
-
-```
-./gradlew clean check
-```
-
-Please make every effort to follow existing conventions and style in order to keep the code as
-readable as possible.
-
-Contribute code changes through GitHub by forking the repository and sending a pull request. We
-squash all pull requests on merge.
-
-
-Committer's Guides
-------------------
-
- * [Concurrency](CONCURRENCY.md)
- * [Releasing](RELEASING.md)
diff --git a/EVENTS.md b/EVENTS.md
deleted file mode 100644
index fc8ab8ae69..0000000000
--- a/EVENTS.md
+++ /dev/null
@@ -1,248 +0,0 @@
-Events
-======
-
-Events allow you to capture metrics on your application‚Äôs HTTP calls. Use events to monitor:
-
- * The size and frequency of the HTTP calls your application makes. If you‚Äôre making too many calls, or your calls are too large, you should know about it!
- * The performance of these calls on the underlying network. If the network‚Äôs performance isn‚Äôt sufficient, you need to either improve the network or use less of it.
-
-### EventListener
-
-Subclass [EventListener](https://square.github.io/okhttp/3.x/okhttp/okhttp3/EventListener.html) and override methods for the events you are interested in. In a successful HTTP call with no redirects or retries the sequence of events is described by this flow.
-
-![Events Diagram](docs/images/events@2x.png)
-
-Here‚Äôs a [sample event listener](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PrintEventsNonConcurrent.java) that prints each event with a timestamp.
-
-```java
-class PrintingEventListener extends EventListener {
-  private long callStartNanos;
-
-  private void printEvent(String name) {
-    long nowNanos = System.nanoTime();
-    if (name.equals("callStart")) {
-      callStartNanos = nowNanos;
-    }
-    long elapsedNanos = nowNanos - callStartNanos;
-    System.out.printf("%.3f %s%n", elapsedNanos / 1000000000d, name);
-  }
-
-  @Override public void callStart(Call call) {
-    printEvent("callStart");
-  }
-
-  @Override public void callEnd(Call call) {
-    printEvent("callEnd");
-  }
-
-  @Override public void dnsStart(Call call, String domainName) {
-    printEvent("dnsStart");
-  }
-
-  @Override public void dnsEnd(Call call, String domainName, List<InetAddress> inetAddressList) {
-    printEvent("dnsEnd");
-  }
-
-  ...
-}
-```
-
-We make a couple calls:
-
-```java
-Request request = new Request.Builder()
-    .url("https://publicobject.com/helloworld.txt")
-    .build();
-
-System.out.println("REQUEST 1 (new connection)");
-try (Response response = client.newCall(request).execute()) {
-  // Consume and discard the response body.
-  response.body().source().readByteString();
-}
-
-System.out.println("REQUEST 2 (pooled connection)");
-try (Response response = client.newCall(request).execute()) {
-  // Consume and discard the response body.
-  response.body().source().readByteString();
-}
-```
-
-And the listener prints the corresponding events:
-
-```
-REQUEST 1 (new connection)
-0.000 callStart
-0.010 dnsStart
-0.017 dnsEnd
-0.025 connectStart
-0.117 secureConnectStart
-0.586 secureConnectEnd
-0.586 connectEnd
-0.587 connectionAcquired
-0.588 requestHeadersStart
-0.590 requestHeadersEnd
-0.591 responseHeadersStart
-0.675 responseHeadersEnd
-0.676 responseBodyStart
-0.679 responseBodyEnd
-0.679 connectionReleased
-0.680 callEnd
-REQUEST 2 (pooled connection)
-0.000 callStart
-0.001 connectionAcquired
-0.001 requestHeadersStart
-0.001 requestHeadersEnd
-0.002 responseHeadersStart
-0.082 responseHeadersEnd
-0.082 responseBodyStart
-0.082 responseBodyEnd
-0.083 connectionReleased
-0.083 callEnd
-```
-
-Notice how no connect events are fired for the second call. It reused the connection from the first request for dramatically better performance.
-
-### EventListener.Factory
-
-In the preceding example we used a field, `callStartNanos`, to track the elapsed time of each event. This is handy, but it won‚Äôt work if multiple calls are executing concurrently. To accommodate this, use a `Factory` to create a new `EventListener` instance for each `Call`. This allows each listener to keep call-specific state.
-
-This [sample factory](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PrintEvents.java) creates a unique ID for each call and uses that ID to differentiate calls in log messages.
-
-```java
-class PrintingEventListener extends EventListener {
-  public static final Factory FACTORY = new Factory() {
-    final AtomicLong nextCallId = new AtomicLong(1L);
-
-    @Override public EventListener create(Call call) {
-      long callId = nextCallId.getAndIncrement();
-      System.out.printf("%04d %s%n", callId, call.request().url());
-      return new PrintingEventListener(callId, System.nanoTime());
-    }
-  };
-
-  final long callId;
-  final long callStartNanos;
-
-  public PrintingEventListener(long callId, long callStartNanos) {
-    this.callId = callId;
-    this.callStartNanos = callStartNanos;
-  }
-
-  private void printEvent(String name) {
-    long elapsedNanos = System.nanoTime() - callStartNanos;
-    System.out.printf("%04d %.3f %s%n", callId, elapsedNanos / 1000000000d, name);
-  }
-
-  @Override public void callStart(Call call) {
-    printEvent("callStart");
-  }
-
-  @Override public void callEnd(Call call) {
-    printEvent("callEnd");
-  }
-
-  ...
-}
-```
-
-We can use this listener to race a pair of concurrent HTTP requests:
-
-```java
-Request washingtonPostRequest = new Request.Builder()
-    .url("https://www.washingtonpost.com/")
-    .build();
-client.newCall(washingtonPostRequest).enqueue(new Callback() {
-  ...
-});
-
-Request newYorkTimesRequest = new Request.Builder()
-    .url("https://www.nytimes.com/")
-    .build();
-client.newCall(newYorkTimesRequest).enqueue(new Callback() {
-  ...
-});
-```
-
-Running this race over home WiFi shows the Times (`0002`) completes just slightly sooner than the Post (`0001`):
-
-```
-0001 https://www.washingtonpost.com/
-0001 0.000 callStart
-0002 https://www.nytimes.com/
-0002 0.000 callStart
-0002 0.010 dnsStart
-0001 0.013 dnsStart
-0001 0.022 dnsEnd
-0002 0.019 dnsEnd
-0001 0.028 connectStart
-0002 0.025 connectStart
-0002 0.072 secureConnectStart
-0001 0.075 secureConnectStart
-0001 0.386 secureConnectEnd
-0002 0.390 secureConnectEnd
-0002 0.400 connectEnd
-0001 0.403 connectEnd
-0002 0.401 connectionAcquired
-0001 0.404 connectionAcquired
-0001 0.406 requestHeadersStart
-0002 0.403 requestHeadersStart
-0001 0.414 requestHeadersEnd
-0002 0.411 requestHeadersEnd
-0002 0.412 responseHeadersStart
-0001 0.415 responseHeadersStart
-0002 0.474 responseHeadersEnd
-0002 0.475 responseBodyStart
-0001 0.554 responseHeadersEnd
-0001 0.555 responseBodyStart
-0002 0.554 responseBodyEnd
-0002 0.554 connectionReleased
-0002 0.554 callEnd
-0001 0.624 responseBodyEnd
-0001 0.624 connectionReleased
-0001 0.624 callEnd
-```
-
-The `EventListener.Factory` also makes it possible to limit metrics to a subset of calls. This one captures metrics on a random 10%:
-
-```java
-class MetricsEventListener extends EventListener {
-  private static final Factory FACTORY = new Factory() {
-    @Override public EventListener create(Call call) {
-      if (Math.random() < 0.10) {
-        return new MetricsEventListener(call);
-      } else {
-        return EventListener.NONE;
-      }
-    }
-  };
-
-  ...
-}
-```
-
-### Events with Failures
-
-When an operation fails, a failure method is called. This is `connectFailed()` for failures while building a connection to the server, and `callFailed()` when the HTTP call fails permanently. When a failure happens it is possible that a `start` event won‚Äôt have a corresponding `end` event.
-
-![Events Diagram](docs/images/events_with_failures@2x.png)
-
-### Events with Retries and Follow-Ups
-
-OkHttp is resilient and can automatically recover from some connectivity failures. In this case, the `connectFailed()` event is not terminal and not followed by `callFailed()`. Event listeners will receive multiple events of the same type when retries are attempted.
-
-A single HTTP call may require follow-up requests to be made to handle authentication challenges, redirects, and HTTP-layer timeouts. In such cases multiple connections, requests, and responses may be attempted. Follow-ups are another reason a single call may trigger multiple events of the same type.
-
-![Events Diagram](docs/images/events_with_failures_and_retries@2x.png)
-
-### Availability
-
-Events is available as a public API in OkHttp 3.11. Future releases may introduce new event types; you will need to override the corresponding methods to handle them.
-
-
-----
-
-<table><tr>
-  <td width="25%" align="left"><a href="HTTPS.md">‚Üê HTTPS</a></td>
-  <td width="50%" align="center">OkHttp User's Guide</td>
-  <td width="25%" align="right"><a href="README.md">Home ‚Üí</a></td>
-</tr></table>
diff --git a/HTTPS.md b/HTTPS.md
deleted file mode 100644
index 29d504d9f2..0000000000
--- a/HTTPS.md
+++ /dev/null
@@ -1,114 +0,0 @@
-HTTPS
-=====
-
-OkHttp attempts to balance two competing concerns:
-
- * **Connectivity** to as many hosts as possible. That includes advanced hosts that run the latest versions of [boringssl](https://boringssl.googlesource.com/boringssl/) and less out of date hosts running older versions of [OpenSSL](https://www.openssl.org/).
- * **Security** of the connection. This includes verification of the remote webserver with certificates and the privacy of data exchanged with strong ciphers.
-
-When negotiating a connection to an HTTPS server, OkHttp needs to know which [TLS versions](http://square.github.io/okhttp/3.x/okhttp/okhttp3/TlsVersion.html) and [cipher suites](http://square.github.io/okhttp/3.x/okhttp/okhttp3/CipherSuite.html) to offer. A client that wants to maximize connectivity would include obsolete TLS versions and weak-by-design cipher suites. A strict client that wants to maximize security would be limited to only the latest TLS version and strongest cipher suites.
-
-Specific security vs. connectivity decisions are implemented by [ConnectionSpec](http://square.github.io/okhttp/3.x/okhttp/okhttp3/ConnectionSpec.html). OkHttp includes four built-in connection specs:
-
- * `RESTRICTED_TLS` is a secure configuration, intended to meet stricter compliance requirements.
- * `MODERN_TLS` is a secure configuration that connects to modern HTTPS servers.
- * `COMPATIBLE_TLS` is a secure configuration that connects to secure‚Äìbut not current‚ÄìHTTPS servers.
- * `CLEARTEXT` is an insecure configuration that is used for `http://` URLs.
-
-These loosely follow the model set in [Google Cloud Policies](https://cloud.google.com/load-balancing/docs/ssl-policies-concepts). We [track changes](TLS_CONFIGURATION_HISTORY.md) to this policy.
-
-By default, OkHttp will attempt a `MODERN_TLS` connection.  However by configuring the client connectionSpecs you can allow a fall back to `COMPATIBLE_TLS` connection if the modern configuration fails.
-
-```java
-OkHttpClient client = new OkHttpClient.Builder()
-    .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
-    .build();
-```
-
-The TLS versions and cipher suites in each spec can change with each release. For example, in OkHttp 2.2 we dropped support for SSL 3.0 in response to the [POODLE](http://googleonlinesecurity.blogspot.ca/2014/10/this-poodle-bites-exploiting-ssl-30.html) attack. And in OkHttp 2.3 we dropped support for [RC4](http://en.wikipedia.org/wiki/RC4#Security). As with your desktop web browser, staying up-to-date with OkHttp is the best way to stay secure.
-
-You can build your own connection spec with a custom set of TLS versions and cipher suites. For example, this configuration is limited to three highly-regarded cipher suites. Its drawback is that it requires Android 5.0+ and a similarly current webserver.
-
-```java
-ConnectionSpec spec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
-    .tlsVersions(TlsVersion.TLS_1_2)
-    .cipherSuites(
-          CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
-          CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
-          CipherSuite.TLS_DHE_RSA_WITH_AES_128_GCM_SHA256)
-    .build();
-
-OkHttpClient client = new OkHttpClient.Builder()
-    .connectionSpecs(Collections.singletonList(spec))
-    .build();
-```
-
-#### [Certificate Pinning](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java)
-
-By default, OkHttp trusts the certificate authorities of the host platform. This strategy maximizes connectivity, but it is subject to certificate authority attacks such as the [2011 DigiNotar attack](http://www.computerworld.com/article/2510951/cybercrime-hacking/hackers-spied-on-300-000-iranians-using-fake-google-certificate.html). It also assumes your HTTPS servers‚Äô certificates are signed by a certificate authority.
-
-Use [CertificatePinner](http://square.github.io/okhttp/3.x/okhttp/okhttp3/CertificatePinner.html) to restrict which certificates and certificate authorities are trusted. Certificate pinning increases security, but limits your server team‚Äôs abilities to update their TLS certificates. **Do not use certificate pinning without the blessing of your server‚Äôs TLS administrator!**
-
-```java
-  public CertificatePinning() {
-    client = new OkHttpClient.Builder()
-        .certificatePinner(new CertificatePinner.Builder()
-            .add("publicobject.com", "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
-            .build())
-        .build();
-  }
-
-  public void run() throws Exception {
-    Request request = new Request.Builder()
-        .url("https://publicobject.com/robots.txt")
-        .build();
-
-    Response response = client.newCall(request).execute();
-    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-    for (Certificate certificate : response.handshake().peerCertificates()) {
-      System.out.println(CertificatePinner.pin(certificate));
-    }
-  }
-```
-
-#### [Customizing Trusted Certificates](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/CustomTrust.java)
-
-The full code sample shows how to replace the host platform‚Äôs certificate authorities with your own set. As above, **do not use custom certificates without the blessing of your server‚Äôs TLS administrator!**
-
-```java
-  private final OkHttpClient client;
-
-  public CustomTrust() {
-    SSLContext sslContext = sslContextForTrustedCertificates(trustedCertificatesInputStream());
-    client = new OkHttpClient.Builder()
-        .sslSocketFactory(sslContext.getSocketFactory())
-        .build();
-  }
-
-  public void run() throws Exception {
-    Request request = new Request.Builder()
-        .url("https://publicobject.com/helloworld.txt")
-        .build();
-
-    Response response = client.newCall(request).execute();
-    System.out.println(response.body().string());
-  }
-
-  private InputStream trustedCertificatesInputStream() {
-    ... // Full source omitted. See sample.
-  }
-
-  public SSLContext sslContextForTrustedCertificates(InputStream in) {
-    ... // Full source omitted. See sample.
-  }
-```
-
-
-----
-
-<table><tr>
-  <td width="25%" align="left"><a href="INTERCEPTORS.md">‚Üê Interceptors</a></td>
-  <td width="50%" align="center">OkHttp User's Guide</td>
-  <td width="25%" align="right"><a href="EVENTS.md">Events ‚Üí</a></td>
-</tr></table>
diff --git a/INTERCEPTORS.md b/INTERCEPTORS.md
deleted file mode 100644
index 5dda7457d3..0000000000
--- a/INTERCEPTORS.md
+++ /dev/null
@@ -1,202 +0,0 @@
-Interceptors
-============
-
-Interceptors are a powerful mechanism that can monitor, rewrite, and retry calls. Here's a simple interceptor that logs the outgoing request and the incoming response.
-
-```java
-class LoggingInterceptor implements Interceptor {
-  @Override public Response intercept(Interceptor.Chain chain) throws IOException {
-    Request request = chain.request();
-
-    long t1 = System.nanoTime();
-    logger.info(String.format("Sending request %s on %s%n%s",
-        request.url(), chain.connection(), request.headers()));
-
-    Response response = chain.proceed(request);
-
-    long t2 = System.nanoTime();
-    logger.info(String.format("Received response for %s in %.1fms%n%s",
-        response.request().url(), (t2 - t1) / 1e6d, response.headers()));
-
-    return response;
-  }
-}
-```
-
-A call to `chain.proceed(request)` is a critical part of each interceptor‚Äôs implementation. This simple-looking method is where all the HTTP work happens, producing a response to satisfy the request.
-
-Interceptors can be chained. Suppose you have both a compressing interceptor and a checksumming interceptor: you'll need to decide whether data is compressed and then checksummed, or checksummed and then compressed. OkHttp uses lists to track interceptors, and interceptors are called in order.
-
-![Interceptors Diagram](docs/images/interceptors@2x.png)
-
-#### Application Interceptors
-
-Interceptors are registered as either _application_ or _network_ interceptors. We'll use the `LoggingInterceptor` defined above to show the difference.
-
-Register an _application_ interceptor by calling `addInterceptor()` on `OkHttpClient.Builder`:
-
-```java
-OkHttpClient client = new OkHttpClient.Builder()
-    .addInterceptor(new LoggingInterceptor())
-    .build();
-
-Request request = new Request.Builder()
-    .url("http://www.publicobject.com/helloworld.txt")
-    .header("User-Agent", "OkHttp Example")
-    .build();
-
-Response response = client.newCall(request).execute();
-response.body().close();
-```
-
-The URL `http://www.publicobject.com/helloworld.txt` redirects to `https://publicobject.com/helloworld.txt`, and OkHttp follows this redirect automatically. Our application interceptor is called **once** and the response returned from `chain.proceed()` has the redirected response:
-
-```
-INFO: Sending request http://www.publicobject.com/helloworld.txt on null
-User-Agent: OkHttp Example
-
-INFO: Received response for https://publicobject.com/helloworld.txt in 1179.7ms
-Server: nginx/1.4.6 (Ubuntu)
-Content-Type: text/plain
-Content-Length: 1759
-Connection: keep-alive
-```
-
-We can see that we were redirected because `response.request().url()` is different from `request.url()`. The two log statements log two different URLs.
-
-#### Network Interceptors
-
-Registering a network interceptor is quite similar. Call `addNetworkInterceptor()` instead of `addInterceptor()`:
-
-```java
-OkHttpClient client = new OkHttpClient.Builder()
-    .addNetworkInterceptor(new LoggingInterceptor())
-    .build();
-
-Request request = new Request.Builder()
-    .url("http://www.publicobject.com/helloworld.txt")
-    .header("User-Agent", "OkHttp Example")
-    .build();
-
-Response response = client.newCall(request).execute();
-response.body().close();
-```
-
-When we run this code, the interceptor runs twice. Once for the initial request to `http://www.publicobject.com/helloworld.txt`, and another for the redirect to `https://publicobject.com/helloworld.txt`.
-
-```
-INFO: Sending request http://www.publicobject.com/helloworld.txt on Connection{www.publicobject.com:80, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=none protocol=http/1.1}
-User-Agent: OkHttp Example
-Host: www.publicobject.com
-Connection: Keep-Alive
-Accept-Encoding: gzip
-
-INFO: Received response for http://www.publicobject.com/helloworld.txt in 115.6ms
-Server: nginx/1.4.6 (Ubuntu)
-Content-Type: text/html
-Content-Length: 193
-Connection: keep-alive
-Location: https://publicobject.com/helloworld.txt
-
-INFO: Sending request https://publicobject.com/helloworld.txt on Connection{publicobject.com:443, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA protocol=http/1.1}
-User-Agent: OkHttp Example
-Host: publicobject.com
-Connection: Keep-Alive
-Accept-Encoding: gzip
-
-INFO: Received response for https://publicobject.com/helloworld.txt in 80.9ms
-Server: nginx/1.4.6 (Ubuntu)
-Content-Type: text/plain
-Content-Length: 1759
-Connection: keep-alive
-```
-
-The network requests also contain more data, such as the `Accept-Encoding: gzip` header added by OkHttp to advertise support for response compression. The network interceptor's `Chain` has a non-null `Connection` that can be used to interrogate the IP address and TLS configuration that were used to connect to the webserver.
-
-#### Choosing between application and network interceptors
-
-Each interceptor chain has relative merits.
-
-**Application interceptors**
-
- * Don't need to worry about intermediate responses like redirects and retries.
- * Are always invoked once, even if the HTTP response is served from the cache.
- * Observe the application's original intent. Unconcerned with OkHttp-injected headers like `If-None-Match`.
- * Permitted to short-circuit and not call `Chain.proceed()`.
- * Permitted to retry and make multiple calls to `Chain.proceed()`.
-
-**Network Interceptors**
-
- * Able to operate on intermediate responses like redirects and retries.
- * Not invoked for cached responses that short-circuit the network.
- * Observe the data just as it will be transmitted over the network.
- * Access to the `Connection` that carries the request.
-
-#### Rewriting Requests
-
-Interceptors can add, remove, or replace request headers. They can also transform the body of those requests that have one. For example, you can use an application interceptor to add request body compression if you're connecting to a webserver known to support it.
-
-```java
-/** This interceptor compresses the HTTP request body. Many webservers can't handle this! */
-final class GzipRequestInterceptor implements Interceptor {
-  @Override public Response intercept(Interceptor.Chain chain) throws IOException {
-    Request originalRequest = chain.request();
-    if (originalRequest.body() == null || originalRequest.header("Content-Encoding") != null) {
-      return chain.proceed(originalRequest);
-    }
-
-    Request compressedRequest = originalRequest.newBuilder()
-        .header("Content-Encoding", "gzip")
-        .method(originalRequest.method(), gzip(originalRequest.body()))
-        .build();
-    return chain.proceed(compressedRequest);
-  }
-
-  private RequestBody gzip(final RequestBody body) {
-    return new RequestBody() {
-      @Override public MediaType contentType() {
-        return body.contentType();
-      }
-
-      @Override public long contentLength() {
-        return -1; // We don't know the compressed length in advance!
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        BufferedSink gzipSink = Okio.buffer(new GzipSink(sink));
-        body.writeTo(gzipSink);
-        gzipSink.close();
-      }
-    };
-  }
-}
-```
-
-#### Rewriting Responses
-
-Symmetrically, interceptors can rewrite response headers and transform the response body. This is generally more dangerous than rewriting request headers because it may violate the webserver's expectations!
-
-If you're in a tricky situation and prepared to deal with the consequences, rewriting response headers is a powerful way to work around problems. For example, you can fix a server's misconfigured `Cache-Control` response header to enable better response caching:
-
-```java
-/** Dangerous interceptor that rewrites the server's cache-control header. */
-private static final Interceptor REWRITE_CACHE_CONTROL_INTERCEPTOR = new Interceptor() {
-  @Override public Response intercept(Interceptor.Chain chain) throws IOException {
-    Response originalResponse = chain.proceed(chain.request());
-    return originalResponse.newBuilder()
-        .header("Cache-Control", "max-age=60")
-        .build();
-  }
-};
-```
-
-Typically this approach works best when it complements a corresponding fix on the webserver!
-
-
-----
-
-<table><tr>
-  <td width="25%" align="left"><a href="RECIPES.md">‚Üê Recipes</a></td>
-  <td width="50%" align="center">OkHttp User's Guide</td>
-  <td width="25%" align="right"><a href="HTTPS.md">HTTPS ‚Üí</a></td>
-</tr></table>
diff --git a/README.md b/README.md
deleted file mode 100644
index 43164e424a..0000000000
--- a/README.md
+++ /dev/null
@@ -1,105 +0,0 @@
-OkHttp 3.x
-==========
-
-An HTTP & HTTP/2 client for Android and Java applications.
-
-Docs
-----
-
- * [**User's Guide**](CALLS.md) (includes [Calls](CALLS.md), [Connections](CONNECTIONS.md),
-   [Recipes](RECIPES.md), [Interceptors](INTERCEPTORS.md), [HTTPS](HTTPS.md), [Events](EVENTS.md))
- * [**3.x API**][3x_okhttp] (also [dnsoverhttps][3x_dnsoverhttps],
-   [logging-interceptor][3x_logging], [sse][3x_sse], [tls][3x_tls],
-   [urlconnection][3x_urlconnection], [mockwebserver][3x_mockwebserver])
- * [**StackOverflow**](http://stackoverflow.com/questions/tagged/okhttp?sort=active)
- * [**Works with OkHttp**](WORKS_WITH_OKHTTP.md)
-
-
-Requirements
-------------
-
-OkHttp works on Android 5.0+ (API level 21+) and on Java 8+.
-
-OkHttp has one library dependency on [Okio][okio], a small library for high-performance I/O. It
-works with either Okio 1.x (implemented in Java) or Okio 2.x (upgraded to Kotlin).
-
-We highly recommend you keep OkHttp up-to-date. As with auto-updating web browsers, staying current
-with HTTPS clients is an important defense against potential security problems. [We
-track][tls_history] the dynamic TLS ecosystem and adjust OkHttp to improve connectivity and
-security.
-
-OkHttp uses your platform's built-in TLS implementation. On Java platforms OkHttp also supports
-[Conscrypt][conscrypt], which integrates BoringSSL with Java. OkHttp will use Conscrypt if it is
-the first security provider:
-
-```java
-Security.insertProviderAt(Conscrypt.newProvider(), 1);
-```
-
-The OkHttp 3.12.x branch supports Android 2.3+ (API level 9+) and Java 7+. These platforms lack
-support for TLS 1.2 and should not be used. But because upgrading is difficult we will backport
-critical fixes to the [3.12.x branch][okhttp_312x] through December 31, 2020.
-
-Releases
---------
-
-Our [change log](CHANGELOG.md) has release history.
-
-```kotlin
-implementation("com.squareup.okhttp3:okhttp:3.14.2")
-```
-
-Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
-
-
-MockWebServer
--------------
-
-OkHttp includes a library for testing HTTP, HTTPS, and HTTP/2 clients.
-
-Download [the latest JAR][mockwebserver_latest_jar] or configure this dependency:
-```xml
-testImplementation("com.squareup.okhttp3:mockwebserver:3.14.2")
-```
-
-R8 / ProGuard
--------------
-
-If you are using R8 or ProGuard add the options from [`okhttp3.pro`][okhttp3_pro].
-
-You might also need rules for Okio which is a dependency of this library.
-
-
-License
--------
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-
-
- [conscrypt]: https://github.com/google/conscrypt/
- [mockwebserver_latest_jar]: https://search.maven.org/remote_content?g=com.squareup.okhttp3&a=mockwebserver&v=LATEST
- [okhttp_312x]: https://github.com/square/okhttp/tree/okhttp_3.12.x
- [okhttp_latest_jar]: https://search.maven.org/remote_content?g=com.squareup.okhttp3&a=okhttp&v=LATEST
- [okio]: https://github.com/square/okio/
- [snap]: https://oss.sonatype.org/content/repositories/snapshots/
- [tls_history]: TLS_CONFIGURATION_HISTORY.md
- [website]: https://square.github.io/okhttp
- [okhttp3_pro]: https://github.com/square/okhttp/blob/master/okhttp/src/main/resources/META-INF/proguard/okhttp3.pro
-
- [3x_okhttp]: http://square.github.io/okhttp/3.x/okhttp/
- [3x_dnsoverhttps]: http://square.github.io/okhttp/3.x/okhttp-dnsoverhttps/
- [3x_logging]: http://square.github.io/okhttp/3.x/logging-interceptor/
- [3x_sse]: http://square.github.io/okhttp/3.x/okhttp-sse/
- [3x_tls]: http://square.github.io/okhttp/3.x/okhttp-tls/
- [3x_urlconnection]: http://square.github.io/okhttp/3.x/okhttp-urlconnection/
- [3x_mockwebserver]: http://square.github.io/okhttp/3.x/mockwebserver/
diff --git a/RECIPES.md b/RECIPES.md
deleted file mode 100644
index 664da04351..0000000000
--- a/RECIPES.md
+++ /dev/null
@@ -1,520 +0,0 @@
-Recipes
-=======
-
-We've written some recipes that demonstrate how to solve common problems with OkHttp. Read through them to learn about how everything works together. Cut-and-paste these examples freely; that's what they're for.
-
-#### [Synchronous Get](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/SynchronousGet.java)
-
-Download a file, print its headers, and print its response body as a string.
-
-The `string()` method on response body is convenient and efficient for small documents. But if the response body is large (greater than 1 MiB), avoid `string()` because it will load the entire document into memory. In that case, prefer to process the body as a stream.
-
-```java
-  private final OkHttpClient client = new OkHttpClient();
-
-  public void run() throws Exception {
-    Request request = new Request.Builder()
-        .url("https://publicobject.com/helloworld.txt")
-        .build();
-
-    try (Response response = client.newCall(request).execute()) {
-      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-      Headers responseHeaders = response.headers();
-      for (int i = 0; i < responseHeaders.size(); i++) {
-        System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i));
-      }
-
-      System.out.println(response.body().string());
-    }
-  }
-```
-
-#### [Asynchronous Get](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/AsynchronousGet.java)
-
-Download a file on a worker thread, and get called back when the response is readable. The callback is made after the response headers are ready. Reading the response body may still block. OkHttp doesn't currently offer asynchronous APIs to receive a response body in parts.
-
-```java
-  private final OkHttpClient client = new OkHttpClient();
-
-  public void run() throws Exception {
-    Request request = new Request.Builder()
-        .url("http://publicobject.com/helloworld.txt")
-        .build();
-
-    client.newCall(request).enqueue(new Callback() {
-      @Override public void onFailure(Call call, IOException e) {
-        e.printStackTrace();
-      }
-
-      @Override public void onResponse(Call call, Response response) throws IOException {
-        try (ResponseBody responseBody = response.body()) {
-          if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-          Headers responseHeaders = response.headers();
-          for (int i = 0, size = responseHeaders.size(); i < size; i++) {
-            System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i));
-          }
-
-          System.out.println(responseBody.string());
-        }
-      }
-    });
-  }
-```
-
-#### [Accessing Headers](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/AccessHeaders.java)
-
-Typically HTTP headers work like a `Map<String, String>`: each field has one value or none. But some headers permit multiple values, like Guava's [Multimap](http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/Multimap.html). For example, it's legal and common for an HTTP response to supply multiple `Vary` headers. OkHttp's APIs attempt to make both cases comfortable.
-
-When writing request headers, use `header(name, value)` to set the only occurrence of `name` to `value`. If there are existing values, they will be removed before the new value is added. Use `addHeader(name, value)` to add a header without removing the headers already present.
-
-When reading response a header, use `header(name)` to return the _last_ occurrence of the named value. Usually this is also the only occurrence! If no value is present, `header(name)` will return null. To read all of a field's values as a list, use `headers(name)`.
-
-To visit all headers, use the `Headers` class which supports access by index.
-
-```java
-  private final OkHttpClient client = new OkHttpClient();
-
-  public void run() throws Exception {
-    Request request = new Request.Builder()
-        .url("https://api.github.com/repos/square/okhttp/issues")
-        .header("User-Agent", "OkHttp Headers.java")
-        .addHeader("Accept", "application/json; q=0.5")
-        .addHeader("Accept", "application/vnd.github.v3+json")
-        .build();
-
-    try (Response response = client.newCall(request).execute()) {
-      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-      System.out.println("Server: " + response.header("Server"));
-      System.out.println("Date: " + response.header("Date"));
-      System.out.println("Vary: " + response.headers("Vary"));
-    }
-  }
-```
-
-#### [Posting a String](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PostString.java)
-
-Use an HTTP POST to send a request body to a service. This example posts a markdown document to a web service that renders markdown as HTML. Because the entire request body is in memory simultaneously, avoid posting large (greater than 1 MiB) documents using this API.
-
-```java
-  public static final MediaType MEDIA_TYPE_MARKDOWN
-      = MediaType.parse("text/x-markdown; charset=utf-8");
-
-  private final OkHttpClient client = new OkHttpClient();
-
-  public void run() throws Exception {
-    String postBody = ""
-        + "Releases\n"
-        + "--------\n"
-        + "\n"
-        + " * _1.0_ May 6, 2013\n"
-        + " * _1.1_ June 15, 2013\n"
-        + " * _1.2_ August 11, 2013\n";
-
-    Request request = new Request.Builder()
-        .url("https://api.github.com/markdown/raw")
-        .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody))
-        .build();
-
-    try (Response response = client.newCall(request).execute()) {
-      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-      System.out.println(response.body().string());
-    }
-  }
-```
-
-#### [Post Streaming](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java)
-
-Here we `POST` a request body as a stream. The content of this request body is being generated as it's being written. This example streams directly into the [Okio](https://github.com/square/okio) buffered sink. Your programs may prefer an `OutputStream`, which you can get from `BufferedSink.outputStream()`.
-
-```java
-  public static final MediaType MEDIA_TYPE_MARKDOWN
-      = MediaType.parse("text/x-markdown; charset=utf-8");
-
-  private final OkHttpClient client = new OkHttpClient();
-
-  public void run() throws Exception {
-    RequestBody requestBody = new RequestBody() {
-      @Override public MediaType contentType() {
-        return MEDIA_TYPE_MARKDOWN;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        sink.writeUtf8("Numbers\n");
-        sink.writeUtf8("-------\n");
-        for (int i = 2; i <= 997; i++) {
-          sink.writeUtf8(String.format(" * %s = %s\n", i, factor(i)));
-        }
-      }
-
-      private String factor(int n) {
-        for (int i = 2; i < n; i++) {
-          int x = n / i;
-          if (x * i == n) return factor(x) + " √ó " + i;
-        }
-        return Integer.toString(n);
-      }
-    };
-
-    Request request = new Request.Builder()
-        .url("https://api.github.com/markdown/raw")
-        .post(requestBody)
-        .build();
-
-    try (Response response = client.newCall(request).execute()) {
-      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-      System.out.println(response.body().string());
-    }
-  }
-```
-
-#### [Posting a File](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PostFile.java)
-
-It's easy to use a file as a request body.
-
-```java
-  public static final MediaType MEDIA_TYPE_MARKDOWN
-      = MediaType.parse("text/x-markdown; charset=utf-8");
-
-  private final OkHttpClient client = new OkHttpClient();
-
-  public void run() throws Exception {
-    File file = new File("README.md");
-
-    Request request = new Request.Builder()
-        .url("https://api.github.com/markdown/raw")
-        .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file))
-        .build();
-
-    try (Response response = client.newCall(request).execute()) {
-      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-      System.out.println(response.body().string());
-    }
-  }
-```
-
-#### [Posting form parameters](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PostForm.java)
-
-Use `FormBody.Builder` to build a request body that works like an HTML `<form>` tag. Names and values will be encoded using an HTML-compatible form URL encoding.
-
-```java
-  private final OkHttpClient client = new OkHttpClient();
-
-  public void run() throws Exception {
-    RequestBody formBody = new FormBody.Builder()
-        .add("search", "Jurassic Park")
-        .build();
-    Request request = new Request.Builder()
-        .url("https://en.wikipedia.org/w/index.php")
-        .post(formBody)
-        .build();
-
-    try (Response response = client.newCall(request).execute()) {
-      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-      System.out.println(response.body().string());
-    }
-  }
-```
-
-#### [Posting a multipart request](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java)
-
-`MultipartBody.Builder` can build sophisticated request bodies compatible with HTML file upload forms. Each part of a multipart request body is itself a request body, and can define its own headers. If present, these headers should describe the part body, such as its `Content-Disposition`. The `Content-Length` and `Content-Type` headers are added automatically if they're available.
-
-```java
-  /**
-   * The imgur client ID for OkHttp recipes. If you're using imgur for anything other than running
-   * these examples, please request your own client ID! https://api.imgur.com/oauth2
-   */
-  private static final String IMGUR_CLIENT_ID = "...";
-  private static final MediaType MEDIA_TYPE_PNG = MediaType.parse("image/png");
-
-  private final OkHttpClient client = new OkHttpClient();
-
-  public void run() throws Exception {
-    // Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image
-    RequestBody requestBody = new MultipartBody.Builder()
-        .setType(MultipartBody.FORM)
-        .addFormDataPart("title", "Square Logo")
-        .addFormDataPart("image", "logo-square.png",
-            RequestBody.create(MEDIA_TYPE_PNG, new File("website/static/logo-square.png")))
-        .build();
-
-    Request request = new Request.Builder()
-        .header("Authorization", "Client-ID " + IMGUR_CLIENT_ID)
-        .url("https://api.imgur.com/3/image")
-        .post(requestBody)
-        .build();
-
-    try (Response response = client.newCall(request).execute()) {
-      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-      System.out.println(response.body().string());
-    }
-  }
-```
-
-#### [Parse a JSON Response With Moshi](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/ParseResponseWithMoshi.java)
-
-[Moshi](https://github.com/square/moshi) is a handy API for converting between JSON and Java objects. Here we're using it to decode a JSON response from a GitHub API.
-
-Note that `ResponseBody.charStream()` uses the `Content-Type` response header to select which charset to use when decoding the response body. It defaults to `UTF-8` if no charset is specified.
-
-```java
-  private final OkHttpClient client = new OkHttpClient();
-  private final Moshi moshi = new Moshi.Builder().build();
-  private final JsonAdapter<Gist> gistJsonAdapter = moshi.adapter(Gist.class);
-
-  public void run() throws Exception {
-    Request request = new Request.Builder()
-        .url("https://api.github.com/gists/c2a7c39532239ff261be")
-        .build();
-    try (Response response = client.newCall(request).execute()) {
-      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-      Gist gist = gistJsonAdapter.fromJson(response.body().source());
-
-      for (Map.Entry<String, GistFile> entry : gist.files.entrySet()) {
-        System.out.println(entry.getKey());
-        System.out.println(entry.getValue().content);
-      }
-    }
-  }
-
-  static class Gist {
-    Map<String, GistFile> files;
-  }
-
-  static class GistFile {
-    String content;
-  }
-```
-
-#### [Response Caching](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/CacheResponse.java)
-
-To cache responses, you'll need a cache directory that you can read and write to, and a limit on the cache's size. The cache directory should be private, and untrusted applications should not be able to read its contents!
-
-It is an error to have multiple caches accessing the same cache directory simultaneously. Most applications should call `new OkHttpClient()` exactly once, configure it with their cache, and use that same instance everywhere. Otherwise the two cache instances will stomp on each other, corrupt the response cache, and possibly crash your program.
-
-Response caching uses HTTP headers for all configuration. You can add request headers like `Cache-Control: max-stale=3600` and OkHttp's cache will honor them. Your webserver configures how long responses are cached with its own response headers, like `Cache-Control: max-age=9600`. There are cache headers to force a cached response, force a network response, or force the network response to be validated with a conditional GET.
-
-```java
-  private final OkHttpClient client;
-
-  public CacheResponse(File cacheDirectory) throws Exception {
-    int cacheSize = 10 * 1024 * 1024; // 10 MiB
-    Cache cache = new Cache(cacheDirectory, cacheSize);
-
-    client = new OkHttpClient.Builder()
-        .cache(cache)
-        .build();
-  }
-
-  public void run() throws Exception {
-    Request request = new Request.Builder()
-        .url("http://publicobject.com/helloworld.txt")
-        .build();
-
-    String response1Body;
-    try (Response response1 = client.newCall(request).execute()) {
-      if (!response1.isSuccessful()) throw new IOException("Unexpected code " + response1);
-
-      response1Body = response1.body().string();
-      System.out.println("Response 1 response:          " + response1);
-      System.out.println("Response 1 cache response:    " + response1.cacheResponse());
-      System.out.println("Response 1 network response:  " + response1.networkResponse());
-    }
-
-    String response2Body;
-    try (Response response2 = client.newCall(request).execute()) {
-      if (!response2.isSuccessful()) throw new IOException("Unexpected code " + response2);
-
-      response2Body = response2.body().string();
-      System.out.println("Response 2 response:          " + response2);
-      System.out.println("Response 2 cache response:    " + response2.cacheResponse());
-      System.out.println("Response 2 network response:  " + response2.networkResponse());
-    }
-
-    System.out.println("Response 2 equals Response 1? " + response1Body.equals(response2Body));
-  }
-```
-To prevent a response from using the cache, use [`CacheControl.FORCE_NETWORK`](http://square.github.io/okhttp/3.x/okhttp/okhttp3/CacheControl.html#FORCE_NETWORK). To prevent it from using the network, use [`CacheControl.FORCE_CACHE`](http://square.github.io/okhttp/3.x/okhttp/okhttp3/CacheControl.html#FORCE_CACHE). Be warned: if you use `FORCE_CACHE` and the response requires the network, OkHttp will return a `504 Unsatisfiable Request` response.
-
-#### [Canceling a Call](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/CancelCall.java)
-
-Use `Call.cancel()` to stop an ongoing call immediately. If a thread is currently writing a request or reading a response, it will receive an `IOException`. Use this to conserve the network when a call is no longer necessary; for example when your user navigates away from an application. Both synchronous and asynchronous calls can be canceled.
-
-```java
-  private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
-  private final OkHttpClient client = new OkHttpClient();
-
-  public void run() throws Exception {
-    Request request = new Request.Builder()
-        .url("http://httpbin.org/delay/2") // This URL is served with a 2 second delay.
-        .build();
-
-    final long startNanos = System.nanoTime();
-    final Call call = client.newCall(request);
-
-    // Schedule a job to cancel the call in 1 second.
-    executor.schedule(new Runnable() {
-      @Override public void run() {
-        System.out.printf("%.2f Canceling call.%n", (System.nanoTime() - startNanos) / 1e9f);
-        call.cancel();
-        System.out.printf("%.2f Canceled call.%n", (System.nanoTime() - startNanos) / 1e9f);
-      }
-    }, 1, TimeUnit.SECONDS);
-
-    System.out.printf("%.2f Executing call.%n", (System.nanoTime() - startNanos) / 1e9f);
-    try (Response response = call.execute()) {
-      System.out.printf("%.2f Call was expected to fail, but completed: %s%n",
-          (System.nanoTime() - startNanos) / 1e9f, response);
-    } catch (IOException e) {
-      System.out.printf("%.2f Call failed as expected: %s%n",
-          (System.nanoTime() - startNanos) / 1e9f, e);
-    }
-  }
-```
-
-#### [Timeouts](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/ConfigureTimeouts.java)
-
-Use timeouts to fail a call when its peer is unreachable. Network partitions can be due to client connectivity problems, server availability problems, or anything between. OkHttp supports connect, read, and write timeouts.
-
-```java
-  private final OkHttpClient client;
-
-  public ConfigureTimeouts() throws Exception {
-    client = new OkHttpClient.Builder()
-        .connectTimeout(10, TimeUnit.SECONDS)
-        .writeTimeout(10, TimeUnit.SECONDS)
-        .readTimeout(30, TimeUnit.SECONDS)
-        .build();
-  }
-
-  public void run() throws Exception {
-    Request request = new Request.Builder()
-        .url("http://httpbin.org/delay/2") // This URL is served with a 2 second delay.
-        .build();
-
-    try (Response response = client.newCall(request).execute()) {
-      System.out.println("Response completed: " + response);
-    }
-  }
-```
-
-#### [Per-call Configuration](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PerCallSettings.java)
-
-All the HTTP client configuration lives in `OkHttpClient` including proxy settings, timeouts, and caches. When you need to change the configuration of a single call, call `OkHttpClient.newBuilder()`. This returns a builder that shares the same connection pool, dispatcher, and configuration with the original client. In the example below, we make one request with a 500 ms timeout and another with a 3000 ms timeout.
-
-```java
-  private final OkHttpClient client = new OkHttpClient();
-
-  public void run() throws Exception {
-    Request request = new Request.Builder()
-        .url("http://httpbin.org/delay/1") // This URL is served with a 1 second delay.
-        .build();
-
-    // Copy to customize OkHttp for this request.
-    OkHttpClient client1 = client.newBuilder()
-        .readTimeout(500, TimeUnit.MILLISECONDS)
-        .build();
-    try (Response response = client1.newCall(request).execute()) {
-      System.out.println("Response 1 succeeded: " + response);
-    } catch (IOException e) {
-      System.out.println("Response 1 failed: " + e);
-    }
-
-    // Copy to customize OkHttp for this request.
-    OkHttpClient client2 = client.newBuilder()
-        .readTimeout(3000, TimeUnit.MILLISECONDS)
-        .build();
-    try (Response response = client2.newCall(request).execute()) {
-      System.out.println("Response 2 succeeded: " + response);
-    } catch (IOException e) {
-      System.out.println("Response 2 failed: " + e);
-    }
-  }
-```
-
-#### [Handling authentication](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/Authenticate.java)
-
-OkHttp can automatically retry unauthenticated requests. When a response is `401 Not Authorized`, an `Authenticator` is asked to supply credentials. Implementations should build a new request that includes the missing credentials. If no credentials are available, return null to skip the retry.
-
-Use `Response.challenges()` to get the schemes and realms of any authentication challenges. When fulfilling a `Basic` challenge, use `Credentials.basic(username, password)` to encode the request header.
-
-```java
-  private final OkHttpClient client;
-
-  public Authenticate() {
-    client = new OkHttpClient.Builder()
-        .authenticator(new Authenticator() {
-          @Override public Request authenticate(Route route, Response response) throws IOException {
-            if (response.request().header("Authorization") != null) {
-              return null; // Give up, we've already attempted to authenticate.
-            }
-
-            System.out.println("Authenticating for response: " + response);
-            System.out.println("Challenges: " + response.challenges());
-            String credential = Credentials.basic("jesse", "password1");
-            return response.request().newBuilder()
-                .header("Authorization", credential)
-                .build();
-          }
-        })
-        .build();
-  }
-
-  public void run() throws Exception {
-    Request request = new Request.Builder()
-        .url("http://publicobject.com/secrets/hellosecret.txt")
-        .build();
-
-    try (Response response = client.newCall(request).execute()) {
-      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-      System.out.println(response.body().string());
-    }
-  }
-```
-
-To avoid making many retries when authentication isn't working, you can return null to give up. For example, you may want to skip the retry when these exact credentials have already been attempted:
-
-```java
-  if (credential.equals(response.request().header("Authorization"))) {
-    return null; // If we already failed with these credentials, don't retry.
-   }
-```
-
-You may also skip the retry when you‚Äôve hit an application-defined attempt limit:
-
-```java
-  if (responseCount(response) >= 3) {
-    return null; // If we've failed 3 times, give up.
-  }
-```
-
-This above code relies on this `responseCount()` method:
-
-```java
-  private int responseCount(Response response) {
-    int result = 1;
-    while ((response = response.priorResponse()) != null) {
-      result++;
-    }
-    return result;
-  }
-```
-
-
-----
-
-<table><tr>
-  <td width="25%" align="left"><a href="CONNECTIONS.md">‚Üê Connections</a></td>
-  <td width="50%" align="center">OkHttp User's Guide</td>
-  <td width="25%" align="right"><a href="INTERCEPTORS.md">Interceptors ‚Üí</a></td>
-</tr></table>
diff --git a/SECURITY.md b/SECURITY.md
deleted file mode 100644
index 8efac6ea61..0000000000
--- a/SECURITY.md
+++ /dev/null
@@ -1,20 +0,0 @@
-Security Policy
-===============
-
-## Supported Versions
-
-| Version | Supported          | Notes          |
-| ------- | ------------------ | -------------- |
-| 4.x     | :x:                | Not released.  |
-| 3.14.x  | :white_check_mark: |                |
-| 3.12.x  | :white_check_mark: | Android 2.3+ (API level 9+) and Java 7+.  Platforms may not support TLSv1.2. Until December 31, 2020  |
-| 2.7.x   | :x:                | Not supported. |
-
-## Reporting a Vulnerability
-
-Square recognizes the important contributions the security research community
-can make. We therefore encourage reporting security issues with the code
-contained in this repository.
-
-If you believe you have discovered a security vulnerability, please follow the
-guidelines at https://hackerone.com/square-open-source
diff --git a/TLS_CONFIGURATION_HISTORY.md b/TLS_CONFIGURATION_HISTORY.md
deleted file mode 100644
index 7ed6e3f5c0..0000000000
--- a/TLS_CONFIGURATION_HISTORY.md
+++ /dev/null
@@ -1,264 +0,0 @@
-TLS Configuration History
-=========================
-
-OkHttp tracks the dynamic TLS ecosystem to balance connectivity and security. This page is a log of
-changes we've made over time to OkHttp's default TLS options.
-
-[OkHttp 3.14][OkHttp314]
-------------------------
-
-_2019-03-14_
-
-Remove 2 TLSv1.3 cipher suites that are neither available on OkHttp‚Äôs host platforms nor enabled in releases of Chrome and Firefox.
-
-##### RESTRICTED_TLS cipher suites
-
- * TLS_AES_128_GCM_SHA256[¬π][tlsv13_only]
- * TLS_AES_256_GCM_SHA384[¬π][tlsv13_only]
- * TLS_CHACHA20_POLY1305_SHA256[¬π][tlsv13_only]
- * TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
- * TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
- * TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
- * TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
- * TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
- * TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
- * **REMOVED:** ~~TLS_AES_128_CCM_SHA256[¬π][tlsv13_only]~~
- * **REMOVED:** ~~TLS_AES_128_CCM_8_SHA256[¬π][tlsv13_only]~~
-
-##### MODERN_TLS / COMPATIBLE_TLS cipher suites
-
- * TLS_AES_128_GCM_SHA256[¬π][tlsv13_only]
- * TLS_AES_256_GCM_SHA384[¬π][tlsv13_only]
- * TLS_CHACHA20_POLY1305_SHA256[¬π][tlsv13_only]
- * TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
- * TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
- * TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
- * TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
- * TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
- * TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
- * TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA[¬≤][http2_naughty]
- * TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA[¬≤][http2_naughty]
- * TLS_RSA_WITH_AES_128_GCM_SHA256[¬≤][http2_naughty]
- * TLS_RSA_WITH_AES_256_GCM_SHA384[¬≤][http2_naughty]
- * TLS_RSA_WITH_AES_128_CBC_SHA[¬≤][http2_naughty]
- * TLS_RSA_WITH_AES_256_CBC_SHA[¬≤][http2_naughty]
- * TLS_RSA_WITH_3DES_EDE_CBC_SHA[¬≤][http2_naughty]
- * **REMOVED:** ~~TLS_AES_128_CCM_SHA256[¬π][tlsv13_only]~~
- * **REMOVED:** ~~TLS_AES_128_CCM_8_SHA256[¬π][tlsv13_only]~~
-
-[OkHttp 3.13][OkHttp313]
-------------------------
-
-_2019-02-04_
-
-Remove TLSv1.1 and TLSv1 from MODERN_TLS. Change COMPATIBLE_TLS to support all TLS versions.
-
-##### RESTRICTED_TLS versions
-
-* TLSv1.3
-* TLSv1.2
-
-##### MODERN_TLS versions
-
-* TLSv1.3
-* TLSv1.2
-* **REMOVED:** ~~TLSv1.1~~
-* **REMOVED:** ~~TLSv1~~
-
-##### COMPATIBLE_TLS versions
-
-* **NEW:** TLSv1.3
-* **NEW:** TLSv1.2
-* **NEW:** TLSv1.1
-* TLSv1
-
-[OkHttp 3.12][OkHttp312]
-------------------------
-
-_2018-11-16_
-
-Added support for TLSv1.3.
-
-##### RESTRICTED_TLS cipher suites
-
- * **NEW:** TLS_AES_128_GCM_SHA256[¬π][tlsv13_only]
- * **NEW:** TLS_AES_256_GCM_SHA384[¬π][tlsv13_only]
- * **NEW:** TLS_CHACHA20_POLY1305_SHA256[¬π][tlsv13_only]
- * **NEW:** TLS_AES_128_CCM_SHA256[¬π][tlsv13_only]
- * **NEW:** TLS_AES_128_CCM_8_SHA256[¬π][tlsv13_only]
- * TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
- * TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
- * TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
- * TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
- * TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
- * TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
-
-##### MODERN_TLS / COMPATIBLE_TLS cipher suites
-
- * **NEW:** TLS_AES_128_GCM_SHA256[¬π][tlsv13_only]
- * **NEW:** TLS_AES_256_GCM_SHA384[¬π][tlsv13_only]
- * **NEW:** TLS_CHACHA20_POLY1305_SHA256[¬π][tlsv13_only]
- * **NEW:** TLS_AES_128_CCM_SHA256[¬π][tlsv13_only]
- * **NEW:** TLS_AES_128_CCM_8_SHA256[¬π][tlsv13_only]
- * TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
- * TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
- * TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
- * TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
- * TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
- * TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
- * TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA[¬≤][http2_naughty]
- * TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA[¬≤][http2_naughty]
- * TLS_RSA_WITH_AES_128_GCM_SHA256[¬≤][http2_naughty]
- * TLS_RSA_WITH_AES_256_GCM_SHA384[¬≤][http2_naughty]
- * TLS_RSA_WITH_AES_128_CBC_SHA[¬≤][http2_naughty]
- * TLS_RSA_WITH_AES_256_CBC_SHA[¬≤][http2_naughty]
- * TLS_RSA_WITH_3DES_EDE_CBC_SHA[¬≤][http2_naughty]
-
-##### RESTRICTED_TLS versions
-
-* **NEW:** TLSv1.3
-* TLSv1.2
-
-##### MODERN_TLS versions
-
-* **NEW:** TLSv1.3
-* TLSv1.2
-* TLSv1.1
-* TLSv1
-
-##### COMPATIBLE_TLS versions
-
-* TLSv1
-
-[OkHttp 3.11][OkHttp311]
-------------------------
-
-_2018-07-12_
-
-Added a new extra strict RESTRICTED_TLS configuration inspired by [Google Cloud‚Äôs similar policy][googlecloud_ssl_policy]. It is appropriate when both the host platform
-(JVM/Conscrypt/Android) and target webserver are current.
-
-##### RESTRICTED_TLS cipher suites
-
- * TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
- * TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
- * TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
- * TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
- * TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
- * TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
-
-##### RESTRICTED_TLS versions
-
- * TLSv1.2
-
-[OkHttp 3.10][OkHttp310]
-------------------------
-
-_2018-02-24_
-
-Remove two rarely-used cipher suites from the default set. This tracks a <a href="https://developers.google.com/web/updates/2016/12/chrome-56-deprecations#remove_cbc-mode_ecdsa_ciphers_in_tls">Chromium change</a> to remove these cipher suites because they are fragile and rarely-used.
-
-##### MODERN_TLS / COMPATIBLE_TLS cipher suites
-
- * TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
- * TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
- * TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
- * TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
- * TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
- * TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
- * TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA[¬≤][http2_naughty]
- * TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA[¬≤][http2_naughty]
- * TLS_RSA_WITH_AES_128_GCM_SHA256[¬≤][http2_naughty]
- * TLS_RSA_WITH_AES_256_GCM_SHA384[¬≤][http2_naughty]
- * TLS_RSA_WITH_AES_128_CBC_SHA[¬≤][http2_naughty]
- * TLS_RSA_WITH_AES_256_CBC_SHA[¬≤][http2_naughty]
- * TLS_RSA_WITH_3DES_EDE_CBC_SHA[¬≤][http2_naughty]
- * **REMOVED:** ~~TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA~~
- * **REMOVED:** ~~TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA~~
-
-
-[OkHttp 3.5][OkHttp35]
-----------------------
-
-_2016-11-30_
-
-Remove three old cipher suites and add five new ones. This tracks changes in what's available on
-Android and Java, and also what cipher suites recent releases of Chrome and Firefox support by
-default.
-
-##### MODERN_TLS / COMPATIBLE_TLS cipher suites
-
- * TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
- * TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
- * **NEW:** TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
- * **NEW:** TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
- * **NEW:** TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
- * **NEW:** TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
- * TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA[¬≤][http2_naughty]
- * TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA[¬≤][http2_naughty]
- * TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA[¬≤][http2_naughty]
- * TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA[¬≤][http2_naughty]
- * TLS_RSA_WITH_AES_128_GCM_SHA256[¬≤][http2_naughty]
- * **NEW:** TLS_RSA_WITH_AES_256_GCM_SHA384[¬≤][http2_naughty]
- * TLS_RSA_WITH_AES_128_CBC_SHA[¬≤][http2_naughty]
- * TLS_RSA_WITH_AES_256_CBC_SHA[¬≤][http2_naughty]
- * TLS_RSA_WITH_3DES_EDE_CBC_SHA[¬≤][http2_naughty]
- * **REMOVED:** ~~TLS_DHE_RSA_WITH_AES_128_CBC_SHA~~
- * **REMOVED:** ~~TLS_DHE_RSA_WITH_AES_128_GCM_SHA256~~
- * **REMOVED:** ~~TLS_DHE_RSA_WITH_AES_256_CBC_SHA~~
-
-[OkHttp 3.0][OkHttp30]
-----------------------
-
-_2016-01-13_
-
-##### MODERN_TLS / COMPATIBLE_TLS cipher suites
-
- * TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
- * TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
- * TLS_DHE_RSA_WITH_AES_128_GCM_SHA256
- * TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA[¬≤][http2_naughty]
- * TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA[¬≤][http2_naughty]
- * TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA[¬≤][http2_naughty]
- * TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA[¬≤][http2_naughty]
- * TLS_DHE_RSA_WITH_AES_128_CBC_SHA[¬≤][http2_naughty]
- * TLS_DHE_RSA_WITH_AES_256_CBC_SHA[¬≤][http2_naughty]
- * TLS_RSA_WITH_AES_128_GCM_SHA256[¬≤][http2_naughty]
- * TLS_RSA_WITH_AES_128_CBC_SHA[¬≤][http2_naughty]
- * TLS_RSA_WITH_AES_256_CBC_SHA[¬≤][http2_naughty]
- * TLS_RSA_WITH_3DES_EDE_CBC_SHA[¬≤][http2_naughty]
-</dl>
-
-##### MODERN_TLS versions
-
- * TLSv1.2
- * TLSv1.1
- * TLSv1
-
-##### COMPATIBLE_TLS versions
-
- * TLSv1
-
----
-
-<a name="tlsv13_only"></a>
-#### ¬π TLSv1.3 Only
-
-Cipher suites that are only available with TLSv1.3.
-
-<a name="http2_naughty"></a>
-#### ¬≤ HTTP/2 Cipher Suite Denylist
-
-Cipher suites that are [discouraged for use][http2_denylist] with HTTP/2. OkHttp includes them because better suites are not commonly available. For example, none of the better cipher suites listed above shipped with Android 4.4 or Java 7.
-
- [OkHttp314]: https://github.com/square/okhttp/blob/master/CHANGELOG.md#version-3140
- [OkHttp313]: https://github.com/square/okhttp/blob/master/CHANGELOG.md#version-3130
- [OkHttp312]: https://github.com/square/okhttp/blob/master/CHANGELOG.md#version-3120
- [OkHttp311]: https://github.com/square/okhttp/blob/master/CHANGELOG.md#version-3110
- [OkHttp310]: https://github.com/square/okhttp/blob/master/CHANGELOG.md#version-3100
- [OkHttp35]: https://github.com/square/okhttp/blob/master/CHANGELOG.md#version-350
- [OkHttp30]: https://github.com/square/okhttp/blob/master/CHANGELOG.md#version-300
- [googlecloud_ssl_policy]: https://cloud.google.com/load-balancing/docs/ssl-policies-concepts
- [tlsv13_only]: #tlsv13_only
- [http2_naughty]: #http2_naughty
- [http2_denylist]: https://tools.ietf.org/html/rfc7540#appendix-A
diff --git a/WORKS_WITH_OKHTTP.md b/WORKS_WITH_OKHTTP.md
deleted file mode 100644
index c809918204..0000000000
--- a/WORKS_WITH_OKHTTP.md
+++ /dev/null
@@ -1,36 +0,0 @@
-Works with OkHttp
-=================
-
-Here‚Äôs some libraries that work nicely with OkHttp.
-
- * [Chuck](https://github.com/jgilfelt/chuck): An in-app HTTP inspector for Android OkHttp clients.
- * [Communicator](https://github.com/Taig/Communicator): An OkHttp wrapper for Scala built with Android in mind.
- * [CWAC-NetSecurity](https://github.com/commonsguy/cwac-netsecurity): Simplifying Secure Internet Access.
- * [Fresco](https://github.com/facebook/fresco): An Android library for managing images and the memory they use.
- * [Glide](https://github.com/bumptech/glide): An image loading and caching library for Android focused on smooth scrolling.
- * [GoogleAppEngineOkHttp](https://github.com/apkelly/GoogleAppEngineOkHttp): An OkHttp Call that works on Google App Engine.
- * [Hunter](https://github.com/Leaking/Hunter): Configure all OkHttpClients centrally.
- * [ModernHttpClient](https://github.com/paulcbetts/ModernHttpClient): Xamarin HTTP API that uses native implementations.
- * ‚¨úÔ∏è [Moshi](https://github.com/square/moshi): A modern JSON library for Android and Java.
- * [Ok2Curl](https://github.com/mrmike/Ok2Curl): Convert OkHttp requests into curl logs.
- * [OkHttp AWS Signer](https://github.com/babbel/okhttp-aws-signer): AWS V4 signing algorithm for OkHttp requests
- * [okhttp-digest](https://github.com/rburgst/okhttp-digest): A digest authenticator for OkHttp.
- * [OkHttp Idling Resource](https://github.com/JakeWharton/okhttp-idling-resource): An Espresso IdlingResource for OkHttp.
- * [okhttp-client-mock](https://github.com/gmazzo/okhttp-client-mock): A simple OKHttp client mock, using a programmable request interceptor.
- * [OkHttp Profiler](https://plugins.jetbrains.com/plugin/11249-okhttp-profiler): An IntelliJ plugin for monitoring OkHttp calls.
- * [OkReplay](https://github.com/airbnb/okreplay): Record and replay OkHttp network interaction in your tests.
- * [okhttp-signpost](https://github.com/pakerfeldt/okhttp-signpost): OAuth signing with signpost and OkHttp.
- * [okhttp-staleiferror-interceptor](https://github.com/PeelTechnologies/okhttp-staleiferror-interceptor/): serve stale responses when the server isn‚Äôt reachable.
- * [okhttp-stats](https://github.com/flipkart-incubator/okhttp-stats): Get stats like average network speed.
- * [OkHttp-Xamarin](https://github.com/paulcbetts/OkHttp-Xamarin): Xamarin bindings for OkHttp.
- * ‚¨úÔ∏è [Okio](https://github.com/square/okio/): A modern I/O API for Java.
- * [OkLog](https://github.com/simonpercic/OkLog): Response logging interceptor for OkHttp. Logs a URL link with URL-encoded response for every OkHttp call.
- * [Okurl](https://github.com/yschimke/okurl/wiki) A curl-like client for social networks and other APIs.
- * [PersistentCookieJar](https://github.com/franmontiel/PersistentCookieJar): A persistent `CookieJar`.
- * ‚¨úÔ∏è [Picasso](https://github.com/square/picasso): A powerful image downloading and caching library for Android.
- * ‚¨úÔ∏è [Retrofit](https://github.com/square/retrofit): Type-safe HTTP client for Android and Java by Square.
- * [Smash](https://github.com/appformation/smash): A Volley-inspired networking library.
- * [Stetho](https://github.com/facebook/stetho): Stetho is a debug bridge for Android applications.
- * [Thrifty](https://github.com/Microsoft/thrifty): An implementation of Apache Thrift for Android.
- * [Volley-OkHttp-Android](https://github.com/lxdvs/Volley-OkHttp-Android): A fork of Volley with changes to work with OkHttp.
- * ‚¨úÔ∏è [Wire](https://github.com/square/wire): Clean, lightweight protocol buffers for Android and Java.
diff --git a/checkstyle.xml b/checkstyle.xml
deleted file mode 100644
index 1e4d8e6d1d..0000000000
--- a/checkstyle.xml
+++ /dev/null
@@ -1,147 +0,0 @@
-<?xml version="1.0"?>
-<!DOCTYPE module PUBLIC
-    "-//Puppy Crawl//DTD Check Configuration 1.3//EN"
-    "http://www.puppycrawl.com/dtds/configuration_1_3.dtd">
-
-<module name="Checker">
-  <module name="SuppressWarningsFilter"/>
-  <module name="NewlineAtEndOfFile"/>
-  <module name="FileLength"/>
-  <module name="FileTabCharacter"/>
-
-  <!-- Trailing spaces -->
-  <module name="RegexpSingleline">
-    <property name="format" value="\s+$"/>
-    <property name="message" value="Line has trailing spaces."/>
-  </module>
-
-  <!-- Space after 'for' and 'if' -->
-  <module name="RegexpSingleline">
-    <property name="format" value="^\s*(for|if)\b[^ ]"/>
-    <property name="message" value="Space needed before opening parenthesis."/>
-  </module>
-
-  <!-- For each spacing -->
-  <module name="RegexpSingleline">
-    <property name="format" value="^\s*for \(.*?([^ ]:|:[^ ])"/>
-    <property name="message" value="Space needed around ':' character."/>
-  </module>
-
-  <module name="TreeWalker">
-    <property name="cacheFile" value="${checkstyle.cache.file}"/>
-
-    <!-- Checks for Javadoc comments.                     -->
-    <!-- See http://checkstyle.sf.net/config_javadoc.html -->
-    <!--module name="JavadocMethod"/-->
-    <!--module name="JavadocType"/-->
-    <!--module name="JavadocVariable"/-->
-    <module name="JavadocStyle"/>
-
-
-    <!-- Checks for Naming Conventions.                  -->
-    <!-- See http://checkstyle.sf.net/config_naming.html -->
-    <!--<module name="ConstantName"/>-->
-    <module name="LocalFinalVariableName"/>
-    <module name="LocalVariableName"/>
-    <module name="MemberName"/>
-    <module name="MethodName"/>
-    <!--<module name="PackageName"/>-->
-    <module name="ParameterName"/>
-    <module name="StaticVariableName"/>
-    <module name="TypeName"/>
-
-
-    <!-- Checks for imports                              -->
-    <!-- See http://checkstyle.sf.net/config_import.html -->
-    <module name="AvoidStarImport"/>
-    <module name="IllegalImport"/>
-    <!-- defaults to sun.* packages -->
-    <module name="RedundantImport"/>
-    <module name="UnusedImports">
-      <property name="processJavadoc" value="true"/>
-    </module>
-
-
-    <!-- Checks for Size Violations.                    -->
-    <!-- See http://checkstyle.sf.net/config_sizes.html -->
-    <module name="LineLength">
-      <property name="max" value="100"/>
-    </module>
-    <module name="MethodLength">
-      <property name="max" value="200"/>
-    </module>
-
-
-    <!-- Checks for whitespace                               -->
-    <!-- See http://checkstyle.sf.net/config_whitespace.html -->
-    <module name="GenericWhitespace"/>
-    <!--<module name="EmptyForIteratorPad"/>-->
-    <module name="MethodParamPad"/>
-    <!--<module name="NoWhitespaceAfter"/>-->
-    <!--<module name="NoWhitespaceBefore"/>-->
-    <module name="OperatorWrap"/>
-    <module name="ParenPad"/>
-    <module name="TypecastParenPad"/>
-    <module name="WhitespaceAfter"/>
-    <module name="WhitespaceAround">
-      <property name="tokens"
-          value="ASSIGN, BAND, BAND_ASSIGN, BOR, BOR_ASSIGN, BSR, BSR_ASSIGN, BXOR, BXOR_ASSIGN,
-          COLON, DIV, DIV_ASSIGN, DO_WHILE, EQUAL, GE, GT, LAND, LCURLY, LE, LITERAL_CATCH,
-          LITERAL_DO, LITERAL_ELSE, LITERAL_FINALLY, LITERAL_FOR, LITERAL_IF, LITERAL_RETURN,
-          LITERAL_SWITCH, LITERAL_SYNCHRONIZED, LITERAL_TRY, LITERAL_WHILE, LOR, LT, MINUS,
-          MINUS_ASSIGN, MOD, MOD_ASSIGN, NOT_EQUAL, PLUS, PLUS_ASSIGN, QUESTION, SL, SLIST,
-          SL_ASSIGN, SR, SR_ASSIGN, STAR, STAR_ASSIGN, LITERAL_ASSERT, TYPE_EXTENSION_AND"/>
-    </module>
-
-
-    <!-- Modifier Checks                                    -->
-    <!-- See http://checkstyle.sf.net/config_modifiers.html -->
-    <module name="ModifierOrder"/>
-    <module name="RedundantModifier"/>
-
-
-    <!-- Checks for blocks. You know, those {}'s         -->
-    <!-- See http://checkstyle.sf.net/config_blocks.html -->
-    <module name="AvoidNestedBlocks"/>
-    <!--module name="EmptyBlock"/-->
-    <module name="LeftCurly"/>
-    <!--<module name="NeedBraces"/>-->
-    <module name="RightCurly"/>
-
-
-    <!-- Checks for common coding problems               -->
-    <!-- See http://checkstyle.sf.net/config_coding.html -->
-    <!--module name="AvoidInlineConditionals"/-->
-    <module name="CovariantEquals"/>
-    <module name="EmptyStatement"/>
-    <!--<module name="EqualsAvoidNull"/>-->
-    <module name="EqualsHashCode"/>
-    <!--module name="HiddenField"/-->
-    <module name="IllegalInstantiation"/>
-    <!--module name="InnerAssignment"/-->
-    <!--module name="MagicNumber"/-->
-    <!--module name="MissingSwitchDefault"/-->
-    <!--<module name="RedundantThrows"/>-->
-    <module name="SimplifyBooleanExpression"/>
-    <module name="SimplifyBooleanReturn"/>
-
-    <!-- Checks for class design                         -->
-    <!-- See http://checkstyle.sf.net/config_design.html -->
-    <!--module name="DesignForExtension"/-->
-    <!--<module name="FinalClass"/>-->
-    <module name="HideUtilityClassConstructor"/>
-    <module name="InterfaceIsType"/>
-    <!--module name="VisibilityModifier"/-->
-
-
-    <!-- Miscellaneous other checks.                   -->
-    <!-- See http://checkstyle.sf.net/config_misc.html -->
-    <module name="ArrayTypeStyle"/>
-    <!--module name="FinalParameters"/-->
-    <!--module name="TodoComment"/-->
-    <module name="UpperEll"/>
-
-    <!-- Make the @SuppressWarnings annotations available to Checkstyle -->
-    <module name="SuppressWarningsHolder"/>
-  </module>
-</module>
diff --git a/deploy_website.sh b/deploy_website.sh
deleted file mode 100755
index c9b7f156b0..0000000000
--- a/deploy_website.sh
+++ /dev/null
@@ -1,36 +0,0 @@
-#!/bin/bash
-
-set -ex
-
-REPO="git@github.com:square/okhttp.git"
-DIR=temp-clone
-
-# Delete any existing temporary website clone
-rm -rf $DIR
-
-# Clone the current repo into temp folder
-git clone $REPO $DIR
-
-# Move working directory into temp folder
-cd $DIR
-
-# Checkout and track the gh-pages branch
-git checkout -t origin/gh-pages
-
-# Delete everything that isn't versioned (1.x, 2.x)
-ls | grep -E -v '^\d+\.x$' | xargs rm -rf
-
-# Copy website files from real repo
-cp -R ../website/* .
-
-# Stage all files in git and create a commit
-git add .
-git add -u
-git commit -m "Website at $(date)"
-
-# Push the new files up to GitHub
-git push origin gh-pages
-
-# Delete our temp folder
-cd ..
-rm -rf $DIR
diff --git a/docs/images/events@2x.png b/docs/images/events@2x.png
deleted file mode 100644
index 24a2084772..0000000000
Binary files a/docs/images/events@2x.png and /dev/null differ
diff --git a/docs/images/events_with_failures@2x.png b/docs/images/events_with_failures@2x.png
deleted file mode 100644
index 7578c646fe..0000000000
Binary files a/docs/images/events_with_failures@2x.png and /dev/null differ
diff --git a/docs/images/events_with_failures_and_retries@2x.png b/docs/images/events_with_failures_and_retries@2x.png
deleted file mode 100644
index 55348a2681..0000000000
Binary files a/docs/images/events_with_failures_and_retries@2x.png and /dev/null differ
diff --git a/docs/images/interceptors@2x.png b/docs/images/interceptors@2x.png
deleted file mode 100644
index 3a832cffd0..0000000000
Binary files a/docs/images/interceptors@2x.png and /dev/null differ
diff --git a/mockwebserver/README.md b/mockwebserver/README.md
deleted file mode 100644
index 73503bb6d2..0000000000
--- a/mockwebserver/README.md
+++ /dev/null
@@ -1,170 +0,0 @@
-MockWebServer
-=============
-
-A scriptable web server for testing HTTP clients
-
-
-### Motivation
-
-This library makes it easy to test that your app Does The Right Thing when it
-makes HTTP and HTTPS calls. It lets you specify which responses to return and
-then verify that requests were made as expected.
-
-Because it exercises your full HTTP stack, you can be confident that you're
-testing everything. You can even copy & paste HTTP responses from your real web
-server to create representative test cases. Or test that your code survives in
-awkward-to-reproduce situations like 500 errors or slow-loading responses.
-
-
-### Example
-
-Use MockWebServer the same way that you use mocking frameworks like
-[Mockito](https://github.com/mockito/mockito):
-
-1. Script the mocks.
-2. Run application code.
-3. Verify that the expected requests were made.
-
-Here's a complete example:
-
-```java
-public void test() throws Exception {
-  // Create a MockWebServer. These are lean enough that you can create a new
-  // instance for every unit test.
-  MockWebServer server = new MockWebServer();
-
-  // Schedule some responses.
-  server.enqueue(new MockResponse().setBody("hello, world!"));
-  server.enqueue(new MockResponse().setBody("sup, bra?"));
-  server.enqueue(new MockResponse().setBody("yo dog"));
-
-  // Start the server.
-  server.start();
-
-  // Ask the server for its URL. You'll need this to make HTTP requests.
-  HttpUrl baseUrl = server.url("/v1/chat/");
-
-  // Exercise your application code, which should make those HTTP requests.
-  // Responses are returned in the same order that they are enqueued.
-  Chat chat = new Chat(baseUrl);
-
-  chat.loadMore();
-  assertEquals("hello, world!", chat.messages());
-
-  chat.loadMore();
-  chat.loadMore();
-  assertEquals(""
-      + "hello, world!\n"
-      + "sup, bra?\n"
-      + "yo dog", chat.messages());
-
-  // Optional: confirm that your app made the HTTP requests you were expecting.
-  RecordedRequest request1 = server.takeRequest();
-  assertEquals("/v1/chat/messages/", request1.getPath());
-  assertNotNull(request1.getHeader("Authorization"));
-
-  RecordedRequest request2 = server.takeRequest();
-  assertEquals("/v1/chat/messages/2", request2.getPath());
-
-  RecordedRequest request3 = server.takeRequest();
-  assertEquals("/v1/chat/messages/3", request3.getPath());
-
-  // Shut down the server. Instances cannot be reused.
-  server.shutdown();
-}
-```
-
-Your unit tests might move the `server` into a field so you can shut it down
-from your test's `tearDown()`.
-
-### API
-
-#### MockResponse
-
-Mock responses default to an empty response body and a `200` status code.
-You can set a custom body with a string, input stream or byte array. Also
-add headers with a fluent builder API.
-
-```java
-MockResponse response = new MockResponse()
-    .addHeader("Content-Type", "application/json; charset=utf-8")
-    .addHeader("Cache-Control", "no-cache")
-    .setBody("{}");
-```
-
-MockResponse can be used to simulate a slow network. This is useful for
-testing timeouts and interactive testing.
-
-```java
-response.throttleBody(1024, 1, TimeUnit.SECONDS);
-```
-
-
-#### RecordedRequest
-
-Verify requests by their method, path, HTTP version, body, and headers.
-
-```java
-RecordedRequest request = server.takeRequest();
-assertEquals("POST /v1/chat/send HTTP/1.1", request.getRequestLine());
-assertEquals("application/json; charset=utf-8", request.getHeader("Content-Type"));
-assertEquals("{}", request.getBody().readUtf8());
-```
-
-#### Dispatcher
-
-By default MockWebServer uses a queue to specify a series of responses. Use a
-Dispatcher to handle requests using another policy. One natural policy is to
-dispatch on the request path.
-You can, for example, filter the request instead of using `server.enqueue()`.
-
-```java
-final Dispatcher dispatcher = new Dispatcher() {
-
-    @Override
-    public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
-
-        if (request.getPath().equals("/v1/login/auth/")){
-            return new MockResponse().setResponseCode(200);
-        } else if (request.getPath().equals("v1/check/version/")){
-            return new MockResponse().setResponseCode(200).setBody("version=9");
-        } else if (request.getPath().equals("/v1/profile/info")) {
-            return new MockResponse().setResponseCode(200).setBody("{\\\"info\\\":{\\\"name\":\"Lucas Albuquerque\",\"age\":\"21\",\"gender\":\"male\"}}");
-        }
-        return new MockResponse().setResponseCode(404);
-    }
-};
-server.setDispatcher(dispatcher);
-```
-
-
-### Download
-
-Get MockWebServer via Maven:
-```xml
-<dependency>
-  <groupId>com.squareup.okhttp3</groupId>
-  <artifactId>mockwebserver</artifactId>
-  <version>(insert latest version)</version>
-  <scope>test</scope>
-</dependency>
-```
-
-or via Gradle 
-```groovy
-testImplementation 'com.squareup.okhttp3:mockwebserver:(insert latest version)'
-```
-
-### License
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
diff --git a/mockwebserver/pom.xml b/mockwebserver/pom.xml
deleted file mode 100644
index 40d59193fd..0000000000
--- a/mockwebserver/pom.xml
+++ /dev/null
@@ -1,89 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.14.3-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>mockwebserver</artifactId>
-  <name>MockWebServer</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-testing-support</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-tls</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-javadoc-plugin</artifactId>
-        <version>3.0.1</version>
-        <configuration>
-          <links>
-            <link>http://square.github.io/okhttp/javadoc/</link>
-            <link>http://square.github.io/okio/</link>
-          </links>
-        </configuration>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-assembly-plugin</artifactId>
-        <version>3.1.0</version>
-        <configuration>
-          <descriptorRefs>
-            <descriptorRef>jar-with-dependencies</descriptorRef>
-          </descriptorRefs>
-        </configuration>
-        <executions>
-          <execution>
-            <phase>package</phase>
-            <goals>
-              <goal>single</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-jar-plugin</artifactId>
-        <version>3.1.1</version>
-        <configuration>
-          <archive>
-            <manifestEntries>
-              <Automatic-Module-Name>okhttp3.mockwebserver</Automatic-Module-Name>
-            </manifestEntries>
-          </archive>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/mockwebserver/src/main/java/okhttp3/internal/duplex/MwsDuplexAccess.java b/mockwebserver/src/main/java/okhttp3/internal/duplex/MwsDuplexAccess.java
deleted file mode 100644
index d1eea00397..0000000000
--- a/mockwebserver/src/main/java/okhttp3/internal/duplex/MwsDuplexAccess.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.duplex;
-
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.internal.duplex.DuplexResponseBody;
-
-/**
- * Internal access to MockWebServer APIs. Don't use this, don't use internal, these APIs are not
- * stable.
- */
-public abstract class MwsDuplexAccess {
-  public static MwsDuplexAccess instance;
-
-  public abstract void setBody(MockResponse mockResponse, DuplexResponseBody duplexResponseBody);
-}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/Dispatcher.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/Dispatcher.java
deleted file mode 100644
index 9f4fc9fb66..0000000000
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/Dispatcher.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (C) 2012 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.mockwebserver;
-
-/** Handler for mock server requests. */
-public abstract class Dispatcher {
-  /**
-   * Returns a response to satisfy {@code request}. This method may block (for instance, to wait on
-   * a CountdownLatch).
-   */
-  public abstract MockResponse dispatch(RecordedRequest request) throws InterruptedException;
-
-  /**
-   * Returns an early guess of the next response, used for policy on how an incoming request should
-   * be received. The default implementation returns an empty response. Mischievous implementations
-   * can return other values to test HTTP edge cases, such as unhappy socket policies or throttled
-   * request bodies.
-   */
-  public MockResponse peek() {
-    return new MockResponse().setSocketPolicy(SocketPolicy.KEEP_OPEN);
-  }
-
-  /**
-   * Release any resources held by this dispatcher. Any requests that are currently being dispatched
-   * should return immediately. Responses returned after shutdown will not be transmitted: their
-   * socket connections have already been closed.
-   */
-  public void shutdown() {
-  }
-}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
deleted file mode 100644
index 2c9ad33b49..0000000000
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
+++ /dev/null
@@ -1,342 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.mockwebserver;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.TimeUnit;
-import okhttp3.Headers;
-import okhttp3.WebSocketListener;
-import okhttp3.internal.Internal;
-import okhttp3.internal.http2.Settings;
-import okhttp3.mockwebserver.internal.duplex.DuplexResponseBody;
-import okio.Buffer;
-
-/** A scripted response to be replayed by the mock web server. */
-public final class MockResponse implements Cloneable {
-  private static final String CHUNKED_BODY_HEADER = "Transfer-encoding: chunked";
-
-  private String status;
-  private Headers.Builder headers = new Headers.Builder();
-  private Headers.Builder trailers = new Headers.Builder();
-
-  private Buffer body;
-
-  private long throttleBytesPerPeriod = Long.MAX_VALUE;
-  private long throttlePeriodAmount = 1;
-  private TimeUnit throttlePeriodUnit = TimeUnit.SECONDS;
-
-  private SocketPolicy socketPolicy = SocketPolicy.KEEP_OPEN;
-  private int http2ErrorCode = -1;
-
-  private long bodyDelayAmount = 0;
-  private TimeUnit bodyDelayUnit = TimeUnit.MILLISECONDS;
-
-  private long headersDelayAmount = 0;
-  private TimeUnit headersDelayUnit = TimeUnit.MILLISECONDS;
-
-  private List<PushPromise> promises = new ArrayList<>();
-  private Settings settings;
-  private WebSocketListener webSocketListener;
-  private DuplexResponseBody duplexResponseBody;
-
-  /** Creates a new mock response with an empty body. */
-  public MockResponse() {
-    setResponseCode(200);
-    setHeader("Content-Length", 0);
-  }
-
-  @Override public MockResponse clone() {
-    try {
-      MockResponse result = (MockResponse) super.clone();
-      result.headers = headers.build().newBuilder();
-      result.promises = new ArrayList<>(promises);
-      return result;
-    } catch (CloneNotSupportedException e) {
-      throw new AssertionError();
-    }
-  }
-
-  /** Returns the HTTP response line, such as "HTTP/1.1 200 OK". */
-  public String getStatus() {
-    return status;
-  }
-
-  public MockResponse setResponseCode(int code) {
-    String reason = "Mock Response";
-    if (code >= 100 && code < 200) {
-      reason = "Informational";
-    } else if (code >= 200 && code < 300) {
-      reason = "OK";
-    } else if (code >= 300 && code < 400) {
-      reason = "Redirection";
-    } else if (code >= 400 && code < 500) {
-      reason = "Client Error";
-    } else if (code >= 500 && code < 600) {
-      reason = "Server Error";
-    }
-    return setStatus("HTTP/1.1 " + code + " " + reason);
-  }
-
-  public MockResponse setStatus(String status) {
-    this.status = status;
-    return this;
-  }
-
-  /** Returns the HTTP headers, such as "Content-Length: 0". */
-  public Headers getHeaders() {
-    return headers.build();
-  }
-
-  public Headers getTrailers() {
-    return trailers.build();
-  }
-
-  /**
-   * Removes all HTTP headers including any "Content-Length" and "Transfer-encoding" headers that
-   * were added by default.
-   */
-  public MockResponse clearHeaders() {
-    headers = new Headers.Builder();
-    return this;
-  }
-
-  /**
-   * Adds {@code header} as an HTTP header. For well-formed HTTP {@code header} should contain a
-   * name followed by a colon and a value.
-   */
-  public MockResponse addHeader(String header) {
-    headers.add(header);
-    return this;
-  }
-
-  /**
-   * Adds a new header with the name and value. This may be used to add multiple headers with the
-   * same name.
-   */
-  public MockResponse addHeader(String name, Object value) {
-    headers.add(name, String.valueOf(value));
-    return this;
-  }
-
-  /**
-   * Adds a new header with the name and value. This may be used to add multiple headers with the
-   * same name. Unlike {@link #addHeader(String, Object)} this does not validate the name and
-   * value.
-   */
-  public MockResponse addHeaderLenient(String name, Object value) {
-    Internal.instance.addLenient(headers, name, String.valueOf(value));
-    return this;
-  }
-
-  /**
-   * Removes all headers named {@code name}, then adds a new header with the name and value.
-   */
-  public MockResponse setHeader(String name, Object value) {
-    removeHeader(name);
-    return addHeader(name, value);
-  }
-
-  /** Replaces all headers with those specified. */
-  public MockResponse setHeaders(Headers headers) {
-    this.headers = headers.newBuilder();
-    return this;
-  }
-
-  /** Replaces all trailers with those specified. */
-  public MockResponse setTrailers(Headers trailers) {
-    this.trailers = trailers.newBuilder();
-    return this;
-  }
-
-  /** Removes all headers named {@code name}. */
-  public MockResponse removeHeader(String name) {
-    headers.removeAll(name);
-    return this;
-  }
-
-  boolean isDuplex() {
-    return duplexResponseBody != null;
-  }
-
-  DuplexResponseBody getDuplexResponseBody() {
-    return duplexResponseBody;
-  }
-
-  /** Returns a copy of the raw HTTP payload. */
-  public Buffer getBody() {
-    return body != null ? body.clone() : null;
-  }
-
-  public MockResponse setBody(Buffer body) {
-    setHeader("Content-Length", body.size());
-    this.body = body.clone(); // Defensive copy.
-    return this;
-  }
-
-  /** Sets the response body to the UTF-8 encoded bytes of {@code body}. */
-  public MockResponse setBody(String body) {
-    return setBody(new Buffer().writeUtf8(body));
-  }
-
-  MockResponse setBody(DuplexResponseBody duplexResponseBody) {
-    this.duplexResponseBody = duplexResponseBody;
-    return this;
-  }
-
-  /**
-   * Sets the response body to {@code body}, chunked every {@code maxChunkSize} bytes.
-   */
-  public MockResponse setChunkedBody(Buffer body, int maxChunkSize) {
-    removeHeader("Content-Length");
-    headers.add(CHUNKED_BODY_HEADER);
-
-    Buffer bytesOut = new Buffer();
-    while (!body.exhausted()) {
-      long chunkSize = Math.min(body.size(), maxChunkSize);
-      bytesOut.writeHexadecimalUnsignedLong(chunkSize);
-      bytesOut.writeUtf8("\r\n");
-      bytesOut.write(body, chunkSize);
-      bytesOut.writeUtf8("\r\n");
-    }
-    bytesOut.writeUtf8("0\r\n"); // Last chunk. Trailers follow!
-
-    this.body = bytesOut;
-    return this;
-  }
-
-  /**
-   * Sets the response body to the UTF-8 encoded bytes of {@code body}, chunked every {@code
-   * maxChunkSize} bytes.
-   */
-  public MockResponse setChunkedBody(String body, int maxChunkSize) {
-    return setChunkedBody(new Buffer().writeUtf8(body), maxChunkSize);
-  }
-
-  public SocketPolicy getSocketPolicy() {
-    return socketPolicy;
-  }
-
-  public MockResponse setSocketPolicy(SocketPolicy socketPolicy) {
-    this.socketPolicy = socketPolicy;
-    return this;
-  }
-
-  public int getHttp2ErrorCode() {
-    return http2ErrorCode;
-  }
-
-  /**
-   * Sets the <a href="https://tools.ietf.org/html/rfc7540#section-7">HTTP/2 error code</a> to be
-   * returned when resetting the stream. This is only valid with {@link
-   * SocketPolicy#RESET_STREAM_AT_START}.
-   */
-  public MockResponse setHttp2ErrorCode(int http2ErrorCode) {
-    this.http2ErrorCode = http2ErrorCode;
-    return this;
-  }
-
-  /**
-   * Throttles the request reader and response writer to sleep for the given period after each
-   * series of {@code bytesPerPeriod} bytes are transferred. Use this to simulate network behavior.
-   */
-  public MockResponse throttleBody(long bytesPerPeriod, long period, TimeUnit unit) {
-    this.throttleBytesPerPeriod = bytesPerPeriod;
-    this.throttlePeriodAmount = period;
-    this.throttlePeriodUnit = unit;
-    return this;
-  }
-
-  public long getThrottleBytesPerPeriod() {
-    return throttleBytesPerPeriod;
-  }
-
-  public long getThrottlePeriod(TimeUnit unit) {
-    return unit.convert(throttlePeriodAmount, throttlePeriodUnit);
-  }
-
-  /**
-   * Set the delayed time of the response body to {@code delay}. This applies to the response body
-   * only; response headers are not affected.
-   */
-  public MockResponse setBodyDelay(long delay, TimeUnit unit) {
-    bodyDelayAmount = delay;
-    bodyDelayUnit = unit;
-    return this;
-  }
-
-  public long getBodyDelay(TimeUnit unit) {
-    return unit.convert(bodyDelayAmount, bodyDelayUnit);
-  }
-
-  public MockResponse setHeadersDelay(long delay, TimeUnit unit) {
-    headersDelayAmount = delay;
-    headersDelayUnit = unit;
-    return this;
-  }
-
-  public long getHeadersDelay(TimeUnit unit) {
-    return unit.convert(headersDelayAmount, headersDelayUnit);
-  }
-
-  /**
-   * When {@link MockWebServer#setProtocols(java.util.List) protocols} include {@linkplain
-   * okhttp3.Protocol#HTTP_2}, this attaches a pushed stream to this response.
-   */
-  public MockResponse withPush(PushPromise promise) {
-    this.promises.add(promise);
-    return this;
-  }
-
-  /** Returns the streams the server will push with this response. */
-  public List<PushPromise> getPushPromises() {
-    return promises;
-  }
-
-  /**
-   * When {@linkplain MockWebServer#setProtocols(java.util.List) protocols} include {@linkplain
-   * okhttp3.Protocol#HTTP_2 HTTP/2}, this pushes {@code settings} before writing the response.
-   */
-  public MockResponse withSettings(Settings settings) {
-    this.settings = settings;
-    return this;
-  }
-
-  public Settings getSettings() {
-    return settings;
-  }
-
-  /**
-   * Attempts to perform a web socket upgrade on the connection. This will overwrite any previously
-   * set status or body.
-   */
-  public MockResponse withWebSocketUpgrade(WebSocketListener listener) {
-    setStatus("HTTP/1.1 101 Switching Protocols");
-    setHeader("Connection", "Upgrade");
-    setHeader("Upgrade", "websocket");
-    body = null;
-    webSocketListener = listener;
-    return this;
-  }
-
-  public WebSocketListener getWebSocketListener() {
-    return webSocketListener;
-  }
-
-  @Override public String toString() {
-    return status;
-  }
-}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
deleted file mode 100644
index 89c089a554..0000000000
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
+++ /dev/null
@@ -1,1093 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package okhttp3.mockwebserver;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.ProtocolException;
-import java.net.Proxy;
-import java.net.ServerSocket;
-import java.net.Socket;
-import java.net.SocketException;
-import java.security.SecureRandom;
-import java.security.cert.CertificateException;
-import java.security.cert.X509Certificate;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Locale;
-import java.util.Set;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import javax.net.ServerSocketFactory;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.Headers;
-import okhttp3.HttpUrl;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.Internal;
-import okhttp3.internal.NamedRunnable;
-import okhttp3.internal.Util;
-import okhttp3.internal.duplex.MwsDuplexAccess;
-import okhttp3.internal.http.HttpMethod;
-import okhttp3.internal.http2.ErrorCode;
-import okhttp3.internal.http2.Header;
-import okhttp3.internal.http2.Http2Connection;
-import okhttp3.internal.http2.Http2Stream;
-import okhttp3.internal.http2.Settings;
-import okhttp3.internal.platform.Platform;
-import okhttp3.internal.ws.RealWebSocket;
-import okhttp3.internal.ws.WebSocketProtocol;
-import okhttp3.mockwebserver.internal.duplex.DuplexResponseBody;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.Okio;
-import okio.Sink;
-import okio.Timeout;
-import org.junit.rules.ExternalResource;
-
-import static okhttp3.internal.Util.closeQuietly;
-import static okhttp3.mockwebserver.SocketPolicy.CONTINUE_ALWAYS;
-import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
-import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
-import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
-import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_DURING_REQUEST_BODY;
-import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY;
-import static okhttp3.mockwebserver.SocketPolicy.EXPECT_CONTINUE;
-import static okhttp3.mockwebserver.SocketPolicy.FAIL_HANDSHAKE;
-import static okhttp3.mockwebserver.SocketPolicy.NO_RESPONSE;
-import static okhttp3.mockwebserver.SocketPolicy.RESET_STREAM_AT_START;
-import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
-import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END;
-import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_SERVER_AFTER_RESPONSE;
-import static okhttp3.mockwebserver.SocketPolicy.STALL_SOCKET_AT_START;
-import static okhttp3.mockwebserver.SocketPolicy.UPGRADE_TO_SSL_AT_END;
-
-/**
- * A scriptable web server. Callers supply canned responses and the server replays them upon request
- * in sequence.
- */
-public final class MockWebServer extends ExternalResource implements Closeable {
-  static {
-    Internal.initializeInstanceForTests();
-    MwsDuplexAccess.instance = new MwsDuplexAccess() {
-      @Override public void setBody(
-          MockResponse mockResponse, DuplexResponseBody duplexResponseBody) {
-        mockResponse.setBody(duplexResponseBody);
-      }
-    };
-  }
-
-  private static final int CLIENT_AUTH_NONE = 0;
-  private static final int CLIENT_AUTH_REQUESTED = 1;
-  private static final int CLIENT_AUTH_REQUIRED = 2;
-
-  private static final X509TrustManager UNTRUSTED_TRUST_MANAGER = new X509TrustManager() {
-    @Override public void checkClientTrusted(X509Certificate[] chain, String authType)
-        throws CertificateException {
-      throw new CertificateException();
-    }
-
-    @Override public void checkServerTrusted(X509Certificate[] chain, String authType) {
-      throw new AssertionError();
-    }
-
-    @Override public X509Certificate[] getAcceptedIssuers() {
-      throw new AssertionError();
-    }
-  };
-
-  private static final Logger logger = Logger.getLogger(MockWebServer.class.getName());
-
-  private final BlockingQueue<RecordedRequest> requestQueue = new LinkedBlockingQueue<>();
-
-  private final Set<Socket> openClientSockets =
-      Collections.newSetFromMap(new ConcurrentHashMap<>());
-  private final Set<Http2Connection> openConnections =
-      Collections.newSetFromMap(new ConcurrentHashMap<>());
-  private final AtomicInteger requestCount = new AtomicInteger();
-  private long bodyLimit = Long.MAX_VALUE;
-  private ServerSocketFactory serverSocketFactory;
-  private ServerSocket serverSocket;
-  private SSLSocketFactory sslSocketFactory;
-  private ExecutorService executor;
-  private boolean tunnelProxy;
-  private int clientAuth = CLIENT_AUTH_NONE;
-  private Dispatcher dispatcher = new QueueDispatcher();
-
-  private int port = -1;
-  private InetSocketAddress inetSocketAddress;
-  private boolean protocolNegotiationEnabled = true;
-  private List<Protocol> protocols = Util.immutableList(Protocol.HTTP_2, Protocol.HTTP_1_1);
-
-  private boolean started;
-
-  @Override protected synchronized void before() {
-    if (started) return;
-    try {
-      start();
-    } catch (IOException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  public int getPort() {
-    before();
-    return port;
-  }
-
-  public String getHostName() {
-    before();
-    return inetSocketAddress.getAddress().getCanonicalHostName();
-  }
-
-  public Proxy toProxyAddress() {
-    before();
-    InetSocketAddress address = new InetSocketAddress(inetSocketAddress.getAddress()
-            .getCanonicalHostName(), getPort());
-    return new Proxy(Proxy.Type.HTTP, address);
-  }
-
-  public void setServerSocketFactory(ServerSocketFactory serverSocketFactory) {
-    if (executor != null) {
-      throw new IllegalStateException(
-          "setServerSocketFactory() must be called before start()");
-    }
-    this.serverSocketFactory = serverSocketFactory;
-  }
-
-  /**
-   * Returns a URL for connecting to this server.
-   *
-   * @param path the request path, such as "/".
-   */
-  public HttpUrl url(String path) {
-    return new HttpUrl.Builder()
-        .scheme(sslSocketFactory != null ? "https" : "http")
-        .host(getHostName())
-        .port(getPort())
-        .build()
-        .resolve(path);
-  }
-
-  /**
-   * Sets the number of bytes of the POST body to keep in memory to the given limit.
-   */
-  public void setBodyLimit(long maxBodyLength) {
-    this.bodyLimit = maxBodyLength;
-  }
-
-  /**
-   * Sets whether ALPN is used on incoming HTTPS connections to negotiate a protocol like HTTP/1.1
-   * or HTTP/2. Call this method to disable negotiation and restrict connections to HTTP/1.1.
-   */
-  public void setProtocolNegotiationEnabled(boolean protocolNegotiationEnabled) {
-    this.protocolNegotiationEnabled = protocolNegotiationEnabled;
-  }
-
-  /**
-   * Indicates the protocols supported by ALPN on incoming HTTPS connections. This list is ignored
-   * when {@link #setProtocolNegotiationEnabled negotiation is disabled}.
-   *
-   * @param protocols the protocols to use, in order of preference. The list must contain
-   * {@linkplain Protocol#HTTP_1_1}. It must not contain null.
-   */
-  public void setProtocols(List<Protocol> protocols) {
-    protocols = Util.immutableList(protocols);
-    if (protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE) && protocols.size() > 1) {
-      // when using h2_prior_knowledge, no other protocol should be supported.
-      throw new IllegalArgumentException(
-          "protocols containing h2_prior_knowledge cannot use other protocols: " + protocols);
-    } else if (!protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE)
-        && !protocols.contains(Protocol.HTTP_1_1)) {
-      throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
-    }
-    if (protocols.contains(null)) {
-      throw new IllegalArgumentException("protocols must not contain null");
-    }
-    this.protocols = protocols;
-  }
-
-  public List<Protocol> protocols() {
-    return protocols;
-  }
-
-  /**
-   * Serve requests with HTTPS rather than otherwise.
-   *
-   * @param tunnelProxy true to expect the HTTP CONNECT method before negotiating TLS.
-   */
-  public void useHttps(SSLSocketFactory sslSocketFactory, boolean tunnelProxy) {
-    this.sslSocketFactory = sslSocketFactory;
-    this.tunnelProxy = tunnelProxy;
-  }
-
-  /**
-   * Configure the server to not perform SSL authentication of the client. This leaves
-   * authentication to another layer such as in an HTTP cookie or header. This is the default and
-   * most common configuration.
-   */
-  public void noClientAuth() {
-    this.clientAuth = CLIENT_AUTH_NONE;
-  }
-
-  /**
-   * Configure the server to {@linkplain SSLSocket#setWantClientAuth want client auth}. If the
-   * client presents a certificate that is {@linkplain TrustManager trusted} the handshake will
-   * proceed normally. The connection will also proceed normally if the client presents no
-   * certificate at all! But if the client presents an untrusted certificate the handshake will fail
-   * and no connection will be established.
-   */
-  public void requestClientAuth() {
-    this.clientAuth = CLIENT_AUTH_REQUESTED;
-  }
-
-  /**
-   * Configure the server to {@linkplain SSLSocket#setNeedClientAuth need client auth}. If the
-   * client presents a certificate that is {@linkplain TrustManager trusted} the handshake will
-   * proceed normally. If the client presents an untrusted certificate or no certificate at all the
-   * handshake will fail and no connection will be established.
-   */
-  public void requireClientAuth() {
-    this.clientAuth = CLIENT_AUTH_REQUIRED;
-  }
-
-  /**
-   * Awaits the next HTTP request, removes it, and returns it. Callers should use this to verify the
-   * request was sent as intended. This method will block until the request is available, possibly
-   * forever.
-   *
-   * @return the head of the request queue
-   */
-  public RecordedRequest takeRequest() throws InterruptedException {
-    return requestQueue.take();
-  }
-
-  /**
-   * Awaits the next HTTP request (waiting up to the specified wait time if necessary), removes it,
-   * and returns it. Callers should use this to verify the request was sent as intended within the
-   * given time.
-   *
-   * @param timeout how long to wait before giving up, in units of {@code unit}
-   * @param unit a {@code TimeUnit} determining how to interpret the {@code timeout} parameter
-   * @return the head of the request queue
-   */
-  public RecordedRequest takeRequest(long timeout, TimeUnit unit) throws InterruptedException {
-    return requestQueue.poll(timeout, unit);
-  }
-
-  /**
-   * Returns the number of HTTP requests received thus far by this server. This may exceed the
-   * number of HTTP connections when connection reuse is in practice.
-   */
-  public int getRequestCount() {
-    return requestCount.get();
-  }
-
-  /**
-   * Scripts {@code response} to be returned to a request made in sequence. The first request is
-   * served by the first enqueued response; the second request by the second enqueued response; and
-   * so on.
-   *
-   * @throws ClassCastException if the default dispatcher has been replaced with {@link
-   * #setDispatcher(Dispatcher)}.
-   */
-  public void enqueue(MockResponse response) {
-    ((QueueDispatcher) dispatcher).enqueueResponse(response.clone());
-  }
-
-  /** Equivalent to {@code start(0)}. */
-  public void start() throws IOException {
-    start(0);
-  }
-
-  /**
-   * Starts the server on the loopback interface for the given port.
-   *
-   * @param port the port to listen to, or 0 for any available port. Automated tests should always
-   * use port 0 to avoid flakiness when a specific port is unavailable.
-   */
-  public void start(int port) throws IOException {
-    start(InetAddress.getByName("localhost"), port);
-  }
-
-  /**
-   * Starts the server on the given address and port.
-   *
-   * @param inetAddress the address to create the server socket on
-   * @param port the port to listen to, or 0 for any available port. Automated tests should always
-   * use port 0 to avoid flakiness when a specific port is unavailable.
-   */
-  public void start(InetAddress inetAddress, int port) throws IOException {
-    start(new InetSocketAddress(inetAddress, port));
-  }
-
-  /**
-   * Starts the server and binds to the given socket address.
-   *
-   * @param inetSocketAddress the socket address to bind the server on
-   */
-  private synchronized void start(InetSocketAddress inetSocketAddress) throws IOException {
-    if (started) throw new IllegalStateException("start() already called");
-    started = true;
-
-    executor = Executors.newCachedThreadPool(Util.threadFactory("MockWebServer", false));
-    this.inetSocketAddress = inetSocketAddress;
-
-    if (serverSocketFactory == null) {
-      serverSocketFactory = ServerSocketFactory.getDefault();
-    }
-    serverSocket = serverSocketFactory.createServerSocket();
-
-    // Reuse if the user specified a port
-    serverSocket.setReuseAddress(inetSocketAddress.getPort() != 0);
-    serverSocket.bind(inetSocketAddress, 50);
-
-    port = serverSocket.getLocalPort();
-    executor.execute(new NamedRunnable("MockWebServer %s", port) {
-      @Override protected void execute() {
-        try {
-          logger.info(MockWebServer.this + " starting to accept connections");
-          acceptConnections();
-        } catch (Throwable e) {
-          logger.log(Level.WARNING, MockWebServer.this + " failed unexpectedly", e);
-        }
-
-        // Release all sockets and all threads, even if any close fails.
-        closeQuietly(serverSocket);
-        for (Iterator<Socket> s = openClientSockets.iterator(); s.hasNext(); ) {
-          closeQuietly(s.next());
-          s.remove();
-        }
-        for (Iterator<Http2Connection> s = openConnections.iterator(); s.hasNext(); ) {
-          closeQuietly(s.next());
-          s.remove();
-        }
-        dispatcher.shutdown();
-        executor.shutdown();
-      }
-
-      private void acceptConnections() throws Exception {
-        while (true) {
-          Socket socket;
-          try {
-            socket = serverSocket.accept();
-          } catch (SocketException e) {
-            logger.info(MockWebServer.this + " done accepting connections: " + e.getMessage());
-            return;
-          }
-          SocketPolicy socketPolicy = dispatcher.peek().getSocketPolicy();
-          if (socketPolicy == DISCONNECT_AT_START) {
-            dispatchBookkeepingRequest(0, socket);
-            socket.close();
-          } else {
-            openClientSockets.add(socket);
-            serveConnection(socket);
-          }
-        }
-      }
-    });
-  }
-
-  public synchronized void shutdown() throws IOException {
-    if (!started) return;
-    if (serverSocket == null) throw new IllegalStateException("shutdown() before start()");
-
-    // Cause acceptConnections() to break out.
-    serverSocket.close();
-
-    // Await shutdown.
-    try {
-      if (!executor.awaitTermination(5, TimeUnit.SECONDS)) {
-        throw new IOException("Gave up waiting for executor to shut down");
-      }
-    } catch (InterruptedException e) {
-      throw new AssertionError();
-    }
-  }
-
-  @Override protected synchronized void after() {
-    try {
-      shutdown();
-    } catch (IOException e) {
-      logger.log(Level.WARNING, "MockWebServer shutdown failed", e);
-    }
-  }
-
-  private void serveConnection(final Socket raw) {
-    executor.execute(new NamedRunnable("MockWebServer %s", raw.getRemoteSocketAddress()) {
-      int sequenceNumber = 0;
-
-      @Override protected void execute() {
-        try {
-          processConnection();
-        } catch (IOException e) {
-          logger.info(
-              MockWebServer.this + " connection from " + raw.getInetAddress() + " failed: " + e);
-        } catch (Exception e) {
-          logger.log(Level.SEVERE,
-              MockWebServer.this + " connection from " + raw.getInetAddress() + " crashed", e);
-        }
-      }
-
-      public void processConnection() throws Exception {
-        SocketPolicy socketPolicy = dispatcher.peek().getSocketPolicy();
-        Protocol protocol = Protocol.HTTP_1_1;
-        Socket socket;
-        if (sslSocketFactory != null) {
-          if (tunnelProxy) {
-            createTunnel();
-          }
-          if (socketPolicy == FAIL_HANDSHAKE) {
-            dispatchBookkeepingRequest(sequenceNumber, raw);
-            processHandshakeFailure(raw);
-            return;
-          }
-          socket = sslSocketFactory.createSocket(raw, raw.getInetAddress().getHostAddress(),
-              raw.getPort(), true);
-          SSLSocket sslSocket = (SSLSocket) socket;
-          sslSocket.setUseClientMode(false);
-          if (clientAuth == CLIENT_AUTH_REQUIRED) {
-            sslSocket.setNeedClientAuth(true);
-          } else if (clientAuth == CLIENT_AUTH_REQUESTED) {
-            sslSocket.setWantClientAuth(true);
-          }
-          openClientSockets.add(socket);
-
-          if (protocolNegotiationEnabled) {
-            Platform.get().configureTlsExtensions(sslSocket, null, protocols);
-          }
-
-          sslSocket.startHandshake();
-
-          if (protocolNegotiationEnabled) {
-            String protocolString = Platform.get().getSelectedProtocol(sslSocket);
-            protocol = protocolString != null ? Protocol.get(protocolString) : Protocol.HTTP_1_1;
-            Platform.get().afterHandshake(sslSocket);
-          }
-          openClientSockets.remove(raw);
-        } else if (protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE)) {
-          socket = raw;
-          protocol = Protocol.H2_PRIOR_KNOWLEDGE;
-        } else {
-          socket = raw;
-        }
-
-        if (socketPolicy == STALL_SOCKET_AT_START) {
-          return; // Ignore the socket until the server is shut down!
-        }
-
-        if (protocol == Protocol.HTTP_2 || protocol == Protocol.H2_PRIOR_KNOWLEDGE) {
-          Http2SocketHandler http2SocketHandler = new Http2SocketHandler(socket, protocol);
-          Http2Connection connection = new Http2Connection.Builder(false)
-              .socket(socket)
-              .listener(http2SocketHandler)
-              .build();
-          connection.start();
-          openConnections.add(connection);
-          openClientSockets.remove(socket);
-          return;
-        } else if (protocol != Protocol.HTTP_1_1) {
-          throw new AssertionError();
-        }
-
-        BufferedSource source = Okio.buffer(Okio.source(socket));
-        BufferedSink sink = Okio.buffer(Okio.sink(socket));
-
-        while (processOneRequest(socket, source, sink)) {
-        }
-
-        if (sequenceNumber == 0) {
-          logger.warning(MockWebServer.this
-              + " connection from "
-              + raw.getInetAddress()
-              + " didn't make a request");
-        }
-
-        socket.close();
-        openClientSockets.remove(socket);
-      }
-
-      /**
-       * Respond to CONNECT requests until a SWITCH_TO_SSL_AT_END response is
-       * dispatched.
-       */
-      private void createTunnel() throws IOException, InterruptedException {
-        BufferedSource source = Okio.buffer(Okio.source(raw));
-        BufferedSink sink = Okio.buffer(Okio.sink(raw));
-        while (true) {
-          SocketPolicy socketPolicy = dispatcher.peek().getSocketPolicy();
-          if (!processOneRequest(raw, source, sink)) {
-            throw new IllegalStateException("Tunnel without any CONNECT!");
-          }
-          if (socketPolicy == UPGRADE_TO_SSL_AT_END) return;
-        }
-      }
-
-      /**
-       * Reads a request and writes its response. Returns true if further calls should be attempted
-       * on the socket.
-       */
-      private boolean processOneRequest(Socket socket, BufferedSource source, BufferedSink sink)
-          throws IOException, InterruptedException {
-        RecordedRequest request = readRequest(socket, source, sink, sequenceNumber);
-        if (request == null) return false;
-
-        requestCount.incrementAndGet();
-        requestQueue.add(request);
-
-        MockResponse response = dispatcher.dispatch(request);
-        if (response.getSocketPolicy() == DISCONNECT_AFTER_REQUEST) {
-          socket.close();
-          return false;
-        }
-        if (response.getSocketPolicy() == NO_RESPONSE) {
-          // This read should block until the socket is closed. (Because nobody is writing.)
-          if (source.exhausted()) return false;
-          throw new ProtocolException("unexpected data");
-        }
-
-        boolean reuseSocket = true;
-        boolean requestWantsWebSockets = "Upgrade".equalsIgnoreCase(request.getHeader("Connection"))
-            && "websocket".equalsIgnoreCase(request.getHeader("Upgrade"));
-        boolean responseWantsWebSockets = response.getWebSocketListener() != null;
-        if (requestWantsWebSockets && responseWantsWebSockets) {
-          handleWebSocketUpgrade(socket, source, sink, request, response);
-          reuseSocket = false;
-        } else {
-          writeHttpResponse(socket, sink, response);
-        }
-
-        if (logger.isLoggable(Level.INFO)) {
-          logger.info(MockWebServer.this + " received request: " + request
-              + " and responded: " + response);
-        }
-
-        // See warnings associated with these socket policies in SocketPolicy.
-        if (response.getSocketPolicy() == DISCONNECT_AT_END) {
-          socket.close();
-          return false;
-        } else if (response.getSocketPolicy() == SHUTDOWN_INPUT_AT_END) {
-          socket.shutdownInput();
-        } else if (response.getSocketPolicy() == SHUTDOWN_OUTPUT_AT_END) {
-          socket.shutdownOutput();
-        } else if (response.getSocketPolicy() == SHUTDOWN_SERVER_AFTER_RESPONSE) {
-          shutdown();
-        }
-
-        sequenceNumber++;
-        return reuseSocket;
-      }
-    });
-  }
-
-  private void processHandshakeFailure(Socket raw) throws Exception {
-    SSLContext context = SSLContext.getInstance("TLS");
-    context.init(null, new TrustManager[] {UNTRUSTED_TRUST_MANAGER}, new SecureRandom());
-    SSLSocketFactory sslSocketFactory = context.getSocketFactory();
-    SSLSocket socket = (SSLSocket) sslSocketFactory.createSocket(
-        raw, raw.getInetAddress().getHostAddress(), raw.getPort(), true);
-    try {
-      socket.startHandshake(); // we're testing a handshake failure
-      throw new AssertionError();
-    } catch (IOException expected) {
-    }
-    socket.close();
-  }
-
-  private void dispatchBookkeepingRequest(int sequenceNumber, Socket socket)
-      throws InterruptedException {
-    RecordedRequest request = new RecordedRequest(
-        null, null, null, -1, null, sequenceNumber, socket);
-    requestCount.incrementAndGet();
-    requestQueue.add(request);
-    dispatcher.dispatch(request);
-  }
-
-  /** @param sequenceNumber the index of this request on this connection. */
-  private RecordedRequest readRequest(Socket socket, BufferedSource source, BufferedSink sink,
-      int sequenceNumber) throws IOException {
-    String request;
-    try {
-      request = source.readUtf8LineStrict();
-    } catch (IOException streamIsClosed) {
-      return null; // no request because we closed the stream
-    }
-    if (request.length() == 0) {
-      return null; // no request because the stream is exhausted
-    }
-
-    Headers.Builder headers = new Headers.Builder();
-    long contentLength = -1;
-    boolean chunked = false;
-    boolean expectContinue = false;
-    String header;
-    while ((header = source.readUtf8LineStrict()).length() != 0) {
-      Internal.instance.addLenient(headers, header);
-      String lowercaseHeader = header.toLowerCase(Locale.US);
-      if (contentLength == -1 && lowercaseHeader.startsWith("content-length:")) {
-        contentLength = Long.parseLong(header.substring(15).trim());
-      }
-      if (lowercaseHeader.startsWith("transfer-encoding:")
-          && lowercaseHeader.substring(18).trim().equals("chunked")) {
-        chunked = true;
-      }
-      if (lowercaseHeader.startsWith("expect:")
-          && lowercaseHeader.substring(7).trim().equalsIgnoreCase("100-continue")) {
-        expectContinue = true;
-      }
-    }
-
-    final SocketPolicy socketPolicy = dispatcher.peek().getSocketPolicy();
-    if (expectContinue && socketPolicy == EXPECT_CONTINUE || socketPolicy == CONTINUE_ALWAYS) {
-      sink.writeUtf8("HTTP/1.1 100 Continue\r\n");
-      sink.writeUtf8("Content-Length: 0\r\n");
-      sink.writeUtf8("\r\n");
-      sink.flush();
-    }
-
-    boolean hasBody = false;
-    TruncatingBuffer requestBody = new TruncatingBuffer(bodyLimit);
-    List<Integer> chunkSizes = new ArrayList<>();
-    MockResponse policy = dispatcher.peek();
-    if (contentLength != -1) {
-      hasBody = contentLength > 0;
-      throttledTransfer(policy, socket, source, Okio.buffer(requestBody), contentLength, true);
-    } else if (chunked) {
-      hasBody = true;
-      while (true) {
-        int chunkSize = Integer.parseInt(source.readUtf8LineStrict().trim(), 16);
-        if (chunkSize == 0) {
-          readEmptyLine(source);
-          break;
-        }
-        chunkSizes.add(chunkSize);
-        throttledTransfer(policy, socket, source, Okio.buffer(requestBody), chunkSize, true);
-        readEmptyLine(source);
-      }
-    }
-
-    String method = request.substring(0, request.indexOf(' '));
-    if (hasBody && !HttpMethod.permitsRequestBody(method)) {
-      throw new IllegalArgumentException("Request must not have a body: " + request);
-    }
-
-    return new RecordedRequest(request, headers.build(), chunkSizes, requestBody.receivedByteCount,
-        requestBody.buffer, sequenceNumber, socket);
-  }
-
-  private void handleWebSocketUpgrade(Socket socket, BufferedSource source, BufferedSink sink,
-      RecordedRequest request, MockResponse response) throws IOException {
-    String key = request.getHeader("Sec-WebSocket-Key");
-    response.setHeader("Sec-WebSocket-Accept", WebSocketProtocol.acceptHeader(key));
-
-    writeHttpResponse(socket, sink, response);
-
-    // Adapt the request and response into our Request and Response domain model.
-    String scheme = request.getTlsVersion() != null ? "https" : "http";
-    String authority = request.getHeader("Host"); // Has host and port.
-    final Request fancyRequest = new Request.Builder()
-        .url(scheme + "://" + authority + "/")
-        .headers(request.getHeaders())
-        .build();
-    final Response fancyResponse = new Response.Builder()
-        .code(Integer.parseInt(response.getStatus().split(" ")[1]))
-        .message(response.getStatus().split(" ", 3)[2])
-        .headers(response.getHeaders())
-        .request(fancyRequest)
-        .protocol(Protocol.HTTP_1_1)
-        .build();
-
-    final CountDownLatch connectionClose = new CountDownLatch(1);
-    RealWebSocket.Streams streams = new RealWebSocket.Streams(false, source, sink) {
-      @Override public void close() {
-        connectionClose.countDown();
-      }
-    };
-    RealWebSocket webSocket = new RealWebSocket(fancyRequest,
-        response.getWebSocketListener(), new SecureRandom(), 0);
-    response.getWebSocketListener().onOpen(webSocket, fancyResponse);
-    String name = "MockWebServer WebSocket " + request.getPath();
-    webSocket.initReaderAndWriter(name, streams);
-    try {
-      webSocket.loopReader();
-
-      // Even if messages are no longer being read we need to wait for the connection close signal.
-      try {
-        connectionClose.await();
-      } catch (InterruptedException e) {
-        throw new AssertionError(e);
-      }
-
-    } catch (IOException e) {
-      webSocket.failWebSocket(e, null);
-    } finally {
-      closeQuietly(source);
-    }
-  }
-
-  private void writeHttpResponse(Socket socket, BufferedSink sink, MockResponse response)
-      throws IOException {
-    sleepIfDelayed(response.getHeadersDelay(TimeUnit.MILLISECONDS));
-    sink.writeUtf8(response.getStatus());
-    sink.writeUtf8("\r\n");
-
-    writeHeaders(sink, response.getHeaders());
-
-    Buffer body = response.getBody();
-    if (body == null) return;
-    sleepIfDelayed(response.getBodyDelay(TimeUnit.MILLISECONDS));
-    throttledTransfer(response, socket, body, sink, body.size(), false);
-
-    if ("chunked".equalsIgnoreCase(response.getHeaders().get("Transfer-Encoding"))) {
-      writeHeaders(sink, response.getTrailers());
-    }
-  }
-
-  private void writeHeaders(BufferedSink sink, Headers headers) throws IOException {
-    for (int i = 0, size = headers.size(); i < size; i++) {
-      sink.writeUtf8(headers.name(i));
-      sink.writeUtf8(": ");
-      sink.writeUtf8(headers.value(i));
-      sink.writeUtf8("\r\n");
-    }
-    sink.writeUtf8("\r\n");
-    sink.flush();
-  }
-
-  private void sleepIfDelayed(long delayMs) {
-    if (delayMs != 0) {
-      try {
-        Thread.sleep(delayMs);
-      } catch (InterruptedException e) {
-        throw new AssertionError(e);
-      }
-    }
-  }
-
-  /**
-   * Transfer bytes from {@code source} to {@code sink} until either {@code byteCount} bytes have
-   * been transferred or {@code source} is exhausted. The transfer is throttled according to {@code
-   * policy}.
-   */
-  private void throttledTransfer(MockResponse policy, Socket socket, BufferedSource source,
-      BufferedSink sink, long byteCount, boolean isRequest) throws IOException {
-    if (byteCount == 0) return;
-
-    Buffer buffer = new Buffer();
-    long bytesPerPeriod = policy.getThrottleBytesPerPeriod();
-    long periodDelayMs = policy.getThrottlePeriod(TimeUnit.MILLISECONDS);
-
-    long halfByteCount = byteCount / 2;
-    boolean disconnectHalfway = isRequest
-        ? policy.getSocketPolicy() == DISCONNECT_DURING_REQUEST_BODY
-        : policy.getSocketPolicy() == DISCONNECT_DURING_RESPONSE_BODY;
-
-    while (!socket.isClosed()) {
-      for (int b = 0; b < bytesPerPeriod; ) {
-        // Ensure we do not read past the allotted bytes in this period.
-        long toRead = Math.min(byteCount, bytesPerPeriod - b);
-        // Ensure we do not read past halfway if the policy will kill the connection.
-        if (disconnectHalfway) {
-          toRead = Math.min(toRead, byteCount - halfByteCount);
-        }
-
-        long read = source.read(buffer, toRead);
-        if (read == -1) return;
-
-        sink.write(buffer, read);
-        sink.flush();
-        b += read;
-        byteCount -= read;
-
-        if (disconnectHalfway && byteCount == halfByteCount) {
-          socket.close();
-          return;
-        }
-
-        if (byteCount == 0) return;
-      }
-
-      if (periodDelayMs != 0) {
-        try {
-          Thread.sleep(periodDelayMs);
-        } catch (InterruptedException e) {
-          throw new AssertionError(e);
-        }
-      }
-    }
-  }
-
-  private void readEmptyLine(BufferedSource source) throws IOException {
-    String line = source.readUtf8LineStrict();
-    if (line.length() != 0) throw new IllegalStateException("Expected empty but was: " + line);
-  }
-
-  /**
-   * Returns the dispatcher used to respond to HTTP requests. The default dispatcher is a {@link
-   * QueueDispatcher} but other dispatchers can be configured.
-   */
-  public Dispatcher getDispatcher() {
-    return dispatcher;
-  }
-
-  /**
-   * Sets the dispatcher used to match incoming requests to mock responses. The default dispatcher
-   * simply serves a fixed sequence of responses from a {@link #enqueue(MockResponse) queue}; custom
-   * dispatchers can vary the response based on timing or the content of the request.
-   */
-  public void setDispatcher(Dispatcher dispatcher) {
-    if (dispatcher == null) throw new NullPointerException();
-    this.dispatcher = dispatcher;
-  }
-
-  @Override public String toString() {
-    return "MockWebServer[" + port + "]";
-  }
-
-  @Override public void close() throws IOException {
-    shutdown();
-  }
-
-  /** A buffer wrapper that drops data after {@code bodyLimit} bytes. */
-  private static class TruncatingBuffer implements Sink {
-    private final Buffer buffer = new Buffer();
-    private long remainingByteCount;
-    private long receivedByteCount;
-
-    TruncatingBuffer(long bodyLimit) {
-      remainingByteCount = bodyLimit;
-    }
-
-    @Override public void write(Buffer source, long byteCount) throws IOException {
-      long toRead = Math.min(remainingByteCount, byteCount);
-      if (toRead > 0) {
-        source.read(buffer, toRead);
-      }
-      long toSkip = byteCount - toRead;
-      if (toSkip > 0) {
-        source.skip(toSkip);
-      }
-      remainingByteCount -= toRead;
-      receivedByteCount += byteCount;
-    }
-
-    @Override public void flush() throws IOException {
-    }
-
-    @Override public Timeout timeout() {
-      return Timeout.NONE;
-    }
-
-    @Override public void close() throws IOException {
-    }
-  }
-
-  /** Processes HTTP requests layered over HTTP/2. */
-  private class Http2SocketHandler extends Http2Connection.Listener {
-    private final Socket socket;
-    private final Protocol protocol;
-    private final AtomicInteger sequenceNumber = new AtomicInteger();
-
-    private Http2SocketHandler(Socket socket, Protocol protocol) {
-      this.socket = socket;
-      this.protocol = protocol;
-    }
-
-    @Override public void onStream(Http2Stream stream) throws IOException {
-      MockResponse peekedResponse = dispatcher.peek();
-      if (peekedResponse.getSocketPolicy() == RESET_STREAM_AT_START) {
-        try {
-          dispatchBookkeepingRequest(sequenceNumber.getAndIncrement(), socket);
-          stream.close(ErrorCode.fromHttp2(peekedResponse.getHttp2ErrorCode()), null);
-          return;
-        } catch (InterruptedException e) {
-          throw new AssertionError(e);
-        }
-      }
-
-      RecordedRequest request = readRequest(stream);
-      requestCount.incrementAndGet();
-      requestQueue.add(request);
-
-      MockResponse response;
-      try {
-        response = dispatcher.dispatch(request);
-      } catch (InterruptedException e) {
-        throw new AssertionError(e);
-      }
-      if (response.getSocketPolicy() == DISCONNECT_AFTER_REQUEST) {
-        socket.close();
-        return;
-      }
-      writeResponse(stream, request, response);
-      if (logger.isLoggable(Level.INFO)) {
-        logger.info(MockWebServer.this + " received request: " + request
-            + " and responded: " + response + " protocol is " + protocol.toString());
-      }
-
-      if (response.getSocketPolicy() == DISCONNECT_AT_END) {
-        Http2Connection connection = stream.getConnection();
-        connection.shutdown(ErrorCode.NO_ERROR);
-      }
-    }
-
-    private RecordedRequest readRequest(Http2Stream stream) throws IOException {
-      Headers streamHeaders = stream.takeHeaders();
-      Headers.Builder httpHeaders = new Headers.Builder();
-      String method = "<:method omitted>";
-      String path = "<:path omitted>";
-      boolean readBody = true;
-      for (int i = 0, size = streamHeaders.size(); i < size; i++) {
-        String name = streamHeaders.name(i);
-        String value = streamHeaders.value(i);
-        if (name.equals(Header.TARGET_METHOD_UTF8)) {
-          method = value;
-        } else if (name.equals(Header.TARGET_PATH_UTF8)) {
-          path = value;
-        } else if (protocol == Protocol.HTTP_2 || protocol == Protocol.H2_PRIOR_KNOWLEDGE) {
-          httpHeaders.add(name, value);
-        } else {
-          throw new IllegalStateException();
-        }
-        if (name.equals("expect") && value.equalsIgnoreCase("100-continue")) {
-          // Don't read the body unless we've invited the client to send it.
-          readBody = false;
-        }
-      }
-      Headers headers = httpHeaders.build();
-
-      MockResponse peek = dispatcher.peek();
-      if (!readBody && peek.getSocketPolicy() == EXPECT_CONTINUE) {
-        List<Header> continueHeaders = Collections.singletonList(
-            new Header(Header.RESPONSE_STATUS, ByteString.encodeUtf8("100 Continue")));
-        stream.writeHeaders(continueHeaders, false, true);
-        stream.getConnection().flush();
-        readBody = true;
-      }
-
-      Buffer body = new Buffer();
-      if (readBody && !peek.isDuplex()) {
-        String contentLengthString = headers.get("content-length");
-        long byteCount = contentLengthString != null
-            ? Long.parseLong(contentLengthString)
-            : Long.MAX_VALUE;
-        throttledTransfer(peek, socket, Okio.buffer(stream.getSource()), body, byteCount, true);
-      }
-
-      String requestLine = method + ' ' + path + " HTTP/1.1";
-      List<Integer> chunkSizes = Collections.emptyList(); // No chunked encoding for HTTP/2.
-      return new RecordedRequest(requestLine, headers, chunkSizes, body.size(), body,
-          sequenceNumber.getAndIncrement(), socket);
-    }
-
-    private void writeResponse(final Http2Stream stream,
-        final RecordedRequest request, final MockResponse response) throws IOException {
-      Settings settings = response.getSettings();
-      if (settings != null) {
-        stream.getConnection().setSettings(settings);
-      }
-
-      if (response.getSocketPolicy() == NO_RESPONSE) {
-        return;
-      }
-      List<Header> http2Headers = new ArrayList<>();
-      String[] statusParts = response.getStatus().split(" ", 3);
-      if (statusParts.length < 2) {
-        throw new AssertionError("Unexpected status: " + response.getStatus());
-      }
-      // TODO: constants for well-known header names.
-      http2Headers.add(new Header(Header.RESPONSE_STATUS, statusParts[1]));
-      Headers headers = response.getHeaders();
-      for (int i = 0, size = headers.size(); i < size; i++) {
-        http2Headers.add(new Header(headers.name(i), headers.value(i)));
-      }
-      Headers trailers = response.getTrailers();
-
-      sleepIfDelayed(response.getHeadersDelay(TimeUnit.MILLISECONDS));
-
-      Buffer body = response.getBody();
-      boolean outFinished = body == null
-          && response.getPushPromises().isEmpty()
-          && !response.isDuplex();
-      boolean flushHeaders = body == null;
-      if (outFinished && trailers.size() > 0) {
-        throw new IllegalStateException("unsupported: no body and non-empty trailers " + trailers);
-      }
-      stream.writeHeaders(http2Headers, outFinished, flushHeaders);
-      if (trailers.size() > 0) {
-        stream.enqueueTrailers(trailers);
-      }
-      pushPromises(stream, request, response.getPushPromises());
-      if (body != null) {
-        try (BufferedSink sink = Okio.buffer(stream.getSink())) {
-          sleepIfDelayed(response.getBodyDelay(TimeUnit.MILLISECONDS));
-          throttledTransfer(response, socket, body, sink, body.size(), false);
-        }
-      } else if (response.isDuplex()) {
-        try (BufferedSink sink = Okio.buffer(stream.getSink());
-             BufferedSource source = Okio.buffer(stream.getSource())) {
-          DuplexResponseBody duplexResponseBody = response.getDuplexResponseBody();
-          duplexResponseBody.onRequest(request, source, sink);
-        }
-      } else if (!outFinished) {
-        stream.close(ErrorCode.NO_ERROR, null);
-      }
-    }
-
-    private void pushPromises(Http2Stream stream, RecordedRequest request,
-        List<PushPromise> promises) throws IOException {
-      for (PushPromise pushPromise : promises) {
-        List<Header> pushedHeaders = new ArrayList<>();
-        pushedHeaders.add(new Header(Header.TARGET_AUTHORITY, url(pushPromise.path()).host()));
-        pushedHeaders.add(new Header(Header.TARGET_METHOD, pushPromise.method()));
-        pushedHeaders.add(new Header(Header.TARGET_PATH, pushPromise.path()));
-        Headers pushPromiseHeaders = pushPromise.headers();
-        for (int i = 0, size = pushPromiseHeaders.size(); i < size; i++) {
-          pushedHeaders.add(new Header(pushPromiseHeaders.name(i), pushPromiseHeaders.value(i)));
-        }
-        String requestLine = pushPromise.method() + ' ' + pushPromise.path() + " HTTP/1.1";
-        List<Integer> chunkSizes = Collections.emptyList(); // No chunked encoding for HTTP/2.
-        requestQueue.add(new RecordedRequest(requestLine, pushPromise.headers(), chunkSizes, 0,
-            new Buffer(), sequenceNumber.getAndIncrement(), socket));
-        boolean hasBody = pushPromise.response().getBody() != null;
-        Http2Stream pushedStream =
-            stream.getConnection().pushStream(stream.getId(), pushedHeaders, hasBody);
-        writeResponse(pushedStream, request, pushPromise.response());
-      }
-    }
-  }
-}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/PushPromise.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/PushPromise.java
deleted file mode 100644
index 744127cadd..0000000000
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/PushPromise.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.mockwebserver;
-
-import okhttp3.Headers;
-
-/** An HTTP request initiated by the server. */
-public final class PushPromise {
-  private final String method;
-  private final String path;
-  private final Headers headers;
-  private final MockResponse response;
-
-  public PushPromise(String method, String path, Headers headers, MockResponse response) {
-    this.method = method;
-    this.path = path;
-    this.headers = headers;
-    this.response = response;
-  }
-
-  public String method() {
-    return method;
-  }
-
-  public String path() {
-    return path;
-  }
-
-  public Headers headers() {
-    return headers;
-  }
-
-  public MockResponse response() {
-    return response;
-  }
-}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/QueueDispatcher.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/QueueDispatcher.java
deleted file mode 100644
index 4071d4718b..0000000000
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/QueueDispatcher.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Copyright (C) 2012 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.mockwebserver;
-
-import java.net.HttpURLConnection;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.logging.Logger;
-
-/**
- * Default dispatcher that processes a script of responses. Populate the script by calling {@link
- * #enqueueResponse(MockResponse)}.
- */
-public class QueueDispatcher extends Dispatcher {
-  /**
-   * Enqueued on shutdown to release threads waiting on {@link #dispatch}. Note that this response
-   * isn't transmitted because the connection is closed before this response is returned.
-   */
-  private static final MockResponse DEAD_LETTER = new MockResponse()
-      .setStatus("HTTP/1.1 " + 503 + " shutting down");
-
-  private static final Logger logger = Logger.getLogger(QueueDispatcher.class.getName());
-  protected final BlockingQueue<MockResponse> responseQueue = new LinkedBlockingQueue<>();
-  private MockResponse failFastResponse;
-
-  @Override public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
-    // To permit interactive/browser testing, ignore requests for favicons.
-    final String requestLine = request.getRequestLine();
-    if (requestLine != null && requestLine.equals("GET /favicon.ico HTTP/1.1")) {
-      logger.info("served " + requestLine);
-      return new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_FOUND);
-    }
-
-    if (failFastResponse != null && responseQueue.peek() == null) {
-      // Fail fast if there's no response queued up.
-      return failFastResponse;
-    }
-
-    MockResponse result = responseQueue.take();
-
-    // If take() returned because we're shutting down, then enqueue another dead letter so that any
-    // other threads waiting on take() will also return.
-    if (result == DEAD_LETTER) responseQueue.add(DEAD_LETTER);
-
-    return result;
-  }
-
-  @Override public MockResponse peek() {
-    MockResponse peek = responseQueue.peek();
-    if (peek != null) return peek;
-    if (failFastResponse != null) return failFastResponse;
-    return super.peek();
-  }
-
-  public void enqueueResponse(MockResponse response) {
-    responseQueue.add(response);
-  }
-
-  @Override public void shutdown() {
-    responseQueue.add(DEAD_LETTER);
-  }
-
-  public void setFailFast(boolean failFast) {
-    MockResponse failFastResponse = failFast
-        ? new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_FOUND)
-        : null;
-    setFailFast(failFastResponse);
-  }
-
-  public void setFailFast(MockResponse failFastResponse) {
-    this.failFastResponse = failFastResponse;
-  }
-}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java
deleted file mode 100644
index 52beb79323..0000000000
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java
+++ /dev/null
@@ -1,167 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package okhttp3.mockwebserver;
-
-import java.io.IOException;
-import java.net.Inet6Address;
-import java.net.InetAddress;
-import java.net.Socket;
-import java.util.List;
-import javax.net.ssl.SSLSocket;
-import okhttp3.Handshake;
-import okhttp3.Headers;
-import okhttp3.HttpUrl;
-import okhttp3.TlsVersion;
-import okio.Buffer;
-
-/** An HTTP request that came into the mock web server. */
-public final class RecordedRequest {
-  private final String requestLine;
-  private final String method;
-  private final String path;
-  private final Headers headers;
-  private final Handshake handshake;
-  private final List<Integer> chunkSizes;
-  private final long bodySize;
-  private final Buffer body;
-  private final int sequenceNumber;
-  private final HttpUrl requestUrl;
-
-  public RecordedRequest(String requestLine, Headers headers, List<Integer> chunkSizes,
-      long bodySize, Buffer body, int sequenceNumber, Socket socket) {
-    this.requestLine = requestLine;
-    this.headers = headers;
-    this.chunkSizes = chunkSizes;
-    this.bodySize = bodySize;
-    this.body = body;
-    this.sequenceNumber = sequenceNumber;
-    if (socket instanceof SSLSocket) {
-      try {
-        this.handshake = Handshake.get(((SSLSocket) socket).getSession());
-      } catch (IOException e) {
-        throw new IllegalArgumentException(e);
-      }
-    } else {
-      this.handshake = null;
-    }
-
-    if (requestLine != null) {
-      int methodEnd = requestLine.indexOf(' ');
-      int pathEnd = requestLine.indexOf(' ', methodEnd + 1);
-      this.method = requestLine.substring(0, methodEnd);
-      String path = requestLine.substring(methodEnd + 1, pathEnd);
-      if (!path.startsWith("/")) {
-        path = "/";
-      }
-      this.path = path;
-
-      String scheme = socket instanceof SSLSocket ? "https" : "http";
-      InetAddress inetAddress = socket.getLocalAddress();
-
-      String hostname = inetAddress.getHostName();
-      if (inetAddress instanceof Inet6Address) {
-        hostname = "[" + hostname + "]";
-      }
-
-      int localPort = socket.getLocalPort();
-      // Allow null in failure case to allow for testing bad requests
-      this.requestUrl =
-          HttpUrl.parse(String.format("%s://%s:%s%s", scheme, hostname, localPort, path));
-    } else {
-      this.requestUrl = null;
-      this.method = null;
-      this.path = null;
-    }
-  }
-
-  public HttpUrl getRequestUrl() {
-    return requestUrl;
-  }
-
-  public String getRequestLine() {
-    return requestLine;
-  }
-
-  public String getMethod() {
-    return method;
-  }
-
-  public String getPath() {
-    return path;
-  }
-
-  /** Returns all headers. */
-  public Headers getHeaders() {
-    return headers;
-  }
-
-  /** Returns the first header named {@code name}, or null if no such header exists. */
-  public String getHeader(String name) {
-    List<String> values = headers.values(name);
-    return values.isEmpty() ? null : values.get(0);
-  }
-
-  /**
-   * Returns the sizes of the chunks of this request's body, or an empty list if the request's body
-   * was empty or unchunked.
-   */
-  public List<Integer> getChunkSizes() {
-    return chunkSizes;
-  }
-
-  /**
-   * Returns the total size of the body of this POST request (before truncation).
-   */
-  public long getBodySize() {
-    return bodySize;
-  }
-
-  /** Returns the body of this POST request. This may be truncated. */
-  public Buffer getBody() {
-    return body;
-  }
-
-  /** @deprecated Use {@link #getBody() getBody().readUtf8()}. */
-  public String getUtf8Body() {
-    return getBody().readUtf8();
-  }
-
-  /**
-   * Returns the index of this request on its HTTP connection. Since a single HTTP connection may
-   * serve multiple requests, each request is assigned its own sequence number.
-   */
-  public int getSequenceNumber() {
-    return sequenceNumber;
-  }
-
-  /** Returns the connection's TLS version or null if the connection doesn't use SSL. */
-  public TlsVersion getTlsVersion() {
-    return handshake != null ? handshake.tlsVersion() : null;
-  }
-
-  /**
-   * Returns the TLS handshake of the connection that carried this request, or null if the request
-   * was received without TLS.
-   */
-  public Handshake getHandshake() {
-    return handshake;
-  }
-
-  @Override public String toString() {
-    return requestLine;
-  }
-}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java
deleted file mode 100644
index beeb2c9a6d..0000000000
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package okhttp3.mockwebserver;
-
-/**
- * What should be done with the incoming socket.
- *
- * <p>Be careful when using values like {@link #DISCONNECT_AT_END}, {@link #SHUTDOWN_INPUT_AT_END}
- * and {@link #SHUTDOWN_OUTPUT_AT_END} that close a socket after a response, and where there are
- * follow-up requests. The client is unblocked and free to continue as soon as it has received the
- * entire response body. If and when the client makes a subsequent request using a pooled socket the
- * server may not have had time to close the socket. The socket will be closed at an indeterminate
- * point before or during the second request. It may be closed after client has started sending the
- * request body. If a request body is not retryable then the client may fail the request, making
- * client behavior non-deterministic. Add delays in the client to improve the chances that the
- * server has closed the socket before follow up requests are made.
- */
-public enum SocketPolicy {
-
-  /**
-   * Shutdown {@link MockWebServer} after writing response.
-   */
-  SHUTDOWN_SERVER_AFTER_RESPONSE,
-
-  /**
-   * Keep the socket open after the response. This is the default HTTP/1.1 behavior.
-   */
-  KEEP_OPEN,
-
-  /**
-   * Close the socket after the response. This is the default HTTP/1.0 behavior. For HTTP/2
-   * connections, this sends a <a href="https://tools.ietf.org/html/rfc7540#section-6.8">GOAWAY
-   * frame</a> immediately after the response and will close the connection when the client's socket
-   * is exhausted.
-   *
-   * <p>See {@link SocketPolicy} for reasons why this can cause test flakiness and how to avoid it.
-   */
-  DISCONNECT_AT_END,
-
-  /**
-   * Wrap the socket with SSL at the completion of this request/response pair. Used for CONNECT
-   * messages to tunnel SSL over an HTTP proxy.
-   */
-  UPGRADE_TO_SSL_AT_END,
-
-  /**
-   * Request immediate close of connection without even reading the request. Use to simulate buggy
-   * SSL servers closing connections in response to unrecognized TLS extensions.
-   */
-  DISCONNECT_AT_START,
-
-  /**
-   * Close connection after reading the request but before writing the response. Use this to
-   * simulate late connection pool failures.
-   */
-  DISCONNECT_AFTER_REQUEST,
-
-  /** Close connection after reading half of the request body (if present). */
-  DISCONNECT_DURING_REQUEST_BODY,
-
-  /** Close connection after writing half of the response body (if present). */
-  DISCONNECT_DURING_RESPONSE_BODY,
-
-  /** Don't trust the client during the SSL handshake. */
-  FAIL_HANDSHAKE,
-
-  /**
-   * Shutdown the socket input after sending the response. For testing bad behavior.
-   *
-   * <p>See {@link SocketPolicy} for reasons why this can cause test flakiness and how to avoid it.
-   */
-  SHUTDOWN_INPUT_AT_END,
-
-  /**
-   * Shutdown the socket output after sending the response. For testing bad behavior.
-   *
-   * <p>See {@link SocketPolicy} for reasons why this can cause test flakiness and how to avoid it.
-   */
-  SHUTDOWN_OUTPUT_AT_END,
-
-  /**
-   * After accepting the connection and doing TLS (if configured) don't do HTTP/1.1 or HTTP/2
-   * framing. Ignore the socket completely until the server is shut down.
-   */
-  STALL_SOCKET_AT_START,
-
-  /**
-   * Read the request but don't respond to it. Just keep the socket open. For testing read response
-   * header timeout issue.
-   */
-  NO_RESPONSE,
-
-  /**
-   * Fail HTTP/2 requests without processing them by sending an {@linkplain
-   * MockResponse#getHttp2ErrorCode() HTTP/2 error code}.
-   */
-  RESET_STREAM_AT_START,
-
-  /**
-   * Transmit a {@code HTTP/1.1 100 Continue} response before reading the HTTP request body.
-   * Typically this response is sent when a client makes a request with the header {@code
-   * Expect: 100-continue}.
-   */
-  EXPECT_CONTINUE,
-
-  /**
-   * Transmit a {@code HTTP/1.1 100 Continue} response before reading the HTTP request body even
-   * if the client does not send the header {@code Expect: 100-continue} in its request.
-   */
-  CONTINUE_ALWAYS
-}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/duplex/DuplexResponseBody.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/duplex/DuplexResponseBody.java
deleted file mode 100644
index 79a8245e8f..0000000000
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/duplex/DuplexResponseBody.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.mockwebserver.internal.duplex;
-
-import java.io.IOException;
-import okhttp3.mockwebserver.RecordedRequest;
-import okio.BufferedSink;
-import okio.BufferedSource;
-
-public interface DuplexResponseBody {
-  void onRequest(RecordedRequest request, BufferedSource requestBody, BufferedSink responseBody)
-      throws IOException;
-}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/duplex/MockDuplexResponseBody.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/duplex/MockDuplexResponseBody.java
deleted file mode 100644
index 229c057c5a..0000000000
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/duplex/MockDuplexResponseBody.java
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.mockwebserver.internal.duplex;
-
-import java.io.IOException;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.FutureTask;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.TimeUnit;
-import okhttp3.mockwebserver.RecordedRequest;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.Utf8;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-/**
- * A scriptable request/response conversation. Create the script by calling methods like {@link
- * #receiveRequest} in the sequence they are run.
- */
-public final class MockDuplexResponseBody implements DuplexResponseBody {
-  private final BlockingQueue<Action> actions = new LinkedBlockingQueue<>();
-  private final BlockingQueue<FutureTask<Void>> results = new LinkedBlockingQueue<>();
-
-  public MockDuplexResponseBody receiveRequest(String expected) {
-    actions.add((request, requestBody, responseBody) -> {
-      assertEquals(expected, requestBody.readUtf8(Utf8.size(expected)));
-    });
-    return this;
-  }
-
-  public MockDuplexResponseBody exhaustRequest() {
-    actions.add((request, requestBody, responseBody) -> {
-      assertTrue(requestBody.exhausted());
-    });
-    return this;
-  }
-
-  public MockDuplexResponseBody requestIOException() {
-    actions.add((request, requestBody, responseBody) -> {
-      try {
-        requestBody.exhausted();
-        fail();
-      } catch (IOException expected) {
-      }
-    });
-    return this;
-  }
-
-  public MockDuplexResponseBody sendResponse(String s) {
-    actions.add((request, requestBody, responseBody) -> {
-      responseBody.writeUtf8(s);
-      responseBody.flush();
-    });
-    return this;
-  }
-
-  public MockDuplexResponseBody exhaustResponse() {
-    actions.add((request, requestBody, responseBody) -> {
-      responseBody.close();
-    });
-    return this;
-  }
-
-  public MockDuplexResponseBody sleep(long duration, TimeUnit unit) {
-    actions.add((request, requestBody, responseBody) -> {
-      try {
-        Thread.sleep(unit.toMillis(duration));
-      } catch (InterruptedException e) {
-        throw new AssertionError(e);
-      }
-    });
-    return this;
-  }
-
-  @Override public void onRequest(RecordedRequest request, BufferedSource requestBody,
-      BufferedSink responseBody) {
-    FutureTask<Void> futureTask = new FutureTask<>(() -> {
-      for (Action action; (action = actions.poll()) != null; ) {
-        action.execute(request, requestBody, responseBody);
-      }
-      return null; // Success!
-    });
-    results.add(futureTask);
-    futureTask.run();
-  }
-
-  /** Returns once the duplex conversation completes successfully. */
-  public void awaitSuccess() throws Exception {
-    FutureTask<Void> futureTask = results.poll(5, TimeUnit.SECONDS);
-    if (futureTask == null) throw new AssertionError("no onRequest call received");
-    futureTask.get(5, TimeUnit.SECONDS);
-  }
-
-  private interface Action {
-    void execute(RecordedRequest request, BufferedSource requestBody, BufferedSink responseBody)
-        throws IOException;
-  }
-}
-
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java
deleted file mode 100644
index ab69ac808f..0000000000
--- a/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Copyright (C) 2012 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.mockwebserver;
-
-import java.io.IOException;
-import java.net.HttpURLConnection;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicInteger;
-import org.junit.After;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public class CustomDispatcherTest {
-  private MockWebServer mockWebServer = new MockWebServer();
-
-  @After public void tearDown() throws Exception {
-    mockWebServer.shutdown();
-  }
-
-  @Test public void simpleDispatch() throws Exception {
-    mockWebServer.start();
-    final List<RecordedRequest> requestsMade = new ArrayList<>();
-    final Dispatcher dispatcher = new Dispatcher() {
-      @Override
-      public MockResponse dispatch(RecordedRequest request) {
-        requestsMade.add(request);
-        return new MockResponse();
-      }
-    };
-    assertThat(requestsMade.size()).isEqualTo(0);
-    mockWebServer.setDispatcher(dispatcher);
-    final URL url = mockWebServer.url("/").url();
-    final HttpURLConnection conn = (HttpURLConnection) url.openConnection();
-    conn.getResponseCode(); // Force the connection to hit the "server".
-    // Make sure our dispatcher got the request.
-    assertThat(requestsMade.size()).isEqualTo(1);
-  }
-
-  @Test public void outOfOrderResponses() throws Exception {
-    AtomicInteger firstResponseCode = new AtomicInteger();
-    AtomicInteger secondResponseCode = new AtomicInteger();
-    mockWebServer.start();
-    final String secondRequest = "/bar";
-    final String firstRequest = "/foo";
-    final CountDownLatch latch = new CountDownLatch(1);
-    final Dispatcher dispatcher = new Dispatcher() {
-      @Override
-      public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
-        if (request.getPath().equals(firstRequest)) {
-          latch.await();
-        }
-        return new MockResponse();
-      }
-    };
-    mockWebServer.setDispatcher(dispatcher);
-    final Thread startsFirst = buildRequestThread(firstRequest, firstResponseCode);
-    startsFirst.start();
-    final Thread endsFirst = buildRequestThread(secondRequest, secondResponseCode);
-    endsFirst.start();
-    endsFirst.join();
-    // First response is still waiting.
-    assertThat(firstResponseCode.get()).isEqualTo(0);
-    // Second response is done.
-    assertThat(secondResponseCode.get()).isEqualTo(200);
-    latch.countDown();
-    startsFirst.join();
-    // And now it's done!
-    assertThat(firstResponseCode.get()).isEqualTo(200);
-    // (Still done).
-    assertThat(secondResponseCode.get()).isEqualTo(200);
-  }
-
-  private Thread buildRequestThread(String path, AtomicInteger responseCode) {
-    return new Thread(() -> {
-      URL url = mockWebServer.url(path).url();
-      HttpURLConnection conn;
-      try {
-        conn = (HttpURLConnection) url.openConnection();
-        responseCode.set(conn.getResponseCode()); // Force the connection to hit the "server".
-      } catch (IOException ignored) {
-      }
-    });
-  }
-}
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
deleted file mode 100644
index df4d59b4ae..0000000000
--- a/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
+++ /dev/null
@@ -1,594 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.mockwebserver;
-
-import java.io.BufferedReader;
-import java.io.Closeable;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.OutputStream;
-import java.net.ConnectException;
-import java.net.HttpURLConnection;
-import java.net.ProtocolException;
-import java.net.SocketTimeoutException;
-import java.net.URL;
-import java.net.URLConnection;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicBoolean;
-import javax.net.ssl.HttpsURLConnection;
-import okhttp3.Handshake;
-import okhttp3.Headers;
-import okhttp3.HttpUrl;
-import okhttp3.Protocol;
-import okhttp3.RecordingHostnameVerifier;
-import okhttp3.internal.Util;
-import okhttp3.tls.HandshakeCertificates;
-import okhttp3.tls.HeldCertificate;
-import org.junit.After;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.Description;
-import org.junit.runners.model.Statement;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static java.util.concurrent.TimeUnit.NANOSECONDS;
-import static java.util.concurrent.TimeUnit.SECONDS;
-import static okhttp3.tls.internal.TlsUtil.localhost;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.data.Offset.offset;
-import static org.junit.Assert.fail;
-
-public final class MockWebServerTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  @Test public void defaultMockResponse() {
-    MockResponse response = new MockResponse();
-    assertThat(headersToList(response)).containsExactly("Content-Length: 0");
-    assertThat(response.getStatus()).isEqualTo("HTTP/1.1 200 OK");
-  }
-
-  @Test public void setResponseMockReason() {
-    String[] reasons = {
-        "Mock Response",
-        "Informational",
-        "OK",
-        "Redirection",
-        "Client Error",
-        "Server Error",
-        "Mock Response"
-    };
-    for (int i = 0; i < 600; i++) {
-      MockResponse response = new MockResponse().setResponseCode(i);
-      String expectedReason = reasons[i / 100];
-      assertThat(response.getStatus()).isEqualTo(("HTTP/1.1 " + i + " " + expectedReason));
-      assertThat(headersToList(response)).containsExactly("Content-Length: 0");
-    }
-  }
-
-  @Test public void setStatusControlsWholeStatusLine() {
-    MockResponse response = new MockResponse().setStatus("HTTP/1.1 202 That'll do pig");
-    assertThat(headersToList(response)).containsExactly("Content-Length: 0");
-    assertThat(response.getStatus()).isEqualTo("HTTP/1.1 202 That'll do pig");
-  }
-
-  @Test public void setBodyAdjustsHeaders() throws IOException {
-    MockResponse response = new MockResponse().setBody("ABC");
-    assertThat(headersToList(response)).containsExactly("Content-Length: 3");
-    assertThat(response.getBody().readUtf8()).isEqualTo("ABC");
-  }
-
-  @Test public void mockResponseAddHeader() {
-    MockResponse response = new MockResponse()
-        .clearHeaders()
-        .addHeader("Cookie: s=square")
-        .addHeader("Cookie", "a=android");
-    assertThat(headersToList(response)).containsExactly("Cookie: s=square", "Cookie: a=android");
-  }
-
-  @Test public void mockResponseSetHeader() {
-    MockResponse response = new MockResponse()
-        .clearHeaders()
-        .addHeader("Cookie: s=square")
-        .addHeader("Cookie: a=android")
-        .addHeader("Cookies: delicious");
-    response.setHeader("cookie", "r=robot");
-    assertThat(headersToList(response)).containsExactly("Cookies: delicious", "cookie: r=robot");
-  }
-
-  @Test public void mockResponseSetHeaders() {
-    MockResponse response = new MockResponse()
-        .clearHeaders()
-        .addHeader("Cookie: s=square")
-        .addHeader("Cookies: delicious");
-
-    response.setHeaders(new Headers.Builder().add("Cookie", "a=android").build());
-
-    assertThat(headersToList(response)).containsExactly("Cookie: a=android");
-  }
-
-  @Test public void regularResponse() throws Exception {
-    server.enqueue(new MockResponse().setBody("hello world"));
-
-    URL url = server.url("/").url();
-    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
-    connection.setRequestProperty("Accept-Language", "en-US");
-    InputStream in = connection.getInputStream();
-    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
-    assertThat(connection.getResponseCode()).isEqualTo(HttpURLConnection.HTTP_OK);
-    assertThat(reader.readLine()).isEqualTo("hello world");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getRequestLine()).isEqualTo("GET / HTTP/1.1");
-    assertThat(request.getHeader("Accept-Language")).isEqualTo("en-US");
-  }
-
-  @Test public void redirect() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server.url("/new-path"))
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse().setBody("This is the new location!"));
-
-    URLConnection connection = server.url("/").url().openConnection();
-    InputStream in = connection.getInputStream();
-    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
-    assertThat(reader.readLine()).isEqualTo("This is the new location!");
-
-    RecordedRequest first = server.takeRequest();
-    assertThat(first.getRequestLine()).isEqualTo("GET / HTTP/1.1");
-    RecordedRequest redirect = server.takeRequest();
-    assertThat(redirect.getRequestLine()).isEqualTo("GET /new-path HTTP/1.1");
-  }
-
-  /**
-   * Test that MockWebServer blocks for a call to enqueue() if a request is made before a mock
-   * response is ready.
-   */
-  @Test public void dispatchBlocksWaitingForEnqueue() throws Exception {
-    new Thread(() -> {
-      try {
-        Thread.sleep(1000);
-      } catch (InterruptedException ignored) {
-      }
-      server.enqueue(new MockResponse().setBody("enqueued in the background"));
-    }).start();
-
-    URLConnection connection = server.url("/").url().openConnection();
-    InputStream in = connection.getInputStream();
-    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
-    assertThat(reader.readLine()).isEqualTo("enqueued in the background");
-  }
-
-  @Test public void nonHexadecimalChunkSize() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("G\r\nxxxxxxxxxxxxxxxx\r\n0\r\n\r\n")
-        .clearHeaders()
-        .addHeader("Transfer-encoding: chunked"));
-
-    URLConnection connection = server.url("/").url().openConnection();
-    InputStream in = connection.getInputStream();
-    try {
-      in.read();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void responseTimeout() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("ABC")
-        .clearHeaders()
-        .addHeader("Content-Length: 4"));
-    server.enqueue(new MockResponse().setBody("DEF"));
-
-    URLConnection urlConnection = server.url("/").url().openConnection();
-    urlConnection.setReadTimeout(1000);
-    InputStream in = urlConnection.getInputStream();
-    assertThat(in.read()).isEqualTo('A');
-    assertThat(in.read()).isEqualTo('B');
-    assertThat(in.read()).isEqualTo('C');
-    try {
-      in.read(); // if Content-Length was accurate, this would return -1 immediately
-      fail();
-    } catch (SocketTimeoutException expected) {
-    }
-
-    URLConnection urlConnection2 = server.url("/").url().openConnection();
-    InputStream in2 = urlConnection2.getInputStream();
-    assertThat(in2.read()).isEqualTo('D');
-    assertThat(in2.read()).isEqualTo('E');
-    assertThat(in2.read()).isEqualTo('F');
-    assertThat(in2.read()).isEqualTo(-1);
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-  }
-
-  @Test public void disconnectAtStart() throws Exception {
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
-    server.enqueue(new MockResponse()); // The jdk's HttpUrlConnection is a bastard.
-    server.enqueue(new MockResponse());
-    try {
-      server.url("/a").url().openConnection().getInputStream();
-    } catch (IOException expected) {
-    }
-    server.url("/b").url().openConnection().getInputStream(); // Should succeed.
-  }
-
-  /**
-   * Throttle the request body by sleeping 500ms after every 3 bytes. With a 6-byte request, this
-   * should yield one sleep for a total delay of 500ms.
-   */
-  @Test public void throttleRequest() throws Exception {
-    server.enqueue(new MockResponse()
-        .throttleBody(3, 500, TimeUnit.MILLISECONDS));
-
-    long startNanos = System.nanoTime();
-    URLConnection connection = server.url("/").url().openConnection();
-    connection.setDoOutput(true);
-    connection.getOutputStream().write("ABCDEF".getBytes(UTF_8));
-    InputStream in = connection.getInputStream();
-    assertThat(in.read()).isEqualTo(-1);
-    long elapsedNanos = System.nanoTime() - startNanos;
-    long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
-
-    assertThat(elapsedMillis >= 500).overridingErrorMessage(
-        Util.format("Request + Response: %sms", elapsedMillis)).isTrue();
-    assertThat(elapsedMillis < 1000).overridingErrorMessage(
-        Util.format("Request + Response: %sms", elapsedMillis)).isTrue();
-  }
-
-  /**
-   * Throttle the response body by sleeping 500ms after every 3 bytes. With a 6-byte response, this
-   * should yield one sleep for a total delay of 500ms.
-   */
-  @Test public void throttleResponse() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("ABCDEF")
-        .throttleBody(3, 500, TimeUnit.MILLISECONDS));
-
-    long startNanos = System.nanoTime();
-    URLConnection connection = server.url("/").url().openConnection();
-    InputStream in = connection.getInputStream();
-    assertThat(in.read()).isEqualTo('A');
-    assertThat(in.read()).isEqualTo('B');
-    assertThat(in.read()).isEqualTo('C');
-    assertThat(in.read()).isEqualTo('D');
-    assertThat(in.read()).isEqualTo('E');
-    assertThat(in.read()).isEqualTo('F');
-    assertThat(in.read()).isEqualTo(-1);
-    long elapsedNanos = System.nanoTime() - startNanos;
-    long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
-
-    assertThat(elapsedMillis >= 500).overridingErrorMessage(
-        Util.format("Request + Response: %sms", elapsedMillis)).isTrue();
-    assertThat(elapsedMillis < 1000).overridingErrorMessage(
-        Util.format("Request + Response: %sms", elapsedMillis)).isTrue();
-  }
-
-  /** Delay the response body by sleeping 1s. */
-  @Test public void delayResponse() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("ABCDEF")
-        .setBodyDelay(1, SECONDS));
-
-    long startNanos = System.nanoTime();
-    URLConnection connection = server.url("/").url().openConnection();
-    InputStream in = connection.getInputStream();
-    assertThat(in.read()).isEqualTo('A');
-    long elapsedNanos = System.nanoTime() - startNanos;
-    long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
-    assertThat(elapsedMillis >= 1000).overridingErrorMessage(
-        Util.format("Request + Response: %sms", elapsedMillis)).isTrue();
-
-    in.close();
-  }
-
-  @Test public void disconnectRequestHalfway() throws Exception {
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_DURING_REQUEST_BODY));
-    // Limit the size of the request body that the server holds in memory to an arbitrary
-    // 3.5 MBytes so this test can pass on devices with little memory.
-    server.setBodyLimit(7 * 512 * 1024);
-
-    HttpURLConnection connection = (HttpURLConnection) server.url("/").url().openConnection();
-    connection.setRequestMethod("POST");
-    connection.setDoOutput(true);
-    connection.setFixedLengthStreamingMode(1024 * 1024 * 1024); // 1 GB
-    connection.connect();
-    OutputStream out = connection.getOutputStream();
-
-    byte[] data = new byte[1024 * 1024];
-    int i;
-    for (i = 0; i < 1024; i++) {
-      try {
-        out.write(data);
-        out.flush();
-        if (i == 513) {
-          // pause slightly after half way to make result more predictable
-          Thread.sleep(100);
-        }
-      } catch (IOException e) {
-        break;
-      }
-    }
-    // Halfway +/- 0.5%
-    assertThat((float) i).isCloseTo(512f, offset(5f));
-  }
-
-  @Test public void disconnectResponseHalfway() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("ab")
-        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY));
-
-    URLConnection connection = server.url("/").url().openConnection();
-    assertThat(connection.getContentLength()).isEqualTo(2);
-    InputStream in = connection.getInputStream();
-    assertThat(in.read()).isEqualTo('a');
-    try {
-      int byteRead = in.read();
-      // OpenJDK behavior: end of stream.
-      assertThat(byteRead).isEqualTo(-1);
-    } catch (ProtocolException e) {
-      // On Android, HttpURLConnection is implemented by OkHttp v2. OkHttp
-      // treats an incomplete response body as a ProtocolException.
-    }
-  }
-
-  private List<String> headersToList(MockResponse response) {
-    Headers headers = response.getHeaders();
-    int size = headers.size();
-    List<String> headerList = new ArrayList<>(size);
-    for (int i = 0; i < size; i++) {
-      headerList.add(headers.name(i) + ": " + headers.value(i));
-    }
-    return headerList;
-  }
-
-  @Test public void shutdownWithoutStart() throws IOException {
-    MockWebServer server = new MockWebServer();
-    server.shutdown();
-  }
-
-  @Test public void closeViaClosable() throws IOException {
-    Closeable server = new MockWebServer();
-    server.close();
-  }
-
-  @Test public void shutdownWithoutEnqueue() throws IOException {
-    MockWebServer server = new MockWebServer();
-    server.start();
-    server.shutdown();
-  }
-
-  @After public void tearDown() throws IOException {
-    server.shutdown();
-  }
-
-  @Test public void portImplicitlyStarts() throws IOException {
-    assertThat(server.getPort() > 0).isTrue();
-  }
-
-  @Test public void hostnameImplicitlyStarts() throws IOException {
-    assertThat(server.getHostName()).isNotNull();
-  }
-
-  @Test public void toProxyAddressImplicitlyStarts() throws IOException {
-    assertThat(server.toProxyAddress()).isNotNull();
-  }
-
-  @Test public void differentInstancesGetDifferentPorts() throws IOException {
-    MockWebServer other = new MockWebServer();
-    assertThat(other.getPort()).isNotEqualTo(server.getPort());
-    other.shutdown();
-  }
-
-  @Test public void statementStartsAndStops() throws Throwable {
-    final AtomicBoolean called = new AtomicBoolean();
-    Statement statement = server.apply(new Statement() {
-      @Override public void evaluate() throws Throwable {
-        called.set(true);
-        server.url("/").url().openConnection().connect();
-      }
-    }, Description.EMPTY);
-
-    statement.evaluate();
-
-    assertThat(called.get()).isTrue();
-    try {
-      server.url("/").url().openConnection().connect();
-      fail();
-    } catch (ConnectException expected) {
-    }
-  }
-
-  @Test public void shutdownWhileBlockedDispatching() throws Exception {
-    // Enqueue a request that'll cause MockWebServer to hang on QueueDispatcher.dispatch().
-    HttpURLConnection connection = (HttpURLConnection) server.url("/").url().openConnection();
-    connection.setReadTimeout(500);
-    try {
-      connection.getResponseCode();
-      fail();
-    } catch (SocketTimeoutException expected) {
-    }
-
-    // Shutting down the server should unblock the dispatcher.
-    server.shutdown();
-  }
-
-  @Test public void requestUrlReconstructed() throws Exception {
-    server.enqueue(new MockResponse().setBody("hello world"));
-
-    URL url = server.url("/a/deep/path?key=foo%20bar").url();
-    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
-    InputStream in = connection.getInputStream();
-    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
-    assertThat(connection.getResponseCode()).isEqualTo(HttpURLConnection.HTTP_OK);
-    assertThat(reader.readLine()).isEqualTo("hello world");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getRequestLine()).isEqualTo(
-        "GET /a/deep/path?key=foo%20bar HTTP/1.1");
-
-    HttpUrl requestUrl = request.getRequestUrl();
-    assertThat(requestUrl.scheme()).isEqualTo("http");
-    assertThat(requestUrl.host()).isEqualTo(server.getHostName());
-    assertThat(requestUrl.port()).isEqualTo(server.getPort());
-    assertThat(requestUrl.encodedPath()).isEqualTo("/a/deep/path");
-    assertThat(requestUrl.queryParameter("key")).isEqualTo("foo bar");
-  }
-
-  @Test public void shutdownServerAfterRequest() throws Exception {
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.SHUTDOWN_SERVER_AFTER_RESPONSE));
-
-    URL url = server.url("/").url();
-
-    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
-    assertThat(connection.getResponseCode()).isEqualTo(HttpURLConnection.HTTP_OK);
-
-    HttpURLConnection refusedConnection = (HttpURLConnection) url.openConnection();
-
-    try {
-      refusedConnection.getResponseCode();
-      fail("Second connection should be refused");
-    } catch (ConnectException e ) {
-      assertThat(e.getMessage().contains("refused")).isTrue();
-    }
-  }
-
-  @Test public void http100Continue() throws Exception {
-    server.enqueue(new MockResponse().setBody("response"));
-
-    URL url = server.url("/").url();
-    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
-    connection.setDoOutput(true);
-    connection.setRequestProperty("Expect", "100-Continue");
-    connection.getOutputStream().write("request".getBytes(UTF_8));
-
-    InputStream in = connection.getInputStream();
-    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
-    assertThat(reader.readLine()).isEqualTo("response");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readUtf8()).isEqualTo("request");
-  }
-
-  @Test public void testH2PriorKnowledgeServerFallback() {
-    try {
-      server.setProtocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.HTTP_1_1));
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          ("protocols containing h2_prior_knowledge cannot use other protocols: "
-                + "[h2_prior_knowledge, http/1.1]"));
-    }
-  }
-
-  @Test public void testH2PriorKnowledgeServerDuplicates() {
-    try {
-      // Treating this use case as user error
-      server.setProtocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.H2_PRIOR_KNOWLEDGE));
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          ("protocols containing h2_prior_knowledge cannot use other protocols: "
-            + "[h2_prior_knowledge, h2_prior_knowledge]"));
-    }
-  }
-
-  @Test public void testMockWebServerH2PriorKnowledgeProtocol() {
-    server.setProtocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE));
-
-    assertThat(server.protocols().size()).isEqualTo(1);
-    assertThat(server.protocols().get(0)).isEqualTo(Protocol.H2_PRIOR_KNOWLEDGE);
-  }
-
-  @Test public void https() throws Exception {
-    HandshakeCertificates handshakeCertificates = localhost();
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    HttpUrl url = server.url("/");
-    HttpsURLConnection connection = (HttpsURLConnection) url.url().openConnection();
-    connection.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
-    connection.setHostnameVerifier(new RecordingHostnameVerifier());
-
-    assertThat(connection.getResponseCode()).isEqualTo(HttpURLConnection.HTTP_OK);
-    BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
-    assertThat(reader.readLine()).isEqualTo("abc");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getRequestUrl().scheme()).isEqualTo("https");
-    Handshake handshake = request.getHandshake();
-    assertThat(handshake.tlsVersion()).isNotNull();
-    assertThat(handshake.cipherSuite()).isNotNull();
-    assertThat(handshake.localPrincipal()).isNotNull();
-    assertThat(handshake.localCertificates().size()).isEqualTo(1);
-    assertThat(handshake.peerPrincipal()).isNull();
-    assertThat(handshake.peerCertificates().size()).isEqualTo(0);
-  }
-
-  @Test public void httpsWithClientAuth() throws Exception {
-    HeldCertificate clientCa = new HeldCertificate.Builder()
-        .certificateAuthority(0)
-        .build();
-    HeldCertificate serverCa = new HeldCertificate.Builder()
-        .certificateAuthority(0)
-        .build();
-    HeldCertificate serverCertificate = new HeldCertificate.Builder()
-        .signedBy(serverCa)
-        .addSubjectAlternativeName(server.getHostName())
-        .build();
-    HandshakeCertificates serverHandshakeCertificates = new HandshakeCertificates.Builder()
-        .addTrustedCertificate(clientCa.certificate())
-        .heldCertificate(serverCertificate)
-        .build();
-
-    server.useHttps(serverHandshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.requestClientAuth();
-
-    HeldCertificate clientCertificate = new HeldCertificate.Builder()
-        .signedBy(clientCa)
-        .build();
-    HandshakeCertificates clientHandshakeCertificates = new HandshakeCertificates.Builder()
-        .addTrustedCertificate(serverCa.certificate())
-        .heldCertificate(clientCertificate)
-        .build();
-
-    HttpUrl url = server.url("/");
-    HttpsURLConnection connection = (HttpsURLConnection) url.url().openConnection();
-    connection.setSSLSocketFactory(clientHandshakeCertificates.sslSocketFactory());
-    connection.setHostnameVerifier(new RecordingHostnameVerifier());
-
-    assertThat(connection.getResponseCode()).isEqualTo(HttpURLConnection.HTTP_OK);
-    BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
-    assertThat(reader.readLine()).isEqualTo("abc");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getRequestUrl().scheme()).isEqualTo("https");
-    Handshake handshake = request.getHandshake();
-    assertThat(handshake.tlsVersion()).isNotNull();
-    assertThat(handshake.cipherSuite()).isNotNull();
-    assertThat(handshake.localPrincipal()).isNotNull();
-    assertThat(handshake.localCertificates().size()).isEqualTo(1);
-    assertThat(handshake.peerPrincipal()).isNotNull();
-    assertThat(handshake.peerCertificates().size()).isEqualTo(1);
-  }
-}
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/RecordedRequestTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/RecordedRequestTest.java
deleted file mode 100644
index 8a58c17e22..0000000000
--- a/mockwebserver/src/test/java/okhttp3/mockwebserver/RecordedRequestTest.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package okhttp3.mockwebserver;
-
-import java.net.Inet4Address;
-import java.net.InetAddress;
-import java.net.Socket;
-import java.net.UnknownHostException;
-import java.util.Collections;
-import okhttp3.Headers;
-import okhttp3.internal.Util;
-import okio.Buffer;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public class RecordedRequestTest {
-  Headers headers = Util.EMPTY_HEADERS;
-
-  private class FakeSocket extends Socket {
-    private final InetAddress localAddress;
-    private final int remotePort;
-    private final InetAddress remoteAddress;
-    private final int localPort;
-
-    private FakeSocket(int localPort) {
-      this(Inet4Address.getLoopbackAddress(), localPort);
-    }
-
-    private FakeSocket(InetAddress inetAddress, int localPort) {
-      this(inetAddress, localPort, inetAddress, 1234);
-    }
-
-    private FakeSocket(InetAddress localAddress, int localPort, InetAddress remoteAddress, int remotePort) {
-      this.localAddress = localAddress;
-      this.localPort = localPort;
-      this.remoteAddress = remoteAddress;
-      this.remotePort = remotePort;
-    }
-
-    @Override public InetAddress getInetAddress() {
-      return remoteAddress;
-    }
-
-    @Override public InetAddress getLocalAddress() {
-      return localAddress;
-    }
-
-    @Override public int getLocalPort() {
-      return localPort;
-    }
-
-    @Override public int getPort() {
-      return remotePort;
-    }
-  }
-
-  @Test public void testIPv4() throws UnknownHostException {
-    Socket socket =
-        new FakeSocket(InetAddress.getByAddress("127.0.0.1", new byte[] { 127, 0, 0, 1 }), 80);
-
-    RecordedRequest request = new RecordedRequest("GET / HTTP/1.1", headers,
-        Collections.emptyList(), 0, new Buffer(), 0, socket);
-
-    assertThat(request.getRequestUrl().toString()).isEqualTo("http://127.0.0.1/");
-  }
-
-  @Test public void testIpv6() throws UnknownHostException {
-    Socket socket = new FakeSocket(InetAddress.getByAddress("::1",
-        new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 }), 80);
-
-    RecordedRequest request = new RecordedRequest("GET / HTTP/1.1", headers,
-        Collections.emptyList(), 0, new Buffer(), 0, socket);
-
-    assertThat(request.getRequestUrl().toString()).isEqualTo("http://[::1]/");
-  }
-
-  @Test public void testUsesLocal() throws UnknownHostException {
-    Socket socket =
-        new FakeSocket(InetAddress.getByAddress("127.0.0.1", new byte[] { 127, 0, 0, 1 }), 80);
-
-    RecordedRequest request = new RecordedRequest("GET / HTTP/1.1", headers,
-        Collections.emptyList(), 0, new Buffer(), 0, socket);
-
-    assertThat(request.getRequestUrl().toString()).isEqualTo("http://127.0.0.1/");
-  }
-}
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java
deleted file mode 100644
index b7ca4b2488..0000000000
--- a/mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java
+++ /dev/null
@@ -1,187 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package okhttp3.mockwebserver.internal.http2;
-
-import java.io.File;
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.net.ServerSocket;
-import java.net.Socket;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-import okhttp3.Headers;
-import okhttp3.Protocol;
-import okhttp3.internal.Util;
-import okhttp3.internal.http2.Header;
-import okhttp3.internal.http2.Http2Connection;
-import okhttp3.internal.http2.Http2Stream;
-import okhttp3.internal.platform.Platform;
-import okio.BufferedSink;
-import okio.Okio;
-import okio.Source;
-
-import static okhttp3.internal.platform.Platform.INFO;
-import static okhttp3.tls.internal.TlsUtil.localhost;
-
-/** A basic HTTP/2 server that serves the contents of a local directory. */
-public final class Http2Server extends Http2Connection.Listener {
-  static final Logger logger = Logger.getLogger(Http2Server.class.getName());
-
-  private final File baseDirectory;
-  private final SSLSocketFactory sslSocketFactory;
-
-  public Http2Server(File baseDirectory, SSLSocketFactory sslSocketFactory) {
-    this.baseDirectory = baseDirectory;
-    this.sslSocketFactory = sslSocketFactory;
-  }
-
-  private void run() throws Exception {
-    ServerSocket serverSocket = new ServerSocket(8888);
-    serverSocket.setReuseAddress(true);
-
-    while (true) {
-      Socket socket = null;
-      try {
-        socket = serverSocket.accept();
-
-        SSLSocket sslSocket = doSsl(socket);
-        String protocolString = Platform.get().getSelectedProtocol(sslSocket);
-        Protocol protocol = protocolString != null ? Protocol.get(protocolString) : null;
-        if (protocol != Protocol.HTTP_2) {
-          throw new ProtocolException("Protocol " + protocol + " unsupported");
-        }
-        Http2Connection connection = new Http2Connection.Builder(false)
-            .socket(sslSocket)
-            .listener(this)
-            .build();
-        connection.start();
-      } catch (IOException e) {
-        logger.log(Level.INFO, "Http2Server connection failure: " + e);
-        Util.closeQuietly(socket);
-      } catch (Exception e) {
-        logger.log(Level.WARNING, "Http2Server unexpected failure", e);
-        Util.closeQuietly(socket);
-      }
-    }
-  }
-
-  private SSLSocket doSsl(Socket socket) throws IOException {
-    SSLSocket sslSocket = (SSLSocket) sslSocketFactory.createSocket(
-        socket, socket.getInetAddress().getHostAddress(), socket.getPort(), true);
-    sslSocket.setUseClientMode(false);
-    Platform.get().configureTlsExtensions(sslSocket, null,
-        Collections.singletonList(Protocol.HTTP_2));
-    sslSocket.startHandshake();
-    return sslSocket;
-  }
-
-  @Override public void onStream(Http2Stream stream) throws IOException {
-    try {
-      Headers requestHeaders = stream.takeHeaders();
-      String path = null;
-      for (int i = 0, size = requestHeaders.size(); i < size; i++) {
-        if (requestHeaders.name(i).equals(Header.TARGET_PATH_UTF8)) {
-          path = requestHeaders.value(i);
-          break;
-        }
-      }
-
-      if (path == null) {
-        // TODO: send bad request error
-        throw new AssertionError();
-      }
-
-      File file = new File(baseDirectory + path);
-
-      if (file.isDirectory()) {
-        serveDirectory(stream, file.listFiles());
-      } else if (file.exists()) {
-        serveFile(stream, file);
-      } else {
-        send404(stream, path);
-      }
-    } catch (IOException e) {
-      Platform.get().log(INFO, "Failure serving Http2Stream: " + e.getMessage(), null);
-    }
-  }
-
-  private void send404(Http2Stream stream, String path) throws IOException {
-    List<Header> responseHeaders = Arrays.asList(
-        new Header(":status", "404"),
-        new Header(":version", "HTTP/1.1"),
-        new Header("content-type", "text/plain")
-    );
-    stream.writeHeaders(responseHeaders, false, false);
-    BufferedSink out = Okio.buffer(stream.getSink());
-    out.writeUtf8("Not found: " + path);
-    out.close();
-  }
-
-  private void serveDirectory(Http2Stream stream, File[] files) throws IOException {
-    List<Header> responseHeaders = Arrays.asList(
-        new Header(":status", "200"),
-        new Header(":version", "HTTP/1.1"),
-        new Header("content-type", "text/html; charset=UTF-8")
-    );
-    stream.writeHeaders(responseHeaders, false, false);
-    BufferedSink out = Okio.buffer(stream.getSink());
-    for (File file : files) {
-      String target = file.isDirectory() ? (file.getName() + "/") : file.getName();
-      out.writeUtf8("<a href='" + target + "'>" + target + "</a><br>");
-    }
-    out.close();
-  }
-
-  private void serveFile(Http2Stream stream, File file) throws IOException {
-    List<Header> responseHeaders = Arrays.asList(
-        new Header(":status", "200"),
-        new Header(":version", "HTTP/1.1"),
-        new Header("content-type", contentType(file))
-    );
-    stream.writeHeaders(responseHeaders, false, false);
-    try (Source source = Okio.source(file); BufferedSink sink = Okio.buffer(stream.getSink())) {
-      sink.writeAll(source);
-    }
-  }
-
-  private String contentType(File file) {
-    if (file.getName().endsWith(".css")) return "text/css";
-    if (file.getName().endsWith(".gif")) return "image/gif";
-    if (file.getName().endsWith(".html")) return "text/html";
-    if (file.getName().endsWith(".jpeg")) return "image/jpeg";
-    if (file.getName().endsWith(".jpg")) return "image/jpeg";
-    if (file.getName().endsWith(".js")) return "application/javascript";
-    if (file.getName().endsWith(".png")) return "image/png";
-    return "text/plain";
-  }
-
-  public static void main(String... args) throws Exception {
-    if (args.length != 1 || args[0].startsWith("-")) {
-      System.out.println("Usage: Http2Server <base directory>");
-      return;
-    }
-
-    Http2Server server = new Http2Server(new File(args[0]),
-        localhost().sslContext().getSocketFactory());
-    server.run();
-  }
-}
diff --git a/okcurl/README.md b/okcurl/README.md
deleted file mode 100644
index 4c65202b11..0000000000
--- a/okcurl/README.md
+++ /dev/null
@@ -1,7 +0,0 @@
-OkCurl
-======
-
-_A curl for the next-generation web._
-
-OkCurl is an OkHttp-backed curl clone which allows you to test OkHttp's HTTP engine (including
-HTTP/2) against web servers.
diff --git a/okcurl/pom.xml b/okcurl/pom.xml
deleted file mode 100644
index 7c642269d7..0000000000
--- a/okcurl/pom.xml
+++ /dev/null
@@ -1,115 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.14.3-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>okcurl</artifactId>
-  <name>OkCurl</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>logging-interceptor</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-testing-support</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>io.airlift</groupId>
-      <artifactId>airline</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>com.google.guava</groupId>
-      <artifactId>guava</artifactId>
-    </dependency>
-
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <resources>
-      <resource>
-        <directory>src/main/resources</directory>
-        <filtering>true</filtering>
-      </resource>
-    </resources>
-
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-assembly-plugin</artifactId>
-        <version>3.1.0</version>
-        <configuration>
-          <descriptorRefs>
-            <descriptorRef>jar-with-dependencies</descriptorRef>
-          </descriptorRefs>
-          <archive>
-            <manifest>
-              <mainClass>okhttp3.curl.Main</mainClass>
-            </manifest>
-          </archive>
-        </configuration>
-        <executions>
-          <execution>
-            <phase>package</phase>
-            <goals>
-              <goal>single</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
-      <plugin>
-        <groupId>org.skife.maven</groupId>
-        <artifactId>really-executable-jar-maven-plugin</artifactId>
-        <version>1.5.0</version>
-        <executions>
-          <execution>
-            <phase>package</phase>
-            <goals>
-              <goal>really-executable-jar</goal>
-            </goals>
-          </execution>
-        </executions>
-        <configuration>
-          <flags>-Xbootclasspath/p:$0</flags>
-        </configuration>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-jar-plugin</artifactId>
-        <version>3.1.1</version>
-        <configuration>
-          <archive>
-            <manifestEntries>
-              <Automatic-Module-Name>okhttp3.curl</Automatic-Module-Name>
-            </manifestEntries>
-          </archive>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/okcurl/src/main/java/okhttp3/curl/Main.java b/okcurl/src/main/java/okhttp3/curl/Main.java
deleted file mode 100644
index 22c8b5c45c..0000000000
--- a/okcurl/src/main/java/okhttp3/curl/Main.java
+++ /dev/null
@@ -1,303 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.curl;
-
-import com.google.common.base.Joiner;
-import io.airlift.airline.Arguments;
-import io.airlift.airline.Command;
-import io.airlift.airline.HelpOption;
-import io.airlift.airline.Option;
-import io.airlift.airline.SingleCommand;
-import java.io.IOException;
-import java.io.InputStream;
-import java.security.cert.X509Certificate;
-import java.util.List;
-import java.util.Properties;
-import java.util.logging.ConsoleHandler;
-import java.util.logging.Level;
-import java.util.logging.LogRecord;
-import java.util.logging.Logger;
-import java.util.logging.SimpleFormatter;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.Headers;
-import okhttp3.MediaType;
-import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.internal.Util;
-import okhttp3.internal.http.StatusLine;
-import okhttp3.internal.http2.Http2;
-import okhttp3.internal.platform.Platform;
-import okhttp3.logging.HttpLoggingInterceptor;
-import okhttp3.logging.LoggingEventListener;
-import okio.BufferedSource;
-import okio.Okio;
-import okio.Sink;
-
-import static java.util.concurrent.TimeUnit.SECONDS;
-
-@Command(name = Main.NAME, description = "A curl for the next-generation web.")
-public class Main extends HelpOption implements Runnable {
-  static final String NAME = "okcurl";
-  static final int DEFAULT_TIMEOUT = -1;
-  private static Logger frameLogger;
-
-  static Main fromArgs(String... args) {
-    return SingleCommand.singleCommand(Main.class).parse(args);
-  }
-
-  public static void main(String... args) {
-    fromArgs(args).run();
-  }
-
-  private static String versionString() {
-    try {
-      Properties prop = new Properties();
-      InputStream in = Main.class.getResourceAsStream("/okcurl-version.properties");
-      prop.load(in);
-      in.close();
-      return prop.getProperty("version");
-    } catch (IOException e) {
-      throw new AssertionError("Could not load okcurl-version.properties.");
-    }
-  }
-
-  private static String protocols() {
-    return Joiner.on(", ").join(Protocol.values());
-  }
-
-  @Option(name = {"-X", "--request"}, description = "Specify request command to use")
-  public String method;
-
-  @Option(name = {"-d", "--data"}, description = "HTTP POST data")
-  public String data;
-
-  @Option(name = {"-H", "--header"}, description = "Custom header to pass to server")
-  public List<String> headers;
-
-  @Option(name = {"-A", "--user-agent"}, description = "User-Agent to send to server")
-  public String userAgent = NAME + "/" + versionString();
-
-  @Option(name = "--connect-timeout", description = "Maximum time allowed for connection (seconds)")
-  public int connectTimeout = DEFAULT_TIMEOUT;
-
-  @Option(name = "--read-timeout", description = "Maximum time allowed for reading data (seconds)")
-  public int readTimeout = DEFAULT_TIMEOUT;
-
-  @Option(
-      name = "--call-timeout",
-      description = "Maximum time allowed for the entire call (seconds)")
-  public int callTimeout = DEFAULT_TIMEOUT;
-
-  @Option(name = {"-L", "--location"}, description = "Follow redirects")
-  public boolean followRedirects;
-
-  @Option(name = {"-k", "--insecure"},
-      description = "Allow connections to SSL sites without certs")
-  public boolean allowInsecure;
-
-  @Option(name = {"-i", "--include"}, description = "Include protocol headers in the output")
-  public boolean showHeaders;
-
-  @Option(name = "--frames", description = "Log HTTP/2 frames to STDERR")
-  public boolean showHttp2Frames;
-
-  @Option(name = {"-e", "--referer"}, description = "Referer URL")
-  public String referer;
-
-  @Option(name = {"-V", "--version"}, description = "Show version number and quit")
-  public boolean version;
-
-  @Option(
-      name = {"-v", "--verbose"},
-      description = "Makes " + NAME + " verbose during the operation")
-  public boolean verbose;
-
-  @Arguments(title = "url", description = "Remote resource URL")
-  public String url;
-
-  private OkHttpClient client;
-
-  @Override public void run() {
-    if (showHelpIfRequested()) {
-      return;
-    }
-    if (version) {
-      System.out.println(NAME + " " + versionString());
-      System.out.println("Protocols: " + protocols());
-      return;
-    }
-
-    if (showHttp2Frames) {
-      enableHttp2FrameLogging();
-    }
-
-    client = createClient();
-    Request request = createRequest();
-    try {
-      Response response = client.newCall(request).execute();
-      if (showHeaders) {
-        System.out.println(StatusLine.get(response));
-        Headers headers = response.headers();
-        for (int i = 0, size = headers.size(); i < size; i++) {
-          System.out.println(headers.name(i) + ": " + headers.value(i));
-        }
-        System.out.println();
-      }
-
-      // Stream the response to the System.out as it is returned from the server.
-      Sink out = Okio.sink(System.out);
-      BufferedSource source = response.body().source();
-      while (!source.exhausted()) {
-        out.write(source.getBuffer(), source.getBuffer().size());
-        out.flush();
-      }
-
-      response.body().close();
-    } catch (IOException e) {
-      e.printStackTrace();
-    } finally {
-      close();
-    }
-  }
-
-  private OkHttpClient createClient() {
-    OkHttpClient.Builder builder = new OkHttpClient.Builder();
-    builder.followSslRedirects(followRedirects);
-    if (connectTimeout != DEFAULT_TIMEOUT) {
-      builder.connectTimeout(connectTimeout, SECONDS);
-    }
-    if (readTimeout != DEFAULT_TIMEOUT) {
-      builder.readTimeout(readTimeout, SECONDS);
-    }
-    if (callTimeout != DEFAULT_TIMEOUT) {
-      builder.callTimeout(callTimeout, SECONDS);
-    }
-    if (allowInsecure) {
-      X509TrustManager trustManager = createInsecureTrustManager();
-      SSLSocketFactory sslSocketFactory = createInsecureSslSocketFactory(trustManager);
-      builder.sslSocketFactory(sslSocketFactory, trustManager);
-      builder.hostnameVerifier(createInsecureHostnameVerifier());
-    }
-    if (verbose) {
-      HttpLoggingInterceptor.Logger logger = System.out::println;
-      builder.eventListenerFactory(new LoggingEventListener.Factory(logger));
-    }
-    return builder.build();
-  }
-
-  private String getRequestMethod() {
-    if (method != null) {
-      return method;
-    }
-    if (data != null) {
-      return "POST";
-    }
-    return "GET";
-  }
-
-  private RequestBody getRequestBody() {
-    if (data == null) {
-      return null;
-    }
-    String bodyData = data;
-
-    String mimeType = "application/x-www-form-urlencoded";
-    if (headers != null) {
-      for (String header : headers) {
-        String[] parts = header.split(":", -1);
-        if ("Content-Type".equalsIgnoreCase(parts[0])) {
-          mimeType = parts[1].trim();
-          headers.remove(header);
-          break;
-        }
-      }
-    }
-
-    return RequestBody.create(MediaType.parse(mimeType), bodyData);
-  }
-
-  Request createRequest() {
-    Request.Builder request = new Request.Builder();
-
-    request.url(url);
-    request.method(getRequestMethod(), getRequestBody());
-
-    if (headers != null) {
-      for (String header : headers) {
-        String[] parts = header.split(":", 2);
-        request.header(parts[0], parts[1]);
-      }
-    }
-    if (referer != null) {
-      request.header("Referer", referer);
-    }
-    request.header("User-Agent", userAgent);
-
-    return request.build();
-  }
-
-  private void close() {
-    client.connectionPool().evictAll(); // Close any persistent connections.
-  }
-
-  private static X509TrustManager createInsecureTrustManager() {
-    return new X509TrustManager() {
-      @Override public void checkClientTrusted(X509Certificate[] chain, String authType) {
-      }
-
-      @Override public void checkServerTrusted(X509Certificate[] chain, String authType) {
-      }
-
-      @Override public X509Certificate[] getAcceptedIssuers() {
-        return new X509Certificate[0];
-      }
-    };
-  }
-
-  private static SSLSocketFactory createInsecureSslSocketFactory(TrustManager trustManager) {
-    try {
-      SSLContext context = Platform.get().getSSLContext();
-      context.init(null, new TrustManager[] {trustManager}, null);
-      return context.getSocketFactory();
-    } catch (Exception e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  private static HostnameVerifier createInsecureHostnameVerifier() {
-    return (name, session) -> true;
-  }
-
-  private static void enableHttp2FrameLogging() {
-    frameLogger = Logger.getLogger(Http2.class.getName());
-    frameLogger.setLevel(Level.FINE);
-    ConsoleHandler handler = new ConsoleHandler();
-    handler.setLevel(Level.FINE);
-    handler.setFormatter(new SimpleFormatter() {
-      @Override public String format(LogRecord record) {
-        return Util.format("%s%n", record.getMessage());
-      }
-    });
-    frameLogger.addHandler(handler);
-  }
-}
diff --git a/okcurl/src/main/resources/okcurl-version.properties b/okcurl/src/main/resources/okcurl-version.properties
deleted file mode 100644
index defbd48204..0000000000
--- a/okcurl/src/main/resources/okcurl-version.properties
+++ /dev/null
@@ -1 +0,0 @@
-version=${project.version}
diff --git a/okcurl/src/test/java/okhttp3/curl/MainTest.java b/okcurl/src/test/java/okhttp3/curl/MainTest.java
deleted file mode 100644
index d4542fbedc..0000000000
--- a/okcurl/src/test/java/okhttp3/curl/MainTest.java
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.curl;
-
-import java.io.IOException;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okio.Buffer;
-import org.junit.Test;
-
-import static okhttp3.curl.Main.fromArgs;
-import static org.assertj.core.api.Assertions.assertThat;
-
-public class MainTest {
-  @Test public void simple() {
-    Request request = fromArgs("http://example.com").createRequest();
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void put() throws IOException {
-    Request request = fromArgs("-X", "PUT", "-d", "foo", "http://example.com").createRequest();
-    assertThat(request.method()).isEqualTo("PUT");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/");
-    assertThat(request.body().contentLength()).isEqualTo(3);
-  }
-
-  @Test public void dataPost() {
-    Request request = fromArgs("-d", "foo", "http://example.com").createRequest();
-    RequestBody body = request.body();
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/");
-    assertThat(body.contentType().toString()).isEqualTo(
-        "application/x-www-form-urlencoded; charset=utf-8");
-    assertThat(bodyAsString(body)).isEqualTo("foo");
-  }
-
-  @Test public void dataPut() {
-    Request request = fromArgs("-d", "foo", "-X", "PUT", "http://example.com").createRequest();
-    RequestBody body = request.body();
-    assertThat(request.method()).isEqualTo("PUT");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/");
-    assertThat(body.contentType().toString()).isEqualTo(
-        "application/x-www-form-urlencoded; charset=utf-8");
-    assertThat(bodyAsString(body)).isEqualTo("foo");
-  }
-
-  @Test public void contentTypeHeader() {
-    Request request = fromArgs("-d", "foo", "-H", "Content-Type: application/json",
-        "http://example.com").createRequest();
-    RequestBody body = request.body();
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/");
-    assertThat(body.contentType().toString()).isEqualTo("application/json; charset=utf-8");
-    assertThat(bodyAsString(body)).isEqualTo("foo");
-  }
-
-  @Test public void referer() {
-    Request request = fromArgs("-e", "foo", "http://example.com").createRequest();
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/");
-    assertThat(request.header("Referer")).isEqualTo("foo");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void userAgent() {
-    Request request = fromArgs("-A", "foo", "http://example.com").createRequest();
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/");
-    assertThat(request.header("User-Agent")).isEqualTo("foo");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void headerSplitWithDate() {
-    Request request = fromArgs("-H", "If-Modified-Since: Mon, 18 Aug 2014 15:16:06 GMT",
-        "http://example.com").createRequest();
-    assertThat(request.header("If-Modified-Since")).isEqualTo(
-        "Mon, 18 Aug 2014 15:16:06 GMT");
-  }
-
-  private static String bodyAsString(RequestBody body) {
-    try {
-      Buffer buffer = new Buffer();
-      body.writeTo(buffer);
-      return buffer.readString(body.contentType().charset());
-    } catch (IOException e) {
-      throw new RuntimeException(e);
-    }
-  }
-}
diff --git a/okhttp-dnsoverhttps/README.md b/okhttp-dnsoverhttps/README.md
deleted file mode 100644
index 30132b47c8..0000000000
--- a/okhttp-dnsoverhttps/README.md
+++ /dev/null
@@ -1,5 +0,0 @@
-OkHttp DNS over HTTPS Implementation
-====================================
-
-This module is an experimental implementation of DNS over HTTPS using OkHttp.
-API is not considered stable and may change at any time.
diff --git a/okhttp-dnsoverhttps/pom.xml b/okhttp-dnsoverhttps/pom.xml
deleted file mode 100644
index 2e70d6e721..0000000000
--- a/okhttp-dnsoverhttps/pom.xml
+++ /dev/null
@@ -1,72 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.14.3-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>okhttp-dnsoverhttps</artifactId>
-  <name>OkHttp DNS over HTTPS</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.google.code.findbugs</groupId>
-      <artifactId>jsr305</artifactId>
-      <scope>provided</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-testing-support</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.conscrypt</groupId>
-      <artifactId>conscrypt-openjdk-uber</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-jar-plugin</artifactId>
-        <version>3.1.1</version>
-        <configuration>
-          <archive>
-            <manifestEntries>
-              <Automatic-Module-Name>okhttp3.dnsoverhttps</Automatic-Module-Name>
-            </manifestEntries>
-          </archive>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/BootstrapDns.java b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/BootstrapDns.java
deleted file mode 100644
index 2cd474d30b..0000000000
--- a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/BootstrapDns.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.dnsoverhttps;
-
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.util.List;
-import okhttp3.Dns;
-
-/**
- * Internal Bootstrap DNS implementation for handling initial connection to DNS over HTTPS server.
- *
- * Returns hardcoded results for the known host.
- */
-final class BootstrapDns implements Dns {
-  private final String dnsHostname;
-  private final List<InetAddress> dnsServers;
-
-  BootstrapDns(String dnsHostname, List<InetAddress> dnsServers) {
-    this.dnsHostname = dnsHostname;
-    this.dnsServers = dnsServers;
-  }
-
-  @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
-    if (!this.dnsHostname.equals(hostname)) {
-      throw new UnknownHostException(
-          "BootstrapDns called for " + hostname + " instead of " + dnsHostname);
-    }
-
-    return dnsServers;
-  }
-}
diff --git a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.java b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.java
deleted file mode 100644
index 67442f3313..0000000000
--- a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.java
+++ /dev/null
@@ -1,359 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.dnsoverhttps;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.concurrent.CountDownLatch;
-import javax.annotation.Nullable;
-import okhttp3.CacheControl;
-import okhttp3.Call;
-import okhttp3.Callback;
-import okhttp3.Dns;
-import okhttp3.HttpUrl;
-import okhttp3.MediaType;
-import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.internal.Util;
-import okhttp3.internal.platform.Platform;
-import okhttp3.internal.publicsuffix.PublicSuffixDatabase;
-import okio.ByteString;
-
-/**
- * DNS over HTTPS implementation.
- *
- * Implementation of https://tools.ietf.org/html/draft-ietf-doh-dns-over-https-13
- *
- * <blockquote>A DNS API client encodes a single DNS query into an HTTP request
- * using either the HTTP GET or POST method and the other requirements
- * of this section.  The DNS API server defines the URI used by the
- * request through the use of a URI Template.</blockquote>
- *
- * <h3>Warning: This is a non-final API.</h3>
- *
- * <p><strong>As of OkHttp 3.11, this feature is an unstable preview: the API is subject to change,
- * and the implementation is incomplete. We expect that OkHttp 3.12 or 3.13 will finalize this API.
- * Until then, expect API and behavior changes when you update your OkHttp dependency.</strong>
- */
-public class DnsOverHttps implements Dns {
-  public static final MediaType DNS_MESSAGE = MediaType.get("application/dns-message");
-  public static final int MAX_RESPONSE_SIZE = 64 * 1024;
-  private final OkHttpClient client;
-  private final HttpUrl url;
-  private final boolean includeIPv6;
-  private final boolean post;
-  private final boolean resolvePrivateAddresses;
-  private final boolean resolvePublicAddresses;
-
-  DnsOverHttps(Builder builder) {
-    if (builder.client == null) {
-      throw new NullPointerException("client not set");
-    }
-    if (builder.url == null) {
-      throw new NullPointerException("url not set");
-    }
-
-    this.url = builder.url;
-    this.includeIPv6 = builder.includeIPv6;
-    this.post = builder.post;
-    this.resolvePrivateAddresses = builder.resolvePrivateAddresses;
-    this.resolvePublicAddresses = builder.resolvePublicAddresses;
-    this.client = builder.client.newBuilder().dns(buildBootstrapClient(builder)).build();
-  }
-
-  private static Dns buildBootstrapClient(Builder builder) {
-    List<InetAddress> hosts = builder.bootstrapDnsHosts;
-
-    if (hosts != null) {
-      return new BootstrapDns(builder.url.host(), hosts);
-    } else {
-      return builder.systemDns;
-    }
-  }
-
-  public HttpUrl url() {
-    return url;
-  }
-
-  public boolean post() {
-    return post;
-  }
-
-  public boolean includeIPv6() {
-    return includeIPv6;
-  }
-
-  public OkHttpClient client() {
-    return client;
-  }
-
-  public boolean resolvePrivateAddresses() {
-    return resolvePrivateAddresses;
-  }
-
-  public boolean resolvePublicAddresses() {
-    return resolvePublicAddresses;
-  }
-
-  @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
-    if (!resolvePrivateAddresses || !resolvePublicAddresses) {
-      boolean privateHost = isPrivateHost(hostname);
-
-      if (privateHost && !resolvePrivateAddresses) {
-        throw new UnknownHostException("private hosts not resolved");
-      }
-
-      if (!privateHost && !resolvePublicAddresses) {
-        throw new UnknownHostException("public hosts not resolved");
-      }
-    }
-
-    return lookupHttps(hostname);
-  }
-
-  private List<InetAddress> lookupHttps(String hostname) throws UnknownHostException {
-    List<Call> networkRequests = new ArrayList<>(2);
-    List<Exception> failures = new ArrayList<>(2);
-    List<InetAddress> results = new ArrayList<>(5);
-
-    buildRequest(hostname, networkRequests, results, failures, DnsRecordCodec.TYPE_A);
-
-    if (includeIPv6) {
-      buildRequest(hostname, networkRequests, results, failures, DnsRecordCodec.TYPE_AAAA);
-    }
-
-    executeRequests(hostname, networkRequests, results, failures);
-
-    if (!results.isEmpty()) {
-      return results;
-    }
-
-    return throwBestFailure(hostname, failures);
-  }
-
-  private void buildRequest(String hostname, List<Call> networkRequests, List<InetAddress> results,
-      List<Exception> failures, int type) {
-    Request request = buildRequest(hostname, type);
-    Response response = getCacheOnlyResponse(request);
-
-    if (response != null) {
-      processResponse(response, hostname, results, failures);
-    } else {
-      networkRequests.add(client.newCall(request));
-    }
-  }
-
-  private void executeRequests(final String hostname, List<Call> networkRequests,
-      final List<InetAddress> responses, final List<Exception> failures) {
-    final CountDownLatch latch = new CountDownLatch(networkRequests.size());
-
-    for (Call call : networkRequests) {
-      call.enqueue(new Callback() {
-        @Override public void onFailure(Call call, IOException e) {
-          synchronized (failures) {
-            failures.add(e);
-          }
-          latch.countDown();
-        }
-
-        @Override public void onResponse(Call call, Response response) {
-          processResponse(response, hostname, responses, failures);
-          latch.countDown();
-        }
-      });
-    }
-
-    try {
-      latch.await();
-    } catch (InterruptedException e) {
-      failures.add(e);
-    }
-  }
-
-  private void processResponse(Response response, String hostname, List<InetAddress> results,
-      List<Exception> failures) {
-    try {
-      List<InetAddress> addresses = readResponse(hostname, response);
-      synchronized (results) {
-        results.addAll(addresses);
-      }
-    } catch (Exception e) {
-      synchronized (failures) {
-        failures.add(e);
-      }
-    }
-  }
-
-  private List<InetAddress> throwBestFailure(String hostname, List<Exception> failures)
-      throws UnknownHostException {
-    if (failures.size() == 0) {
-      throw new UnknownHostException(hostname);
-    }
-
-    Exception failure = failures.get(0);
-
-    if (failure instanceof UnknownHostException) {
-      throw (UnknownHostException) failure;
-    }
-
-    UnknownHostException unknownHostException = new UnknownHostException(hostname);
-    unknownHostException.initCause(failure);
-
-    for (int i = 1; i < failures.size(); i++) {
-      Util.addSuppressedIfPossible(unknownHostException, failures.get(i));
-    }
-
-    throw unknownHostException;
-  }
-
-  private @Nullable Response getCacheOnlyResponse(Request request) {
-    if (!post && client.cache() != null) {
-      try {
-        Request cacheRequest = request.newBuilder().cacheControl(CacheControl.FORCE_CACHE).build();
-
-        Response cacheResponse = client.newCall(cacheRequest).execute();
-
-        if (cacheResponse.code() != 504) {
-          return cacheResponse;
-        }
-      } catch (IOException ioe) {
-        // Failures are ignored as we can fallback to the network
-        // and hopefully repopulate the cache.
-      }
-    }
-
-    return null;
-  }
-
-  private List<InetAddress> readResponse(String hostname, Response response) throws Exception {
-    if (response.cacheResponse() == null && response.protocol() != Protocol.HTTP_2) {
-      Platform.get().log(Platform.WARN, "Incorrect protocol: " + response.protocol(), null);
-    }
-
-    try {
-      if (!response.isSuccessful()) {
-        throw new IOException("response: " + response.code() + " " + response.message());
-      }
-
-      ResponseBody body = response.body();
-
-      if (body.contentLength() > MAX_RESPONSE_SIZE) {
-        throw new IOException("response size exceeds limit ("
-            + MAX_RESPONSE_SIZE
-            + " bytes): "
-            + body.contentLength()
-            + " bytes");
-      }
-
-      ByteString responseBytes = body.source().readByteString();
-
-      return DnsRecordCodec.decodeAnswers(hostname, responseBytes);
-    } finally {
-      response.close();
-    }
-  }
-
-  private Request buildRequest(String hostname, int type) {
-    Request.Builder requestBuilder = new Request.Builder().header("Accept", DNS_MESSAGE.toString());
-
-    ByteString query = DnsRecordCodec.encodeQuery(hostname, type);
-
-    if (post) {
-      requestBuilder = requestBuilder.url(url).post(RequestBody.create(DNS_MESSAGE, query));
-    } else {
-      String encoded = query.base64Url().replace("=", "");
-      HttpUrl requestUrl = url.newBuilder().addQueryParameter("dns", encoded).build();
-
-      requestBuilder = requestBuilder.url(requestUrl);
-    }
-
-    return requestBuilder.build();
-  }
-
-  static boolean isPrivateHost(String host) {
-    return PublicSuffixDatabase.get().getEffectiveTldPlusOne(host) == null;
-  }
-
-  public static final class Builder {
-    @Nullable OkHttpClient client = null;
-    @Nullable HttpUrl url = null;
-    boolean includeIPv6 = true;
-    boolean post = false;
-    Dns systemDns = Dns.SYSTEM;
-    @Nullable List<InetAddress> bootstrapDnsHosts = null;
-    boolean resolvePrivateAddresses = false;
-    boolean resolvePublicAddresses = true;
-
-    public Builder() {
-    }
-
-    public DnsOverHttps build() {
-      return new DnsOverHttps(this);
-    }
-
-    public Builder client(OkHttpClient client) {
-      this.client = client;
-      return this;
-    }
-
-    public Builder url(HttpUrl url) {
-      this.url = url;
-      return this;
-    }
-
-    public Builder includeIPv6(boolean includeIPv6) {
-      this.includeIPv6 = includeIPv6;
-      return this;
-    }
-
-    public Builder post(boolean post) {
-      this.post = post;
-      return this;
-    }
-
-    public Builder resolvePrivateAddresses(boolean resolvePrivateAddresses) {
-      this.resolvePrivateAddresses = resolvePrivateAddresses;
-      return this;
-    }
-
-    public Builder resolvePublicAddresses(boolean resolvePublicAddresses) {
-      this.resolvePublicAddresses = resolvePublicAddresses;
-      return this;
-    }
-
-    public Builder bootstrapDnsHosts(@Nullable List<InetAddress> bootstrapDnsHosts) {
-      this.bootstrapDnsHosts = bootstrapDnsHosts;
-      return this;
-    }
-
-    public Builder bootstrapDnsHosts(InetAddress... bootstrapDnsHosts) {
-      return bootstrapDnsHosts(Arrays.asList(bootstrapDnsHosts));
-    }
-
-    public Builder systemDns(Dns systemDns) {
-      this.systemDns = systemDns;
-      return this;
-    }
-  }
-}
diff --git a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsRecordCodec.java b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsRecordCodec.java
deleted file mode 100644
index 4c1cfc481e..0000000000
--- a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsRecordCodec.java
+++ /dev/null
@@ -1,139 +0,0 @@
-/*
- * Copyright 2016 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
- * "License"); you may not use this file except in compliance with the License. You may obtain a
- * copy of the License at:
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License
- * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations under
- * the License.
- */
-
-package okhttp3.dnsoverhttps;
-
-import java.io.EOFException;
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.nio.charset.Charset;
-import java.util.ArrayList;
-import java.util.List;
-import okio.Buffer;
-import okio.ByteString;
-import okio.Utf8;
-
-/**
- * Trivial Dns Encoder/Decoder, basically ripped from Netty full implementation.
- */
-class DnsRecordCodec {
-  private static final byte SERVFAIL = 2;
-  private static final byte NXDOMAIN = 3;
-  public static final int TYPE_A = 0x0001;
-  public static final int TYPE_AAAA = 0x001c;
-  private static final int TYPE_PTR = 0x000c;
-  private static final Charset ASCII = Charset.forName("ASCII");
-
-  private DnsRecordCodec() {
-  }
-
-  public static ByteString encodeQuery(String host, int type) {
-    Buffer buf = new Buffer();
-
-    buf.writeShort(0); // query id
-    buf.writeShort(256); // flags with recursion
-    buf.writeShort(1); // question count
-    buf.writeShort(0); // answerCount
-    buf.writeShort(0); // authorityResourceCount
-    buf.writeShort(0); // additional
-
-    Buffer nameBuf = new Buffer();
-    final String[] labels = host.split("\\.");
-    for (String label : labels) {
-      long utf8ByteCount = Utf8.size(label);
-      if (utf8ByteCount != label.length()) {
-        throw new IllegalArgumentException("non-ascii hostname: " + host);
-      }
-      nameBuf.writeByte((byte) utf8ByteCount);
-      nameBuf.writeUtf8(label);
-    }
-    nameBuf.writeByte(0); // end
-
-    nameBuf.copyTo(buf, 0, nameBuf.size());
-    buf.writeShort(type);
-    buf.writeShort(1); // CLASS_IN
-
-    return buf.readByteString();
-  }
-
-  public static List<InetAddress> decodeAnswers(String hostname, ByteString byteString)
-      throws Exception {
-    List<InetAddress> result = new ArrayList<>();
-
-    Buffer buf = new Buffer();
-    buf.write(byteString);
-    buf.readShort(); // query id
-
-    final int flags = buf.readShort() & 0xffff;
-    if (flags >> 15 == 0) {
-      throw new IllegalArgumentException("not a response");
-    }
-
-    byte responseCode = (byte) (flags & 0xf);
-
-    if (responseCode == NXDOMAIN) {
-      throw new UnknownHostException(hostname + ": NXDOMAIN");
-    } else if (responseCode == SERVFAIL) {
-      throw new UnknownHostException(hostname + ": SERVFAIL");
-    }
-
-    final int questionCount = buf.readShort() & 0xffff;
-    final int answerCount = buf.readShort() & 0xffff;
-    buf.readShort(); // authority record count
-    buf.readShort(); // additional record count
-
-    for (int i = 0; i < questionCount; i++) {
-      skipName(buf); // name
-      buf.readShort(); // type
-      buf.readShort(); // class
-    }
-
-    for (int i = 0; i < answerCount; i++) {
-      skipName(buf); // name
-
-      int type = buf.readShort() & 0xffff;
-      buf.readShort(); // class
-      final long ttl = buf.readInt() & 0xffffffffL; // ttl
-      final int length = buf.readShort() & 0xffff;
-
-      if (type == TYPE_A || type == TYPE_AAAA) {
-        byte[] bytes = new byte[length];
-        buf.read(bytes);
-        result.add(InetAddress.getByAddress(bytes));
-      } else {
-        buf.skip(length);
-      }
-    }
-
-    return result;
-  }
-
-  private static void skipName(Buffer in) throws EOFException {
-    // 0 - 63 bytes
-    int length = in.readByte();
-
-    if (length < 0) {
-      // compressed name pointer, first two bits are 1
-      // drop second byte of compression offset
-      in.skip(1);
-    } else {
-      while (length > 0) {
-        // skip each part of the domain name
-        in.skip(length);
-        length = in.readByte();
-      }
-    }
-  }
-}
diff --git a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/package-info.java b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/package-info.java
deleted file mode 100644
index 54da565bc2..0000000000
--- a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/package-info.java
+++ /dev/null
@@ -1,3 +0,0 @@
-/** A DNS over HTTPS implementation for OkHttp. */
-@okhttp3.internal.annotations.EverythingIsNonNull
-package okhttp3.dnsoverhttps;
diff --git a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsOverHttpsTest.java b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsOverHttpsTest.java
deleted file mode 100644
index 6c939bfdba..0000000000
--- a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsOverHttpsTest.java
+++ /dev/null
@@ -1,208 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.dnsoverhttps;
-
-import java.io.File;
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.util.Arrays;
-import java.util.HashSet;
-import java.util.LinkedHashSet;
-import java.util.List;
-import okhttp3.Cache;
-import okhttp3.Dns;
-import okhttp3.HttpUrl;
-import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
-import okio.Buffer;
-import okio.ByteString;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static java.util.Arrays.asList;
-import static java.util.Collections.singletonList;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public class DnsOverHttpsTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  private final OkHttpClient bootstrapClient =
-      new OkHttpClient.Builder().protocols(asList(Protocol.HTTP_2, Protocol.HTTP_1_1)).build();
-  private Dns dns = buildLocalhost(bootstrapClient, false);
-
-  @Before public void setUp() {
-    server.setProtocols(bootstrapClient.protocols());
-  }
-
-  @Test public void getOne() throws Exception {
-    server.enqueue(dnsResponse(
-        "0000818000010003000000000567726170680866616365626f6f6b03636f6d0000010001c00c00050001"
-            + "00000a6d000603617069c012c0300005000100000cde000c04737461720463313072c012c04200010"
-            + "0010000003b00049df00112"));
-
-    List<InetAddress> result = dns.lookup("google.com");
-
-    assertThat(result).isEqualTo(singletonList(address("157.240.1.18")));
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getMethod()).isEqualTo("GET");
-    assertThat(recordedRequest.getPath()).isEqualTo(
-        "/lookup?ct&dns=AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ");
-  }
-
-  @Test public void getIpv6() throws Exception {
-    server.enqueue(dnsResponse(
-        "0000818000010003000000000567726170680866616365626f6f6b03636f6d0000010001c00c00050001"
-            + "00000a6d000603617069c012c0300005000100000cde000c04737461720463313072c012c04200010"
-            + "0010000003b00049df00112"));
-    server.enqueue(dnsResponse(
-        "0000818000010003000000000567726170680866616365626f6f6b03636f6d00001c0001c00c00050001"
-            + "00000a1b000603617069c012c0300005000100000b1f000c04737461720463313072c012c042001c0"
-            + "0010000003b00102a032880f0290011faceb00c00000002"));
-
-    dns = buildLocalhost(bootstrapClient, true);
-
-    List<InetAddress> result = dns.lookup("google.com");
-
-    assertThat(result.size()).isEqualTo(2);
-    assertThat(result.contains(address("157.240.1.18"))).isTrue();
-    assertThat(result.contains(address("2a03:2880:f029:11:face:b00c:0:2"))).isTrue();
-
-    RecordedRequest request1 = server.takeRequest();
-    assertThat(request1.getMethod()).isEqualTo("GET");
-
-    RecordedRequest request2 = server.takeRequest();
-    assertThat(request2.getMethod()).isEqualTo("GET");
-
-    assertThat(new LinkedHashSet<>(Arrays.asList(request1.getPath(), request2.getPath()))).isEqualTo(
-        new HashSet<>(
-            Arrays.asList("/lookup?ct&dns=AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ",
-                "/lookup?ct&dns=AAABAAABAAAAAAAABmdvb2dsZQNjb20AABwAAQ")));
-  }
-
-  @Test public void failure() throws Exception {
-    server.enqueue(dnsResponse(
-        "0000818300010000000100000e7364666c6b686673646c6b6a64660265650000010001c01b00060001"
-            + "000007070038026e7303746c64c01b0a686f73746d61737465720d6565737469696e7465726e657"
-            + "4c01b5adb12c100000e10000003840012750000000e10"));
-
-    try {
-      dns.lookup("google.com");
-      fail();
-    } catch (UnknownHostException uhe) {
-      uhe.printStackTrace();
-      assertThat(uhe.getMessage()).isEqualTo("google.com: NXDOMAIN");
-    }
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getMethod()).isEqualTo("GET");
-    assertThat(recordedRequest.getPath()).isEqualTo(
-        "/lookup?ct&dns=AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ");
-  }
-
-  @Test public void failOnExcessiveResponse() {
-    char[] array = new char[128 * 1024 + 2];
-    Arrays.fill(array, '0');
-    server.enqueue(dnsResponse(new String(array)));
-
-    try {
-      dns.lookup("google.com");
-      fail();
-    } catch (IOException ioe) {
-      assertThat(ioe.getMessage()).isEqualTo("google.com");
-      Throwable cause = ioe.getCause();
-      assertThat(cause instanceof IOException).isTrue();
-      assertThat(cause.getMessage()).isEqualTo(
-          "response size exceeds limit (65536 bytes): 65537 bytes");
-    }
-  }
-
-  @Test public void failOnBadResponse() {
-    server.enqueue(dnsResponse("00"));
-
-    try {
-      dns.lookup("google.com");
-      fail();
-    } catch (IOException ioe) {
-      assertThat(ioe.getMessage()).isEqualTo("google.com");
-      Throwable cause = ioe.getCause();
-      boolean condition = cause instanceof RuntimeException;
-      assertThat(condition).isTrue();
-    }
-  }
-
-  // TODO GET preferred order - with tests to confirm this
-  // 1. successful fresh cached GET response
-  // 2. unsuccessful (404, 500) fresh cached GET response
-  // 3. successful network response
-  // 4. successful stale cached GET response
-  // 5. unsuccessful response
-
-  // TODO how closely to follow POST rules on caching?
-
-  @Test public void usesCache() throws Exception {
-    Cache cache = new Cache(new File("./target/DnsOverHttpsTest.cache"), 100 * 1024);
-    OkHttpClient cachedClient = bootstrapClient.newBuilder().cache(cache).build();
-    DnsOverHttps cachedDns = buildLocalhost(cachedClient, false);
-
-    server.enqueue(dnsResponse(
-        "0000818000010003000000000567726170680866616365626f6f6b03636f6d0000010001c00c00050001"
-            + "00000a6d000603617069c012c0300005000100000cde000c04737461720463313072c012c04200010"
-            + "0010000003b00049df00112").setHeader("cache-control", "private, max-age=298"));
-
-    List<InetAddress> result = cachedDns.lookup("google.com");
-
-    assertThat(result).containsExactly(address("157.240.1.18"));
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getMethod()).isEqualTo("GET");
-    assertThat(recordedRequest.getPath()).isEqualTo(
-        "/lookup?ct&dns=AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ");
-
-    result = cachedDns.lookup("google.com");
-    assertThat(result).isEqualTo(singletonList(address("157.240.1.18")));
-  }
-
-  private MockResponse dnsResponse(String s) {
-    return new MockResponse().setBody(new Buffer().write(ByteString.decodeHex(s)))
-        .addHeader("content-type", "application/dns-message")
-        .addHeader("content-length", s.length() / 2);
-  }
-
-  private DnsOverHttps buildLocalhost(OkHttpClient bootstrapClient, boolean includeIPv6) {
-    HttpUrl url = server.url("/lookup?ct");
-    return new DnsOverHttps.Builder().client(bootstrapClient)
-        .includeIPv6(includeIPv6)
-        .resolvePrivateAddresses(true)
-        .url(url)
-        .build();
-  }
-
-  private static InetAddress address(String host) {
-    try {
-      return InetAddress.getByName(host);
-    } catch (UnknownHostException e) {
-      // impossible for IP addresses
-      throw new RuntimeException(e);
-    }
-  }
-}
diff --git a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsRecordCodecTest.java b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsRecordCodecTest.java
deleted file mode 100644
index 8eea96c7bd..0000000000
--- a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsRecordCodecTest.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.dnsoverhttps;
-
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.util.List;
-import okio.ByteString;
-import org.junit.Test;
-
-import static okhttp3.dnsoverhttps.DnsRecordCodec.TYPE_A;
-import static okhttp3.dnsoverhttps.DnsRecordCodec.TYPE_AAAA;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public class DnsRecordCodecTest {
-  @Test public void testGoogleDotComEncoding() {
-    String encoded = encodeQuery("google.com", TYPE_A);
-
-    assertThat(encoded).isEqualTo("AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ");
-  }
-
-  private String encodeQuery(String host, int type) {
-    return DnsRecordCodec.encodeQuery(host, type).base64Url().replace("=", "");
-  }
-
-  @Test public void testGoogleDotComEncodingWithIPv6() {
-    String encoded = encodeQuery("google.com", TYPE_AAAA);
-
-    assertThat(encoded).isEqualTo("AAABAAABAAAAAAAABmdvb2dsZQNjb20AABwAAQ");
-  }
-
-  @Test public void testGoogleDotComDecodingFromCloudflare() throws Exception {
-    List<InetAddress> encoded = DnsRecordCodec.decodeAnswers("test.com", ByteString.decodeHex(
-        "00008180000100010000000006676f6f676c6503636f6d0000010001c00c00010001000000430004d83ad54e"));
-
-    assertThat(encoded).containsExactly(InetAddress.getByName("216.58.213.78"));
-  }
-
-  @Test public void testGoogleDotComDecodingFromGoogle() throws Exception {
-    List<InetAddress> decoded = DnsRecordCodec.decodeAnswers("test.com", ByteString.decodeHex(
-        "0000818000010003000000000567726170680866616365626f6f6b03636f6d0000010001c00c0005000100000a6d000603617069c012c0300005000100000cde000c04737461720463313072c012c042000100010000003b00049df00112"));
-
-    assertThat(decoded).containsExactly(InetAddress.getByName("157.240.1.18"));
-  }
-
-  @Test public void testGoogleDotComDecodingFromGoogleIPv6() throws Exception {
-    List<InetAddress> decoded = DnsRecordCodec.decodeAnswers("test.com", ByteString.decodeHex(
-        "0000818000010003000000000567726170680866616365626f6f6b03636f6d00001c0001c00c0005000100000a1b000603617069c012c0300005000100000b1f000c04737461720463313072c012c042001c00010000003b00102a032880f0290011faceb00c00000002"));
-
-    assertThat(decoded).containsExactly(InetAddress.getByName("2a03:2880:f029:11:face:b00c:0:2"));
-  }
-
-  @Test public void testGoogleDotComDecodingNxdomainFailure() throws Exception {
-    try {
-      DnsRecordCodec.decodeAnswers("sdflkhfsdlkjdf.ee", ByteString.decodeHex(
-          "0000818300010000000100000e7364666c6b686673646c6b6a64660265650000010001c01b00060001000007070038026e7303746c64c01b0a686f73746d61737465720d6565737469696e7465726e6574c01b5adb12c100000e10000003840012750000000e10"));
-      fail();
-    } catch (UnknownHostException uhe) {
-      assertThat(uhe.getMessage()).isEqualTo("sdflkhfsdlkjdf.ee: NXDOMAIN");
-    }
-  }
-}
diff --git a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DohProviders.java b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DohProviders.java
deleted file mode 100644
index 301eee57ca..0000000000
--- a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DohProviders.java
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.dnsoverhttps;
-
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.util.ArrayList;
-import java.util.List;
-import okhttp3.HttpUrl;
-import okhttp3.OkHttpClient;
-
-/**
- * Temporary registry of known DNS over HTTPS providers.
- *
- * https://github.com/curl/curl/wiki/DNS-over-HTTPS
- */
-public class DohProviders {
-  static DnsOverHttps buildGoogle(OkHttpClient bootstrapClient) {
-    return new DnsOverHttps.Builder().client(bootstrapClient)
-        .url(HttpUrl.get("https://dns.google.com/experimental"))
-        .bootstrapDnsHosts(getByIp("216.58.204.78"), getByIp("2a00:1450:4009:814:0:0:0:200e"))
-        .build();
-  }
-
-  static DnsOverHttps buildGooglePost(OkHttpClient bootstrapClient) {
-    return new DnsOverHttps.Builder().client(bootstrapClient)
-        .url(HttpUrl.get("https://dns.google.com/experimental"))
-        .bootstrapDnsHosts(getByIp("216.58.204.78"), getByIp("2a00:1450:4009:814:0:0:0:200e"))
-        .post(true)
-        .build();
-  }
-
-  static DnsOverHttps buildCloudflareIp(OkHttpClient bootstrapClient) {
-    return new DnsOverHttps.Builder().client(bootstrapClient)
-        .url(HttpUrl.get("https://1.1.1.1/dns-query"))
-        .includeIPv6(false)
-        .build();
-  }
-
-  static DnsOverHttps buildCloudflare(OkHttpClient bootstrapClient) {
-    return new DnsOverHttps.Builder().client(bootstrapClient)
-        .url(HttpUrl.get("https://cloudflare-dns.com/dns-query"))
-        .bootstrapDnsHosts(getByIp("1.1.1.1"))
-        .includeIPv6(false)
-        .build();
-  }
-
-  static DnsOverHttps buildCloudflarePost(OkHttpClient bootstrapClient) {
-    return new DnsOverHttps.Builder().client(bootstrapClient)
-        .url(HttpUrl.get("https://cloudflare-dns.com/dns-query"))
-        .bootstrapDnsHosts(getByIp("104.16.111.25"), getByIp("104.16.112.25"),
-            getByIp("2400:cb00:2048:1:0:0:6810:7019"), getByIp("2400:cb00:2048:1:0:0:6810:6f19"))
-        .includeIPv6(false)
-        .post(true)
-        .build();
-  }
-
-  static DnsOverHttps buildCleanBrowsing(OkHttpClient bootstrapClient) {
-    return new DnsOverHttps.Builder().client(bootstrapClient)
-        .url(HttpUrl.get("https://doh.cleanbrowsing.org/doh/family-filter/"))
-        .includeIPv6(false)
-        .build();
-  }
-
-  static DnsOverHttps buildChantra(OkHttpClient bootstrapClient) {
-    return new DnsOverHttps.Builder().client(bootstrapClient)
-        .url(HttpUrl.get("https://dns.dnsoverhttps.net/dns-query"))
-        .includeIPv6(false)
-        .build();
-  }
-
-  static DnsOverHttps buildCryptoSx(OkHttpClient bootstrapClient) {
-    return new DnsOverHttps.Builder().client(bootstrapClient)
-        .url(HttpUrl.get("https://doh.crypto.sx/dns-query"))
-        .includeIPv6(false)
-        .build();
-  }
-
-  public static List<DnsOverHttps> providers(OkHttpClient client, boolean http2Only,
-      boolean workingOnly, boolean getOnly) {
-
-    List<DnsOverHttps> result = new ArrayList<>();
-
-    result.add(buildGoogle(client));
-    if (!getOnly) {
-      result.add(buildGooglePost(client));
-    }
-    result.add(buildCloudflare(client));
-    result.add(buildCloudflareIp(client));
-    if (!getOnly) {
-      result.add(buildCloudflarePost(client));
-    }
-    if (!workingOnly) {
-      //result.add(buildCleanBrowsing(client)); // timeouts
-      result.add(buildCryptoSx(client)); // 521 - server down
-    }
-    result.add(buildChantra(client));
-
-    return result;
-  }
-
-  private static InetAddress getByIp(String host) {
-    try {
-      return InetAddress.getByName(host);
-    } catch (UnknownHostException e) {
-      // unlikely
-      throw new RuntimeException(e);
-    }
-  }
-}
diff --git a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/TestDohMain.java b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/TestDohMain.java
deleted file mode 100644
index 65975ae5cc..0000000000
--- a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/TestDohMain.java
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.dnsoverhttps;
-
-import java.io.File;
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.security.Security;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-import okhttp3.Cache;
-import okhttp3.HttpUrl;
-import okhttp3.OkHttpClient;
-
-public class TestDohMain {
-  public static void main(String[] args) throws IOException {
-    Security.insertProviderAt(new org.conscrypt.OpenSSLProvider(), 1);
-
-    OkHttpClient bootstrapClient = new OkHttpClient.Builder().build();
-
-    List<String> names = Arrays.asList("google.com", "graph.facebook.com", "sdflkhfsdlkjdf.ee");
-
-    try {
-      System.out.println("uncached\n********\n");
-      List<DnsOverHttps> dnsProviders =
-          DohProviders.providers(bootstrapClient, false, false, false);
-      runBatch(dnsProviders, names);
-
-      Cache dnsCache =
-          new Cache(new File("./target/TestDohMain.cache." + System.currentTimeMillis()),
-              10 * 1024 * 1024);
-
-      System.out.println("Bad targets\n***********\n");
-
-      HttpUrl url = HttpUrl.get("https://dns.cloudflare.com/.not-so-well-known/run-dmc-query");
-      List<DnsOverHttps> badProviders = Collections.singletonList(
-          new DnsOverHttps.Builder().client(bootstrapClient).url(url).post(true).build());
-      runBatch(badProviders, names);
-
-      System.out.println("cached first run\n****************\n");
-      names = Arrays.asList("google.com", "graph.facebook.com");
-      bootstrapClient = bootstrapClient.newBuilder().cache(dnsCache).build();
-      dnsProviders = DohProviders.providers(bootstrapClient, true, true, true);
-      runBatch(dnsProviders, names);
-
-      System.out.println("cached second run\n*****************\n");
-      dnsProviders = DohProviders.providers(bootstrapClient, true, true, true);
-      runBatch(dnsProviders, names);
-    } finally {
-      bootstrapClient.connectionPool().evictAll();
-      bootstrapClient.dispatcher().executorService().shutdownNow();
-      Cache cache = bootstrapClient.cache();
-      if (cache != null) {
-        cache.close();
-      }
-    }
-  }
-
-  private static void runBatch(List<DnsOverHttps> dnsProviders, List<String> names) {
-    long time = System.currentTimeMillis();
-
-    for (DnsOverHttps dns : dnsProviders) {
-      System.out.println("Testing " + dns.url());
-
-      for (String host : names) {
-        System.out.print(host + ": ");
-        System.out.flush();
-
-        try {
-          List<InetAddress> results = dns.lookup(host);
-          System.out.println(results);
-        } catch (UnknownHostException uhe) {
-          Throwable e = uhe;
-
-          while (e != null) {
-            System.out.println(e.toString());
-
-            e = e.getCause();
-          }
-        }
-      }
-
-      System.out.println();
-    }
-
-    time = System.currentTimeMillis() - time;
-
-    System.out.println("Time: " + (((double) time) / 1000) + " seconds\n");
-  }
-}
diff --git a/okhttp-hpacktests/README.md b/okhttp-hpacktests/README.md
deleted file mode 100644
index 6b85c9a000..0000000000
--- a/okhttp-hpacktests/README.md
+++ /dev/null
@@ -1,19 +0,0 @@
-OkHttp HPACK tests
-==================
-
-These tests use the [hpack-test-case][1] project to validate OkHttp's HPACK
-implementation.  The HPACK test cases are in a separate git submodule, so to
-initialize them, you must run:
-
-    git submodule init
-    git submodule update
-
-TODO
-----
-
- * Add maven goal to avoid manual call to git submodule init.
- * Make hpack-test-case update itself from git, and run new tests.
- * Add maven goal to generate stories and a pull request to hpack-test-case
-   to have others validate our output.
-
-[1]: https://github.com/http2jp/hpack-test-case 
diff --git a/okhttp-hpacktests/pom.xml b/okhttp-hpacktests/pom.xml
deleted file mode 100644
index 18eb58cb00..0000000000
--- a/okhttp-hpacktests/pom.xml
+++ /dev/null
@@ -1,65 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.15.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>okhttp-hpacktests</artifactId>
-  <name>OkHttp HPACK Tests</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup.okio</groupId>
-      <artifactId>okio</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.moshi</groupId>
-      <artifactId>moshi</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-testing-support</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <!-- Do not deploy this as an artifact to Maven central. -->
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-deploy-plugin</artifactId>
-        <configuration>
-          <skip>true</skip>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackDecodeInteropTest.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackDecodeInteropTest.java
deleted file mode 100644
index dbcc99f55f..0000000000
--- a/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackDecodeInteropTest.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import java.util.Collection;
-import okhttp3.internal.http2.hpackjson.Story;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-
-import static okhttp3.internal.http2.hpackjson.HpackJsonUtil.storiesForCurrentDraft;
-
-@RunWith(Parameterized.class)
-public class HpackDecodeInteropTest extends HpackDecodeTestBase {
-
-  public HpackDecodeInteropTest(Story story) {
-    super(story);
-  }
-
-  @Parameterized.Parameters(name = "{0}")
-  public static Collection<Story[]> createStories() throws Exception {
-    return createStories(storiesForCurrentDraft());
-  }
-
-  @Test
-  public void testGoodDecoderInterop() throws Exception {
-    testDecoder();
-  }
-}
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackDecodeTestBase.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackDecodeTestBase.java
deleted file mode 100644
index 879fe6aba0..0000000000
--- a/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackDecodeTestBase.java
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.LinkedHashSet;
-import java.util.List;
-import okhttp3.internal.http2.hpackjson.Case;
-import okhttp3.internal.http2.hpackjson.HpackJsonUtil;
-import okhttp3.internal.http2.hpackjson.Story;
-import okio.Buffer;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-/**
- * Tests Hpack implementation using https://github.com/http2jp/hpack-test-case/
- */
-public class HpackDecodeTestBase {
-
-  /**
-   * Reads all stories in the folders provided, asserts if no story found.
-   */
-  protected static Collection<Story[]> createStories(String[] interopTests)
-      throws Exception {
-    List<Story[]> result = new ArrayList<>();
-    for (String interopTestName : interopTests) {
-      List<Story> stories = HpackJsonUtil.readStories(interopTestName);
-      if (stories.isEmpty()) {
-        fail("No stories for: " + interopTestName);
-      }
-      for (Story story : stories) {
-        result.add(new Story[] {story});
-      }
-    }
-    return result;
-  }
-
-  private final Buffer bytesIn = new Buffer();
-  private final Hpack.Reader hpackReader = new Hpack.Reader(4096, bytesIn);
-
-  private final Story story;
-
-  public HpackDecodeTestBase(Story story) {
-    this.story = story;
-  }
-
-  /**
-   * Expects wire to be set for all cases, and compares the decoder's output to expected headers.
-   */
-  protected void testDecoder() throws Exception {
-    testDecoder(story);
-  }
-
-  protected void testDecoder(Story story) throws Exception {
-    for (Case caze : story.getCases()) {
-      bytesIn.write(caze.getWire());
-      hpackReader.readHeaders();
-      assertSetEquals(String.format("seqno=%d", caze.getSeqno()), caze.getHeaders(),
-          hpackReader.getAndResetHeaderList());
-    }
-  }
-
-  /**
-   * Checks if {@code expected} and {@code observed} are equal when viewed as a set and headers are
-   * deduped.
-   *
-   * TODO: See if duped headers should be preserved on decode and verify.
-   */
-  private static void assertSetEquals(
-      String message, List<Header> expected, List<Header> observed) {
-    assertThat(new LinkedHashSet<>(observed)).overridingErrorMessage(message).isEqualTo(
-        new LinkedHashSet<>(expected));
-  }
-
-  protected Story getStory() {
-    return story;
-  }
-}
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackRoundTripTest.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackRoundTripTest.java
deleted file mode 100644
index 55325ce53d..0000000000
--- a/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackRoundTripTest.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import java.util.Collection;
-import okhttp3.internal.http2.hpackjson.Case;
-import okhttp3.internal.http2.hpackjson.Story;
-import okio.Buffer;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-
-/**
- * Tests for round-tripping headers through hpack..
- */
-// TODO: update hpack-test-case with the output of our encoder.
-// This test will hide complementary bugs in the encoder and decoder,
-// We should test that the encoder is producing responses that are
-// d]
-@RunWith(Parameterized.class)
-public class HpackRoundTripTest extends HpackDecodeTestBase {
-
-  private static final String[] RAW_DATA = {"raw-data"};
-
-  @Parameterized.Parameters(name = "{0}")
-  public static Collection<Story[]> getStories() throws Exception {
-    return createStories(RAW_DATA);
-  }
-
-  private Buffer bytesOut = new Buffer();
-  private Hpack.Writer hpackWriter = new Hpack.Writer(bytesOut);
-
-  public HpackRoundTripTest(Story story) {
-    super(story);
-  }
-
-  @Test
-  public void testRoundTrip() throws Exception {
-    Story story = getStory().clone();
-    // Mutate cases in base class.
-    for (Case caze : story.getCases()) {
-      hpackWriter.writeHeaders(caze.getHeaders());
-      caze.setWire(bytesOut.readByteString());
-    }
-
-    testDecoder(story);
-  }
-}
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/Case.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/Case.java
deleted file mode 100644
index f1685f3800..0000000000
--- a/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/Case.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2.hpackjson;
-
-import java.util.ArrayList;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import okhttp3.internal.http2.Header;
-import okio.ByteString;
-
-/**
- * Representation of an individual case (set of headers and wire format). There are many cases for a
- * single story.  This class is used reflectively with Moshi to parse stories.
- */
-public class Case implements Cloneable {
-
-  private int seqno;
-  private String wire;
-  private List<Map<String, String>> headers;
-
-  public List<Header> getHeaders() {
-    List<Header> result = new ArrayList<>();
-    for (Map<String, String> inputHeader : headers) {
-      Map.Entry<String, String> entry = inputHeader.entrySet().iterator().next();
-      result.add(new Header(entry.getKey(), entry.getValue()));
-    }
-    return result;
-  }
-
-  public ByteString getWire() {
-    return ByteString.decodeHex(wire);
-  }
-
-  public int getSeqno() {
-    return seqno;
-  }
-
-  public void setWire(ByteString wire) {
-    this.wire = wire.hex();
-  }
-
-  @Override
-  protected Case clone() throws CloneNotSupportedException {
-    Case result = new Case();
-    result.seqno = seqno;
-    result.wire = wire;
-    result.headers = new ArrayList<>();
-    for (Map<String, String> header : headers) {
-      result.headers.add(new LinkedHashMap<String, String>(header));
-    }
-    return result;
-  }
-}
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/HpackJsonUtil.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/HpackJsonUtil.java
deleted file mode 100644
index 39b1489d4b..0000000000
--- a/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/HpackJsonUtil.java
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2.hpackjson;
-
-import com.squareup.moshi.JsonAdapter;
-import com.squareup.moshi.Moshi;
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.URISyntaxException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import okio.Okio;
-
-/**
- * Utilities for reading HPACK tests.
- */
-public final class HpackJsonUtil {
-  /** Earliest draft that is code-compatible with latest. */
-  private static final int BASE_DRAFT = 9;
-
-  private static final String STORY_RESOURCE_FORMAT = "/hpack-test-case/%s/story_%02d.json";
-
-  private static final Moshi MOSHI = new Moshi.Builder().build();
-  private static final JsonAdapter<Story> STORY_JSON_ADAPTER = MOSHI.adapter(Story.class);
-
-  private static Story readStory(InputStream jsonResource) throws IOException {
-    return STORY_JSON_ADAPTER.fromJson(Okio.buffer(Okio.source(jsonResource)));
-  }
-
-  private static Story readStory(File file) throws IOException {
-    return STORY_JSON_ADAPTER.fromJson(Okio.buffer(Okio.source(file)));
-  }
-
-  /** Iterate through the hpack-test-case resources, only picking stories for the current draft. */
-  public static String[] storiesForCurrentDraft() throws URISyntaxException {
-    File testCaseDirectory = new File(HpackJsonUtil.class.getResource("/hpack-test-case").toURI());
-    List<String> storyNames = new ArrayList<>();
-    for (File path : testCaseDirectory.listFiles()) {
-      if (path.isDirectory() && Arrays.asList(path.list()).contains("story_00.json")) {
-        try {
-          Story firstStory = readStory(new File(path, "story_00.json"));
-          if (firstStory.getDraft() >= BASE_DRAFT) {
-            storyNames.add(path.getName());
-          }
-        } catch (IOException ignored) {
-          // Skip this path.
-        }
-      }
-    }
-    return storyNames.toArray(new String[storyNames.size()]);
-  }
-
-  /**
-   * Reads stories named "story_xx.json" from the folder provided.
-   */
-  public static List<Story> readStories(String testFolderName) throws Exception {
-    List<Story> result = new ArrayList<>();
-    int i = 0;
-    while (true) { // break after last test.
-      String storyResourceName = String.format(STORY_RESOURCE_FORMAT, testFolderName, i);
-      InputStream storyInputStream = HpackJsonUtil.class.getResourceAsStream(storyResourceName);
-      if (storyInputStream == null) {
-        break;
-      }
-      try {
-        Story story = readStory(storyInputStream);
-        story.setFileName(storyResourceName);
-        result.add(story);
-        i++;
-      } finally {
-        storyInputStream.close();
-      }
-    }
-    return result;
-  }
-
-  private HpackJsonUtil() {
-  } // Utilities only.
-}
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/Story.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/Story.java
deleted file mode 100644
index 288a87b81f..0000000000
--- a/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/Story.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2.hpackjson;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * Representation of one story, a set of request headers to encode or decode. This class is used
- * reflectively with Moshi to parse stories from files.
- */
-public class Story implements Cloneable {
-
-  private transient String fileName;
-  private List<Case> cases;
-  private int draft;
-  private String description;
-
-  /**
-   * The filename is only used in the toString representation.
-   */
-  void setFileName(String fileName) {
-    this.fileName = fileName;
-  }
-
-  public List<Case> getCases() {
-    return cases;
-  }
-
-  /** We only expect stories that match the draft we've implemented to pass. */
-  public int getDraft() {
-    return draft;
-  }
-
-  @Override
-  public Story clone() throws CloneNotSupportedException {
-    Story story = new Story();
-    story.fileName = this.fileName;
-    story.cases = new ArrayList<>();
-    for (Case caze : cases) {
-      story.cases.add(caze.clone());
-    }
-    story.draft = draft;
-    story.description = description;
-    return story;
-  }
-
-  @Override
-  public String toString() {
-    // Used as the test name.
-    return fileName;
-  }
-}
diff --git a/okhttp-hpacktests/src/test/resources/hpack-test-case b/okhttp-hpacktests/src/test/resources/hpack-test-case
deleted file mode 160000
index a5652bc2bc..0000000000
--- a/okhttp-hpacktests/src/test/resources/hpack-test-case
+++ /dev/null
@@ -1 +0,0 @@
-Subproject commit a5652bc2bc3d2a992f39446369fb004a72e881d4
diff --git a/okhttp-logging-interceptor/README.md b/okhttp-logging-interceptor/README.md
deleted file mode 100644
index a6363f2237..0000000000
--- a/okhttp-logging-interceptor/README.md
+++ /dev/null
@@ -1,55 +0,0 @@
-Logging Interceptor
-===================
-
-An [OkHttp interceptor][1] which logs HTTP request and response data.
-
-```java
-HttpLoggingInterceptor logging = new HttpLoggingInterceptor();
-logging.setLevel(Level.BASIC);
-OkHttpClient client = new OkHttpClient.Builder()
-  .addInterceptor(logging)
-  .build();
-```
-
-You can change the log level at any time by calling `setLevel()`.
-
-To log to a custom location, pass a `Logger` instance to the constructor.
-```java
-HttpLoggingInterceptor logging = new HttpLoggingInterceptor(new Logger() {
-  @Override public void log(String message) {
-    Timber.tag("OkHttp").d(message);
-  }
-});
-```
-
-**Warning**: The logs generated by this interceptor when using the `HEADERS` or `BODY` levels have
-the potential to leak sensitive information such as "Authorization" or "Cookie" headers and the
-contents of request and response bodies. This data should only be logged in a controlled way or in
-a non-production environment.
-
-You can redact headers that may contain sensitive information by calling `redactHeader()`.
-```java
-logging.redactHeader("Authorization");
-logging.redactHeader("Cookie");
-```
-
-Download
---------
-
-Get via Maven:
-```xml
-<dependency>
-  <groupId>com.squareup.okhttp3</groupId>
-  <artifactId>logging-interceptor</artifactId>
-  <version>(insert latest version)</version>
-</dependency>
-```
-
-or via Gradle 
-```groovy
-implementation 'com.squareup.okhttp3:logging-interceptor:(insert latest version)'
-```
-
-
-
- [1]: ../INTERCEPTORS.md
diff --git a/okhttp-logging-interceptor/pom.xml b/okhttp-logging-interceptor/pom.xml
deleted file mode 100644
index 7dfe0bceb1..0000000000
--- a/okhttp-logging-interceptor/pom.xml
+++ /dev/null
@@ -1,73 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.14.3-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>logging-interceptor</artifactId>
-  <name>OkHttp Logging Interceptor</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.google.code.findbugs</groupId>
-      <artifactId>jsr305</artifactId>
-      <scope>provided</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-testing-support</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-tls</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-jar-plugin</artifactId>
-        <version>3.1.1</version>
-        <configuration>
-          <archive>
-            <manifestEntries>
-              <Automatic-Module-Name>okhttp3.logging</Automatic-Module-Name>
-            </manifestEntries>
-          </archive>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
deleted file mode 100644
index 5d65ac054f..0000000000
--- a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
+++ /dev/null
@@ -1,327 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.logging;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.nio.charset.Charset;
-import java.util.Collections;
-import java.util.Set;
-import java.util.TreeSet;
-import java.util.concurrent.TimeUnit;
-import okhttp3.Connection;
-import okhttp3.Headers;
-import okhttp3.Interceptor;
-import okhttp3.MediaType;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.internal.http.HttpHeaders;
-import okhttp3.internal.platform.Platform;
-import okio.Buffer;
-import okio.BufferedSource;
-import okio.GzipSource;
-
-import static okhttp3.internal.platform.Platform.INFO;
-
-/**
- * An OkHttp interceptor which logs request and response information. Can be applied as an
- * {@linkplain OkHttpClient#interceptors() application interceptor} or as a {@linkplain
- * OkHttpClient#networkInterceptors() network interceptor}. <p> The format of the logs created by
- * this class should not be considered stable and may change slightly between releases. If you need
- * a stable logging format, use your own interceptor.
- */
-public final class HttpLoggingInterceptor implements Interceptor {
-  private static final Charset UTF8 = Charset.forName("UTF-8");
-
-  public enum Level {
-    /** No logs. */
-    NONE,
-    /**
-     * Logs request and response lines.
-     *
-     * <p>Example:
-     * <pre>{@code
-     * --> POST /greeting http/1.1 (3-byte body)
-     *
-     * <-- 200 OK (22ms, 6-byte body)
-     * }</pre>
-     */
-    BASIC,
-    /**
-     * Logs request and response lines and their respective headers.
-     *
-     * <p>Example:
-     * <pre>{@code
-     * --> POST /greeting http/1.1
-     * Host: example.com
-     * Content-Type: plain/text
-     * Content-Length: 3
-     * --> END POST
-     *
-     * <-- 200 OK (22ms)
-     * Content-Type: plain/text
-     * Content-Length: 6
-     * <-- END HTTP
-     * }</pre>
-     */
-    HEADERS,
-    /**
-     * Logs request and response lines and their respective headers and bodies (if present).
-     *
-     * <p>Example:
-     * <pre>{@code
-     * --> POST /greeting http/1.1
-     * Host: example.com
-     * Content-Type: plain/text
-     * Content-Length: 3
-     *
-     * Hi?
-     * --> END POST
-     *
-     * <-- 200 OK (22ms)
-     * Content-Type: plain/text
-     * Content-Length: 6
-     *
-     * Hello!
-     * <-- END HTTP
-     * }</pre>
-     */
-    BODY
-  }
-
-  public interface Logger {
-    void log(String message);
-
-    /** A {@link Logger} defaults output appropriate for the current platform. */
-    Logger DEFAULT = message -> Platform.get().log(INFO, message, null);
-  }
-
-  public HttpLoggingInterceptor() {
-    this(Logger.DEFAULT);
-  }
-
-  public HttpLoggingInterceptor(Logger logger) {
-    this.logger = logger;
-  }
-
-  private final Logger logger;
-
-  private volatile Set<String> headersToRedact = Collections.emptySet();
-
-  public void redactHeader(String name) {
-    Set<String> newHeadersToRedact = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
-    newHeadersToRedact.addAll(headersToRedact);
-    newHeadersToRedact.add(name);
-    headersToRedact = newHeadersToRedact;
-  }
-
-  private volatile Level level = Level.NONE;
-
-  /** Change the level at which this interceptor logs. */
-  public HttpLoggingInterceptor setLevel(Level level) {
-    if (level == null) throw new NullPointerException("level == null. Use Level.NONE instead.");
-    this.level = level;
-    return this;
-  }
-
-  public Level getLevel() {
-    return level;
-  }
-
-  @Override public Response intercept(Chain chain) throws IOException {
-    Level level = this.level;
-
-    Request request = chain.request();
-    if (level == Level.NONE) {
-      return chain.proceed(request);
-    }
-
-    boolean logBody = level == Level.BODY;
-    boolean logHeaders = logBody || level == Level.HEADERS;
-
-    RequestBody requestBody = request.body();
-    boolean hasRequestBody = requestBody != null;
-
-    Connection connection = chain.connection();
-    String requestStartMessage = "--> "
-        + request.method()
-        + ' ' + request.url()
-        + (connection != null ? " " + connection.protocol() : "");
-    if (!logHeaders && hasRequestBody) {
-      requestStartMessage += " (" + requestBody.contentLength() + "-byte body)";
-    }
-    logger.log(requestStartMessage);
-
-    if (logHeaders) {
-      if (hasRequestBody) {
-        // Request body headers are only present when installed as a network interceptor. Force
-        // them to be included (when available) so there values are known.
-        if (requestBody.contentType() != null) {
-          logger.log("Content-Type: " + requestBody.contentType());
-        }
-        if (requestBody.contentLength() != -1) {
-          logger.log("Content-Length: " + requestBody.contentLength());
-        }
-      }
-
-      Headers headers = request.headers();
-      for (int i = 0, count = headers.size(); i < count; i++) {
-        String name = headers.name(i);
-        // Skip headers from the request body as they are explicitly logged above.
-        if (!"Content-Type".equalsIgnoreCase(name) && !"Content-Length".equalsIgnoreCase(name)) {
-          logHeader(headers, i);
-        }
-      }
-
-      if (!logBody || !hasRequestBody) {
-        logger.log("--> END " + request.method());
-      } else if (bodyHasUnknownEncoding(request.headers())) {
-        logger.log("--> END " + request.method() + " (encoded body omitted)");
-      } else if (requestBody.isDuplex()) {
-        logger.log("--> END " + request.method() + " (duplex request body omitted)");
-      } else {
-        Buffer buffer = new Buffer();
-        requestBody.writeTo(buffer);
-
-        Charset charset = UTF8;
-        MediaType contentType = requestBody.contentType();
-        if (contentType != null) {
-          charset = contentType.charset(UTF8);
-        }
-
-        logger.log("");
-        if (isPlaintext(buffer)) {
-          logger.log(buffer.readString(charset));
-          logger.log("--> END " + request.method()
-              + " (" + requestBody.contentLength() + "-byte body)");
-        } else {
-          logger.log("--> END " + request.method() + " (binary "
-              + requestBody.contentLength() + "-byte body omitted)");
-        }
-      }
-    }
-
-    long startNs = System.nanoTime();
-    Response response;
-    try {
-      response = chain.proceed(request);
-    } catch (Exception e) {
-      logger.log("<-- HTTP FAILED: " + e);
-      throw e;
-    }
-    long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNs);
-
-    ResponseBody responseBody = response.body();
-    long contentLength = responseBody.contentLength();
-    String bodySize = contentLength != -1 ? contentLength + "-byte" : "unknown-length";
-    logger.log("<-- "
-        + response.code()
-        + (response.message().isEmpty() ? "" : ' ' + response.message())
-        + ' ' + response.request().url()
-        + " (" + tookMs + "ms" + (!logHeaders ? ", " + bodySize + " body" : "") + ')');
-
-    if (logHeaders) {
-      Headers headers = response.headers();
-      for (int i = 0, count = headers.size(); i < count; i++) {
-        logHeader(headers, i);
-      }
-
-      if (!logBody || !HttpHeaders.hasBody(response)) {
-        logger.log("<-- END HTTP");
-      } else if (bodyHasUnknownEncoding(response.headers())) {
-        logger.log("<-- END HTTP (encoded body omitted)");
-      } else {
-        BufferedSource source = responseBody.source();
-        source.request(Long.MAX_VALUE); // Buffer the entire body.
-        Buffer buffer = source.getBuffer();
-
-        Long gzippedLength = null;
-        if ("gzip".equalsIgnoreCase(headers.get("Content-Encoding"))) {
-          gzippedLength = buffer.size();
-          try (GzipSource gzippedResponseBody = new GzipSource(buffer.clone())) {
-            buffer = new Buffer();
-            buffer.writeAll(gzippedResponseBody);
-          }
-        }
-
-        Charset charset = UTF8;
-        MediaType contentType = responseBody.contentType();
-        if (contentType != null) {
-          charset = contentType.charset(UTF8);
-        }
-
-        if (!isPlaintext(buffer)) {
-          logger.log("");
-          logger.log("<-- END HTTP (binary " + buffer.size() + "-byte body omitted)");
-          return response;
-        }
-
-        if (contentLength != 0) {
-          logger.log("");
-          logger.log(buffer.clone().readString(charset));
-        }
-
-        if (gzippedLength != null) {
-            logger.log("<-- END HTTP (" + buffer.size() + "-byte, "
-                + gzippedLength + "-gzipped-byte body)");
-        } else {
-            logger.log("<-- END HTTP (" + buffer.size() + "-byte body)");
-        }
-      }
-    }
-
-    return response;
-  }
-
-  private void logHeader(Headers headers, int i) {
-    String value = headersToRedact.contains(headers.name(i)) ? "‚ñà‚ñà" : headers.value(i);
-    logger.log(headers.name(i) + ": " + value);
-  }
-
-  /**
-   * Returns true if the body in question probably contains human readable text. Uses a small sample
-   * of code points to detect unicode control characters commonly used in binary file signatures.
-   */
-  static boolean isPlaintext(Buffer buffer) {
-    try {
-      Buffer prefix = new Buffer();
-      long byteCount = buffer.size() < 64 ? buffer.size() : 64;
-      buffer.copyTo(prefix, 0, byteCount);
-      for (int i = 0; i < 16; i++) {
-        if (prefix.exhausted()) {
-          break;
-        }
-        int codePoint = prefix.readUtf8CodePoint();
-        if (Character.isISOControl(codePoint) && !Character.isWhitespace(codePoint)) {
-          return false;
-        }
-      }
-      return true;
-    } catch (EOFException e) {
-      return false; // Truncated UTF-8 sequence.
-    }
-  }
-
-  private static boolean bodyHasUnknownEncoding(Headers headers) {
-    String contentEncoding = headers.get("Content-Encoding");
-    return contentEncoding != null
-        && !contentEncoding.equalsIgnoreCase("identity")
-        && !contentEncoding.equalsIgnoreCase("gzip");
-  }
-}
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/LoggingEventListener.java b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/LoggingEventListener.java
deleted file mode 100644
index b0136d1248..0000000000
--- a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/LoggingEventListener.java
+++ /dev/null
@@ -1,188 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.logging;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import java.util.List;
-import java.util.concurrent.TimeUnit;
-import javax.annotation.Nullable;
-import okhttp3.Call;
-import okhttp3.Connection;
-import okhttp3.EventListener;
-import okhttp3.Handshake;
-import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.Response;
-
-/**
- * An OkHttp EventListener, which logs call events. Can be applied as an
- * {@linkplain OkHttpClient#eventListenerFactory() event listener factory}.
- *
- * <p>The format of the logs created by this class should not be considered stable and may change
- * slightly between releases. If you need a stable logging format, use your own event listener.
- */
-public final class LoggingEventListener extends EventListener {
-  private final HttpLoggingInterceptor.Logger logger;
-  private long startNs;
-
-  private LoggingEventListener(HttpLoggingInterceptor.Logger logger) {
-    this.logger = logger;
-  }
-
-  @Override
-  public void callStart(Call call) {
-    startNs = System.nanoTime();
-
-    logWithTime("callStart: " + call.request());
-  }
-
-  @Override
-  public void dnsStart(Call call, String domainName) {
-    logWithTime("dnsStart: " + domainName);
-  }
-
-  @Override
-  public void dnsEnd(Call call, String domainName, List<InetAddress> inetAddressList) {
-    logWithTime("dnsEnd: " + inetAddressList);
-  }
-
-  @Override
-  public void connectStart(Call call, InetSocketAddress inetSocketAddress, Proxy proxy) {
-    logWithTime("connectStart: " + inetSocketAddress + " " + proxy);
-  }
-
-  @Override
-  public void secureConnectStart(Call call) {
-    logWithTime("secureConnectStart");
-  }
-
-  @Override
-  public void secureConnectEnd(Call call, @Nullable Handshake handshake) {
-    logWithTime("secureConnectEnd: " + handshake);
-  }
-
-  @Override
-  public void connectEnd(
-      Call call, InetSocketAddress inetSocketAddress, Proxy proxy, @Nullable Protocol protocol) {
-    logWithTime("connectEnd: " + protocol);
-  }
-
-  @Override
-  public void connectFailed(
-      Call call,
-      InetSocketAddress inetSocketAddress,
-      Proxy proxy,
-      @Nullable Protocol protocol,
-      IOException ioe) {
-    logWithTime("connectFailed: " + protocol + " " + ioe);
-  }
-
-  @Override
-  public void connectionAcquired(Call call, Connection connection) {
-    logWithTime("connectionAcquired: " + connection);
-  }
-
-  @Override
-  public void connectionReleased(Call call, Connection connection) {
-    logWithTime("connectionReleased");
-  }
-
-  @Override
-  public void requestHeadersStart(Call call) {
-    logWithTime("requestHeadersStart");
-  }
-
-  @Override
-  public void requestHeadersEnd(Call call, Request request) {
-    logWithTime("requestHeadersEnd");
-  }
-
-  @Override
-  public void requestBodyStart(Call call) {
-    logWithTime("requestBodyStart");
-  }
-
-  @Override
-  public void requestBodyEnd(Call call, long byteCount) {
-    logWithTime("requestBodyEnd: byteCount=" + byteCount);
-  }
-
-  @Override
-  public void requestFailed(Call call, IOException ioe) {
-    logWithTime("requestFailed: " + ioe);
-  }
-
-  @Override
-  public void responseHeadersStart(Call call) {
-    logWithTime("responseHeadersStart");
-  }
-
-  @Override
-  public void responseHeadersEnd(Call call, Response response) {
-    logWithTime("responseHeadersEnd: " + response);
-  }
-
-  @Override
-  public void responseBodyStart(Call call) {
-    logWithTime("responseBodyStart");
-  }
-
-  @Override
-  public void responseBodyEnd(Call call, long byteCount) {
-    logWithTime("responseBodyEnd: byteCount=" + byteCount);
-  }
-
-  @Override
-  public void responseFailed(Call call, IOException ioe) {
-    logWithTime("responseFailed: " + ioe);
-  }
-
-  @Override
-  public void callEnd(Call call) {
-    logWithTime("callEnd");
-  }
-
-  @Override
-  public void callFailed(Call call, IOException ioe) {
-    logWithTime("callFailed: " + ioe);
-  }
-
-  private void logWithTime(String message) {
-    long timeMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNs);
-    logger.log("[" + timeMs + " ms] " + message);
-  }
-
-  public static class Factory implements EventListener.Factory {
-    private final HttpLoggingInterceptor.Logger logger;
-
-    public Factory() {
-      this(HttpLoggingInterceptor.Logger.DEFAULT);
-    }
-
-    public Factory(HttpLoggingInterceptor.Logger logger) {
-      this.logger = logger;
-    }
-
-    @Override
-    public EventListener create(Call call) {
-      return new LoggingEventListener(logger);
-    }
-  }
-}
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/package-info.java b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/package-info.java
deleted file mode 100644
index 62d0ff5761..0000000000
--- a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/package-info.java
+++ /dev/null
@@ -1,3 +0,0 @@
-/** An OkHttp interceptor which logs HTTP request and response data. */
-@okhttp3.internal.annotations.EverythingIsNonNull
-package okhttp3.logging;
diff --git a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
deleted file mode 100644
index a3d18befe5..0000000000
--- a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
+++ /dev/null
@@ -1,872 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.logging;
-
-import java.io.IOException;
-import java.net.UnknownHostException;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.regex.Pattern;
-import javax.annotation.Nullable;
-import javax.net.ssl.HostnameVerifier;
-import okhttp3.HttpUrl;
-import okhttp3.MediaType;
-import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
-import okhttp3.RecordingHostnameVerifier;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.logging.HttpLoggingInterceptor.Level;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.tls.HandshakeCertificates;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.ByteString;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static okhttp3.tls.internal.TlsUtil.localhost;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.hamcrest.CoreMatchers.equalTo;
-import static org.junit.Assert.fail;
-import static org.junit.Assume.assumeThat;
-
-public final class HttpLoggingInterceptorTest {
-  private static final MediaType PLAIN = MediaType.get("text/plain; charset=utf-8");
-
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  private final HandshakeCertificates handshakeCertificates = localhost();
-  private final HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-  private OkHttpClient client;
-  private String host;
-  private HttpUrl url;
-
-  private final LogRecorder networkLogs = new LogRecorder();
-  private final HttpLoggingInterceptor networkInterceptor =
-      new HttpLoggingInterceptor(networkLogs);
-
-  private final LogRecorder applicationLogs = new LogRecorder();
-  private final HttpLoggingInterceptor applicationInterceptor =
-      new HttpLoggingInterceptor(applicationLogs);
-
-  private void setLevel(Level level) {
-    networkInterceptor.setLevel(level);
-    applicationInterceptor.setLevel(level);
-  }
-
-  @Before public void setUp() {
-    client = new OkHttpClient.Builder()
-        .addNetworkInterceptor(networkInterceptor)
-        .addInterceptor(applicationInterceptor)
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(hostnameVerifier)
-        .build();
-
-    host = server.getHostName() + ":" + server.getPort();
-    url = server.url("/");
-  }
-
-  @Test public void levelGetter() {
-    // The default is NONE.
-    assertThat(applicationInterceptor.getLevel()).isEqualTo(Level.NONE);
-
-    for (Level level : Level.values()) {
-      applicationInterceptor.setLevel(level);
-      assertThat(applicationInterceptor.getLevel()).isEqualTo(level);
-    }
-  }
-
-  @Test public void setLevelShouldPreventNullValue() {
-    try {
-      applicationInterceptor.setLevel(null);
-      fail();
-    } catch (NullPointerException expected) {
-      assertThat(expected.getMessage()).isEqualTo("level == null. Use Level.NONE instead.");
-    }
-  }
-
-  @Test public void setLevelShouldReturnSameInstanceOfInterceptor() {
-    for (Level level : Level.values()) {
-      assertThat(applicationInterceptor.setLevel(level)).isSameAs(applicationInterceptor);
-    }
-  }
-
-  @Test public void none() throws IOException {
-    server.enqueue(new MockResponse());
-    client.newCall(request().build()).execute();
-
-    applicationLogs.assertNoMoreLogs();
-    networkLogs.assertNoMoreLogs();
-  }
-
-  @Test public void basicGet() throws IOException {
-    setLevel(Level.BASIC);
-
-    server.enqueue(new MockResponse());
-    client.newCall(request().build()).execute();
-
-    applicationLogs
-        .assertLogEqual("--> GET " + url)
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 0-byte body\\)")
-        .assertNoMoreLogs();
-
-    networkLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 0-byte body\\)")
-        .assertNoMoreLogs();
-  }
-
-  @Test public void basicPost() throws IOException {
-    setLevel(Level.BASIC);
-
-    server.enqueue(new MockResponse());
-    client.newCall(request().post(RequestBody.create(PLAIN, "Hi?")).build()).execute();
-
-    applicationLogs
-        .assertLogEqual("--> POST " + url + " (3-byte body)")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 0-byte body\\)")
-        .assertNoMoreLogs();
-
-    networkLogs
-        .assertLogEqual("--> POST " + url + " http/1.1 (3-byte body)")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 0-byte body\\)")
-        .assertNoMoreLogs();
-  }
-
-  @Test public void basicResponseBody() throws IOException {
-    setLevel(Level.BASIC);
-
-    server.enqueue(new MockResponse()
-        .setBody("Hello!")
-        .setHeader("Content-Type", PLAIN));
-    Response response = client.newCall(request().build()).execute();
-    response.body().close();
-
-    applicationLogs
-        .assertLogEqual("--> GET " + url)
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 6-byte body\\)")
-        .assertNoMoreLogs();
-
-    networkLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 6-byte body\\)")
-        .assertNoMoreLogs();
-  }
-
-  @Test public void basicChunkedResponseBody() throws IOException {
-    setLevel(Level.BASIC);
-
-    server.enqueue(new MockResponse()
-        .setChunkedBody("Hello!", 2)
-        .setHeader("Content-Type", PLAIN));
-    Response response = client.newCall(request().build()).execute();
-    response.body().close();
-
-    applicationLogs
-        .assertLogEqual("--> GET " + url)
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, unknown-length body\\)")
-        .assertNoMoreLogs();
-
-    networkLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, unknown-length body\\)")
-        .assertNoMoreLogs();
-  }
-
-  @Test public void headersGet() throws IOException {
-    setLevel(Level.HEADERS);
-
-    server.enqueue(new MockResponse());
-    Response response = client.newCall(request().build()).execute();
-    response.body().close();
-
-    applicationLogs
-        .assertLogEqual("--> GET " + url)
-        .assertLogEqual("--> END GET")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 0")
-        .assertLogEqual("<-- END HTTP")
-        .assertNoMoreLogs();
-
-    networkLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
-        .assertLogEqual("Host: " + host)
-        .assertLogEqual("Connection: Keep-Alive")
-        .assertLogEqual("Accept-Encoding: gzip")
-        .assertLogMatch("User-Agent: okhttp/.+")
-        .assertLogEqual("--> END GET")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 0")
-        .assertLogEqual("<-- END HTTP")
-        .assertNoMoreLogs();
-  }
-
-  @Test public void headersPost() throws IOException {
-    setLevel(Level.HEADERS);
-
-    server.enqueue(new MockResponse());
-    Request request = request().post(RequestBody.create(PLAIN, "Hi?")).build();
-    Response response = client.newCall(request).execute();
-    response.body().close();
-
-    applicationLogs
-        .assertLogEqual("--> POST " + url)
-        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
-        .assertLogEqual("Content-Length: 3")
-        .assertLogEqual("--> END POST")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 0")
-        .assertLogEqual("<-- END HTTP")
-        .assertNoMoreLogs();
-
-    networkLogs
-        .assertLogEqual("--> POST " + url + " http/1.1")
-        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
-        .assertLogEqual("Content-Length: 3")
-        .assertLogEqual("Host: " + host)
-        .assertLogEqual("Connection: Keep-Alive")
-        .assertLogEqual("Accept-Encoding: gzip")
-        .assertLogMatch("User-Agent: okhttp/.+")
-        .assertLogEqual("--> END POST")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 0")
-        .assertLogEqual("<-- END HTTP")
-        .assertNoMoreLogs();
-  }
-
-  @Test public void headersPostNoContentType() throws IOException {
-    setLevel(Level.HEADERS);
-
-    server.enqueue(new MockResponse());
-    Request request = request().post(RequestBody.create(null, "Hi?")).build();
-    Response response = client.newCall(request).execute();
-    response.body().close();
-
-    applicationLogs
-        .assertLogEqual("--> POST " + url)
-        .assertLogEqual("Content-Length: 3")
-        .assertLogEqual("--> END POST")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 0")
-        .assertLogEqual("<-- END HTTP")
-        .assertNoMoreLogs();
-
-    networkLogs
-        .assertLogEqual("--> POST " + url + " http/1.1")
-        .assertLogEqual("Content-Length: 3")
-        .assertLogEqual("Host: " + host)
-        .assertLogEqual("Connection: Keep-Alive")
-        .assertLogEqual("Accept-Encoding: gzip")
-        .assertLogMatch("User-Agent: okhttp/.+")
-        .assertLogEqual("--> END POST")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 0")
-        .assertLogEqual("<-- END HTTP")
-        .assertNoMoreLogs();
-  }
-
-  @Test public void headersPostNoLength() throws IOException {
-    setLevel(Level.HEADERS);
-
-    server.enqueue(new MockResponse());
-    RequestBody body = new RequestBody() {
-      @Override public MediaType contentType() {
-        return PLAIN;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        sink.writeUtf8("Hi!");
-      }
-    };
-    Response response = client.newCall(request().post(body).build()).execute();
-    response.body().close();
-
-    applicationLogs
-        .assertLogEqual("--> POST " + url)
-        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
-        .assertLogEqual("--> END POST")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 0")
-        .assertLogEqual("<-- END HTTP")
-        .assertNoMoreLogs();
-
-    networkLogs
-        .assertLogEqual("--> POST " + url + " http/1.1")
-        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
-        .assertLogEqual("Transfer-Encoding: chunked")
-        .assertLogEqual("Host: " + host)
-        .assertLogEqual("Connection: Keep-Alive")
-        .assertLogEqual("Accept-Encoding: gzip")
-        .assertLogMatch("User-Agent: okhttp/.+")
-        .assertLogEqual("--> END POST")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 0")
-        .assertLogEqual("<-- END HTTP")
-        .assertNoMoreLogs();
-  }
-
-  @Test public void headersResponseBody() throws IOException {
-    setLevel(Level.HEADERS);
-
-    server.enqueue(new MockResponse()
-        .setBody("Hello!")
-        .setHeader("Content-Type", PLAIN));
-    Response response = client.newCall(request().build()).execute();
-    response.body().close();
-
-    applicationLogs
-        .assertLogEqual("--> GET " + url)
-        .assertLogEqual("--> END GET")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 6")
-        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
-        .assertLogEqual("<-- END HTTP")
-        .assertNoMoreLogs();
-
-    networkLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
-        .assertLogEqual("Host: " + host)
-        .assertLogEqual("Connection: Keep-Alive")
-        .assertLogEqual("Accept-Encoding: gzip")
-        .assertLogMatch("User-Agent: okhttp/.+")
-        .assertLogEqual("--> END GET")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 6")
-        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
-        .assertLogEqual("<-- END HTTP")
-        .assertNoMoreLogs();
-  }
-
-  @Test public void bodyGet() throws IOException {
-    setLevel(Level.BODY);
-
-    server.enqueue(new MockResponse());
-    Response response = client.newCall(request().build()).execute();
-    response.body().close();
-
-    applicationLogs
-        .assertLogEqual("--> GET " + url)
-        .assertLogEqual("--> END GET")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 0")
-        .assertLogEqual("<-- END HTTP (0-byte body)")
-        .assertNoMoreLogs();
-
-    networkLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
-        .assertLogEqual("Host: " + host)
-        .assertLogEqual("Connection: Keep-Alive")
-        .assertLogEqual("Accept-Encoding: gzip")
-        .assertLogMatch("User-Agent: okhttp/.+")
-        .assertLogEqual("--> END GET")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 0")
-        .assertLogEqual("<-- END HTTP (0-byte body)")
-        .assertNoMoreLogs();
-  }
-
-  @Test public void bodyGet204() throws IOException {
-    setLevel(Level.BODY);
-    bodyGetNoBody(204);
-  }
-
-  @Test public void bodyGet205() throws IOException {
-    setLevel(Level.BODY);
-    bodyGetNoBody(205);
-  }
-
-  private void bodyGetNoBody(int code) throws IOException {
-    server.enqueue(new MockResponse()
-        .setStatus("HTTP/1.1 " + code + " No Content"));
-    Response response = client.newCall(request().build()).execute();
-    response.body().close();
-
-    applicationLogs
-        .assertLogEqual("--> GET " + url)
-        .assertLogEqual("--> END GET")
-        .assertLogMatch("<-- " + code + " No Content " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 0")
-        .assertLogEqual("<-- END HTTP (0-byte body)")
-        .assertNoMoreLogs();
-
-    networkLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
-        .assertLogEqual("Host: " + host)
-        .assertLogEqual("Connection: Keep-Alive")
-        .assertLogEqual("Accept-Encoding: gzip")
-        .assertLogMatch("User-Agent: okhttp/.+")
-        .assertLogEqual("--> END GET")
-        .assertLogMatch("<-- " + code + " No Content " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 0")
-        .assertLogEqual("<-- END HTTP (0-byte body)")
-        .assertNoMoreLogs();
-  }
-
-  @Test public void bodyPost() throws IOException {
-    setLevel(Level.BODY);
-
-    server.enqueue(new MockResponse());
-    Request request = request().post(RequestBody.create(PLAIN, "Hi?")).build();
-    Response response = client.newCall(request).execute();
-    response.body().close();
-
-    applicationLogs
-        .assertLogEqual("--> POST " + url)
-        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
-        .assertLogEqual("Content-Length: 3")
-        .assertLogEqual("")
-        .assertLogEqual("Hi?")
-        .assertLogEqual("--> END POST (3-byte body)")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 0")
-        .assertLogEqual("<-- END HTTP (0-byte body)")
-        .assertNoMoreLogs();
-
-    networkLogs
-        .assertLogEqual("--> POST " + url + " http/1.1")
-        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
-        .assertLogEqual("Content-Length: 3")
-        .assertLogEqual("Host: " + host)
-        .assertLogEqual("Connection: Keep-Alive")
-        .assertLogEqual("Accept-Encoding: gzip")
-        .assertLogMatch("User-Agent: okhttp/.+")
-        .assertLogEqual("")
-        .assertLogEqual("Hi?")
-        .assertLogEqual("--> END POST (3-byte body)")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 0")
-        .assertLogEqual("<-- END HTTP (0-byte body)")
-        .assertNoMoreLogs();
-  }
-
-  @Test public void bodyResponseBody() throws IOException {
-    setLevel(Level.BODY);
-
-    server.enqueue(new MockResponse()
-        .setBody("Hello!")
-        .setHeader("Content-Type", PLAIN));
-    Response response = client.newCall(request().build()).execute();
-    response.body().close();
-
-    applicationLogs
-        .assertLogEqual("--> GET " + url)
-        .assertLogEqual("--> END GET")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 6")
-        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
-        .assertLogEqual("")
-        .assertLogEqual("Hello!")
-        .assertLogEqual("<-- END HTTP (6-byte body)")
-        .assertNoMoreLogs();
-
-    networkLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
-        .assertLogEqual("Host: " + host)
-        .assertLogEqual("Connection: Keep-Alive")
-        .assertLogEqual("Accept-Encoding: gzip")
-        .assertLogMatch("User-Agent: okhttp/.+")
-        .assertLogEqual("--> END GET")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 6")
-        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
-        .assertLogEqual("")
-        .assertLogEqual("Hello!")
-        .assertLogEqual("<-- END HTTP (6-byte body)")
-        .assertNoMoreLogs();
-  }
-
-  @Test public void bodyResponseBodyChunked() throws IOException {
-    setLevel(Level.BODY);
-
-    server.enqueue(new MockResponse()
-        .setChunkedBody("Hello!", 2)
-        .setHeader("Content-Type", PLAIN));
-    Response response = client.newCall(request().build()).execute();
-    response.body().close();
-
-    applicationLogs
-        .assertLogEqual("--> GET " + url)
-        .assertLogEqual("--> END GET")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Transfer-encoding: chunked")
-        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
-        .assertLogEqual("")
-        .assertLogEqual("Hello!")
-        .assertLogEqual("<-- END HTTP (6-byte body)")
-        .assertNoMoreLogs();
-
-    networkLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
-        .assertLogEqual("Host: " + host)
-        .assertLogEqual("Connection: Keep-Alive")
-        .assertLogEqual("Accept-Encoding: gzip")
-        .assertLogMatch("User-Agent: okhttp/.+")
-        .assertLogEqual("--> END GET")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Transfer-encoding: chunked")
-        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
-        .assertLogEqual("")
-        .assertLogEqual("Hello!")
-        .assertLogEqual("<-- END HTTP (6-byte body)")
-        .assertNoMoreLogs();
-  }
-
-  @Test public void bodyResponseGzipEncoded() throws IOException {
-    setLevel(Level.BODY);
-
-    server.enqueue(new MockResponse()
-        .setHeader("Content-Encoding", "gzip")
-        .setHeader("Content-Type", PLAIN)
-        .setBody(new Buffer().write(ByteString.decodeBase64(
-            "H4sIAAAAAAAAAPNIzcnJ11HwQKIAdyO+9hMAAAA="))));
-    Response response = client.newCall(request().build()).execute();
-
-    ResponseBody responseBody = response.body();
-    assertThat(responseBody.string()).overridingErrorMessage(
-        "Expected response body to be valid").isEqualTo("Hello, Hello, Hello");
-    responseBody.close();
-
-    networkLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
-        .assertLogEqual("Host: " + host)
-        .assertLogEqual("Connection: Keep-Alive")
-        .assertLogEqual("Accept-Encoding: gzip")
-        .assertLogMatch("User-Agent: okhttp/.+")
-        .assertLogEqual("--> END GET")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Encoding: gzip")
-        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
-        .assertLogMatch("Content-Length: \\d+")
-        .assertLogEqual("")
-        .assertLogEqual("Hello, Hello, Hello")
-        .assertLogEqual("<-- END HTTP (19-byte, 29-gzipped-byte body)")
-        .assertNoMoreLogs();
-
-    applicationLogs
-        .assertLogEqual("--> GET " + url)
-        .assertLogEqual("--> END GET")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
-        .assertLogEqual("")
-        .assertLogEqual("Hello, Hello, Hello")
-        .assertLogEqual("<-- END HTTP (19-byte body)")
-        .assertNoMoreLogs();
-  }
-
-  @Test public void bodyResponseUnknownEncoded() throws IOException {
-      setLevel(Level.BODY);
-
-      server.enqueue(new MockResponse()
-          // It's invalid to return this if not requested, but the server might anyway
-          .setHeader("Content-Encoding", "br")
-          .setHeader("Content-Type", PLAIN)
-          .setBody(new Buffer().write(ByteString.decodeBase64(
-              "iwmASGVsbG8sIEhlbGxvLCBIZWxsbwoD"))));
-      Response response = client.newCall(request().build()).execute();
-      response.body().close();
-
-      networkLogs
-          .assertLogEqual("--> GET " + url + " http/1.1")
-          .assertLogEqual("Host: " + host)
-          .assertLogEqual("Connection: Keep-Alive")
-          .assertLogEqual("Accept-Encoding: gzip")
-          .assertLogMatch("User-Agent: okhttp/.+")
-          .assertLogEqual("--> END GET")
-          .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-          .assertLogEqual("Content-Encoding: br")
-          .assertLogEqual("Content-Type: text/plain; charset=utf-8")
-          .assertLogMatch("Content-Length: \\d+")
-          .assertLogEqual("<-- END HTTP (encoded body omitted)")
-          .assertNoMoreLogs();
-
-      applicationLogs
-          .assertLogEqual("--> GET " + url)
-          .assertLogEqual("--> END GET")
-          .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-          .assertLogEqual("Content-Encoding: br")
-          .assertLogEqual("Content-Type: text/plain; charset=utf-8")
-          .assertLogMatch("Content-Length: \\d+")
-          .assertLogEqual("<-- END HTTP (encoded body omitted)")
-          .assertNoMoreLogs();
-    }
-
-  @Test public void bodyGetMalformedCharset() throws IOException {
-    setLevel(Level.BODY);
-
-    server.enqueue(new MockResponse()
-        .setHeader("Content-Type", "text/html; charset=0")
-        .setBody("Body with unknown charset"));
-    Response response = client.newCall(request().build()).execute();
-    response.body().close();
-
-    networkLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
-        .assertLogEqual("Host: " + host)
-        .assertLogEqual("Connection: Keep-Alive")
-        .assertLogEqual("Accept-Encoding: gzip")
-        .assertLogMatch("User-Agent: okhttp/.+")
-        .assertLogEqual("--> END GET")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Type: text/html; charset=0")
-        .assertLogMatch("Content-Length: \\d+")
-        .assertLogMatch("")
-        .assertLogEqual("Body with unknown charset")
-        .assertLogEqual("<-- END HTTP (25-byte body)")
-        .assertNoMoreLogs();
-
-    applicationLogs
-        .assertLogEqual("--> GET " + url)
-        .assertLogEqual("--> END GET")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Type: text/html; charset=0")
-        .assertLogMatch("Content-Length: \\d+")
-        .assertLogEqual("")
-        .assertLogEqual("Body with unknown charset")
-        .assertLogEqual("<-- END HTTP (25-byte body)")
-        .assertNoMoreLogs();
-  }
-
-  @Test public void isPlaintext() {
-    assertThat(HttpLoggingInterceptor.isPlaintext(new Buffer())).isTrue();
-    assertThat(HttpLoggingInterceptor.isPlaintext(new Buffer().writeUtf8("abc"))).isTrue();
-    assertThat(HttpLoggingInterceptor.isPlaintext(new Buffer().writeUtf8("new\r\nlines"))).isTrue();
-    assertThat(HttpLoggingInterceptor.isPlaintext(new Buffer().writeUtf8("white\t space"))).isTrue();
-    assertThat(HttpLoggingInterceptor.isPlaintext(new Buffer().writeByte(0x80))).isTrue();
-    assertThat(HttpLoggingInterceptor.isPlaintext(new Buffer().writeByte(0x00))).isFalse();
-    assertThat(HttpLoggingInterceptor.isPlaintext(new Buffer().writeByte(0xc0))).isFalse();
-  }
-
-  @Test public void responseBodyIsBinary() throws IOException {
-    setLevel(Level.BODY);
-    Buffer buffer = new Buffer();
-    buffer.writeUtf8CodePoint(0x89);
-    buffer.writeUtf8CodePoint(0x50);
-    buffer.writeUtf8CodePoint(0x4e);
-    buffer.writeUtf8CodePoint(0x47);
-    buffer.writeUtf8CodePoint(0x0d);
-    buffer.writeUtf8CodePoint(0x0a);
-    buffer.writeUtf8CodePoint(0x1a);
-    buffer.writeUtf8CodePoint(0x0a);
-    server.enqueue(new MockResponse()
-        .setBody(buffer)
-        .setHeader("Content-Type", "image/png; charset=utf-8"));
-    Response response = client.newCall(request().build()).execute();
-    response.body().close();
-
-    applicationLogs
-        .assertLogEqual("--> GET " + url)
-        .assertLogEqual("--> END GET")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 9")
-        .assertLogEqual("Content-Type: image/png; charset=utf-8")
-        .assertLogEqual("")
-        .assertLogEqual("<-- END HTTP (binary 9-byte body omitted)")
-        .assertNoMoreLogs();
-
-    networkLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
-        .assertLogEqual("Host: " + host)
-        .assertLogEqual("Connection: Keep-Alive")
-        .assertLogEqual("Accept-Encoding: gzip")
-        .assertLogMatch("User-Agent: okhttp/.+")
-        .assertLogEqual("--> END GET")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 9")
-        .assertLogEqual("Content-Type: image/png; charset=utf-8")
-        .assertLogEqual("")
-        .assertLogEqual("<-- END HTTP (binary 9-byte body omitted)")
-        .assertNoMoreLogs();
-  }
-
-  @Test public void connectFail() throws IOException {
-    setLevel(Level.BASIC);
-    client = new OkHttpClient.Builder()
-        .dns(hostname -> { throw new UnknownHostException("reason"); })
-        .addInterceptor(applicationInterceptor)
-        .build();
-
-    try {
-      client.newCall(request().build()).execute();
-      fail();
-    } catch (UnknownHostException expected) {
-    }
-
-    applicationLogs
-        .assertLogEqual("--> GET " + url)
-        .assertLogEqual("<-- HTTP FAILED: java.net.UnknownHostException: reason")
-        .assertNoMoreLogs();
-  }
-
-  @Test public void http2() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    url = server.url("/");
-
-    setLevel(Level.BASIC);
-
-    server.enqueue(new MockResponse());
-    Response response = client.newCall(request().build()).execute();
-    assumeThat(response.protocol(), equalTo(Protocol.HTTP_2));
-
-    applicationLogs
-        .assertLogEqual("--> GET " + url)
-        .assertLogMatch("<-- 200 " + url + " \\(\\d+ms, 0-byte body\\)")
-        .assertNoMoreLogs();
-
-    networkLogs
-        .assertLogEqual("--> GET " + url + " h2")
-        .assertLogMatch("<-- 200 " + url + " \\(\\d+ms, 0-byte body\\)")
-        .assertNoMoreLogs();
-  }
-
-  @Test
-  public void headersAreRedacted() throws Exception {
-    HttpLoggingInterceptor networkInterceptor =
-        new HttpLoggingInterceptor(networkLogs).setLevel(Level.HEADERS);
-    networkInterceptor.redactHeader("sEnSiTiVe");
-
-    HttpLoggingInterceptor applicationInterceptor =
-        new HttpLoggingInterceptor(applicationLogs).setLevel(Level.HEADERS);
-    applicationInterceptor.redactHeader("sEnSiTiVe");
-
-    client =
-        new OkHttpClient.Builder()
-            .addNetworkInterceptor(networkInterceptor)
-            .addInterceptor(applicationInterceptor)
-            .build();
-
-    server.enqueue(
-        new MockResponse().addHeader("SeNsItIvE", "Value").addHeader("Not-Sensitive", "Value"));
-    Response response =
-        client
-            .newCall(
-                request()
-                    .addHeader("SeNsItIvE", "Value")
-                    .addHeader("Not-Sensitive", "Value")
-                    .build())
-            .execute();
-    response.body().close();
-
-    applicationLogs
-        .assertLogEqual("--> GET " + url)
-        .assertLogEqual("SeNsItIvE: ‚ñà‚ñà")
-        .assertLogEqual("Not-Sensitive: Value")
-        .assertLogEqual("--> END GET")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 0")
-        .assertLogEqual("SeNsItIvE: ‚ñà‚ñà")
-        .assertLogEqual("Not-Sensitive: Value")
-        .assertLogEqual("<-- END HTTP")
-        .assertNoMoreLogs();
-
-    networkLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
-        .assertLogEqual("SeNsItIvE: ‚ñà‚ñà")
-        .assertLogEqual("Not-Sensitive: Value")
-        .assertLogEqual("Host: " + host)
-        .assertLogEqual("Connection: Keep-Alive")
-        .assertLogEqual("Accept-Encoding: gzip")
-        .assertLogMatch("User-Agent: okhttp/.+")
-        .assertLogEqual("--> END GET")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 0")
-        .assertLogEqual("SeNsItIvE: ‚ñà‚ñà")
-        .assertLogEqual("Not-Sensitive: Value")
-        .assertLogEqual("<-- END HTTP")
-        .assertNoMoreLogs();
-  }
-
-  @Test public void duplexRequestsAreNotLogged() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false); // HTTP/2
-    url = server.url("/");
-
-    setLevel(Level.BODY);
-
-    server.enqueue(new MockResponse()
-        .setBody("Hello response!"));
-
-    RequestBody asyncRequestBody = new RequestBody() {
-      @Override public @Nullable MediaType contentType() {
-        return null;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        sink.writeUtf8("Hello request!");
-        sink.close();
-      }
-
-      @Override public boolean isDuplex() {
-        return true;
-      }
-    };
-
-    Request request = request()
-        .post(asyncRequestBody)
-        .build();
-    Response response = client.newCall(request).execute();
-    assumeThat(response.protocol(), equalTo(Protocol.HTTP_2));
-
-    assertThat(response.body().string()).isEqualTo("Hello response!");
-
-    applicationLogs
-        .assertLogEqual("--> POST " + url)
-        .assertLogEqual("--> END POST (duplex request body omitted)")
-        .assertLogMatch("<-- 200 " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("content-length: 15")
-        .assertLogEqual("")
-        .assertLogEqual("Hello response!")
-        .assertLogEqual("<-- END HTTP (15-byte body)")
-        .assertNoMoreLogs();
-  }
-
-  private Request.Builder request() {
-    return new Request.Builder().url(url);
-  }
-
-  static class LogRecorder implements HttpLoggingInterceptor.Logger {
-    private final List<String> logs = new ArrayList<>();
-    private int index;
-
-    LogRecorder assertLogEqual(String expected) {
-      assertThat(index < logs.size()).overridingErrorMessage("No more messages found").isTrue();
-      String actual = logs.get(index++);
-      assertThat(actual).isEqualTo(expected);
-      return this;
-    }
-
-    LogRecorder assertLogMatch(String pattern) {
-      assertThat(index < logs.size()).overridingErrorMessage("No more messages found").isTrue();
-      String actual = logs.get(index++);
-      assertThat(Pattern.matches(pattern, actual)).overridingErrorMessage(
-          "<" + actual + "> did not match pattern <" + pattern + ">").isTrue();
-      return this;
-    }
-
-    void assertNoMoreLogs() {
-      assertThat(logs.size()).overridingErrorMessage(
-          "More messages remain: " + logs.subList(index, logs.size())).isEqualTo(index);
-    }
-
-    @Override public void log(String message) {
-      logs.add(message);
-    }
-  }
-}
diff --git a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/LoggingEventListenerTest.java b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/LoggingEventListenerTest.java
deleted file mode 100644
index a1d3015421..0000000000
--- a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/LoggingEventListenerTest.java
+++ /dev/null
@@ -1,227 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.logging;
-
-import java.io.IOException;
-import java.net.UnknownHostException;
-import okhttp3.HttpUrl;
-import okhttp3.MediaType;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.SocketPolicy;
-import okhttp3.tls.HandshakeCertificates;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static java.util.Arrays.asList;
-import static okhttp3.Protocol.HTTP_1_1;
-import static okhttp3.Protocol.HTTP_2;
-import static okhttp3.tls.internal.TlsUtil.localhost;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class LoggingEventListenerTest {
-  private static final MediaType PLAIN = MediaType.get("text/plain");
-
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  private final HandshakeCertificates handshakeCertificates = localhost();
-  private final LogRecorder logRecorder = new LogRecorder();
-  private final LoggingEventListener.Factory loggingEventListenerFactory =
-      new LoggingEventListener.Factory(logRecorder);
-  private OkHttpClient client;
-  private HttpUrl url;
-
-  @Before
-  public void setUp() {
-    client =
-        new OkHttpClient.Builder()
-            .eventListenerFactory(loggingEventListenerFactory)
-            .sslSocketFactory(
-                handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-            .retryOnConnectionFailure(false)
-            .build();
-
-    url = server.url("/");
-  }
-
-  @Test
-  public void get() throws Exception {
-    server.enqueue(new MockResponse().setBody("Hello!").setHeader("Content-Type", PLAIN));
-    Response response = client.newCall(request().build()).execute();
-    assertThat(response.body()).isNotNull();
-    response.body().bytes();
-
-    logRecorder
-        .assertLogMatch("callStart: Request\\{method=GET, url=" + url + ", tags=\\{\\}\\}")
-        .assertLogMatch("dnsStart: " + url.host())
-        .assertLogMatch("dnsEnd: \\[.+\\]")
-        .assertLogMatch("connectStart: " + url.host() + "/.+ DIRECT")
-        .assertLogMatch("connectEnd: http/1.1")
-        .assertLogMatch(
-            "connectionAcquired: Connection\\{"
-                + url.host()
-                + ":\\d+, proxy=DIRECT hostAddress="
-                + url.host()
-                + "/.+ cipherSuite=none protocol=http/1\\.1\\}")
-        .assertLogMatch("requestHeadersStart")
-        .assertLogMatch("requestHeadersEnd")
-        .assertLogMatch("responseHeadersStart")
-        .assertLogMatch(
-            "responseHeadersEnd: Response\\{protocol=http/1\\.1, code=200, message=OK, url="
-                + url
-                + "}")
-        .assertLogMatch("responseBodyStart")
-        .assertLogMatch("responseBodyEnd: byteCount=6")
-        .assertLogMatch("connectionReleased")
-        .assertLogMatch("callEnd")
-        .assertNoMoreLogs();
-  }
-
-  @Test
-  public void post() throws IOException {
-    server.enqueue(new MockResponse());
-    client.newCall(request().post(RequestBody.create(PLAIN, "Hello!")).build()).execute();
-
-    logRecorder
-        .assertLogMatch("callStart: Request\\{method=POST, url=" + url + ", tags=\\{\\}\\}")
-        .assertLogMatch("dnsStart: " + url.host())
-        .assertLogMatch("dnsEnd: \\[.+\\]")
-        .assertLogMatch("connectStart: " + url.host() + "/.+ DIRECT")
-        .assertLogMatch("connectEnd: http/1.1")
-        .assertLogMatch(
-            "connectionAcquired: Connection\\{"
-                + url.host()
-                + ":\\d+, proxy=DIRECT hostAddress="
-                + url.host()
-                + "/.+ cipherSuite=none protocol=http/1\\.1\\}")
-        .assertLogMatch("requestHeadersStart")
-        .assertLogMatch("requestHeadersEnd")
-        .assertLogMatch("requestBodyStart")
-        .assertLogMatch("requestBodyEnd: byteCount=6")
-        .assertLogMatch("responseHeadersStart")
-        .assertLogMatch(
-            "responseHeadersEnd: Response\\{protocol=http/1\\.1, code=200, message=OK, url="
-                + url
-                + "}")
-        .assertLogMatch("responseBodyStart")
-        .assertLogMatch("responseBodyEnd: byteCount=0")
-        .assertLogMatch("connectionReleased")
-        .assertLogMatch("callEnd")
-        .assertNoMoreLogs();
-  }
-
-  @Test
-  public void secureGet() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    url = server.url("/");
-
-    server.enqueue(new MockResponse());
-    Response response = client.newCall(request().build()).execute();
-    assertThat(response.body()).isNotNull();
-    response.body().bytes();
-
-    logRecorder
-        .assertLogMatch("callStart: Request\\{method=GET, url=" + url + ", tags=\\{\\}\\}")
-        .assertLogMatch("dnsStart: " + url.host())
-        .assertLogMatch("dnsEnd: \\[.+\\]")
-        .assertLogMatch("connectStart: " + url.host() + "/.+ DIRECT")
-        .assertLogMatch("secureConnectStart")
-        .assertLogMatch("secureConnectEnd: Handshake\\{"
-            + "tlsVersion=TLS_1_[23] "
-            + "cipherSuite=TLS_.* "
-            + "peerCertificates=\\[CN=localhost\\] "
-            + "localCertificates=\\[\\]}")
-        .assertLogMatch("connectEnd: h2")
-        .assertLogMatch(
-            "connectionAcquired: Connection\\{"
-                + url.host()
-                + ":\\d+, proxy=DIRECT hostAddress="
-                + url.host()
-                + "/.+ cipherSuite=.+ protocol=h2}")
-        .assertLogMatch("requestHeadersStart")
-        .assertLogMatch("requestHeadersEnd")
-        .assertLogMatch("responseHeadersStart")
-        .assertLogMatch(
-            "responseHeadersEnd: Response\\{protocol=h2, code=200, message=, url=" + url + "}")
-        .assertLogMatch("responseBodyStart")
-        .assertLogMatch("responseBodyEnd: byteCount=0")
-        .assertLogMatch("connectionReleased")
-        .assertLogMatch("callEnd")
-        .assertNoMoreLogs();
-  }
-
-  @Test
-  public void dnsFail() throws IOException {
-    client = new OkHttpClient.Builder()
-        .dns(hostname -> { throw new UnknownHostException("reason"); })
-        .eventListenerFactory(loggingEventListenerFactory)
-        .build();
-
-    try {
-      client.newCall(request().build()).execute();
-      fail();
-    } catch (UnknownHostException expected) {
-    }
-
-    logRecorder
-        .assertLogMatch("callStart: Request\\{method=GET, url=" + url + ", tags=\\{\\}\\}")
-        .assertLogMatch("dnsStart: " + url.host())
-        .assertLogMatch("callFailed: java.net.UnknownHostException: reason")
-        .assertNoMoreLogs();
-  }
-
-  @Test
-  public void connectFail() {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.setProtocols(asList(HTTP_2, HTTP_1_1));
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
-    url = server.url("/");
-
-    try {
-      client.newCall(request().build()).execute();
-      fail();
-    } catch (IOException expected) {
-    }
-
-    logRecorder
-        .assertLogMatch("callStart: Request\\{method=GET, url=" + url + ", tags=\\{\\}\\}")
-        .assertLogMatch("dnsStart: " + url.host())
-        .assertLogMatch("dnsEnd: \\[.+\\]")
-        .assertLogMatch("connectStart: " + url.host() + "/.+ DIRECT")
-        .assertLogMatch("secureConnectStart")
-        .assertLogMatch(
-            "connectFailed: null javax\\.net\\.ssl\\.SSLProtocolException: (?:Unexpected handshake message: client_hello|Handshake message sequence violation, 1)")
-        .assertLogMatch(
-            "callFailed: javax\\.net\\.ssl\\.SSLProtocolException: (?:Unexpected handshake message: client_hello|Handshake message sequence violation, 1)")
-        .assertNoMoreLogs();
-  }
-
-  private Request.Builder request() {
-    return new Request.Builder().url(url);
-  }
-
-  private static class LogRecorder extends HttpLoggingInterceptorTest.LogRecorder {
-    LogRecorder assertLogMatch(String pattern) {
-      return (LogRecorder) super.assertLogMatch("\\[\\d+ ms] " + pattern);
-    }
-  }
-}
diff --git a/okhttp-sse/README.md b/okhttp-sse/README.md
deleted file mode 100644
index 2b1bc42830..0000000000
--- a/okhttp-sse/README.md
+++ /dev/null
@@ -1,5 +0,0 @@
-OkHttp Server-Sent Events
-=========================
-
-Experimental support for server-sent events.
-API is not considered stable and may change at any time.
diff --git a/okhttp-sse/pom.xml b/okhttp-sse/pom.xml
deleted file mode 100644
index 2bda5e90d5..0000000000
--- a/okhttp-sse/pom.xml
+++ /dev/null
@@ -1,78 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.14.3-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>okhttp-sse</artifactId>
-  <name>OkHttp Server-Sent Events</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.google.code.findbugs</groupId>
-      <artifactId>jsr305</artifactId>
-      <scope>provided</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-testing-support</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-javadoc-plugin</artifactId>
-        <version>3.0.1</version>
-        <configuration>
-          <excludePackageNames>okhttp3.internal:okhttp3.internal.*</excludePackageNames>
-          <links>
-            <link>http://square.github.io/okhttp/javadoc/</link>
-          </links>
-        </configuration>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-jar-plugin</artifactId>
-        <version>3.1.1</version>
-        <configuration>
-          <archive>
-            <manifestEntries>
-              <Automatic-Module-Name>okhttp3.sse</Automatic-Module-Name>
-            </manifestEntries>
-          </archive>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/okhttp-sse/src/main/java/okhttp3/internal/sse/RealEventSource.java b/okhttp-sse/src/main/java/okhttp3/internal/sse/RealEventSource.java
deleted file mode 100644
index d1261077a4..0000000000
--- a/okhttp-sse/src/main/java/okhttp3/internal/sse/RealEventSource.java
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.sse;
-
-import java.io.IOException;
-import javax.annotation.Nullable;
-import okhttp3.Call;
-import okhttp3.Callback;
-import okhttp3.EventListener;
-import okhttp3.MediaType;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.internal.Internal;
-import okhttp3.internal.Util;
-import okhttp3.internal.connection.Exchange;
-import okhttp3.sse.EventSource;
-import okhttp3.sse.EventSourceListener;
-
-public final class RealEventSource
-    implements EventSource, ServerSentEventReader.Callback, Callback {
-
-  private final Request request;
-  private final EventSourceListener listener;
-
-  private @Nullable Call call;
-
-  public RealEventSource(Request request, EventSourceListener listener) {
-    this.request = request;
-    this.listener = listener;
-  }
-
-  public void connect(OkHttpClient client) {
-    client = client.newBuilder()
-        .eventListener(EventListener.NONE)
-        .build();
-    call = client.newCall(request);
-    call.enqueue(this);
-  }
-
-  @Override public void onResponse(Call call, Response response) {
-    processResponse(response);
-  }
-
-  public void processResponse(Response response) {
-    try {
-      if (!response.isSuccessful()) {
-        listener.onFailure(this, null, response);
-        return;
-      }
-
-      ResponseBody body = response.body();
-
-      //noinspection ConstantConditions main body is never null
-      MediaType contentType = body.contentType();
-      if (!isEventStream(contentType)) {
-        listener.onFailure(this,
-            new IllegalStateException("Invalid content-type: " + contentType), response);
-        return;
-      }
-
-      // This is a long-lived response. Cancel full-call timeouts.
-      Exchange exchange = Internal.instance.exchange(response);
-      if (exchange != null) exchange.timeoutEarlyExit();
-
-      // Replace the body with an empty one so the callbacks can't see real data.
-      response = response.newBuilder().body(Util.EMPTY_RESPONSE).build();
-
-      ServerSentEventReader reader = new ServerSentEventReader(body.source(), this);
-      try {
-        listener.onOpen(this, response);
-        while (reader.processNextEvent()) {
-        }
-      } catch (Exception e) {
-        listener.onFailure(this, e, response);
-        return;
-      }
-
-      listener.onClosed(this);
-    } finally {
-      response.close();
-    }
-  }
-
-  private static boolean isEventStream(@Nullable MediaType contentType) {
-    return contentType != null && contentType.type().equals("text") && contentType.subtype()
-        .equals("event-stream");
-  }
-
-  @Override public void onFailure(Call call, IOException e) {
-    listener.onFailure(this, e, null);
-  }
-
-  @Override public Request request() {
-    return request;
-  }
-
-  @Override public void cancel() {
-    call.cancel();
-  }
-
-  @Override public void onEvent(@Nullable String id, @Nullable String type, String data) {
-    listener.onEvent(this, id, type, data);
-  }
-
-  @Override public void onRetryChange(long timeMs) {
-    // Ignored. We do not auto-retry.
-  }
-}
diff --git a/okhttp-sse/src/main/java/okhttp3/internal/sse/ServerSentEventReader.java b/okhttp-sse/src/main/java/okhttp3/internal/sse/ServerSentEventReader.java
deleted file mode 100644
index ae19d3745e..0000000000
--- a/okhttp-sse/src/main/java/okhttp3/internal/sse/ServerSentEventReader.java
+++ /dev/null
@@ -1,201 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.sse;
-
-import java.io.IOException;
-import javax.annotation.Nullable;
-import okio.Buffer;
-import okio.BufferedSource;
-import okio.ByteString;
-
-public final class ServerSentEventReader {
-  private static final ByteString CRLF = ByteString.encodeUtf8("\r\n");
-  private static final ByteString DATA = ByteString.encodeUtf8("data");
-  private static final ByteString ID = ByteString.encodeUtf8("id");
-  private static final ByteString EVENT = ByteString.encodeUtf8("event");
-  private static final ByteString RETRY = ByteString.encodeUtf8("retry");
-
-  public interface Callback {
-    void onEvent(@Nullable String id, @Nullable String type, String data);
-    void onRetryChange(long timeMs);
-  }
-
-  private final BufferedSource source;
-  private final Callback callback;
-
-  private String lastId = null;
-
-  public ServerSentEventReader(BufferedSource source, Callback callback) {
-    if (source == null) throw new NullPointerException("source == null");
-    if (callback == null) throw new NullPointerException("callback == null");
-    this.source = source;
-    this.callback = callback;
-  }
-
-  /**
-   * Process the next event. This will result in a single call to {@link Callback#onEvent}
-   * <em>unless</em> the data section was empty. Any number of calls to
-   * {@link Callback#onRetryChange} may occur while processing an event.
-   *
-   * @return false when EOF is reached
-   */
-  boolean processNextEvent() throws IOException {
-    String id = lastId;
-    String type = null;
-    Buffer data = new Buffer();
-
-    while (true) {
-      long lineEnd = source.indexOfElement(CRLF);
-      if (lineEnd == -1L) {
-        return false;
-      }
-
-      switch (source.getBuffer().getByte(0)) {
-        case '\r':
-        case '\n':
-          completeEvent(id, type, data);
-          return true;
-
-        case 'd':
-          if (isKey(DATA)) {
-            parseData(data, lineEnd);
-            continue;
-          }
-          break;
-
-        case 'e':
-          if (isKey(EVENT)) {
-            type = parseEvent(lineEnd);
-            continue;
-          }
-          break;
-
-        case 'i':
-          if (isKey(ID)) {
-            id = parseId(lineEnd);
-            continue;
-          }
-          break;
-
-        case 'r':
-          if (isKey(RETRY)) {
-            parseRetry(lineEnd);
-            continue;
-          }
-          break;
-      }
-
-      source.skip(lineEnd);
-      skipCrAndOrLf();
-    }
-  }
-
-  private void completeEvent(String id, String type, Buffer data) throws IOException {
-    skipCrAndOrLf();
-
-    if (data.size() != 0L) {
-      lastId = id;
-      data.skip(1L); // Leading newline.
-      callback.onEvent(id, type, data.readUtf8());
-    }
-  }
-
-  private void parseData(Buffer data, long end) throws IOException {
-    data.writeByte('\n');
-    end -= skipNameAndDivider(4L);
-    source.readFully(data, end);
-    skipCrAndOrLf();
-  }
-
-  private String parseEvent(long end) throws IOException {
-    String type = null;
-    end -= skipNameAndDivider(5L);
-    if (end != 0L) {
-      type = source.readUtf8(end);
-    }
-    skipCrAndOrLf();
-    return type;
-  }
-
-  private String parseId(long end) throws IOException {
-    String id;
-    end -= skipNameAndDivider(2L);
-    if (end != 0L) {
-      id = source.readUtf8(end);
-    } else {
-      id = null;
-    }
-    skipCrAndOrLf();
-    return id;
-  }
-
-  private void parseRetry(long end) throws IOException {
-    end -= skipNameAndDivider(5L);
-    String retryString = source.readUtf8(end);
-    long retryMs = -1L;
-    try {
-      retryMs = Long.parseLong(retryString);
-    } catch (NumberFormatException ignored) {
-    }
-    if (retryMs != -1L) {
-      callback.onRetryChange(retryMs);
-    }
-    skipCrAndOrLf();
-  }
-
-  /**
-   * Returns true if the first bytes of {@link #source} are {@code key} followed by a colon or
-   * a newline.
-   */
-  private boolean isKey(ByteString key) throws IOException {
-    if (source.rangeEquals(0, key)) {
-      byte nextByte = source.getBuffer().getByte(key.size());
-      return nextByte == ':'
-          || nextByte == '\r'
-          || nextByte == '\n';
-    }
-    return false;
-  }
-
-  /** Consumes {@code \r}, {@code \r\n}, or {@code \n} from {@link #source}. */
-  private void skipCrAndOrLf() throws IOException {
-    if ((source.readByte() & 0xff) == '\r'
-        && source.request(1)
-        && source.getBuffer().getByte(0) == '\n') {
-      source.skip(1);
-    }
-  }
-
-  /**
-   * Consumes the field name of the specified length and the optional colon and its optional
-   * trailing space. Returns the number of bytes skipped.
-   */
-  private long skipNameAndDivider(long length) throws IOException {
-    source.skip(length);
-
-    if (source.getBuffer().getByte(0) == ':') {
-      source.skip(1L);
-      length++;
-
-      if (source.getBuffer().getByte(0) == ' ') {
-        source.skip(1);
-        length++;
-      }
-    }
-
-    return length;
-  }
-}
diff --git a/okhttp-sse/src/main/java/okhttp3/internal/sse/package-info.java b/okhttp-sse/src/main/java/okhttp3/internal/sse/package-info.java
deleted file mode 100644
index afcf5f4f9d..0000000000
--- a/okhttp-sse/src/main/java/okhttp3/internal/sse/package-info.java
+++ /dev/null
@@ -1,3 +0,0 @@
-/** Private support classes for server-sent events. */
-@okhttp3.internal.annotations.EverythingIsNonNull
-package okhttp3.internal.sse;
diff --git a/okhttp-sse/src/main/java/okhttp3/sse/EventSource.java b/okhttp-sse/src/main/java/okhttp3/sse/EventSource.java
deleted file mode 100644
index fe703dc8c0..0000000000
--- a/okhttp-sse/src/main/java/okhttp3/sse/EventSource.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.sse;
-
-import okhttp3.Request;
-
-public interface EventSource {
-  /** Returns the original request that initiated this event source. */
-  Request request();
-
-  /**
-   * Immediately and violently release resources held by this event source. This does nothing if
-   * the event source has already been closed or canceled.
-   */
-  void cancel();
-
-  interface Factory {
-    /**
-     * Creates a new event source and immediately returns it. Creating an event source initiates an
-     * asynchronous process to connect the socket. Once that succeeds or fails, {@code listener}
-     * will be notified. The caller must cancel the returned event source when it is no longer
-     * in use.
-     */
-    EventSource newEventSource(Request request, EventSourceListener listener);
-  }
-}
diff --git a/okhttp-sse/src/main/java/okhttp3/sse/EventSourceListener.java b/okhttp-sse/src/main/java/okhttp3/sse/EventSourceListener.java
deleted file mode 100644
index 4246625eca..0000000000
--- a/okhttp-sse/src/main/java/okhttp3/sse/EventSourceListener.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.sse;
-
-import javax.annotation.Nullable;
-import okhttp3.Response;
-
-public abstract class EventSourceListener {
-  /**
-   * Invoked when an event source has been accepted by the remote peer and may begin transmitting
-   * events.
-   */
-  public void onOpen(EventSource eventSource, Response response) {
-  }
-
-  /**
-   * TODO description.
-   */
-  public void onEvent(EventSource eventSource, @Nullable String id, @Nullable String type,
-      String data) {
-  }
-
-  /**
-   * TODO description.
-   * No further calls to this listener will be made.
-   */
-  public void onClosed(EventSource eventSource) {
-  }
-
-  /**
-   * Invoked when an event source has been closed due to an error reading from or writing to the
-   * network. Incoming events may have been lost. No further calls to this listener will be made.
-   */
-  public void onFailure(EventSource eventSource, @Nullable Throwable t,
-      @Nullable Response response) {
-  }
-}
diff --git a/okhttp-sse/src/main/java/okhttp3/sse/EventSources.java b/okhttp-sse/src/main/java/okhttp3/sse/EventSources.java
deleted file mode 100644
index db0c818d54..0000000000
--- a/okhttp-sse/src/main/java/okhttp3/sse/EventSources.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.sse;
-
-import okhttp3.OkHttpClient;
-import okhttp3.Response;
-import okhttp3.internal.sse.RealEventSource;
-
-public final class EventSources {
-  public static EventSource.Factory createFactory(final OkHttpClient client) {
-    return (request, listener) -> {
-      RealEventSource eventSource = new RealEventSource(request, listener);
-      eventSource.connect(client);
-      return eventSource;
-    };
-  }
-
-  public static void processResponse(Response response, EventSourceListener listener) {
-    RealEventSource eventSource = new RealEventSource(response.request(), listener);
-    eventSource.processResponse(response);
-  }
-
-  private EventSources() {
-    throw new AssertionError();
-  }
-}
diff --git a/okhttp-sse/src/main/java/okhttp3/sse/package-info.java b/okhttp-sse/src/main/java/okhttp3/sse/package-info.java
deleted file mode 100644
index 2a5f883883..0000000000
--- a/okhttp-sse/src/main/java/okhttp3/sse/package-info.java
+++ /dev/null
@@ -1,3 +0,0 @@
-/** Support for server-sent events. */
-@okhttp3.internal.annotations.EverythingIsNonNull
-package okhttp3.sse;
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/Event.java b/okhttp-sse/src/test/java/okhttp3/internal/sse/Event.java
deleted file mode 100644
index fade2b978a..0000000000
--- a/okhttp-sse/src/test/java/okhttp3/internal/sse/Event.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.sse;
-
-import java.util.Objects;
-import javax.annotation.Nullable;
-
-final class Event {
-  final @Nullable String id;
-  final @Nullable String type;
-  final String data;
-
-  Event(@Nullable String id, @Nullable String type, String data) {
-    if (data == null) throw new NullPointerException("data == null");
-    this.id = id;
-    this.type = type;
-    this.data = data;
-  }
-
-  @Override public String toString() {
-    return "Event{id='" + id + "', type='" + type + "', data='" + data + "'}";
-  }
-
-  @Override public boolean equals(Object o) {
-    if (this == o) return true;
-    if (!(o instanceof Event)) return false;
-    Event other = (Event) o;
-    return Objects.equals(id, other.id)
-        && Objects.equals(type, other.type)
-        && data.equals(other.data);
-  }
-
-  @Override public int hashCode() {
-    int result = Objects.hashCode(id);
-    result = 31 * result + Objects.hashCode(type);
-    result = 31 * result + data.hashCode();
-    return result;
-  }
-}
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java b/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java
deleted file mode 100644
index 0dbec41be1..0000000000
--- a/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.sse;
-
-import java.util.concurrent.TimeUnit;
-import okhttp3.OkHttpClient;
-import okhttp3.OkHttpClientTestRule;
-import okhttp3.Request;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.sse.EventSource;
-import okhttp3.sse.EventSources;
-import org.junit.After;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public final class EventSourceHttpTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
-
-  private final EventSourceRecorder listener = new EventSourceRecorder();
-  private OkHttpClient client = clientTestRule.client;
-
-  @After public void after() {
-    listener.assertExhausted();
-  }
-
-  @Test public void event() {
-    server.enqueue(new MockResponse().setBody(""
-        + "data: hey\n"
-        + "\n").setHeader("content-type", "text/event-stream"));
-
-    EventSource source = newEventSource();
-
-    assertThat(source.request().url().encodedPath()).isEqualTo("/");
-
-    listener.assertOpen();
-    listener.assertEvent(null, null, "hey");
-    listener.assertClose();
-  }
-
-  @Test public void badContentType() {
-    server.enqueue(new MockResponse().setBody(""
-        + "data: hey\n"
-        + "\n").setHeader("content-type", "text/plain"));
-
-    EventSource source = newEventSource();
-    listener.assertFailure("Invalid content-type: text/plain");
-  }
-
-  @Test public void badResponseCode() {
-    server.enqueue(new MockResponse().setBody(""
-        + "data: hey\n"
-        + "\n").setHeader("content-type", "text/event-stream").setResponseCode(401));
-
-    EventSource source = newEventSource();
-    listener.assertFailure(null);
-  }
-
-  @Test public void fullCallTimeoutDoesNotApplyOnceConnected() throws Exception {
-    client = client.newBuilder()
-        .callTimeout(250, TimeUnit.MILLISECONDS)
-        .build();
-
-    server.enqueue(new MockResponse()
-        .setBodyDelay(500, TimeUnit.MILLISECONDS)
-        .setHeader("content-type", "text/event-stream")
-        .setBody("data: hey\n\n"));
-
-    EventSource source = newEventSource();
-
-    assertThat(source.request().url().encodedPath()).isEqualTo("/");
-
-    listener.assertOpen();
-    listener.assertEvent(null, null, "hey");
-    listener.assertClose();
-  }
-
-  @Test public void fullCallTimeoutAppliesToSetup() throws Exception {
-    client = client.newBuilder()
-        .callTimeout(250, TimeUnit.MILLISECONDS)
-        .build();
-
-    server.enqueue(new MockResponse()
-        .setHeadersDelay(500, TimeUnit.MILLISECONDS)
-        .setHeader("content-type", "text/event-stream")
-        .setBody("data: hey\n\n"));
-
-    newEventSource();
-    listener.assertFailure("timeout");
-  }
-
-  private EventSource newEventSource() {
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    EventSource.Factory factory = EventSources.createFactory(client);
-    return factory.newEventSource(request, listener);
-  }
-}
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceRecorder.java b/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceRecorder.java
deleted file mode 100644
index ffcf8daa97..0000000000
--- a/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceRecorder.java
+++ /dev/null
@@ -1,148 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.sse;
-
-import java.io.IOException;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.LinkedBlockingDeque;
-import javax.annotation.Nullable;
-import okhttp3.sse.EventSource;
-import okhttp3.sse.EventSourceListener;
-import okhttp3.Response;
-import okhttp3.internal.platform.Platform;
-
-import static java.util.concurrent.TimeUnit.SECONDS;
-import static org.assertj.core.api.Assertions.assertThat;
-
-public final class EventSourceRecorder extends EventSourceListener {
-  private final BlockingQueue<Object> events = new LinkedBlockingDeque<>();
-
-  @Override public void onOpen(EventSource eventSource, Response response) {
-    Platform.get().log(Platform.INFO, "[ES] onOpen", null);
-    events.add(new Open(eventSource, response));
-  }
-
-  @Override public void onEvent(EventSource eventSource, @Nullable String id, @Nullable String type,
-      String data) {
-    Platform.get().log(Platform.INFO, "[ES] onEvent", null);
-    events.add(new Event(id, type, data));
-  }
-
-  @Override public void onClosed(EventSource eventSource) {
-    Platform.get().log(Platform.INFO, "[ES] onClosed", null);
-    events.add(new Closed());
-  }
-
-  @Override
-  public void onFailure(EventSource eventSource, @Nullable Throwable t, @Nullable Response response) {
-    Platform.get().log(Platform.INFO, "[ES] onFailure", t);
-    events.add(new Failure(t, response));
-  }
-
-  private Object nextEvent() {
-    try {
-      Object event = events.poll(10, SECONDS);
-      if (event == null) {
-        throw new AssertionError("Timed out waiting for event.");
-      }
-      return event;
-    } catch (InterruptedException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  public void assertExhausted() {
-    assertThat(events.isEmpty()).overridingErrorMessage("Remaining events: " + events).isTrue();
-  }
-
-  public void assertEvent(@Nullable String id, @Nullable String type, String data) {
-    Object actual = nextEvent();
-    assertThat(actual).isEqualTo(new Event(id, type, data));
-  }
-
-  public EventSource assertOpen() {
-    Object event = nextEvent();
-    if (!(event instanceof Open)) {
-      throw new AssertionError("Expected Open but was " + event);
-    }
-    return ((Open) event).eventSource;
-  }
-
-  public void assertClose() {
-    Object event = nextEvent();
-    if (!(event instanceof Closed)) {
-      throw new AssertionError("Expected Open but was " + event);
-    }
-  }
-
-  public void assertFailure(@Nullable String message) {
-    Object event = nextEvent();
-    if (!(event instanceof Failure)) {
-      throw new AssertionError("Expected Failure but was " + event);
-    }
-    if (message != null) {
-      assertThat(((Failure) event).t.getMessage()).isEqualTo(message);
-    } else {
-      assertThat(((Failure) event).t).isNull();
-    }
-  }
-
-  static final class Open {
-    final EventSource eventSource;
-    final Response response;
-
-    Open(EventSource eventSource, Response response) {
-      this.eventSource = eventSource;
-      this.response = response;
-    }
-
-    @Override public String toString() {
-      return "Open[" + response + ']';
-    }
-  }
-
-  static final class Failure {
-    final Throwable t;
-    final Response response;
-    final String responseBody;
-
-    Failure(Throwable t, Response response) {
-      this.t = t;
-      this.response = response;
-      String responseBody = null;
-      if (response != null) {
-        try {
-          responseBody = response.body().string();
-        } catch (IOException ignored) {
-        }
-      }
-      this.responseBody = responseBody;
-    }
-
-    @Override public String toString() {
-      if (response == null) {
-        return "Failure[" + t + "]";
-      }
-      return "Failure[" + response + "]";
-    }
-  }
-
-  static final class Closed {
-    @Override public String toString() {
-      return "Closed[]";
-    }
-  }
-}
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/ServerSentEventIteratorTest.java b/okhttp-sse/src/test/java/okhttp3/internal/sse/ServerSentEventIteratorTest.java
deleted file mode 100644
index 77297370a6..0000000000
--- a/okhttp-sse/src/test/java/okhttp3/internal/sse/ServerSentEventIteratorTest.java
+++ /dev/null
@@ -1,196 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.sse;
-
-import java.io.IOException;
-import java.util.ArrayDeque;
-import java.util.Deque;
-import javax.annotation.Nullable;
-import okio.Buffer;
-import org.junit.After;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public final class ServerSentEventIteratorTest {
-  /** Either {@link Event} or {@link Long} items for events and retry changes, respectively. */
-  private final Deque<Object> callbacks = new ArrayDeque<>();
-
-  @After public void after() {
-    assertThat(callbacks.isEmpty()).overridingErrorMessage("Unconsumed events: " + callbacks).isTrue();
-  }
-  
-  @Test public void multiline() throws IOException {
-    consumeEvents(""
-        + "data: YHOO\n"
-        + "data: +2\n"
-        + "data: 10\n"
-        + "\n");
-    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, "YHOO\n+2\n10"));
-  }
-
-  @Test public void multilineCr() throws IOException {
-    consumeEvents(""
-        + "data: YHOO\r"
-        + "data: +2\r"
-        + "data: 10\r"
-        + "\r");
-    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, "YHOO\n+2\n10"));
-  }
-
-  @Test public void multilineCrLf() throws IOException {
-    consumeEvents(""
-        + "data: YHOO\r\n"
-        + "data: +2\r\n"
-        + "data: 10\r\n"
-        + "\r\n");
-    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, "YHOO\n+2\n10"));
-  }
-
-  @Test public void eventType() throws IOException {
-    consumeEvents(""
-        + "event: add\n"
-        + "data: 73857293\n"
-        + "\n"
-        + "event: remove\n"
-        + "data: 2153\n"
-        + "\n"
-        + "event: add\n"
-        + "data: 113411\n"
-        + "\n");
-    assertThat(callbacks.remove()).isEqualTo(new Event(null, "add", "73857293"));
-    assertThat(callbacks.remove()).isEqualTo(new Event(null, "remove", "2153"));
-    assertThat(callbacks.remove()).isEqualTo(new Event(null, "add", "113411"));
-  }
-
-  @Test public void commentsIgnored() throws IOException {
-    consumeEvents(""
-        + ": test stream\n"
-        + "\n"
-        + "data: first event\n"
-        + "id: 1\n"
-        + "\n");
-    assertThat(callbacks.remove()).isEqualTo(new Event("1", null, "first event"));
-  }
-
-  @Test public void idCleared() throws IOException {
-    consumeEvents(""
-        + "data: first event\n"
-        + "id: 1\n"
-        + "\n"
-        + "data: second event\n"
-        + "id\n"
-        + "\n"
-        + "data: third event\n"
-        + "\n");
-    assertThat(callbacks.remove()).isEqualTo(new Event("1", null, "first event"));
-    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, "second event"));
-    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, "third event"));
-  }
-
-  @Test public void nakedFieldNames() throws IOException {
-    consumeEvents(""
-        + "data\n"
-        + "\n"
-        + "data\n"
-        + "data\n"
-        + "\n"
-        + "data:\n");
-    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, ""));
-    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, "\n"));
-  }
-
-  @Test public void colonSpaceOptional() throws IOException {
-    consumeEvents(""
-        + "data:test\n"
-        + "\n"
-        + "data: test\n"
-        + "\n");
-    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, "test"));
-    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, "test"));
-  }
-
-  @Test public void leadingWhitespace() throws IOException {
-    consumeEvents(""
-        + "data:  test\n"
-        + "\n");
-    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, " test"));
-  }
-
-  @Test public void idReusedAcrossEvents() throws IOException {
-    consumeEvents(""
-        + "data: first event\n"
-        + "id: 1\n"
-        + "\n"
-        + "data: second event\n"
-        + "\n"
-        + "id: 2\n"
-        + "data: third event\n"
-        + "\n");
-    assertThat(callbacks.remove()).isEqualTo(new Event("1", null, "first event"));
-    assertThat(callbacks.remove()).isEqualTo(new Event("1", null, "second event"));
-    assertThat(callbacks.remove()).isEqualTo(new Event("2", null, "third event"));
-  }
-
-  @Test public void idIgnoredFromEmptyEvent() throws IOException {
-    consumeEvents(""
-        + "data: first event\n"
-        + "id: 1\n"
-        + "\n"
-        + "id: 2\n"
-        + "\n"
-        + "data: second event\n"
-        + "\n");
-    assertThat(callbacks.remove()).isEqualTo(new Event("1", null, "first event"));
-    assertThat(callbacks.remove()).isEqualTo(new Event("1", null, "second event"));
-  }
-
-  @Test public void retry() throws IOException {
-    consumeEvents(""
-        + "retry: 22\n"
-        + "\n"
-        + "data: first event\n"
-        + "id: 1\n"
-        + "\n");
-    assertThat(callbacks.remove()).isEqualTo(22L);
-    assertThat(callbacks.remove()).isEqualTo(new Event("1", null, "first event"));
-  }
-
-  @Test public void retryInvalidFormatIgnored() throws IOException {
-    consumeEvents(""
-        + "retry: 22\n"
-        + "\n"
-        + "retry: hey"
-        + "\n");
-    assertThat(callbacks.remove()).isEqualTo(22L);
-  }
-  
-  private void consumeEvents(String source) throws IOException {
-    ServerSentEventReader.Callback callback = new ServerSentEventReader.Callback() {
-      @Override public void onEvent(@Nullable String id, @Nullable String type, String data) {
-        callbacks.add(new Event(id, type, data));
-      }
-      @Override public void onRetryChange(long timeMs) {
-        callbacks.add(timeMs);
-      }
-    };
-    Buffer buffer = new Buffer().writeUtf8(source);
-    ServerSentEventReader reader = new ServerSentEventReader(buffer, callback);
-    while (reader.processNextEvent());
-    assertThat(buffer.size()).overridingErrorMessage("Unconsumed buffer: " + buffer.readUtf8())
-        .isEqualTo(0);
-  }
-}
diff --git a/okhttp-testing-support/pom.xml b/okhttp-testing-support/pom.xml
deleted file mode 100644
index daa5f8198a..0000000000
--- a/okhttp-testing-support/pom.xml
+++ /dev/null
@@ -1,53 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.14.3-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>okhttp-testing-support</artifactId>
-  <name>OkHttp test support classes</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <optional>true</optional>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.google.code.findbugs</groupId>
-      <artifactId>jsr305</artifactId>
-      <scope>provided</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-jar-plugin</artifactId>
-        <version>3.1.1</version>
-        <configuration>
-          <archive>
-            <manifestEntries>
-              <Automatic-Module-Name>okhttp3.testing</Automatic-Module-Name>
-            </manifestEntries>
-          </archive>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java b/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java
deleted file mode 100644
index 82cacacbac..0000000000
--- a/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.util.ArrayList;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public final class FakeDns implements Dns {
-  private final Map<String, List<InetAddress>> hostAddresses = new LinkedHashMap<>();
-  private final List<String> requestedHosts = new ArrayList<>();
-  private int nextAddress = 100;
-
-  /** Sets the results for {@code hostname}. */
-  public FakeDns set(String hostname, List<InetAddress> addresses) {
-    hostAddresses.put(hostname, addresses);
-    return this;
-  }
-
-  /** Clears the results for {@code hostname}. */
-  public FakeDns clear(String hostname) {
-    hostAddresses.remove(hostname);
-    return this;
-  }
-
-  public InetAddress lookup(String hostname, int index) throws UnknownHostException {
-    return hostAddresses.get(hostname).get(index);
-  }
-
-  @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
-    requestedHosts.add(hostname);
-
-    List<InetAddress> result = hostAddresses.get(hostname);
-    if (result != null) return result;
-
-    throw new UnknownHostException();
-  }
-
-  public void assertRequests(String... expectedHosts) {
-    assertThat(requestedHosts).containsExactly(expectedHosts);
-    requestedHosts.clear();
-  }
-
-  /** Allocates and returns {@code count} fake addresses like [255.0.0.100, 255.0.0.101]. */
-  public List<InetAddress> allocate(int count) {
-    try {
-      List<InetAddress> result = new ArrayList<>();
-      for (int i = 0; i < count; i++) {
-        if (nextAddress > 255) {
-          throw new AssertionError("too many addresses allocated");
-        }
-        result.add(InetAddress.getByAddress(
-            new byte[] {(byte) 255, (byte) 0, (byte) 0, (byte) nextAddress++}));
-      }
-      return result;
-    } catch (UnknownHostException e) {
-      throw new AssertionError();
-    }
-  }
-}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/FakeProxySelector.java b/okhttp-testing-support/src/main/java/okhttp3/FakeProxySelector.java
deleted file mode 100644
index c7d37f57ea..0000000000
--- a/okhttp-testing-support/src/main/java/okhttp3/FakeProxySelector.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.net.Proxy;
-import java.net.ProxySelector;
-import java.net.SocketAddress;
-import java.net.URI;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-public final class FakeProxySelector extends ProxySelector {
-  public final List<Proxy> proxies = new ArrayList<>();
-
-  public FakeProxySelector addProxy(Proxy proxy) {
-    proxies.add(proxy);
-    return this;
-  }
-
-  @Override public List<Proxy> select(URI uri) {
-    // Don't handle 'socket' schemes, which the RI's Socket class may request (for SOCKS).
-    return uri.getScheme().equals("http") || uri.getScheme().equals("https") ? proxies
-        : Collections.singletonList(Proxy.NO_PROXY);
-  }
-
-  @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
-  }
-}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/FakeSSLSession.java b/okhttp-testing-support/src/main/java/okhttp3/FakeSSLSession.java
deleted file mode 100644
index ab67a9f06e..0000000000
--- a/okhttp-testing-support/src/main/java/okhttp3/FakeSSLSession.java
+++ /dev/null
@@ -1,120 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements. See the NOTICE file distributed with this
- * work for additional information regarding copyright ownership. The ASF
- * licenses this file to You under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations under
- * the License.
- */
-package okhttp3;
-
-import java.security.Principal;
-import java.security.cert.Certificate;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSession;
-import javax.net.ssl.SSLSessionContext;
-import javax.security.cert.X509Certificate;
-
-public final class FakeSSLSession implements SSLSession {
-  private final Certificate[] certificates;
-
-  public FakeSSLSession(Certificate... certificates) throws Exception {
-    this.certificates = certificates;
-  }
-
-  public int getApplicationBufferSize() {
-    throw new UnsupportedOperationException();
-  }
-
-  public String getCipherSuite() {
-    throw new UnsupportedOperationException();
-  }
-
-  public long getCreationTime() {
-    throw new UnsupportedOperationException();
-  }
-
-  public byte[] getId() {
-    throw new UnsupportedOperationException();
-  }
-
-  public long getLastAccessedTime() {
-    throw new UnsupportedOperationException();
-  }
-
-  public Certificate[] getLocalCertificates() {
-    throw new UnsupportedOperationException();
-  }
-
-  public Principal getLocalPrincipal() {
-    throw new UnsupportedOperationException();
-  }
-
-  public int getPacketBufferSize() {
-    throw new UnsupportedOperationException();
-  }
-
-  public Certificate[] getPeerCertificates() throws SSLPeerUnverifiedException {
-    if (certificates.length == 0) {
-      throw new SSLPeerUnverifiedException("peer not authenticated");
-    } else {
-      return certificates;
-    }
-  }
-
-  public X509Certificate[] getPeerCertificateChain() throws SSLPeerUnverifiedException {
-    throw new UnsupportedOperationException();
-  }
-
-  public String getPeerHost() {
-    throw new UnsupportedOperationException();
-  }
-
-  public int getPeerPort() {
-    throw new UnsupportedOperationException();
-  }
-
-  public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
-    throw new UnsupportedOperationException();
-  }
-
-  public String getProtocol() {
-    throw new UnsupportedOperationException();
-  }
-
-  public SSLSessionContext getSessionContext() {
-    throw new UnsupportedOperationException();
-  }
-
-  public void putValue(String s, Object obj) {
-    throw new UnsupportedOperationException();
-  }
-
-  public void removeValue(String s) {
-    throw new UnsupportedOperationException();
-  }
-
-  public Object getValue(String s) {
-    throw new UnsupportedOperationException();
-  }
-
-  public String[] getValueNames() {
-    throw new UnsupportedOperationException();
-  }
-
-  public void invalidate() {
-    throw new UnsupportedOperationException();
-  }
-
-  public boolean isValid() {
-    throw new UnsupportedOperationException();
-  }
-}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/ForwardingRequestBody.java b/okhttp-testing-support/src/main/java/okhttp3/ForwardingRequestBody.java
deleted file mode 100644
index 4aa144c6be..0000000000
--- a/okhttp-testing-support/src/main/java/okhttp3/ForwardingRequestBody.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import javax.annotation.Nullable;
-import okio.BufferedSink;
-
-public class ForwardingRequestBody extends RequestBody {
-  private final RequestBody delegate;
-
-  public ForwardingRequestBody(RequestBody delegate) {
-    if (delegate == null) throw new IllegalArgumentException("delegate == null");
-    this.delegate = delegate;
-  }
-
-  public final RequestBody delegate() {
-    return delegate;
-  }
-
-  @Override public @Nullable MediaType contentType() {
-    return delegate.contentType();
-  }
-
-  @Override public long contentLength() throws IOException {
-    return delegate.contentLength();
-  }
-
-  @Override public void writeTo(BufferedSink sink) throws IOException {
-    delegate.writeTo(sink);
-  }
-
-  @Override public boolean isDuplex() {
-    return delegate.isDuplex();
-  }
-
-  @Override public String toString() {
-    return getClass().getSimpleName() + "(" + delegate.toString() + ")";
-  }
-}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/ForwardingResponseBody.java b/okhttp-testing-support/src/main/java/okhttp3/ForwardingResponseBody.java
deleted file mode 100644
index 2cc067ac0c..0000000000
--- a/okhttp-testing-support/src/main/java/okhttp3/ForwardingResponseBody.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import javax.annotation.Nullable;
-import okio.BufferedSource;
-
-public class ForwardingResponseBody extends ResponseBody {
-  private final ResponseBody delegate;
-
-  public ForwardingResponseBody(ResponseBody delegate) {
-    if (delegate == null) throw new IllegalArgumentException("delegate == null");
-    this.delegate = delegate;
-  }
-
-  public final ResponseBody delegate() {
-    return delegate;
-  }
-
-  @Override public @Nullable MediaType contentType() {
-    return delegate.contentType();
-  }
-
-  @Override public long contentLength() {
-    return delegate.contentLength();
-  }
-
-  @Override public BufferedSource source() {
-    return delegate.source();
-  }
-
-  @Override public String toString() {
-    return getClass().getSimpleName() + "(" + delegate.toString() + ")";
-  }
-}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/OkHttpClientTestRule.java b/okhttp-testing-support/src/main/java/okhttp3/OkHttpClientTestRule.java
deleted file mode 100644
index c447117e81..0000000000
--- a/okhttp-testing-support/src/main/java/okhttp3/OkHttpClientTestRule.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import org.junit.rules.TestRule;
-import org.junit.runner.Description;
-import org.junit.runners.model.Statement;
-
-import static okhttp3.TestUtil.defaultClient;
-
-public class OkHttpClientTestRule implements TestRule {
-  public OkHttpClient client = defaultClient();
-
-  @Override
-  public Statement apply(Statement base, Description description) {
-    return statement(base);
-  }
-
-  private Statement statement(final Statement base) {
-    return new Statement() {
-      public void evaluate() throws Throwable {
-        try {
-          base.evaluate();
-        } finally {
-          TestUtil.ensureAllConnectionsReleased(client);
-        }
-      }
-    };
-  }
-}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/RecordingCookieJar.java b/okhttp-testing-support/src/main/java/okhttp3/RecordingCookieJar.java
deleted file mode 100644
index a4988b8e34..0000000000
--- a/okhttp-testing-support/src/main/java/okhttp3/RecordingCookieJar.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.util.ArrayDeque;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Deque;
-import java.util.List;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public final class RecordingCookieJar implements CookieJar {
-  private final Deque<List<Cookie>> requestCookies = new ArrayDeque<>();
-  private final Deque<List<Cookie>> responseCookies = new ArrayDeque<>();
-
-  public void enqueueRequestCookies(Cookie... cookies) {
-    requestCookies.add(Arrays.asList(cookies));
-  }
-
-  public List<Cookie> takeResponseCookies() {
-    return responseCookies.removeFirst();
-  }
-
-  public void assertResponseCookies(String... cookies) {
-    List<Cookie> actualCookies = takeResponseCookies();
-    List<String> actualCookieStrings = new ArrayList<>();
-    for (Cookie cookie : actualCookies) {
-      actualCookieStrings.add(cookie.toString());
-    }
-    assertThat(actualCookieStrings).containsExactly(cookies);
-  }
-
-  @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {
-    responseCookies.add(cookies);
-  }
-
-  @Override public List<Cookie> loadForRequest(HttpUrl url) {
-    if (requestCookies.isEmpty()) return Collections.emptyList();
-    return requestCookies.removeFirst();
-  }
-}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/RecordingHostnameVerifier.java b/okhttp-testing-support/src/main/java/okhttp3/RecordingHostnameVerifier.java
deleted file mode 100644
index 568b7c518c..0000000000
--- a/okhttp-testing-support/src/main/java/okhttp3/RecordingHostnameVerifier.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.util.ArrayList;
-import java.util.List;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLSession;
-
-public final class RecordingHostnameVerifier implements HostnameVerifier {
-  public final List<String> calls = new ArrayList<>();
-
-  public boolean verify(String hostname, SSLSession session) {
-    calls.add("verify " + hostname);
-    return true;
-  }
-}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/TestUtil.java b/okhttp-testing-support/src/main/java/okhttp3/TestUtil.java
deleted file mode 100644
index f3038c090a..0000000000
--- a/okhttp-testing-support/src/main/java/okhttp3/TestUtil.java
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-import okhttp3.internal.http2.Header;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public final class TestUtil {
-  public static final InetSocketAddress UNREACHABLE_ADDRESS
-      = new InetSocketAddress("198.51.100.1", 8080);
-
-  /**
-   * A network that resolves only one IP address per host. Use this when testing route selection
-   * fallbacks to prevent the host machine's various IP addresses from interfering.
-   */
-  private static final Dns SINGLE_INET_ADDRESS_DNS = hostname -> {
-    List<InetAddress> addresses = Dns.SYSTEM.lookup(hostname);
-    return Collections.singletonList(addresses.get(0));
-  };
-
-  private TestUtil() {
-  }
-
-  private static final ConnectionPool connectionPool = new ConnectionPool();
-  private static final Dispatcher dispatcher = new Dispatcher();
-
-  /**
-   * Returns an OkHttpClient for all tests to use as a starting point.
-   *
-   * <p>The shared instance allows all tests to share a single connection pool, which prevents idle
-   * connections from consuming unnecessary resources while connections wait to be evicted.
-   *
-   * <p>This client is also configured to be slightly more deterministic, returning a single IP
-   * address for all hosts, regardless of the actual number of IP addresses reported by DNS.
-   */
-  public static OkHttpClient defaultClient() {
-    return new OkHttpClient.Builder()
-        .connectionPool(connectionPool)
-        .dispatcher(dispatcher)
-        .dns(SINGLE_INET_ADDRESS_DNS) // Prevent unexpected fallback addresses.
-        .build();
-  }
-
-  public static List<Header> headerEntries(String... elements) {
-    List<Header> result = new ArrayList<>(elements.length / 2);
-    for (int i = 0; i < elements.length; i += 2) {
-      result.add(new Header(elements[i], elements[i + 1]));
-    }
-    return result;
-  }
-
-  public static String repeat(char c, int count) {
-    char[] array = new char[count];
-    Arrays.fill(array, c);
-    return new String(array);
-  }
-
-  /**
-   * See FinalizationTester for discussion on how to best trigger GC in tests.
-   * https://android.googlesource.com/platform/libcore/+/master/support/src/test/java/libcore/
-   * java/lang/ref/FinalizationTester.java
-   */
-  public static void awaitGarbageCollection() throws Exception {
-    Runtime.getRuntime().gc();
-    Thread.sleep(100);
-    System.runFinalization();
-  }
-
-  public static void ensureAllConnectionsReleased(OkHttpClient client) {
-    client.connectionPool().evictAll();
-    assertThat(client.connectionPool().idleConnectionCount()).isEqualTo(0);
-  }
-}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/UppercaseRequestInterceptor.java b/okhttp-testing-support/src/main/java/okhttp3/UppercaseRequestInterceptor.java
deleted file mode 100644
index 490c266116..0000000000
--- a/okhttp-testing-support/src/main/java/okhttp3/UppercaseRequestInterceptor.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.ByteString;
-import okio.ForwardingSink;
-import okio.Okio;
-import okio.Sink;
-
-/** Rewrites the request body sent to the server to be all uppercase. */
-public final class UppercaseRequestInterceptor implements Interceptor {
-  @Override public Response intercept(Chain chain) throws IOException {
-    return chain.proceed(uppercaseRequest(chain.request()));
-  }
-
-  /** Returns a request that transforms {@code request} to be all uppercase. */
-  private Request uppercaseRequest(Request request) {
-    RequestBody uppercaseBody = new ForwardingRequestBody(request.body()) {
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        delegate().writeTo(Okio.buffer(uppercaseSink(sink)));
-      }
-    };
-    return request.newBuilder()
-        .method(request.method(), uppercaseBody)
-        .build();
-  }
-
-  private Sink uppercaseSink(Sink sink) {
-    return new ForwardingSink(sink) {
-      @Override public void write(Buffer source, long byteCount) throws IOException {
-        ByteString bytes = source.readByteString(byteCount);
-        delegate().write(new Buffer().write(bytes.toAsciiUppercase()), byteCount);
-      }
-    };
-  }
-}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/UppercaseResponseInterceptor.java b/okhttp-testing-support/src/main/java/okhttp3/UppercaseResponseInterceptor.java
deleted file mode 100644
index 7fbf8ef479..0000000000
--- a/okhttp-testing-support/src/main/java/okhttp3/UppercaseResponseInterceptor.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import okio.Buffer;
-import okio.BufferedSource;
-import okio.ForwardingSource;
-import okio.Okio;
-
-/** Rewrites the response body returned from the server to be all uppercase. */
-public final class UppercaseResponseInterceptor implements Interceptor {
-  @Override public Response intercept(Chain chain) throws IOException {
-    return uppercaseResponse(chain.proceed(chain.request()));
-  }
-
-  private Response uppercaseResponse(Response response) {
-    ResponseBody uppercaseBody = new ForwardingResponseBody(response.body()) {
-      @Override public BufferedSource source() {
-        return Okio.buffer(uppercaseSource(delegate().source()));
-      }
-    };
-    return response.newBuilder()
-        .body(uppercaseBody)
-        .build();
-  }
-
-  private ForwardingSource uppercaseSource(BufferedSource source) {
-    return new ForwardingSource(source) {
-      @Override public long read(Buffer sink, long byteCount) throws IOException {
-        Buffer buffer = new Buffer();
-        long read = delegate().read(buffer, byteCount);
-        if (read != -1L) sink.write(buffer.readByteString().toAsciiUppercase());
-        return read;
-      }
-    };
-  }
-}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/internal/duplex/AsyncRequestBody.java b/okhttp-testing-support/src/main/java/okhttp3/internal/duplex/AsyncRequestBody.java
deleted file mode 100644
index a6b554adcb..0000000000
--- a/okhttp-testing-support/src/main/java/okhttp3/internal/duplex/AsyncRequestBody.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.duplex;
-
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.TimeUnit;
-import javax.annotation.Nullable;
-import okhttp3.MediaType;
-import okhttp3.RequestBody;
-import okio.BufferedSink;
-
-import static junit.framework.TestCase.assertTrue;
-
-/** A duplex request body that keeps the provided sinks so they can be written to later. */
-public final class AsyncRequestBody extends RequestBody {
-  private final BlockingQueue<BufferedSink> requestBodySinks = new LinkedBlockingQueue<>();
-
-  @Override public @Nullable MediaType contentType() {
-    return null;
-  }
-
-  @Override public void writeTo(BufferedSink sink) {
-    requestBodySinks.add(sink);
-  }
-
-  @Override public boolean isDuplex() {
-    return true;
-  }
-
-  public BufferedSink takeSink() throws InterruptedException {
-    BufferedSink result = requestBodySinks.poll(5, TimeUnit.SECONDS);
-    if (result == null) throw new AssertionError("no sink to take");
-    return result;
-  }
-
-  public void assertNoMoreSinks() {
-    assertTrue(requestBodySinks.isEmpty());
-  }
-}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/internal/io/InMemoryFileSystem.java b/okhttp-testing-support/src/main/java/okhttp3/internal/io/InMemoryFileSystem.java
deleted file mode 100644
index bb6f519092..0000000000
--- a/okhttp-testing-support/src/main/java/okhttp3/internal/io/InMemoryFileSystem.java
+++ /dev/null
@@ -1,138 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.io;
-
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.IdentityHashMap;
-import java.util.Iterator;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import okio.Buffer;
-import okio.ForwardingSink;
-import okio.ForwardingSource;
-import okio.Sink;
-import okio.Source;
-import org.junit.rules.TestRule;
-import org.junit.runner.Description;
-import org.junit.runners.model.Statement;
-
-/** A simple file system where all files are held in memory. Not safe for concurrent use. */
-public final class InMemoryFileSystem implements FileSystem, TestRule {
-  private final Map<File, Buffer> files = new LinkedHashMap<>();
-  private final Map<Source, File> openSources = new IdentityHashMap<>();
-  private final Map<Sink, File> openSinks = new IdentityHashMap<>();
-
-  @Override public Statement apply(final Statement base, Description description) {
-    return new Statement() {
-      @Override public void evaluate() throws Throwable {
-        base.evaluate();
-        ensureResourcesClosed();
-      }
-    };
-  }
-
-  public void ensureResourcesClosed() {
-    List<String> openResources = new ArrayList<>();
-    for (File file : openSources.values()) {
-      openResources.add("Source for " + file);
-    }
-    for (File file : openSinks.values()) {
-      openResources.add("Sink for " + file);
-    }
-    if (!openResources.isEmpty()) {
-      StringBuilder builder = new StringBuilder("Resources acquired but not closed:");
-      for (String resource : openResources) {
-        builder.append("\n * ").append(resource);
-      }
-      throw new IllegalStateException(builder.toString());
-    }
-  }
-
-  @Override public Source source(File file) throws FileNotFoundException {
-    Buffer result = files.get(file);
-    if (result == null) throw new FileNotFoundException();
-
-    final Source source = result.clone();
-    openSources.put(source, file);
-
-    return new ForwardingSource(source) {
-      @Override public void close() throws IOException {
-        openSources.remove(source);
-        super.close();
-      }
-    };
-  }
-
-  @Override public Sink sink(File file) throws FileNotFoundException {
-    return sink(file, false);
-  }
-
-  @Override public Sink appendingSink(File file) throws FileNotFoundException {
-    return sink(file, true);
-  }
-
-  private Sink sink(File file, boolean appending) {
-    Buffer result = null;
-    if (appending) {
-      result = files.get(file);
-    }
-    if (result == null) {
-      result = new Buffer();
-    }
-    files.put(file, result);
-
-    final Sink sink = result;
-    openSinks.put(sink, file);
-
-    return new ForwardingSink(sink) {
-      @Override public void close() throws IOException {
-        openSinks.remove(sink);
-        super.close();
-      }
-    };
-  }
-
-  @Override public void delete(File file) throws IOException {
-    files.remove(file);
-  }
-
-  @Override public boolean exists(File file) {
-    return files.containsKey(file);
-  }
-
-  @Override public long size(File file) {
-    Buffer buffer = files.get(file);
-    return buffer != null ? buffer.size() : 0L;
-  }
-
-  @Override public void rename(File from, File to) throws IOException {
-    Buffer buffer = files.remove(from);
-    if (buffer == null) throw new FileNotFoundException();
-    files.put(to, buffer);
-  }
-
-  @Override public void deleteContents(File directory) throws IOException {
-    String prefix = directory.toString() + "/";
-    for (Iterator<File> i = files.keySet().iterator(); i.hasNext(); ) {
-      File file = i.next();
-      if (file.toString().startsWith(prefix)) i.remove();
-    }
-  }
-}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/testing/InstallUncaughtExceptionHandlerListener.java b/okhttp-testing-support/src/main/java/okhttp3/testing/InstallUncaughtExceptionHandlerListener.java
deleted file mode 100644
index c1768dcd4b..0000000000
--- a/okhttp-testing-support/src/main/java/okhttp3/testing/InstallUncaughtExceptionHandlerListener.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.testing;
-
-import java.io.PrintWriter;
-import java.io.StringWriter;
-import java.util.LinkedHashMap;
-import java.util.Map;
-import org.junit.internal.Throwables;
-import org.junit.runner.Description;
-import org.junit.runner.Result;
-import org.junit.runner.notification.RunListener;
-
-/**
- * A {@link org.junit.runner.notification.RunListener} used to install an aggressive default {@link
- * java.lang.Thread.UncaughtExceptionHandler} similar to the one found on Android. No exceptions
- * should escape from OkHttp that might cause apps to be killed or tests to fail on Android.
- */
-public class InstallUncaughtExceptionHandlerListener extends RunListener {
-
-  private Thread.UncaughtExceptionHandler oldDefaultUncaughtExceptionHandler;
-  private Description lastTestStarted;
-  private final Map<Throwable, String> exceptions = new LinkedHashMap<>();
-
-  @Override public void testRunStarted(Description description) {
-    System.err.println("Installing aggressive uncaught exception handler");
-    oldDefaultUncaughtExceptionHandler = Thread.getDefaultUncaughtExceptionHandler();
-    Thread.setDefaultUncaughtExceptionHandler((thread, throwable) -> {
-      StringWriter errorText = new StringWriter(256);
-      errorText.append("Uncaught exception in OkHttp thread \"");
-      errorText.append(thread.getName());
-      errorText.append("\"\n");
-      throwable.printStackTrace(new PrintWriter(errorText));
-      errorText.append("\n");
-      if (lastTestStarted != null) {
-        errorText.append("Last test to start was: ");
-        errorText.append(lastTestStarted.getDisplayName());
-        errorText.append("\n");
-      }
-      System.err.print(errorText.toString());
-
-      synchronized (exceptions) {
-        exceptions.put(throwable, lastTestStarted.getDisplayName());
-      }
-    });
-  }
-
-  @Override public void testStarted(Description description) {
-    lastTestStarted = description;
-  }
-
-  @Override public void testRunFinished(Result result) throws Exception {
-    Thread.setDefaultUncaughtExceptionHandler(oldDefaultUncaughtExceptionHandler);
-    System.err.println("Uninstalled aggressive uncaught exception handler");
-
-    synchronized (exceptions) {
-      if (!exceptions.isEmpty()) {
-        throw Throwables.rethrowAsException(exceptions.keySet().iterator().next());
-      }
-    }
-  }
-}
diff --git a/okhttp-tests/fuzzingserver-config.json b/okhttp-tests/fuzzingserver-config.json
deleted file mode 100644
index f9a3e1f597..0000000000
--- a/okhttp-tests/fuzzingserver-config.json
+++ /dev/null
@@ -1,153 +0,0 @@
-{
-  "url": "ws://127.0.0.1:9099",
-  "outdir": "./target/fuzzingserver-report",
-  "cases": ["*"],
-  "exclude-cases": [
-    "6.1.1",
-    "6.1.2",
-    "6.1.3",
-    "6.2.1",
-    "6.2.2",
-    "6.2.3",
-    "6.2.4",
-    "6.3.1",
-    "6.3.2",
-    "6.4.1",
-    "6.4.2",
-    "6.4.3",
-    "6.4.4",
-    "6.5.1",
-    "6.5.2",
-    "6.5.3",
-    "6.5.4",
-    "6.5.5",
-    "6.6.1",
-    "6.6.2",
-    "6.6.3",
-    "6.6.4",
-    "6.6.5",
-    "6.6.6",
-    "6.6.7",
-    "6.6.8",
-    "6.6.9",
-    "6.6.10",
-    "6.6.11",
-    "6.7.1",
-    "6.7.2",
-    "6.7.3",
-    "6.7.4",
-    "6.8.1",
-    "6.8.2",
-    "6.9.1",
-    "6.9.2",
-    "6.9.3",
-    "6.9.4",
-    "6.10.1",
-    "6.10.2",
-    "6.10.3",
-    "6.11.1",
-    "6.11.2",
-    "6.11.3",
-    "6.11.4",
-    "6.11.5",
-    "6.12.1",
-    "6.12.2",
-    "6.12.3",
-    "6.12.4",
-    "6.12.5",
-    "6.12.6",
-    "6.12.7",
-    "6.12.8",
-    "6.13.1",
-    "6.13.2",
-    "6.13.3",
-    "6.13.4",
-    "6.13.5",
-    "6.14.1",
-    "6.14.2",
-    "6.14.3",
-    "6.14.4",
-    "6.14.5",
-    "6.14.6",
-    "6.14.7",
-    "6.14.8",
-    "6.14.9",
-    "6.14.10",
-    "6.15.1",
-    "6.16.1",
-    "6.16.2",
-    "6.16.3",
-    "6.17.1",
-    "6.17.2",
-    "6.17.3",
-    "6.17.4",
-    "6.17.5",
-    "6.18.1",
-    "6.18.2",
-    "6.18.3",
-    "6.18.4",
-    "6.18.5",
-    "6.19.1",
-    "6.19.2",
-    "6.19.3",
-    "6.19.4",
-    "6.19.5",
-    "6.20.1",
-    "6.20.2",
-    "6.20.3",
-    "6.20.4",
-    "6.20.5",
-    "6.20.6",
-    "6.20.7",
-    "6.21.1",
-    "6.21.2",
-    "6.21.3",
-    "6.21.4",
-    "6.21.5",
-    "6.21.6",
-    "6.21.7",
-    "6.21.8",
-    "6.22.1",
-    "6.22.2",
-    "6.22.3",
-    "6.22.4",
-    "6.22.5",
-    "6.22.6",
-    "6.22.7",
-    "6.22.8",
-    "6.22.9",
-    "6.22.10",
-    "6.22.11",
-    "6.22.12",
-    "6.22.13",
-    "6.22.14",
-    "6.22.15",
-    "6.22.16",
-    "6.22.17",
-    "6.22.18",
-    "6.22.19",
-    "6.22.20",
-    "6.22.21",
-    "6.22.22",
-    "6.22.23",
-    "6.22.24",
-    "6.22.25",
-    "6.22.26",
-    "6.22.27",
-    "6.22.28",
-    "6.22.29",
-    "6.22.30",
-    "6.22.31",
-    "6.22.32",
-    "6.22.33",
-    "6.22.34",
-    "6.23.1",
-    "6.23.2",
-    "6.23.3",
-    "6.23.4",
-    "6.23.5",
-    "6.23.6",
-    "6.23.7"
-  ],
-  "exclude-agent-cases": {}
-}
diff --git a/okhttp-tests/fuzzingserver-expected.txt b/okhttp-tests/fuzzingserver-expected.txt
deleted file mode 100644
index f0f6ed0bbd..0000000000
--- a/okhttp-tests/fuzzingserver-expected.txt
+++ /dev/null
@@ -1,376 +0,0 @@
-"1.1.1 OK"
-"1.1.2 OK"
-"1.1.3 OK"
-"1.1.4 OK"
-"1.1.5 OK"
-"1.1.6 OK"
-"1.1.7 OK"
-"1.1.8 OK"
-"1.2.1 OK"
-"1.2.2 OK"
-"1.2.3 OK"
-"1.2.4 OK"
-"1.2.5 OK"
-"1.2.6 OK"
-"1.2.7 OK"
-"1.2.8 OK"
-"10.1.1 OK"
-"12.1.1 UNIMPLEMENTED"
-"12.1.10 UNIMPLEMENTED"
-"12.1.11 UNIMPLEMENTED"
-"12.1.12 UNIMPLEMENTED"
-"12.1.13 UNIMPLEMENTED"
-"12.1.14 UNIMPLEMENTED"
-"12.1.15 UNIMPLEMENTED"
-"12.1.16 UNIMPLEMENTED"
-"12.1.17 UNIMPLEMENTED"
-"12.1.18 UNIMPLEMENTED"
-"12.1.2 UNIMPLEMENTED"
-"12.1.3 UNIMPLEMENTED"
-"12.1.4 UNIMPLEMENTED"
-"12.1.5 UNIMPLEMENTED"
-"12.1.6 UNIMPLEMENTED"
-"12.1.7 UNIMPLEMENTED"
-"12.1.8 UNIMPLEMENTED"
-"12.1.9 UNIMPLEMENTED"
-"12.2.1 UNIMPLEMENTED"
-"12.2.10 UNIMPLEMENTED"
-"12.2.11 UNIMPLEMENTED"
-"12.2.12 UNIMPLEMENTED"
-"12.2.13 UNIMPLEMENTED"
-"12.2.14 UNIMPLEMENTED"
-"12.2.15 UNIMPLEMENTED"
-"12.2.16 UNIMPLEMENTED"
-"12.2.17 UNIMPLEMENTED"
-"12.2.18 UNIMPLEMENTED"
-"12.2.2 UNIMPLEMENTED"
-"12.2.3 UNIMPLEMENTED"
-"12.2.4 UNIMPLEMENTED"
-"12.2.5 UNIMPLEMENTED"
-"12.2.6 UNIMPLEMENTED"
-"12.2.7 UNIMPLEMENTED"
-"12.2.8 UNIMPLEMENTED"
-"12.2.9 UNIMPLEMENTED"
-"12.3.1 UNIMPLEMENTED"
-"12.3.10 UNIMPLEMENTED"
-"12.3.11 UNIMPLEMENTED"
-"12.3.12 UNIMPLEMENTED"
-"12.3.13 UNIMPLEMENTED"
-"12.3.14 UNIMPLEMENTED"
-"12.3.15 UNIMPLEMENTED"
-"12.3.16 UNIMPLEMENTED"
-"12.3.17 UNIMPLEMENTED"
-"12.3.18 UNIMPLEMENTED"
-"12.3.2 UNIMPLEMENTED"
-"12.3.3 UNIMPLEMENTED"
-"12.3.4 UNIMPLEMENTED"
-"12.3.5 UNIMPLEMENTED"
-"12.3.6 UNIMPLEMENTED"
-"12.3.7 UNIMPLEMENTED"
-"12.3.8 UNIMPLEMENTED"
-"12.3.9 UNIMPLEMENTED"
-"12.4.1 UNIMPLEMENTED"
-"12.4.10 UNIMPLEMENTED"
-"12.4.11 UNIMPLEMENTED"
-"12.4.12 UNIMPLEMENTED"
-"12.4.13 UNIMPLEMENTED"
-"12.4.14 UNIMPLEMENTED"
-"12.4.15 UNIMPLEMENTED"
-"12.4.16 UNIMPLEMENTED"
-"12.4.17 UNIMPLEMENTED"
-"12.4.18 UNIMPLEMENTED"
-"12.4.2 UNIMPLEMENTED"
-"12.4.3 UNIMPLEMENTED"
-"12.4.4 UNIMPLEMENTED"
-"12.4.5 UNIMPLEMENTED"
-"12.4.6 UNIMPLEMENTED"
-"12.4.7 UNIMPLEMENTED"
-"12.4.8 UNIMPLEMENTED"
-"12.4.9 UNIMPLEMENTED"
-"12.5.1 UNIMPLEMENTED"
-"12.5.10 UNIMPLEMENTED"
-"12.5.11 UNIMPLEMENTED"
-"12.5.12 UNIMPLEMENTED"
-"12.5.13 UNIMPLEMENTED"
-"12.5.14 UNIMPLEMENTED"
-"12.5.15 UNIMPLEMENTED"
-"12.5.16 UNIMPLEMENTED"
-"12.5.17 UNIMPLEMENTED"
-"12.5.18 UNIMPLEMENTED"
-"12.5.2 UNIMPLEMENTED"
-"12.5.3 UNIMPLEMENTED"
-"12.5.4 UNIMPLEMENTED"
-"12.5.5 UNIMPLEMENTED"
-"12.5.6 UNIMPLEMENTED"
-"12.5.7 UNIMPLEMENTED"
-"12.5.8 UNIMPLEMENTED"
-"12.5.9 UNIMPLEMENTED"
-"13.1.1 UNIMPLEMENTED"
-"13.1.10 UNIMPLEMENTED"
-"13.1.11 UNIMPLEMENTED"
-"13.1.12 UNIMPLEMENTED"
-"13.1.13 UNIMPLEMENTED"
-"13.1.14 UNIMPLEMENTED"
-"13.1.15 UNIMPLEMENTED"
-"13.1.16 UNIMPLEMENTED"
-"13.1.17 UNIMPLEMENTED"
-"13.1.18 UNIMPLEMENTED"
-"13.1.2 UNIMPLEMENTED"
-"13.1.3 UNIMPLEMENTED"
-"13.1.4 UNIMPLEMENTED"
-"13.1.5 UNIMPLEMENTED"
-"13.1.6 UNIMPLEMENTED"
-"13.1.7 UNIMPLEMENTED"
-"13.1.8 UNIMPLEMENTED"
-"13.1.9 UNIMPLEMENTED"
-"13.2.1 UNIMPLEMENTED"
-"13.2.10 UNIMPLEMENTED"
-"13.2.11 UNIMPLEMENTED"
-"13.2.12 UNIMPLEMENTED"
-"13.2.13 UNIMPLEMENTED"
-"13.2.14 UNIMPLEMENTED"
-"13.2.15 UNIMPLEMENTED"
-"13.2.16 UNIMPLEMENTED"
-"13.2.17 UNIMPLEMENTED"
-"13.2.18 UNIMPLEMENTED"
-"13.2.2 UNIMPLEMENTED"
-"13.2.3 UNIMPLEMENTED"
-"13.2.4 UNIMPLEMENTED"
-"13.2.5 UNIMPLEMENTED"
-"13.2.6 UNIMPLEMENTED"
-"13.2.7 UNIMPLEMENTED"
-"13.2.8 UNIMPLEMENTED"
-"13.2.9 UNIMPLEMENTED"
-"13.3.1 UNIMPLEMENTED"
-"13.3.10 UNIMPLEMENTED"
-"13.3.11 UNIMPLEMENTED"
-"13.3.12 UNIMPLEMENTED"
-"13.3.13 UNIMPLEMENTED"
-"13.3.14 UNIMPLEMENTED"
-"13.3.15 UNIMPLEMENTED"
-"13.3.16 UNIMPLEMENTED"
-"13.3.17 UNIMPLEMENTED"
-"13.3.18 UNIMPLEMENTED"
-"13.3.2 UNIMPLEMENTED"
-"13.3.3 UNIMPLEMENTED"
-"13.3.4 UNIMPLEMENTED"
-"13.3.5 UNIMPLEMENTED"
-"13.3.6 UNIMPLEMENTED"
-"13.3.7 UNIMPLEMENTED"
-"13.3.8 UNIMPLEMENTED"
-"13.3.9 UNIMPLEMENTED"
-"13.4.1 UNIMPLEMENTED"
-"13.4.10 UNIMPLEMENTED"
-"13.4.11 UNIMPLEMENTED"
-"13.4.12 UNIMPLEMENTED"
-"13.4.13 UNIMPLEMENTED"
-"13.4.14 UNIMPLEMENTED"
-"13.4.15 UNIMPLEMENTED"
-"13.4.16 UNIMPLEMENTED"
-"13.4.17 UNIMPLEMENTED"
-"13.4.18 UNIMPLEMENTED"
-"13.4.2 UNIMPLEMENTED"
-"13.4.3 UNIMPLEMENTED"
-"13.4.4 UNIMPLEMENTED"
-"13.4.5 UNIMPLEMENTED"
-"13.4.6 UNIMPLEMENTED"
-"13.4.7 UNIMPLEMENTED"
-"13.4.8 UNIMPLEMENTED"
-"13.4.9 UNIMPLEMENTED"
-"13.5.1 UNIMPLEMENTED"
-"13.5.10 UNIMPLEMENTED"
-"13.5.11 UNIMPLEMENTED"
-"13.5.12 UNIMPLEMENTED"
-"13.5.13 UNIMPLEMENTED"
-"13.5.14 UNIMPLEMENTED"
-"13.5.15 UNIMPLEMENTED"
-"13.5.16 UNIMPLEMENTED"
-"13.5.17 UNIMPLEMENTED"
-"13.5.18 UNIMPLEMENTED"
-"13.5.2 UNIMPLEMENTED"
-"13.5.3 UNIMPLEMENTED"
-"13.5.4 UNIMPLEMENTED"
-"13.5.5 UNIMPLEMENTED"
-"13.5.6 UNIMPLEMENTED"
-"13.5.7 UNIMPLEMENTED"
-"13.5.8 UNIMPLEMENTED"
-"13.5.9 UNIMPLEMENTED"
-"13.6.1 UNIMPLEMENTED"
-"13.6.10 UNIMPLEMENTED"
-"13.6.11 UNIMPLEMENTED"
-"13.6.12 UNIMPLEMENTED"
-"13.6.13 UNIMPLEMENTED"
-"13.6.14 UNIMPLEMENTED"
-"13.6.15 UNIMPLEMENTED"
-"13.6.16 UNIMPLEMENTED"
-"13.6.17 UNIMPLEMENTED"
-"13.6.18 UNIMPLEMENTED"
-"13.6.2 UNIMPLEMENTED"
-"13.6.3 UNIMPLEMENTED"
-"13.6.4 UNIMPLEMENTED"
-"13.6.5 UNIMPLEMENTED"
-"13.6.6 UNIMPLEMENTED"
-"13.6.7 UNIMPLEMENTED"
-"13.6.8 UNIMPLEMENTED"
-"13.6.9 UNIMPLEMENTED"
-"13.7.1 UNIMPLEMENTED"
-"13.7.10 UNIMPLEMENTED"
-"13.7.11 UNIMPLEMENTED"
-"13.7.12 UNIMPLEMENTED"
-"13.7.13 UNIMPLEMENTED"
-"13.7.14 UNIMPLEMENTED"
-"13.7.15 UNIMPLEMENTED"
-"13.7.16 UNIMPLEMENTED"
-"13.7.17 UNIMPLEMENTED"
-"13.7.18 UNIMPLEMENTED"
-"13.7.2 UNIMPLEMENTED"
-"13.7.3 UNIMPLEMENTED"
-"13.7.4 UNIMPLEMENTED"
-"13.7.5 UNIMPLEMENTED"
-"13.7.6 UNIMPLEMENTED"
-"13.7.7 UNIMPLEMENTED"
-"13.7.8 UNIMPLEMENTED"
-"13.7.9 UNIMPLEMENTED"
-"2.1 OK"
-"2.10 OK"
-"2.11 OK"
-"2.2 OK"
-"2.3 OK"
-"2.4 OK"
-"2.5 OK"
-"2.6 OK"
-"2.7 OK"
-"2.8 OK"
-"2.9 OK"
-"3.1 OK"
-"3.2 NON-STRICT"
-"3.3 NON-STRICT"
-"3.4 NON-STRICT"
-"3.5 OK"
-"3.6 OK"
-"3.7 OK"
-"4.1.1 OK"
-"4.1.2 OK"
-"4.1.3 NON-STRICT"
-"4.1.4 NON-STRICT"
-"4.1.5 OK"
-"4.2.1 OK"
-"4.2.2 OK"
-"4.2.3 NON-STRICT"
-"4.2.4 OK"
-"4.2.5 OK"
-"5.1 OK"
-"5.10 OK"
-"5.11 OK"
-"5.12 OK"
-"5.13 OK"
-"5.14 OK"
-"5.15 OK"
-"5.16 OK"
-"5.17 OK"
-"5.18 OK"
-"5.19 OK"
-"5.2 OK"
-"5.20 OK"
-"5.3 OK"
-"5.4 OK"
-"5.5 OK"
-"5.6 OK"
-"5.7 OK"
-"5.8 OK"
-"5.9 OK"
-"7.1.1 OK"
-"7.1.2 OK"
-"7.1.3 OK"
-"7.1.4 OK"
-"7.1.5 OK"
-"7.1.6 INFORMATIONAL"
-"7.13.1 INFORMATIONAL"
-"7.13.2 INFORMATIONAL"
-"7.3.1 OK"
-"7.3.2 OK"
-"7.3.3 OK"
-"7.3.4 OK"
-"7.3.5 OK"
-"7.3.6 OK"
-"7.5.1 FAILED"
-"7.7.1 OK"
-"7.7.10 OK"
-"7.7.11 OK"
-"7.7.12 OK"
-"7.7.13 OK"
-"7.7.2 OK"
-"7.7.3 OK"
-"7.7.4 OK"
-"7.7.5 OK"
-"7.7.6 OK"
-"7.7.7 OK"
-"7.7.8 OK"
-"7.7.9 OK"
-"7.9.1 OK"
-"7.9.10 OK"
-"7.9.11 OK"
-"7.9.12 OK"
-"7.9.13 OK"
-"7.9.2 OK"
-"7.9.3 OK"
-"7.9.4 OK"
-"7.9.5 OK"
-"7.9.6 OK"
-"7.9.7 OK"
-"7.9.8 OK"
-"7.9.9 OK"
-"9.1.1 OK"
-"9.1.2 OK"
-"9.1.3 OK"
-"9.1.4 OK"
-"9.1.5 OK"
-"9.1.6 OK"
-"9.2.1 OK"
-"9.2.2 OK"
-"9.2.3 OK"
-"9.2.4 OK"
-"9.2.5 OK"
-"9.2.6 OK"
-"9.3.1 OK"
-"9.3.2 OK"
-"9.3.3 OK"
-"9.3.4 OK"
-"9.3.5 OK"
-"9.3.6 OK"
-"9.3.7 OK"
-"9.3.8 OK"
-"9.3.9 OK"
-"9.4.1 OK"
-"9.4.2 OK"
-"9.4.3 OK"
-"9.4.4 OK"
-"9.4.5 OK"
-"9.4.6 OK"
-"9.4.7 OK"
-"9.4.8 OK"
-"9.4.9 OK"
-"9.5.1 OK"
-"9.5.2 OK"
-"9.5.3 OK"
-"9.5.4 OK"
-"9.5.5 OK"
-"9.5.6 OK"
-"9.6.1 OK"
-"9.6.2 OK"
-"9.6.3 OK"
-"9.6.4 OK"
-"9.6.5 OK"
-"9.6.6 OK"
-"9.7.1 OK"
-"9.7.2 OK"
-"9.7.3 OK"
-"9.7.4 OK"
-"9.7.5 OK"
-"9.7.6 OK"
-"9.8.1 OK"
-"9.8.2 OK"
-"9.8.3 OK"
-"9.8.4 OK"
-"9.8.5 OK"
-"9.8.6 OK"
diff --git a/okhttp-tests/fuzzingserver-test.sh b/okhttp-tests/fuzzingserver-test.sh
deleted file mode 100755
index 78ad71f59e..0000000000
--- a/okhttp-tests/fuzzingserver-test.sh
+++ /dev/null
@@ -1,28 +0,0 @@
-#!/usr/bin/env bash
-
-SCRIPT_DIR="$( cd "$( dirname "$0" )" && pwd )"
-cd "$SCRIPT_DIR"
-
-which wstest
-if [ $? != 0 ]; then
-  echo "Run 'pip install autobahntestsuite', maybe with 'sudo'."
-  exit 1
-fi
-which jq
-if [ $? != 0 ]; then
-  echo "Run 'brew install jq'"
-  exit 1
-fi
-
-trap 'kill $(jobs -pr)' SIGINT SIGTERM EXIT
-
-set -ex
-
-wstest -m fuzzingserver -s fuzzingserver-config.json &
-sleep 2 # wait for wstest to start
-
-java -jar target/okhttp-tests-*-jar-with-dependencies.jar
-
-jq '.[] as $in | $in | keys[] | . + " " + $in[.].behavior' target/fuzzingserver-report/index.json > target/fuzzingserver-actual.txt
-
-diff fuzzingserver-expected.txt target/fuzzingserver-actual.txt
diff --git a/okhttp-tests/fuzzingserver-update-expected.sh b/okhttp-tests/fuzzingserver-update-expected.sh
deleted file mode 100755
index 56592c95fe..0000000000
--- a/okhttp-tests/fuzzingserver-update-expected.sh
+++ /dev/null
@@ -1,11 +0,0 @@
-#!/usr/bin/env bash
-
-SCRIPT_DIR="$( cd "$( dirname "$0" )" && pwd )"
-cd "$SCRIPT_DIR"
-
-if [ ! -f target/fuzzingserver-actual.txt ]; then
-  echo "File not found. Did you run the Autobahn test script?"
-  exit 1
-fi
-
-cp target/fuzzingserver-actual.txt fuzzingserver-expected.txt
diff --git a/okhttp-tests/pom.xml b/okhttp-tests/pom.xml
deleted file mode 100644
index 5fa95d4dbf..0000000000
--- a/okhttp-tests/pom.xml
+++ /dev/null
@@ -1,112 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.14.3-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>okhttp-tests</artifactId>
-  <name>OkHttp Tests</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup.okio</groupId>
-      <artifactId>okio</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>com.google.code.findbugs</groupId>
-      <artifactId>jsr305</artifactId>
-      <scope>provided</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-testing-support</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-tls</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-urlconnection</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>org.conscrypt</groupId>
-      <artifactId>conscrypt-openjdk-uber</artifactId>
-    </dependency>
-
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>logging-interceptor</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-assembly-plugin</artifactId>
-        <version>3.1.0</version>
-        <configuration>
-          <descriptorRefs>
-            <descriptorRef>jar-with-dependencies</descriptorRef>
-          </descriptorRefs>
-          <archive>
-            <manifest>
-              <mainClass>okhttp3.AutobahnTester</mainClass>
-            </manifest>
-          </archive>
-        </configuration>
-        <executions>
-          <execution>
-            <phase>package</phase>
-            <goals>
-              <goal>single</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
-      <!-- Do not deploy this as an artifact to Maven central. -->
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-deploy-plugin</artifactId>
-        <version>2.8.2</version>
-        <configuration>
-          <skip>true</skip>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/okhttp-tests/src/main/java/okhttp3/AutobahnTester.java b/okhttp-tests/src/main/java/okhttp3/AutobahnTester.java
deleted file mode 100644
index ab7b9c771d..0000000000
--- a/okhttp-tests/src/main/java/okhttp3/AutobahnTester.java
+++ /dev/null
@@ -1,152 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicLong;
-import java.util.concurrent.atomic.AtomicReference;
-import okhttp3.internal.Version;
-import okio.ByteString;
-
-/**
- * Exercises the web socket implementation against the <a
- * href="http://autobahn.ws/testsuite/">Autobahn Testsuite</a>.
- */
-public final class AutobahnTester {
-  private static final String HOST = "ws://localhost:9099";
-
-  public static void main(String... args) throws IOException {
-    new AutobahnTester().run();
-  }
-
-  final OkHttpClient client = new OkHttpClient();
-
-  private WebSocket newWebSocket(String path, WebSocketListener listener) {
-    Request request = new Request.Builder().url(HOST + path).build();
-    return client.newWebSocket(request, listener);
-  }
-
-  public void run() throws IOException {
-    try {
-      long count = getTestCount();
-      System.out.println("Test count: " + count);
-
-      for (long number = 1; number <= count; number++) {
-        runTest(number, count);
-      }
-
-      updateReports();
-    } finally {
-      client.dispatcher().executorService().shutdown();
-    }
-  }
-
-  private void runTest(final long number, final long count) {
-    final CountDownLatch latch = new CountDownLatch(1);
-    final AtomicLong startNanos = new AtomicLong();
-    newWebSocket("/runCase?case=" + number + "&agent=okhttp", new WebSocketListener() {
-      @Override public void onOpen(WebSocket webSocket, Response response) {
-        System.out.println("Executing test case " + number + "/" + count);
-        startNanos.set(System.nanoTime());
-      }
-
-      @Override public void onMessage(final WebSocket webSocket, final ByteString bytes) {
-        webSocket.send(bytes);
-      }
-
-      @Override public void onMessage(final WebSocket webSocket, final String text) {
-        webSocket.send(text);
-      }
-
-      @Override public void onClosing(WebSocket webSocket, int code, String reason) {
-        webSocket.close(1000, null);
-        latch.countDown();
-      }
-
-      @Override public void onFailure(WebSocket webSocket, Throwable t, Response response) {
-        t.printStackTrace(System.out);
-        latch.countDown();
-      }
-    });
-    try {
-      if (!latch.await(30, TimeUnit.SECONDS)) {
-        throw new IllegalStateException("Timed out waiting for test " + number + " to finish.");
-      }
-    } catch (InterruptedException e) {
-      throw new AssertionError();
-    }
-
-    long endNanos = System.nanoTime();
-    long tookMs = TimeUnit.NANOSECONDS.toMillis(endNanos - startNanos.get());
-    System.out.println("Took " + tookMs + "ms");
-  }
-
-  private long getTestCount() throws IOException {
-    final CountDownLatch latch = new CountDownLatch(1);
-    final AtomicLong countRef = new AtomicLong();
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    newWebSocket("/getCaseCount", new WebSocketListener() {
-      @Override public void onMessage(WebSocket webSocket, String text) {
-        countRef.set(Long.parseLong(text));
-      }
-
-      @Override public void onClosing(WebSocket webSocket, int code, String reason) {
-        webSocket.close(1000, null);
-        latch.countDown();
-      }
-
-      @Override public void onFailure(WebSocket webSocket, Throwable t, Response response) {
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-    try {
-      if (!latch.await(10, TimeUnit.SECONDS)) {
-        throw new IllegalStateException("Timed out waiting for count.");
-      }
-    } catch (InterruptedException e) {
-      throw new AssertionError();
-    }
-    Throwable failure = failureRef.get();
-    if (failure != null) {
-      throw new RuntimeException(failure);
-    }
-    return countRef.get();
-  }
-
-  private void updateReports() {
-    final CountDownLatch latch = new CountDownLatch(1);
-    newWebSocket("/updateReports?agent=" + Version.userAgent(), new WebSocketListener() {
-      @Override public void onClosing(WebSocket webSocket, int code, String reason) {
-        webSocket.close(1000, null);
-        latch.countDown();
-      }
-
-      @Override public void onFailure(WebSocket webSocket, Throwable t, Response response) {
-        latch.countDown();
-      }
-    });
-    try {
-      if (!latch.await(10, TimeUnit.SECONDS)) {
-        throw new IllegalStateException("Timed out waiting for count.");
-      }
-    } catch (InterruptedException e) {
-      throw new AssertionError();
-    }
-  }
-}
diff --git a/okhttp-tests/src/main/java/okhttp3/TestTls13Request.java b/okhttp-tests/src/main/java/okhttp3/TestTls13Request.java
deleted file mode 100644
index ac1bbc7f21..0000000000
--- a/okhttp-tests/src/main/java/okhttp3/TestTls13Request.java
+++ /dev/null
@@ -1,105 +0,0 @@
-package okhttp3;
-
-import java.io.IOException;
-import java.security.Security;
-import java.util.Arrays;
-import java.util.List;
-import okhttp3.internal.platform.Platform;
-import org.conscrypt.Conscrypt;
-
-public class TestTls13Request {
-
-  // TLS 1.3
-  private static final CipherSuite[] TLS13_CIPHER_SUITES = new CipherSuite[] {
-      CipherSuite.TLS_AES_128_GCM_SHA256,
-      CipherSuite.TLS_AES_256_GCM_SHA384,
-      CipherSuite.TLS_CHACHA20_POLY1305_SHA256,
-      CipherSuite.TLS_AES_128_CCM_SHA256,
-      CipherSuite.TLS_AES_128_CCM_8_SHA256
-  };
-
-  /**
-   * A TLS 1.3 only Connection Spec. This will be eventually be exposed
-   * as part of MODERN_TLS or folded into the default OkHttp client once published and
-   * available in JDK11 or Conscrypt.
-   */
-  private static final ConnectionSpec TLS_13 = new ConnectionSpec.Builder(true)
-      .cipherSuites(TLS13_CIPHER_SUITES)
-      .tlsVersions(TlsVersion.TLS_1_3)
-      .build();
-
-
-  private static final ConnectionSpec TLS_12 =
-      new ConnectionSpec.Builder(ConnectionSpec.RESTRICTED_TLS).tlsVersions(TlsVersion.TLS_1_2)
-          .build();
-
-  private TestTls13Request() {
-  }
-
-  public static void main(String[] args) {
-    //System.setProperty("javax.net.debug", "ssl:handshake:verbose");
-    Security.insertProviderAt(Conscrypt.newProviderBuilder().provideTrustManager().build(), 1);
-
-    System.out.println(
-        "Running tests using " + Platform.get() + " " + System.getProperty("java.vm.version"));
-
-    // https://github.com/tlswg/tls13-spec/wiki/Implementations
-    List<String> urls =
-        Arrays.asList("https://enabled.tls13.com", "https://www.howsmyssl.com/a/check",
-            "https://tls13.cloudflare.com", "https://www.allizom.org/robots.txt",
-            "https://tls13.crypto.mozilla.org/", "https://tls.ctf.network/robots.txt",
-            "https://rustls.jbp.io/", "https://h2o.examp1e.net", "https://mew.org/",
-            "https://tls13.baishancloud.com/", "https://tls13.akamai.io/", "https://swifttls.org/",
-            "https://www.googleapis.com/robots.txt", "https://graph.facebook.com/robots.txt",
-            "https://api.twitter.com/robots.txt", "https://connect.squareup.com/robots.txt");
-
-    System.out.println("TLS1.3+TLS1.2");
-    testClient(urls, buildClient(ConnectionSpec.RESTRICTED_TLS));
-
-    System.out.println("\nTLS1.3 only");
-    testClient(urls, buildClient(TLS_13));
-
-    System.out.println("\nTLS1.3 then fallback");
-    testClient(urls, buildClient(TLS_13, TLS_12));
-  }
-
-  private static void testClient(List<String> urls, OkHttpClient client) {
-    try {
-      for (String url : urls) {
-        sendRequest(client, url);
-      }
-    } finally {
-      client.dispatcher.executorService().shutdownNow();
-      client.connectionPool.evictAll();
-    }
-  }
-
-  private static OkHttpClient buildClient(ConnectionSpec... specs) {
-    return new OkHttpClient.Builder().connectionSpecs(Arrays.asList(specs)).build();
-  }
-
-  private static void sendRequest(OkHttpClient client, String url) {
-    System.out.printf("%-40s ", url);
-    System.out.flush();
-
-    System.out.println(Platform.get());
-
-    Request request = new Request.Builder().url(url).build();
-
-    try (Response response = client.newCall(request).execute()) {
-      Handshake handshake = response.handshake();
-      System.out.println(handshake.tlsVersion()
-          + " "
-          + handshake.cipherSuite()
-          + " "
-          + response.protocol()
-          + " "
-          + response.code
-          + " "
-          + response.body.bytes().length
-          + "b");
-    } catch (IOException ioe) {
-      System.out.println(ioe.toString());
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/AddressTest.java b/okhttp-tests/src/test/java/okhttp3/AddressTest.java
deleted file mode 100644
index 9d3bf4165b..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/AddressTest.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.net.Proxy;
-import java.util.List;
-import javax.net.SocketFactory;
-import okhttp3.internal.Util;
-import okhttp3.internal.http.RecordingProxySelector;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public final class AddressTest {
-  private Dns dns = Dns.SYSTEM;
-  private SocketFactory socketFactory = SocketFactory.getDefault();
-  private Authenticator authenticator = Authenticator.NONE;
-  private List<Protocol> protocols = Util.immutableList(Protocol.HTTP_1_1);
-  private List<ConnectionSpec> connectionSpecs = Util.immutableList(ConnectionSpec.MODERN_TLS);
-  private RecordingProxySelector proxySelector = new RecordingProxySelector();
-
-  @Test public void equalsAndHashcode() throws Exception {
-    Address a = new Address("square.com", 80, dns, socketFactory, null, null, null,
-        authenticator, null, protocols, connectionSpecs, proxySelector);
-    Address b = new Address("square.com", 80, dns, socketFactory, null, null, null,
-        authenticator, null, protocols, connectionSpecs, proxySelector);
-    assertThat(b).isEqualTo(a);
-    assertThat(b.hashCode()).isEqualTo(a.hashCode());
-  }
-
-  @Test public void differentProxySelectorsAreDifferent() throws Exception {
-    Address a = new Address("square.com", 80, dns, socketFactory, null, null, null,
-        authenticator, null, protocols, connectionSpecs, new RecordingProxySelector());
-    Address b = new Address("square.com", 80, dns, socketFactory, null, null, null,
-        authenticator, null, protocols, connectionSpecs, new RecordingProxySelector());
-    assertThat(b).isNotEqualTo(a);
-  }
-
-  @Test public void addressToString() throws Exception {
-    Address address = new Address("square.com", 80, dns, socketFactory, null, null, null,
-        authenticator, null, protocols, connectionSpecs, proxySelector);
-    assertThat(address.toString()).isEqualTo(
-        "Address{square.com:80, proxySelector=RecordingProxySelector}");
-  }
-
-  @Test public void addressWithProxyToString() throws Exception {
-    Address address = new Address("square.com", 80, dns, socketFactory, null, null, null,
-        authenticator, Proxy.NO_PROXY, protocols, connectionSpecs, proxySelector);
-    assertThat(address.toString()).isEqualTo(
-        "Address{square.com:80, proxy=" + Proxy.NO_PROXY + "}");
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/CacheControlTest.java b/okhttp-tests/src/test/java/okhttp3/CacheControlTest.java
deleted file mode 100644
index a1030b611b..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/CacheControlTest.java
+++ /dev/null
@@ -1,194 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.util.concurrent.TimeUnit;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class CacheControlTest {
-  @Test public void emptyBuilderIsEmpty() throws Exception {
-    CacheControl cacheControl = new CacheControl.Builder().build();
-    assertThat(cacheControl.toString()).isEqualTo("");
-    assertThat(cacheControl.noCache()).isFalse();
-    assertThat(cacheControl.noStore()).isFalse();
-    assertThat(cacheControl.maxAgeSeconds()).isEqualTo(-1);
-    assertThat(cacheControl.sMaxAgeSeconds()).isEqualTo(-1);
-    assertThat(cacheControl.isPrivate()).isFalse();
-    assertThat(cacheControl.isPublic()).isFalse();
-    assertThat(cacheControl.mustRevalidate()).isFalse();
-    assertThat(cacheControl.maxStaleSeconds()).isEqualTo(-1);
-    assertThat(cacheControl.minFreshSeconds()).isEqualTo(-1);
-    assertThat(cacheControl.onlyIfCached()).isFalse();
-    assertThat(cacheControl.mustRevalidate()).isFalse();
-  }
-
-  @Test public void completeBuilder() throws Exception {
-    CacheControl cacheControl = new CacheControl.Builder()
-        .noCache()
-        .noStore()
-        .maxAge(1, TimeUnit.SECONDS)
-        .maxStale(2, TimeUnit.SECONDS)
-        .minFresh(3, TimeUnit.SECONDS)
-        .onlyIfCached()
-        .noTransform()
-        .immutable()
-        .build();
-    assertThat(cacheControl.toString()).isEqualTo(
-        ("no-cache, no-store, max-age=1, max-stale=2, min-fresh=3, only-if-cached, "
-        + "no-transform, immutable"));
-    assertThat(cacheControl.noCache()).isTrue();
-    assertThat(cacheControl.noStore()).isTrue();
-    assertThat(cacheControl.maxAgeSeconds()).isEqualTo(1);
-    assertThat(cacheControl.maxStaleSeconds()).isEqualTo(2);
-    assertThat(cacheControl.minFreshSeconds()).isEqualTo(3);
-    assertThat(cacheControl.onlyIfCached()).isTrue();
-    assertThat(cacheControl.noTransform()).isTrue();
-    assertThat(cacheControl.immutable()).isTrue();
-
-    // These members are accessible to response headers only.
-    assertThat(cacheControl.sMaxAgeSeconds()).isEqualTo(-1);
-    assertThat(cacheControl.isPrivate()).isFalse();
-    assertThat(cacheControl.isPublic()).isFalse();
-    assertThat(cacheControl.mustRevalidate()).isFalse();
-  }
-
-  @Test public void parseEmpty() throws Exception {
-    CacheControl cacheControl = CacheControl.parse(
-        new Headers.Builder().set("Cache-Control", "").build());
-    assertThat(cacheControl.toString()).isEqualTo("");
-    assertThat(cacheControl.noCache()).isFalse();
-    assertThat(cacheControl.noStore()).isFalse();
-    assertThat(cacheControl.maxAgeSeconds()).isEqualTo(-1);
-    assertThat(cacheControl.sMaxAgeSeconds()).isEqualTo(-1);
-    assertThat(cacheControl.isPublic()).isFalse();
-    assertThat(cacheControl.mustRevalidate()).isFalse();
-    assertThat(cacheControl.maxStaleSeconds()).isEqualTo(-1);
-    assertThat(cacheControl.minFreshSeconds()).isEqualTo(-1);
-    assertThat(cacheControl.onlyIfCached()).isFalse();
-    assertThat(cacheControl.mustRevalidate()).isFalse();
-  }
-
-  @Test public void parse() throws Exception {
-    String header = "no-cache, no-store, max-age=1, s-maxage=2, private, public, must-revalidate, "
-        + "max-stale=3, min-fresh=4, only-if-cached, no-transform";
-    CacheControl cacheControl = CacheControl.parse(new Headers.Builder()
-        .set("Cache-Control", header)
-        .build());
-    assertThat(cacheControl.noCache()).isTrue();
-    assertThat(cacheControl.noStore()).isTrue();
-    assertThat(cacheControl.maxAgeSeconds()).isEqualTo(1);
-    assertThat(cacheControl.sMaxAgeSeconds()).isEqualTo(2);
-    assertThat(cacheControl.isPrivate()).isTrue();
-    assertThat(cacheControl.isPublic()).isTrue();
-    assertThat(cacheControl.mustRevalidate()).isTrue();
-    assertThat(cacheControl.maxStaleSeconds()).isEqualTo(3);
-    assertThat(cacheControl.minFreshSeconds()).isEqualTo(4);
-    assertThat(cacheControl.onlyIfCached()).isTrue();
-    assertThat(cacheControl.noTransform()).isTrue();
-    assertThat(cacheControl.toString()).isEqualTo(header);
-  }
-
-  @Test public void parseIgnoreCacheControlExtensions() throws Exception {
-    // Example from http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9.6
-    String header = "private, community=\"UCI\"";
-    CacheControl cacheControl = CacheControl.parse(new Headers.Builder()
-        .set("Cache-Control", header)
-        .build());
-    assertThat(cacheControl.noCache()).isFalse();
-    assertThat(cacheControl.noStore()).isFalse();
-    assertThat(cacheControl.maxAgeSeconds()).isEqualTo(-1);
-    assertThat(cacheControl.sMaxAgeSeconds()).isEqualTo(-1);
-    assertThat(cacheControl.isPrivate()).isTrue();
-    assertThat(cacheControl.isPublic()).isFalse();
-    assertThat(cacheControl.mustRevalidate()).isFalse();
-    assertThat(cacheControl.maxStaleSeconds()).isEqualTo(-1);
-    assertThat(cacheControl.minFreshSeconds()).isEqualTo(-1);
-    assertThat(cacheControl.onlyIfCached()).isFalse();
-    assertThat(cacheControl.noTransform()).isFalse();
-    assertThat(cacheControl.immutable()).isFalse();
-    assertThat(cacheControl.toString()).isEqualTo(header);
-  }
-
-  @Test public void parseCacheControlAndPragmaAreCombined() {
-    Headers headers =
-        Headers.of("Cache-Control", "max-age=12", "Pragma", "must-revalidate", "Pragma", "public");
-    CacheControl cacheControl = CacheControl.parse(headers);
-    assertThat(cacheControl.toString()).isEqualTo("max-age=12, public, must-revalidate");
-  }
-
-  @SuppressWarnings("RedundantStringConstructorCall") // Testing instance equality.
-  @Test public void parseCacheControlHeaderValueIsRetained() {
-    String value = new String("max-age=12");
-    Headers headers = Headers.of("Cache-Control", value);
-    CacheControl cacheControl = CacheControl.parse(headers);
-    assertThat(cacheControl.toString()).isSameAs(value);
-  }
-
-  @Test public void parseCacheControlHeaderValueInvalidatedByPragma() {
-    Headers headers = Headers.of("Cache-Control", "max-age=12", "Pragma", "must-revalidate");
-    CacheControl cacheControl = CacheControl.parse(headers);
-    assertThat(cacheControl.headerValue).isNull();
-  }
-
-  @Test public void parseCacheControlHeaderValueInvalidatedByTwoValues() {
-    Headers headers = Headers.of("Cache-Control", "max-age=12", "Cache-Control", "must-revalidate");
-    CacheControl cacheControl = CacheControl.parse(headers);
-    assertThat(cacheControl.headerValue).isNull();
-  }
-
-  @Test public void parsePragmaHeaderValueIsNotRetained() {
-    Headers headers = Headers.of("Pragma", "must-revalidate");
-    CacheControl cacheControl = CacheControl.parse(headers);
-    assertThat(cacheControl.headerValue).isNull();
-  }
-
-  @Test public void computedHeaderValueIsCached() {
-    CacheControl cacheControl = new CacheControl.Builder()
-        .maxAge(2, TimeUnit.DAYS)
-        .build();
-    assertThat(cacheControl.headerValue).isNull();
-    assertThat(cacheControl.toString()).isEqualTo("max-age=172800");
-    assertThat(cacheControl.headerValue).isEqualTo("max-age=172800");
-    cacheControl.headerValue = "Hi";
-    assertThat(cacheControl.toString()).isEqualTo("Hi");
-  }
-
-  @Test public void timeDurationTruncatedToMaxValue() throws Exception {
-    CacheControl cacheControl = new CacheControl.Builder()
-        .maxAge(365 * 100, TimeUnit.DAYS) // Longer than Integer.MAX_VALUE seconds.
-        .build();
-    assertThat(cacheControl.maxAgeSeconds()).isEqualTo(Integer.MAX_VALUE);
-  }
-
-  @Test public void secondsMustBeNonNegative() throws Exception {
-    CacheControl.Builder builder = new CacheControl.Builder();
-    try {
-      builder.maxAge(-1, TimeUnit.SECONDS);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void timePrecisionIsTruncatedToSeconds() throws Exception {
-    CacheControl cacheControl = new CacheControl.Builder()
-        .maxAge(4999, TimeUnit.MILLISECONDS)
-        .build();
-    assertThat(cacheControl.maxAgeSeconds()).isEqualTo(4);
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/CacheTest.java b/okhttp-tests/src/test/java/okhttp3/CacheTest.java
deleted file mode 100644
index e8f00dbea4..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/CacheTest.java
+++ /dev/null
@@ -1,2624 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package okhttp3;
-
-import java.io.File;
-import java.io.IOException;
-import java.net.CookieManager;
-import java.net.HttpURLConnection;
-import java.net.ResponseCache;
-import java.security.Principal;
-import java.security.cert.Certificate;
-import java.text.DateFormat;
-import java.text.SimpleDateFormat;
-import java.util.Date;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Locale;
-import java.util.NoSuchElementException;
-import java.util.TimeZone;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicReference;
-import javax.net.ssl.HostnameVerifier;
-import okhttp3.internal.Internal;
-import okhttp3.internal.io.InMemoryFileSystem;
-import okhttp3.internal.platform.Platform;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
-import okhttp3.tls.HandshakeCertificates;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.GzipSink;
-import okio.Okio;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
-import static okhttp3.tls.internal.TlsUtil.localhost;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.data.Offset.offset;
-import static org.junit.Assert.fail;
-
-public final class CacheTest {
-  private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = (name, session) -> true;
-
-  @Rule public MockWebServer server = new MockWebServer();
-  @Rule public MockWebServer server2 = new MockWebServer();
-  @Rule public InMemoryFileSystem fileSystem = new InMemoryFileSystem();
-  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
-
-  private final HandshakeCertificates handshakeCertificates = localhost();
-  private OkHttpClient client;
-  private Cache cache;
-  private final CookieManager cookieManager = new CookieManager();
-
-  @Before public void setUp() throws Exception {
-    server.setProtocolNegotiationEnabled(false);
-    cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
-    client = clientTestRule.client.newBuilder()
-        .cache(cache)
-        .cookieJar(new JavaNetCookieJar(cookieManager))
-        .build();
-  }
-
-  @After public void tearDown() throws Exception {
-    ResponseCache.setDefault(null);
-    cache.delete();
-  }
-
-  /**
-   * Test that response caching is consistent with the RI and the spec.
-   * http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.4
-   */
-  @Test public void responseCachingByResponseCode() throws Exception {
-    // Test each documented HTTP/1.1 code, plus the first unused value in each range.
-    // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
-
-    // We can't test 100 because it's not really a response.
-    // assertCached(false, 100);
-    assertCached(false, 101);
-    assertCached(false, 102);
-    assertCached(true, 200);
-    assertCached(false, 201);
-    assertCached(false, 202);
-    assertCached(true, 203);
-    assertCached(true, 204);
-    assertCached(false, 205);
-    assertCached(false, 206); //Electing to not cache partial responses
-    assertCached(false, 207);
-    assertCached(true, 300);
-    assertCached(true, 301);
-    assertCached(true, 302);
-    assertCached(false, 303);
-    assertCached(false, 304);
-    assertCached(false, 305);
-    assertCached(false, 306);
-    assertCached(true, 307);
-    assertCached(true, 308);
-    assertCached(false, 400);
-    assertCached(false, 401);
-    assertCached(false, 402);
-    assertCached(false, 403);
-    assertCached(true, 404);
-    assertCached(true, 405);
-    assertCached(false, 406);
-    assertCached(false, 408);
-    assertCached(false, 409);
-    // the HTTP spec permits caching 410s, but the RI doesn't.
-    assertCached(true, 410);
-    assertCached(false, 411);
-    assertCached(false, 412);
-    assertCached(false, 413);
-    assertCached(true, 414);
-    assertCached(false, 415);
-    assertCached(false, 416);
-    assertCached(false, 417);
-    assertCached(false, 418);
-
-    assertCached(false, 500);
-    assertCached(true, 501);
-    assertCached(false, 502);
-    assertCached(false, 503);
-    assertCached(false, 504);
-    assertCached(false, 505);
-    assertCached(false, 506);
-  }
-
-  private void assertCached(boolean shouldPut, int responseCode) throws Exception {
-    int expectedResponseCode = responseCode;
-
-    server = new MockWebServer();
-    MockResponse mockResponse = new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setResponseCode(responseCode)
-        .setBody("ABCDE")
-        .addHeader("WWW-Authenticate: challenge");
-    if (responseCode == HttpURLConnection.HTTP_PROXY_AUTH) {
-      mockResponse.addHeader("Proxy-Authenticate: Basic realm=\"protected area\"");
-    } else if (responseCode == HttpURLConnection.HTTP_UNAUTHORIZED) {
-      mockResponse.addHeader("WWW-Authenticate: Basic realm=\"protected area\"");
-    } else if (responseCode == HttpURLConnection.HTTP_NO_CONTENT
-        || responseCode == HttpURLConnection.HTTP_RESET) {
-      mockResponse.setBody(""); // We forbid bodies for 204 and 205.
-    }
-    server.enqueue(mockResponse);
-
-    if (responseCode == HttpURLConnection.HTTP_CLIENT_TIMEOUT) {
-      // 408's are a bit of an outlier because we may repeat the request if we encounter this
-      // response code. In this scenario, there are 2 responses: the initial 408 and then the 200
-      // because of the retry. We just want to ensure the initial 408 isn't cached.
-      expectedResponseCode = 200;
-      server.enqueue(new MockResponse()
-          .setHeader("Cache-Control", "no-store")
-          .setBody("FGHIJ"));
-    }
-
-    server.start();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.code()).isEqualTo(expectedResponseCode);
-
-    // Exhaust the content stream.
-    response.body().string();
-
-    Response cached = cache.get(request);
-    if (shouldPut) {
-      assertThat(cached).isNotNull();
-      cached.body().close();
-    } else {
-      assertThat(cached).isNull();
-    }
-    server.shutdown(); // tearDown() isn't sufficient; this test starts multiple servers
-  }
-
-  @Test public void responseCachingAndInputStreamSkipWithFixedLength() throws IOException {
-    testResponseCaching(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void responseCachingAndInputStreamSkipWithChunkedEncoding() throws IOException {
-    testResponseCaching(TransferKind.CHUNKED);
-  }
-
-  @Test public void responseCachingAndInputStreamSkipWithNoLengthHeaders() throws IOException {
-    testResponseCaching(TransferKind.END_OF_STREAM);
-  }
-
-  /**
-   * Skipping bytes in the input stream caused ResponseCache corruption.
-   * http://code.google.com/p/android/issues/detail?id=8175
-   */
-  private void testResponseCaching(TransferKind transferKind) throws IOException {
-    MockResponse mockResponse = new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setStatus("HTTP/1.1 200 Fantastic");
-    transferKind.setBody(mockResponse, "I love puppies but hate spiders", 1);
-    server.enqueue(mockResponse);
-
-    // Make sure that calling skip() doesn't omit bytes from the cache.
-    Request request = new Request.Builder().url(server.url("/")).build();
-    Response response1 = client.newCall(request).execute();
-
-    BufferedSource in1 = response1.body().source();
-    assertThat(in1.readUtf8("I love ".length())).isEqualTo("I love ");
-    in1.skip("puppies but hate ".length());
-    assertThat(in1.readUtf8("spiders".length())).isEqualTo("spiders");
-    assertThat(in1.exhausted()).isTrue();
-    in1.close();
-    assertThat(cache.writeSuccessCount()).isEqualTo(1);
-    assertThat(cache.writeAbortCount()).isEqualTo(0);
-
-    Response response2 = client.newCall(request).execute();
-    BufferedSource in2 = response2.body().source();
-    assertThat(in2.readUtf8("I love puppies but hate spiders".length())).isEqualTo(
-        "I love puppies but hate spiders");
-    assertThat(response2.code()).isEqualTo(200);
-    assertThat(response2.message()).isEqualTo("Fantastic");
-
-    assertThat(in2.exhausted()).isTrue();
-    in2.close();
-    assertThat(cache.writeSuccessCount()).isEqualTo(1);
-    assertThat(cache.writeAbortCount()).isEqualTo(0);
-    assertThat(cache.requestCount()).isEqualTo(2);
-    assertThat(cache.hitCount()).isEqualTo(1);
-  }
-
-  @Test public void secureResponseCaching() throws IOException {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setBody("ABC"));
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
-        .build();
-
-    Request request = new Request.Builder().url(server.url("/")).build();
-    Response response1 = client.newCall(request).execute();
-    BufferedSource in = response1.body().source();
-    assertThat(in.readUtf8()).isEqualTo("ABC");
-
-    // OpenJDK 6 fails on this line, complaining that the connection isn't open yet
-    CipherSuite cipherSuite = response1.handshake().cipherSuite();
-    List<Certificate> localCerts = response1.handshake().localCertificates();
-    List<Certificate> serverCerts = response1.handshake().peerCertificates();
-    Principal peerPrincipal = response1.handshake().peerPrincipal();
-    Principal localPrincipal = response1.handshake().localPrincipal();
-
-    Response response2 = client.newCall(request).execute(); // Cached!
-    assertThat(response2.body().string()).isEqualTo("ABC");
-
-    assertThat(cache.requestCount()).isEqualTo(2);
-    assertThat(cache.networkCount()).isEqualTo(1);
-    assertThat(cache.hitCount()).isEqualTo(1);
-
-    assertThat(response2.handshake().cipherSuite()).isEqualTo(cipherSuite);
-    assertThat(response2.handshake().localCertificates()).isEqualTo(localCerts);
-    assertThat(response2.handshake().peerCertificates()).isEqualTo(serverCerts);
-    assertThat(response2.handshake().peerPrincipal()).isEqualTo(peerPrincipal);
-    assertThat(response2.handshake().localPrincipal()).isEqualTo(localPrincipal);
-  }
-
-  @Test public void responseCachingAndRedirects() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setBody("ABC"));
-    server.enqueue(new MockResponse()
-        .setBody("DEF"));
-
-    Request request = new Request.Builder().url(server.url("/")).build();
-    Response response1 = client.newCall(request).execute();
-    assertThat(response1.body().string()).isEqualTo("ABC");
-
-    Response response2 = client.newCall(request).execute(); // Cached!
-    assertThat(response2.body().string()).isEqualTo("ABC");
-
-    // 2 requests + 2 redirects
-    assertThat(cache.requestCount()).isEqualTo(4);
-    assertThat(cache.networkCount()).isEqualTo(2);
-    assertThat(cache.hitCount()).isEqualTo(2);
-  }
-
-  @Test public void redirectToCachedResult() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("ABC"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse()
-        .setBody("DEF"));
-
-    Request request1 = new Request.Builder().url(server.url("/foo")).build();
-    Response response1 = client.newCall(request1).execute();
-    assertThat(response1.body().string()).isEqualTo("ABC");
-    RecordedRequest recordedRequest1 = server.takeRequest();
-    assertThat(recordedRequest1.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
-    assertThat(recordedRequest1.getSequenceNumber()).isEqualTo(0);
-
-    Request request2 = new Request.Builder().url(server.url("/bar")).build();
-    Response response2 = client.newCall(request2).execute();
-    assertThat(response2.body().string()).isEqualTo("ABC");
-    RecordedRequest recordedRequest2 = server.takeRequest();
-    assertThat(recordedRequest2.getRequestLine()).isEqualTo("GET /bar HTTP/1.1");
-    assertThat(recordedRequest2.getSequenceNumber()).isEqualTo(1);
-
-    // an unrelated request should reuse the pooled connection
-    Request request3 = new Request.Builder().url(server.url("/baz")).build();
-    Response response3 = client.newCall(request3).execute();
-    assertThat(response3.body().string()).isEqualTo("DEF");
-    RecordedRequest recordedRequest3 = server.takeRequest();
-    assertThat(recordedRequest3.getRequestLine()).isEqualTo("GET /baz HTTP/1.1");
-    assertThat(recordedRequest3.getSequenceNumber()).isEqualTo(2);
-  }
-
-  @Test public void secureResponseCachingAndRedirects() throws IOException {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setBody("ABC"));
-    server.enqueue(new MockResponse()
-        .setBody("DEF"));
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
-        .build();
-
-    Response response1 = get(server.url("/"));
-    assertThat(response1.body().string()).isEqualTo("ABC");
-    assertThat(response1.handshake().cipherSuite()).isNotNull();
-
-    // Cached!
-    Response response2 = get(server.url("/"));
-    assertThat(response2.body().string()).isEqualTo("ABC");
-    assertThat(response2.handshake().cipherSuite()).isNotNull();
-
-    // 2 direct + 2 redirect = 4
-    assertThat(cache.requestCount()).isEqualTo(4);
-    assertThat(cache.hitCount()).isEqualTo(2);
-    assertThat(response2.handshake().cipherSuite()).isEqualTo(
-        response1.handshake().cipherSuite());
-  }
-
-  /**
-   * We've had bugs where caching and cross-protocol redirects yield class cast exceptions internal
-   * to the cache because we incorrectly assumed that HttpsURLConnection was always HTTPS and
-   * HttpURLConnection was always HTTP; in practice redirects mean that each can do either.
-   *
-   * https://github.com/square/okhttp/issues/214
-   */
-  @Test public void secureResponseCachingAndProtocolRedirects() throws IOException {
-    server2.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server2.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setBody("ABC"));
-    server2.enqueue(new MockResponse()
-        .setBody("DEF"));
-
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: " + server2.url("/")));
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
-        .build();
-
-    Response response1 = get(server.url("/"));
-    assertThat(response1.body().string()).isEqualTo("ABC");
-
-    // Cached!
-    Response response2 = get(server.url("/"));
-    assertThat(response2.body().string()).isEqualTo("ABC");
-
-    // 2 direct + 2 redirect = 4
-    assertThat(cache.requestCount()).isEqualTo(4);
-    assertThat(cache.hitCount()).isEqualTo(2);
-  }
-
-  @Test public void foundCachedWithExpiresHeader() throws Exception {
-    temporaryRedirectCachedWithCachingHeader(302, "Expires", formatDate(1, TimeUnit.HOURS));
-  }
-
-  @Test public void foundCachedWithCacheControlHeader() throws Exception {
-    temporaryRedirectCachedWithCachingHeader(302, "Cache-Control", "max-age=60");
-  }
-
-  @Test public void temporaryRedirectCachedWithExpiresHeader() throws Exception {
-    temporaryRedirectCachedWithCachingHeader(307, "Expires", formatDate(1, TimeUnit.HOURS));
-  }
-
-  @Test public void temporaryRedirectCachedWithCacheControlHeader() throws Exception {
-    temporaryRedirectCachedWithCachingHeader(307, "Cache-Control", "max-age=60");
-  }
-
-  @Test public void foundNotCachedWithoutCacheHeader() throws Exception {
-    temporaryRedirectNotCachedWithoutCachingHeader(302);
-  }
-
-  @Test public void temporaryRedirectNotCachedWithoutCacheHeader() throws Exception {
-    temporaryRedirectNotCachedWithoutCachingHeader(307);
-  }
-
-  private void temporaryRedirectCachedWithCachingHeader(
-      int responseCode, String headerName, String headerValue) throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(responseCode)
-        .addHeader(headerName, headerValue)
-        .addHeader("Location", "/a"));
-    server.enqueue(new MockResponse()
-        .addHeader(headerName, headerValue)
-        .setBody("a"));
-    server.enqueue(new MockResponse()
-        .setBody("b"));
-    server.enqueue(new MockResponse()
-        .setBody("c"));
-
-    HttpUrl url = server.url("/");
-    assertThat(get(url).body().string()).isEqualTo("a");
-    assertThat(get(url).body().string()).isEqualTo("a");
-  }
-
-  private void temporaryRedirectNotCachedWithoutCachingHeader(int responseCode) throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(responseCode)
-        .addHeader("Location", "/a"));
-    server.enqueue(new MockResponse()
-        .setBody("a"));
-    server.enqueue(new MockResponse()
-        .setBody("b"));
-
-    HttpUrl url = server.url("/");
-    assertThat(get(url).body().string()).isEqualTo("a");
-    assertThat(get(url).body().string()).isEqualTo("b");
-  }
-
-  /** https://github.com/square/okhttp/issues/2198 */
-  @Test public void cachedRedirect() throws IOException {
-    server.enqueue(new MockResponse()
-        .setResponseCode(301)
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Location: /bar"));
-    server.enqueue(new MockResponse()
-        .setBody("ABC"));
-    server.enqueue(new MockResponse()
-        .setBody("ABC"));
-
-    Request request1 = new Request.Builder().url(server.url("/")).build();
-    Response response1 = client.newCall(request1).execute();
-    assertThat(response1.body().string()).isEqualTo("ABC");
-
-    Request request2 = new Request.Builder().url(server.url("/")).build();
-    Response response2 = client.newCall(request2).execute();
-    assertThat(response2.body().string()).isEqualTo("ABC");
-  }
-
-  @Test public void serverDisconnectsPrematurelyWithContentLengthHeader() throws IOException {
-    testServerPrematureDisconnect(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void serverDisconnectsPrematurelyWithChunkedEncoding() throws IOException {
-    testServerPrematureDisconnect(TransferKind.CHUNKED);
-  }
-
-  @Test public void serverDisconnectsPrematurelyWithNoLengthHeaders() throws IOException {
-    // Intentionally empty. This case doesn't make sense because there's no
-    // such thing as a premature disconnect when the disconnect itself
-    // indicates the end of the data stream.
-  }
-
-  private void testServerPrematureDisconnect(TransferKind transferKind) throws IOException {
-    MockResponse mockResponse = new MockResponse();
-    transferKind.setBody(mockResponse, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 16);
-    server.enqueue(truncateViolently(mockResponse, 16));
-    server.enqueue(new MockResponse()
-        .setBody("Request #2"));
-
-    BufferedSource bodySource = get(server.url("/")).body().source();
-    assertThat(bodySource.readUtf8Line()).isEqualTo("ABCDE");
-    try {
-      bodySource.readUtf8(21);
-      fail("This implementation silently ignored a truncated HTTP body.");
-    } catch (IOException expected) {
-    } finally {
-      bodySource.close();
-    }
-
-    assertThat(cache.writeAbortCount()).isEqualTo(1);
-    assertThat(cache.writeSuccessCount()).isEqualTo(0);
-    Response response = get(server.url("/"));
-    assertThat(response.body().string()).isEqualTo("Request #2");
-    assertThat(cache.writeAbortCount()).isEqualTo(1);
-    assertThat(cache.writeSuccessCount()).isEqualTo(1);
-  }
-
-  @Test public void clientPrematureDisconnectWithContentLengthHeader() throws IOException {
-    testClientPrematureDisconnect(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void clientPrematureDisconnectWithChunkedEncoding() throws IOException {
-    testClientPrematureDisconnect(TransferKind.CHUNKED);
-  }
-
-  @Test public void clientPrematureDisconnectWithNoLengthHeaders() throws IOException {
-    testClientPrematureDisconnect(TransferKind.END_OF_STREAM);
-  }
-
-  private void testClientPrematureDisconnect(TransferKind transferKind) throws IOException {
-    // Setting a low transfer speed ensures that stream discarding will time out.
-    MockResponse mockResponse = new MockResponse()
-        .throttleBody(6, 1, TimeUnit.SECONDS);
-    transferKind.setBody(mockResponse, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 1024);
-    server.enqueue(mockResponse);
-    server.enqueue(new MockResponse()
-        .setBody("Request #2"));
-
-    Response response1 = get(server.url("/"));
-    BufferedSource in = response1.body().source();
-    assertThat(in.readUtf8(5)).isEqualTo("ABCDE");
-    in.close();
-    try {
-      in.readByte();
-      fail("Expected an IllegalStateException because the source is closed.");
-    } catch (IllegalStateException expected) {
-    }
-
-    assertThat(cache.writeAbortCount()).isEqualTo(1);
-    assertThat(cache.writeSuccessCount()).isEqualTo(0);
-    Response response2 = get(server.url("/"));
-    assertThat(response2.body().string()).isEqualTo("Request #2");
-    assertThat(cache.writeAbortCount()).isEqualTo(1);
-    assertThat(cache.writeSuccessCount()).isEqualTo(1);
-  }
-
-  @Test public void defaultExpirationDateFullyCachedForLessThan24Hours() throws Exception {
-    //      last modified: 105 seconds ago
-    //             served:   5 seconds ago
-    //   default lifetime: (105 - 5) / 10 = 10 seconds
-    //            expires:  10 seconds from served date = 5 seconds from now
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
-        .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
-        .setBody("A"));
-
-    HttpUrl url = server.url("/");
-    Response response1 = get(url);
-    assertThat(response1.body().string()).isEqualTo("A");
-
-    Response response2 = get(url);
-    assertThat(response2.body().string()).isEqualTo("A");
-    assertThat(response2.header("Warning")).isNull();
-  }
-
-  @Test public void defaultExpirationDateConditionallyCached() throws Exception {
-    //      last modified: 115 seconds ago
-    //             served:  15 seconds ago
-    //   default lifetime: (115 - 15) / 10 = 10 seconds
-    //            expires:  10 seconds from served date = 5 seconds ago
-    String lastModifiedDate = formatDate(-115, TimeUnit.SECONDS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Date: " + formatDate(-15, TimeUnit.SECONDS)));
-    assertThat(conditionalRequest.getHeader("If-Modified-Since")).isEqualTo(
-        lastModifiedDate);
-  }
-
-  @Test public void defaultExpirationDateFullyCachedForMoreThan24Hours() throws Exception {
-    //      last modified: 105 days ago
-    //             served:   5 days ago
-    //   default lifetime: (105 - 5) / 10 = 10 days
-    //            expires:  10 days from served date = 5 days from now
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-105, TimeUnit.DAYS))
-        .addHeader("Date: " + formatDate(-5, TimeUnit.DAYS))
-        .setBody("A"));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-    Response response = get(server.url("/"));
-    assertThat(response.body().string()).isEqualTo("A");
-    assertThat(response.header("Warning")).isEqualTo(
-        "113 HttpURLConnection \"Heuristic expiration\"");
-  }
-
-  @Test public void noDefaultExpirationForUrlsWithQueryString() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
-        .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/").newBuilder().addQueryParameter("foo", "bar").build();
-    assertThat(get(url).body().string()).isEqualTo("A");
-    assertThat(get(url).body().string()).isEqualTo("B");
-  }
-
-  @Test public void expirationDateInThePastWithLastModifiedHeader() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    assertThat(conditionalRequest.getHeader("If-Modified-Since")).isEqualTo(
-        lastModifiedDate);
-  }
-
-  @Test public void expirationDateInThePastWithNoLastModifiedHeader() throws Exception {
-    assertNotCached(new MockResponse()
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-  }
-
-  @Test public void expirationDateInTheFuture() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-  }
-
-  @Test public void maxAgePreferredWithMaxAgeAndExpires() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeInThePastWithDateAndLastModifiedHeaders() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Cache-Control: max-age=60"));
-    assertThat(conditionalRequest.getHeader("If-Modified-Since")).isEqualTo(
-        lastModifiedDate);
-  }
-
-  @Test public void maxAgeInThePastWithDateHeaderButNoLastModifiedHeader() throws Exception {
-    // Chrome interprets max-age relative to the local clock. Both our cache
-    // and Firefox both use the earlier of the local and server's clock.
-    assertNotCached(new MockResponse()
-        .addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeInTheFutureWithDateHeader() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeInTheFutureWithNoDateHeader() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeWithLastModifiedButNoServedDate() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeInTheFutureWithDateAndLastModifiedHeaders() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-        .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgePreferredOverLowerSharedMaxAge() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
-        .addHeader("Cache-Control: s-maxage=60")
-        .addHeader("Cache-Control: max-age=180"));
-  }
-
-  @Test public void maxAgePreferredOverHigherMaxAge() throws Exception {
-    assertNotCached(new MockResponse()
-        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
-        .addHeader("Cache-Control: s-maxage=180")
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void requestMethodOptionsIsNotCached() throws Exception {
-    testRequestMethod("OPTIONS", false);
-  }
-
-  @Test public void requestMethodGetIsCached() throws Exception {
-    testRequestMethod("GET", true);
-  }
-
-  @Test public void requestMethodHeadIsNotCached() throws Exception {
-    // We could support this but choose not to for implementation simplicity
-    testRequestMethod("HEAD", false);
-  }
-
-  @Test public void requestMethodPostIsNotCached() throws Exception {
-    // We could support this but choose not to for implementation simplicity
-    testRequestMethod("POST", false);
-  }
-
-  @Test public void requestMethodPutIsNotCached() throws Exception {
-    testRequestMethod("PUT", false);
-  }
-
-  @Test public void requestMethodDeleteIsNotCached() throws Exception {
-    testRequestMethod("DELETE", false);
-  }
-
-  @Test public void requestMethodTraceIsNotCached() throws Exception {
-    testRequestMethod("TRACE", false);
-  }
-
-  private void testRequestMethod(String requestMethod, boolean expectCached) throws Exception {
-    // 1. Seed the cache (potentially).
-    // 2. Expect a cache hit or miss.
-    server.enqueue(new MockResponse()
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("X-Response-ID: 1"));
-    server.enqueue(new MockResponse()
-        .addHeader("X-Response-ID: 2"));
-
-    HttpUrl url = server.url("/");
-
-    Request request = new Request.Builder()
-        .url(url)
-        .method(requestMethod, requestBodyOrNull(requestMethod))
-        .build();
-    Response response1 = client.newCall(request).execute();
-    response1.body().close();
-    assertThat(response1.header("X-Response-ID")).isEqualTo("1");
-
-    Response response2 = get(url);
-    response2.body().close();
-    if (expectCached) {
-      assertThat(response2.header("X-Response-ID")).isEqualTo("1");
-    } else {
-      assertThat(response2.header("X-Response-ID")).isEqualTo("2");
-    }
-  }
-
-  private RequestBody requestBodyOrNull(String requestMethod) {
-    return (requestMethod.equals("POST") || requestMethod.equals("PUT"))
-        ? RequestBody.create(MediaType.get("text/plain"), "foo")
-        : null;
-  }
-
-  @Test public void postInvalidatesCache() throws Exception {
-    testMethodInvalidates("POST");
-  }
-
-  @Test public void putInvalidatesCache() throws Exception {
-    testMethodInvalidates("PUT");
-  }
-
-  @Test public void deleteMethodInvalidatesCache() throws Exception {
-    testMethodInvalidates("DELETE");
-  }
-
-  private void testMethodInvalidates(String requestMethod) throws Exception {
-    // 1. Seed the cache.
-    // 2. Invalidate it.
-    // 3. Expect a cache miss.
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-    server.enqueue(new MockResponse()
-        .setBody("C"));
-
-    HttpUrl url = server.url("/");
-
-    assertThat(get(url).body().string()).isEqualTo("A");
-
-    Request request = new Request.Builder()
-        .url(url)
-        .method(requestMethod, requestBodyOrNull(requestMethod))
-        .build();
-    Response invalidate = client.newCall(request).execute();
-    assertThat(invalidate.body().string()).isEqualTo("B");
-
-    assertThat(get(url).body().string()).isEqualTo("C");
-  }
-
-  @Test public void postInvalidatesCacheWithUncacheableResponse() throws Exception {
-    // 1. Seed the cache.
-    // 2. Invalidate it with an uncacheable response.
-    // 3. Expect a cache miss.
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-        .setBody("B")
-        .setResponseCode(500));
-    server.enqueue(new MockResponse()
-        .setBody("C"));
-
-    HttpUrl url = server.url("/");
-
-    assertThat(get(url).body().string()).isEqualTo("A");
-
-    Request request = new Request.Builder()
-        .url(url)
-        .method("POST", requestBodyOrNull("POST"))
-        .build();
-    Response invalidate = client.newCall(request).execute();
-    assertThat(invalidate.body().string()).isEqualTo("B");
-
-    assertThat(get(url).body().string()).isEqualTo("C");
-  }
-
-  @Test public void putInvalidatesWithNoContentResponse() throws Exception {
-    // 1. Seed the cache.
-    // 2. Invalidate it.
-    // 3. Expect a cache miss.
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-        .clearHeaders()
-        .setResponseCode(HttpURLConnection.HTTP_NO_CONTENT));
-    server.enqueue(new MockResponse()
-        .setBody("C"));
-
-    HttpUrl url = server.url("/");
-
-    assertThat(get(url).body().string()).isEqualTo("A");
-
-    Request request = new Request.Builder()
-        .url(url)
-        .put(RequestBody.create(MediaType.get("text/plain"), "foo"))
-        .build();
-    Response invalidate = client.newCall(request).execute();
-    assertThat(invalidate.body().string()).isEqualTo("");
-
-    assertThat(get(url).body().string()).isEqualTo("C");
-  }
-
-  @Test public void etag() throws Exception {
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("ETag: v1"));
-    assertThat(conditionalRequest.getHeader("If-None-Match")).isEqualTo("v1");
-  }
-
-  /** If both If-Modified-Since and If-None-Match conditions apply, send only If-None-Match. */
-  @Test public void etagAndExpirationDateInThePast() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("ETag: v1")
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    assertThat(conditionalRequest.getHeader("If-None-Match")).isEqualTo("v1");
-    assertThat(conditionalRequest.getHeader("If-Modified-Since")).isNull();
-  }
-
-  @Test public void etagAndExpirationDateInTheFuture() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("ETag: v1")
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-  }
-
-  @Test public void cacheControlNoCache() throws Exception {
-    assertNotCached(new MockResponse()
-        .addHeader("Cache-Control: no-cache"));
-  }
-
-  @Test public void cacheControlNoCacheAndExpirationDateInTheFuture() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: no-cache"));
-    assertThat(conditionalRequest.getHeader("If-Modified-Since")).isEqualTo(
-        lastModifiedDate);
-  }
-
-  @Test public void pragmaNoCache() throws Exception {
-    assertNotCached(new MockResponse()
-        .addHeader("Pragma: no-cache"));
-  }
-
-  @Test public void pragmaNoCacheAndExpirationDateInTheFuture() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("Pragma: no-cache"));
-    assertThat(conditionalRequest.getHeader("If-Modified-Since")).isEqualTo(
-        lastModifiedDate);
-  }
-
-  @Test public void cacheControlNoStore() throws Exception {
-    assertNotCached(new MockResponse()
-        .addHeader("Cache-Control: no-store"));
-  }
-
-  @Test public void cacheControlNoStoreAndExpirationDateInTheFuture() throws Exception {
-    assertNotCached(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: no-store"));
-  }
-
-  @Test public void partialRangeResponsesDoNotCorruptCache() throws Exception {
-    // 1. Request a range.
-    // 2. Request a full document, expecting a cache miss.
-    server.enqueue(new MockResponse()
-        .setBody("AA")
-        .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("Content-Range: bytes 1000-1001/2000"));
-    server.enqueue(new MockResponse()
-        .setBody("BB"));
-
-    HttpUrl url = server.url("/");
-
-    Request request = new Request.Builder()
-        .url(url)
-        .header("Range", "bytes=1000-1001")
-        .build();
-    Response range = client.newCall(request).execute();
-    assertThat(range.body().string()).isEqualTo("AA");
-
-    assertThat(get(url).body().string()).isEqualTo("BB");
-  }
-
-  /**
-   * When the server returns a full response body we will store it and return it regardless of what
-   * its Last-Modified date is. This behavior was different prior to OkHttp 3.5 when we would prefer
-   * the response with the later Last-Modified date.
-   *
-   * https://github.com/square/okhttp/issues/2886
-   */
-  @Test public void serverReturnsDocumentOlderThanCache() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-        .setBody("B")
-        .addHeader("Last-Modified: " + formatDate(-4, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    HttpUrl url = server.url("/");
-
-    assertThat(get(url).body().string()).isEqualTo("A");
-    assertThat(get(url).body().string()).isEqualTo("B");
-    assertThat(get(url).body().string()).isEqualTo("B");
-  }
-
-  @Test public void clientSideNoStore() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("B"));
-
-    Request request1 = new Request.Builder()
-        .url(server.url("/"))
-        .cacheControl(new CacheControl.Builder().noStore().build())
-        .build();
-    Response response1 = client.newCall(request1).execute();
-    assertThat(response1.body().string()).isEqualTo("A");
-
-    Request request2 = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Response response2 = client.newCall(request2).execute();
-    assertThat(response2.body().string()).isEqualTo("B");
-  }
-
-  @Test public void nonIdentityEncodingAndConditionalCache() throws Exception {
-    assertNonIdentityEncodingCached(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-  }
-
-  @Test public void nonIdentityEncodingAndFullCache() throws Exception {
-    assertNonIdentityEncodingCached(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-  }
-
-  private void assertNonIdentityEncodingCached(MockResponse response) throws Exception {
-    server.enqueue(response
-        .setBody(gzip("ABCABCABC"))
-        .addHeader("Content-Encoding: gzip"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    // At least three request/response pairs are required because after the first request is cached
-    // a different execution path might be taken. Thus modifications to the cache applied during
-    // the second request might not be visible until another request is performed.
-    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
-    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
-    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
-  }
-
-  @Test public void previouslyNotGzippedContentIsNotModifiedAndSpecifiesGzipEncoding() throws Exception {
-    server.enqueue(new MockResponse()
-            .setBody("ABCABCABC")
-            .addHeader("Content-Type: text/plain")
-            .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-            .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-            .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
-            .addHeader("Content-Type: text/plain")
-            .addHeader("Content-Encoding: gzip"));
-    server.enqueue(new MockResponse()
-            .setBody("DEFDEFDEF"));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
-    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
-    assertThat(get(server.url("/")).body().string()).isEqualTo("DEFDEFDEF");
-  }
-
-  @Test public void changedGzippedContentIsNotModifiedAndSpecifiesNewEncoding() throws Exception {
-    server.enqueue(new MockResponse()
-            .setBody(gzip("ABCABCABC"))
-            .addHeader("Content-Type: text/plain")
-            .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-            .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS))
-            .addHeader("Content-Encoding: gzip"));
-    server.enqueue(new MockResponse()
-            .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
-            .addHeader("Content-Type: text/plain")
-            .addHeader("Content-Encoding: identity"));
-    server.enqueue(new MockResponse()
-            .setBody("DEFDEFDEF"));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
-    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
-    assertThat(get(server.url("/")).body().string()).isEqualTo("DEFDEFDEF");
-  }
-
-  @Test public void notModifiedSpecifiesEncoding() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody(gzip("ABCABCABC"))
-        .addHeader("Content-Encoding: gzip")
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
-        .addHeader("Content-Encoding: gzip"));
-    server.enqueue(new MockResponse()
-        .setBody("DEFDEFDEF"));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
-    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
-    assertThat(get(server.url("/")).body().string()).isEqualTo("DEFDEFDEF");
-  }
-
-  /** https://github.com/square/okhttp/issues/947 */
-  @Test public void gzipAndVaryOnAcceptEncoding() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody(gzip("ABCABCABC"))
-        .addHeader("Content-Encoding: gzip")
-        .addHeader("Vary: Accept-Encoding")
-        .addHeader("Cache-Control: max-age=60"));
-    server.enqueue(new MockResponse()
-        .setBody("FAIL"));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
-    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
-  }
-
-  @Test public void conditionalCacheHitIsNotDoublePooled() throws Exception {
-    TestUtil.ensureAllConnectionsReleased(client);
-
-    server.enqueue(new MockResponse()
-        .addHeader("ETag: v1")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .clearHeaders()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-    assertThat(client.connectionPool().idleConnectionCount()).isEqualTo(1);
-  }
-
-  @Test public void expiresDateBeforeModifiedDate() throws Exception {
-    assertConditionallyCached(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-2, TimeUnit.HOURS)));
-  }
-
-  @Test public void requestMaxAge() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Cache-Control", "max-age=30")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("B");
-  }
-
-  @Test public void requestMinFresh() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Cache-Control", "min-fresh=120")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("B");
-  }
-
-  @Test public void requestMaxStale() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=120")
-        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Cache-Control", "max-stale=180")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("A");
-    assertThat(response.header("Warning")).isEqualTo(
-        "110 HttpURLConnection \"Response is stale\"");
-  }
-
-  @Test public void requestMaxStaleDirectiveWithNoValue() throws IOException {
-    // Add a stale response to the cache.
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=120")
-        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-
-    // With max-stale, we'll return that stale response.
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Cache-Control", "max-stale")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("A");
-    assertThat(response.header("Warning")).isEqualTo(
-        "110 HttpURLConnection \"Response is stale\"");
-  }
-
-  @Test public void requestMaxStaleNotHonoredWithMustRevalidate() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=120, must-revalidate")
-        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Cache-Control", "max-stale=180")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("B");
-  }
-
-  @Test public void requestOnlyIfCachedWithNoResponseCached() throws IOException {
-    // (no responses enqueued)
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Cache-Control", "only-if-cached")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().source().exhausted()).isTrue();
-    assertThat(response.code()).isEqualTo(504);
-    assertThat(cache.requestCount()).isEqualTo(1);
-    assertThat(cache.networkCount()).isEqualTo(0);
-    assertThat(cache.hitCount()).isEqualTo(0);
-  }
-
-  @Test public void requestOnlyIfCachedWithFullResponseCached() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Cache-Control", "only-if-cached")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("A");
-    assertThat(cache.requestCount()).isEqualTo(2);
-    assertThat(cache.networkCount()).isEqualTo(1);
-    assertThat(cache.hitCount()).isEqualTo(1);
-  }
-
-  @Test public void requestOnlyIfCachedWithConditionalResponseCached() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES)));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Cache-Control", "only-if-cached")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().source().exhausted()).isTrue();
-    assertThat(response.code()).isEqualTo(504);
-    assertThat(cache.requestCount()).isEqualTo(2);
-    assertThat(cache.networkCount()).isEqualTo(1);
-    assertThat(cache.hitCount()).isEqualTo(0);
-  }
-
-  @Test public void requestOnlyIfCachedWithUnhelpfulResponseCached() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A"));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Cache-Control", "only-if-cached")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().source().exhausted()).isTrue();
-    assertThat(response.code()).isEqualTo(504);
-    assertThat(cache.requestCount()).isEqualTo(2);
-    assertThat(cache.networkCount()).isEqualTo(1);
-    assertThat(cache.hitCount()).isEqualTo(0);
-  }
-
-  @Test public void requestCacheControlNoCache() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-        .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/");
-    assertThat(get(url).body().string()).isEqualTo("A");
-    Request request = new Request.Builder()
-        .url(url)
-        .header("Cache-Control", "no-cache")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("B");
-  }
-
-  @Test public void requestPragmaNoCache() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-        .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/");
-    assertThat(get(url).body().string()).isEqualTo("A");
-    Request request = new Request.Builder()
-        .url(url)
-        .header("Pragma", "no-cache")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("B");
-  }
-
-  @Test public void clientSuppliedIfModifiedSinceWithCachedResult() throws Exception {
-    MockResponse response = new MockResponse()
-        .addHeader("ETag: v3")
-        .addHeader("Cache-Control: max-age=0");
-    String ifModifiedSinceDate = formatDate(-24, TimeUnit.HOURS);
-    RecordedRequest request =
-        assertClientSuppliedCondition(response, "If-Modified-Since", ifModifiedSinceDate);
-    assertThat(request.getHeader("If-Modified-Since")).isEqualTo(ifModifiedSinceDate);
-    assertThat(request.getHeader("If-None-Match")).isNull();
-  }
-
-  @Test public void clientSuppliedIfNoneMatchSinceWithCachedResult() throws Exception {
-    String lastModifiedDate = formatDate(-3, TimeUnit.MINUTES);
-    MockResponse response = new MockResponse()
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
-        .addHeader("Cache-Control: max-age=0");
-    RecordedRequest request = assertClientSuppliedCondition(response, "If-None-Match", "v1");
-    assertThat(request.getHeader("If-None-Match")).isEqualTo("v1");
-    assertThat(request.getHeader("If-Modified-Since")).isNull();
-  }
-
-  private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String conditionName,
-      String conditionValue) throws Exception {
-    server.enqueue(seed.setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    HttpUrl url = server.url("/");
-    assertThat(get(url).body().string()).isEqualTo("A");
-
-    Request request = new Request.Builder()
-        .url(url)
-        .header(conditionName, conditionValue)
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.code()).isEqualTo(HttpURLConnection.HTTP_NOT_MODIFIED);
-    assertThat(response.body().string()).isEqualTo("");
-
-    server.takeRequest(); // seed
-    return server.takeRequest();
-  }
-
-  /**
-   * For Last-Modified and Date headers, we should echo the date back in the exact format we were
-   * served.
-   */
-  @Test public void retainServedDateFormat() throws Exception {
-    // Serve a response with a non-standard date format that OkHttp supports.
-    Date lastModifiedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-1));
-    Date servedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-2));
-    DateFormat dateFormat = new SimpleDateFormat("EEE dd-MMM-yyyy HH:mm:ss z", Locale.US);
-    dateFormat.setTimeZone(TimeZone.getTimeZone("America/New_York"));
-    String lastModifiedString = dateFormat.format(lastModifiedDate);
-    String servedString = dateFormat.format(servedDate);
-
-    // This response should be conditionally cached.
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + lastModifiedString)
-        .addHeader("Expires: " + servedString)
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-
-    // The first request has no conditions.
-    RecordedRequest request1 = server.takeRequest();
-    assertThat(request1.getHeader("If-Modified-Since")).isNull();
-
-    // The 2nd request uses the server's date format.
-    RecordedRequest request2 = server.takeRequest();
-    assertThat(request2.getHeader("If-Modified-Since")).isEqualTo(lastModifiedString);
-  }
-
-  @Test public void clientSuppliedConditionWithoutCachedResult() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("If-Modified-Since", formatDate(-24, TimeUnit.HOURS))
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.code()).isEqualTo(HttpURLConnection.HTTP_NOT_MODIFIED);
-    assertThat(response.body().string()).isEqualTo("");
-  }
-
-  @Test public void authorizationRequestFullyCached() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/");
-    Request request = new Request.Builder()
-        .url(url)
-        .header("Authorization", "password")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("A");
-    assertThat(get(url).body().string()).isEqualTo("A");
-  }
-
-  @Test public void contentLocationDoesNotPopulateCache() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Content-Location: /bar")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertThat(get(server.url("/foo")).body().string()).isEqualTo("A");
-    assertThat(get(server.url("/bar")).body().string()).isEqualTo("B");
-  }
-
-  @Test public void connectionIsReturnedToPoolAfterConditionalSuccess() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertThat(get(server.url("/a")).body().string()).isEqualTo("A");
-    assertThat(get(server.url("/a")).body().string()).isEqualTo("A");
-    assertThat(get(server.url("/b")).body().string()).isEqualTo("B");
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
-  }
-
-  @Test public void statisticsConditionalCacheMiss() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-    server.enqueue(new MockResponse()
-        .setBody("C"));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-    assertThat(cache.requestCount()).isEqualTo(1);
-    assertThat(cache.networkCount()).isEqualTo(1);
-    assertThat(cache.hitCount()).isEqualTo(0);
-    assertThat(get(server.url("/")).body().string()).isEqualTo("B");
-    assertThat(get(server.url("/")).body().string()).isEqualTo("C");
-    assertThat(cache.requestCount()).isEqualTo(3);
-    assertThat(cache.networkCount()).isEqualTo(3);
-    assertThat(cache.hitCount()).isEqualTo(0);
-  }
-
-  @Test public void statisticsConditionalCacheHit() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-    assertThat(cache.requestCount()).isEqualTo(1);
-    assertThat(cache.networkCount()).isEqualTo(1);
-    assertThat(cache.hitCount()).isEqualTo(0);
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-    assertThat(cache.requestCount()).isEqualTo(3);
-    assertThat(cache.networkCount()).isEqualTo(3);
-    assertThat(cache.hitCount()).isEqualTo(2);
-  }
-
-  @Test public void statisticsFullCacheHit() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-    assertThat(cache.requestCount()).isEqualTo(1);
-    assertThat(cache.networkCount()).isEqualTo(1);
-    assertThat(cache.hitCount()).isEqualTo(0);
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-    assertThat(cache.requestCount()).isEqualTo(3);
-    assertThat(cache.networkCount()).isEqualTo(1);
-    assertThat(cache.hitCount()).isEqualTo(2);
-  }
-
-  @Test public void varyMatchesChangedRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/");
-    Request frRequest = new Request.Builder()
-        .url(url)
-        .header("Accept-Language", "fr-CA")
-        .build();
-    Response frResponse = client.newCall(frRequest).execute();
-    assertThat(frResponse.body().string()).isEqualTo("A");
-
-    Request enRequest = new Request.Builder()
-        .url(url)
-        .header("Accept-Language", "en-US")
-        .build();
-    Response enResponse = client.newCall(enRequest).execute();
-    assertThat(enResponse.body().string()).isEqualTo("B");
-  }
-
-  @Test public void varyMatchesUnchangedRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/");
-    Request request = new Request.Builder()
-        .url(url)
-        .header("Accept-Language", "fr-CA")
-        .build();
-    Response response1 = client.newCall(request).execute();
-    assertThat(response1.body().string()).isEqualTo("A");
-    Request request1 = new Request.Builder()
-        .url(url)
-        .header("Accept-Language", "fr-CA")
-        .build();
-    Response response2 = client.newCall(request1).execute();
-    assertThat(response2.body().string()).isEqualTo("A");
-  }
-
-  @Test public void varyMatchesAbsentRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Foo")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-  }
-
-  @Test public void varyMatchesAddedRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Foo")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-    Request request = new Request.Builder()
-        .url(server.url("/")).header("Foo", "bar")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("B");
-  }
-
-  @Test public void varyMatchesRemovedRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Foo")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/")).header("Foo", "bar")
-        .build();
-    Response fooresponse = client.newCall(request).execute();
-    assertThat(fooresponse.body().string()).isEqualTo("A");
-    assertThat(get(server.url("/")).body().string()).isEqualTo("B");
-  }
-
-  @Test public void varyFieldsAreCaseInsensitive() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: ACCEPT-LANGUAGE")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/");
-    Request request = new Request.Builder()
-        .url(url)
-        .header("Accept-Language", "fr-CA")
-        .build();
-    Response response1 = client.newCall(request).execute();
-    assertThat(response1.body().string()).isEqualTo("A");
-    Request request1 = new Request.Builder()
-        .url(url)
-        .header("accept-language", "fr-CA")
-        .build();
-    Response response2 = client.newCall(request1).execute();
-    assertThat(response2.body().string()).isEqualTo("A");
-  }
-
-  @Test public void varyMultipleFieldsWithMatch() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language, Accept-Charset")
-        .addHeader("Vary: Accept-Encoding")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/");
-    Request request = new Request.Builder()
-        .url(url)
-        .header("Accept-Language", "fr-CA")
-        .header("Accept-Charset", "UTF-8")
-        .header("Accept-Encoding", "identity")
-        .build();
-    Response response1 = client.newCall(request).execute();
-    assertThat(response1.body().string()).isEqualTo("A");
-    Request request1 = new Request.Builder()
-        .url(url)
-        .header("Accept-Language", "fr-CA")
-        .header("Accept-Charset", "UTF-8")
-        .header("Accept-Encoding", "identity")
-        .build();
-    Response response2 = client.newCall(request1).execute();
-    assertThat(response2.body().string()).isEqualTo("A");
-  }
-
-  @Test public void varyMultipleFieldsWithNoMatch() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language, Accept-Charset")
-        .addHeader("Vary: Accept-Encoding")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/");
-    Request frRequest = new Request.Builder()
-        .url(url)
-        .header("Accept-Language", "fr-CA")
-        .header("Accept-Charset", "UTF-8")
-        .header("Accept-Encoding", "identity")
-        .build();
-    Response frResponse = client.newCall(frRequest).execute();
-    assertThat(frResponse.body().string()).isEqualTo("A");
-    Request enRequest = new Request.Builder()
-        .url(url)
-        .header("Accept-Language", "en-CA")
-        .header("Accept-Charset", "UTF-8")
-        .header("Accept-Encoding", "identity")
-        .build();
-    Response enResponse = client.newCall(enRequest).execute();
-    assertThat(enResponse.body().string()).isEqualTo("B");
-  }
-
-  @Test public void varyMultipleFieldValuesWithMatch() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/");
-    Request request1 = new Request.Builder()
-        .url(url)
-        .addHeader("Accept-Language", "fr-CA, fr-FR")
-        .addHeader("Accept-Language", "en-US")
-        .build();
-    Response response1 = client.newCall(request1).execute();
-    assertThat(response1.body().string()).isEqualTo("A");
-
-    Request request2 = new Request.Builder()
-        .url(url)
-        .addHeader("Accept-Language", "fr-CA, fr-FR")
-        .addHeader("Accept-Language", "en-US")
-        .build();
-    Response response2 = client.newCall(request2).execute();
-    assertThat(response2.body().string()).isEqualTo("A");
-  }
-
-  @Test public void varyMultipleFieldValuesWithNoMatch() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/");
-    Request request1 = new Request.Builder()
-        .url(url)
-        .addHeader("Accept-Language", "fr-CA, fr-FR")
-        .addHeader("Accept-Language", "en-US")
-        .build();
-    Response response1 = client.newCall(request1).execute();
-    assertThat(response1.body().string()).isEqualTo("A");
-
-    Request request2 = new Request.Builder()
-        .url(url)
-        .addHeader("Accept-Language", "fr-CA")
-        .addHeader("Accept-Language", "en-US")
-        .build();
-    Response response2 = client.newCall(request2).execute();
-    assertThat(response2.body().string()).isEqualTo("B");
-  }
-
-  @Test public void varyAsterisk() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: *")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-    assertThat(get(server.url("/")).body().string()).isEqualTo("B");
-  }
-
-  @Test public void varyAndHttps() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
-        .build();
-
-    HttpUrl url = server.url("/");
-    Request request1 = new Request.Builder()
-        .url(url)
-        .header("Accept-Language", "en-US")
-        .build();
-    Response response1 = client.newCall(request1).execute();
-    assertThat(response1.body().string()).isEqualTo("A");
-
-    Request request2 = new Request.Builder()
-        .url(url)
-        .header("Accept-Language", "en-US")
-        .build();
-    Response response2 = client.newCall(request2).execute();
-    assertThat(response2.body().string()).isEqualTo("A");
-  }
-
-  @Test public void cachePlusCookies() throws Exception {
-    RecordingCookieJar cookieJar = new RecordingCookieJar();
-    client = client.newBuilder()
-        .cookieJar(cookieJar)
-        .build();
-
-    server.enqueue(new MockResponse()
-        .addHeader("Set-Cookie: a=FIRST")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .addHeader("Set-Cookie: a=SECOND")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    HttpUrl url = server.url("/");
-    assertThat(get(url).body().string()).isEqualTo("A");
-    cookieJar.assertResponseCookies("a=FIRST; path=/");
-    assertThat(get(url).body().string()).isEqualTo("A");
-    cookieJar.assertResponseCookies("a=SECOND; path=/");
-  }
-
-  @Test public void getHeadersReturnsNetworkEndToEndHeaders() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Allow: GET, HEAD")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .addHeader("Allow: GET, HEAD, PUT")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    Response response1 = get(server.url("/"));
-    assertThat(response1.body().string()).isEqualTo("A");
-    assertThat(response1.header("Allow")).isEqualTo("GET, HEAD");
-
-    Response response2 = get(server.url("/"));
-    assertThat(response2.body().string()).isEqualTo("A");
-    assertThat(response2.header("Allow")).isEqualTo("GET, HEAD, PUT");
-  }
-
-  @Test public void getHeadersReturnsCachedHopByHopHeaders() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Transfer-Encoding: identity")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .addHeader("Transfer-Encoding: none")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    Response response1 = get(server.url("/"));
-    assertThat(response1.body().string()).isEqualTo("A");
-    assertThat(response1.header("Transfer-Encoding")).isEqualTo("identity");
-
-    Response response2 = get(server.url("/"));
-    assertThat(response2.body().string()).isEqualTo("A");
-    assertThat(response2.header("Transfer-Encoding")).isEqualTo("identity");
-  }
-
-  @Test public void getHeadersDeletesCached100LevelWarnings() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Warning: 199 test danger")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    Response response1 = get(server.url("/"));
-    assertThat(response1.body().string()).isEqualTo("A");
-    assertThat(response1.header("Warning")).isEqualTo("199 test danger");
-
-    Response response2 = get(server.url("/"));
-    assertThat(response2.body().string()).isEqualTo("A");
-    assertThat(response2.header("Warning")).isNull();
-  }
-
-  @Test public void getHeadersRetainsCached200LevelWarnings() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Warning: 299 test danger")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    Response response1 = get(server.url("/"));
-    assertThat(response1.body().string()).isEqualTo("A");
-    assertThat(response1.header("Warning")).isEqualTo("299 test danger");
-
-    Response response2 = get(server.url("/"));
-    assertThat(response2.body().string()).isEqualTo("A");
-    assertThat(response2.header("Warning")).isEqualTo("299 test danger");
-  }
-
-  @Test public void doNotCachePartialResponse() throws Exception {
-    assertNotCached(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
-        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
-        .addHeader("Content-Range: bytes 100-100/200")
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void conditionalHitUpdatesCache() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(0, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Allow: GET, HEAD")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    // A cache miss writes the cache.
-    long t0 = System.currentTimeMillis();
-    Response response1 = get(server.url("/a"));
-    assertThat(response1.body().string()).isEqualTo("A");
-    assertThat(response1.header("Allow")).isNull();
-    assertThat((double) (response1.receivedResponseAtMillis() - t0)).isCloseTo(
-        (double) 0, offset(250.0));
-
-    // A conditional cache hit updates the cache.
-    Thread.sleep(500); // Make sure t0 and t1 are distinct.
-    long t1 = System.currentTimeMillis();
-    Response response2 = get(server.url("/a"));
-    assertThat(response2.code()).isEqualTo(HttpURLConnection.HTTP_OK);
-    assertThat(response2.body().string()).isEqualTo("A");
-    assertThat(response2.header("Allow")).isEqualTo("GET, HEAD");
-    assertThat((double) (response2.receivedResponseAtMillis() - t1)).isCloseTo(
-        (double) 0, offset(250.0));
-
-    // A full cache hit reads the cache.
-    Thread.sleep(500); // Make sure t1 and t2 are distinct.
-    long t2 = System.currentTimeMillis();
-    Response response3 = get(server.url("/a"));
-    assertThat(response3.body().string()).isEqualTo("A");
-    assertThat(response3.header("Allow")).isEqualTo("GET, HEAD");
-    assertThat((double) (response3.receivedResponseAtMillis() - t1)).isCloseTo(
-        (double) 0, offset(250.0));
-
-    assertThat(server.getRequestCount()).isEqualTo(2);
-  }
-
-  @Test public void responseSourceHeaderCached() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-    Request request = new Request.Builder()
-        .url(server.url("/")).header("Cache-Control", "only-if-cached")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("A");
-  }
-
-  @Test public void responseSourceHeaderConditionalCacheFetched() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(-31, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse()
-        .setBody("B")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-    Response response = get(server.url("/"));
-    assertThat(response.body().string()).isEqualTo("B");
-  }
-
-  @Test public void responseSourceHeaderConditionalCacheNotFetched() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=0")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse()
-        .setResponseCode(304));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-    Response response = get(server.url("/"));
-    assertThat(response.body().string()).isEqualTo("A");
-  }
-
-  @Test public void responseSourceHeaderFetched() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A"));
-
-    Response response = get(server.url("/"));
-    assertThat(response.body().string()).isEqualTo("A");
-  }
-
-  @Test public void emptyResponseHeaderNameFromCacheIsLenient() throws Exception {
-    Headers.Builder headers = new Headers.Builder()
-        .add("Cache-Control: max-age=120");
-    Internal.instance.addLenient(headers, ": A");
-    server.enqueue(new MockResponse()
-        .setHeaders(headers.build())
-        .setBody("body"));
-
-    Response response = get(server.url("/"));
-    assertThat(response.header("")).isEqualTo("A");
-    assertThat(response.body().string()).isEqualTo("body");
-  }
-
-  /**
-   * Old implementations of OkHttp's response cache wrote header fields like ":status: 200 OK". This
-   * broke our cached response parser because it split on the first colon. This regression test
-   * exists to help us read these old bad cache entries.
-   *
-   * https://github.com/square/okhttp/issues/227
-   */
-  @Test public void testGoldenCacheResponse() throws Exception {
-    cache.close();
-    server.enqueue(new MockResponse()
-        .clearHeaders()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    HttpUrl url = server.url("/");
-    String urlKey = Cache.key(url);
-    String entryMetadata = ""
-        + "" + url + "\n"
-        + "GET\n"
-        + "0\n"
-        + "HTTP/1.1 200 OK\n"
-        + "7\n"
-        + ":status: 200 OK\n"
-        + ":version: HTTP/1.1\n"
-        + "etag: foo\n"
-        + "content-length: 3\n"
-        + "OkHttp-Received-Millis: " + System.currentTimeMillis() + "\n"
-        + "X-Android-Response-Source: NETWORK 200\n"
-        + "OkHttp-Sent-Millis: " + System.currentTimeMillis() + "\n"
-        + "\n"
-        + "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\n"
-        + "1\n"
-        + "MIIBpDCCAQ2gAwIBAgIBATANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDEw1qd2lsc29uLmxvY2FsMB4XDTEzMDgy"
-        + "OTA1MDE1OVoXDTEzMDgzMDA1MDE1OVowGDEWMBQGA1UEAxMNandpbHNvbi5sb2NhbDCBnzANBgkqhkiG9w0BAQEF"
-        + "AAOBjQAwgYkCgYEAlFW+rGo/YikCcRghOyKkJanmVmJSce/p2/jH1QvNIFKizZdh8AKNwojt3ywRWaDULA/RlCUc"
-        + "ltF3HGNsCyjQI/+Lf40x7JpxXF8oim1E6EtDoYtGWAseelawus3IQ13nmo6nWzfyCA55KhAWf4VipelEy8DjcuFK"
-        + "v6L0xwXnI0ECAwEAATANBgkqhkiG9w0BAQsFAAOBgQAuluNyPo1HksU3+Mr/PyRQIQS4BI7pRXN8mcejXmqyscdP"
-        + "7S6J21FBFeRR8/XNjVOp4HT9uSc2hrRtTEHEZCmpyoxixbnM706ikTmC7SN/GgM+SmcoJ1ipJcNcl8N0X6zym4dm"
-        + "yFfXKHu2PkTo7QFdpOJFvP3lIigcSZXozfmEDg==\n"
-        + "-1\n";
-    String entryBody = "abc";
-    String journalBody = ""
-        + "libcore.io.DiskLruCache\n"
-        + "1\n"
-        + "201105\n"
-        + "2\n"
-        + "\n"
-        + "CLEAN " + urlKey + " " + entryMetadata.length() + " " + entryBody.length() + "\n";
-    writeFile(cache.directory(), urlKey + ".0", entryMetadata);
-    writeFile(cache.directory(), urlKey + ".1", entryBody);
-    writeFile(cache.directory(), "journal", journalBody);
-    cache = new Cache(cache.directory(), Integer.MAX_VALUE, fileSystem);
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-
-    Response response = get(url);
-    assertThat(response.body().string()).isEqualTo(entryBody);
-    assertThat(response.header("Content-Length")).isEqualTo("3");
-    assertThat(response.header("etag")).isEqualTo("foo");
-  }
-
-  /** Exercise the cache format in OkHttp 2.7 and all earlier releases. */
-  @Test public void testGoldenCacheHttpsResponseOkHttp27() throws Exception {
-    HttpUrl url = server.url("/");
-    String urlKey = Cache.key(url);
-    String prefix = Platform.get().getPrefix();
-    String entryMetadata = ""
-        + "" + url + "\n"
-        + "GET\n"
-        + "0\n"
-        + "HTTP/1.1 200 OK\n"
-        + "4\n"
-        + "Content-Length: 3\n"
-        + prefix + "-Received-Millis: " + System.currentTimeMillis() + "\n"
-        + prefix + "-Sent-Millis: " + System.currentTimeMillis() + "\n"
-        + "Cache-Control: max-age=60\n"
-        + "\n"
-        + "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\n"
-        + "1\n"
-        + "MIIBnDCCAQWgAwIBAgIBATANBgkqhkiG9w0BAQsFADAUMRIwEAYDVQQDEwlsb2NhbGhvc3QwHhcNMTUxMjIyMDEx"
-        + "MTQwWhcNMTUxMjIzMDExMTQwWjAUMRIwEAYDVQQDEwlsb2NhbGhvc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJ"
-        + "AoGBAJTn2Dh8xYmegvpOSmsKb2Os6Cxf1L4fYbnHr/turInUD5r1P7ZAuxurY880q3GT5bUDoirS3IfucddrT1Ac"
-        + "AmUzEmk/FDjggiP8DlxFkY/XwXBlhRDVIp/mRuASPMGInckc0ZaixOkRFyrxADj+r1eaSmXCIvV5yTY6IaIokLj1"
-        + "AgMBAAEwDQYJKoZIhvcNAQELBQADgYEAFblnedqtfRqI9j2WDyPPoG0NTZf9xwjeUu+ju+Ktty8u9k7Lgrrd/DH2"
-        + "mQEtBD1Ctvp91MJfAClNg3faZzwClUyu5pd0QXRZEUwSwZQNen2QWDHRlVsItclBJ4t+AJLqTbwofWi4m4K8REOl"
-        + "593hD55E4+lY22JZiVQyjsQhe6I=\n"
-        + "0\n";
-    String entryBody = "abc";
-    String journalBody = ""
-        + "libcore.io.DiskLruCache\n"
-        + "1\n"
-        + "201105\n"
-        + "2\n"
-        + "\n"
-        + "DIRTY " + urlKey + "\n"
-        + "CLEAN " + urlKey + " " + entryMetadata.length() + " " + entryBody.length() + "\n";
-    writeFile(cache.directory(), urlKey + ".0", entryMetadata);
-    writeFile(cache.directory(), urlKey + ".1", entryBody);
-    writeFile(cache.directory(), "journal", journalBody);
-    cache.close();
-    cache = new Cache(cache.directory(), Integer.MAX_VALUE, fileSystem);
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-
-    Response response = get(url);
-    assertThat(response.body().string()).isEqualTo(entryBody);
-    assertThat(response.header("Content-Length")).isEqualTo("3");
-  }
-
-  /** The TLS version is present in OkHttp 3.0 and beyond. */
-  @Test public void testGoldenCacheHttpsResponseOkHttp30() throws Exception {
-    HttpUrl url = server.url("/");
-    String urlKey = Cache.key(url);
-    String prefix = Platform.get().getPrefix();
-    String entryMetadata = ""
-        + "" + url + "\n"
-        + "GET\n"
-        + "0\n"
-        + "HTTP/1.1 200 OK\n"
-        + "4\n"
-        + "Content-Length: 3\n"
-        + prefix + "-Received-Millis: " + System.currentTimeMillis() + "\n"
-        + prefix + "-Sent-Millis: " + System.currentTimeMillis() + "\n"
-        + "Cache-Control: max-age=60\n"
-        + "\n"
-        + "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\n"
-        + "1\n"
-        + "MIIBnDCCAQWgAwIBAgIBATANBgkqhkiG9w0BAQsFADAUMRIwEAYDVQQDEwlsb2NhbGhvc3QwHhcNMTUxMjIyMDEx"
-        + "MTQwWhcNMTUxMjIzMDExMTQwWjAUMRIwEAYDVQQDEwlsb2NhbGhvc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJ"
-        + "AoGBAJTn2Dh8xYmegvpOSmsKb2Os6Cxf1L4fYbnHr/turInUD5r1P7ZAuxurY880q3GT5bUDoirS3IfucddrT1Ac"
-        + "AmUzEmk/FDjggiP8DlxFkY/XwXBlhRDVIp/mRuASPMGInckc0ZaixOkRFyrxADj+r1eaSmXCIvV5yTY6IaIokLj1"
-        + "AgMBAAEwDQYJKoZIhvcNAQELBQADgYEAFblnedqtfRqI9j2WDyPPoG0NTZf9xwjeUu+ju+Ktty8u9k7Lgrrd/DH2"
-        + "mQEtBD1Ctvp91MJfAClNg3faZzwClUyu5pd0QXRZEUwSwZQNen2QWDHRlVsItclBJ4t+AJLqTbwofWi4m4K8REOl"
-        + "593hD55E4+lY22JZiVQyjsQhe6I=\n"
-        + "0\n"
-        + "TLSv1.2\n";
-    String entryBody = "abc";
-    String journalBody = ""
-        + "libcore.io.DiskLruCache\n"
-        + "1\n"
-        + "201105\n"
-        + "2\n"
-        + "\n"
-        + "DIRTY " + urlKey + "\n"
-        + "CLEAN " + urlKey + " " + entryMetadata.length() + " " + entryBody.length() + "\n";
-    writeFile(cache.directory(), urlKey + ".0", entryMetadata);
-    writeFile(cache.directory(), urlKey + ".1", entryBody);
-    writeFile(cache.directory(), "journal", journalBody);
-    cache.close();
-    cache = new Cache(cache.directory(), Integer.MAX_VALUE, fileSystem);
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-
-    Response response = get(url);
-    assertThat(response.body().string()).isEqualTo(entryBody);
-    assertThat(response.header("Content-Length")).isEqualTo("3");
-  }
-
-  @Test public void testGoldenCacheHttpResponseOkHttp30() throws Exception {
-    HttpUrl url = server.url("/");
-    String urlKey = Cache.key(url);
-    String prefix = Platform.get().getPrefix();
-    String entryMetadata = ""
-        + "" + url + "\n"
-        + "GET\n"
-        + "0\n"
-        + "HTTP/1.1 200 OK\n"
-        + "4\n"
-        + "Cache-Control: max-age=60\n"
-        + "Content-Length: 3\n"
-        + prefix + "-Received-Millis: " + System.currentTimeMillis() + "\n"
-        + prefix + "-Sent-Millis: " + System.currentTimeMillis() + "\n";
-    String entryBody = "abc";
-    String journalBody = ""
-        + "libcore.io.DiskLruCache\n"
-        + "1\n"
-        + "201105\n"
-        + "2\n"
-        + "\n"
-        + "DIRTY " + urlKey + "\n"
-        + "CLEAN " + urlKey + " " + entryMetadata.length() + " " + entryBody.length() + "\n";
-    writeFile(cache.directory(), urlKey + ".0", entryMetadata);
-    writeFile(cache.directory(), urlKey + ".1", entryBody);
-    writeFile(cache.directory(), "journal", journalBody);
-    cache.close();
-    cache = new Cache(cache.directory(), Integer.MAX_VALUE, fileSystem);
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-
-    Response response = get(url);
-    assertThat(response.body().string()).isEqualTo(entryBody);
-    assertThat(response.header("Content-Length")).isEqualTo("3");
-  }
-
-  @Test public void evictAll() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/");
-    assertThat(get(url).body().string()).isEqualTo("A");
-    client.cache().evictAll();
-    assertThat(client.cache().size()).isEqualTo(0);
-    assertThat(get(url).body().string()).isEqualTo("B");
-  }
-
-  @Test public void networkInterceptorInvokedForConditionalGet() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("ETag: v1")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    // Seed the cache.
-    HttpUrl url = server.url("/");
-    assertThat(get(url).body().string()).isEqualTo("A");
-
-    final AtomicReference<String> ifNoneMatch = new AtomicReference<>();
-    client = client.newBuilder()
-        .addNetworkInterceptor(chain -> {
-          ifNoneMatch.compareAndSet(null, chain.request().header("If-None-Match"));
-          return chain.proceed(chain.request());
-        })
-        .build();
-
-    // Confirm the value is cached and intercepted.
-    assertThat(get(url).body().string()).isEqualTo("A");
-    assertThat(ifNoneMatch.get()).isEqualTo("v1");
-  }
-
-  @Test public void networkInterceptorNotInvokedForFullyCached() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-
-    // Seed the cache.
-    HttpUrl url = server.url("/");
-    assertThat(get(url).body().string()).isEqualTo("A");
-
-    // Confirm the interceptor isn't exercised.
-    client = client.newBuilder()
-        .addNetworkInterceptor(chain -> { throw new AssertionError(); })
-        .build();
-    assertThat(get(url).body().string()).isEqualTo("A");
-  }
-
-  @Test public void iterateCache() throws Exception {
-    // Put some responses in the cache.
-    server.enqueue(new MockResponse()
-        .setBody("a"));
-    HttpUrl urlA = server.url("/a");
-    assertThat(get(urlA).body().string()).isEqualTo("a");
-
-    server.enqueue(new MockResponse()
-        .setBody("b"));
-    HttpUrl urlB = server.url("/b");
-    assertThat(get(urlB).body().string()).isEqualTo("b");
-
-    server.enqueue(new MockResponse()
-        .setBody("c"));
-    HttpUrl urlC = server.url("/c");
-    assertThat(get(urlC).body().string()).isEqualTo("c");
-
-    // Confirm the iterator returns those responses...
-    Iterator<String> i = cache.urls();
-    assertThat(i.hasNext()).isTrue();
-    assertThat(i.next()).isEqualTo(urlA.toString());
-    assertThat(i.hasNext()).isTrue();
-    assertThat(i.next()).isEqualTo(urlB.toString());
-    assertThat(i.hasNext()).isTrue();
-    assertThat(i.next()).isEqualTo(urlC.toString());
-
-    // ... and nothing else.
-    assertThat(i.hasNext()).isFalse();
-    try {
-      i.next();
-      fail();
-    } catch (NoSuchElementException expected) {
-    }
-  }
-
-  @Test public void iteratorRemoveFromCache() throws Exception {
-    // Put a response in the cache.
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("a"));
-    HttpUrl url = server.url("/a");
-    assertThat(get(url).body().string()).isEqualTo("a");
-
-    // Remove it with iteration.
-    Iterator<String> i = cache.urls();
-    assertThat(i.next()).isEqualTo(url.toString());
-    i.remove();
-
-    // Confirm that subsequent requests suffer a cache miss.
-    server.enqueue(new MockResponse()
-        .setBody("b"));
-    assertThat(get(url).body().string()).isEqualTo("b");
-  }
-
-  @Test public void iteratorRemoveWithoutNextThrows() throws Exception {
-    // Put a response in the cache.
-    server.enqueue(new MockResponse()
-        .setBody("a"));
-    HttpUrl url = server.url("/a");
-    assertThat(get(url).body().string()).isEqualTo("a");
-
-    Iterator<String> i = cache.urls();
-    assertThat(i.hasNext()).isTrue();
-    try {
-      i.remove();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void iteratorRemoveOncePerCallToNext() throws Exception {
-    // Put a response in the cache.
-    server.enqueue(new MockResponse()
-        .setBody("a"));
-    HttpUrl url = server.url("/a");
-    assertThat(get(url).body().string()).isEqualTo("a");
-
-    Iterator<String> i = cache.urls();
-    assertThat(i.next()).isEqualTo(url.toString());
-    i.remove();
-
-    // Too many calls to remove().
-    try {
-      i.remove();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void elementEvictedBetweenHasNextAndNext() throws Exception {
-    // Put a response in the cache.
-    server.enqueue(new MockResponse()
-        .setBody("a"));
-    HttpUrl url = server.url("/a");
-    assertThat(get(url).body().string()).isEqualTo("a");
-
-    // The URL will remain available if hasNext() returned true...
-    Iterator<String> i = cache.urls();
-    assertThat(i.hasNext()).isTrue();
-
-    // ...so even when we evict the element, we still get something back.
-    cache.evictAll();
-    assertThat(i.next()).isEqualTo(url.toString());
-
-    // Remove does nothing. But most importantly, it doesn't throw!
-    i.remove();
-  }
-
-  @Test public void elementEvictedBeforeHasNextIsOmitted() throws Exception {
-    // Put a response in the cache.
-    server.enqueue(new MockResponse()
-        .setBody("a"));
-    HttpUrl url = server.url("/a");
-    assertThat(get(url).body().string()).isEqualTo("a");
-
-    Iterator<String> i = cache.urls();
-    cache.evictAll();
-
-    // The URL was evicted before hasNext() made any promises.
-    assertThat(i.hasNext()).isFalse();
-    try {
-      i.next();
-      fail();
-    } catch (NoSuchElementException expected) {
-    }
-  }
-
-  /** Test https://github.com/square/okhttp/issues/1712. */
-  @Test public void conditionalMissUpdatesCache() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("ETag: v1")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.enqueue(new MockResponse()
-        .addHeader("ETag: v2")
-        .setBody("B"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    HttpUrl url = server.url("/");
-    assertThat(get(url).body().string()).isEqualTo("A");
-    assertThat(get(url).body().string()).isEqualTo("A");
-    assertThat(get(url).body().string()).isEqualTo("B");
-    assertThat(get(url).body().string()).isEqualTo("B");
-
-    assertThat(server.takeRequest().getHeader("If-None-Match")).isNull();
-    assertThat(server.takeRequest().getHeader("If-None-Match")).isEqualTo("v1");
-    assertThat(server.takeRequest().getHeader("If-None-Match")).isEqualTo("v1");
-    assertThat(server.takeRequest().getHeader("If-None-Match")).isEqualTo("v2");
-  }
-
-  @Test public void combinedCacheHeadersCanBeNonAscii() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .addHeaderLenient("Alpha", "Œ±")
-        .addHeaderLenient("Œ≤", "Beta")
-        .setBody("abcd"));
-    server.enqueue(new MockResponse()
-        .addHeader("Transfer-Encoding: none")
-        .addHeaderLenient("Gamma", "Œì")
-        .addHeaderLenient("Œî", "Delta")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    Response response1 = get(server.url("/"));
-    assertThat(response1.header("Alpha")).isEqualTo("Œ±");
-    assertThat(response1.header("Œ≤")).isEqualTo("Beta");
-    assertThat(response1.body().string()).isEqualTo("abcd");
-
-    Response response2 = get(server.url("/"));
-    assertThat(response2.header("Alpha")).isEqualTo("Œ±");
-    assertThat(response2.header("Œ≤")).isEqualTo("Beta");
-    assertThat(response2.header("Gamma")).isEqualTo("Œì");
-    assertThat(response2.header("Œî")).isEqualTo("Delta");
-    assertThat(response2.body().string()).isEqualTo("abcd");
-  }
-
-  @Test public void etagConditionCanBeNonAscii() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeaderLenient("Etag", "Œ±")
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("abcd"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    Response response1 = get(server.url("/"));
-    assertThat(response1.body().string()).isEqualTo("abcd");
-
-    Response response2 = get(server.url("/"));
-    assertThat(response2.body().string()).isEqualTo("abcd");
-
-    assertThat(server.takeRequest().getHeader("If-None-Match")).isNull();
-    assertThat(server.takeRequest().getHeader("If-None-Match")).isEqualTo("Œ±");
-  }
-
-  private Response get(HttpUrl url) throws IOException {
-    Request request = new Request.Builder()
-        .url(url)
-        .build();
-    return client.newCall(request).execute();
-  }
-
-  private void writeFile(File directory, String file, String content) throws IOException {
-    BufferedSink sink = Okio.buffer(fileSystem.sink(new File(directory, file)));
-    sink.writeUtf8(content);
-    sink.close();
-  }
-
-  /**
-   * @param delta the offset from the current date to use. Negative values yield dates in the past;
-   * positive values yield dates in the future.
-   */
-  private String formatDate(long delta, TimeUnit timeUnit) {
-    return formatDate(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
-  }
-
-  private String formatDate(Date date) {
-    DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
-    rfc1123.setTimeZone(TimeZone.getTimeZone("GMT"));
-    return rfc1123.format(date);
-  }
-
-  private void assertNotCached(MockResponse response) throws Exception {
-    server.enqueue(response.setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/");
-    assertThat(get(url).body().string()).isEqualTo("A");
-    assertThat(get(url).body().string()).isEqualTo("B");
-  }
-
-  /** @return the request with the conditional get headers. */
-  private RecordedRequest assertConditionallyCached(MockResponse response) throws Exception {
-    // scenario 1: condition succeeds
-    server.enqueue(response.setBody("A").setStatus("HTTP/1.1 200 A-OK"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    // scenario 2: condition fails
-    server.enqueue(response.setBody("B")
-        .setStatus("HTTP/1.1 200 B-OK"));
-    server.enqueue(new MockResponse()
-        .setStatus("HTTP/1.1 200 C-OK")
-        .setBody("C"));
-
-    HttpUrl valid = server.url("/valid");
-    Response response1 = get(valid);
-    assertThat(response1.body().string()).isEqualTo("A");
-    assertThat(response1.code()).isEqualTo(HttpURLConnection.HTTP_OK);
-    assertThat(response1.message()).isEqualTo("A-OK");
-    Response response2 = get(valid);
-    assertThat(response2.body().string()).isEqualTo("A");
-    assertThat(response2.code()).isEqualTo(HttpURLConnection.HTTP_OK);
-    assertThat(response2.message()).isEqualTo("A-OK");
-
-    HttpUrl invalid = server.url("/invalid");
-    Response response3 = get(invalid);
-    assertThat(response3.body().string()).isEqualTo("B");
-    assertThat(response3.code()).isEqualTo(HttpURLConnection.HTTP_OK);
-    assertThat(response3.message()).isEqualTo("B-OK");
-    Response response4 = get(invalid);
-    assertThat(response4.body().string()).isEqualTo("C");
-    assertThat(response4.code()).isEqualTo(HttpURLConnection.HTTP_OK);
-    assertThat(response4.message()).isEqualTo("C-OK");
-
-    server.takeRequest(); // regular get
-    return server.takeRequest(); // conditional get
-  }
-
-  @Test public void immutableIsCached() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control", "immutable, max-age=10")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/");
-    assertThat(get(url).body().string()).isEqualTo("A");
-    assertThat(get(url).body().string()).isEqualTo("A");
-  }
-
-  @Test public void immutableIsCachedAfterMultipleCalls() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control", "immutable, max-age=10")
-        .setBody("B"));
-    server.enqueue(new MockResponse()
-        .setBody("C"));
-
-    HttpUrl url = server.url("/");
-    assertThat(get(url).body().string()).isEqualTo("A");
-    assertThat(get(url).body().string()).isEqualTo("B");
-    assertThat(get(url).body().string()).isEqualTo("B");
-  }
-
-  @Test public void immutableIsNotCachedBeyondFreshnessLifetime() throws Exception {
-    //      last modified: 115 seconds ago
-    //             served:  15 seconds ago
-    //   default lifetime: (115 - 15) / 10 = 10 seconds
-    //            expires:  10 seconds from served date = 5 seconds ago
-    String lastModifiedDate = formatDate(-115, TimeUnit.SECONDS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("Cache-Control: immutable")
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Date: " + formatDate(-15, TimeUnit.SECONDS)));
-    assertThat(conditionalRequest.getHeader("If-Modified-Since")).isEqualTo(
-        lastModifiedDate);
-  }
-
-  private void assertFullyCached(MockResponse response) throws Exception {
-    server.enqueue(response.setBody("A"));
-    server.enqueue(response.setBody("B"));
-
-    HttpUrl url = server.url("/");
-    assertThat(get(url).body().string()).isEqualTo("A");
-    assertThat(get(url).body().string()).isEqualTo("A");
-  }
-
-  /**
-   * Shortens the body of {@code response} but not the corresponding headers. Only useful to test
-   * how clients respond to the premature conclusion of the HTTP body.
-   */
-  private MockResponse truncateViolently(MockResponse response, int numBytesToKeep) {
-    response.setSocketPolicy(DISCONNECT_AT_END);
-    Headers headers = response.getHeaders();
-    Buffer truncatedBody = new Buffer();
-    truncatedBody.write(response.getBody(), numBytesToKeep);
-    response.setBody(truncatedBody);
-    response.setHeaders(headers);
-    return response;
-  }
-
-  enum TransferKind {
-    CHUNKED {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
-        response.setChunkedBody(content, chunkSize);
-      }
-    },
-    FIXED_LENGTH {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
-        response.setBody(content);
-      }
-    },
-    END_OF_STREAM {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
-        response.setBody(content);
-        response.setSocketPolicy(DISCONNECT_AT_END);
-        response.removeHeader("Content-Length");
-      }
-    };
-
-    abstract void setBody(MockResponse response, Buffer content, int chunkSize) throws IOException;
-
-    void setBody(MockResponse response, String content, int chunkSize) throws IOException {
-      setBody(response, new Buffer().writeUtf8(content), chunkSize);
-    }
-  }
-
-  /** Returns a gzipped copy of {@code bytes}. */
-  public Buffer gzip(String data) throws IOException {
-    Buffer result = new Buffer();
-    BufferedSink sink = Okio.buffer(new GzipSink(result));
-    sink.writeUtf8(data);
-    sink.close();
-    return result;
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/CallTest.java b/okhttp-tests/src/test/java/okhttp3/CallTest.java
deleted file mode 100644
index 59411f8456..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/CallTest.java
+++ /dev/null
@@ -1,3851 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InterruptedIOException;
-import java.net.CookieManager;
-import java.net.HttpCookie;
-import java.net.HttpURLConnection;
-import java.net.InetAddress;
-import java.net.ProtocolException;
-import java.net.Proxy;
-import java.net.SocketTimeoutException;
-import java.net.UnknownHostException;
-import java.net.UnknownServiceException;
-import java.security.cert.Certificate;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Set;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.SynchronousQueue;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicReference;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import java.util.logging.SimpleFormatter;
-import javax.annotation.Nullable;
-import javax.net.ssl.SSLException;
-import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLProtocolException;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-import okhttp3.RecordingEventListener.CallEnd;
-import okhttp3.RecordingEventListener.ConnectionAcquired;
-import okhttp3.RecordingEventListener.ConnectionReleased;
-import okhttp3.RecordingEventListener.ResponseFailed;
-import okhttp3.internal.DoubleInetAddressDns;
-import okhttp3.internal.RecordingOkAuthenticator;
-import okhttp3.internal.Util;
-import okhttp3.internal.Version;
-import okhttp3.internal.http.RecordingProxySelector;
-import okhttp3.internal.io.InMemoryFileSystem;
-import okhttp3.mockwebserver.Dispatcher;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
-import okhttp3.mockwebserver.SocketPolicy;
-import okhttp3.tls.HandshakeCertificates;
-import okhttp3.tls.HeldCertificate;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.ForwardingSource;
-import okio.GzipSink;
-import okio.Okio;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TestRule;
-import org.junit.rules.Timeout;
-
-import static java.net.CookiePolicy.ACCEPT_ORIGINAL_SERVER;
-import static okhttp3.CipherSuite.TLS_DH_anon_WITH_AES_128_GCM_SHA256;
-import static okhttp3.TestUtil.awaitGarbageCollection;
-import static okhttp3.internal.platform.PlatformTest.getJvmSpecVersion;
-import static okhttp3.tls.internal.TlsUtil.localhost;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.data.Offset.offset;
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.fail;
-import static org.junit.Assume.assumeFalse;
-
-public final class CallTest {
-  @Rule public final TestRule timeout = new Timeout(30_000, TimeUnit.MILLISECONDS);
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final MockWebServer server2 = new MockWebServer();
-  @Rule public final InMemoryFileSystem fileSystem = new InMemoryFileSystem();
-  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
-
-  private final RecordingEventListener listener = new RecordingEventListener();
-  private HandshakeCertificates handshakeCertificates = localhost();
-  private OkHttpClient client = clientTestRule.client.newBuilder()
-      .eventListener(listener)
-      .build();
-  private RecordingCallback callback = new RecordingCallback();
-  private TestLogHandler logHandler = new TestLogHandler();
-  private Cache cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
-  private Logger logger = Logger.getLogger(OkHttpClient.class.getName());
-
-  @Before public void setUp() throws Exception {
-    logger.addHandler(logHandler);
-  }
-
-  @After public void tearDown() throws Exception {
-    cache.delete();
-    logger.removeHandler(logHandler);
-  }
-
-  @Test public void get() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .clearHeaders()
-        .addHeader("content-type: text/plain")
-        .addHeader("content-length", "3"));
-
-    long sentAt = System.currentTimeMillis();
-    RecordedResponse recordedResponse = executeSynchronously("/", "User-Agent", "SyncApiTest");
-    long receivedAt = System.currentTimeMillis();
-
-    recordedResponse.assertCode(200)
-        .assertSuccessful()
-        .assertHeaders(new Headers.Builder()
-            .add("content-type", "text/plain")
-            .add("content-length", "3")
-            .build())
-        .assertBody("abc")
-        .assertSentRequestAtMillis(sentAt, receivedAt)
-        .assertReceivedResponseAtMillis(sentAt, receivedAt);
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getMethod()).isEqualTo("GET");
-    assertThat(recordedRequest.getHeader("User-Agent")).isEqualTo("SyncApiTest");
-    assertThat(recordedRequest.getBody().size()).isEqualTo(0);
-    assertThat(recordedRequest.getHeader("Content-Length")).isNull();
-  }
-
-  @Test public void buildRequestUsingHttpUrl() throws Exception {
-    server.enqueue(new MockResponse());
-    executeSynchronously("/").assertSuccessful();
-  }
-
-  @Test public void invalidScheme() throws Exception {
-    Request.Builder requestBuilder = new Request.Builder();
-    try {
-      requestBuilder.url("ftp://hostname/path");
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          "Expected URL scheme 'http' or 'https' but was 'ftp'");
-    }
-  }
-
-  @Test public void invalidPort() throws Exception {
-    Request.Builder requestBuilder = new Request.Builder();
-    try {
-      requestBuilder.url("http://localhost:65536/");
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo("Invalid URL port: \"65536\"");
-    }
-  }
-
-  @Test public void getReturns500() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(500));
-    executeSynchronously("/")
-        .assertCode(500)
-        .assertNotSuccessful();
-  }
-
-  @Test public void get_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    get();
-  }
-
-  @Test public void get_HTTPS() throws Exception {
-    enableTls();
-    get();
-  }
-
-  @Test public void repeatedHeaderNames() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("B", "123")
-        .addHeader("B", "234"));
-
-    executeSynchronously("/", "A", "345", "A", "456")
-        .assertCode(200)
-        .assertHeader("B", "123", "234");
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getHeaders().values("A")).isEqualTo(
-        Arrays.asList("345", "456"));
-  }
-
-  @Test public void repeatedHeaderNames_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    repeatedHeaderNames();
-  }
-
-  @Test public void getWithRequestBody() throws Exception {
-    server.enqueue(new MockResponse());
-
-    try {
-      new Request.Builder().method("GET", RequestBody.create(MediaType.get("text/plain"), "abc"));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void head() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Content-Type: text/plain"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .head()
-        .header("User-Agent", "SyncApiTest")
-        .build();
-
-    executeSynchronously(request)
-        .assertCode(200)
-        .assertHeader("Content-Type", "text/plain");
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getMethod()).isEqualTo("HEAD");
-    assertThat(recordedRequest.getHeader("User-Agent")).isEqualTo("SyncApiTest");
-    assertThat(recordedRequest.getBody().size()).isEqualTo(0);
-    assertThat(recordedRequest.getHeader("Content-Length")).isNull();
-  }
-
-  @Test public void headResponseContentLengthIsIgnored() throws Exception {
-    server.enqueue(new MockResponse()
-        .clearHeaders()
-        .addHeader("Content-Length", "100"));
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    Request headRequest = new Request.Builder()
-        .url(server.url("/"))
-        .head()
-        .build();
-    Response response = client.newCall(headRequest).execute();
-    assertThat(response.code()).isEqualTo(200);
-    assertArrayEquals(new byte[0], response.body().bytes());
-
-    Request getRequest = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    executeSynchronously(getRequest)
-        .assertCode(200)
-        .assertBody("abc");
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void headResponseContentEncodingIsIgnored() throws Exception {
-    server.enqueue(new MockResponse()
-        .clearHeaders()
-        .addHeader("Content-Encoding", "chunked"));
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    Request headRequest = new Request.Builder()
-        .url(server.url("/"))
-        .head()
-        .build();
-    executeSynchronously(headRequest)
-        .assertCode(200)
-        .assertHeader("Content-Encoding", "chunked")
-        .assertBody("");
-
-    Request getRequest = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    executeSynchronously(getRequest)
-        .assertCode(200)
-        .assertBody("abc");
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void head_HTTPS() throws Exception {
-    enableTls();
-    head();
-  }
-
-  @Test public void head_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    head();
-  }
-
-  @Test public void post() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .post(RequestBody.create(MediaType.get("text/plain"), "def"))
-        .build();
-
-    executeSynchronously(request)
-        .assertCode(200)
-        .assertBody("abc");
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getMethod()).isEqualTo("POST");
-    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("def");
-    assertThat(recordedRequest.getHeader("Content-Length")).isEqualTo("3");
-    assertThat(recordedRequest.getHeader("Content-Type")).isEqualTo(
-        "text/plain; charset=utf-8");
-  }
-
-  @Test public void post_HTTPS() throws Exception {
-    enableTls();
-    post();
-  }
-
-  @Test public void post_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    post();
-  }
-
-  @Test public void postZeroLength() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .method("POST", RequestBody.create(null, new byte[0]))
-        .build();
-
-    executeSynchronously(request)
-        .assertCode(200)
-        .assertBody("abc");
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getMethod()).isEqualTo("POST");
-    assertThat(recordedRequest.getBody().size()).isEqualTo(0);
-    assertThat(recordedRequest.getHeader("Content-Length")).isEqualTo("0");
-    assertThat(recordedRequest.getHeader("Content-Type")).isNull();
-  }
-
-  @Test public void postZerolength_HTTPS() throws Exception {
-    enableTls();
-    postZeroLength();
-  }
-
-  @Test public void postZerolength_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    postZeroLength();
-  }
-
-  @Test public void postBodyRetransmittedAfterAuthorizationFail() throws Exception {
-    postBodyRetransmittedAfterAuthorizationFail("abc");
-  }
-
-  @Test public void postBodyRetransmittedAfterAuthorizationFail_HTTPS() throws Exception {
-    enableTls();
-    postBodyRetransmittedAfterAuthorizationFail("abc");
-  }
-
-  @Test public void postBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    postBodyRetransmittedAfterAuthorizationFail("abc");
-  }
-
-  /** Don't explode when resending an empty post. https://github.com/square/okhttp/issues/1131 */
-  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail() throws Exception {
-    postBodyRetransmittedAfterAuthorizationFail("");
-  }
-
-  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_HTTPS() throws Exception {
-    enableTls();
-    postBodyRetransmittedAfterAuthorizationFail("");
-  }
-
-  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    postBodyRetransmittedAfterAuthorizationFail("");
-  }
-
-  private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(401));
-    server.enqueue(new MockResponse());
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .method("POST", RequestBody.create(null, body))
-        .build();
-
-    String credential = Credentials.basic("jesse", "secret");
-    client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential, null))
-        .build();
-
-    Response response = client.newCall(request).execute();
-    assertThat(response.code()).isEqualTo(200);
-    response.body().close();
-
-    RecordedRequest recordedRequest1 = server.takeRequest();
-    assertThat(recordedRequest1.getMethod()).isEqualTo("POST");
-    assertThat(recordedRequest1.getBody().readUtf8()).isEqualTo(body);
-    assertThat(recordedRequest1.getHeader("Authorization")).isNull();
-
-    RecordedRequest recordedRequest2 = server.takeRequest();
-    assertThat(recordedRequest2.getMethod()).isEqualTo("POST");
-    assertThat(recordedRequest2.getBody().readUtf8()).isEqualTo(body);
-    assertThat(recordedRequest2.getHeader("Authorization")).isEqualTo(credential);
-  }
-
-  @Test public void attemptAuthorization20Times() throws Exception {
-    for (int i = 0; i < 20; i++) {
-      server.enqueue(new MockResponse().setResponseCode(401));
-    }
-    server.enqueue(new MockResponse().setBody("Success!"));
-
-    String credential = Credentials.basic("jesse", "secret");
-    client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential, null))
-        .build();
-
-    executeSynchronously("/")
-        .assertCode(200)
-        .assertBody("Success!");
-  }
-
-  @Test public void doesNotAttemptAuthorization21Times() throws Exception {
-    for (int i = 0; i < 21; i++) {
-      server.enqueue(new MockResponse().setResponseCode(401));
-    }
-
-    String credential = Credentials.basic("jesse", "secret");
-    client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential, null))
-        .build();
-
-    try {
-      client.newCall(new Request.Builder().url(server.url("/0")).build()).execute();
-      fail();
-    } catch (IOException expected) {
-      assertThat(expected.getMessage()).isEqualTo("Too many follow-up requests: 21");
-    }
-  }
-
-  /**
-   * We had a bug where we were passing a null route to the authenticator.
-   * https://github.com/square/okhttp/issues/3809
-   */
-  @Test public void authenticateWithNoConnection() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Connection: close")
-        .setResponseCode(401)
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
-
-    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(null, null);
-
-    client = client.newBuilder()
-        .authenticator(authenticator)
-        .build();
-
-    executeSynchronously("/")
-        .assertCode(401);
-
-    assertThat(authenticator.onlyRoute()).isNotNull();
-  }
-
-  @Test public void delete() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .delete()
-        .build();
-
-    executeSynchronously(request)
-        .assertCode(200)
-        .assertBody("abc");
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getMethod()).isEqualTo("DELETE");
-    assertThat(recordedRequest.getBody().size()).isEqualTo(0);
-    assertThat(recordedRequest.getHeader("Content-Length")).isEqualTo("0");
-    assertThat(recordedRequest.getHeader("Content-Type")).isNull();
-  }
-
-  @Test public void delete_HTTPS() throws Exception {
-    enableTls();
-    delete();
-  }
-
-  @Test public void delete_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    delete();
-  }
-
-  @Test public void deleteWithRequestBody() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .method("DELETE", RequestBody.create(MediaType.get("text/plain"), "def"))
-        .build();
-
-    executeSynchronously(request)
-        .assertCode(200)
-        .assertBody("abc");
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getMethod()).isEqualTo("DELETE");
-    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("def");
-  }
-
-  @Test public void put() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .put(RequestBody.create(MediaType.get("text/plain"), "def"))
-        .build();
-
-    executeSynchronously(request)
-        .assertCode(200)
-        .assertBody("abc");
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getMethod()).isEqualTo("PUT");
-    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("def");
-    assertThat(recordedRequest.getHeader("Content-Length")).isEqualTo("3");
-    assertThat(recordedRequest.getHeader("Content-Type")).isEqualTo(
-        "text/plain; charset=utf-8");
-  }
-
-  @Test public void put_HTTPS() throws Exception {
-    enableTls();
-    put();
-  }
-
-  @Test public void put_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    put();
-  }
-
-  @Test public void patch() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .patch(RequestBody.create(MediaType.get("text/plain"), "def"))
-        .build();
-
-    executeSynchronously(request)
-        .assertCode(200)
-        .assertBody("abc");
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getMethod()).isEqualTo("PATCH");
-    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("def");
-    assertThat(recordedRequest.getHeader("Content-Length")).isEqualTo("3");
-    assertThat(recordedRequest.getHeader("Content-Type")).isEqualTo(
-        "text/plain; charset=utf-8");
-  }
-
-  @Test public void patch_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    patch();
-  }
-
-  @Test public void patch_HTTPS() throws Exception {
-    enableTls();
-    patch();
-  }
-
-  @Test public void customMethodWithBody() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .method("CUSTOM", RequestBody.create(MediaType.get("text/plain"), "def"))
-        .build();
-
-    executeSynchronously(request)
-        .assertCode(200)
-        .assertBody("abc");
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getMethod()).isEqualTo("CUSTOM");
-    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("def");
-    assertThat(recordedRequest.getHeader("Content-Length")).isEqualTo("3");
-    assertThat(recordedRequest.getHeader("Content-Type")).isEqualTo(
-        "text/plain; charset=utf-8");
-  }
-
-  @Test public void unspecifiedRequestBodyContentTypeDoesNotGetDefault() throws Exception {
-    server.enqueue(new MockResponse());
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .method("POST", RequestBody.create(null, "abc"))
-        .build();
-
-    executeSynchronously(request).assertCode(200);
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getHeader("Content-Type")).isNull();
-    assertThat(recordedRequest.getHeader("Content-Length")).isEqualTo("3");
-    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("abc");
-  }
-
-  @Test public void illegalToExecuteTwice() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .addHeader("Content-Type: text/plain"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("User-Agent", "SyncApiTest")
-        .build();
-
-    Call call = client.newCall(request);
-    Response response = call.execute();
-    response.body().close();
-
-    try {
-      call.execute();
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e.getMessage()).isEqualTo("Already Executed");
-    }
-
-    try {
-      call.enqueue(callback);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e.getMessage()).isEqualTo("Already Executed");
-    }
-
-    assertThat(server.takeRequest().getHeader("User-Agent")).isEqualTo("SyncApiTest");
-  }
-
-  @Test public void illegalToExecuteTwice_Async() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .addHeader("Content-Type: text/plain"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("User-Agent", "SyncApiTest")
-        .build();
-
-    Call call = client.newCall(request);
-    call.enqueue(callback);
-
-    try {
-      call.execute();
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e.getMessage()).isEqualTo("Already Executed");
-    }
-
-    try {
-      call.enqueue(callback);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e.getMessage()).isEqualTo("Already Executed");
-    }
-
-    assertThat(server.takeRequest().getHeader("User-Agent")).isEqualTo("SyncApiTest");
-
-    callback.await(request.url()).assertSuccessful();
-  }
-
-  @Test public void legalToExecuteTwiceCloning() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setBody("def"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    Call call = client.newCall(request);
-    Response response1 = call.execute();
-
-    Call cloned = call.clone();
-    Response response2 = cloned.execute();
-
-    assertThat("abc").isEqualTo(response1.body().string());
-    assertThat("def").isEqualTo(response2.body().string());
-  }
-
-  @Test public void legalToExecuteTwiceCloning_Async() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setBody("def"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    Call call = client.newCall(request);
-    call.enqueue(callback);
-
-    Call cloned = call.clone();
-    cloned.enqueue(callback);
-
-    RecordedResponse firstResponse = callback.await(request.url()).assertSuccessful();
-    RecordedResponse secondResponse = callback.await(request.url()).assertSuccessful();
-
-    Set<String> bodies = new LinkedHashSet<>();
-    bodies.add(firstResponse.getBody());
-    bodies.add(secondResponse.getBody());
-
-    assertThat(bodies.contains("abc")).isTrue();
-    assertThat(bodies.contains("def")).isTrue();
-  }
-
-  @Test public void get_Async() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .addHeader("Content-Type: text/plain"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("User-Agent", "AsyncApiTest")
-        .build();
-    client.newCall(request).enqueue(callback);
-
-    callback.await(request.url())
-        .assertCode(200)
-        .assertHeader("Content-Type", "text/plain")
-        .assertBody("abc");
-
-    assertThat(server.takeRequest().getHeader("User-Agent")).isEqualTo("AsyncApiTest");
-  }
-
-  @Test public void exceptionThrownByOnResponseIsRedactedAndLogged() throws Exception {
-    server.enqueue(new MockResponse());
-
-    Request request = new Request.Builder()
-        .url(server.url("/secret"))
-        .build();
-
-    client.newCall(request).enqueue(new Callback() {
-      @Override public void onFailure(Call call, IOException e) {
-        fail();
-      }
-
-      @Override public void onResponse(Call call, Response response) throws IOException {
-        throw new IOException("a");
-      }
-    });
-
-    assertThat(logHandler.take()).isEqualTo(
-        ("INFO: Callback failure for call to " + server.url("/") + "..."));
-  }
-
-  @Test public void connectionPooling() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setBody("def"));
-    server.enqueue(new MockResponse().setBody("ghi"));
-
-    executeSynchronously("/a").assertBody("abc");
-    executeSynchronously("/b").assertBody("def");
-    executeSynchronously("/c").assertBody("ghi");
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
-  }
-
-  @Test public void connectionPooling_Async() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setBody("def"));
-    server.enqueue(new MockResponse().setBody("ghi"));
-
-    client.newCall(new Request.Builder().url(server.url("/a")).build()).enqueue(callback);
-    callback.await(server.url("/a")).assertBody("abc");
-
-    client.newCall(new Request.Builder().url(server.url("/b")).build()).enqueue(callback);
-    callback.await(server.url("/b")).assertBody("def");
-
-    client.newCall(new Request.Builder().url(server.url("/c")).build()).enqueue(callback);
-    callback.await(server.url("/c")).assertBody("ghi");
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
-  }
-
-  @Test public void connectionReuseWhenResponseBodyConsumed_Async() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setBody("def"));
-
-    Request request = new Request.Builder().url(server.url("/a")).build();
-    client.newCall(request).enqueue(new Callback() {
-      @Override public void onFailure(Call call, IOException e) {
-        throw new AssertionError();
-      }
-
-      @Override public void onResponse(Call call, Response response) throws IOException {
-        InputStream bytes = response.body().byteStream();
-        assertThat(bytes.read()).isEqualTo('a');
-        assertThat(bytes.read()).isEqualTo('b');
-        assertThat(bytes.read()).isEqualTo('c');
-
-        // This request will share a connection with 'A' cause it's all done.
-        client.newCall(new Request.Builder().url(server.url("/b")).build()).enqueue(callback);
-      }
-    });
-
-    callback.await(server.url("/b")).assertCode(200).assertBody("def");
-    // New connection.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    // Connection reuse!
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void timeoutsUpdatedOnReusedConnections() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setBody("def").throttleBody(1, 750, TimeUnit.MILLISECONDS));
-
-    // First request: time out after 1000ms.
-    client = client.newBuilder()
-        .readTimeout(1000, TimeUnit.MILLISECONDS)
-        .build();
-    executeSynchronously("/a").assertBody("abc");
-
-    // Second request: time out after 250ms.
-    client = client.newBuilder()
-        .readTimeout(250, TimeUnit.MILLISECONDS)
-        .build();
-    Request request = new Request.Builder().url(server.url("/b")).build();
-    Response response = client.newCall(request).execute();
-    BufferedSource bodySource = response.body().source();
-    assertThat(bodySource.readByte()).isEqualTo((byte) 'd');
-
-    // The second byte of this request will be delayed by 750ms so we should time out after 250ms.
-    long startNanos = System.nanoTime();
-    try {
-      bodySource.readByte();
-      fail();
-    } catch (IOException expected) {
-      // Timed out as expected.
-      long elapsedNanos = System.nanoTime() - startNanos;
-      long elapsedMillis = TimeUnit.NANOSECONDS.toMillis(elapsedNanos);
-      assertThat(elapsedMillis < 500).overridingErrorMessage(
-          Util.format("Timed out: %sms", elapsedMillis)).isTrue();
-    } finally {
-      bodySource.close();
-    }
-  }
-
-  /** https://github.com/square/okhttp/issues/442 */
-  @Test public void tlsTimeoutsNotRetried() throws Exception {
-    enableTls();
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.NO_RESPONSE));
-    server.enqueue(new MockResponse()
-        .setBody("unreachable!"));
-
-    client = client.newBuilder()
-        .readTimeout(100, TimeUnit.MILLISECONDS)
-        .build();
-
-    Request request = new Request.Builder().url(server.url("/")).build();
-    try {
-      // If this succeeds, too many requests were made.
-      client.newCall(request).execute();
-      fail();
-    } catch (InterruptedIOException expected) {
-    }
-  }
-
-  /**
-   * Make a request with two routes. The first route will time out because it's connecting to a
-   * special address that never connects. The automatic retry will succeed.
-   */
-  @Test public void connectTimeoutsAttemptsAlternateRoute() throws Exception {
-    RecordingProxySelector proxySelector = new RecordingProxySelector();
-    proxySelector.proxies.add(new Proxy(Proxy.Type.HTTP, TestUtil.UNREACHABLE_ADDRESS));
-    proxySelector.proxies.add(server.toProxyAddress());
-
-    server.enqueue(new MockResponse()
-        .setBody("success!"));
-
-    client = client.newBuilder()
-        .proxySelector(proxySelector)
-        .readTimeout(100, TimeUnit.MILLISECONDS)
-        .connectTimeout(100, TimeUnit.MILLISECONDS)
-        .build();
-
-    Request request = new Request.Builder().url("http://android.com/").build();
-    executeSynchronously(request)
-        .assertCode(200)
-        .assertBody("success!");
-  }
-
-  /** https://github.com/square/okhttp/issues/4875 */
-  @Test public void interceptorRecoversWhenRoutesExhausted() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
-    server.enqueue(new MockResponse());
-
-    client = client.newBuilder()
-        .addInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
-            try {
-              chain.proceed(chain.request());
-              throw new AssertionError();
-            } catch (IOException expected) {
-              return chain.proceed(chain.request());
-            }
-          }
-        })
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    executeSynchronously(request)
-        .assertCode(200);
-  }
-
-  /** https://github.com/square/okhttp/issues/4761 */
-  @Test public void interceptorCallsProceedWithoutClosingPriorResponse() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-    server.enqueue(new MockResponse());
-
-    client = client.newBuilder()
-        .addInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
-            Response response = chain.proceed(chain.request());
-            try {
-              chain.proceed(chain.request());
-              fail();
-            } catch (IllegalStateException expected) {
-              assertThat(expected).hasMessageContaining("please call response.close()");
-            }
-            return response;
-          }
-        })
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    executeSynchronously(request)
-        .assertCode(200)
-        .assertBody("abc");
-  }
-
-  /**
-   * Make a request with two routes. The first route will fail because the null server connects but
-   * never responds. The manual retry will succeed.
-   */
-  @Test public void readTimeoutFails() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.STALL_SOCKET_AT_START));
-    server2.enqueue(new MockResponse()
-        .setBody("success!"));
-
-    RecordingProxySelector proxySelector = new RecordingProxySelector();
-    proxySelector.proxies.add(server.toProxyAddress());
-    proxySelector.proxies.add(server2.toProxyAddress());
-
-    client = client.newBuilder()
-        .proxySelector(proxySelector)
-        .readTimeout(100, TimeUnit.MILLISECONDS)
-        .build();
-
-    Request request = new Request.Builder().url("http://android.com/").build();
-    executeSynchronously(request)
-        .assertFailure(SocketTimeoutException.class);
-    executeSynchronously(request)
-        .assertCode(200)
-        .assertBody("success!");
-  }
-
-  /** https://github.com/square/okhttp/issues/1801 */
-  @Test public void asyncCallEngineInitialized() throws Exception {
-    OkHttpClient c = clientTestRule.client.newBuilder()
-        .addInterceptor(chain -> { throw new IOException(); })
-        .build();
-    Request request = new Request.Builder().url(server.url("/")).build();
-    c.newCall(request).enqueue(callback);
-    RecordedResponse response = callback.await(request.url());
-    assertThat(response.request).isEqualTo(request);
-  }
-
-  @Test public void reusedSinksGetIndependentTimeoutInstances() throws Exception {
-    server.enqueue(new MockResponse());
-    server.enqueue(new MockResponse());
-
-    // Call 1: set a deadline on the request body.
-    RequestBody requestBody1 = new RequestBody() {
-      @Override public MediaType contentType() {
-        return MediaType.get("text/plain");
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        sink.writeUtf8("abc");
-        sink.timeout().deadline(5, TimeUnit.SECONDS);
-      }
-    };
-    Request request1 = new Request.Builder()
-        .url(server.url("/"))
-        .method("POST", requestBody1)
-        .build();
-    Response response1 = client.newCall(request1).execute();
-    assertThat(response1.code()).isEqualTo(200);
-
-    // Call 2: check for the absence of a deadline on the request body.
-    RequestBody requestBody2 = new RequestBody() {
-      @Override public MediaType contentType() {
-        return MediaType.get("text/plain");
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        assertThat(sink.timeout().hasDeadline()).isFalse();
-        sink.writeUtf8("def");
-      }
-    };
-    Request request2 = new Request.Builder()
-        .url(server.url("/"))
-        .method("POST", requestBody2)
-        .build();
-    Response response2 = client.newCall(request2).execute();
-    assertThat(response2.code()).isEqualTo(200);
-
-    // Use sequence numbers to confirm the connection was pooled.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void reusedSourcesGetIndependentTimeoutInstances() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setBody("def"));
-
-    // Call 1: set a deadline on the response body.
-    Request request1 = new Request.Builder().url(server.url("/")).build();
-    Response response1 = client.newCall(request1).execute();
-    BufferedSource body1 = response1.body().source();
-    assertThat(body1.readUtf8()).isEqualTo("abc");
-    body1.timeout().deadline(5, TimeUnit.SECONDS);
-
-    // Call 2: check for the absence of a deadline on the request body.
-    Request request2 = new Request.Builder().url(server.url("/")).build();
-    Response response2 = client.newCall(request2).execute();
-    BufferedSource body2 = response2.body().source();
-    assertThat(body2.readUtf8()).isEqualTo("def");
-    assertThat(body2.timeout().hasDeadline()).isFalse();
-
-    // Use sequence numbers to confirm the connection was pooled.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void tls() throws Exception {
-    enableTls();
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .addHeader("Content-Type: text/plain"));
-
-    executeSynchronously("/").assertHandshake();
-  }
-
-  @Test public void tls_Async() throws Exception {
-    enableTls();
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .addHeader("Content-Type: text/plain"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    client.newCall(request).enqueue(callback);
-
-    callback.await(request.url()).assertHandshake();
-  }
-
-  @Test public void recoverWhenRetryOnConnectionFailureIsTrue() throws Exception {
-    server.enqueue(new MockResponse().setBody("seed connection pool"));
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
-    server.enqueue(new MockResponse().setBody("retry success"));
-
-    client = client.newBuilder()
-        .dns(new DoubleInetAddressDns())
-        .build();
-    assertThat(client.retryOnConnectionFailure()).isTrue();
-
-    executeSynchronously("/").assertBody("seed connection pool");
-    executeSynchronously("/").assertBody("retry success");
-
-    // The call that seeds the connection pool.
-    listener.removeUpToEvent(CallEnd.class);
-
-    // The ResponseFailed event is not necessarily fatal!
-    listener.removeUpToEvent(ConnectionAcquired.class);
-    listener.removeUpToEvent(ResponseFailed.class);
-    listener.removeUpToEvent(ConnectionReleased.class);
-    listener.removeUpToEvent(ConnectionAcquired.class);
-    listener.removeUpToEvent(ConnectionReleased.class);
-    listener.removeUpToEvent(CallEnd.class);
-  }
-
-  @Test public void recoverWhenRetryOnConnectionFailureIsTrue_HTTP2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    recoverWhenRetryOnConnectionFailureIsTrue();
-  }
-
-  @Test public void noRecoverWhenRetryOnConnectionFailureIsFalse() throws Exception {
-    server.enqueue(new MockResponse().setBody("seed connection pool"));
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
-    server.enqueue(new MockResponse().setBody("unreachable!"));
-
-    client = client.newBuilder()
-        .dns(new DoubleInetAddressDns())
-        .retryOnConnectionFailure(false)
-        .build();
-
-    executeSynchronously("/").assertBody("seed connection pool");
-
-    // If this succeeds, too many requests were made.
-    executeSynchronously("/")
-        .assertFailure(IOException.class)
-        .assertFailureMatches("stream was reset: CANCEL",
-            "unexpected end of stream on " + server.url("/").redact());
-  }
-
-  @Test public void recoverWhenRetryOnConnectionFailureIsFalse_HTTP2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    noRecoverWhenRetryOnConnectionFailureIsFalse();
-  }
-
-  @Test public void tlsHandshakeFailure_noFallbackByDefault() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
-    server.enqueue(new MockResponse().setBody("response that will never be received"));
-    RecordedResponse response = executeSynchronously("/");
-    response.assertFailure(
-            SSLException.class, // JDK 11 response to the FAIL_HANDSHAKE
-            SSLProtocolException.class, // RI response to the FAIL_HANDSHAKE
-            SSLHandshakeException.class // Android's response to the FAIL_HANDSHAKE
-    );
-    assertThat(client.connectionSpecs().contains(ConnectionSpec.COMPATIBLE_TLS)).isFalse();
-  }
-
-  @Test public void recoverFromTlsHandshakeFailure() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    client = client.newBuilder()
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        // Attempt RESTRICTED_TLS then fall back to MODERN_TLS.
-        .connectionSpecs(Arrays.asList(ConnectionSpec.RESTRICTED_TLS, ConnectionSpec.MODERN_TLS))
-        .sslSocketFactory(
-            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
-        .build();
-
-    executeSynchronously("/").assertBody("abc");
-  }
-
-  @Test public void recoverFromTlsHandshakeFailure_tlsFallbackScsvEnabled() throws Exception {
-    final String tlsFallbackScsv = "TLS_FALLBACK_SCSV";
-    List<String> supportedCiphers =
-        Arrays.asList(handshakeCertificates.sslSocketFactory().getSupportedCipherSuites());
-    if (!supportedCiphers.contains(tlsFallbackScsv)) {
-      // This only works if the client socket supports TLS_FALLBACK_SCSV.
-      return;
-    }
-
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
-
-    RecordingSSLSocketFactory clientSocketFactory =
-        new RecordingSSLSocketFactory(handshakeCertificates.sslSocketFactory());
-    client = client.newBuilder()
-        .sslSocketFactory(clientSocketFactory, handshakeCertificates.trustManager())
-        // Attempt RESTRICTED_TLS then fall back to MODERN_TLS.
-        .connectionSpecs(Arrays.asList(ConnectionSpec.RESTRICTED_TLS, ConnectionSpec.MODERN_TLS))
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-
-    Request request = new Request.Builder().url(server.url("/")).build();
-    try {
-      client.newCall(request).execute();
-      fail();
-    } catch (SSLHandshakeException expected) {
-    }
-
-    List<SSLSocket> clientSockets = clientSocketFactory.getSocketsCreated();
-    SSLSocket firstSocket = clientSockets.get(0);
-    assertThat(Arrays.asList(firstSocket.getEnabledCipherSuites()).contains(tlsFallbackScsv)).isFalse();
-    SSLSocket secondSocket = clientSockets.get(1);
-    assertThat(Arrays.asList(secondSocket.getEnabledCipherSuites()).contains(tlsFallbackScsv)).isTrue();
-  }
-
-  @Test public void recoverFromTlsHandshakeFailure_Async() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    client = client.newBuilder()
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        // Attempt RESTRICTED_TLS then fall back to MODERN_TLS.
-        .connectionSpecs(Arrays.asList(ConnectionSpec.RESTRICTED_TLS, ConnectionSpec.MODERN_TLS))
-        .sslSocketFactory(
-            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    client.newCall(request).enqueue(callback);
-
-    callback.await(request.url()).assertBody("abc");
-  }
-
-  @Test public void noRecoveryFromTlsHandshakeFailureWhenTlsFallbackIsDisabled() throws Exception {
-    client = client.newBuilder()
-        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT))
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .sslSocketFactory(
-            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
-        .build();
-
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
-
-    Request request = new Request.Builder().url(server.url("/")).build();
-    try {
-      client.newCall(request).execute();
-      fail();
-    } catch (SSLProtocolException expected) {
-      // RI response to the FAIL_HANDSHAKE
-    } catch (SSLHandshakeException expected) {
-      // Android's response to the FAIL_HANDSHAKE
-    } catch (SSLException expected) {
-      // JDK 11 response to the FAIL_HANDSHAKE
-      String jvmVersion = System.getProperty("java.specification.version");
-      assertThat(jvmVersion).isEqualTo("11");
-    }
-  }
-
-  @Test public void tlsHostnameVerificationFailure() throws Exception {
-    server.enqueue(new MockResponse());
-
-    HeldCertificate serverCertificate = new HeldCertificate.Builder()
-        .commonName("localhost") // Unusued for hostname verification.
-        .addSubjectAlternativeName("wronghostname")
-        .build();
-
-    HandshakeCertificates serverCertificates = new HandshakeCertificates.Builder()
-        .heldCertificate(serverCertificate)
-        .build();
-
-    HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder()
-        .addTrustedCertificate(serverCertificate.certificate())
-        .build();
-
-    client = client.newBuilder()
-        .sslSocketFactory(clientCertificates.sslSocketFactory(), clientCertificates.trustManager())
-        .build();
-    server.useHttps(serverCertificates.sslSocketFactory(), false);
-
-    executeSynchronously("/")
-        .assertFailureMatches("(?s)Hostname localhost not verified.*");
-  }
-
-  /**
-   * Anonymous cipher suites were disabled in OpenJDK because they're rarely used and permit
-   * man-in-the-middle attacks. https://bugs.openjdk.java.net/browse/JDK-8212823
-   */
-  @Test public void anonCipherSuiteUnsupported() throws Exception {
-    // The _anon_ suites became unsupported in "1.8.0_201" and "11.0.2".
-    assumeFalse(System.getProperty("java.version", "unknown").matches("1\\.8\\.0_1\\d\\d"));
-    assumeFalse(System.getProperty("java.version", "unknown").matches("11"));
-
-    server.enqueue(new MockResponse());
-
-    CipherSuite cipherSuite = TLS_DH_anon_WITH_AES_128_GCM_SHA256;
-
-    HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder()
-        .build();
-    client = client.newBuilder()
-        .sslSocketFactory(
-            socketFactoryWithCipherSuite(clientCertificates.sslSocketFactory(), cipherSuite),
-            clientCertificates.trustManager())
-        .connectionSpecs(Arrays.asList(new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
-            .cipherSuites(cipherSuite)
-            .build()))
-        .build();
-
-    HandshakeCertificates serverCertificates = new HandshakeCertificates.Builder()
-        .build();
-    server.useHttps(socketFactoryWithCipherSuite(
-        serverCertificates.sslSocketFactory(), cipherSuite), false);
-
-    executeSynchronously("/")
-        .assertFailure(SSLHandshakeException.class);
-  }
-
-  @Test public void cleartextCallsFailWhenCleartextIsDisabled() throws Exception {
-    // Configure the client with only TLS configurations. No cleartext!
-    client = client.newBuilder()
-        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
-        .build();
-
-    server.enqueue(new MockResponse());
-
-    Request request = new Request.Builder().url(server.url("/")).build();
-    try {
-      client.newCall(request).execute();
-      fail();
-    } catch (UnknownServiceException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          "CLEARTEXT communication not enabled for client");
-    }
-  }
-
-  @Test public void httpsCallsFailWhenProtocolIsH2PriorKnowledge() throws Exception {
-    client = client.newBuilder()
-        .protocols(Collections.singletonList(Protocol.H2_PRIOR_KNOWLEDGE))
-        .build();
-
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse());
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    try {
-      call.execute();
-      fail();
-    } catch (UnknownServiceException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          "H2_PRIOR_KNOWLEDGE cannot be used with HTTPS");
-    }
-  }
-
-  @Test public void setFollowSslRedirectsFalse() throws Exception {
-    enableTls();
-    server.enqueue(new MockResponse()
-        .setResponseCode(301)
-        .addHeader("Location: http://square.com"));
-
-    client = client.newBuilder()
-        .followSslRedirects(false)
-        .build();
-
-    Request request = new Request.Builder().url(server.url("/")).build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.code()).isEqualTo(301);
-    response.body().close();
-  }
-
-  @Test public void matchingPinnedCertificate() throws Exception {
-    // TODO https://github.com/square/okhttp/issues/4703
-    assumeFalse(getJvmSpecVersion().equals("11"));
-
-    enableTls();
-    server.enqueue(new MockResponse());
-    server.enqueue(new MockResponse());
-
-    // Make a first request without certificate pinning. Use it to collect certificates to pin.
-    Request request1 = new Request.Builder().url(server.url("/")).build();
-    Response response1 = client.newCall(request1).execute();
-    CertificatePinner.Builder certificatePinnerBuilder = new CertificatePinner.Builder();
-    for (Certificate certificate : response1.handshake().peerCertificates()) {
-      certificatePinnerBuilder.add(server.getHostName(), CertificatePinner.pin(certificate));
-    }
-    response1.body().close();
-
-    // Make another request with certificate pinning. It should complete normally.
-    client = client.newBuilder()
-        .certificatePinner(certificatePinnerBuilder.build())
-        .build();
-    Request request2 = new Request.Builder().url(server.url("/")).build();
-    Response response2 = client.newCall(request2).execute();
-    assertThat(response1.handshake()).isNotSameAs(response2.handshake());
-    response2.body().close();
-  }
-
-  @Test public void unmatchingPinnedCertificate() throws Exception {
-    enableTls();
-    server.enqueue(new MockResponse());
-
-    // Pin publicobject.com's cert.
-    client = client.newBuilder()
-        .certificatePinner(new CertificatePinner.Builder()
-            .add(server.getHostName(), "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=")
-            .build())
-        .build();
-
-    // When we pin the wrong certificate, connectivity fails.
-    Request request = new Request.Builder().url(server.url("/")).build();
-    try {
-      client.newCall(request).execute();
-      fail();
-    } catch (SSLPeerUnverifiedException expected) {
-      assertThat(expected.getMessage().startsWith("Certificate pinning failure!")).isTrue();
-    }
-  }
-
-  @Test public void post_Async() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .post(RequestBody.create(MediaType.get("text/plain"), "def"))
-        .build();
-    client.newCall(request).enqueue(callback);
-
-    callback.await(request.url())
-        .assertCode(200)
-        .assertBody("abc");
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("def");
-    assertThat(recordedRequest.getHeader("Content-Length")).isEqualTo("3");
-    assertThat(recordedRequest.getHeader("Content-Type")).isEqualTo(
-        "text/plain; charset=utf-8");
-  }
-
-  @Test public void postBodyRetransmittedOnFailureRecovery() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
-    server.enqueue(new MockResponse().setBody("def"));
-
-    // Seed the connection pool so we have something that can fail.
-    Request request1 = new Request.Builder().url(server.url("/")).build();
-    Response response1 = client.newCall(request1).execute();
-    assertThat(response1.body().string()).isEqualTo("abc");
-
-    Request request2 = new Request.Builder()
-        .url(server.url("/"))
-        .post(RequestBody.create(MediaType.get("text/plain"), "body!"))
-        .build();
-    Response response2 = client.newCall(request2).execute();
-    assertThat(response2.body().string()).isEqualTo("def");
-
-    RecordedRequest get = server.takeRequest();
-    assertThat(get.getSequenceNumber()).isEqualTo(0);
-
-    RecordedRequest post1 = server.takeRequest();
-    assertThat(post1.getBody().readUtf8()).isEqualTo("body!");
-    assertThat(post1.getSequenceNumber()).isEqualTo(1);
-
-    RecordedRequest post2 = server.takeRequest();
-    assertThat(post2.getBody().readUtf8()).isEqualTo("body!");
-    assertThat(post2.getSequenceNumber()).isEqualTo(0);
-  }
-
-  @Test public void postBodyRetransmittedOnFailureRecovery_HTTP2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    postBodyRetransmittedOnFailureRecovery();
-  }
-
-  @Test public void cacheHit() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("ETag: v1")
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Charset")
-        .setBody("A"));
-
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-
-    // Store a response in the cache.
-    HttpUrl url = server.url("/");
-    long request1SentAt = System.currentTimeMillis();
-    executeSynchronously("/", "Accept-Language", "fr-CA", "Accept-Charset", "UTF-8")
-        .assertCode(200)
-        .assertBody("A");
-    long request1ReceivedAt = System.currentTimeMillis();
-    assertThat(server.takeRequest().getHeader("If-None-Match")).isNull();
-
-    // Hit that stored response. It's different, but Vary says it doesn't matter.
-    Thread.sleep(10); // Make sure the timestamps are unique.
-    RecordedResponse cacheHit = executeSynchronously(
-        "/", "Accept-Language", "en-US", "Accept-Charset", "UTF-8");
-
-    // Check the merged response. The request is the application's original request.
-    cacheHit.assertCode(200)
-        .assertBody("A")
-        .assertHeaders(new Headers.Builder()
-            .add("ETag", "v1")
-            .add("Cache-Control", "max-age=60")
-            .add("Vary", "Accept-Charset")
-            .add("Content-Length", "1")
-            .build())
-        .assertRequestUrl(url)
-        .assertRequestHeader("Accept-Language", "en-US")
-        .assertRequestHeader("Accept-Charset", "UTF-8")
-        .assertSentRequestAtMillis(request1SentAt, request1ReceivedAt)
-        .assertReceivedResponseAtMillis(request1SentAt, request1ReceivedAt);
-
-    // Check the cached response. Its request contains only the saved Vary headers.
-    cacheHit.cacheResponse()
-        .assertCode(200)
-        .assertHeaders(new Headers.Builder()
-            .add("ETag", "v1")
-            .add("Cache-Control", "max-age=60")
-            .add("Vary", "Accept-Charset")
-            .add("Content-Length", "1")
-            .build())
-        .assertRequestMethod("GET")
-        .assertRequestUrl(url)
-        .assertRequestHeader("Accept-Language")
-        .assertRequestHeader("Accept-Charset", "UTF-8")
-        .assertSentRequestAtMillis(request1SentAt, request1ReceivedAt)
-        .assertReceivedResponseAtMillis(request1SentAt, request1ReceivedAt);
-
-    cacheHit.assertNoNetworkResponse();
-  }
-
-  @Test public void conditionalCacheHit() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("ETag: v1")
-        .addHeader("Vary: Accept-Charset")
-        .addHeader("Donut: a")
-        .setBody("A"));
-    server.enqueue(new MockResponse().clearHeaders()
-        .addHeader("Donut: b")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-
-    // Store a response in the cache.
-    long request1SentAt = System.currentTimeMillis();
-    executeSynchronously("/", "Accept-Language", "fr-CA", "Accept-Charset", "UTF-8")
-        .assertCode(200)
-        .assertHeader("Donut", "a")
-        .assertBody("A");
-    long request1ReceivedAt = System.currentTimeMillis();
-    assertThat(server.takeRequest().getHeader("If-None-Match")).isNull();
-
-    // Hit that stored response. It's different, but Vary says it doesn't matter.
-    Thread.sleep(10); // Make sure the timestamps are unique.
-    long request2SentAt = System.currentTimeMillis();
-    RecordedResponse cacheHit = executeSynchronously(
-        "/", "Accept-Language", "en-US", "Accept-Charset", "UTF-8");
-    long request2ReceivedAt = System.currentTimeMillis();
-    assertThat(server.takeRequest().getHeader("If-None-Match")).isEqualTo("v1");
-
-    // Check the merged response. The request is the application's original request.
-    cacheHit.assertCode(200)
-        .assertBody("A")
-        .assertHeader("Donut", "b")
-        .assertRequestUrl(server.url("/"))
-        .assertRequestHeader("Accept-Language", "en-US")
-        .assertRequestHeader("Accept-Charset", "UTF-8")
-        .assertRequestHeader("If-None-Match") // No If-None-Match on the user's request.
-        .assertSentRequestAtMillis(request2SentAt, request2ReceivedAt)
-        .assertReceivedResponseAtMillis(request2SentAt, request2ReceivedAt);
-
-    // Check the cached response. Its request contains only the saved Vary headers.
-    cacheHit.cacheResponse()
-        .assertCode(200)
-        .assertHeader("Donut", "a")
-        .assertHeader("ETag", "v1")
-        .assertRequestUrl(server.url("/"))
-        .assertRequestHeader("Accept-Language") // No Vary on Accept-Language.
-        .assertRequestHeader("Accept-Charset", "UTF-8") // Because of Vary on Accept-Charset.
-        .assertRequestHeader("If-None-Match") // This wasn't present in the original request.
-        .assertSentRequestAtMillis(request1SentAt, request1ReceivedAt)
-        .assertReceivedResponseAtMillis(request1SentAt, request1ReceivedAt);
-
-    // Check the network response. It has the caller's request, plus some caching headers.
-    cacheHit.networkResponse()
-        .assertCode(304)
-        .assertHeader("Donut", "b")
-        .assertRequestHeader("Accept-Language", "en-US")
-        .assertRequestHeader("Accept-Charset", "UTF-8")
-        .assertRequestHeader("If-None-Match", "v1") // If-None-Match in the validation request.
-        .assertSentRequestAtMillis(request2SentAt, request2ReceivedAt)
-        .assertReceivedResponseAtMillis(request2SentAt, request2ReceivedAt);
-  }
-
-  @Test public void conditionalCacheHit_Async() throws Exception {
-    server.enqueue(new MockResponse().setBody("A").addHeader("ETag: v1"));
-    server.enqueue(new MockResponse()
-        .clearHeaders()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-
-    Request request1 = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    client.newCall(request1).enqueue(callback);
-    callback.await(request1.url()).assertCode(200).assertBody("A");
-    assertThat(server.takeRequest().getHeader("If-None-Match")).isNull();
-
-    Request request2 = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    client.newCall(request2).enqueue(callback);
-    callback.await(request2.url()).assertCode(200).assertBody("A");
-    assertThat(server.takeRequest().getHeader("If-None-Match")).isEqualTo("v1");
-  }
-
-  @Test public void conditionalCacheMiss() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("ETag: v1")
-        .addHeader("Vary: Accept-Charset")
-        .addHeader("Donut: a")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .addHeader("Donut: b")
-        .setBody("B"));
-
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-
-    long request1SentAt = System.currentTimeMillis();
-    executeSynchronously("/", "Accept-Language", "fr-CA", "Accept-Charset", "UTF-8")
-        .assertCode(200)
-        .assertBody("A");
-    long request1ReceivedAt = System.currentTimeMillis();
-    assertThat(server.takeRequest().getHeader("If-None-Match")).isNull();
-
-    // Different request, but Vary says it doesn't matter.
-    Thread.sleep(10); // Make sure the timestamps are unique.
-    long request2SentAt = System.currentTimeMillis();
-    RecordedResponse cacheMiss = executeSynchronously(
-        "/", "Accept-Language", "en-US", "Accept-Charset", "UTF-8");
-    long request2ReceivedAt = System.currentTimeMillis();
-    assertThat(server.takeRequest().getHeader("If-None-Match")).isEqualTo("v1");
-
-    // Check the user response. It has the application's original request.
-    cacheMiss.assertCode(200)
-        .assertBody("B")
-        .assertHeader("Donut", "b")
-        .assertRequestUrl(server.url("/"))
-        .assertSentRequestAtMillis(request2SentAt, request2ReceivedAt)
-        .assertReceivedResponseAtMillis(request2SentAt, request2ReceivedAt);
-
-    // Check the cache response. Even though it's a miss, we used the cache.
-    cacheMiss.cacheResponse()
-        .assertCode(200)
-        .assertHeader("Donut", "a")
-        .assertHeader("ETag", "v1")
-        .assertRequestUrl(server.url("/"))
-        .assertSentRequestAtMillis(request1SentAt, request1ReceivedAt)
-        .assertReceivedResponseAtMillis(request1SentAt, request1ReceivedAt);
-
-    // Check the network response. It has the network request, plus caching headers.
-    cacheMiss.networkResponse()
-        .assertCode(200)
-        .assertHeader("Donut", "b")
-        .assertRequestHeader("If-None-Match", "v1")  // If-None-Match in the validation request.
-        .assertRequestUrl(server.url("/"))
-        .assertSentRequestAtMillis(request2SentAt, request2ReceivedAt)
-        .assertReceivedResponseAtMillis(request2SentAt, request2ReceivedAt);
-  }
-
-  @Test public void conditionalCacheMiss_Async() throws Exception {
-    server.enqueue(new MockResponse().setBody("A").addHeader("ETag: v1"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-
-    Request request1 = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    client.newCall(request1).enqueue(callback);
-    callback.await(request1.url()).assertCode(200).assertBody("A");
-    assertThat(server.takeRequest().getHeader("If-None-Match")).isNull();
-
-    Request request2 = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    client.newCall(request2).enqueue(callback);
-    callback.await(request2.url()).assertCode(200).assertBody("B");
-    assertThat(server.takeRequest().getHeader("If-None-Match")).isEqualTo("v1");
-  }
-
-  @Test public void onlyIfCachedReturns504WhenNotCached() throws Exception {
-    executeSynchronously("/", "Cache-Control", "only-if-cached")
-        .assertCode(504)
-        .assertBody("")
-        .assertNoNetworkResponse()
-        .assertNoCacheResponse();
-  }
-
-  @Test public void networkDropsOnConditionalGet() throws IOException {
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-
-    // Seed the cache.
-    server.enqueue(new MockResponse()
-        .addHeader("ETag: v1")
-        .setBody("A"));
-    executeSynchronously("/")
-        .assertCode(200)
-        .assertBody("A");
-
-    // Attempt conditional cache validation and a DNS miss.
-    client = client.newBuilder()
-        .dns(new FakeDns())
-        .build();
-    executeSynchronously("/").assertFailure(UnknownHostException.class);
-  }
-
-  @Test public void redirect() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(301)
-        .addHeader("Location: /b")
-        .addHeader("Test", "Redirect from /a to /b")
-        .setBody("/a has moved!"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(302)
-        .addHeader("Location: /c")
-        .addHeader("Test", "Redirect from /b to /c")
-        .setBody("/b has moved!"));
-    server.enqueue(new MockResponse().setBody("C"));
-
-    executeSynchronously("/a")
-        .assertCode(200)
-        .assertBody("C")
-        .priorResponse()
-        .assertCode(302)
-        .assertHeader("Test", "Redirect from /b to /c")
-        .priorResponse()
-        .assertCode(301)
-        .assertHeader("Test", "Redirect from /a to /b");
-
-    // New connection.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    // Connection reused.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-    // Connection reused again!
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
-  }
-
-  @Test public void postRedirectsToGet() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /page2")
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse().setBody("Page 2"));
-
-    Response response = client.newCall(new Request.Builder()
-        .url(server.url("/page1"))
-        .post(RequestBody.create(MediaType.get("text/plain"), "Request Body"))
-        .build()).execute();
-    assertThat(response.body().string()).isEqualTo("Page 2");
-
-    RecordedRequest page1 = server.takeRequest();
-    assertThat(page1.getRequestLine()).isEqualTo("POST /page1 HTTP/1.1");
-    assertThat(page1.getBody().readUtf8()).isEqualTo("Request Body");
-
-    RecordedRequest page2 = server.takeRequest();
-    assertThat(page2.getRequestLine()).isEqualTo("GET /page2 HTTP/1.1");
-  }
-
-  @Test public void getClientRequestTimeout() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setResponseCode(408)
-        .setHeader("Connection", "Close")
-        .setBody("You took too long!"));
-    server.enqueue(new MockResponse().setBody("Body"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Response response = client.newCall(request).execute();
-
-    assertThat(response.body().string()).isEqualTo("Body");
-  }
-
-  @Test public void getClientRequestTimeoutWithBackPressure() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setResponseCode(408)
-        .setHeader("Connection", "Close")
-        .setHeader("Retry-After", "1")
-        .setBody("You took too long!"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Response response = client.newCall(request).execute();
-
-    assertThat(response.body().string()).isEqualTo("You took too long!");
-  }
-
-  @Test public void requestBodyRetransmittedOnClientRequestTimeout() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setResponseCode(408)
-        .setHeader("Connection", "Close")
-        .setBody("You took too long!"));
-    server.enqueue(new MockResponse().setBody("Body"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .post(RequestBody.create(MediaType.get("text/plain"), "Hello"))
-        .build();
-    Response response = client.newCall(request).execute();
-
-    assertThat(response.body().string()).isEqualTo("Body");
-
-    RecordedRequest request1 = server.takeRequest();
-    assertThat(request1.getBody().readUtf8()).isEqualTo("Hello");
-
-    RecordedRequest request2 = server.takeRequest();
-    assertThat(request2.getBody().readUtf8()).isEqualTo("Hello");
-  }
-
-  @Test public void disableClientRequestTimeoutRetry() throws IOException {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setResponseCode(408)
-        .setHeader("Connection", "Close")
-        .setBody("You took too long!"));
-
-    client = client.newBuilder()
-        .retryOnConnectionFailure(false)
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Response response = client.newCall(request).execute();
-
-    assertThat(response.code()).isEqualTo(408);
-    assertThat(response.body().string()).isEqualTo("You took too long!");
-  }
-
-  @Test public void maxClientRequestTimeoutRetries() throws IOException {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setResponseCode(408)
-        .setHeader("Connection", "Close")
-        .setBody("You took too long!"));
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setResponseCode(408)
-        .setHeader("Connection", "Close")
-        .setBody("You took too long!"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Response response = client.newCall(request).execute();
-
-    assertThat(response.code()).isEqualTo(408);
-    assertThat(response.body().string()).isEqualTo("You took too long!");
-
-    assertThat(server.getRequestCount()).isEqualTo(2);
-  }
-
-  @Test public void maxUnavailableTimeoutRetries() throws IOException {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setResponseCode(503)
-        .setHeader("Connection", "Close")
-        .setHeader("Retry-After", "0")
-        .setBody("You took too long!"));
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setResponseCode(503)
-        .setHeader("Connection", "Close")
-        .setHeader("Retry-After", "0")
-        .setBody("You took too long!"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Response response = client.newCall(request).execute();
-
-    assertThat(response.code()).isEqualTo(503);
-    assertThat(response.body().string()).isEqualTo("You took too long!");
-
-    assertThat(server.getRequestCount()).isEqualTo(2);
-  }
-
-  @Test public void retryOnUnavailableWith0RetryAfter() throws IOException {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setResponseCode(503)
-        .setHeader("Connection", "Close")
-        .setHeader("Retry-After", "0")
-        .setBody("You took too long!"));
-    server.enqueue(new MockResponse().setBody("Body"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Response response = client.newCall(request).execute();
-
-    assertThat(response.body().string()).isEqualTo("Body");
-  }
-
-  @Test public void canRetryNormalRequestBody() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(503)
-        .setHeader("Retry-After", "0")
-        .setBody("please retry"));
-    server.enqueue(new MockResponse()
-        .setBody("thank you for retrying"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .post(new RequestBody() {
-          int attempt = 0;
-
-          @Override public @Nullable MediaType contentType() {
-            return null;
-          }
-
-          @Override public void writeTo(BufferedSink sink) throws IOException {
-            sink.writeUtf8("attempt " + (attempt++));
-          }
-        })
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.code()).isEqualTo(200);
-    assertThat(response.body().string()).isEqualTo("thank you for retrying");
-
-    assertThat(server.takeRequest().getBody().readUtf8()).isEqualTo("attempt 0");
-    assertThat(server.takeRequest().getBody().readUtf8()).isEqualTo("attempt 1");
-    assertThat(server.getRequestCount()).isEqualTo(2);
-  }
-
-  @Test public void cannotRetryOneShotRequestBody() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(503)
-        .setHeader("Retry-After", "0")
-        .setBody("please retry"));
-    server.enqueue(new MockResponse()
-        .setBody("thank you for retrying"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .post(new RequestBody() {
-          int attempt = 0;
-
-          @Override public @Nullable MediaType contentType() {
-            return null;
-          }
-
-          @Override public void writeTo(BufferedSink sink) throws IOException {
-            sink.writeUtf8("attempt " + (attempt++));
-          }
-
-          @Override public boolean isOneShot() {
-            return true;
-          }
-        })
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.code()).isEqualTo(503);
-    assertThat(response.body().string()).isEqualTo("please retry");
-
-    assertThat(server.takeRequest().getBody().readUtf8()).isEqualTo("attempt 0");
-    assertThat(server.getRequestCount()).isEqualTo(1);
-  }
-
-  @Test public void propfindRedirectsToPropfindAndMaintainsRequestBody() throws Exception {
-    // given
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /page2")
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse().setBody("Page 2"));
-
-    // when
-    Response response = client.newCall(new Request.Builder()
-        .url(server.url("/page1"))
-        .method("PROPFIND", RequestBody.create(MediaType.get("text/plain"), "Request Body"))
-        .build()).execute();
-
-    // then
-    assertThat(response.body().string()).isEqualTo("Page 2");
-
-    RecordedRequest page1 = server.takeRequest();
-    assertThat(page1.getRequestLine()).isEqualTo("PROPFIND /page1 HTTP/1.1");
-    assertThat(page1.getBody().readUtf8()).isEqualTo("Request Body");
-
-    RecordedRequest page2 = server.takeRequest();
-    assertThat(page2.getRequestLine()).isEqualTo("PROPFIND /page2 HTTP/1.1");
-    assertThat(page2.getBody().readUtf8()).isEqualTo("Request Body");
-  }
-
-  @Test public void responseCookies() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Set-Cookie", "a=b; Expires=Thu, 01 Jan 1970 00:00:00 GMT")
-        .addHeader("Set-Cookie", "c=d; Expires=Fri, 02 Jan 1970 23:59:59 GMT; path=/bar; secure"));
-
-    RecordingCookieJar cookieJar = new RecordingCookieJar();
-    client = client.newBuilder()
-        .cookieJar(cookieJar)
-        .build();
-
-    executeSynchronously("/").assertCode(200);
-
-    List<Cookie> responseCookies = cookieJar.takeResponseCookies();
-    assertThat(responseCookies.size()).isEqualTo(2);
-    assertThat(responseCookies.get(0).toString()).isEqualTo(
-        "a=b; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/");
-    assertThat(responseCookies.get(1).toString()).isEqualTo(
-        "c=d; expires=Fri, 02 Jan 1970 23:59:59 GMT; path=/bar; secure");
-  }
-
-  @Test public void requestCookies() throws Exception {
-    server.enqueue(new MockResponse());
-
-    RecordingCookieJar cookieJar = new RecordingCookieJar();
-
-    cookieJar.enqueueRequestCookies(
-        new Cookie.Builder().name("a").value("b").domain(server.getHostName()).build(),
-        new Cookie.Builder().name("c").value("d").domain(server.getHostName()).build());
-    client = client.newBuilder()
-        .cookieJar(cookieJar)
-        .build();
-
-    executeSynchronously("/").assertCode(200);
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getHeader("Cookie")).isEqualTo("a=b; c=d");
-  }
-
-  @Test public void redirectsDoNotIncludeTooManyCookies() throws Exception {
-    server2.enqueue(new MockResponse().setBody("Page 2"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.url("/")));
-
-    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
-    HttpCookie cookie = new HttpCookie("c", "cookie");
-    cookie.setDomain(server.getHostName());
-    cookie.setPath("/");
-    String portList = Integer.toString(server.getPort());
-    cookie.setPortlist(portList);
-    cookieManager.getCookieStore().add(server.url("/").uri(), cookie);
-    client = client.newBuilder()
-        .cookieJar(new JavaNetCookieJar(cookieManager))
-        .build();
-
-    Response response = client.newCall(new Request.Builder()
-        .url(server.url("/page1"))
-        .build()).execute();
-    assertThat(response.body().string()).isEqualTo("Page 2");
-
-    RecordedRequest request1 = server.takeRequest();
-    assertThat(request1.getHeader("Cookie")).isEqualTo("c=cookie");
-
-    RecordedRequest request2 = server2.takeRequest();
-    assertThat(request2.getHeader("Cookie")).isNull();
-  }
-
-  @Test public void redirectsDoNotIncludeTooManyAuthHeaders() throws Exception {
-    server2.enqueue(new MockResponse().setBody("Page 2"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(401));
-    server.enqueue(new MockResponse()
-        .setResponseCode(302)
-        .addHeader("Location: " + server2.url("/b")));
-
-    client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(Credentials.basic("jesse", "secret"), null))
-        .build();
-
-    Request request = new Request.Builder().url(server.url("/a")).build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("Page 2");
-
-    RecordedRequest redirectRequest = server2.takeRequest();
-    assertThat(redirectRequest.getHeader("Authorization")).isNull();
-    assertThat(redirectRequest.getPath()).isEqualTo("/b");
-  }
-
-  @Test public void redirect_Async() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(301)
-        .addHeader("Location: /b")
-        .addHeader("Test", "Redirect from /a to /b")
-        .setBody("/a has moved!"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(302)
-        .addHeader("Location: /c")
-        .addHeader("Test", "Redirect from /b to /c")
-        .setBody("/b has moved!"));
-    server.enqueue(new MockResponse().setBody("C"));
-
-    Request request = new Request.Builder().url(server.url("/a")).build();
-    client.newCall(request).enqueue(callback);
-
-    callback.await(server.url("/a"))
-        .assertCode(200)
-        .assertBody("C")
-        .priorResponse()
-        .assertCode(302)
-        .assertHeader("Test", "Redirect from /b to /c")
-        .priorResponse()
-        .assertCode(301)
-        .assertHeader("Test", "Redirect from /a to /b");
-
-    // New connection.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    // Connection reused.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-    // Connection reused again!
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
-  }
-
-  @Test public void follow20Redirects() throws Exception {
-    for (int i = 0; i < 20; i++) {
-      server.enqueue(new MockResponse()
-          .setResponseCode(301)
-          .addHeader("Location: /" + (i + 1))
-          .setBody("Redirecting to /" + (i + 1)));
-    }
-    server.enqueue(new MockResponse().setBody("Success!"));
-
-    executeSynchronously("/0")
-        .assertCode(200)
-        .assertBody("Success!");
-  }
-
-  @Test public void follow20Redirects_Async() throws Exception {
-    for (int i = 0; i < 20; i++) {
-      server.enqueue(new MockResponse()
-          .setResponseCode(301)
-          .addHeader("Location: /" + (i + 1))
-          .setBody("Redirecting to /" + (i + 1)));
-    }
-    server.enqueue(new MockResponse().setBody("Success!"));
-
-    Request request = new Request.Builder().url(server.url("/0")).build();
-    client.newCall(request).enqueue(callback);
-    callback.await(server.url("/0"))
-        .assertCode(200)
-        .assertBody("Success!");
-  }
-
-  @Test public void doesNotFollow21Redirects() throws Exception {
-    for (int i = 0; i < 21; i++) {
-      server.enqueue(new MockResponse()
-          .setResponseCode(301)
-          .addHeader("Location: /" + (i + 1))
-          .setBody("Redirecting to /" + (i + 1)));
-    }
-
-    try {
-      client.newCall(new Request.Builder().url(server.url("/0")).build()).execute();
-      fail();
-    } catch (IOException expected) {
-      assertThat(expected.getMessage()).isEqualTo("Too many follow-up requests: 21");
-    }
-  }
-
-  @Test public void doesNotFollow21Redirects_Async() throws Exception {
-    for (int i = 0; i < 21; i++) {
-      server.enqueue(new MockResponse()
-          .setResponseCode(301)
-          .addHeader("Location: /" + (i + 1))
-          .setBody("Redirecting to /" + (i + 1)));
-    }
-
-    Request request = new Request.Builder().url(server.url("/0")).build();
-    client.newCall(request).enqueue(callback);
-    callback.await(server.url("/0")).assertFailure("Too many follow-up requests: 21");
-  }
-
-  @Test public void http204WithBodyDisallowed() throws IOException {
-    server.enqueue(new MockResponse()
-        .setResponseCode(204)
-        .setBody("I'm not even supposed to be here today."));
-
-    executeSynchronously("/")
-        .assertFailure("HTTP 204 had non-zero Content-Length: 39");
-  }
-
-  @Test public void http205WithBodyDisallowed() throws IOException {
-    server.enqueue(new MockResponse()
-        .setResponseCode(205)
-        .setBody("I'm not even supposed to be here today."));
-
-    executeSynchronously("/")
-        .assertFailure("HTTP 205 had non-zero Content-Length: 39");
-  }
-
-  @Test public void httpWithExcessiveHeaders() throws IOException {
-    String longLine = "HTTP/1.1 200 " + stringFill('O', 256 * 1024) + "K";
-
-    server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
-
-    server.enqueue(new MockResponse()
-        .setStatus(longLine)
-        .setBody("I'm not even supposed to be here today."));
-
-    executeSynchronously("/")
-        .assertFailureMatches(".*unexpected end of stream on " + server.url("/").redact());
-  }
-
-  private String stringFill(char fillChar, int length) {
-    char[] value = new char[length];
-    Arrays.fill(value, fillChar);
-    return new String(value);
-  }
-
-  @Test public void canceledBeforeExecute() throws Exception {
-    Call call = client.newCall(new Request.Builder().url(server.url("/a")).build());
-    call.cancel();
-
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-    }
-    assertThat(server.getRequestCount()).isEqualTo(0);
-  }
-
-  @Test public void cancelDuringHttpConnect() throws Exception {
-    cancelDuringConnect("http");
-  }
-
-  @Test public void cancelDuringHttpsConnect() throws Exception {
-    cancelDuringConnect("https");
-  }
-
-  /** Cancel a call that's waiting for connect to complete. */
-  private void cancelDuringConnect(String scheme) throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.STALL_SOCKET_AT_START));
-
-    long cancelDelayMillis = 300L;
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/").newBuilder().scheme(scheme).build())
-        .build());
-    cancelLater(call, cancelDelayMillis);
-
-    long startNanos = System.nanoTime();
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-    }
-    long elapsedNanos = System.nanoTime() - startNanos;
-    assertThat((float) TimeUnit.NANOSECONDS.toMillis(elapsedNanos)).isCloseTo(
-        (float) cancelDelayMillis, offset(100f));
-  }
-
-  @Test public void cancelImmediatelyAfterEnqueue() throws Exception {
-    server.enqueue(new MockResponse());
-    final CountDownLatch latch = new CountDownLatch(1);
-    client = client.newBuilder()
-        .addNetworkInterceptor(chain -> {
-          try {
-            latch.await();
-          } catch (InterruptedException e) {
-            throw new AssertionError(e);
-          }
-          return chain.proceed(chain.request());
-        })
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/a"))
-        .build());
-    call.enqueue(callback);
-    call.cancel();
-    latch.countDown();
-
-    callback.await(server.url("/a")).assertFailure("Canceled", "Socket closed");
-  }
-
-  @Test public void cancelAll() throws Exception {
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    call.enqueue(callback);
-    client.dispatcher().cancelAll();
-    callback.await(server.url("/")).assertFailure("Canceled", "Socket closed");
-  }
-
-  @Test
-  public void cancelWhileRequestHeadersAreSent() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-
-    EventListener listener = new EventListener() {
-      @Override public void requestHeadersStart(Call call) {
-        try {
-          // Cancel call from another thread to avoid reentrance.
-          cancelLater(call, 0).join();
-        } catch (InterruptedException e) {
-          throw new AssertionError();
-        }
-      }
-    };
-    client = client.newBuilder().eventListener(listener).build();
-
-    Call call = client.newCall(new Request.Builder().url(server.url("/a")).build());
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test
-  public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    cancelWhileRequestHeadersAreSent();
-  }
-
-  @Test public void cancelBeforeBodyIsRead() throws Exception {
-    server.enqueue(new MockResponse().setBody("def").throttleBody(1, 750, TimeUnit.MILLISECONDS));
-
-    final Call call = client.newCall(new Request.Builder().url(server.url("/a")).build());
-    ExecutorService executor = Executors.newSingleThreadExecutor();
-    Future<Response> result = executor.submit(call::execute);
-
-    Thread.sleep(100); // wait for it to go in flight.
-
-    call.cancel();
-    try {
-      result.get().body().bytes();
-      fail();
-    } catch (IOException expected) {
-    }
-    assertThat(server.getRequestCount()).isEqualTo(1);
-  }
-
-  @Test public void cancelInFlightBeforeResponseReadThrowsIOE() throws Exception {
-    Request request = new Request.Builder().url(server.url("/a")).build();
-    final Call call = client.newCall(request);
-
-    server.setDispatcher(new Dispatcher() {
-      @Override public MockResponse dispatch(RecordedRequest request) {
-        call.cancel();
-        return new MockResponse().setBody("A");
-      }
-    });
-
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void cancelInFlightBeforeResponseReadThrowsIOE_HTTPS() throws Exception {
-    enableTls();
-    cancelInFlightBeforeResponseReadThrowsIOE();
-  }
-
-  @Test public void cancelInFlightBeforeResponseReadThrowsIOE_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    cancelInFlightBeforeResponseReadThrowsIOE();
-  }
-
-  /**
-   * This test puts a request in front of one that is to be canceled, so that it is canceled before
-   * I/O takes place.
-   */
-  @Test public void canceledBeforeIOSignalsOnFailure() throws Exception {
-    // Force requests to be executed serially.
-    okhttp3.Dispatcher dispatcher = new okhttp3.Dispatcher(client.dispatcher().executorService());
-    dispatcher.setMaxRequests(1);
-    client = client.newBuilder()
-        .dispatcher(dispatcher)
-        .build();
-
-    Request requestA = new Request.Builder().url(server.url("/a")).build();
-    Request requestB = new Request.Builder().url(server.url("/b")).build();
-    final Call callA = client.newCall(requestA);
-    final Call callB = client.newCall(requestB);
-
-    server.setDispatcher(new Dispatcher() {
-      char nextResponse = 'A';
-
-      @Override public MockResponse dispatch(RecordedRequest request) {
-        callB.cancel();
-        return new MockResponse().setBody(Character.toString(nextResponse++));
-      }
-    });
-
-    callA.enqueue(callback);
-    callB.enqueue(callback);
-    assertThat(server.takeRequest().getPath()).isEqualTo("/a");
-
-    callback.await(requestA.url()).assertBody("A");
-    // At this point we know the callback is ready, and that it will receive a cancel failure.
-    callback.await(requestB.url()).assertFailure("Canceled", "Socket closed");
-  }
-
-  @Test public void canceledBeforeIOSignalsOnFailure_HTTPS() throws Exception {
-    enableTls();
-    canceledBeforeIOSignalsOnFailure();
-  }
-
-  @Test public void canceledBeforeIOSignalsOnFailure_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    canceledBeforeIOSignalsOnFailure();
-  }
-
-  @Test public void canceledBeforeResponseReadSignalsOnFailure() throws Exception {
-    Request requestA = new Request.Builder().url(server.url("/a")).build();
-    final Call call = client.newCall(requestA);
-    server.setDispatcher(new Dispatcher() {
-      @Override public MockResponse dispatch(RecordedRequest request) {
-        call.cancel();
-        return new MockResponse().setBody("A");
-      }
-    });
-
-    call.enqueue(callback);
-    assertThat(server.takeRequest().getPath()).isEqualTo("/a");
-
-    callback.await(requestA.url()).assertFailure("Canceled", "stream was reset: CANCEL",
-        "Socket closed");
-  }
-
-  @Test public void canceledBeforeResponseReadSignalsOnFailure_HTTPS() throws Exception {
-    enableTls();
-    canceledBeforeResponseReadSignalsOnFailure();
-  }
-
-  @Test public void canceledBeforeResponseReadSignalsOnFailure_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    canceledBeforeResponseReadSignalsOnFailure();
-  }
-
-  /**
-   * There's a race condition where the cancel may apply after the stream has already been
-   * processed.
-   */
-  @Test public void canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    final AtomicReference<String> bodyRef = new AtomicReference<>();
-    final AtomicBoolean failureRef = new AtomicBoolean();
-
-    Request request = new Request.Builder().url(server.url("/a")).build();
-    final Call call = client.newCall(request);
-    call.enqueue(new Callback() {
-      @Override public void onFailure(Call call, IOException e) {
-        failureRef.set(true);
-        latch.countDown();
-      }
-
-      @Override public void onResponse(Call call, Response response) throws IOException {
-        call.cancel();
-        try {
-          bodyRef.set(response.body().string());
-        } catch (IOException e) { // It is ok if this broke the stream.
-          bodyRef.set("A");
-          throw e; // We expect to not loop into onFailure in this case.
-        } finally {
-          latch.countDown();
-        }
-      }
-    });
-
-    latch.await();
-    assertThat(bodyRef.get()).isEqualTo("A");
-    assertThat(failureRef.get()).isFalse();
-  }
-
-  @Test public void canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce_HTTPS()
-      throws Exception {
-    enableTls();
-    canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce();
-  }
-
-  @Test public void canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce_HTTP_2()
-      throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce();
-  }
-
-  @Test public void cancelWithInterceptor() throws Exception {
-    client = client.newBuilder()
-        .addInterceptor(chain -> {
-          chain.proceed(chain.request());
-          throw new AssertionError(); // We expect an exception.
-        })
-        .build();
-
-    Call call = client.newCall(new Request.Builder().url(server.url("/a")).build());
-    call.cancel();
-
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-    }
-    assertThat(server.getRequestCount()).isEqualTo(0);
-  }
-
-  @Test public void gzip() throws Exception {
-    Buffer gzippedBody = gzip("abcabcabc");
-    String bodySize = Long.toString(gzippedBody.size());
-
-    server.enqueue(new MockResponse()
-        .setBody(gzippedBody)
-        .addHeader("Content-Encoding: gzip"));
-
-    // Confirm that the user request doesn't have Accept-Encoding, and the user
-    // response doesn't have a Content-Encoding or Content-Length.
-    RecordedResponse userResponse = executeSynchronously("/");
-    userResponse.assertCode(200)
-        .assertRequestHeader("Accept-Encoding")
-        .assertHeader("Content-Encoding")
-        .assertHeader("Content-Length")
-        .assertBody("abcabcabc");
-
-    // But the network request doesn't lie. OkHttp used gzip for this call.
-    userResponse.networkResponse()
-        .assertHeader("Content-Encoding", "gzip")
-        .assertHeader("Content-Length", bodySize)
-        .assertRequestHeader("Accept-Encoding", "gzip");
-  }
-
-  /** https://github.com/square/okhttp/issues/1927 */
-  @Test public void gzipResponseAfterAuthenticationChallenge() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(401));
-    server.enqueue(new MockResponse()
-        .setBody(gzip("abcabcabc"))
-        .addHeader("Content-Encoding: gzip"));
-    client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator("password", null))
-        .build();
-
-    executeSynchronously("/").assertBody("abcabcabc");
-  }
-
-  @Test public void rangeHeaderPreventsAutomaticGzip() throws Exception {
-    Buffer gzippedBody = gzip("abcabcabc");
-
-    // Enqueue a gzipped response. Our request isn't expecting it, but that's okay.
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
-        .setBody(gzippedBody)
-        .addHeader("Content-Encoding: gzip")
-        .addHeader("Content-Range: bytes 0-" + (gzippedBody.size() - 1)));
-
-    // Make a range request.
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Range", "bytes=0-")
-        .build();
-    Call call = client.newCall(request);
-
-    // The response is not decompressed.
-    Response response = call.execute();
-    assertThat(response.header("Content-Encoding")).isEqualTo("gzip");
-    assertThat(response.body().source().readByteString()).isEqualTo(gzippedBody.snapshot());
-
-    // The request did not offer gzip support.
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getHeader("Accept-Encoding")).isNull();
-  }
-
-  @Test public void asyncResponseCanBeConsumedLater() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setBody("def"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("User-Agent", "SyncApiTest")
-        .build();
-
-    final BlockingQueue<Response> responseRef = new SynchronousQueue<>();
-    client.newCall(request).enqueue(new Callback() {
-      @Override public void onFailure(Call call, IOException e) {
-        throw new AssertionError();
-      }
-
-      @Override public void onResponse(Call call, Response response) throws IOException {
-        try {
-          responseRef.put(response);
-        } catch (InterruptedException e) {
-          throw new AssertionError();
-        }
-      }
-    });
-
-    Response response = responseRef.take();
-    assertThat(response.code()).isEqualTo(200);
-    assertThat(response.body().string()).isEqualTo("abc");
-
-    // Make another request just to confirm that that connection can be reused...
-    executeSynchronously("/").assertBody("def");
-    // New connection.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    // Connection reused.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-
-    // ... even before we close the response body!
-    response.body().close();
-  }
-
-  @Test public void userAgentIsIncludedByDefault() throws Exception {
-    server.enqueue(new MockResponse());
-
-    executeSynchronously("/");
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getHeader("User-Agent")
-        .matches(Version.userAgent())).isTrue();
-  }
-
-  @Test public void setFollowRedirectsFalse() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(302)
-        .addHeader("Location: /b")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    client = client.newBuilder()
-        .followRedirects(false)
-        .build();
-    executeSynchronously("/a")
-        .assertBody("A")
-        .assertCode(302);
-  }
-
-  @Test public void expect100ContinueNonEmptyRequestBody() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.EXPECT_CONTINUE));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
-        .build();
-
-    executeSynchronously(request)
-        .assertCode(200)
-        .assertSuccessful();
-
-    assertThat(server.takeRequest().getBody().readUtf8()).isEqualTo("abc");
-  }
-
-  @Test public void expect100ContinueEmptyRequestBody() throws Exception {
-    server.enqueue(new MockResponse());
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.get("text/plain"), ""))
-        .build();
-
-    executeSynchronously(request)
-        .assertCode(200)
-        .assertSuccessful();
-  }
-
-  @Test public void expect100ContinueEmptyRequestBody_HTTP2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    expect100ContinueEmptyRequestBody();
-  }
-
-  @Test public void expect100ContinueTimesOutWithoutContinue() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.NO_RESPONSE));
-
-    client = client.newBuilder()
-        .readTimeout(500, TimeUnit.MILLISECONDS)
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
-        .build();
-
-    Call call = client.newCall(request);
-    try {
-      call.execute();
-      fail();
-    } catch (SocketTimeoutException expected) {
-    }
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("");
-  }
-
-  @Test public void expect100ContinueTimesOutWithoutContinue_HTTP2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    expect100ContinueTimesOutWithoutContinue();
-  }
-
-  @Test public void serverRespondsWithUnsolicited100Continue() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.CONTINUE_ALWAYS));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
-        .build();
-
-    executeSynchronously(request)
-        .assertCode(200)
-        .assertSuccessful();
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("abc");
-  }
-
-  @Test public void serverRespondsWithUnsolicited100Continue_HTTP2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    serverRespondsWithUnsolicited100Continue();
-  }
-
-  @Test public void serverRespondsWith100ContinueOnly() throws Exception {
-    client = client.newBuilder()
-        .readTimeout(1, TimeUnit.SECONDS)
-        .build();
-
-    server.enqueue(new MockResponse()
-        .setStatus("HTTP/1.1 100 Continue"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
-        .build();
-
-    Call call = client.newCall(request);
-    try {
-      call.execute();
-      fail();
-    } catch (SocketTimeoutException expected) {
-    }
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("abc");
-  }
-
-  @Test public void serverRespondsWith100ContinueOnly_HTTP2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    serverRespondsWith100ContinueOnly();
-  }
-
-  @Test public void successfulExpectContinuePermitsConnectionReuse() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.EXPECT_CONTINUE));
-    server.enqueue(new MockResponse());
-
-    executeSynchronously(new Request.Builder()
-        .url(server.url("/"))
-        .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
-        .build());
-    executeSynchronously(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void successfulExpectContinuePermitsConnectionReuseWithHttp2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    successfulExpectContinuePermitsConnectionReuse();
-  }
-
-  @Test public void unsuccessfulExpectContinuePreventsConnectionReuse() throws Exception {
-    server.enqueue(new MockResponse());
-    server.enqueue(new MockResponse());
-
-    executeSynchronously(new Request.Builder()
-        .url(server.url("/"))
-        .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
-        .build());
-    executeSynchronously(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-  }
-
-  @Test public void unsuccessfulExpectContinuePermitsConnectionReuseWithHttp2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-
-    server.enqueue(new MockResponse());
-    server.enqueue(new MockResponse());
-
-    executeSynchronously(new Request.Builder()
-        .url(server.url("/"))
-        .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
-        .build());
-    executeSynchronously(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  /** We forbid non-ASCII characters in outgoing request headers, but accept UTF-8. */
-  @Test public void responseHeaderParsingIsLenient() throws Exception {
-    Headers headers = new Headers.Builder()
-        .add("Content-Length", "0")
-        .addLenient("a\tb: c\u007fd")
-        .addLenient(": ef")
-        .addLenient("\ud83c\udf69: \u2615\ufe0f")
-        .build();
-    server.enqueue(new MockResponse().setHeaders(headers));
-
-    executeSynchronously("/")
-        .assertHeader("a\tb", "c\u007fd")
-        .assertHeader("\ud83c\udf69", "\u2615\ufe0f")
-        .assertHeader("", "ef");
-  }
-
-  @Test public void customDns() throws Exception {
-    // Configure a DNS that returns our local MockWebServer for android.com.
-    FakeDns dns = new FakeDns();
-    dns.set("android.com", Dns.SYSTEM.lookup(server.url("/").host()));
-    client = client.newBuilder()
-        .dns(dns)
-        .build();
-
-    server.enqueue(new MockResponse());
-    Request request = new Request.Builder()
-        .url(server.url("/").newBuilder().host("android.com").build())
-        .build();
-    executeSynchronously(request).assertCode(200);
-
-    dns.assertRequests("android.com");
-  }
-  @Test public void dnsReturnsZeroIpAddresses() throws Exception {
-    // Configure a DNS that returns our local MockWebServer for android.com.
-    FakeDns dns = new FakeDns();
-    List<InetAddress> ipAddresses = new ArrayList<>();
-    dns.set("android.com", ipAddresses);
-    client = client.newBuilder()
-        .dns(dns)
-        .build();
-
-    server.enqueue(new MockResponse());
-    Request request = new Request.Builder()
-        .url(server.url("/").newBuilder().host("android.com").build())
-        .build();
-    executeSynchronously(request).assertFailure(dns + " returned no addresses for android.com");
-
-    dns.assertRequests("android.com");
-  }
-
-  /** We had a bug where failed HTTP/2 calls could break the entire connection. */
-  @Test public void failingCallsDoNotInterfereWithConnection() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-
-    server.enqueue(new MockResponse().setBody("Response 1"));
-    server.enqueue(new MockResponse().setBody("Response 2"));
-
-    RequestBody requestBody = new RequestBody() {
-      @Override public MediaType contentType() {
-        return null;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        sink.writeUtf8("abc");
-        sink.flush();
-
-        makeFailingCall();
-
-        sink.writeUtf8("def");
-        sink.flush();
-      }
-    };
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .post(requestBody)
-        .build());
-    assertThat(call.execute().body().string()).isEqualTo("Response 1");
-  }
-
-  /** Test which headers are sent unencrypted to the HTTP proxy. */
-  @Test public void proxyConnectOmitsApplicationHeaders() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
-        .clearHeaders());
-    server.enqueue(new MockResponse()
-        .setBody("encrypted response from the origin server"));
-
-    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .proxy(server.toProxyAddress())
-        .hostnameVerifier(hostnameVerifier)
-        .build();
-
-    Request request = new Request.Builder()
-        .url("https://android.com/foo")
-        .header("Private", "Secret")
-        .header("User-Agent", "App 1.0")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo(
-        "encrypted response from the origin server");
-
-    RecordedRequest connect = server.takeRequest();
-    assertThat(connect.getHeader("Private")).isNull();
-    assertThat(connect.getHeader("User-Agent")).isEqualTo(Version.userAgent());
-    assertThat(connect.getHeader("Proxy-Connection")).isEqualTo("Keep-Alive");
-    assertThat(connect.getHeader("Host")).isEqualTo("android.com:443");
-
-    RecordedRequest get = server.takeRequest();
-    assertThat(get.getHeader("Private")).isEqualTo("Secret");
-    assertThat(get.getHeader("User-Agent")).isEqualTo("App 1.0");
-
-    assertThat(hostnameVerifier.calls).isEqualTo(Arrays.asList("verify android.com"));
-  }
-
-  /** Respond to a proxy authorization challenge. */
-  @Test public void proxyAuthenticateOnConnect() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
-    server.enqueue(new MockResponse()
-        .setResponseCode(407)
-        .addHeader("Proxy-Authenticate: Basic realm=\"localhost\""));
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
-        .clearHeaders());
-    server.enqueue(new MockResponse()
-        .setBody("response body"));
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .proxy(server.toProxyAddress())
-        .proxyAuthenticator(new RecordingOkAuthenticator("password", "Basic"))
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-
-    Request request = new Request.Builder()
-        .url("https://android.com/foo")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("response body");
-
-    RecordedRequest connect1 = server.takeRequest();
-    assertThat(connect1.getRequestLine()).isEqualTo("CONNECT android.com:443 HTTP/1.1");
-    assertThat(connect1.getHeader("Proxy-Authorization")).isNull();
-
-    RecordedRequest connect2 = server.takeRequest();
-    assertThat(connect2.getRequestLine()).isEqualTo("CONNECT android.com:443 HTTP/1.1");
-    assertThat(connect2.getHeader("Proxy-Authorization")).isEqualTo("password");
-
-    RecordedRequest get = server.takeRequest();
-    assertThat(get.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
-    assertThat(get.getHeader("Proxy-Authorization")).isNull();
-  }
-
-  /** Confirm that the proxy authenticator works for unencrypted HTTP proxies. */
-  @Test public void httpProxyAuthenticate() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(407)
-        .addHeader("Proxy-Authenticate: Basic realm=\"localhost\""));
-    server.enqueue(new MockResponse()
-        .setBody("response body"));
-
-    client = client.newBuilder()
-        .proxy(server.toProxyAddress())
-        .proxyAuthenticator(new RecordingOkAuthenticator("password", "Basic"))
-        .build();
-
-    Request request = new Request.Builder()
-        .url("http://android.com/foo")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("response body");
-
-    RecordedRequest get1 = server.takeRequest();
-    assertThat(get1.getRequestLine()).isEqualTo("GET http://android.com/foo HTTP/1.1");
-    assertThat(get1.getHeader("Proxy-Authorization")).isNull();
-
-    RecordedRequest get2 = server.takeRequest();
-    assertThat(get2.getRequestLine()).isEqualTo("GET http://android.com/foo HTTP/1.1");
-    assertThat(get2.getHeader("Proxy-Authorization")).isEqualTo("password");
-  }
-
-  /**
-   * OkHttp has a bug where a `Connection: close` response header is not honored when establishing a
-   * TLS tunnel. https://github.com/square/okhttp/issues/2426
-   */
-  @Test public void proxyAuthenticateOnConnectWithConnectionClose() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
-    server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
-    server.enqueue(new MockResponse()
-        .setResponseCode(407)
-        .addHeader("Proxy-Authenticate: Basic realm=\"localhost\"")
-        .addHeader("Connection: close"));
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
-        .clearHeaders());
-    server.enqueue(new MockResponse()
-        .setBody("response body"));
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .proxy(server.toProxyAddress())
-        .proxyAuthenticator(new RecordingOkAuthenticator("password", "Basic"))
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-
-    Request request = new Request.Builder()
-        .url("https://android.com/foo")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("response body");
-
-    // First CONNECT call needs a new connection.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-
-    // Second CONNECT call needs a new connection.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-
-    // GET reuses the connection from the second connect.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void tooManyProxyAuthFailuresWithConnectionClose() throws IOException {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
-    server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
-    for (int i = 0; i < 21; i++) {
-      server.enqueue(new MockResponse()
-          .setResponseCode(407)
-          .addHeader("Proxy-Authenticate: Basic realm=\"localhost\"")
-          .addHeader("Connection: close"));
-    }
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .proxy(server.toProxyAddress())
-        .proxyAuthenticator(new RecordingOkAuthenticator("password", "Basic"))
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-
-    Request request = new Request.Builder()
-        .url("https://android.com/foo")
-        .build();
-    try {
-      client.newCall(request).execute();
-      fail();
-    } catch (ProtocolException expected) {
-    }
-  }
-
-  /**
-   * Confirm that we don't send the Proxy-Authorization header from the request to the proxy server.
-   * We used to have that behavior but it is problematic because unrelated requests end up sharing
-   * credentials. Worse, that approach leaks proxy credentials to the origin server.
-   */
-  @Test public void noPreemptiveProxyAuthorization() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
-        .clearHeaders());
-    server.enqueue(new MockResponse()
-        .setBody("response body"));
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .proxy(server.toProxyAddress())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-
-    Request request = new Request.Builder()
-        .url("https://android.com/foo")
-        .header("Proxy-Authorization", "password")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("response body");
-
-    RecordedRequest connect1 = server.takeRequest();
-    assertThat(connect1.getHeader("Proxy-Authorization")).isNull();
-
-    RecordedRequest connect2 = server.takeRequest();
-    assertThat(connect2.getHeader("Proxy-Authorization")).isEqualTo("password");
-  }
-
-  /** Confirm that we can send authentication information without being prompted first. */
-  @Test public void preemptiveProxyAuthentication() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
-        .clearHeaders());
-    server.enqueue(new MockResponse()
-        .setBody("encrypted response from the origin server"));
-
-    final String credential = Credentials.basic("jesse", "password1");
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .proxy(server.toProxyAddress())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .proxyAuthenticator((route, response) -> {
-          assertThat(response.request().method()).isEqualTo("CONNECT");
-          assertThat(response.code()).isEqualTo(HttpURLConnection.HTTP_PROXY_AUTH);
-          assertThat(response.request().url().host()).isEqualTo("android.com");
-
-          List<Challenge> challenges = response.challenges();
-          assertThat(challenges.get(0).scheme()).isEqualTo("OkHttp-Preemptive");
-
-          return response.request().newBuilder()
-              .header("Proxy-Authorization", credential)
-              .build();
-        })
-        .build();
-
-    Request request = new Request.Builder()
-        .url("https://android.com/foo")
-        .build();
-
-    executeSynchronously(request).assertSuccessful();
-
-    RecordedRequest connect = server.takeRequest();
-    assertThat(connect.getMethod()).isEqualTo("CONNECT");
-    assertThat(connect.getHeader("Proxy-Authorization")).isEqualTo(credential);
-    assertThat(connect.getPath()).isEqualTo("/");
-
-    RecordedRequest get = server.takeRequest();
-    assertThat(get.getMethod()).isEqualTo("GET");
-    assertThat(get.getHeader("Proxy-Authorization")).isNull();
-    assertThat(get.getPath()).isEqualTo("/foo");
-  }
-
-  @Test public void preemptiveThenReactiveProxyAuthentication() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_PROXY_AUTH)
-        .addHeader("Proxy-Authenticate", "Basic realm=\"localhost\"")
-        .setBody("proxy auth required"));
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
-        .clearHeaders());
-    server.enqueue(new MockResponse());
-
-    final List<String> challengeSchemes = new ArrayList<>();
-    final String credential = Credentials.basic("jesse", "password1");
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .proxy(server.toProxyAddress())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .proxyAuthenticator((route, response) -> {
-          List<Challenge> challenges = response.challenges();
-          challengeSchemes.add(challenges.get(0).scheme());
-          return response.request().newBuilder()
-              .header("Proxy-Authorization", credential)
-              .build();
-        })
-        .build();
-
-    Request request = new Request.Builder()
-        .url("https://android.com/foo")
-        .build();
-
-    executeSynchronously(request).assertSuccessful();
-
-    RecordedRequest connect1 = server.takeRequest();
-    assertThat(connect1.getMethod()).isEqualTo("CONNECT");
-    assertThat(connect1.getHeader("Proxy-Authorization")).isEqualTo(credential);
-
-    RecordedRequest connect2 = server.takeRequest();
-    assertThat(connect2.getMethod()).isEqualTo("CONNECT");
-    assertThat(connect2.getHeader("Proxy-Authorization")).isEqualTo(credential);
-
-    assertThat(challengeSchemes).isEqualTo(Arrays.asList("OkHttp-Preemptive", "Basic"));
-  }
-
-  @Test public void interceptorGetsHttp2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-
-    // Capture the protocol as it is observed by the interceptor.
-    final AtomicReference<Protocol> protocolRef = new AtomicReference<>();
-    Interceptor interceptor = chain -> {
-      protocolRef.set(chain.connection().protocol());
-      return chain.proceed(chain.request());
-    };
-    client = client.newBuilder()
-        .addNetworkInterceptor(interceptor)
-        .build();
-
-    // Make an HTTP/2 request and confirm that the protocol matches.
-    server.enqueue(new MockResponse());
-    executeSynchronously("/");
-    assertThat(protocolRef.get()).isEqualTo(Protocol.HTTP_2);
-  }
-
-  @Test public void serverSendsInvalidResponseHeaders() throws Exception {
-    server.enqueue(new MockResponse()
-        .setStatus("HTP/1.1 200 OK"));
-
-    executeSynchronously("/")
-        .assertFailure("Unexpected status line: HTP/1.1 200 OK");
-  }
-
-  @Test public void serverSendsInvalidCodeTooLarge() throws Exception {
-    server.enqueue(new MockResponse()
-        .setStatus("HTTP/1.1 2147483648 OK"));
-
-    executeSynchronously("/")
-        .assertFailure("Unexpected status line: HTTP/1.1 2147483648 OK");
-  }
-
-  @Test public void serverSendsInvalidCodeNotANumber() throws Exception {
-    server.enqueue(new MockResponse()
-        .setStatus("HTTP/1.1 00a OK"));
-
-    executeSynchronously("/")
-        .assertFailure("Unexpected status line: HTTP/1.1 00a OK");
-  }
-
-  @Test public void serverSendsUnnecessaryWhitespace() throws Exception {
-    server.enqueue(new MockResponse()
-        .setStatus(" HTTP/1.1 200 OK"));
-
-    executeSynchronously("/")
-        .assertFailure("Unexpected status line:  HTTP/1.1 200 OK");
-  }
-
-  @Test public void requestHeaderNameWithSpaceForbidden() throws Exception {
-    try {
-      new Request.Builder().addHeader("a b", "c");
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          "Unexpected char 0x20 at 1 in header name: a b");
-    }
-  }
-
-  @Test public void requestHeaderNameWithTabForbidden() throws Exception {
-    try {
-      new Request.Builder().addHeader("a\tb", "c");
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          "Unexpected char 0x09 at 1 in header name: a\tb");
-    }
-  }
-
-  @Test public void responseHeaderNameWithSpacePermitted() throws Exception {
-    server.enqueue(new MockResponse()
-        .clearHeaders()
-        .addHeader("content-length: 0")
-        .addHeaderLenient("a b", "c"));
-
-    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
-    Response response = call.execute();
-    assertThat(response.header("a b")).isEqualTo("c");
-  }
-
-  @Test public void responseHeaderNameWithTabPermitted() throws Exception {
-    server.enqueue(new MockResponse()
-        .clearHeaders()
-        .addHeader("content-length: 0")
-        .addHeaderLenient("a\tb", "c"));
-
-    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
-    Response response = call.execute();
-    assertThat(response.header("a\tb")).isEqualTo("c");
-  }
-
-  @Test public void connectFails() throws Exception {
-    server.shutdown();
-
-    executeSynchronously("/")
-        .assertFailure(IOException.class);
-  }
-
-  @Test public void requestBodySurvivesRetries() throws Exception {
-    server.enqueue(new MockResponse());
-
-    // Enable a misconfigured proxy selector to guarantee that the request is retried.
-    client = client.newBuilder()
-        .proxySelector(new FakeProxySelector()
-            .addProxy(server2.toProxyAddress())
-            .addProxy(Proxy.NO_PROXY))
-        .build();
-    server2.shutdown();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
-        .build();
-
-    executeSynchronously(request);
-    assertThat(server.takeRequest().getBody().readUtf8()).isEqualTo("abc");
-  }
-
-  @Ignore // This may fail in DNS lookup, which we don't have timeouts for.
-  @Test public void invalidHost() throws Exception {
-    Request request = new Request.Builder()
-        .url(HttpUrl.get("http://1234.1.1.1/"))
-        .build();
-
-    executeSynchronously(request)
-        .assertFailure(UnknownHostException.class);
-  }
-
-  @Test public void uploadBodySmallChunkedEncoding() throws Exception {
-    upload(true, 1048576, 256);
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getBodySize()).isEqualTo(1048576);
-    assertThat(recordedRequest.getChunkSizes().isEmpty()).isFalse();
-  }
-
-  @Test public void uploadBodyLargeChunkedEncoding() throws Exception {
-    upload(true, 1048576, 65536);
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getBodySize()).isEqualTo(1048576);
-    assertThat(recordedRequest.getChunkSizes().isEmpty()).isFalse();
-  }
-
-  @Test public void uploadBodySmallFixedLength() throws Exception {
-    upload(false, 1048576, 256);
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getBodySize()).isEqualTo(1048576);
-    assertThat(recordedRequest.getChunkSizes().isEmpty()).isTrue();
-  }
-
-  @Test public void uploadBodyLargeFixedLength() throws Exception {
-    upload(false, 1048576, 65536);
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getBodySize()).isEqualTo(1048576);
-    assertThat(recordedRequest.getChunkSizes().isEmpty()).isTrue();
-  }
-
-  private void upload(
-      final boolean chunked, final int size, final int writeSize) throws Exception {
-    server.enqueue(new MockResponse());
-    executeSynchronously(new Request.Builder()
-        .url(server.url("/"))
-        .post(requestBody(chunked, size, writeSize))
-        .build());
-  }
-
-  /** https://github.com/square/okhttp/issues/2344 */
-  @Test public void ipv6HostHasSquareBraces() throws Exception {
-    // Use a proxy to fake IPv6 connectivity, even if localhost doesn't have IPv6.
-    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
-    server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
-        .clearHeaders());
-    server.enqueue(new MockResponse()
-        .setBody("response body"));
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .proxy(server.toProxyAddress())
-        .build();
-
-    Request request = new Request.Builder()
-        .url("https://[::1]/")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("response body");
-
-    RecordedRequest connect = server.takeRequest();
-    assertThat(connect.getRequestLine()).isEqualTo("CONNECT [::1]:443 HTTP/1.1");
-    assertThat(connect.getHeader("Host")).isEqualTo("[::1]:443");
-
-    RecordedRequest get = server.takeRequest();
-    assertThat(get.getRequestLine()).isEqualTo("GET / HTTP/1.1");
-    assertThat(get.getHeader("Host")).isEqualTo("[::1]");
-  }
-
-  private RequestBody requestBody(final boolean chunked, final long size, final int writeSize) {
-    final byte[] buffer = new byte[writeSize];
-    Arrays.fill(buffer, (byte) 'x');
-
-    return new RequestBody() {
-      @Override public MediaType contentType() {
-        return MediaType.get("text/plain; charset=utf-8");
-      }
-
-      @Override public long contentLength() throws IOException {
-        return chunked ? -1L : size;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        for (int count = 0; count < size; count += writeSize) {
-          sink.write(buffer, 0, (int) Math.min(size - count, writeSize));
-        }
-      }
-    };
-  }
-
-  @Test public void emptyResponseBody() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("abc", "def"));
-    executeSynchronously("/")
-        .assertCode(200)
-        .assertHeader("abc", "def")
-        .assertBody("");
-  }
-
-  @Test public void leakedResponseBodyLogsStackTrace() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("This gets leaked."));
-
-    client = clientTestRule.client.newBuilder()
-        .connectionPool(new ConnectionPool(0, 10, TimeUnit.MILLISECONDS))
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    Level original = logger.getLevel();
-    logger.setLevel(Level.FINE);
-    logHandler.setFormatter(new SimpleFormatter());
-    try {
-      client.newCall(request).execute(); // Ignore the response so it gets leaked then GC'd.
-      awaitGarbageCollection();
-
-      String message = logHandler.take();
-      assertThat(message.contains("A connection to " + server.url("/") + " was leaked."
-            + " Did you forget to close a response body?")).isTrue();
-      assertThat(message.contains("okhttp3.RealCall.execute(")).isTrue();
-      assertThat(message.contains("okhttp3.CallTest.leakedResponseBodyLogsStackTrace(")).isTrue();
-    } finally {
-      logger.setLevel(original);
-    }
-  }
-
-  @Test public void asyncLeakedResponseBodyLogsStackTrace() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("This gets leaked."));
-
-    client = clientTestRule.client.newBuilder()
-        .connectionPool(new ConnectionPool(0, 10, TimeUnit.MILLISECONDS))
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    Level original = logger.getLevel();
-    logger.setLevel(Level.FINE);
-    logHandler.setFormatter(new SimpleFormatter());
-    try {
-      final CountDownLatch latch = new CountDownLatch(1);
-      client.newCall(request).enqueue(new Callback() {
-        @Override public void onFailure(Call call, IOException e) {
-          fail();
-        }
-
-        @Override public void onResponse(Call call, Response response) throws IOException {
-          // Ignore the response so it gets leaked then GC'd.
-          latch.countDown();
-        }
-      });
-      latch.await();
-      // There's some flakiness when triggering a GC for objects in a separate thread. Adding a
-      // small delay appears to ensure the objects will get GC'd.
-      Thread.sleep(200);
-      awaitGarbageCollection();
-
-      String message = logHandler.take();
-      assertThat(message.contains("A connection to " + server.url("/") + " was leaked."
-            + " Did you forget to close a response body?")).isTrue();
-      assertThat(message.contains("okhttp3.RealCall.enqueue(")).isTrue();
-      assertThat(message.contains("okhttp3.CallTest.asyncLeakedResponseBodyLogsStackTrace(")).isTrue();
-    } finally {
-      logger.setLevel(original);
-    }
-  }
-
-  @Test public void failedAuthenticatorReleasesConnection() throws IOException {
-    server.enqueue(new MockResponse()
-        .setResponseCode(401));
-
-    client = client.newBuilder()
-        .authenticator((route, response) -> { throw new IOException("IOException!"); })
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    executeSynchronously(request)
-        .assertFailure(IOException.class);
-
-    assertThat(client.connectionPool().idleConnectionCount()).isEqualTo(1);
-  }
-
-  @Test public void failedProxyAuthenticatorReleasesConnection() throws IOException {
-    server.enqueue(new MockResponse()
-        .setResponseCode(407));
-
-    client = client.newBuilder()
-        .proxyAuthenticator((route, response) -> { throw new IOException("IOException!"); })
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    executeSynchronously(request)
-        .assertFailure(IOException.class);
-
-    assertThat(client.connectionPool().idleConnectionCount()).isEqualTo(1);
-  }
-
-  @Test public void httpsWithIpAddress() throws Exception {
-    String localIpAddress = InetAddress.getLoopbackAddress().getHostAddress();
-
-    // Create a certificate with an IP address in the subject alt name.
-    HeldCertificate heldCertificate = new HeldCertificate.Builder()
-        .commonName("example.com")
-        .addSubjectAlternativeName(localIpAddress)
-        .build();
-    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
-        .heldCertificate(heldCertificate)
-        .addTrustedCertificate(heldCertificate.certificate())
-        .build();
-
-    // Use that certificate on the server and trust it on the client.
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .protocols(Collections.singletonList(Protocol.HTTP_1_1))
-        .build();
-
-    // Make a request.
-    server.enqueue(new MockResponse());
-    HttpUrl url = server.url("/").newBuilder()
-        .host(localIpAddress)
-        .build();
-    Request request = new Request.Builder()
-        .url(url)
-        .build();
-    executeSynchronously(request)
-        .assertCode(200);
-
-    // Confirm that the IP address was used in the host header.
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getHeader("Host")).isEqualTo(
-        (localIpAddress + ":" + server.getPort()));
-  }
-
-  @Test public void postWithFileNotFound() throws Exception {
-    final AtomicInteger called = new AtomicInteger(0);
-
-    RequestBody body = new RequestBody() {
-      @Nullable @Override public MediaType contentType() {
-        return MediaType.get("application/octet-stream");
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        called.incrementAndGet();
-        throw new FileNotFoundException();
-      }
-    };
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .post(body)
-        .build();
-
-    client = client.newBuilder()
-        .dns(new DoubleInetAddressDns())
-        .build();
-
-    executeSynchronously(request)
-        .assertFailure(FileNotFoundException.class);
-
-    assertThat(called.get()).isEqualTo(1L);
-  }
-
-  @Test public void clientReadsHeadersDataTrailersHttp1ChunkedTransferEncoding() throws Exception {
-    MockResponse mockResponse = new MockResponse()
-        .clearHeaders()
-        .addHeader("h1", "v1")
-        .addHeader("h2", "v2")
-        .setChunkedBody("HelloBonjour", 1024)
-        .setTrailers(Headers.of("trailers", "boom"));
-    server.enqueue(mockResponse);
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-
-    Response response = call.execute();
-    BufferedSource source = response.body().source();
-
-    assertThat(response.header("h1")).isEqualTo("v1");
-    assertThat(response.header("h2")).isEqualTo("v2");
-
-    assertThat(source.readUtf8(5)).isEqualTo("Hello");
-    assertThat(source.readUtf8(7)).isEqualTo("Bonjour");
-
-    assertThat(source.exhausted()).isTrue();
-    assertThat(response.trailers()).isEqualTo(Headers.of("trailers", "boom"));
-  }
-
-  @Test public void clientReadsHeadersDataTrailersHttp2() throws IOException {
-    MockResponse mockResponse = new MockResponse()
-        .clearHeaders()
-        .addHeader("h1", "v1")
-        .addHeader("h2", "v2")
-        .setBody("HelloBonjour")
-        .setTrailers(Headers.of("trailers", "boom"));
-    server.enqueue(mockResponse);
-    enableProtocol(Protocol.HTTP_2);
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-
-    try (Response response = call.execute()) {
-      BufferedSource source = response.body().source();
-
-      assertThat(response.header("h1")).isEqualTo("v1");
-      assertThat(response.header("h2")).isEqualTo("v2");
-
-      assertThat(source.readUtf8(5)).isEqualTo("Hello");
-      assertThat(source.readUtf8(7)).isEqualTo("Bonjour");
-
-      assertThat(source.exhausted()).isTrue();
-      assertThat(response.trailers()).isEqualTo(Headers.of("trailers", "boom"));
-    }
-  }
-
-  @Test public void requestBodyThrowsUnrelatedToNetwork() throws Exception {
-    server.enqueue(new MockResponse());
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .post(new RequestBody() {
-          @Override public @Nullable MediaType contentType() {
-            return null;
-          }
-
-          @Override public void writeTo(BufferedSink sink) throws IOException {
-            throw new IOException("boom");
-          }
-        })
-        .build();
-
-    executeSynchronously(request).assertFailure("boom");
-  }
-
-  @Test public void requestBodyThrowsUnrelatedToNetwork_HTTP2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    requestBodyThrowsUnrelatedToNetwork();
-  }
-
-  /** https://github.com/square/okhttp/issues/4583 */
-  @Test public void lateCancelCallsOnFailure() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    AtomicBoolean closed = new AtomicBoolean();
-
-    client = client.newBuilder()
-        .addInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
-            Response response = chain.proceed(chain.request());
-            chain.call().cancel(); // Cancel after we have the response.
-            ForwardingSource closeTrackingSource = new ForwardingSource(response.body().source()) {
-              @Override public void close() throws IOException {
-                closed.set(true);
-                super.close();
-              }
-            };
-            return response.newBuilder()
-                .body(ResponseBody.create(null, -1L, Okio.buffer(closeTrackingSource)))
-                .build();
-          }
-        })
-        .build();
-
-    executeSynchronously("/").assertFailure("Canceled");
-    assertThat(closed.get()).isTrue();
-  }
-
-  private void makeFailingCall() {
-    RequestBody requestBody = new RequestBody() {
-      @Override public MediaType contentType() {
-        return null;
-      }
-
-      @Override public long contentLength() throws IOException {
-        return 1;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        throw new IOException("write body fail!");
-      }
-    };
-    OkHttpClient nonRetryingClient = client.newBuilder()
-        .retryOnConnectionFailure(false)
-        .build();
-    Call call = nonRetryingClient.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .post(requestBody)
-        .build());
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-      assertThat(expected.getMessage()).isEqualTo("write body fail!");
-    }
-  }
-
-  private RecordedResponse executeSynchronously(String path, String... headers) throws IOException {
-    Request.Builder builder = new Request.Builder();
-    builder.url(server.url(path));
-    for (int i = 0, size = headers.length; i < size; i += 2) {
-      builder.addHeader(headers[i], headers[i + 1]);
-    }
-    return executeSynchronously(builder.build());
-  }
-
-  private RecordedResponse executeSynchronously(Request request) throws IOException {
-    Call call = client.newCall(request);
-    try {
-      Response response = call.execute();
-      String bodyString = response.body().string();
-      return new RecordedResponse(request, response, null, bodyString, null);
-    } catch (IOException e) {
-      return new RecordedResponse(request, null, null, null, e);
-    }
-  }
-
-  /**
-   * Tests that use this will fail unless boot classpath is set. Ex. {@code
-   * -Xbootclasspath/p:/tmp/alpn-boot-8.0.0.v20140317}
-   */
-  private void enableProtocol(Protocol protocol) {
-    enableTls();
-    client = client.newBuilder()
-        .protocols(Arrays.asList(protocol, Protocol.HTTP_1_1))
-        .build();
-    server.setProtocols(client.protocols());
-  }
-
-  private void enableTls() {
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-  }
-
-  private Buffer gzip(String data) throws IOException {
-    Buffer result = new Buffer();
-    BufferedSink sink = Okio.buffer(new GzipSink(result));
-    sink.writeUtf8(data);
-    sink.close();
-    return result;
-  }
-
-  private Thread cancelLater(final Call call, final long delay) {
-    Thread thread = new Thread("canceler") {
-      @Override public void run() {
-        try {
-          Thread.sleep(delay);
-        } catch (InterruptedException e) {
-          throw new AssertionError();
-        }
-        call.cancel();
-      }
-    };
-    thread.start();
-    return thread;
-  }
-
-  private SSLSocketFactory socketFactoryWithCipherSuite(
-      final SSLSocketFactory sslSocketFactory, final CipherSuite cipherSuite) {
-    return new DelegatingSSLSocketFactory(sslSocketFactory) {
-      @Override protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
-        sslSocket.setEnabledCipherSuites(new String[] { cipherSuite.javaName() });
-        return super.configureSocket(sslSocket);
-      }
-    };
-  }
-
-  private static class RecordingSSLSocketFactory extends DelegatingSSLSocketFactory {
-
-    private List<SSLSocket> socketsCreated = new ArrayList<>();
-
-    public RecordingSSLSocketFactory(SSLSocketFactory delegate) {
-      super(delegate);
-    }
-
-    @Override
-    protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
-      socketsCreated.add(sslSocket);
-      return sslSocket;
-    }
-
-    public List<SSLSocket> getSocketsCreated() {
-      return socketsCreated;
-    }
-  }
-
-  /**
-   * Used during tests that involve TLS connection fallback attempts. OkHttp includes the
-   * TLS_FALLBACK_SCSV cipher on fallback connections. See {@link FallbackTestClientSocketFactory}
-   * for details.
-   */
-  private FallbackTestClientSocketFactory suppressTlsFallbackClientSocketFactory() {
-    return new FallbackTestClientSocketFactory(handshakeCertificates.sslSocketFactory());
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java b/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
deleted file mode 100644
index a2185a9348..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
+++ /dev/null
@@ -1,274 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.security.cert.Certificate;
-import java.security.cert.X509Certificate;
-import java.util.ArrayList;
-import java.util.List;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.internal.tls.CertificateChainCleaner;
-import okhttp3.tls.HandshakeCertificates;
-import okhttp3.tls.HeldCertificate;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class CertificateChainCleanerTest {
-  @Test public void equalsFromCertificate() {
-    HeldCertificate rootA = new HeldCertificate.Builder()
-        .serialNumber(1L)
-        .build();
-    HeldCertificate rootB = new HeldCertificate.Builder()
-        .serialNumber(2L)
-        .build();
-    assertThat(CertificateChainCleaner.get(rootB.certificate(), rootA.certificate())).isEqualTo(
-        CertificateChainCleaner.get(rootA.certificate(), rootB.certificate()));
-  }
-
-  @Test public void equalsFromTrustManager() {
-    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder().build();
-    X509TrustManager x509TrustManager = handshakeCertificates.trustManager();
-    assertThat(CertificateChainCleaner.get(x509TrustManager)).isEqualTo(
-        CertificateChainCleaner.get(x509TrustManager));
-  }
-
-  @Test public void normalizeSingleSelfSignedCertificate() throws Exception {
-    HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber(1L)
-        .build();
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
-    assertThat(cleaner.clean(list(root), "hostname")).isEqualTo(list(root));
-  }
-
-  @Test public void normalizeUnknownSelfSignedCertificate() {
-    HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber(1L)
-        .build();
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get();
-
-    try {
-      cleaner.clean(list(root), "hostname");
-      fail();
-    } catch (SSLPeerUnverifiedException expected) {
-    }
-  }
-
-  @Test public void orderedChainOfCertificatesWithRoot() throws Exception {
-    HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber(1L)
-        .build();
-    HeldCertificate certA = new HeldCertificate.Builder()
-        .serialNumber(2L)
-        .signedBy(root)
-        .build();
-    HeldCertificate certB = new HeldCertificate.Builder()
-        .serialNumber(3L)
-        .signedBy(certA)
-        .build();
-
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
-    assertThat(cleaner.clean(list(certB, certA, root), "hostname")).isEqualTo(
-        list(certB, certA, root));
-  }
-
-  @Test public void orderedChainOfCertificatesWithoutRoot() throws Exception {
-    HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber(1L)
-        .build();
-    HeldCertificate certA = new HeldCertificate.Builder()
-        .serialNumber(2L)
-        .signedBy(root)
-        .build();
-    HeldCertificate certB = new HeldCertificate.Builder()
-        .serialNumber(3L)
-        .signedBy(certA)
-        .build();
-
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
-    // Root is added!
-    assertThat(cleaner.clean(list(certB, certA), "hostname")).isEqualTo(
-        list(certB, certA, root));
-  }
-
-  @Test public void unorderedChainOfCertificatesWithRoot() throws Exception {
-    HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber(1L)
-        .build();
-    HeldCertificate certA = new HeldCertificate.Builder()
-        .serialNumber(2L)
-        .signedBy(root)
-        .build();
-    HeldCertificate certB = new HeldCertificate.Builder()
-        .serialNumber(3L)
-        .signedBy(certA)
-        .build();
-    HeldCertificate certC = new HeldCertificate.Builder()
-        .serialNumber(4L)
-        .signedBy(certB)
-        .build();
-
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
-    assertThat(cleaner.clean(list(certC, certA, root, certB), "hostname")).isEqualTo(
-        list(certC, certB, certA, root));
-  }
-
-  @Test public void unorderedChainOfCertificatesWithoutRoot() throws Exception {
-    HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber(1L)
-        .build();
-    HeldCertificate certA = new HeldCertificate.Builder()
-        .serialNumber(2L)
-        .signedBy(root)
-        .build();
-    HeldCertificate certB = new HeldCertificate.Builder()
-        .serialNumber(3L)
-        .signedBy(certA)
-        .build();
-    HeldCertificate certC = new HeldCertificate.Builder()
-        .serialNumber(4L)
-        .signedBy(certB)
-        .build();
-
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
-    assertThat(cleaner.clean(list(certC, certA, certB), "hostname")).isEqualTo(
-        list(certC, certB, certA, root));
-  }
-
-  @Test public void unrelatedCertificatesAreOmitted() throws Exception {
-    HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber(1L)
-        .build();
-    HeldCertificate certA = new HeldCertificate.Builder()
-        .serialNumber(2L)
-        .signedBy(root)
-        .build();
-    HeldCertificate certB = new HeldCertificate.Builder()
-        .serialNumber(3L)
-        .signedBy(certA)
-        .build();
-    HeldCertificate certUnnecessary = new HeldCertificate.Builder()
-        .serialNumber(4L)
-        .build();
-
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
-    assertThat(cleaner.clean(list(certB, certUnnecessary, certA, root), "hostname")).isEqualTo(
-        list(certB, certA, root));
-  }
-
-  @Test public void chainGoesAllTheWayToSelfSignedRoot() throws Exception {
-    HeldCertificate selfSigned = new HeldCertificate.Builder()
-        .serialNumber(1L)
-        .build();
-    HeldCertificate trusted = new HeldCertificate.Builder()
-        .serialNumber(2L)
-        .signedBy(selfSigned)
-        .build();
-    HeldCertificate certA = new HeldCertificate.Builder()
-        .serialNumber(3L)
-        .signedBy(trusted)
-        .build();
-    HeldCertificate certB = new HeldCertificate.Builder()
-        .serialNumber(4L)
-        .signedBy(certA)
-        .build();
-
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(
-        selfSigned.certificate(), trusted.certificate());
-    assertThat(cleaner.clean(list(certB, certA), "hostname")).isEqualTo(
-        list(certB, certA, trusted, selfSigned));
-    assertThat(cleaner.clean(list(certB, certA, trusted), "hostname")).isEqualTo(
-        list(certB, certA, trusted, selfSigned));
-    assertThat(cleaner.clean(list(certB, certA, trusted, selfSigned), "hostname")).isEqualTo(
-        list(certB, certA, trusted, selfSigned));
-  }
-
-  @Test public void trustedRootNotSelfSigned() throws Exception {
-    HeldCertificate unknownSigner = new HeldCertificate.Builder()
-        .serialNumber(1L)
-        .build();
-    HeldCertificate trusted = new HeldCertificate.Builder()
-        .signedBy(unknownSigner)
-        .serialNumber(2L)
-        .build();
-    HeldCertificate intermediateCa = new HeldCertificate.Builder()
-        .signedBy(trusted)
-        .serialNumber(3L)
-        .build();
-    HeldCertificate certificate = new HeldCertificate.Builder()
-        .signedBy(intermediateCa)
-        .serialNumber(4L)
-        .build();
-
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(trusted.certificate());
-    assertThat(cleaner.clean(list(certificate, intermediateCa), "hostname")).isEqualTo(
-        list(certificate, intermediateCa, trusted));
-    assertThat(cleaner.clean(list(certificate, intermediateCa, trusted), "hostname")).isEqualTo(
-        list(certificate, intermediateCa, trusted));
-  }
-
-  @Test public void chainMaxLength() throws Exception {
-    List<HeldCertificate> heldCertificates = chainOfLength(10);
-    List<Certificate> certificates = new ArrayList<>();
-    for (HeldCertificate heldCertificate : heldCertificates) {
-      certificates.add(heldCertificate.certificate());
-    }
-
-    X509Certificate root = heldCertificates.get(heldCertificates.size() - 1).certificate();
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root);
-    assertThat(cleaner.clean(certificates, "hostname")).isEqualTo(certificates);
-    assertThat(cleaner.clean(certificates.subList(0, 9), "hostname")).isEqualTo(
-        certificates);
-  }
-
-  @Test public void chainTooLong() {
-    List<HeldCertificate> heldCertificates = chainOfLength(11);
-    List<Certificate> certificates = new ArrayList<>();
-    for (HeldCertificate heldCertificate : heldCertificates) {
-      certificates.add(heldCertificate.certificate());
-    }
-
-    X509Certificate root = heldCertificates.get(heldCertificates.size() - 1).certificate();
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root);
-    try {
-      cleaner.clean(certificates, "hostname");
-      fail();
-    } catch (SSLPeerUnverifiedException expected) {
-    }
-  }
-
-  /** Returns a chain starting at the leaf certificate and progressing to the root. */
-  private List<HeldCertificate> chainOfLength(int length) {
-    List<HeldCertificate> result = new ArrayList<>();
-    for (int i = 1; i <= length; i++) {
-      result.add(0, new HeldCertificate.Builder()
-          .signedBy(!result.isEmpty() ? result.get(0) : null)
-          .serialNumber(i)
-          .build());
-    }
-    return result;
-  }
-
-  private List<Certificate> list(HeldCertificate... heldCertificates) {
-    List<Certificate> result = new ArrayList<>();
-    for (HeldCertificate heldCertificate : heldCertificates) {
-      result.add(heldCertificate.certificate());
-    }
-    return result;
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java b/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
deleted file mode 100644
index 6e57f2cfde..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
+++ /dev/null
@@ -1,291 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import okhttp3.CertificatePinner.Pin;
-import okhttp3.tls.HeldCertificate;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class CertificatePinnerTest {
-  static HeldCertificate certA1;
-  static String certA1Sha256Pin;
-
-  static HeldCertificate certB1;
-  static String certB1Sha256Pin;
-
-  static HeldCertificate certC1;
-  static String certC1Sha256Pin;
-
-  static {
-    certA1 = new HeldCertificate.Builder()
-        .serialNumber(100L)
-        .build();
-    certA1Sha256Pin = "sha256/" + CertificatePinner.sha256(certA1.certificate()).base64();
-
-    certB1 = new HeldCertificate.Builder()
-        .serialNumber(200L)
-        .build();
-    certB1Sha256Pin = "sha256/" + CertificatePinner.sha256(certB1.certificate()).base64();
-
-    certC1 = new HeldCertificate.Builder()
-        .serialNumber(300L)
-        .build();
-    certC1Sha256Pin = "sha256/" + CertificatePinner.sha256(certC1.certificate()).base64();
-  }
-
-  @Test public void malformedPin() throws Exception {
-    CertificatePinner.Builder builder = new CertificatePinner.Builder();
-    try {
-      builder.add("example.com", "md5/DmxUShsZuNiqPQsX2Oi9uv2sCnw=");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void malformedBase64() throws Exception {
-    CertificatePinner.Builder builder = new CertificatePinner.Builder();
-    try {
-      builder.add("example.com", "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw*");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  /** Multiple certificates generated from the same keypair have the same pin. */
-  @Test public void sameKeypairSamePin() throws Exception {
-    HeldCertificate heldCertificateA2 = new HeldCertificate.Builder()
-        .keyPair(certA1.keyPair())
-        .serialNumber(101L)
-        .build();
-    String keypairACertificate2Pin = CertificatePinner.pin(heldCertificateA2.certificate());
-
-    HeldCertificate heldCertificateB2 = new HeldCertificate.Builder()
-        .keyPair(certB1.keyPair())
-        .serialNumber(201L)
-        .build();
-    String keypairBCertificate2Pin = CertificatePinner.pin(heldCertificateB2.certificate());
-
-    assertThat(keypairACertificate2Pin).isEqualTo(certA1Sha256Pin);
-    assertThat(keypairBCertificate2Pin).isEqualTo(certB1Sha256Pin);
-    assertThat(certB1Sha256Pin).isNotEqualTo(certA1Sha256Pin);
-  }
-
-  @Test public void successfulCheck() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", certA1Sha256Pin)
-        .build();
-
-    certificatePinner.check("example.com", certA1.certificate());
-  }
-
-  @Test public void successfulCheckSha1Pin() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", "sha1/" + CertificatePinner.sha1(certA1.certificate()).base64())
-        .build();
-
-    certificatePinner.check("example.com", certA1.certificate());
-  }
-
-  @Test public void successfulMatchAcceptsAnyMatchingCertificate() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", certB1Sha256Pin)
-        .build();
-
-    certificatePinner.check("example.com", certA1.certificate(), certB1.certificate());
-  }
-
-  @Test public void unsuccessfulCheck() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", certA1Sha256Pin)
-        .build();
-
-    try {
-      certificatePinner.check("example.com", certB1.certificate());
-      fail();
-    } catch (SSLPeerUnverifiedException expected) {
-    }
-  }
-
-  @Test public void multipleCertificatesForOneHostname() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", certA1Sha256Pin, certB1Sha256Pin)
-        .build();
-
-    certificatePinner.check("example.com", certA1.certificate());
-    certificatePinner.check("example.com", certB1.certificate());
-  }
-
-  @Test public void multipleHostnamesForOneCertificate() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", certA1Sha256Pin)
-        .add("www.example.com", certA1Sha256Pin)
-        .build();
-
-    certificatePinner.check("example.com", certA1.certificate());
-    certificatePinner.check("www.example.com", certA1.certificate());
-  }
-
-  @Test public void absentHostnameMatches() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder().build();
-    certificatePinner.check("example.com", certA1.certificate());
-  }
-
-  @Test public void successfulCheckForWildcardHostname() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Sha256Pin)
-        .build();
-
-    certificatePinner.check("a.example.com", certA1.certificate());
-  }
-
-  @Test public void successfulMatchAcceptsAnyMatchingCertificateForWildcardHostname()
-      throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certB1Sha256Pin)
-        .build();
-
-    certificatePinner.check("a.example.com", certA1.certificate(), certB1.certificate());
-  }
-
-  @Test public void unsuccessfulCheckForWildcardHostname() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Sha256Pin)
-        .build();
-
-    try {
-      certificatePinner.check("a.example.com", certB1.certificate());
-      fail();
-    } catch (SSLPeerUnverifiedException expected) {
-    }
-  }
-
-  @Test public void multipleCertificatesForOneWildcardHostname() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Sha256Pin, certB1Sha256Pin)
-        .build();
-
-    certificatePinner.check("a.example.com", certA1.certificate());
-    certificatePinner.check("a.example.com", certB1.certificate());
-  }
-
-  @Test public void successfulCheckForOneHostnameWithWildcardAndDirectCertificate()
-      throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Sha256Pin)
-        .add("a.example.com", certB1Sha256Pin)
-        .build();
-
-    certificatePinner.check("a.example.com", certA1.certificate());
-    certificatePinner.check("a.example.com", certB1.certificate());
-  }
-
-  @Test public void unsuccessfulCheckForOneHostnameWithWildcardAndDirectCertificate()
-      throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Sha256Pin)
-        .add("a.example.com", certB1Sha256Pin)
-        .build();
-
-    try {
-      certificatePinner.check("a.example.com", certC1.certificate());
-      fail();
-    } catch (SSLPeerUnverifiedException expected) {
-    }
-  }
-
-  @Test public void successfulFindMatchingPins() {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("first.com", certA1Sha256Pin, certB1Sha256Pin)
-        .add("second.com", certC1Sha256Pin)
-        .build();
-
-    List<Pin> expectedPins = Arrays.asList(
-        new Pin("first.com", certA1Sha256Pin),
-        new Pin("first.com", certB1Sha256Pin));
-    assertThat(certificatePinner.findMatchingPins("first.com")).isEqualTo(expectedPins);
-  }
-
-  @Test public void successfulFindMatchingPinsForWildcardAndDirectCertificates() {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Sha256Pin)
-        .add("a.example.com", certB1Sha256Pin)
-        .add("b.example.com", certC1Sha256Pin)
-        .build();
-
-    List<Pin> expectedPins = Arrays.asList(
-        new Pin("*.example.com", certA1Sha256Pin),
-        new Pin("a.example.com", certB1Sha256Pin));
-    assertThat(certificatePinner.findMatchingPins("a.example.com")).isEqualTo(expectedPins);
-  }
-
-  @Test public void wildcardHostnameShouldNotMatchThroughDot() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Sha256Pin)
-        .build();
-
-    assertThat(certificatePinner.findMatchingPins("example.com")).isEmpty();
-    assertThat(certificatePinner.findMatchingPins("a.b.example.com")).isEmpty();
-  }
-
-  @Test public void successfulFindMatchingPinsIgnoresCase() {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("EXAMPLE.com", certA1Sha256Pin)
-        .add("*.MyExample.Com", certB1Sha256Pin)
-        .build();
-
-    List<Pin> expectedPin1 = Arrays.asList(new Pin("EXAMPLE.com", certA1Sha256Pin));
-    assertThat(certificatePinner.findMatchingPins("example.com")).isEqualTo(expectedPin1);
-
-    List<Pin> expectedPin2 = Arrays.asList(new Pin("*.MyExample.Com", certB1Sha256Pin));
-    assertThat(certificatePinner.findMatchingPins("a.myexample.com")).isEqualTo(expectedPin2);
-  }
-
-  @Test public void successfulFindMatchingPinPunycode() {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("œÉkhttp.com", certA1Sha256Pin)
-        .build();
-
-    List<Pin> expectedPin = Arrays.asList(new Pin("œÉkhttp.com", certA1Sha256Pin));
-    assertThat(certificatePinner.findMatchingPins("xn--khttp-fde.com")).isEqualTo(expectedPin);
-  }
-
-  /** https://github.com/square/okhttp/issues/3324 */
-  @Test public void checkSubstringMatch() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Sha256Pin)
-        .build();
-
-    assertThat(certificatePinner.findMatchingPins("a.example.com.notexample.com")).isEmpty();
-    assertThat(certificatePinner.findMatchingPins("example.com.notexample.com")).isEmpty();
-    assertThat(certificatePinner.findMatchingPins("notexample.com")).isEmpty();
-    assertThat(certificatePinner.findMatchingPins("example.com")).isEmpty();
-    assertThat(certificatePinner.findMatchingPins("a.b.example.com")).isEmpty();
-    assertThat(certificatePinner.findMatchingPins("ple.com")).isEmpty();
-    assertThat(certificatePinner.findMatchingPins("com")).isEmpty();
-
-    Pin expectedPin = new Pin("*.example.com", certA1Sha256Pin);
-    assertThat(certificatePinner.findMatchingPins("a.example.com")).containsExactly(expectedPin);
-    assertThat(certificatePinner.findMatchingPins("example.example.com"))
-        .containsExactly(expectedPin);
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/CipherSuiteTest.java b/okhttp-tests/src/test/java/okhttp3/CipherSuiteTest.java
deleted file mode 100644
index 3a72df03a4..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/CipherSuiteTest.java
+++ /dev/null
@@ -1,221 +0,0 @@
-/*
- * Copyright (C) 2016 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import org.junit.Test;
-
-import static okhttp3.CipherSuite.TLS_KRB5_WITH_DES_CBC_MD5;
-import static okhttp3.CipherSuite.TLS_RSA_EXPORT_WITH_RC4_40_MD5;
-import static okhttp3.CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA256;
-import static okhttp3.CipherSuite.forJavaName;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.fail;
-
-public class CipherSuiteTest {
-  @Test public void nullCipherName() {
-    try {
-      forJavaName(null);
-      fail("Should have thrown");
-    } catch (NullPointerException expected) {
-    }
-  }
-
-  @Test public void hashCode_usesIdentityHashCode_legacyCase() {
-    CipherSuite cs = TLS_RSA_EXPORT_WITH_RC4_40_MD5; // This one's javaName starts with "SSL_".
-    assertThat(cs.hashCode()).overridingErrorMessage(cs.toString()).isEqualTo(
-        System.identityHashCode(cs));
-  }
-
-  @Test public void hashCode_usesIdentityHashCode_regularCase() {
-    CipherSuite cs = TLS_RSA_WITH_AES_128_CBC_SHA256; // This one's javaName matches the identifier.
-    assertThat(cs.hashCode()).overridingErrorMessage(cs.toString()).isEqualTo(
-        System.identityHashCode(cs));
-  }
-
-  @Test public void instancesAreInterned() {
-    assertThat(forJavaName("TestCipherSuite")).isSameAs(forJavaName("TestCipherSuite"));
-    assertThat(forJavaName(TLS_KRB5_WITH_DES_CBC_MD5.javaName()))
-        .isSameAs(TLS_KRB5_WITH_DES_CBC_MD5);
-  }
-
-  /**
-   * Tests that interned CipherSuite instances remain the case across garbage collections, even if
-   * the String used to construct them is no longer strongly referenced outside of the CipherSuite.
-   */
-  @SuppressWarnings("RedundantStringConstructorCall")
-  @Test public void instancesAreInterned_survivesGarbageCollection() {
-    // We're not holding onto a reference to this String instance outside of the CipherSuite...
-    CipherSuite cs = forJavaName(new String("FakeCipherSuite_instancesAreInterned"));
-    System.gc(); // Unless cs references the String instance, it may now be garbage collected.
-    assertThat(forJavaName(new String(cs.javaName()))).isSameAs(cs);
-  }
-
-  @Test public void equals() {
-    assertThat(forJavaName("cipher")).isEqualTo(forJavaName("cipher"));
-    assertThat(forJavaName("cipherB")).isNotEqualTo(forJavaName("cipherA"));
-    assertThat(TLS_RSA_EXPORT_WITH_RC4_40_MD5).isEqualTo(
-        forJavaName("SSL_RSA_EXPORT_WITH_RC4_40_MD5"));
-    assertThat(TLS_RSA_WITH_AES_128_CBC_SHA256).isNotEqualTo(
-        TLS_RSA_EXPORT_WITH_RC4_40_MD5);
-  }
-
-  @Test public void forJavaName_acceptsArbitraryStrings() {
-    // Shouldn't throw.
-    forJavaName("example CipherSuite name that is not in the whitelist");
-  }
-
-  @Test public void javaName_examples() {
-    assertThat(TLS_RSA_EXPORT_WITH_RC4_40_MD5.javaName()).isEqualTo(
-        "SSL_RSA_EXPORT_WITH_RC4_40_MD5");
-    assertThat(TLS_RSA_WITH_AES_128_CBC_SHA256.javaName()).isEqualTo(
-        "TLS_RSA_WITH_AES_128_CBC_SHA256");
-    assertThat(forJavaName("TestCipherSuite").javaName()).isEqualTo("TestCipherSuite");
-  }
-
-  @Test public void javaName_equalsToString() {
-    assertThat(TLS_RSA_EXPORT_WITH_RC4_40_MD5.toString()).isEqualTo(
-        TLS_RSA_EXPORT_WITH_RC4_40_MD5.javaName);
-    assertThat(TLS_RSA_WITH_AES_128_CBC_SHA256.toString()).isEqualTo(
-        TLS_RSA_WITH_AES_128_CBC_SHA256.javaName);
-  }
-
-  /**
-   * On the Oracle JVM some older cipher suites have the "SSL_" prefix and others have the "TLS_"
-   * prefix. On the IBM JVM all cipher suites have the "SSL_" prefix.
-   *
-   * <p>Prior to OkHttp 3.3.1 we accepted either form and consider them equivalent. And since OkHttp
-   * 3.7.0 this is also true. But OkHttp 3.3.1 through 3.6.0 treated these as different.
-   */
-  @Test public void forJavaName_fromLegacyEnumName() {
-    // These would have been considered equal in OkHttp 3.3.1, but now aren't.
-    assertThat(forJavaName("SSL_RSA_EXPORT_WITH_RC4_40_MD5")).isEqualTo(
-        forJavaName("TLS_RSA_EXPORT_WITH_RC4_40_MD5"));
-    assertThat(forJavaName("SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA")).isEqualTo(
-        forJavaName("TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA"));
-    assertThat(forJavaName("SSL_FAKE_NEW_CIPHER")).isEqualTo(
-        forJavaName("TLS_FAKE_NEW_CIPHER"));
-  }
-
-  @Test public void applyIntersectionRetainsSslPrefixes() throws Exception {
-    FakeSslSocket socket = new FakeSslSocket();
-    socket.setEnabledProtocols(new String[] { "TLSv1" });
-    socket.setSupportedCipherSuites(new String[] { "SSL_A", "SSL_B", "SSL_C", "SSL_D", "SSL_E" });
-    socket.setEnabledCipherSuites(new String[] { "SSL_A", "SSL_B", "SSL_C" });
-
-    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(true)
-        .tlsVersions(TlsVersion.TLS_1_0)
-        .cipherSuites("TLS_A", "TLS_C", "TLS_E")
-        .build();
-    connectionSpec.apply(socket, false);
-
-    assertArrayEquals(new String[] { "SSL_A", "SSL_C" }, socket.enabledCipherSuites);
-  }
-
-  @Test public void applyIntersectionRetainsTlsPrefixes() throws Exception {
-    FakeSslSocket socket = new FakeSslSocket();
-    socket.setEnabledProtocols(new String[] { "TLSv1" });
-    socket.setSupportedCipherSuites(new String[] { "TLS_A", "TLS_B", "TLS_C", "TLS_D", "TLS_E" });
-    socket.setEnabledCipherSuites(new String[] { "TLS_A", "TLS_B", "TLS_C" });
-
-    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(true)
-        .tlsVersions(TlsVersion.TLS_1_0)
-        .cipherSuites("SSL_A", "SSL_C", "SSL_E")
-        .build();
-    connectionSpec.apply(socket, false);
-
-    assertArrayEquals(new String[] { "TLS_A", "TLS_C" }, socket.enabledCipherSuites);
-  }
-
-  @Test public void applyIntersectionAddsSslScsvForFallback() throws Exception {
-    FakeSslSocket socket = new FakeSslSocket();
-    socket.setEnabledProtocols(new String[] { "TLSv1" });
-    socket.setSupportedCipherSuites(new String[] { "SSL_A", "SSL_FALLBACK_SCSV" });
-    socket.setEnabledCipherSuites(new String[] { "SSL_A" });
-
-    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(true)
-        .tlsVersions(TlsVersion.TLS_1_0)
-        .cipherSuites("SSL_A")
-        .build();
-    connectionSpec.apply(socket, true);
-
-    assertArrayEquals(new String[] { "SSL_A", "SSL_FALLBACK_SCSV" }, socket.enabledCipherSuites);
-  }
-
-  @Test public void applyIntersectionAddsTlsScsvForFallback() throws Exception {
-    FakeSslSocket socket = new FakeSslSocket();
-    socket.setEnabledProtocols(new String[] { "TLSv1" });
-    socket.setSupportedCipherSuites(new String[] { "TLS_A", "TLS_FALLBACK_SCSV" });
-    socket.setEnabledCipherSuites(new String[] { "TLS_A" });
-
-    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(true)
-        .tlsVersions(TlsVersion.TLS_1_0)
-        .cipherSuites("TLS_A")
-        .build();
-    connectionSpec.apply(socket, true);
-
-    assertArrayEquals(new String[] { "TLS_A", "TLS_FALLBACK_SCSV" }, socket.enabledCipherSuites);
-  }
-
-  @Test public void applyIntersectionToProtocolVersion() throws Exception {
-    FakeSslSocket socket = new FakeSslSocket();
-    socket.setEnabledProtocols(new String[] { "TLSv1", "TLSv1.1", "TLSv1.2" });
-    socket.setSupportedCipherSuites(new String[] { "TLS_A" });
-    socket.setEnabledCipherSuites(new String[] { "TLS_A" });
-
-    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(true)
-        .tlsVersions(TlsVersion.TLS_1_1, TlsVersion.TLS_1_2, TlsVersion.TLS_1_3)
-        .cipherSuites("TLS_A")
-        .build();
-    connectionSpec.apply(socket, false);
-
-    assertArrayEquals(new String[] { "TLSv1.1", "TLSv1.2" }, socket.enabledProtocols);
-  }
-
-  static final class FakeSslSocket extends DelegatingSSLSocket {
-    private String[] enabledProtocols;
-    private String[] supportedCipherSuites;
-    private String[] enabledCipherSuites;
-
-    FakeSslSocket() {
-      super(null);
-    }
-
-    @Override public String[] getEnabledProtocols() {
-      return enabledProtocols;
-    }
-
-    @Override public void setEnabledProtocols(String[] enabledProtocols) {
-      this.enabledProtocols = enabledProtocols;
-    }
-
-    @Override public String[] getSupportedCipherSuites() {
-      return supportedCipherSuites;
-    }
-
-    public void setSupportedCipherSuites(String[] supportedCipherSuites) {
-      this.supportedCipherSuites = supportedCipherSuites;
-    }
-
-    @Override public String[] getEnabledCipherSuites() {
-      return enabledCipherSuites;
-    }
-
-    @Override public void setEnabledCipherSuites(String[] enabledCipherSuites) {
-      this.enabledCipherSuites = enabledCipherSuites;
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionCoalescingTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionCoalescingTest.java
deleted file mode 100644
index 868057c137..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/ConnectionCoalescingTest.java
+++ /dev/null
@@ -1,329 +0,0 @@
-/*
- * Copyright (C) 2017 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicReference;
-import javax.net.ssl.HostnameVerifier;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.tls.HandshakeCertificates;
-import okhttp3.tls.HeldCertificate;
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class ConnectionCoalescingTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
-
-  private OkHttpClient client;
-
-  private HeldCertificate rootCa;
-  private HeldCertificate certificate;
-  private FakeDns dns = new FakeDns();
-  private HttpUrl url;
-  private List<InetAddress> serverIps;
-
-  @Before public void setUp() throws Exception {
-    rootCa = new HeldCertificate.Builder()
-        .serialNumber(1L)
-        .certificateAuthority(0)
-        .commonName("root")
-        .build();
-    certificate = new HeldCertificate.Builder()
-        .signedBy(rootCa)
-        .serialNumber(2L)
-        .commonName(server.getHostName())
-        .addSubjectAlternativeName(server.getHostName())
-        .addSubjectAlternativeName("san.com")
-        .addSubjectAlternativeName("*.wildcard.com")
-        .addSubjectAlternativeName("differentdns.com")
-        .build();
-
-    serverIps = Dns.SYSTEM.lookup(server.getHostName());
-
-    dns.set(server.getHostName(), serverIps);
-    dns.set("san.com", serverIps);
-    dns.set("nonsan.com", serverIps);
-    dns.set("www.wildcard.com", serverIps);
-    dns.set("differentdns.com", Collections.emptyList());
-
-    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
-        .addTrustedCertificate(rootCa.certificate())
-        .build();
-
-    client = new OkHttpClient.Builder().dns(dns)
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .build();
-    clientTestRule.client = client;
-
-    HandshakeCertificates serverHandshakeCertificates = new HandshakeCertificates.Builder()
-        .heldCertificate(certificate)
-        .build();
-    server.useHttps(serverHandshakeCertificates.sslSocketFactory(), false);
-
-    url = server.url("/robots.txt");
-  }
-
-  /**
-   * Test connecting to the main host then an alternative, although only subject alternative names
-   * are used if present no special consideration of common name.
-   */
-  @Test public void commonThenAlternative() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(200));
-    server.enqueue(new MockResponse().setResponseCode(200));
-
-    assert200Http2Response(execute(url), server.getHostName());
-
-    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
-    assert200Http2Response(execute(sanUrl), "san.com");
-
-    assertThat(client.connectionPool().connectionCount()).isEqualTo(1);
-  }
-
-  /**
-   * Test connecting to an alternative host then common name, although only subject alternative
-   * names are used if present no special consideration of common name.
-   */
-  @Test public void alternativeThenCommon() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(200));
-    server.enqueue(new MockResponse().setResponseCode(200));
-
-    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
-    assert200Http2Response(execute(sanUrl), "san.com");
-
-    assert200Http2Response(execute(url), server.getHostName());
-
-    assertThat(client.connectionPool().connectionCount()).isEqualTo(1);
-  }
-
-  /** Test a previously coalesced connection that's no longer healthy. */
-  @Test public void staleCoalescedConnection() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(200));
-    server.enqueue(new MockResponse().setResponseCode(200));
-
-    AtomicReference<Connection> connection = new AtomicReference<>();
-    client = client.newBuilder()
-        .addNetworkInterceptor(chain -> {
-          connection.set(chain.connection());
-          return chain.proceed(chain.request());
-        })
-        .build();
-    dns.set("san.com", Dns.SYSTEM.lookup(server.getHostName()).subList(0, 1));
-
-    assert200Http2Response(execute(url), server.getHostName());
-
-    // Simulate a stale connection in the pool.
-    connection.get().socket().close();
-
-    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
-    assert200Http2Response(execute(sanUrl), "san.com");
-
-    assertThat(client.connectionPool().connectionCount()).isEqualTo(1);
-  }
-
-  /** If the existing connection matches a SAN but not a match for DNS then skip. */
-  @Test public void skipsWhenDnsDontMatch() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(200));
-
-    assert200Http2Response(execute(url), server.getHostName());
-
-    HttpUrl differentDnsUrl = url.newBuilder().host("differentdns.com").build();
-    try {
-      execute(differentDnsUrl);
-      fail("expected a failed attempt to connect");
-    } catch (IOException expected) {
-    }
-  }
-
-  /** Not in the certificate SAN. */
-  @Test public void skipsWhenNotSubjectAltName() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(200));
-
-    assert200Http2Response(execute(url), server.getHostName());
-
-    HttpUrl nonsanUrl = url.newBuilder().host("nonsan.com").build();
-
-    try {
-      execute(nonsanUrl);
-      fail("expected a failed attempt to connect");
-    } catch (IOException expected) {
-    }
-  }
-
-  /** Can still coalesce when pinning is used if pins match. */
-  @Test public void coalescesWhenCertificatePinsMatch() throws Exception {
-    CertificatePinner pinner = new CertificatePinner.Builder()
-        .add("san.com", "sha1/" + CertificatePinner.sha1(certificate.certificate()).base64())
-        .build();
-    client = client.newBuilder().certificatePinner(pinner).build();
-
-    server.enqueue(new MockResponse().setResponseCode(200));
-    server.enqueue(new MockResponse().setResponseCode(200));
-
-    assert200Http2Response(execute(url), server.getHostName());
-
-    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
-
-    assert200Http2Response(execute(sanUrl), "san.com");
-
-    assertThat(client.connectionPool().connectionCount()).isEqualTo(1);
-  }
-
-  /** Certificate pinning used and not a match will avoid coalescing and try to connect. */
-  @Test public void skipsWhenCertificatePinningFails() throws Exception {
-    CertificatePinner pinner = new CertificatePinner.Builder()
-        .add("san.com", "sha1/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
-        .build();
-    client = client.newBuilder().certificatePinner(pinner).build();
-
-    server.enqueue(new MockResponse().setResponseCode(200));
-
-    assert200Http2Response(execute(url), server.getHostName());
-
-    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
-
-    try {
-      execute(sanUrl);
-      fail("expected a failed attempt to connect");
-    } catch (IOException expected) {
-    }
-  }
-
-  /**
-   * Skips coalescing when hostname verifier is overridden since the intention of the hostname
-   * verification is a black box.
-   */
-  @Test public void skipsWhenHostnameVerifierUsed() throws Exception {
-    HostnameVerifier verifier = (name, session) -> true;
-    client = client.newBuilder().hostnameVerifier(verifier).build();
-
-    server.enqueue(new MockResponse().setResponseCode(200));
-    server.enqueue(new MockResponse().setResponseCode(200));
-
-    assert200Http2Response(execute(url), server.getHostName());
-
-    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
-
-    assert200Http2Response(execute(sanUrl), "san.com");
-
-    assertThat(client.connectionPool().connectionCount()).isEqualTo(2);
-  }
-
-  /**
-   * Check we would use an existing connection to a later DNS result instead of connecting to the
-   * first DNS result for the first time.
-   */
-  @Test public void prefersExistingCompatible() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(200));
-    server.enqueue(new MockResponse().setResponseCode(200));
-
-    AtomicInteger connectCount = new AtomicInteger();
-    EventListener listener = new EventListener() {
-      @Override public void connectStart(
-          Call call, InetSocketAddress inetSocketAddress, Proxy proxy) {
-        connectCount.getAndIncrement();
-      }
-    };
-    client = client.newBuilder()
-        .eventListener(listener)
-        .build();
-
-    assert200Http2Response(execute(url), server.getHostName());
-
-    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
-    dns.set("san.com",
-        Arrays.asList(InetAddress.getByAddress("san.com", new byte[] {0, 0, 0, 0}),
-            serverIps.get(0)));
-    assert200Http2Response(execute(sanUrl), "san.com");
-
-    assertThat(client.connectionPool().connectionCount()).isEqualTo(1);
-    assertThat(connectCount.get()).isEqualTo(1);
-  }
-
-  /** Check that wildcard SANs are supported. */
-  @Test public void commonThenWildcard() throws Exception {
-
-    server.enqueue(new MockResponse().setResponseCode(200));
-    server.enqueue(new MockResponse().setResponseCode(200));
-
-    assert200Http2Response(execute(url), server.getHostName());
-
-    HttpUrl sanUrl = url.newBuilder().host("www.wildcard.com").build();
-    assert200Http2Response(execute(sanUrl), "www.wildcard.com");
-
-    assertThat(client.connectionPool().connectionCount()).isEqualTo(1);
-  }
-
-  /** Network interceptors check for changes to target. */
-  @Test public void worksWithNetworkInterceptors() throws Exception {
-    client = client.newBuilder()
-        .addNetworkInterceptor(chain -> chain.proceed(chain.request()))
-        .build();
-
-    server.enqueue(new MockResponse().setResponseCode(200));
-    server.enqueue(new MockResponse().setResponseCode(200));
-
-    assert200Http2Response(execute(url), server.getHostName());
-
-    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
-    assert200Http2Response(execute(sanUrl), "san.com");
-
-    assertThat(client.connectionPool().connectionCount()).isEqualTo(1);
-  }
-
-  /** Run against public external sites, doesn't run by default. */
-  @Ignore
-  @Test public void coalescesConnectionsToRealSites() throws IOException {
-    client = new OkHttpClient();
-
-    assert200Http2Response(execute("https://graph.facebook.com/robots.txt"), "graph.facebook.com");
-    assert200Http2Response(execute("https://www.facebook.com/robots.txt"), "m.facebook.com");
-    assert200Http2Response(execute("https://fb.com/robots.txt"), "m.facebook.com");
-    assert200Http2Response(execute("https://messenger.com/robots.txt"), "messenger.com");
-    assert200Http2Response(execute("https://m.facebook.com/robots.txt"), "m.facebook.com");
-
-    assertThat(client.connectionPool().connectionCount()).isEqualTo(3);
-  }
-
-  private Response execute(String url) throws IOException {
-    return execute(HttpUrl.get(url));
-  }
-
-  private Response execute(HttpUrl url) throws IOException {
-    return client.newCall(new Request.Builder().url(url).build()).execute();
-  }
-
-  private void assert200Http2Response(Response response, String expectedHost) {
-    assertThat(response.code()).isEqualTo(200);
-    assertThat(response.request().url().host()).isEqualTo(expectedHost);
-    assertThat(response.protocol()).isEqualTo(Protocol.HTTP_2);
-    response.body().close();
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java
deleted file mode 100644
index fbce95e42b..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java
+++ /dev/null
@@ -1,379 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.concurrent.TimeUnit;
-import javax.net.ssl.SSLException;
-import okhttp3.internal.Util;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.SocketPolicy;
-import okhttp3.tls.HandshakeCertificates;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TestRule;
-import org.junit.rules.Timeout;
-
-import static okhttp3.tls.internal.TlsUtil.localhost;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class ConnectionReuseTest {
-  @Rule public final TestRule timeout = new Timeout(30_000);
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
-
-  private HandshakeCertificates handshakeCertificates = localhost();
-  private OkHttpClient client = clientTestRule.client;
-
-  @Test public void connectionsAreReused() throws Exception {
-    server.enqueue(new MockResponse().setBody("a"));
-    server.enqueue(new MockResponse().setBody("b"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    assertConnectionReused(request, request);
-  }
-
-  @Test public void connectionsAreReusedWithHttp2() throws Exception {
-    enableHttp2();
-    server.enqueue(new MockResponse().setBody("a"));
-    server.enqueue(new MockResponse().setBody("b"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    assertConnectionReused(request, request);
-  }
-
-  @Test public void connectionsAreNotReusedWithRequestConnectionClose() throws Exception {
-    server.enqueue(new MockResponse().setBody("a"));
-    server.enqueue(new MockResponse().setBody("b"));
-
-    Request requestA = new Request.Builder()
-        .url(server.url("/"))
-        .header("Connection", "close")
-        .build();
-    Request requestB = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    assertConnectionNotReused(requestA, requestB);
-  }
-
-  @Test public void connectionsAreNotReusedWithResponseConnectionClose() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Connection", "close")
-        .setBody("a"));
-    server.enqueue(new MockResponse().setBody("b"));
-
-    Request requestA = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Request requestB = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    assertConnectionNotReused(requestA, requestB);
-  }
-
-  @Test public void connectionsAreNotReusedWithUnknownLengthResponseBody() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("a")
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .clearHeaders());
-    server.enqueue(new MockResponse().setBody("b"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    assertConnectionNotReused(request, request);
-  }
-
-  @Test public void connectionsAreNotReusedIfPoolIsSizeZero() throws Exception {
-    client = client.newBuilder()
-        .connectionPool(new ConnectionPool(0, 5, TimeUnit.SECONDS))
-        .build();
-    server.enqueue(new MockResponse().setBody("a"));
-    server.enqueue(new MockResponse().setBody("b"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    assertConnectionNotReused(request, request);
-  }
-
-  @Test public void connectionsReusedWithRedirectEvenIfPoolIsSizeZero() throws Exception {
-    client = client.newBuilder()
-        .connectionPool(new ConnectionPool(0, 5, TimeUnit.SECONDS))
-        .build();
-    server.enqueue(new MockResponse()
-        .setResponseCode(301)
-        .addHeader("Location: /b")
-        .setBody("a"));
-    server.enqueue(new MockResponse().setBody("b"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("b");
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void connectionsNotReusedWithRedirectIfDiscardingResponseIsSlow() throws Exception {
-    client = client.newBuilder()
-        .connectionPool(new ConnectionPool(0, 5, TimeUnit.SECONDS))
-        .build();
-    server.enqueue(new MockResponse()
-        .setResponseCode(301)
-        .addHeader("Location: /b")
-        .setBodyDelay(1, TimeUnit.SECONDS)
-        .setBody("a"));
-    server.enqueue(new MockResponse().setBody("b"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("b");
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-  }
-
-  @Test public void silentRetryWhenIdempotentRequestFailsOnReusedConnection() throws Exception {
-    server.enqueue(new MockResponse().setBody("a"));
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
-    server.enqueue(new MockResponse().setBody("b"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    Response responseA = client.newCall(request).execute();
-    assertThat(responseA.body().string()).isEqualTo("a");
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-
-    Response responseB = client.newCall(request).execute();
-    assertThat(responseB.body().string()).isEqualTo("b");
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-  }
-
-  @Test public void staleConnectionNotReusedForNonIdempotentRequest() throws Exception {
-    server.enqueue(new MockResponse().setBody("a")
-        .setSocketPolicy(SocketPolicy.SHUTDOWN_OUTPUT_AT_END));
-    server.enqueue(new MockResponse().setBody("b"));
-
-    Request requestA = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Response responseA = client.newCall(requestA).execute();
-    assertThat(responseA.body().string()).isEqualTo("a");
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-
-    // Give the socket a chance to become stale.
-    Thread.sleep(250);
-
-    Request requestB = new Request.Builder()
-        .url(server.url("/"))
-        .post(RequestBody.create(MediaType.get("text/plain"), "b"))
-        .build();
-    Response responseB = client.newCall(requestB).execute();
-    assertThat(responseB.body().string()).isEqualTo("b");
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-  }
-
-  @Test public void http2ConnectionsAreSharedBeforeResponseIsConsumed() throws Exception {
-    enableHttp2();
-    server.enqueue(new MockResponse().setBody("a"));
-    server.enqueue(new MockResponse().setBody("b"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Response response1 = client.newCall(request).execute();
-    Response response2 = client.newCall(request).execute();
-    response1.body().string(); // Discard the response body.
-    response2.body().string(); // Discard the response body.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void connectionsAreEvicted() throws Exception {
-    server.enqueue(new MockResponse().setBody("a"));
-    server.enqueue(new MockResponse().setBody("b"));
-
-    client = client.newBuilder()
-        .connectionPool(new ConnectionPool(5, 250, TimeUnit.MILLISECONDS))
-        .build();
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    Response response1 = client.newCall(request).execute();
-    assertThat(response1.body().string()).isEqualTo("a");
-
-    // Give the thread pool a chance to evict.
-    Thread.sleep(500);
-
-    Response response2 = client.newCall(request).execute();
-    assertThat(response2.body().string()).isEqualTo("b");
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-  }
-
-  @Test public void connectionsAreNotReusedIfSslSocketFactoryChanges() throws Exception {
-    enableHttps();
-    server.enqueue(new MockResponse());
-    server.enqueue(new MockResponse());
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    Response response = client.newCall(request).execute();
-    response.body().close();
-
-    // This client shares a connection pool but has a different SSL socket factory.
-    HandshakeCertificates handshakeCertificates2 = new HandshakeCertificates.Builder().build();
-    OkHttpClient anotherClient = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates2.sslSocketFactory(), handshakeCertificates2.trustManager())
-        .build();
-
-    // This client fails to connect because the new SSL socket factory refuses.
-    try {
-      anotherClient.newCall(request).execute();
-      fail();
-    } catch (SSLException expected) {
-    }
-  }
-
-  @Test public void connectionsAreNotReusedIfHostnameVerifierChanges() throws Exception {
-    enableHttps();
-    server.enqueue(new MockResponse());
-    server.enqueue(new MockResponse());
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    Response response1 = client.newCall(request).execute();
-    response1.body().close();
-
-    // This client shares a connection pool but has a different SSL socket factory.
-    OkHttpClient anotherClient = client.newBuilder()
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-
-    Response response2 = anotherClient.newCall(request).execute();
-    response2.body().close();
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-  }
-
-  /**
-   * Regression test for an edge case where closing response body in the HTTP engine doesn't release
-   * the corresponding stream allocation. This test keeps those response bodies alive and reads
-   * them after the redirect has completed. This forces a connection to not be reused where it would
-   * be otherwise.
-   *
-   * <p>This test leaks a response body by not closing it.
-   *
-   * https://github.com/square/okhttp/issues/2409
-   */
-  @Test public void connectionsAreNotReusedIfNetworkInterceptorInterferes() throws Exception {
-    List<Response> responsesNotClosed = new ArrayList<>();
-
-    client = client.newBuilder()
-        // Since this test knowingly leaks a connection, avoid using the default shared connection
-        // pool, which should remain clean for subsequent tests.
-        .connectionPool(new ConnectionPool())
-        .addNetworkInterceptor(chain -> {
-          Response response = chain.proceed(chain.request());
-          responsesNotClosed.add(response);
-          return response
-              .newBuilder()
-              .body(ResponseBody.create(null, "unrelated response body!"))
-              .build();
-        })
-        .build();
-
-    server.enqueue(new MockResponse()
-        .setResponseCode(301)
-        .addHeader("Location: /b")
-        .setBody("/a has moved!"));
-    server.enqueue(new MockResponse()
-        .setBody("/b is here"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Call call = client.newCall(request);
-    try (Response response = call.execute()) {
-      assertThat(response.body().string()).isEqualTo("unrelated response body!");
-    }
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    // No connection reuse.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-
-    for (Response response : responsesNotClosed) {
-      Util.closeQuietly(response);
-    }
-  }
-
-  private void enableHttps() {
-    enableHttpsAndAlpn(Protocol.HTTP_1_1);
-  }
-
-  private void enableHttp2() {
-    enableHttpsAndAlpn(Protocol.HTTP_2, Protocol.HTTP_1_1);
-  }
-
-  private void enableHttpsAndAlpn(Protocol... protocols) {
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .protocols(Arrays.asList(protocols))
-        .build();
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.setProtocols(client.protocols());
-  }
-
-  private void assertConnectionReused(Request... requests) throws Exception {
-    for (int i = 0; i < requests.length; i++) {
-      Response response = client.newCall(requests[i]).execute();
-      response.body().string(); // Discard the response body.
-      assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(i);
-    }
-  }
-
-  private void assertConnectionNotReused(Request... requests) throws Exception {
-    for (Request request : requests) {
-      Response response = client.newCall(request).execute();
-      response.body().string(); // Discard the response body.
-      assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionSpecTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionSpecTest.java
deleted file mode 100644
index a889e5c885..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/ConnectionSpecTest.java
+++ /dev/null
@@ -1,302 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.util.Arrays;
-import java.util.LinkedHashSet;
-import java.util.Set;
-import java.util.concurrent.CopyOnWriteArraySet;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class ConnectionSpecTest {
-  @Test public void noTlsVersions() throws Exception {
-    try {
-      new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
-          .tlsVersions(new TlsVersion[0])
-          .build();
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo("At least one TLS version is required");
-    }
-  }
-
-  @Test public void noCipherSuites() throws Exception {
-    try {
-      new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
-          .cipherSuites(new CipherSuite[0])
-          .build();
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo("At least one cipher suite is required");
-    }
-  }
-
-  @Test public void cleartextBuilder() throws Exception {
-    ConnectionSpec cleartextSpec = new ConnectionSpec.Builder(false).build();
-    assertThat(cleartextSpec.isTls()).isFalse();
-  }
-
-  @Test public void tlsBuilder_explicitCiphers() throws Exception {
-    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
-        .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
-        .tlsVersions(TlsVersion.TLS_1_2)
-        .supportsTlsExtensions(true)
-        .build();
-    assertThat(tlsSpec.cipherSuites()).containsExactly(CipherSuite.TLS_RSA_WITH_RC4_128_MD5);
-    assertThat(tlsSpec.tlsVersions()).containsExactly(TlsVersion.TLS_1_2);
-    assertThat(tlsSpec.supportsTlsExtensions()).isTrue();
-  }
-
-  @Test public void tlsBuilder_defaultCiphers() throws Exception {
-    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
-        .tlsVersions(TlsVersion.TLS_1_2)
-        .supportsTlsExtensions(true)
-        .build();
-    assertThat(tlsSpec.cipherSuites()).isNull();
-    assertThat(tlsSpec.tlsVersions()).containsExactly(TlsVersion.TLS_1_2);
-    assertThat(tlsSpec.supportsTlsExtensions()).isTrue();
-  }
-
-  @Test public void tls_defaultCiphers_noFallbackIndicator() throws Exception {
-    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
-        .tlsVersions(TlsVersion.TLS_1_2)
-        .supportsTlsExtensions(false)
-        .build();
-
-    SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
-    socket.setEnabledCipherSuites(new String[] {
-        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
-        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
-    });
-    socket.setEnabledProtocols(new String[] {
-        TlsVersion.TLS_1_2.javaName,
-        TlsVersion.TLS_1_1.javaName,
-    });
-
-    assertThat(tlsSpec.isCompatible(socket)).isTrue();
-    tlsSpec.apply(socket, false /* isFallback */);
-
-    assertThat(set(socket.getEnabledProtocols())).isEqualTo(set(TlsVersion.TLS_1_2.javaName));
-
-    Set<String> expectedCipherSet =
-        set(
-            CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
-            CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName);
-    assertThat(expectedCipherSet).isEqualTo(expectedCipherSet);
-  }
-
-  @Test public void tls_defaultCiphers_withFallbackIndicator() throws Exception {
-    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
-        .tlsVersions(TlsVersion.TLS_1_2)
-        .supportsTlsExtensions(false)
-        .build();
-
-    SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
-    socket.setEnabledCipherSuites(new String[] {
-        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
-        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
-    });
-    socket.setEnabledProtocols(new String[] {
-        TlsVersion.TLS_1_2.javaName,
-        TlsVersion.TLS_1_1.javaName,
-    });
-
-    assertThat(tlsSpec.isCompatible(socket)).isTrue();
-    tlsSpec.apply(socket, true /* isFallback */);
-
-    assertThat(set(socket.getEnabledProtocols())).isEqualTo(set(TlsVersion.TLS_1_2.javaName));
-
-    Set<String> expectedCipherSet =
-        set(
-            CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
-            CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName);
-    if (Arrays.asList(socket.getSupportedCipherSuites()).contains("TLS_FALLBACK_SCSV")) {
-      expectedCipherSet.add("TLS_FALLBACK_SCSV");
-    }
-    assertThat(expectedCipherSet).isEqualTo(expectedCipherSet);
-  }
-
-  @Test public void tls_explicitCiphers() throws Exception {
-    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
-        .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
-        .tlsVersions(TlsVersion.TLS_1_2)
-        .supportsTlsExtensions(false)
-        .build();
-
-    SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
-    socket.setEnabledCipherSuites(new String[] {
-        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
-        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
-    });
-    socket.setEnabledProtocols(new String[] {
-        TlsVersion.TLS_1_2.javaName,
-        TlsVersion.TLS_1_1.javaName,
-    });
-
-    assertThat(tlsSpec.isCompatible(socket)).isTrue();
-    tlsSpec.apply(socket, true /* isFallback */);
-
-    assertThat(set(socket.getEnabledProtocols())).isEqualTo(set(TlsVersion.TLS_1_2.javaName));
-
-    Set<String> expectedCipherSet = set(CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName);
-    if (Arrays.asList(socket.getSupportedCipherSuites()).contains("TLS_FALLBACK_SCSV")) {
-      expectedCipherSet.add("TLS_FALLBACK_SCSV");
-    }
-    assertThat(expectedCipherSet).isEqualTo(expectedCipherSet);
-  }
-
-  @Test public void tls_stringCiphersAndVersions() throws Exception {
-    // Supporting arbitrary input strings allows users to enable suites and versions that are not
-    // yet known to the library, but are supported by the platform.
-    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
-        .cipherSuites("MAGIC-CIPHER")
-        .tlsVersions("TLS9k")
-        .build();
-  }
-
-  @Test public void tls_missingRequiredCipher() throws Exception {
-    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
-        .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
-        .tlsVersions(TlsVersion.TLS_1_2)
-        .supportsTlsExtensions(false)
-        .build();
-
-    SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
-    socket.setEnabledProtocols(new String[] {
-        TlsVersion.TLS_1_2.javaName,
-        TlsVersion.TLS_1_1.javaName,
-    });
-
-    socket.setEnabledCipherSuites(new String[] {
-        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
-        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
-    });
-    assertThat(tlsSpec.isCompatible(socket)).isTrue();
-
-    socket.setEnabledCipherSuites(new String[] {
-        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
-    });
-    assertThat(tlsSpec.isCompatible(socket)).isFalse();
-  }
-
-  @Test public void allEnabledCipherSuites() throws Exception {
-    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
-        .allEnabledCipherSuites()
-        .build();
-    assertThat(tlsSpec.cipherSuites()).isNull();
-
-    SSLSocket sslSocket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
-    sslSocket.setEnabledCipherSuites(new String[] {
-        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
-        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
-    });
-
-    tlsSpec.apply(sslSocket, false);
-    assertThat(Arrays.asList(sslSocket.getEnabledCipherSuites())).containsExactly(
-        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
-        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName);
-  }
-
-  @Test public void allEnabledTlsVersions() throws Exception {
-    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
-        .allEnabledTlsVersions()
-        .build();
-    assertThat(tlsSpec.tlsVersions()).isNull();
-
-    SSLSocket sslSocket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
-    sslSocket.setEnabledProtocols(new String[] {
-        TlsVersion.SSL_3_0.javaName(),
-        TlsVersion.TLS_1_1.javaName()
-    });
-
-    tlsSpec.apply(sslSocket, false);
-    assertThat(Arrays.asList(sslSocket.getEnabledProtocols())).containsExactly(
-        TlsVersion.SSL_3_0.javaName(), TlsVersion.TLS_1_1.javaName());
-  }
-
-  @Test public void tls_missingTlsVersion() throws Exception {
-    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
-        .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
-        .tlsVersions(TlsVersion.TLS_1_2)
-        .supportsTlsExtensions(false)
-        .build();
-
-    SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
-    socket.setEnabledCipherSuites(new String[] {
-        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
-    });
-
-    socket.setEnabledProtocols(
-        new String[] {TlsVersion.TLS_1_2.javaName, TlsVersion.TLS_1_1.javaName});
-    assertThat(tlsSpec.isCompatible(socket)).isTrue();
-
-    socket.setEnabledProtocols(new String[] {TlsVersion.TLS_1_1.javaName});
-    assertThat(tlsSpec.isCompatible(socket)).isFalse();
-  }
-
-  @Test public void equalsAndHashCode() throws Exception {
-    ConnectionSpec allCipherSuites = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
-        .allEnabledCipherSuites()
-        .build();
-    ConnectionSpec allTlsVersions = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
-        .allEnabledTlsVersions()
-        .build();
-
-    Set<Object> set = new CopyOnWriteArraySet<>();
-    assertThat(set.add(ConnectionSpec.MODERN_TLS)).isTrue();
-    assertThat(set.add(ConnectionSpec.COMPATIBLE_TLS)).isTrue();
-    assertThat(set.add(ConnectionSpec.CLEARTEXT)).isTrue();
-    assertThat(set.add(allTlsVersions)).isTrue();
-    assertThat(set.add(allCipherSuites)).isTrue();
-
-    assertThat(set.remove(ConnectionSpec.MODERN_TLS)).isTrue();
-    assertThat(set.remove(ConnectionSpec.COMPATIBLE_TLS)).isTrue();
-    assertThat(set.remove(ConnectionSpec.CLEARTEXT)).isTrue();
-    assertThat(set.remove(allTlsVersions)).isTrue();
-    assertThat(set.remove(allCipherSuites)).isTrue();
-    assertThat(set.isEmpty()).isTrue();
-  }
-
-  @Test public void allEnabledToString() throws Exception {
-    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
-        .allEnabledTlsVersions()
-        .allEnabledCipherSuites()
-        .build();
-    assertThat(connectionSpec.toString()).isEqualTo(
-        ("ConnectionSpec(cipherSuites=[all enabled], tlsVersions=[all enabled], "
-        + "supportsTlsExtensions=true)"));
-  }
-
-  @Test public void simpleToString() throws Exception {
-    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
-        .tlsVersions(TlsVersion.TLS_1_2)
-        .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
-        .build();
-    assertThat(connectionSpec.toString()).isEqualTo(
-        ("ConnectionSpec(cipherSuites=[SSL_RSA_WITH_RC4_128_MD5], tlsVersions=[TLS_1_2], "
-        + "supportsTlsExtensions=true)"));
-  }
-
-  @SafeVarargs
-  private static <T> Set<T> set(T... values) {
-    return new LinkedHashSet<>(Arrays.asList(values));
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/ConscryptTest.java b/okhttp-tests/src/test/java/okhttp3/ConscryptTest.java
deleted file mode 100644
index 5c5184d22a..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/ConscryptTest.java
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.security.Security;
-import java.util.Arrays;
-import okhttp3.internal.platform.ConscryptPlatform;
-import okhttp3.internal.platform.Platform;
-import org.conscrypt.OpenSSLProvider;
-import org.junit.After;
-import org.junit.Assume;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public class ConscryptTest {
-  public static final CipherSuite[] MANDATORY_CIPHER_SUITES = new CipherSuite[] {
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
-      CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
-      CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,
-      CipherSuite.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
-  };
-
-  private OkHttpClient client = buildClient();
-
-  @After
-  public void tearDown() {
-    TestUtil.ensureAllConnectionsReleased(client);
-  }
-
-  private OkHttpClient buildClient() {
-    ConnectionSpec spec = new ConnectionSpec.Builder(true)
-        .cipherSuites(MANDATORY_CIPHER_SUITES) // Check we are using strong ciphers
-        .tlsVersions(TlsVersion.TLS_1_2) // and modern TLS
-        .supportsTlsExtensions(true)
-        .build();
-
-    return new OkHttpClient.Builder().connectionSpecs(Arrays.asList(spec)).build();
-  }
-
-  private static void assumeConscrypt() {
-    Assume.assumeTrue("conscrypt".equals(System.getProperty("okhttp.platform")));
-  }
-
-  private static void assumeNetwork() {
-    try {
-      InetAddress.getByName("www.google.com");
-    } catch (UnknownHostException uhe) {
-      Assume.assumeNoException(uhe);
-    }
-  }
-
-  @Test
-  public void testMozilla() throws IOException {
-    assumeNetwork();
-    assumeConscrypt();
-
-    Request request = new Request.Builder().url("https://mozilla.org/robots.txt").build();
-
-    Response response = client.newCall(request).execute();
-
-    assertThat(response.protocol()).isEqualTo(Protocol.HTTP_2);
-  }
-
-  @Test
-  public void testGoogle() throws IOException {
-    assumeNetwork();
-    assumeConscrypt();
-
-    Request request = new Request.Builder().url("https://google.com/robots.txt").build();
-
-    Response response = client.newCall(request).execute();
-
-    assertThat(response.protocol()).isEqualTo(Protocol.HTTP_2);
-  }
-
-  @Test
-  public void testBuild() {
-    assertThat(ConscryptPlatform.buildIfSupported()).isNotNull();
-  }
-
-  @Test
-  public void testPreferred() {
-    Assume.assumeFalse(Platform.isConscryptPreferred());
-
-    try {
-      Security.insertProviderAt(new OpenSSLProvider(), 1);
-      assertThat(Platform.isConscryptPreferred()).isTrue();
-    } finally {
-      Security.removeProvider("Conscrypt");
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/CookieTest.java b/okhttp-tests/src/test/java/okhttp3/CookieTest.java
deleted file mode 100644
index 31186a842d..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/CookieTest.java
+++ /dev/null
@@ -1,586 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.text.ParseException;
-import java.text.SimpleDateFormat;
-import java.util.Arrays;
-import java.util.Date;
-import java.util.List;
-import java.util.Objects;
-import okhttp3.internal.Util;
-import okhttp3.internal.http.HttpDate;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class CookieTest {
-  HttpUrl url = HttpUrl.get("https://example.com/");
-
-  @Test public void simpleCookie() throws Exception {
-    Cookie cookie = Cookie.parse(url, "SID=31d4d96e407aad42");
-    assertThat(cookie.toString()).isEqualTo("SID=31d4d96e407aad42; path=/");
-  }
-
-  @Test public void noEqualsSign() throws Exception {
-    assertThat(Cookie.parse(url, "foo")).isNull();
-    assertThat(Cookie.parse(url, "foo; Path=/")).isNull();
-  }
-
-  @Test public void emptyName() throws Exception {
-    assertThat(Cookie.parse(url, "=b")).isNull();
-    assertThat(Cookie.parse(url, " =b")).isNull();
-    assertThat(Cookie.parse(url, "\r\t \n=b")).isNull();
-  }
-
-  @Test public void spaceInName() throws Exception {
-    assertThat(Cookie.parse(url, "a b=cd").name()).isEqualTo("a b");
-  }
-
-  @Test public void spaceInValue() throws Exception {
-    assertThat(Cookie.parse(url, "ab=c d").value()).isEqualTo("c d");
-  }
-
-  @Test public void trimLeadingAndTrailingWhitespaceFromName() throws Exception {
-    assertThat(Cookie.parse(url, " a=b").name()).isEqualTo("a");
-    assertThat(Cookie.parse(url, "a =b").name()).isEqualTo("a");
-    assertThat(Cookie.parse(url, "\r\t \na\n\t \n=b").name()).isEqualTo("a");
-  }
-
-  @Test public void emptyValue() throws Exception {
-    assertThat(Cookie.parse(url, "a=").value()).isEqualTo("");
-    assertThat(Cookie.parse(url, "a= ").value()).isEqualTo("");
-    assertThat(Cookie.parse(url, "a=\r\t \n").value()).isEqualTo("");
-  }
-
-  @Test public void trimLeadingAndTrailingWhitespaceFromValue() throws Exception {
-    assertThat(Cookie.parse(url, "a= ").value()).isEqualTo("");
-    assertThat(Cookie.parse(url, "a= b").value()).isEqualTo("b");
-    assertThat(Cookie.parse(url, "a=b ").value()).isEqualTo("b");
-    assertThat(Cookie.parse(url, "a=\r\t \nb\n\t \n").value()).isEqualTo("b");
-  }
-
-  @Test public void invalidCharacters() throws Exception {
-    assertThat(Cookie.parse(url, "a\u0000b=cd")).isNull();
-    assertThat(Cookie.parse(url, "ab=c\u0000d")).isNull();
-    assertThat(Cookie.parse(url, "a\u0001b=cd")).isNull();
-    assertThat(Cookie.parse(url, "ab=c\u0001d")).isNull();
-    assertThat(Cookie.parse(url, "a\u0009b=cd")).isNull();
-    assertThat(Cookie.parse(url, "ab=c\u0009d")).isNull();
-    assertThat(Cookie.parse(url, "a\u001fb=cd")).isNull();
-    assertThat(Cookie.parse(url, "ab=c\u001fd")).isNull();
-    assertThat(Cookie.parse(url, "a\u007fb=cd")).isNull();
-    assertThat(Cookie.parse(url, "ab=c\u007fd")).isNull();
-    assertThat(Cookie.parse(url, "a\u0080b=cd")).isNull();
-    assertThat(Cookie.parse(url, "ab=c\u0080d")).isNull();
-    assertThat(Cookie.parse(url, "a\u00ffb=cd")).isNull();
-    assertThat(Cookie.parse(url, "ab=c\u00ffd")).isNull();
-  }
-
-  @Test public void maxAge() throws Exception {
-    assertThat(Cookie.parse(50000L, url, "a=b; Max-Age=1").expiresAt()).isEqualTo(51000L);
-    assertThat(Cookie.parse(50000L, url, "a=b; Max-Age=9223372036854724").expiresAt()).isEqualTo(
-        HttpDate.MAX_DATE);
-    assertThat(Cookie.parse(50000L, url, "a=b; Max-Age=9223372036854725").expiresAt()).isEqualTo(
-        HttpDate.MAX_DATE);
-    assertThat(Cookie.parse(50000L, url, "a=b; Max-Age=9223372036854726").expiresAt()).isEqualTo(
-        HttpDate.MAX_DATE);
-    assertThat(Cookie.parse(9223372036854773807L, url, "a=b; Max-Age=1").expiresAt()).isEqualTo(
-        HttpDate.MAX_DATE);
-    assertThat(Cookie.parse(9223372036854773807L, url, "a=b; Max-Age=2").expiresAt()).isEqualTo(
-        HttpDate.MAX_DATE);
-    assertThat(Cookie.parse(9223372036854773807L, url, "a=b; Max-Age=3").expiresAt()).isEqualTo(
-        HttpDate.MAX_DATE);
-    assertThat(Cookie.parse(50000L, url, "a=b; Max-Age=10000000000000000000").expiresAt()).isEqualTo(
-        HttpDate.MAX_DATE);
-  }
-
-  @Test public void maxAgeNonPositive() throws Exception {
-    assertThat(Cookie.parse(50000L, url, "a=b; Max-Age=-1").expiresAt()).isEqualTo(Long.MIN_VALUE);
-    assertThat(Cookie.parse(50000L, url, "a=b; Max-Age=0").expiresAt()).isEqualTo(Long.MIN_VALUE);
-    assertThat(Cookie.parse(50000L, url, "a=b; Max-Age=-9223372036854775808").expiresAt()).isEqualTo(
-        Long.MIN_VALUE);
-    assertThat(Cookie.parse(50000L, url, "a=b; Max-Age=-9223372036854775809").expiresAt()).isEqualTo(
-        Long.MIN_VALUE);
-    assertThat(Cookie.parse(50000L, url, "a=b; Max-Age=-10000000000000000000").expiresAt()).isEqualTo(
-        Long.MIN_VALUE);
-  }
-
-  @Test public void domainAndPath() throws Exception {
-    Cookie cookie = Cookie.parse(url, "SID=31d4d96e407aad42; Path=/; Domain=example.com");
-    assertThat(cookie.domain()).isEqualTo("example.com");
-    assertThat(cookie.path()).isEqualTo("/");
-    assertThat(cookie.hostOnly()).isFalse();
-    assertThat(cookie.toString()).isEqualTo(
-        "SID=31d4d96e407aad42; domain=example.com; path=/");
-  }
-
-  @Test public void secureAndHttpOnly() throws Exception {
-    Cookie cookie = Cookie.parse(url, "SID=31d4d96e407aad42; Path=/; Secure; HttpOnly");
-    assertThat(cookie.secure()).isTrue();
-    assertThat(cookie.httpOnly()).isTrue();
-    assertThat(cookie.toString()).isEqualTo(
-        "SID=31d4d96e407aad42; path=/; secure; httponly");
-  }
-
-  @Test public void expiresDate() throws Exception {
-    assertThat(new Date(
-        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:00:00 GMT").expiresAt())).isEqualTo(
-        date("1970-01-01T00:00:00.000+0000"));
-    assertThat(new Date(
-        Cookie.parse(url, "a=b; Expires=Wed, 09 Jun 2021 10:18:14 GMT").expiresAt())).isEqualTo(
-        date("2021-06-09T10:18:14.000+0000"));
-    assertThat(new Date(
-        Cookie.parse(url, "a=b; Expires=Sun, 06 Nov 1994 08:49:37 GMT").expiresAt())).isEqualTo(
-        date("1994-11-06T08:49:37.000+0000"));
-  }
-
-  @Test public void awkwardDates() throws Exception {
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 70 00:00:00 GMT").expiresAt()).isEqualTo(
-        0L);
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 January 1970 00:00:00 GMT").expiresAt()).isEqualTo(
-        0L);
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Janucember 1970 00:00:00 GMT").expiresAt()).isEqualTo(
-        0L);
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 1 Jan 1970 00:00:00 GMT").expiresAt()).isEqualTo(
-        0L);
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 0:00:00 GMT").expiresAt()).isEqualTo(
-        0L);
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:0:00 GMT").expiresAt()).isEqualTo(
-        0L);
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:00:0 GMT").expiresAt()).isEqualTo(
-        0L);
-    assertThat(Cookie.parse(url, "a=b; Expires=00:00:00 Thu, 01 Jan 1970 GMT").expiresAt()).isEqualTo(
-        0L);
-    assertThat(Cookie.parse(url, "a=b; Expires=00:00:00 1970 Jan 01").expiresAt()).isEqualTo(0L);
-    assertThat(Cookie.parse(url, "a=b; Expires=00:00:00 1970 Jan 1").expiresAt()).isEqualTo(0L);
-  }
-
-  @Test public void invalidYear() throws Exception {
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1600 00:00:00 GMT").expiresAt()).isEqualTo(
-        HttpDate.MAX_DATE);
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 19999 00:00:00 GMT").expiresAt()).isEqualTo(
-        HttpDate.MAX_DATE);
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 00:00:00 GMT").expiresAt()).isEqualTo(
-        HttpDate.MAX_DATE);
-  }
-
-  @Test public void invalidMonth() throws Exception {
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Foo 1970 00:00:00 GMT").expiresAt()).isEqualTo(
-        HttpDate.MAX_DATE);
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Foocember 1970 00:00:00 GMT").expiresAt()).isEqualTo(
-        HttpDate.MAX_DATE);
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 1970 00:00:00 GMT").expiresAt()).isEqualTo(
-        HttpDate.MAX_DATE);
-  }
-
-  @Test public void invalidDayOfMonth() throws Exception {
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 32 Jan 1970 00:00:00 GMT").expiresAt()).isEqualTo(
-        HttpDate.MAX_DATE);
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, Jan 1970 00:00:00 GMT").expiresAt()).isEqualTo(
-        HttpDate.MAX_DATE);
-  }
-
-  @Test public void invalidHour() throws Exception {
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 24:00:00 GMT").expiresAt()).isEqualTo(
-        HttpDate.MAX_DATE);
-  }
-
-  @Test public void invalidMinute() throws Exception {
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:60:00 GMT").expiresAt()).isEqualTo(
-        HttpDate.MAX_DATE);
-  }
-
-  @Test public void invalidSecond() throws Exception {
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:00:60 GMT").expiresAt()).isEqualTo(
-        HttpDate.MAX_DATE);
-  }
-
-  @Test public void domainMatches() throws Exception {
-    Cookie cookie = Cookie.parse(url, "a=b; domain=example.com");
-    assertThat(cookie.matches(HttpUrl.get("http://example.com"))).isTrue();
-    assertThat(cookie.matches(HttpUrl.get("http://www.example.com"))).isTrue();
-    assertThat(cookie.matches(HttpUrl.get("http://square.com"))).isFalse();
-  }
-
-  /** If no domain is present, match only the origin domain. */
-  @Test public void domainMatchesNoDomain() throws Exception {
-    Cookie cookie = Cookie.parse(url, "a=b");
-    assertThat(cookie.matches(HttpUrl.get("http://example.com"))).isTrue();
-    assertThat(cookie.matches(HttpUrl.get("http://www.example.com"))).isFalse();
-    assertThat(cookie.matches(HttpUrl.get("http://square.com"))).isFalse();
-  }
-
-  /** Ignore an optional leading `.` in the domain. */
-  @Test public void domainMatchesIgnoresLeadingDot() throws Exception {
-    Cookie cookie = Cookie.parse(url, "a=b; domain=.example.com");
-    assertThat(cookie.matches(HttpUrl.get("http://example.com"))).isTrue();
-    assertThat(cookie.matches(HttpUrl.get("http://www.example.com"))).isTrue();
-    assertThat(cookie.matches(HttpUrl.get("http://square.com"))).isFalse();
-  }
-
-  /** Ignore the entire attribute if the domain ends with `.`. */
-  @Test public void domainIgnoredWithTrailingDot() throws Exception {
-    Cookie cookie = Cookie.parse(url, "a=b; domain=example.com.");
-    assertThat(cookie.matches(HttpUrl.get("http://example.com"))).isTrue();
-    assertThat(cookie.matches(HttpUrl.get("http://www.example.com"))).isFalse();
-    assertThat(cookie.matches(HttpUrl.get("http://square.com"))).isFalse();
-  }
-
-  @Test public void idnDomainMatches() throws Exception {
-    Cookie cookie = Cookie.parse(HttpUrl.get("http://‚òÉ.net/"), "a=b; domain=‚òÉ.net");
-    assertThat(cookie.matches(HttpUrl.get("http://‚òÉ.net/"))).isTrue();
-    assertThat(cookie.matches(HttpUrl.get("http://xn--n3h.net/"))).isTrue();
-    assertThat(cookie.matches(HttpUrl.get("http://www.‚òÉ.net/"))).isTrue();
-    assertThat(cookie.matches(HttpUrl.get("http://www.xn--n3h.net/"))).isTrue();
-  }
-
-  @Test public void punycodeDomainMatches() throws Exception {
-    Cookie cookie = Cookie.parse(HttpUrl.get("http://xn--n3h.net/"), "a=b; domain=xn--n3h.net");
-    assertThat(cookie.matches(HttpUrl.get("http://‚òÉ.net/"))).isTrue();
-    assertThat(cookie.matches(HttpUrl.get("http://xn--n3h.net/"))).isTrue();
-    assertThat(cookie.matches(HttpUrl.get("http://www.‚òÉ.net/"))).isTrue();
-    assertThat(cookie.matches(HttpUrl.get("http://www.xn--n3h.net/"))).isTrue();
-  }
-
-  @Test public void domainMatchesIpAddress() throws Exception {
-    HttpUrl urlWithIp = HttpUrl.get("http://123.45.234.56/");
-    assertThat(Cookie.parse(urlWithIp, "a=b; domain=234.56")).isNull();
-    assertThat(Cookie.parse(urlWithIp, "a=b; domain=123.45.234.56").domain()).isEqualTo(
-        "123.45.234.56");
-  }
-
-  @Test public void domainMatchesIpv6Address() throws Exception {
-    Cookie cookie = Cookie.parse(HttpUrl.get("http://[::1]/"), "a=b; domain=::1");
-    assertThat(cookie.domain()).isEqualTo("::1");
-    assertThat(cookie.matches(HttpUrl.get("http://[::1]/"))).isTrue();
-  }
-
-  @Test public void domainMatchesIpv6AddressWithCompression() throws Exception {
-    Cookie cookie = Cookie.parse(HttpUrl.get("http://[0001:0000::]/"), "a=b; domain=0001:0000::");
-    assertThat(cookie.domain()).isEqualTo("1::");
-    assertThat(cookie.matches(HttpUrl.get("http://[1::]/"))).isTrue();
-  }
-
-  @Test public void domainMatchesIpv6AddressWithIpv4Suffix() throws Exception {
-    Cookie cookie = Cookie.parse(
-        HttpUrl.get("http://[::1:ffff:ffff]/"), "a=b; domain=::1:255.255.255.255");
-    assertThat(cookie.domain()).isEqualTo("::1:ffff:ffff");
-    assertThat(cookie.matches(HttpUrl.get("http://[::1:ffff:ffff]/"))).isTrue();
-  }
-
-  @Test public void ipv6AddressDoesntMatch() throws Exception {
-    Cookie cookie = Cookie.parse(HttpUrl.get("http://[::1]/"), "a=b; domain=::2");
-    assertThat(cookie).isNull();
-  }
-
-  @Test public void ipv6AddressMalformed() throws Exception {
-    Cookie cookie = Cookie.parse(HttpUrl.get("http://[::1]/"), "a=b; domain=::2::2");
-    assertThat(cookie.domain()).isEqualTo("::1");
-  }
-
-  /**
-   * These public suffixes were selected by inspecting the publicsuffix.org list. It's possible they
-   * may change in the future. If this test begins to fail, please double check they are still
-   * present in the public suffix list.
-   */
-  @Test public void domainIsPublicSuffix() {
-    HttpUrl ascii = HttpUrl.get("https://foo1.foo.bar.elb.amazonaws.com");
-    assertThat(Cookie.parse(ascii, "a=b; domain=foo.bar.elb.amazonaws.com")).isNotNull();
-    assertThat(Cookie.parse(ascii, "a=b; domain=bar.elb.amazonaws.com")).isNull();
-    assertThat(Cookie.parse(ascii, "a=b; domain=com")).isNull();
-
-    HttpUrl unicode = HttpUrl.get("https://Èï∑.Èï∑.Èï∑Â¥é.jp");
-    assertThat(Cookie.parse(unicode, "a=b; domain=Èï∑.Èï∑Â¥é.jp")).isNotNull();
-    assertThat(Cookie.parse(unicode, "a=b; domain=Èï∑Â¥é.jp")).isNull();
-
-    HttpUrl punycode = HttpUrl.get("https://xn--ue5a.xn--ue5a.xn--8ltr62k.jp");
-    assertThat(Cookie.parse(punycode, "a=b; domain=xn--ue5a.xn--8ltr62k.jp")).isNotNull();
-    assertThat(Cookie.parse(punycode, "a=b; domain=xn--8ltr62k.jp")).isNull();
-  }
-
-  @Test public void hostOnly() throws Exception {
-    assertThat(Cookie.parse(url, "a=b").hostOnly()).isTrue();
-    assertThat(Cookie.parse(url, "a=b; domain=example.com").hostOnly()).isFalse();
-  }
-
-  @Test public void defaultPath() throws Exception {
-    assertThat(Cookie.parse(HttpUrl.get("http://example.com/foo/bar"), "a=b").path()).isEqualTo(
-        "/foo");
-    assertThat(Cookie.parse(HttpUrl.get("http://example.com/foo/"), "a=b").path()).isEqualTo(
-        "/foo");
-    assertThat(Cookie.parse(HttpUrl.get("http://example.com/foo"), "a=b").path()).isEqualTo(
-        "/");
-    assertThat(Cookie.parse(HttpUrl.get("http://example.com/"), "a=b").path()).isEqualTo(
-        "/");
-  }
-
-  @Test public void defaultPathIsUsedIfPathDoesntHaveLeadingSlash() throws Exception {
-    assertThat(Cookie.parse(HttpUrl.get("http://example.com/foo/bar"),
-        "a=b; path=quux").path()).isEqualTo("/foo");
-    assertThat(Cookie.parse(HttpUrl.get("http://example.com/foo/bar"),
-        "a=b; path=").path()).isEqualTo("/foo");
-  }
-
-  @Test public void pathAttributeDoesntNeedToMatch() throws Exception {
-    assertThat(Cookie.parse(HttpUrl.get("http://example.com/"),
-        "a=b; path=/quux").path()).isEqualTo("/quux");
-    assertThat(Cookie.parse(HttpUrl.get("http://example.com/foo/bar"),
-        "a=b; path=/quux").path()).isEqualTo("/quux");
-  }
-
-  @Test public void httpOnly() throws Exception {
-    assertThat(Cookie.parse(url, "a=b").httpOnly()).isFalse();
-    assertThat(Cookie.parse(url, "a=b; HttpOnly").httpOnly()).isTrue();
-  }
-
-  @Test public void secure() throws Exception {
-    assertThat(Cookie.parse(url, "a=b").secure()).isFalse();
-    assertThat(Cookie.parse(url, "a=b; Secure").secure()).isTrue();
-  }
-
-  @Test public void maxAgeTakesPrecedenceOverExpires() throws Exception {
-    // Max-Age = 1, Expires = 2. In either order.
-    assertThat(Cookie.parse(
-        0L, url, "a=b; Max-Age=1; Expires=Thu, 01 Jan 1970 00:00:02 GMT").expiresAt()).isEqualTo(
-        1000L);
-    assertThat(Cookie.parse(
-        0L, url, "a=b; Expires=Thu, 01 Jan 1970 00:00:02 GMT; Max-Age=1").expiresAt()).isEqualTo(
-        1000L);
-    // Max-Age = 2, Expires = 1. In either order.
-    assertThat(Cookie.parse(
-        0L, url, "a=b; Max-Age=2; Expires=Thu, 01 Jan 1970 00:00:01 GMT").expiresAt()).isEqualTo(
-        2000L);
-    assertThat(Cookie.parse(
-        0L, url, "a=b; Expires=Thu, 01 Jan 1970 00:00:01 GMT; Max-Age=2").expiresAt()).isEqualTo(
-        2000L);
-  }
-
-  /** If a cookie incorrectly defines multiple 'Max-Age' attributes, the last one defined wins. */
-  @Test public void lastMaxAgeWins() throws Exception {
-    assertThat(Cookie.parse(
-        0L, url, "a=b; Max-Age=2; Max-Age=4; Max-Age=1; Max-Age=3").expiresAt()).isEqualTo(3000L);
-  }
-
-  /** If a cookie incorrectly defines multiple 'Expires' attributes, the last one defined wins. */
-  @Test public void lastExpiresAtWins() throws Exception {
-    assertThat(Cookie.parse(0L, url, "a=b; "
-        + "Expires=Thu, 01 Jan 1970 00:00:02 GMT; "
-        + "Expires=Thu, 01 Jan 1970 00:00:04 GMT; "
-        + "Expires=Thu, 01 Jan 1970 00:00:01 GMT; "
-        + "Expires=Thu, 01 Jan 1970 00:00:03 GMT").expiresAt()).isEqualTo(3000L);
-  }
-
-  @Test public void maxAgeOrExpiresMakesCookiePersistent() throws Exception {
-    assertThat(Cookie.parse(0L, url, "a=b").persistent()).isFalse();
-    assertThat(Cookie.parse(0L, url, "a=b; Max-Age=1").persistent()).isTrue();
-    assertThat(Cookie.parse(0L, url, "a=b; Expires=Thu, 01 Jan 1970 00:00:01 GMT").persistent()).isTrue();
-  }
-
-  @Test public void parseAll() throws Exception {
-    Headers headers = new Headers.Builder()
-        .add("Set-Cookie: a=b")
-        .add("Set-Cookie: c=d")
-        .build();
-    List<Cookie> cookies = Cookie.parseAll(url, headers);
-    assertThat(cookies.size()).isEqualTo(2);
-    assertThat(cookies.get(0).toString()).isEqualTo("a=b; path=/");
-    assertThat(cookies.get(1).toString()).isEqualTo("c=d; path=/");
-  }
-
-  @Test public void builder() throws Exception {
-    Cookie cookie = new Cookie.Builder()
-        .name("a")
-        .value("b")
-        .domain("example.com")
-        .build();
-    assertThat(cookie.name()).isEqualTo("a");
-    assertThat(cookie.value()).isEqualTo("b");
-    assertThat(cookie.expiresAt()).isEqualTo(HttpDate.MAX_DATE);
-    assertThat(cookie.domain()).isEqualTo("example.com");
-    assertThat(cookie.path()).isEqualTo("/");
-    assertThat(cookie.secure()).isFalse();
-    assertThat(cookie.httpOnly()).isFalse();
-    assertThat(cookie.persistent()).isFalse();
-    assertThat(cookie.hostOnly()).isFalse();
-  }
-
-  @Test public void builderNameValidation() throws Exception {
-    try {
-      new Cookie.Builder().name(null);
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    try {
-      new Cookie.Builder().name(" a ");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void builderValueValidation() throws Exception {
-    try {
-      new Cookie.Builder().value(null);
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    try {
-      new Cookie.Builder().value(" b ");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void builderClampsMaxDate() throws Exception {
-    Cookie cookie = new Cookie.Builder()
-        .name("a")
-        .value("b")
-        .hostOnlyDomain("example.com")
-        .expiresAt(Long.MAX_VALUE)
-        .build();
-    assertThat(cookie.toString()).isEqualTo(
-        "a=b; expires=Fri, 31 Dec 9999 23:59:59 GMT; path=/");
-  }
-
-  @Test public void builderExpiresAt() throws Exception {
-    Cookie cookie = new Cookie.Builder()
-        .name("a")
-        .value("b")
-        .hostOnlyDomain("example.com")
-        .expiresAt(date("1970-01-01T00:00:01.000+0000").getTime())
-        .build();
-    assertThat(cookie.toString()).isEqualTo(
-        "a=b; expires=Thu, 01 Jan 1970 00:00:01 GMT; path=/");
-  }
-
-  @Test public void builderClampsMinDate() throws Exception {
-    Cookie cookie = new Cookie.Builder()
-        .name("a")
-        .value("b")
-        .hostOnlyDomain("example.com")
-        .expiresAt(date("1970-01-01T00:00:00.000+0000").getTime())
-        .build();
-    assertThat(cookie.toString()).isEqualTo("a=b; max-age=0; path=/");
-  }
-
-  @Test public void builderDomainValidation() throws Exception {
-    try {
-      new Cookie.Builder().hostOnlyDomain(null);
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    try {
-      new Cookie.Builder().hostOnlyDomain("a/b");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void builderDomain() throws Exception {
-    Cookie cookie = new Cookie.Builder()
-        .name("a")
-        .value("b")
-        .hostOnlyDomain("squareup.com")
-        .build();
-    assertThat(cookie.domain()).isEqualTo("squareup.com");
-    assertThat(cookie.hostOnly()).isTrue();
-  }
-
-  @Test public void builderPath() throws Exception {
-    Cookie cookie = new Cookie.Builder()
-        .name("a")
-        .value("b")
-        .hostOnlyDomain("example.com")
-        .path("/foo")
-        .build();
-    assertThat(cookie.path()).isEqualTo("/foo");
-  }
-
-  @Test public void builderPathValidation() throws Exception {
-    try {
-      new Cookie.Builder().path(null);
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    try {
-      new Cookie.Builder().path("foo");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void builderSecure() throws Exception {
-    Cookie cookie = new Cookie.Builder()
-        .name("a")
-        .value("b")
-        .hostOnlyDomain("example.com")
-        .secure()
-        .build();
-    assertThat(cookie.secure()).isTrue();
-  }
-
-  @Test public void builderHttpOnly() throws Exception {
-    Cookie cookie = new Cookie.Builder()
-        .name("a")
-        .value("b")
-        .hostOnlyDomain("example.com")
-        .httpOnly()
-        .build();
-    assertThat(cookie.httpOnly()).isTrue();
-  }
-
-  @Test public void builderIpv6() throws Exception {
-    Cookie cookie = new Cookie.Builder()
-        .name("a")
-        .value("b")
-        .domain("0:0:0:0:0:0:0:1")
-        .build();
-    assertThat(cookie.domain()).isEqualTo("::1");
-  }
-
-  @Test public void equalsAndHashCode() throws Exception {
-    List<String> cookieStrings = Arrays.asList(
-        "a=b; Path=/c; Domain=example.com; Max-Age=5; Secure; HttpOnly",
-        "a= ; Path=/c; Domain=example.com; Max-Age=5; Secure; HttpOnly",
-        "a=b;          Domain=example.com; Max-Age=5; Secure; HttpOnly",
-        "a=b; Path=/c;                     Max-Age=5; Secure; HttpOnly",
-        "a=b; Path=/c; Domain=example.com;            Secure; HttpOnly",
-        "a=b; Path=/c; Domain=example.com; Max-Age=5;         HttpOnly",
-        "a=b; Path=/c; Domain=example.com; Max-Age=5; Secure;         "
-    );
-    for (String stringA : cookieStrings) {
-      Cookie cookieA = Cookie.parse(0, url, stringA);
-      for (String stringB : cookieStrings) {
-        Cookie cookieB = Cookie.parse(0, url, stringB);
-        if (Objects.equals(stringA, stringB)) {
-          assertThat(cookieB.hashCode()).isEqualTo(cookieA.hashCode());
-          assertThat(cookieB).isEqualTo(cookieA);
-        } else {
-          assertThat(cookieB.hashCode()).isNotEqualTo((long) cookieA.hashCode());
-          assertThat(cookieB).isNotEqualTo(cookieA);
-        }
-      }
-      assertThat(cookieA).isNotEqualTo(null);
-    }
-  }
-
-  private Date date(String s) throws ParseException {
-    SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ");
-    format.setTimeZone(Util.UTC);
-    return format.parse(s);
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/CookiesTest.java b/okhttp-tests/src/test/java/okhttp3/CookiesTest.java
deleted file mode 100644
index 514252822e..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/CookiesTest.java
+++ /dev/null
@@ -1,344 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package okhttp3;
-
-import java.io.IOException;
-import java.net.CookieHandler;
-import java.net.CookieManager;
-import java.net.HttpCookie;
-import java.net.HttpURLConnection;
-import java.net.InetAddress;
-import java.net.URI;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static java.net.CookiePolicy.ACCEPT_ORIGINAL_SERVER;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.data.Offset.offset;
-import static org.junit.Assert.fail;
-
-/** Derived from Android's CookiesTest. */
-public class CookiesTest {
-  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
-
-  private OkHttpClient client = clientTestRule.client;
-
-  @Test
-  public void testNetscapeResponse() throws Exception {
-    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
-    client = client.newBuilder()
-        .cookieJar(new JavaNetCookieJar(cookieManager))
-        .build();
-    MockWebServer server = new MockWebServer();
-    server.start();
-
-    HttpUrl urlWithIpAddress = urlWithIpAddress(server, "/path/foo");
-    server.enqueue(new MockResponse().addHeader("Set-Cookie: a=android; "
-        + "expires=Fri, 31-Dec-9999 23:59:59 GMT; "
-        + "path=/path; "
-        + "domain=" + urlWithIpAddress.host() + "; "
-        + "secure"));
-    get(urlWithIpAddress);
-
-    List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
-    assertThat(cookies.size()).isEqualTo(1);
-    HttpCookie cookie = cookies.get(0);
-    assertThat(cookie.getName()).isEqualTo("a");
-    assertThat(cookie.getValue()).isEqualTo("android");
-    assertThat(cookie.getComment()).isNull();
-    assertThat(cookie.getCommentURL()).isNull();
-    assertThat(cookie.getDiscard()).isFalse();
-    assertThat(cookie.getMaxAge() > 100000000000L).isTrue();
-    assertThat(cookie.getPath()).isEqualTo("/path");
-    assertThat(cookie.getSecure()).isTrue();
-    assertThat(cookie.getVersion()).isEqualTo(0);
-  }
-
-  @Test public void testRfc2109Response() throws Exception {
-    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
-    client = client.newBuilder()
-        .cookieJar(new JavaNetCookieJar(cookieManager))
-        .build();
-    MockWebServer server = new MockWebServer();
-    server.start();
-
-    HttpUrl urlWithIpAddress = urlWithIpAddress(server, "/path/foo");
-    server.enqueue(new MockResponse().addHeader("Set-Cookie: a=android; "
-        + "Comment=this cookie is delicious; "
-        + "Domain=" + urlWithIpAddress.host() + "; "
-        + "Max-Age=60; "
-        + "Path=/path; "
-        + "Secure; "
-        + "Version=1"));
-    get(urlWithIpAddress);
-
-    List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
-    assertThat(cookies.size()).isEqualTo(1);
-    HttpCookie cookie = cookies.get(0);
-    assertThat(cookie.getName()).isEqualTo("a");
-    assertThat(cookie.getValue()).isEqualTo("android");
-    assertThat(cookie.getCommentURL()).isNull();
-    assertThat(cookie.getDiscard()).isFalse();
-    // Converting to a fixed date can cause rounding!
-    assertThat((double) cookie.getMaxAge()).isCloseTo(60.0, offset(1.0));
-    assertThat(cookie.getPath()).isEqualTo("/path");
-    assertThat(cookie.getSecure()).isTrue();
-  }
-
-  @Test public void testQuotedAttributeValues() throws Exception {
-    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
-    client = client.newBuilder()
-        .cookieJar(new JavaNetCookieJar(cookieManager))
-        .build();
-    MockWebServer server = new MockWebServer();
-    server.start();
-
-    HttpUrl urlWithIpAddress = urlWithIpAddress(server, "/path/foo");
-    server.enqueue(new MockResponse().addHeader("Set-Cookie: a=\"android\"; "
-        + "Comment=\"this cookie is delicious\"; "
-        + "CommentURL=\"http://google.com/\"; "
-        + "Discard; "
-        + "Domain=" + urlWithIpAddress.host() + "; "
-        + "Max-Age=60; "
-        + "Path=\"/path\"; "
-        + "Port=\"80,443," + server.getPort() + "\"; "
-        + "Secure; "
-        + "Version=\"1\""));
-    get(urlWithIpAddress);
-
-    List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
-    assertThat(cookies.size()).isEqualTo(1);
-    HttpCookie cookie = cookies.get(0);
-    assertThat(cookie.getName()).isEqualTo("a");
-    assertThat(cookie.getValue()).isEqualTo("android");
-    // Converting to a fixed date can cause rounding!
-    assertThat((double) cookie.getMaxAge()).isCloseTo(60.0, offset(1.0));
-    assertThat(cookie.getPath()).isEqualTo("/path");
-    assertThat(cookie.getSecure()).isTrue();
-  }
-
-  @Test public void testSendingCookiesFromStore() throws Exception {
-    MockWebServer server = new MockWebServer();
-    server.enqueue(new MockResponse());
-    server.start();
-    HttpUrl serverUrl = urlWithIpAddress(server, "/");
-
-    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
-    HttpCookie cookieA = new HttpCookie("a", "android");
-    cookieA.setDomain(serverUrl.host());
-    cookieA.setPath("/");
-    cookieManager.getCookieStore().add(serverUrl.uri(), cookieA);
-    HttpCookie cookieB = new HttpCookie("b", "banana");
-    cookieB.setDomain(serverUrl.host());
-    cookieB.setPath("/");
-    cookieManager.getCookieStore().add(serverUrl.uri(), cookieB);
-    client = client.newBuilder()
-        .cookieJar(new JavaNetCookieJar(cookieManager))
-        .build();
-
-    get(serverUrl);
-    RecordedRequest request = server.takeRequest();
-
-    assertThat(request.getHeader("Cookie")).isEqualTo("a=android; b=banana");
-  }
-
-  @Test public void cookieHandlerLikeAndroid() throws Exception {
-    final MockWebServer server = new MockWebServer();
-    server.enqueue(new MockResponse());
-    server.start();
-    final HttpUrl serverUrl = urlWithIpAddress(server, "/");
-
-    CookieHandler androidCookieHandler = new CookieHandler() {
-      @Override public Map<String, List<String>> get(URI uri, Map<String, List<String>> map)
-          throws IOException {
-        return Collections.singletonMap("Cookie", Collections.singletonList("$Version=\"1\"; "
-            + "a=\"android\";$Path=\"/\";$Domain=\"" + serverUrl.host() + "\"; "
-            + "b=\"banana\";$Path=\"/\";$Domain=\"" + serverUrl.host() + "\""));
-      }
-
-      @Override public void put(URI uri, Map<String, List<String>> map) throws IOException {
-      }
-    };
-
-    client = client.newBuilder()
-        .cookieJar(new JavaNetCookieJar(androidCookieHandler))
-        .build();
-
-    get(serverUrl);
-    RecordedRequest request = server.takeRequest();
-
-    assertThat(request.getHeader("Cookie")).isEqualTo("a=android; b=banana");
-  }
-
-  @Test public void receiveAndSendMultipleCookies() throws Exception {
-    MockWebServer server = new MockWebServer();
-    server.enqueue(new MockResponse()
-        .addHeader("Set-Cookie", "a=android")
-        .addHeader("Set-Cookie", "b=banana"));
-    server.enqueue(new MockResponse());
-    server.start();
-
-    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
-    client = client.newBuilder()
-        .cookieJar(new JavaNetCookieJar(cookieManager))
-        .build();
-
-    get(urlWithIpAddress(server, "/"));
-    RecordedRequest request1 = server.takeRequest();
-    assertThat(request1.getHeader("Cookie")).isNull();
-
-    get(urlWithIpAddress(server, "/"));
-    RecordedRequest request2 = server.takeRequest();
-    assertThat(request2.getHeader("Cookie")).isEqualTo("a=android; b=banana");
-  }
-
-  @Test public void testRedirectsDoNotIncludeTooManyCookies() throws Exception {
-    MockWebServer redirectTarget = new MockWebServer();
-    redirectTarget.enqueue(new MockResponse().setBody("A"));
-    redirectTarget.start();
-    HttpUrl redirectTargetUrl = urlWithIpAddress(redirectTarget, "/");
-
-    MockWebServer redirectSource = new MockWebServer();
-    redirectSource.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + redirectTargetUrl));
-    redirectSource.start();
-    HttpUrl redirectSourceUrl = urlWithIpAddress(redirectSource, "/");
-
-    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
-    HttpCookie cookie = new HttpCookie("c", "cookie");
-    cookie.setDomain(redirectSourceUrl.host());
-    cookie.setPath("/");
-    String portList = Integer.toString(redirectSource.getPort());
-    cookie.setPortlist(portList);
-    cookieManager.getCookieStore().add(redirectSourceUrl.uri(), cookie);
-    client = client.newBuilder()
-        .cookieJar(new JavaNetCookieJar(cookieManager))
-        .build();
-
-    get(redirectSourceUrl);
-    RecordedRequest request = redirectSource.takeRequest();
-
-    assertThat(request.getHeader("Cookie")).isEqualTo("c=cookie");
-
-    for (String header : redirectTarget.takeRequest().getHeaders().names()) {
-      if (header.startsWith("Cookie")) {
-        fail(header);
-      }
-    }
-  }
-
-  @Test public void testCookiesSentIgnoresCase() throws Exception {
-    client = client.newBuilder()
-        .cookieJar(new JavaNetCookieJar(new CookieManager() {
-          @Override public Map<String, List<String>> get(URI uri,
-              Map<String, List<String>> requestHeaders) throws IOException {
-            Map<String, List<String>> result = new LinkedHashMap<>();
-            result.put("COOKIE", Collections.singletonList("Bar=bar"));
-            result.put("cooKIE2", Collections.singletonList("Baz=baz"));
-            return result;
-          }
-        }))
-        .build();
-
-    MockWebServer server = new MockWebServer();
-    server.enqueue(new MockResponse());
-    server.start();
-
-    get(server.url("/"));
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getHeader("Cookie")).isEqualTo("Bar=bar; Baz=baz");
-    assertThat(request.getHeader("Cookie2")).isNull();
-    assertThat(request.getHeader("Quux")).isNull();
-  }
-
-  @Test public void acceptOriginalServerMatchesSubdomain() throws Exception {
-    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
-    JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
-
-    HttpUrl url = HttpUrl.get("https://www.squareup.com/");
-    cookieJar.saveFromResponse(url, Arrays.asList(
-        Cookie.parse(url, "a=android; Domain=squareup.com")));
-    List<Cookie> actualCookies = cookieJar.loadForRequest(url);
-    assertThat(actualCookies.size()).isEqualTo(1);
-    assertThat(actualCookies.get(0).name()).isEqualTo("a");
-    assertThat(actualCookies.get(0).value()).isEqualTo("android");
-  }
-
-  @Test public void acceptOriginalServerMatchesRfc2965Dot() throws Exception {
-    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
-    JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
-
-    HttpUrl url = HttpUrl.get("https://www.squareup.com/");
-    cookieJar.saveFromResponse(url, Arrays.asList(
-        Cookie.parse(url, "a=android; Domain=.squareup.com")));
-    List<Cookie> actualCookies = cookieJar.loadForRequest(url);
-    assertThat(actualCookies.size()).isEqualTo(1);
-    assertThat(actualCookies.get(0).name()).isEqualTo("a");
-    assertThat(actualCookies.get(0).value()).isEqualTo("android");
-  }
-
-  @Test public void acceptOriginalServerMatchesExactly() throws Exception {
-    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
-    JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
-
-    HttpUrl url = HttpUrl.get("https://squareup.com/");
-    cookieJar.saveFromResponse(url, Arrays.asList(
-        Cookie.parse(url, "a=android; Domain=squareup.com")));
-    List<Cookie> actualCookies = cookieJar.loadForRequest(url);
-    assertThat(actualCookies.size()).isEqualTo(1);
-    assertThat(actualCookies.get(0).name()).isEqualTo("a");
-    assertThat(actualCookies.get(0).value()).isEqualTo("android");
-  }
-
-  @Test public void acceptOriginalServerDoesNotMatchDifferentServer() throws Exception {
-    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
-    JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
-
-    HttpUrl url1 = HttpUrl.get("https://api.squareup.com/");
-    cookieJar.saveFromResponse(url1, Arrays.asList(
-        Cookie.parse(url1, "a=android; Domain=api.squareup.com")));
-
-    HttpUrl url2 = HttpUrl.get("https://www.squareup.com/");
-    List<Cookie> actualCookies = cookieJar.loadForRequest(url2);
-    assertThat(actualCookies).isEmpty();
-  }
-
-  private HttpUrl urlWithIpAddress(MockWebServer server, String path) throws Exception {
-    return server.url(path)
-        .newBuilder()
-        .host(InetAddress.getByName(server.getHostName()).getHostAddress())
-        .build();
-  }
-
-  private void get(HttpUrl url) throws Exception {
-    Call call = client.newCall(new Request.Builder()
-        .url(url)
-        .build());
-    Response response = call.execute();
-    response.body().close();
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocket.java b/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocket.java
deleted file mode 100644
index e6c931b6ad..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocket.java
+++ /dev/null
@@ -1,340 +0,0 @@
-/*
- * Copyright 2014 Square Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.lang.reflect.InvocationTargetException;
-import java.net.InetAddress;
-import java.net.Socket;
-import java.net.SocketAddress;
-import java.net.SocketException;
-import java.net.SocketOption;
-import java.nio.channels.SocketChannel;
-import java.util.Set;
-import javax.net.ssl.HandshakeCompletedListener;
-import javax.net.ssl.SSLParameters;
-import javax.net.ssl.SSLSession;
-import javax.net.ssl.SSLSocket;
-
-/**
- * An {@link javax.net.ssl.SSLSocket} that delegates all calls.
- */
-public abstract class DelegatingSSLSocket extends SSLSocket {
-  protected final SSLSocket delegate;
-
-  public DelegatingSSLSocket(SSLSocket delegate) {
-    this.delegate = delegate;
-  }
-
-  @Override public void shutdownInput() throws IOException {
-    delegate.shutdownInput();
-  }
-
-  @Override public void shutdownOutput() throws IOException {
-    delegate.shutdownOutput();
-  }
-
-  @Override public String[] getSupportedCipherSuites() {
-    return delegate.getSupportedCipherSuites();
-  }
-
-  @Override public String[] getEnabledCipherSuites() {
-    return delegate.getEnabledCipherSuites();
-  }
-
-  @Override public void setEnabledCipherSuites(String[] suites) {
-    delegate.setEnabledCipherSuites(suites);
-  }
-
-  @Override public String[] getSupportedProtocols() {
-    return delegate.getSupportedProtocols();
-  }
-
-  @Override public String[] getEnabledProtocols() {
-    return delegate.getEnabledProtocols();
-  }
-
-  @Override public void setEnabledProtocols(String[] protocols) {
-    delegate.setEnabledProtocols(protocols);
-  }
-
-  @Override public SSLSession getSession() {
-    return delegate.getSession();
-  }
-
-  @Override public void addHandshakeCompletedListener(HandshakeCompletedListener listener) {
-    delegate.addHandshakeCompletedListener(listener);
-  }
-
-  @Override public void removeHandshakeCompletedListener(HandshakeCompletedListener listener) {
-    delegate.removeHandshakeCompletedListener(listener);
-  }
-
-  @Override public void startHandshake() throws IOException {
-    delegate.startHandshake();
-  }
-
-  @Override public void setUseClientMode(boolean mode) {
-    delegate.setUseClientMode(mode);
-  }
-
-  @Override public boolean getUseClientMode() {
-    return delegate.getUseClientMode();
-  }
-
-  @Override public void setNeedClientAuth(boolean need) {
-    delegate.setNeedClientAuth(need);
-  }
-
-  @Override public void setWantClientAuth(boolean want) {
-    delegate.setWantClientAuth(want);
-  }
-
-  @Override public boolean getNeedClientAuth() {
-    return delegate.getNeedClientAuth();
-  }
-
-  @Override public boolean getWantClientAuth() {
-    return delegate.getWantClientAuth();
-  }
-
-  @Override public void setEnableSessionCreation(boolean flag) {
-    delegate.setEnableSessionCreation(flag);
-  }
-
-  @Override public boolean getEnableSessionCreation() {
-    return delegate.getEnableSessionCreation();
-  }
-
-  @Override public SSLParameters getSSLParameters() {
-    return delegate.getSSLParameters();
-  }
-
-  @Override public void setSSLParameters(SSLParameters p) {
-    delegate.setSSLParameters(p);
-  }
-
-  @Override public void close() throws IOException {
-    delegate.close();
-  }
-
-  @Override public InetAddress getInetAddress() {
-    return delegate.getInetAddress();
-  }
-
-  @Override public InputStream getInputStream() throws IOException {
-    return delegate.getInputStream();
-  }
-
-  @Override public boolean getKeepAlive() throws SocketException {
-    return delegate.getKeepAlive();
-  }
-
-  @Override public InetAddress getLocalAddress() {
-    return delegate.getLocalAddress();
-  }
-
-  @Override public int getLocalPort() {
-    return delegate.getLocalPort();
-  }
-
-  @Override public OutputStream getOutputStream() throws IOException {
-    return delegate.getOutputStream();
-  }
-
-  @Override public int getPort() {
-    return delegate.getPort();
-  }
-
-  @Override public int getSoLinger() throws SocketException {
-    return delegate.getSoLinger();
-  }
-
-  @Override public int getReceiveBufferSize() throws SocketException {
-    return delegate.getReceiveBufferSize();
-  }
-
-  @Override public int getSendBufferSize() throws SocketException {
-    return delegate.getSendBufferSize();
-  }
-
-  @Override public int getSoTimeout() throws SocketException {
-    return delegate.getSoTimeout();
-  }
-
-  @Override public boolean getTcpNoDelay() throws SocketException {
-    return delegate.getTcpNoDelay();
-  }
-
-  @Override public void setKeepAlive(boolean keepAlive) throws SocketException {
-    delegate.setKeepAlive(keepAlive);
-  }
-
-  @Override public void setSendBufferSize(int size) throws SocketException {
-    delegate.setSendBufferSize(size);
-  }
-
-  @Override public void setReceiveBufferSize(int size) throws SocketException {
-    delegate.setReceiveBufferSize(size);
-  }
-
-  @Override public void setSoLinger(boolean on, int timeout) throws SocketException {
-    delegate.setSoLinger(on, timeout);
-  }
-
-  @Override public void setSoTimeout(int timeout) throws SocketException {
-    delegate.setSoTimeout(timeout);
-  }
-
-  @Override public void setTcpNoDelay(boolean on) throws SocketException {
-    delegate.setTcpNoDelay(on);
-  }
-
-  @Override public String toString() {
-    return delegate.toString();
-  }
-
-  @Override public SocketAddress getLocalSocketAddress() {
-    return delegate.getLocalSocketAddress();
-  }
-
-  @Override public SocketAddress getRemoteSocketAddress() {
-    return delegate.getRemoteSocketAddress();
-  }
-
-  @Override public boolean isBound() {
-    return delegate.isBound();
-  }
-
-  @Override public boolean isConnected() {
-    return delegate.isConnected();
-  }
-
-  @Override public boolean isClosed() {
-    return delegate.isClosed();
-  }
-
-  @Override public void bind(SocketAddress localAddr) throws IOException {
-    delegate.bind(localAddr);
-  }
-
-  @Override public void connect(SocketAddress remoteAddr) throws IOException {
-    delegate.connect(remoteAddr);
-  }
-
-  @Override public void connect(SocketAddress remoteAddr, int timeout) throws IOException {
-    delegate.connect(remoteAddr, timeout);
-  }
-
-  @Override public boolean isInputShutdown() {
-    return delegate.isInputShutdown();
-  }
-
-  @Override public boolean isOutputShutdown() {
-    return delegate.isOutputShutdown();
-  }
-
-  @Override public void setReuseAddress(boolean reuse) throws SocketException {
-    delegate.setReuseAddress(reuse);
-  }
-
-  @Override public boolean getReuseAddress() throws SocketException {
-    return delegate.getReuseAddress();
-  }
-
-  @Override public void setOOBInline(boolean oobinline) throws SocketException {
-    delegate.setOOBInline(oobinline);
-  }
-
-  @Override public boolean getOOBInline() throws SocketException {
-    return delegate.getOOBInline();
-  }
-
-  @Override public void setTrafficClass(int value) throws SocketException {
-    delegate.setTrafficClass(value);
-  }
-
-  @Override public int getTrafficClass() throws SocketException {
-    return delegate.getTrafficClass();
-  }
-
-  @Override public void sendUrgentData(int value) throws IOException {
-    delegate.sendUrgentData(value);
-  }
-
-  @Override public SocketChannel getChannel() {
-    return delegate.getChannel();
-  }
-
-  @Override public void setPerformancePreferences(int connectionTime, int latency, int bandwidth) {
-    delegate.setPerformancePreferences(connectionTime, latency, bandwidth);
-  }
-
-  // Java 9 methods.
-
-  public SSLSession getHandshakeSession() {
-    try {
-      return (SSLSession) SSLSocket.class.getMethod("getHandshakeSession").invoke(delegate);
-    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
-      throw new AssertionError();
-    }
-  }
-
-  public String getApplicationProtocol() {
-    try {
-      return (String) SSLSocket.class.getMethod("getApplicationProtocol").invoke(delegate);
-    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
-      throw new AssertionError();
-    }
-  }
-
-  public String getHandshakeApplicationProtocol() {
-    try {
-      return (String) SSLSocket.class.getMethod("getHandshakeApplicationProtocol").invoke(delegate);
-    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
-      throw new AssertionError();
-    }
-  }
-
-  public <T> Socket setOption(SocketOption<T> name, T value) throws IOException {
-    try {
-      SSLSocket.class.getMethod("setOption", SocketOption.class, Object.class).invoke(delegate, name, value);
-      return this;
-    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
-      throw new AssertionError();
-    }
-  }
-
-  @SuppressWarnings("unchecked") // Using reflection to delegate.
-  public <T> T getOption(SocketOption<T> name) throws IOException {
-    try {
-      return (T) SSLSocket.class.getMethod("getOption", SocketOption.class).invoke(delegate, name);
-    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
-      throw new AssertionError();
-    }
-  }
-
-  @SuppressWarnings("unchecked") // Using reflection to delegate.
-  public Set<SocketOption<?>> supportedOptions() {
-    try {
-      return (Set<SocketOption<?>>) SSLSocket.class.getMethod("supportedOptions").invoke(delegate);
-    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
-      throw new AssertionError();
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocketFactory.java b/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocketFactory.java
deleted file mode 100644
index 5a5a3dc20a..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocketFactory.java
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.Socket;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-
-/**
- * A {@link SSLSocketFactory} that delegates calls. Sockets can be configured after creation by
- * overriding {@link #configureSocket(javax.net.ssl.SSLSocket)}.
- */
-public class DelegatingSSLSocketFactory extends SSLSocketFactory {
-
-  private final SSLSocketFactory delegate;
-
-  public DelegatingSSLSocketFactory(SSLSocketFactory delegate) {
-    this.delegate = delegate;
-  }
-
-  @Override public SSLSocket createSocket() throws IOException {
-    SSLSocket sslSocket = (SSLSocket) delegate.createSocket();
-    return configureSocket(sslSocket);
-  }
-
-  @Override public SSLSocket createSocket(String host, int port) throws IOException {
-    SSLSocket sslSocket = (SSLSocket) delegate.createSocket(host, port);
-    return configureSocket(sslSocket);
-  }
-
-  @Override public SSLSocket createSocket(
-      String host, int port, InetAddress localAddress, int localPort) throws IOException {
-    SSLSocket sslSocket = (SSLSocket) delegate.createSocket(host, port, localAddress, localPort);
-    return configureSocket(sslSocket);
-  }
-
-  @Override public SSLSocket createSocket(InetAddress host, int port) throws IOException {
-    SSLSocket sslSocket = (SSLSocket) delegate.createSocket(host, port);
-    return configureSocket(sslSocket);
-  }
-
-  @Override public SSLSocket createSocket(
-      InetAddress host, int port, InetAddress localAddress, int localPort) throws IOException {
-    SSLSocket sslSocket = (SSLSocket) delegate.createSocket(host, port, localAddress, localPort);
-    return configureSocket(sslSocket);
-  }
-
-  @Override public String[] getDefaultCipherSuites() {
-    return delegate.getDefaultCipherSuites();
-  }
-
-  @Override public String[] getSupportedCipherSuites() {
-    return delegate.getSupportedCipherSuites();
-  }
-
-  @Override public SSLSocket createSocket(
-      Socket socket, String host, int port, boolean autoClose) throws IOException {
-    SSLSocket sslSocket = (SSLSocket) delegate.createSocket(socket, host, port, autoClose);
-    return configureSocket(sslSocket);
-  }
-
-  protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
-    // No-op by default.
-    return sslSocket;
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/DelegatingServerSocketFactory.java b/okhttp-tests/src/test/java/okhttp3/DelegatingServerSocketFactory.java
deleted file mode 100644
index 09b3a25d09..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/DelegatingServerSocketFactory.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.ServerSocket;
-import javax.net.ServerSocketFactory;
-
-/**
- * A {@link ServerSocketFactory} that delegates calls. Sockets can be configured after creation by
- * overriding {@link #configureServerSocket(java.net.ServerSocket)}.
- */
-public class DelegatingServerSocketFactory extends ServerSocketFactory {
-
-  private final ServerSocketFactory delegate;
-
-  public DelegatingServerSocketFactory(ServerSocketFactory delegate) {
-    this.delegate = delegate;
-  }
-
-  @Override
-  public ServerSocket createServerSocket() throws IOException {
-    ServerSocket serverSocket = delegate.createServerSocket();
-    return configureServerSocket(serverSocket);
-  }
-
-  @Override
-  public ServerSocket createServerSocket(int port) throws IOException {
-    ServerSocket serverSocket = delegate.createServerSocket(port);
-    return configureServerSocket(serverSocket);
-  }
-
-  @Override
-  public ServerSocket createServerSocket(int port, int backlog) throws IOException {
-    ServerSocket serverSocket = delegate.createServerSocket(port, backlog);
-    return configureServerSocket(serverSocket);
-  }
-
-  @Override
-  public ServerSocket createServerSocket(int port, int backlog, InetAddress ifAddress)
-      throws IOException {
-    ServerSocket serverSocket = delegate.createServerSocket(port, backlog, ifAddress);
-    return configureServerSocket(serverSocket);
-  }
-
-  protected ServerSocket configureServerSocket(ServerSocket serverSocket) throws IOException {
-    // No-op by default.
-    return serverSocket;
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/DelegatingSocketFactory.java b/okhttp-tests/src/test/java/okhttp3/DelegatingSocketFactory.java
deleted file mode 100644
index 33ac2f4e1a..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/DelegatingSocketFactory.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.Socket;
-import javax.net.SocketFactory;
-
-/**
- * A {@link SocketFactory} that delegates calls. Sockets can be configured after creation by
- * overriding {@link #configureSocket(java.net.Socket)}.
- */
-public class DelegatingSocketFactory extends SocketFactory {
-  private final SocketFactory delegate;
-
-  public DelegatingSocketFactory(SocketFactory delegate) {
-    this.delegate = delegate;
-  }
-
-  @Override public Socket createSocket() throws IOException {
-    Socket socket = delegate.createSocket();
-    return configureSocket(socket);
-  }
-
-  @Override public Socket createSocket(String host, int port) throws IOException {
-    Socket socket = delegate.createSocket(host, port);
-    return configureSocket(socket);
-  }
-
-  @Override public Socket createSocket(String host, int port, InetAddress localAddress,
-      int localPort) throws IOException {
-    Socket socket = delegate.createSocket(host, port, localAddress, localPort);
-    return configureSocket(socket);
-  }
-
-  @Override public Socket createSocket(InetAddress host, int port) throws IOException {
-    Socket socket = delegate.createSocket(host, port);
-    return configureSocket(socket);
-  }
-
-  @Override public Socket createSocket(InetAddress host, int port, InetAddress localAddress,
-      int localPort) throws IOException {
-    Socket socket = delegate.createSocket(host, port, localAddress, localPort);
-    return configureSocket(socket);
-  }
-
-  protected Socket configureSocket(Socket socket) throws IOException {
-    // No-op by default.
-    return socket;
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java b/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
deleted file mode 100644
index 8d24fc435b..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
+++ /dev/null
@@ -1,400 +0,0 @@
-package okhttp3;
-
-import java.io.IOException;
-import java.io.InterruptedIOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Iterator;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Set;
-import java.util.concurrent.AbstractExecutorService;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.RejectedExecutionException;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicBoolean;
-import okhttp3.RealCall.AsyncCall;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static java.util.concurrent.TimeUnit.SECONDS;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class DispatcherTest {
-  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
-
-  RecordingExecutor executor = new RecordingExecutor();
-  RecordingCallback callback = new RecordingCallback();
-  RecordingWebSocketListener webSocketListener = new RecordingWebSocketListener();
-  Dispatcher dispatcher = new Dispatcher(executor);
-  RecordingEventListener listener = new RecordingEventListener();
-  OkHttpClient client = clientTestRule.client.newBuilder()
-      .dispatcher(dispatcher)
-      .eventListener(listener)
-      .build();
-
-  @Before public void setUp() throws Exception {
-    dispatcher.setMaxRequests(20);
-    dispatcher.setMaxRequestsPerHost(10);
-    listener.forbidLock(dispatcher);
-  }
-
-  @Test public void maxRequestsZero() throws Exception {
-    try {
-      dispatcher.setMaxRequests(0);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void maxPerHostZero() throws Exception {
-    try {
-      dispatcher.setMaxRequestsPerHost(0);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void enqueuedJobsRunImmediately() throws Exception {
-    client.newCall(newRequest("http://a/1")).enqueue(callback);
-    executor.assertJobs("http://a/1");
-  }
-
-  @Test public void maxRequestsEnforced() throws Exception {
-    dispatcher.setMaxRequests(3);
-    client.newCall(newRequest("http://a/1")).enqueue(callback);
-    client.newCall(newRequest("http://a/2")).enqueue(callback);
-    client.newCall(newRequest("http://b/1")).enqueue(callback);
-    client.newCall(newRequest("http://b/2")).enqueue(callback);
-    executor.assertJobs("http://a/1", "http://a/2", "http://b/1");
-  }
-
-  @Test public void maxPerHostEnforced() throws Exception {
-    dispatcher.setMaxRequestsPerHost(2);
-    client.newCall(newRequest("http://a/1")).enqueue(callback);
-    client.newCall(newRequest("http://a/2")).enqueue(callback);
-    client.newCall(newRequest("http://a/3")).enqueue(callback);
-    executor.assertJobs("http://a/1", "http://a/2");
-  }
-
-  @Test public void maxPerHostNotEnforcedForWebSockets() {
-    dispatcher.setMaxRequestsPerHost(2);
-    client.newWebSocket(newRequest("http://a/1"), webSocketListener);
-    client.newWebSocket(newRequest("http://a/2"), webSocketListener);
-    client.newWebSocket(newRequest("http://a/3"), webSocketListener);
-    executor.assertJobs("http://a/1", "http://a/2", "http://a/3");
-  }
-
-  @Test public void increasingMaxRequestsPromotesJobsImmediately() throws Exception {
-    dispatcher.setMaxRequests(2);
-    client.newCall(newRequest("http://a/1")).enqueue(callback);
-    client.newCall(newRequest("http://b/1")).enqueue(callback);
-    client.newCall(newRequest("http://c/1")).enqueue(callback);
-    client.newCall(newRequest("http://a/2")).enqueue(callback);
-    client.newCall(newRequest("http://b/2")).enqueue(callback);
-    dispatcher.setMaxRequests(4);
-    executor.assertJobs("http://a/1", "http://b/1", "http://c/1", "http://a/2");
-  }
-
-  @Test public void increasingMaxPerHostPromotesJobsImmediately() throws Exception {
-    dispatcher.setMaxRequestsPerHost(2);
-    client.newCall(newRequest("http://a/1")).enqueue(callback);
-    client.newCall(newRequest("http://a/2")).enqueue(callback);
-    client.newCall(newRequest("http://a/3")).enqueue(callback);
-    client.newCall(newRequest("http://a/4")).enqueue(callback);
-    client.newCall(newRequest("http://a/5")).enqueue(callback);
-    dispatcher.setMaxRequestsPerHost(4);
-    executor.assertJobs("http://a/1", "http://a/2", "http://a/3", "http://a/4");
-  }
-
-  @Test public void oldJobFinishesNewJobCanRunDifferentHost() throws Exception {
-    dispatcher.setMaxRequests(1);
-    client.newCall(newRequest("http://a/1")).enqueue(callback);
-    client.newCall(newRequest("http://b/1")).enqueue(callback);
-    executor.finishJob("http://a/1");
-    executor.assertJobs("http://b/1");
-  }
-
-  @Test public void oldJobFinishesNewJobWithSameHostStarts() throws Exception {
-    dispatcher.setMaxRequests(2);
-    dispatcher.setMaxRequestsPerHost(1);
-    client.newCall(newRequest("http://a/1")).enqueue(callback);
-    client.newCall(newRequest("http://b/1")).enqueue(callback);
-    client.newCall(newRequest("http://b/2")).enqueue(callback);
-    client.newCall(newRequest("http://a/2")).enqueue(callback);
-    executor.finishJob("http://a/1");
-    executor.assertJobs("http://b/1", "http://a/2");
-  }
-
-  @Test public void oldJobFinishesNewJobCantRunDueToHostLimit() throws Exception {
-    dispatcher.setMaxRequestsPerHost(1);
-    client.newCall(newRequest("http://a/1")).enqueue(callback);
-    client.newCall(newRequest("http://b/1")).enqueue(callback);
-    client.newCall(newRequest("http://a/2")).enqueue(callback);
-    executor.finishJob("http://b/1");
-    executor.assertJobs("http://a/1");
-  }
-
-  @Test public void enqueuedCallsStillRespectMaxCallsPerHost() throws Exception {
-    dispatcher.setMaxRequests(1);
-    dispatcher.setMaxRequestsPerHost(1);
-    client.newCall(newRequest("http://a/1")).enqueue(callback);
-    client.newCall(newRequest("http://b/1")).enqueue(callback);
-    client.newCall(newRequest("http://b/2")).enqueue(callback);
-    client.newCall(newRequest("http://b/3")).enqueue(callback);
-    dispatcher.setMaxRequests(3);
-    executor.finishJob("http://a/1");
-    executor.assertJobs("http://b/1");
-  }
-
-  @Test public void cancelingRunningJobTakesNoEffectUntilJobFinishes() throws Exception {
-    dispatcher.setMaxRequests(1);
-    Call c1 = client.newCall(newRequest("http://a/1", "tag1"));
-    Call c2 = client.newCall(newRequest("http://a/2"));
-    c1.enqueue(callback);
-    c2.enqueue(callback);
-    c1.cancel();
-    executor.assertJobs("http://a/1");
-    executor.finishJob("http://a/1");
-    executor.assertJobs("http://a/2");
-  }
-
-  @Test public void asyncCallAccessors() throws Exception {
-    dispatcher.setMaxRequests(3);
-    Call a1 = client.newCall(newRequest("http://a/1"));
-    Call a2 = client.newCall(newRequest("http://a/2"));
-    Call a3 = client.newCall(newRequest("http://a/3"));
-    Call a4 = client.newCall(newRequest("http://a/4"));
-    Call a5 = client.newCall(newRequest("http://a/5"));
-    a1.enqueue(callback);
-    a2.enqueue(callback);
-    a3.enqueue(callback);
-    a4.enqueue(callback);
-    a5.enqueue(callback);
-    assertThat(dispatcher.runningCallsCount()).isEqualTo(3);
-    assertThat(dispatcher.queuedCallsCount()).isEqualTo(2);
-    assertThat(set(dispatcher.runningCalls())).isEqualTo(set(a1, a2, a3));
-    assertThat(set(dispatcher.queuedCalls())).isEqualTo(set(a4, a5));
-  }
-
-  @Test public void synchronousCallAccessors() throws Exception {
-    CountDownLatch ready = new CountDownLatch(2);
-    CountDownLatch waiting = new CountDownLatch(1);
-    client = client.newBuilder()
-        .addInterceptor(chain -> {
-          try {
-            ready.countDown();
-            waiting.await();
-          } catch (InterruptedException e) {
-            throw new AssertionError();
-          }
-          throw new IOException();
-        })
-        .build();
-
-    Call a1 = client.newCall(newRequest("http://a/1"));
-    Call a2 = client.newCall(newRequest("http://a/2"));
-    Call a3 = client.newCall(newRequest("http://a/3"));
-    Call a4 = client.newCall(newRequest("http://a/4"));
-    Thread t1 = makeSynchronousCall(a1);
-    Thread t2 = makeSynchronousCall(a2);
-
-    // We created 4 calls and started 2 of them. That's 2 running calls and 0 queued.
-    ready.await();
-    assertThat(dispatcher.runningCallsCount()).isEqualTo(2);
-    assertThat(dispatcher.queuedCallsCount()).isEqualTo(0);
-    assertThat(set(dispatcher.runningCalls())).isEqualTo(set(a1, a2));
-    assertThat(dispatcher.queuedCalls()).isEmpty();
-
-    // Cancel some calls. That doesn't impact running or queued.
-    a2.cancel();
-    a3.cancel();
-    assertThat(set(dispatcher.runningCalls())).isEqualTo(set(a1, a2));
-    assertThat(dispatcher.queuedCalls()).isEmpty();
-
-    // Let the calls finish.
-    waiting.countDown();
-    t1.join();
-    t2.join();
-
-    // Now we should have 0 running calls and 0 queued calls.
-    assertThat(dispatcher.runningCallsCount()).isEqualTo(0);
-    assertThat(dispatcher.queuedCallsCount()).isEqualTo(0);
-    assertThat(dispatcher.runningCalls()).isEmpty();
-    assertThat(dispatcher.queuedCalls()).isEmpty();
-
-    assertThat(a1.isExecuted()).isTrue();
-    assertThat(a1.isCanceled()).isFalse();
-
-    assertThat(a2.isExecuted()).isTrue();
-    assertThat(a2.isCanceled()).isTrue();
-
-    assertThat(a3.isExecuted()).isFalse();
-    assertThat(a3.isCanceled()).isTrue();
-
-    assertThat(a4.isExecuted()).isFalse();
-    assertThat(a4.isCanceled()).isFalse();
-  }
-
-  @Test public void idleCallbackInvokedWhenIdle() throws Exception {
-    AtomicBoolean idle = new AtomicBoolean();
-    dispatcher.setIdleCallback(() -> idle.set(true));
-
-    client.newCall(newRequest("http://a/1")).enqueue(callback);
-    client.newCall(newRequest("http://a/2")).enqueue(callback);
-    executor.finishJob("http://a/1");
-    assertThat(idle.get()).isFalse();
-
-    CountDownLatch ready = new CountDownLatch(1);
-    CountDownLatch proceed = new CountDownLatch(1);
-    client = client.newBuilder()
-        .addInterceptor(chain -> {
-          ready.countDown();
-          try {
-            proceed.await(5, SECONDS);
-          } catch (InterruptedException e) {
-            throw new RuntimeException(e);
-          }
-          return chain.proceed(chain.request());
-        })
-        .build();
-
-    Thread t1 = makeSynchronousCall(client.newCall(newRequest("http://a/3")));
-    ready.await(5, SECONDS);
-    executor.finishJob("http://a/2");
-    assertThat(idle.get()).isFalse();
-
-    proceed.countDown();
-    t1.join();
-    assertThat(idle.get()).isTrue();
-  }
-
-  @Test public void executionRejectedImmediately() throws Exception {
-    Request request = newRequest("http://a/1");
-    executor.shutdown();
-    client.newCall(request).enqueue(callback);
-    callback.await(request.url()).assertFailure(InterruptedIOException.class);
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "CallFailed");
-  }
-
-  @Test public void executionRejectedAfterMaxRequestsChange() throws Exception {
-    Request request1 = newRequest("http://a/1");
-    Request request2 = newRequest("http://a/2");
-    dispatcher.setMaxRequests(1);
-    client.newCall(request1).enqueue(callback);
-    executor.shutdown();
-    client.newCall(request2).enqueue(callback);
-    dispatcher.setMaxRequests(2); // Trigger promotion.
-    callback.await(request2.url()).assertFailure(InterruptedIOException.class);
-
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "CallStart",
-        "CallFailed");
-  }
-
-  @Test public void executionRejectedAfterMaxRequestsPerHostChange() throws Exception {
-    Request request1 = newRequest("http://a/1");
-    Request request2 = newRequest("http://a/2");
-    dispatcher.setMaxRequestsPerHost(1);
-    client.newCall(request1).enqueue(callback);
-    executor.shutdown();
-    client.newCall(request2).enqueue(callback);
-    dispatcher.setMaxRequestsPerHost(2); // Trigger promotion.
-    callback.await(request2.url()).assertFailure(InterruptedIOException.class);
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "CallStart",
-        "CallFailed");
-  }
-
-  @Test public void executionRejectedAfterPrecedingCallFinishes() throws Exception {
-    Request request1 = newRequest("http://a/1");
-    Request request2 = newRequest("http://a/2");
-    dispatcher.setMaxRequests(1);
-    client.newCall(request1).enqueue(callback);
-    executor.shutdown();
-    client.newCall(request2).enqueue(callback);
-    executor.finishJob("http://a/1"); // Trigger promotion.
-    callback.await(request2.url()).assertFailure(InterruptedIOException.class);
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "CallStart",
-        "CallFailed");
-  }
-
-  @SafeVarargs
-  private final <T> Set<T> set(T... values) {
-    return set(Arrays.asList(values));
-  }
-
-  private <T> Set<T> set(List<T> list) {
-    return new LinkedHashSet<>(list);
-  }
-
-  private Thread makeSynchronousCall(Call call) {
-    Thread thread = new Thread(() -> {
-      try {
-        call.execute();
-        throw new AssertionError();
-      } catch (IOException expected) {
-      }
-    });
-    thread.start();
-    return thread;
-  }
-
-  class RecordingExecutor extends AbstractExecutorService {
-    private boolean shutdown;
-    private List<AsyncCall> calls = new ArrayList<>();
-
-    @Override public void execute(Runnable command) {
-      if (shutdown) throw new RejectedExecutionException();
-      calls.add((AsyncCall) command);
-    }
-
-    public void assertJobs(String... expectedUrls) {
-      List<String> actualUrls = new ArrayList<>();
-      for (AsyncCall call : calls) {
-        actualUrls.add(call.request().url().toString());
-      }
-      assertThat(actualUrls).containsExactly(expectedUrls);
-    }
-
-    public void finishJob(String url) {
-      for (Iterator<AsyncCall> i = calls.iterator(); i.hasNext(); ) {
-        AsyncCall call = i.next();
-        if (call.request().url().toString().equals(url)) {
-          i.remove();
-          dispatcher.finished(call);
-          return;
-        }
-      }
-      throw new AssertionError("No such job: " + url);
-    }
-
-    @Override public void shutdown() {
-      shutdown = true;
-    }
-
-    @Override public List<Runnable> shutdownNow() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override public boolean isShutdown() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override public boolean isTerminated() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override public boolean awaitTermination(long timeout, TimeUnit unit) {
-      throw new UnsupportedOperationException();
-    }
-  }
-
-  private Request newRequest(String url) {
-    return new Request.Builder().url(url).build();
-  }
-
-  private Request newRequest(String url, String tag) {
-    return new Request.Builder().url(url).tag(tag).build();
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/DuplexTest.java b/okhttp-tests/src/test/java/okhttp3/DuplexTest.java
deleted file mode 100644
index c67e333b1c..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/DuplexTest.java
+++ /dev/null
@@ -1,510 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.net.HttpURLConnection;
-import java.net.ProtocolException;
-import java.util.Arrays;
-import java.util.List;
-import java.util.concurrent.TimeUnit;
-import okhttp3.internal.RecordingOkAuthenticator;
-import okhttp3.internal.duplex.AsyncRequestBody;
-import okhttp3.internal.duplex.MwsDuplexAccess;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.SocketPolicy;
-import okhttp3.mockwebserver.internal.duplex.MockDuplexResponseBody;
-import okhttp3.tls.HandshakeCertificates;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TestRule;
-import org.junit.rules.Timeout;
-
-import static junit.framework.TestCase.assertTrue;
-import static okhttp3.tls.internal.TlsUtil.localhost;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class DuplexTest {
-  @Rule public final TestRule timeout = new Timeout(30_000, TimeUnit.MILLISECONDS);
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
-
-  private final RecordingEventListener listener = new RecordingEventListener();
-  private HandshakeCertificates handshakeCertificates = localhost();
-  private OkHttpClient client = clientTestRule.client
-      .newBuilder()
-      .eventListener(listener)
-      .build();
-
-  @Test public void http1DoesntSupportDuplex() throws IOException {
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .post(new AsyncRequestBody())
-        .build());
-    try {
-      call.execute();
-      fail();
-    } catch (ProtocolException expected) {
-    }
-  }
-
-  @Test public void trueDuplexClientWritesFirst() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    MockDuplexResponseBody mockDuplexResponseBody = enqueueResponseWithBody(
-        new MockResponse()
-            .clearHeaders(),
-        new MockDuplexResponseBody()
-            .receiveRequest("request A\n")
-            .sendResponse("response B\n")
-            .receiveRequest("request C\n")
-            .sendResponse("response D\n")
-            .receiveRequest("request E\n")
-            .sendResponse("response F\n")
-            .exhaustRequest()
-            .exhaustResponse());
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .post(new AsyncRequestBody())
-        .build());
-
-    try (Response response = call.execute()) {
-      BufferedSink requestBody = ((AsyncRequestBody) call.request().body()).takeSink();
-      requestBody.writeUtf8("request A\n");
-      requestBody.flush();
-
-      BufferedSource responseBody = response.body().source();
-      assertThat(responseBody.readUtf8Line()).isEqualTo("response B");
-
-      requestBody.writeUtf8("request C\n");
-      requestBody.flush();
-      assertThat(responseBody.readUtf8Line()).isEqualTo("response D");
-
-      requestBody.writeUtf8("request E\n");
-      requestBody.flush();
-      assertThat(responseBody.readUtf8Line()).isEqualTo("response F");
-
-      requestBody.close();
-      assertThat(responseBody.readUtf8Line()).isNull();
-    }
-
-    mockDuplexResponseBody.awaitSuccess();
-  }
-
-  @Test public void trueDuplexServerWritesFirst() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    MockDuplexResponseBody mockDuplexResponseBody = enqueueResponseWithBody(
-        new MockResponse()
-            .clearHeaders(),
-        new MockDuplexResponseBody()
-            .sendResponse("response A\n")
-            .receiveRequest("request B\n")
-            .sendResponse("response C\n")
-            .receiveRequest("request D\n")
-            .sendResponse("response E\n")
-            .receiveRequest("request F\n")
-            .exhaustResponse()
-            .exhaustRequest());
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .post(new AsyncRequestBody())
-        .build());
-
-    try (Response response = call.execute()) {
-      BufferedSink requestBody = ((AsyncRequestBody) call.request().body()).takeSink();
-      BufferedSource responseBody = response.body().source();
-
-      assertThat(responseBody.readUtf8Line()).isEqualTo("response A");
-      requestBody.writeUtf8("request B\n");
-      requestBody.flush();
-
-      assertThat(responseBody.readUtf8Line()).isEqualTo("response C");
-      requestBody.writeUtf8("request D\n");
-      requestBody.flush();
-
-      assertThat(responseBody.readUtf8Line()).isEqualTo("response E");
-      requestBody.writeUtf8("request F\n");
-      requestBody.flush();
-
-      assertThat(responseBody.readUtf8Line()).isNull();
-      requestBody.close();
-    }
-
-    mockDuplexResponseBody.awaitSuccess();
-  }
-
-  @Test public void clientReadsHeadersDataTrailers() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    MockDuplexResponseBody mockDuplexResponseBody = enqueueResponseWithBody(
-        new MockResponse()
-            .clearHeaders()
-            .addHeader("h1", "v1")
-            .addHeader("h2", "v2")
-            .setTrailers(Headers.of("trailers", "boom")),
-        new MockDuplexResponseBody()
-            .sendResponse("ok")
-            .exhaustResponse());
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-
-    try (Response response = call.execute()) {
-      assertThat(response.headers()).isEqualTo(Headers.of("h1", "v1", "h2", "v2"));
-
-      BufferedSource responseBody = response.body().source();
-      assertThat(responseBody.readUtf8(2)).isEqualTo("ok");
-      assertTrue(responseBody.exhausted());
-      assertThat(response.trailers()).isEqualTo(Headers.of("trailers", "boom"));
-    }
-
-    mockDuplexResponseBody.awaitSuccess();
-  }
-
-  @Test public void serverReadsHeadersData() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    MockDuplexResponseBody mockDuplexResponseBody = enqueueResponseWithBody(
-        new MockResponse()
-            .clearHeaders()
-            .addHeader("h1", "v1")
-            .addHeader("h2", "v2"),
-        new MockDuplexResponseBody()
-            .exhaustResponse()
-            .receiveRequest("hey\n")
-            .receiveRequest("whats going on\n")
-            .exhaustRequest());
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .method("POST", new AsyncRequestBody())
-        .build();
-    Call call = client.newCall(request);
-
-    try (Response response = call.execute()) {
-      BufferedSink sink = ((AsyncRequestBody) request.body()).takeSink();
-      sink.writeUtf8("hey\n");
-      sink.writeUtf8("whats going on\n");
-      sink.close();
-    }
-
-    mockDuplexResponseBody.awaitSuccess();
-  }
-
-  @Test public void requestBodyEndsAfterResponseBody() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    MockDuplexResponseBody mockDuplexResponseBody = enqueueResponseWithBody(
-        new MockResponse()
-            .clearHeaders(),
-        new MockDuplexResponseBody()
-            .exhaustResponse()
-            .receiveRequest("request A\n")
-            .exhaustRequest());
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .post(new AsyncRequestBody())
-        .build());
-
-    try (Response response = call.execute()) {
-      BufferedSource responseBody = response.body().source();
-      assertTrue(responseBody.exhausted());
-
-      BufferedSink requestBody = ((AsyncRequestBody) call.request().body()).takeSink();
-      requestBody.writeUtf8("request A\n");
-      requestBody.close();
-    }
-
-    mockDuplexResponseBody.awaitSuccess();
-
-    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd", "ConnectStart",
-        "SecureConnectStart", "SecureConnectEnd", "ConnectEnd", "ConnectionAcquired",
-        "RequestHeadersStart", "RequestHeadersEnd", "RequestBodyStart", "ResponseHeadersStart",
-        "ResponseHeadersEnd", "ResponseBodyStart", "ResponseBodyEnd", "RequestBodyEnd",
-        "ConnectionReleased", "CallEnd");
-    assertThat(listener.recordedEventTypes()).isEqualTo(expectedEvents);
-  }
-
-  @Test public void duplexWith100Continue() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-
-    MockDuplexResponseBody mockDuplexResponseBody = enqueueResponseWithBody(
-        new MockResponse()
-            .clearHeaders()
-            .setSocketPolicy(SocketPolicy.EXPECT_CONTINUE),
-        new MockDuplexResponseBody()
-            .receiveRequest("request body\n")
-            .sendResponse("response body\n")
-            .exhaustRequest());
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .header("Expect", "100-continue")
-        .post(new AsyncRequestBody())
-        .build());
-
-    try (Response response = call.execute()) {
-      BufferedSink requestBody = ((AsyncRequestBody) call.request().body()).takeSink();
-      requestBody.writeUtf8("request body\n");
-      requestBody.flush();
-
-      BufferedSource responseBody = response.body().source();
-      assertThat(responseBody.readUtf8Line()).isEqualTo("response body");
-
-      requestBody.close();
-      assertThat(responseBody.readUtf8Line()).isNull();
-    }
-
-    mockDuplexResponseBody.awaitSuccess();
-  }
-
-  /**
-   * Duplex calls that have follow-ups are weird. By the time we know there's a follow-up we've
-   * already split off another thread to stream the request body. Because we permit at most one
-   * exchange at a time we break the request stream out from under that writer.
-   */
-  @Test public void duplexWithRedirect() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-
-    MockDuplexResponseBody mockDuplexResponseBody = enqueueResponseWithBody(
-        new MockResponse()
-            .clearHeaders()
-            .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-            .addHeader("Location: /b"),
-        new MockDuplexResponseBody()
-            .sendResponse("/a has moved!\n")
-            .requestIOException()
-            .exhaustResponse());
-    server.enqueue(new MockResponse()
-        .setBody("this is /b"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .post(new AsyncRequestBody())
-        .build());
-
-    try (Response response = call.execute()) {
-      BufferedSource responseBody = response.body().source();
-      assertThat(responseBody.readUtf8Line()).isEqualTo("this is /b");
-    }
-
-    BufferedSink requestBody = ((AsyncRequestBody) call.request().body()).takeSink();
-    try {
-      requestBody.writeUtf8("request body\n");
-      requestBody.flush();
-      fail();
-    } catch (IOException expected) {
-      assertThat(expected.getMessage()).isEqualTo("stream was reset: CANCEL");
-    }
-
-    mockDuplexResponseBody.awaitSuccess();
-
-    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd", "ConnectStart",
-        "SecureConnectStart", "SecureConnectEnd", "ConnectEnd", "ConnectionAcquired",
-        "RequestHeadersStart", "RequestHeadersEnd", "RequestBodyStart", "ResponseHeadersStart",
-        "ResponseHeadersEnd", "ResponseBodyStart", "ResponseBodyEnd", "RequestHeadersStart",
-        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
-        "ResponseBodyEnd", "ConnectionReleased", "CallEnd", "RequestFailed");
-    assertThat(listener.recordedEventTypes()).isEqualTo(expectedEvents);
-  }
-
-  /**
-   * Auth requires follow-ups. Unlike redirects, the auth follow-up also has a request body. This
-   * test makes a single call with two duplex requests!
-   */
-  @Test public void duplexWithAuthChallenge() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-
-    String credential = Credentials.basic("jesse", "secret");
-    client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential, null))
-        .build();
-
-    MockDuplexResponseBody mockResponseBody1 = enqueueResponseWithBody(
-        new MockResponse()
-            .clearHeaders()
-            .setResponseCode(HttpURLConnection.HTTP_UNAUTHORIZED),
-        new MockDuplexResponseBody()
-            .sendResponse("please authenticate!\n")
-            .requestIOException()
-            .exhaustResponse());
-    MockDuplexResponseBody mockResponseBody2 = enqueueResponseWithBody(
-        new MockResponse()
-            .clearHeaders(),
-        new MockDuplexResponseBody()
-            .sendResponse("response body\n")
-            .exhaustResponse()
-            .receiveRequest("request body\n")
-            .exhaustRequest());
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .post(new AsyncRequestBody())
-        .build());
-
-    Response response2 = call.execute();
-
-    // First duplex request is detached with violence.
-    BufferedSink requestBody1 = ((AsyncRequestBody) call.request().body()).takeSink();
-    try {
-      requestBody1.writeUtf8("not authenticated\n");
-      requestBody1.flush();
-      fail();
-    } catch (IOException expected) {
-      assertThat(expected.getMessage()).isEqualTo("stream was reset: CANCEL");
-    }
-    mockResponseBody1.awaitSuccess();
-
-    // Second duplex request proceeds normally.
-    BufferedSink requestBody2 = ((AsyncRequestBody) call.request().body()).takeSink();
-    requestBody2.writeUtf8("request body\n");
-    requestBody2.close();
-    BufferedSource responseBody2 = response2.body().source();
-    assertThat(responseBody2.readUtf8Line()).isEqualTo("response body");
-    assertTrue(responseBody2.exhausted());
-    mockResponseBody2.awaitSuccess();
-
-    // No more requests attempted!
-    ((AsyncRequestBody) call.request().body()).assertNoMoreSinks();
-  }
-
-  @Test public void fullCallTimeoutAppliesToSetup() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-
-    server.enqueue(new MockResponse()
-        .setHeadersDelay(500, TimeUnit.MILLISECONDS));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .post(new AsyncRequestBody())
-        .build();
-
-    Call call = client.newCall(request);
-    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
-    try {
-      call.execute();
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo("timeout");
-      assertTrue(call.isCanceled());
-    }
-  }
-
-  @Test public void fullCallTimeoutDoesNotApplyOnceConnected() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-
-    MockDuplexResponseBody mockDuplexResponseBody = enqueueResponseWithBody(
-        new MockResponse()
-            .clearHeaders(),
-        new MockDuplexResponseBody()
-            .sendResponse("response A\n")
-            .sleep(750, TimeUnit.MILLISECONDS)
-            .sendResponse("response B\n")
-            .receiveRequest("request C\n")
-            .exhaustResponse()
-            .exhaustRequest());
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .post(new AsyncRequestBody())
-        .build();
-
-    Call call = client.newCall(request);
-    call.timeout().timeout(500, TimeUnit.MILLISECONDS); // Long enough for the first TLS handshake.
-
-    try (Response response = call.execute()) {
-      BufferedSink requestBody = ((AsyncRequestBody) call.request().body()).takeSink();
-
-      BufferedSource responseBody = response.body().source();
-      assertThat(responseBody.readUtf8Line()).isEqualTo("response A");
-      assertThat(responseBody.readUtf8Line()).isEqualTo("response B");
-
-      requestBody.writeUtf8("request C\n");
-      requestBody.close();
-      assertThat(responseBody.readUtf8Line()).isNull();
-    }
-
-    mockDuplexResponseBody.awaitSuccess();
-  }
-
-  @Test public void duplexWithRewriteInterceptors() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    MockDuplexResponseBody mockDuplexResponseBody = enqueueResponseWithBody(
-        new MockResponse()
-            .clearHeaders(),
-        new MockDuplexResponseBody()
-            .receiveRequest("REQUEST A\n")
-            .sendResponse("response B\n")
-            .exhaustRequest()
-            .exhaustResponse());
-
-    client = client.newBuilder()
-        .addInterceptor(new UppercaseRequestInterceptor())
-        .addInterceptor(new UppercaseResponseInterceptor())
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .post(new AsyncRequestBody())
-        .build());
-
-    try (Response response = call.execute()) {
-      BufferedSink requestBody = ((AsyncRequestBody) call.request().body()).takeSink();
-      requestBody.writeUtf8("request A\n");
-      requestBody.flush();
-
-      BufferedSource responseBody = response.body().source();
-      assertThat(responseBody.readUtf8Line()).isEqualTo("RESPONSE B");
-
-      requestBody.close();
-      assertThat(responseBody.readUtf8Line()).isNull();
-    }
-
-    mockDuplexResponseBody.awaitSuccess();
-  }
-
-  private MockDuplexResponseBody enqueueResponseWithBody(
-      MockResponse response, MockDuplexResponseBody body) {
-    MwsDuplexAccess.instance.setBody(response, body);
-    server.enqueue(response);
-    return body;
-  }
-
-  /**
-   * Tests that use this will fail unless boot classpath is set. Ex. {@code
-   * -Xbootclasspath/p:/tmp/alpn-boot-8.0.0.v20140317}
-   */
-  private void enableProtocol(Protocol protocol) {
-    enableTls();
-    client = client.newBuilder()
-        .protocols(Arrays.asList(protocol, Protocol.HTTP_1_1))
-        .build();
-    server.setProtocols(client.protocols());
-  }
-
-  private void enableTls() {
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java b/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
deleted file mode 100644
index 8f614badb7..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
+++ /dev/null
@@ -1,1255 +0,0 @@
-/*
- * Copyright (C) 2017 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.net.HttpURLConnection;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import java.net.UnknownHostException;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import javax.annotation.Nullable;
-import okhttp3.RecordingEventListener.CallEnd;
-import okhttp3.RecordingEventListener.CallFailed;
-import okhttp3.RecordingEventListener.ConnectEnd;
-import okhttp3.RecordingEventListener.ConnectFailed;
-import okhttp3.RecordingEventListener.ConnectStart;
-import okhttp3.RecordingEventListener.ConnectionAcquired;
-import okhttp3.RecordingEventListener.DnsEnd;
-import okhttp3.RecordingEventListener.DnsStart;
-import okhttp3.RecordingEventListener.RequestBodyEnd;
-import okhttp3.RecordingEventListener.RequestHeadersEnd;
-import okhttp3.RecordingEventListener.ResponseBodyEnd;
-import okhttp3.RecordingEventListener.ResponseFailed;
-import okhttp3.RecordingEventListener.ResponseHeadersEnd;
-import okhttp3.RecordingEventListener.SecureConnectEnd;
-import okhttp3.RecordingEventListener.SecureConnectStart;
-import okhttp3.internal.DoubleInetAddressDns;
-import okhttp3.internal.Internal;
-import okhttp3.internal.RecordingOkAuthenticator;
-import okhttp3.logging.HttpLoggingInterceptor;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.SocketPolicy;
-import okhttp3.tls.HandshakeCertificates;
-import okio.Buffer;
-import okio.BufferedSink;
-import org.assertj.core.api.Assertions;
-import org.hamcrest.BaseMatcher;
-import org.hamcrest.CoreMatchers;
-import org.hamcrest.Description;
-import org.hamcrest.Matcher;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static java.util.Arrays.asList;
-import static okhttp3.tls.internal.TlsUtil.localhost;
-import static org.hamcrest.CoreMatchers.any;
-import static org.hamcrest.CoreMatchers.either;
-import static org.hamcrest.CoreMatchers.equalTo;
-import static org.junit.Assert.assertThat;
-import static org.junit.Assert.fail;
-import static org.junit.Assume.assumeThat;
-
-public final class EventListenerTest {
-  public static final Matcher<Response> anyResponse = CoreMatchers.any(Response.class);
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
-
-  private final RecordingEventListener listener = new RecordingEventListener();
-  private final HandshakeCertificates handshakeCertificates = localhost();
-
-  private OkHttpClient client = clientTestRule.client;
-  private SocksProxy socksProxy;
-
-  @Before public void setUp() {
-    client = clientTestRule.client.newBuilder()
-        .eventListener(listener)
-        .build();
-
-    listener.forbidLock(Internal.instance.realConnectionPool(client.connectionPool()));
-    listener.forbidLock(client.dispatcher());
-  }
-
-  @After public void tearDown() throws Exception {
-    if (socksProxy != null) {
-      socksProxy.shutdown();
-    }
-  }
-
-  @Test public void successfulCallEventSequence() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    Assertions.assertThat(response.code()).isEqualTo(200);
-    Assertions.assertThat(response.body().string()).isEqualTo("abc");
-    response.body().close();
-
-    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
-        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
-        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
-        "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
-    Assertions.assertThat(listener.recordedEventTypes()).isEqualTo(expectedEvents);
-  }
-
-  @Test public void successfulCallEventSequenceForEnqueue() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-
-    final CountDownLatch completionLatch = new CountDownLatch(1);
-    Callback callback = new Callback() {
-      @Override public void onFailure(Call call, IOException e) {
-        completionLatch.countDown();
-      }
-
-      @Override public void onResponse(Call call, Response response) {
-        response.close();
-        completionLatch.countDown();
-      }
-    };
-
-    call.enqueue(callback);
-
-    completionLatch.await();
-
-    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
-        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
-        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
-        "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
-    Assertions.assertThat(listener.recordedEventTypes()).isEqualTo(expectedEvents);
-  }
-
-  @Test public void failedCallEventSequence() {
-    server.enqueue(new MockResponse().setHeadersDelay(2, TimeUnit.SECONDS));
-
-    client = client.newBuilder().readTimeout(250, TimeUnit.MILLISECONDS).build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-      assertThat(expected.getMessage(), either(equalTo("timeout")).or(equalTo("Read timed out")));
-    }
-
-    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
-        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
-        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseFailed", "ConnectionReleased",
-        "CallFailed");
-    Assertions.assertThat(listener.recordedEventTypes()).isEqualTo(expectedEvents);
-  }
-
-  @Test public void failedDribbledCallEventSequence() throws IOException {
-    server.enqueue(new MockResponse().setBody("0123456789")
-        .throttleBody(2, 100, TimeUnit.MILLISECONDS)
-        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY));
-
-    client = client.newBuilder()
-        .protocols(Collections.singletonList(Protocol.HTTP_1_1))
-        .readTimeout(250, TimeUnit.MILLISECONDS)
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-
-    Response response = call.execute();
-    try {
-      response.body.string();
-      fail();
-    } catch (IOException expected) {
-      assertThat(expected.getMessage(), equalTo("unexpected end of stream"));
-    }
-
-    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
-        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
-        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
-        "ResponseFailed", "ConnectionReleased", "CallFailed");
-    Assertions.assertThat(listener.recordedEventTypes()).isEqualTo(expectedEvents);
-    ResponseFailed responseFailed = listener.removeUpToEvent(ResponseFailed.class);
-    Assertions.assertThat(responseFailed.ioe.getMessage()).isEqualTo(
-        "unexpected end of stream");
-  }
-
-  @Test public void canceledCallEventSequence() {
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    call.cancel();
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-      Assertions.assertThat(expected.getMessage()).isEqualTo("Canceled");
-    }
-
-    List<String> expectedEvents = Arrays.asList("CallStart", "CallFailed");
-    Assertions.assertThat(listener.recordedEventTypes()).isEqualTo(expectedEvents);
-  }
-
-  private void assertSuccessfulEventOrder(Matcher<Response> responseMatcher) throws IOException {
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    Assertions.assertThat(response.code()).isEqualTo(200);
-    response.body().string();
-    response.body().close();
-
-    assumeThat(response, responseMatcher);
-
-    List<String> expectedEvents = asList("CallStart", "DnsStart", "DnsEnd", "ConnectStart",
-        "SecureConnectStart", "SecureConnectEnd", "ConnectEnd", "ConnectionAcquired",
-        "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd",
-        "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
-
-    Assertions.assertThat(listener.recordedEventTypes()).isEqualTo(expectedEvents);
-  }
-
-  @Test public void secondCallEventSequence() throws IOException {
-    enableTlsWithTunnel(false);
-    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
-    server.enqueue(new MockResponse());
-    server.enqueue(new MockResponse());
-
-    client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build()).execute().close();
-
-    listener.removeUpToEvent(CallEnd.class);
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    response.close();
-
-    List<String> expectedEvents = asList("CallStart", "ConnectionAcquired",
-        "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd",
-        "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
-
-    Assertions.assertThat(listener.recordedEventTypes()).isEqualTo(expectedEvents);
-  }
-
-  private void assertBytesReadWritten(RecordingEventListener listener,
-      @Nullable Matcher<Long> requestHeaderLength, @Nullable Matcher<Long> requestBodyBytes,
-      @Nullable Matcher<Long> responseHeaderLength, @Nullable Matcher<Long> responseBodyBytes) {
-
-    if (requestHeaderLength != null) {
-      RequestHeadersEnd responseHeadersEnd = listener.removeUpToEvent(RequestHeadersEnd.class);
-      assertThat("request header length", responseHeadersEnd.headerLength, requestHeaderLength);
-    } else {
-      Assertions.assertThat(listener.recordedEventTypes().contains("RequestHeadersEnd")).overridingErrorMessage(
-          "Found RequestHeadersEnd").isFalse();
-    }
-
-    if (requestBodyBytes != null) {
-      RequestBodyEnd responseBodyEnd = listener.removeUpToEvent(RequestBodyEnd.class);
-      assertThat("request body bytes", responseBodyEnd.bytesWritten, requestBodyBytes);
-    } else {
-      Assertions.assertThat(listener.recordedEventTypes().contains("RequestBodyEnd")).overridingErrorMessage(
-          "Found RequestBodyEnd").isFalse();
-    }
-
-    if (responseHeaderLength != null) {
-      ResponseHeadersEnd responseHeadersEnd = listener.removeUpToEvent(ResponseHeadersEnd.class);
-      assertThat("response header length", responseHeadersEnd.headerLength, responseHeaderLength);
-    } else {
-      Assertions.assertThat(listener.recordedEventTypes().contains("ResponseHeadersEnd")).overridingErrorMessage(
-          "Found ResponseHeadersEnd").isFalse();
-    }
-
-    if (responseBodyBytes != null) {
-      ResponseBodyEnd responseBodyEnd = listener.removeUpToEvent(ResponseBodyEnd.class);
-      assertThat("response body bytes", responseBodyEnd.bytesRead, responseBodyBytes);
-    } else {
-      Assertions.assertThat(listener.recordedEventTypes().contains("ResponseBodyEnd")).overridingErrorMessage(
-          "Found ResponseBodyEnd").isFalse();
-    }
-  }
-
-  private Matcher<Long> greaterThan(final long value) {
-    return new BaseMatcher<Long>() {
-      @Override public void describeTo(Description description) {
-        description.appendText("> " + value);
-      }
-
-      @Override public boolean matches(Object o) {
-        return ((Long)o) > value;
-      }
-    };
-  }
-
-  private Matcher<Long> lessThan(final long value) {
-    return new BaseMatcher<Long>() {
-      @Override public void describeTo(Description description) {
-        description.appendText("< " + value);
-      }
-
-      @Override public boolean matches(Object o) {
-        return ((Long)o) < value;
-      }
-    };
-  }
-
-  private Matcher<Response> matchesProtocol(final Protocol protocol) {
-    return new BaseMatcher<Response>() {
-      @Override public void describeTo(Description description) {
-        description.appendText("is HTTP/2");
-      }
-
-      @Override public boolean matches(Object o) {
-        return ((Response)o).protocol == protocol;
-      }
-    };
-  }
-
-  @Test public void successfulEmptyH2CallEventSequence() throws IOException {
-    enableTlsWithTunnel(false);
-    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
-    server.enqueue(new MockResponse());
-
-    assertSuccessfulEventOrder(matchesProtocol(Protocol.HTTP_2));
-
-    assertBytesReadWritten(listener, any(Long.class), null, greaterThan(0L),
-        equalTo(0L));
-  }
-
-  @Test public void successfulEmptyHttpsCallEventSequence() throws IOException {
-    enableTlsWithTunnel(false);
-    server.setProtocols(Arrays.asList(Protocol.HTTP_1_1));
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    assertSuccessfulEventOrder(anyResponse);
-
-    assertBytesReadWritten(listener, any(Long.class), null, greaterThan(0L),
-        equalTo(3L));
-  }
-
-  @Test public void successfulChunkedHttpsCallEventSequence() throws IOException {
-    enableTlsWithTunnel(false);
-    server.setProtocols(Arrays.asList(Protocol.HTTP_1_1));
-    server.enqueue(
-        new MockResponse().setBodyDelay(100, TimeUnit.MILLISECONDS).setChunkedBody("Hello!", 2));
-
-    assertSuccessfulEventOrder(anyResponse);
-
-    assertBytesReadWritten(listener, any(Long.class), null, greaterThan(0L),
-        equalTo(6L));
-  }
-
-  @Test public void successfulChunkedH2CallEventSequence() throws IOException {
-    enableTlsWithTunnel(false);
-    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
-    server.enqueue(
-        new MockResponse().setBodyDelay(100, TimeUnit.MILLISECONDS).setChunkedBody("Hello!", 2));
-
-    assertSuccessfulEventOrder(matchesProtocol(Protocol.HTTP_2));
-
-    assertBytesReadWritten(listener, any(Long.class), null, equalTo(0L),
-        greaterThan(6L));
-  }
-
-  @Test public void successfulDnsLookup() throws IOException {
-    server.enqueue(new MockResponse());
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    Assertions.assertThat(response.code()).isEqualTo(200);
-    response.body().close();
-
-    DnsStart dnsStart = listener.removeUpToEvent(DnsStart.class);
-    Assertions.assertThat(dnsStart.call).isSameAs(call);
-    Assertions.assertThat(dnsStart.domainName).isEqualTo(server.getHostName());
-
-    DnsEnd dnsEnd = listener.removeUpToEvent(DnsEnd.class);
-    Assertions.assertThat(dnsEnd.call).isSameAs(call);
-    Assertions.assertThat(dnsEnd.domainName).isEqualTo(server.getHostName());
-    Assertions.assertThat(dnsEnd.inetAddressList.size()).isEqualTo(1);
-  }
-
-  @Test public void noDnsLookupOnPooledConnection() throws IOException {
-    server.enqueue(new MockResponse());
-    server.enqueue(new MockResponse());
-
-    // Seed the pool.
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response1 = call1.execute();
-    Assertions.assertThat(response1.code()).isEqualTo(200);
-    response1.body().close();
-
-    listener.clearAllEvents();
-
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response2 = call2.execute();
-    Assertions.assertThat(response2.code()).isEqualTo(200);
-    response2.body().close();
-
-    List<String> recordedEvents = listener.recordedEventTypes();
-    Assertions.assertThat(recordedEvents.contains("DnsStart")).isFalse();
-    Assertions.assertThat(recordedEvents.contains("DnsEnd")).isFalse();
-  }
-
-  @Test public void multipleDnsLookupsForSingleCall() throws IOException {
-    server.enqueue(new MockResponse()
-        .setResponseCode(301)
-        .setHeader("Location", "http://www.fakeurl:" + server.getPort()));
-    server.enqueue(new MockResponse());
-
-    FakeDns dns = new FakeDns();
-    dns.set("fakeurl", client.dns().lookup(server.getHostName()));
-    dns.set("www.fakeurl", client.dns().lookup(server.getHostName()));
-
-    client = client.newBuilder()
-        .dns(dns)
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url("http://fakeurl:" + server.getPort())
-        .build());
-    Response response = call.execute();
-    Assertions.assertThat(response.code()).isEqualTo(200);
-    response.body().close();
-
-    listener.removeUpToEvent(DnsStart.class);
-    listener.removeUpToEvent(DnsEnd.class);
-    listener.removeUpToEvent(DnsStart.class);
-    listener.removeUpToEvent(DnsEnd.class);
-  }
-
-  @Test public void failedDnsLookup() {
-    client = client.newBuilder()
-        .dns(new FakeDns())
-        .build();
-    Call call = client.newCall(new Request.Builder()
-        .url("http://fakeurl/")
-        .build());
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-    }
-
-    listener.removeUpToEvent(DnsStart.class);
-
-    CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
-    Assertions.assertThat(callFailed.call).isSameAs(call);
-    boolean condition = callFailed.ioe instanceof UnknownHostException;
-    Assertions.assertThat(condition).isTrue();
-  }
-
-  @Test public void emptyDnsLookup() {
-    Dns emptyDns = hostname -> Collections.emptyList();
-
-    client = client.newBuilder()
-        .dns(emptyDns)
-        .build();
-    Call call = client.newCall(new Request.Builder()
-        .url("http://fakeurl/")
-        .build());
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-    }
-
-    listener.removeUpToEvent(DnsStart.class);
-
-    CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
-    Assertions.assertThat(callFailed.call).isSameAs(call);
-    boolean condition = callFailed.ioe instanceof UnknownHostException;
-    Assertions.assertThat(condition).isTrue();
-  }
-
-  @Test public void successfulConnect() throws IOException {
-    server.enqueue(new MockResponse());
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    Assertions.assertThat(response.code()).isEqualTo(200);
-    response.body().close();
-
-    InetAddress address = client.dns().lookup(server.getHostName()).get(0);
-    InetSocketAddress expectedAddress = new InetSocketAddress(address, server.getPort());
-
-    ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
-    Assertions.assertThat(connectStart.call).isSameAs(call);
-    Assertions.assertThat(connectStart.inetSocketAddress).isEqualTo(expectedAddress);
-    Assertions.assertThat(connectStart.proxy).isEqualTo(Proxy.NO_PROXY);
-
-    ConnectEnd connectEnd = listener.removeUpToEvent(ConnectEnd.class);
-    Assertions.assertThat(connectEnd.call).isSameAs(call);
-    Assertions.assertThat(connectEnd.inetSocketAddress).isEqualTo(expectedAddress);
-    Assertions.assertThat(connectEnd.protocol).isEqualTo(Protocol.HTTP_1_1);
-  }
-
-  @Test public void failedConnect() throws UnknownHostException {
-    enableTlsWithTunnel(false);
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-    }
-
-    InetAddress address = client.dns().lookup(server.getHostName()).get(0);
-    InetSocketAddress expectedAddress = new InetSocketAddress(address, server.getPort());
-
-    ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
-    Assertions.assertThat(connectStart.call).isSameAs(call);
-    Assertions.assertThat(connectStart.inetSocketAddress).isEqualTo(expectedAddress);
-    Assertions.assertThat(connectStart.proxy).isEqualTo(Proxy.NO_PROXY);
-
-    ConnectFailed connectFailed = listener.removeUpToEvent(ConnectFailed.class);
-    Assertions.assertThat(connectFailed.call).isSameAs(call);
-    Assertions.assertThat(connectFailed.inetSocketAddress).isEqualTo(expectedAddress);
-    Assertions.assertThat(connectFailed.protocol).isNull();
-    Assertions.assertThat(connectFailed.ioe).isNotNull();
-  }
-
-  @Test public void multipleConnectsForSingleCall() throws IOException {
-    enableTlsWithTunnel(false);
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
-    server.enqueue(new MockResponse());
-
-    client = client.newBuilder()
-        .dns(new DoubleInetAddressDns())
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    Assertions.assertThat(response.code()).isEqualTo(200);
-    response.body().close();
-
-    listener.removeUpToEvent(ConnectStart.class);
-    listener.removeUpToEvent(ConnectFailed.class);
-    listener.removeUpToEvent(ConnectStart.class);
-    listener.removeUpToEvent(ConnectEnd.class);
-  }
-
-  @Test public void successfulHttpProxyConnect() throws IOException {
-    server.enqueue(new MockResponse());
-
-    client = client.newBuilder()
-        .proxy(server.toProxyAddress())
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url("http://www.fakeurl")
-        .build());
-    Response response = call.execute();
-    Assertions.assertThat(response.code()).isEqualTo(200);
-    response.body().close();
-
-    InetAddress address = client.dns().lookup(server.getHostName()).get(0);
-    InetSocketAddress expectedAddress = new InetSocketAddress(address, server.getPort());
-
-    ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
-    Assertions.assertThat(connectStart.call).isSameAs(call);
-    Assertions.assertThat(connectStart.inetSocketAddress).isEqualTo(expectedAddress);
-    Assertions.assertThat(connectStart.proxy).isEqualTo(server.toProxyAddress());
-
-    ConnectEnd connectEnd = listener.removeUpToEvent(ConnectEnd.class);
-    Assertions.assertThat(connectEnd.call).isSameAs(call);
-    Assertions.assertThat(connectEnd.inetSocketAddress).isEqualTo(expectedAddress);
-    Assertions.assertThat(connectEnd.protocol).isEqualTo(Protocol.HTTP_1_1);
-  }
-
-  @Test public void successfulSocksProxyConnect() throws Exception {
-    server.enqueue(new MockResponse());
-
-    socksProxy = new SocksProxy();
-    socksProxy.play();
-    Proxy proxy = socksProxy.proxy();
-
-    client = client.newBuilder()
-        .proxy(proxy)
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url("http://" + SocksProxy.HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS + ":" + server.getPort())
-        .build());
-    Response response = call.execute();
-    Assertions.assertThat(response.code()).isEqualTo(200);
-    response.body().close();
-
-    InetSocketAddress expectedAddress = InetSocketAddress.createUnresolved(
-        SocksProxy.HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS, server.getPort());
-
-    ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
-    Assertions.assertThat(connectStart.call).isSameAs(call);
-    Assertions.assertThat(connectStart.inetSocketAddress).isEqualTo(expectedAddress);
-    Assertions.assertThat(connectStart.proxy).isEqualTo(proxy);
-
-    ConnectEnd connectEnd = listener.removeUpToEvent(ConnectEnd.class);
-    Assertions.assertThat(connectEnd.call).isSameAs(call);
-    Assertions.assertThat(connectEnd.inetSocketAddress).isEqualTo(expectedAddress);
-    Assertions.assertThat(connectEnd.protocol).isEqualTo(Protocol.HTTP_1_1);
-  }
-
-  @Test public void authenticatingTunnelProxyConnect() throws IOException {
-    enableTlsWithTunnel(true);
-    server.enqueue(new MockResponse()
-        .setResponseCode(407)
-        .addHeader("Proxy-Authenticate: Basic realm=\"localhost\"")
-        .addHeader("Connection: close"));
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END));
-    server.enqueue(new MockResponse());
-
-    client = client.newBuilder()
-        .proxy(server.toProxyAddress())
-        .proxyAuthenticator(new RecordingOkAuthenticator("password", "Basic"))
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    Assertions.assertThat(response.code()).isEqualTo(200);
-    response.body().close();
-
-    listener.removeUpToEvent(ConnectStart.class);
-
-    ConnectEnd connectEnd = listener.removeUpToEvent(ConnectEnd.class);
-    Assertions.assertThat(connectEnd.protocol).isNull();
-
-    listener.removeUpToEvent(ConnectStart.class);
-    listener.removeUpToEvent(ConnectEnd.class);
-  }
-
-  @Test public void successfulSecureConnect() throws IOException {
-    enableTlsWithTunnel(false);
-    server.enqueue(new MockResponse());
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    Assertions.assertThat(response.code()).isEqualTo(200);
-    response.body().close();
-
-    SecureConnectStart secureStart = listener.removeUpToEvent(SecureConnectStart.class);
-    Assertions.assertThat(secureStart.call).isSameAs(call);
-
-    SecureConnectEnd secureEnd = listener.removeUpToEvent(SecureConnectEnd.class);
-    Assertions.assertThat(secureEnd.call).isSameAs(call);
-    Assertions.assertThat(secureEnd.handshake).isNotNull();
-  }
-
-  @Test public void failedSecureConnect() {
-    enableTlsWithTunnel(false);
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-    }
-
-    SecureConnectStart secureStart = listener.removeUpToEvent(SecureConnectStart.class);
-    Assertions.assertThat(secureStart.call).isSameAs(call);
-
-    CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
-    Assertions.assertThat(callFailed.call).isSameAs(call);
-    Assertions.assertThat(callFailed.ioe).isNotNull();
-  }
-
-  @Test public void secureConnectWithTunnel() throws IOException {
-    enableTlsWithTunnel(true);
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END));
-    server.enqueue(new MockResponse());
-
-    client = client.newBuilder()
-        .proxy(server.toProxyAddress())
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    Assertions.assertThat(response.code()).isEqualTo(200);
-    response.body().close();
-
-    SecureConnectStart secureStart = listener.removeUpToEvent(SecureConnectStart.class);
-    Assertions.assertThat(secureStart.call).isSameAs(call);
-
-    SecureConnectEnd secureEnd = listener.removeUpToEvent(SecureConnectEnd.class);
-    Assertions.assertThat(secureEnd.call).isSameAs(call);
-    Assertions.assertThat(secureEnd.handshake).isNotNull();
-  }
-
-  @Test public void multipleSecureConnectsForSingleCall() throws IOException {
-    enableTlsWithTunnel(false);
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
-    server.enqueue(new MockResponse());
-
-    client = client.newBuilder()
-        .dns(new DoubleInetAddressDns())
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    Assertions.assertThat(response.code()).isEqualTo(200);
-    response.body().close();
-
-    listener.removeUpToEvent(SecureConnectStart.class);
-    listener.removeUpToEvent(ConnectFailed.class);
-
-    listener.removeUpToEvent(SecureConnectStart.class);
-    listener.removeUpToEvent(SecureConnectEnd.class);
-  }
-
-  @Test public void noSecureConnectsOnPooledConnection() throws IOException {
-    enableTlsWithTunnel(false);
-    server.enqueue(new MockResponse());
-    server.enqueue(new MockResponse());
-
-    client = client.newBuilder()
-        .dns(new DoubleInetAddressDns())
-        .build();
-
-    // Seed the pool.
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response1 = call1.execute();
-    Assertions.assertThat(response1.code()).isEqualTo(200);
-    response1.body().close();
-
-    listener.clearAllEvents();
-
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response2 = call2.execute();
-    Assertions.assertThat(response2.code()).isEqualTo(200);
-    response2.body().close();
-
-    List<String> recordedEvents = listener.recordedEventTypes();
-    Assertions.assertThat(recordedEvents.contains("SecureConnectStart")).isFalse();
-    Assertions.assertThat(recordedEvents.contains("SecureConnectEnd")).isFalse();
-  }
-
-  @Test public void successfulConnectionFound() throws IOException {
-    server.enqueue(new MockResponse());
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    Assertions.assertThat(response.code()).isEqualTo(200);
-    response.body().close();
-
-    ConnectionAcquired connectionAcquired = listener.removeUpToEvent(ConnectionAcquired.class);
-    Assertions.assertThat(connectionAcquired.call).isSameAs(call);
-    Assertions.assertThat(connectionAcquired.connection).isNotNull();
-  }
-
-  @Test public void noConnectionFoundOnFollowUp() throws IOException {
-    server.enqueue(new MockResponse()
-        .setResponseCode(301)
-        .addHeader("Location", "/foo"));
-    server.enqueue(new MockResponse()
-        .setBody("ABC"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    Assertions.assertThat(response.body().string()).isEqualTo("ABC");
-
-    listener.removeUpToEvent(ConnectionAcquired.class);
-
-    List<String> remainingEvents = listener.recordedEventTypes();
-    Assertions.assertThat(remainingEvents.contains("ConnectionAcquired")).isFalse();
-  }
-
-  @Test public void pooledConnectionFound() throws IOException {
-    server.enqueue(new MockResponse());
-    server.enqueue(new MockResponse());
-
-    // Seed the pool.
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response1 = call1.execute();
-    Assertions.assertThat(response1.code()).isEqualTo(200);
-    response1.body().close();
-
-    ConnectionAcquired connectionAcquired1 = listener.removeUpToEvent(ConnectionAcquired.class);
-    listener.clearAllEvents();
-
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response2 = call2.execute();
-    Assertions.assertThat(response2.code()).isEqualTo(200);
-    response2.body().close();
-
-    ConnectionAcquired connectionAcquired2 = listener.removeUpToEvent(ConnectionAcquired.class);
-    Assertions.assertThat(connectionAcquired2.connection).isSameAs(
-        connectionAcquired1.connection);
-  }
-
-  @Test public void multipleConnectionsFoundForSingleCall() throws IOException {
-    server.enqueue(new MockResponse()
-        .setResponseCode(301)
-        .addHeader("Location", "/foo")
-        .addHeader("Connection", "Close"));
-    server.enqueue(new MockResponse()
-        .setBody("ABC"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    Assertions.assertThat(response.body().string()).isEqualTo("ABC");
-
-    listener.removeUpToEvent(ConnectionAcquired.class);
-    listener.removeUpToEvent(ConnectionAcquired.class);
-  }
-
-  @Test public void responseBodyFailHttp1OverHttps() throws IOException {
-    enableTlsWithTunnel(false);
-    server.setProtocols(Arrays.asList(Protocol.HTTP_1_1));
-    responseBodyFail(Protocol.HTTP_1_1);
-  }
-
-  @Test public void responseBodyFailHttp2OverHttps() throws IOException {
-    enableTlsWithTunnel(false);
-    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
-    responseBodyFail(Protocol.HTTP_2);
-  }
-
-  @Test public void responseBodyFailHttp() throws IOException {
-    responseBodyFail(Protocol.HTTP_1_1);
-  }
-
-  private void responseBodyFail(Protocol expectedProtocol) throws IOException {
-    // Use a 2 MiB body so the disconnect won't happen until the client has read some data.
-    int responseBodySize = 2 * 1024 * 1024; // 2 MiB
-    server.enqueue(new MockResponse()
-        .setBody(new Buffer().write(new byte[responseBodySize]))
-        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    if (expectedProtocol == Protocol.HTTP_2) {
-      // soft failure since client may not support depending on Platform
-      assumeThat(response, matchesProtocol(Protocol.HTTP_2));
-    }
-    Assertions.assertThat(response.protocol()).isEqualTo(expectedProtocol);
-    try {
-      response.body.string();
-      fail();
-    } catch (IOException expected) {
-    }
-
-    CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
-    Assertions.assertThat(callFailed.ioe).isNotNull();
-  }
-
-  @Test public void emptyResponseBody() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("")
-        .setBodyDelay(1, TimeUnit.SECONDS)
-        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    response.body().close();
-
-    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
-        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
-        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
-        "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
-    Assertions.assertThat(listener.recordedEventTypes()).isEqualTo(expectedEvents);
-  }
-
-  @Test public void emptyResponseBodyConnectionClose() throws IOException {
-    server.enqueue(new MockResponse()
-        .addHeader("Connection", "close")
-        .setBody(""));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    response.body().close();
-
-    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
-        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
-        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
-        "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
-    Assertions.assertThat(listener.recordedEventTypes()).isEqualTo(expectedEvents);
-  }
-
-  @Test public void responseBodyClosedClosedWithoutReadingAllData() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .setBodyDelay(1, TimeUnit.SECONDS)
-        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    response.body().close();
-
-    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
-        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
-        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
-        "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
-    Assertions.assertThat(listener.recordedEventTypes()).isEqualTo(expectedEvents);
-  }
-
-  @Test public void requestBodyFailHttp1OverHttps() throws IOException {
-    enableTlsWithTunnel(false);
-    server.setProtocols(Arrays.asList(Protocol.HTTP_1_1));
-    requestBodyFail();
-  }
-
-  @Test public void requestBodyFailHttp2OverHttps() throws IOException {
-    enableTlsWithTunnel(false);
-    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
-    requestBodyFail();
-  }
-
-  @Test public void requestBodyFailHttp() throws IOException {
-    requestBodyFail();
-  }
-
-  private void requestBodyFail() {
-    // Stream a 8 MiB body so the disconnect will happen before the server has read everything.
-    RequestBody requestBody = new RequestBody() {
-      @Override public MediaType contentType() {
-        return MediaType.get("text/plain");
-      }
-
-      @Override public long contentLength() {
-        return 1024 * 1024 * 256;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        for (int i = 0; i < 1024; i++) {
-          sink.write(new byte[1024 * 256]);
-          sink.flush();
-        }
-      }
-    };
-
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_REQUEST_BODY));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .post(requestBody)
-        .build());
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-    }
-
-    CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
-    Assertions.assertThat(callFailed.ioe).isNotNull();
-  }
-
-  @Test public void requestBodyMultipleFailuresReportedOnlyOnce() {
-    RequestBody requestBody = new RequestBody() {
-      @Override public MediaType contentType() {
-        return MediaType.get("text/plain");
-      }
-
-      @Override public long contentLength() {
-        return 1024 * 1024 * 256;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        int failureCount = 0;
-        for (int i = 0; i < 1024; i++) {
-          try {
-            sink.write(new byte[1024 * 256]);
-            sink.flush();
-          } catch (IOException e) {
-            failureCount++;
-            if (failureCount == 3) throw e;
-          }
-        }
-      }
-    };
-
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_REQUEST_BODY));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .post(requestBody)
-        .build());
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-    }
-
-    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd", "ConnectStart",
-        "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart", "RequestHeadersEnd",
-        "RequestBodyStart", "RequestFailed", "ConnectionReleased", "CallFailed");
-    Assertions.assertThat(listener.recordedEventTypes()).isEqualTo(expectedEvents);
-  }
-
-  @Test public void requestBodySuccessHttp1OverHttps() throws IOException {
-    enableTlsWithTunnel(false);
-    server.setProtocols(Arrays.asList(Protocol.HTTP_1_1));
-    requestBodySuccess(RequestBody.create(MediaType.get("text/plain"), "Hello"), equalTo(5L),
-        equalTo(19L));
-  }
-
-  @Test public void requestBodySuccessHttp2OverHttps() throws IOException {
-    enableTlsWithTunnel(false);
-    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
-    requestBodySuccess(RequestBody.create(MediaType.get("text/plain"), "Hello"), equalTo(5L),
-        equalTo(19L));
-  }
-
-  @Test public void requestBodySuccessHttp() throws IOException {
-    requestBodySuccess(RequestBody.create(MediaType.get("text/plain"), "Hello"), equalTo(5L),
-        equalTo(19L));
-  }
-
-  @Test public void requestBodySuccessStreaming() throws IOException {
-    RequestBody requestBody = new RequestBody() {
-      @Override public MediaType contentType() {
-        return MediaType.get("text/plain");
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        sink.write(new byte[8192]);
-        sink.flush();
-      }
-    };
-
-    requestBodySuccess(requestBody, equalTo(8192L), equalTo(19L));
-  }
-
-  @Test public void requestBodySuccessEmpty() throws IOException {
-    requestBodySuccess(RequestBody.create(MediaType.get("text/plain"), ""), equalTo(0L),
-        equalTo(19L));
-  }
-
-  @Test public void successfulCallEventSequenceWithListener() throws IOException {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    client = client.newBuilder()
-        .addNetworkInterceptor(new HttpLoggingInterceptor()
-            .setLevel(HttpLoggingInterceptor.Level.BODY))
-        .build();
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    Assertions.assertThat(response.code()).isEqualTo(200);
-    Assertions.assertThat(response.body().string()).isEqualTo("abc");
-    response.body().close();
-
-    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
-        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
-        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
-        "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
-    Assertions.assertThat(listener.recordedEventTypes()).isEqualTo(expectedEvents);
-  }
-
-  private void requestBodySuccess(RequestBody body, Matcher<Long> requestBodyBytes,
-      Matcher<Long> responseHeaderLength) throws IOException {
-    server.enqueue(new MockResponse().setResponseCode(200).setBody("World!"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .post(body)
-        .build());
-    Response response = call.execute();
-    Assertions.assertThat(response.body().string()).isEqualTo("World!");
-
-    assertBytesReadWritten(listener, any(Long.class), requestBodyBytes, responseHeaderLength,
-        equalTo(6L));
-  }
-
-  private void enableTlsWithTunnel(boolean tunnelProxy) {
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-    server.useHttps(handshakeCertificates.sslSocketFactory(), tunnelProxy);
-  }
-
-  @Test public void redirectUsingSameConnectionEventSequence() throws IOException {
-    server.enqueue(
-        new MockResponse()
-            .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-            .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse());
-
-    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
-    call.execute();
-
-    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
-        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
-        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
-        "ResponseBodyEnd", "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart",
-        "ResponseHeadersEnd", "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased",
-        "CallEnd");
-    Assertions.assertThat(listener.recordedEventTypes()).isEqualTo(expectedEvents);
-  }
-
-  @Test
-  public void redirectUsingNewConnectionEventSequence() throws IOException {
-    MockWebServer otherServer = new MockWebServer();
-    server.enqueue(
-        new MockResponse()
-            .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-            .addHeader("Location: " + otherServer.url("/foo")));
-    otherServer.enqueue(new MockResponse());
-
-    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
-    Response response = call.execute();
-
-    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
-        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
-        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
-        "ResponseBodyEnd", "ConnectionReleased", "DnsStart", "DnsEnd", "ConnectStart", "ConnectEnd",
-        "ConnectionAcquired", "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart",
-        "ResponseHeadersEnd", "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased",
-        "CallEnd");
-    Assertions.assertThat(listener.recordedEventTypes()).isEqualTo(expectedEvents);
-  }
-
-  @Test public void applicationInterceptorProceedsMultipleTimes() throws Exception {
-    server.enqueue(new MockResponse().setBody("a"));
-    server.enqueue(new MockResponse().setBody("b"));
-
-    client = client.newBuilder()
-        .addInterceptor(chain -> {
-          try (Response a = chain.proceed(chain.request())) {
-            Assertions.assertThat(a.body().string()).isEqualTo("a");
-          }
-          return chain.proceed(chain.request());
-        })
-        .build();
-
-    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
-    Response response = call.execute();
-    Assertions.assertThat(response.body().string()).isEqualTo("b");
-
-    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
-        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
-        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
-        "ResponseBodyEnd", "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart",
-        "ResponseHeadersEnd", "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased",
-        "CallEnd");
-    Assertions.assertThat(listener.recordedEventTypes()).isEqualTo(expectedEvents);
-
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void applicationInterceptorShortCircuit() throws Exception {
-    client = client.newBuilder()
-        .addInterceptor(chain -> new Response.Builder()
-            .request(chain.request())
-            .protocol(Protocol.HTTP_1_1)
-            .code(200)
-            .message("OK")
-            .body(ResponseBody.create(null, "a"))
-            .build())
-        .build();
-
-    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
-    Response response = call.execute();
-    Assertions.assertThat(response.body().string()).isEqualTo("a");
-
-    List<String> expectedEvents = Arrays.asList("CallStart", "CallEnd");
-    Assertions.assertThat(listener.recordedEventTypes()).isEqualTo(expectedEvents);
-  }
-
-  /** Response headers start, then the entire request body, then response headers end. */
-  @Test public void expectContinueStartsResponseHeadersEarly() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.EXPECT_CONTINUE));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
-        .build();
-
-    Call call = client.newCall(request);
-    call.execute();
-
-    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd", "ConnectStart",
-        "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart", "RequestHeadersEnd",
-        "ResponseHeadersStart", "RequestBodyStart", "RequestBodyEnd", "ResponseHeadersEnd",
-        "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
-    Assertions.assertThat(listener.recordedEventTypes()).isEqualTo(expectedEvents);
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/FallbackTestClientSocketFactory.java b/okhttp-tests/src/test/java/okhttp3/FallbackTestClientSocketFactory.java
deleted file mode 100644
index d829566e20..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/FallbackTestClientSocketFactory.java
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright 2014 Square Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-
-/**
- * An SSLSocketFactory that delegates calls. Sockets created by the delegate are wrapped with ones
- * that will not accept the {@link #TLS_FALLBACK_SCSV} cipher, thus bypassing server-side fallback
- * checks on platforms that support it. Unfortunately this wrapping will disable any
- * reflection-based calls to SSLSocket from Platform.
- */
-public class FallbackTestClientSocketFactory extends DelegatingSSLSocketFactory {
-  /**
-   * The cipher suite used during TLS connection fallback to indicate a fallback. See
-   * https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00
-   */
-  public static final String TLS_FALLBACK_SCSV = "TLS_FALLBACK_SCSV";
-
-  public FallbackTestClientSocketFactory(SSLSocketFactory delegate) {
-    super(delegate);
-  }
-
-  @Override protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
-    return new TlsFallbackScsvDisabledSSLSocket(sslSocket);
-  }
-
-  private static class TlsFallbackScsvDisabledSSLSocket extends DelegatingSSLSocket {
-
-    public TlsFallbackScsvDisabledSSLSocket(SSLSocket socket) {
-      super(socket);
-    }
-
-    @Override public void setEnabledCipherSuites(String[] suites) {
-      List<String> enabledCipherSuites = new ArrayList<>(suites.length);
-      for (String suite : suites) {
-        if (!suite.equals(TLS_FALLBACK_SCSV)) {
-          enabledCipherSuites.add(suite);
-        }
-      }
-      delegate.setEnabledCipherSuites(
-          enabledCipherSuites.toArray(new String[enabledCipherSuites.size()]));
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/FormBodyTest.java b/okhttp-tests/src/test/java/okhttp3/FormBodyTest.java
deleted file mode 100644
index e352298f0e..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/FormBodyTest.java
+++ /dev/null
@@ -1,218 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import okio.Buffer;
-import org.junit.Test;
-import java.nio.charset.Charset;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public final class FormBodyTest {
-  @Test public void urlEncoding() throws Exception {
-    FormBody body = new FormBody.Builder()
-        .add("a+=& b", "c+=& d")
-        .add("space, the", "final frontier")
-        .add("%25", "%25")
-        .build();
-
-    assertThat(body.size()).isEqualTo(3);
-
-    assertThat(body.encodedName(0)).isEqualTo("a%2B%3D%26%20b");
-    assertThat(body.encodedName(1)).isEqualTo("space%2C%20the");
-    assertThat(body.encodedName(2)).isEqualTo("%2525");
-
-    assertThat(body.name(0)).isEqualTo("a+=& b");
-    assertThat(body.name(1)).isEqualTo("space, the");
-    assertThat(body.name(2)).isEqualTo("%25");
-
-    assertThat(body.encodedValue(0)).isEqualTo("c%2B%3D%26%20d");
-    assertThat(body.encodedValue(1)).isEqualTo("final%20frontier");
-    assertThat(body.encodedValue(2)).isEqualTo("%2525");
-
-    assertThat(body.value(0)).isEqualTo("c+=& d");
-    assertThat(body.value(1)).isEqualTo("final frontier");
-    assertThat(body.value(2)).isEqualTo("%25");
-
-    assertThat(body.contentType().toString()).isEqualTo(
-        "application/x-www-form-urlencoded");
-
-    String expected = "a%2B%3D%26%20b=c%2B%3D%26%20d&space%2C%20the=final%20frontier&%2525=%2525";
-    assertThat(body.contentLength()).isEqualTo(expected.length());
-
-    Buffer out = new Buffer();
-    body.writeTo(out);
-    assertThat(out.readUtf8()).isEqualTo(expected);
-  }
-
-  @Test public void addEncoded() throws Exception {
-    FormBody body = new FormBody.Builder()
-        .addEncoded("a+=& b", "c+=& d")
-        .addEncoded("e+=& f", "g+=& h")
-        .addEncoded("%25", "%25")
-        .build();
-
-    String expected = "a+%3D%26%20b=c+%3D%26%20d&e+%3D%26%20f=g+%3D%26%20h&%25=%25";
-    Buffer out = new Buffer();
-    body.writeTo(out);
-    assertThat(out.readUtf8()).isEqualTo(expected);
-  }
-
-  @Test public void encodedPair() throws Exception {
-    FormBody body = new FormBody.Builder()
-        .add("sim", "ple")
-        .build();
-
-    String expected = "sim=ple";
-    assertThat(body.contentLength()).isEqualTo(expected.length());
-
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    assertThat(buffer.readUtf8()).isEqualTo(expected);
-  }
-
-  @Test public void encodeMultiplePairs() throws Exception {
-    FormBody body = new FormBody.Builder()
-        .add("sim", "ple")
-        .add("hey", "there")
-        .add("help", "me")
-        .build();
-
-    String expected = "sim=ple&hey=there&help=me";
-    assertThat(body.contentLength()).isEqualTo(expected.length());
-
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    assertThat(buffer.readUtf8()).isEqualTo(expected);
-  }
-
-  @Test public void buildEmptyForm() throws Exception {
-    FormBody body = new FormBody.Builder().build();
-
-    String expected = "";
-    assertThat(body.contentLength()).isEqualTo(expected.length());
-
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    assertThat(buffer.readUtf8()).isEqualTo(expected);
-  }
-
-  @Test public void characterEncoding() throws Exception {
-    // Browsers convert '\u0000' to '%EF%BF%BD'.
-    assertThat(formEncode(0)).isEqualTo("%00");
-    assertThat(formEncode(1)).isEqualTo("%01");
-    assertThat(formEncode(2)).isEqualTo("%02");
-    assertThat(formEncode(3)).isEqualTo("%03");
-    assertThat(formEncode(4)).isEqualTo("%04");
-    assertThat(formEncode(5)).isEqualTo("%05");
-    assertThat(formEncode(6)).isEqualTo("%06");
-    assertThat(formEncode(7)).isEqualTo("%07");
-    assertThat(formEncode(8)).isEqualTo("%08");
-    assertThat(formEncode(9)).isEqualTo("%09");
-    // Browsers convert '\n' to '\r\n'
-    assertThat(formEncode(10)).isEqualTo("%0A");
-    assertThat(formEncode(11)).isEqualTo("%0B");
-    assertThat(formEncode(12)).isEqualTo("%0C");
-    // Browsers convert '\r' to '\r\n'
-    assertThat(formEncode(13)).isEqualTo("%0D");
-    assertThat(formEncode(14)).isEqualTo("%0E");
-    assertThat(formEncode(15)).isEqualTo("%0F");
-    assertThat(formEncode(16)).isEqualTo("%10");
-    assertThat(formEncode(17)).isEqualTo("%11");
-    assertThat(formEncode(18)).isEqualTo("%12");
-    assertThat(formEncode(19)).isEqualTo("%13");
-    assertThat(formEncode(20)).isEqualTo("%14");
-    assertThat(formEncode(21)).isEqualTo("%15");
-    assertThat(formEncode(22)).isEqualTo("%16");
-    assertThat(formEncode(23)).isEqualTo("%17");
-    assertThat(formEncode(24)).isEqualTo("%18");
-    assertThat(formEncode(25)).isEqualTo("%19");
-    assertThat(formEncode(26)).isEqualTo("%1A");
-    assertThat(formEncode(27)).isEqualTo("%1B");
-    assertThat(formEncode(28)).isEqualTo("%1C");
-    assertThat(formEncode(29)).isEqualTo("%1D");
-    assertThat(formEncode(30)).isEqualTo("%1E");
-    assertThat(formEncode(31)).isEqualTo("%1F");
-    // Browsers use '+' for space.
-    assertThat(formEncode(32)).isEqualTo("%20");
-    assertThat(formEncode(33)).isEqualTo("%21");
-    assertThat(formEncode(34)).isEqualTo("%22");
-    assertThat(formEncode(35)).isEqualTo("%23");
-    assertThat(formEncode(36)).isEqualTo("%24");
-    assertThat(formEncode(37)).isEqualTo("%25");
-    assertThat(formEncode(38)).isEqualTo("%26");
-    assertThat(formEncode(39)).isEqualTo("%27");
-    assertThat(formEncode(40)).isEqualTo("%28");
-    assertThat(formEncode(41)).isEqualTo("%29");
-    assertThat(formEncode(42)).isEqualTo("*");
-    assertThat(formEncode(43)).isEqualTo("%2B");
-    assertThat(formEncode(44)).isEqualTo("%2C");
-    assertThat(formEncode(45)).isEqualTo("-");
-    assertThat(formEncode(46)).isEqualTo(".");
-    assertThat(formEncode(47)).isEqualTo("%2F");
-    assertThat(formEncode(48)).isEqualTo("0");
-    assertThat(formEncode(57)).isEqualTo("9");
-    assertThat(formEncode(58)).isEqualTo("%3A");
-    assertThat(formEncode(59)).isEqualTo("%3B");
-    assertThat(formEncode(60)).isEqualTo("%3C");
-    assertThat(formEncode(61)).isEqualTo("%3D");
-    assertThat(formEncode(62)).isEqualTo("%3E");
-    assertThat(formEncode(63)).isEqualTo("%3F");
-    assertThat(formEncode(64)).isEqualTo("%40");
-    assertThat(formEncode(65)).isEqualTo("A");
-    assertThat(formEncode(90)).isEqualTo("Z");
-    assertThat(formEncode(91)).isEqualTo("%5B");
-    assertThat(formEncode(92)).isEqualTo("%5C");
-    assertThat(formEncode(93)).isEqualTo("%5D");
-    assertThat(formEncode(94)).isEqualTo("%5E");
-    assertThat(formEncode(95)).isEqualTo("_");
-    assertThat(formEncode(96)).isEqualTo("%60");
-    assertThat(formEncode(97)).isEqualTo("a");
-    assertThat(formEncode(122)).isEqualTo("z");
-    assertThat(formEncode(123)).isEqualTo("%7B");
-    assertThat(formEncode(124)).isEqualTo("%7C");
-    assertThat(formEncode(125)).isEqualTo("%7D");
-    assertThat(formEncode(126)).isEqualTo("%7E");
-    assertThat(formEncode(127)).isEqualTo("%7F");
-    assertThat(formEncode(128)).isEqualTo("%C2%80");
-    assertThat(formEncode(255)).isEqualTo("%C3%BF");
-  }
-
-  private String formEncode(int codePoint) throws IOException {
-    // Wrap the codepoint with regular printable characters to prevent trimming.
-    FormBody body = new FormBody.Builder()
-        .add("a", new String(new int[] {'b', codePoint, 'c'}, 0, 3))
-        .build();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    buffer.skip(3); // Skip "a=b" prefix.
-    return buffer.readUtf8(buffer.size() - 1); // Skip the "c" suffix.
-  }
-
-  @Test public void manualCharset() throws Exception {
-    FormBody body = new FormBody.Builder(Charset.forName("ISO-8859-1"))
-        .add("name", "Nicol√°s")
-        .build();
-
-    String expected = "name=Nicol%E1s";
-    assertThat(body.contentLength()).isEqualTo(expected.length());
-
-    Buffer out = new Buffer();
-    body.writeTo(out);
-    assertThat(out.readUtf8()).isEqualTo(expected);
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/HeadersTest.java b/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
deleted file mode 100644
index ef1e5ed347..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
+++ /dev/null
@@ -1,905 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.time.Instant;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Date;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import okhttp3.internal.Internal;
-import okhttp3.internal.Util;
-import okhttp3.internal.http.HttpHeaders;
-import okhttp3.internal.http2.Header;
-import okhttp3.internal.http2.Http2ExchangeCodec;
-import org.junit.Ignore;
-import org.junit.Test;
-
-import static java.util.Collections.emptyList;
-import static java.util.Collections.emptyMap;
-import static java.util.Collections.singletonList;
-import static java.util.Collections.singletonMap;
-import static okhttp3.TestUtil.headerEntries;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class HeadersTest {
-  static {
-    Internal.initializeInstanceForTests();
-  }
-
-  @Test public void readNameValueBlockDropsForbiddenHeadersHttp2() throws IOException {
-    Headers headerBlock = Headers.of(
-        ":status", "200 OK",
-        ":version", "HTTP/1.1",
-        "connection", "close");
-    Request request = new Request.Builder().url("http://square.com/").build();
-    Response response = Http2ExchangeCodec.readHttp2HeadersList(headerBlock, Protocol.HTTP_2).request(request).build();
-    Headers headers = response.headers();
-    assertThat(headers.size()).isEqualTo(1);
-    assertThat(headers.name(0)).isEqualTo(":version");
-    assertThat(headers.value(0)).isEqualTo("HTTP/1.1");
-  }
-
-  @Test public void http2HeadersListDropsForbiddenHeadersHttp2() {
-    Request request = new Request.Builder()
-        .url("http://square.com/")
-        .header("Connection", "upgrade")
-        .header("Upgrade", "websocket")
-        .header("Host", "square.com")
-        .header("TE", "gzip")
-        .build();
-    List<Header> expected = headerEntries(
-        ":method", "GET",
-        ":path", "/",
-        ":authority", "square.com",
-        ":scheme", "http");
-    assertThat(Http2ExchangeCodec.http2HeadersList(request)).isEqualTo(expected);
-  }
-
-  @Test public void http2HeadersListDontDropTeIfTrailersHttp2() {
-    Request request = new Request.Builder()
-        .url("http://square.com/")
-        .header("TE", "trailers")
-        .build();
-    List<Header> expected = headerEntries(
-        ":method", "GET",
-        ":path", "/",
-        ":scheme", "http",
-        "te", "trailers");
-    assertThat(Http2ExchangeCodec.http2HeadersList(request)).isEqualTo(expected);
-  }
-
-  @Test public void ofTrims() {
-    Headers headers = Headers.of("\t User-Agent \n", " \r OkHttp ");
-    assertThat(headers.name(0)).isEqualTo("User-Agent");
-    assertThat(headers.value(0)).isEqualTo("OkHttp");
-  }
-
-  @Test public void addParsing() {
-    Headers headers = new Headers.Builder()
-        .add("foo: bar")
-        .add(" foo: baz") // Name leading whitespace is trimmed.
-        .add("foo : bak") // Name trailing whitespace is trimmed.
-        .add("\tkey\t:\tvalue\t") // '\t' also counts as whitespace
-        .add("ping:  pong  ") // Value whitespace is trimmed.
-        .add("kit:kat") // Space after colon is not required.
-        .build();
-    assertThat(headers.values("foo")).isEqualTo(Arrays.asList("bar", "baz", "bak"));
-    assertThat(headers.values("key")).isEqualTo(Arrays.asList("value"));
-    assertThat(headers.values("ping")).isEqualTo(Arrays.asList("pong"));
-    assertThat(headers.values("kit")).isEqualTo(Arrays.asList("kat"));
-  }
-
-  @Test public void addThrowsOnEmptyName() {
-    try {
-      new Headers.Builder().add(": bar");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      new Headers.Builder().add(" : bar");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void addThrowsOnNoColon() {
-    try {
-      new Headers.Builder().add("foo bar");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void addThrowsOnMultiColon() {
-    try {
-      new Headers.Builder().add(":status: 200 OK");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void addUnsafeNonAsciiRejectsUnicodeName() {
-    try {
-      Headers headers = new Headers.Builder()
-          .addUnsafeNonAscii("h√©ader1", "value1")
-          .build();
-      fail("Should have complained about invalid value");
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          "Unexpected char 0xe9 at 1 in header name: h√©ader1");
-    }
-  }
-
-  @Test public void addUnsafeNonAsciiAcceptsUnicodeValue() {
-    Headers headers = new Headers.Builder()
-        .addUnsafeNonAscii("header1", "valu√©1")
-        .build();
-    assertThat(headers.toString()).isEqualTo("header1: valu√©1\n");
-  }
-
-  @Test public void ofThrowsOddNumberOfHeaders() {
-    try {
-      Headers.of("User-Agent", "OkHttp", "Content-Length");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void ofThrowsOnNull() {
-    try {
-      Headers.of("User-Agent", null);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void ofThrowsOnEmptyName() {
-    try {
-      Headers.of("", "OkHttp");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void ofAcceptsEmptyValue() {
-    Headers headers = Headers.of("User-Agent", "");
-    assertThat(headers.value(0)).isEqualTo("");
-  }
-
-  @Test public void ofMakesDefensiveCopy() {
-    String[] namesAndValues = {
-        "User-Agent",
-        "OkHttp"
-    };
-    Headers headers = Headers.of(namesAndValues);
-    namesAndValues[1] = "Chrome";
-    assertThat(headers.value(0)).isEqualTo("OkHttp");
-  }
-
-  @Test public void ofRejectsNullChar() {
-    try {
-      Headers.of("User-Agent", "Square\u0000OkHttp");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void ofMapThrowsOnNull() {
-    try {
-      Headers.of(Collections.singletonMap("User-Agent", null));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void ofMapThrowsOnEmptyName() {
-    try {
-      Headers.of(singletonMap("", "OkHttp"));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void ofMapThrowsOnBlankName() {
-    try {
-      Headers.of(singletonMap(" ", "OkHttp"));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void ofMapAcceptsEmptyValue() {
-    Headers headers = Headers.of(singletonMap("User-Agent", ""));
-    assertThat(headers.value(0)).isEqualTo("");
-  }
-
-  @Test public void ofMapTrimsKey() {
-    Headers headers = Headers.of(singletonMap(" User-Agent ", "OkHttp"));
-    assertThat(headers.name(0)).isEqualTo("User-Agent");
-  }
-
-  @Test public void ofMapTrimsValue() {
-    Headers headers = Headers.of(singletonMap("User-Agent", " OkHttp "));
-    assertThat(headers.value(0)).isEqualTo("OkHttp");
-  }
-
-  @Test public void ofMapMakesDefensiveCopy() {
-    Map<String, String> namesAndValues = new LinkedHashMap<>();
-    namesAndValues.put("User-Agent", "OkHttp");
-
-    Headers headers = Headers.of(namesAndValues);
-    namesAndValues.put("User-Agent", "Chrome");
-    assertThat(headers.value(0)).isEqualTo("OkHttp");
-  }
-
-  @Test public void ofMapRejectsNullCharInName() {
-    try {
-      Headers.of(singletonMap("User-\u0000Agent", "OkHttp"));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void ofMapRejectsNullCharInValue() {
-    try {
-      Headers.of(singletonMap("User-Agent", "Square\u0000OkHttp"));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void toMultimapGroupsHeaders() {
-    Headers headers = Headers.of(
-        "cache-control", "no-cache",
-        "cache-control", "no-store",
-        "user-agent", "OkHttp");
-    Map<String, List<String>> headerMap = headers.toMultimap();
-    assertThat(headerMap.get("cache-control").size()).isEqualTo(2);
-    assertThat(headerMap.get("user-agent").size()).isEqualTo(1);
-  }
-
-  @Test public void toMultimapUsesCanonicalCase() {
-    Headers headers = Headers.of(
-        "cache-control", "no-store",
-        "Cache-Control", "no-cache",
-        "User-Agent", "OkHttp");
-    Map<String, List<String>> headerMap = headers.toMultimap();
-    assertThat(headerMap.get("cache-control").size()).isEqualTo(2);
-    assertThat(headerMap.get("user-agent").size()).isEqualTo(1);
-  }
-
-  @Test public void toMultimapAllowsCaseInsensitiveGet() {
-    Headers headers = Headers.of(
-        "cache-control", "no-store",
-        "Cache-Control", "no-cache");
-    Map<String, List<String>> headerMap = headers.toMultimap();
-    assertThat(headerMap.get("cache-control").size()).isEqualTo(2);
-    assertThat(headerMap.get("Cache-Control").size()).isEqualTo(2);
-  }
-
-  @Test public void nameIndexesAreStrict() {
-    Headers headers = Headers.of("a", "b", "c", "d");
-    try {
-      headers.name(-1);
-      fail();
-    } catch (IndexOutOfBoundsException expected) {
-    }
-    assertThat(headers.name(0)).isEqualTo("a");
-    assertThat(headers.name(1)).isEqualTo("c");
-    try {
-      headers.name(2);
-      fail();
-    } catch (IndexOutOfBoundsException expected) {
-    }
-  }
-
-  @Test public void valueIndexesAreStrict() {
-    Headers headers = Headers.of("a", "b", "c", "d");
-    try {
-      headers.value(-1);
-      fail();
-    } catch (IndexOutOfBoundsException expected) {
-    }
-    assertThat(headers.value(0)).isEqualTo("b");
-    assertThat(headers.value(1)).isEqualTo("d");
-    try {
-      headers.value(2);
-      fail();
-    } catch (IndexOutOfBoundsException expected) {
-    }
-  }
-
-  @Test public void builderRejectsUnicodeInHeaderName() {
-    try {
-      new Headers.Builder().add("h√©ader1", "value1");
-      fail("Should have complained about invalid name");
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          "Unexpected char 0xe9 at 1 in header name: h√©ader1");
-    }
-  }
-
-  @Test public void builderRejectsUnicodeInHeaderValue() {
-    try {
-      new Headers.Builder().add("header1", "valu√©1");
-      fail("Should have complained about invalid value");
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          "Unexpected char 0xe9 at 4 in header1 value: valu√©1");
-    }
-  }
-
-  @Test public void varargFactoryRejectsUnicodeInHeaderName() {
-    try {
-      Headers.of("h√©ader1", "value1");
-      fail("Should have complained about invalid value");
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          "Unexpected char 0xe9 at 1 in header name: h√©ader1");
-    }
-  }
-
-  @Test public void varargFactoryRejectsUnicodeInHeaderValue() {
-    try {
-      Headers.of("header1", "valu√©1");
-      fail("Should have complained about invalid value");
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          "Unexpected char 0xe9 at 4 in header1 value: valu√©1");
-    }
-  }
-
-  @Test public void mapFactoryRejectsUnicodeInHeaderName() {
-    try {
-      Headers.of(singletonMap("h√©ader1", "value1"));
-      fail("Should have complained about invalid value");
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          "Unexpected char 0xe9 at 1 in header name: h√©ader1");
-    }
-  }
-
-  @Test public void mapFactoryRejectsUnicodeInHeaderValue() {
-    try {
-      Headers.of(singletonMap("header1", "valu√©1"));
-      fail("Should have complained about invalid value");
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          "Unexpected char 0xe9 at 4 in header1 value: valu√©1");
-    }
-  }
-
-  @Test public void headersEquals() {
-    Headers headers1 = new Headers.Builder()
-        .add("Connection", "close")
-        .add("Transfer-Encoding", "chunked")
-        .build();
-    Headers headers2 = new Headers.Builder()
-        .add("Connection", "close")
-        .add("Transfer-Encoding", "chunked")
-        .build();
-    assertThat(headers2).isEqualTo(headers1);
-    assertThat(headers2.hashCode()).isEqualTo(headers1.hashCode());
-  }
-
-  @Test public void headersNotEquals() {
-    Headers headers1 = new Headers.Builder()
-        .add("Connection", "close")
-        .add("Transfer-Encoding", "chunked")
-        .build();
-    Headers headers2 = new Headers.Builder()
-        .add("Connection", "keep-alive")
-        .add("Transfer-Encoding", "chunked")
-        .build();
-    assertThat(headers2).isNotEqualTo(headers1);
-    assertThat(headers2.hashCode()).isNotEqualTo((long) headers1.hashCode());
-  }
-
-  @Test public void headersToString() {
-    Headers headers = new Headers.Builder()
-        .add("A", "a")
-        .add("B", "bb")
-        .build();
-    assertThat(headers.toString()).isEqualTo("A: a\nB: bb\n");
-  }
-
-  @Test public void headersAddAll() {
-    Headers sourceHeaders = new Headers.Builder()
-        .add("A", "aa")
-        .add("a", "aa")
-        .add("B", "bb")
-        .build();
-    Headers headers = new Headers.Builder()
-        .add("A", "a")
-        .addAll(sourceHeaders)
-        .add("C", "c")
-        .build();
-    assertThat(headers.toString()).isEqualTo("A: a\nA: aa\na: aa\nB: bb\nC: c\n");
-  }
-
-  /** See https://github.com/square/okhttp/issues/2780. */
-  @Test public void testDigestChallengeWithStrictRfc2617Header() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest realm=\"myrealm\", nonce=\"fjalskdflwejrlaskdfjlaskdjflaks"
-            + "jdflkasdf\", qop=\"auth\", stale=\"FALSE\"")
-        .build();
-    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertThat(challenges.size()).isEqualTo(1);
-    assertThat(challenges.get(0).scheme()).isEqualTo("Digest");
-    assertThat(challenges.get(0).realm()).isEqualTo("myrealm");
-    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
-    expectedAuthParams.put("realm", "myrealm");
-    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
-    expectedAuthParams.put("qop", "auth");
-    expectedAuthParams.put("stale", "FALSE");
-    assertThat(challenges.get(0).authParams()).isEqualTo(expectedAuthParams);
-  }
-
-  @Test public void testDigestChallengeWithDifferentlyOrderedAuthParams() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest qop=\"auth\", realm=\"myrealm\", nonce=\"fjalskdflwejrlask"
-            + "dfjlaskdjflaksjdflkasdf\", stale=\"FALSE\"")
-        .build();
-    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertThat(challenges.size()).isEqualTo(1);
-    assertThat(challenges.get(0).scheme()).isEqualTo("Digest");
-    assertThat(challenges.get(0).realm()).isEqualTo("myrealm");
-    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
-    expectedAuthParams.put("realm", "myrealm");
-    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
-    expectedAuthParams.put("qop", "auth");
-    expectedAuthParams.put("stale", "FALSE");
-    assertThat(challenges.get(0).authParams()).isEqualTo(expectedAuthParams);
-  }
-
-  @Test public void testDigestChallengeWithDifferentlyOrderedAuthParams2() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest qop=\"auth\", nonce=\"fjalskdflwejrlaskdfjlaskdjflaksjdflk"
-            + "asdf\", realm=\"myrealm\", stale=\"FALSE\"")
-        .build();
-    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertThat(challenges.size()).isEqualTo(1);
-    assertThat(challenges.get(0).scheme()).isEqualTo("Digest");
-    assertThat(challenges.get(0).realm()).isEqualTo("myrealm");
-    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
-    expectedAuthParams.put("realm", "myrealm");
-    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
-    expectedAuthParams.put("qop", "auth");
-    expectedAuthParams.put("stale", "FALSE");
-    assertThat(challenges.get(0).authParams()).isEqualTo(expectedAuthParams);
-  }
-
-  @Test public void testDigestChallengeWithMissingRealm() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest qop=\"auth\", underrealm=\"myrealm\", nonce=\"fjalskdflwej"
-            + "rlaskdfjlaskdjflaksjdflkasdf\", stale=\"FALSE\"")
-        .build();
-    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertThat(challenges.size()).isEqualTo(1);
-    assertThat(challenges.get(0).scheme()).isEqualTo("Digest");
-    assertThat(challenges.get(0).realm()).isNull();
-    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
-    expectedAuthParams.put("underrealm", "myrealm");
-    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
-    expectedAuthParams.put("qop", "auth");
-    expectedAuthParams.put("stale", "FALSE");
-    assertThat(challenges.get(0).authParams()).isEqualTo(expectedAuthParams);
-  }
-
-  @Test public void testDigestChallengeWithAdditionalSpaces() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest qop=\"auth\",    realm=\"myrealm\", nonce=\"fjalskdflwejrl"
-            + "askdfjlaskdjflaksjdflkasdf\", stale=\"FALSE\"")
-        .build();
-    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertThat(challenges.size()).isEqualTo(1);
-    assertThat(challenges.get(0).scheme()).isEqualTo("Digest");
-    assertThat(challenges.get(0).realm()).isEqualTo("myrealm");
-    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
-    expectedAuthParams.put("realm", "myrealm");
-    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
-    expectedAuthParams.put("qop", "auth");
-    expectedAuthParams.put("stale", "FALSE");
-    assertThat(challenges.get(0).authParams()).isEqualTo(expectedAuthParams);
-  }
-
-  @Test public void testDigestChallengeWithAdditionalSpacesBeforeFirstAuthParam() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest    realm=\"myrealm\", nonce=\"fjalskdflwejrlaskdfjlaskdjfl"
-            + "aksjdflkasdf\", qop=\"auth\", stale=\"FALSE\"")
-        .build();
-    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertThat(challenges.size()).isEqualTo(1);
-    assertThat(challenges.get(0).scheme()).isEqualTo("Digest");
-    assertThat(challenges.get(0).realm()).isEqualTo("myrealm");
-    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
-    expectedAuthParams.put("realm", "myrealm");
-    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
-    expectedAuthParams.put("qop", "auth");
-    expectedAuthParams.put("stale", "FALSE");
-    assertThat(challenges.get(0).authParams()).isEqualTo(expectedAuthParams);
-  }
-
-  @Test public void testDigestChallengeWithCamelCasedNames() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "DiGeSt qop=\"auth\", rEaLm=\"myrealm\", nonce=\"fjalskdflwejrlask"
-            + "dfjlaskdjflaksjdflkasdf\", stale=\"FALSE\"")
-        .build();
-    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertThat(challenges.size()).isEqualTo(1);
-    assertThat(challenges.get(0).scheme()).isEqualTo("DiGeSt");
-    assertThat(challenges.get(0).realm()).isEqualTo("myrealm");
-    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
-    expectedAuthParams.put("realm", "myrealm");
-    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
-    expectedAuthParams.put("qop", "auth");
-    expectedAuthParams.put("stale", "FALSE");
-    assertThat(challenges.get(0).authParams()).isEqualTo(expectedAuthParams);
-  }
-
-  @Test public void testDigestChallengeWithCamelCasedNames2() {
-    // Strict RFC 2617 camelcased.
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "DIgEsT rEaLm=\"myrealm\", nonce=\"fjalskdflwejrlaskdfjlaskdjflaks"
-            + "jdflkasdf\", qop=\"auth\", stale=\"FALSE\"")
-        .build();
-    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertThat(challenges.size()).isEqualTo(1);
-    assertThat(challenges.get(0).scheme()).isEqualTo("DIgEsT");
-    assertThat(challenges.get(0).realm()).isEqualTo("myrealm");
-    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
-    expectedAuthParams.put("realm", "myrealm");
-    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
-    expectedAuthParams.put("qop", "auth");
-    expectedAuthParams.put("stale", "FALSE");
-    assertThat(challenges.get(0).authParams()).isEqualTo(expectedAuthParams);
-  }
-
-  @Test public void testDigestChallengeWithTokenFormOfAuthParam() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest realm=myrealm").build();
-    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertThat(challenges.size()).isEqualTo(1);
-    assertThat(challenges.get(0).scheme()).isEqualTo("Digest");
-    assertThat(challenges.get(0).realm()).isEqualTo("myrealm");
-    assertThat(challenges.get(0).authParams()).isEqualTo(singletonMap("realm", "myrealm"));
-  }
-
-  @Test public void testDigestChallengeWithoutAuthParams() {
-    // Scheme only.
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest").build();
-    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertThat(challenges.size()).isEqualTo(1);
-    assertThat(challenges.get(0).scheme()).isEqualTo("Digest");
-    assertThat(challenges.get(0).realm()).isNull();
-    assertThat(challenges.get(0).authParams()).isEqualTo(emptyMap());
-  }
-
-  @Test public void basicChallenge() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate: Basic realm=\"protected area\"")
-        .build();
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(
-        singletonList(new Challenge("Basic", singletonMap("realm", "protected area"))));
-  }
-
-  @Test public void basicChallengeWithCharset() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate: Basic realm=\"protected area\", charset=\"UTF-8\"")
-        .build();
-    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
-    expectedAuthParams.put("realm", "protected area");
-    expectedAuthParams.put("charset", "UTF-8");
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(
-        singletonList(new Challenge("Basic", expectedAuthParams)));
-  }
-
-  @Test public void basicChallengeWithUnexpectedCharset() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate: Basic realm=\"protected area\", charset=\"US-ASCII\"")
-        .build();
-
-    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
-    expectedAuthParams.put("realm", "protected area");
-    expectedAuthParams.put("charset", "US-ASCII");
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(
-        singletonList(new Challenge("Basic", expectedAuthParams)));
-  }
-
-  @Test public void separatorsBeforeFirstChallenge() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", " ,  , Basic realm=myrealm")
-        .build();
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(
-        singletonList(new Challenge("Basic", singletonMap("realm", "myrealm"))));
-  }
-
-  @Test public void spacesAroundKeyValueSeparator() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Basic realm = \"myrealm\"")
-        .build();
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(
-        singletonList(new Challenge("Basic", singletonMap("realm", "myrealm"))));
-  }
-
-  @Test public void multipleChallengesInOneHeader() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Basic realm = \"myrealm\",Digest")
-        .build();
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(Arrays.asList(
-        new Challenge("Basic", singletonMap("realm", "myrealm")),
-        new Challenge("Digest", Collections.emptyMap())));
-  }
-
-  @Test public void multipleChallengesWithSameSchemeButDifferentRealmInOneHeader() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Basic realm = \"myrealm\",Basic realm=myotherrealm")
-        .build();
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(Arrays.asList(
-        new Challenge("Basic", singletonMap("realm", "myrealm")),
-        new Challenge("Basic", singletonMap("realm", "myotherrealm"))));
-  }
-
-  @Test public void separatorsBeforeFirstAuthParam() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest, Basic ,,realm=\"myrealm\"")
-        .build();
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(Arrays.asList(
-        new Challenge("Digest", Collections.emptyMap()),
-        new Challenge("Basic", singletonMap("realm", "myrealm"))));
-  }
-
-  @Test public void onlyCommaBetweenChallenges() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest,Basic realm=\"myrealm\"")
-        .build();
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(Arrays.asList(
-        new Challenge("Digest", Collections.emptyMap()),
-        new Challenge("Basic", singletonMap("realm", "myrealm"))));
-  }
-
-  @Test public void multipleSeparatorsBetweenChallenges() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest,,,, Basic ,,realm=\"myrealm\"")
-        .build();
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(Arrays.asList(
-        new Challenge("Digest", Collections.emptyMap()),
-        new Challenge("Basic", singletonMap("realm", "myrealm"))));
-  }
-
-  @Test public void unknownAuthParams() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest,,,, Basic ,,foo=bar,realm=\"myrealm\"")
-        .build();
-
-    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
-    expectedAuthParams.put("realm", "myrealm");
-    expectedAuthParams.put("foo", "bar");
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(Arrays.asList(
-        new Challenge("Digest", Collections.emptyMap()),
-        new Challenge("Basic", expectedAuthParams)));
-  }
-
-  @Test public void escapedCharactersInQuotedString() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest,,,, Basic ,,,realm=\"my\\\\\\\"r\\ealm\"")
-        .build();
-
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(Arrays.asList(
-        new Challenge("Digest", Collections.emptyMap()),
-        new Challenge("Basic", singletonMap("realm", "my\\\"realm"))));
-  }
-
-  @Test public void commaInQuotedStringAndBeforeFirstChallenge() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", ",Digest,,,, Basic ,,,realm=\"my, realm,\"")
-        .build();
-
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(Arrays.asList(
-        new Challenge("Digest", Collections.emptyMap()),
-        new Challenge("Basic", singletonMap("realm", "my, realm,"))));
-  }
-
-  @Test public void unescapedDoubleQuoteInQuotedStringWithEvenNumberOfBackslashesInFront() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest,,,, Basic ,,,realm=\"my\\\\\\\\\"r\\ealm\"")
-        .build();
-
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(Arrays.asList(
-        new Challenge("Digest", Collections.emptyMap())));
-  }
-
-  @Test public void unescapedDoubleQuoteInQuotedString() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest,,,, Basic ,,,realm=\"my\"realm\"")
-        .build();
-
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(Arrays.asList(
-        new Challenge("Digest", Collections.emptyMap())));
-  }
-
-  @Ignore("TODO(jwilson): reject parameters that use invalid characters")
-  @Test public void doubleQuoteInToken() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest,,,, Basic ,,,realm=my\"realm")
-        .build();
-
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(Arrays.asList(
-        new Challenge("Digest", Collections.emptyMap())));
-  }
-
-  @Test public void token68InsteadOfAuthParams() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Other abc==")
-        .build();
-
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(
-        singletonList(
-        new Challenge("Other", singletonMap(null, "abc=="))));
-  }
-
-  @Test public void token68AndAuthParams() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Other abc==, realm=myrealm")
-        .build();
-
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(Arrays.asList(
-        new Challenge("Other", singletonMap(null, "abc=="))));
-  }
-
-  @Test public void repeatedAuthParamKey() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Other realm=myotherrealm, realm=myrealm")
-        .build();
-
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(
-        emptyList());
-  }
-
-  @Test public void multipleAuthenticateHeaders() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest")
-        .add("WWW-Authenticate", "Basic realm=myrealm")
-        .build();
-
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(Arrays.asList(
-        new Challenge("Digest", Collections.emptyMap()),
-        new Challenge("Basic", singletonMap("realm", "myrealm"))));
-  }
-
-  @Test public void multipleAuthenticateHeadersInDifferentOrder() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Basic realm=myrealm")
-        .add("WWW-Authenticate", "Digest")
-        .build();
-
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(Arrays.asList(
-        new Challenge("Basic", singletonMap("realm", "myrealm")),
-        new Challenge("Digest", Collections.emptyMap())));
-  }
-
-  @Test public void multipleBasicAuthenticateHeaders() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Basic realm=myrealm")
-        .add("WWW-Authenticate", "Basic realm=myotherrealm")
-        .build();
-
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(Arrays.asList(
-        new Challenge("Basic", singletonMap("realm", "myrealm")),
-        new Challenge("Basic", singletonMap("realm", "myotherrealm"))));
-  }
-
-  @Test public void byteCount() {
-    assertThat(Util.EMPTY_HEADERS.byteCount()).isEqualTo(0L);
-    assertThat(new Headers.Builder()
-        .add("abc", "def")
-        .build()
-        .byteCount()).isEqualTo(10L);
-    assertThat(new Headers.Builder()
-        .add("abc", "def")
-        .add("ghi", "jkl")
-        .build()
-        .byteCount()).isEqualTo(20L);
-  }
-
-  @Test public void addDate() {
-    Date expected = new Date(0L);
-    Headers headers = new Headers.Builder()
-        .add("testDate", expected)
-        .build();
-    assertThat(headers.get("testDate")).isEqualTo("Thu, 01 Jan 1970 00:00:00 GMT");
-    assertThat(headers.getDate("testDate")).isEqualTo(new Date(0L));
-  }
-
-  @Test public void addDateNull() {
-    try {
-      new Headers.Builder()
-          .add("testDate", (Date) null)
-          .build();
-      fail();
-    } catch (NullPointerException expected) {
-      assertThat(expected.getMessage()).isEqualTo("value for name testDate == null");
-    }
-  }
-
-  @Test public void addInstant() {
-    Instant expected = Instant.ofEpochMilli(0L);
-    Headers headers = new Headers.Builder()
-        .add("Test-Instant", expected)
-        .build();
-    assertThat(headers.get("Test-Instant")).isEqualTo("Thu, 01 Jan 1970 00:00:00 GMT");
-    assertThat(headers.getInstant("Test-Instant")).isEqualTo(expected);
-  }
-
-  @Test public void addInstantNull() {
-    try {
-      new Headers.Builder()
-          .add("Test-Instant", (Instant) null)
-          .build();
-      fail();
-    } catch (NullPointerException expected) {
-      assertThat(expected.getMessage()).isEqualTo("value for name Test-Instant == null");
-    }
-  }
-
-  @Test public void setDate() {
-    Date expected = new Date(1000);
-    Headers headers = new Headers.Builder()
-        .add("testDate", new Date(0L))
-        .set("testDate", expected)
-        .build();
-    assertThat(headers.get("testDate")).isEqualTo("Thu, 01 Jan 1970 00:00:01 GMT");
-    assertThat(headers.getDate("testDate")).isEqualTo(expected);
-  }
-
-  @Test public void setDateNull() {
-    try {
-      new Headers.Builder()
-          .set("testDate", (Date) null)
-          .build();
-      fail();
-    } catch (NullPointerException expected) {
-      assertThat(expected.getMessage()).isEqualTo("value for name testDate == null");
-    }
-  }
-
-  @Test public void setInstant() {
-    Instant expected = Instant.ofEpochMilli(1000L);
-    Headers headers = new Headers.Builder()
-        .add("Test-Instant", Instant.ofEpochMilli(0L))
-        .set("Test-Instant", expected)
-        .build();
-    assertThat(headers.get("Test-Instant")).isEqualTo("Thu, 01 Jan 1970 00:00:01 GMT");
-    assertThat(headers.getInstant("Test-Instant")).isEqualTo(expected);
-  }
-
-  @Test public void setInstantNull() {
-    try {
-      new Headers.Builder()
-          .set("Test-Instant", (Instant) null)
-          .build();
-      fail();
-    } catch (NullPointerException expected) {
-      assertThat(expected.getMessage()).isEqualTo("value for name Test-Instant == null");
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java b/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
deleted file mode 100644
index 92b5809594..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
+++ /dev/null
@@ -1,904 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.net.ServerSocket;
-import java.net.Socket;
-import java.net.SocketTimeoutException;
-import java.util.Arrays;
-import java.util.Locale;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.SynchronousQueue;
-import java.util.concurrent.ThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicReference;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
-import okhttp3.mockwebserver.SocketPolicy;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.ForwardingSink;
-import okio.ForwardingSource;
-import okio.GzipSink;
-import okio.Okio;
-import okio.Sink;
-import okio.Source;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class InterceptorTest {
-  @Rule public MockWebServer server = new MockWebServer();
-  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
-
-  private OkHttpClient client = clientTestRule.client;
-  private RecordingCallback callback = new RecordingCallback();
-
-  @Test public void applicationInterceptorsCanShortCircuitResponses() throws Exception {
-    server.shutdown(); // Accept no connections.
-
-    Request request = new Request.Builder()
-        .url("https://localhost:1/")
-        .build();
-
-    Response interceptorResponse = new Response.Builder()
-        .request(request)
-        .protocol(Protocol.HTTP_1_1)
-        .code(200)
-        .message("Intercepted!")
-        .body(ResponseBody.create(MediaType.get("text/plain; charset=utf-8"), "abc"))
-        .build();
-
-    client = client.newBuilder()
-        .addInterceptor(chain -> interceptorResponse)
-        .build();
-
-    Response response = client.newCall(request).execute();
-    assertThat(response).isSameAs(interceptorResponse);
-  }
-
-  @Test public void networkInterceptorsCannotShortCircuitResponses() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(500));
-
-    Interceptor interceptor = chain -> new Response.Builder()
-        .request(chain.request())
-        .protocol(Protocol.HTTP_1_1)
-        .code(200)
-        .message("Intercepted!")
-        .body(ResponseBody.create(MediaType.get("text/plain; charset=utf-8"), "abc"))
-        .build();
-    client = client.newBuilder()
-        .addNetworkInterceptor(interceptor)
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    try {
-      client.newCall(request).execute();
-      fail();
-    } catch (IllegalStateException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          ("network interceptor " + interceptor + " must call proceed() exactly once"));
-    }
-  }
-
-  @Test public void networkInterceptorsCannotCallProceedMultipleTimes() throws Exception {
-    server.enqueue(new MockResponse());
-    server.enqueue(new MockResponse());
-
-    Interceptor interceptor = chain -> {
-      chain.proceed(chain.request());
-      return chain.proceed(chain.request());
-    };
-    client = client.newBuilder()
-        .addNetworkInterceptor(interceptor)
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    try {
-      client.newCall(request).execute();
-      fail();
-    } catch (IllegalStateException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          ("network interceptor " + interceptor + " must call proceed() exactly once"));
-    }
-  }
-
-  @Test public void networkInterceptorsCannotChangeServerAddress() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(500));
-
-    Interceptor interceptor = chain -> {
-      Address address = chain.connection().route().address();
-      String sameHost = address.url().host();
-      int differentPort = address.url().port() + 1;
-      return chain.proceed(chain.request().newBuilder()
-          .url("http://" + sameHost + ":" + differentPort + "/")
-          .build());
-    };
-    client = client.newBuilder()
-        .addNetworkInterceptor(interceptor)
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    try {
-      client.newCall(request).execute();
-      fail();
-    } catch (IllegalStateException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          ("network interceptor " + interceptor + " must retain the same host and port"));
-    }
-  }
-
-  @Test public void networkInterceptorsHaveConnectionAccess() throws Exception {
-    server.enqueue(new MockResponse());
-
-    Interceptor interceptor = chain -> {
-      Connection connection = chain.connection();
-      assertThat(connection).isNotNull();
-      return chain.proceed(chain.request());
-    };
-    client = client.newBuilder()
-        .addNetworkInterceptor(interceptor)
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    client.newCall(request).execute();
-  }
-
-  @Test public void networkInterceptorsObserveNetworkHeaders() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody(gzip("abcabcabc"))
-        .addHeader("Content-Encoding: gzip"));
-
-    Interceptor interceptor = chain -> {
-      // The network request has everything: User-Agent, Host, Accept-Encoding.
-      Request networkRequest = chain.request();
-      assertThat(networkRequest.header("User-Agent")).isNotNull();
-      assertThat(networkRequest.header("Host")).isEqualTo(
-          (server.getHostName() + ":" + server.getPort()));
-      assertThat(networkRequest.header("Accept-Encoding")).isNotNull();
-
-      // The network response also has everything, including the raw gzipped content.
-      Response networkResponse = chain.proceed(networkRequest);
-      assertThat(networkResponse.header("Content-Encoding")).isEqualTo("gzip");
-      return networkResponse;
-    };
-    client = client.newBuilder()
-        .addNetworkInterceptor(interceptor)
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    // No extra headers in the application's request.
-    assertThat(request.header("User-Agent")).isNull();
-    assertThat(request.header("Host")).isNull();
-    assertThat(request.header("Accept-Encoding")).isNull();
-
-    // No extra headers in the application's response.
-    Response response = client.newCall(request).execute();
-    assertThat(request.header("Content-Encoding")).isNull();
-    assertThat(response.body().string()).isEqualTo("abcabcabc");
-  }
-
-  @Test public void networkInterceptorsCanChangeRequestMethodFromGetToPost() throws Exception {
-    server.enqueue(new MockResponse());
-
-    Interceptor interceptor = chain -> {
-      Request originalRequest = chain.request();
-      MediaType mediaType = MediaType.get("text/plain");
-      RequestBody body = RequestBody.create(mediaType, "abc");
-      return chain.proceed(originalRequest.newBuilder()
-          .method("POST", body)
-          .header("Content-Type", mediaType.toString())
-          .header("Content-Length", Long.toString(body.contentLength()))
-          .build());
-    };
-    client = client.newBuilder()
-        .addNetworkInterceptor(interceptor)
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .get()
-        .build();
-
-    client.newCall(request).execute();
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getMethod()).isEqualTo("POST");
-    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("abc");
-  }
-
-  @Test public void applicationInterceptorsRewriteRequestToServer() throws Exception {
-    rewriteRequestToServer(false);
-  }
-
-  @Test public void networkInterceptorsRewriteRequestToServer() throws Exception {
-    rewriteRequestToServer(true);
-  }
-
-  private void rewriteRequestToServer(boolean network) throws Exception {
-    server.enqueue(new MockResponse());
-
-    addInterceptor(network, chain -> {
-      Request originalRequest = chain.request();
-      return chain.proceed(originalRequest.newBuilder()
-          .method("POST", uppercase(originalRequest.body()))
-          .addHeader("OkHttp-Intercepted", "yep")
-          .build());
-    });
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .addHeader("Original-Header", "foo")
-        .method("PUT", RequestBody.create(MediaType.get("text/plain"), "abc"))
-        .build();
-
-    client.newCall(request).execute();
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("ABC");
-    assertThat(recordedRequest.getHeader("Original-Header")).isEqualTo("foo");
-    assertThat(recordedRequest.getHeader("OkHttp-Intercepted")).isEqualTo("yep");
-    assertThat(recordedRequest.getMethod()).isEqualTo("POST");
-  }
-
-  @Test public void applicationInterceptorsRewriteResponseFromServer() throws Exception {
-    rewriteResponseFromServer(false);
-  }
-
-  @Test public void networkInterceptorsRewriteResponseFromServer() throws Exception {
-    rewriteResponseFromServer(true);
-  }
-
-  private void rewriteResponseFromServer(boolean network) throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Original-Header: foo")
-        .setBody("abc"));
-
-    addInterceptor(network, chain -> {
-      Response originalResponse = chain.proceed(chain.request());
-      return originalResponse.newBuilder()
-          .body(uppercase(originalResponse.body()))
-          .addHeader("OkHttp-Intercepted", "yep")
-          .build();
-    });
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("ABC");
-    assertThat(response.header("OkHttp-Intercepted")).isEqualTo("yep");
-    assertThat(response.header("Original-Header")).isEqualTo("foo");
-  }
-
-  @Test public void multipleApplicationInterceptors() throws Exception {
-    multipleInterceptors(false);
-  }
-
-  @Test public void multipleNetworkInterceptors() throws Exception {
-    multipleInterceptors(true);
-  }
-
-  private void multipleInterceptors(boolean network) throws Exception {
-    server.enqueue(new MockResponse());
-
-    addInterceptor(network, chain -> {
-      Request originalRequest = chain.request();
-      Response originalResponse = chain.proceed(originalRequest.newBuilder()
-          .addHeader("Request-Interceptor", "Android") // 1. Added first.
-          .build());
-      return originalResponse.newBuilder()
-          .addHeader("Response-Interceptor", "Donut") // 4. Added last.
-          .build();
-    });
-    addInterceptor(network, chain -> {
-      Request originalRequest = chain.request();
-      Response originalResponse = chain.proceed(originalRequest.newBuilder()
-          .addHeader("Request-Interceptor", "Bob") // 2. Added second.
-          .build());
-      return originalResponse.newBuilder()
-          .addHeader("Response-Interceptor", "Cupcake") // 3. Added third.
-          .build();
-    });
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    Response response = client.newCall(request).execute();
-    assertThat(response.headers("Response-Interceptor")).isEqualTo(
-        Arrays.asList("Cupcake", "Donut"));
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getHeaders().values("Request-Interceptor")).isEqualTo(
-        Arrays.asList("Android", "Bob"));
-  }
-
-  @Test public void asyncApplicationInterceptors() throws Exception {
-    asyncInterceptors(false);
-  }
-
-  @Test public void asyncNetworkInterceptors() throws Exception {
-    asyncInterceptors(true);
-  }
-
-  private void asyncInterceptors(boolean network) throws Exception {
-    server.enqueue(new MockResponse());
-
-    addInterceptor(network, chain -> {
-      Response originalResponse = chain.proceed(chain.request());
-      return originalResponse.newBuilder()
-          .addHeader("OkHttp-Intercepted", "yep")
-          .build();
-    });
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    client.newCall(request).enqueue(callback);
-
-    callback.await(request.url())
-        .assertCode(200)
-        .assertHeader("OkHttp-Intercepted", "yep");
-  }
-
-  @Test public void applicationInterceptorsCanMakeMultipleRequestsToServer() throws Exception {
-    server.enqueue(new MockResponse().setBody("a"));
-    server.enqueue(new MockResponse().setBody("b"));
-
-    client = client.newBuilder()
-        .addInterceptor(chain -> {
-          Response response1 = chain.proceed(chain.request());
-          response1.body().close();
-          return chain.proceed(chain.request());
-        })
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    Response response = client.newCall(request).execute();
-    assertThat("b").isEqualTo(response.body().string());
-  }
-
-  /** Make sure interceptors can interact with the OkHttp client. */
-  @Test public void interceptorMakesAnUnrelatedRequest() throws Exception {
-    server.enqueue(new MockResponse().setBody("a")); // Fetched by interceptor.
-    server.enqueue(new MockResponse().setBody("b")); // Fetched directly.
-
-    client = client.newBuilder()
-        .addInterceptor(chain -> {
-          if (chain.request().url().encodedPath().equals("/b")) {
-            Request requestA = new Request.Builder()
-                .url(server.url("/a"))
-                .build();
-            Response responseA = client.newCall(requestA).execute();
-            assertThat(responseA.body().string()).isEqualTo("a");
-          }
-
-          return chain.proceed(chain.request());
-        })
-        .build();
-
-    Request requestB = new Request.Builder()
-        .url(server.url("/b"))
-        .build();
-    Response responseB = client.newCall(requestB).execute();
-    assertThat(responseB.body().string()).isEqualTo("b");
-  }
-
-  /** Make sure interceptors can interact with the OkHttp client asynchronously. */
-  @Test public void interceptorMakesAnUnrelatedAsyncRequest() throws Exception {
-    server.enqueue(new MockResponse().setBody("a")); // Fetched by interceptor.
-    server.enqueue(new MockResponse().setBody("b")); // Fetched directly.
-
-    client = client.newBuilder()
-        .addInterceptor(chain -> {
-          if (chain.request().url().encodedPath().equals("/b")) {
-            Request requestA = new Request.Builder()
-                .url(server.url("/a"))
-                .build();
-
-            try {
-              RecordingCallback callbackA = new RecordingCallback();
-              client.newCall(requestA).enqueue(callbackA);
-              callbackA.await(requestA.url()).assertBody("a");
-            } catch (Exception e) {
-              throw new RuntimeException(e);
-            }
-          }
-
-          return chain.proceed(chain.request());
-        })
-        .build();
-
-    Request requestB = new Request.Builder()
-        .url(server.url("/b"))
-        .build();
-    RecordingCallback callbackB = new RecordingCallback();
-    client.newCall(requestB).enqueue(callbackB);
-    callbackB.await(requestB.url()).assertBody("b");
-  }
-
-  @Test public void applicationInterceptorThrowsRuntimeExceptionSynchronous() throws Exception {
-    interceptorThrowsRuntimeExceptionSynchronous(false);
-  }
-
-  @Test public void networkInterceptorThrowsRuntimeExceptionSynchronous() throws Exception {
-    interceptorThrowsRuntimeExceptionSynchronous(true);
-  }
-
-  /**
-   * When an interceptor throws an unexpected exception, synchronous callers can catch it and deal
-   * with it.
-   */
-  private void interceptorThrowsRuntimeExceptionSynchronous(boolean network) throws Exception {
-    addInterceptor(network, chain -> { throw new RuntimeException("boom!"); });
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    try {
-      client.newCall(request).execute();
-      fail();
-    } catch (RuntimeException expected) {
-      assertThat(expected.getMessage()).isEqualTo("boom!");
-    }
-  }
-
-  @Test public void networkInterceptorModifiedRequestIsReturned() throws IOException {
-    server.enqueue(new MockResponse());
-
-    Interceptor modifyHeaderInterceptor = chain -> {
-      Request modifiedRequest = chain.request()
-          .newBuilder()
-          .header("User-Agent", "intercepted request")
-          .build();
-      return chain.proceed(modifiedRequest);
-    };
-
-    client = client.newBuilder()
-        .addNetworkInterceptor(modifyHeaderInterceptor)
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("User-Agent", "user request")
-        .build();
-
-    Response response = client.newCall(request).execute();
-    assertThat(response.request().header("User-Agent")).isNotNull();
-    assertThat(response.request().header("User-Agent")).isEqualTo("user request");
-    assertThat(response.networkResponse().request().header("User-Agent")).isEqualTo(
-        "intercepted request");
-  }
-
-  @Test public void applicationInterceptorThrowsRuntimeExceptionAsynchronous() throws Exception {
-    interceptorThrowsRuntimeExceptionAsynchronous(false);
-  }
-
-  @Test public void networkInterceptorThrowsRuntimeExceptionAsynchronous() throws Exception {
-    interceptorThrowsRuntimeExceptionAsynchronous(true);
-  }
-
-  /**
-   * When an interceptor throws an unexpected exception, asynchronous callers are left hanging. The
-   * exception goes to the uncaught exception handler.
-   */
-  private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) throws Exception {
-    addInterceptor(network, chain -> { throw new RuntimeException("boom!"); });
-
-    ExceptionCatchingExecutor executor = new ExceptionCatchingExecutor();
-    client = client.newBuilder()
-        .dispatcher(new Dispatcher(executor))
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    client.newCall(request).enqueue(callback);
-
-    assertThat(executor.takeException().getMessage()).isEqualTo("boom!");
-  }
-
-  @Test public void applicationInterceptorReturnsNull() throws Exception {
-    server.enqueue(new MockResponse());
-
-    Interceptor interceptor = chain -> {
-      chain.proceed(chain.request());
-      return null;
-    };
-    client = client.newBuilder()
-        .addInterceptor(interceptor)
-        .build();
-
-    ExceptionCatchingExecutor executor = new ExceptionCatchingExecutor();
-    client = client.newBuilder()
-        .dispatcher(new Dispatcher(executor))
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    try {
-      client.newCall(request).execute();
-      fail();
-    } catch (NullPointerException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          ("interceptor " + interceptor + " returned null"));
-    }
-  }
-
-  @Test public void networkInterceptorReturnsNull() throws Exception {
-    server.enqueue(new MockResponse());
-
-    Interceptor interceptor = chain -> {
-      chain.proceed(chain.request());
-      return null;
-    };
-    client = client.newBuilder()
-        .addNetworkInterceptor(interceptor)
-        .build();
-
-    ExceptionCatchingExecutor executor = new ExceptionCatchingExecutor();
-    client = client.newBuilder()
-        .dispatcher(new Dispatcher(executor))
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    try {
-      client.newCall(request).execute();
-      fail();
-    } catch (NullPointerException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          ("interceptor " + interceptor + " returned null"));
-    }
-  }
-
-  @Test public void networkInterceptorReturnsConnectionOnEmptyBody() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .addHeader("Connection", "Close"));
-
-    Interceptor interceptor = chain -> {
-      Response response = chain.proceed(chain.request());
-      assertThat(chain.connection()).isNotNull();
-      return response;
-    };
-
-    client = client.newBuilder()
-        .addNetworkInterceptor(interceptor)
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    Response response = client.newCall(request).execute();
-    response.body().close();
-  }
-
-  @Test public void applicationInterceptorResponseMustHaveBody() throws Exception {
-    server.enqueue(new MockResponse());
-
-    Interceptor interceptor = chain -> {
-      Response response = chain.proceed(chain.request());
-      return response.newBuilder()
-          .body(null)
-          .build();
-    };
-    client = client.newBuilder()
-        .addInterceptor(interceptor)
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    try {
-      client.newCall(request).execute();
-      fail();
-    } catch (IllegalStateException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          ("interceptor " + interceptor + " returned a response with no body"));
-    }
-  }
-
-  @Test public void networkInterceptorResponseMustHaveBody() throws Exception {
-    server.enqueue(new MockResponse());
-
-    Interceptor interceptor = chain -> {
-      Response response = chain.proceed(chain.request());
-      return response.newBuilder()
-          .body(null)
-          .build();
-    };
-    client = client.newBuilder()
-        .addNetworkInterceptor(interceptor)
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    try {
-      client.newCall(request).execute();
-      fail();
-    } catch (IllegalStateException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          ("interceptor " + interceptor + " returned a response with no body"));
-    }
-  }
-
-  @Test public void connectTimeout() throws Exception {
-    Interceptor interceptor1 = chainA -> {
-      assertThat(chainA.connectTimeoutMillis()).isEqualTo(5000);
-
-      Interceptor.Chain chainB = chainA.withConnectTimeout(100, TimeUnit.MILLISECONDS);
-      assertThat(chainB.connectTimeoutMillis()).isEqualTo(100);
-
-      return chainB.proceed(chainA.request());
-    };
-
-    Interceptor interceptor2 = chain -> {
-      assertThat(chain.connectTimeoutMillis()).isEqualTo(100);
-      return chain.proceed(chain.request());
-    };
-
-    ServerSocket serverSocket = new ServerSocket(0, 1);
-    // Fill backlog queue with this request so subsequent requests will be blocked.
-    new Socket().connect(serverSocket.getLocalSocketAddress());
-
-    client = client.newBuilder()
-        .connectTimeout(5, TimeUnit.SECONDS)
-        .addInterceptor(interceptor1)
-        .addInterceptor(interceptor2)
-        .build();
-
-    Request request1 =
-        new Request.Builder()
-            .url(
-                "http://"
-                    + serverSocket.getInetAddress().getCanonicalHostName()
-                    + ":"
-                    + serverSocket.getLocalPort())
-            .build();
-    Call call = client.newCall(request1);
-
-    try {
-      call.execute();
-      fail();
-    } catch (SocketTimeoutException expected) {
-    }
-
-    serverSocket.close();
-  }
-
-  @Test public void chainWithReadTimeout() throws Exception {
-    Interceptor interceptor1 = chainA -> {
-      assertThat(chainA.readTimeoutMillis()).isEqualTo(5000);
-
-      Interceptor.Chain chainB = chainA.withReadTimeout(100, TimeUnit.MILLISECONDS);
-      assertThat(chainB.readTimeoutMillis()).isEqualTo(100);
-
-      return chainB.proceed(chainA.request());
-    };
-
-    Interceptor interceptor2 = chain -> {
-      assertThat(chain.readTimeoutMillis()).isEqualTo(100);
-      return chain.proceed(chain.request());
-    };
-
-    client = client.newBuilder()
-        .readTimeout(5, TimeUnit.SECONDS)
-        .addInterceptor(interceptor1)
-        .addInterceptor(interceptor2)
-        .build();
-
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .throttleBody(1, 1, TimeUnit.SECONDS));
-
-    Request request1 = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Call call = client.newCall(request1);
-    Response response = call.execute();
-    ResponseBody body = response.body();
-    try {
-      body.string();
-      fail();
-    } catch (SocketTimeoutException expected) {
-    }
-  }
-
-  @Test public void chainWithWriteTimeout() throws Exception {
-    Interceptor interceptor1 = chainA -> {
-      assertThat(chainA.writeTimeoutMillis()).isEqualTo(5000);
-
-      Interceptor.Chain chainB = chainA.withWriteTimeout(100, TimeUnit.MILLISECONDS);
-      assertThat(chainB.writeTimeoutMillis()).isEqualTo(100);
-
-      return chainB.proceed(chainA.request());
-    };
-
-    Interceptor interceptor2 = chain -> {
-      assertThat(chain.writeTimeoutMillis()).isEqualTo(100);
-      return chain.proceed(chain.request());
-    };
-
-    client = client.newBuilder()
-        .writeTimeout(5, TimeUnit.SECONDS)
-        .addInterceptor(interceptor1)
-        .addInterceptor(interceptor2)
-        .build();
-
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .throttleBody(1, 1, TimeUnit.SECONDS));
-
-    byte[] data = new byte[2 * 1024 * 1024]; // 2 MiB.
-    Request request1 = new Request.Builder()
-        .url(server.url("/"))
-        .post(RequestBody.create(MediaType.get("text/plain"), data))
-        .build();
-    Call call = client.newCall(request1);
-
-    try {
-      call.execute(); // we want this call to throw a SocketTimeoutException
-      fail();
-    } catch (SocketTimeoutException expected) {
-    }
-  }
-
-  @Test public void chainCanCancelCall() throws Exception {
-    AtomicReference<Call> callRef = new AtomicReference<>();
-
-    Interceptor interceptor = chain -> {
-      Call call = chain.call();
-      callRef.set(call);
-
-      assertThat(call.isCanceled()).isFalse();
-      call.cancel();
-      assertThat(call.isCanceled()).isTrue();
-
-      return chain.proceed(chain.request());
-    };
-
-    client = client.newBuilder()
-        .addInterceptor(interceptor)
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Call call = client.newCall(request);
-
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-    }
-
-    assertThat(callRef.get()).isSameAs(call);
-  }
-
-  private RequestBody uppercase(RequestBody original) {
-    return new RequestBody() {
-      @Override public MediaType contentType() {
-        return original.contentType();
-      }
-
-      @Override public long contentLength() throws IOException {
-        return original.contentLength();
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        Sink uppercase = uppercase(sink);
-        BufferedSink bufferedSink = Okio.buffer(uppercase);
-        original.writeTo(bufferedSink);
-        bufferedSink.emit();
-      }
-    };
-  }
-
-  private Sink uppercase(BufferedSink original) {
-    return new ForwardingSink(original) {
-      @Override public void write(Buffer source, long byteCount) throws IOException {
-        original.writeUtf8(source.readUtf8(byteCount).toUpperCase(Locale.US));
-      }
-    };
-  }
-
-  static ResponseBody uppercase(ResponseBody original) throws IOException {
-    return ResponseBody.create(original.contentType(), original.contentLength(),
-        Okio.buffer(uppercase(original.source())));
-  }
-
-  private static Source uppercase(Source original) {
-    return new ForwardingSource(original) {
-      @Override public long read(Buffer sink, long byteCount) throws IOException {
-        Buffer mixedCase = new Buffer();
-        long count = original.read(mixedCase, byteCount);
-        sink.writeUtf8(mixedCase.readUtf8().toUpperCase(Locale.US));
-        return count;
-      }
-    };
-  }
-
-  private Buffer gzip(String data) throws IOException {
-    Buffer result = new Buffer();
-    BufferedSink sink = Okio.buffer(new GzipSink(result));
-    sink.writeUtf8(data);
-    sink.close();
-    return result;
-  }
-
-  private void addInterceptor(boolean network, Interceptor interceptor) {
-    OkHttpClient.Builder builder = client.newBuilder();
-    if (network) {
-      builder.addNetworkInterceptor(interceptor);
-    } else {
-      builder.addInterceptor(interceptor);
-    }
-    client = builder.build();
-  }
-
-  /** Catches exceptions that are otherwise headed for the uncaught exception handler. */
-  private static class ExceptionCatchingExecutor extends ThreadPoolExecutor {
-    private final BlockingQueue<Exception> exceptions = new LinkedBlockingQueue<>();
-
-    public ExceptionCatchingExecutor() {
-      super(1, 1, 0, TimeUnit.SECONDS, new SynchronousQueue<>());
-    }
-
-    @Override public void execute(Runnable runnable) {
-      super.execute(() -> {
-        try {
-          runnable.run();
-        } catch (Exception e) {
-          exceptions.add(e);
-        }
-      });
-    }
-
-    public Exception takeException() throws Exception {
-      return exceptions.take();
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java b/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java
deleted file mode 100644
index ac4c608f1e..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java
+++ /dev/null
@@ -1,221 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- * Copyright (C) 2011 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.nio.charset.Charset;
-import java.util.Arrays;
-import java.util.Collection;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-/**
- * Test MediaType API and parsing.
- *
- * <p>This test includes tests from <a href="https://code.google.com/p/guava-libraries/">Guava's</a>
- * MediaTypeTest.
- */
-@RunWith(Parameterized.class)
-public class MediaTypeTest {
-  @Parameterized.Parameters(name = "Use get = {0}")
-  public static Collection<Object[]> parameters() {
-    return Arrays.asList(
-        new Object[] { true },
-        new Object[] { false }
-    );
-  }
-
-  @Parameterized.Parameter
-  public boolean useGet;
-
-  private MediaType parse(String string) {
-    return useGet
-        ? MediaType.get(string)
-        : MediaType.parse(string);
-  }
-
-  @Test public void testParse() throws Exception {
-    MediaType mediaType = parse("text/plain;boundary=foo;charset=utf-8");
-    assertThat(mediaType.type()).isEqualTo("text");
-    assertThat(mediaType.subtype()).isEqualTo("plain");
-    assertThat(mediaType.charset().name()).isEqualTo("UTF-8");
-    assertThat(mediaType.toString()).isEqualTo("text/plain;boundary=foo;charset=utf-8");
-    assertThat(parse("text/plain;boundary=foo;charset=utf-8")).isEqualTo(mediaType);
-    assertThat(parse("text/plain;boundary=foo;charset=utf-8").hashCode()).isEqualTo(
-        (long) mediaType.hashCode());
-  }
-
-  @Test public void testValidParse() throws Exception {
-    assertMediaType("text/plain");
-    assertMediaType("application/atom+xml; charset=utf-8");
-    assertMediaType("application/atom+xml; a=1; a=2; b=3");
-    assertMediaType("image/gif; foo=bar");
-    assertMediaType("text/plain; a=1");
-    assertMediaType("text/plain; a=1; a=2; b=3");
-    assertMediaType("text/plain; charset=utf-16");
-    assertMediaType("text/plain; \t \n \r a=b");
-    assertMediaType("text/plain;");
-    assertMediaType("text/plain; ");
-    assertMediaType("text/plain; a=1;");
-    assertMediaType("text/plain; a=1; ");
-    assertMediaType("text/plain; a=1;; b=2");
-    assertMediaType("text/plain;;");
-    assertMediaType("text/plain; ;");
-  }
-
-  @Test public void testInvalidParse() throws Exception {
-    assertInvalid("", "No subtype found for: \"\"");
-    assertInvalid("/", "No subtype found for: \"/\"");
-    assertInvalid("text", "No subtype found for: \"text\"");
-    assertInvalid("text/", "No subtype found for: \"text/\"");
-    assertInvalid("te<t/plain", "No subtype found for: \"te<t/plain\"");
-    assertInvalid(" text/plain", "No subtype found for: \" text/plain\"");
-    assertInvalid("te xt/plain", "No subtype found for: \"te xt/plain\"");
-    assertInvalid("text /plain", "No subtype found for: \"text /plain\"");
-    assertInvalid("text/ plain", "No subtype found for: \"text/ plain\"");
-
-    assertInvalid("text/pl@in",
-        "Parameter is not formatted correctly: \"@in\" for: \"text/pl@in\"");
-    assertInvalid("text/plain; a",
-        "Parameter is not formatted correctly: \"a\" for: \"text/plain; a\"");
-    assertInvalid("text/plain; a=",
-        "Parameter is not formatted correctly: \"a=\" for: \"text/plain; a=\"");
-    assertInvalid("text/plain; a=@",
-        "Parameter is not formatted correctly: \"a=@\" for: \"text/plain; a=@\"");
-    assertInvalid("text/plain; a=\"@",
-        "Parameter is not formatted correctly: \"a=\"@\" for: \"text/plain; a=\"@\"");
-    assertInvalid("text/plain; a=1; b",
-        "Parameter is not formatted correctly: \"b\" for: \"text/plain; a=1; b\"");
-    assertInvalid("text/plain; a=1; b=",
-        "Parameter is not formatted correctly: \"b=\" for: \"text/plain; a=1; b=\"");
-    assertInvalid("text/plain; a=\u2025",
-        "Parameter is not formatted correctly: \"a=‚Ä•\" for: \"text/plain; a=‚Ä•\"");
-    assertInvalid("text/pl ain",
-        "Parameter is not formatted correctly: \" ain\" for: \"text/pl ain\"");
-    assertInvalid("text/plain ",
-        "Parameter is not formatted correctly: \" \" for: \"text/plain \"");
-    assertInvalid("text/plain ; a=1",
-        "Parameter is not formatted correctly: \" ; a=1\" for: \"text/plain ; a=1\"");
-  }
-
-  @Test public void testDoubleQuotesAreSpecial() throws Exception {
-    MediaType mediaType = parse("text/plain;a=\";charset=utf-8;b=\"");
-    assertThat(mediaType.charset()).isNull();
-  }
-
-  @Test public void testSingleQuotesAreNotSpecial() throws Exception {
-    MediaType mediaType = parse("text/plain;a=';charset=utf-8;b='");
-    assertThat(mediaType.charset().name()).isEqualTo("UTF-8");
-  }
-
-  @Test public void testParseWithSpecialCharacters() throws Exception {
-    MediaType mediaType = parse("!#$%&'*+-.{|}~/!#$%&'*+-.{|}~; !#$%&'*+-.{|}~=!#$%&'*+-.{|}~");
-    assertThat(mediaType.type()).isEqualTo("!#$%&'*+-.{|}~");
-    assertThat(mediaType.subtype()).isEqualTo("!#$%&'*+-.{|}~");
-  }
-
-  @Test public void testCharsetIsOneOfManyParameters() throws Exception {
-    MediaType mediaType = parse("text/plain;a=1;b=2;charset=utf-8;c=3");
-    assertThat(mediaType.type()).isEqualTo("text");
-    assertThat(mediaType.subtype()).isEqualTo("plain");
-    assertThat(mediaType.charset().name()).isEqualTo("UTF-8");
-  }
-
-  @Test public void testCharsetAndQuoting() throws Exception {
-    MediaType mediaType = parse(
-        "text/plain;a=\";charset=us-ascii\";charset=\"utf-8\";b=\"iso-8859-1\"");
-    assertThat(mediaType.charset().name()).isEqualTo("UTF-8");
-  }
-
-  @Test public void testDuplicatedCharsets() {
-    MediaType mediaType = parse("text/plain; charset=utf-8; charset=UTF-8");
-    assertThat(mediaType.charset().name()).isEqualTo("UTF-8");
-  }
-
-  @Test public void testMultipleCharsets() {
-    assertInvalid("text/plain; charset=utf-8; charset=utf-16",
-        "Multiple charsets defined: \"utf-8\" and: \"utf-16\" for: \"text/plain; charset=utf-8; charset=utf-16\"");
-  }
-
-  @Test public void testIllegalCharsetName() {
-    MediaType mediaType = parse("text/plain; charset=\"!@#$%^&*()\"");
-    assertThat(mediaType.charset()).isNull();
-  }
-
-  @Test public void testUnsupportedCharset() {
-    MediaType mediaType = parse("text/plain; charset=utf-wtf");
-    assertThat(mediaType.charset()).isNull();
-  }
-
-  /**
-   * This is invalid according to RFC 822. But it's what Chrome does and it avoids a potentially
-   * unpleasant IllegalCharsetNameException.
-   */
-  @Test public void testCharsetNameIsSingleQuoted() throws Exception {
-    MediaType mediaType = parse("text/plain;charset='utf-8'");
-    assertThat(mediaType.charset().name()).isEqualTo("UTF-8");
-  }
-
-  @Test public void testCharsetNameIsDoubleQuotedAndSingleQuoted() throws Exception {
-    MediaType mediaType = parse("text/plain;charset=\"'utf-8'\"");
-    assertThat(mediaType.charset()).isNull();
-  }
-
-  @Test public void testCharsetNameIsDoubleQuotedSingleQuote() throws Exception {
-    MediaType mediaType = parse("text/plain;charset=\"'\"");
-    assertThat(mediaType.charset()).isNull();
-  }
-
-  @Test public void testDefaultCharset() throws Exception {
-    MediaType noCharset = parse("text/plain");
-    assertThat(noCharset.charset(UTF_8).name()).isEqualTo("UTF-8");
-    assertThat(noCharset.charset(Charset.forName("US-ASCII")).name()).isEqualTo("US-ASCII");
-
-    MediaType charset = parse("text/plain; charset=iso-8859-1");
-    assertThat(charset.charset(UTF_8).name()).isEqualTo("ISO-8859-1");
-    assertThat(charset.charset(Charset.forName("US-ASCII")).name()).isEqualTo("ISO-8859-1");
-  }
-
-  @Test public void testParseDanglingSemicolon() throws Exception {
-    MediaType mediaType = parse("text/plain;");
-    assertThat(mediaType.type()).isEqualTo("text");
-    assertThat(mediaType.subtype()).isEqualTo("plain");
-    assertThat(mediaType.charset()).isNull();
-    assertThat(mediaType.toString()).isEqualTo("text/plain;");
-  }
-
-  private void assertMediaType(String string) {
-    assertThat(parse(string).toString()).isEqualTo(string);
-  }
-
-  private void assertInvalid(String string, String exceptionMessage) {
-    if (useGet) {
-      try {
-        parse(string);
-        fail("Expected get of \"" + string + "\" to throw with: " + exceptionMessage);
-      } catch (IllegalArgumentException e) {
-        assertThat(e.getMessage()).isEqualTo(exceptionMessage);
-      }
-    } else {
-      assertThat(parse(string)).overridingErrorMessage(string).isNull();
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java b/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java
deleted file mode 100644
index 00ae7bbdf5..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java
+++ /dev/null
@@ -1,296 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import okio.Buffer;
-import okio.BufferedSink;
-import org.junit.Test;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class MultipartBodyTest {
-  @Test public void onePartRequired() throws Exception {
-    try {
-      new MultipartBody.Builder().build();
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e.getMessage()).isEqualTo("Multipart body must have at least one part.");
-    }
-  }
-
-  @Test public void singlePart() throws Exception {
-    String expected = ""
-        + "--123\r\n"
-        + "Content-Length: 13\r\n"
-        + "\r\n"
-        + "Hello, World!\r\n"
-        + "--123--\r\n";
-
-    MultipartBody body = new MultipartBody.Builder("123")
-        .addPart(RequestBody.create(null, "Hello, World!"))
-        .build();
-
-    assertThat(body.boundary()).isEqualTo("123");
-    assertThat(body.type()).isEqualTo(MultipartBody.MIXED);
-    assertThat(body.contentType().toString()).isEqualTo("multipart/mixed; boundary=123");
-    assertThat(body.parts().size()).isEqualTo(1);
-    assertThat(body.contentLength()).isEqualTo(53);
-
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    assertThat(body.contentLength()).isEqualTo(buffer.size());
-    assertThat(buffer.readUtf8()).isEqualTo(expected);
-  }
-
-  @Test public void threeParts() throws Exception {
-    String expected = ""
-        + "--123\r\n"
-        + "Content-Length: 5\r\n"
-        + "\r\n"
-        + "Quick\r\n"
-        + "--123\r\n"
-        + "Content-Length: 5\r\n"
-        + "\r\n"
-        + "Brown\r\n"
-        + "--123\r\n"
-        + "Content-Length: 3\r\n"
-        + "\r\n"
-        + "Fox\r\n"
-        + "--123--\r\n";
-
-    MultipartBody body = new MultipartBody.Builder("123")
-        .addPart(RequestBody.create(null, "Quick"))
-        .addPart(RequestBody.create(null, "Brown"))
-        .addPart(RequestBody.create(null, "Fox"))
-        .build();
-
-    assertThat(body.boundary()).isEqualTo("123");
-    assertThat(body.type()).isEqualTo(MultipartBody.MIXED);
-    assertThat(body.contentType().toString()).isEqualTo("multipart/mixed; boundary=123");
-    assertThat(body.parts().size()).isEqualTo(3);
-    assertThat(body.contentLength()).isEqualTo(112);
-
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    assertThat(body.contentLength()).isEqualTo(buffer.size());
-    assertThat(buffer.readUtf8()).isEqualTo(expected);
-  }
-
-  @Test public void fieldAndTwoFiles() throws Exception {
-    String expected = ""
-        + "--AaB03x\r\n"
-        + "Content-Disposition: form-data; name=\"submit-name\"\r\n"
-        + "Content-Length: 5\r\n"
-        + "\r\n"
-        + "Larry\r\n"
-        + "--AaB03x\r\n"
-        + "Content-Disposition: form-data; name=\"files\"\r\n"
-        + "Content-Type: multipart/mixed; boundary=BbC04y\r\n"
-        + "Content-Length: 337\r\n"
-        + "\r\n"
-        + "--BbC04y\r\n"
-        + "Content-Disposition: file; filename=\"file1.txt\"\r\n"
-        + "Content-Type: text/plain; charset=utf-8\r\n"
-        + "Content-Length: 29\r\n"
-        + "\r\n"
-        + "... contents of file1.txt ...\r\n"
-        + "--BbC04y\r\n"
-        + "Content-Disposition: file; filename=\"file2.gif\"\r\n"
-        + "Content-Transfer-Encoding: binary\r\n"
-        + "Content-Type: image/gif\r\n"
-        + "Content-Length: 29\r\n"
-        + "\r\n"
-        + "... contents of file2.gif ...\r\n"
-        + "--BbC04y--\r\n"
-        + "\r\n"
-        + "--AaB03x--\r\n";
-
-    MultipartBody body = new MultipartBody.Builder("AaB03x")
-        .setType(MultipartBody.FORM)
-        .addFormDataPart("submit-name", "Larry")
-        .addFormDataPart("files", null,
-            new MultipartBody.Builder("BbC04y")
-                .addPart(
-                    Headers.of("Content-Disposition", "file; filename=\"file1.txt\""),
-                    RequestBody.create(
-                        MediaType.get("text/plain"), "... contents of file1.txt ..."))
-                .addPart(
-                    Headers.of(
-                        "Content-Disposition", "file; filename=\"file2.gif\"",
-                        "Content-Transfer-Encoding", "binary"),
-                    RequestBody.create(
-                        MediaType.get("image/gif"),
-                        "... contents of file2.gif ...".getBytes(UTF_8)))
-                .build())
-        .build();
-
-    assertThat(body.boundary()).isEqualTo("AaB03x");
-    assertThat(body.type()).isEqualTo(MultipartBody.FORM);
-    assertThat(body.contentType().toString()).isEqualTo(
-        "multipart/form-data; boundary=AaB03x");
-    assertThat(body.parts().size()).isEqualTo(2);
-    assertThat(body.contentLength()).isEqualTo(568);
-
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    assertThat(body.contentLength()).isEqualTo(buffer.size());
-    assertThat(buffer.readUtf8()).isEqualTo(expected);
-  }
-
-  @Test public void stringEscapingIsWeird() throws Exception {
-    String expected = ""
-        + "--AaB03x\r\n"
-        + "Content-Disposition: form-data; name=\"field with spaces\"; filename=\"filename with spaces.txt\"\r\n"
-        + "Content-Type: text/plain; charset=utf-8\r\n"
-        + "Content-Length: 4\r\n"
-        + "\r\n"
-        + "okay\r\n"
-        + "--AaB03x\r\n"
-        + "Content-Disposition: form-data; name=\"field with %22\"\r\n"
-        + "Content-Length: 1\r\n"
-        + "\r\n"
-        + "\"\r\n"
-        + "--AaB03x\r\n"
-        + "Content-Disposition: form-data; name=\"field with %22\"\r\n"
-        + "Content-Length: 3\r\n"
-        + "\r\n"
-        + "%22\r\n"
-        + "--AaB03x\r\n"
-        + "Content-Disposition: form-data; name=\"field with \u007e\"\r\n"
-        + "Content-Length: 5\r\n"
-        + "\r\n"
-        + "Alpha\r\n"
-        + "--AaB03x--\r\n";
-
-    MultipartBody body = new MultipartBody.Builder("AaB03x")
-        .setType(MultipartBody.FORM)
-        .addFormDataPart("field with spaces", "filename with spaces.txt",
-            RequestBody.create(MediaType.get("text/plain; charset=utf-8"), "okay"))
-        .addFormDataPart("field with \"", "\"")
-        .addFormDataPart("field with %22", "%22")
-        .addFormDataPart("field with \u007e", "Alpha")
-        .build();
-
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    assertThat(buffer.readUtf8()).isEqualTo(expected);
-  }
-
-  @Test public void streamingPartHasNoLength() throws Exception {
-    class StreamingBody extends RequestBody {
-      private final String body;
-
-      StreamingBody(String body) {
-        this.body = body;
-      }
-
-      @Override public MediaType contentType() {
-        return null;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        sink.writeUtf8(body);
-      }
-    }
-
-    String expected = ""
-        + "--123\r\n"
-        + "Content-Length: 5\r\n"
-        + "\r\n"
-        + "Quick\r\n"
-        + "--123\r\n"
-        + "\r\n"
-        + "Brown\r\n"
-        + "--123\r\n"
-        + "Content-Length: 3\r\n"
-        + "\r\n"
-        + "Fox\r\n"
-        + "--123--\r\n";
-
-    MultipartBody body = new MultipartBody.Builder("123")
-        .addPart(RequestBody.create(null, "Quick"))
-        .addPart(new StreamingBody("Brown"))
-        .addPart(RequestBody.create(null, "Fox"))
-        .build();
-
-    assertThat(body.boundary()).isEqualTo("123");
-    assertThat(body.type()).isEqualTo(MultipartBody.MIXED);
-    assertThat(body.contentType().toString()).isEqualTo("multipart/mixed; boundary=123");
-    assertThat(body.parts().size()).isEqualTo(3);
-    assertThat(body.contentLength()).isEqualTo(-1);
-
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    assertThat(buffer.readUtf8()).isEqualTo(expected);
-  }
-
-  @Test public void contentTypeHeaderIsForbidden() throws Exception {
-    MultipartBody.Builder multipart = new MultipartBody.Builder();
-    try {
-      multipart.addPart(Headers.of("Content-Type", "text/plain"),
-          RequestBody.create(null, "Hello, World!"));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void contentLengthHeaderIsForbidden() throws Exception {
-    MultipartBody.Builder multipart = new MultipartBody.Builder();
-    try {
-      multipart.addPart(Headers.of("Content-Length", "13"),
-          RequestBody.create(null, "Hello, World!"));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void partAccessors() throws IOException {
-    MultipartBody body = new MultipartBody.Builder()
-        .addPart(Headers.of("Foo", "Bar"), RequestBody.create(null, "Baz"))
-        .build();
-    assertThat(body.parts().size()).isEqualTo(1);
-
-    Buffer part1Buffer = new Buffer();
-    MultipartBody.Part part1 = body.part(0);
-    part1.body().writeTo(part1Buffer);
-    assertThat(part1.headers()).isEqualTo(Headers.of("Foo", "Bar"));
-    assertThat(part1Buffer.readUtf8()).isEqualTo("Baz");
-  }
-
-  @Test public void nonAsciiFilename() throws Exception {
-    String expected = ""
-        + "--AaB03x\r\n"
-        + "Content-Disposition: form-data; name=\"attachment\"; filename=\"resum√©.pdf\"\r\n"
-        + "Content-Type: application/pdf; charset=utf-8\r\n"
-        + "Content-Length: 17\r\n"
-        + "\r\n"
-        + "Jesse‚Äôs Resum√©\r\n"
-        + "--AaB03x--\r\n";
-
-    MultipartBody body = new MultipartBody.Builder("AaB03x")
-        .setType(MultipartBody.FORM)
-        .addFormDataPart("attachment", "resum√©.pdf",
-            RequestBody.create(MediaType.parse("application/pdf"), "Jesse‚Äôs Resum√©"))
-        .build();
-
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    assertThat(buffer.readUtf8()).isEqualTo(expected);
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java b/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
deleted file mode 100644
index b999eb285b..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
+++ /dev/null
@@ -1,238 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.net.CookieHandler;
-import java.net.CookieManager;
-import java.net.ProxySelector;
-import java.net.ResponseCache;
-import java.util.Arrays;
-import java.util.concurrent.TimeUnit;
-import javax.net.ssl.SSLSocketFactory;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import static okhttp3.TestUtil.defaultClient;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class OkHttpClientTest {
-  private static final ProxySelector DEFAULT_PROXY_SELECTOR = ProxySelector.getDefault();
-  private static final CookieHandler DEFAULT_COOKIE_HANDLER = CookieManager.getDefault();
-  private static final ResponseCache DEFAULT_RESPONSE_CACHE = ResponseCache.getDefault();
-  private final MockWebServer server = new MockWebServer();
-
-  @Before public void setUp() throws Exception {
-    server.start();
-  }
-
-  @After public void tearDown() throws Exception {
-    server.shutdown();
-    ProxySelector.setDefault(DEFAULT_PROXY_SELECTOR);
-    CookieManager.setDefault(DEFAULT_COOKIE_HANDLER);
-    ResponseCache.setDefault(DEFAULT_RESPONSE_CACHE);
-  }
-
-  @Test public void durationDefaults() {
-    OkHttpClient client = defaultClient();
-    assertThat(client.callTimeoutMillis()).isEqualTo(0);
-    assertThat(client.connectTimeoutMillis()).isEqualTo(10_000);
-    assertThat(client.readTimeoutMillis()).isEqualTo(10_000);
-    assertThat(client.writeTimeoutMillis()).isEqualTo(10_000);
-    assertThat(client.pingIntervalMillis()).isEqualTo(0);
-  }
-
-  @Test public void timeoutValidRange() {
-    OkHttpClient.Builder builder = new OkHttpClient.Builder();
-    try {
-      builder.callTimeout(1, TimeUnit.NANOSECONDS);
-    } catch (IllegalArgumentException ignored) {
-    }
-    try {
-      builder.connectTimeout(1, TimeUnit.NANOSECONDS);
-    } catch (IllegalArgumentException ignored) {
-    }
-    try {
-      builder.writeTimeout(1, TimeUnit.NANOSECONDS);
-    } catch (IllegalArgumentException ignored) {
-    }
-    try {
-      builder.readTimeout(1, TimeUnit.NANOSECONDS);
-    } catch (IllegalArgumentException ignored) {
-    }
-    try {
-      builder.callTimeout(365, TimeUnit.DAYS);
-    } catch (IllegalArgumentException ignored) {
-    }
-    try {
-      builder.connectTimeout(365, TimeUnit.DAYS);
-    } catch (IllegalArgumentException ignored) {
-    }
-    try {
-      builder.writeTimeout(365, TimeUnit.DAYS);
-    } catch (IllegalArgumentException ignored) {
-    }
-    try {
-      builder.readTimeout(365, TimeUnit.DAYS);
-    } catch (IllegalArgumentException ignored) {
-    }
-  }
-
-  @Test public void clonedInterceptorsListsAreIndependent() throws Exception {
-    Interceptor interceptor = chain -> chain.proceed(chain.request());
-    OkHttpClient original = defaultClient();
-    original.newBuilder()
-        .addInterceptor(interceptor)
-        .addNetworkInterceptor(interceptor)
-        .build();
-    assertThat(original.interceptors().size()).isEqualTo(0);
-    assertThat(original.networkInterceptors().size()).isEqualTo(0);
-  }
-
-  /**
-   * When copying the client, stateful things like the connection pool are shared across all
-   * clients.
-   */
-  @Test public void cloneSharesStatefulInstances() throws Exception {
-    OkHttpClient client = defaultClient();
-
-    // Values should be non-null.
-    OkHttpClient a = client.newBuilder().build();
-    assertThat(a.dispatcher()).isNotNull();
-    assertThat(a.connectionPool()).isNotNull();
-    assertThat(a.sslSocketFactory()).isNotNull();
-
-    // Multiple clients share the instances.
-    OkHttpClient b = client.newBuilder().build();
-    assertThat(b.dispatcher()).isSameAs(a.dispatcher());
-    assertThat(b.connectionPool()).isSameAs(a.connectionPool());
-    assertThat(b.sslSocketFactory()).isSameAs(a.sslSocketFactory());
-  }
-
-  @Test public void setProtocolsRejectsHttp10() throws Exception {
-    OkHttpClient.Builder builder = new OkHttpClient.Builder();
-    try {
-      builder.protocols(Arrays.asList(Protocol.HTTP_1_0, Protocol.HTTP_1_1));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void certificatePinnerEquality() {
-    OkHttpClient clientA = TestUtil.defaultClient();
-    OkHttpClient clientB = TestUtil.defaultClient();
-    assertThat(clientB.certificatePinner()).isEqualTo(clientA.certificatePinner());
-  }
-
-  @Test public void nullInterceptor() {
-    OkHttpClient.Builder builder = new OkHttpClient.Builder();
-    try {
-      builder.addInterceptor(null);
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo("interceptor == null");
-    }
-  }
-
-  @Test public void nullNetworkInterceptor() {
-    OkHttpClient.Builder builder = new OkHttpClient.Builder();
-    try {
-      builder.addNetworkInterceptor(null);
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo("interceptor == null");
-    }
-  }
-
-  @Test public void nullInterceptorInList() {
-    OkHttpClient.Builder builder = new OkHttpClient.Builder();
-    builder.interceptors().add(null);
-    try {
-      builder.build();
-      fail();
-    } catch (IllegalStateException expected) {
-      assertThat(expected.getMessage()).isEqualTo("Null interceptor: [null]");
-    }
-  }
-
-  @Test public void nullNetworkInterceptorInList() {
-    OkHttpClient.Builder builder = new OkHttpClient.Builder();
-    builder.networkInterceptors().add(null);
-    try {
-      builder.build();
-      fail();
-    } catch (IllegalStateException expected) {
-      assertThat(expected.getMessage()).isEqualTo("Null network interceptor: [null]");
-    }
-  }
-
-  @Test public void testH2PriorKnowledgeOkHttpClientConstructionFallback() {
-    try {
-      new OkHttpClient.Builder()
-          .protocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.HTTP_1_1));
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          ("protocols containing h2_prior_knowledge cannot use other protocols: "
-            + "[h2_prior_knowledge, http/1.1]"));
-    }
-  }
-
-  @Test public void testH2PriorKnowledgeOkHttpClientConstructionDuplicates() {
-    try {
-      new OkHttpClient.Builder()
-          .protocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.H2_PRIOR_KNOWLEDGE));
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          ("protocols containing h2_prior_knowledge cannot use other protocols: "
-            + "[h2_prior_knowledge, h2_prior_knowledge]"));
-    }
-  }
-
-  @Test public void testH2PriorKnowledgeOkHttpClientConstructionSuccess() {
-    OkHttpClient okHttpClient = new OkHttpClient.Builder()
-        .protocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE))
-        .build();
-    assertThat(okHttpClient.protocols().size()).isEqualTo(1);
-    assertThat(okHttpClient.protocols().get(0)).isEqualTo(Protocol.H2_PRIOR_KNOWLEDGE);
-  }
-
-  @Test public void nullDefaultProxySelector() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    ProxySelector.setDefault(null);
-
-    OkHttpClient client = defaultClient().newBuilder()
-        .build();
-
-    Request request = new Request.Builder().url(server.url("/")).build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("abc");
-  }
-
-  @Test public void sslSocketFactorySetAsSocketFactory() throws Exception {
-    OkHttpClient.Builder builder = new OkHttpClient.Builder();
-    try {
-      builder.socketFactory(SSLSocketFactory.getDefault());
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/ProtocolTest.java b/okhttp-tests/src/test/java/okhttp3/ProtocolTest.java
deleted file mode 100644
index ffced6eacf..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/ProtocolTest.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public class ProtocolTest {
-  @Test
-  public void testGetKnown() throws IOException {
-    assertThat(Protocol.get("http/1.0")).isEqualTo(Protocol.HTTP_1_0);
-    assertThat(Protocol.get("http/1.1")).isEqualTo(Protocol.HTTP_1_1);
-    assertThat(Protocol.get("spdy/3.1")).isEqualTo(Protocol.SPDY_3);
-    assertThat(Protocol.get("h2")).isEqualTo(Protocol.HTTP_2);
-    assertThat(Protocol.get("h2_prior_knowledge")).isEqualTo(Protocol.H2_PRIOR_KNOWLEDGE);
-    assertThat(Protocol.get("quic")).isEqualTo(Protocol.QUIC);
-  }
-
-  @Test(expected = IOException.class)
-  public void testGetUnknown() throws IOException {
-    Protocol.get("tcp");
-  }
-
-  @Test
-  public void testToString() throws IOException {
-    assertThat(Protocol.HTTP_1_0.toString()).isEqualTo("http/1.0");
-    assertThat(Protocol.HTTP_1_1.toString()).isEqualTo("http/1.1");
-    assertThat(Protocol.SPDY_3.toString()).isEqualTo("spdy/3.1");
-    assertThat(Protocol.HTTP_2.toString()).isEqualTo("h2");
-    assertThat(Protocol.H2_PRIOR_KNOWLEDGE.toString()).isEqualTo("h2_prior_knowledge");
-    assertThat(Protocol.QUIC.toString()).isEqualTo("quic");
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java b/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
deleted file mode 100644
index 8d502a0882..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
+++ /dev/null
@@ -1,195 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.text.SimpleDateFormat;
-import java.util.Arrays;
-import java.util.Date;
-import javax.annotation.Nullable;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-/**
- * A received response or failure recorded by the response recorder.
- */
-public final class RecordedResponse {
-  public final Request request;
-  public final @Nullable Response response;
-  public final @Nullable WebSocket webSocket;
-  public final @Nullable String body;
-  public final @Nullable IOException failure;
-
-  public RecordedResponse(Request request, @Nullable Response response,
-      @Nullable WebSocket webSocket, @Nullable String body, @Nullable IOException failure) {
-    this.request = request;
-    this.response = response;
-    this.webSocket = webSocket;
-    this.body = body;
-    this.failure = failure;
-  }
-
-  public RecordedResponse assertRequestUrl(HttpUrl url) {
-    assertThat(request.url()).isEqualTo(url);
-    return this;
-  }
-
-  public RecordedResponse assertRequestMethod(String method) {
-    assertThat(request.method()).isEqualTo(method);
-    return this;
-  }
-
-  public RecordedResponse assertRequestHeader(String name, String... values) {
-    assertThat(request.headers(name)).isEqualTo(Arrays.asList(values));
-    return this;
-  }
-
-  public RecordedResponse assertCode(int expectedCode) {
-    assertThat(response.code()).isEqualTo(expectedCode);
-    return this;
-  }
-
-  public RecordedResponse assertSuccessful() {
-    assertThat(response.isSuccessful()).isTrue();
-    return this;
-  }
-
-  public RecordedResponse assertNotSuccessful() {
-    assertThat(response.isSuccessful()).isFalse();
-    return this;
-  }
-
-  public RecordedResponse assertHeader(String name, String... values) {
-    assertThat(response.headers(name)).isEqualTo(Arrays.asList(values));
-    return this;
-  }
-
-  public RecordedResponse assertHeaders(Headers headers) {
-    assertThat(response.headers()).isEqualTo(headers);
-    return this;
-  }
-
-  public RecordedResponse assertBody(String expectedBody) {
-    assertThat(body).isEqualTo(expectedBody);
-    return this;
-  }
-
-  public RecordedResponse assertHandshake() {
-    Handshake handshake = response.handshake();
-    assertThat(handshake.tlsVersion()).isNotNull();
-    assertThat(handshake.cipherSuite()).isNotNull();
-    assertThat(handshake.peerPrincipal()).isNotNull();
-    assertThat(handshake.peerCertificates().size()).isEqualTo(1);
-    assertThat(handshake.localPrincipal()).isNull();
-    assertThat(handshake.localCertificates().size()).isEqualTo(0);
-    return this;
-  }
-
-  /**
-   * Asserts that the current response was redirected and returns the prior response.
-   */
-  public RecordedResponse priorResponse() {
-    Response priorResponse = response.priorResponse();
-    assertThat(priorResponse).isNotNull();
-    assertThat(priorResponse.body()).isNull();
-    return new RecordedResponse(priorResponse.request(), priorResponse, null, null, null);
-  }
-
-  /**
-   * Asserts that the current response used the network and returns the network response.
-   */
-  public RecordedResponse networkResponse() {
-    Response networkResponse = response.networkResponse();
-    assertThat(networkResponse).isNotNull();
-    assertThat(networkResponse.body()).isNull();
-    return new RecordedResponse(networkResponse.request(), networkResponse, null, null, null);
-  }
-
-  /** Asserts that the current response didn't use the network. */
-  public RecordedResponse assertNoNetworkResponse() {
-    assertThat(response.networkResponse()).isNull();
-    return this;
-  }
-
-  /** Asserts that the current response didn't use the cache. */
-  public RecordedResponse assertNoCacheResponse() {
-    assertThat(response.cacheResponse()).isNull();
-    return this;
-  }
-
-  /**
-   * Asserts that the current response used the cache and returns the cache response.
-   */
-  public RecordedResponse cacheResponse() {
-    Response cacheResponse = response.cacheResponse();
-    assertThat(cacheResponse).isNotNull();
-    assertThat(cacheResponse.body()).isNull();
-    return new RecordedResponse(cacheResponse.request(), cacheResponse, null, null, null);
-  }
-
-  public RecordedResponse assertFailure(Class<?>... allowedExceptionTypes) {
-    boolean found = false;
-    for (Class expectedClass : allowedExceptionTypes) {
-      if (expectedClass.isInstance(failure)) {
-        found = true;
-        break;
-      }
-    }
-    assertThat(found).overridingErrorMessage("Expected exception type among " + Arrays.toString(allowedExceptionTypes)
-            + ", got " + failure).isTrue();
-    return this;
-  }
-
-  public RecordedResponse assertFailure(String... messages) {
-    assertThat(failure).overridingErrorMessage("No failure found").isNotNull();
-    assertThat(Arrays.asList(messages).contains(failure.getMessage())).overridingErrorMessage(
-        failure.getMessage()).isTrue();
-    return this;
-  }
-
-  public RecordedResponse assertFailureMatches(String... patterns) {
-    assertThat(failure).isNotNull();
-    for (String pattern : patterns) {
-      if (failure.getMessage().matches(pattern)) return this;
-    }
-    throw new AssertionError(failure.getMessage());
-  }
-
-  public RecordedResponse assertSentRequestAtMillis(long minimum, long maximum) {
-    assertDateInRange(minimum, response.sentRequestAtMillis(), maximum);
-    return this;
-  }
-
-  public RecordedResponse assertReceivedResponseAtMillis(long minimum, long maximum) {
-    assertDateInRange(minimum, response.receivedResponseAtMillis(), maximum);
-    return this;
-  }
-
-  private void assertDateInRange(long minimum, long actual, long maximum) {
-    assertThat(actual >= minimum).overridingErrorMessage(
-        "actual " + format(actual) + " < minimum " + format(maximum)).isTrue();
-    assertThat(actual <= maximum).overridingErrorMessage(
-        "actual " + format(actual) + " > maximum " + format(minimum)).isTrue();
-  }
-
-  private String format(long time) {
-    return new SimpleDateFormat("HH:mm:ss.SSS").format(new Date(time));
-  }
-
-  public String getBody() {
-    return body;
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/RecordingCallback.java b/okhttp-tests/src/test/java/okhttp3/RecordingCallback.java
deleted file mode 100644
index 56a1d7e003..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/RecordingCallback.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-import java.util.concurrent.TimeUnit;
-
-/**
- * Records received HTTP responses so they can be later retrieved by tests.
- */
-public class RecordingCallback implements Callback {
-  public static final long TIMEOUT_MILLIS = TimeUnit.SECONDS.toMillis(10);
-
-  private final List<RecordedResponse> responses = new ArrayList<>();
-
-  @Override public synchronized void onFailure(Call call, IOException e) {
-    responses.add(new RecordedResponse(call.request(), null, null, null, e));
-    notifyAll();
-  }
-
-  @Override public synchronized void onResponse(Call call, Response response) throws IOException {
-    String body = response.body().string();
-    responses.add(new RecordedResponse(call.request(), response, null, body, null));
-    notifyAll();
-  }
-
-  /**
-   * Returns the recorded response triggered by {@code request}. Throws if the response isn't
-   * enqueued before the timeout.
-   */
-  public synchronized RecordedResponse await(HttpUrl url) throws Exception {
-    long timeoutMillis = TimeUnit.NANOSECONDS.toMillis(System.nanoTime()) + TIMEOUT_MILLIS;
-    while (true) {
-      for (Iterator<RecordedResponse> i = responses.iterator(); i.hasNext(); ) {
-        RecordedResponse recordedResponse = i.next();
-        if (recordedResponse.request.url().equals(url)) {
-          i.remove();
-          return recordedResponse;
-        }
-      }
-
-      long nowMillis = TimeUnit.NANOSECONDS.toMillis(System.nanoTime());
-      if (nowMillis >= timeoutMillis) break;
-      wait(timeoutMillis - nowMillis);
-    }
-
-    throw new AssertionError("Timed out waiting for response to " + url);
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/RecordingEventListener.java b/okhttp-tests/src/test/java/okhttp3/RecordingEventListener.java
deleted file mode 100644
index f3ed94acd9..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/RecordingEventListener.java
+++ /dev/null
@@ -1,439 +0,0 @@
-/*
- * Copyright (C) 2017 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Deque;
-import java.util.List;
-import java.util.concurrent.ConcurrentLinkedDeque;
-import javax.annotation.Nullable;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public final class RecordingEventListener extends EventListener {
-  final Deque<CallEvent> eventSequence = new ConcurrentLinkedDeque<>();
-
-  final List<Object> forbiddenLocks = new ArrayList<>();
-
-  /** Confirm that the thread does not hold a lock on {@code lock} during the callback. */
-  public void forbidLock(Object lock) {
-    forbiddenLocks.add(lock);
-  }
-
-  /**
-   * Removes recorded events up to (and including) an event is found whose class equals
-   * {@code eventClass} and returns it.
-   */
-  public <T> T removeUpToEvent(Class<T> eventClass) {
-    Object event = eventSequence.poll();
-    while (event != null && !eventClass.isInstance(event)) {
-      event = eventSequence.poll();
-    }
-    if (event == null) throw new AssertionError();
-    return eventClass.cast(event);
-  }
-
-  public List<String> recordedEventTypes() {
-    List<String> eventTypes = new ArrayList<>();
-    for (CallEvent event : eventSequence) {
-      eventTypes.add(event.getName());
-    }
-    return eventTypes;
-  }
-
-  public void clearAllEvents() {
-    eventSequence.clear();
-  }
-
-  private void logEvent(CallEvent e) {
-    for (Object lock : forbiddenLocks) {
-      assertThat(Thread.holdsLock(lock)).overridingErrorMessage(lock.toString()).isFalse();
-    }
-
-    CallEvent startEvent = e.closes();
-
-    if (startEvent != null) {
-      assertThat(eventSequence.contains(startEvent)).overridingErrorMessage(
-          e.getName() + " without matching " + startEvent.getName()).isTrue();
-    }
-
-    eventSequence.offer(e);
-  }
-
-  @Override public void dnsStart(Call call, String domainName) {
-    logEvent(new DnsStart(call, domainName));
-  }
-
-  @Override public void dnsEnd(Call call, String domainName, List<InetAddress> inetAddressList) {
-    logEvent(new DnsEnd(call, domainName, inetAddressList));
-  }
-
-  @Override public void connectStart(Call call, InetSocketAddress inetSocketAddress,
-      Proxy proxy) {
-    logEvent(new ConnectStart(call, inetSocketAddress, proxy));
-  }
-
-  @Override public void secureConnectStart(Call call) {
-    logEvent(new SecureConnectStart(call));
-  }
-
-  @Override public void secureConnectEnd(Call call, Handshake handshake) {
-    logEvent(new SecureConnectEnd(call, handshake));
-  }
-
-  @Override public void connectEnd(Call call, InetSocketAddress inetSocketAddress,
-      @Nullable Proxy proxy, Protocol protocol) {
-    logEvent(new ConnectEnd(call, inetSocketAddress, proxy, protocol));
-  }
-
-  @Override public void connectFailed(Call call, InetSocketAddress inetSocketAddress, Proxy proxy,
-      @Nullable Protocol protocol, IOException ioe) {
-    logEvent(new ConnectFailed(call, inetSocketAddress, proxy, protocol, ioe));
-  }
-
-  @Override public void connectionAcquired(Call call, Connection connection) {
-    logEvent(new ConnectionAcquired(call, connection));
-  }
-
-  @Override public void connectionReleased(Call call, Connection connection) {
-    logEvent(new ConnectionReleased(call, connection));
-  }
-
-  @Override public void callStart(Call call) {
-    logEvent(new CallStart(call));
-  }
-
-  @Override public void requestHeadersStart(Call call) {
-    logEvent(new RequestHeadersStart(call));
-  }
-
-  @Override public void requestHeadersEnd(Call call, Request request) {
-    logEvent(new RequestHeadersEnd(call, request.headers.byteCount()));
-  }
-
-  @Override public void requestBodyStart(Call call) {
-    logEvent(new RequestBodyStart(call));
-  }
-
-  @Override public void requestBodyEnd(Call call, long byteCount) {
-    logEvent(new RequestBodyEnd(call, byteCount));
-  }
-
-  @Override public void requestFailed(Call call, IOException ioe) {
-    logEvent(new RequestFailed(call, ioe));
-  }
-
-  @Override public void responseHeadersStart(Call call) {
-    logEvent(new ResponseHeadersStart(call));
-  }
-
-  @Override public void responseHeadersEnd(Call call, Response response) {
-    logEvent(new ResponseHeadersEnd(call, response.headers.byteCount()));
-  }
-
-  @Override public void responseBodyStart(Call call) {
-    logEvent(new ResponseBodyStart(call));
-  }
-
-  @Override public void responseBodyEnd(Call call, long byteCount) {
-    logEvent(new ResponseBodyEnd(call, byteCount));
-  }
-
-  @Override public void responseFailed(Call call, IOException ioe) {
-    logEvent(new ResponseFailed(call, ioe));
-  }
-
-  @Override public void callEnd(Call call) {
-    logEvent(new CallEnd(call));
-  }
-
-  @Override public void callFailed(Call call, IOException ioe) {
-    logEvent(new CallFailed(call, ioe));
-  }
-
-  static class CallEvent {
-    final Call call;
-    final List<Object> params;
-
-    CallEvent(Call call, Object... params) {
-      this.call = call;
-      this.params = Arrays.asList(params);
-    }
-
-    public String getName() {
-      return getClass().getSimpleName();
-    }
-
-    @Override public boolean equals(Object o) {
-      if (this == o) return true;
-      if (!(o instanceof CallEvent)) return false;
-
-      CallEvent callEvent = (CallEvent) o;
-
-      if (!getName().equals(callEvent.getName())) return false;
-      if (!call.equals(callEvent.call)) return false;
-      return params.equals(callEvent.params);
-    }
-
-    @Override public int hashCode() {
-      int result = call.hashCode();
-      result = 31 * result + getName().hashCode();
-      result = 31 * result + params.hashCode();
-      return result;
-    }
-
-    public @Nullable CallEvent closes() {
-      return null;
-    }
-  }
-
-  static final class DnsStart extends CallEvent {
-    final String domainName;
-
-    DnsStart(Call call, String domainName) {
-      super(call, domainName);
-      this.domainName = domainName;
-    }
-  }
-
-  static final class DnsEnd extends CallEvent {
-    final String domainName;
-    final List<InetAddress> inetAddressList;
-
-    DnsEnd(Call call, String domainName, List<InetAddress> inetAddressList) {
-      super(call, domainName, inetAddressList);
-      this.domainName = domainName;
-      this.inetAddressList = inetAddressList;
-    }
-
-    @Override public @Nullable CallEvent closes() {
-      return new DnsStart(call, domainName);
-    }
-  }
-
-  static final class ConnectStart extends CallEvent {
-    final InetSocketAddress inetSocketAddress;
-    final Proxy proxy;
-
-    ConnectStart(Call call, InetSocketAddress inetSocketAddress, Proxy proxy) {
-      super(call, inetSocketAddress, proxy);
-      this.inetSocketAddress = inetSocketAddress;
-      this.proxy = proxy;
-    }
-  }
-
-  static final class ConnectEnd extends CallEvent {
-    final InetSocketAddress inetSocketAddress;
-    final Protocol protocol;
-    final Proxy proxy;
-
-    ConnectEnd(Call call, InetSocketAddress inetSocketAddress, Proxy proxy, Protocol protocol) {
-      super(call, inetSocketAddress, proxy, protocol);
-      this.inetSocketAddress = inetSocketAddress;
-      this.proxy = proxy;
-      this.protocol = protocol;
-    }
-
-    @Override public CallEvent closes() {
-      return new ConnectStart(call, inetSocketAddress, proxy);
-    }
-  }
-
-  static final class ConnectFailed extends CallEvent {
-    final InetSocketAddress inetSocketAddress;
-    final Protocol protocol;
-    final Proxy proxy;
-    final IOException ioe;
-
-    ConnectFailed(Call call, InetSocketAddress inetSocketAddress, Proxy proxy, Protocol protocol,
-        IOException ioe) {
-      super(call, inetSocketAddress, proxy, protocol, ioe);
-      this.inetSocketAddress = inetSocketAddress;
-      this.proxy = proxy;
-      this.protocol = protocol;
-      this.ioe = ioe;
-    }
-
-    @Override public @Nullable CallEvent closes() {
-      return new ConnectStart(call, inetSocketAddress, proxy);
-    }
-  }
-
-  static final class SecureConnectStart extends CallEvent {
-    SecureConnectStart(Call call) {
-      super(call);
-    }
-  }
-
-  static final class SecureConnectEnd extends CallEvent {
-    final Handshake handshake;
-
-    SecureConnectEnd(Call call, Handshake handshake) {
-      super(call, handshake);
-      this.handshake = handshake;
-    }
-
-    @Override public @Nullable CallEvent closes() {
-      return new SecureConnectStart(call);
-    }
-  }
-
-  static final class ConnectionAcquired extends CallEvent {
-    final Connection connection;
-
-    ConnectionAcquired(Call call, Connection connection) {
-      super(call, connection);
-      this.connection = connection;
-    }
-  }
-
-  static final class ConnectionReleased extends CallEvent {
-    final Connection connection;
-
-    ConnectionReleased(Call call, Connection connection) {
-      super(call, connection);
-      this.connection = connection;
-    }
-
-    @Override public @Nullable CallEvent closes() {
-      return new ConnectionAcquired(call, connection);
-    }
-  }
-
-  static final class CallStart extends CallEvent {
-    CallStart(Call call) {
-      super(call);
-    }
-  }
-
-  static final class CallEnd extends CallEvent {
-    CallEnd(Call call) {
-      super(call);
-    }
-
-    @Override public @Nullable CallEvent closes() {
-      return new CallStart(call);
-    }
-  }
-
-  static final class CallFailed extends CallEvent {
-    final IOException ioe;
-
-    CallFailed(Call call, IOException ioe) {
-      super(call, ioe);
-      this.ioe = ioe;
-    }
-  }
-
-  static final class RequestHeadersStart extends CallEvent {
-    RequestHeadersStart(Call call) {
-      super(call);
-    }
-  }
-
-  static final class RequestHeadersEnd extends CallEvent {
-    final long headerLength;
-
-    RequestHeadersEnd(Call call, long headerLength) {
-      super(call, headerLength);
-      this.headerLength = headerLength;
-    }
-
-    @Override public @Nullable CallEvent closes() {
-      return new RequestHeadersStart(call);
-    }
-  }
-
-  static final class RequestBodyStart extends CallEvent {
-    RequestBodyStart(Call call) {
-      super(call);
-    }
-  }
-
-  static final class RequestBodyEnd extends CallEvent {
-    final long bytesWritten;
-
-    RequestBodyEnd(Call call, long bytesWritten) {
-      super(call, bytesWritten);
-      this.bytesWritten = bytesWritten;
-    }
-
-    @Override public @Nullable CallEvent closes() {
-      return new RequestBodyStart(call);
-    }
-  }
-
-  static final class RequestFailed extends CallEvent {
-    final IOException ioe;
-
-    RequestFailed(Call call, IOException ioe) {
-      super(call, ioe);
-      this.ioe = ioe;
-    }
-  }
-
-  static final class ResponseHeadersStart extends CallEvent {
-    ResponseHeadersStart(Call call) {
-      super(call);
-    }
-  }
-
-  static final class ResponseHeadersEnd extends CallEvent {
-    final long headerLength;
-
-    ResponseHeadersEnd(Call call, long headerLength) {
-      super(call, headerLength);
-      this.headerLength = headerLength;
-    }
-
-    @Override public @Nullable CallEvent closes() {
-      return new RequestHeadersStart(call);
-    }
-  }
-
-  static final class ResponseBodyStart extends CallEvent {
-    ResponseBodyStart(Call call) {
-      super(call);
-    }
-  }
-
-  static final class ResponseBodyEnd extends CallEvent {
-    final long bytesRead;
-
-    ResponseBodyEnd(Call call, long bytesRead) {
-      super(call, bytesRead);
-      this.bytesRead = bytesRead;
-    }
-
-    @Override public @Nullable CallEvent closes() {
-      return new ResponseBodyStart(call);
-    }
-  }
-
-  static final class ResponseFailed extends CallEvent {
-    final IOException ioe;
-
-    ResponseFailed(Call call, IOException ioe) {
-      super(call, ioe);
-      this.ioe = ioe;
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/RecordingWebSocketListener.java b/okhttp-tests/src/test/java/okhttp3/RecordingWebSocketListener.java
deleted file mode 100644
index 45a13c4786..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/RecordingWebSocketListener.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import javax.annotation.Nullable;
-import okio.ByteString;
-
-public final class RecordingWebSocketListener extends WebSocketListener {
-  @Override public void onOpen(WebSocket webSocket, Response response) {
-    // TODO
-  }
-
-  @Override public void onMessage(WebSocket webSocket, String text) {
-    // TODO
-  }
-
-  @Override public void onMessage(WebSocket webSocket, ByteString bytes) {
-    // TODO
-  }
-
-  @Override public void onClosing(WebSocket webSocket, int code, String reason) {
-    // TODO
-  }
-
-  @Override public void onClosed(WebSocket webSocket, int code, String reason) {
-    // TODO
-  }
-
-  @Override public void onFailure(WebSocket webSocket, Throwable t, @Nullable Response response) {
-    // TODO
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/RequestTest.java b/okhttp-tests/src/test/java/okhttp3/RequestTest.java
deleted file mode 100644
index c16c441396..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/RequestTest.java
+++ /dev/null
@@ -1,359 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.File;
-import java.io.FileWriter;
-import java.io.IOException;
-import java.net.URI;
-import java.util.UUID;
-import okio.Buffer;
-import org.junit.Test;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class RequestTest {
-  @Test public void string() throws Exception {
-    MediaType contentType = MediaType.get("text/plain; charset=utf-8");
-    RequestBody body = RequestBody.create(contentType, "abc".getBytes(UTF_8));
-    assertThat(body.contentType()).isEqualTo(contentType);
-    assertThat(body.contentLength()).isEqualTo(3);
-    assertThat(bodyToHex(body)).isEqualTo("616263");
-    assertThat(bodyToHex(body)).overridingErrorMessage("Retransmit body").isEqualTo(
-        "616263");
-  }
-
-  @Test public void stringWithDefaultCharsetAdded() throws Exception {
-    MediaType contentType = MediaType.get("text/plain");
-    RequestBody body = RequestBody.create(contentType, "\u0800");
-    assertThat(body.contentType()).isEqualTo(MediaType.get("text/plain; charset=utf-8"));
-    assertThat(body.contentLength()).isEqualTo(3);
-    assertThat(bodyToHex(body)).isEqualTo("e0a080");
-  }
-
-  @Test public void stringWithNonDefaultCharsetSpecified() throws Exception {
-    MediaType contentType = MediaType.get("text/plain; charset=utf-16be");
-    RequestBody body = RequestBody.create(contentType, "\u0800");
-    assertThat(body.contentType()).isEqualTo(contentType);
-    assertThat(body.contentLength()).isEqualTo(2);
-    assertThat(bodyToHex(body)).isEqualTo("0800");
-  }
-
-  @Test public void byteArray() throws Exception {
-    MediaType contentType = MediaType.get("text/plain");
-    RequestBody body = RequestBody.create(contentType, "abc".getBytes(UTF_8));
-    assertThat(body.contentType()).isEqualTo(contentType);
-    assertThat(body.contentLength()).isEqualTo(3);
-    assertThat(bodyToHex(body)).isEqualTo("616263");
-    assertThat(bodyToHex(body)).overridingErrorMessage("Retransmit body").isEqualTo(
-        "616263");
-  }
-
-  @Test public void byteArrayRange() throws Exception {
-    MediaType contentType = MediaType.get("text/plain");
-    RequestBody body = RequestBody.create(contentType, ".abcd".getBytes(UTF_8), 1, 3);
-    assertThat(body.contentType()).isEqualTo(contentType);
-    assertThat(body.contentLength()).isEqualTo(3);
-    assertThat(bodyToHex(body)).isEqualTo("616263");
-    assertThat(bodyToHex(body)).overridingErrorMessage("Retransmit body").isEqualTo(
-        "616263");
-  }
-
-  @Test public void file() throws Exception {
-    File file = File.createTempFile("RequestTest", "tmp");
-    FileWriter writer = new FileWriter(file);
-    writer.write("abc");
-    writer.close();
-
-    MediaType contentType = MediaType.get("text/plain");
-    RequestBody body = RequestBody.create(contentType, file);
-    assertThat(body.contentType()).isEqualTo(contentType);
-    assertThat(body.contentLength()).isEqualTo(3);
-    assertThat(bodyToHex(body)).isEqualTo("616263");
-    assertThat(bodyToHex(body)).overridingErrorMessage("Retransmit body").isEqualTo(
-        "616263");
-  }
-
-  /** Common verbs used for apis such as GitHub, AWS, and Google Cloud. */
-  @Test public void crudVerbs() throws IOException {
-    MediaType contentType = MediaType.get("application/json");
-    RequestBody body = RequestBody.create(contentType, "{}");
-
-    Request get = new Request.Builder().url("http://localhost/api").get().build();
-    assertThat(get.method()).isEqualTo("GET");
-    assertThat(get.body()).isNull();
-
-    Request head = new Request.Builder().url("http://localhost/api").head().build();
-    assertThat(head.method()).isEqualTo("HEAD");
-    assertThat(head.body()).isNull();
-
-    Request delete = new Request.Builder().url("http://localhost/api").delete().build();
-    assertThat(delete.method()).isEqualTo("DELETE");
-    assertThat(delete.body().contentLength()).isEqualTo(0L);
-
-    Request post = new Request.Builder().url("http://localhost/api").post(body).build();
-    assertThat(post.method()).isEqualTo("POST");
-    assertThat(post.body()).isEqualTo(body);
-
-    Request put = new Request.Builder().url("http://localhost/api").put(body).build();
-    assertThat(put.method()).isEqualTo("PUT");
-    assertThat(put.body()).isEqualTo(body);
-
-    Request patch = new Request.Builder().url("http://localhost/api").patch(body).build();
-    assertThat(patch.method()).isEqualTo("PATCH");
-    assertThat(patch.body()).isEqualTo(body);
-  }
-
-  @Test public void uninitializedURI() throws Exception {
-    Request request = new Request.Builder().url("http://localhost/api").build();
-    assertThat(request.url().uri()).isEqualTo(new URI("http://localhost/api"));
-    assertThat(request.url()).isEqualTo(HttpUrl.get("http://localhost/api"));
-  }
-
-  @Test public void newBuilderUrlResetsUrl() {
-    Request requestWithoutCache = new Request.Builder().url("http://localhost/api").build();
-    Request builtRequestWithoutCache =
-        requestWithoutCache.newBuilder().url("http://localhost/api/foo").build();
-    assertThat(builtRequestWithoutCache.url()).isEqualTo(
-        HttpUrl.get("http://localhost/api/foo"));
-
-    Request requestWithCache = new Request.Builder().url("http://localhost/api").build();
-    // cache url object
-    requestWithCache.url();
-    Request builtRequestWithCache = requestWithCache.newBuilder().url(
-        "http://localhost/api/foo").build();
-    assertThat(builtRequestWithCache.url()).isEqualTo(
-        HttpUrl.get("http://localhost/api/foo"));
-  }
-
-  @Test public void cacheControl() {
-    Request request = new Request.Builder()
-        .cacheControl(new CacheControl.Builder().noCache().build())
-        .url("https://square.com")
-        .build();
-    assertThat(request.headers("Cache-Control")).containsExactly("no-cache");
-  }
-
-  @Test public void emptyCacheControlClearsAllCacheControlHeaders() {
-    Request request = new Request.Builder()
-        .header("Cache-Control", "foo")
-        .cacheControl(new CacheControl.Builder().build())
-        .url("https://square.com")
-        .build();
-    assertThat(request.headers("Cache-Control")).isEmpty();
-  }
-
-  @Test public void headerAcceptsPermittedCharacters() {
-    Request.Builder builder = new Request.Builder();
-    builder.header("AZab09~", "AZab09 ~");
-    builder.addHeader("AZab09~", "AZab09 ~");
-  }
-
-  @Test public void emptyNameForbidden() {
-    Request.Builder builder = new Request.Builder();
-    try {
-      builder.header("", "Value");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      builder.addHeader("", "Value");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void headerForbidsNullArguments() {
-    Request.Builder builder = new Request.Builder();
-    try {
-      builder.header(null, "Value");
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    try {
-      builder.addHeader(null, "Value");
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    try {
-      builder.header("Name", null);
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    try {
-      builder.addHeader("Name", null);
-      fail();
-    } catch (NullPointerException expected) {
-    }
-  }
-
-  @Test public void headerAllowsTabOnlyInValues() {
-    Request.Builder builder = new Request.Builder();
-    builder.header("key", "sample\tvalue");
-    try {
-      builder.header("sample\tkey", "value");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void headerForbidsControlCharacters() {
-    assertForbiddenHeader("\u0000");
-    assertForbiddenHeader("\r");
-    assertForbiddenHeader("\n");
-    assertForbiddenHeader("\u001f");
-    assertForbiddenHeader("\u007f");
-    assertForbiddenHeader("\u0080");
-    assertForbiddenHeader("\ud83c\udf69");
-  }
-
-  private void assertForbiddenHeader(String s) {
-    Request.Builder builder = new Request.Builder();
-    try {
-      builder.header(s, "Value");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      builder.addHeader(s, "Value");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      builder.header("Name", s);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      builder.addHeader("Name", s);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void noTag() {
-    Request request = new Request.Builder()
-        .url("https://square.com")
-        .build();
-    assertThat(request.tag()).isNull();
-    assertThat(request.tag(Object.class)).isNull();
-    assertThat(request.tag(UUID.class)).isNull();
-    assertThat(request.tag(String.class)).isNull();
-  }
-
-  @Test public void defaultTag() {
-    UUID tag = UUID.randomUUID();
-    Request request = new Request.Builder()
-        .url("https://square.com")
-        .tag(tag)
-        .build();
-    assertThat(request.tag()).isSameAs(tag);
-    assertThat(request.tag(Object.class)).isSameAs(tag);
-    assertThat(request.tag(UUID.class)).isNull();
-    assertThat(request.tag(String.class)).isNull();
-  }
-
-  @Test public void nullRemovesTag() {
-    Request request = new Request.Builder()
-        .url("https://square.com")
-        .tag("a")
-        .tag(null)
-        .build();
-    assertThat(request.tag()).isNull();
-  }
-
-  @Test public void removeAbsentTag() {
-    Request request = new Request.Builder()
-        .url("https://square.com")
-        .tag(null)
-        .build();
-    assertThat(request.tag()).isNull();
-  }
-
-  @Test public void objectTag() {
-    UUID tag = UUID.randomUUID();
-    Request request = new Request.Builder()
-        .url("https://square.com")
-        .tag(Object.class, tag)
-        .build();
-    assertThat(request.tag()).isSameAs(tag);
-    assertThat(request.tag(Object.class)).isSameAs(tag);
-    assertThat(request.tag(UUID.class)).isNull();
-    assertThat(request.tag(String.class)).isNull();
-  }
-
-  @Test public void typedTag() {
-    UUID uuidTag = UUID.randomUUID();
-    Request request = new Request.Builder()
-        .url("https://square.com")
-        .tag(UUID.class, uuidTag)
-        .build();
-    assertThat(request.tag()).isNull();
-    assertThat(request.tag(Object.class)).isNull();
-    assertThat(request.tag(UUID.class)).isSameAs(uuidTag);
-    assertThat(request.tag(String.class)).isNull();
-  }
-
-  @Test public void replaceOnlyTag() {
-    UUID uuidTag1 = UUID.randomUUID();
-    UUID uuidTag2 = UUID.randomUUID();
-    Request request = new Request.Builder()
-        .url("https://square.com")
-        .tag(UUID.class, uuidTag1)
-        .tag(UUID.class, uuidTag2)
-        .build();
-    assertThat(request.tag(UUID.class)).isSameAs(uuidTag2);
-  }
-
-  @Test public void multipleTags() {
-    UUID uuidTag = UUID.randomUUID();
-    String stringTag = "dilophosaurus";
-    Long longTag = 20170815L;
-    Object objectTag = new Object();
-    Request request = new Request.Builder()
-        .url("https://square.com")
-        .tag(Object.class, objectTag)
-        .tag(UUID.class, uuidTag)
-        .tag(String.class, stringTag)
-        .tag(Long.class, longTag)
-        .build();
-    assertThat(request.tag()).isSameAs(objectTag);
-    assertThat(request.tag(Object.class)).isSameAs(objectTag);
-    assertThat(request.tag(UUID.class)).isSameAs(uuidTag);
-    assertThat(request.tag(String.class)).isSameAs(stringTag);
-    assertThat(request.tag(Long.class)).isSameAs(longTag);
-  }
-
-  /** Confirm that we don't accidentally share the backing map between objects. */
-  @Test public void tagsAreImmutable() {
-    Request.Builder builder = new Request.Builder()
-        .url("https://square.com");
-    Request requestA = builder.tag(String.class, "a").build();
-    Request requestB = builder.tag(String.class, "b").build();
-    Request requestC = requestA.newBuilder().tag(String.class, "c").build();
-    assertThat(requestA.tag(String.class)).isSameAs("a");
-    assertThat(requestB.tag(String.class)).isSameAs("b");
-    assertThat(requestC.tag(String.class)).isSameAs("c");
-  }
-
-  private String bodyToHex(RequestBody body) throws IOException {
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    return buffer.readByteString().hex();
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java b/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java
deleted file mode 100644
index cced85f93a..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java
+++ /dev/null
@@ -1,414 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.Reader;
-import java.util.concurrent.atomic.AtomicBoolean;
-import okio.Buffer;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.ForwardingSource;
-import okio.Okio;
-import org.junit.Test;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class ResponseBodyTest {
-  @Test public void stringEmpty() throws IOException {
-    ResponseBody body = body("");
-    assertThat(body.string()).isEqualTo("");
-  }
-
-  @Test public void stringLooksLikeBomButTooShort() throws IOException {
-    ResponseBody body = body("000048");
-    assertThat(body.string()).isEqualTo("\0\0H");
-  }
-
-  @Test public void stringDefaultsToUtf8() throws IOException {
-    ResponseBody body = body("68656c6c6f");
-    assertThat(body.string()).isEqualTo("hello");
-  }
-
-  @Test public void stringExplicitCharset() throws IOException {
-    ResponseBody body = body("00000068000000650000006c0000006c0000006f", "utf-32be");
-    assertThat(body.string()).isEqualTo("hello");
-  }
-
-  @Test public void stringBomOverridesExplicitCharset() throws IOException {
-    ResponseBody body = body("0000ffff00000068000000650000006c0000006c0000006f", "utf-8");
-    assertThat(body.string()).isEqualTo("hello");
-  }
-
-  @Test public void stringBomUtf8() throws IOException {
-    ResponseBody body = body("efbbbf68656c6c6f");
-    assertThat(body.string()).isEqualTo("hello");
-  }
-
-  @Test public void stringBomUtf16Be() throws IOException {
-    ResponseBody body = body("feff00680065006c006c006f");
-    assertThat(body.string()).isEqualTo("hello");
-  }
-
-  @Test public void stringBomUtf16Le() throws IOException {
-    ResponseBody body = body("fffe680065006c006c006f00");
-    assertThat(body.string()).isEqualTo("hello");
-  }
-
-  @Test public void stringBomUtf32Be() throws IOException {
-    ResponseBody body = body("0000ffff00000068000000650000006c0000006c0000006f");
-    assertThat(body.string()).isEqualTo("hello");
-  }
-
-  @Test public void stringBomUtf32Le() throws IOException {
-    ResponseBody body = body("ffff000068000000650000006c0000006c0000006f000000");
-    assertThat(body.string()).isEqualTo("hello");
-  }
-
-  @Test public void stringClosesUnderlyingSource() throws IOException {
-    final AtomicBoolean closed = new AtomicBoolean();
-    ResponseBody body = new ResponseBody() {
-      @Override public MediaType contentType() {
-        return null;
-      }
-
-      @Override public long contentLength() {
-        return 5;
-      }
-
-      @Override public BufferedSource source() {
-        Buffer source = new Buffer().writeUtf8("hello");
-        return Okio.buffer(new ForwardingSource(source) {
-          @Override public void close() throws IOException {
-            closed.set(true);
-            super.close();
-          }
-        });
-      }
-    };
-    assertThat(body.string()).isEqualTo("hello");
-    assertThat(closed.get()).isTrue();
-  }
-
-  @Test public void readerEmpty() throws IOException {
-    ResponseBody body = body("");
-    assertThat(exhaust(body.charStream())).isEqualTo("");
-  }
-
-  @Test public void readerLooksLikeBomButTooShort() throws IOException {
-    ResponseBody body = body("000048");
-    assertThat(exhaust(body.charStream())).isEqualTo("\0\0H");
-  }
-
-  @Test public void readerDefaultsToUtf8() throws IOException {
-    ResponseBody body = body("68656c6c6f");
-    assertThat(exhaust(body.charStream())).isEqualTo("hello");
-  }
-
-  @Test public void readerExplicitCharset() throws IOException {
-    ResponseBody body = body("00000068000000650000006c0000006c0000006f", "utf-32be");
-    assertThat(exhaust(body.charStream())).isEqualTo("hello");
-  }
-
-  @Test public void readerBomUtf8() throws IOException {
-    ResponseBody body = body("efbbbf68656c6c6f");
-    assertThat(exhaust(body.charStream())).isEqualTo("hello");
-  }
-
-  @Test public void readerBomUtf16Be() throws IOException {
-    ResponseBody body = body("feff00680065006c006c006f");
-    assertThat(exhaust(body.charStream())).isEqualTo("hello");
-  }
-
-  @Test public void readerBomUtf16Le() throws IOException {
-    ResponseBody body = body("fffe680065006c006c006f00");
-    assertThat(exhaust(body.charStream())).isEqualTo("hello");
-  }
-
-  @Test public void readerBomUtf32Be() throws IOException {
-    ResponseBody body = body("0000ffff00000068000000650000006c0000006c0000006f");
-    assertThat(exhaust(body.charStream())).isEqualTo("hello");
-  }
-
-  @Test public void readerBomUtf32Le() throws IOException {
-    ResponseBody body = body("ffff000068000000650000006c0000006c0000006f000000");
-    assertThat(exhaust(body.charStream())).isEqualTo("hello");
-  }
-
-  @Test public void readerClosedBeforeBomClosesUnderlyingSource() throws IOException {
-    final AtomicBoolean closed = new AtomicBoolean();
-    ResponseBody body = new ResponseBody() {
-      @Override public MediaType contentType() {
-        return null;
-      }
-
-      @Override public long contentLength() {
-        return 5;
-      }
-
-      @Override public BufferedSource source() {
-        ResponseBody body = body("fffe680065006c006c006f00");
-        return Okio.buffer(new ForwardingSource(body.source()) {
-          @Override public void close() throws IOException {
-            closed.set(true);
-            super.close();
-          }
-        });
-      }
-    };
-    body.charStream().close();
-    assertThat(closed.get()).isTrue();
-  }
-
-  @Test public void readerClosedAfterBomClosesUnderlyingSource() throws IOException {
-    final AtomicBoolean closed = new AtomicBoolean();
-    ResponseBody body = new ResponseBody() {
-      @Override public MediaType contentType() {
-        return null;
-      }
-
-      @Override public long contentLength() {
-        return 5;
-      }
-
-      @Override public BufferedSource source() {
-        ResponseBody body = body("fffe680065006c006c006f00");
-        return Okio.buffer(new ForwardingSource(body.source()) {
-          @Override public void close() throws IOException {
-            closed.set(true);
-            super.close();
-          }
-        });
-      }
-    };
-    Reader reader = body.charStream();
-    assertThat(reader.read()).isEqualTo('h');
-    reader.close();
-    assertThat(closed.get()).isTrue();
-  }
-
-  @Test public void sourceEmpty() throws IOException {
-    ResponseBody body = body("");
-    BufferedSource source = body.source();
-    assertThat(source.exhausted()).isTrue();
-    assertThat(source.readUtf8()).isEqualTo("");
-  }
-
-  @Test public void sourceSeesBom() throws IOException {
-    ResponseBody body = body("efbbbf68656c6c6f");
-    BufferedSource source = body.source();
-    assertThat((source.readByte() & 0xff)).isEqualTo(0xef);
-    assertThat((source.readByte() & 0xff)).isEqualTo(0xbb);
-    assertThat((source.readByte() & 0xff)).isEqualTo(0xbf);
-    assertThat(source.readUtf8()).isEqualTo("hello");
-  }
-
-  @Test public void sourceClosesUnderlyingSource() throws IOException {
-    final AtomicBoolean closed = new AtomicBoolean();
-    ResponseBody body = new ResponseBody() {
-      @Override public MediaType contentType() {
-        return null;
-      }
-
-      @Override public long contentLength() {
-        return 5;
-      }
-
-      @Override public BufferedSource source() {
-        Buffer source = new Buffer().writeUtf8("hello");
-        return Okio.buffer(new ForwardingSource(source) {
-          @Override public void close() throws IOException {
-            closed.set(true);
-            super.close();
-          }
-        });
-      }
-    };
-    body.source().close();
-    assertThat(closed.get()).isTrue();
-  }
-
-  @Test public void bytesEmpty() throws IOException {
-    ResponseBody body = body("");
-    assertThat(body.bytes().length).isEqualTo(0);
-  }
-
-  @Test public void bytesSeesBom() throws IOException {
-    ResponseBody body = body("efbbbf68656c6c6f");
-    byte[] bytes = body.bytes();
-    assertThat((bytes[0] & 0xff)).isEqualTo(0xef);
-    assertThat((bytes[1] & 0xff)).isEqualTo(0xbb);
-    assertThat((bytes[2] & 0xff)).isEqualTo(0xbf);
-    assertThat(new String(bytes, 3, 5, UTF_8)).isEqualTo("hello");
-  }
-
-  @Test public void bytesClosesUnderlyingSource() throws IOException {
-    final AtomicBoolean closed = new AtomicBoolean();
-    ResponseBody body = new ResponseBody() {
-      @Override public MediaType contentType() {
-        return null;
-      }
-
-      @Override public long contentLength() {
-        return 5;
-      }
-
-      @Override public BufferedSource source() {
-        Buffer source = new Buffer().writeUtf8("hello");
-        return Okio.buffer(new ForwardingSource(source) {
-          @Override public void close() throws IOException {
-            closed.set(true);
-            super.close();
-          }
-        });
-      }
-    };
-    assertThat(body.bytes().length).isEqualTo(5);
-    assertThat(closed.get()).isTrue();
-  }
-
-  @Test public void bytesThrowsWhenLengthsDisagree() {
-    ResponseBody body = new ResponseBody() {
-      @Override public MediaType contentType() {
-        return null;
-      }
-
-      @Override public long contentLength() {
-        return 10;
-      }
-
-      @Override public BufferedSource source() {
-        return new Buffer().writeUtf8("hello");
-      }
-    };
-    try {
-      body.bytes();
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo(
-          "Content-Length (10) and stream length (5) disagree");
-    }
-  }
-
-  @Test public void bytesThrowsMoreThanIntMaxValue() {
-    ResponseBody body = new ResponseBody() {
-      @Override public MediaType contentType() {
-        return null;
-      }
-
-      @Override public long contentLength() {
-        return Integer.MAX_VALUE + 1L;
-      }
-
-      @Override public BufferedSource source() {
-        throw new AssertionError();
-      }
-    };
-    try {
-      body.bytes();
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo(
-          "Cannot buffer entire body for content length: 2147483648");
-    }
-  }
-
-  @Test public void byteStreamEmpty() throws IOException {
-    ResponseBody body = body("");
-    InputStream bytes = body.byteStream();
-    assertThat(bytes.read()).isEqualTo(-1);
-  }
-
-  @Test public void byteStreamSeesBom() throws IOException {
-    ResponseBody body = body("efbbbf68656c6c6f");
-    InputStream bytes = body.byteStream();
-    assertThat(bytes.read()).isEqualTo(0xef);
-    assertThat(bytes.read()).isEqualTo(0xbb);
-    assertThat(bytes.read()).isEqualTo(0xbf);
-    assertThat(exhaust(new InputStreamReader(bytes, UTF_8))).isEqualTo("hello");
-  }
-
-  @Test public void byteStreamClosesUnderlyingSource() throws IOException {
-    final AtomicBoolean closed = new AtomicBoolean();
-    ResponseBody body = new ResponseBody() {
-      @Override public MediaType contentType() {
-        return null;
-      }
-
-      @Override public long contentLength() {
-        return 5;
-      }
-
-      @Override public BufferedSource source() {
-        Buffer source = new Buffer().writeUtf8("hello");
-        return Okio.buffer(new ForwardingSource(source) {
-          @Override public void close() throws IOException {
-            closed.set(true);
-            super.close();
-          }
-        });
-      }
-    };
-    body.byteStream().close();
-    assertThat(closed.get()).isTrue();
-  }
-
-  @Test public void throwingUnderlyingSourceClosesQuietly() throws IOException {
-    ResponseBody body = new ResponseBody() {
-      @Override public MediaType contentType() {
-        return null;
-      }
-
-      @Override public long contentLength() {
-        return 5;
-      }
-
-      @Override public BufferedSource source() {
-        Buffer source = new Buffer().writeUtf8("hello");
-        return Okio.buffer(new ForwardingSource(source) {
-          @Override public void close() throws IOException {
-            throw new IOException("Broken!");
-          }
-        });
-      }
-    };
-    assertThat(body.source().readUtf8()).isEqualTo("hello");
-    body.close();
-  }
-
-  static ResponseBody body(String hex) {
-    return body(hex, null);
-  }
-
-  static ResponseBody body(String hex, String charset) {
-    MediaType mediaType = charset == null ? null : MediaType.get("any/thing; charset=" + charset);
-    return ResponseBody.create(mediaType, ByteString.decodeHex(hex));
-  }
-
-  static String exhaust(Reader reader) throws IOException {
-    StringBuilder builder = new StringBuilder();
-    char[] buf = new char[10];
-    int read;
-    while ((read = reader.read(buf)) != -1) {
-      builder.append(buf, 0, read);
-    }
-    return builder.toString();
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/ResponseTest.java b/okhttp-tests/src/test/java/okhttp3/ResponseTest.java
deleted file mode 100644
index 162d2d9a39..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/ResponseTest.java
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import okio.Buffer;
-import okio.BufferedSource;
-import okio.Okio;
-import okio.Source;
-import okio.Timeout;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class ResponseTest {
-  @Test public void peekShorterThanResponse() throws Exception {
-    Response response = newResponse(responseBody("abcdef"));
-    ResponseBody peekedBody = response.peekBody(3);
-    assertThat(peekedBody.string()).isEqualTo("abc");
-    assertThat(response.body().string()).isEqualTo("abcdef");
-  }
-
-  @Test public void peekLongerThanResponse() throws Exception {
-    Response response = newResponse(responseBody("abc"));
-    ResponseBody peekedBody = response.peekBody(6);
-    assertThat(peekedBody.string()).isEqualTo("abc");
-    assertThat(response.body().string()).isEqualTo("abc");
-  }
-
-  @Test public void peekAfterReadingResponse() throws Exception {
-    Response response = newResponse(responseBody("abc"));
-    assertThat(response.body().string()).isEqualTo("abc");
-
-    try {
-      response.peekBody(3);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void eachPeakIsIndependent() throws Exception {
-    Response response = newResponse(responseBody("abcdef"));
-    ResponseBody p1 = response.peekBody(4);
-    ResponseBody p2 = response.peekBody(2);
-    assertThat(response.body().string()).isEqualTo("abcdef");
-    assertThat(p1.string()).isEqualTo("abcd");
-    assertThat(p2.string()).isEqualTo("ab");
-  }
-
-  /**
-   * Returns a new response body that refuses to be read once it has been closed. This is true of
-   * most {@link BufferedSource} instances, but not of {@link Buffer}.
-   */
-  private ResponseBody responseBody(String content) {
-    final Buffer data = new Buffer().writeUtf8(content);
-
-    Source source = new Source() {
-      boolean closed;
-
-      @Override public void close() throws IOException {
-        closed = true;
-      }
-
-      @Override public long read(Buffer sink, long byteCount) throws IOException {
-        if (closed) throw new IllegalStateException();
-        return data.read(sink, byteCount);
-      }
-
-      @Override public Timeout timeout() {
-        return Timeout.NONE;
-      }
-    };
-
-    return ResponseBody.create(null, -1, Okio.buffer(source));
-  }
-
-  private Response newResponse(ResponseBody responseBody) {
-    return new Response.Builder()
-        .request(new Request.Builder()
-            .url("https://example.com/")
-            .build())
-        .protocol(Protocol.HTTP_1_1)
-        .code(200)
-        .message("OK")
-        .body(responseBody)
-        .build();
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/SocksProxy.java b/okhttp-tests/src/test/java/okhttp3/SocksProxy.java
deleted file mode 100644
index 4675171798..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/SocksProxy.java
+++ /dev/null
@@ -1,247 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.ProtocolException;
-import java.net.Proxy;
-import java.net.ServerSocket;
-import java.net.Socket;
-import java.net.SocketException;
-import java.util.Collections;
-import java.util.Set;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import okhttp3.internal.NamedRunnable;
-import okhttp3.internal.Util;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.Okio;
-
-/**
- * A limited implementation of SOCKS Protocol Version 5, intended to be similar to MockWebServer.
- * See <a href="https://www.ietf.org/rfc/rfc1928.txt">RFC 1928</a>.
- */
-public final class SocksProxy {
-  public static final String HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS = "onlyProxyCanResolveMe.org";
-
-  private static final int VERSION_5 = 5;
-  private static final int METHOD_NONE = 0xff;
-  private static final int METHOD_NO_AUTHENTICATION_REQUIRED = 0;
-  private static final int ADDRESS_TYPE_IPV4 = 1;
-  private static final int ADDRESS_TYPE_DOMAIN_NAME = 3;
-  private static final int COMMAND_CONNECT = 1;
-  private static final int REPLY_SUCCEEDED = 0;
-
-  private static final Logger logger = Logger.getLogger(SocksProxy.class.getName());
-
-  private final ExecutorService executor = Executors.newCachedThreadPool(
-      Util.threadFactory("SocksProxy", false));
-
-  private ServerSocket serverSocket;
-  private AtomicInteger connectionCount = new AtomicInteger();
-  private final Set<Socket> openSockets = Collections.newSetFromMap(new ConcurrentHashMap<>());
-
-  public void play() throws IOException {
-    serverSocket = new ServerSocket(0);
-    executor.execute(new NamedRunnable("SocksProxy %s", serverSocket.getLocalPort()) {
-      @Override protected void execute() {
-        try {
-          while (true) {
-            Socket socket = serverSocket.accept();
-            connectionCount.incrementAndGet();
-            service(socket);
-          }
-        } catch (SocketException e) {
-          logger.info(name + " done accepting connections: " + e.getMessage());
-        } catch (IOException e) {
-          logger.log(Level.WARNING, name + " failed unexpectedly", e);
-        } finally {
-          for (Socket socket : openSockets) {
-            Util.closeQuietly(socket);
-          }
-        }
-      }
-    });
-  }
-
-  public Proxy proxy() {
-    return new Proxy(Proxy.Type.SOCKS, InetSocketAddress.createUnresolved(
-        "localhost", serverSocket.getLocalPort()));
-  }
-
-  public int connectionCount() {
-    return connectionCount.get();
-  }
-
-  public void shutdown() throws Exception {
-    serverSocket.close();
-    executor.shutdown();
-    if (!executor.awaitTermination(5, TimeUnit.SECONDS)) {
-      throw new IOException("Gave up waiting for executor to shut down");
-    }
-  }
-
-  private void service(final Socket from) {
-    executor.execute(new NamedRunnable("SocksProxy %s", from.getRemoteSocketAddress()) {
-      @Override protected void execute() {
-        try {
-          BufferedSource fromSource = Okio.buffer(Okio.source(from));
-          BufferedSink fromSink = Okio.buffer(Okio.sink(from));
-          hello(fromSource, fromSink);
-          acceptCommand(from.getInetAddress(), fromSource, fromSink);
-          openSockets.add(from);
-        } catch (IOException e) {
-          logger.log(Level.WARNING, name + " failed", e);
-          Util.closeQuietly(from);
-        }
-      }
-    });
-  }
-
-  private void hello(BufferedSource fromSource, BufferedSink fromSink) throws IOException {
-    int version = fromSource.readByte() & 0xff;
-    int methodCount = fromSource.readByte() & 0xff;
-    int selectedMethod = METHOD_NONE;
-
-    if (version != VERSION_5) {
-      throw new ProtocolException("unsupported version: " + version);
-    }
-
-    for (int i = 0; i < methodCount; i++) {
-      int candidateMethod = fromSource.readByte() & 0xff;
-      if (candidateMethod == METHOD_NO_AUTHENTICATION_REQUIRED) {
-        selectedMethod = candidateMethod;
-      }
-    }
-
-    switch (selectedMethod) {
-      case METHOD_NO_AUTHENTICATION_REQUIRED:
-        fromSink.writeByte(VERSION_5);
-        fromSink.writeByte(selectedMethod);
-        fromSink.emit();
-        break;
-
-      default:
-        throw new ProtocolException("unsupported method: " + selectedMethod);
-    }
-  }
-
-  private void acceptCommand(InetAddress fromAddress, BufferedSource fromSource,
-      BufferedSink fromSink) throws IOException {
-    // Read the command.
-    int version = fromSource.readByte() & 0xff;
-    if (version != VERSION_5) throw new ProtocolException("unexpected version: " + version);
-    int command = fromSource.readByte() & 0xff;
-    int reserved = fromSource.readByte() & 0xff;
-    if (reserved != 0) throw new ProtocolException("unexpected reserved: " + reserved);
-
-    int addressType = fromSource.readByte() & 0xff;
-    InetAddress toAddress;
-    switch (addressType) {
-      case ADDRESS_TYPE_IPV4:
-        toAddress = InetAddress.getByAddress(fromSource.readByteArray(4L));
-        break;
-
-      case ADDRESS_TYPE_DOMAIN_NAME:
-        int domainNameLength = fromSource.readByte() & 0xff;
-        String domainName = fromSource.readUtf8(domainNameLength);
-        // Resolve HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS to localhost.
-        toAddress = domainName.equalsIgnoreCase(HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS)
-            ? InetAddress.getByName("localhost")
-            : InetAddress.getByName(domainName);
-        break;
-
-      default:
-        throw new ProtocolException("unsupported address type: " + addressType);
-    }
-
-    int port = fromSource.readShort() & 0xffff;
-
-    switch (command) {
-      case COMMAND_CONNECT:
-        Socket toSocket = new Socket(toAddress, port);
-        byte[] localAddress = toSocket.getLocalAddress().getAddress();
-        if (localAddress.length != 4) {
-          throw new ProtocolException("unexpected address: " + toSocket.getLocalAddress());
-        }
-
-        // Write the reply.
-        fromSink.writeByte(VERSION_5);
-        fromSink.writeByte(REPLY_SUCCEEDED);
-        fromSink.writeByte(0);
-        fromSink.writeByte(ADDRESS_TYPE_IPV4);
-        fromSink.write(localAddress);
-        fromSink.writeShort(toSocket.getLocalPort());
-        fromSink.emit();
-
-        logger.log(Level.INFO, "SocksProxy connected " + fromAddress + " to " + toAddress);
-
-        // Copy sources to sinks in both directions.
-        BufferedSource toSource = Okio.buffer(Okio.source(toSocket));
-        BufferedSink toSink = Okio.buffer(Okio.sink(toSocket));
-        openSockets.add(toSocket);
-
-        transfer(fromAddress, toAddress, fromSource, toSink);
-        transfer(fromAddress, toAddress, toSource, fromSink);
-        break;
-
-      default:
-        throw new ProtocolException("unexpected command: " + command);
-    }
-  }
-
-  private void transfer(final InetAddress fromAddress, final InetAddress toAddress,
-      final BufferedSource source, final BufferedSink sink) {
-    executor.execute(new NamedRunnable("SocksProxy %s to %s", fromAddress, toAddress) {
-      @Override protected void execute() {
-        Buffer buffer = new Buffer();
-        try {
-          while (true) {
-            long byteCount = source.read(buffer, 8192L);
-            if (byteCount == -1L) break;
-            sink.write(buffer, byteCount);
-            sink.emit();
-          }
-        } catch (SocketException e) {
-          logger.info(name + " done: " + e.getMessage());
-        } catch (IOException e) {
-          logger.log(Level.WARNING, name + " failed", e);
-        }
-
-        try {
-          source.close();
-        } catch (IOException e) {
-          logger.log(Level.WARNING, name + " failed", e);
-        }
-
-        try {
-          sink.close();
-        } catch (IOException e) {
-          logger.log(Level.WARNING, name + " failed", e);
-        }
-      }
-    });
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/SocksProxyTest.java b/okhttp-tests/src/test/java/okhttp3/SocksProxyTest.java
deleted file mode 100644
index c0e884e721..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/SocksProxyTest.java
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.net.Proxy;
-import java.net.ProxySelector;
-import java.net.SocketAddress;
-import java.net.URI;
-import java.util.Collections;
-import java.util.List;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import static okhttp3.TestUtil.defaultClient;
-import static org.assertj.core.api.Assertions.assertThat;
-
-public final class SocksProxyTest {
-  private final SocksProxy socksProxy = new SocksProxy();
-  private final MockWebServer server = new MockWebServer();
-
-  @Before public void setUp() throws Exception {
-    server.start();
-    socksProxy.play();
-  }
-
-  @After public void tearDown() throws Exception {
-    server.shutdown();
-    socksProxy.shutdown();
-  }
-
-  @Test public void proxy() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setBody("def"));
-
-    OkHttpClient client = defaultClient().newBuilder()
-        .proxy(socksProxy.proxy())
-        .build();
-
-    Request request1 = new Request.Builder().url(server.url("/")).build();
-    Response response1 = client.newCall(request1).execute();
-    assertThat(response1.body().string()).isEqualTo("abc");
-
-    Request request2 = new Request.Builder().url(server.url("/")).build();
-    Response response2 = client.newCall(request2).execute();
-    assertThat(response2.body().string()).isEqualTo("def");
-
-    // The HTTP calls should share a single connection.
-    assertThat(socksProxy.connectionCount()).isEqualTo(1);
-  }
-
-  @Test public void proxySelector() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    ProxySelector proxySelector = new ProxySelector() {
-      @Override public List<Proxy> select(URI uri) {
-        return Collections.singletonList(socksProxy.proxy());
-      }
-
-      @Override public void connectFailed(URI uri, SocketAddress socketAddress, IOException e) {
-        throw new AssertionError();
-      }
-    };
-
-    OkHttpClient client = defaultClient().newBuilder()
-        .proxySelector(proxySelector)
-        .build();
-
-    Request request = new Request.Builder().url(server.url("/")).build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("abc");
-
-    assertThat(socksProxy.connectionCount()).isEqualTo(1);
-  }
-
-  @Test public void checkRemoteDNSResolve() throws Exception {
-    // This testcase will fail if the target is resolved locally instead of through the proxy.
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    OkHttpClient client = defaultClient().newBuilder()
-        .proxy(socksProxy.proxy())
-        .build();
-
-    HttpUrl url = server.url("/")
-        .newBuilder()
-        .host(SocksProxy.HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS)
-        .build();
-
-    Request request = new Request.Builder().url(url).build();
-    Response response1 = client.newCall(request).execute();
-    assertThat(response1.body().string()).isEqualTo("abc");
-
-    assertThat(socksProxy.connectionCount()).isEqualTo(1);
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java b/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java
deleted file mode 100644
index 055b25e226..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.TimeUnit;
-import java.util.logging.Handler;
-import java.util.logging.LogRecord;
-
-/**
- * A log handler that records which log messages were published so that a calling test can make
- * assertions about them.
- */
-public final class TestLogHandler extends Handler {
-  private final BlockingQueue<String> logs = new LinkedBlockingQueue<>();
-
-  @Override public void publish(LogRecord logRecord) {
-    if (getFormatter() == null) {
-      logs.add(logRecord.getLevel() + ": " + logRecord.getMessage());
-    } else {
-      logs.add(getFormatter().format(logRecord));
-    }
-  }
-
-  @Override public void flush() {
-  }
-
-  @Override public void close() {
-  }
-
-  public List<String> takeAll() {
-    List<String> list = new ArrayList<>();
-    logs.drainTo(list);
-    return list;
-  }
-
-  public String take() throws Exception {
-    String message = logs.poll(10, TimeUnit.SECONDS);
-    if (message == null) {
-      throw new AssertionError("Timed out waiting for log message.");
-    }
-    return message;
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
deleted file mode 100644
index e44ab7736f..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
+++ /dev/null
@@ -1,3869 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.Authenticator;
-import java.net.ConnectException;
-import java.net.CookieManager;
-import java.net.HttpURLConnection;
-import java.net.InetAddress;
-import java.net.PasswordAuthentication;
-import java.net.ProtocolException;
-import java.net.Proxy;
-import java.net.ProxySelector;
-import java.net.ServerSocket;
-import java.net.Socket;
-import java.net.SocketAddress;
-import java.net.SocketException;
-import java.net.SocketTimeoutException;
-import java.net.URI;
-import java.net.URL;
-import java.net.URLConnection;
-import java.net.UnknownHostException;
-import java.security.KeyStore;
-import java.security.cert.CertificateException;
-import java.security.cert.X509Certificate;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.EnumSet;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Set;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicReference;
-import java.util.zip.GZIPInputStream;
-import javax.annotation.Nullable;
-import javax.net.ServerSocketFactory;
-import javax.net.SocketFactory;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLException;
-import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLProtocolException;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.TrustManagerFactory;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.internal.Internal;
-import okhttp3.internal.RecordingAuthenticator;
-import okhttp3.internal.RecordingOkAuthenticator;
-import okhttp3.internal.Util;
-import okhttp3.internal.Version;
-import okhttp3.internal.platform.Platform;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
-import okhttp3.mockwebserver.SocketPolicy;
-import okhttp3.tls.HandshakeCertificates;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.GzipSink;
-import okio.Okio;
-import okio.Utf8;
-import org.assertj.core.api.Assertions;
-import org.junit.After;
-import org.junit.AssumptionViolatedException;
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static java.util.Locale.US;
-import static java.util.concurrent.TimeUnit.MILLISECONDS;
-import static java.util.concurrent.TimeUnit.NANOSECONDS;
-import static okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT;
-import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
-import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
-import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
-import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
-import static okhttp3.mockwebserver.SocketPolicy.FAIL_HANDSHAKE;
-import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
-import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END;
-import static okhttp3.mockwebserver.SocketPolicy.UPGRADE_TO_SSL_AT_END;
-import static okhttp3.tls.internal.TlsUtil.localhost;
-import static org.hamcrest.CoreMatchers.either;
-import static org.hamcrest.CoreMatchers.equalTo;
-import static org.junit.Assert.assertThat;
-import static org.junit.Assert.fail;
-import static org.junit.Assume.assumeTrue;
-
-/** Android's URLConnectionTest, ported to exercise OkHttp's Call API. */
-public final class URLConnectionTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final MockWebServer server2 = new MockWebServer();
-  @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
-  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
-
-  private HandshakeCertificates handshakeCertificates = localhost();
-  private OkHttpClient client = clientTestRule.client;
-  private @Nullable Cache cache;
-
-  @Before public void setUp() {
-    server.setProtocolNegotiationEnabled(false);
-  }
-
-  @After public void tearDown() throws Exception {
-    Authenticator.setDefault(null);
-    System.clearProperty("proxyHost");
-    System.clearProperty("proxyPort");
-    System.clearProperty("http.proxyHost");
-    System.clearProperty("http.proxyPort");
-    System.clearProperty("https.proxyHost");
-    System.clearProperty("https.proxyPort");
-    if (cache != null) {
-      cache.delete();
-    }
-  }
-
-  @Test public void requestHeaders() throws Exception {
-    server.enqueue(new MockResponse());
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .addHeader("D", "e")
-        .addHeader("D", "f")
-        .build();
-    Assertions.assertThat(request.header("D")).isEqualTo("f");
-    Assertions.assertThat(request.header("d")).isEqualTo("f");
-    Headers requestHeaders = request.headers();
-    Assertions.assertThat(new LinkedHashSet<>(requestHeaders.values("D"))).isEqualTo(
-        newSet("e", "f"));
-    Assertions.assertThat(new LinkedHashSet<>(requestHeaders.values("d"))).isEqualTo(
-        newSet("e", "f"));
-    try {
-      new Request.Builder()
-          .header(null, "j");
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    try {
-      new Request.Builder()
-          .addHeader(null, "k");
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    try {
-      new Request.Builder()
-          .addHeader("NullValue", null);
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    try {
-      new Request.Builder()
-          .addHeader("AnotherNullValue", null);
-      fail();
-    } catch (NullPointerException expected) {
-    }
-
-    Response response = getResponse(request);
-    response.close();
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    Assertions.assertThat(recordedRequest.getHeaders().values("D")).isEqualTo(
-        Arrays.asList("e", "f"));
-    Assertions.assertThat(recordedRequest.getHeader("G")).isNull();
-    Assertions.assertThat(recordedRequest.getHeader("null")).isNull();
-  }
-
-  @Test public void getRequestPropertyReturnsLastValue() {
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .addHeader("A", "value1")
-        .addHeader("A", "value2")
-        .build();
-    Assertions.assertThat(request.header("A")).isEqualTo("value2");
-  }
-
-  @Test public void responseHeaders() throws Exception {
-    server.enqueue(new MockResponse()
-        .setStatus("HTTP/1.0 200 Fantastic")
-        .addHeader("A: c")
-        .addHeader("B: d")
-        .addHeader("A: e")
-        .setChunkedBody("ABCDE\nFGHIJ\nKLMNO\nPQR", 8));
-
-    Request request = newRequest("/");
-    Response response = getResponse(request);
-    Assertions.assertThat(response.code()).isEqualTo(200);
-    Assertions.assertThat(response.message()).isEqualTo("Fantastic");
-    try {
-      response.header(null);
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    Headers responseHeaders = response.headers();
-    Assertions.assertThat(new LinkedHashSet<>(responseHeaders.values("A"))).isEqualTo(
-        newSet("c", "e"));
-    Assertions.assertThat(new LinkedHashSet<>(responseHeaders.values("a"))).isEqualTo(
-        newSet("c", "e"));
-    Assertions.assertThat(responseHeaders.name(0)).isEqualTo("A");
-    Assertions.assertThat(responseHeaders.value(0)).isEqualTo("c");
-    Assertions.assertThat(responseHeaders.name(1)).isEqualTo("B");
-    Assertions.assertThat(responseHeaders.value(1)).isEqualTo("d");
-    Assertions.assertThat(responseHeaders.name(2)).isEqualTo("A");
-    Assertions.assertThat(responseHeaders.value(2)).isEqualTo("e");
-    response.body().close();
-  }
-
-  @Test public void serverSendsInvalidStatusLine() {
-    server.enqueue(new MockResponse().setStatus("HTP/1.1 200 OK"));
-
-    Request request = newRequest("/");
-
-    try {
-      getResponse(request);
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void serverSendsInvalidCodeTooLarge() {
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 2147483648 OK"));
-
-    Request request = newRequest("/");
-
-    try {
-      getResponse(request);
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void serverSendsInvalidCodeNotANumber() {
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 00a OK"));
-
-    Request request = newRequest("/");
-    try {
-      getResponse(request);
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void serverSendsUnnecessaryWhitespace() {
-    server.enqueue(new MockResponse().setStatus(" HTTP/1.1 2147483648 OK"));
-
-    Request request = newRequest("/");
-    try {
-      getResponse(request);
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void connectRetriesUntilConnectedOrFailed() throws Exception {
-    Request request = newRequest("/foo");
-    server.shutdown();
-
-    try {
-      getResponse(request);
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void requestBodySurvivesRetriesWithFixedLength() throws Exception {
-    testRequestBodySurvivesRetries(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void requestBodySurvivesRetriesWithChunkedStreaming() throws Exception {
-    testRequestBodySurvivesRetries(TransferKind.CHUNKED);
-  }
-
-  private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    // Use a misconfigured proxy to guarantee that the request is retried.
-    client = client.newBuilder()
-        .proxySelector(new FakeProxySelector()
-            .addProxy(server2.toProxyAddress())
-            .addProxy(Proxy.NO_PROXY))
-        .build();
-    server2.shutdown();
-
-    Request request = new Request.Builder()
-        .url(server.url("/def"))
-        .post(transferKind.newRequestBody("body"))
-        .build();
-    Response response = getResponse(request);
-    assertContent("abc", response);
-
-    Assertions.assertThat(server.takeRequest().getBody().readUtf8()).isEqualTo("body");
-  }
-
-  // Check that if we don't read to the end of a response, the next request on the
-  // recycled connection doesn't get the unread tail of the first request's response.
-  // http://code.google.com/p/android/issues/detail?id=2939
-  @Test public void bug2939() throws Exception {
-    MockResponse response = new MockResponse()
-        .setChunkedBody("ABCDE\nFGHIJ\nKLMNO\nPQR", 8);
-
-    server.enqueue(response);
-    server.enqueue(response);
-
-    Request request = newRequest("/");
-    Response c1 = getResponse(request);
-    assertContent("ABCDE", c1, 5);
-    Response c2 = getResponse(request);
-    assertContent("ABCDE", c2, 5);
-
-    c1.close();
-    c2.close();
-  }
-
-  @Test public void connectionsArePooled() throws Exception {
-    MockResponse response = new MockResponse()
-        .setBody("ABCDEFGHIJKLMNOPQR");
-
-    server.enqueue(response);
-    server.enqueue(response);
-    server.enqueue(response);
-
-    assertContent("ABCDEFGHIJKLMNOPQR", getResponse(newRequest("/foo")));
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertContent("ABCDEFGHIJKLMNOPQR", getResponse(newRequest("/bar?baz=quux")));
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-    assertContent("ABCDEFGHIJKLMNOPQR", getResponse(newRequest("/z")));
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
-  }
-
-  @Test public void chunkedConnectionsArePooled() throws Exception {
-    MockResponse response = new MockResponse()
-        .setChunkedBody("ABCDEFGHIJKLMNOPQR", 5);
-
-    server.enqueue(response);
-    server.enqueue(response);
-    server.enqueue(response);
-
-    assertContent("ABCDEFGHIJKLMNOPQR", getResponse(newRequest("/foo")));
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertContent("ABCDEFGHIJKLMNOPQR", getResponse(newRequest("/bar?baz=quux")));
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-    assertContent("ABCDEFGHIJKLMNOPQR", getResponse(newRequest("/z")));
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
-  }
-
-  @Test public void serverClosesSocket() throws Exception {
-    testServerClosesOutput(DISCONNECT_AT_END);
-  }
-
-  @Test public void serverShutdownInput() throws Exception {
-    testServerClosesOutput(SHUTDOWN_INPUT_AT_END);
-  }
-
-  @Test public void serverShutdownOutput() throws Exception {
-    testServerClosesOutput(SHUTDOWN_OUTPUT_AT_END);
-  }
-
-  @Test public void invalidHost() throws Exception {
-    // Note that 1234.1.1.1 is an invalid host in a URI, but URL isn't as strict.
-    client = client.newBuilder()
-        .dns(new FakeDns())
-        .build();
-    try {
-      getResponse(new Request.Builder()
-          .url(HttpUrl.get("http://1234.1.1.1/index.html"))
-          .build());
-      fail();
-    } catch (UnknownHostException expected) {
-    }
-  }
-
-  private void testServerClosesOutput(SocketPolicy socketPolicy) throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("This connection won't pool properly")
-        .setSocketPolicy(socketPolicy));
-    MockResponse responseAfter = new MockResponse()
-        .setBody("This comes after a busted connection");
-    server.enqueue(responseAfter);
-    server.enqueue(responseAfter); // Enqueue 2x because the broken connection may be reused.
-
-    Response response1 = getResponse(newRequest("/a"));
-    response1.body().source().timeout().timeout(100, MILLISECONDS);
-    assertContent("This connection won't pool properly", response1);
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-
-    // Give the server time to enact the socket policy if it's one that could happen after the
-    // client has received the response.
-    Thread.sleep(500);
-
-    Response response2 = getResponse(newRequest("/b"));
-    response1.body().source().timeout().timeout(100, MILLISECONDS);
-    assertContent("This comes after a busted connection", response2);
-
-    // Check that a fresh connection was created, either immediately or after attempting reuse.
-    // We know that a fresh connection was created if the server recorded a request with sequence
-    // number 0. Since the client may have attempted to reuse the broken connection just before
-    // creating a fresh connection, the server may have recorded 2 requests at this point. The order
-    // of recording is non-deterministic.
-    RecordedRequest requestAfter = server.takeRequest();
-    Assertions.assertThat(requestAfter.getSequenceNumber() == 0
-            || server.getRequestCount() == 3 && server.takeRequest().getSequenceNumber() == 0).isTrue();
-  }
-
-  enum WriteKind {BYTE_BY_BYTE, SMALL_BUFFERS, LARGE_BUFFERS}
-
-  @Test public void chunkedUpload_byteByByte() throws Exception {
-    doUpload(TransferKind.CHUNKED, WriteKind.BYTE_BY_BYTE);
-  }
-
-  @Test public void chunkedUpload_smallBuffers() throws Exception {
-    doUpload(TransferKind.CHUNKED, WriteKind.SMALL_BUFFERS);
-  }
-
-  @Test public void chunkedUpload_largeBuffers() throws Exception {
-    doUpload(TransferKind.CHUNKED, WriteKind.LARGE_BUFFERS);
-  }
-
-  @Test public void fixedLengthUpload_byteByByte() throws Exception {
-    doUpload(TransferKind.FIXED_LENGTH, WriteKind.BYTE_BY_BYTE);
-  }
-
-  @Test public void fixedLengthUpload_smallBuffers() throws Exception {
-    doUpload(TransferKind.FIXED_LENGTH, WriteKind.SMALL_BUFFERS);
-  }
-
-  @Test public void fixedLengthUpload_largeBuffers() throws Exception {
-    doUpload(TransferKind.FIXED_LENGTH, WriteKind.LARGE_BUFFERS);
-  }
-
-  private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Exception {
-    int n = 512 * 1024;
-    server.setBodyLimit(0);
-    server.enqueue(new MockResponse());
-
-    RequestBody requestBody = new RequestBody() {
-      @Override public @Nullable MediaType contentType() {
-        return null;
-      }
-
-      @Override public long contentLength() {
-        return uploadKind == TransferKind.CHUNKED ? -1L : n;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        if (writeKind == WriteKind.BYTE_BY_BYTE) {
-          for (int i = 0; i < n; ++i) {
-            sink.writeByte('x');
-          }
-        } else {
-          byte[] buf = new byte[writeKind == WriteKind.SMALL_BUFFERS ? 256 : 64 * 1024];
-          Arrays.fill(buf, (byte) 'x');
-          for (int i = 0; i < n; i += buf.length) {
-            sink.write(buf, 0, Math.min(buf.length, n - i));
-          }
-        }
-      }
-    };
-
-    Response response = getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .post(requestBody)
-        .build());
-    Assertions.assertThat(response.code()).isEqualTo(200);
-    RecordedRequest request = server.takeRequest();
-    Assertions.assertThat(request.getBodySize()).isEqualTo(n);
-    if (uploadKind == TransferKind.CHUNKED) {
-      Assertions.assertThat(request.getChunkSizes().size() > 0).isTrue();
-    } else {
-      Assertions.assertThat(request.getChunkSizes().isEmpty()).isTrue();
-    }
-  }
-
-  @Test public void connectViaHttps() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse()
-        .setBody("this response comes via HTTPS"));
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-
-    Response response = getResponse(newRequest("/foo"));
-    assertContent("this response comes via HTTPS", response);
-
-    RecordedRequest request = server.takeRequest();
-    Assertions.assertThat(request.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
-  }
-
-  @Test public void connectViaHttpsReusingConnections() throws Exception {
-    connectViaHttpsReusingConnections(false);
-  }
-
-  @Test public void connectViaHttpsReusingConnectionsAfterRebuildingClient() throws Exception {
-    connectViaHttpsReusingConnections(true);
-  }
-
-  private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse()
-        .setBody("this response comes via HTTPS"));
-    server.enqueue(new MockResponse()
-        .setBody("another response via HTTPS"));
-
-    // The pool will only reuse sockets if the SSL socket factories are the same.
-    SSLSocketFactory clientSocketFactory = handshakeCertificates.sslSocketFactory();
-    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-
-    CookieJar cookieJar = new JavaNetCookieJar(new CookieManager());
-    ConnectionPool connectionPool = new ConnectionPool();
-
-    client = new OkHttpClient.Builder()
-        .cache(cache)
-        .connectionPool(connectionPool)
-        .cookieJar(cookieJar)
-        .sslSocketFactory(clientSocketFactory, handshakeCertificates.trustManager())
-        .hostnameVerifier(hostnameVerifier)
-        .build();
-    Response response1 = getResponse(newRequest("/"));
-    assertContent("this response comes via HTTPS", response1);
-
-    if (rebuildClient) {
-      client = new OkHttpClient.Builder()
-          .cache(cache)
-          .connectionPool(connectionPool)
-          .cookieJar(cookieJar)
-          .sslSocketFactory(clientSocketFactory, handshakeCertificates.trustManager())
-          .hostnameVerifier(hostnameVerifier)
-          .build();
-    }
-
-    Response response2 = getResponse(newRequest("/"));
-    assertContent("another response via HTTPS", response2);
-
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void connectViaHttpsReusingConnectionsDifferentFactories() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse()
-        .setBody("this response comes via HTTPS"));
-    server.enqueue(new MockResponse()
-        .setBody("another response via HTTPS"));
-
-    // install a custom SSL socket factory so the server can be authorized
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-    Response response1 = getResponse(newRequest("/"));
-    assertContent("this response comes via HTTPS", response1);
-
-    SSLContext sslContext2 = Platform.get().getSSLContext();
-    sslContext2.init(null, null, null);
-    SSLSocketFactory sslSocketFactory2 = sslContext2.getSocketFactory();
-
-    TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
-        TrustManagerFactory.getDefaultAlgorithm());
-    trustManagerFactory.init((KeyStore) null);
-    X509TrustManager trustManager = (X509TrustManager) trustManagerFactory.getTrustManagers()[0];
-
-    client = client.newBuilder()
-        .sslSocketFactory(sslSocketFactory2, trustManager)
-        .build();
-    try {
-      getResponse(newRequest("/"));
-      fail("without an SSL socket factory, the connection should fail");
-    } catch (SSLException expected) {
-    }
-  }
-
-  // TODO(jwilson): tests below this marker need to be migrated to OkHttp's request/response API.
-
-  @Test public void connectViaHttpsWithSSLFallback() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(FAIL_HANDSHAKE));
-    server.enqueue(new MockResponse()
-        .setBody("this response comes via SSL"));
-
-    client = client.newBuilder()
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        // Attempt RESTRICTED_TLS then fall back to MODERN_TLS.
-        .connectionSpecs(Arrays.asList(ConnectionSpec.RESTRICTED_TLS, ConnectionSpec.MODERN_TLS))
-        .sslSocketFactory(
-            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
-        .build();
-    Response response = getResponse(newRequest("/foo"));
-
-    assertContent("this response comes via SSL", response);
-
-    RecordedRequest failHandshakeRequest = server.takeRequest();
-    Assertions.assertThat(failHandshakeRequest.getRequestLine()).isNull();
-
-    RecordedRequest fallbackRequest = server.takeRequest();
-    Assertions.assertThat(fallbackRequest.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
-    assertThat(fallbackRequest.getTlsVersion(),
-        either(equalTo(TlsVersion.TLS_1_2)).or(equalTo(TlsVersion.TLS_1_3)));
-  }
-
-  @Test public void connectViaHttpsWithSSLFallbackFailuresRecorded() {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(FAIL_HANDSHAKE));
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(FAIL_HANDSHAKE));
-
-    client = client.newBuilder()
-        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .sslSocketFactory(
-            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
-        .build();
-
-    try {
-      getResponse(newRequest("/foo"));
-      fail();
-    } catch (IOException expected) {
-      Assertions.assertThat(expected.getSuppressed().length).isEqualTo(1);
-    }
-  }
-
-  /**
-   * When a pooled connection fails, don't blame the route. Otherwise pooled connection failures can
-   * cause unnecessary SSL fallbacks.
-   *
-   * https://github.com/square/okhttp/issues/515
-   */
-  @Test public void sslFallbackNotUsedWhenRecycledConnectionFails() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .setSocketPolicy(DISCONNECT_AT_END));
-    server.enqueue(new MockResponse()
-        .setBody("def"));
-
-    client = client.newBuilder()
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .sslSocketFactory(
-            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
-        .build();
-
-    assertContent("abc", getResponse(newRequest("/")));
-
-    // Give the server time to disconnect.
-    Thread.sleep(500);
-
-    assertContent("def", getResponse(newRequest("/")));
-
-    Set<TlsVersion> tlsVersions =
-        EnumSet.of(TlsVersion.TLS_1_0, TlsVersion.TLS_1_2,
-            TlsVersion.TLS_1_3); // v1.2 on OpenJDK 8.
-
-    RecordedRequest request1 = server.takeRequest();
-    Assertions.assertThat(tlsVersions.contains(request1.getTlsVersion())).isTrue();
-
-    RecordedRequest request2 = server.takeRequest();
-    Assertions.assertThat(tlsVersions.contains(request2.getTlsVersion())).isTrue();
-  }
-
-  /**
-   * Verify that we don't retry connections on certificate verification errors.
-   *
-   * http://code.google.com/p/android/issues/detail?id=13178
-   */
-  @Test public void connectViaHttpsToUntrustedServer() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse()); // unused
-
-    try {
-      getResponse(newRequest("/foo"));
-      fail();
-    } catch (SSLHandshakeException expected) {
-      boolean condition = expected.getCause() instanceof CertificateException;
-      Assertions.assertThat(condition).isTrue();
-    }
-    Assertions.assertThat(server.getRequestCount()).isEqualTo(0);
-  }
-
-  @Test public void connectViaProxyUsingProxyArg() throws Exception {
-    testConnectViaProxy(ProxyConfig.CREATE_ARG);
-  }
-
-  @Test public void connectViaProxyUsingProxySystemProperty() throws Exception {
-    testConnectViaProxy(ProxyConfig.PROXY_SYSTEM_PROPERTY);
-  }
-
-  @Test public void connectViaProxyUsingHttpProxySystemProperty() throws Exception {
-    testConnectViaProxy(ProxyConfig.HTTP_PROXY_SYSTEM_PROPERTY);
-  }
-
-  private void testConnectViaProxy(ProxyConfig proxyConfig) throws Exception {
-    MockResponse mockResponse = new MockResponse()
-        .setBody("this response comes via a proxy");
-    server.enqueue(mockResponse);
-
-    HttpUrl url = HttpUrl.parse("http://android.com/foo");
-    Response response = proxyConfig.connect(server, client, url).execute();
-    assertContent("this response comes via a proxy", response);
-
-    RecordedRequest request = server.takeRequest();
-    Assertions.assertThat(request.getRequestLine()).isEqualTo(
-        "GET http://android.com/foo HTTP/1.1");
-    Assertions.assertThat(request.getHeader("Host")).isEqualTo("android.com");
-  }
-
-  @Test public void contentDisagreesWithContentLengthHeaderBodyTooLong() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("abc\r\nYOU SHOULD NOT SEE THIS")
-        .clearHeaders()
-        .addHeader("Content-Length: 3"));
-    assertContent("abc", getResponse(newRequest("/")));
-  }
-
-  @Test public void contentDisagreesWithContentLengthHeaderBodyTooShort() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .setHeader("Content-Length", "5")
-        .setSocketPolicy(DISCONNECT_AT_END));
-    try {
-      Response response = getResponse(newRequest("/"));
-      response.body().source().readUtf8(5);
-      fail();
-    } catch (ProtocolException expected) {
-    }
-  }
-
-  private void testConnectViaSocketFactory(boolean useHttps) throws IOException {
-    SocketFactory uselessSocketFactory = new SocketFactory() {
-      public Socket createSocket() {
-        throw new IllegalArgumentException("useless");
-      }
-
-      public Socket createSocket(InetAddress host, int port) {
-        return null;
-      }
-
-      public Socket createSocket(InetAddress address, int port, InetAddress localAddress,
-          int localPort) {
-        return null;
-      }
-
-      public Socket createSocket(String host, int port) {
-        return null;
-      }
-
-      public Socket createSocket(String host, int port, InetAddress localHost, int localPort) {
-        return null;
-      }
-    };
-
-    if (useHttps) {
-      server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-      client = client.newBuilder()
-          .sslSocketFactory(
-              handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-          .hostnameVerifier(new RecordingHostnameVerifier())
-          .build();
-    }
-
-    server.enqueue(new MockResponse()
-        .setStatus("HTTP/1.1 200 OK"));
-
-    client = client.newBuilder()
-        .socketFactory(uselessSocketFactory)
-        .build();
-    try {
-      getResponse(newRequest("/"));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-
-    client = client.newBuilder()
-        .socketFactory(SocketFactory.getDefault())
-        .build();
-    Response response = getResponse(newRequest("/"));
-    Assertions.assertThat(response.code()).isEqualTo(200);
-  }
-
-  @Test public void connectHttpViaSocketFactory() throws Exception {
-    testConnectViaSocketFactory(false);
-  }
-
-  @Test public void connectHttpsViaSocketFactory() throws Exception {
-    testConnectViaSocketFactory(true);
-  }
-
-  @Test public void contentDisagreesWithChunkedHeaderBodyTooLong() throws IOException {
-    MockResponse mockResponse = new MockResponse()
-        .setChunkedBody("abc", 3);
-    Buffer buffer = mockResponse.getBody();
-    buffer.writeUtf8("\r\nYOU SHOULD NOT SEE THIS");
-    mockResponse.setBody(buffer);
-    mockResponse.clearHeaders();
-    mockResponse.addHeader("Transfer-encoding: chunked");
-
-    server.enqueue(mockResponse);
-
-    assertContent("abc", getResponse(newRequest("/")));
-  }
-
-  @Test public void contentDisagreesWithChunkedHeaderBodyTooShort() {
-    MockResponse mockResponse = new MockResponse()
-        .setChunkedBody("abcdefg", 5);
-
-    Buffer truncatedBody = new Buffer();
-    Buffer fullBody = mockResponse.getBody();
-    truncatedBody.write(fullBody, 4);
-    mockResponse.setBody(truncatedBody);
-
-    mockResponse.clearHeaders();
-    mockResponse.addHeader("Transfer-encoding: chunked");
-    mockResponse.setSocketPolicy(DISCONNECT_AT_END);
-
-    server.enqueue(mockResponse);
-
-    try {
-      Response response = getResponse(newRequest("/"));
-      response.body().source().readUtf8(7);
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void connectViaHttpProxyToHttpsUsingProxyArgWithNoProxy() throws Exception {
-    testConnectViaDirectProxyToHttps(ProxyConfig.NO_PROXY);
-  }
-
-  @Test public void connectViaHttpProxyToHttpsUsingHttpProxySystemProperty() throws Exception {
-    // https should not use http proxy
-    testConnectViaDirectProxyToHttps(ProxyConfig.HTTP_PROXY_SYSTEM_PROPERTY);
-  }
-
-  private void testConnectViaDirectProxyToHttps(ProxyConfig proxyConfig) throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse()
-        .setBody("this response comes via HTTPS"));
-
-    HttpUrl url = server.url("/foo");
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-    Call call = proxyConfig.connect(server, client, url);
-
-    assertContent("this response comes via HTTPS", call.execute());
-
-    RecordedRequest request = server.takeRequest();
-    Assertions.assertThat(request.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
-  }
-
-  @Test public void connectViaHttpProxyToHttpsUsingProxyArg() throws Exception {
-    testConnectViaHttpProxyToHttps(ProxyConfig.CREATE_ARG);
-  }
-
-  /**
-   * We weren't honoring all of the appropriate proxy system properties when connecting via HTTPS.
-   * http://b/3097518
-   */
-  @Test public void connectViaHttpProxyToHttpsUsingProxySystemProperty() throws Exception {
-    testConnectViaHttpProxyToHttps(ProxyConfig.PROXY_SYSTEM_PROPERTY);
-  }
-
-  @Test public void connectViaHttpProxyToHttpsUsingHttpsProxySystemProperty() throws Exception {
-    testConnectViaHttpProxyToHttps(ProxyConfig.HTTPS_PROXY_SYSTEM_PROPERTY);
-  }
-
-  /**
-   * We were verifying the wrong hostname when connecting to an HTTPS site through a proxy.
-   * http://b/3097277
-   */
-  private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exception {
-    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-
-    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(UPGRADE_TO_SSL_AT_END)
-        .clearHeaders());
-    server.enqueue(new MockResponse()
-        .setBody("this response comes via a secure proxy"));
-
-    HttpUrl url = HttpUrl.parse("https://android.com/foo");
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(hostnameVerifier)
-        .build();
-    Call call = proxyConfig.connect(server, client, url);
-
-    assertContent("this response comes via a secure proxy", call.execute());
-
-    RecordedRequest connect = server.takeRequest();
-    Assertions.assertThat(connect.getRequestLine()).overridingErrorMessage(
-        "Connect line failure on proxy").isEqualTo("CONNECT android.com:443 HTTP/1.1");
-    Assertions.assertThat(connect.getHeader("Host")).isEqualTo("android.com:443");
-
-    RecordedRequest get = server.takeRequest();
-    Assertions.assertThat(get.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
-    Assertions.assertThat(get.getHeader("Host")).isEqualTo("android.com");
-    Assertions.assertThat(hostnameVerifier.calls).isEqualTo(
-        Arrays.asList("verify android.com"));
-  }
-
-  /** Tolerate bad https proxy response when using HttpResponseCache. Android bug 6754912. */
-  @Test public void connectViaHttpProxyToHttpsUsingBadProxyAndHttpResponseCache() throws Exception {
-    initResponseCache();
-
-    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
-    // The inclusion of a body in the response to a CONNECT is key to reproducing b/6754912.
-    MockResponse badProxyResponse = new MockResponse()
-        .setSocketPolicy(UPGRADE_TO_SSL_AT_END)
-        .setBody("bogus proxy connect response content");
-    server.enqueue(badProxyResponse);
-    server.enqueue(new MockResponse()
-        .setBody("response"));
-
-    // Configure a single IP address for the host and a single configuration, so we only need one
-    // failure to fail permanently.
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .connectionSpecs(Util.immutableList(ConnectionSpec.MODERN_TLS))
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .proxy(server.toProxyAddress())
-        .build();
-
-    Response response = getResponse(new Request.Builder()
-        .url(HttpUrl.get("https://android.com/foo"))
-        .build());
-    assertContent("response", response);
-
-    RecordedRequest connect = server.takeRequest();
-    Assertions.assertThat(connect.getRequestLine()).isEqualTo(
-        "CONNECT android.com:443 HTTP/1.1");
-    Assertions.assertThat(connect.getHeader("Host")).isEqualTo("android.com:443");
-  }
-
-  private void initResponseCache() {
-    cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-  }
-
-  /** Test which headers are sent unencrypted to the HTTP proxy. */
-  @Test public void proxyConnectIncludesProxyHeadersOnly() throws Exception {
-    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-
-    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(UPGRADE_TO_SSL_AT_END)
-        .clearHeaders());
-    server.enqueue(new MockResponse()
-        .setBody("encrypted response from the origin server"));
-
-    client = client.newBuilder()
-        .proxy(server.toProxyAddress())
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(hostnameVerifier)
-        .build();
-
-    Response response = getResponse(new Request.Builder()
-        .url(HttpUrl.get("https://android.com/foo"))
-        .header("Private", "Secret")
-        .header("Proxy-Authorization", "bar")
-        .header("User-Agent", "baz")
-        .build());
-    assertContent("encrypted response from the origin server", response);
-
-    RecordedRequest connect = server.takeRequest();
-    Assertions.assertThat(connect.getHeader("Private")).isNull();
-    Assertions.assertThat(connect.getHeader("Proxy-Authorization")).isNull();
-    Assertions.assertThat(connect.getHeader("User-Agent")).isEqualTo(Version.userAgent());
-    Assertions.assertThat(connect.getHeader("Host")).isEqualTo("android.com:443");
-    Assertions.assertThat(connect.getHeader("Proxy-Connection")).isEqualTo("Keep-Alive");
-
-    RecordedRequest get = server.takeRequest();
-    Assertions.assertThat(get.getHeader("Private")).isEqualTo("Secret");
-    Assertions.assertThat(hostnameVerifier.calls).isEqualTo(
-        Arrays.asList("verify android.com"));
-  }
-
-  @Test public void proxyAuthenticateOnConnect() throws Exception {
-    Authenticator.setDefault(new RecordingAuthenticator());
-    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
-    server.enqueue(new MockResponse()
-        .setResponseCode(407)
-        .addHeader("Proxy-Authenticate: Basic realm=\"localhost\""));
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(UPGRADE_TO_SSL_AT_END)
-        .clearHeaders());
-    server.enqueue(new MockResponse()
-        .setBody("A"));
-
-    client = client.newBuilder()
-        .proxyAuthenticator(new JavaNetAuthenticator())
-        .proxy(server.toProxyAddress())
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-
-    Response response = getResponse(new Request.Builder()
-        .url(HttpUrl.parse("https://android.com/foo"))
-        .build());
-    assertContent("A", response);
-
-    RecordedRequest connect1 = server.takeRequest();
-    Assertions.assertThat(connect1.getRequestLine()).isEqualTo(
-        "CONNECT android.com:443 HTTP/1.1");
-    Assertions.assertThat(connect1.getHeader("Proxy-Authorization")).isNull();
-
-    RecordedRequest connect2 = server.takeRequest();
-    Assertions.assertThat(connect2.getRequestLine()).isEqualTo(
-        "CONNECT android.com:443 HTTP/1.1");
-    Assertions.assertThat(connect2.getHeader("Proxy-Authorization")).isEqualTo(
-        ("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS));
-
-    RecordedRequest get = server.takeRequest();
-    Assertions.assertThat(get.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
-    Assertions.assertThat(get.getHeader("Proxy-Authorization")).isNull();
-  }
-
-  // Don't disconnect after building a tunnel with CONNECT
-  // http://code.google.com/p/android/issues/detail?id=37221
-  @Test public void proxyWithConnectionClose() throws IOException {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(UPGRADE_TO_SSL_AT_END)
-        .clearHeaders());
-    server.enqueue(new MockResponse()
-        .setBody("this response comes via a proxy"));
-
-    client = client.newBuilder()
-        .proxy(server.toProxyAddress())
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-
-    Response response = getResponse(new Request.Builder()
-        .url("https://android.com/foo")
-        .header("Connection", "close")
-        .build());
-
-    assertContent("this response comes via a proxy", response);
-  }
-
-  @Test public void proxyWithConnectionReuse() throws IOException {
-    SSLSocketFactory socketFactory = handshakeCertificates.sslSocketFactory();
-    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-
-    server.useHttps(socketFactory, true);
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(UPGRADE_TO_SSL_AT_END)
-        .clearHeaders());
-    server.enqueue(new MockResponse()
-        .setBody("response 1"));
-    server.enqueue(new MockResponse()
-        .setBody("response 2"));
-
-    client = client.newBuilder()
-        .proxy(server.toProxyAddress())
-        .sslSocketFactory(socketFactory, handshakeCertificates.trustManager())
-        .hostnameVerifier(hostnameVerifier)
-        .build();
-
-    assertContent("response 1", getResponse(newRequest(HttpUrl.get("https://android.com/foo"))));
-    assertContent("response 2", getResponse(newRequest(HttpUrl.get("https://android.com/foo"))));
-  }
-
-  @Test public void proxySelectorHttpWithConnectionReuse() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("response 1"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(407));
-
-    client = client.newBuilder()
-        .proxySelector(new ProxySelector() {
-          @Override public List<Proxy> select(URI uri) {
-            return Collections.singletonList(server.toProxyAddress());
-          }
-
-          @Override public void connectFailed(
-              URI uri, SocketAddress socketAddress, IOException e) {
-          }
-        }).build();
-    HttpUrl url = HttpUrl.get("http://android.com/foo");
-    assertContent("response 1", getResponse(newRequest(url)));
-    Assertions.assertThat(getResponse(newRequest(url)).code()).isEqualTo(407);
-  }
-
-  @Test public void disconnectedConnection() throws IOException {
-    server.enqueue(new MockResponse()
-        .throttleBody(2, 100, TimeUnit.MILLISECONDS)
-        .setBody("ABCD"));
-
-    Call call = client.newCall(newRequest("/"));
-    Response response = call.execute();
-    InputStream in = response.body().byteStream();
-    Assertions.assertThat((char) in.read()).isEqualTo('A');
-    call.cancel();
-    try {
-      // Reading 'B' may succeed if it's buffered.
-      in.read();
-
-      // But 'C' shouldn't be buffered (the response is throttled) and this should fail.
-      in.read();
-      fail("Expected a connection closed exception");
-    } catch (IOException expected) {
-    }
-    in.close();
-  }
-
-  @Test public void disconnectDuringConnect_cookieJar() {
-    AtomicReference<Call> callReference = new AtomicReference<>();
-
-    class DisconnectingCookieJar implements CookieJar {
-      @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {
-      }
-
-      @Override public List<Cookie> loadForRequest(HttpUrl url) {
-        callReference.get().cancel();
-        return Collections.emptyList();
-      }
-    }
-    client = client.newBuilder()
-        .cookieJar(new DisconnectingCookieJar())
-        .build();
-
-    Call call = client.newCall(newRequest("/"));
-    callReference.set(call);
-    try {
-      call.execute();
-      fail("Connection should not be established");
-    } catch (IOException expected) {
-      Assertions.assertThat(expected.getMessage()).isEqualTo("Canceled");
-    }
-  }
-
-  @Test public void disconnectBeforeConnect() {
-    server.enqueue(new MockResponse()
-        .setBody("A"));
-
-    Call call = client.newCall(newRequest("/"));
-    call.cancel();
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @SuppressWarnings("deprecation") @Test public void defaultRequestProperty() {
-    URLConnection.setDefaultRequestProperty("X-testSetDefaultRequestProperty", "A");
-    Assertions.assertThat(
-        (Object) URLConnection.getDefaultRequestProperty("X-setDefaultRequestProperty")).isNull();
-  }
-
-  /**
-   * Reads {@code count} characters from the stream. If the stream is exhausted before {@code count}
-   * characters can be read, the remaining characters are returned and the stream is closed.
-   */
-  private String readAscii(InputStream in, int count) throws IOException {
-    StringBuilder result = new StringBuilder();
-    for (int i = 0; i < count; i++) {
-      int value = in.read();
-      if (value == -1) {
-        in.close();
-        break;
-      }
-      result.append((char) value);
-    }
-    return result.toString();
-  }
-
-  @Test public void markAndResetWithContentLengthHeader() throws IOException {
-    testMarkAndReset(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void markAndResetWithChunkedEncoding() throws IOException {
-    testMarkAndReset(TransferKind.CHUNKED);
-  }
-
-  @Test public void markAndResetWithNoLengthHeaders() throws IOException {
-    testMarkAndReset(TransferKind.END_OF_STREAM);
-  }
-
-  private void testMarkAndReset(TransferKind transferKind) throws IOException {
-    MockResponse response = new MockResponse();
-    transferKind.setBody(response, "ABCDEFGHIJKLMNOPQRSTUVWXYZ", 1024);
-    server.enqueue(response);
-    server.enqueue(response);
-
-    InputStream in = getResponse(newRequest("/")).body().byteStream();
-    Assertions.assertThat(in.markSupported()).overridingErrorMessage(
-        "This implementation claims to support mark().").isFalse();
-    in.mark(5);
-    Assertions.assertThat(readAscii(in, 5)).isEqualTo("ABCDE");
-    try {
-      in.reset();
-      fail();
-    } catch (IOException expected) {
-    }
-    Assertions.assertThat(readAscii(in, Integer.MAX_VALUE)).isEqualTo(
-        "FGHIJKLMNOPQRSTUVWXYZ");
-    in.close();
-    assertContent("ABCDEFGHIJKLMNOPQRSTUVWXYZ", getResponse(newRequest("/")));
-  }
-
-  /**
-   * We've had a bug where we forget the HTTP response when we see response code 401. This causes a
-   * new HTTP request to be issued for every call into the URLConnection.
-   */
-  @Test public void unauthorizedResponseHandling() throws IOException {
-    MockResponse mockResponse = new MockResponse()
-        .addHeader("WWW-Authenticate: challenge")
-        .setResponseCode(HttpURLConnection.HTTP_UNAUTHORIZED)
-        .setBody("Unauthorized");
-    server.enqueue(mockResponse);
-    server.enqueue(mockResponse);
-    server.enqueue(mockResponse);
-
-    Response response = getResponse(newRequest("/"));
-
-    Assertions.assertThat(response.code()).isEqualTo(401);
-    Assertions.assertThat(response.code()).isEqualTo(401);
-    Assertions.assertThat(response.code()).isEqualTo(401);
-    Assertions.assertThat(server.getRequestCount()).isEqualTo(1);
-    response.body().close();
-  }
-
-  @Test public void nonHexChunkSize() {
-    server.enqueue(new MockResponse()
-        .setBody("5\r\nABCDE\r\nG\r\nFGHIJKLMNOPQRSTU\r\n0\r\n\r\n")
-        .clearHeaders()
-        .addHeader("Transfer-encoding: chunked"));
-
-    try (Response response = getResponse(newRequest("/"))) {
-      response.body().string();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void malformedChunkSize() {
-    server.enqueue(new MockResponse()
-        .setBody("5:x\r\nABCDE\r\n0\r\n\r\n")
-        .clearHeaders()
-        .addHeader("Transfer-encoding: chunked"));
-
-    try (Response response = getResponse(newRequest("/"))) {
-      readAscii(response.body().byteStream(), Integer.MAX_VALUE);
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void extensionAfterChunkSize() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("5;x\r\nABCDE\r\n0\r\n\r\n")
-        .clearHeaders()
-        .addHeader("Transfer-encoding: chunked"));
-
-    try (Response response = getResponse(newRequest("/"))) {
-      assertContent("ABCDE", response);
-    }
-  }
-
-  @Test public void missingChunkBody() {
-    server.enqueue(new MockResponse()
-        .setBody("5")
-        .clearHeaders()
-        .addHeader("Transfer-encoding: chunked")
-        .setSocketPolicy(DISCONNECT_AT_END));
-
-    try (Response response = getResponse(newRequest("/"))) {
-      readAscii(response.body().byteStream(), Integer.MAX_VALUE);
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  /**
-   * This test checks whether connections are gzipped by default. This behavior in not required by
-   * the API, so a failure of this test does not imply a bug in the implementation.
-   */
-  @Test public void gzipEncodingEnabledByDefault() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody(gzip("ABCABCABC"))
-        .addHeader("Content-Encoding: gzip"));
-
-    Response response = getResponse(newRequest("/"));
-    Assertions.assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "ABCABCABC");
-    Assertions.assertThat(response.header("Content-Encoding")).isNull();
-    Assertions.assertThat(response.body().contentLength()).isEqualTo(-1L);
-
-    RecordedRequest request = server.takeRequest();
-    Assertions.assertThat(request.getHeader("Accept-Encoding")).isEqualTo("gzip");
-  }
-
-  @Test public void clientConfiguredGzipContentEncoding() throws Exception {
-    Buffer bodyBytes = gzip("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
-    server.enqueue(new MockResponse()
-        .setBody(bodyBytes)
-        .addHeader("Content-Encoding: gzip"));
-
-    Response response = getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .header("Accept-Encoding", "gzip")
-        .build());
-    InputStream gunzippedIn = new GZIPInputStream(response.body().byteStream());
-    Assertions.assertThat(readAscii(gunzippedIn, Integer.MAX_VALUE)).isEqualTo(
-        "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
-    Assertions.assertThat(response.body().contentLength()).isEqualTo(bodyBytes.size());
-
-    RecordedRequest request = server.takeRequest();
-    Assertions.assertThat(request.getHeader("Accept-Encoding")).isEqualTo("gzip");
-  }
-
-  @Test public void gzipAndConnectionReuseWithFixedLength() throws Exception {
-    testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.FIXED_LENGTH, false);
-  }
-
-  @Test public void gzipAndConnectionReuseWithChunkedEncoding() throws Exception {
-    testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.CHUNKED, false);
-  }
-
-  @Test public void gzipAndConnectionReuseWithFixedLengthAndTls() throws Exception {
-    testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.FIXED_LENGTH, true);
-  }
-
-  @Test public void gzipAndConnectionReuseWithChunkedEncodingAndTls() throws Exception {
-    testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.CHUNKED, true);
-  }
-
-  @Test public void clientConfiguredCustomContentEncoding() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("ABCDE")
-        .addHeader("Content-Encoding: custom"));
-
-    Response response = getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .header("Accept-Encoding", "custom")
-        .build());
-    Assertions.assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "ABCDE");
-
-    RecordedRequest request = server.takeRequest();
-    Assertions.assertThat(request.getHeader("Accept-Encoding")).isEqualTo("custom");
-  }
-
-  /**
-   * Test a bug where gzip input streams weren't exhausting the input stream, which corrupted the
-   * request that followed or prevented connection reuse. http://code.google.com/p/android/issues/detail?id=7059
-   * http://code.google.com/p/android/issues/detail?id=38817
-   */
-  private void testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind transferKind,
-      boolean tls) throws Exception {
-    if (tls) {
-      SSLSocketFactory socketFactory = handshakeCertificates.sslSocketFactory();
-      RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-      server.useHttps(socketFactory, false);
-      client = client.newBuilder()
-          .sslSocketFactory(socketFactory, handshakeCertificates.trustManager())
-          .hostnameVerifier(hostnameVerifier)
-          .build();
-    }
-
-    MockResponse responseOne = new MockResponse()
-        .addHeader("Content-Encoding: gzip");
-    transferKind.setBody(responseOne, gzip("one (gzipped)"), 5);
-    server.enqueue(responseOne);
-    MockResponse responseTwo = new MockResponse();
-    transferKind.setBody(responseTwo, "two (identity)", 5);
-    server.enqueue(responseTwo);
-
-    Response response1 = getResponse(new Request.Builder()
-        .header("Accept-Encoding", "gzip")
-        .url(server.url("/"))
-        .build());
-    InputStream gunzippedIn = new GZIPInputStream(response1.body().byteStream());
-    Assertions.assertThat(readAscii(gunzippedIn, Integer.MAX_VALUE)).isEqualTo(
-        "one (gzipped)");
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-
-    Response response2 = getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Assertions.assertThat(readAscii(response2.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "two (identity)");
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void transparentGzipWorksAfterExceptionRecovery() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("a")
-        .setSocketPolicy(SHUTDOWN_INPUT_AT_END));
-    server.enqueue(new MockResponse()
-        .addHeader("Content-Encoding: gzip")
-        .setBody(gzip("b")));
-
-    // Seed the pool with a bad connection.
-    assertContent("a", getResponse(newRequest("/")));
-
-    // Give the server time to disconnect.
-    Thread.sleep(500);
-
-    // This connection will need to be recovered. When it is, transparent gzip should still work!
-    assertContent("b", getResponse(newRequest("/")));
-
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    // Connection is not pooled.
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-  }
-
-  @Test public void endOfStreamResponseIsNotPooled() throws Exception {
-    client.connectionPool().evictAll();
-    server.enqueue(new MockResponse()
-        .setBody("{}")
-        .clearHeaders()
-        .setSocketPolicy(DISCONNECT_AT_END));
-
-    Response response = getResponse(newRequest("/"));
-    assertContent("{}", response);
-    Assertions.assertThat(client.connectionPool().idleConnectionCount()).isEqualTo(0);
-  }
-
-  @Test public void earlyDisconnectDoesntHarmPoolingWithChunkedEncoding() throws Exception {
-    testEarlyDisconnectDoesntHarmPooling(TransferKind.CHUNKED);
-  }
-
-  @Test public void earlyDisconnectDoesntHarmPoolingWithFixedLengthEncoding() throws Exception {
-    testEarlyDisconnectDoesntHarmPooling(TransferKind.FIXED_LENGTH);
-  }
-
-  private void testEarlyDisconnectDoesntHarmPooling(TransferKind transferKind) throws Exception {
-    MockResponse mockResponse1 = new MockResponse();
-    transferKind.setBody(mockResponse1, "ABCDEFGHIJK", 1024);
-    server.enqueue(mockResponse1);
-
-    MockResponse mockResponse2 = new MockResponse();
-    transferKind.setBody(mockResponse2, "LMNOPQRSTUV", 1024);
-    server.enqueue(mockResponse2);
-
-    Call call1 = client.newCall(newRequest("/"));
-    Response response1 = call1.execute();
-    InputStream in1 = response1.body().byteStream();
-    Assertions.assertThat(readAscii(in1, 5)).isEqualTo("ABCDE");
-    in1.close();
-    call1.cancel();
-
-    Call call2 = client.newCall(newRequest("/"));
-    Response response2 = call2.execute();
-    InputStream in2 = response2.body().byteStream();
-    Assertions.assertThat(readAscii(in2, 5)).isEqualTo("LMNOP");
-    in2.close();
-    call2.cancel();
-
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    // Connection is pooled!
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void streamDiscardingIsTimely() throws Exception {
-    // This response takes at least a full second to serve: 10,000 bytes served 100 bytes at a time.
-    server.enqueue(new MockResponse()
-        .setBody(new Buffer().write(new byte[10000]))
-        .throttleBody(100, 10, MILLISECONDS));
-    server.enqueue(new MockResponse()
-        .setBody("A"));
-
-    long startNanos = System.nanoTime();
-    Response connection1 = getResponse(newRequest("/"));
-    InputStream in = connection1.body().byteStream();
-    in.close();
-    long elapsedNanos = System.nanoTime() - startNanos;
-    long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
-
-    // If we're working correctly, this should be greater than 100ms, but less than double that.
-    // Previously we had a bug where we would download the entire response body as long as no
-    // individual read took longer than 100ms.
-    Assertions.assertThat(elapsedMillis < 500).overridingErrorMessage(
-        Util.format("Time to close: %sms", elapsedMillis)).isTrue();
-
-    // Do another request to confirm that the discarded connection was not pooled.
-    assertContent("A", getResponse(newRequest("/")));
-
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    // Connection is not pooled.
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-  }
-
-  @Test public void setChunkedStreamingMode() throws Exception {
-    server.enqueue(new MockResponse());
-
-    Response response = getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .post(TransferKind.CHUNKED.newRequestBody("ABCDEFGHIJKLMNOPQ"))
-        .build());
-    Assertions.assertThat(response.code()).isEqualTo(200);
-
-    RecordedRequest request = server.takeRequest();
-    Assertions.assertThat(request.getBody().readUtf8()).isEqualTo("ABCDEFGHIJKLMNOPQ");
-    Assertions.assertThat(request.getChunkSizes()).isEqualTo(
-        Arrays.asList("ABCDEFGHIJKLMNOPQ".length()));
-  }
-
-  @Test public void authenticateWithFixedLengthStreaming() throws Exception {
-    testAuthenticateWithStreamingPost(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void authenticateWithChunkedStreaming() throws Exception {
-    testAuthenticateWithStreamingPost(TransferKind.CHUNKED);
-  }
-
-  private void testAuthenticateWithStreamingPost(TransferKind streamingMode) throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate."));
-    server.enqueue(new MockResponse()
-        .setBody("Authenticated!"));
-
-    Authenticator.setDefault(new RecordingAuthenticator());
-    client = client.newBuilder()
-        .authenticator(new JavaNetAuthenticator())
-        .build();
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .post(streamingMode.newRequestBody("ABCD"))
-        .build();
-    Response response = getResponse(request);
-    Assertions.assertThat(response.code()).isEqualTo(200);
-    assertContent("Authenticated!", response);
-
-    // No authorization header for the request...
-    RecordedRequest recordedRequest = server.takeRequest();
-    Assertions.assertThat(recordedRequest.getHeader("Authorization")).isNull();
-    Assertions.assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("ABCD");
-  }
-
-  @Test public void postBodyRetransmittedAfterAuthorizationFail() throws Exception {
-    postBodyRetransmittedAfterAuthorizationFail("abc");
-  }
-
-  @Test public void postBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    postBodyRetransmittedAfterAuthorizationFail("abc");
-  }
-
-  /** Don't explode when resending an empty post. https://github.com/square/okhttp/issues/1131 */
-  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail() throws Exception {
-    postBodyRetransmittedAfterAuthorizationFail("");
-  }
-
-  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    postBodyRetransmittedAfterAuthorizationFail("");
-  }
-
-  private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(401));
-    server.enqueue(new MockResponse());
-
-    String credential = Credentials.basic("jesse", "secret");
-    client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential, null))
-        .build();
-
-    Response response = getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .post(RequestBody.create(null, body))
-        .build());
-    Assertions.assertThat(response.code()).isEqualTo(200);
-    response.body().byteStream().close();
-
-    RecordedRequest recordedRequest1 = server.takeRequest();
-    Assertions.assertThat(recordedRequest1.getMethod()).isEqualTo("POST");
-    Assertions.assertThat(recordedRequest1.getBody().readUtf8()).isEqualTo(body);
-    Assertions.assertThat(recordedRequest1.getHeader("Authorization")).isNull();
-
-    RecordedRequest recordedRequest2 = server.takeRequest();
-    Assertions.assertThat(recordedRequest2.getMethod()).isEqualTo("POST");
-    Assertions.assertThat(recordedRequest2.getBody().readUtf8()).isEqualTo(body);
-    Assertions.assertThat(recordedRequest2.getHeader("Authorization")).isEqualTo(
-        credential);
-  }
-
-  @Test public void nonStandardAuthenticationScheme() throws Exception {
-    List<String> calls = authCallsForHeader("WWW-Authenticate: Foo");
-    Assertions.assertThat(calls).isEqualTo(Collections.<String>emptyList());
-  }
-
-  @Test public void nonStandardAuthenticationSchemeWithRealm() throws Exception {
-    List<String> calls = authCallsForHeader("WWW-Authenticate: Foo realm=\"Bar\"");
-    Assertions.assertThat(calls.size()).isEqualTo(0);
-  }
-
-  // Digest auth is currently unsupported. Test that digest requests should fail reasonably.
-  // http://code.google.com/p/android/issues/detail?id=11140
-  @Test public void digestAuthentication() throws Exception {
-    List<String> calls = authCallsForHeader("WWW-Authenticate: Digest "
-        + "realm=\"testrealm@host.com\", qop=\"auth,auth-int\", "
-        + "nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", "
-        + "opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"");
-    Assertions.assertThat(calls.size()).isEqualTo(0);
-  }
-
-  @Test public void allAttributesSetInServerAuthenticationCallbacks() throws Exception {
-    List<String> calls = authCallsForHeader("WWW-Authenticate: Basic realm=\"Bar\"");
-    Assertions.assertThat(calls.size()).isEqualTo(1);
-    URL url = server.url("/").url();
-    String call = calls.get(0);
-    Assertions.assertThat(call.contains("host=" + url.getHost())).overridingErrorMessage(call).isTrue();
-    Assertions.assertThat(call.contains("port=" + url.getPort())).overridingErrorMessage(call).isTrue();
-    Assertions.assertThat(call.contains("site=" + url.getHost())).overridingErrorMessage(call).isTrue();
-    Assertions.assertThat(call.contains("url=" + url)).overridingErrorMessage(call).isTrue();
-    Assertions.assertThat(call.contains("type=" + Authenticator.RequestorType.SERVER)).overridingErrorMessage(
-        call).isTrue();
-    Assertions.assertThat(call.contains("prompt=Bar")).overridingErrorMessage(call).isTrue();
-    Assertions.assertThat(call.contains("protocol=http")).overridingErrorMessage(call).isTrue();
-    // lowercase for the RI.
-    Assertions.assertThat(call.toLowerCase(US).contains("scheme=basic")).overridingErrorMessage(
-        call).isTrue();
-  }
-
-  @Test public void allAttributesSetInProxyAuthenticationCallbacks() throws Exception {
-    List<String> calls = authCallsForHeader("Proxy-Authenticate: Basic realm=\"Bar\"");
-    Assertions.assertThat(calls.size()).isEqualTo(1);
-    URL url = server.url("/").url();
-    String call = calls.get(0);
-    Assertions.assertThat(call.contains("host=" + url.getHost())).overridingErrorMessage(call).isTrue();
-    Assertions.assertThat(call.contains("port=" + url.getPort())).overridingErrorMessage(call).isTrue();
-    Assertions.assertThat(call.contains("site=" + url.getHost())).overridingErrorMessage(call).isTrue();
-    Assertions.assertThat(call.contains("url=http://android.com")).overridingErrorMessage(call).isTrue();
-    Assertions.assertThat(call.contains("type=" + Authenticator.RequestorType.PROXY)).overridingErrorMessage(
-        call).isTrue();
-    Assertions.assertThat(call.contains("prompt=Bar")).overridingErrorMessage(call).isTrue();
-    Assertions.assertThat(call.contains("protocol=http")).overridingErrorMessage(call).isTrue();
-    // lowercase for the RI.
-    Assertions.assertThat(call.toLowerCase(US).contains("scheme=basic")).overridingErrorMessage(
-        call).isTrue();
-  }
-
-  private List<String> authCallsForHeader(String authHeader) throws IOException {
-    boolean proxy = authHeader.startsWith("Proxy-");
-    int responseCode = proxy ? 407 : 401;
-    RecordingAuthenticator authenticator = new RecordingAuthenticator(null);
-    Authenticator.setDefault(authenticator);
-    server.enqueue(new MockResponse()
-        .setResponseCode(responseCode)
-        .addHeader(authHeader)
-        .setBody("Please authenticate."));
-
-    Response response;
-    if (proxy) {
-      client = client.newBuilder()
-          .proxy(server.toProxyAddress())
-          .proxyAuthenticator(new JavaNetAuthenticator())
-          .build();
-      response = getResponse(newRequest(HttpUrl.get("http://android.com/")));
-    } else {
-      client = client.newBuilder()
-          .authenticator(new JavaNetAuthenticator())
-          .build();
-      response = getResponse(newRequest("/"));
-    }
-    Assertions.assertThat(response.code()).isEqualTo(responseCode);
-    response.body().byteStream().close();
-    return authenticator.calls;
-  }
-
-  @Test public void setValidRequestMethod() {
-    assertMethodForbidsRequestBody("GET");
-    assertMethodPermitsRequestBody("DELETE");
-    assertMethodForbidsRequestBody("HEAD");
-    assertMethodPermitsRequestBody("OPTIONS");
-    assertMethodPermitsRequestBody("POST");
-    assertMethodPermitsRequestBody("PUT");
-    assertMethodPermitsRequestBody("TRACE");
-    assertMethodPermitsRequestBody("PATCH");
-
-    assertMethodPermitsNoRequestBody("GET");
-    assertMethodPermitsNoRequestBody("DELETE");
-    assertMethodPermitsNoRequestBody("HEAD");
-    assertMethodPermitsNoRequestBody("OPTIONS");
-    assertMethodForbidsNoRequestBody("POST");
-    assertMethodForbidsNoRequestBody("PUT");
-    assertMethodPermitsNoRequestBody("TRACE");
-    assertMethodForbidsNoRequestBody("PATCH");
-  }
-
-  private void assertMethodPermitsRequestBody(String requestMethod) {
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .method(requestMethod, RequestBody.create(null, "abc"))
-        .build();
-    Assertions.assertThat(request.method()).isEqualTo(requestMethod);
-  }
-
-  private void assertMethodForbidsRequestBody(String requestMethod) {
-    try {
-      new Request.Builder()
-          .url(server.url("/"))
-          .method(requestMethod, RequestBody.create(null, "abc"))
-          .build();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  private void assertMethodPermitsNoRequestBody(String requestMethod) {
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .method(requestMethod, null)
-        .build();
-    Assertions.assertThat(request.method()).isEqualTo(requestMethod);
-  }
-
-  private void assertMethodForbidsNoRequestBody(String requestMethod) {
-    try {
-      new Request.Builder()
-          .url(server.url("/"))
-          .method(requestMethod, null)
-          .build();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void setInvalidRequestMethodLowercase() throws Exception {
-    assertValidRequestMethod("get");
-  }
-
-  @Test public void setInvalidRequestMethodConnect() throws Exception {
-    assertValidRequestMethod("CONNECT");
-  }
-
-  private void assertValidRequestMethod(String requestMethod) throws Exception {
-    server.enqueue(new MockResponse());
-    Response response = getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .method(requestMethod, null)
-        .build());
-    Assertions.assertThat(response.code()).isEqualTo(200);
-    RecordedRequest recordedRequest = server.takeRequest();
-    Assertions.assertThat(recordedRequest.getMethod()).isEqualTo(requestMethod);
-  }
-
-  @Test public void shoutcast() throws Exception {
-    server.enqueue(new MockResponse()
-        .setStatus("ICY 200 OK")
-        .addHeader("Accept-Ranges: none")
-        .addHeader("Content-Type: audio/mpeg")
-        .addHeader("icy-br:128")
-        .addHeader("ice-audio-info: bitrate=128;samplerate=44100;channels=2")
-        .addHeader("icy-br:128")
-        .addHeader("icy-description:Rock")
-        .addHeader("icy-genre:riders")
-        .addHeader("icy-name:A2RRock")
-        .addHeader("icy-pub:1")
-        .addHeader("icy-url:http://www.A2Rradio.com")
-        .addHeader("Server: Icecast 2.3.3-kh8")
-        .addHeader("Cache-Control: no-cache")
-        .addHeader("Pragma: no-cache")
-        .addHeader("Expires: Mon, 26 Jul 1997 05:00:00 GMT")
-        .addHeader("icy-metaint:16000")
-        .setBody("mp3 data"));
-    Response response = getResponse(newRequest("/"));
-    Assertions.assertThat(response.code()).isEqualTo(200);
-    Assertions.assertThat(response.message()).isEqualTo("OK");
-    assertContent("mp3 data", response);
-  }
-
-  @Test public void secureFixedLengthStreaming() throws Exception {
-    testSecureStreamingPost(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void secureChunkedStreaming() throws Exception {
-    testSecureStreamingPost(TransferKind.CHUNKED);
-  }
-
-  /**
-   * Users have reported problems using HTTPS with streaming request bodies.
-   * http://code.google.com/p/android/issues/detail?id=12860
-   */
-  private void testSecureStreamingPost(TransferKind streamingMode) throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse()
-        .setBody("Success!"));
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-    Response response = getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .post(streamingMode.newRequestBody("ABCD"))
-        .build());
-    Assertions.assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "Success!");
-
-    RecordedRequest request = server.takeRequest();
-    Assertions.assertThat(request.getRequestLine()).isEqualTo("POST / HTTP/1.1");
-    if (streamingMode == TransferKind.FIXED_LENGTH) {
-      Assertions.assertThat(request.getChunkSizes()).isEqualTo(
-          Collections.<Integer>emptyList());
-    } else if (streamingMode == TransferKind.CHUNKED) {
-      Assertions.assertThat(request.getChunkSizes()).isEqualTo(Arrays.asList(4));
-    }
-    Assertions.assertThat(request.getBody().readUtf8()).isEqualTo("ABCD");
-  }
-
-  @Test public void authenticateWithPost() throws Exception {
-    MockResponse pleaseAuthenticate = new MockResponse()
-        .setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate.");
-    // Fail auth three times...
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(pleaseAuthenticate);
-    // ...then succeed the fourth time.
-    server.enqueue(new MockResponse()
-        .setBody("Successful auth!"));
-
-    Authenticator.setDefault(new RecordingAuthenticator());
-    client = client.newBuilder()
-        .authenticator(new JavaNetAuthenticator())
-        .build();
-    Response response = getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .post(RequestBody.create(null, "ABCD"))
-        .build());
-    Assertions.assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "Successful auth!");
-
-    // No authorization header for the first request...
-    RecordedRequest request = server.takeRequest();
-    Assertions.assertThat(request.getHeader("Authorization")).isNull();
-
-    // ...but the three requests that follow include an authorization header.
-    for (int i = 0; i < 3; i++) {
-      request = server.takeRequest();
-      Assertions.assertThat(request.getRequestLine()).isEqualTo("POST / HTTP/1.1");
-      Assertions.assertThat(request.getHeader("Authorization")).isEqualTo(
-          ("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS));
-      Assertions.assertThat(request.getBody().readUtf8()).isEqualTo("ABCD");
-    }
-  }
-
-  @Test public void authenticateWithGet() throws Exception {
-    MockResponse pleaseAuthenticate = new MockResponse()
-        .setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate.");
-    // Fail auth three times...
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(pleaseAuthenticate);
-    // ...then succeed the fourth time.
-    server.enqueue(new MockResponse()
-        .setBody("Successful auth!"));
-
-    Authenticator.setDefault(new RecordingAuthenticator());
-    client = client.newBuilder()
-        .authenticator(new JavaNetAuthenticator())
-        .build();
-    Response response = getResponse(newRequest("/"));
-    Assertions.assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "Successful auth!");
-
-    // No authorization header for the first request...
-    RecordedRequest request = server.takeRequest();
-    Assertions.assertThat(request.getHeader("Authorization")).isNull();
-
-    // ...but the three requests that follow requests include an authorization header.
-    for (int i = 0; i < 3; i++) {
-      request = server.takeRequest();
-      Assertions.assertThat(request.getRequestLine()).isEqualTo("GET / HTTP/1.1");
-      Assertions.assertThat(request.getHeader("Authorization")).isEqualTo(
-          ("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS));
-    }
-  }
-
-  @Test public void authenticateWithCharset() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\", charset=\"UTF-8\"")
-        .setBody("Please authenticate with UTF-8."));
-    server.enqueue(new MockResponse()
-        .setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate with ISO-8859-1."));
-    server.enqueue(new MockResponse()
-        .setBody("Successful auth!"));
-
-    Authenticator.setDefault(new RecordingAuthenticator(
-        new PasswordAuthentication("username", "m√∂torhead".toCharArray())));
-    client = client.newBuilder()
-        .authenticator(new JavaNetAuthenticator())
-        .build();
-    Response response = getResponse(newRequest("/"));
-    Assertions.assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "Successful auth!");
-
-    // No authorization header for the first request...
-    RecordedRequest request1 = server.takeRequest();
-    Assertions.assertThat(request1.getHeader("Authorization")).isNull();
-
-    // UTF-8 encoding for the first credential.
-    RecordedRequest request2 = server.takeRequest();
-    Assertions.assertThat(request2.getHeader("Authorization")).isEqualTo(
-        "Basic dXNlcm5hbWU6bcO2dG9yaGVhZA==");
-
-    // ISO-8859-1 encoding for the second credential.
-    RecordedRequest request3 = server.takeRequest();
-    Assertions.assertThat(request3.getHeader("Authorization")).isEqualTo(
-        "Basic dXNlcm5hbWU6bfZ0b3JoZWFk");
-  }
-
-  /** https://code.google.com/p/android/issues/detail?id=74026 */
-  @Test public void authenticateWithGetAndTransparentGzip() throws Exception {
-    MockResponse pleaseAuthenticate = new MockResponse()
-        .setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate.");
-    // Fail auth three times...
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(pleaseAuthenticate);
-    // ...then succeed the fourth time.
-    MockResponse successfulResponse = new MockResponse()
-        .addHeader("Content-Encoding", "gzip")
-        .setBody(gzip("Successful auth!"));
-    server.enqueue(successfulResponse);
-
-    Authenticator.setDefault(new RecordingAuthenticator());
-    client = client.newBuilder()
-        .authenticator(new JavaNetAuthenticator())
-        .build();
-    Response response = getResponse(newRequest("/"));
-    Assertions.assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "Successful auth!");
-
-    // no authorization header for the first request...
-    RecordedRequest request = server.takeRequest();
-    Assertions.assertThat(request.getHeader("Authorization")).isNull();
-
-    // ...but the three requests that follow requests include an authorization header
-    for (int i = 0; i < 3; i++) {
-      request = server.takeRequest();
-      Assertions.assertThat(request.getRequestLine()).isEqualTo("GET / HTTP/1.1");
-      Assertions.assertThat(request.getHeader("Authorization")).isEqualTo(
-          ("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS));
-    }
-  }
-
-  /** https://github.com/square/okhttp/issues/342 */
-  @Test public void authenticateRealmUppercase() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(401)
-        .addHeader("wWw-aUtHeNtIcAtE: bAsIc rEaLm=\"pRoTeCtEd aReA\"")
-        .setBody("Please authenticate."));
-    server.enqueue(new MockResponse()
-        .setBody("Successful auth!"));
-
-    Authenticator.setDefault(new RecordingAuthenticator());
-    client = client.newBuilder()
-        .authenticator(new JavaNetAuthenticator())
-        .build();
-    Response response = getResponse(newRequest("/"));
-    Assertions.assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "Successful auth!");
-  }
-
-  @Test public void redirectedWithChunkedEncoding() throws Exception {
-    testRedirected(TransferKind.CHUNKED, true);
-  }
-
-  @Test public void redirectedWithContentLengthHeader() throws Exception {
-    testRedirected(TransferKind.FIXED_LENGTH, true);
-  }
-
-  @Test public void redirectedWithNoLengthHeaders() throws Exception {
-    testRedirected(TransferKind.END_OF_STREAM, false);
-  }
-
-  private void testRedirected(TransferKind transferKind, boolean reuse) throws Exception {
-    MockResponse mockResponse = new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /foo");
-    transferKind.setBody(mockResponse, "This page has moved!", 10);
-    server.enqueue(mockResponse);
-    server.enqueue(new MockResponse()
-        .setBody("This is the new location!"));
-
-    Response response = getResponse(newRequest("/"));
-    Assertions.assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "This is the new location!");
-
-    RecordedRequest first = server.takeRequest();
-    Assertions.assertThat(first.getRequestLine()).isEqualTo("GET / HTTP/1.1");
-    RecordedRequest retry = server.takeRequest();
-    Assertions.assertThat(retry.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
-    if (reuse) {
-      Assertions.assertThat(retry.getSequenceNumber()).overridingErrorMessage(
-          "Expected connection reuse").isEqualTo(1);
-    }
-  }
-
-  @Test public void redirectedOnHttps() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /foo")
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse()
-        .setBody("This is the new location!"));
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-    Response response = getResponse(newRequest("/"));
-    Assertions.assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "This is the new location!");
-
-    RecordedRequest first = server.takeRequest();
-    Assertions.assertThat(first.getRequestLine()).isEqualTo("GET / HTTP/1.1");
-    RecordedRequest retry = server.takeRequest();
-    Assertions.assertThat(retry.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
-    Assertions.assertThat(retry.getSequenceNumber()).overridingErrorMessage(
-        "Expected connection reuse").isEqualTo(1);
-  }
-
-  @Test public void notRedirectedFromHttpsToHttp() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: http://anyhost/foo")
-        .setBody("This page has moved!"));
-
-    client = client.newBuilder()
-        .followSslRedirects(false)
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-    Response response = getResponse(newRequest("/"));
-    Assertions.assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "This page has moved!");
-  }
-
-  @Test public void notRedirectedFromHttpToHttps() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: https://anyhost/foo")
-        .setBody("This page has moved!"));
-
-    client = client.newBuilder()
-        .followSslRedirects(false)
-        .build();
-    Response response = getResponse(newRequest("/"));
-    Assertions.assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "This page has moved!");
-  }
-
-  @Test public void redirectedFromHttpsToHttpFollowingProtocolRedirects() throws Exception {
-    server2.enqueue(new MockResponse()
-        .setBody("This is insecure HTTP!"));
-
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.url("/").url())
-        .setBody("This page has moved!"));
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .followSslRedirects(true)
-        .build();
-    Response response = getResponse(newRequest("/"));
-    assertContent("This is insecure HTTP!", response);
-    Assertions.assertThat(response.handshake()).isNull();
-  }
-
-  @Test public void redirectedFromHttpToHttpsFollowingProtocolRedirects() throws Exception {
-    server2.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server2.enqueue(new MockResponse()
-        .setBody("This is secure HTTPS!"));
-
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.url("/").url())
-        .setBody("This page has moved!"));
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .followSslRedirects(true)
-        .build();
-    Response response = getResponse(newRequest("/"));
-    assertContent("This is secure HTTPS!", response);
-  }
-
-  @Test public void redirectToAnotherOriginServer() throws Exception {
-    redirectToAnotherOriginServer(false);
-  }
-
-  @Test public void redirectToAnotherOriginServerWithHttps() throws Exception {
-    redirectToAnotherOriginServer(true);
-  }
-
-  private void redirectToAnotherOriginServer(boolean https) throws Exception {
-    if (https) {
-      server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-      server2.useHttps(handshakeCertificates.sslSocketFactory(), false);
-      server2.setProtocolNegotiationEnabled(false);
-      client = client.newBuilder()
-          .sslSocketFactory(
-              handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-          .hostnameVerifier(new RecordingHostnameVerifier())
-          .build();
-    }
-
-    server2.enqueue(new MockResponse()
-        .setBody("This is the 2nd server!"));
-    server2.enqueue(new MockResponse()
-        .setBody("This is the 2nd server, again!"));
-
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.url("/").url().toString())
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse()
-        .setBody("This is the first server again!"));
-
-    Response response = getResponse(newRequest("/"));
-    assertContent("This is the 2nd server!", response);
-    Assertions.assertThat(response.request().url()).isEqualTo(server2.url("/"));
-
-    // make sure the first server was careful to recycle the connection
-    assertContent("This is the first server again!", getResponse(newRequest(server.url("/"))));
-    assertContent("This is the 2nd server, again!", getResponse(newRequest(server2.url("/"))));
-
-    String server1Host = server.getHostName() + ":" + server.getPort();
-    String server2Host = server2.getHostName() + ":" + server2.getPort();
-    Assertions.assertThat(server.takeRequest().getHeader("Host")).isEqualTo(server1Host);
-    Assertions.assertThat(server2.takeRequest().getHeader("Host")).isEqualTo(server2Host);
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).overridingErrorMessage(
-        "Expected connection reuse").isEqualTo(1);
-    Assertions.assertThat(server2.takeRequest().getSequenceNumber()).overridingErrorMessage(
-        "Expected connection reuse").isEqualTo(1);
-  }
-
-  @Test public void redirectWithProxySelector() throws Exception {
-    final List<URI> proxySelectionRequests = new ArrayList<>();
-    client = client.newBuilder()
-        .proxySelector(new ProxySelector() {
-          @Override public List<Proxy> select(URI uri) {
-            proxySelectionRequests.add(uri);
-            MockWebServer proxyServer = (uri.getPort() == server.getPort())
-                ? server
-                : server2;
-            return Arrays.asList(proxyServer.toProxyAddress());
-          }
-
-          @Override public void connectFailed(URI uri, SocketAddress address, IOException failure) {
-            throw new AssertionError();
-          }
-        })
-        .build();
-
-    server2.enqueue(new MockResponse()
-        .setBody("This is the 2nd server!"));
-
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.url("/b").toString())
-        .setBody("This page has moved!"));
-
-    assertContent("This is the 2nd server!", getResponse(newRequest("/a")));
-
-    Assertions.assertThat(proxySelectionRequests).isEqualTo(
-        Arrays.asList(server.url("/").url().toURI(), server2.url("/").url().toURI()));
-  }
-
-  @Test public void redirectWithAuthentication() throws Exception {
-    server2.enqueue(new MockResponse()
-        .setBody("Page 2"));
-
-    server.enqueue(new MockResponse()
-        .setResponseCode(401));
-    server.enqueue(new MockResponse()
-        .setResponseCode(302)
-        .addHeader("Location: " + server2.url("/b")));
-
-    client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(Credentials.basic("jesse", "secret"), null))
-        .build();
-    assertContent("Page 2", getResponse(newRequest("/a")));
-
-    RecordedRequest redirectRequest = server2.takeRequest();
-    Assertions.assertThat(redirectRequest.getHeader("Authorization")).isNull();
-    Assertions.assertThat(redirectRequest.getPath()).isEqualTo("/b");
-  }
-
-  @Test public void response300MultipleChoiceWithPost() throws Exception {
-    // Chrome doesn't follow the redirect, but Firefox and the RI both do
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MULT_CHOICE, TransferKind.END_OF_STREAM);
-  }
-
-  @Test public void response301MovedPermanentlyWithPost() throws Exception {
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_PERM, TransferKind.END_OF_STREAM);
-  }
-
-  @Test public void response302MovedTemporarilyWithPost() throws Exception {
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_TEMP, TransferKind.END_OF_STREAM);
-  }
-
-  @Test public void response303SeeOtherWithPost() throws Exception {
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_SEE_OTHER, TransferKind.END_OF_STREAM);
-  }
-
-  @Test public void postRedirectToGetWithChunkedRequest() throws Exception {
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_TEMP, TransferKind.CHUNKED);
-  }
-
-  @Test public void postRedirectToGetWithStreamedRequest() throws Exception {
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_TEMP, TransferKind.FIXED_LENGTH);
-  }
-
-  private void testResponseRedirectedWithPost(int redirectCode, TransferKind transferKind)
-      throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(redirectCode)
-        .addHeader("Location: /page2")
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse()
-        .setBody("Page 2"));
-
-    Response response = getResponse(new Request.Builder()
-        .url(server.url("/page1"))
-        .post(transferKind.newRequestBody("ABCD"))
-        .build());
-    Assertions.assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "Page 2");
-
-    RecordedRequest page1 = server.takeRequest();
-    Assertions.assertThat(page1.getRequestLine()).isEqualTo("POST /page1 HTTP/1.1");
-    Assertions.assertThat(page1.getBody().readUtf8()).isEqualTo("ABCD");
-
-    RecordedRequest page2 = server.takeRequest();
-    Assertions.assertThat(page2.getRequestLine()).isEqualTo("GET /page2 HTTP/1.1");
-  }
-
-  @Test public void redirectedPostStripsRequestBodyHeaders() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /page2"));
-    server.enqueue(new MockResponse()
-        .setBody("Page 2"));
-
-    Response response = getResponse(new Request.Builder()
-        .url(server.url("/page1"))
-        .post(RequestBody.create(MediaType.get("text/plain; charset=utf-8"), "ABCD"))
-        .header("Transfer-Encoding", "identity")
-        .build());
-    Assertions.assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "Page 2");
-
-    Assertions.assertThat(server.takeRequest().getRequestLine()).isEqualTo(
-        "POST /page1 HTTP/1.1");
-
-    RecordedRequest page2 = server.takeRequest();
-    Assertions.assertThat(page2.getRequestLine()).isEqualTo("GET /page2 HTTP/1.1");
-    Assertions.assertThat(page2.getHeader("Content-Length")).isNull();
-    Assertions.assertThat(page2.getHeader("Content-Type")).isNull();
-    Assertions.assertThat(page2.getHeader("Transfer-Encoding")).isNull();
-  }
-
-  @Test public void response305UseProxy() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_USE_PROXY)
-        .addHeader("Location: " + server.url("/").url())
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse()
-        .setBody("Proxy Response"));
-
-    Response response = getResponse(newRequest("/foo"));
-    // Fails on the RI, which gets "Proxy Response".
-    Assertions.assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "This page has moved!");
-
-    RecordedRequest page1 = server.takeRequest();
-    Assertions.assertThat(page1.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
-    Assertions.assertThat(server.getRequestCount()).isEqualTo(1);
-  }
-
-  @Test public void response307WithGet() throws Exception {
-    testRedirect(true, "GET");
-  }
-
-  @Test public void response307WithHead() throws Exception {
-    testRedirect(true, "HEAD");
-  }
-
-  @Test public void response307WithOptions() throws Exception {
-    testRedirect(true, "OPTIONS");
-  }
-
-  @Test public void response307WithPost() throws Exception {
-    testRedirect(true, "POST");
-  }
-
-  @Test public void response308WithGet() throws Exception {
-    testRedirect(false, "GET");
-  }
-
-  @Test public void response308WithHead() throws Exception {
-    testRedirect(false, "HEAD");
-  }
-
-  @Test public void response308WithOptions() throws Exception {
-    testRedirect(false, "OPTIONS");
-  }
-
-  @Test public void response308WithPost() throws Exception {
-    testRedirect(false, "POST");
-  }
-
-  private void testRedirect(boolean temporary, String method) throws Exception {
-    MockResponse response1 = new MockResponse()
-        .setResponseCode(temporary ? HTTP_TEMP_REDIRECT : HTTP_PERM_REDIRECT)
-        .addHeader("Location: /page2");
-    if (!method.equals("HEAD")) {
-      response1.setBody("This page has moved!");
-    }
-    server.enqueue(response1);
-    server.enqueue(new MockResponse()
-        .setBody("Page 2"));
-
-    Request.Builder requestBuilder = new Request.Builder()
-        .url(server.url("/page1"));
-    if (method.equals("POST")) {
-      requestBuilder.post(RequestBody.create(null, "ABCD"));
-    } else {
-      requestBuilder.method(method, null);
-    }
-
-    Response response = getResponse(requestBuilder.build());
-    String responseString = readAscii(response.body().byteStream(), Integer.MAX_VALUE);
-
-    RecordedRequest page1 = server.takeRequest();
-    Assertions.assertThat(page1.getRequestLine()).isEqualTo((method + " /page1 HTTP/1.1"));
-
-    if (method.equals("GET")) {
-      Assertions.assertThat(responseString).isEqualTo("Page 2");
-    } else if (method.equals("HEAD")) {
-      Assertions.assertThat(responseString).isEqualTo("");
-    } else {
-      // Methods other than GET/HEAD shouldn't follow the redirect.
-      if (method.equals("POST")) {
-        Assertions.assertThat(page1.getBody().readUtf8()).isEqualTo("ABCD");
-      }
-      Assertions.assertThat(server.getRequestCount()).isEqualTo(1);
-      Assertions.assertThat(responseString).isEqualTo("This page has moved!");
-      return;
-    }
-
-    // GET/HEAD requests should have followed the redirect with the same method.
-    Assertions.assertThat(server.getRequestCount()).isEqualTo(2);
-    RecordedRequest page2 = server.takeRequest();
-    Assertions.assertThat(page2.getRequestLine()).isEqualTo((method + " /page2 HTTP/1.1"));
-  }
-
-  @Test public void follow20Redirects() throws Exception {
-    for (int i = 0; i < 20; i++) {
-      server.enqueue(new MockResponse()
-          .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-          .addHeader("Location: /" + (i + 1))
-          .setBody("Redirecting to /" + (i + 1)));
-    }
-    server.enqueue(new MockResponse()
-        .setBody("Success!"));
-
-    Response response = getResponse(newRequest("/0"));
-    assertContent("Success!", response);
-    Assertions.assertThat(response.request().url()).isEqualTo(server.url("/20"));
-  }
-
-  @Test public void doesNotFollow21Redirects() throws Exception {
-    for (int i = 0; i < 21; i++) {
-      server.enqueue(new MockResponse()
-          .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-          .addHeader("Location: /" + (i + 1))
-          .setBody("Redirecting to /" + (i + 1)));
-    }
-
-    try {
-      getResponse(newRequest("/0"));
-      fail();
-    } catch (ProtocolException expected) {
-      Assertions.assertThat(expected.getMessage()).isEqualTo(
-          "Too many follow-up requests: 21");
-    }
-  }
-
-  @Test public void httpsWithCustomTrustManager() throws Exception {
-    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-    RecordingTrustManager trustManager =
-        new RecordingTrustManager(handshakeCertificates.trustManager());
-    SSLContext sslContext = Platform.get().getSSLContext();
-    sslContext.init(null, new TrustManager[] {trustManager}, null);
-
-    client = client.newBuilder()
-        .hostnameVerifier(hostnameVerifier)
-        .sslSocketFactory(sslContext.getSocketFactory(), trustManager)
-        .build();
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse()
-        .setBody("ABC"));
-    server.enqueue(new MockResponse()
-        .setBody("DEF"));
-    server.enqueue(new MockResponse()
-        .setBody("GHI"));
-
-    assertContent("ABC", getResponse(newRequest("/")));
-    assertContent("DEF", getResponse(newRequest("/")));
-    assertContent("GHI", getResponse(newRequest("/")));
-
-    Assertions.assertThat(hostnameVerifier.calls).isEqualTo(
-        Arrays.asList("verify " + server.getHostName()));
-    Assertions.assertThat(trustManager.calls).isEqualTo(
-        Arrays.asList("checkServerTrusted [CN=localhost 1]"));
-  }
-
-  @Test public void getClientRequestTimeout() throws Exception {
-    enqueueClientRequestTimeoutResponses();
-
-    Response response = getResponse(newRequest("/"));
-
-    Assertions.assertThat(response.code()).isEqualTo(200);
-    Assertions.assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "Body");
-  }
-
-  private void enqueueClientRequestTimeoutResponses() {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setResponseCode(HttpURLConnection.HTTP_CLIENT_TIMEOUT)
-        .setHeader("Connection", "Close")
-        .setBody("You took too long!"));
-    server.enqueue(new MockResponse()
-        .setBody("Body"));
-  }
-
-  @Test public void bufferedBodyWithClientRequestTimeout() throws Exception {
-    enqueueClientRequestTimeoutResponses();
-
-    Response response = getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .post(RequestBody.create(null, "Hello"))
-        .build());
-
-    Assertions.assertThat(response.code()).isEqualTo(200);
-    Assertions.assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "Body");
-
-    RecordedRequest request1 = server.takeRequest();
-    Assertions.assertThat(request1.getBody().readUtf8()).isEqualTo("Hello");
-
-    RecordedRequest request2 = server.takeRequest();
-    Assertions.assertThat(request2.getBody().readUtf8()).isEqualTo("Hello");
-  }
-
-  @Test public void streamedBodyWithClientRequestTimeout() throws Exception {
-    enqueueClientRequestTimeoutResponses();
-
-    Response response = getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .post(TransferKind.CHUNKED.newRequestBody("Hello"))
-        .build());
-
-    Assertions.assertThat(response.code()).isEqualTo(200);
-    assertContent("Body", response);
-    response.close();
-    Assertions.assertThat(server.getRequestCount()).isEqualTo(2);
-  }
-
-  @Test public void readTimeouts() throws IOException {
-    // This relies on the fact that MockWebServer doesn't close the
-    // connection after a response has been sent. This causes the client to
-    // try to read more bytes than are sent, which results in a timeout.
-    server.enqueue(new MockResponse()
-        .setBody("ABC")
-        .clearHeaders()
-        .addHeader("Content-Length: 4"));
-    server.enqueue(new MockResponse()
-        .setBody("unused")); // to keep the server alive
-
-    Response response = getResponse(newRequest("/"));
-    BufferedSource in = response.body().source();
-    in.timeout().timeout(1000, MILLISECONDS);
-    Assertions.assertThat(in.readByte()).isEqualTo((byte) 'A');
-    Assertions.assertThat(in.readByte()).isEqualTo((byte) 'B');
-    Assertions.assertThat(in.readByte()).isEqualTo((byte) 'C');
-    try {
-      in.readByte(); // If Content-Length was accurate, this would return -1 immediately.
-      fail();
-    } catch (SocketTimeoutException expected) {
-    }
-    in.close();
-  }
-
-  /** Confirm that an unacknowledged write times out. */
-  @Test public void writeTimeouts() throws IOException {
-    MockWebServer server = new MockWebServer();
-    // Sockets on some platforms can have large buffers that mean writes do not block when
-    // required. These socket factories explicitly set the buffer sizes on sockets created.
-    final int SOCKET_BUFFER_SIZE = 4 * 1024;
-    server.setServerSocketFactory(
-        new DelegatingServerSocketFactory(ServerSocketFactory.getDefault()) {
-          @Override
-          protected ServerSocket configureServerSocket(ServerSocket serverSocket)
-              throws IOException {
-            serverSocket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
-            return serverSocket;
-          }
-        });
-    client = client.newBuilder()
-        .socketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
-          @Override protected Socket configureSocket(Socket socket) throws IOException {
-            socket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
-            socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
-            return socket;
-          }
-        })
-        .writeTimeout(500, TimeUnit.MILLISECONDS)
-        .build();
-
-    server.start();
-    server.enqueue(new MockResponse()
-        .throttleBody(1, 1, TimeUnit.SECONDS)); // Prevent the server from reading!
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .post(new RequestBody() {
-          @Override public @Nullable MediaType contentType() {
-            return null;
-          }
-
-          @Override public void writeTo(BufferedSink sink) throws IOException {
-            byte[] data = new byte[2 * 1024 * 1024]; // 2 MiB.
-            sink.write(data);
-          }
-        })
-        .build();
-    try {
-      getResponse(request);
-      fail();
-    } catch (SocketTimeoutException expected) {
-    }
-  }
-
-  @Test public void setChunkedEncodingAsRequestProperty() throws Exception {
-    server.enqueue(new MockResponse());
-
-    Response response = getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .header("Transfer-encoding", "chunked")
-        .post(TransferKind.CHUNKED.newRequestBody("ABC"))
-        .build());
-    Assertions.assertThat(response.code()).isEqualTo(200);
-
-    RecordedRequest request = server.takeRequest();
-    Assertions.assertThat(request.getBody().readUtf8()).isEqualTo("ABC");
-  }
-
-  @Test public void connectionCloseInRequest() throws Exception {
-    server.enqueue(new MockResponse()); // Server doesn't honor the connection: close header!
-    server.enqueue(new MockResponse());
-
-    Response a = getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .header("Connection", "close")
-        .build());
-    Assertions.assertThat(a.code()).isEqualTo(200);
-
-    Response b = getResponse(newRequest("/"));
-    Assertions.assertThat(b.code()).isEqualTo(200);
-
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).overridingErrorMessage(
-        "When connection: close is used, each request should get its own connection").isEqualTo(
-        (long) 0);
-  }
-
-  @Test public void connectionCloseInResponse() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Connection: close"));
-    server.enqueue(new MockResponse());
-
-    Response a = getResponse(newRequest("/"));
-    Assertions.assertThat(a.code()).isEqualTo(200);
-
-    Response b = getResponse(newRequest("/"));
-    Assertions.assertThat(b.code()).isEqualTo(200);
-
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).overridingErrorMessage(
-        "When connection: close is used, each request should get its own connection").isEqualTo(
-        (long) 0);
-  }
-
-  @Test public void connectionCloseWithRedirect() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /foo")
-        .addHeader("Connection: close"));
-    server.enqueue(new MockResponse()
-        .setBody("This is the new location!"));
-
-    Response response = getResponse(newRequest("/"));
-    Assertions.assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "This is the new location!");
-
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).overridingErrorMessage(
-        "When connection: close is used, each request should get its own connection").isEqualTo(
-        (long) 0);
-  }
-
-  /**
-   * Retry redirects if the socket is closed.
-   * https://code.google.com/p/android/issues/detail?id=41576
-   */
-  @Test public void sameConnectionRedirectAndReuse() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .setSocketPolicy(SHUTDOWN_INPUT_AT_END)
-        .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse()
-        .setBody("This is the new page!"));
-
-    assertContent("This is the new page!", getResponse(newRequest("/")));
-
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-  }
-
-  @Test public void responseCodeDisagreesWithHeaders() {
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NO_CONTENT)
-        .setBody("This body is not allowed!"));
-
-    try {
-      getResponse(newRequest("/"));
-      fail();
-    } catch (IOException expected) {
-      Assertions.assertThat(expected.getMessage()).isEqualTo(
-          "HTTP 204 had non-zero Content-Length: 25");
-    }
-  }
-
-  @Test public void singleByteReadIsSigned() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody(new Buffer()
-            .writeByte(-2)
-            .writeByte(-1)));
-
-    Response response = getResponse(newRequest("/"));
-    InputStream in = response.body().byteStream();
-    Assertions.assertThat(in.read()).isEqualTo(254);
-    Assertions.assertThat(in.read()).isEqualTo(255);
-    Assertions.assertThat(in.read()).isEqualTo(-1);
-  }
-
-  @Test public void flushAfterStreamTransmittedWithChunkedEncoding() throws IOException {
-    testFlushAfterStreamTransmitted(TransferKind.CHUNKED);
-  }
-
-  @Test public void flushAfterStreamTransmittedWithFixedLength() throws IOException {
-    testFlushAfterStreamTransmitted(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void flushAfterStreamTransmittedWithNoLengthHeaders() throws IOException {
-    testFlushAfterStreamTransmitted(TransferKind.END_OF_STREAM);
-  }
-
-  /**
-   * We explicitly permit apps to close the upload stream even after it has been transmitted.  We
-   * also permit flush so that buffered streams can do a no-op flush when they are closed.
-   * http://b/3038470
-   */
-  private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    AtomicReference<BufferedSink> sinkReference = new AtomicReference<>();
-    Response response = getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .post(new ForwardingRequestBody(transferKind.newRequestBody("def")) {
-          @Override public void writeTo(BufferedSink sink) throws IOException {
-            sinkReference.set(sink);
-            super.writeTo(sink);
-          }
-        })
-        .build());
-
-    Assertions.assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "abc");
-
-    try {
-      sinkReference.get().flush();
-    } catch (IllegalStateException expected) {
-    }
-    try {
-      sinkReference.get().write("ghi".getBytes(UTF_8));
-      sinkReference.get().emit();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void getHeadersThrows() {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(DISCONNECT_AT_START));
-
-    try {
-      getResponse(newRequest("/"));
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void dnsFailureThrowsIOException() {
-    client = client.newBuilder()
-        .dns(new FakeDns())
-        .build();
-    try {
-      getResponse(newRequest(HttpUrl.get("http://host.unlikelytld")));
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void malformedUrlThrowsUnknownHostException() throws IOException {
-    try {
-      getResponse(newRequest(HttpUrl.get("http://./foo.html")));
-      fail();
-    } catch (UnknownHostException expected) {
-    }
-  }
-
-  @Test public void getKeepAlive() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("ABC"));
-
-    // The request should work once and then fail.
-    Response connection1 = getResponse(newRequest("/"));
-    BufferedSource source1 = connection1.body().source();
-    source1.timeout().timeout(100, TimeUnit.MILLISECONDS);
-    Assertions.assertThat(readAscii(source1.inputStream(), Integer.MAX_VALUE)).isEqualTo(
-        "ABC");
-    server.shutdown();
-    try {
-      getResponse(newRequest("/"));
-      fail();
-    } catch (ConnectException expected) {
-    }
-  }
-
-  /** http://code.google.com/p/android/issues/detail?id=14562 */
-  @Test public void readAfterLastByte() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("ABC")
-        .clearHeaders()
-        .addHeader("Connection: close")
-        .setSocketPolicy(DISCONNECT_AT_END));
-
-    Response response = getResponse(newRequest("/"));
-    InputStream in = response.body().byteStream();
-    Assertions.assertThat(readAscii(in, 3)).isEqualTo("ABC");
-    Assertions.assertThat(in.read()).isEqualTo(-1);
-    // throws IOException in Gingerbread.
-    Assertions.assertThat(in.read()).isEqualTo(-1);
-  }
-
-  @Test public void getOutputStreamOnGetFails() {
-    try {
-      new Request.Builder()
-          .url(server.url("/"))
-          .method("GET", RequestBody.create(null, "abc"))
-          .build();
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void clientSendsContentLength() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("A"));
-    Response response = getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .post(RequestBody.create(null, "ABC"))
-        .build());
-    Assertions.assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "A");
-    RecordedRequest request = server.takeRequest();
-    Assertions.assertThat(request.getHeader("Content-Length")).isEqualTo("3");
-    response.body().close();
-  }
-
-  @Test public void getContentLengthConnects() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("ABC"));
-    Response response = getResponse(newRequest("/"));
-    Assertions.assertThat(response.body().contentLength()).isEqualTo(3L);
-    response.body().close();
-  }
-
-  @Test public void getContentTypeConnects() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Content-Type: text/plain")
-        .setBody("ABC"));
-    Response response = getResponse(newRequest("/"));
-    Assertions.assertThat(response.body().contentType()).isEqualTo(
-        MediaType.get("text/plain"));
-    response.body().close();
-  }
-
-  @Test public void getContentEncodingConnects() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Content-Encoding: identity")
-        .setBody("ABC"));
-    Response response = getResponse(newRequest("/"));
-    Assertions.assertThat(response.header("Content-Encoding")).isEqualTo("identity");
-    response.body().close();
-  }
-
-  @Test public void urlContainsQueryButNoPath() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("A"));
-
-    HttpUrl url = server.url("?query");
-    Response response = getResponse(newRequest(url));
-    Assertions.assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "A");
-    RecordedRequest request = server.takeRequest();
-    Assertions.assertThat(request.getRequestLine()).isEqualTo("GET /?query HTTP/1.1");
-  }
-
-  @Test public void doOutputForMethodThatDoesntSupportOutput() {
-    try {
-      new Request.Builder()
-          .url(server.url("/"))
-          .method("HEAD", RequestBody.create(null, ""))
-          .build();
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  // http://code.google.com/p/android/issues/detail?id=20442
-  @Test public void inputStreamAvailableWithChunkedEncoding() throws Exception {
-    testInputStreamAvailable(TransferKind.CHUNKED);
-  }
-
-  @Test public void inputStreamAvailableWithContentLengthHeader() throws Exception {
-    testInputStreamAvailable(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void inputStreamAvailableWithNoLengthHeaders() throws Exception {
-    testInputStreamAvailable(TransferKind.END_OF_STREAM);
-  }
-
-  private void testInputStreamAvailable(TransferKind transferKind) throws IOException {
-    String body = "ABCDEFGH";
-    MockResponse mockResponse = new MockResponse();
-    transferKind.setBody(mockResponse, body, 4);
-    server.enqueue(mockResponse);
-    Response response = getResponse(newRequest("/"));
-    InputStream in = response.body().byteStream();
-    for (int i = 0; i < body.length(); i++) {
-      Assertions.assertThat(in.available() >= 0).isTrue();
-      Assertions.assertThat(in.read()).isEqualTo(body.charAt(i));
-    }
-    Assertions.assertThat(in.available()).isEqualTo(0);
-    Assertions.assertThat(in.read()).isEqualTo(-1);
-  }
-
-  @Test public void postFailsWithBufferedRequestForSmallRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.END_OF_STREAM, 1024);
-  }
-
-  @Test public void postFailsWithBufferedRequestForLargeRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.END_OF_STREAM, 16384);
-  }
-
-  @Test public void postFailsWithChunkedRequestForSmallRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.CHUNKED, 1024);
-  }
-
-  @Test public void postFailsWithChunkedRequestForLargeRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.CHUNKED, 16384);
-  }
-
-  @Test public void postFailsWithFixedLengthRequestForSmallRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.FIXED_LENGTH, 1024);
-  }
-
-  @Test public void postFailsWithFixedLengthRequestForLargeRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.FIXED_LENGTH, 16384);
-  }
-
-  private void reusedConnectionFailsWithPost(TransferKind transferKind, int requestSize)
-      throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .setSocketPolicy(DISCONNECT_AT_END));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-    server.enqueue(new MockResponse()
-        .setBody("C"));
-
-    assertContent("A", getResponse(newRequest("/a")));
-
-    // Give the server time to disconnect.
-    Thread.sleep(500);
-
-    // If the request body is larger than OkHttp's replay buffer, the failure may still occur.
-    char[] requestBodyChars = new char[requestSize];
-    Arrays.fill(requestBodyChars, 'x');
-    String requestBody = new String(requestBodyChars);
-
-    for (int j = 0; j < 2; j++) {
-      try {
-        Response response = getResponse(new Request.Builder()
-            .url(server.url("/b"))
-            .post(transferKind.newRequestBody(requestBody))
-            .build());
-        assertContent("B", response);
-        break;
-      } catch (IOException socketException) {
-        // If there's a socket exception, this must have a streamed request body.
-        Assertions.assertThat(j).isEqualTo(0);
-        Assertions.assertThat(transferKind == TransferKind.CHUNKED
-                || transferKind == TransferKind.FIXED_LENGTH).isTrue();
-      }
-    }
-
-    RecordedRequest requestA = server.takeRequest();
-    Assertions.assertThat(requestA.getPath()).isEqualTo("/a");
-    RecordedRequest requestB = server.takeRequest();
-    Assertions.assertThat(requestB.getPath()).isEqualTo("/b");
-    Assertions.assertThat(requestB.getBody().readUtf8()).isEqualTo(requestBody);
-  }
-
-  @Test public void postBodyRetransmittedOnFailureRecovery() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-    server.enqueue(new MockResponse()
-        .setBody("def"));
-
-    // Seed the connection pool so we have something that can fail.
-    assertContent("abc", getResponse(newRequest("/")));
-
-    Response post = getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .post(RequestBody.create(null, "body!"))
-        .build());
-    assertContent("def", post);
-
-    RecordedRequest get = server.takeRequest();
-    Assertions.assertThat(get.getSequenceNumber()).isEqualTo(0);
-
-    RecordedRequest post1 = server.takeRequest();
-    Assertions.assertThat(post1.getBody().readUtf8()).isEqualTo("body!");
-    Assertions.assertThat(post1.getSequenceNumber()).isEqualTo(1);
-
-    RecordedRequest post2 = server.takeRequest();
-    Assertions.assertThat(post2.getBody().readUtf8()).isEqualTo("body!");
-    Assertions.assertThat(post2.getSequenceNumber()).isEqualTo(0);
-  }
-
-  @Test public void fullyBufferedPostIsTooShort() {
-    server.enqueue(new MockResponse()
-        .setBody("A"));
-
-    RequestBody requestBody = new RequestBody() {
-      @Override public @Nullable MediaType contentType() {
-        return null;
-      }
-
-      @Override public long contentLength() {
-        return 4L;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        sink.writeUtf8("abc");
-      }
-    };
-    try {
-      getResponse(new Request.Builder()
-          .url(server.url("/b"))
-          .post(requestBody)
-          .build());
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void fullyBufferedPostIsTooLong() {
-    server.enqueue(new MockResponse()
-        .setBody("A"));
-
-    RequestBody requestBody = new RequestBody() {
-      @Override public @Nullable MediaType contentType() {
-        return null;
-      }
-
-      @Override public long contentLength() {
-        return 3L;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        sink.writeUtf8("abcd");
-      }
-    };
-    try {
-      getResponse(new Request.Builder()
-          .url(server.url("/b"))
-          .post(requestBody)
-          .build());
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test @Ignore public void testPooledConnectionsDetectHttp10() {
-    // TODO: write a test that shows pooled connections detect HTTP/1.0 (vs. HTTP/1.1)
-    fail("TODO");
-  }
-
-  @Test @Ignore public void postBodiesRetransmittedOnAuthProblems() {
-    fail("TODO");
-  }
-
-  @Test @Ignore public void cookiesAndTrailers() {
-    // Do cookie headers get processed too many times?
-    fail("TODO");
-  }
-
-  @Test public void emptyRequestHeaderValueIsAllowed() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("body"));
-    Response response = getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .header("B", "")
-        .build());
-    assertContent("body", response);
-    Assertions.assertThat(response.request().header("B")).isEqualTo("");
-  }
-
-  @Test public void emptyResponseHeaderValueIsAllowed() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("A:")
-        .setBody("body"));
-    Response response = getResponse(newRequest("/"));
-    assertContent("body", response);
-    Assertions.assertThat(response.header("A")).isEqualTo("");
-  }
-
-  @Test public void emptyRequestHeaderNameIsStrict() {
-    try {
-      new Request.Builder()
-          .url(server.url("/"))
-          .header("", "A")
-          .build();
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void emptyResponseHeaderNameIsLenient() throws Exception {
-    Headers.Builder headers = new Headers.Builder();
-    Internal.instance.addLenient(headers, ":A");
-    server.enqueue(new MockResponse()
-        .setHeaders(headers.build())
-        .setBody("body"));
-    Response response = getResponse(newRequest("/"));
-    Assertions.assertThat(response.code()).isEqualTo(200);
-    Assertions.assertThat(response.header("")).isEqualTo("A");
-    response.body().close();
-  }
-
-  @Test public void requestHeaderValidationIsStrict() {
-    try {
-      new Request.Builder()
-          .addHeader("a\tb", "Value");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      new Request.Builder()
-          .addHeader("Name", "c\u007fd");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      new Request.Builder()
-          .addHeader("", "Value");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      new Request.Builder()
-          .addHeader("\ud83c\udf69", "Value");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      new Request.Builder()
-          .addHeader("Name", "\u2615\ufe0f");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void responseHeaderParsingIsLenient() throws Exception {
-    Headers headers = new Headers.Builder()
-        .add("Content-Length", "0")
-        .addLenient("a\tb: c\u007fd")
-        .addLenient(": ef")
-        .addLenient("\ud83c\udf69: \u2615\ufe0f")
-        .build();
-    server.enqueue(new MockResponse()
-        .setHeaders(headers));
-
-    Response response = getResponse(newRequest("/"));
-    Assertions.assertThat(response.code()).isEqualTo(200);
-    Assertions.assertThat(response.header("a\tb")).isEqualTo("c\u007fd");
-    Assertions.assertThat(response.header("\ud83c\udf69")).isEqualTo("\u2615\ufe0f");
-    Assertions.assertThat(response.header("")).isEqualTo("ef");
-  }
-
-  @Test @Ignore public void deflateCompression() {
-    fail("TODO");
-  }
-
-  @Test @Ignore public void postBodiesRetransmittedOnIpAddressProblems() {
-    fail("TODO");
-  }
-
-  @Test @Ignore public void pooledConnectionProblemsNotReportedToProxySelector() {
-    fail("TODO");
-  }
-
-  @Test public void customBasicAuthenticator() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate."));
-    server.enqueue(new MockResponse()
-        .setBody("A"));
-
-    String credential = Credentials.basic("jesse", "peanutbutter");
-    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(credential, null);
-    client = client.newBuilder()
-        .authenticator(authenticator)
-        .build();
-    assertContent("A", getResponse(newRequest("/private")));
-
-    Assertions.assertThat(server.takeRequest().getHeader("Authorization")).isNull();
-    Assertions.assertThat(server.takeRequest().getHeader("Authorization")).isEqualTo(
-        credential);
-
-    Assertions.assertThat(authenticator.onlyRoute().proxy()).isEqualTo(Proxy.NO_PROXY);
-    Response response = authenticator.onlyResponse();
-    Assertions.assertThat(response.request().url().url().getPath()).isEqualTo("/private");
-    Assertions.assertThat(response.challenges()).isEqualTo(
-        Arrays.asList(new Challenge("Basic", "protected area")));
-  }
-
-  @Test public void customTokenAuthenticator() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(401)
-        .addHeader("WWW-Authenticate: Bearer realm=\"oauthed\"")
-        .setBody("Please authenticate."));
-    server.enqueue(new MockResponse()
-        .setBody("A"));
-
-    RecordingOkAuthenticator authenticator
-        = new RecordingOkAuthenticator("oauthed abc123", "Bearer");
-    client = client.newBuilder()
-        .authenticator(authenticator)
-        .build();
-    assertContent("A", getResponse(newRequest("/private")));
-
-    Assertions.assertThat(server.takeRequest().getHeader("Authorization")).isNull();
-    Assertions.assertThat(server.takeRequest().getHeader("Authorization")).isEqualTo(
-        "oauthed abc123");
-
-    Response response = authenticator.onlyResponse();
-    Assertions.assertThat(response.request().url().url().getPath()).isEqualTo("/private");
-    Assertions.assertThat(response.challenges()).isEqualTo(
-        Arrays.asList(new Challenge("Bearer", "oauthed")));
-  }
-
-  @Test public void authenticateCallsTrackedAsRedirects() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(302)
-        .addHeader("Location: /b"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\""));
-    server.enqueue(new MockResponse()
-        .setBody("c"));
-
-    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(
-        Credentials.basic("jesse", "peanutbutter"), "Basic");
-    client = client.newBuilder()
-        .authenticator(authenticator)
-        .build();
-    assertContent("c", getResponse(newRequest("/a")));
-
-    Response challengeResponse = authenticator.responses.get(0);
-    Assertions.assertThat(challengeResponse.request().url().url().getPath()).isEqualTo(
-        "/b");
-
-    Response redirectedBy = challengeResponse.priorResponse();
-    Assertions.assertThat(redirectedBy.request().url().url().getPath()).isEqualTo("/a");
-  }
-
-  @Test public void attemptAuthorization20Times() throws Exception {
-    for (int i = 0; i < 20; i++) {
-      server.enqueue(new MockResponse()
-          .setResponseCode(401));
-    }
-    server.enqueue(new MockResponse()
-        .setBody("Success!"));
-
-    String credential = Credentials.basic("jesse", "peanutbutter");
-    client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential, null))
-        .build();
-
-    Response response = getResponse(newRequest("/0"));
-    assertContent("Success!", response);
-  }
-
-  @Test public void doesNotAttemptAuthorization21Times() throws Exception {
-    for (int i = 0; i < 21; i++) {
-      server.enqueue(new MockResponse()
-          .setResponseCode(401));
-    }
-
-    String credential = Credentials.basic("jesse", "peanutbutter");
-    client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential, null))
-        .build();
-
-    try {
-      getResponse(newRequest("/"));
-      fail();
-    } catch (ProtocolException expected) {
-      Assertions.assertThat(expected.getMessage()).isEqualTo(
-          "Too many follow-up requests: 21");
-    }
-  }
-
-  @Test public void setsNegotiatedProtocolHeader_HTTP_2() throws Exception {
-    setsNegotiatedProtocolHeader(Protocol.HTTP_2);
-  }
-
-  private void setsNegotiatedProtocolHeader(Protocol protocol) throws IOException {
-    enableProtocol(protocol);
-    server.enqueue(new MockResponse()
-        .setBody("A"));
-    client = client.newBuilder()
-        .protocols(Arrays.asList(protocol, Protocol.HTTP_1_1))
-        .build();
-    Response response = getResponse(newRequest("/"));
-    Assertions.assertThat(response.protocol()).isEqualTo(protocol);
-    assertContent("A", response);
-  }
-
-  @Test public void http10SelectedProtocol() throws IOException {
-    server.enqueue(new MockResponse()
-        .setStatus("HTTP/1.0 200 OK"));
-    Response response = getResponse(newRequest("/"));
-    Assertions.assertThat(response.protocol()).isEqualTo(Protocol.HTTP_1_0);
-  }
-
-  @Test public void http11SelectedProtocol() throws IOException {
-    server.enqueue(new MockResponse()
-        .setStatus("HTTP/1.1 200 OK"));
-    Response response = getResponse(newRequest("/"));
-    Assertions.assertThat(response.protocol()).isEqualTo(Protocol.HTTP_1_1);
-  }
-
-  /** For example, empty Protobuf RPC messages end up as a zero-length POST. */
-  @Test public void zeroLengthPost() throws Exception {
-    zeroLengthPayload("POST");
-  }
-
-  @Test public void zeroLengthPost_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    zeroLengthPost();
-  }
-
-  /** For example, creating an Amazon S3 bucket ends up as a zero-length POST. */
-  @Test public void zeroLengthPut() throws Exception {
-    zeroLengthPayload("PUT");
-  }
-
-  @Test public void zeroLengthPut_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    zeroLengthPut();
-  }
-
-  private void zeroLengthPayload(String method) throws Exception {
-    server.enqueue(new MockResponse());
-
-    Response response = getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .method(method, RequestBody.create(null, ""))
-        .build());
-    assertContent("", response);
-    RecordedRequest zeroLengthPayload = server.takeRequest();
-    Assertions.assertThat(zeroLengthPayload.getMethod()).isEqualTo(method);
-    Assertions.assertThat(zeroLengthPayload.getHeader("content-length")).isEqualTo("0");
-    Assertions.assertThat(zeroLengthPayload.getBodySize()).isEqualTo(0L);
-  }
-
-  @Test public void setProtocols() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("A"));
-    client = client.newBuilder()
-        .protocols(Arrays.asList(Protocol.HTTP_1_1))
-        .build();
-    assertContent("A", getResponse(newRequest("/")));
-  }
-
-  @Test public void setProtocolsWithoutHttp11() {
-    try {
-      new OkHttpClient.Builder()
-          .protocols(Arrays.asList(Protocol.HTTP_2));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void setProtocolsWithNull() {
-    try {
-      new OkHttpClient.Builder()
-          .protocols(Arrays.asList(Protocol.HTTP_1_1, null));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void veryLargeFixedLengthRequest() throws Exception {
-    server.setBodyLimit(0);
-    server.enqueue(new MockResponse());
-
-    long contentLength = Integer.MAX_VALUE + 1L;
-    Response response = getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .post(new RequestBody() {
-          @Override public @Nullable MediaType contentType() {
-            return null;
-          }
-
-          @Override public long contentLength() {
-            return contentLength;
-          }
-
-          @Override public void writeTo(BufferedSink sink) throws IOException {
-            byte[] buffer = new byte[1024 * 1024];
-            for (long bytesWritten = 0; bytesWritten < contentLength; ) {
-              int byteCount = (int) Math.min(buffer.length, contentLength - bytesWritten);
-              bytesWritten += byteCount;
-              sink.write(buffer, 0, byteCount);
-            }
-          }
-        })
-        .build());
-
-    assertContent("", response);
-
-    RecordedRequest request = server.takeRequest();
-    Assertions.assertThat(request.getHeader("Content-Length")).isEqualTo(
-        Long.toString(contentLength));
-  }
-
-  @Test public void testNoSslFallback() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false /* tunnelProxy */);
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(FAIL_HANDSHAKE));
-    server.enqueue(new MockResponse()
-        .setBody("Response that would have needed fallbacks"));
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .build();
-    try {
-      getResponse(newRequest("/"));
-      fail();
-    } catch (SSLProtocolException expected) {
-      // RI response to the FAIL_HANDSHAKE
-    } catch (SSLHandshakeException expected) {
-      // Android's response to the FAIL_HANDSHAKE
-    } catch (SSLException expected) {
-      // JDK 1.9 response to the FAIL_HANDSHAKE
-      // javax.net.ssl.SSLException: Unexpected handshake message: client_hello
-    } catch (SocketException expected) {
-      // Conscrypt's response to the FAIL_HANDSHAKE
-    }
-  }
-
-  /**
-   * We had a bug where we attempted to gunzip responses that didn't have a body. This only came up
-   * with 304s since that response code can include headers (like "Content-Encoding") without any
-   * content to go along with it. https://github.com/square/okhttp/issues/358
-   */
-  @Test public void noTransparentGzipFor304NotModified() throws Exception {
-    server.enqueue(new MockResponse()
-        .clearHeaders()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
-        .addHeader("Content-Encoding: gzip"));
-    server.enqueue(new MockResponse()
-        .setBody("b"));
-
-    Response response1 = getResponse(newRequest("/"));
-    Assertions.assertThat(response1.code()).isEqualTo(
-        (long) HttpURLConnection.HTTP_NOT_MODIFIED);
-    assertContent("", response1);
-
-    Response response2 = getResponse(newRequest("/"));
-    Assertions.assertThat(response2.code()).isEqualTo(HttpURLConnection.HTTP_OK);
-    assertContent("b", response2);
-
-    RecordedRequest requestA = server.takeRequest();
-    Assertions.assertThat(requestA.getSequenceNumber()).isEqualTo(0);
-
-    RecordedRequest requestB = server.takeRequest();
-    Assertions.assertThat(requestB.getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void nullSSLSocketFactory_throws() {
-    try {
-      client.newBuilder().sslSocketFactory(null);
-      fail();
-    } catch (NullPointerException expected) {
-    }
-  }
-
-  /**
-   * We had a bug where we weren't closing Gzip streams on redirects.
-   * https://github.com/square/okhttp/issues/441
-   */
-  @Test public void gzipWithRedirectAndConnectionReuse() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /foo")
-        .addHeader("Content-Encoding: gzip")
-        .setBody(gzip("Moved! Moved! Moved!")));
-    server.enqueue(new MockResponse()
-        .setBody("This is the new page!"));
-
-    Response response = getResponse(newRequest("/"));
-    assertContent("This is the new page!", response);
-
-    RecordedRequest requestA = server.takeRequest();
-    Assertions.assertThat(requestA.getSequenceNumber()).isEqualTo(0);
-
-    RecordedRequest requestB = server.takeRequest();
-    Assertions.assertThat(requestB.getSequenceNumber()).isEqualTo(1);
-  }
-
-  /**
-   * The RFC is unclear in this regard as it only specifies that this should invalidate the cache
-   * entry (if any).
-   */
-  @Test public void bodyPermittedOnDelete() throws Exception {
-    server.enqueue(new MockResponse());
-
-    Response response = getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .delete(RequestBody.create(null, "BODY"))
-        .build());
-    Assertions.assertThat(response.code()).isEqualTo(200);
-
-    RecordedRequest request = server.takeRequest();
-    Assertions.assertThat(request.getMethod()).isEqualTo("DELETE");
-    Assertions.assertThat(request.getBody().readUtf8()).isEqualTo("BODY");
-  }
-
-  @Test public void userAgentDefaultsToOkHttpVersion() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    assertContent("abc", getResponse(newRequest("/")));
-
-    RecordedRequest request = server.takeRequest();
-    Assertions.assertThat(request.getHeader("User-Agent")).isEqualTo(Version.userAgent());
-  }
-
-  @Test public void urlWithSpaceInHost() {
-    try {
-      HttpUrl.get("http://and roid.com/");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void urlWithSpaceInHostViaHttpProxy() {
-    try {
-      HttpUrl.get("http://and roid.com/");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void urlHostWithNul() {
-    try {
-      HttpUrl.get("http://host\u0000/");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void urlRedirectToHostWithNul() throws Exception {
-    String redirectUrl = "http://host\u0000/";
-    server.enqueue(new MockResponse()
-        .setResponseCode(302)
-        .addHeaderLenient("Location", redirectUrl));
-
-    Response response = getResponse(newRequest("/"));
-    Assertions.assertThat(response.code()).isEqualTo(302);
-    Assertions.assertThat(response.header("Location")).isEqualTo(redirectUrl);
-  }
-
-  @Test public void urlWithBadAsciiHost() {
-    try {
-      HttpUrl.get("http://host\u0001/");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void setSslSocketFactoryFailsOnJdk9() {
-    assumeTrue(getPlatform().equals("jdk9"));
-
-    try {
-      client.newBuilder()
-          .sslSocketFactory(handshakeCertificates.sslSocketFactory());
-      fail();
-    } catch (UnsupportedOperationException expected) {
-    }
-  }
-
-  /** Confirm that runtime exceptions thrown inside of OkHttp propagate to the caller. */
-  @Test public void unexpectedExceptionSync() throws Exception {
-    client = client.newBuilder()
-        .dns(hostname -> {
-          throw new RuntimeException("boom!");
-        })
-        .build();
-
-    server.enqueue(new MockResponse());
-
-    try {
-      getResponse(newRequest("/"));
-      fail();
-    } catch (RuntimeException expected) {
-      Assertions.assertThat(expected.getMessage()).isEqualTo("boom!");
-    }
-  }
-
-  @Test public void streamedBodyIsRetriedOnHttp2Shutdown() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setBody("abc"));
-    server.enqueue(new MockResponse()
-        .setBody("def"));
-
-    // Send a separate request which will trigger a GOAWAY frame on the healthy connection.
-    Response response = getResponse(newRequest("/"));
-    assertContent("abc", response);
-
-    // Ensure the GOAWAY frame has time to be read and processed.
-    Thread.sleep(500);
-
-    assertContent("def", getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .post(RequestBody.create(null, "123"))
-        .build()));
-
-    RecordedRequest request1 = server.takeRequest();
-    Assertions.assertThat(request1.getSequenceNumber()).isEqualTo(0);
-
-    RecordedRequest request2 = server.takeRequest();
-    Assertions.assertThat(request2.getBody().readUtf8()).isEqualTo("123");
-    Assertions.assertThat(request2.getSequenceNumber()).isEqualTo(0);
-  }
-
-  @Test public void authenticateNoConnection() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Connection: close")
-        .setResponseCode(401)
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
-
-    Authenticator.setDefault(new RecordingAuthenticator(null));
-    client = client.newBuilder()
-        .authenticator(new JavaNetAuthenticator())
-        .build();
-    Response response = getResponse(newRequest("/"));
-    Assertions.assertThat(response.code()).isEqualTo(401);
-  }
-
-  private Request newRequest(String s) {
-    return newRequest(server.url(s));
-  }
-
-  private Request newRequest(HttpUrl url) {
-    return new Request.Builder()
-        .url(url)
-        .build();
-  }
-
-  private Response getResponse(Request request) throws IOException {
-    return client.newCall(request).execute();
-  }
-
-  /** Returns a gzipped copy of {@code bytes}. */
-  public Buffer gzip(String data) throws IOException {
-    Buffer result = new Buffer();
-    BufferedSink gzipSink = Okio.buffer(new GzipSink(result));
-    gzipSink.writeUtf8(data);
-    gzipSink.close();
-    return result;
-  }
-
-  private void assertContent(String expected, Response response, int limit)
-      throws IOException {
-    Assertions.assertThat(readAscii(response.body().byteStream(), limit)).isEqualTo(
-        expected);
-  }
-
-  private void assertContent(String expected, Response response) throws IOException {
-    assertContent(expected, response, Integer.MAX_VALUE);
-  }
-
-  private Set<String> newSet(String... elements) {
-    return new LinkedHashSet<>(Arrays.asList(elements));
-  }
-
-  enum TransferKind {
-    CHUNKED {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
-        response.setChunkedBody(content, chunkSize);
-      }
-
-      @Override RequestBody newRequestBody(String body) {
-        return new RequestBody() {
-          @Override public long contentLength() {
-            return -1L;
-          }
-
-          @Override public @Nullable MediaType contentType() {
-            return null;
-          }
-
-          @Override public void writeTo(BufferedSink sink) throws IOException {
-            sink.writeUtf8(body);
-          }
-        };
-      }
-    },
-    FIXED_LENGTH {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
-        response.setBody(content);
-      }
-
-      @Override RequestBody newRequestBody(String body) {
-        return new RequestBody() {
-          @Override public long contentLength() {
-            return Utf8.size(body);
-          }
-
-          @Override public @Nullable MediaType contentType() {
-            return null;
-          }
-
-          @Override public void writeTo(BufferedSink sink) throws IOException {
-            sink.writeUtf8(body);
-          }
-        };
-      }
-    },
-    END_OF_STREAM {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
-        response.setBody(content);
-        response.setSocketPolicy(DISCONNECT_AT_END);
-        response.removeHeader("Content-Length");
-      }
-
-      @Override RequestBody newRequestBody(String body) {
-        throw new AssumptionViolatedException("END_OF_STREAM not implemented for requests");
-      }
-    };
-
-    abstract void setBody(MockResponse response, Buffer content, int chunkSize) throws IOException;
-
-    abstract RequestBody newRequestBody(String body);
-
-    void setBody(MockResponse response, String content, int chunkSize) throws IOException {
-      setBody(response, new Buffer().writeUtf8(content), chunkSize);
-    }
-  }
-
-  enum ProxyConfig {
-    NO_PROXY() {
-      @Override public Call.Factory connect(MockWebServer server, OkHttpClient client) {
-        return client.newBuilder()
-            .proxy(Proxy.NO_PROXY)
-            .build();
-      }
-    },
-
-    CREATE_ARG() {
-      @Override public Call.Factory connect(MockWebServer server, OkHttpClient client) {
-        return client.newBuilder()
-            .proxy(server.toProxyAddress())
-            .build();
-      }
-    },
-
-    PROXY_SYSTEM_PROPERTY() {
-      @Override public Call.Factory connect(MockWebServer server, OkHttpClient client) {
-        System.setProperty("proxyHost", server.getHostName());
-        System.setProperty("proxyPort", Integer.toString(server.getPort()));
-        return client;
-      }
-    },
-
-    HTTP_PROXY_SYSTEM_PROPERTY() {
-      @Override public Call.Factory connect(MockWebServer server, OkHttpClient client) {
-        System.setProperty("http.proxyHost", server.getHostName());
-        System.setProperty("http.proxyPort", Integer.toString(server.getPort()));
-        return client;
-      }
-    },
-
-    HTTPS_PROXY_SYSTEM_PROPERTY() {
-      @Override public Call.Factory connect(MockWebServer server, OkHttpClient client) {
-        System.setProperty("https.proxyHost", server.getHostName());
-        System.setProperty("https.proxyPort", Integer.toString(server.getPort()));
-        return client;
-      }
-    };
-
-    public abstract Call.Factory connect(MockWebServer server, OkHttpClient client)
-        throws IOException;
-
-    public Call connect(
-        MockWebServer server, OkHttpClient client, HttpUrl url) throws IOException {
-      Request request = new Request.Builder()
-          .url(url)
-          .build();
-      return connect(server, client).newCall(request);
-    }
-  }
-
-  private static class RecordingTrustManager implements X509TrustManager {
-    private final List<String> calls = new ArrayList<>();
-    private final X509TrustManager delegate;
-
-    RecordingTrustManager(X509TrustManager delegate) {
-      this.delegate = delegate;
-    }
-
-    public X509Certificate[] getAcceptedIssuers() {
-      return delegate.getAcceptedIssuers();
-    }
-
-    public void checkClientTrusted(X509Certificate[] chain, String authType) {
-      calls.add("checkClientTrusted " + certificatesToString(chain));
-    }
-
-    public void checkServerTrusted(X509Certificate[] chain, String authType) {
-      calls.add("checkServerTrusted " + certificatesToString(chain));
-    }
-
-    private String certificatesToString(X509Certificate[] certificates) {
-      List<String> result = new ArrayList<>();
-      for (X509Certificate certificate : certificates) {
-        result.add(certificate.getSubjectDN() + " " + certificate.getSerialNumber());
-      }
-      return result.toString();
-    }
-  }
-
-  /**
-   * Tests that use this will fail unless boot classpath is set. Ex. {@code
-   * -Xbootclasspath/p:/tmp/alpn-boot-8.0.0.v20140317}
-   */
-  private void enableProtocol(Protocol protocol) {
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .protocols(Arrays.asList(protocol, Protocol.HTTP_1_1))
-        .build();
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.setProtocolNegotiationEnabled(true);
-    server.setProtocols(client.protocols());
-  }
-
-  /**
-   * Used during tests that involve TLS connection fallback attempts. OkHttp includes the
-   * TLS_FALLBACK_SCSV cipher on fallback connections. See {@link FallbackTestClientSocketFactory}
-   * for details.
-   */
-  private FallbackTestClientSocketFactory suppressTlsFallbackClientSocketFactory() {
-    return new FallbackTestClientSocketFactory(handshakeCertificates.sslSocketFactory());
-  }
-
-  private String getPlatform() {
-    return System.getProperty("okhttp.platform", "platform");
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java b/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java
deleted file mode 100644
index c12c6a417a..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-import okhttp3.internal.Util;
-import okio.BufferedSource;
-import okio.Okio;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameter;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-/** Runs the web platform URL tests against Java URL models. */
-@RunWith(Parameterized.class)
-public final class WebPlatformUrlTest {
-  @Parameterized.Parameters(name = "{0}")
-  public static List<Object[]> parameters() {
-    try {
-      List<Object[]> result = new ArrayList<>();
-      for (WebPlatformUrlTestData urlTestData : loadTests()) {
-        result.add(new Object[] {urlTestData});
-      }
-      return result;
-    } catch (IOException e) {
-      throw new AssertionError();
-    }
-  }
-
-  @Parameter
-  public WebPlatformUrlTestData testData;
-
-  private static final List<String> HTTP_URL_SCHEMES
-      = Util.immutableList("http", "https");
-  private static final List<String> KNOWN_FAILURES = Util.immutableList(
-      "Parsing: <http://example\t.\norg> against <http://example.org/foo/bar>",
-      "Parsing: <http://f:0/c> against <http://example.org/foo/bar>",
-      "Parsing: <http://f:00000000000000/c> against <http://example.org/foo/bar>",
-      "Parsing: <http://f:\n/c> against <http://example.org/foo/bar>",
-      "Parsing: <http://f:999999/c> against <http://example.org/foo/bar>",
-      "Parsing: <http://192.0x00A80001> against <about:blank>",
-      "Parsing: <http://%30%78%63%30%2e%30%32%35%30.01> against <http://other.com/>",
-      "Parsing: <http://192.168.0.257> against <http://other.com/>",
-      "Parsing: <http://ÔºêÔº∏ÔΩÉÔºêÔºéÔºêÔºíÔºïÔºêÔºéÔºêÔºë> against <http://other.com/>"
-  );
-
-  /** Test how {@link HttpUrl} does against the web platform test suite. */
-  @Test public void httpUrl() throws Exception {
-    if (!testData.scheme.isEmpty() && !HTTP_URL_SCHEMES.contains(testData.scheme)) {
-      System.err.println("Ignoring unsupported scheme " + testData.scheme);
-      return;
-    }
-    if (!testData.base.startsWith("https:")
-        && !testData.base.startsWith("http:")
-        && !testData.base.equals("about:blank")) {
-      System.err.println("Ignoring unsupported base " + testData.base);
-      return;
-    }
-
-    try {
-      testHttpUrl();
-      if (KNOWN_FAILURES.contains(testData.toString())) {
-        System.err.println("Expected failure but was success: " + testData);
-      }
-    } catch (Throwable e) {
-      if (KNOWN_FAILURES.contains(testData.toString())) {
-        System.err.println("Ignoring known failure: " + testData);
-        e.printStackTrace();
-      } else {
-        throw e;
-      }
-    }
-  }
-
-  private void testHttpUrl() {
-    HttpUrl url;
-    if (testData.base.equals("about:blank")) {
-      url = HttpUrl.parse(testData.input);
-    } else {
-      HttpUrl baseUrl = HttpUrl.get(testData.base);
-      url = baseUrl.resolve(testData.input);
-    }
-
-    if (testData.expectParseFailure()) {
-      assertThat(url).overridingErrorMessage("Expected URL to fail parsing").isNull();
-    } else {
-      assertThat(url).overridingErrorMessage(
-          "Expected URL to parse successfully, but was null").isNotNull();
-      String effectivePort = url.port() != HttpUrl.defaultPort(url.scheme())
-          ? Integer.toString(url.port())
-          : "";
-      String effectiveQuery = url.encodedQuery() != null ? "?" + url.encodedQuery() : "";
-      String effectiveFragment = url.encodedFragment() != null ? "#" + url.encodedFragment() : "";
-      String effectiveHost = url.host().contains(":")
-          ? ("[" + url.host() + "]")
-          : url.host();
-      assertThat(url.scheme()).overridingErrorMessage("scheme").isEqualTo(testData.scheme);
-      assertThat(effectiveHost).overridingErrorMessage("host").isEqualTo(testData.host);
-      assertThat(effectivePort).overridingErrorMessage("port").isEqualTo(testData.port);
-      assertThat(url.encodedPath()).overridingErrorMessage("path").isEqualTo(testData.path);
-      assertThat(effectiveQuery).overridingErrorMessage("query").isEqualTo(testData.query);
-      assertThat(effectiveFragment).overridingErrorMessage("fragment").isEqualTo(
-          testData.fragment);
-    }
-  }
-
-  private static List<WebPlatformUrlTestData> loadTests() throws IOException {
-    BufferedSource source = Okio.buffer(Okio.source(
-        WebPlatformUrlTest.class.getResourceAsStream("/web-platform-test-urltestdata.txt")));
-    return WebPlatformUrlTestData.load(source);
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTestData.java b/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTestData.java
deleted file mode 100644
index 72f92f9abf..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTestData.java
+++ /dev/null
@@ -1,157 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-import okhttp3.internal.Util;
-import okio.Buffer;
-import okio.BufferedSource;
-
-/**
- * A test from the <a href="https://github.com/w3c/web-platform-tests/tree/master/url">Web Platform
- * URL test suite</a>. Each test is a line of the file {@code urltestdata.txt}; the format is
- * informally specified by its JavaScript parser {@code urltestparser.js}; with which this class
- * attempts to be compatible.
- *
- * <p>Each line of the urltestdata.text file specifies a test. Lines look like this: <pre>   {@code
- *
- *   http://example\t.\norg http://example.org/foo/bar s:http h:example.org p:/
- * }</pre>
- */
-public final class WebPlatformUrlTestData {
-  String input;
-  String base;
-  String scheme = "";
-  String username = "";
-  String password = null;
-  String host = "";
-  String port = "";
-  String path = "";
-  String query = "";
-  String fragment = "";
-
-  public boolean expectParseFailure() {
-    return scheme.isEmpty();
-  }
-
-  private void set(String name, String value) {
-    switch (name) {
-      case "s":
-        scheme = value;
-        break;
-      case "u":
-        username = value;
-        break;
-      case "pass":
-        password = value;
-        break;
-      case "h":
-        host = value;
-        break;
-      case "port":
-        port = value;
-        break;
-      case "p":
-        path = value;
-        break;
-      case "q":
-        query = value;
-        break;
-      case "f":
-        fragment = value;
-        break;
-      default:
-        throw new IllegalArgumentException("unexpected attribute: " + value);
-    }
-  }
-
-  @Override public String toString() {
-    return Util.format("Parsing: <%s> against <%s>", input, base);
-  }
-
-  public static List<WebPlatformUrlTestData> load(BufferedSource source) throws IOException {
-    List<WebPlatformUrlTestData> list = new ArrayList<>();
-    for (String line; (line = source.readUtf8Line()) != null; ) {
-      if (line.isEmpty() || line.startsWith("#")) continue;
-
-      int i = 0;
-      String[] parts = line.split(" ");
-      WebPlatformUrlTestData element = new WebPlatformUrlTestData();
-      element.input = unescape(parts[i++]);
-
-      String base = i < parts.length ? parts[i++] : null;
-      element.base = (base == null || base.isEmpty())
-          ? list.get(list.size() - 1).base
-          : unescape(base);
-
-      for (; i < parts.length; i++) {
-        String piece = parts[i];
-        if (piece.startsWith("#")) continue;
-        String[] nameAndValue = piece.split(":", 2);
-        element.set(nameAndValue[0], unescape(nameAndValue[1]));
-      }
-
-      list.add(element);
-    }
-    return list;
-  }
-
-  private static String unescape(String s) throws EOFException {
-    Buffer in = new Buffer().writeUtf8(s);
-    StringBuilder result = new StringBuilder();
-    while (!in.exhausted()) {
-      int c = in.readUtf8CodePoint();
-      if (c != '\\') {
-        result.append((char) c);
-        continue;
-      }
-
-      switch (in.readUtf8CodePoint()) {
-        case '\\':
-          result.append('\\');
-          break;
-        case '#':
-          result.append('#');
-          break;
-        case 'n':
-          result.append('\n');
-          break;
-        case 'r':
-          result.append('\r');
-          break;
-        case 's':
-          result.append(' ');
-          break;
-        case 't':
-          result.append('\t');
-          break;
-        case 'f':
-          result.append('\f');
-          break;
-        case 'u':
-          result.append((char) Integer.parseInt(in.readUtf8(4), 16));
-          break;
-        default:
-          throw new IllegalArgumentException("unexpected escape character in " + s);
-      }
-    }
-
-    return result.toString();
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/WholeOperationTimeoutTest.java b/okhttp-tests/src/test/java/okhttp3/WholeOperationTimeoutTest.java
deleted file mode 100644
index 6d9dcef39f..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/WholeOperationTimeoutTest.java
+++ /dev/null
@@ -1,321 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.io.InterruptedIOException;
-import java.net.HttpURLConnection;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicReference;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okio.BufferedSink;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class WholeOperationTimeoutTest {
-  /** A large response body. Smaller bodies might successfully read after the socket is closed! */
-  private static final String BIG_ENOUGH_BODY = TestUtil.repeat('a', 64 * 1024);
-
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
-
-  private OkHttpClient client = clientTestRule.client;
-
-  @Test public void defaultConfigIsNoTimeout() throws Exception {
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Call call = client.newCall(request);
-    assertThat(call.timeout().timeoutNanos()).isEqualTo(0);
-  }
-
-  @Test public void configureClientDefault() throws Exception {
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    OkHttpClient timeoutClient = client.newBuilder()
-        .callTimeout(456, TimeUnit.MILLISECONDS)
-        .build();
-
-    Call call = timeoutClient.newCall(request);
-    assertThat(call.timeout().timeoutNanos()).isEqualTo(TimeUnit.MILLISECONDS.toNanos(456));
-  }
-
-  @Test public void timeoutWritingRequest() throws Exception {
-    server.enqueue(new MockResponse());
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .post(sleepingRequestBody(500))
-        .build();
-
-    Call call = client.newCall(request);
-    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
-    try {
-      call.execute();
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo("timeout");
-      assertThat(call.isCanceled()).isTrue();
-    }
-  }
-
-  @Test public void timeoutWritingRequestWithEnqueue() throws Exception {
-    server.enqueue(new MockResponse());
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .post(sleepingRequestBody(500))
-        .build();
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    final AtomicReference<Throwable> exceptionRef = new AtomicReference<>();
-
-    Call call = client.newCall(request);
-    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
-    call.enqueue(new Callback() {
-      @Override public void onFailure(Call call, IOException e) {
-        exceptionRef.set(e);
-        latch.countDown();
-      }
-
-      @Override public void onResponse(Call call, Response response) throws IOException {
-        response.close();
-        latch.countDown();
-      }
-    });
-
-    latch.await();
-    assertThat(call.isCanceled()).isTrue();
-    assertThat(exceptionRef.get()).isNotNull();
-  }
-
-  @Test public void timeoutProcessing() throws Exception {
-    server.enqueue(new MockResponse()
-        .setHeadersDelay(500, TimeUnit.MILLISECONDS));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    Call call = client.newCall(request);
-    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
-    try {
-      call.execute();
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo("timeout");
-      assertThat(call.isCanceled()).isTrue();
-    }
-  }
-
-  @Test public void timeoutProcessingWithEnqueue() throws Exception {
-    server.enqueue(new MockResponse()
-        .setHeadersDelay(500, TimeUnit.MILLISECONDS));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    final AtomicReference<Throwable> exceptionRef = new AtomicReference<>();
-
-    Call call = client.newCall(request);
-    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
-    call.enqueue(new Callback() {
-      @Override public void onFailure(Call call, IOException e) {
-        exceptionRef.set(e);
-        latch.countDown();
-      }
-
-      @Override public void onResponse(Call call, Response response) throws IOException {
-        response.close();
-        latch.countDown();
-      }
-    });
-
-    latch.await();
-    assertThat(call.isCanceled()).isTrue();
-    assertThat(exceptionRef.get()).isNotNull();
-  }
-
-  @Test public void timeoutReadingResponse() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody(BIG_ENOUGH_BODY));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    Call call = client.newCall(request);
-    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
-    Response response = call.execute();
-    Thread.sleep(500);
-    try {
-      response.body().source().readUtf8();
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo("timeout");
-      assertThat(call.isCanceled()).isTrue();
-    }
-  }
-
-  @Test public void timeoutReadingResponseWithEnqueue() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody(BIG_ENOUGH_BODY));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    final AtomicReference<Throwable> exceptionRef = new AtomicReference<>();
-
-    Call call = client.newCall(request);
-    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
-    call.enqueue(new Callback() {
-      @Override public void onFailure(Call call, IOException e) {
-        latch.countDown();
-      }
-
-      @Override public void onResponse(Call call, Response response) throws IOException {
-        try {
-          Thread.sleep(500);
-        } catch (InterruptedException e) {
-          throw new AssertionError();
-        }
-        try {
-          response.body().source().readUtf8();
-          fail();
-        } catch (IOException e) {
-          exceptionRef.set(e);
-        } finally {
-          latch.countDown();
-        }
-      }
-    });
-
-    latch.await();
-    assertThat(call.isCanceled()).isTrue();
-    assertThat(exceptionRef.get()).isNotNull();
-  }
-
-  @Test public void singleTimeoutForAllFollowUpRequests() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .setHeader("Location", "/b")
-        .setHeadersDelay(100, TimeUnit.MILLISECONDS));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .setHeader("Location", "/c")
-        .setHeadersDelay(100, TimeUnit.MILLISECONDS));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .setHeader("Location", "/d")
-        .setHeadersDelay(100, TimeUnit.MILLISECONDS));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .setHeader("Location", "/e")
-        .setHeadersDelay(100, TimeUnit.MILLISECONDS));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .setHeader("Location", "/f")
-        .setHeadersDelay(100, TimeUnit.MILLISECONDS));
-    server.enqueue(new MockResponse());
-
-    Request request = new Request.Builder()
-        .url(server.url("/a"))
-        .build();
-
-    Call call = client.newCall(request);
-    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
-    try {
-      call.execute();
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo("timeout");
-      assertThat(call.isCanceled()).isTrue();
-    }
-  }
-
-  @Test
-  public void timeoutFollowingRedirectOnNewConnection() throws Exception {
-    MockWebServer otherServer = new MockWebServer();
-
-    server.enqueue(
-        new MockResponse()
-            .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-            .setHeader("Location", otherServer.url("/")));
-
-    otherServer.enqueue(new MockResponse().setHeadersDelay(500, TimeUnit.MILLISECONDS));
-
-    Request request = new Request.Builder().url(server.url("/")).build();
-
-    Call call = client.newCall(request);
-    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
-    try {
-      call.execute();
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo("timeout");
-      assertThat(call.isCanceled()).isTrue();
-    }
-  }
-
-  @Test public void noTimeout() throws Exception {
-    server.enqueue(new MockResponse()
-        .setHeadersDelay(250, TimeUnit.MILLISECONDS)
-        .setBody(BIG_ENOUGH_BODY));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .post(sleepingRequestBody(250))
-        .build();
-
-    Call call = client.newCall(request);
-    call.timeout().timeout(1000, TimeUnit.MILLISECONDS);
-    Response response = call.execute();
-    Thread.sleep(250);
-    response.body().source().readUtf8();
-    response.close();
-    assertThat(call.isCanceled()).isFalse();
-  }
-
-  private RequestBody sleepingRequestBody(final int sleepMillis) {
-    return new RequestBody() {
-      @Override public MediaType contentType() {
-        return MediaType.parse("text/plain");
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        try {
-          sink.writeUtf8("abc");
-          sink.flush();
-          Thread.sleep(sleepMillis);
-          sink.writeUtf8("def");
-        } catch (InterruptedException e) {
-          throw new InterruptedIOException();
-        }
-      }
-    };
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/DoubleInetAddressDns.java b/okhttp-tests/src/test/java/okhttp3/internal/DoubleInetAddressDns.java
deleted file mode 100644
index 7811ff5d75..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/DoubleInetAddressDns.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal;
-
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.util.Arrays;
-import java.util.List;
-import okhttp3.Dns;
-
-/**
- * A network that always resolves two IP addresses per host. Use this when testing route selection
- * fallbacks to guarantee that a fallback address is available.
- */
-public class DoubleInetAddressDns implements Dns {
-  @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
-    List<InetAddress> addresses = Dns.SYSTEM.lookup(hostname);
-    return Arrays.asList(addresses.get(0), addresses.get(0));
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/RecordingAuthenticator.java b/okhttp-tests/src/test/java/okhttp3/internal/RecordingAuthenticator.java
deleted file mode 100644
index aeb34f742f..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/RecordingAuthenticator.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (C) 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal;
-
-import java.net.Authenticator;
-import java.net.PasswordAuthentication;
-import java.util.ArrayList;
-import java.util.List;
-
-public final class RecordingAuthenticator extends Authenticator {
-  /** base64("username:password") */
-  public static final String BASE_64_CREDENTIALS = "dXNlcm5hbWU6cGFzc3dvcmQ=";
-
-  public final List<String> calls = new ArrayList<>();
-  public final PasswordAuthentication authentication;
-
-  public RecordingAuthenticator(PasswordAuthentication authentication) {
-    this.authentication = authentication;
-  }
-
-  public RecordingAuthenticator() {
-    this(new PasswordAuthentication("username", "password".toCharArray()));
-  }
-
-  @Override protected PasswordAuthentication getPasswordAuthentication() {
-    this.calls.add("host=" + getRequestingHost()
-        + " port=" + getRequestingPort()
-        + " site=" + getRequestingSite().getHostName()
-        + " url=" + getRequestingURL()
-        + " type=" + getRequestorType()
-        + " prompt=" + getRequestingPrompt()
-        + " protocol=" + getRequestingProtocol()
-        + " scheme=" + getRequestingScheme());
-    return authentication;
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java b/okhttp-tests/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java
deleted file mode 100644
index 126fce4d7e..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-import javax.annotation.Nullable;
-import okhttp3.Authenticator;
-import okhttp3.Challenge;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.Route;
-
-public final class RecordingOkAuthenticator implements Authenticator {
-  public final List<Response> responses = new ArrayList<>();
-  public final List<Route> routes = new ArrayList<>();
-  public @Nullable String credential;
-  public @Nullable String scheme;
-
-  public RecordingOkAuthenticator(@Nullable String credential, @Nullable String scheme) {
-    this.credential = credential;
-    this.scheme = scheme;
-  }
-
-  public Response onlyResponse() {
-    if (responses.size() != 1) throw new IllegalStateException();
-    return responses.get(0);
-  }
-
-  public Route onlyRoute() {
-    if (routes.size() != 1) throw new IllegalStateException();
-    return routes.get(0);
-  }
-
-  @Override public Request authenticate(Route route, Response response) throws IOException {
-    if (route == null) throw new NullPointerException("route == null");
-    if (response == null) throw new NullPointerException("response == null");
-
-    responses.add(response);
-    routes.add(route);
-
-    if (!schemeMatches(response) || credential == null) return null;
-
-    String header = response.code() == 407 ? "Proxy-Authorization" : "Authorization";
-    return response.request().newBuilder()
-        .addHeader(header, credential)
-        .build();
-  }
-
-  private boolean schemeMatches(Response response) {
-    if (scheme == null) return true;
-
-    for (Challenge challenge : response.challenges()) {
-      if (challenge.scheme().equalsIgnoreCase(scheme)) return true;
-    }
-
-    return false;
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/SocketRecorder.java b/okhttp-tests/src/test/java/okhttp3/internal/SocketRecorder.java
deleted file mode 100644
index ba3b84f91e..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/SocketRecorder.java
+++ /dev/null
@@ -1,206 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.net.Socket;
-import java.util.Deque;
-import java.util.concurrent.LinkedBlockingDeque;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-import okhttp3.DelegatingSSLSocket;
-import okhttp3.DelegatingSSLSocketFactory;
-import okio.Buffer;
-import okio.ByteString;
-
-/** Records all bytes written and read from a socket and makes them available for inspection. */
-public final class SocketRecorder {
-  private final Deque<RecordedSocket> recordedSockets = new LinkedBlockingDeque<>();
-
-  /** Returns an SSLSocketFactory whose sockets will record all transmitted bytes. */
-  public SSLSocketFactory sslSocketFactory(SSLSocketFactory delegate) {
-    return new DelegatingSSLSocketFactory(delegate) {
-      @Override protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
-        RecordedSocket recordedSocket = new RecordedSocket();
-        recordedSockets.add(recordedSocket);
-        return new RecordingSSLSocket(sslSocket, recordedSocket);
-      }
-    };
-  }
-
-  public RecordedSocket takeSocket() {
-    return recordedSockets.remove();
-  }
-
-  /** A bidirectional transfer of unadulterated bytes over a socket. */
-  public static final class RecordedSocket {
-    private final Buffer bytesWritten = new Buffer();
-    private final Buffer bytesRead = new Buffer();
-
-    synchronized void byteWritten(int b) {
-      bytesWritten.writeByte(b);
-    }
-
-    synchronized void byteRead(int b) {
-      bytesRead.writeByte(b);
-    }
-
-    synchronized void bytesWritten(byte[] bytes, int offset, int length) {
-      bytesWritten.write(bytes, offset, length);
-    }
-
-    synchronized void bytesRead(byte[] bytes, int offset, int length) {
-      bytesRead.write(bytes, offset, length);
-    }
-
-    /** Returns all bytes that have been written to this socket. */
-    public synchronized ByteString bytesWritten() {
-      return bytesWritten.readByteString();
-    }
-
-    /** Returns all bytes that have been read from this socket. */
-    public synchronized ByteString bytesRead() {
-      return bytesRead.readByteString();
-    }
-  }
-
-  static final class RecordingInputStream extends InputStream {
-    private final Socket socket;
-    private final RecordedSocket recordedSocket;
-
-    RecordingInputStream(Socket socket, RecordedSocket recordedSocket) {
-      this.socket = socket;
-      this.recordedSocket = recordedSocket;
-    }
-
-    @Override public int read() throws IOException {
-      int b = socket.getInputStream().read();
-      if (b == -1) return -1;
-      recordedSocket.byteRead(b);
-      return b;
-    }
-
-    @Override public int read(byte[] b, int off, int len) throws IOException {
-      int read = socket.getInputStream().read(b, off, len);
-      if (read == -1) return -1;
-      recordedSocket.bytesRead(b, off, read);
-      return read;
-    }
-
-    @Override public void close() throws IOException {
-      socket.getInputStream().close();
-    }
-  }
-
-  static final class RecordingOutputStream extends OutputStream {
-    private final Socket socket;
-    private final RecordedSocket recordedSocket;
-
-    RecordingOutputStream(Socket socket, RecordedSocket recordedSocket) {
-      this.socket = socket;
-      this.recordedSocket = recordedSocket;
-    }
-
-    @Override public void write(int b) throws IOException {
-      socket.getOutputStream().write(b);
-      recordedSocket.byteWritten(b);
-    }
-
-    @Override public void write(byte[] b, int off, int len) throws IOException {
-      socket.getOutputStream().write(b, off, len);
-      recordedSocket.bytesWritten(b, off, len);
-    }
-
-    @Override public void close() throws IOException {
-      socket.getOutputStream().close();
-    }
-
-    @Override public void flush() throws IOException {
-      socket.getOutputStream().flush();
-    }
-  }
-
-  static final class RecordingSSLSocket extends DelegatingSSLSocket {
-    private final InputStream inputStream;
-    private final OutputStream outputStream;
-
-    RecordingSSLSocket(SSLSocket delegate, RecordedSocket recordedSocket) {
-      super(delegate);
-      inputStream = new RecordingInputStream(delegate, recordedSocket);
-      outputStream = new RecordingOutputStream(delegate, recordedSocket);
-    }
-
-    @Override public void startHandshake() throws IOException {
-      // Intercept the handshake to properly configure TLS extensions with Jetty ALPN. Jetty ALPN
-      // expects the real SSLSocket to be placed in the global map. Because we are wrapping the real
-      // SSLSocket, it confuses Jetty ALPN. This patches that up so things work as expected.
-      Class<?> alpn = null;
-      Class<?> provider = null;
-      try {
-        alpn = Class.forName("org.eclipse.jetty.alpn.ALPN");
-        provider = Class.forName("org.eclipse.jetty.alpn.ALPN$Provider");
-      } catch (ClassNotFoundException ignored) {
-      }
-
-      if (alpn == null || provider == null) {
-        // No Jetty, so nothing to worry about.
-        super.startHandshake();
-        return;
-      }
-
-      Object providerInstance = null;
-      Method putMethod = null;
-      try {
-        Method getMethod = alpn.getMethod("get", SSLSocket.class);
-        putMethod = alpn.getMethod("put", SSLSocket.class, provider);
-        providerInstance = getMethod.invoke(null, this);
-        if (providerInstance == null) {
-          // Jetty's on the classpath but TLS extensions weren't used.
-          super.startHandshake();
-          return;
-        }
-
-        // TLS extensions were used; replace with the real SSLSocket to make Jetty ALPN happy.
-        putMethod.invoke(null, delegate, providerInstance);
-        super.startHandshake();
-      } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
-        throw new AssertionError();
-      } finally {
-        // If we replaced the SSLSocket in the global map, we must put the original back for
-        // everything to work inside OkHttp.
-        if (providerInstance != null) {
-          try {
-            putMethod.invoke(null, this, providerInstance);
-          } catch (IllegalAccessException | InvocationTargetException e) {
-            throw new AssertionError();
-          }
-        }
-      }
-    }
-
-    @Override public InputStream getInputStream() throws IOException {
-      return inputStream;
-    }
-
-    @Override public OutputStream getOutputStream() throws IOException {
-      return outputStream;
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/UtilTest.java b/okhttp-tests/src/test/java/okhttp3/internal/UtilTest.java
deleted file mode 100644
index cac32a9922..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/UtilTest.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal;
-
-import java.util.Collections;
-import java.util.LinkedHashMap;
-import java.util.Map;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class UtilTest {
-  @Test public void immutableMap() {
-    Map<String, String> map = new LinkedHashMap<>();
-    map.put("a", "A");
-    Map<String, String> immutableCopy = Util.immutableMap(map);
-    assertThat(Collections.singletonMap("a", "A")).isEqualTo(immutableCopy);
-    map.clear();
-    assertThat(Collections.singletonMap("a", "A")).isEqualTo(immutableCopy);
-    try {
-      immutableCopy.clear();
-      fail();
-    } catch (UnsupportedOperationException expected) {
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java b/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
deleted file mode 100644
index 9e8f2a9893..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
+++ /dev/null
@@ -1,1816 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.cache;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.ArrayDeque;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Deque;
-import java.util.Iterator;
-import java.util.List;
-import java.util.NoSuchElementException;
-import java.util.concurrent.Executor;
-import okhttp3.internal.io.FaultyFileSystem;
-import okhttp3.internal.io.FileSystem;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.Okio;
-import okio.Source;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
-import org.junit.rules.Timeout;
-
-import static okhttp3.internal.cache.DiskLruCache.JOURNAL_FILE;
-import static okhttp3.internal.cache.DiskLruCache.JOURNAL_FILE_BACKUP;
-import static okhttp3.internal.cache.DiskLruCache.MAGIC;
-import static okhttp3.internal.cache.DiskLruCache.VERSION_1;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class DiskLruCacheTest {
-  @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
-  @Rule public final Timeout timeout = new Timeout(60 * 1000);
-
-  private final FaultyFileSystem fileSystem = new FaultyFileSystem(FileSystem.SYSTEM);
-  private final int appVersion = 100;
-  private File cacheDir;
-  private File journalFile;
-  private File journalBkpFile;
-  private final TestExecutor executor = new TestExecutor();
-
-  private DiskLruCache cache;
-  private final Deque<DiskLruCache> toClose = new ArrayDeque<>();
-
-  private void createNewCache() throws IOException {
-    createNewCacheWithSize(Integer.MAX_VALUE);
-  }
-
-  private void createNewCacheWithSize(int maxSize) throws IOException {
-    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, maxSize, executor);
-    synchronized (cache) {
-      cache.initialize();
-    }
-    toClose.add(cache);
-  }
-
-  @Before public void setUp() throws Exception {
-    cacheDir = tempDir.getRoot();
-    journalFile = new File(cacheDir, JOURNAL_FILE);
-    journalBkpFile = new File(cacheDir, JOURNAL_FILE_BACKUP);
-    createNewCache();
-  }
-
-  @After public void tearDown() throws Exception {
-    while (!toClose.isEmpty()) {
-      toClose.pop().close();
-    }
-  }
-
-  @Test public void emptyCache() throws Exception {
-    cache.close();
-    assertJournalEquals();
-  }
-
-  @Test public void recoverFromInitializationFailure() throws IOException {
-    // Add an uncommitted entry. This will get detected on initialization, and the cache will
-    // attempt to delete the file. Do not explicitly close the cache here so the entry is left as
-    // incomplete.
-    DiskLruCache.Editor creator = cache.edit("k1");
-    BufferedSink sink = Okio.buffer(creator.newSink(0));
-    sink.writeUtf8("Hello");
-    sink.close();
-
-    // Simulate a severe filesystem failure on the first initialization.
-    fileSystem.setFaultyDelete(new File(cacheDir, "k1.0.tmp"), true);
-    fileSystem.setFaultyDelete(cacheDir, true);
-
-    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
-    toClose.add(cache);
-
-    try {
-      cache.get("k1");
-      fail();
-    } catch (IOException expected) {
-    }
-
-    // Now let it operate normally.
-    fileSystem.setFaultyDelete(new File(cacheDir, "k1.0.tmp"), false);
-    fileSystem.setFaultyDelete(cacheDir, false);
-
-    DiskLruCache.Snapshot snapshot = cache.get("k1");
-    assertThat(snapshot).isNull();
-  }
-
-  @Test public void validateKey() throws Exception {
-    String key = null;
-    try {
-      key = "has_space ";
-      cache.edit(key);
-      fail("Expecting an IllegalArgumentException as the key was invalid.");
-    } catch (IllegalArgumentException iae) {
-      assertThat(iae.getMessage()).isEqualTo(
-          ("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\""));
-    }
-    try {
-      key = "has_CR\r";
-      cache.edit(key);
-      fail("Expecting an IllegalArgumentException as the key was invalid.");
-    } catch (IllegalArgumentException iae) {
-      assertThat(iae.getMessage()).isEqualTo(
-          ("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\""));
-    }
-    try {
-      key = "has_LF\n";
-      cache.edit(key);
-      fail("Expecting an IllegalArgumentException as the key was invalid.");
-    } catch (IllegalArgumentException iae) {
-      assertThat(iae.getMessage()).isEqualTo(
-          ("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\""));
-    }
-    try {
-      key = "has_invalid/";
-      cache.edit(key);
-      fail("Expecting an IllegalArgumentException as the key was invalid.");
-    } catch (IllegalArgumentException iae) {
-      assertThat(iae.getMessage()).isEqualTo(
-          ("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\""));
-    }
-    try {
-      key = "has_invalid\u2603";
-      cache.edit(key);
-      fail("Expecting an IllegalArgumentException as the key was invalid.");
-    } catch (IllegalArgumentException iae) {
-      assertThat(iae.getMessage()).isEqualTo(
-          ("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\""));
-    }
-    try {
-      key = "this_is_way_too_long_this_is_way_too_long_this_is_way_too_long_"
-          + "this_is_way_too_long_this_is_way_too_long_this_is_way_too_long";
-      cache.edit(key);
-      fail("Expecting an IllegalArgumentException as the key was too long.");
-    } catch (IllegalArgumentException iae) {
-      assertThat(iae.getMessage()).isEqualTo(
-          ("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\""));
-    }
-
-    // Test valid cases.
-
-    // Exactly 120.
-    key = "0123456789012345678901234567890123456789012345678901234567890123456789"
-        + "01234567890123456789012345678901234567890123456789";
-    cache.edit(key).abort();
-    // Contains all valid characters.
-    key = "abcdefghijklmnopqrstuvwxyz_0123456789";
-    cache.edit(key).abort();
-    // Contains dash.
-    key = "-20384573948576";
-    cache.edit(key).abort();
-  }
-
-  @Test public void writeAndReadEntry() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    setString(creator, 0, "ABC");
-    setString(creator, 1, "DE");
-    assertThat(creator.newSource(0)).isNull();
-    assertThat(creator.newSource(1)).isNull();
-    creator.commit();
-
-    DiskLruCache.Snapshot snapshot = cache.get("k1");
-    assertSnapshotValue(snapshot, 0, "ABC");
-    assertSnapshotValue(snapshot, 1, "DE");
-  }
-
-  @Test public void readAndWriteEntryAcrossCacheOpenAndClose() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    setString(creator, 0, "A");
-    setString(creator, 1, "B");
-    creator.commit();
-    cache.close();
-
-    createNewCache();
-    DiskLruCache.Snapshot snapshot = cache.get("k1");
-    assertSnapshotValue(snapshot, 0, "A");
-    assertSnapshotValue(snapshot, 1, "B");
-    snapshot.close();
-  }
-
-  @Test public void readAndWriteEntryWithoutProperClose() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    setString(creator, 0, "A");
-    setString(creator, 1, "B");
-    creator.commit();
-
-    // Simulate a dirty close of 'cache' by opening the cache directory again.
-    createNewCache();
-    DiskLruCache.Snapshot snapshot = cache.get("k1");
-    assertSnapshotValue(snapshot, 0, "A");
-    assertSnapshotValue(snapshot, 1, "B");
-    snapshot.close();
-  }
-
-  @Test public void journalWithEditAndPublish() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    assertJournalEquals("DIRTY k1"); // DIRTY must always be flushed.
-    setString(creator, 0, "AB");
-    setString(creator, 1, "C");
-    creator.commit();
-    cache.close();
-    assertJournalEquals("DIRTY k1", "CLEAN k1 2 1");
-  }
-
-  @Test public void revertedNewFileIsRemoveInJournal() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    assertJournalEquals("DIRTY k1"); // DIRTY must always be flushed.
-    setString(creator, 0, "AB");
-    setString(creator, 1, "C");
-    creator.abort();
-    cache.close();
-    assertJournalEquals("DIRTY k1", "REMOVE k1");
-  }
-
-  @Test public void unterminatedEditIsRevertedOnClose() throws Exception {
-    cache.edit("k1");
-    cache.close();
-    assertJournalEquals("DIRTY k1", "REMOVE k1");
-  }
-
-  @Test public void journalDoesNotIncludeReadOfYetUnpublishedValue() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    assertThat(cache.get("k1")).isNull();
-    setString(creator, 0, "A");
-    setString(creator, 1, "BC");
-    creator.commit();
-    cache.close();
-    assertJournalEquals("DIRTY k1", "CLEAN k1 1 2");
-  }
-
-  @Test public void journalWithEditAndPublishAndRead() throws Exception {
-    DiskLruCache.Editor k1Creator = cache.edit("k1");
-    setString(k1Creator, 0, "AB");
-    setString(k1Creator, 1, "C");
-    k1Creator.commit();
-    DiskLruCache.Editor k2Creator = cache.edit("k2");
-    setString(k2Creator, 0, "DEF");
-    setString(k2Creator, 1, "G");
-    k2Creator.commit();
-    DiskLruCache.Snapshot k1Snapshot = cache.get("k1");
-    k1Snapshot.close();
-    cache.close();
-    assertJournalEquals("DIRTY k1", "CLEAN k1 2 1", "DIRTY k2", "CLEAN k2 3 1", "READ k1");
-  }
-
-  @Test public void cannotOperateOnEditAfterPublish() throws Exception {
-    DiskLruCache.Editor editor = cache.edit("k1");
-    setString(editor, 0, "A");
-    setString(editor, 1, "B");
-    editor.commit();
-    assertInoperable(editor);
-  }
-
-  @Test public void cannotOperateOnEditAfterRevert() throws Exception {
-    DiskLruCache.Editor editor = cache.edit("k1");
-    setString(editor, 0, "A");
-    setString(editor, 1, "B");
-    editor.abort();
-    assertInoperable(editor);
-  }
-
-  @Test public void explicitRemoveAppliedToDiskImmediately() throws Exception {
-    DiskLruCache.Editor editor = cache.edit("k1");
-    setString(editor, 0, "ABC");
-    setString(editor, 1, "B");
-    editor.commit();
-    File k1 = getCleanFile("k1", 0);
-    assertThat(readFile(k1)).isEqualTo("ABC");
-    cache.remove("k1");
-    assertThat(fileSystem.exists(k1)).isFalse();
-  }
-
-  @Test public void removePreventsActiveEditFromStoringAValue() throws Exception {
-    set("a", "a", "a");
-    DiskLruCache.Editor a = cache.edit("a");
-    setString(a, 0, "a1");
-    assertThat(cache.remove("a")).isTrue();
-    setString(a, 1, "a2");
-    a.commit();
-    assertAbsent("a");
-  }
-
-  /**
-   * Each read sees a snapshot of the file at the time read was called. This means that two reads of
-   * the same key can see different data.
-   */
-  @Test public void readAndWriteOverlapsMaintainConsistency() throws Exception {
-    DiskLruCache.Editor v1Creator = cache.edit("k1");
-    setString(v1Creator, 0, "AAaa");
-    setString(v1Creator, 1, "BBbb");
-    v1Creator.commit();
-
-    DiskLruCache.Snapshot snapshot1 = cache.get("k1");
-    BufferedSource inV1 = Okio.buffer(snapshot1.getSource(0));
-    assertThat(inV1.readByte()).isEqualTo((byte) 'A');
-    assertThat(inV1.readByte()).isEqualTo((byte) 'A');
-
-    DiskLruCache.Editor v1Updater = cache.edit("k1");
-    setString(v1Updater, 0, "CCcc");
-    setString(v1Updater, 1, "DDdd");
-    v1Updater.commit();
-
-    DiskLruCache.Snapshot snapshot2 = cache.get("k1");
-    assertSnapshotValue(snapshot2, 0, "CCcc");
-    assertSnapshotValue(snapshot2, 1, "DDdd");
-    snapshot2.close();
-
-    assertThat(inV1.readByte()).isEqualTo((byte) 'a');
-    assertThat(inV1.readByte()).isEqualTo((byte) 'a');
-    assertSnapshotValue(snapshot1, 1, "BBbb");
-    snapshot1.close();
-  }
-
-  @Test public void openWithDirtyKeyDeletesAllFilesForThatKey() throws Exception {
-    cache.close();
-    File cleanFile0 = getCleanFile("k1", 0);
-    File cleanFile1 = getCleanFile("k1", 1);
-    File dirtyFile0 = getDirtyFile("k1", 0);
-    File dirtyFile1 = getDirtyFile("k1", 1);
-    writeFile(cleanFile0, "A");
-    writeFile(cleanFile1, "B");
-    writeFile(dirtyFile0, "C");
-    writeFile(dirtyFile1, "D");
-    createJournal("CLEAN k1 1 1", "DIRTY   k1");
-    createNewCache();
-    assertThat(fileSystem.exists(cleanFile0)).isFalse();
-    assertThat(fileSystem.exists(cleanFile1)).isFalse();
-    assertThat(fileSystem.exists(dirtyFile0)).isFalse();
-    assertThat(fileSystem.exists(dirtyFile1)).isFalse();
-    assertThat(cache.get("k1")).isNull();
-  }
-
-  @Test public void openWithInvalidVersionClearsDirectory() throws Exception {
-    cache.close();
-    generateSomeGarbageFiles();
-    createJournalWithHeader(MAGIC, "0", "100", "2", "");
-    createNewCache();
-    assertGarbageFilesAllDeleted();
-  }
-
-  @Test public void openWithInvalidAppVersionClearsDirectory() throws Exception {
-    cache.close();
-    generateSomeGarbageFiles();
-    createJournalWithHeader(MAGIC, "1", "101", "2", "");
-    createNewCache();
-    assertGarbageFilesAllDeleted();
-  }
-
-  @Test public void openWithInvalidValueCountClearsDirectory() throws Exception {
-    cache.close();
-    generateSomeGarbageFiles();
-    createJournalWithHeader(MAGIC, "1", "100", "1", "");
-    createNewCache();
-    assertGarbageFilesAllDeleted();
-  }
-
-  @Test public void openWithInvalidBlankLineClearsDirectory() throws Exception {
-    cache.close();
-    generateSomeGarbageFiles();
-    createJournalWithHeader(MAGIC, "1", "100", "2", "x");
-    createNewCache();
-    assertGarbageFilesAllDeleted();
-  }
-
-  @Test public void openWithInvalidJournalLineClearsDirectory() throws Exception {
-    cache.close();
-    generateSomeGarbageFiles();
-    createJournal("CLEAN k1 1 1", "BOGUS");
-    createNewCache();
-    assertGarbageFilesAllDeleted();
-    assertThat(cache.get("k1")).isNull();
-  }
-
-  @Test public void openWithInvalidFileSizeClearsDirectory() throws Exception {
-    cache.close();
-    generateSomeGarbageFiles();
-    createJournal("CLEAN k1 0000x001 1");
-    createNewCache();
-    assertGarbageFilesAllDeleted();
-    assertThat(cache.get("k1")).isNull();
-  }
-
-  @Test public void openWithTruncatedLineDiscardsThatLine() throws Exception {
-    cache.close();
-    writeFile(getCleanFile("k1", 0), "A");
-    writeFile(getCleanFile("k1", 1), "B");
-
-    BufferedSink sink = Okio.buffer(fileSystem.sink(journalFile));
-    sink.writeUtf8(MAGIC + "\n" + VERSION_1 + "\n100\n2\n\nCLEAN k1 1 1"); // no trailing newline
-    sink.close();
-    createNewCache();
-    assertThat(cache.get("k1")).isNull();
-
-    // The journal is not corrupt when editing after a truncated line.
-    set("k1", "C", "D");
-
-    cache.close();
-    createNewCache();
-    assertValue("k1", "C", "D");
-  }
-
-  @Test public void openWithTooManyFileSizesClearsDirectory() throws Exception {
-    cache.close();
-    generateSomeGarbageFiles();
-    createJournal("CLEAN k1 1 1 1");
-    createNewCache();
-    assertGarbageFilesAllDeleted();
-    assertThat(cache.get("k1")).isNull();
-  }
-
-  @Test public void keyWithSpaceNotPermitted() throws Exception {
-    try {
-      cache.edit("my key");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void keyWithNewlineNotPermitted() throws Exception {
-    try {
-      cache.edit("my\nkey");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void keyWithCarriageReturnNotPermitted() throws Exception {
-    try {
-      cache.edit("my\rkey");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void nullKeyThrows() throws Exception {
-    try {
-      cache.edit(null);
-      fail();
-    } catch (NullPointerException expected) {
-    }
-  }
-
-  @Test public void createNewEntryWithTooFewValuesFails() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    setString(creator, 1, "A");
-    try {
-      creator.commit();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-
-    assertThat(fileSystem.exists(getCleanFile("k1", 0))).isFalse();
-    assertThat(fileSystem.exists(getCleanFile("k1", 1))).isFalse();
-    assertThat(fileSystem.exists(getDirtyFile("k1", 0))).isFalse();
-    assertThat(fileSystem.exists(getDirtyFile("k1", 1))).isFalse();
-    assertThat(cache.get("k1")).isNull();
-
-    DiskLruCache.Editor creator2 = cache.edit("k1");
-    setString(creator2, 0, "B");
-    setString(creator2, 1, "C");
-    creator2.commit();
-  }
-
-  @Test public void revertWithTooFewValues() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    setString(creator, 1, "A");
-    creator.abort();
-    assertThat(fileSystem.exists(getCleanFile("k1", 0))).isFalse();
-    assertThat(fileSystem.exists(getCleanFile("k1", 1))).isFalse();
-    assertThat(fileSystem.exists(getDirtyFile("k1", 0))).isFalse();
-    assertThat(fileSystem.exists(getDirtyFile("k1", 1))).isFalse();
-    assertThat(cache.get("k1")).isNull();
-  }
-
-  @Test public void updateExistingEntryWithTooFewValuesReusesPreviousValues() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    setString(creator, 0, "A");
-    setString(creator, 1, "B");
-    creator.commit();
-
-    DiskLruCache.Editor updater = cache.edit("k1");
-    setString(updater, 0, "C");
-    updater.commit();
-
-    DiskLruCache.Snapshot snapshot = cache.get("k1");
-    assertSnapshotValue(snapshot, 0, "C");
-    assertSnapshotValue(snapshot, 1, "B");
-    snapshot.close();
-  }
-
-  @Test public void growMaxSize() throws Exception {
-    cache.close();
-    createNewCacheWithSize(10);
-    set("a", "a", "aaa"); // size 4
-    set("b", "bb", "bbbb"); // size 6
-    cache.setMaxSize(20);
-    set("c", "c", "c"); // size 12
-    assertThat(cache.size()).isEqualTo(12);
-  }
-
-  @Test public void shrinkMaxSizeEvicts() throws Exception {
-    cache.close();
-    createNewCacheWithSize(20);
-    set("a", "a", "aaa"); // size 4
-    set("b", "bb", "bbbb"); // size 6
-    set("c", "c", "c"); // size 12
-    cache.setMaxSize(10);
-    assertThat(executor.jobs.size()).isEqualTo(1);
-  }
-
-  @Test public void evictOnInsert() throws Exception {
-    cache.close();
-    createNewCacheWithSize(10);
-
-    set("a", "a", "aaa"); // size 4
-    set("b", "bb", "bbbb"); // size 6
-    assertThat(cache.size()).isEqualTo(10);
-
-    // Cause the size to grow to 12 should evict 'A'.
-    set("c", "c", "c");
-    cache.flush();
-    assertThat(cache.size()).isEqualTo(8);
-    assertAbsent("a");
-    assertValue("b", "bb", "bbbb");
-    assertValue("c", "c", "c");
-
-    // Causing the size to grow to 10 should evict nothing.
-    set("d", "d", "d");
-    cache.flush();
-    assertThat(cache.size()).isEqualTo(10);
-    assertAbsent("a");
-    assertValue("b", "bb", "bbbb");
-    assertValue("c", "c", "c");
-    assertValue("d", "d", "d");
-
-    // Causing the size to grow to 18 should evict 'B' and 'C'.
-    set("e", "eeee", "eeee");
-    cache.flush();
-    assertThat(cache.size()).isEqualTo(10);
-    assertAbsent("a");
-    assertAbsent("b");
-    assertAbsent("c");
-    assertValue("d", "d", "d");
-    assertValue("e", "eeee", "eeee");
-  }
-
-  @Test public void evictOnUpdate() throws Exception {
-    cache.close();
-    createNewCacheWithSize(10);
-
-    set("a", "a", "aa"); // size 3
-    set("b", "b", "bb"); // size 3
-    set("c", "c", "cc"); // size 3
-    assertThat(cache.size()).isEqualTo(9);
-
-    // Causing the size to grow to 11 should evict 'A'.
-    set("b", "b", "bbbb");
-    cache.flush();
-    assertThat(cache.size()).isEqualTo(8);
-    assertAbsent("a");
-    assertValue("b", "b", "bbbb");
-    assertValue("c", "c", "cc");
-  }
-
-  @Test public void evictionHonorsLruFromCurrentSession() throws Exception {
-    cache.close();
-    createNewCacheWithSize(10);
-    set("a", "a", "a");
-    set("b", "b", "b");
-    set("c", "c", "c");
-    set("d", "d", "d");
-    set("e", "e", "e");
-    cache.get("b").close(); // 'B' is now least recently used.
-
-    // Causing the size to grow to 12 should evict 'A'.
-    set("f", "f", "f");
-    // Causing the size to grow to 12 should evict 'C'.
-    set("g", "g", "g");
-    cache.flush();
-    assertThat(cache.size()).isEqualTo(10);
-    assertAbsent("a");
-    assertValue("b", "b", "b");
-    assertAbsent("c");
-    assertValue("d", "d", "d");
-    assertValue("e", "e", "e");
-    assertValue("f", "f", "f");
-  }
-
-  @Test public void evictionHonorsLruFromPreviousSession() throws Exception {
-    set("a", "a", "a");
-    set("b", "b", "b");
-    set("c", "c", "c");
-    set("d", "d", "d");
-    set("e", "e", "e");
-    set("f", "f", "f");
-    cache.get("b").close(); // 'B' is now least recently used.
-    assertThat(cache.size()).isEqualTo(12);
-    cache.close();
-    createNewCacheWithSize(10);
-
-    set("g", "g", "g");
-    cache.flush();
-    assertThat(cache.size()).isEqualTo(10);
-    assertAbsent("a");
-    assertValue("b", "b", "b");
-    assertAbsent("c");
-    assertValue("d", "d", "d");
-    assertValue("e", "e", "e");
-    assertValue("f", "f", "f");
-    assertValue("g", "g", "g");
-  }
-
-  @Test public void cacheSingleEntryOfSizeGreaterThanMaxSize() throws Exception {
-    cache.close();
-    createNewCacheWithSize(10);
-    set("a", "aaaaa", "aaaaaa"); // size=11
-    cache.flush();
-    assertAbsent("a");
-  }
-
-  @Test public void cacheSingleValueOfSizeGreaterThanMaxSize() throws Exception {
-    cache.close();
-    createNewCacheWithSize(10);
-    set("a", "aaaaaaaaaaa", "a"); // size=12
-    cache.flush();
-    assertAbsent("a");
-  }
-
-  @Test public void constructorDoesNotAllowZeroCacheSize() throws Exception {
-    try {
-      DiskLruCache.create(fileSystem, cacheDir, appVersion, 2, 0);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void constructorDoesNotAllowZeroValuesPerEntry() throws Exception {
-    try {
-      DiskLruCache.create(fileSystem, cacheDir, appVersion, 0, 10);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void removeAbsentElement() throws Exception {
-    cache.remove("a");
-  }
-
-  @Test public void readingTheSameStreamMultipleTimes() throws Exception {
-    set("a", "a", "b");
-    DiskLruCache.Snapshot snapshot = cache.get("a");
-    assertThat(snapshot.getSource(0)).isSameAs(snapshot.getSource(0));
-    snapshot.close();
-  }
-
-  @Test public void rebuildJournalOnRepeatedReads() throws Exception {
-    set("a", "a", "a");
-    set("b", "b", "b");
-    while (executor.jobs.isEmpty()) {
-      assertValue("a", "a", "a");
-      assertValue("b", "b", "b");
-    }
-  }
-
-  @Test public void rebuildJournalOnRepeatedEdits() throws Exception {
-    while (executor.jobs.isEmpty()) {
-      set("a", "a", "a");
-      set("b", "b", "b");
-    }
-    executor.jobs.removeFirst().run();
-
-    // Sanity check that a rebuilt journal behaves normally.
-    assertValue("a", "a", "a");
-    assertValue("b", "b", "b");
-  }
-
-  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/28">Issue #28</a> */
-  @Test public void rebuildJournalOnRepeatedReadsWithOpenAndClose() throws Exception {
-    set("a", "a", "a");
-    set("b", "b", "b");
-    while (executor.jobs.isEmpty()) {
-      assertValue("a", "a", "a");
-      assertValue("b", "b", "b");
-      cache.close();
-      createNewCache();
-    }
-  }
-
-  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/28">Issue #28</a> */
-  @Test public void rebuildJournalOnRepeatedEditsWithOpenAndClose() throws Exception {
-    while (executor.jobs.isEmpty()) {
-      set("a", "a", "a");
-      set("b", "b", "b");
-      cache.close();
-      createNewCache();
-    }
-  }
-
-  @Test public void rebuildJournalFailurePreventsEditors() throws Exception {
-    while (executor.jobs.isEmpty()) {
-      set("a", "a", "a");
-      set("b", "b", "b");
-    }
-
-    // Cause the rebuild action to fail.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
-    executor.jobs.removeFirst().run();
-
-    // Don't allow edits under any circumstances.
-    assertThat(cache.edit("a")).isNull();
-    assertThat(cache.edit("c")).isNull();
-    DiskLruCache.Snapshot snapshot = cache.get("a");
-    assertThat(snapshot.edit()).isNull();
-    snapshot.close();
-  }
-
-  @Test public void rebuildJournalFailureIsRetried() throws Exception {
-    while (executor.jobs.isEmpty()) {
-      set("a", "a", "a");
-      set("b", "b", "b");
-    }
-
-    // Cause the rebuild action to fail.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
-    executor.jobs.removeFirst().run();
-
-    // The rebuild is retried on cache hits and on cache edits.
-    DiskLruCache.Snapshot snapshot = cache.get("b");
-    snapshot.close();
-    assertThat(cache.edit("d")).isNull();
-    assertThat(executor.jobs.size()).isEqualTo(2);
-
-    // On cache misses, no retry job is queued.
-    assertThat(cache.get("c")).isNull();
-    assertThat(executor.jobs.size()).isEqualTo(2);
-
-    // Let the rebuild complete successfully.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), false);
-    executor.jobs.removeFirst().run();
-    assertJournalEquals("CLEAN a 1 1", "CLEAN b 1 1");
-  }
-
-  @Test public void rebuildJournalFailureWithInFlightEditors() throws Exception {
-    while (executor.jobs.isEmpty()) {
-      set("a", "a", "a");
-      set("b", "b", "b");
-    }
-    DiskLruCache.Editor commitEditor = cache.edit("c");
-    DiskLruCache.Editor abortEditor = cache.edit("d");
-    cache.edit("e"); // Grab an editor, but don't do anything with it.
-
-    // Cause the rebuild action to fail.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
-    executor.jobs.removeFirst().run();
-
-    // In-flight editors can commit and have their values retained.
-    setString(commitEditor, 0, "c");
-    setString(commitEditor, 1, "c");
-    commitEditor.commit();
-    assertValue("c", "c", "c");
-
-    abortEditor.abort();
-
-    // Let the rebuild complete successfully.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), false);
-    executor.jobs.removeFirst().run();
-    assertJournalEquals("CLEAN a 1 1", "CLEAN b 1 1", "DIRTY e", "CLEAN c 1 1");
-  }
-
-  @Test public void rebuildJournalFailureWithEditorsInFlightThenClose() throws Exception {
-    while (executor.jobs.isEmpty()) {
-      set("a", "a", "a");
-      set("b", "b", "b");
-    }
-    DiskLruCache.Editor commitEditor = cache.edit("c");
-    DiskLruCache.Editor abortEditor = cache.edit("d");
-    cache.edit("e"); // Grab an editor, but don't do anything with it.
-
-    // Cause the rebuild action to fail.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
-    executor.jobs.removeFirst().run();
-
-    setString(commitEditor, 0, "c");
-    setString(commitEditor, 1, "c");
-    commitEditor.commit();
-    assertValue("c", "c", "c");
-
-    abortEditor.abort();
-
-    cache.close();
-    createNewCache();
-
-    // Although 'c' successfully committed above, the journal wasn't available to issue a CLEAN op.
-    // Because the last state of 'c' was DIRTY before the journal failed, it should be removed
-    // entirely on a subsequent open.
-    assertThat(cache.size()).isEqualTo(4);
-    assertAbsent("c");
-    assertAbsent("d");
-    assertAbsent("e");
-  }
-
-  @Test public void rebuildJournalFailureAllowsRemovals() throws Exception {
-    while (executor.jobs.isEmpty()) {
-      set("a", "a", "a");
-      set("b", "b", "b");
-    }
-
-    // Cause the rebuild action to fail.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
-    executor.jobs.removeFirst().run();
-
-    assertThat(cache.remove("a")).isTrue();
-    assertAbsent("a");
-
-    // Let the rebuild complete successfully.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), false);
-    executor.jobs.removeFirst().run();
-
-    assertJournalEquals("CLEAN b 1 1");
-  }
-
-  @Test public void rebuildJournalFailureWithRemovalThenClose() throws Exception {
-    while (executor.jobs.isEmpty()) {
-      set("a", "a", "a");
-      set("b", "b", "b");
-    }
-
-    // Cause the rebuild action to fail.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
-    executor.jobs.removeFirst().run();
-
-    assertThat(cache.remove("a")).isTrue();
-    assertAbsent("a");
-
-    cache.close();
-    createNewCache();
-
-    // The journal will have no record that 'a' was removed. It will have an entry for 'a', but when
-    // it tries to read the cache files, it will find they were deleted. Once it encounters an entry
-    // with missing cache files, it should remove it from the cache entirely.
-    assertThat(cache.size()).isEqualTo(4);
-    assertThat(cache.get("a")).isNull();
-    assertThat(cache.size()).isEqualTo(2);
-  }
-
-  @Test public void rebuildJournalFailureAllowsEvictAll() throws Exception {
-    while (executor.jobs.isEmpty()) {
-      set("a", "a", "a");
-      set("b", "b", "b");
-    }
-
-    // Cause the rebuild action to fail.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
-    executor.jobs.removeFirst().run();
-
-    cache.evictAll();
-
-    assertThat(cache.size()).isEqualTo(0);
-    assertAbsent("a");
-    assertAbsent("b");
-
-    cache.close();
-    createNewCache();
-
-    // The journal has no record that 'a' and 'b' were removed. It will have an entry for both, but
-    // when it tries to read the cache files for either entry, it will discover the cache files are
-    // missing and remove the entries from the cache.
-    assertThat(cache.size()).isEqualTo(4);
-    assertThat(cache.get("a")).isNull();
-    assertThat(cache.get("b")).isNull();
-    assertThat(cache.size()).isEqualTo(0);
-  }
-
-  @Test public void rebuildJournalFailureWithCacheTrim() throws Exception {
-    while (executor.jobs.isEmpty()) {
-      set("a", "aa", "aa");
-      set("b", "bb", "bb");
-    }
-
-    // Cause the rebuild action to fail.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
-    executor.jobs.removeFirst().run();
-
-    // Trigger a job to trim the cache.
-    cache.setMaxSize(4);
-    executor.jobs.removeFirst().run();
-
-    assertAbsent("a");
-    assertValue("b", "bb", "bb");
-  }
-
-  @Test public void restoreBackupFile() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    setString(creator, 0, "ABC");
-    setString(creator, 1, "DE");
-    creator.commit();
-    cache.close();
-
-    fileSystem.rename(journalFile, journalBkpFile);
-    assertThat(fileSystem.exists(journalFile)).isFalse();
-
-    createNewCache();
-
-    DiskLruCache.Snapshot snapshot = cache.get("k1");
-    assertSnapshotValue(snapshot, 0, "ABC");
-    assertSnapshotValue(snapshot, 1, "DE");
-
-    assertThat(fileSystem.exists(journalBkpFile)).isFalse();
-    assertThat(fileSystem.exists(journalFile)).isTrue();
-  }
-
-  @Test public void journalFileIsPreferredOverBackupFile() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    setString(creator, 0, "ABC");
-    setString(creator, 1, "DE");
-    creator.commit();
-    cache.flush();
-
-    copyFile(journalFile, journalBkpFile);
-
-    creator = cache.edit("k2");
-    setString(creator, 0, "F");
-    setString(creator, 1, "GH");
-    creator.commit();
-    cache.close();
-
-    assertThat(fileSystem.exists(journalFile)).isTrue();
-    assertThat(fileSystem.exists(journalBkpFile)).isTrue();
-
-    createNewCache();
-
-    DiskLruCache.Snapshot snapshotA = cache.get("k1");
-    assertSnapshotValue(snapshotA, 0, "ABC");
-    assertSnapshotValue(snapshotA, 1, "DE");
-
-    DiskLruCache.Snapshot snapshotB = cache.get("k2");
-    assertSnapshotValue(snapshotB, 0, "F");
-    assertSnapshotValue(snapshotB, 1, "GH");
-
-    assertThat(fileSystem.exists(journalBkpFile)).isFalse();
-    assertThat(fileSystem.exists(journalFile)).isTrue();
-  }
-
-  @Test public void openCreatesDirectoryIfNecessary() throws Exception {
-    cache.close();
-    File dir = tempDir.newFolder("testOpenCreatesDirectoryIfNecessary");
-    cache = DiskLruCache.create(fileSystem, dir, appVersion, 2, Integer.MAX_VALUE);
-    set("a", "a", "a");
-    assertThat(fileSystem.exists(new File(dir, "a.0"))).isTrue();
-    assertThat(fileSystem.exists(new File(dir, "a.1"))).isTrue();
-    assertThat(fileSystem.exists(new File(dir, "journal"))).isTrue();
-  }
-
-  @Test public void fileDeletedExternally() throws Exception {
-    set("a", "a", "a");
-    fileSystem.delete(getCleanFile("a", 1));
-    assertThat(cache.get("a")).isNull();
-    assertThat(cache.size()).isEqualTo(0);
-  }
-
-  @Test public void editSameVersion() throws Exception {
-    set("a", "a", "a");
-    DiskLruCache.Snapshot snapshot = cache.get("a");
-    DiskLruCache.Editor editor = snapshot.edit();
-    setString(editor, 1, "a2");
-    editor.commit();
-    assertValue("a", "a", "a2");
-  }
-
-  @Test public void editSnapshotAfterChangeAborted() throws Exception {
-    set("a", "a", "a");
-    DiskLruCache.Snapshot snapshot = cache.get("a");
-    DiskLruCache.Editor toAbort = snapshot.edit();
-    setString(toAbort, 0, "b");
-    toAbort.abort();
-    DiskLruCache.Editor editor = snapshot.edit();
-    setString(editor, 1, "a2");
-    editor.commit();
-    assertValue("a", "a", "a2");
-  }
-
-  @Test public void editSnapshotAfterChangeCommitted() throws Exception {
-    set("a", "a", "a");
-    DiskLruCache.Snapshot snapshot = cache.get("a");
-    DiskLruCache.Editor toAbort = snapshot.edit();
-    setString(toAbort, 0, "b");
-    toAbort.commit();
-    assertThat(snapshot.edit()).isNull();
-  }
-
-  @Test public void editSinceEvicted() throws Exception {
-    cache.close();
-    createNewCacheWithSize(10);
-    set("a", "aa", "aaa"); // size 5
-    DiskLruCache.Snapshot snapshot = cache.get("a");
-    set("b", "bb", "bbb"); // size 5
-    set("c", "cc", "ccc"); // size 5; will evict 'A'
-    cache.flush();
-    assertThat(snapshot.edit()).isNull();
-  }
-
-  @Test public void editSinceEvictedAndRecreated() throws Exception {
-    cache.close();
-    createNewCacheWithSize(10);
-    set("a", "aa", "aaa"); // size 5
-    DiskLruCache.Snapshot snapshot = cache.get("a");
-    set("b", "bb", "bbb"); // size 5
-    set("c", "cc", "ccc"); // size 5; will evict 'A'
-    set("a", "a", "aaaa"); // size 5; will evict 'B'
-    cache.flush();
-    assertThat(snapshot.edit()).isNull();
-  }
-
-  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
-  @Test public void aggressiveClearingHandlesWrite() throws Exception {
-    fileSystem.deleteContents(tempDir.getRoot());
-    set("a", "a", "a");
-    assertValue("a", "a", "a");
-  }
-
-  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
-  @Test public void aggressiveClearingHandlesEdit() throws Exception {
-    set("a", "a", "a");
-    DiskLruCache.Editor a = cache.get("a").edit();
-    fileSystem.deleteContents(tempDir.getRoot());
-    setString(a, 1, "a2");
-    a.commit();
-  }
-
-  @Test public void removeHandlesMissingFile() throws Exception {
-    set("a", "a", "a");
-    getCleanFile("a", 0).delete();
-    cache.remove("a");
-  }
-
-  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
-  @Test public void aggressiveClearingHandlesPartialEdit() throws Exception {
-    set("a", "a", "a");
-    set("b", "b", "b");
-    DiskLruCache.Editor a = cache.get("a").edit();
-    setString(a, 0, "a1");
-    fileSystem.deleteContents(tempDir.getRoot());
-    setString(a, 1, "a2");
-    a.commit();
-    assertThat(cache.get("a")).isNull();
-  }
-
-  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
-  @Test public void aggressiveClearingHandlesRead() throws Exception {
-    fileSystem.deleteContents(tempDir.getRoot());
-    assertThat(cache.get("a")).isNull();
-  }
-
-  /**
-   * We had a long-lived bug where {@link DiskLruCache#trimToSize} could infinite loop if entries
-   * being edited required deletion for the operation to complete.
-   */
-  @Test public void trimToSizeWithActiveEdit() throws Exception {
-    set("a", "a1234", "a1234");
-    DiskLruCache.Editor a = cache.edit("a");
-    setString(a, 0, "a123");
-
-    cache.setMaxSize(8); // Smaller than the sum of active edits!
-    cache.flush(); // Force trimToSize().
-    assertThat(cache.size()).isEqualTo(0);
-    assertThat(cache.get("a")).isNull();
-
-    // After the edit is completed, its entry is still gone.
-    setString(a, 1, "a1");
-    a.commit();
-    assertAbsent("a");
-    assertThat(cache.size()).isEqualTo(0);
-  }
-
-  @Test public void evictAll() throws Exception {
-    set("a", "a", "a");
-    set("b", "b", "b");
-    cache.evictAll();
-    assertThat(cache.size()).isEqualTo(0);
-    assertAbsent("a");
-    assertAbsent("b");
-  }
-
-  @Test public void evictAllWithPartialCreate() throws Exception {
-    DiskLruCache.Editor a = cache.edit("a");
-    setString(a, 0, "a1");
-    setString(a, 1, "a2");
-    cache.evictAll();
-    assertThat(cache.size()).isEqualTo(0);
-    a.commit();
-    assertAbsent("a");
-  }
-
-  @Test public void evictAllWithPartialEditDoesNotStoreAValue() throws Exception {
-    set("a", "a", "a");
-    DiskLruCache.Editor a = cache.edit("a");
-    setString(a, 0, "a1");
-    setString(a, 1, "a2");
-    cache.evictAll();
-    assertThat(cache.size()).isEqualTo(0);
-    a.commit();
-    assertAbsent("a");
-  }
-
-  @Test public void evictAllDoesntInterruptPartialRead() throws Exception {
-    set("a", "a", "a");
-    DiskLruCache.Snapshot a = cache.get("a");
-    assertSnapshotValue(a, 0, "a");
-    cache.evictAll();
-    assertThat(cache.size()).isEqualTo(0);
-    assertAbsent("a");
-    assertSnapshotValue(a, 1, "a");
-    a.close();
-  }
-
-  @Test public void editSnapshotAfterEvictAllReturnsNullDueToStaleValue() throws Exception {
-    set("a", "a", "a");
-    DiskLruCache.Snapshot a = cache.get("a");
-    cache.evictAll();
-    assertThat(cache.size()).isEqualTo(0);
-    assertAbsent("a");
-    assertThat(a.edit()).isNull();
-    a.close();
-  }
-
-  @Test public void iterator() throws Exception {
-    set("a", "a1", "a2");
-    set("b", "b1", "b2");
-    set("c", "c1", "c2");
-    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
-
-    assertThat(iterator.hasNext()).isTrue();
-    DiskLruCache.Snapshot a = iterator.next();
-    assertThat(a.key()).isEqualTo("a");
-    assertSnapshotValue(a, 0, "a1");
-    assertSnapshotValue(a, 1, "a2");
-    a.close();
-
-    assertThat(iterator.hasNext()).isTrue();
-    DiskLruCache.Snapshot b = iterator.next();
-    assertThat(b.key()).isEqualTo("b");
-    assertSnapshotValue(b, 0, "b1");
-    assertSnapshotValue(b, 1, "b2");
-    b.close();
-
-    assertThat(iterator.hasNext()).isTrue();
-    DiskLruCache.Snapshot c = iterator.next();
-    assertThat(c.key()).isEqualTo("c");
-    assertSnapshotValue(c, 0, "c1");
-    assertSnapshotValue(c, 1, "c2");
-    c.close();
-
-    assertThat(iterator.hasNext()).isFalse();
-    try {
-      iterator.next();
-      fail();
-    } catch (NoSuchElementException expected) {
-    }
-  }
-
-  @Test public void iteratorElementsAddedDuringIterationAreOmitted() throws Exception {
-    set("a", "a1", "a2");
-    set("b", "b1", "b2");
-    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
-
-    DiskLruCache.Snapshot a = iterator.next();
-    assertThat(a.key()).isEqualTo("a");
-    a.close();
-
-    set("c", "c1", "c2");
-
-    DiskLruCache.Snapshot b = iterator.next();
-    assertThat(b.key()).isEqualTo("b");
-    b.close();
-
-    assertThat(iterator.hasNext()).isFalse();
-  }
-
-  @Test public void iteratorElementsUpdatedDuringIterationAreUpdated() throws Exception {
-    set("a", "a1", "a2");
-    set("b", "b1", "b2");
-    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
-
-    DiskLruCache.Snapshot a = iterator.next();
-    assertThat(a.key()).isEqualTo("a");
-    a.close();
-
-    set("b", "b3", "b4");
-
-    DiskLruCache.Snapshot b = iterator.next();
-    assertThat(b.key()).isEqualTo("b");
-    assertSnapshotValue(b, 0, "b3");
-    assertSnapshotValue(b, 1, "b4");
-    b.close();
-  }
-
-  @Test public void iteratorElementsRemovedDuringIterationAreOmitted() throws Exception {
-    set("a", "a1", "a2");
-    set("b", "b1", "b2");
-    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
-
-    cache.remove("b");
-
-    DiskLruCache.Snapshot a = iterator.next();
-    assertThat(a.key()).isEqualTo("a");
-    a.close();
-
-    assertThat(iterator.hasNext()).isFalse();
-  }
-
-  @Test public void iteratorRemove() throws Exception {
-    set("a", "a1", "a2");
-    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
-
-    DiskLruCache.Snapshot a = iterator.next();
-    a.close();
-    iterator.remove();
-
-    assertThat(cache.get("a")).isNull();
-  }
-
-  @Test public void iteratorRemoveBeforeNext() throws Exception {
-    set("a", "a1", "a2");
-    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
-    try {
-      iterator.remove();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void iteratorRemoveOncePerCallToNext() throws Exception {
-    set("a", "a1", "a2");
-    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
-
-    DiskLruCache.Snapshot a = iterator.next();
-    iterator.remove();
-    a.close();
-
-    try {
-      iterator.remove();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void cacheClosedTruncatesIterator() throws Exception {
-    set("a", "a1", "a2");
-    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
-    cache.close();
-    assertThat(iterator.hasNext()).isFalse();
-  }
-
-  @Test public void isClosed_uninitializedCache() throws Exception {
-    // Create an uninitialized cache.
-    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
-    toClose.add(cache);
-
-    assertThat(cache.isClosed()).isFalse();
-    cache.close();
-    assertThat(cache.isClosed()).isTrue();
-  }
-
-  @Test public void journalWriteFailsDuringEdit() throws Exception {
-    set("a", "a", "a");
-    set("b", "b", "b");
-
-    // We can't begin the edit if writing 'DIRTY' fails.
-    fileSystem.setFaultyWrite(journalFile, true);
-    assertThat(cache.edit("c")).isNull();
-
-    // Once the journal has a failure, subsequent writes aren't permitted.
-    fileSystem.setFaultyWrite(journalFile, false);
-    assertThat(cache.edit("d")).isNull();
-
-    // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
-    cache.close();
-    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
-    assertValue("a", "a", "a");
-    assertValue("b", "b", "b");
-    assertAbsent("c");
-    assertAbsent("d");
-  }
-
-  /**
-   * We had a bug where the cache was left in an inconsistent state after a journal write failed.
-   * https://github.com/square/okhttp/issues/1211
-   */
-  @Test public void journalWriteFailsDuringEditorCommit() throws Exception {
-    set("a", "a", "a");
-    set("b", "b", "b");
-
-    // Create an entry that fails to write to the journal during commit.
-    DiskLruCache.Editor editor = cache.edit("c");
-    setString(editor, 0, "c");
-    setString(editor, 1, "c");
-    fileSystem.setFaultyWrite(journalFile, true);
-    editor.commit();
-
-    // Once the journal has a failure, subsequent writes aren't permitted.
-    fileSystem.setFaultyWrite(journalFile, false);
-    assertThat(cache.edit("d")).isNull();
-
-    // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
-    cache.close();
-    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
-    assertValue("a", "a", "a");
-    assertValue("b", "b", "b");
-    assertAbsent("c");
-    assertAbsent("d");
-  }
-
-  @Test public void journalWriteFailsDuringEditorAbort() throws Exception {
-    set("a", "a", "a");
-    set("b", "b", "b");
-
-    // Create an entry that fails to write to the journal during abort.
-    DiskLruCache.Editor editor = cache.edit("c");
-    setString(editor, 0, "c");
-    setString(editor, 1, "c");
-    fileSystem.setFaultyWrite(journalFile, true);
-    editor.abort();
-
-    // Once the journal has a failure, subsequent writes aren't permitted.
-    fileSystem.setFaultyWrite(journalFile, false);
-    assertThat(cache.edit("d")).isNull();
-
-    // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
-    cache.close();
-    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
-    assertValue("a", "a", "a");
-    assertValue("b", "b", "b");
-    assertAbsent("c");
-    assertAbsent("d");
-  }
-
-  @Test public void journalWriteFailsDuringRemove() throws Exception {
-    set("a", "a", "a");
-    set("b", "b", "b");
-
-    // Remove, but the journal write will fail.
-    fileSystem.setFaultyWrite(journalFile, true);
-    assertThat(cache.remove("a")).isTrue();
-
-    // Confirm that the entry was still removed.
-    fileSystem.setFaultyWrite(journalFile, false);
-    cache.close();
-    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
-    assertAbsent("a");
-    assertValue("b", "b", "b");
-  }
-
-  @Test public void cleanupTrimFailurePreventsNewEditors() throws Exception {
-    cache.setMaxSize(8);
-    executor.jobs.pop();
-    set("a", "aa", "aa");
-    set("b", "bb", "bbb");
-
-    // Cause the cache trim job to fail.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
-    executor.jobs.pop().run();
-
-    // Confirm that edits are prevented after a cache trim failure.
-    assertThat(cache.edit("a")).isNull();
-    assertThat(cache.edit("b")).isNull();
-    assertThat(cache.edit("c")).isNull();
-
-    // Allow the test to clean up.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
-  }
-
-  @Test public void cleanupTrimFailureRetriedOnEditors() throws Exception {
-    cache.setMaxSize(8);
-    executor.jobs.pop();
-    set("a", "aa", "aa");
-    set("b", "bb", "bbb");
-
-    // Cause the cache trim job to fail.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
-    executor.jobs.pop().run();
-
-    // An edit should now add a job to clean up if the most recent trim failed.
-    assertThat(cache.edit("b")).isNull();
-    executor.jobs.pop().run();
-
-    // Confirm a successful cache trim now allows edits.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
-    assertThat(cache.edit("c")).isNull();
-    executor.jobs.pop().run();
-    set("c", "cc", "cc");
-    assertValue("c", "cc", "cc");
-  }
-
-  @Test public void cleanupTrimFailureWithInFlightEditor() throws Exception {
-    cache.setMaxSize(8);
-    executor.jobs.pop();
-    set("a", "aa", "aaa");
-    set("b", "bb", "bb");
-    DiskLruCache.Editor inFlightEditor = cache.edit("c");
-
-    // Cause the cache trim job to fail.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
-    executor.jobs.pop().run();
-
-    // The in-flight editor can still write after a trim failure.
-    setString(inFlightEditor, 0, "cc");
-    setString(inFlightEditor, 1, "cc");
-    inFlightEditor.commit();
-
-    // Confirm the committed values are present after a successful cache trim.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
-    executor.jobs.pop().run();
-    assertValue("c", "cc", "cc");
-  }
-
-  @Test public void cleanupTrimFailureAllowsSnapshotReads() throws Exception {
-    cache.setMaxSize(8);
-    executor.jobs.pop();
-    set("a", "aa", "aa");
-    set("b", "bb", "bbb");
-
-    // Cause the cache trim job to fail.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
-    executor.jobs.pop().run();
-
-    // Confirm we still allow snapshot reads after a trim failure.
-    assertValue("a", "aa", "aa");
-    assertValue("b", "bb", "bbb");
-
-    // Allow the test to clean up.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
-  }
-
-  @Test public void cleanupTrimFailurePreventsSnapshotWrites() throws Exception {
-    cache.setMaxSize(8);
-    executor.jobs.pop();
-    set("a", "aa", "aa");
-    set("b", "bb", "bbb");
-
-    // Cause the cache trim job to fail.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
-    executor.jobs.pop().run();
-
-    // Confirm snapshot writes are prevented after a trim failure.
-    DiskLruCache.Snapshot snapshot1 = cache.get("a");
-    assertThat(snapshot1.edit()).isNull();
-    snapshot1.close();
-    DiskLruCache.Snapshot snapshot2 = cache.get("b");
-    assertThat(snapshot2.edit()).isNull();
-    snapshot2.close();
-
-    // Allow the test to clean up.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
-  }
-
-  @Test public void evictAllAfterCleanupTrimFailure() throws Exception {
-    cache.setMaxSize(8);
-    executor.jobs.pop();
-    set("a", "aa", "aa");
-    set("b", "bb", "bbb");
-
-    // Cause the cache trim job to fail.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
-    executor.jobs.pop().run();
-
-    // Confirm we prevent edits after a trim failure.
-    assertThat(cache.edit("c")).isNull();
-
-    // A successful eviction should allow new writes.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
-    cache.evictAll();
-    set("c", "cc", "cc");
-    assertValue("c", "cc", "cc");
-  }
-
-  @Test public void manualRemovalAfterCleanupTrimFailure() throws Exception {
-    cache.setMaxSize(8);
-    executor.jobs.pop();
-    set("a", "aa", "aa");
-    set("b", "bb", "bbb");
-
-    // Cause the cache trim job to fail.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
-    executor.jobs.pop().run();
-
-    // Confirm we prevent edits after a trim failure.
-    assertThat(cache.edit("c")).isNull();
-
-    // A successful removal which trims the cache should allow new writes.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
-    cache.remove("a");
-    set("c", "cc", "cc");
-    assertValue("c", "cc", "cc");
-  }
-
-  @Test public void flushingAfterCleanupTrimFailure() throws Exception {
-    cache.setMaxSize(8);
-    executor.jobs.pop();
-    set("a", "aa", "aa");
-    set("b", "bb", "bbb");
-
-    // Cause the cache trim job to fail.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
-    executor.jobs.pop().run();
-
-    // Confirm we prevent edits after a trim failure.
-    assertThat(cache.edit("c")).isNull();
-
-    // A successful flush trims the cache and should allow new writes.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
-    cache.flush();
-    set("c", "cc", "cc");
-    assertValue("c", "cc", "cc");
-  }
-
-  @Test public void cleanupTrimFailureWithPartialSnapshot() throws Exception {
-    cache.setMaxSize(8);
-    executor.jobs.pop();
-    set("a", "aa", "aa");
-    set("b", "bb", "bbb");
-
-    // Cause the cache trim to fail on the second value leaving a partial snapshot.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.1"), true);
-    executor.jobs.pop().run();
-
-    // Confirm the partial snapshot is not returned.
-    assertThat(cache.get("a")).isNull();
-
-    // Confirm we prevent edits after a trim failure.
-    assertThat(cache.edit("a")).isNull();
-
-    // Confirm the partial snapshot is not returned after a successful trim.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.1"), false);
-    executor.jobs.pop().run();
-    assertThat(cache.get("a")).isNull();
-  }
-
-  @Test public void noSizeCorruptionAfterCreatorDetached() throws Exception {
-    // Create an editor for k1. Detach it by clearing the cache.
-    DiskLruCache.Editor editor = cache.edit("k1");
-    setString(editor, 0, "a");
-    setString(editor, 1, "a");
-    cache.evictAll();
-
-    // Create a new value in its place.
-    set("k1", "bb", "bb");
-    assertThat(cache.size()).isEqualTo(4);
-
-    // Committing the detached editor should not change the cache's size.
-    editor.commit();
-    assertThat(cache.size()).isEqualTo(4);
-    assertValue("k1", "bb", "bb");
-  }
-
-  @Test public void noSizeCorruptionAfterEditorDetached() throws Exception {
-    set("k1", "a", "a");
-
-    // Create an editor for k1. Detach it by clearing the cache.
-    DiskLruCache.Editor editor = cache.edit("k1");
-    setString(editor, 0, "bb");
-    setString(editor, 1, "bb");
-    cache.evictAll();
-
-    // Create a new value in its place.
-    set("k1", "ccc", "ccc");
-    assertThat(cache.size()).isEqualTo(6);
-
-    // Committing the detached editor should not change the cache's size.
-    editor.commit();
-    assertThat(cache.size()).isEqualTo(6);
-    assertValue("k1", "ccc", "ccc");
-  }
-
-  @Test public void noNewSourceAfterEditorDetached() throws Exception {
-    set("k1", "a", "a");
-
-    DiskLruCache.Editor editor = cache.edit("k1");
-    cache.evictAll();
-
-    assertThat(editor.newSource(0)).isNull();
-  }
-
-  @Test public void editsDiscardedAfterEditorDetached() throws Exception {
-    set("k1", "a", "a");
-
-    // Create an editor, then detach it.
-    DiskLruCache.Editor editor = cache.edit("k1");
-    BufferedSink sink = Okio.buffer(editor.newSink(0));
-    cache.evictAll();
-
-    // Create another value in its place.
-    set("k1", "ccc", "ccc");
-
-    // Complete the original edit. It goes into a black hole.
-    sink.writeUtf8("bb");
-    sink.close();
-
-    assertValue("k1", "ccc", "ccc");
-  }
-
-  @Test public void abortAfterDetach() throws Exception {
-    set("k1", "a", "a");
-
-    DiskLruCache.Editor editor = cache.edit("k1");
-    cache.evictAll();
-
-    editor.abort();
-    assertThat(cache.size()).isEqualTo(0);
-    assertAbsent("k1");
-  }
-
-  private void assertJournalEquals(String... expectedBodyLines) throws Exception {
-    List<String> expectedLines = new ArrayList<>();
-    expectedLines.add(MAGIC);
-    expectedLines.add(VERSION_1);
-    expectedLines.add("100");
-    expectedLines.add("2");
-    expectedLines.add("");
-    expectedLines.addAll(Arrays.asList(expectedBodyLines));
-    assertThat(readJournalLines()).isEqualTo(expectedLines);
-  }
-
-  private void createJournal(String... bodyLines) throws Exception {
-    createJournalWithHeader(MAGIC, VERSION_1, "100", "2", "", bodyLines);
-  }
-
-  private void createJournalWithHeader(String magic, String version, String appVersion,
-      String valueCount, String blank, String... bodyLines) throws Exception {
-    BufferedSink sink = Okio.buffer(fileSystem.sink(journalFile));
-    sink.writeUtf8(magic + "\n");
-    sink.writeUtf8(version + "\n");
-    sink.writeUtf8(appVersion + "\n");
-    sink.writeUtf8(valueCount + "\n");
-    sink.writeUtf8(blank + "\n");
-    for (String line : bodyLines) {
-      sink.writeUtf8(line);
-      sink.writeUtf8("\n");
-    }
-    sink.close();
-  }
-
-  private List<String> readJournalLines() throws Exception {
-    List<String> result = new ArrayList<>();
-    BufferedSource source = Okio.buffer(fileSystem.source(journalFile));
-    for (String line; (line = source.readUtf8Line()) != null; ) {
-      result.add(line);
-    }
-    source.close();
-    return result;
-  }
-
-  private File getCleanFile(String key, int index) {
-    return new File(cacheDir, key + "." + index);
-  }
-
-  private File getDirtyFile(String key, int index) {
-    return new File(cacheDir, key + "." + index + ".tmp");
-  }
-
-  private String readFile(File file) throws Exception {
-    BufferedSource source = Okio.buffer(fileSystem.source(file));
-    String result = source.readUtf8();
-    source.close();
-    return result;
-  }
-
-  public void writeFile(File file, String content) throws Exception {
-    BufferedSink sink = Okio.buffer(fileSystem.sink(file));
-    sink.writeUtf8(content);
-    sink.close();
-  }
-
-  private static void assertInoperable(DiskLruCache.Editor editor) throws Exception {
-    try {
-      setString(editor, 0, "A");
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-    try {
-      editor.newSource(0);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-    try {
-      editor.newSink(0);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-    try {
-      editor.commit();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-    try {
-      editor.abort();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  private void generateSomeGarbageFiles() throws Exception {
-    File dir1 = new File(cacheDir, "dir1");
-    File dir2 = new File(dir1, "dir2");
-    writeFile(getCleanFile("g1", 0), "A");
-    writeFile(getCleanFile("g1", 1), "B");
-    writeFile(getCleanFile("g2", 0), "C");
-    writeFile(getCleanFile("g2", 1), "D");
-    writeFile(getCleanFile("g2", 1), "D");
-    writeFile(new File(cacheDir, "otherFile0"), "E");
-    writeFile(new File(dir2, "otherFile1"), "F");
-  }
-
-  private void assertGarbageFilesAllDeleted() {
-    assertThat(fileSystem.exists(getCleanFile("g1", 0))).isFalse();
-    assertThat(fileSystem.exists(getCleanFile("g1", 1))).isFalse();
-    assertThat(fileSystem.exists(getCleanFile("g2", 0))).isFalse();
-    assertThat(fileSystem.exists(getCleanFile("g2", 1))).isFalse();
-    assertThat(fileSystem.exists(new File(cacheDir, "otherFile0"))).isFalse();
-    assertThat(fileSystem.exists(new File(cacheDir, "dir1"))).isFalse();
-  }
-
-  private void set(String key, String value0, String value1) throws Exception {
-    DiskLruCache.Editor editor = cache.edit(key);
-    setString(editor, 0, value0);
-    setString(editor, 1, value1);
-    editor.commit();
-  }
-
-  public static void setString(DiskLruCache.Editor editor, int index, String value)
-      throws IOException {
-    BufferedSink writer = Okio.buffer(editor.newSink(index));
-    writer.writeUtf8(value);
-    writer.close();
-  }
-
-  private void assertAbsent(String key) throws Exception {
-    DiskLruCache.Snapshot snapshot = cache.get(key);
-    if (snapshot != null) {
-      snapshot.close();
-      fail();
-    }
-    assertThat(fileSystem.exists(getCleanFile(key, 0))).isFalse();
-    assertThat(fileSystem.exists(getCleanFile(key, 1))).isFalse();
-    assertThat(fileSystem.exists(getDirtyFile(key, 0))).isFalse();
-    assertThat(fileSystem.exists(getDirtyFile(key, 1))).isFalse();
-  }
-
-  private void assertValue(String key, String value0, String value1) throws Exception {
-    DiskLruCache.Snapshot snapshot = cache.get(key);
-    assertSnapshotValue(snapshot, 0, value0);
-    assertSnapshotValue(snapshot, 1, value1);
-    assertThat(fileSystem.exists(getCleanFile(key, 0))).isTrue();
-    assertThat(fileSystem.exists(getCleanFile(key, 1))).isTrue();
-    snapshot.close();
-  }
-
-  private void assertSnapshotValue(DiskLruCache.Snapshot snapshot, int index, String value)
-      throws IOException {
-    assertThat(sourceAsString(snapshot.getSource(index))).isEqualTo(value);
-    assertThat(snapshot.getLength(index)).isEqualTo(value.length());
-  }
-
-  private String sourceAsString(Source source) throws IOException {
-    return source != null ? Okio.buffer(source).readUtf8() : null;
-  }
-
-  private void copyFile(File from, File to) throws IOException {
-    Source source = fileSystem.source(from);
-    BufferedSink sink = Okio.buffer(fileSystem.sink(to));
-    sink.writeAll(source);
-    source.close();
-    sink.close();
-  }
-
-  private static class TestExecutor implements Executor {
-    final Deque<Runnable> jobs = new ArrayDeque<>();
-
-    @Override public void execute(Runnable command) {
-      jobs.addLast(command);
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/cache2/FileOperatorTest.java b/okhttp-tests/src/test/java/okhttp3/internal/cache2/FileOperatorTest.java
deleted file mode 100644
index cca27974fc..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/cache2/FileOperatorTest.java
+++ /dev/null
@@ -1,200 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.cache2;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.RandomAccessFile;
-import java.util.Random;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.Okio;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class FileOperatorTest {
-  @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
-
-  private File file;
-  private RandomAccessFile randomAccessFile;
-
-  @Before public void setUp() throws Exception {
-    file = tempDir.newFile();
-    randomAccessFile = new RandomAccessFile(file, "rw");
-  }
-
-  @After public void tearDown() throws Exception {
-    randomAccessFile.close();
-  }
-
-  @Test public void read() throws Exception {
-    write(ByteString.encodeUtf8("Hello, World"));
-
-    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
-
-    Buffer buffer = new Buffer();
-    operator.read(0, buffer, 5);
-    assertThat(buffer.readUtf8()).isEqualTo("Hello");
-
-    operator.read(4, buffer, 5);
-    assertThat(buffer.readUtf8()).isEqualTo("o, Wo");
-  }
-
-  @Test public void write() throws Exception {
-    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
-
-    Buffer buffer1 = new Buffer().writeUtf8("Hello, World");
-    operator.write(0, buffer1, 5);
-    assertThat(buffer1.readUtf8()).isEqualTo(", World");
-
-    Buffer buffer2 = new Buffer().writeUtf8("icopter!");
-    operator.write(3, buffer2, 7);
-    assertThat(buffer2.readUtf8()).isEqualTo("!");
-
-    assertThat(snapshot()).isEqualTo(ByteString.encodeUtf8("Helicopter"));
-  }
-
-  @Test public void readAndWrite() throws Exception {
-    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
-
-    write(ByteString.encodeUtf8("woman god creates dinosaurs destroys. "));
-    Buffer buffer = new Buffer();
-    operator.read(6, buffer, 21);
-    operator.read(36, buffer, 1);
-    operator.read(5, buffer, 5);
-    operator.read(28, buffer, 8);
-    operator.read(17, buffer, 10);
-    operator.read(36, buffer, 2);
-    operator.read(2, buffer, 4);
-    operator.write(0, buffer, buffer.size());
-    operator.read(0, buffer, 12);
-    operator.read(47, buffer, 3);
-    operator.read(45, buffer, 2);
-    operator.read(47, buffer, 3);
-    operator.read(26, buffer, 10);
-    operator.read(23, buffer, 3);
-    operator.write(47, buffer, buffer.size());
-    operator.read(62, buffer, 6);
-    operator.read(4, buffer, 19);
-    operator.write(80, buffer, buffer.size());
-
-    assertThat(ByteString.encodeUtf8(""
-        + "god creates dinosaurs. "
-        + "god destroys dinosaurs. "
-        + "god creates man. "
-        + "man destroys god. "
-        + "man creates dinosaurs. ")).isEqualTo(snapshot());
-  }
-
-  @Test public void multipleOperatorsShareOneFile() throws Exception {
-    FileOperator operatorA = new FileOperator(randomAccessFile.getChannel());
-    FileOperator operatorB = new FileOperator(randomAccessFile.getChannel());
-
-    Buffer bufferA = new Buffer();
-    Buffer bufferB = new Buffer();
-
-    bufferA.writeUtf8("Dodgson!\n");
-    operatorA.write(0, bufferA, 9);
-
-    bufferB.writeUtf8("You shouldn't use my name.\n");
-    operatorB.write(9, bufferB, 27);
-
-    bufferA.writeUtf8("Dodgson, we've got Dodgson here!\n");
-    operatorA.write(36, bufferA, 33);
-
-    operatorB.read(0, bufferB, 9);
-    assertThat(bufferB.readUtf8()).isEqualTo("Dodgson!\n");
-
-    operatorA.read(9, bufferA, 27);
-    assertThat(bufferA.readUtf8()).isEqualTo("You shouldn't use my name.\n");
-
-    operatorB.read(36, bufferB, 33);
-    assertThat(bufferB.readUtf8()).isEqualTo("Dodgson, we've got Dodgson here!\n");
-  }
-
-  @Test public void largeRead() throws Exception {
-    ByteString data = randomByteString(1000000);
-    write(data);
-
-    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
-
-    Buffer buffer = new Buffer();
-    operator.read(0, buffer, data.size());
-    assertThat(buffer.readByteString()).isEqualTo(data);
-  }
-
-  @Test public void largeWrite() throws Exception {
-    ByteString data = randomByteString(1000000);
-
-    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
-
-    Buffer buffer = new Buffer().write(data);
-    operator.write(0, buffer, data.size());
-
-    assertThat(snapshot()).isEqualTo(data);
-  }
-
-  @Test public void readBounds() throws Exception {
-    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
-    Buffer buffer = new Buffer();
-    try {
-      operator.read(0, buffer, -1L);
-      fail();
-    } catch (IndexOutOfBoundsException expected) {
-    }
-  }
-
-  @Test public void writeBounds() throws Exception {
-    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
-    Buffer buffer = new Buffer().writeUtf8("abc");
-    try {
-      operator.write(0, buffer, -1L);
-      fail();
-    } catch (IndexOutOfBoundsException expected) {
-    }
-    try {
-      operator.write(0, buffer, 4L);
-      fail();
-    } catch (IndexOutOfBoundsException expected) {
-    }
-  }
-
-  private ByteString randomByteString(int byteCount) {
-    byte[] bytes = new byte[byteCount];
-    new Random(0).nextBytes(bytes);
-    return ByteString.of(bytes);
-  }
-
-  private ByteString snapshot() throws IOException {
-    randomAccessFile.getChannel().force(false);
-    BufferedSource source = Okio.buffer(Okio.source(file));
-    return source.readByteString();
-  }
-
-  private void write(ByteString data) throws IOException {
-    BufferedSink sink = Okio.buffer(Okio.sink(file));
-    sink.write(data);
-    sink.close();
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/cache2/RelayTest.java b/okhttp-tests/src/test/java/okhttp3/internal/cache2/RelayTest.java
deleted file mode 100644
index 5e3911899f..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/cache2/RelayTest.java
+++ /dev/null
@@ -1,250 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.cache2;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.concurrent.Callable;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.Okio;
-import okio.Pipe;
-import okio.Source;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class RelayTest {
-  @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
-
-  private ExecutorService executor = Executors.newCachedThreadPool();
-  private ByteString metadata = ByteString.encodeUtf8("great metadata!");
-  private File file;
-
-  @Before public void setUp() throws Exception {
-    file = tempDir.newFile();
-  }
-
-  @After public void tearDown() throws Exception {
-    executor.shutdown();
-  }
-
-  @Test public void singleSource() throws Exception {
-    Buffer upstream = new Buffer();
-    upstream.writeUtf8("abcdefghijklm");
-
-    Relay relay = Relay.edit(file, upstream, metadata, 1024);
-    Source source = relay.newSource();
-    Buffer sourceBuffer = new Buffer();
-
-    assertThat(source.read(sourceBuffer, 5)).isEqualTo(5);
-    assertThat(sourceBuffer.readUtf8()).isEqualTo("abcde");
-
-    assertThat(source.read(sourceBuffer, 1024)).isEqualTo(8);
-    assertThat(sourceBuffer.readUtf8()).isEqualTo("fghijklm");
-
-    assertThat(source.read(sourceBuffer, 1024)).isEqualTo(-1);
-    assertThat(sourceBuffer.size()).isEqualTo(0);
-
-    source.close();
-    assertThat(relay.isClosed()).isTrue();
-    assertFile(Relay.PREFIX_CLEAN, 13L, metadata.size(), "abcdefghijklm", metadata);
-  }
-
-  @Test public void multipleSources() throws Exception {
-    Buffer upstream = new Buffer();
-    upstream.writeUtf8("abcdefghijklm");
-
-    Relay relay = Relay.edit(file, upstream, metadata, 1024);
-    BufferedSource source1 = Okio.buffer(relay.newSource());
-    BufferedSource source2 = Okio.buffer(relay.newSource());
-
-    assertThat(source1.readUtf8()).isEqualTo("abcdefghijklm");
-    assertThat(source2.readUtf8()).isEqualTo("abcdefghijklm");
-    source1.close();
-    source2.close();
-    assertThat(relay.isClosed()).isTrue();
-
-    assertFile(Relay.PREFIX_CLEAN, 13L, metadata.size(), "abcdefghijklm", metadata);
-  }
-
-  @Test public void readFromBuffer() throws Exception {
-    Buffer upstream = new Buffer();
-    upstream.writeUtf8("abcdefghij");
-
-    Relay relay = Relay.edit(file, upstream, metadata, 5);
-    BufferedSource source1 = Okio.buffer(relay.newSource());
-    BufferedSource source2 = Okio.buffer(relay.newSource());
-
-    assertThat(source1.readUtf8(5)).isEqualTo("abcde");
-    assertThat(source2.readUtf8(5)).isEqualTo("abcde");
-    assertThat(source2.readUtf8(5)).isEqualTo("fghij");
-    assertThat(source1.readUtf8(5)).isEqualTo("fghij");
-    assertThat(source1.exhausted()).isTrue();
-    assertThat(source2.exhausted()).isTrue();
-    source1.close();
-    source2.close();
-    assertThat(relay.isClosed()).isTrue();
-
-    assertFile(Relay.PREFIX_CLEAN, 10L, metadata.size(), "abcdefghij", metadata);
-  }
-
-  @Test public void readFromFile() throws Exception {
-    Buffer upstream = new Buffer();
-    upstream.writeUtf8("abcdefghijklmnopqrst");
-
-    Relay relay = Relay.edit(file, upstream, metadata, 5);
-    BufferedSource source1 = Okio.buffer(relay.newSource());
-    BufferedSource source2 = Okio.buffer(relay.newSource());
-
-    assertThat(source1.readUtf8(10)).isEqualTo("abcdefghij");
-    assertThat(source2.readUtf8(10)).isEqualTo("abcdefghij");
-    assertThat(source2.readUtf8(10)).isEqualTo("klmnopqrst");
-    assertThat(source1.readUtf8(10)).isEqualTo("klmnopqrst");
-    assertThat(source1.exhausted()).isTrue();
-    assertThat(source2.exhausted()).isTrue();
-    source1.close();
-    source2.close();
-    assertThat(relay.isClosed()).isTrue();
-
-    assertFile(Relay.PREFIX_CLEAN, 20L, metadata.size(), "abcdefghijklmnopqrst", metadata);
-  }
-
-  @Test public void readAfterEdit() throws Exception {
-    Buffer upstream = new Buffer();
-    upstream.writeUtf8("abcdefghij");
-
-    Relay relay1 = Relay.edit(file, upstream, metadata, 5);
-    BufferedSource source1 = Okio.buffer(relay1.newSource());
-    assertThat(source1.readUtf8(10)).isEqualTo("abcdefghij");
-    assertThat(source1.exhausted()).isTrue();
-    source1.close();
-    assertThat(relay1.isClosed()).isTrue();
-
-    // Since relay1 is closed, new sources cannot be created.
-    assertThat(relay1.newSource()).isNull();
-
-    Relay relay2 = Relay.read(file);
-    assertThat(relay2.metadata()).isEqualTo(metadata);
-    BufferedSource source2 = Okio.buffer(relay2.newSource());
-    assertThat(source2.readUtf8(10)).isEqualTo("abcdefghij");
-    assertThat(source2.exhausted()).isTrue();
-    source2.close();
-    assertThat(relay2.isClosed()).isTrue();
-
-    // Since relay2 is closed, new sources cannot be created.
-    assertThat(relay2.newSource()).isNull();
-
-    assertFile(Relay.PREFIX_CLEAN, 10L, metadata.size(), "abcdefghij", metadata);
-  }
-
-  @Test public void closeBeforeExhaustLeavesDirtyFile() throws Exception {
-    Buffer upstream = new Buffer();
-    upstream.writeUtf8("abcdefghij");
-
-    Relay relay1 = Relay.edit(file, upstream, metadata, 5);
-    BufferedSource source1 = Okio.buffer(relay1.newSource());
-    assertThat(source1.readUtf8(10)).isEqualTo("abcdefghij");
-    source1.close(); // Not exhausted!
-    assertThat(relay1.isClosed()).isTrue();
-
-    try {
-      Relay.read(file);
-      fail();
-    } catch (IOException expected) {
-      assertThat(expected.getMessage()).isEqualTo("unreadable cache file");
-    }
-
-    assertFile(Relay.PREFIX_DIRTY, -1L, -1, null, null);
-  }
-
-  @Test public void redundantCallsToCloseAreIgnored() throws Exception {
-    Buffer upstream = new Buffer();
-    upstream.writeUtf8("abcde");
-
-    Relay relay = Relay.edit(file, upstream, metadata, 1024);
-    Source source1 = relay.newSource();
-    Source source2 = relay.newSource();
-
-    source1.close();
-    source1.close(); // Unnecessary. Shouldn't decrement the reference count.
-    assertThat(relay.isClosed()).isFalse();
-
-    source2.close();
-    assertThat(relay.isClosed()).isTrue();
-    assertFile(Relay.PREFIX_DIRTY, -1L, -1, null, null);
-  }
-
-  @Test public void racingReaders() throws Exception {
-    Pipe pipe = new Pipe(1024);
-    BufferedSink sink = Okio.buffer(pipe.sink());
-
-    Relay relay = Relay.edit(file, pipe.source(), metadata, 5);
-
-    Future<ByteString> future1 = executor.submit(sourceReader(relay.newSource()));
-    Future<ByteString> future2 = executor.submit(sourceReader(relay.newSource()));
-
-    Thread.sleep(500);
-    sink.writeUtf8("abcdefghij");
-
-    Thread.sleep(500);
-    sink.writeUtf8("klmnopqrst");
-    sink.close();
-
-    assertThat(future1.get()).isEqualTo(ByteString.encodeUtf8("abcdefghijklmnopqrst"));
-    assertThat(future2.get()).isEqualTo(ByteString.encodeUtf8("abcdefghijklmnopqrst"));
-
-    assertThat(relay.isClosed()).isTrue();
-
-    assertFile(Relay.PREFIX_CLEAN, 20L, metadata.size(), "abcdefghijklmnopqrst", metadata);
-  }
-
-  /** Returns a callable that reads all of source, closes it, and returns the bytes. */
-  private Callable<ByteString> sourceReader(final Source source) {
-    return () -> {
-      Buffer buffer = new Buffer();
-      while (source.read(buffer, 16384) != -1) {
-      }
-      source.close();
-      return buffer.readByteString();
-    };
-  }
-
-  private void assertFile(ByteString prefix, long upstreamSize, int metadataSize, String upstream,
-      ByteString metadata) throws IOException {
-    BufferedSource source = Okio.buffer(Okio.source(file));
-    assertThat(source.readByteString(prefix.size())).isEqualTo(prefix);
-    assertThat(source.readLong()).isEqualTo(upstreamSize);
-    assertThat(source.readLong()).isEqualTo(metadataSize);
-    if (upstream != null) {
-      assertThat(source.readUtf8(upstreamSize)).isEqualTo(upstream);
-    }
-    if (metadata != null) {
-      assertThat(source.readByteString(metadataSize)).isEqualTo(metadata);
-    }
-    source.close();
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java b/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java
deleted file mode 100644
index 3224f9fa22..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java
+++ /dev/null
@@ -1,224 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.connection;
-
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import java.net.ProxySelector;
-import java.net.Socket;
-import java.util.Collections;
-import java.util.concurrent.TimeUnit;
-import javax.net.SocketFactory;
-import okhttp3.Address;
-import okhttp3.Call;
-import okhttp3.ConnectionPool;
-import okhttp3.Dns;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Route;
-import okhttp3.internal.Internal;
-import okhttp3.internal.RecordingOkAuthenticator;
-import org.junit.Test;
-
-import static okhttp3.TestUtil.awaitGarbageCollection;
-import static org.assertj.core.api.Assertions.assertThat;
-
-public final class ConnectionPoolTest {
-  private final Address addressA = newAddress("a");
-  private final Route routeA1 = newRoute(addressA);
-  private final Address addressB = newAddress("b");
-  private final Route routeB1 = newRoute(addressB);
-  private final Address addressC = newAddress("c");
-  private final Route routeC1 = newRoute(addressC);
-
-  static {
-    Internal.initializeInstanceForTests();
-  }
-
-  @Test public void connectionsEvictedWhenIdleLongEnough() throws Exception {
-    RealConnectionPool pool = new RealConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
-    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
-
-    RealConnection c1 = newConnection(pool, routeA1, 50L);
-
-    // Running at time 50, the pool returns that nothing can be evicted until time 150.
-    assertThat(pool.cleanup(50L)).isEqualTo(100L);
-    assertThat(pool.connectionCount()).isEqualTo(1);
-    assertThat(c1.socket().isClosed()).isFalse();
-
-    // Running at time 60, the pool returns that nothing can be evicted until time 150.
-    assertThat(pool.cleanup(60L)).isEqualTo(90L);
-    assertThat(pool.connectionCount()).isEqualTo(1);
-    assertThat(c1.socket().isClosed()).isFalse();
-
-    // Running at time 149, the pool returns that nothing can be evicted until time 150.
-    assertThat(pool.cleanup(149L)).isEqualTo(1L);
-    assertThat(pool.connectionCount()).isEqualTo(1);
-    assertThat(c1.socket().isClosed()).isFalse();
-
-    // Running at time 150, the pool evicts.
-    assertThat(pool.cleanup(150L)).isEqualTo(0);
-    assertThat(pool.connectionCount()).isEqualTo(0);
-    assertThat(c1.socket().isClosed()).isTrue();
-
-    // Running again, the pool reports that no further runs are necessary.
-    assertThat(pool.cleanup(150L)).isEqualTo(-1);
-    assertThat(pool.connectionCount()).isEqualTo(0);
-    assertThat(c1.socket().isClosed()).isTrue();
-  }
-
-  @Test public void inUseConnectionsNotEvicted() throws Exception {
-    ConnectionPool poolApi = new ConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
-    RealConnectionPool pool = Internal.instance.realConnectionPool(poolApi);
-    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
-
-    RealConnection c1 = newConnection(pool, routeA1, 50L);
-    synchronized (pool) {
-      OkHttpClient client = new OkHttpClient.Builder()
-          .connectionPool(poolApi)
-          .build();
-      Call call = client.newCall(newRequest(addressA));
-      Transmitter transmitter = new Transmitter(client, call);
-      transmitter.prepareToConnect(call.request());
-      transmitter.acquireConnectionNoEvents(c1);
-    }
-
-    // Running at time 50, the pool returns that nothing can be evicted until time 150.
-    assertThat(pool.cleanup(50L)).isEqualTo(100L);
-    assertThat(pool.connectionCount()).isEqualTo(1);
-    assertThat(c1.socket().isClosed()).isFalse();
-
-    // Running at time 60, the pool returns that nothing can be evicted until time 160.
-    assertThat(pool.cleanup(60L)).isEqualTo(100L);
-    assertThat(pool.connectionCount()).isEqualTo(1);
-    assertThat(c1.socket().isClosed()).isFalse();
-
-    // Running at time 160, the pool returns that nothing can be evicted until time 260.
-    assertThat(pool.cleanup(160L)).isEqualTo(100L);
-    assertThat(pool.connectionCount()).isEqualTo(1);
-    assertThat(c1.socket().isClosed()).isFalse();
-  }
-
-  @Test public void cleanupPrioritizesEarliestEviction() throws Exception {
-    RealConnectionPool pool = new RealConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
-    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
-
-    RealConnection c1 = newConnection(pool, routeA1, 75L);
-    RealConnection c2 = newConnection(pool, routeB1, 50L);
-
-    // Running at time 75, the pool returns that nothing can be evicted until time 150.
-    assertThat(pool.cleanup(75L)).isEqualTo(75L);
-    assertThat(pool.connectionCount()).isEqualTo(2);
-
-    // Running at time 149, the pool returns that nothing can be evicted until time 150.
-    assertThat(pool.cleanup(149L)).isEqualTo(1L);
-    assertThat(pool.connectionCount()).isEqualTo(2);
-
-    // Running at time 150, the pool evicts c2.
-    assertThat(pool.cleanup(150L)).isEqualTo(0L);
-    assertThat(pool.connectionCount()).isEqualTo(1);
-    assertThat(c1.socket().isClosed()).isFalse();
-    assertThat(c2.socket().isClosed()).isTrue();
-
-    // Running at time 150, the pool returns that nothing can be evicted until time 175.
-    assertThat(pool.cleanup(150L)).isEqualTo(25L);
-    assertThat(pool.connectionCount()).isEqualTo(1);
-
-    // Running at time 175, the pool evicts c1.
-    assertThat(pool.cleanup(175L)).isEqualTo(0L);
-    assertThat(pool.connectionCount()).isEqualTo(0);
-    assertThat(c1.socket().isClosed()).isTrue();
-    assertThat(c2.socket().isClosed()).isTrue();
-  }
-
-  @Test public void oldestConnectionsEvictedIfIdleLimitExceeded() throws Exception {
-    RealConnectionPool pool = new RealConnectionPool(2, 100L, TimeUnit.NANOSECONDS);
-    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
-
-    RealConnection c1 = newConnection(pool, routeA1, 50L);
-    RealConnection c2 = newConnection(pool, routeB1, 75L);
-
-    // With 2 connections, there's no need to evict until the connections time out.
-    assertThat(pool.cleanup(100L)).isEqualTo(50L);
-    assertThat(pool.connectionCount()).isEqualTo(2);
-    assertThat(c1.socket().isClosed()).isFalse();
-    assertThat(c2.socket().isClosed()).isFalse();
-
-    // Add a third connection
-    RealConnection c3 = newConnection(pool, routeC1, 75L);
-
-    // The third connection bounces the first.
-    assertThat(pool.cleanup(100L)).isEqualTo(0L);
-    assertThat(pool.connectionCount()).isEqualTo(2);
-    assertThat(c1.socket().isClosed()).isTrue();
-    assertThat(c2.socket().isClosed()).isFalse();
-    assertThat(c3.socket().isClosed()).isFalse();
-  }
-
-  @Test public void leakedAllocation() throws Exception {
-    ConnectionPool poolApi = new ConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
-    RealConnectionPool pool = Internal.instance.realConnectionPool(poolApi);
-    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
-
-    RealConnection c1 = newConnection(pool, routeA1, 0L);
-    allocateAndLeakAllocation(poolApi, c1);
-
-    awaitGarbageCollection();
-    assertThat(pool.cleanup(100L)).isEqualTo(0L);
-    assertThat(c1.transmitters).isEmpty();
-
-    // Can't allocate once a leak has been detected.
-    assertThat(c1.noNewExchanges).isTrue();
-  }
-
-  /** Use a helper method so there's no hidden reference remaining on the stack. */
-  private void allocateAndLeakAllocation(ConnectionPool pool, RealConnection connection) {
-    synchronized (Internal.instance.realConnectionPool(pool)) {
-      OkHttpClient client = new OkHttpClient.Builder()
-          .connectionPool(pool)
-          .build();
-      Call call = client.newCall(newRequest(connection.route().address()));
-      Transmitter transmitter = new Transmitter(client, call);
-      transmitter.prepareToConnect(call.request());
-      transmitter.acquireConnectionNoEvents(connection);
-    }
-  }
-
-  private RealConnection newConnection(RealConnectionPool pool, Route route, long idleAtNanos) {
-    RealConnection result = RealConnection.testConnection(pool, route, new Socket(), idleAtNanos);
-    synchronized (pool) {
-      pool.put(result);
-    }
-    return result;
-  }
-
-  private Address newAddress(String name) {
-    return new Address(name, 1, Dns.SYSTEM, SocketFactory.getDefault(), null, null, null,
-        new RecordingOkAuthenticator("password", null), null, Collections.emptyList(),
-        Collections.emptyList(), ProxySelector.getDefault());
-  }
-
-  private Route newRoute(Address address) {
-    return new Route(address, Proxy.NO_PROXY,
-        InetSocketAddress.createUnresolved(address.url().host(), address.url().port()));
-  }
-
-  private Request newRequest(Address address) {
-    return new Request.Builder()
-        .url(address.url())
-        .build();
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java b/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java
deleted file mode 100644
index f0c47d76d4..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java
+++ /dev/null
@@ -1,143 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.connection;
-
-import java.io.IOException;
-import java.security.cert.CertificateException;
-import java.util.Arrays;
-import java.util.LinkedHashSet;
-import java.util.Set;
-import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLSocket;
-import okhttp3.ConnectionSpec;
-import okhttp3.TlsVersion;
-import okhttp3.internal.Internal;
-import okhttp3.tls.HandshakeCertificates;
-import org.junit.Test;
-
-import static okhttp3.tls.internal.TlsUtil.localhost;
-import static org.assertj.core.api.Assertions.assertThat;
-
-public class ConnectionSpecSelectorTest {
-  static {
-    Internal.initializeInstanceForTests();
-  }
-
-  public static final SSLHandshakeException RETRYABLE_EXCEPTION = new SSLHandshakeException(
-      "Simulated handshake exception");
-
-  private HandshakeCertificates handshakeCertificates = localhost();
-
-  @Test
-  public void nonRetryableIOException() throws Exception {
-    ConnectionSpecSelector connectionSpecSelector =
-        createConnectionSpecSelector(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS);
-    SSLSocket socket = createSocketWithEnabledProtocols(TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
-    connectionSpecSelector.configureSecureSocket(socket);
-
-    boolean retry = connectionSpecSelector.connectionFailed(
-        new IOException("Non-handshake exception"));
-    assertThat(retry).isFalse();
-    socket.close();
-  }
-
-  @Test
-  public void nonRetryableSSLHandshakeException() throws Exception {
-    ConnectionSpecSelector connectionSpecSelector =
-        createConnectionSpecSelector(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS);
-    SSLSocket socket = createSocketWithEnabledProtocols(TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
-    connectionSpecSelector.configureSecureSocket(socket);
-
-    SSLHandshakeException trustIssueException =
-        new SSLHandshakeException("Certificate handshake exception");
-    trustIssueException.initCause(new CertificateException());
-    boolean retry = connectionSpecSelector.connectionFailed(trustIssueException);
-    assertThat(retry).isFalse();
-    socket.close();
-  }
-
-  @Test
-  public void retryableSSLHandshakeException() throws Exception {
-    ConnectionSpecSelector connectionSpecSelector =
-        createConnectionSpecSelector(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS);
-    SSLSocket socket = createSocketWithEnabledProtocols(
-        TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
-    connectionSpecSelector.configureSecureSocket(socket);
-
-    boolean retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
-    assertThat(retry).isTrue();
-    socket.close();
-  }
-
-  @Test
-  public void someFallbacksSupported() throws Exception {
-    ConnectionSpec sslV3 = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
-        .tlsVersions(TlsVersion.SSL_3_0)
-        .build();
-
-    ConnectionSpecSelector connectionSpecSelector = createConnectionSpecSelector(
-        ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS, sslV3);
-
-    TlsVersion[] enabledSocketTlsVersions = {
-        TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0
-    };
-    SSLSocket socket = createSocketWithEnabledProtocols(enabledSocketTlsVersions);
-
-    // MODERN_TLS is used here.
-    connectionSpecSelector.configureSecureSocket(socket);
-    assertEnabledProtocols(socket, TlsVersion.TLS_1_2);
-
-    boolean retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
-    assertThat(retry).isTrue();
-    socket.close();
-
-    // COMPATIBLE_TLS is used here.
-    socket = createSocketWithEnabledProtocols(enabledSocketTlsVersions);
-    connectionSpecSelector.configureSecureSocket(socket);
-    assertEnabledProtocols(socket, TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
-
-    retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
-    assertThat(retry).isFalse();
-    socket.close();
-
-    // sslV3 is not used because SSLv3 is not enabled on the socket.
-  }
-
-  private static ConnectionSpecSelector createConnectionSpecSelector(
-      ConnectionSpec... connectionSpecs) {
-    return new ConnectionSpecSelector(Arrays.asList(connectionSpecs));
-  }
-
-  private SSLSocket createSocketWithEnabledProtocols(TlsVersion... tlsVersions) throws IOException {
-    SSLSocket socket = (SSLSocket) handshakeCertificates.sslSocketFactory().createSocket();
-    socket.setEnabledProtocols(javaNames(tlsVersions));
-    return socket;
-  }
-
-  private static void assertEnabledProtocols(SSLSocket socket, TlsVersion... required) {
-    Set<String> actual = new LinkedHashSet<>(Arrays.asList(socket.getEnabledProtocols()));
-    Set<String> expected = new LinkedHashSet<>(Arrays.asList(javaNames(required)));
-    assertThat(actual).isEqualTo(expected);
-  }
-
-  private static String[] javaNames(TlsVersion... tlsVersions) {
-    String[] protocols = new String[tlsVersions.length];
-    for (int i = 0; i < tlsVersions.length; i++) {
-      protocols[i] = tlsVersions[i].javaName();
-    }
-    return protocols;
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteExceptionTest.java b/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteExceptionTest.java
deleted file mode 100644
index bce264a618..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteExceptionTest.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.connection;
-
-import java.io.IOException;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public class RouteExceptionTest {
-
-  @Test public void getConnectionIOException_single() {
-    IOException firstException = new IOException();
-    RouteException re = new RouteException(firstException);
-    assertThat(re.getFirstConnectException()).isSameAs(firstException);
-    assertThat(re.getLastConnectException()).isSameAs(firstException);
-  }
-
-  @Test public void getConnectionIOException_multiple() {
-    IOException firstException = new IOException();
-    IOException secondException = new IOException();
-    IOException thirdException = new IOException();
-    RouteException re = new RouteException(firstException);
-    re.addConnectException(secondException);
-    re.addConnectException(thirdException);
-
-    IOException connectionIOException = re.getFirstConnectException();
-    assertThat(connectionIOException).isSameAs(firstException);
-    Throwable[] suppressedExceptions = connectionIOException.getSuppressed();
-    assertThat(suppressedExceptions.length).isEqualTo(2);
-    assertThat(suppressedExceptions[0]).isSameAs(secondException);
-    assertThat(suppressedExceptions[1]).isSameAs(thirdException);
-
-    assertThat(re.getLastConnectException()).isSameAs(thirdException);
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java b/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java
deleted file mode 100644
index e1c870da1f..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java
+++ /dev/null
@@ -1,457 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.connection;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import java.net.ProxySelector;
-import java.net.SocketAddress;
-import java.net.URI;
-import java.net.UnknownHostException;
-import java.util.Arrays;
-import java.util.List;
-import java.util.NoSuchElementException;
-import javax.net.SocketFactory;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLSocketFactory;
-import okhttp3.Address;
-import okhttp3.Authenticator;
-import okhttp3.ConnectionSpec;
-import okhttp3.EventListener;
-import okhttp3.FakeDns;
-import okhttp3.Protocol;
-import okhttp3.Route;
-import okhttp3.internal.Util;
-import okhttp3.internal.http.RecordingProxySelector;
-import okhttp3.tls.HandshakeCertificates;
-import org.junit.Before;
-import org.junit.Test;
-
-import static java.net.Proxy.NO_PROXY;
-import static okhttp3.tls.internal.TlsUtil.localhost;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class RouteSelectorTest {
-  public final List<ConnectionSpec> connectionSpecs = Util.immutableList(
-      ConnectionSpec.MODERN_TLS,
-      ConnectionSpec.COMPATIBLE_TLS,
-      ConnectionSpec.CLEARTEXT);
-
-  private static final int proxyAPort = 1001;
-  private static final String proxyAHost = "proxya";
-  private static final Proxy proxyA =
-      new Proxy(Proxy.Type.HTTP, InetSocketAddress.createUnresolved(proxyAHost, proxyAPort));
-  private static final int proxyBPort = 1002;
-  private static final String proxyBHost = "proxyb";
-  private static final Proxy proxyB =
-      new Proxy(Proxy.Type.HTTP, InetSocketAddress.createUnresolved(proxyBHost, proxyBPort));
-  private String uriHost = "hosta";
-  private int uriPort = 1003;
-
-  private SocketFactory socketFactory;
-  private final HandshakeCertificates handshakeCertificates = localhost();
-  private final SSLSocketFactory sslSocketFactory = handshakeCertificates.sslSocketFactory();
-  private HostnameVerifier hostnameVerifier;
-
-  private final Authenticator authenticator = Authenticator.NONE;
-  private final List<Protocol> protocols = Arrays.asList(Protocol.HTTP_1_1);
-  private final FakeDns dns = new FakeDns();
-  private final RecordingProxySelector proxySelector = new RecordingProxySelector();
-  private RouteDatabase routeDatabase = new RouteDatabase();
-
-  @Before public void setUp() throws Exception {
-    socketFactory = SocketFactory.getDefault();
-    hostnameVerifier = HttpsURLConnection.getDefaultHostnameVerifier();
-  }
-
-  @Test public void singleRoute() throws Exception {
-    Address address = httpAddress();
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
-        EventListener.NONE);
-
-    assertThat(routeSelector.hasNext()).isTrue();
-    dns.set(uriHost, dns.allocate(1));
-    RouteSelector.Selection selection = routeSelector.next();
-    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
-    dns.assertRequests(uriHost);
-    assertThat(selection.hasNext()).isFalse();
-    try {
-      selection.next();
-      fail();
-    } catch (NoSuchElementException expected) {
-    }
-
-    assertThat(routeSelector.hasNext()).isFalse();
-    try {
-      routeSelector.next();
-      fail();
-    } catch (NoSuchElementException expected) {
-    }
-  }
-
-  @Test public void singleRouteReturnsFailedRoute() throws Exception {
-    Address address = httpAddress();
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
-        EventListener.NONE);
-
-    assertThat(routeSelector.hasNext()).isTrue();
-    dns.set(uriHost, dns.allocate(1));
-    RouteSelector.Selection selection = routeSelector.next();
-    Route route = selection.next();
-    routeDatabase.failed(route);
-    routeSelector = new RouteSelector(address, routeDatabase, null, EventListener.NONE);
-    selection = routeSelector.next();
-    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
-    assertThat(selection.hasNext()).isFalse();
-
-    try {
-      selection.next();
-      fail();
-    } catch (NoSuchElementException expected) {
-    }
-
-    assertThat(routeSelector.hasNext()).isFalse();
-    try {
-      routeSelector.next();
-      fail();
-    } catch (NoSuchElementException expected) {
-    }
-  }
-
-  @Test public void explicitProxyTriesThatProxysAddressesOnly() throws Exception {
-    Address address = new Address(uriHost, uriPort, dns, socketFactory, null, null, null,
-        authenticator, proxyA, protocols, connectionSpecs, proxySelector);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
-        EventListener.NONE);
-
-    assertThat(routeSelector.hasNext()).isTrue();
-    dns.set(proxyAHost, dns.allocate(2));
-    RouteSelector.Selection selection = routeSelector.next();
-    assertRoute(selection.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
-    assertRoute(selection.next(), address, proxyA, dns.lookup(proxyAHost, 1), proxyAPort);
-
-    assertThat(selection.hasNext()).isFalse();
-    assertThat(routeSelector.hasNext()).isFalse();
-    dns.assertRequests(proxyAHost);
-    proxySelector.assertRequests(); // No proxy selector requests!
-  }
-
-  @Test public void explicitDirectProxy() throws Exception {
-    Address address = new Address(uriHost, uriPort, dns, socketFactory, null, null, null,
-        authenticator, NO_PROXY, protocols, connectionSpecs, proxySelector);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
-        EventListener.NONE);
-
-    assertThat(routeSelector.hasNext()).isTrue();
-    dns.set(uriHost, dns.allocate(2));
-    RouteSelector.Selection selection = routeSelector.next();
-    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
-    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 1), uriPort);
-
-    assertThat(selection.hasNext()).isFalse();
-    assertThat(routeSelector.hasNext()).isFalse();
-    dns.assertRequests(uriHost);
-    proxySelector.assertRequests(); // No proxy selector requests!
-  }
-
-  @Test public void proxySelectorReturnsNull() throws Exception {
-    ProxySelector nullProxySelector = new ProxySelector() {
-      @Override public List<Proxy> select(URI uri) {
-        assertThat(uri.getHost()).isEqualTo(uriHost);
-        return null;
-      }
-
-      @Override public void connectFailed(
-          URI uri, SocketAddress socketAddress, IOException e) {
-        throw new AssertionError();
-      }
-    };
-
-    Address address = new Address(uriHost, uriPort, dns, socketFactory, null, null, null,
-        authenticator, null, protocols, connectionSpecs, nullProxySelector);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
-        EventListener.NONE);
-    assertThat(routeSelector.hasNext()).isTrue();
-    dns.set(uriHost, dns.allocate(1));
-    RouteSelector.Selection selection = routeSelector.next();
-    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
-    dns.assertRequests(uriHost);
-
-    assertThat(selection.hasNext()).isFalse();
-    assertThat(routeSelector.hasNext()).isFalse();
-  }
-
-  @Test public void proxySelectorReturnsNoProxies() throws Exception {
-    Address address = httpAddress();
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
-        EventListener.NONE);
-
-    assertThat(routeSelector.hasNext()).isTrue();
-    dns.set(uriHost, dns.allocate(2));
-    RouteSelector.Selection selection = routeSelector.next();
-    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
-    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 1), uriPort);
-
-    assertThat(selection.hasNext()).isFalse();
-    assertThat(routeSelector.hasNext()).isFalse();
-    dns.assertRequests(uriHost);
-    proxySelector.assertRequests(address.url().uri());
-  }
-
-  @Test public void proxySelectorReturnsMultipleProxies() throws Exception {
-    Address address = httpAddress();
-
-    proxySelector.proxies.add(proxyA);
-    proxySelector.proxies.add(proxyB);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
-        EventListener.NONE);
-    proxySelector.assertRequests(address.url().uri());
-
-    // First try the IP addresses of the first proxy, in sequence.
-    assertThat(routeSelector.hasNext()).isTrue();
-    dns.set(proxyAHost, dns.allocate(2));
-    RouteSelector.Selection selection1 = routeSelector.next();
-    assertRoute(selection1.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
-    assertRoute(selection1.next(), address, proxyA, dns.lookup(proxyAHost, 1), proxyAPort);
-    dns.assertRequests(proxyAHost);
-    assertThat(selection1.hasNext()).isFalse();
-
-    // Next try the IP address of the second proxy.
-    assertThat(routeSelector.hasNext()).isTrue();
-    dns.set(proxyBHost, dns.allocate(1));
-    RouteSelector.Selection selection2 = routeSelector.next();
-    assertRoute(selection2.next(), address, proxyB, dns.lookup(proxyBHost, 0), proxyBPort);
-    dns.assertRequests(proxyBHost);
-    assertThat(selection2.hasNext()).isFalse();
-
-    // No more proxies to try.
-    assertThat(routeSelector.hasNext()).isFalse();
-  }
-
-  @Test public void proxySelectorDirectConnectionsAreSkipped() throws Exception {
-    Address address = httpAddress();
-
-    proxySelector.proxies.add(NO_PROXY);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
-        EventListener.NONE);
-    proxySelector.assertRequests(address.url().uri());
-
-    // Only the origin server will be attempted.
-    assertThat(routeSelector.hasNext()).isTrue();
-    dns.set(uriHost, dns.allocate(1));
-    RouteSelector.Selection selection = routeSelector.next();
-    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
-    dns.assertRequests(uriHost);
-
-    assertThat(selection.hasNext()).isFalse();
-    assertThat(routeSelector.hasNext()).isFalse();
-  }
-
-  @Test public void proxyDnsFailureContinuesToNextProxy() throws Exception {
-    Address address = httpAddress();
-
-    proxySelector.proxies.add(proxyA);
-    proxySelector.proxies.add(proxyB);
-    proxySelector.proxies.add(proxyA);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
-        EventListener.NONE);
-    proxySelector.assertRequests(address.url().uri());
-
-    assertThat(routeSelector.hasNext()).isTrue();
-    dns.set(proxyAHost, dns.allocate(1));
-    RouteSelector.Selection selection1 = routeSelector.next();
-    assertRoute(selection1.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
-    dns.assertRequests(proxyAHost);
-    assertThat(selection1.hasNext()).isFalse();
-
-    assertThat(routeSelector.hasNext()).isTrue();
-    dns.clear(proxyBHost);
-    try {
-      routeSelector.next();
-      fail();
-    } catch (UnknownHostException expected) {
-    }
-    dns.assertRequests(proxyBHost);
-
-    assertThat(routeSelector.hasNext()).isTrue();
-    dns.set(proxyAHost, dns.allocate(1));
-    RouteSelector.Selection selection2 = routeSelector.next();
-    assertRoute(selection2.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
-    dns.assertRequests(proxyAHost);
-
-    assertThat(selection2.hasNext()).isFalse();
-    assertThat(routeSelector.hasNext()).isFalse();
-  }
-
-  @Test public void multipleProxiesMultipleInetAddressesMultipleConfigurations() throws Exception {
-    Address address = httpsAddress();
-    proxySelector.proxies.add(proxyA);
-    proxySelector.proxies.add(proxyB);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
-        EventListener.NONE);
-
-    // Proxy A
-    dns.set(proxyAHost, dns.allocate(2));
-    RouteSelector.Selection selection1 = routeSelector.next();
-    assertRoute(selection1.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
-    dns.assertRequests(proxyAHost);
-    assertRoute(selection1.next(), address, proxyA, dns.lookup(proxyAHost, 1), proxyAPort);
-    assertThat(selection1.hasNext()).isFalse();
-
-    // Proxy B
-    dns.set(proxyBHost, dns.allocate(2));
-    RouteSelector.Selection selection2 = routeSelector.next();
-    assertRoute(selection2.next(), address, proxyB, dns.lookup(proxyBHost, 0), proxyBPort);
-    dns.assertRequests(proxyBHost);
-    assertRoute(selection2.next(), address, proxyB, dns.lookup(proxyBHost, 1), proxyBPort);
-    assertThat(selection2.hasNext()).isFalse();
-
-    // No more proxies to attempt.
-    assertThat(routeSelector.hasNext()).isFalse();
-  }
-
-  @Test public void failedRouteWithSingleProxy() throws Exception {
-    Address address = httpsAddress();
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
-        EventListener.NONE);
-
-    final int numberOfAddresses = 2;
-    dns.set(uriHost, dns.allocate(numberOfAddresses));
-
-    // Extract the regular sequence of routes from selector.
-    RouteSelector.Selection selection1 = routeSelector.next();
-    List<Route> regularRoutes = selection1.getAll();
-
-    // Check that we do indeed have more than one route.
-    assertThat(regularRoutes.size()).isEqualTo(numberOfAddresses);
-    // Add first regular route as failed.
-    routeDatabase.failed(regularRoutes.get(0));
-    // Reset selector
-    routeSelector = new RouteSelector(address, routeDatabase, null, EventListener.NONE);
-
-    // The first selection prioritizes the non-failed routes.
-    RouteSelector.Selection selection2 = routeSelector.next();
-    assertThat(selection2.next()).isEqualTo(regularRoutes.get(1));
-    assertThat(selection2.hasNext()).isFalse();
-
-    // The second selection will contain all failed routes.
-    RouteSelector.Selection selection3 = routeSelector.next();
-    assertThat(selection3.next()).isEqualTo(regularRoutes.get(0));
-    assertThat(selection3.hasNext()).isFalse();
-
-    assertThat(routeSelector.hasNext()).isFalse();
-  }
-
-  @Test public void failedRouteWithMultipleProxies() throws IOException {
-    Address address = httpsAddress();
-    proxySelector.proxies.add(proxyA);
-    proxySelector.proxies.add(proxyB);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
-        EventListener.NONE);
-
-    dns.set(proxyAHost, dns.allocate(1));
-    dns.set(proxyBHost, dns.allocate(1));
-
-    // Mark the ProxyA route as failed.
-    RouteSelector.Selection selection = routeSelector.next();
-    dns.assertRequests(proxyAHost);
-    Route route = selection.next();
-    assertRoute(route, address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
-    routeDatabase.failed(route);
-
-    routeSelector = new RouteSelector(address, routeDatabase, null, EventListener.NONE);
-
-    // Confirm we enumerate both proxies, giving preference to the route from ProxyB.
-    RouteSelector.Selection selection2 = routeSelector.next();
-    dns.assertRequests(proxyAHost, proxyBHost);
-    assertRoute(selection2.next(), address, proxyB, dns.lookup(proxyBHost, 0), proxyBPort);
-    assertThat(selection2.hasNext()).isFalse();
-
-    // Confirm the last selection contains the postponed route from ProxyA.
-    RouteSelector.Selection selection3 = routeSelector.next();
-    dns.assertRequests();
-    assertRoute(selection3.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
-    assertThat(selection3.hasNext()).isFalse();
-
-    assertThat(routeSelector.hasNext()).isFalse();
-  }
-
-  @Test public void queryForAllSelectedRoutes() throws IOException {
-    Address address = httpAddress();
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
-        EventListener.NONE);
-
-    dns.set(uriHost, dns.allocate(2));
-    RouteSelector.Selection selection = routeSelector.next();
-    dns.assertRequests(uriHost);
-
-    List<Route> routes = selection.getAll();
-    assertRoute(routes.get(0), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
-    assertRoute(routes.get(1), address, NO_PROXY, dns.lookup(uriHost, 1), uriPort);
-
-    assertThat(selection.next()).isSameAs(routes.get(0));
-    assertThat(selection.next()).isSameAs(routes.get(1));
-    assertThat(selection.hasNext()).isFalse();
-    assertThat(routeSelector.hasNext()).isFalse();
-  }
-
-  @Test public void getHostString() throws Exception {
-    // Name proxy specification.
-    InetSocketAddress socketAddress = InetSocketAddress.createUnresolved("host", 1234);
-    assertThat(RouteSelector.getHostString(socketAddress)).isEqualTo("host");
-    socketAddress = InetSocketAddress.createUnresolved("127.0.0.1", 1234);
-    assertThat(RouteSelector.getHostString(socketAddress)).isEqualTo("127.0.0.1");
-
-    // InetAddress proxy specification.
-    socketAddress = new InetSocketAddress(InetAddress.getByName("localhost"), 1234);
-    assertThat(RouteSelector.getHostString(socketAddress)).isEqualTo("127.0.0.1");
-    socketAddress = new InetSocketAddress(
-        InetAddress.getByAddress(new byte[] {127, 0, 0, 1}), 1234);
-    assertThat(RouteSelector.getHostString(socketAddress)).isEqualTo("127.0.0.1");
-    socketAddress = new InetSocketAddress(
-        InetAddress.getByAddress("foobar", new byte[] {127, 0, 0, 1}), 1234);
-    assertThat(RouteSelector.getHostString(socketAddress)).isEqualTo("127.0.0.1");
-  }
-
-  @Test public void routeToString() throws Exception {
-    Route route = new Route(httpAddress(), Proxy.NO_PROXY,
-        InetSocketAddress.createUnresolved("host", 1234));
-    assertThat(route.toString()).isEqualTo("Route{host:1234}");
-  }
-
-  private void assertRoute(Route route, Address address, Proxy proxy, InetAddress socketAddress,
-      int socketPort) {
-    assertThat(route.address()).isEqualTo(address);
-    assertThat(route.proxy()).isEqualTo(proxy);
-    assertThat(route.socketAddress().getAddress()).isEqualTo(socketAddress);
-    assertThat(route.socketAddress().getPort()).isEqualTo(socketPort);
-  }
-
-  /** Returns an address that's without an SSL socket factory or hostname verifier. */
-  private Address httpAddress() {
-    return new Address(uriHost, uriPort, dns, socketFactory, null, null, null, authenticator, null,
-        protocols, connectionSpecs, proxySelector);
-  }
-
-  private Address httpsAddress() {
-    return new Address(uriHost, uriPort, dns, socketFactory, sslSocketFactory,
-        hostnameVerifier, null, authenticator, null, protocols, connectionSpecs, proxySelector);
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/CancelTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/CancelTest.java
deleted file mode 100644
index 6f11d320b7..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/CancelTest.java
+++ /dev/null
@@ -1,148 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.ServerSocket;
-import java.net.Socket;
-import java.util.concurrent.TimeUnit;
-import javax.annotation.Nullable;
-import javax.net.ServerSocketFactory;
-import javax.net.SocketFactory;
-import okhttp3.Call;
-import okhttp3.DelegatingServerSocketFactory;
-import okhttp3.DelegatingSocketFactory;
-import okhttp3.MediaType;
-import okhttp3.OkHttpClient;
-import okhttp3.OkHttpClientTestRule;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okio.Buffer;
-import okio.BufferedSink;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static org.junit.Assert.fail;
-
-public final class CancelTest {
-  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
-
-  // The size of the socket buffers in bytes.
-  private static final int SOCKET_BUFFER_SIZE = 256 * 1024;
-
-  private MockWebServer server;
-  private OkHttpClient client;
-
-  @Before public void setUp() throws Exception {
-    // Sockets on some platforms can have large buffers that mean writes do not block when
-    // required. These socket factories explicitly set the buffer sizes on sockets created.
-    server = new MockWebServer();
-    server.setServerSocketFactory(
-        new DelegatingServerSocketFactory(ServerSocketFactory.getDefault()) {
-          @Override protected ServerSocket configureServerSocket(
-              ServerSocket serverSocket) throws IOException {
-            serverSocket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
-            return serverSocket;
-          }
-        });
-    client = clientTestRule.client.newBuilder()
-        .socketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
-          @Override protected Socket configureSocket(Socket socket) throws IOException {
-            socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
-            socket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
-            return socket;
-          }
-        })
-        .build();
-  }
-
-  @Test public void cancelWritingRequestBody() throws Exception {
-    server.enqueue(new MockResponse());
-    server.start();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .post(new RequestBody() {
-          @Override public @Nullable MediaType contentType() {
-            return null;
-          }
-
-          @Override public void writeTo(BufferedSink sink) throws IOException {
-            for (int i = 0; i < 10; i++) {
-              sink.writeByte(0);
-              sink.flush();
-              sleep(100);
-            }
-            fail("Expected connection to be closed");
-          }
-        })
-        .build());
-
-    cancelLater(call, 500);
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void cancelReadingResponseBody() throws Exception {
-    int responseBodySize = 8 * 1024 * 1024; // 8 MiB.
-
-    server.enqueue(new MockResponse()
-        .setBody(new Buffer().write(new byte[responseBodySize]))
-        .throttleBody(64 * 1024, 125, TimeUnit.MILLISECONDS)); // 500 Kbps
-    server.start();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-
-    Response response = call.execute();
-    cancelLater(call, 500);
-    InputStream responseBody = response.body().byteStream();
-    byte[] buffer = new byte[1024];
-    try {
-      while (responseBody.read(buffer) != -1) {
-      }
-      fail("Expected connection to be closed");
-    } catch (IOException expected) {
-    }
-
-    responseBody.close();
-  }
-
-  private void sleep(int delayMillis) {
-    try {
-      Thread.sleep(delayMillis);
-    } catch (InterruptedException e) {
-      Thread.currentThread().interrupt();
-    }
-  }
-
-  private void cancelLater(Call call, int delayMillis) {
-    Thread interruptingCow = new Thread(() -> {
-      sleep(delayMillis);
-      call.cancel();
-    });
-    interruptingCow.start();
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/ExternalHttp2Example.java b/okhttp-tests/src/test/java/okhttp3/internal/http/ExternalHttp2Example.java
deleted file mode 100644
index 73f9471fac..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/ExternalHttp2Example.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package okhttp3.internal.http;
-
-import okhttp3.Call;
-import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.Util;
-
-public final class ExternalHttp2Example {
-  public static void main(String[] args) throws Exception {
-    OkHttpClient client = new OkHttpClient.Builder()
-        .protocols(Util.immutableList(Protocol.HTTP_2, Protocol.HTTP_1_1))
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url("https://www.google.ca/")
-        .build());
-
-    Response response = call.execute();
-    try {
-      System.out.println(response.code());
-      System.out.println("PROTOCOL " + response.protocol());
-
-      String line;
-      while ((line = response.body().source().readUtf8Line()) != null) {
-        System.out.println(line);
-      }
-    } finally {
-      response.body().close();
-    }
-
-    client.connectionPool().evictAll();
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/HttpDateTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/HttpDateTest.java
deleted file mode 100644
index 3d9860da64..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/HttpDateTest.java
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http;
-
-import java.util.Date;
-import java.util.TimeZone;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public class HttpDateTest {
-
-  private TimeZone originalDefault;
-
-  @Before
-  public void setUp() throws Exception {
-    originalDefault = TimeZone.getDefault();
-    // The default timezone should affect none of these tests: HTTP specified GMT, so we set it to
-    // something else.
-    TimeZone.setDefault(TimeZone.getTimeZone("America/Los_Angeles"));
-  }
-
-  @After
-  public void tearDown() throws Exception {
-    TimeZone.setDefault(originalDefault);
-  }
-
-  @Test public void parseStandardFormats() throws Exception {
-    // RFC 822, updated by RFC 1123 with GMT.
-    assertThat(HttpDate.parse("Thu, 01 Jan 1970 00:00:00 GMT").getTime()).isEqualTo(0L);
-    assertThat(HttpDate.parse("Fri, 06 Jun 2014 12:30:30 GMT").getTime()).isEqualTo(1402057830000L);
-
-    // RFC 850, obsoleted by RFC 1036 with GMT.
-    assertThat(HttpDate.parse("Thursday, 01-Jan-70 00:00:00 GMT").getTime()).isEqualTo(0L);
-    assertThat(HttpDate.parse("Friday, 06-Jun-14 12:30:30 GMT").getTime()).isEqualTo(1402057830000L);
-
-    // ANSI C's asctime(): should use GMT, not platform default.
-    assertThat(HttpDate.parse("Thu Jan 1 00:00:00 1970").getTime()).isEqualTo(0L);
-    assertThat(HttpDate.parse("Fri Jun 6 12:30:30 2014").getTime()).isEqualTo(1402057830000L);
-  }
-
-  @Test public void format() throws Exception {
-    assertThat(HttpDate.format(new Date(0))).isEqualTo("Thu, 01 Jan 1970 00:00:00 GMT");
-    assertThat(HttpDate.format(new Date(1402057830000L))).isEqualTo(
-        "Fri, 06 Jun 2014 12:30:30 GMT");
-  }
-
-  @Test public void parseNonStandardStrings() throws Exception {
-    // RFC 822, updated by RFC 1123 with any TZ
-    assertThat(HttpDate.parse("Thu, 01 Jan 1970 00:00:00 GMT-01:00").getTime()).isEqualTo(3600000L);
-    assertThat(HttpDate.parse("Thu, 01 Jan 1970 00:00:00 PST").getTime()).isEqualTo(28800000L);
-    // Ignore trailing junk
-    assertThat(HttpDate.parse("Thu, 01 Jan 1970 00:00:00 GMT JUNK").getTime()).isEqualTo(0L);
-    // Missing timezones treated as bad.
-    assertThat(HttpDate.parse("Thu, 01 Jan 1970 00:00:00")).isNull();
-    // Missing seconds treated as bad.
-    assertThat(HttpDate.parse("Thu, 01 Jan 1970 00:00 GMT")).isNull();
-    // Extra spaces treated as bad.
-    assertThat(HttpDate.parse("Thu,  01 Jan 1970 00:00 GMT")).isNull();
-    // Missing leading zero treated as bad.
-    assertThat(HttpDate.parse("Thu, 1 Jan 1970 00:00 GMT")).isNull();
-
-    // RFC 850, obsoleted by RFC 1036 with any TZ.
-    assertThat(HttpDate.parse("Thursday, 01-Jan-1970 00:00:00 GMT-01:00").getTime()).isEqualTo(
-        3600000L);
-    assertThat(HttpDate.parse("Thursday, 01-Jan-1970 00:00:00 PST").getTime()).isEqualTo(28800000L);
-    // Ignore trailing junk
-    assertThat(HttpDate.parse("Thursday, 01-Jan-1970 00:00:00 PST JUNK").getTime()).isEqualTo(
-        28800000L);
-
-    // ANSI C's asctime() format
-    // This format ignores the timezone entirely even if it is present and uses GMT.
-    assertThat(HttpDate.parse("Fri Jun 6 12:30:30 2014 PST").getTime()).isEqualTo(1402057830000L);
-    // Ignore trailing junk.
-    assertThat(HttpDate.parse("Fri Jun 6 12:30:30 2014 JUNK").getTime()).isEqualTo(1402057830000L);
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java b/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
deleted file mode 100644
index dafaae89f9..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http;
-
-import java.io.IOException;
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import java.net.ProxySelector;
-import java.net.SocketAddress;
-import java.net.URI;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import okhttp3.internal.Util;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public final class RecordingProxySelector extends ProxySelector {
-  public final List<Proxy> proxies = new ArrayList<>();
-  public final List<URI> requestedUris = new ArrayList<>();
-  public final List<String> failures = new ArrayList<>();
-
-  @Override public List<Proxy> select(URI uri) {
-    requestedUris.add(uri);
-    return proxies;
-  }
-
-  public void assertRequests(URI... expectedUris) {
-    assertThat(requestedUris).isEqualTo(Arrays.asList(expectedUris));
-    requestedUris.clear();
-  }
-
-  @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
-    InetSocketAddress socketAddress = (InetSocketAddress) sa;
-    failures.add(Util.format("%s %s:%d %s",
-        uri, socketAddress, socketAddress.getPort(), ioe.getMessage()));
-  }
-
-  @Override public String toString() {
-    return "RecordingProxySelector";
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/StatusLineTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/StatusLineTest.java
deleted file mode 100644
index 08e002de7e..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/StatusLineTest.java
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http;
-
-import java.io.IOException;
-import java.net.ProtocolException;
-import okhttp3.Protocol;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class StatusLineTest {
-  @Test public void parse() throws IOException {
-    String message = "Temporary Redirect";
-    int version = 1;
-    int code = 200;
-    StatusLine statusLine = StatusLine.parse("HTTP/1." + version + " " + code + " " + message);
-    assertThat(statusLine.message).isEqualTo(message);
-    assertThat(statusLine.protocol).isEqualTo(Protocol.HTTP_1_1);
-    assertThat(statusLine.code).isEqualTo(code);
-  }
-
-  @Test public void emptyMessage() throws IOException {
-    int version = 1;
-    int code = 503;
-    StatusLine statusLine = StatusLine.parse("HTTP/1." + version + " " + code + " ");
-    assertThat(statusLine.message).isEqualTo("");
-    assertThat(statusLine.protocol).isEqualTo(Protocol.HTTP_1_1);
-    assertThat(statusLine.code).isEqualTo(code);
-  }
-
-  /**
-   * This is not defined in the protocol but some servers won't add the leading empty space when the
-   * message is empty. http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.1
-   */
-  @Test public void emptyMessageAndNoLeadingSpace() throws IOException {
-    int version = 1;
-    int code = 503;
-    StatusLine statusLine = StatusLine.parse("HTTP/1." + version + " " + code);
-    assertThat(statusLine.message).isEqualTo("");
-    assertThat(statusLine.protocol).isEqualTo(Protocol.HTTP_1_1);
-    assertThat(statusLine.code).isEqualTo(code);
-  }
-
-  // https://github.com/square/okhttp/issues/386
-  @Test public void shoutcast() throws IOException {
-    StatusLine statusLine = StatusLine.parse("ICY 200 OK");
-    assertThat(statusLine.message).isEqualTo("OK");
-    assertThat(statusLine.protocol).isEqualTo(Protocol.HTTP_1_0);
-    assertThat(statusLine.code).isEqualTo(200);
-  }
-
-  @Test public void missingProtocol() throws IOException {
-    assertInvalid("");
-    assertInvalid(" ");
-    assertInvalid("200 OK");
-    assertInvalid(" 200 OK");
-  }
-
-  @Test public void protocolVersions() throws IOException {
-    assertInvalid("HTTP/2.0 200 OK");
-    assertInvalid("HTTP/2.1 200 OK");
-    assertInvalid("HTTP/-.1 200 OK");
-    assertInvalid("HTTP/1.- 200 OK");
-    assertInvalid("HTTP/0.1 200 OK");
-    assertInvalid("HTTP/101 200 OK");
-    assertInvalid("HTTP/1.1_200 OK");
-  }
-
-  @Test public void nonThreeDigitCode() throws IOException {
-    assertInvalid("HTTP/1.1  OK");
-    assertInvalid("HTTP/1.1 2 OK");
-    assertInvalid("HTTP/1.1 20 OK");
-    assertInvalid("HTTP/1.1 2000 OK");
-    assertInvalid("HTTP/1.1 two OK");
-    assertInvalid("HTTP/1.1 2");
-    assertInvalid("HTTP/1.1 2000");
-    assertInvalid("HTTP/1.1 two");
-  }
-
-  @Test public void truncated() throws IOException {
-    assertInvalid("");
-    assertInvalid("H");
-    assertInvalid("HTTP/1");
-    assertInvalid("HTTP/1.");
-    assertInvalid("HTTP/1.1");
-    assertInvalid("HTTP/1.1 ");
-    assertInvalid("HTTP/1.1 2");
-    assertInvalid("HTTP/1.1 20");
-  }
-
-  @Test public void wrongMessageDelimiter() throws IOException {
-    assertInvalid("HTTP/1.1 200_");
-  }
-
-  private void assertInvalid(String statusLine) throws IOException {
-    try {
-      StatusLine.parse(statusLine);
-      fail();
-    } catch (ProtocolException expected) {
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
deleted file mode 100644
index 86364052f6..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
+++ /dev/null
@@ -1,156 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.ServerSocket;
-import java.net.Socket;
-import java.util.concurrent.TimeUnit;
-import javax.annotation.Nullable;
-import javax.net.ServerSocketFactory;
-import javax.net.SocketFactory;
-import okhttp3.Call;
-import okhttp3.DelegatingServerSocketFactory;
-import okhttp3.DelegatingSocketFactory;
-import okhttp3.MediaType;
-import okhttp3.OkHttpClient;
-import okhttp3.OkHttpClientTestRule;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okio.Buffer;
-import okio.BufferedSink;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static org.junit.Assert.fail;
-
-public final class ThreadInterruptTest {
-  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
-
-  // The size of the socket buffers in bytes.
-  private static final int SOCKET_BUFFER_SIZE = 256 * 1024;
-
-  private MockWebServer server;
-  private OkHttpClient client = clientTestRule.client;
-
-  @Before public void setUp() throws Exception {
-    // Sockets on some platforms can have large buffers that mean writes do not block when
-    // required. These socket factories explicitly set the buffer sizes on sockets created.
-    server = new MockWebServer();
-    server.setServerSocketFactory(
-        new DelegatingServerSocketFactory(ServerSocketFactory.getDefault()) {
-          @Override
-          protected ServerSocket configureServerSocket(ServerSocket serverSocket)
-              throws IOException {
-            serverSocket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
-            return serverSocket;
-          }
-        });
-    client = clientTestRule.client.newBuilder()
-        .socketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
-          @Override
-          protected Socket configureSocket(Socket socket) throws IOException {
-            socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
-            socket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
-            return socket;
-          }
-        })
-        .build();
-  }
-
-  @After public void tearDown() throws Exception {
-    Thread.interrupted(); // Clear interrupted state.
-  }
-
-  @Test public void interruptWritingRequestBody() throws Exception {
-    server.enqueue(new MockResponse());
-    server.start();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .post(new RequestBody() {
-          @Override public @Nullable MediaType contentType() {
-            return null;
-          }
-
-          @Override public void writeTo(BufferedSink sink) throws IOException {
-            for (int i = 0; i < 10; i++) {
-              sink.writeByte(0);
-              sink.flush();
-              sleep(100);
-            }
-            fail("Expected connection to be closed");
-          }
-        })
-        .build());
-
-    interruptLater(500);
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void interruptReadingResponseBody() throws Exception {
-    int responseBodySize = 8 * 1024 * 1024; // 8 MiB.
-
-    server.enqueue(new MockResponse()
-        .setBody(new Buffer().write(new byte[responseBodySize]))
-        .throttleBody(64 * 1024, 125, TimeUnit.MILLISECONDS)); // 500 Kbps
-    server.start();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-
-    Response response = call.execute();
-    interruptLater(500);
-    InputStream responseBody = response.body().byteStream();
-    byte[] buffer = new byte[1024];
-    try {
-      while (responseBody.read(buffer) != -1) {
-      }
-      fail("Expected connection to be interrupted");
-    } catch (IOException expected) {
-    }
-
-    responseBody.close();
-  }
-
-  private void sleep(int delayMillis) {
-    try {
-      Thread.sleep(delayMillis);
-    } catch (InterruptedException e) {
-      Thread.currentThread().interrupt();
-    }
-  }
-
-  private void interruptLater(int delayMillis) {
-    Thread toInterrupt = Thread.currentThread();
-    Thread interruptingCow = new Thread(() -> {
-      sleep(delayMillis);
-      toInterrupt.interrupt();
-    });
-    interruptingCow.start();
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/BaseTestHandler.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/BaseTestHandler.java
deleted file mode 100644
index b0b552b937..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/BaseTestHandler.java
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import java.io.IOException;
-import java.util.List;
-import okio.BufferedSource;
-import okio.ByteString;
-
-import static org.junit.Assert.fail;
-
-class BaseTestHandler implements Http2Reader.Handler {
-  @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
-      throws IOException {
-    fail();
-  }
-
-  @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,
-      List<Header> headerBlock) {
-    fail();
-  }
-
-  @Override public void rstStream(int streamId, ErrorCode errorCode) {
-    fail();
-  }
-
-  @Override public void settings(boolean clearPrevious, Settings settings) {
-    fail();
-  }
-
-  @Override public void ackSettings() {
-    fail();
-  }
-
-  @Override public void ping(boolean ack, int payload1, int payload2) {
-    fail();
-  }
-
-  @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
-    fail();
-  }
-
-  @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
-    fail();
-  }
-
-  @Override public void priority(int streamId, int streamDependency, int weight,
-      boolean exclusive) {
-    fail();
-  }
-
-  @Override
-  public void pushPromise(int streamId, int associatedStreamId, List<Header> headerBlock) {
-    fail();
-  }
-
-  @Override public void alternateService(int streamId, String origin, ByteString protocol,
-      String host, int port, long maxAge) {
-    fail();
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/FrameLogTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/FrameLogTest.java
deleted file mode 100644
index ee21f46c86..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/FrameLogTest.java
+++ /dev/null
@@ -1,162 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import org.junit.Test;
-
-import static okhttp3.internal.http2.Http2.FLAG_ACK;
-import static okhttp3.internal.http2.Http2.FLAG_END_HEADERS;
-import static okhttp3.internal.http2.Http2.FLAG_END_STREAM;
-import static okhttp3.internal.http2.Http2.FLAG_NONE;
-import static okhttp3.internal.http2.Http2.TYPE_CONTINUATION;
-import static okhttp3.internal.http2.Http2.TYPE_DATA;
-import static okhttp3.internal.http2.Http2.TYPE_GOAWAY;
-import static okhttp3.internal.http2.Http2.TYPE_HEADERS;
-import static okhttp3.internal.http2.Http2.TYPE_PING;
-import static okhttp3.internal.http2.Http2.TYPE_PUSH_PROMISE;
-import static okhttp3.internal.http2.Http2.TYPE_SETTINGS;
-import static okhttp3.internal.http2.Http2.frameLog;
-import static org.assertj.core.api.Assertions.assertThat;
-
-public final class FrameLogTest {
-  /** Real stream traffic applied to the log format. */
-  @Test public void exampleStream() {
-    assertThat(frameLog(false, 0, 5, TYPE_SETTINGS, FLAG_NONE)).isEqualTo(
-        ">> 0x00000000     5 SETTINGS      ");
-    assertThat(frameLog(false, 3, 100, TYPE_HEADERS, FLAG_END_HEADERS)).isEqualTo(
-        ">> 0x00000003   100 HEADERS       END_HEADERS");
-    assertThat(frameLog(false, 3, 0, TYPE_DATA, FLAG_END_STREAM)).isEqualTo(
-        ">> 0x00000003     0 DATA          END_STREAM");
-    assertThat(frameLog(true, 0, 15, TYPE_SETTINGS, FLAG_NONE)).isEqualTo(
-        "<< 0x00000000    15 SETTINGS      ");
-    assertThat(frameLog(false, 0, 0, TYPE_SETTINGS, FLAG_ACK)).isEqualTo(
-        ">> 0x00000000     0 SETTINGS      ACK");
-    assertThat(frameLog(true, 0, 0, TYPE_SETTINGS, FLAG_ACK)).isEqualTo(
-        "<< 0x00000000     0 SETTINGS      ACK");
-    assertThat(frameLog(true, 3, 22, TYPE_HEADERS, FLAG_END_HEADERS)).isEqualTo(
-        "<< 0x00000003    22 HEADERS       END_HEADERS");
-    assertThat(frameLog(true, 3, 226, TYPE_DATA, FLAG_END_STREAM)).isEqualTo(
-        "<< 0x00000003   226 DATA          END_STREAM");
-    assertThat(frameLog(false, 0, 8, TYPE_GOAWAY, FLAG_NONE)).isEqualTo(
-        ">> 0x00000000     8 GOAWAY        ");
-  }
-
-  @Test public void flagOverlapOn0x1() {
-    assertThat(frameLog(true, 0, 0, TYPE_SETTINGS, (byte) 0x1)).isEqualTo(
-        "<< 0x00000000     0 SETTINGS      ACK");
-    assertThat(frameLog(true, 0, 8, TYPE_PING, (byte) 0x1)).isEqualTo(
-        "<< 0x00000000     8 PING          ACK");
-    assertThat(frameLog(true, 3, 0, TYPE_HEADERS, (byte) 0x1)).isEqualTo(
-        "<< 0x00000003     0 HEADERS       END_STREAM");
-    assertThat(frameLog(true, 3, 0, TYPE_DATA, (byte) 0x1)).isEqualTo(
-        "<< 0x00000003     0 DATA          END_STREAM");
-  }
-
-  @Test public void flagOverlapOn0x4() {
-    assertThat(frameLog(true, 3, 10000, TYPE_HEADERS, (byte) 0x4)).isEqualTo(
-        "<< 0x00000003 10000 HEADERS       END_HEADERS");
-    assertThat(frameLog(true, 3, 10000, TYPE_CONTINUATION, (byte) 0x4)).isEqualTo(
-        "<< 0x00000003 10000 CONTINUATION  END_HEADERS");
-    assertThat(frameLog(true, 4, 10000, TYPE_PUSH_PROMISE, (byte) 0x4)).isEqualTo(
-        "<< 0x00000004 10000 PUSH_PROMISE  END_PUSH_PROMISE");
-  }
-
-  @Test public void flagOverlapOn0x20() {
-    assertThat(frameLog(true, 3, 10000, TYPE_HEADERS, (byte) 0x20)).isEqualTo(
-        "<< 0x00000003 10000 HEADERS       PRIORITY");
-    assertThat(frameLog(true, 3, 10000, TYPE_DATA, (byte) 0x20)).isEqualTo(
-        "<< 0x00000003 10000 DATA          COMPRESSED");
-  }
-
-  /**
-   * Ensures that valid flag combinations appear visually correct, and invalid show in hex.  This
-   * also demonstrates how sparse the lookup table is.
-   */
-  @Test public void allFormattedFlagsWithValidBits() {
-    List<String> formattedFlags = new ArrayList<>(0x40); // Highest valid flag is 0x20.
-    for (byte i = 0; i < 0x40; i++) formattedFlags.add(Http2.formatFlags(TYPE_HEADERS, i));
-
-    assertThat(formattedFlags).isEqualTo(Arrays.asList(
-        "",
-        "END_STREAM",
-        "00000010",
-        "00000011",
-        "END_HEADERS",
-        "END_STREAM|END_HEADERS",
-        "00000110",
-        "00000111",
-        "PADDED",
-        "END_STREAM|PADDED",
-        "00001010",
-        "00001011",
-        "00001100",
-        "END_STREAM|END_HEADERS|PADDED",
-        "00001110",
-        "00001111",
-        "00010000",
-        "00010001",
-        "00010010",
-        "00010011",
-        "00010100",
-        "00010101",
-        "00010110",
-        "00010111",
-        "00011000",
-        "00011001",
-        "00011010",
-        "00011011",
-        "00011100",
-        "00011101",
-        "00011110",
-        "00011111",
-        "PRIORITY",
-        "END_STREAM|PRIORITY",
-        "00100010",
-        "00100011",
-        "END_HEADERS|PRIORITY",
-        "END_STREAM|END_HEADERS|PRIORITY",
-        "00100110",
-        "00100111",
-        "00101000",
-        "END_STREAM|PRIORITY|PADDED",
-        "00101010",
-        "00101011",
-        "00101100",
-        "END_STREAM|END_HEADERS|PRIORITY|PADDED",
-        "00101110",
-        "00101111",
-        "00110000",
-        "00110001",
-        "00110010",
-        "00110011",
-        "00110100",
-        "00110101",
-        "00110110",
-        "00110111",
-        "00111000",
-        "00111001",
-        "00111010",
-        "00111011",
-        "00111100",
-        "00111101",
-        "00111110",
-        "00111111"
-    ));
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/HpackTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/HpackTest.java
deleted file mode 100644
index 69dd07923f..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/HpackTest.java
+++ /dev/null
@@ -1,1106 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.List;
-import okio.Buffer;
-import okio.ByteString;
-import org.junit.Before;
-import org.junit.Test;
-
-import static okhttp3.TestUtil.headerEntries;
-import static okio.ByteString.decodeHex;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class HpackTest {
-  private final Buffer bytesIn = new Buffer();
-  private Hpack.Reader hpackReader;
-  private Buffer bytesOut = new Buffer();
-  private Hpack.Writer hpackWriter;
-
-  @Before public void reset() {
-    hpackReader = newReader(bytesIn);
-    hpackWriter = new Hpack.Writer(4096, false, bytesOut);
-  }
-
-  /**
-   * Variable-length quantity special cases strings which are longer than 127 bytes.  Values such as
-   * cookies can be 4KiB, and should be possible to send.
-   *
-   * <p> http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-5.2
-   */
-  @Test public void largeHeaderValue() throws IOException {
-    char[] value = new char[4096];
-    Arrays.fill(value, '!');
-    List<Header> headerBlock = headerEntries("cookie", new String(value));
-
-    hpackWriter.writeHeaders(headerBlock);
-    bytesIn.writeAll(bytesOut);
-    hpackReader.readHeaders();
-
-    assertThat(hpackReader.headerCount).isEqualTo(0);
-
-    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerBlock);
-  }
-
-  /**
-   * HPACK has a max header table size, which can be smaller than the max header message. Ensure the
-   * larger header content is not lost.
-   */
-  @Test public void tooLargeToHPackIsStillEmitted() throws IOException {
-    bytesIn.writeByte(0x21); // Dynamic table size update (size = 1).
-    bytesIn.writeByte(0x00); // Literal indexed
-    bytesIn.writeByte(0x0a); // Literal name (len = 10)
-    bytesIn.writeUtf8("custom-key");
-
-    bytesIn.writeByte(0x0d); // Literal value (len = 13)
-    bytesIn.writeUtf8("custom-header");
-
-    hpackReader.readHeaders();
-
-    assertThat(hpackReader.headerCount).isEqualTo(0);
-
-    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(
-        headerEntries("custom-key", "custom-header"));
-  }
-
-  /** Oldest entries are evicted to support newer ones. */
-  @Test public void writerEviction() throws IOException {
-    List<Header> headerBlock =
-        headerEntries(
-            "custom-foo", "custom-header",
-            "custom-bar", "custom-header",
-            "custom-baz", "custom-header");
-
-    bytesIn.writeByte(0x40); // Literal indexed
-    bytesIn.writeByte(0x0a); // Literal name (len = 10)
-    bytesIn.writeUtf8("custom-foo");
-
-    bytesIn.writeByte(0x0d); // Literal value (len = 13)
-    bytesIn.writeUtf8("custom-header");
-
-    bytesIn.writeByte(0x40); // Literal indexed
-    bytesIn.writeByte(0x0a); // Literal name (len = 10)
-    bytesIn.writeUtf8("custom-bar");
-
-    bytesIn.writeByte(0x0d); // Literal value (len = 13)
-    bytesIn.writeUtf8("custom-header");
-
-    bytesIn.writeByte(0x40); // Literal indexed
-    bytesIn.writeByte(0x0a); // Literal name (len = 10)
-    bytesIn.writeUtf8("custom-baz");
-
-    bytesIn.writeByte(0x0d); // Literal value (len = 13)
-    bytesIn.writeUtf8("custom-header");
-
-    // Set to only support 110 bytes (enough for 2 headers).
-    // Use a new Writer because we don't support change the dynamic table
-    // size after Writer constructed.
-    Hpack.Writer writer = new Hpack.Writer(110, false, bytesOut);
-    writer.writeHeaders(headerBlock);
-
-    assertThat(bytesOut).isEqualTo(bytesIn);
-    assertThat(writer.headerCount).isEqualTo(2);
-
-    int tableLength = writer.dynamicTable.length;
-    Header entry = writer.dynamicTable[tableLength - 1];
-    checkEntry(entry, "custom-bar", "custom-header", 55);
-
-    entry = writer.dynamicTable[tableLength - 2];
-    checkEntry(entry, "custom-baz", "custom-header", 55);
-  }
-
-  @Test public void readerEviction() throws IOException {
-    List<Header> headerBlock =
-        headerEntries(
-            "custom-foo", "custom-header",
-            "custom-bar", "custom-header",
-            "custom-baz", "custom-header");
-
-    // Set to only support 110 bytes (enough for 2 headers).
-    bytesIn.writeByte(0x3F); // Dynamic table size update (size = 110).
-    bytesIn.writeByte(0x4F);
-
-    bytesIn.writeByte(0x40); // Literal indexed
-    bytesIn.writeByte(0x0a); // Literal name (len = 10)
-    bytesIn.writeUtf8("custom-foo");
-
-    bytesIn.writeByte(0x0d); // Literal value (len = 13)
-    bytesIn.writeUtf8("custom-header");
-
-    bytesIn.writeByte(0x40); // Literal indexed
-    bytesIn.writeByte(0x0a); // Literal name (len = 10)
-    bytesIn.writeUtf8("custom-bar");
-
-    bytesIn.writeByte(0x0d); // Literal value (len = 13)
-    bytesIn.writeUtf8("custom-header");
-
-    bytesIn.writeByte(0x40); // Literal indexed
-    bytesIn.writeByte(0x0a); // Literal name (len = 10)
-    bytesIn.writeUtf8("custom-baz");
-
-    bytesIn.writeByte(0x0d); // Literal value (len = 13)
-    bytesIn.writeUtf8("custom-header");
-
-    hpackReader.readHeaders();
-
-    assertThat(hpackReader.headerCount).isEqualTo(2);
-
-    Header entry1 = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
-    checkEntry(entry1, "custom-bar", "custom-header", 55);
-
-    Header entry2 = hpackReader.dynamicTable[readerHeaderTableLength() - 2];
-    checkEntry(entry2, "custom-baz", "custom-header", 55);
-
-    // Once a header field is decoded and added to the reconstructed header
-    // list, it cannot be removed from it. Hence, foo is here.
-    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerBlock);
-
-    // Simulate receiving a small dynamic table size update, that implies eviction.
-    bytesIn.writeByte(0x3F); // Dynamic table size update (size = 55).
-    bytesIn.writeByte(0x18);
-    hpackReader.readHeaders();
-    assertThat(hpackReader.headerCount).isEqualTo(1);
-  }
-
-  /** Header table backing array is initially 8 long, let's ensure it grows. */
-  @Test public void dynamicallyGrowsBeyond64Entries() throws IOException {
-    // Lots of headers need more room!
-    hpackReader = new Hpack.Reader(16384, 4096, bytesIn);
-    bytesIn.writeByte(0x3F); // Dynamic table size update (size = 16384).
-    bytesIn.writeByte(0xE1);
-    bytesIn.writeByte(0x7F);
-
-    for (int i = 0; i < 256; i++) {
-      bytesIn.writeByte(0x40); // Literal indexed
-      bytesIn.writeByte(0x0a); // Literal name (len = 10)
-      bytesIn.writeUtf8("custom-foo");
-
-      bytesIn.writeByte(0x0d); // Literal value (len = 13)
-      bytesIn.writeUtf8("custom-header");
-    }
-
-    hpackReader.readHeaders();
-
-    assertThat(hpackReader.headerCount).isEqualTo(256);
-  }
-
-  @Test public void huffmanDecodingSupported() throws IOException {
-    bytesIn.writeByte(0x44); // == Literal indexed ==
-                             // Indexed name (idx = 4) -> :path
-    bytesIn.writeByte(0x8c); // Literal value Huffman encoded 12 bytes
-                             // decodes to www.example.com which is length 15
-    bytesIn.write(decodeHex("f1e3c2e5f23a6ba0ab90f4ff"));
-
-    hpackReader.readHeaders();
-
-    assertThat(hpackReader.headerCount).isEqualTo(1);
-    assertThat(hpackReader.dynamicTableByteCount).isEqualTo(52);
-
-    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
-    checkEntry(entry, ":path", "www.example.com", 52);
-  }
-
-  /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#appendix-C.2.1
-   */
-  @Test public void readLiteralHeaderFieldWithIndexing() throws IOException {
-    bytesIn.writeByte(0x40); // Literal indexed
-    bytesIn.writeByte(0x0a); // Literal name (len = 10)
-    bytesIn.writeUtf8("custom-key");
-
-    bytesIn.writeByte(0x0d); // Literal value (len = 13)
-    bytesIn.writeUtf8("custom-header");
-
-    hpackReader.readHeaders();
-
-    assertThat(hpackReader.headerCount).isEqualTo(1);
-    assertThat(hpackReader.dynamicTableByteCount).isEqualTo(55);
-
-    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
-    checkEntry(entry, "custom-key", "custom-header", 55);
-
-    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(
-        headerEntries("custom-key", "custom-header"));
-  }
-
-  /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#appendix-C.2.2
-   */
-  @Test public void literalHeaderFieldWithoutIndexingIndexedName() throws IOException {
-    List<Header> headerBlock = headerEntries(":path", "/sample/path");
-
-    bytesIn.writeByte(0x04); // == Literal not indexed ==
-                             // Indexed name (idx = 4) -> :path
-    bytesIn.writeByte(0x0c); // Literal value (len = 12)
-    bytesIn.writeUtf8("/sample/path");
-
-    hpackWriter.writeHeaders(headerBlock);
-    assertThat(bytesOut).isEqualTo(bytesIn);
-
-    hpackReader.readHeaders();
-
-    assertThat(hpackReader.headerCount).isEqualTo(0);
-
-    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerBlock);
-  }
-
-  @Test public void literalHeaderFieldWithoutIndexingNewName() throws IOException {
-    List<Header> headerBlock = headerEntries("custom-key", "custom-header");
-
-    bytesIn.writeByte(0x00); // Not indexed
-    bytesIn.writeByte(0x0a); // Literal name (len = 10)
-    bytesIn.writeUtf8("custom-key");
-
-    bytesIn.writeByte(0x0d); // Literal value (len = 13)
-    bytesIn.writeUtf8("custom-header");
-
-    hpackReader.readHeaders();
-
-    assertThat(hpackReader.headerCount).isEqualTo(0);
-
-    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerBlock);
-  }
-
-  @Test public void literalHeaderFieldNeverIndexedIndexedName() throws IOException {
-    bytesIn.writeByte(0x14); // == Literal never indexed ==
-                             // Indexed name (idx = 4) -> :path
-    bytesIn.writeByte(0x0c); // Literal value (len = 12)
-    bytesIn.writeUtf8("/sample/path");
-
-    hpackReader.readHeaders();
-
-    assertThat(hpackReader.headerCount).isEqualTo(0);
-
-    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(
-        headerEntries(":path", "/sample/path"));
-  }
-
-  @Test public void literalHeaderFieldNeverIndexedNewName() throws IOException {
-    List<Header> headerBlock = headerEntries("custom-key", "custom-header");
-
-    bytesIn.writeByte(0x10); // Never indexed
-    bytesIn.writeByte(0x0a); // Literal name (len = 10)
-    bytesIn.writeUtf8("custom-key");
-
-    bytesIn.writeByte(0x0d); // Literal value (len = 13)
-    bytesIn.writeUtf8("custom-header");
-
-    hpackReader.readHeaders();
-
-    assertThat(hpackReader.headerCount).isEqualTo(0);
-
-    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerBlock);
-  }
-
-  @Test public void literalHeaderFieldWithIncrementalIndexingIndexedName() throws IOException {
-    List<Header> headerBlock = headerEntries(":path", "/sample/path");
-
-    bytesIn.writeByte(0x44); // Indexed name (idx = 4) -> :path
-    bytesIn.writeByte(0x0c); // Literal value (len = 12)
-    bytesIn.writeUtf8("/sample/path");
-
-    hpackReader.readHeaders();
-
-    assertThat(hpackReader.headerCount).isEqualTo(1);
-
-    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerBlock);
-  }
-
-  @Test public void literalHeaderFieldWithIncrementalIndexingNewName() throws IOException {
-    List<Header> headerBlock = headerEntries("custom-key", "custom-header");
-
-    bytesIn.writeByte(0x40); // Never indexed
-    bytesIn.writeByte(0x0a); // Literal name (len = 10)
-    bytesIn.writeUtf8("custom-key");
-
-    bytesIn.writeByte(0x0d); // Literal value (len = 13)
-    bytesIn.writeUtf8("custom-header");
-
-    hpackWriter.writeHeaders(headerBlock);
-    assertThat(bytesOut).isEqualTo(bytesIn);
-
-    assertThat(hpackWriter.headerCount).isEqualTo(1);
-
-    Header entry = hpackWriter.dynamicTable[hpackWriter.dynamicTable.length - 1];
-    checkEntry(entry, "custom-key", "custom-header", 55);
-
-    hpackReader.readHeaders();
-
-    assertThat(hpackReader.headerCount).isEqualTo(1);
-
-    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerBlock);
-  }
-
-  @Test public void theSameHeaderAfterOneIncrementalIndexed() throws IOException {
-    List<Header> headerBlock =
-        headerEntries(
-            "custom-key", "custom-header",
-            "custom-key", "custom-header");
-
-    bytesIn.writeByte(0x40); // Never indexed
-    bytesIn.writeByte(0x0a); // Literal name (len = 10)
-    bytesIn.writeUtf8("custom-key");
-
-    bytesIn.writeByte(0x0d); // Literal value (len = 13)
-    bytesIn.writeUtf8("custom-header");
-
-    bytesIn.writeByte(0xbe); // Indexed name and value (idx = 63)
-
-    hpackWriter.writeHeaders(headerBlock);
-    assertThat(bytesOut).isEqualTo(bytesIn);
-
-    assertThat(hpackWriter.headerCount).isEqualTo(1);
-
-    Header entry = hpackWriter.dynamicTable[hpackWriter.dynamicTable.length - 1];
-    checkEntry(entry, "custom-key", "custom-header", 55);
-
-    hpackReader.readHeaders();
-
-    assertThat(hpackReader.headerCount).isEqualTo(1);
-
-    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerBlock);
-  }
-
-  @Test public void staticHeaderIsNotCopiedIntoTheIndexedTable() throws IOException {
-    bytesIn.writeByte(0x82); // == Indexed - Add ==
-                             // idx = 2 -> :method: GET
-
-    hpackReader.readHeaders();
-
-    assertThat(hpackReader.headerCount).isEqualTo(0);
-    assertThat(hpackReader.dynamicTableByteCount).isEqualTo(0);
-
-    assertThat(hpackReader.dynamicTable[readerHeaderTableLength() - 1]).isNull();
-
-    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(
-        headerEntries(":method", "GET"));
-  }
-
-  // Example taken from twitter/hpack DecoderTest.testUnusedIndex
-  @Test public void readIndexedHeaderFieldIndex0() throws IOException {
-    bytesIn.writeByte(0x80); // == Indexed - Add idx = 0
-
-    try {
-      hpackReader.readHeaders();
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo("index == 0");
-    }
-  }
-
-  // Example taken from twitter/hpack DecoderTest.testIllegalIndex
-  @Test public void readIndexedHeaderFieldTooLargeIndex() throws IOException {
-    bytesIn.writeShort(0xff00); // == Indexed - Add idx = 127
-
-    try {
-      hpackReader.readHeaders();
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo("Header index too large 127");
-    }
-  }
-
-  // Example taken from twitter/hpack DecoderTest.testInsidiousIndex
-  @Test public void readIndexedHeaderFieldInsidiousIndex() throws IOException {
-    bytesIn.writeByte(0xff); // == Indexed - Add ==
-    bytesIn.write(decodeHex("8080808008")); // idx = -2147483521
-
-    try {
-      hpackReader.readHeaders();
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo("Header index too large -2147483521");
-    }
-  }
-
-  // Example taken from twitter/hpack DecoderTest.testHeaderTableSizeUpdate
-  @Test public void minMaxHeaderTableSize() throws IOException {
-    bytesIn.writeByte(0x20);
-    hpackReader.readHeaders();
-
-    assertThat(hpackReader.maxDynamicTableByteCount()).isEqualTo(0);
-
-    bytesIn.writeByte(0x3f); // encode size 4096
-    bytesIn.writeByte(0xe1);
-    bytesIn.writeByte(0x1f);
-    hpackReader.readHeaders();
-
-    assertThat(hpackReader.maxDynamicTableByteCount()).isEqualTo(4096);
-  }
-
-  // Example taken from twitter/hpack DecoderTest.testIllegalHeaderTableSizeUpdate
-  @Test public void cannotSetTableSizeLargerThanSettingsValue() throws IOException {
-    bytesIn.writeByte(0x3f); // encode size 4097
-    bytesIn.writeByte(0xe2);
-    bytesIn.writeByte(0x1f);
-
-    try {
-      hpackReader.readHeaders();
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo("Invalid dynamic table size update 4097");
-    }
-  }
-
-  // Example taken from twitter/hpack DecoderTest.testInsidiousMaxHeaderSize
-  @Test public void readHeaderTableStateChangeInsidiousMaxHeaderByteCount() throws IOException {
-    bytesIn.writeByte(0x3f);
-    bytesIn.write(decodeHex("e1ffffff07")); // count = -2147483648
-
-    try {
-      hpackReader.readHeaders();
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo("Invalid dynamic table size update -2147483648");
-    }
-  }
-
-  /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#appendix-C.2.4
-   */
-  @Test public void readIndexedHeaderFieldFromStaticTableWithoutBuffering() throws IOException {
-    bytesIn.writeByte(0x20); // Dynamic table size update (size = 0).
-    bytesIn.writeByte(0x82); // == Indexed - Add ==
-                             // idx = 2 -> :method: GET
-
-    hpackReader.readHeaders();
-
-    // Not buffered in header table.
-    assertThat(hpackReader.headerCount).isEqualTo(0);
-
-    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(
-        headerEntries(":method", "GET"));
-  }
-
-  @Test public void readLiteralHeaderWithIncrementalIndexingStaticName() throws IOException {
-    bytesIn.writeByte(0x7d); // == Literal indexed ==
-    // Indexed name (idx = 60) -> "www-authenticate"
-    bytesIn.writeByte(0x05); // Literal value (len = 5)
-    bytesIn.writeUtf8("Basic");
-
-    hpackReader.readHeaders();
-
-    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(
-        Arrays.asList(new Header("www-authenticate", "Basic")));
-  }
-
-  @Test public void readLiteralHeaderWithIncrementalIndexingDynamicName() throws IOException {
-    bytesIn.writeByte(0x40);
-    bytesIn.writeByte(0x0a); // Literal name (len = 10)
-    bytesIn.writeUtf8("custom-foo");
-    bytesIn.writeByte(0x05); // Literal value (len = 5)
-    bytesIn.writeUtf8("Basic");
-
-    bytesIn.writeByte(0x7e);
-    bytesIn.writeByte(0x06); // Literal value (len = 6)
-    bytesIn.writeUtf8("Basic2");
-
-    hpackReader.readHeaders();
-
-    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(
-        Arrays.asList(new Header("custom-foo", "Basic"), new Header("custom-foo", "Basic2")));
-  }
-
-  /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#appendix-C.2
-   */
-  @Test public void readRequestExamplesWithoutHuffman() throws IOException {
-    firstRequestWithoutHuffman();
-    hpackReader.readHeaders();
-    checkReadFirstRequestWithoutHuffman();
-
-    secondRequestWithoutHuffman();
-    hpackReader.readHeaders();
-    checkReadSecondRequestWithoutHuffman();
-
-    thirdRequestWithoutHuffman();
-    hpackReader.readHeaders();
-    checkReadThirdRequestWithoutHuffman();
-  }
-
-  @Test public void readFailingRequestExample() throws IOException {
-    bytesIn.writeByte(0x82); // == Indexed - Add ==
-    // idx = 2 -> :method: GET
-    bytesIn.writeByte(0x86); // == Indexed - Add ==
-    // idx = 7 -> :scheme: http
-    bytesIn.writeByte(0x84); // == Indexed - Add ==
-
-    bytesIn.writeByte(0x7f); // == Bad index! ==
-
-    // Indexed name (idx = 4) -> :authority
-    bytesIn.writeByte(0x0f); // Literal value (len = 15)
-    bytesIn.writeUtf8("www.example.com");
-
-    try {
-      hpackReader.readHeaders();
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo("Header index too large 78");
-    }
-  }
-
-  private void firstRequestWithoutHuffman() {
-    bytesIn.writeByte(0x82); // == Indexed - Add ==
-                             // idx = 2 -> :method: GET
-    bytesIn.writeByte(0x86); // == Indexed - Add ==
-                             // idx = 7 -> :scheme: http
-    bytesIn.writeByte(0x84); // == Indexed - Add ==
-                             // idx = 6 -> :path: /
-    bytesIn.writeByte(0x41); // == Literal indexed ==
-                             // Indexed name (idx = 4) -> :authority
-    bytesIn.writeByte(0x0f); // Literal value (len = 15)
-    bytesIn.writeUtf8("www.example.com");
-  }
-
-  private void checkReadFirstRequestWithoutHuffman() {
-    assertThat(hpackReader.headerCount).isEqualTo(1);
-
-    // [  1] (s =  57) :authority: www.example.com
-    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
-    checkEntry(entry, ":authority", "www.example.com", 57);
-
-    // Table size: 57
-    assertThat(hpackReader.dynamicTableByteCount).isEqualTo(57);
-
-    // Decoded header list:
-    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerEntries(
-        ":method", "GET",
-        ":scheme", "http",
-        ":path", "/",
-        ":authority", "www.example.com"));
-  }
-
-  private void secondRequestWithoutHuffman() {
-    bytesIn.writeByte(0x82); // == Indexed - Add ==
-                             // idx = 2 -> :method: GET
-    bytesIn.writeByte(0x86); // == Indexed - Add ==
-                             // idx = 7 -> :scheme: http
-    bytesIn.writeByte(0x84); // == Indexed - Add ==
-                             // idx = 6 -> :path: /
-    bytesIn.writeByte(0xbe); // == Indexed - Add ==
-                             // Indexed name (idx = 62) -> :authority: www.example.com
-    bytesIn.writeByte(0x58); // == Literal indexed ==
-                             // Indexed name (idx = 24) -> cache-control
-    bytesIn.writeByte(0x08); // Literal value (len = 8)
-    bytesIn.writeUtf8("no-cache");
-  }
-
-  private void checkReadSecondRequestWithoutHuffman() {
-    assertThat(hpackReader.headerCount).isEqualTo(2);
-
-    // [  1] (s =  53) cache-control: no-cache
-    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 2];
-    checkEntry(entry, "cache-control", "no-cache", 53);
-
-    // [  2] (s =  57) :authority: www.example.com
-    entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
-    checkEntry(entry, ":authority", "www.example.com", 57);
-
-    // Table size: 110
-    assertThat(hpackReader.dynamicTableByteCount).isEqualTo(110);
-
-    // Decoded header list:
-    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerEntries(
-        ":method", "GET",
-        ":scheme", "http",
-        ":path", "/",
-        ":authority", "www.example.com",
-        "cache-control", "no-cache"));
-  }
-
-  private void thirdRequestWithoutHuffman() {
-    bytesIn.writeByte(0x82); // == Indexed - Add ==
-                             // idx = 2 -> :method: GET
-    bytesIn.writeByte(0x87); // == Indexed - Add ==
-                             // idx = 7 -> :scheme: http
-    bytesIn.writeByte(0x85); // == Indexed - Add ==
-                             // idx = 5 -> :path: /index.html
-    bytesIn.writeByte(0xbf); // == Indexed - Add ==
-                             // Indexed name (idx = 63) -> :authority: www.example.com
-    bytesIn.writeByte(0x40); // Literal indexed
-    bytesIn.writeByte(0x0a); // Literal name (len = 10)
-    bytesIn.writeUtf8("custom-key");
-    bytesIn.writeByte(0x0c); // Literal value (len = 12)
-    bytesIn.writeUtf8("custom-value");
-  }
-
-  private void checkReadThirdRequestWithoutHuffman() {
-    assertThat(hpackReader.headerCount).isEqualTo(3);
-
-    // [  1] (s =  54) custom-key: custom-value
-    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 3];
-    checkEntry(entry, "custom-key", "custom-value", 54);
-
-    // [  2] (s =  53) cache-control: no-cache
-    entry = hpackReader.dynamicTable[readerHeaderTableLength() - 2];
-    checkEntry(entry, "cache-control", "no-cache", 53);
-
-    // [  3] (s =  57) :authority: www.example.com
-    entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
-    checkEntry(entry, ":authority", "www.example.com", 57);
-
-    // Table size: 164
-    assertThat(hpackReader.dynamicTableByteCount).isEqualTo(164);
-
-    // Decoded header list:
-    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerEntries(
-        ":method", "GET",
-        ":scheme", "https",
-        ":path", "/index.html",
-        ":authority", "www.example.com",
-        "custom-key", "custom-value"));
-  }
-
-  /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#appendix-C.4
-   */
-  @Test public void readRequestExamplesWithHuffman() throws IOException {
-    firstRequestWithHuffman();
-    hpackReader.readHeaders();
-    checkReadFirstRequestWithHuffman();
-
-    secondRequestWithHuffman();
-    hpackReader.readHeaders();
-    checkReadSecondRequestWithHuffman();
-
-    thirdRequestWithHuffman();
-    hpackReader.readHeaders();
-    checkReadThirdRequestWithHuffman();
-  }
-
-  private void firstRequestWithHuffman() {
-    bytesIn.writeByte(0x82); // == Indexed - Add ==
-                             // idx = 2 -> :method: GET
-    bytesIn.writeByte(0x86); // == Indexed - Add ==
-                             // idx = 6 -> :scheme: http
-    bytesIn.writeByte(0x84); // == Indexed - Add ==
-                             // idx = 4 -> :path: /
-    bytesIn.writeByte(0x41); // == Literal indexed ==
-                             // Indexed name (idx = 1) -> :authority
-    bytesIn.writeByte(0x8c); // Literal value Huffman encoded 12 bytes
-                             // decodes to www.example.com which is length 15
-    bytesIn.write(decodeHex("f1e3c2e5f23a6ba0ab90f4ff"));
-  }
-
-  private void checkReadFirstRequestWithHuffman() {
-    assertThat(hpackReader.headerCount).isEqualTo(1);
-
-    // [  1] (s =  57) :authority: www.example.com
-    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
-    checkEntry(entry, ":authority", "www.example.com", 57);
-
-    // Table size: 57
-    assertThat(hpackReader.dynamicTableByteCount).isEqualTo(57);
-
-    // Decoded header list:
-    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerEntries(
-        ":method", "GET",
-        ":scheme", "http",
-        ":path", "/",
-        ":authority", "www.example.com"));
-  }
-
-  private void secondRequestWithHuffman() {
-    bytesIn.writeByte(0x82); // == Indexed - Add ==
-                             // idx = 2 -> :method: GET
-    bytesIn.writeByte(0x86); // == Indexed - Add ==
-                             // idx = 6 -> :scheme: http
-    bytesIn.writeByte(0x84); // == Indexed - Add ==
-                             // idx = 4 -> :path: /
-    bytesIn.writeByte(0xbe); // == Indexed - Add ==
-                             // idx = 62 -> :authority: www.example.com
-    bytesIn.writeByte(0x58); // == Literal indexed ==
-                             // Indexed name (idx = 24) -> cache-control
-    bytesIn.writeByte(0x86); // Literal value Huffman encoded 6 bytes
-                             // decodes to no-cache which is length 8
-    bytesIn.write(decodeHex("a8eb10649cbf"));
-  }
-
-  private void checkReadSecondRequestWithHuffman() {
-    assertThat(hpackReader.headerCount).isEqualTo(2);
-
-    // [  1] (s =  53) cache-control: no-cache
-    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 2];
-    checkEntry(entry, "cache-control", "no-cache", 53);
-
-    // [  2] (s =  57) :authority: www.example.com
-    entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
-    checkEntry(entry, ":authority", "www.example.com", 57);
-
-    // Table size: 110
-    assertThat(hpackReader.dynamicTableByteCount).isEqualTo(110);
-
-    // Decoded header list:
-    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerEntries(
-        ":method", "GET",
-        ":scheme", "http",
-        ":path", "/",
-        ":authority", "www.example.com",
-        "cache-control", "no-cache"));
-  }
-
-  private void thirdRequestWithHuffman() {
-    bytesIn.writeByte(0x82); // == Indexed - Add ==
-                             // idx = 2 -> :method: GET
-    bytesIn.writeByte(0x87); // == Indexed - Add ==
-                             // idx = 7 -> :scheme: https
-    bytesIn.writeByte(0x85); // == Indexed - Add ==
-                             // idx = 5 -> :path: /index.html
-    bytesIn.writeByte(0xbf); // == Indexed - Add ==
-                             // idx = 63 -> :authority: www.example.com
-    bytesIn.writeByte(0x40); // Literal indexed
-    bytesIn.writeByte(0x88); // Literal name Huffman encoded 8 bytes
-                             // decodes to custom-key which is length 10
-    bytesIn.write(decodeHex("25a849e95ba97d7f"));
-    bytesIn.writeByte(0x89); // Literal value Huffman encoded 9 bytes
-                             // decodes to custom-value which is length 12
-    bytesIn.write(decodeHex("25a849e95bb8e8b4bf"));
-  }
-
-  private void checkReadThirdRequestWithHuffman() {
-    assertThat(hpackReader.headerCount).isEqualTo(3);
-
-    // [  1] (s =  54) custom-key: custom-value
-    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 3];
-    checkEntry(entry, "custom-key", "custom-value", 54);
-
-    // [  2] (s =  53) cache-control: no-cache
-    entry = hpackReader.dynamicTable[readerHeaderTableLength() - 2];
-    checkEntry(entry, "cache-control", "no-cache", 53);
-
-    // [  3] (s =  57) :authority: www.example.com
-    entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
-    checkEntry(entry, ":authority", "www.example.com", 57);
-
-    // Table size: 164
-    assertThat(hpackReader.dynamicTableByteCount).isEqualTo(164);
-
-    // Decoded header list:
-    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerEntries(
-        ":method", "GET",
-        ":scheme", "https",
-        ":path", "/index.html",
-        ":authority", "www.example.com",
-        "custom-key", "custom-value"));
-  }
-
-  @Test public void readSingleByteInt() throws IOException {
-    assertThat(newReader(byteStream()).readInt(10, 31)).isEqualTo(10);
-    assertThat(newReader(byteStream()).readInt(0xe0 | 10, 31)).isEqualTo(10);
-  }
-
-  @Test public void readMultibyteInt() throws IOException {
-    assertThat(newReader(byteStream(154, 10)).readInt(31, 31)).isEqualTo(1337);
-  }
-
-  @Test public void writeSingleByteInt() throws IOException {
-    hpackWriter.writeInt(10, 31, 0);
-    assertBytes(10);
-    hpackWriter.writeInt(10, 31, 0xe0);
-    assertBytes(0xe0 | 10);
-  }
-
-  @Test public void writeMultibyteInt() throws IOException {
-    hpackWriter.writeInt(1337, 31, 0);
-    assertBytes(31, 154, 10);
-    hpackWriter.writeInt(1337, 31, 0xe0);
-    assertBytes(0xe0 | 31, 154, 10);
-  }
-
-  @Test public void max31BitValue() throws IOException {
-    hpackWriter.writeInt(0x7fffffff, 31, 0);
-    assertBytes(31, 224, 255, 255, 255, 7);
-    assertThat(newReader(byteStream(224, 255, 255, 255, 7)).readInt(31, 31)).isEqualTo(
-        (long) 0x7fffffff);
-  }
-
-  @Test public void prefixMask() throws IOException {
-    hpackWriter.writeInt(31, 31, 0);
-    assertBytes(31, 0);
-    assertThat(newReader(byteStream(0)).readInt(31, 31)).isEqualTo(31);
-  }
-
-  @Test public void prefixMaskMinusOne() throws IOException {
-    hpackWriter.writeInt(30, 31, 0);
-    assertBytes(30);
-    assertThat(newReader(byteStream(0)).readInt(31, 31)).isEqualTo(31);
-  }
-
-  @Test public void zero() throws IOException {
-    hpackWriter.writeInt(0, 31, 0);
-    assertBytes(0);
-    assertThat(newReader(byteStream()).readInt(0, 31)).isEqualTo(0);
-  }
-
-  @Test public void lowercaseHeaderNameBeforeEmit() throws IOException {
-    hpackWriter.writeHeaders(Arrays.asList(new Header("FoO", "BaR")));
-    assertBytes(0x40, 3, 'f', 'o', 'o', 3, 'B', 'a', 'R');
-  }
-
-  @Test public void mixedCaseHeaderNameIsMalformed() throws IOException {
-    try {
-      newReader(byteStream(0, 3, 'F', 'o', 'o', 3, 'B', 'a', 'R')).readHeaders();
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo(
-          "PROTOCOL_ERROR response malformed: mixed case name: Foo");
-    }
-  }
-
-  @Test public void emptyHeaderName() throws IOException {
-    hpackWriter.writeByteString(ByteString.encodeUtf8(""));
-    assertBytes(0);
-    assertThat(newReader(byteStream(0)).readByteString()).isEqualTo(ByteString.EMPTY);
-  }
-
-  @Test public void emitsDynamicTableSizeUpdate() throws IOException {
-    hpackWriter.setHeaderTableSizeSetting(2048);
-    hpackWriter.writeHeaders(Arrays.asList(new Header("foo", "bar")));
-    assertBytes(
-        0x3F, 0xE1, 0xF, // Dynamic table size update (size = 2048).
-        0x40, 3, 'f', 'o', 'o', 3, 'b', 'a', 'r');
-
-    hpackWriter.setHeaderTableSizeSetting(8192);
-    hpackWriter.writeHeaders(Arrays.asList(new Header("bar", "foo")));
-    assertBytes(
-        0x3F, 0xE1, 0x3F, // Dynamic table size update (size = 8192).
-        0x40, 3, 'b', 'a', 'r', 3, 'f', 'o', 'o');
-
-    // No more dynamic table updates should be emitted.
-    hpackWriter.writeHeaders(Arrays.asList(new Header("far", "boo")));
-    assertBytes(0x40, 3, 'f', 'a', 'r', 3, 'b', 'o', 'o');
-  }
-
-  @Test public void noDynamicTableSizeUpdateWhenSizeIsEqual() throws IOException {
-    int currentSize = hpackWriter.headerTableSizeSetting;
-    hpackWriter.setHeaderTableSizeSetting(currentSize);
-    hpackWriter.writeHeaders(Arrays.asList(new Header("foo", "bar")));
-
-    assertBytes(0x40, 3, 'f', 'o', 'o', 3, 'b', 'a', 'r');
-  }
-
-  @Test public void growDynamicTableSize() throws IOException {
-    hpackWriter.setHeaderTableSizeSetting(8192);
-    hpackWriter.setHeaderTableSizeSetting(16384);
-    hpackWriter.writeHeaders(Arrays.asList(new Header("foo", "bar")));
-
-    assertBytes(
-        0x3F, 0xE1, 0x7F, // Dynamic table size update (size = 16384).
-        0x40, 3, 'f', 'o', 'o', 3, 'b', 'a', 'r');
-  }
-
-  @Test public void shrinkDynamicTableSize() throws IOException {
-    hpackWriter.setHeaderTableSizeSetting(2048);
-    hpackWriter.setHeaderTableSizeSetting(0);
-    hpackWriter.writeHeaders(Arrays.asList(new Header("foo", "bar")));
-
-    assertBytes(
-        0x20, // Dynamic size update (size = 0).
-        0x40, 3, 'f', 'o', 'o', 3, 'b', 'a', 'r');
-  }
-
-  @Test public void manyDynamicTableSizeChanges() throws IOException {
-    hpackWriter.setHeaderTableSizeSetting(16384);
-    hpackWriter.setHeaderTableSizeSetting(8096);
-    hpackWriter.setHeaderTableSizeSetting(0);
-    hpackWriter.setHeaderTableSizeSetting(4096);
-    hpackWriter.setHeaderTableSizeSetting(2048);
-    hpackWriter.writeHeaders(Arrays.asList(new Header("foo", "bar")));
-
-    assertBytes(
-        0x20, // Dynamic size update (size = 0).
-        0x3F, 0xE1, 0xF, // Dynamic size update (size = 2048).
-        0x40, 3, 'f', 'o', 'o', 3, 'b', 'a', 'r');
-  }
-
-  @Test public void dynamicTableEvictionWhenSizeLowered() throws IOException {
-    List<Header> headerBlock =
-        headerEntries(
-            "custom-key1", "custom-header",
-            "custom-key2", "custom-header");
-    hpackWriter.writeHeaders(headerBlock);
-    assertThat(hpackWriter.headerCount).isEqualTo(2);
-
-    hpackWriter.setHeaderTableSizeSetting(56);
-    assertThat(hpackWriter.headerCount).isEqualTo(1);
-
-    hpackWriter.setHeaderTableSizeSetting(0);
-    assertThat(hpackWriter.headerCount).isEqualTo(0);
-  }
-
-  @Test public void noEvictionOnDynamicTableSizeIncrease() throws IOException {
-    List<Header> headerBlock =
-        headerEntries(
-            "custom-key1", "custom-header",
-            "custom-key2", "custom-header");
-    hpackWriter.writeHeaders(headerBlock);
-    assertThat(hpackWriter.headerCount).isEqualTo(2);
-
-    hpackWriter.setHeaderTableSizeSetting(8192);
-    assertThat(hpackWriter.headerCount).isEqualTo(2);
-  }
-
-  @Test public void dynamicTableSizeHasAnUpperBound() {
-    hpackWriter.setHeaderTableSizeSetting(1048576);
-    assertThat(hpackWriter.maxDynamicTableByteCount).isEqualTo(16384);
-  }
-
-  @Test public void huffmanEncode() throws IOException {
-    hpackWriter = new Hpack.Writer(4096, true, bytesOut);
-    hpackWriter.writeHeaders(headerEntries("foo", "bar"));
-
-    ByteString expected = new Buffer()
-        .writeByte(0x40) // Literal header, new name.
-        .writeByte(0x82) // String literal is Huffman encoded (len = 2).
-        .writeByte(0x94) // 'foo' Huffman encoded.
-        .writeByte(0xE7)
-        .writeByte(3) // String literal not Huffman encoded (len = 3).
-        .writeByte('b')
-        .writeByte('a')
-        .writeByte('r')
-        .readByteString();
-
-    ByteString actual = bytesOut.readByteString();
-    assertThat(actual).isEqualTo(expected);
-  }
-
-  @Test public void staticTableIndexedHeaders() throws IOException {
-    hpackWriter.writeHeaders(headerEntries(":method", "GET"));
-    assertBytes(0x82);
-    assertThat(hpackWriter.headerCount).isEqualTo(0);
-
-    hpackWriter.writeHeaders(headerEntries(":method", "POST"));
-    assertBytes(0x83);
-    assertThat(hpackWriter.headerCount).isEqualTo(0);
-
-    hpackWriter.writeHeaders(headerEntries(":path", "/"));
-    assertBytes(0x84);
-    assertThat(hpackWriter.headerCount).isEqualTo(0);
-
-    hpackWriter.writeHeaders(headerEntries(":path", "/index.html"));
-    assertBytes(0x85);
-    assertThat(hpackWriter.headerCount).isEqualTo(0);
-
-    hpackWriter.writeHeaders(headerEntries(":scheme", "http"));
-    assertBytes(0x86);
-    assertThat(hpackWriter.headerCount).isEqualTo(0);
-
-    hpackWriter.writeHeaders(headerEntries(":scheme", "https"));
-    assertBytes(0x87);
-    assertThat(hpackWriter.headerCount).isEqualTo(0);
-  }
-
-  @Test public void dynamicTableIndexedHeader() throws IOException {
-    hpackWriter.writeHeaders(headerEntries("custom-key", "custom-header"));
-    assertBytes(0x40,
-        10, 'c', 'u', 's', 't', 'o', 'm', '-', 'k', 'e', 'y',
-        13, 'c', 'u', 's', 't', 'o', 'm', '-', 'h', 'e', 'a', 'd', 'e', 'r');
-    assertThat(hpackWriter.headerCount).isEqualTo(1);
-
-    hpackWriter.writeHeaders(headerEntries("custom-key", "custom-header"));
-    assertBytes(0xbe);
-    assertThat(hpackWriter.headerCount).isEqualTo(1);
-  }
-
-  @Test public void doNotIndexPseudoHeaders() throws IOException {
-    hpackWriter.writeHeaders(headerEntries(":method", "PUT"));
-    assertBytes(0x02, 3, 'P', 'U', 'T');
-    assertThat(hpackWriter.headerCount).isEqualTo(0);
-
-    hpackWriter.writeHeaders(headerEntries(":path", "/okhttp"));
-    assertBytes(0x04, 7, '/', 'o', 'k', 'h', 't', 't', 'p');
-    assertThat(hpackWriter.headerCount).isEqualTo(0);
-  }
-
-  @Test public void incrementalIndexingWithAuthorityPseudoHeader() throws IOException {
-    hpackWriter.writeHeaders(headerEntries(":authority", "foo.com"));
-    assertBytes(0x41, 7, 'f', 'o', 'o', '.', 'c', 'o', 'm');
-    assertThat(hpackWriter.headerCount).isEqualTo(1);
-
-    hpackWriter.writeHeaders(headerEntries(":authority", "foo.com"));
-    assertBytes(0xbe);
-    assertThat(hpackWriter.headerCount).isEqualTo(1);
-
-    // If the :authority header somehow changes, it should be re-added to the dynamic table.
-    hpackWriter.writeHeaders(headerEntries(":authority", "bar.com"));
-    assertBytes(0x41, 7, 'b', 'a', 'r', '.', 'c', 'o', 'm');
-    assertThat(hpackWriter.headerCount).isEqualTo(2);
-
-    hpackWriter.writeHeaders(headerEntries(":authority", "bar.com"));
-    assertBytes(0xbe);
-    assertThat(hpackWriter.headerCount).isEqualTo(2);
-  }
-
-  @Test public void incrementalIndexingWithStaticTableIndexedName() throws IOException {
-    hpackWriter.writeHeaders(headerEntries("accept-encoding", "gzip"));
-    assertBytes(0x50, 4, 'g', 'z', 'i', 'p');
-    assertThat(hpackWriter.headerCount).isEqualTo(1);
-
-    hpackWriter.writeHeaders(headerEntries("accept-encoding", "gzip"));
-    assertBytes(0xbe);
-    assertThat(hpackWriter.headerCount).isEqualTo(1);
-  }
-
-  @Test public void incrementalIndexingWithDynamcTableIndexedName() throws IOException {
-    hpackWriter.writeHeaders(headerEntries("foo", "bar"));
-    assertBytes(0x40, 3, 'f', 'o', 'o', 3, 'b', 'a', 'r');
-    assertThat(hpackWriter.headerCount).isEqualTo(1);
-
-    hpackWriter.writeHeaders(headerEntries("foo", "bar1"));
-    assertBytes(0x7e, 4, 'b', 'a', 'r', '1');
-    assertThat(hpackWriter.headerCount).isEqualTo(2);
-
-    hpackWriter.writeHeaders(headerEntries("foo", "bar1"));
-    assertBytes(0xbe);
-    assertThat(hpackWriter.headerCount).isEqualTo(2);
-  }
-
-  private Hpack.Reader newReader(Buffer source) {
-    return new Hpack.Reader(4096, source);
-  }
-
-  private Buffer byteStream(int... bytes) {
-    return new Buffer().write(intArrayToByteArray(bytes));
-  }
-
-  private void checkEntry(Header entry, String name, String value, int size) {
-    assertThat(entry.name.utf8()).isEqualTo(name);
-    assertThat(entry.value.utf8()).isEqualTo(value);
-    assertThat(entry.hpackSize).isEqualTo(size);
-  }
-
-  private void assertBytes(int... bytes) throws IOException {
-    ByteString expected = intArrayToByteArray(bytes);
-    ByteString actual = bytesOut.readByteString();
-    assertThat(actual).isEqualTo(expected);
-  }
-
-  private ByteString intArrayToByteArray(int[] bytes) {
-    byte[] data = new byte[bytes.length];
-    for (int i = 0; i < bytes.length; i++) {
-      data[i] = (byte) bytes[i];
-    }
-    return ByteString.of(data);
-  }
-
-  private int readerHeaderTableLength() {
-    return hpackReader.dynamicTable.length;
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
deleted file mode 100644
index fd17034047..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
+++ /dev/null
@@ -1,1929 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.io.InterruptedIOException;
-import java.net.Socket;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-import okhttp3.Headers;
-import okhttp3.internal.Util;
-import okhttp3.internal.http2.MockHttp2Peer.InFrame;
-import okio.AsyncTimeout;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.Okio;
-import okio.Sink;
-import okio.Source;
-import okio.Utf8;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TestRule;
-import org.junit.rules.Timeout;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static okhttp3.TestUtil.headerEntries;
-import static okhttp3.TestUtil.repeat;
-import static okhttp3.internal.Internal.initializeInstanceForTests;
-import static okhttp3.internal.Util.EMPTY_BYTE_ARRAY;
-import static okhttp3.internal.Util.EMPTY_HEADERS;
-import static okhttp3.internal.http2.Http2Connection.Listener.REFUSE_INCOMING_STREAMS;
-import static okhttp3.internal.http2.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
-import static okhttp3.internal.http2.Settings.ENABLE_PUSH;
-import static okhttp3.internal.http2.Settings.HEADER_TABLE_SIZE;
-import static okhttp3.internal.http2.Settings.INITIAL_WINDOW_SIZE;
-import static okhttp3.internal.http2.Settings.MAX_CONCURRENT_STREAMS;
-import static okhttp3.internal.http2.Settings.MAX_FRAME_SIZE;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.data.Offset.offset;
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.fail;
-
-public final class Http2ConnectionTest {
-  private final MockHttp2Peer peer = new MockHttp2Peer();
-
-  @Rule public final TestRule timeout = new Timeout(5_000, TimeUnit.MILLISECONDS);
-
-  @Before public void setup() {
-    initializeInstanceForTests();
-  }
-
-  @After public void tearDown() throws Exception {
-    peer.close();
-  }
-
-  @Test public void serverPingsClientHttp2() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.sendFrame().ping(false, 2, 3);
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    connect(peer);
-
-    // verify the peer received what was expected
-    InFrame ping = peer.takeFrame();
-    assertThat(ping.type).isEqualTo(Http2.TYPE_PING);
-    assertThat(ping.streamId).isEqualTo(0);
-    assertThat(ping.payload1).isEqualTo(2);
-    assertThat(ping.payload2).isEqualTo(3);
-    assertThat(ping.ack).isTrue();
-  }
-
-  @Test public void peerHttp2ServerLowersInitialWindowSize() throws Exception {
-    Settings initial = new Settings();
-    initial.set(INITIAL_WINDOW_SIZE, 1684);
-    Settings shouldntImpactConnection = new Settings();
-    shouldntImpactConnection.set(INITIAL_WINDOW_SIZE, 3368);
-
-    peer.sendFrame().settings(initial);
-    peer.acceptFrame(); // ACK
-    peer.sendFrame().settings(shouldntImpactConnection);
-    peer.acceptFrame(); // ACK 2
-    peer.acceptFrame(); // HEADERS
-    peer.play();
-
-    Http2Connection connection = connect(peer);
-
-    // Verify the peer received the second ACK.
-    InFrame ackFrame = peer.takeFrame();
-    assertThat(ackFrame.type).isEqualTo(Http2.TYPE_SETTINGS);
-    assertThat(ackFrame.streamId).isEqualTo(0);
-    assertThat(ackFrame.ack).isTrue();
-
-    // This stream was created *after* the connection settings were adjusted.
-    Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
-
-    assertThat(connection.peerSettings.getInitialWindowSize()).isEqualTo(3368);
-    // New Stream is has the most recent initial window size.
-    assertThat(stream.bytesLeftInWriteWindow).isEqualTo(3368);
-  }
-
-  @Test public void peerHttp2ServerZerosCompressionTable() throws Exception {
-    boolean client = false; // Peer is server, so we are client.
-    Settings settings = new Settings();
-    settings.set(HEADER_TABLE_SIZE, 0);
-
-    Http2Connection connection = connectWithSettings(client, settings);
-
-    // Verify the peer's settings were read and applied.
-    assertThat(connection.peerSettings.getHeaderTableSize()).isEqualTo(0);
-    Http2Writer writer = connection.writer;
-    assertThat(writer.hpackWriter.dynamicTableByteCount).isEqualTo(0);
-    assertThat(writer.hpackWriter.headerTableSizeSetting).isEqualTo(0);
-  }
-
-  @Test public void peerHttp2ClientDisablesPush() throws Exception {
-    boolean client = false; // Peer is client, so we are server.
-    Settings settings = new Settings();
-    settings.set(ENABLE_PUSH, 0); // The peer client disables push.
-
-    Http2Connection connection = connectWithSettings(client, settings);
-
-    // verify the peer's settings were read and applied.
-    assertThat(connection.peerSettings.getEnablePush(true)).isFalse();
-  }
-
-  @Test public void peerIncreasesMaxFrameSize() throws Exception {
-    int newMaxFrameSize = 0x4001;
-    Settings settings = new Settings();
-    settings.set(MAX_FRAME_SIZE, newMaxFrameSize);
-
-    Http2Connection connection = connectWithSettings(true, settings);
-
-    // verify the peer's settings were read and applied.
-    assertThat(connection.peerSettings.getMaxFrameSize(-1)).isEqualTo(newMaxFrameSize);
-    assertThat(connection.writer.maxDataLength()).isEqualTo(newMaxFrameSize);
-  }
-
-  /**
-   * Webservers may set the initial window size to zero, which is a special case because it means
-   * that we have to flush headers immediately before any request body can be sent.
-   * https://github.com/square/okhttp/issues/2543
-   */
-  @Test public void peerSetsZeroFlowControl() throws Exception {
-    peer.setClient(true);
-
-    // Write the mocking script.
-    peer.sendFrame().settings(new Settings().set(INITIAL_WINDOW_SIZE, 0));
-    peer.acceptFrame(); // ACK
-    peer.sendFrame().windowUpdate(0, 10); // Increase the connection window size.
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
-    peer.acceptFrame(); // HEADERS STREAM 3
-    peer.sendFrame().windowUpdate(3, 5);
-    peer.acceptFrame(); // DATA STREAM 3 "abcde"
-    peer.sendFrame().windowUpdate(3, 5);
-    peer.acceptFrame(); // DATA STREAM 3 "fghi"
-    peer.play();
-
-    // Play it back.
-    Http2Connection connection = connect(peer);
-    connection.writePingAndAwaitPong(); // Ensure the SETTINGS have been received.
-    Http2Stream stream = connection.newStream(headerEntries("a", "android"), true);
-    BufferedSink sink = Okio.buffer(stream.getSink());
-    sink.writeUtf8("abcdefghi");
-    sink.flush();
-
-    // Verify the peer received what was expected.
-    peer.takeFrame(); // PING
-    InFrame headers = peer.takeFrame();
-    assertThat(headers.type).isEqualTo(Http2.TYPE_HEADERS);
-    InFrame data1 = peer.takeFrame();
-    assertThat(data1.type).isEqualTo(Http2.TYPE_DATA);
-    assertThat(data1.streamId).isEqualTo(3);
-    assertArrayEquals("abcde".getBytes(UTF_8), data1.data);
-    InFrame data2 = peer.takeFrame();
-    assertThat(data2.type).isEqualTo(Http2.TYPE_DATA);
-    assertThat(data2.streamId).isEqualTo(3);
-    assertArrayEquals("fghi".getBytes(UTF_8), data2.data);
-  }
-
-  /**
-   * Confirm that we account for discarded data frames. It's possible that data frames are in-flight
-   * just prior to us canceling a stream.
-   */
-  @Test public void discardedDataFramesAreCounted() throws Exception {
-    // Write the mocking script.
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM 3
-    peer.sendFrame().headers(false, 3, headerEntries("a", "apple"));
-    peer.sendFrame().data(false, 3, data(1024), 1024);
-    peer.acceptFrame(); // RST_STREAM
-    peer.sendFrame().data(true, 3, data(1024), 1024);
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    Http2Connection connection = connect(peer);
-    Http2Stream stream1 = connection.newStream(headerEntries("b", "bark"), false);
-    Source source = stream1.getSource();
-    Buffer buffer = new Buffer();
-    while (buffer.size() != 1024) source.read(buffer, 1024);
-    stream1.close(ErrorCode.CANCEL, null);
-
-    InFrame frame1 = peer.takeFrame();
-    assertThat(frame1.type).isEqualTo(Http2.TYPE_HEADERS);
-    InFrame frame2 = peer.takeFrame();
-    assertThat(frame2.type).isEqualTo(Http2.TYPE_RST_STREAM);
-    InFrame frame3 = peer.takeFrame();
-    assertThat(frame3.type).isEqualTo(Http2.TYPE_RST_STREAM);
-
-    assertThat(connection.unacknowledgedBytesRead).isEqualTo(2048);
-  }
-
-  @Test public void receiveGoAwayHttp2() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM 3
-    peer.acceptFrame(); // SYN_STREAM 5
-    peer.sendFrame().goAway(3, ErrorCode.PROTOCOL_ERROR, EMPTY_BYTE_ARRAY);
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
-    peer.acceptFrame(); // DATA STREAM 3
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream1 = connection.newStream(headerEntries("a", "android"), true);
-    Http2Stream stream2 = connection.newStream(headerEntries("b", "banana"), true);
-    connection.writePingAndAwaitPong(); // Ensure the GO_AWAY that resets stream2 has been received.
-    BufferedSink sink1 = Okio.buffer(stream1.getSink());
-    BufferedSink sink2 = Okio.buffer(stream2.getSink());
-    sink1.writeUtf8("abc");
-    try {
-      sink2.writeUtf8("abc");
-      sink2.flush();
-      fail();
-    } catch (IOException expected) {
-      assertThat(expected.getMessage()).isEqualTo("stream was reset: REFUSED_STREAM");
-    }
-    sink1.writeUtf8("def");
-    sink1.close();
-    try {
-      connection.newStream(headerEntries("c", "cola"), true);
-      fail();
-    } catch (ConnectionShutdownException expected) {
-    }
-    assertThat(stream1.isOpen()).isTrue();
-    assertThat(stream2.isOpen()).isFalse();
-    assertThat(connection.openStreamCount()).isEqualTo(1);
-
-    // verify the peer received what was expected
-    InFrame synStream1 = peer.takeFrame();
-    assertThat(synStream1.type).isEqualTo(Http2.TYPE_HEADERS);
-    InFrame synStream2 = peer.takeFrame();
-    assertThat(synStream2.type).isEqualTo(Http2.TYPE_HEADERS);
-    InFrame ping = peer.takeFrame();
-    assertThat(ping.type).isEqualTo(Http2.TYPE_PING);
-    InFrame data1 = peer.takeFrame();
-    assertThat(data1.type).isEqualTo(Http2.TYPE_DATA);
-    assertThat(data1.streamId).isEqualTo(3);
-    assertArrayEquals("abcdef".getBytes(UTF_8), data1.data);
-  }
-
-  @Test public void readSendsWindowUpdateHttp2() throws Exception {
-    int windowSize = 100;
-    int windowUpdateThreshold = 50;
-
-    // Write the mocking script.
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
-    for (int i = 0; i < 3; i++) {
-      // Send frames of summing to size 50, which is windowUpdateThreshold.
-      peer.sendFrame().data(false, 3, data(24), 24);
-      peer.sendFrame().data(false, 3, data(25), 25);
-      peer.sendFrame().data(false, 3, data(1), 1);
-      peer.acceptFrame(); // connection WINDOW UPDATE
-      peer.acceptFrame(); // stream WINDOW UPDATE
-    }
-    peer.sendFrame().data(true, 3, data(0), 0);
-    peer.play();
-
-    // Play it back.
-    Http2Connection connection = connect(peer);
-    connection.okHttpSettings.set(INITIAL_WINDOW_SIZE, windowSize);
-    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
-    assertThat(stream.unacknowledgedBytesRead).isEqualTo(0);
-    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("a", "android"));
-    Source in = stream.getSource();
-    Buffer buffer = new Buffer();
-    buffer.writeAll(in);
-    assertThat(in.read(buffer, 1)).isEqualTo(-1);
-    assertThat(buffer.size()).isEqualTo(150);
-
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    for (int i = 0; i < 3; i++) {
-      List<Integer> windowUpdateStreamIds = new ArrayList<>(2);
-      for (int j = 0; j < 2; j++) {
-        InFrame windowUpdate = peer.takeFrame();
-        assertThat(windowUpdate.type).isEqualTo(Http2.TYPE_WINDOW_UPDATE);
-        windowUpdateStreamIds.add(windowUpdate.streamId);
-        assertThat(windowUpdate.windowSizeIncrement).isEqualTo(windowUpdateThreshold);
-      }
-      // connection
-      assertThat(windowUpdateStreamIds.contains(0)).isTrue();
-      // stream
-      assertThat(windowUpdateStreamIds.contains(3)).isTrue();
-    }
-  }
-
-  @Test public void serverSendsEmptyDataClientDoesntSendWindowUpdateHttp2() throws Exception {
-    // Write the mocking script.
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
-    peer.sendFrame().data(true, 3, data(0), 0);
-    peer.play();
-
-    // Play it back.
-    Http2Connection connection = connect(peer);
-    Http2Stream client = connection.newStream(headerEntries("b", "banana"), false);
-    assertThat(client.getSource().read(new Buffer(), 1)).isEqualTo(-1);
-
-    // Verify the peer received what was expected.
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    assertThat(peer.frameCount()).isEqualTo(5);
-  }
-
-  @Test public void clientSendsEmptyDataServerDoesntSendWindowUpdateHttp2() throws Exception {
-    // Write the mocking script.
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // DATA
-    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
-    peer.play();
-
-    // Play it back.
-    Http2Connection connection = connect(peer);
-    Http2Stream client = connection.newStream(headerEntries("b", "banana"), true);
-    BufferedSink out = Okio.buffer(client.getSink());
-    out.write(EMPTY_BYTE_ARRAY);
-    out.flush();
-    out.close();
-
-    // Verify the peer received what was expected.
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS);
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_DATA);
-    assertThat(peer.frameCount()).isEqualTo(5);
-  }
-
-  @Test public void maxFrameSizeHonored() throws Exception {
-    byte[] buff = new byte[peer.maxOutboundDataLength() + 1];
-    Arrays.fill(buff, (byte) '*');
-
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
-    peer.acceptFrame(); // DATA
-    peer.acceptFrame(); // DATA
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
-    BufferedSink out = Okio.buffer(stream.getSink());
-    out.write(buff);
-    out.flush();
-    out.close();
-
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    InFrame data = peer.takeFrame();
-    assertThat(data.data.length).isEqualTo(peer.maxOutboundDataLength());
-    data = peer.takeFrame();
-    assertThat(data.data.length).isEqualTo(1);
-  }
-
-  @Test public void pushPromiseStream() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
-    final List<Header> expectedRequestHeaders = Arrays.asList(
-        new Header(Header.TARGET_METHOD, "GET"),
-        new Header(Header.TARGET_SCHEME, "https"),
-        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
-        new Header(Header.TARGET_PATH, "/cached")
-    );
-    peer.sendFrame().pushPromise(3, 2, expectedRequestHeaders);
-    final List<Header> expectedResponseHeaders = Arrays.asList(
-        new Header(Header.RESPONSE_STATUS, "200")
-    );
-    peer.sendFrame().headers(true, 2, expectedResponseHeaders);
-    peer.sendFrame().data(true, 3, data(0), 0);
-    peer.play();
-
-    RecordingPushObserver observer = new RecordingPushObserver();
-
-    // play it back
-    Http2Connection connection = connect(peer, observer, REFUSE_INCOMING_STREAMS);
-    Http2Stream client = connection.newStream(headerEntries("b", "banana"), false);
-    assertThat(client.getSource().read(new Buffer(), 1)).isEqualTo(-1);
-
-    // verify the peer received what was expected
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS);
-
-    assertThat(observer.takeEvent()).isEqualTo(expectedRequestHeaders);
-    assertThat(observer.takeEvent()).isEqualTo(expectedResponseHeaders);
-  }
-
-  @Test public void doublePushPromise() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.sendFrame().pushPromise(3, 2, headerEntries("a", "android"));
-    peer.acceptFrame(); // SYN_REPLY
-    peer.sendFrame().pushPromise(3, 2, headerEntries("b", "banana"));
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    connection.newStream(headerEntries("b", "banana"), false);
-
-    // verify the peer received what was expected
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS);
-    assertThat(peer.takeFrame().errorCode).isEqualTo(ErrorCode.PROTOCOL_ERROR);
-  }
-
-  @Test public void pushPromiseStreamsAutomaticallyCancel() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.sendFrame().pushPromise(3, 2, Arrays.asList(
-        new Header(Header.TARGET_METHOD, "GET"),
-        new Header(Header.TARGET_SCHEME, "https"),
-        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
-        new Header(Header.TARGET_PATH, "/cached")
-    ));
-    peer.sendFrame().headers(true, 2, Arrays.asList(
-        new Header(Header.RESPONSE_STATUS, "200")
-    ));
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    connect(peer, PushObserver.CANCEL, REFUSE_INCOMING_STREAMS);
-
-    // verify the peer received what was expected
-    InFrame rstStream = peer.takeFrame();
-    assertThat(rstStream.type).isEqualTo(Http2.TYPE_RST_STREAM);
-    assertThat(rstStream.streamId).isEqualTo(2);
-    assertThat(rstStream.errorCode).isEqualTo(ErrorCode.CANCEL);
-  }
-
-  /**
-   * When writing a set of headers fails due to an {@code IOException}, make sure the writer is left
-   * in a consistent state so the next writer also gets an {@code IOException} also instead of
-   * something worse (like an {@link IllegalStateException}.
-   *
-   * <p>See https://github.com/square/okhttp/issues/1651
-   */
-  @Test public void socketExceptionWhileWritingHeaders() throws Exception {
-    peer.acceptFrame(); // SYN_STREAM.
-    peer.play();
-
-    String longString = repeat('a', Http2.INITIAL_MAX_FRAME_SIZE + 1);
-    Socket socket = peer.openSocket();
-    Http2Connection connection = new Http2Connection.Builder(true)
-        .socket(socket)
-        .pushObserver(IGNORE)
-        .build();
-    connection.start(false);
-    socket.shutdownOutput();
-    try {
-      connection.newStream(headerEntries("a", longString), false);
-      fail();
-    } catch (IOException expected) {
-    }
-    try {
-      connection.newStream(headerEntries("b", longString), false);
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void clientCreatesStreamAndServerReplies() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // DATA
-    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
-    peer.sendFrame().data(true, 3, new Buffer().writeUtf8("robot"), 5);
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0); // PING
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
-    BufferedSink out = Okio.buffer(stream.getSink());
-    out.writeUtf8("c3po");
-    out.close();
-    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("a", "android"));
-    assertStreamData("robot", stream.getSource());
-    connection.writePingAndAwaitPong();
-    assertThat(connection.openStreamCount()).isEqualTo(0);
-
-    // verify the peer received what was expected
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    assertThat(synStream.outFinished).isFalse();
-    assertThat(synStream.streamId).isEqualTo(3);
-    assertThat(synStream.associatedStreamId).isEqualTo(-1);
-    assertThat(synStream.headerBlock).isEqualTo(headerEntries("b", "banana"));
-    InFrame requestData = peer.takeFrame();
-    assertArrayEquals("c3po".getBytes(UTF_8), requestData.data);
-  }
-
-  @Test public void serverFinishesStreamWithHeaders() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // PING
-    peer.sendFrame().headers(true, 3, headerEntries("headers", "bam"));
-    peer.sendFrame().ping(true, 1, 0); // PONG
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("a", "artichaut"), false);
-    connection.writePingAndAwaitPong();
-    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("headers", "bam"));
-    assertThat(stream.trailers()).isEqualTo(EMPTY_HEADERS);
-    assertThat(connection.openStreamCount()).isEqualTo(0);
-
-    // verify the peer received what was expected
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    assertThat(synStream.outFinished).isFalse();
-    assertThat(synStream.streamId).isEqualTo(3);
-    assertThat(synStream.associatedStreamId).isEqualTo(-1);
-    assertThat(synStream.headerBlock).isEqualTo(headerEntries("a", "artichaut"));
-  }
-
-  @Test public void serverWritesTrailersAndClientReadsTrailers() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().headers(false, 3, headerEntries("headers", "bam"));
-    peer.acceptFrame(); // PING
-    peer.sendFrame().headers(true, 3, headerEntries("trailers", "boom"));
-    peer.sendFrame().ping(true, 1, 0); // PONG
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("a", "artichaut"), false);
-    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("headers", "bam"));
-    connection.writePingAndAwaitPong();
-    assertThat(stream.trailers()).isEqualTo(Headers.of("trailers", "boom"));
-    assertThat(connection.openStreamCount()).isEqualTo(0);
-
-    // verify the peer received what was expected
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    assertThat(synStream.outFinished).isFalse();
-    assertThat(synStream.streamId).isEqualTo(3);
-    assertThat(synStream.associatedStreamId).isEqualTo(-1);
-    assertThat(synStream.headerBlock).isEqualTo(headerEntries("a", "artichaut"));
-  }
-
-  @Test public void serverWritesTrailersWithData() throws Exception {
-    // We buffer some outbound data and headers and confirm that the END_STREAM flag comes with the
-    // headers (and not with the data).
-
-    // write the mocking script for the client
-    peer.setClient(true);
-
-    // Write the mocking script.
-    peer.sendFrame().settings(new Settings());
-    peer.sendFrame().headers(true, 3, headerEntries("client", "abc"));
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // HEADERS STREAM 3
-    peer.acceptFrame(); // DATA STREAM 3 "abcde"
-    peer.acceptFrame(); // HEADERS STREAM 3
-    peer.play();
-
-    // Play it back.
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("a", "android"), true);
-    stream.enqueueTrailers(Headers.of("foo", "bar"));
-    BufferedSink sink = Okio.buffer(stream.getSink());
-    sink.writeUtf8("abcdefghi");
-    sink.close();
-
-    // Verify the peer received what was expected.
-    InFrame headers1 = peer.takeFrame();
-    assertThat(headers1.type).isEqualTo(Http2.TYPE_HEADERS);
-    InFrame data1 = peer.takeFrame();
-    assertThat(data1.type).isEqualTo(Http2.TYPE_DATA);
-    assertThat(data1.streamId).isEqualTo(3);
-    assertArrayEquals("abcdefghi".getBytes(UTF_8), data1.data);
-    assertThat(data1.inFinished).isFalse();
-    InFrame headers2 = peer.takeFrame();
-    assertThat(headers2.type).isEqualTo(Http2.TYPE_HEADERS);
-    assertThat(headers2.inFinished).isTrue();
-  }
-
-  @Test public void clientCannotReadTrailersWithoutExhaustingStream() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().data(false, 3, new Buffer().writeUtf8("robot"), 5);
-    peer.sendFrame().headers(true, 3, headerEntries("trailers", "boom"));
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0); // PONG
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("a", "artichaut"), true);
-    connection.writePingAndAwaitPong();
-    try {
-      stream.trailers();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void clientCannotReadTrailersIfTheStreamFailed() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().rstStream(3, ErrorCode.PROTOCOL_ERROR);
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0); // PONG
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("a", "artichaut"), true);
-    connection.writePingAndAwaitPong();
-    try {
-      stream.trailers();
-      fail();
-    } catch (StreamResetException expected) {
-    }
-  }
-
-  @Test public void serverCannotEnqueueTrailersAfterFinishingTheStream() throws Exception {
-    peer.setClient(true);
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    // Play it back.
-    Http2Connection connection = connect(peer);
-    connection.writePingAndAwaitPong();
-    Http2Stream stream = connection.newStream(headerEntries("a", "android"), true);
-    // finish the stream
-    stream.writeHeaders(headerEntries("b", "berserk"), true, false);
-    try {
-      stream.enqueueTrailers(Headers.of("trailers", "boom"));
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void noTrailersFrameYieldsEmptyTrailers() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().headers(false, 3, headerEntries("headers", "bam"));
-    peer.sendFrame().data(true, 3, new Buffer().writeUtf8("robot"), 5);
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0); // PONG
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("a", "artichaut"), false);
-    BufferedSource source = Okio.buffer(stream.getSource());
-    connection.writePingAndAwaitPong();
-    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("headers", "bam"));
-    assertThat(source.readUtf8(5)).isEqualTo("robot");
-    assertThat(stream.trailers()).isEqualTo(EMPTY_HEADERS);
-    assertThat(connection.openStreamCount()).isEqualTo(0);
-
-    // verify the peer received what was expected
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    assertThat(synStream.outFinished).isFalse();
-    assertThat(synStream.streamId).isEqualTo(3);
-    assertThat(synStream.associatedStreamId).isEqualTo(-1);
-    assertThat(synStream.headerBlock).isEqualTo(headerEntries("a", "artichaut"));
-  }
-
-  @Test public void serverReadsHeadersDataHeaders() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // DATA
-    peer.acceptFrame(); // HEADERS
-    peer.sendFrame().headers(true, 3, headerEntries("a", "android"));
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0); // PING
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
-    BufferedSink out = Okio.buffer(stream.getSink());
-    out.writeUtf8("c3po");
-    out.close();
-    stream.writeHeaders(headerEntries("e", "elephant"), false, false);
-    connection.writePingAndAwaitPong();
-    assertThat(connection.openStreamCount()).isEqualTo(0);
-
-    // verify the peer received what was expected
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    assertThat(synStream.outFinished).isFalse();
-    assertThat(synStream.streamId).isEqualTo(3);
-    assertThat(synStream.associatedStreamId).isEqualTo(-1);
-    assertThat(synStream.headerBlock).isEqualTo(headerEntries("b", "banana"));
-    InFrame requestData = peer.takeFrame();
-    assertArrayEquals("c3po".getBytes(UTF_8), requestData.data);
-
-    InFrame nextFrame = peer.takeFrame();
-    assertThat(nextFrame.headerBlock).isEqualTo(headerEntries("e", "elephant"));
-  }
-
-  @Test public void clientCreatesStreamAndServerRepliesWithFin() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // PING
-    peer.sendFrame().headers(true, 3, headerEntries("a", "android"));
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    connection.newStream(headerEntries("b", "banana"), false);
-    assertThat(connection.openStreamCount()).isEqualTo(1);
-    connection.writePingAndAwaitPong(); // Ensure that the SYN_REPLY has been received.
-    assertThat(connection.openStreamCount()).isEqualTo(0);
-
-    // verify the peer received what was expected
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    InFrame ping = peer.takeFrame();
-    assertThat(ping.type).isEqualTo(Http2.TYPE_PING);
-  }
-
-  @Test public void serverPingsClient() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.sendFrame().ping(false, 2, 0);
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    connect(peer);
-
-    // verify the peer received what was expected
-    InFrame ping = peer.takeFrame();
-    assertThat(ping.streamId).isEqualTo(0);
-    assertThat(ping.payload1).isEqualTo(2);
-    assertThat(ping.payload2).isEqualTo(0);
-    assertThat(ping.ack).isTrue();
-  }
-
-  @Test public void clientPingsServer() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 5);
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    long pingAtNanos = System.nanoTime();
-    connection.writePingAndAwaitPong();
-    long elapsedNanos = System.nanoTime() - pingAtNanos;
-    assertThat(elapsedNanos > 0).isTrue();
-    assertThat(elapsedNanos < TimeUnit.SECONDS.toNanos(1)).isTrue();
-
-    // verify the peer received what was expected
-    InFrame pingFrame = peer.takeFrame();
-    assertThat(pingFrame.type).isEqualTo(Http2.TYPE_PING);
-    assertThat(pingFrame.streamId).isEqualTo(0);
-    // OkOk
-    assertThat(pingFrame.payload1).isEqualTo(0x4f4b6f6b);
-    // donut
-    assertThat(pingFrame.payload2).isEqualTo(0xf09f8da9);
-    assertThat(pingFrame.ack).isFalse();
-  }
-
-  @Test public void unexpectedPingIsNotReturned() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.sendFrame().ping(false, 2, 0);
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 3, 0); // This ping will not be returned.
-    peer.sendFrame().ping(false, 4, 0);
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    connect(peer);
-
-    // verify the peer received what was expected
-    InFrame ping2 = peer.takeFrame();
-    assertThat(ping2.payload1).isEqualTo(2);
-    InFrame ping4 = peer.takeFrame();
-    assertThat(ping4.payload1).isEqualTo(4);
-  }
-
-  @Test public void serverSendsSettingsToClient() throws Exception {
-    // write the mocking script
-    final Settings settings = new Settings();
-    settings.set(MAX_CONCURRENT_STREAMS, 10);
-    peer.sendFrame().settings(settings);
-    peer.acceptFrame(); // ACK
-    peer.sendFrame().ping(false, 2, 0);
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    final CountDownLatch maxConcurrentStreamsUpdated = new CountDownLatch(1);
-    final AtomicInteger maxConcurrentStreams = new AtomicInteger();
-    Http2Connection.Listener listener = new Http2Connection.Listener() {
-      @Override public void onStream(Http2Stream stream) throws IOException {
-        throw new AssertionError();
-      }
-
-      @Override public void onSettings(Http2Connection connection) {
-        maxConcurrentStreams.set(connection.maxConcurrentStreams());
-        maxConcurrentStreamsUpdated.countDown();
-      }
-    };
-    Http2Connection connection = connect(peer, IGNORE, listener);
-
-    synchronized (connection) {
-      assertThat(connection.peerSettings.getMaxConcurrentStreams(-1)).isEqualTo(10);
-    }
-    maxConcurrentStreamsUpdated.await();
-    assertThat(maxConcurrentStreams.get()).isEqualTo(10);
-  }
-
-  @Test public void multipleSettingsFramesAreMerged() throws Exception {
-    // write the mocking script
-    Settings settings1 = new Settings();
-    settings1.set(HEADER_TABLE_SIZE, 10000);
-    settings1.set(INITIAL_WINDOW_SIZE, 20000);
-    settings1.set(MAX_FRAME_SIZE, 30000);
-    peer.sendFrame().settings(settings1);
-    peer.acceptFrame(); // ACK SETTINGS
-    Settings settings2 = new Settings();
-    settings2.set(INITIAL_WINDOW_SIZE, 40000);
-    settings2.set(MAX_FRAME_SIZE, 50000);
-    settings2.set(MAX_CONCURRENT_STREAMS, 60000);
-    peer.sendFrame().settings(settings2);
-    peer.acceptFrame(); // ACK SETTINGS
-    peer.sendFrame().ping(false, 2, 0);
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_SETTINGS);
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_PING);
-    synchronized (connection) {
-      assertThat(connection.peerSettings.getHeaderTableSize()).isEqualTo(10000);
-      assertThat(connection.peerSettings.getInitialWindowSize()).isEqualTo(40000);
-      assertThat(connection.peerSettings.getMaxFrameSize(-1)).isEqualTo(50000);
-      assertThat(connection.peerSettings.getMaxConcurrentStreams(-1)).isEqualTo(60000);
-    }
-  }
-
-  @Test public void clearSettingsBeforeMerge() throws Exception {
-    // write the mocking script
-    Settings settings1 = new Settings();
-    settings1.set(HEADER_TABLE_SIZE, 10000);
-    settings1.set(INITIAL_WINDOW_SIZE, 20000);
-    settings1.set(MAX_FRAME_SIZE, 30000);
-    peer.sendFrame().settings(settings1);
-    peer.acceptFrame(); // ACK
-    peer.sendFrame().ping(false, 2, 0);
-    peer.acceptFrame();
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-
-    // fake a settings frame with clear flag set.
-    Settings settings2 = new Settings();
-    settings2.set(MAX_CONCURRENT_STREAMS, 60000);
-    connection.readerRunnable.settings(true, settings2);
-
-    synchronized (connection) {
-      assertThat(connection.peerSettings.getHeaderTableSize()).isEqualTo(-1);
-      assertThat(connection.peerSettings.getInitialWindowSize()).isEqualTo(
-          (long) DEFAULT_INITIAL_WINDOW_SIZE);
-      assertThat(connection.peerSettings.getMaxFrameSize(-1)).isEqualTo(-1);
-      assertThat(connection.peerSettings.getMaxConcurrentStreams(-1)).isEqualTo(60000);
-    }
-  }
-
-  @Test public void bogusDataFrameDoesNotDisruptConnection() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.sendFrame().data(true, 41, new Buffer().writeUtf8("bogus"), 5);
-    peer.acceptFrame(); // RST_STREAM
-    peer.sendFrame().ping(false, 2, 0);
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    connect(peer);
-
-    // verify the peer received what was expected
-    InFrame rstStream = peer.takeFrame();
-    assertThat(rstStream.type).isEqualTo(Http2.TYPE_RST_STREAM);
-    assertThat(rstStream.streamId).isEqualTo(41);
-    assertThat(rstStream.errorCode).isEqualTo(ErrorCode.PROTOCOL_ERROR);
-    InFrame ping = peer.takeFrame();
-    assertThat(ping.payload1).isEqualTo(2);
-  }
-
-  @Test public void bogusReplySilentlyIgnored() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.sendFrame().headers(false, 41, headerEntries("a", "android"));
-    peer.sendFrame().ping(false, 2, 0);
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    connect(peer);
-
-    // verify the peer received what was expected
-    InFrame ping = peer.takeFrame();
-    assertThat(ping.payload1).isEqualTo(2);
-  }
-
-  @Test public void serverClosesClientOutputStream() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().rstStream(3, ErrorCode.CANCEL);
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("a", "android"), true);
-    BufferedSink out = Okio.buffer(stream.getSink());
-    connection.writePingAndAwaitPong(); // Ensure that the RST_CANCEL has been received.
-    try {
-      out.writeUtf8("square");
-      out.flush();
-      fail();
-    } catch (IOException expected) {
-      assertThat(expected.getMessage()).isEqualTo("stream was reset: CANCEL");
-    }
-    try {
-      out.close();
-      fail();
-    } catch (IOException expected) {
-      // Close throws because buffered data wasn't flushed.
-    }
-    assertThat(connection.openStreamCount()).isEqualTo(0);
-
-    // verify the peer received what was expected
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    assertThat(synStream.inFinished).isFalse();
-    assertThat(synStream.outFinished).isFalse();
-    InFrame ping = peer.takeFrame();
-    assertThat(ping.type).isEqualTo(Http2.TYPE_PING);
-  }
-
-  /**
-   * Test that the client sends a RST_STREAM if doing so won't disrupt the output stream.
-   */
-  @Test public void clientClosesClientInputStream() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
-    Source in = stream.getSource();
-    BufferedSink out = Okio.buffer(stream.getSink());
-    in.close();
-    try {
-      in.read(new Buffer(), 1);
-      fail();
-    } catch (IOException expected) {
-      assertThat(expected.getMessage()).isEqualTo("stream closed");
-    }
-    try {
-      out.writeUtf8("a");
-      out.flush();
-      fail();
-    } catch (IOException expected) {
-      assertThat(expected.getMessage()).isEqualTo("stream finished");
-    }
-    assertThat(connection.openStreamCount()).isEqualTo(0);
-
-    // verify the peer received what was expected
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    assertThat(synStream.inFinished).isTrue();
-    assertThat(synStream.outFinished).isFalse();
-    InFrame rstStream = peer.takeFrame();
-    assertThat(rstStream.type).isEqualTo(Http2.TYPE_RST_STREAM);
-    assertThat(rstStream.errorCode).isEqualTo(ErrorCode.CANCEL);
-  }
-
-  /**
-   * Test that the client doesn't send a RST_STREAM if doing so will disrupt the output stream.
-   */
-  @Test public void clientClosesClientInputStreamIfOutputStreamIsClosed() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // DATA
-    peer.acceptFrame(); // DATA with FLAG_FIN
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("a", "android"), true);
-    Source source = stream.getSource();
-    BufferedSink out = Okio.buffer(stream.getSink());
-    source.close();
-    try {
-      source.read(new Buffer(), 1);
-      fail();
-    } catch (IOException expected) {
-      assertThat(expected.getMessage()).isEqualTo("stream closed");
-    }
-    out.writeUtf8("square");
-    out.flush();
-    out.close();
-    assertThat(connection.openStreamCount()).isEqualTo(0);
-
-    // verify the peer received what was expected
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    assertThat(synStream.inFinished).isFalse();
-    assertThat(synStream.outFinished).isFalse();
-    InFrame data = peer.takeFrame();
-    assertThat(data.type).isEqualTo(Http2.TYPE_DATA);
-    assertArrayEquals("square".getBytes(UTF_8), data.data);
-    InFrame fin = peer.takeFrame();
-    assertThat(fin.type).isEqualTo(Http2.TYPE_DATA);
-    assertThat(fin.inFinished).isTrue();
-    assertThat(fin.outFinished).isFalse();
-    InFrame rstStream = peer.takeFrame();
-    assertThat(rstStream.type).isEqualTo(Http2.TYPE_RST_STREAM);
-    assertThat(rstStream.errorCode).isEqualTo(ErrorCode.CANCEL);
-  }
-
-  @Test public void serverClosesClientInputStream() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().headers(false, 3, headerEntries("b", "banana"));
-    peer.sendFrame().data(true, 3, new Buffer().writeUtf8("square"), 6);
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
-    Source source = stream.getSource();
-    assertStreamData("square", source);
-    connection.writePingAndAwaitPong(); // Ensure that inFinished has been received.
-    assertThat(connection.openStreamCount()).isEqualTo(0);
-
-    // verify the peer received what was expected
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    assertThat(synStream.inFinished).isTrue();
-    assertThat(synStream.outFinished).isFalse();
-  }
-
-  @Test public void remoteDoubleSynReply() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
-    peer.acceptFrame(); // PING
-    peer.sendFrame().headers(false, 3, headerEntries("b", "banana"));
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("c", "cola"), false);
-    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("a", "android"));
-    connection.writePingAndAwaitPong(); // Ensure that the 2nd SYN REPLY has been received.
-
-    // verify the peer received what was expected
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    InFrame ping = peer.takeFrame();
-    assertThat(ping.type).isEqualTo(Http2.TYPE_PING);
-  }
-
-  @Test public void remoteSendsDataAfterInFinished() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
-    peer.sendFrame().data(true, 3, new Buffer().writeUtf8("robot"), 5);
-    peer.sendFrame().data(true, 3, new Buffer().writeUtf8("c3po"), 4);
-    peer.acceptFrame(); // RST_STREAM
-    peer.sendFrame().ping(false, 2, 0); // Ping just to make sure the stream was fastforwarded.
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
-    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("a", "android"));
-    assertStreamData("robot", stream.getSource());
-
-    // verify the peer received what was expected
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    InFrame rstStream = peer.takeFrame();
-    assertThat(rstStream.type).isEqualTo(Http2.TYPE_RST_STREAM);
-    assertThat(rstStream.streamId).isEqualTo(3);
-    InFrame ping = peer.takeFrame();
-    assertThat(ping.type).isEqualTo(Http2.TYPE_PING);
-    assertThat(ping.payload1).isEqualTo(2);
-  }
-
-  @Test public void clientDoesNotLimitFlowControl() throws Exception {
-    int dataLength = 16384;
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().headers(false, 3, headerEntries("b", "banana"));
-    peer.sendFrame().data(false, 3, new Buffer().write(new byte[dataLength]), dataLength);
-    peer.sendFrame().data(false, 3, new Buffer().write(new byte[dataLength]), dataLength);
-    peer.sendFrame().data(false, 3, new Buffer().write(new byte[dataLength]), dataLength);
-    peer.sendFrame().data(false, 3, new Buffer().write(new byte[dataLength]), dataLength);
-    peer.sendFrame().data(false, 3, new Buffer().write(new byte[1]), 1);
-    peer.sendFrame().ping(false, 2, 0); // Ping just to make sure the stream was fastforwarded.
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
-    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("b", "banana"));
-
-    // verify the peer received what was expected
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    InFrame ping = peer.takeFrame();
-    assertThat(ping.type).isEqualTo(Http2.TYPE_PING);
-    assertThat(ping.payload1).isEqualTo(2);
-  }
-
-  @Test public void remoteSendsRefusedStreamBeforeReplyHeaders() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().rstStream(3, ErrorCode.REFUSED_STREAM);
-    peer.sendFrame().ping(false, 2, 0);
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
-    try {
-      stream.takeHeaders();
-      fail();
-    } catch (IOException expected) {
-      assertThat(expected.getMessage()).isEqualTo("stream was reset: REFUSED_STREAM");
-    }
-    assertThat(connection.openStreamCount()).isEqualTo(0);
-
-    // verify the peer received what was expected
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    InFrame ping = peer.takeFrame();
-    assertThat(ping.type).isEqualTo(Http2.TYPE_PING);
-    assertThat(ping.payload1).isEqualTo(2);
-  }
-
-  @Test public void receiveGoAway() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM 1
-    peer.acceptFrame(); // SYN_STREAM 3
-    peer.acceptFrame(); // PING.
-    peer.sendFrame().goAway(3, ErrorCode.PROTOCOL_ERROR, Util.EMPTY_BYTE_ARRAY);
-    peer.sendFrame().ping(true, 1, 0);
-    peer.acceptFrame(); // DATA STREAM 1
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream1 = connection.newStream(headerEntries("a", "android"), true);
-    Http2Stream stream2 = connection.newStream(headerEntries("b", "banana"), true);
-    connection.writePingAndAwaitPong(); // Ensure the GO_AWAY that resets stream2 has been received.
-    BufferedSink sink1 = Okio.buffer(stream1.getSink());
-    BufferedSink sink2 = Okio.buffer(stream2.getSink());
-    sink1.writeUtf8("abc");
-    try {
-      sink2.writeUtf8("abc");
-      sink2.flush();
-      fail();
-    } catch (IOException expected) {
-      assertThat(expected.getMessage()).isEqualTo("stream was reset: REFUSED_STREAM");
-    }
-    sink1.writeUtf8("def");
-    sink1.close();
-    try {
-      connection.newStream(headerEntries("c", "cola"), false);
-      fail();
-    } catch (ConnectionShutdownException expected) {
-    }
-    assertThat(stream1.isOpen()).isTrue();
-    assertThat(stream2.isOpen()).isFalse();
-    assertThat(connection.openStreamCount()).isEqualTo(1);
-
-    // verify the peer received what was expected
-    InFrame synStream1 = peer.takeFrame();
-    assertThat(synStream1.type).isEqualTo(Http2.TYPE_HEADERS);
-    InFrame synStream2 = peer.takeFrame();
-    assertThat(synStream2.type).isEqualTo(Http2.TYPE_HEADERS);
-    InFrame ping = peer.takeFrame();
-    assertThat(ping.type).isEqualTo(Http2.TYPE_PING);
-    InFrame data1 = peer.takeFrame();
-    assertThat(data1.type).isEqualTo(Http2.TYPE_DATA);
-    assertThat(data1.streamId).isEqualTo(3);
-    assertArrayEquals("abcdef".getBytes(UTF_8), data1.data);
-  }
-
-  @Test public void sendGoAway() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM 1
-    peer.acceptFrame(); // GOAWAY
-    peer.acceptFrame(); // PING
-    peer.sendFrame().headers(false, 2, headerEntries("b", "b")); // Should be ignored!
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    connection.newStream(headerEntries("a", "android"), false);
-    synchronized (connection) {
-      if (connection.shutdown) {
-        throw new ConnectionShutdownException();
-      }
-    }
-    connection.writePing(false, 0x01, 0x02);
-    connection.shutdown(ErrorCode.PROTOCOL_ERROR);
-    assertThat(connection.openStreamCount()).isEqualTo(1);
-    connection.awaitPong(); // Prevent the peer from exiting prematurely.
-
-    // verify the peer received what was expected
-    InFrame synStream1 = peer.takeFrame();
-    assertThat(synStream1.type).isEqualTo(Http2.TYPE_HEADERS);
-    InFrame pingFrame = peer.takeFrame();
-    assertThat(pingFrame.type).isEqualTo(Http2.TYPE_PING);
-    InFrame goaway = peer.takeFrame();
-    assertThat(goaway.type).isEqualTo(Http2.TYPE_GOAWAY);
-    assertThat(goaway.streamId).isEqualTo(0);
-    assertThat(goaway.errorCode).isEqualTo(ErrorCode.PROTOCOL_ERROR);
-  }
-
-  @Test public void close() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // GOAWAY
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
-    assertThat(connection.openStreamCount()).isEqualTo(1);
-    connection.close();
-    assertThat(connection.openStreamCount()).isEqualTo(0);
-    try {
-      connection.newStream(headerEntries("b", "banana"), false);
-      fail();
-    } catch (ConnectionShutdownException expected) {
-    }
-    BufferedSink sink = Okio.buffer(stream.getSink());
-    try {
-      sink.writeByte(0);
-      sink.flush();
-      fail();
-    } catch (IOException expected) {
-      assertThat(expected.getMessage()).isEqualTo("stream finished");
-    }
-    try {
-      stream.getSource().read(new Buffer(), 1);
-      fail();
-    } catch (IOException expected) {
-      assertThat(expected.getMessage()).isEqualTo("stream was reset: CANCEL");
-    }
-
-    // verify the peer received what was expected
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    InFrame goaway = peer.takeFrame();
-    assertThat(goaway.type).isEqualTo(Http2.TYPE_GOAWAY);
-    InFrame rstStream = peer.takeFrame();
-    assertThat(rstStream.type).isEqualTo(Http2.TYPE_RST_STREAM);
-    assertThat(rstStream.streamId).isEqualTo(3);
-  }
-
-  @Test public void getResponseHeadersTimesOut() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
-    stream.readTimeout().timeout(500, TimeUnit.MILLISECONDS);
-    long startNanos = System.nanoTime();
-    try {
-      stream.takeHeaders();
-      fail();
-    } catch (InterruptedIOException expected) {
-    }
-    long elapsedNanos = System.nanoTime() - startNanos;
-    awaitWatchdogIdle();
-    /* 200ms delta */
-    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedNanos)).isCloseTo(500d, offset(200d));
-    assertThat(connection.openStreamCount()).isEqualTo(0);
-
-    // verify the peer received what was expected
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS);
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_RST_STREAM);
-  }
-
-  @Test public void readTimesOut() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
-    stream.readTimeout().timeout(500, TimeUnit.MILLISECONDS);
-    Source source = stream.getSource();
-    long startNanos = System.nanoTime();
-    try {
-      source.read(new Buffer(), 1);
-      fail();
-    } catch (InterruptedIOException expected) {
-    }
-    long elapsedNanos = System.nanoTime() - startNanos;
-    awaitWatchdogIdle();
-    /* 200ms delta */
-    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedNanos)).isCloseTo(500d, offset(200d));
-    assertThat(connection.openStreamCount()).isEqualTo(0);
-
-    // verify the peer received what was expected
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS);
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_RST_STREAM);
-  }
-
-  @Test public void writeTimesOutAwaitingStreamWindow() throws Exception {
-    // Set the peer's receive window to 5 bytes!
-    Settings peerSettings = new Settings().set(INITIAL_WINDOW_SIZE, 5);
-
-    // write the mocking script
-    peer.sendFrame().settings(peerSettings);
-    peer.acceptFrame(); // ACK SETTINGS
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
-    peer.acceptFrame(); // DATA
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    connection.writePingAndAwaitPong(); // Make sure settings have been received.
-    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
-    Sink sink = stream.getSink();
-    sink.write(new Buffer().writeUtf8("abcde"), 5);
-    stream.writeTimeout().timeout(500, TimeUnit.MILLISECONDS);
-    long startNanos = System.nanoTime();
-    sink.write(new Buffer().writeUtf8("f"), 1);
-    try {
-      sink.flush(); // This will time out waiting on the write window.
-      fail();
-    } catch (InterruptedIOException expected) {
-    }
-    long elapsedNanos = System.nanoTime() - startNanos;
-    awaitWatchdogIdle();
-    /* 200ms delta */
-    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedNanos)).isCloseTo(500d, offset(200d));
-    assertThat(connection.openStreamCount()).isEqualTo(0);
-
-    // verify the peer received what was expected
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_PING);
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS);
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_DATA);
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_RST_STREAM);
-  }
-
-  @Test public void writeTimesOutAwaitingConnectionWindow() throws Exception {
-    // Set the peer's receive window to 5 bytes. Give the stream 5 bytes back, so only the
-    // connection-level window is applicable.
-    Settings peerSettings = new Settings().set(INITIAL_WINDOW_SIZE, 5);
-
-    // write the mocking script
-    peer.sendFrame().settings(peerSettings);
-    peer.acceptFrame(); // ACK SETTINGS
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 3, 0);
-    peer.acceptFrame(); // DATA
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    connection.writePingAndAwaitPong(); // Make sure settings have been acked.
-    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
-    connection.writePingAndAwaitPong(); // Make sure the window update has been received.
-    Sink sink = stream.getSink();
-    stream.writeTimeout().timeout(500, TimeUnit.MILLISECONDS);
-    sink.write(new Buffer().writeUtf8("abcdef"), 6);
-    long startNanos = System.nanoTime();
-    try {
-      sink.flush(); // This will time out waiting on the write window.
-      fail();
-    } catch (InterruptedIOException expected) {
-    }
-    long elapsedNanos = System.nanoTime() - startNanos;
-    awaitWatchdogIdle();
-    /* 200ms delta */
-    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedNanos)).isCloseTo(500d, offset(200d));
-    assertThat(connection.openStreamCount()).isEqualTo(0);
-
-    // verify the peer received what was expected
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_PING);
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS);
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_PING);
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_DATA);
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_RST_STREAM);
-  }
-
-  @Test public void outgoingWritesAreBatched() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
-    peer.acceptFrame(); // DATA
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
-
-    // two outgoing writes
-    Sink sink = stream.getSink();
-    sink.write(new Buffer().writeUtf8("abcde"), 5);
-    sink.write(new Buffer().writeUtf8("fghij"), 5);
-    sink.close();
-
-    // verify the peer received one incoming frame
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS);
-    InFrame data = peer.takeFrame();
-    assertThat(data.type).isEqualTo(Http2.TYPE_DATA);
-    assertArrayEquals("abcdefghij".getBytes(UTF_8), data.data);
-    assertThat(data.inFinished).isTrue();
-  }
-
-  @Test public void headers() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // PING
-    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
-    peer.sendFrame().headers(false, 3, headerEntries("c", "c3po"));
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
-    connection.writePingAndAwaitPong(); // Ensure that the HEADERS has been received.
-    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("a", "android"));
-    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("c", "c3po"));
-
-    // verify the peer received what was expected
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    InFrame ping = peer.takeFrame();
-    assertThat(ping.type).isEqualTo(Http2.TYPE_PING);
-  }
-
-  @Test public void readMultipleSetsOfResponseHeaders() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
-    peer.acceptFrame(); // PING
-    peer.sendFrame().headers(true, 3, headerEntries("c", "cola"));
-    peer.sendFrame().ping(true, 1, 0); // PONG
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
-    stream.getConnection().flush();
-    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("a", "android"));
-    connection.writePingAndAwaitPong();
-    assertThat(stream.trailers()).isEqualTo(Headers.of("c", "cola"));
-
-    // verify the peer received what was expected
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS);
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_PING);
-  }
-
-  @Test public void readSendsWindowUpdate() throws Exception {
-    int windowSize = 100;
-    int windowUpdateThreshold = 50;
-
-    // Write the mocking script.
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
-    for (int i = 0; i < 3; i++) {
-      // Send frames of summing to size 50, which is windowUpdateThreshold.
-      peer.sendFrame().data(false, 3, data(24), 24);
-      peer.sendFrame().data(false, 3, data(25), 25);
-      peer.sendFrame().data(false, 3, data(1), 1);
-      peer.acceptFrame(); // connection WINDOW UPDATE
-      peer.acceptFrame(); // stream WINDOW UPDATE
-    }
-    peer.sendFrame().data(true, 3, data(0), 0);
-    peer.play();
-
-    // Play it back.
-    Http2Connection connection = connect(peer);
-    connection.okHttpSettings.set(INITIAL_WINDOW_SIZE, windowSize);
-    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
-    assertThat(stream.unacknowledgedBytesRead).isEqualTo(0);
-    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("a", "android"));
-    Source in = stream.getSource();
-    Buffer buffer = new Buffer();
-    buffer.writeAll(in);
-    assertThat(in.read(buffer, 1)).isEqualTo(-1);
-    assertThat(buffer.size()).isEqualTo(150);
-
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    for (int i = 0; i < 3; i++) {
-      List<Integer> windowUpdateStreamIds = new ArrayList<>(2);
-      for (int j = 0; j < 2; j++) {
-        InFrame windowUpdate = peer.takeFrame();
-        assertThat(windowUpdate.type).isEqualTo(Http2.TYPE_WINDOW_UPDATE);
-        windowUpdateStreamIds.add(windowUpdate.streamId);
-        assertThat(windowUpdate.windowSizeIncrement).isEqualTo(windowUpdateThreshold);
-      }
-      // connection
-      assertThat(windowUpdateStreamIds.contains(0)).isTrue();
-      // stream
-      assertThat(windowUpdateStreamIds.contains(3)).isTrue();
-    }
-  }
-
-  @Test public void serverSendsEmptyDataClientDoesntSendWindowUpdate() throws Exception {
-    // Write the mocking script.
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
-    peer.sendFrame().data(true, 3, data(0), 0);
-    peer.play();
-
-    // Play it back.
-    Http2Connection connection = connect(peer);
-    Http2Stream client = connection.newStream(headerEntries("b", "banana"), false);
-    assertThat(client.getSource().read(new Buffer(), 1)).isEqualTo(-1);
-
-    // Verify the peer received what was expected.
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    assertThat(peer.frameCount()).isEqualTo(5);
-  }
-
-  @Test public void clientSendsEmptyDataServerDoesntSendWindowUpdate() throws Exception {
-    // Write the mocking script.
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // DATA
-    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
-    peer.play();
-
-    // Play it back.
-    Http2Connection connection = connect(peer);
-    Http2Stream client = connection.newStream(headerEntries("b", "banana"), true);
-    BufferedSink out = Okio.buffer(client.getSink());
-    out.write(Util.EMPTY_BYTE_ARRAY);
-    out.flush();
-    out.close();
-
-    // Verify the peer received what was expected.
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS);
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_DATA);
-    assertThat(peer.frameCount()).isEqualTo(5);
-  }
-
-  @Test public void testTruncatedDataFrame() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
-    peer.sendFrame().data(false, 3, data(1024), 1024);
-    peer.truncateLastFrame(8 + 100);
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
-    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("a", "android"));
-    Source in = stream.getSource();
-    try {
-      Okio.buffer(in).readByteString(101);
-      fail();
-    } catch (EOFException expected) {
-    }
-  }
-
-  @Test public void blockedStreamDoesntStarveNewStream() throws Exception {
-    int framesThatFillWindow = roundUp(DEFAULT_INITIAL_WINDOW_SIZE, peer.maxOutboundDataLength());
-
-    // Write the mocking script. This accepts more data frames than necessary!
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // SETTINGS ACK
-    peer.acceptFrame(); // SYN_STREAM on stream 1
-    for (int i = 0; i < framesThatFillWindow; i++) {
-      peer.acceptFrame(); // DATA on stream 1
-    }
-    peer.acceptFrame(); // SYN_STREAM on stream 2
-    peer.acceptFrame(); // DATA on stream 2
-    peer.play();
-
-    // Play it back.
-    Http2Connection connection = connect(peer);
-    Http2Stream stream1 = connection.newStream(headerEntries("a", "apple"), true);
-    BufferedSink out1 = Okio.buffer(stream1.getSink());
-    out1.write(new byte[DEFAULT_INITIAL_WINDOW_SIZE]);
-    out1.flush();
-
-    // Check that we've filled the window for both the stream and also the connection.
-    assertThat(connection.bytesLeftInWriteWindow).isEqualTo(0);
-    assertThat(connection.getStream(3).bytesLeftInWriteWindow).isEqualTo(0);
-
-    // receiving a window update on the connection will unblock new streams.
-    connection.readerRunnable.windowUpdate(0, 3);
-
-    assertThat(connection.bytesLeftInWriteWindow).isEqualTo(3);
-    assertThat(connection.getStream(3).bytesLeftInWriteWindow).isEqualTo(0);
-
-    // Another stream should be able to send data even though 1 is blocked.
-    Http2Stream stream2 = connection.newStream(headerEntries("b", "banana"), true);
-    BufferedSink out2 = Okio.buffer(stream2.getSink());
-    out2.writeUtf8("foo");
-    out2.flush();
-
-    assertThat(connection.bytesLeftInWriteWindow).isEqualTo(0);
-    assertThat(connection.getStream(3).bytesLeftInWriteWindow).isEqualTo(0);
-    assertThat(connection.getStream(5).bytesLeftInWriteWindow).isEqualTo(
-        (long) (DEFAULT_INITIAL_WINDOW_SIZE - 3));
-  }
-
-  @Test public void remoteOmitsInitialSettings() throws Exception {
-    // Write the mocking script. Note no SETTINGS frame is sent or acknowledged.
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
-    peer.acceptFrame(); // GOAWAY
-    peer.play();
-
-    Http2Connection connection = new Http2Connection.Builder(true)
-        .socket(peer.openSocket())
-        .build();
-    connection.start(false);
-
-    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
-    try {
-      stream.takeHeaders();
-      fail();
-    } catch (IOException expected) {
-      assertThat(expected.getMessage()).isEqualTo("Expected a SETTINGS frame but was 1");
-    }
-
-    // verify the peer received what was expected
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    InFrame goaway = peer.takeFrame();
-    assertThat(goaway.type).isEqualTo(Http2.TYPE_GOAWAY);
-    assertThat(goaway.errorCode).isEqualTo(ErrorCode.PROTOCOL_ERROR);
-  }
-
-  private Buffer data(int byteCount) {
-    return new Buffer().write(new byte[byteCount]);
-  }
-
-  private void assertStreamData(String expected, Source source) throws IOException {
-    String actual = Okio.buffer(source).readUtf8();
-    assertThat(actual).isEqualTo(expected);
-  }
-
-  /** Reads {@code prefix} from {@code source}. */
-  private void assertStreamPrefix(String prefix, BufferedSource source) throws IOException {
-    assertThat(source.readUtf8(Utf8.size(prefix))).isEqualTo(prefix);
-  }
-
-  /**
-   * Returns true when all work currently in progress by the watchdog have completed. This method
-   * creates more work for the watchdog and waits for that work to be executed. When it is, we know
-   * work that preceded this call is complete.
-   */
-  private void awaitWatchdogIdle() throws Exception {
-    final CountDownLatch latch = new CountDownLatch(1);
-    AsyncTimeout watchdogJob = new AsyncTimeout() {
-      @Override protected void timedOut() {
-        latch.countDown();
-      }
-    };
-    watchdogJob.deadlineNanoTime(System.nanoTime()); // Due immediately!
-    watchdogJob.enter();
-    latch.await();
-  }
-
-  static int roundUp(int num, int divisor) {
-    return (num + divisor - 1) / divisor;
-  }
-
-  private Http2Connection connectWithSettings(boolean client, Settings settings) throws Exception {
-    peer.setClient(client);
-    peer.sendFrame().settings(settings);
-    peer.acceptFrame(); // ACK
-    peer.play();
-    return connect(peer);
-  }
-
-  private Http2Connection connect(MockHttp2Peer peer) throws Exception {
-    return connect(peer, IGNORE, REFUSE_INCOMING_STREAMS);
-  }
-
-  /** Builds a new connection to {@code peer} with settings acked. */
-  private Http2Connection connect(MockHttp2Peer peer, PushObserver pushObserver,
-      Http2Connection.Listener listener) throws Exception {
-    Http2Connection connection = new Http2Connection.Builder(true)
-        .socket(peer.openSocket())
-        .pushObserver(pushObserver)
-        .listener(listener)
-        .build();
-    connection.start(false);
-
-    // verify the peer received the ACK
-    InFrame ackFrame = peer.takeFrame();
-    assertThat(ackFrame.type).isEqualTo(Http2.TYPE_SETTINGS);
-    assertThat(ackFrame.streamId).isEqualTo(0);
-    assertThat(ackFrame.ack).isTrue();
-
-    return connection;
-  }
-
-  static final PushObserver IGNORE = new PushObserver() {
-
-    @Override public boolean onRequest(int streamId, List<Header> requestHeaders) {
-      return false;
-    }
-
-    @Override public boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last) {
-      return false;
-    }
-
-    @Override public boolean onData(int streamId, BufferedSource source, int byteCount,
-        boolean last) throws IOException {
-      source.skip(byteCount);
-      return false;
-    }
-
-    @Override public void onReset(int streamId, ErrorCode errorCode) {
-    }
-  };
-
-  private static class RecordingPushObserver implements PushObserver {
-    final List<Object> events = new ArrayList<>();
-
-    public synchronized Object takeEvent() throws Exception {
-      while (events.isEmpty()) {
-        wait();
-      }
-      return events.remove(0);
-    }
-
-    @Override public synchronized boolean onRequest(int streamId, List<Header> requestHeaders) {
-      assertThat(streamId).isEqualTo(2);
-      events.add(requestHeaders);
-      notifyAll();
-      return false;
-    }
-
-    @Override public synchronized boolean onHeaders(
-        int streamId, List<Header> responseHeaders, boolean last) {
-      assertThat(streamId).isEqualTo(2);
-      assertThat(last).isTrue();
-      events.add(responseHeaders);
-      notifyAll();
-      return false;
-    }
-
-    @Override public synchronized boolean onData(
-        int streamId, BufferedSource source, int byteCount, boolean last) {
-      events.add(new AssertionError("onData"));
-      notifyAll();
-      return false;
-    }
-
-    @Override public synchronized void onReset(int streamId, ErrorCode errorCode) {
-      events.add(new AssertionError("onReset"));
-      notifyAll();
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java
deleted file mode 100644
index 0854370aa6..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java
+++ /dev/null
@@ -1,777 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.List;
-import java.util.concurrent.atomic.AtomicInteger;
-import okhttp3.internal.Util;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.GzipSink;
-import okio.Okio;
-import org.junit.Test;
-
-import static okhttp3.TestUtil.headerEntries;
-import static okhttp3.internal.http2.Http2.FLAG_COMPRESSED;
-import static okhttp3.internal.http2.Http2.FLAG_END_HEADERS;
-import static okhttp3.internal.http2.Http2.FLAG_END_STREAM;
-import static okhttp3.internal.http2.Http2.FLAG_NONE;
-import static okhttp3.internal.http2.Http2.FLAG_PADDED;
-import static okhttp3.internal.http2.Http2.FLAG_PRIORITY;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class Http2Test {
-  final Buffer frame = new Buffer();
-  final Http2Reader reader = new Http2Reader(frame, false);
-  final int expectedStreamId = 15;
-
-  @Test public void unknownFrameTypeSkipped() throws IOException {
-    writeMedium(frame, 4); // has a 4-byte field
-    frame.writeByte(99); // type 99
-    frame.writeByte(Http2.FLAG_NONE);
-    frame.writeInt(expectedStreamId);
-    frame.writeInt(111111111); // custom data
-
-    reader.nextFrame(false, new BaseTestHandler()); // Should not callback.
-  }
-
-  @Test public void onlyOneLiteralHeadersFrame() throws IOException {
-    final List<Header> sentHeaders = headerEntries("name", "value");
-
-    Buffer headerBytes = literalHeaders(sentHeaders);
-    writeMedium(frame, (int) headerBytes.size());
-    frame.writeByte(Http2.TYPE_HEADERS);
-    frame.writeByte(FLAG_END_HEADERS | FLAG_END_STREAM);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeAll(headerBytes);
-
-    // Check writer sends the same bytes.
-    assertThat(sendHeaderFrames(true, sentHeaders)).isEqualTo(frame);
-
-    reader.nextFrame(false, new BaseTestHandler() {
-      @Override public void headers(boolean inFinished, int streamId,
-          int associatedStreamId, List<Header> headerBlock) {
-        assertThat(inFinished).isTrue();
-        assertThat(streamId).isEqualTo(expectedStreamId);
-        assertThat(associatedStreamId).isEqualTo(-1);
-        assertThat(headerBlock).isEqualTo(sentHeaders);
-      }
-    });
-  }
-
-  @Test public void headersWithPriority() throws IOException {
-    final List<Header> sentHeaders = headerEntries("name", "value");
-
-    Buffer headerBytes = literalHeaders(sentHeaders);
-    writeMedium(frame, (int) (headerBytes.size() + 5));
-    frame.writeByte(Http2.TYPE_HEADERS);
-    frame.writeByte(FLAG_END_HEADERS | FLAG_PRIORITY);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeInt(0); // Independent stream.
-    frame.writeByte(255); // Heaviest weight, zero-indexed.
-    frame.writeAll(headerBytes);
-
-    reader.nextFrame(false, new BaseTestHandler() {
-      @Override public void priority(int streamId, int streamDependency, int weight,
-          boolean exclusive) {
-        assertThat(streamDependency).isEqualTo(0);
-        assertThat(weight).isEqualTo(256);
-        assertThat(exclusive).isFalse();
-      }
-
-      @Override public void headers(boolean inFinished, int streamId,
-          int associatedStreamId, List<Header> nameValueBlock) {
-        assertThat(inFinished).isFalse();
-        assertThat(streamId).isEqualTo(expectedStreamId);
-        assertThat(associatedStreamId).isEqualTo(-1);
-        assertThat(nameValueBlock).isEqualTo(sentHeaders);
-      }
-    });
-  }
-
-  /** Headers are compressed, then framed. */
-  @Test public void headersFrameThenContinuation() throws IOException {
-    final List<Header> sentHeaders = largeHeaders();
-
-    Buffer headerBlock = literalHeaders(sentHeaders);
-
-    // Write the first headers frame.
-    writeMedium(frame, Http2.INITIAL_MAX_FRAME_SIZE);
-    frame.writeByte(Http2.TYPE_HEADERS);
-    frame.writeByte(Http2.FLAG_NONE);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.write(headerBlock, Http2.INITIAL_MAX_FRAME_SIZE);
-
-    // Write the continuation frame, specifying no more frames are expected.
-    writeMedium(frame, (int) headerBlock.size());
-    frame.writeByte(Http2.TYPE_CONTINUATION);
-    frame.writeByte(FLAG_END_HEADERS);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeAll(headerBlock);
-
-    // Check writer sends the same bytes.
-    assertThat(sendHeaderFrames(false, sentHeaders)).isEqualTo(frame);
-
-    // Reading the above frames should result in a concatenated headerBlock.
-    reader.nextFrame(false, new BaseTestHandler() {
-      @Override public void headers(boolean inFinished, int streamId,
-          int associatedStreamId, List<Header> headerBlock) {
-        assertThat(inFinished).isFalse();
-        assertThat(streamId).isEqualTo(expectedStreamId);
-        assertThat(associatedStreamId).isEqualTo(-1);
-        assertThat(headerBlock).isEqualTo(sentHeaders);
-      }
-    });
-  }
-
-  @Test public void pushPromise() throws IOException {
-    final int expectedPromisedStreamId = 11;
-
-    final List<Header> pushPromise = Arrays.asList(
-        new Header(Header.TARGET_METHOD, "GET"),
-        new Header(Header.TARGET_SCHEME, "https"),
-        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
-        new Header(Header.TARGET_PATH, "/")
-    );
-
-    // Write the push promise frame, specifying the associated stream ID.
-    Buffer headerBytes = literalHeaders(pushPromise);
-    writeMedium(frame, (int) (headerBytes.size() + 4));
-    frame.writeByte(Http2.TYPE_PUSH_PROMISE);
-    frame.writeByte(Http2.FLAG_END_PUSH_PROMISE);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeInt(expectedPromisedStreamId & 0x7fffffff);
-    frame.writeAll(headerBytes);
-
-    assertThat(sendPushPromiseFrames(expectedPromisedStreamId, pushPromise)).isEqualTo(
-        frame);
-
-    reader.nextFrame(false, new BaseTestHandler() {
-      @Override
-      public void pushPromise(int streamId, int promisedStreamId, List<Header> headerBlock) {
-        assertThat(streamId).isEqualTo(expectedStreamId);
-        assertThat(promisedStreamId).isEqualTo(expectedPromisedStreamId);
-        assertThat(headerBlock).isEqualTo(pushPromise);
-      }
-    });
-  }
-
-  /** Headers are compressed, then framed. */
-  @Test public void pushPromiseThenContinuation() throws IOException {
-    final int expectedPromisedStreamId = 11;
-    final List<Header> pushPromise = largeHeaders();
-
-    // Decoding the first header will cross frame boundaries.
-    Buffer headerBlock = literalHeaders(pushPromise);
-
-    // Write the first headers frame.
-    writeMedium(frame, Http2.INITIAL_MAX_FRAME_SIZE);
-    frame.writeByte(Http2.TYPE_PUSH_PROMISE);
-    frame.writeByte(Http2.FLAG_NONE);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeInt(expectedPromisedStreamId & 0x7fffffff);
-    frame.write(headerBlock, Http2.INITIAL_MAX_FRAME_SIZE - 4);
-
-    // Write the continuation frame, specifying no more frames are expected.
-    writeMedium(frame, (int) headerBlock.size());
-    frame.writeByte(Http2.TYPE_CONTINUATION);
-    frame.writeByte(FLAG_END_HEADERS);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeAll(headerBlock);
-
-    assertThat(sendPushPromiseFrames(expectedPromisedStreamId, pushPromise)).isEqualTo(
-        frame);
-
-    // Reading the above frames should result in a concatenated headerBlock.
-    reader.nextFrame(false, new BaseTestHandler() {
-      @Override
-      public void pushPromise(int streamId, int promisedStreamId, List<Header> headerBlock) {
-        assertThat(streamId).isEqualTo(expectedStreamId);
-        assertThat(promisedStreamId).isEqualTo(expectedPromisedStreamId);
-        assertThat(headerBlock).isEqualTo(pushPromise);
-      }
-    });
-  }
-
-  @Test public void readRstStreamFrame() throws IOException {
-    writeMedium(frame, 4);
-    frame.writeByte(Http2.TYPE_RST_STREAM);
-    frame.writeByte(Http2.FLAG_NONE);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeInt(ErrorCode.PROTOCOL_ERROR.httpCode);
-
-    reader.nextFrame(false, new BaseTestHandler() {
-      @Override public void rstStream(int streamId, ErrorCode errorCode) {
-        assertThat(streamId).isEqualTo(expectedStreamId);
-        assertThat(errorCode).isEqualTo(ErrorCode.PROTOCOL_ERROR);
-      }
-    });
-  }
-
-  @Test public void readSettingsFrame() throws IOException {
-    final int reducedTableSizeBytes = 16;
-
-    writeMedium(frame, 12); // 2 settings * 6 bytes (2 for the code and 4 for the value).
-    frame.writeByte(Http2.TYPE_SETTINGS);
-    frame.writeByte(Http2.FLAG_NONE);
-    frame.writeInt(0); // Settings are always on the connection stream 0.
-    frame.writeShort(1); // SETTINGS_HEADER_TABLE_SIZE
-    frame.writeInt(reducedTableSizeBytes);
-    frame.writeShort(2); // SETTINGS_ENABLE_PUSH
-    frame.writeInt(0);
-
-    reader.nextFrame(false, new BaseTestHandler() {
-      @Override public void settings(boolean clearPrevious, Settings settings) {
-        // No clearPrevious in HTTP/2.
-        assertThat(clearPrevious).isFalse();
-        assertThat(settings.getHeaderTableSize()).isEqualTo(reducedTableSizeBytes);
-        assertThat(settings.getEnablePush(true)).isFalse();
-      }
-    });
-  }
-
-  @Test public void readSettingsFrameInvalidPushValue() throws IOException {
-    writeMedium(frame, 6); // 2 for the code and 4 for the value
-    frame.writeByte(Http2.TYPE_SETTINGS);
-    frame.writeByte(Http2.FLAG_NONE);
-    frame.writeInt(0); // Settings are always on the connection stream 0.
-    frame.writeShort(2);
-    frame.writeInt(2);
-
-    try {
-      reader.nextFrame(false, new BaseTestHandler());
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo("PROTOCOL_ERROR SETTINGS_ENABLE_PUSH != 0 or 1");
-    }
-  }
-
-  @Test public void readSettingsFrameUnknownSettingId() throws IOException {
-    writeMedium(frame, 6); // 2 for the code and 4 for the value
-    frame.writeByte(Http2.TYPE_SETTINGS);
-    frame.writeByte(Http2.FLAG_NONE);
-    frame.writeInt(0); // Settings are always on the connection stream 0.
-    frame.writeShort(7); // old number for SETTINGS_INITIAL_WINDOW_SIZE
-    frame.writeInt(1);
-
-    final AtomicInteger settingValue = new AtomicInteger();
-    reader.nextFrame(false, new BaseTestHandler() {
-      @Override public void settings(boolean clearPrevious, Settings settings) {
-        settingValue.set(settings.get(7));
-      }
-    });
-    assertThat(1).isEqualTo(settingValue.intValue());
-  }
-
-  @Test public void readSettingsFrameExperimentalId() throws IOException {
-    writeMedium(frame, 6); // 2 for the code and 4 for the value
-    frame.writeByte(Http2.TYPE_SETTINGS);
-    frame.writeByte(Http2.FLAG_NONE);
-    frame.writeInt(0); // Settings are always on the connection stream 0.
-    frame.write(ByteString.decodeHex("f000")); // Id reserved for experimental use.
-    frame.writeInt(1);
-
-    reader.nextFrame(false, new BaseTestHandler() {
-      @Override public void settings(boolean clearPrevious, Settings settings) {
-        // no-op
-      }
-    });
-  }
-
-  @Test public void readSettingsFrameNegativeWindowSize() throws IOException {
-    writeMedium(frame, 6); // 2 for the code and 4 for the value
-    frame.writeByte(Http2.TYPE_SETTINGS);
-    frame.writeByte(Http2.FLAG_NONE);
-    frame.writeInt(0); // Settings are always on the connection stream 0.
-    frame.writeShort(4); // SETTINGS_INITIAL_WINDOW_SIZE
-    frame.writeInt(Integer.MIN_VALUE);
-
-    try {
-      reader.nextFrame(false, new BaseTestHandler());
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo(
-          "PROTOCOL_ERROR SETTINGS_INITIAL_WINDOW_SIZE > 2^31 - 1");
-    }
-  }
-
-  @Test public void readSettingsFrameNegativeFrameLength() throws IOException {
-    writeMedium(frame, 6); // 2 for the code and 4 for the value
-    frame.writeByte(Http2.TYPE_SETTINGS);
-    frame.writeByte(Http2.FLAG_NONE);
-    frame.writeInt(0); // Settings are always on the connection stream 0.
-    frame.writeShort(5); // SETTINGS_MAX_FRAME_SIZE
-    frame.writeInt(Integer.MIN_VALUE);
-
-    try {
-      reader.nextFrame(false, new BaseTestHandler());
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo(
-          "PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: -2147483648");
-    }
-  }
-
-  @Test public void readSettingsFrameTooShortFrameLength() throws IOException {
-    writeMedium(frame, 6); // 2 for the code and 4 for the value
-    frame.writeByte(Http2.TYPE_SETTINGS);
-    frame.writeByte(Http2.FLAG_NONE);
-    frame.writeInt(0); // Settings are always on the connection stream 0.
-    frame.writeShort(5); // SETTINGS_MAX_FRAME_SIZE
-    frame.writeInt((int) Math.pow(2, 14) - 1);
-
-    try {
-      reader.nextFrame(false, new BaseTestHandler());
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: 16383");
-    }
-  }
-
-  @Test public void readSettingsFrameTooLongFrameLength() throws IOException {
-    writeMedium(frame, 6); // 2 for the code and 4 for the value
-    frame.writeByte(Http2.TYPE_SETTINGS);
-    frame.writeByte(Http2.FLAG_NONE);
-    frame.writeInt(0); // Settings are always on the connection stream 0.
-    frame.writeShort(5); // SETTINGS_MAX_FRAME_SIZE
-    frame.writeInt((int) Math.pow(2, 24));
-
-    try {
-      reader.nextFrame(false, new BaseTestHandler());
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo(
-          "PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: 16777216");
-    }
-  }
-
-  @Test public void pingRoundTrip() throws IOException {
-    final int expectedPayload1 = 7;
-    final int expectedPayload2 = 8;
-
-    writeMedium(frame, 8); // length
-    frame.writeByte(Http2.TYPE_PING);
-    frame.writeByte(Http2.FLAG_ACK);
-    frame.writeInt(0); // connection-level
-    frame.writeInt(expectedPayload1);
-    frame.writeInt(expectedPayload2);
-
-    // Check writer sends the same bytes.
-    assertThat(sendPingFrame(true, expectedPayload1, expectedPayload2)).isEqualTo(frame);
-
-    reader.nextFrame(false, new BaseTestHandler() {
-      @Override public void ping(boolean ack, int payload1, int payload2) {
-        assertThat(ack).isTrue();
-        assertThat(payload1).isEqualTo(expectedPayload1);
-        assertThat(payload2).isEqualTo(expectedPayload2);
-      }
-    });
-  }
-
-  @Test public void maxLengthDataFrame() throws IOException {
-    final byte[] expectedData = new byte[Http2.INITIAL_MAX_FRAME_SIZE];
-    Arrays.fill(expectedData, (byte) 2);
-
-    writeMedium(frame, expectedData.length);
-    frame.writeByte(Http2.TYPE_DATA);
-    frame.writeByte(Http2.FLAG_NONE);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.write(expectedData);
-
-    // Check writer sends the same bytes.
-    assertThat(sendDataFrame(new Buffer().write(expectedData))).isEqualTo(frame);
-
-    reader.nextFrame(false, new BaseTestHandler() {
-      @Override public void data(boolean inFinished, int streamId, BufferedSource source,
-          int length) throws IOException {
-        assertThat(inFinished).isFalse();
-        assertThat(streamId).isEqualTo(expectedStreamId);
-        assertThat(length).isEqualTo(Http2.INITIAL_MAX_FRAME_SIZE);
-        ByteString data = source.readByteString(length);
-        for (byte b : data.toByteArray()) {
-          assertThat(b).isEqualTo((byte) 2);
-        }
-      }
-    });
-  }
-
-  @Test public void dataFrameNotAssociateWithStream() throws IOException {
-    byte[] payload = new byte[] {0x01, 0x02};
-
-    writeMedium(frame, payload.length);
-    frame.writeByte(Http2.TYPE_DATA);
-    frame.writeByte(Http2.FLAG_NONE);
-    frame.writeInt(0);
-    frame.write(payload);
-
-    try {
-      reader.nextFrame(false, new BaseTestHandler());
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo("PROTOCOL_ERROR: TYPE_DATA streamId == 0");
-    }
-  }
-
-  /** We do not send SETTINGS_COMPRESS_DATA = 1, nor want to. Let's make sure we error. */
-  @Test public void compressedDataFrameWhenSettingDisabled() throws IOException {
-    byte[] expectedData = new byte[Http2.INITIAL_MAX_FRAME_SIZE];
-    Arrays.fill(expectedData, (byte) 2);
-    Buffer zipped = gzip(expectedData);
-    int zippedSize = (int) zipped.size();
-
-    writeMedium(frame, zippedSize);
-    frame.writeByte(Http2.TYPE_DATA);
-    frame.writeByte(FLAG_COMPRESSED);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    zipped.readAll(frame);
-
-    try {
-      reader.nextFrame(false, new BaseTestHandler());
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo(
-          "PROTOCOL_ERROR: FLAG_COMPRESSED without SETTINGS_COMPRESS_DATA");
-    }
-  }
-
-  @Test public void readPaddedDataFrame() throws IOException {
-    int dataLength = 1123;
-    byte[] expectedData = new byte[dataLength];
-    Arrays.fill(expectedData, (byte) 2);
-
-    int paddingLength = 254;
-    byte[] padding = new byte[paddingLength];
-    Arrays.fill(padding, (byte) 0);
-
-    writeMedium(frame, dataLength + paddingLength + 1);
-    frame.writeByte(Http2.TYPE_DATA);
-    frame.writeByte(FLAG_PADDED);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeByte(paddingLength);
-    frame.write(expectedData);
-    frame.write(padding);
-
-    reader.nextFrame(false, assertData());
-    // Padding was skipped.
-    assertThat(frame.exhausted()).isTrue();
-  }
-
-  @Test public void readPaddedDataFrameZeroPadding() throws IOException {
-    int dataLength = 1123;
-    byte[] expectedData = new byte[dataLength];
-    Arrays.fill(expectedData, (byte) 2);
-
-    writeMedium(frame, dataLength + 1);
-    frame.writeByte(Http2.TYPE_DATA);
-    frame.writeByte(FLAG_PADDED);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeByte(0);
-    frame.write(expectedData);
-
-    reader.nextFrame(false, assertData());
-  }
-
-  @Test public void readPaddedHeadersFrame() throws IOException {
-    int paddingLength = 254;
-    byte[] padding = new byte[paddingLength];
-    Arrays.fill(padding, (byte) 0);
-
-    Buffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
-    writeMedium(frame, (int) headerBlock.size() + paddingLength + 1);
-    frame.writeByte(Http2.TYPE_HEADERS);
-    frame.writeByte(FLAG_END_HEADERS | FLAG_PADDED);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeByte(paddingLength);
-    frame.writeAll(headerBlock);
-    frame.write(padding);
-
-    reader.nextFrame(false, assertHeaderBlock());
-    // Padding was skipped.
-    assertThat(frame.exhausted()).isTrue();
-  }
-
-  @Test public void readPaddedHeadersFrameZeroPadding() throws IOException {
-    Buffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
-    writeMedium(frame, (int) headerBlock.size() + 1);
-    frame.writeByte(Http2.TYPE_HEADERS);
-    frame.writeByte(FLAG_END_HEADERS | FLAG_PADDED);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeByte(0);
-    frame.writeAll(headerBlock);
-
-    reader.nextFrame(false, assertHeaderBlock());
-  }
-
-  /** Headers are compressed, then framed. */
-  @Test public void readPaddedHeadersFrameThenContinuation() throws IOException {
-    int paddingLength = 254;
-    byte[] padding = new byte[paddingLength];
-    Arrays.fill(padding, (byte) 0);
-
-    // Decoding the first header will cross frame boundaries.
-    Buffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
-
-    // Write the first headers frame.
-    writeMedium(frame, (int) (headerBlock.size() / 2) + paddingLength + 1);
-    frame.writeByte(Http2.TYPE_HEADERS);
-    frame.writeByte(FLAG_PADDED);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeByte(paddingLength);
-    frame.write(headerBlock, headerBlock.size() / 2);
-    frame.write(padding);
-
-    // Write the continuation frame, specifying no more frames are expected.
-    writeMedium(frame, (int) headerBlock.size());
-    frame.writeByte(Http2.TYPE_CONTINUATION);
-    frame.writeByte(FLAG_END_HEADERS);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeAll(headerBlock);
-
-    reader.nextFrame(false, assertHeaderBlock());
-    assertThat(frame.exhausted()).isTrue();
-  }
-
-  @Test public void tooLargeDataFrame() throws IOException {
-    try {
-      sendDataFrame(new Buffer().write(new byte[0x1000000]));
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).isEqualTo("FRAME_SIZE_ERROR length > 16384: 16777216");
-    }
-  }
-
-  @Test public void windowUpdateRoundTrip() throws IOException {
-    final long expectedWindowSizeIncrement = 0x7fffffff;
-
-    writeMedium(frame, 4); // length
-    frame.writeByte(Http2.TYPE_WINDOW_UPDATE);
-    frame.writeByte(Http2.FLAG_NONE);
-    frame.writeInt(expectedStreamId);
-    frame.writeInt((int) expectedWindowSizeIncrement);
-
-    // Check writer sends the same bytes.
-    assertThat(windowUpdate(expectedWindowSizeIncrement)).isEqualTo(frame);
-
-    reader.nextFrame(false, new BaseTestHandler() {
-      @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
-        assertThat(streamId).isEqualTo(expectedStreamId);
-        assertThat(windowSizeIncrement).isEqualTo(expectedWindowSizeIncrement);
-      }
-    });
-  }
-
-  @Test public void badWindowSizeIncrement() throws IOException {
-    try {
-      windowUpdate(0);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).isEqualTo(
-          "windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: 0");
-    }
-    try {
-      windowUpdate(0x80000000L);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).isEqualTo(
-          "windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: 2147483648");
-    }
-  }
-
-  @Test public void goAwayWithoutDebugDataRoundTrip() throws IOException {
-    final ErrorCode expectedError = ErrorCode.PROTOCOL_ERROR;
-
-    writeMedium(frame, 8); // Without debug data there's only 2 32-bit fields.
-    frame.writeByte(Http2.TYPE_GOAWAY);
-    frame.writeByte(Http2.FLAG_NONE);
-    frame.writeInt(0); // connection-scope
-    frame.writeInt(expectedStreamId); // last good stream.
-    frame.writeInt(expectedError.httpCode);
-
-    // Check writer sends the same bytes.
-    assertThat(sendGoAway(expectedStreamId, expectedError, Util.EMPTY_BYTE_ARRAY)).isEqualTo(
-        frame);
-
-    reader.nextFrame(false, new BaseTestHandler() {
-      @Override public void goAway(
-          int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
-        assertThat(lastGoodStreamId).isEqualTo(expectedStreamId);
-        assertThat(errorCode).isEqualTo(expectedError);
-        assertThat(debugData.size()).isEqualTo(0);
-      }
-    });
-  }
-
-  @Test public void goAwayWithDebugDataRoundTrip() throws IOException {
-    final ErrorCode expectedError = ErrorCode.PROTOCOL_ERROR;
-    final ByteString expectedData = ByteString.encodeUtf8("abcdefgh");
-
-    // Compose the expected GOAWAY frame without debug data.
-    writeMedium(frame, 8 + expectedData.size());
-    frame.writeByte(Http2.TYPE_GOAWAY);
-    frame.writeByte(Http2.FLAG_NONE);
-    frame.writeInt(0); // connection-scope
-    frame.writeInt(0); // never read any stream!
-    frame.writeInt(expectedError.httpCode);
-    frame.write(expectedData.toByteArray());
-
-    // Check writer sends the same bytes.
-    assertThat(sendGoAway(0, expectedError, expectedData.toByteArray())).isEqualTo(frame);
-
-    reader.nextFrame(false, new BaseTestHandler() {
-      @Override public void goAway(
-          int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
-        assertThat(lastGoodStreamId).isEqualTo(0);
-        assertThat(errorCode).isEqualTo(expectedError);
-        assertThat(debugData).isEqualTo(expectedData);
-      }
-    });
-  }
-
-  @Test public void frameSizeError() throws IOException {
-    Http2Writer writer = new Http2Writer(new Buffer(), true);
-
-    try {
-      writer.frameHeader(0, 16777216, Http2.TYPE_DATA, FLAG_NONE);
-      fail();
-    } catch (IllegalArgumentException e) {
-      // TODO: real max is based on settings between 16384 and 16777215
-      assertThat(e.getMessage()).isEqualTo("FRAME_SIZE_ERROR length > 16384: 16777216");
-    }
-  }
-
-  @Test public void ackSettingsAppliesMaxFrameSize() throws IOException {
-    int newMaxFrameSize = 16777215;
-
-    Http2Writer writer = new Http2Writer(new Buffer(), true);
-
-    writer.applyAndAckSettings(new Settings().set(Settings.MAX_FRAME_SIZE, newMaxFrameSize));
-
-    assertThat(writer.maxDataLength()).isEqualTo(newMaxFrameSize);
-    writer.frameHeader(0, newMaxFrameSize, Http2.TYPE_DATA, FLAG_NONE);
-  }
-
-  @Test public void streamIdHasReservedBit() throws IOException {
-    Http2Writer writer = new Http2Writer(new Buffer(), true);
-
-    try {
-      int streamId = 3;
-      streamId |= 1L << 31; // set reserved bit
-      writer.frameHeader(streamId, Http2.INITIAL_MAX_FRAME_SIZE, Http2.TYPE_DATA, FLAG_NONE);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).isEqualTo("reserved bit set: -2147483645");
-    }
-  }
-
-  private Buffer literalHeaders(List<Header> sentHeaders) throws IOException {
-    Buffer out = new Buffer();
-    new Hpack.Writer(out).writeHeaders(sentHeaders);
-    return out;
-  }
-
-  private Buffer sendHeaderFrames(boolean outFinished, List<Header> headers) throws IOException {
-    Buffer out = new Buffer();
-    new Http2Writer(out, true).headers(outFinished, expectedStreamId, headers);
-    return out;
-  }
-
-  private Buffer sendPushPromiseFrames(int streamId, List<Header> headers) throws IOException {
-    Buffer out = new Buffer();
-    new Http2Writer(out, true).pushPromise(expectedStreamId, streamId, headers);
-    return out;
-  }
-
-  private Buffer sendPingFrame(boolean ack, int payload1, int payload2) throws IOException {
-    Buffer out = new Buffer();
-    new Http2Writer(out, true).ping(ack, payload1, payload2);
-    return out;
-  }
-
-  private Buffer sendGoAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
-      throws IOException {
-    Buffer out = new Buffer();
-    new Http2Writer(out, true).goAway(lastGoodStreamId, errorCode, debugData);
-    return out;
-  }
-
-  private Buffer sendDataFrame(Buffer data) throws IOException {
-    Buffer out = new Buffer();
-    new Http2Writer(out, true).dataFrame(expectedStreamId, FLAG_NONE, data,
-        (int) data.size());
-    return out;
-  }
-
-  private Buffer windowUpdate(long windowSizeIncrement) throws IOException {
-    Buffer out = new Buffer();
-    new Http2Writer(out, true).windowUpdate(expectedStreamId, windowSizeIncrement);
-    return out;
-  }
-
-  private Http2Reader.Handler assertHeaderBlock() {
-    return new BaseTestHandler() {
-      @Override public void headers(boolean inFinished, int streamId,
-          int associatedStreamId, List<Header> headerBlock) {
-        assertThat(inFinished).isFalse();
-        assertThat(streamId).isEqualTo(expectedStreamId);
-        assertThat(associatedStreamId).isEqualTo(-1);
-        assertThat(headerBlock).isEqualTo(headerEntries("foo", "barrr", "baz", "qux"));
-      }
-    };
-  }
-
-  private Http2Reader.Handler assertData() {
-    return new BaseTestHandler() {
-      @Override public void data(boolean inFinished, int streamId, BufferedSource source,
-          int length) throws IOException {
-        assertThat(inFinished).isFalse();
-        assertThat(streamId).isEqualTo(expectedStreamId);
-        assertThat(length).isEqualTo(1123);
-        ByteString data = source.readByteString(length);
-        for (byte b : data.toByteArray()) {
-          assertThat(b).isEqualTo((byte) 2);
-        }
-      }
-    };
-  }
-
-  private static Buffer gzip(byte[] data) throws IOException {
-    Buffer buffer = new Buffer();
-    Okio.buffer(new GzipSink(buffer)).write(data).close();
-    return buffer;
-  }
-
-  /** Create a sufficiently large header set to overflow INITIAL_MAX_FRAME_SIZE bytes. */
-  private static List<Header> largeHeaders() {
-    String[] nameValues = new String[32];
-    char[] chars = new char[512];
-    for (int i = 0; i < nameValues.length; ) {
-      Arrays.fill(chars, (char) i);
-      nameValues[i++] = nameValues[i++] = String.valueOf(chars);
-    }
-    return headerEntries(nameValues);
-  }
-
-  private static void writeMedium(BufferedSink sink, int i) throws IOException {
-    sink.writeByte((i >>> 16) & 0xff);
-    sink.writeByte((i >>> 8) & 0xff);
-    sink.writeByte(i & 0xff);
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
deleted file mode 100644
index 40eb1ef4f3..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
+++ /dev/null
@@ -1,1540 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.Authenticator;
-import java.net.HttpURLConnection;
-import java.net.SocketTimeoutException;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.List;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.SynchronousQueue;
-import java.util.concurrent.TimeUnit;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import okhttp3.Cache;
-import okhttp3.Call;
-import okhttp3.Callback;
-import okhttp3.Connection;
-import okhttp3.Cookie;
-import okhttp3.Credentials;
-import okhttp3.EventListener;
-import okhttp3.Headers;
-import okhttp3.Interceptor;
-import okhttp3.MediaType;
-import okhttp3.OkHttpClient;
-import okhttp3.OkHttpClientTestRule;
-import okhttp3.Protocol;
-import okhttp3.RecordingCookieJar;
-import okhttp3.RecordingHostnameVerifier;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.TestLogHandler;
-import okhttp3.TestUtil;
-import okhttp3.internal.DoubleInetAddressDns;
-import okhttp3.internal.RecordingOkAuthenticator;
-import okhttp3.internal.Util;
-import okhttp3.internal.connection.RealConnection;
-import okhttp3.mockwebserver.Dispatcher;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.PushPromise;
-import okhttp3.mockwebserver.QueueDispatcher;
-import okhttp3.mockwebserver.RecordedRequest;
-import okhttp3.mockwebserver.SocketPolicy;
-import okhttp3.tls.HandshakeCertificates;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.GzipSink;
-import okio.Okio;
-import org.assertj.core.api.Assertions;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
-import org.junit.rules.Timeout;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameters;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static java.util.concurrent.TimeUnit.MILLISECONDS;
-import static java.util.concurrent.TimeUnit.SECONDS;
-import static okhttp3.tls.internal.TlsUtil.localhost;
-import static org.assertj.core.data.Offset.offset;
-import static org.hamcrest.CoreMatchers.containsString;
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertThat;
-import static org.junit.Assert.fail;
-import static org.junit.Assume.assumeTrue;
-
-/** Test how HTTP/2 interacts with HTTP features. */
-@RunWith(Parameterized.class)
-public final class HttpOverHttp2Test {
-  private static final Logger http2Logger = Logger.getLogger(Http2.class.getName());
-  private static final HandshakeCertificates handshakeCertificates = localhost();
-
-  @Parameters(name = "{0}")
-  public static Collection<Protocol> data() {
-    return Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.HTTP_2);
-  }
-
-  @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
-  @Rule public final Timeout timeout = new Timeout(5, SECONDS);
-
-  private OkHttpClient client;
-  private Cache cache;
-  private TestLogHandler http2Handler = new TestLogHandler();
-  private Level previousLevel;
-  private String scheme;
-  private Protocol protocol;
-
-  public HttpOverHttp2Test(Protocol protocol) {
-    this.client = protocol == Protocol.HTTP_2 ? buildHttp2Client() : buildH2PriorKnowledgeClient();
-    this.scheme = protocol == Protocol.HTTP_2 ? "https" : "http";
-    this.protocol = protocol;
-  }
-
-  private OkHttpClient buildH2PriorKnowledgeClient() {
-    return clientTestRule.client.newBuilder()
-        .protocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE))
-        .build();
-  }
-
-  private OkHttpClient buildHttp2Client() {
-    return clientTestRule.client.newBuilder()
-        .protocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1))
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-  }
-
-  @Before public void setUp() {
-    if (protocol == Protocol.H2_PRIOR_KNOWLEDGE) {
-      server.setProtocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE));
-    } else {
-      server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    }
-
-    cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
-
-    http2Logger.addHandler(http2Handler);
-    previousLevel = http2Logger.getLevel();
-    http2Logger.setLevel(Level.FINE);
-  }
-
-  @After public void tearDown() {
-    Authenticator.setDefault(null);
-    http2Logger.removeHandler(http2Handler);
-    http2Logger.setLevel(previousLevel);
-  }
-
-  @Test public void get() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("ABCDE")
-        .setStatus("HTTP/1.1 200 Sweet"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/foo"))
-        .build());
-    Response response = call.execute();
-
-    Assertions.assertThat(response.body().string()).isEqualTo("ABCDE");
-    Assertions.assertThat(response.code()).isEqualTo(200);
-    Assertions.assertThat(response.message()).isEqualTo("");
-    Assertions.assertThat(response.protocol()).isEqualTo(protocol);
-
-    RecordedRequest request = server.takeRequest();
-    Assertions.assertThat(request.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
-    Assertions.assertThat(request.getHeader(":scheme")).isEqualTo(scheme);
-    Assertions.assertThat(request.getHeader(":authority")).isEqualTo(
-        (server.getHostName() + ":" + server.getPort()));
-  }
-
-  @Test public void emptyResponse() throws IOException {
-    server.enqueue(new MockResponse());
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/foo"))
-        .build());
-    Response response = call.execute();
-
-    Assertions.assertThat(response.body().byteStream().read()).isEqualTo(-1);
-    response.body().close();
-  }
-
-  @Test public void noDefaultContentLengthOnStreamingPost() throws Exception {
-    byte[] postBytes = "FGHIJ".getBytes(UTF_8);
-
-    server.enqueue(new MockResponse().setBody("ABCDE"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/foo"))
-        .post(new RequestBody() {
-          @Override public MediaType contentType() {
-            return MediaType.get("text/plain; charset=utf-8");
-          }
-
-          @Override public void writeTo(BufferedSink sink) throws IOException {
-            sink.write(postBytes);
-          }
-        })
-        .build());
-
-    Response response = call.execute();
-    Assertions.assertThat(response.body().string()).isEqualTo("ABCDE");
-
-    RecordedRequest request = server.takeRequest();
-    Assertions.assertThat(request.getRequestLine()).isEqualTo("POST /foo HTTP/1.1");
-    assertArrayEquals(postBytes, request.getBody().readByteArray());
-    Assertions.assertThat(request.getHeader("Content-Length")).isNull();
-  }
-
-  @Test public void userSuppliedContentLengthHeader() throws Exception {
-    byte[] postBytes = "FGHIJ".getBytes(UTF_8);
-
-    server.enqueue(new MockResponse().setBody("ABCDE"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/foo"))
-        .post(new RequestBody() {
-          @Override public MediaType contentType() {
-            return MediaType.get("text/plain; charset=utf-8");
-          }
-
-          @Override public long contentLength() {
-            return postBytes.length;
-          }
-
-          @Override public void writeTo(BufferedSink sink) throws IOException {
-            sink.write(postBytes);
-          }
-        })
-        .build());
-
-    Response response = call.execute();
-    Assertions.assertThat(response.body().string()).isEqualTo("ABCDE");
-
-    RecordedRequest request = server.takeRequest();
-    Assertions.assertThat(request.getRequestLine()).isEqualTo("POST /foo HTTP/1.1");
-    assertArrayEquals(postBytes, request.getBody().readByteArray());
-    Assertions.assertThat(Integer.parseInt(request.getHeader("Content-Length"))).isEqualTo(
-        (long) postBytes.length);
-  }
-
-  @Test public void closeAfterFlush() throws Exception {
-    byte[] postBytes = "FGHIJ".getBytes(UTF_8);
-
-    server.enqueue(new MockResponse().setBody("ABCDE"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/foo"))
-        .post(new RequestBody() {
-          @Override public MediaType contentType() {
-            return MediaType.get("text/plain; charset=utf-8");
-          }
-
-          @Override public long contentLength() {
-            return postBytes.length;
-          }
-
-          @Override public void writeTo(BufferedSink sink) throws IOException {
-            sink.write(postBytes);  // push bytes into the stream's buffer
-            sink.flush(); // Http2Connection.writeData subject to write window
-            sink.close(); // Http2Connection.writeData empty frame
-          }
-        })
-        .build());
-
-    Response response = call.execute();
-    Assertions.assertThat(response.body().string()).isEqualTo("ABCDE");
-
-    RecordedRequest request = server.takeRequest();
-    Assertions.assertThat(request.getRequestLine()).isEqualTo("POST /foo HTTP/1.1");
-    assertArrayEquals(postBytes, request.getBody().readByteArray());
-    Assertions.assertThat(Integer.parseInt(request.getHeader("Content-Length"))).isEqualTo(
-        (long) postBytes.length);
-  }
-
-  @Test public void connectionReuse() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABCDEF"));
-    server.enqueue(new MockResponse().setBody("GHIJKL"));
-
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/r1"))
-        .build());
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/r1"))
-        .build());
-    Response response1 = call1.execute();
-    Response response2 = call2.execute();
-
-    Assertions.assertThat(response1.body().source().readUtf8(3)).isEqualTo("ABC");
-    Assertions.assertThat(response2.body().source().readUtf8(3)).isEqualTo("GHI");
-    Assertions.assertThat(response1.body().source().readUtf8(3)).isEqualTo("DEF");
-    Assertions.assertThat(response2.body().source().readUtf8(3)).isEqualTo("JKL");
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-
-    response1.close();
-    response2.close();
-  }
-
-  @Test public void connectionWindowUpdateAfterCanceling() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody(new Buffer().write(new byte[Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE + 1])));
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response1 = call1.execute();
-
-    waitForDataFrames(Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE);
-
-    // Cancel the call and discard what we've buffered for the response body. This should free up
-    // the connection flow-control window so new requests can proceed.
-    call1.cancel();
-    Assertions.assertThat(Util.discard(response1.body().source(), 1, TimeUnit.SECONDS)).overridingErrorMessage(
-        "Call should not have completed successfully.").isFalse();
-
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response2 = call2.execute();
-    Assertions.assertThat(response2.body().string()).isEqualTo("abc");
-  }
-
-  /** Wait for the client to receive {@code dataLength} DATA frames. */
-  private void waitForDataFrames(int dataLength) throws Exception {
-    int expectedFrameCount = dataLength / 16384;
-    int dataFrameCount = 0;
-    while (dataFrameCount < expectedFrameCount) {
-      String log = http2Handler.take();
-      if (log.equals("FINE: << 0x00000003 16384 DATA          ")) {
-        dataFrameCount++;
-      }
-    }
-  }
-
-  @Test public void connectionWindowUpdateOnClose() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody(new Buffer().write(new byte[Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE + 1])));
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response1 = call1.execute();
-
-    waitForDataFrames(Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE);
-
-    // Cancel the call and close the response body. This should discard the buffered data and update
-    // the connection flow-control window.
-    call1.cancel();
-    response1.close();
-
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response2 = call2.execute();
-    Assertions.assertThat(response2.body().string()).isEqualTo("abc");
-  }
-
-  @Test public void concurrentRequestWithEmptyFlowControlWindow() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody(new Buffer().write(new byte[Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE])));
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response1 = call1.execute();
-
-    waitForDataFrames(Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE);
-
-    Assertions.assertThat(response1.body().contentLength()).isEqualTo(
-        (long) Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE);
-    int read = response1.body().source().read(new byte[8192]);
-    Assertions.assertThat(read).isEqualTo(8192);
-
-    // Make a second call that should transmit the response headers. The response body won't be
-    // transmitted until the flow-control window is updated from the first request.
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response2 = call2.execute();
-    Assertions.assertThat(response2.code()).isEqualTo(200);
-
-    // Close the response body. This should discard the buffered data and update the connection
-    // flow-control window.
-    response1.close();
-
-    Assertions.assertThat(response2.body().string()).isEqualTo("abc");
-  }
-
-  /** https://github.com/square/okhttp/issues/373 */
-  @Test @Ignore public void synchronousRequest() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-    server.enqueue(new MockResponse().setBody("A"));
-
-    ExecutorService executor = Executors.newCachedThreadPool();
-    CountDownLatch countDownLatch = new CountDownLatch(2);
-    executor.execute(new AsyncRequest("/r1", countDownLatch));
-    executor.execute(new AsyncRequest("/r2", countDownLatch));
-    countDownLatch.await();
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void gzippedResponseBody() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Content-Encoding: gzip")
-        .setBody(gzip("ABCABCABC")));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/r1"))
-        .build());
-
-    Response response = call.execute();
-    Assertions.assertThat(response.body().string()).isEqualTo("ABCABCABC");
-  }
-
-  @Test public void authenticate() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_UNAUTHORIZED)
-        .addHeader("www-authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate."));
-    server.enqueue(new MockResponse()
-        .setBody("Successful auth!"));
-
-    String credential = Credentials.basic("username", "password");
-    client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential, "Basic"))
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    Assertions.assertThat(response.body().string()).isEqualTo("Successful auth!");
-
-    RecordedRequest denied = server.takeRequest();
-    Assertions.assertThat(denied.getHeader("Authorization")).isNull();
-    RecordedRequest accepted = server.takeRequest();
-    Assertions.assertThat(accepted.getRequestLine()).isEqualTo("GET / HTTP/1.1");
-    Assertions.assertThat(accepted.getHeader("Authorization")).isEqualTo(credential);
-  }
-
-  @Test public void redirect() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /foo")
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse().setBody("This is the new location!"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-
-    Response response = call.execute();
-    Assertions.assertThat(response.body().string()).isEqualTo("This is the new location!");
-
-    RecordedRequest request1 = server.takeRequest();
-    Assertions.assertThat(request1.getPath()).isEqualTo("/");
-    RecordedRequest request2 = server.takeRequest();
-    Assertions.assertThat(request2.getPath()).isEqualTo("/foo");
-  }
-
-  @Test public void readAfterLastByte() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABC"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-
-    InputStream in = response.body().byteStream();
-    Assertions.assertThat(in.read()).isEqualTo('A');
-    Assertions.assertThat(in.read()).isEqualTo('B');
-    Assertions.assertThat(in.read()).isEqualTo('C');
-    Assertions.assertThat(in.read()).isEqualTo(-1);
-    Assertions.assertThat(in.read()).isEqualTo(-1);
-
-    in.close();
-  }
-
-  @Test public void readResponseHeaderTimeout() throws Exception {
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.NO_RESPONSE));
-    server.enqueue(new MockResponse().setBody("A"));
-
-    client = client.newBuilder()
-        .readTimeout(1000, MILLISECONDS)
-        .build();
-
-    // Make a call expecting a timeout reading the response headers.
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    try {
-      call1.execute();
-      fail("Should have timed out!");
-    } catch (SocketTimeoutException expected) {
-      Assertions.assertThat(expected.getMessage()).isEqualTo("timeout");
-    }
-
-    // Confirm that a subsequent request on the same connection is not impacted.
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response2 = call2.execute();
-    Assertions.assertThat(response2.body().string()).isEqualTo("A");
-
-    // Confirm that the connection was reused.
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  /**
-   * Test to ensure we don't  throw a read timeout on responses that are progressing.  For this
-   * case, we take a 4KiB body and throttle it to 1KiB/second.  We set the read timeout to two
-   * seconds.  If our implementation is acting correctly, it will not throw, as it is progressing.
-   */
-  @Test public void readTimeoutMoreGranularThanBodySize() throws Exception {
-    char[] body = new char[4096]; // 4KiB to read.
-    Arrays.fill(body, 'y');
-    server.enqueue(new MockResponse().setBody(new String(body))
-        .throttleBody(1024, 1, SECONDS)); // Slow connection 1KiB/second.
-
-    client = client.newBuilder()
-        .readTimeout(2, SECONDS)
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-
-    Response response = call.execute();
-    Assertions.assertThat(response.body().string()).isEqualTo(new String(body));
-  }
-
-  /**
-   * Test to ensure we throw a read timeout on responses that are progressing too slowly.  For this
-   * case, we take a 2KiB body and throttle it to 1KiB/second.  We set the read timeout to half a
-   * second.  If our implementation is acting correctly, it will throw, as a byte doesn't arrive in
-   * time.
-   */
-  @Test public void readTimeoutOnSlowConnection() throws Exception {
-    String body = TestUtil.repeat('y', 2048);
-    server.enqueue(new MockResponse()
-        .setBody(body)
-        .throttleBody(1024, 1, SECONDS)); // Slow connection 1KiB/second.
-    server.enqueue(new MockResponse()
-        .setBody(body));
-
-    client = client.newBuilder()
-        .readTimeout(500, MILLISECONDS) // Half a second to read something.
-        .build();
-
-    // Make a call expecting a timeout reading the response body.
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response1 = call1.execute();
-    try {
-      response1.body().string();
-      fail("Should have timed out!");
-    } catch (SocketTimeoutException expected) {
-      Assertions.assertThat(expected.getMessage()).isEqualTo("timeout");
-    }
-
-    // Confirm that a subsequent request on the same connection is not impacted.
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response2 = call2.execute();
-    Assertions.assertThat(response2.body().string()).isEqualTo(body);
-
-    // Confirm that the connection was reused.
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void connectionTimeout() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .setBodyDelay(1, SECONDS));
-
-    OkHttpClient client1 = client.newBuilder()
-        .readTimeout(2000, MILLISECONDS)
-        .build();
-    Call call1 = client1
-        .newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-
-    OkHttpClient client2 = client.newBuilder()
-        .readTimeout(200, MILLISECONDS)
-        .build();
-    Call call2 = client2
-        .newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-
-    Response response1 = call1.execute();
-    Assertions.assertThat(response1.body().string()).isEqualTo("A");
-
-    try {
-      call2.execute();
-      fail();
-    } catch (IOException expected) {
-    }
-
-    // Confirm that the connection was reused.
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void responsesAreCached() throws IOException {
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-
-    server.enqueue(new MockResponse()
-        .addHeader("cache-control: max-age=60")
-        .setBody("A"));
-
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response1 = call1.execute();
-
-    Assertions.assertThat(response1.body().string()).isEqualTo("A");
-    Assertions.assertThat(cache.requestCount()).isEqualTo(1);
-    Assertions.assertThat(cache.networkCount()).isEqualTo(1);
-    Assertions.assertThat(cache.hitCount()).isEqualTo(0);
-
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response2 = call2.execute();
-    Assertions.assertThat(response2.body().string()).isEqualTo("A");
-
-    Call call3 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response3 = call3.execute();
-    Assertions.assertThat(response3.body().string()).isEqualTo("A");
-
-    Assertions.assertThat(cache.requestCount()).isEqualTo(3);
-    Assertions.assertThat(cache.networkCount()).isEqualTo(1);
-    Assertions.assertThat(cache.hitCount()).isEqualTo(2);
-  }
-
-  @Test public void conditionalCache() throws IOException {
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-
-    server.enqueue(new MockResponse()
-        .addHeader("ETag: v1")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response1 = call1.execute();
-    Assertions.assertThat(response1.body().string()).isEqualTo("A");
-
-    Assertions.assertThat(cache.requestCount()).isEqualTo(1);
-    Assertions.assertThat(cache.networkCount()).isEqualTo(1);
-    Assertions.assertThat(cache.hitCount()).isEqualTo(0);
-
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response2 = call2.execute();
-    Assertions.assertThat(response2.body().string()).isEqualTo("A");
-
-    Assertions.assertThat(cache.requestCount()).isEqualTo(2);
-    Assertions.assertThat(cache.networkCount()).isEqualTo(2);
-    Assertions.assertThat(cache.hitCount()).isEqualTo(1);
-  }
-
-  @Test public void responseCachedWithoutConsumingFullBody() throws IOException {
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-
-    server.enqueue(new MockResponse()
-        .addHeader("cache-control: max-age=60")
-        .setBody("ABCD"));
-    server.enqueue(new MockResponse()
-        .addHeader("cache-control: max-age=60")
-        .setBody("EFGH"));
-
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response1 = call1.execute();
-    Assertions.assertThat(response1.body().source().readUtf8(2)).isEqualTo("AB");
-    response1.body().close();
-
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response2 = call2.execute();
-    Assertions.assertThat(response2.body().source().readUtf8()).isEqualTo("ABCD");
-    response2.body().close();
-  }
-
-  @Test public void sendRequestCookies() throws Exception {
-    RecordingCookieJar cookieJar = new RecordingCookieJar();
-    Cookie requestCookie = new Cookie.Builder()
-        .name("a")
-        .value("b")
-        .domain(server.getHostName())
-        .build();
-    cookieJar.enqueueRequestCookies(requestCookie);
-    client = client.newBuilder()
-        .cookieJar(cookieJar)
-        .build();
-
-    server.enqueue(new MockResponse());
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    Assertions.assertThat(response.body().string()).isEqualTo("");
-
-    RecordedRequest request = server.takeRequest();
-    Assertions.assertThat(request.getHeader("Cookie")).isEqualTo("a=b");
-  }
-
-  @Test public void receiveResponseCookies() throws Exception {
-    RecordingCookieJar cookieJar = new RecordingCookieJar();
-    client = client.newBuilder()
-        .cookieJar(cookieJar)
-        .build();
-
-    server.enqueue(new MockResponse()
-        .addHeader("set-cookie: a=b"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    Assertions.assertThat(response.body().string()).isEqualTo("");
-
-    cookieJar.assertResponseCookies("a=b; path=/");
-  }
-
-  @Test public void cancelWithStreamNotCompleted() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-    server.enqueue(new MockResponse()
-        .setBody("def"));
-
-    // Disconnect before the stream is created. A connection is still established!
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call1.execute();
-    call1.cancel();
-
-    // That connection is pooled, and it works.
-    Assertions.assertThat(client.connectionPool().connectionCount()).isEqualTo(1);
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response2 = call2.execute();
-    Assertions.assertThat(response2.body().string()).isEqualTo("def");
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-
-    // Clean up the connection.
-    response.close();
-  }
-
-  @Test public void recoverFromOneRefusedStreamReusesConnection() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
-        .setHttp2ErrorCode(ErrorCode.REFUSED_STREAM.httpCode));
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    Assertions.assertThat(response.body().string()).isEqualTo("abc");
-
-    // New connection.
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    // Reused connection.
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void recoverFromOneInternalErrorRequiresNewConnection() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
-        .setHttp2ErrorCode(ErrorCode.INTERNAL_ERROR.httpCode));
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    client = client.newBuilder()
-        .dns(new DoubleInetAddressDns())
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    Assertions.assertThat(response.body().string()).isEqualTo("abc");
-
-    // New connection.
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    // New connection.
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-  }
-
-  @Test public void recoverFromMultipleRefusedStreamsRequiresNewConnection() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
-        .setHttp2ErrorCode(ErrorCode.REFUSED_STREAM.httpCode));
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
-        .setHttp2ErrorCode(ErrorCode.REFUSED_STREAM.httpCode));
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    client = client.newBuilder()
-        .dns(new DoubleInetAddressDns())
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    Assertions.assertThat(response.body().string()).isEqualTo("abc");
-
-    // New connection.
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    // Reused connection.
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-    // New connection.
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-  }
-
-  @Test public void recoverFromCancelReusesConnection() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBodyDelay(10, TimeUnit.SECONDS)
-        .setBody("abc"));
-    server.enqueue(new MockResponse()
-        .setBody("def"));
-
-    client = client.newBuilder()
-        .dns(new DoubleInetAddressDns())
-        .build();
-
-    callAndCancel(0);
-
-    // Make a second request to ensure the connection is reused.
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    Assertions.assertThat(response.body().string()).isEqualTo("def");
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void recoverFromMultipleCancelReusesConnection() throws Exception {
-    server.enqueue(new MockResponse()
-            .setBodyDelay(10, TimeUnit.SECONDS)
-            .setBody("abc"));
-    server.enqueue(new MockResponse()
-            .setBodyDelay(10, TimeUnit.SECONDS)
-            .setBody("def"));
-    server.enqueue(new MockResponse()
-            .setBody("ghi"));
-
-    client = client.newBuilder()
-            .dns(new DoubleInetAddressDns())
-            .build();
-
-    callAndCancel(0);
-    callAndCancel(1);
-
-    // Make a third request to ensure the connection is reused.
-    Call call = client.newCall(new Request.Builder()
-            .url(server.url("/"))
-            .build());
-    Response response = call.execute();
-    Assertions.assertThat(response.body().string()).isEqualTo("ghi");
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
-  }
-
-  /** Make a call and canceling it as soon as it's accepted by the server. */
-  private void callAndCancel(int expectedSequenceNumber) throws Exception {
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback() {
-      @Override public void onFailure(Call call1, IOException e) {
-        latch.countDown();
-      }
-
-      @Override public void onResponse(Call call1, Response response) {
-        fail();
-      }
-    });
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(
-        (long) expectedSequenceNumber);
-    call.cancel();
-    latch.await();
-  }
-
-  @Test public void noRecoveryFromRefusedStreamWithRetryDisabled() throws Exception {
-    noRecoveryFromErrorWithRetryDisabled(ErrorCode.REFUSED_STREAM);
-  }
-
-  @Test public void noRecoveryFromInternalErrorWithRetryDisabled() throws Exception {
-    noRecoveryFromErrorWithRetryDisabled(ErrorCode.INTERNAL_ERROR);
-  }
-
-  private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
-        .setHttp2ErrorCode(errorCode.httpCode));
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    client = client.newBuilder()
-        .retryOnConnectionFailure(false)
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    try {
-      call.execute();
-      fail();
-    } catch (StreamResetException expected) {
-      Assertions.assertThat(expected.errorCode).isEqualTo(errorCode);
-    }
-  }
-
-  @Test public void recoverFromConnectionNoNewStreamsOnFollowUp() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(401));
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
-        .setHttp2ErrorCode(ErrorCode.INTERNAL_ERROR.httpCode));
-    server.enqueue(new MockResponse()
-        .setBody("DEF"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(301)
-        .addHeader("Location", "/foo"));
-    server.enqueue(new MockResponse()
-        .setBody("ABC"));
-
-    CountDownLatch latch = new CountDownLatch(1);
-    BlockingQueue<String> responses = new SynchronousQueue<>();
-    okhttp3.Authenticator authenticator = (route, response) -> {
-      responses.offer(response.body().string());
-      try {
-        latch.await();
-      } catch (InterruptedException e) {
-        throw new AssertionError();
-      }
-      return response.request();
-    };
-
-    OkHttpClient blockingAuthClient = client.newBuilder()
-        .authenticator(authenticator)
-        .build();
-
-    Callback callback = new Callback() {
-      @Override public void onFailure(Call call, IOException e) {
-        fail();
-      }
-
-      @Override public void onResponse(Call call, Response response) throws IOException {
-        responses.offer(response.body().string());
-      }
-    };
-
-    // Make the first request waiting until we get our auth challenge.
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    blockingAuthClient.newCall(request).enqueue(callback);
-    String response1 = responses.take();
-    Assertions.assertThat(response1).isEqualTo("");
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-
-    // Now make the second request which will restrict the first HTTP/2 connection from creating new
-    // streams.
-    client.newCall(request).enqueue(callback);
-    String response2 = responses.take();
-    Assertions.assertThat(response2).isEqualTo("DEF");
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-
-    // Let the first request proceed. It should discard the the held HTTP/2 connection and get a new
-    // one.
-    latch.countDown();
-    String response3 = responses.take();
-    Assertions.assertThat(response3).isEqualTo("ABC");
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
-  }
-
-  @Test public void nonAsciiResponseHeader() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeaderLenient("Alpha", "Œ±")
-        .addHeaderLenient("Œ≤", "Beta"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    response.close();
-
-    Assertions.assertThat(response.header("Alpha")).isEqualTo("Œ±");
-    Assertions.assertThat(response.header("Œ≤")).isEqualTo("Beta");
-  }
-
-  @Test public void serverSendsPushPromise_GET() throws Exception {
-    PushPromise pushPromise = new PushPromise("GET", "/foo/bar", Headers.of("foo", "bar"),
-        new MockResponse().setBody("bar").setStatus("HTTP/1.1 200 Sweet"));
-    server.enqueue(new MockResponse()
-        .setBody("ABCDE")
-        .setStatus("HTTP/1.1 200 Sweet")
-        .withPush(pushPromise));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/foo"))
-        .build());
-    Response response = call.execute();
-
-    Assertions.assertThat(response.body().string()).isEqualTo("ABCDE");
-    Assertions.assertThat(response.code()).isEqualTo(200);
-    Assertions.assertThat(response.message()).isEqualTo("");
-
-    RecordedRequest request = server.takeRequest();
-    Assertions.assertThat(request.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
-    Assertions.assertThat(request.getHeader(":scheme")).isEqualTo(scheme);
-    Assertions.assertThat(request.getHeader(":authority")).isEqualTo(
-        (server.getHostName() + ":" + server.getPort()));
-
-    RecordedRequest pushedRequest = server.takeRequest();
-    Assertions.assertThat(pushedRequest.getRequestLine()).isEqualTo(
-        "GET /foo/bar HTTP/1.1");
-    Assertions.assertThat(pushedRequest.getHeader("foo")).isEqualTo("bar");
-  }
-
-  @Test public void serverSendsPushPromise_HEAD() throws Exception {
-    PushPromise pushPromise = new PushPromise("HEAD", "/foo/bar", Headers.of("foo", "bar"),
-        new MockResponse().setStatus("HTTP/1.1 204 Sweet"));
-    server.enqueue(new MockResponse()
-        .setBody("ABCDE")
-        .setStatus("HTTP/1.1 200 Sweet")
-        .withPush(pushPromise));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/foo"))
-        .build());
-    Response response = call.execute();
-    Assertions.assertThat(response.body().string()).isEqualTo("ABCDE");
-    Assertions.assertThat(response.code()).isEqualTo(200);
-    Assertions.assertThat(response.message()).isEqualTo("");
-
-    RecordedRequest request = server.takeRequest();
-    Assertions.assertThat(request.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
-    Assertions.assertThat(request.getHeader(":scheme")).isEqualTo(scheme);
-    Assertions.assertThat(request.getHeader(":authority")).isEqualTo(
-        (server.getHostName() + ":" + server.getPort()));
-
-    RecordedRequest pushedRequest = server.takeRequest();
-    Assertions.assertThat(pushedRequest.getRequestLine()).isEqualTo(
-        "HEAD /foo/bar HTTP/1.1");
-    Assertions.assertThat(pushedRequest.getHeader("foo")).isEqualTo("bar");
-  }
-
-  @Test public void noDataFramesSentWithNullRequestBody() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("ABC"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .method("DELETE", null)
-        .build());
-    Response response = call.execute();
-    Assertions.assertThat(response.body().string()).isEqualTo("ABC");
-
-    Assertions.assertThat(response.protocol()).isEqualTo(protocol);
-
-    List<String> logs = http2Handler.takeAll();
-
-    assertThat("header logged", firstFrame(logs, "HEADERS"), containsString("HEADERS       END_STREAM|END_HEADERS"));
-  }
-
-  @Test public void emptyDataFrameSentWithEmptyBody() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("ABC"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .method("DELETE", Util.EMPTY_REQUEST)
-        .build());
-    Response response = call.execute();
-    Assertions.assertThat(response.body().string()).isEqualTo("ABC");
-
-    Assertions.assertThat(response.protocol()).isEqualTo(protocol);
-
-    List<String> logs = http2Handler.takeAll();
-
-    assertThat("header logged", firstFrame(logs, "HEADERS"), containsString("HEADERS       END_HEADERS"));
-    assertThat("data logged", firstFrame(logs, "DATA"), containsString("0 DATA          END_STREAM"));
-  }
-
-  @Test public void pingsTransmitted() throws Exception {
-    // Ping every 500 ms, starting at 500 ms.
-    client = client.newBuilder()
-        .pingInterval(500, TimeUnit.MILLISECONDS)
-        .build();
-
-    // Delay the response to give 1 ping enough time to be sent and replied to.
-    server.enqueue(new MockResponse()
-        .setBodyDelay(750, TimeUnit.MILLISECONDS)
-        .setBody("ABC"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    Assertions.assertThat(response.body().string()).isEqualTo("ABC");
-
-    Assertions.assertThat(response.protocol()).isEqualTo(protocol);
-
-    // Confirm a single ping was sent and received, and its reply was sent and received.
-    List<String> logs = http2Handler.takeAll();
-    Assertions.assertThat(countFrames(logs, "FINE: >> 0x00000000     8 PING          ")).isEqualTo(
-        (long) 1);
-    Assertions.assertThat(countFrames(logs, "FINE: << 0x00000000     8 PING          ")).isEqualTo(
-        (long) 1);
-    Assertions.assertThat(countFrames(logs, "FINE: >> 0x00000000     8 PING          ACK")).isEqualTo(
-        (long) 1);
-    Assertions.assertThat(countFrames(logs, "FINE: << 0x00000000     8 PING          ACK")).isEqualTo(
-        (long) 1);
-  }
-
-  @Test public void missingPongsFailsConnection() throws Exception {
-    // Ping every 500 ms, starting at 500 ms.
-    client = client.newBuilder()
-        .readTimeout(10, TimeUnit.SECONDS) // Confirm we fail before the read timeout.
-        .pingInterval(500, TimeUnit.MILLISECONDS)
-        .build();
-
-    // Set up the server to ignore the socket. It won't respond to pings!
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.STALL_SOCKET_AT_START));
-
-    // Make a call. It'll fail as soon as our pings detect a problem.
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    long executeAtNanos = System.nanoTime();
-    try {
-      call.execute();
-      fail();
-    } catch (StreamResetException expected) {
-      Assertions.assertThat(expected.getMessage()).isEqualTo(
-          "stream was reset: PROTOCOL_ERROR");
-    }
-
-    long elapsedUntilFailure = System.nanoTime() - executeAtNanos;
-    Assertions.assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure)).isCloseTo(
-        (double) 1000, offset(250d));
-
-    // Confirm a single ping was sent but not acknowledged.
-    List<String> logs = http2Handler.takeAll();
-    Assertions.assertThat(countFrames(logs, "FINE: >> 0x00000000     8 PING          ")).isEqualTo(
-        (long) 1);
-    Assertions.assertThat(countFrames(logs, "FINE: << 0x00000000     8 PING          ACK")).isEqualTo(
-        (long) 0);
-  }
-
-  private String firstFrame(List<String> logs, String type) {
-    for (String log: logs) {
-      if (log.contains(type)) {
-        return log;
-      }
-    }
-    return null;
-  }
-
-  private int countFrames(List<String> logs, String message) {
-    int result = 0;
-    for (String log: logs) {
-      if (log.equals(message)) {
-        result++;
-      }
-    }
-    return result;
-  }
-
-  /**
-   * Push a setting that permits up to 2 concurrent streams, then make 3 concurrent requests and
-   * confirm that the third concurrent request prepared a new connection.
-   */
-  @Test public void settingsLimitsMaxConcurrentStreams() throws Exception {
-    Settings settings = new Settings();
-    settings.set(Settings.MAX_CONCURRENT_STREAMS, 2);
-
-    // Read & write a full request to confirm settings are accepted.
-    server.enqueue(new MockResponse().withSettings(settings));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    Assertions.assertThat(response.body().string()).isEqualTo("");
-
-    server.enqueue(new MockResponse()
-        .setBody("ABC"));
-    server.enqueue(new MockResponse()
-        .setBody("DEF"));
-    server.enqueue(new MockResponse()
-        .setBody("GHI"));
-
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response1 = call1.execute();
-
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response2 = call2.execute();
-
-    Call call3 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response3 = call3.execute();
-
-    Assertions.assertThat(response1.body().string()).isEqualTo("ABC");
-    Assertions.assertThat(response2.body().string()).isEqualTo("DEF");
-    Assertions.assertThat(response3.body().string()).isEqualTo("GHI");
-    // Settings connection.
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    // Reuse settings connection.
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-    // Reuse settings connection.
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
-    // New connection!
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-  }
-
-  @Test public void connectionNotReusedAfterShutdown() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setBody("ABC"));
-    server.enqueue(new MockResponse()
-        .setBody("DEF"));
-
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response1 = call1.execute();
-    Assertions.assertThat(response1.body().string()).isEqualTo("ABC");
-
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response2 = call2.execute();
-    Assertions.assertThat(response2.body().string()).isEqualTo("DEF");
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-  }
-
-  /**
-   * This simulates a race condition where we receive a healthy HTTP/2 connection and just prior to
-   * writing our request, we get a GOAWAY frame from the server.
-   */
-  @Test public void connectionShutdownAfterHealthCheck() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setBody("ABC"));
-    server.enqueue(new MockResponse()
-        .setBody("DEF"));
-
-    OkHttpClient client2 = client.newBuilder()
-        .addNetworkInterceptor(new Interceptor() {
-          boolean executedCall;
-
-          @Override public Response intercept(Chain chain) throws IOException {
-            if (!executedCall) {
-              // At this point, we have a healthy HTTP/2 connection. This call will trigger the
-              // server to send a GOAWAY frame, leaving the connection in a shutdown state.
-              executedCall = true;
-              Call call = client.newCall(new Request.Builder()
-                  .url(server.url("/"))
-                  .build());
-              Response response = call.execute();
-              Assertions.assertThat(response.body().string()).isEqualTo("ABC");
-              // Wait until the GOAWAY has been processed.
-              RealConnection connection = (RealConnection) chain.connection();
-              while (connection.isHealthy(false)) ;
-            }
-            return chain.proceed(chain.request());
-          }
-        })
-        .build();
-
-    Call call = client2.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    Assertions.assertThat(response.body().string()).isEqualTo("DEF");
-
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    Assertions.assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-  }
-
-  @Test public void responseHeadersAfterGoaway() throws Exception {
-    server.enqueue(new MockResponse()
-        .setHeadersDelay(1, SECONDS)
-        .setBody("ABC"));
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setBody("DEF"));
-
-    BlockingQueue<String> bodies = new SynchronousQueue<>();
-    Callback callback = new Callback() {
-      @Override public void onResponse(Call call, Response response) throws IOException {
-        bodies.add(response.body().string());
-      }
-      @Override public void onFailure(Call call, IOException e) {
-        System.out.println(e);
-      }
-    };
-    client.newCall(new Request.Builder().url(server.url("/")).build()).enqueue(callback);
-    client.newCall(new Request.Builder().url(server.url("/")).build()).enqueue(callback);
-
-    Assertions.assertThat(bodies.poll(2, SECONDS)).isEqualTo("DEF");
-    Assertions.assertThat(bodies.poll(2, SECONDS)).isEqualTo("ABC");
-    Assertions.assertThat(server.getRequestCount()).isEqualTo(2);
-  }
-
-  /**
-   * We don't know if the connection will support HTTP/2 until after we've connected. When multiple
-   * connections are requested concurrently OkHttp will pessimistically connect multiple times, then
-   * close any unnecessary connections. This test confirms that behavior works as intended.
-   *
-   * <p>This test uses proxy tunnels to get a hook while a connection is being established.
-   */
-  @Test public void concurrentHttp2ConnectionsDeduplicated() throws Exception {
-    assumeTrue(protocol == Protocol.HTTP_2);
-
-    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
-
-    QueueDispatcher queueDispatcher = new QueueDispatcher();
-    queueDispatcher.enqueueResponse(new MockResponse()
-        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
-        .clearHeaders());
-    queueDispatcher.enqueueResponse(new MockResponse()
-        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
-        .clearHeaders());
-    queueDispatcher.enqueueResponse(new MockResponse()
-        .setBody("call2 response"));
-    queueDispatcher.enqueueResponse(new MockResponse()
-        .setBody("call1 response"));
-
-    // We use a re-entrant dispatcher to initiate one HTTPS connection while the other is in flight.
-    server.setDispatcher(new Dispatcher() {
-      int requestCount;
-
-      @Override public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
-        MockResponse result = queueDispatcher.dispatch(request);
-
-        requestCount++;
-        if (requestCount == 1) {
-          // Before handling call1's CONNECT we do all of call2. This part re-entrant!
-          try {
-            Call call2 = client.newCall(new Request.Builder()
-                .url("https://android.com/call2")
-                .build());
-            Response response2 = call2.execute();
-            Assertions.assertThat(response2.body().string()).isEqualTo("call2 response");
-          } catch (IOException e) {
-            throw new RuntimeException(e);
-          }
-        }
-
-        return result;
-      }
-
-      @Override public MockResponse peek() {
-        return queueDispatcher.peek();
-      }
-
-      @Override public void shutdown() {
-        queueDispatcher.shutdown();
-      }
-    });
-
-    client = client.newBuilder()
-        .proxy(server.toProxyAddress())
-        .build();
-
-    Call call1 = client.newCall(new Request.Builder()
-        .url("https://android.com/call1")
-        .build());
-    Response response2 = call1.execute();
-    Assertions.assertThat(response2.body().string()).isEqualTo("call1 response");
-
-    RecordedRequest call1Connect = server.takeRequest();
-    Assertions.assertThat(call1Connect.getMethod()).isEqualTo("CONNECT");
-    Assertions.assertThat(call1Connect.getSequenceNumber()).isEqualTo(0);
-
-    RecordedRequest call2Connect = server.takeRequest();
-    Assertions.assertThat(call2Connect.getMethod()).isEqualTo("CONNECT");
-    Assertions.assertThat(call2Connect.getSequenceNumber()).isEqualTo(0);
-
-    RecordedRequest call2Get = server.takeRequest();
-    Assertions.assertThat(call2Get.getMethod()).isEqualTo("GET");
-    Assertions.assertThat(call2Get.getPath()).isEqualTo("/call2");
-    Assertions.assertThat(call2Get.getSequenceNumber()).isEqualTo(0);
-
-    RecordedRequest call1Get = server.takeRequest();
-    Assertions.assertThat(call1Get.getMethod()).isEqualTo("GET");
-    Assertions.assertThat(call1Get.getPath()).isEqualTo("/call1");
-    Assertions.assertThat(call1Get.getSequenceNumber()).isEqualTo(1);
-
-    Assertions.assertThat(client.connectionPool().connectionCount()).isEqualTo(1);
-  }
-
-  /** https://github.com/square/okhttp/issues/3103 */
-  @Test public void domainFronting() throws Exception {
-    client = client.newBuilder()
-        .addNetworkInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
-            Request request = chain.request().newBuilder()
-                .header("Host", "privateobject.com")
-                .build();
-            return chain.proceed(request);
-          }
-        })
-        .build();
-
-    server.enqueue(new MockResponse());
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-
-    Response response = call.execute();
-    Assertions.assertThat(response.body().string()).isEqualTo("");
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    Assertions.assertThat(recordedRequest.getHeader(":authority")).isEqualTo(
-        "privateobject.com");
-  }
-
-  private Buffer gzip(String bytes) throws IOException {
-    Buffer bytesOut = new Buffer();
-    BufferedSink sink = Okio.buffer(new GzipSink(bytesOut));
-    sink.writeUtf8(bytes);
-    sink.close();
-    return bytesOut;
-  }
-
-  class AsyncRequest implements Runnable {
-    String path;
-    CountDownLatch countDownLatch;
-
-    AsyncRequest(String path, CountDownLatch countDownLatch) {
-      this.path = path;
-      this.countDownLatch = countDownLatch;
-    }
-
-    @Override public void run() {
-      try {
-        Call call = client.newCall(new Request.Builder()
-            .url(server.url(path))
-            .build());
-        Response response = call.execute();
-        Assertions.assertThat(response.body().string()).isEqualTo("A");
-        countDownLatch.countDown();
-      } catch (Exception e) {
-        throw new RuntimeException(e);
-      }
-    }
-  }
-
-  /** https://github.com/square/okhttp/issues/4875 */
-  @Test
-  public void shutdownAfterLateCoalescing() throws Exception {
-    CountDownLatch latch = new CountDownLatch(2);
-
-    Callback callback = new Callback() {
-      @Override public void onResponse(Call call, Response response) {
-        fail();
-      }
-
-      @Override public void onFailure(Call call, IOException e) {
-        latch.countDown();
-      }
-    };
-
-    client = client.newBuilder().eventListener(new EventListener() {
-      int callCount;
-
-      @Override public void connectionAcquired(Call call, Connection connection) {
-        try {
-          if (callCount++ == 1) {
-            server.shutdown();
-          }
-        } catch(IOException e) {
-          fail();
-        }
-      }
-    }).build();
-
-    client.newCall(new Request.Builder().url(server.url("")).build()).enqueue(callback);
-    client.newCall(new Request.Builder().url(server.url("")).build()).enqueue(callback);
-
-    latch.await();
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/HuffmanTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/HuffmanTest.java
deleted file mode 100644
index b84d2de09f..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/HuffmanTest.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright 2013 Twitter, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import java.io.IOException;
-import java.util.Random;
-import okio.Buffer;
-import okio.ByteString;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.assertArrayEquals;
-
-/** Original version of this class was lifted from {@code com.twitter.hpack.HuffmanTest}. */
-public final class HuffmanTest {
-  @Test public void roundTripForRequestAndResponse() throws IOException {
-    String s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
-    for (int i = 0; i < s.length(); i++) {
-      assertRoundTrip(ByteString.encodeUtf8(s.substring(0, i)));
-    }
-
-    Random random = new Random(123456789L);
-    byte[] buf = new byte[4096];
-    random.nextBytes(buf);
-    assertRoundTrip(ByteString.of(buf));
-  }
-
-  private void assertRoundTrip(ByteString data) throws IOException {
-    Buffer buffer = new Buffer();
-    Huffman.get().encode(data, buffer);
-    assertThat(Huffman.get().encodedLength(data)).isEqualTo(buffer.size());
-
-    byte[] decodedBytes = Huffman.get().decode(buffer.readByteArray());
-    assertArrayEquals(data.toByteArray(), decodedBytes);
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
deleted file mode 100644
index 1ade5b1dde..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
+++ /dev/null
@@ -1,307 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package okhttp3.internal.http2;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.InetSocketAddress;
-import java.net.ServerSocket;
-import java.net.Socket;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.logging.Logger;
-import okhttp3.internal.Util;
-import okio.Buffer;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.Okio;
-
-/** Replays prerecorded outgoing frames and records incoming frames. */
-public final class MockHttp2Peer implements Closeable {
-  private static final Logger logger = Logger.getLogger(MockHttp2Peer.class.getName());
-
-  private int frameCount = 0;
-  private boolean client = false;
-  private final Buffer bytesOut = new Buffer();
-  private Http2Writer writer = new Http2Writer(bytesOut, client);
-  private final List<OutFrame> outFrames = new ArrayList<>();
-  private final BlockingQueue<InFrame> inFrames = new LinkedBlockingQueue<>();
-  private int port;
-  private final ExecutorService executor = Executors.newSingleThreadExecutor(
-      Util.threadFactory("MockHttp2Peer", false));
-  private ServerSocket serverSocket;
-  private Socket socket;
-
-  public void setClient(boolean client) {
-    if (this.client == client) {
-      return;
-    }
-    this.client = client;
-    this.writer = new Http2Writer(bytesOut, client);
-  }
-
-  public void acceptFrame() {
-    frameCount++;
-  }
-
-  /** Maximum length of an outbound data frame. */
-  public int maxOutboundDataLength() {
-    return writer.maxDataLength();
-  }
-
-  /** Count of frames sent or received. */
-  public int frameCount() {
-    return frameCount;
-  }
-
-  public Http2Writer sendFrame() {
-    outFrames.add(new OutFrame(frameCount++, bytesOut.size(), false));
-    return writer;
-  }
-
-  /**
-   * Shortens the last frame from its original length to {@code length}. This will cause the peer to
-   * close the socket as soon as this frame has been written; otherwise the peer stays open until
-   * explicitly closed.
-   */
-  public Http2Writer truncateLastFrame(int length) {
-    OutFrame lastFrame = outFrames.remove(outFrames.size() - 1);
-    if (length >= bytesOut.size() - lastFrame.start) throw new IllegalArgumentException();
-
-    // Move everything from bytesOut into a new buffer.
-    Buffer fullBuffer = new Buffer();
-    bytesOut.read(fullBuffer, bytesOut.size());
-
-    // Copy back all but what we're truncating.
-    fullBuffer.read(bytesOut, lastFrame.start + length);
-
-    outFrames.add(new OutFrame(lastFrame.sequence, lastFrame.start, true));
-    return writer;
-  }
-
-  public InFrame takeFrame() throws Exception {
-    return inFrames.take();
-  }
-
-  public void play() throws IOException {
-    if (serverSocket != null) throw new IllegalStateException();
-    serverSocket = new ServerSocket();
-    serverSocket.setReuseAddress(false);
-    serverSocket.bind(new InetSocketAddress("localhost", 0), 1);
-    port = serverSocket.getLocalPort();
-    executor.execute(() -> {
-      try {
-        readAndWriteFrames();
-      } catch (IOException e) {
-        Util.closeQuietly(MockHttp2Peer.this);
-        logger.info(MockHttp2Peer.this + " done: " + e.getMessage());
-      }
-    });
-  }
-
-  private void readAndWriteFrames() throws IOException {
-    if (socket != null) throw new IllegalStateException();
-    socket = serverSocket.accept();
-
-    // Bail out now if this instance was closed while waiting for the socket to accept.
-    synchronized (this) {
-      if (executor.isShutdown()) {
-        socket.close();
-        return;
-      }
-    }
-
-    OutputStream out = socket.getOutputStream();
-    InputStream in = socket.getInputStream();
-    Http2Reader reader = new Http2Reader(Okio.buffer(Okio.source(in)), client);
-
-    Iterator<OutFrame> outFramesIterator = outFrames.iterator();
-    byte[] outBytes = bytesOut.readByteArray();
-    OutFrame nextOutFrame = null;
-
-    for (int i = 0; i < frameCount; i++) {
-      if (nextOutFrame == null && outFramesIterator.hasNext()) {
-        nextOutFrame = outFramesIterator.next();
-      }
-
-      if (nextOutFrame != null && nextOutFrame.sequence == i) {
-        long start = nextOutFrame.start;
-        boolean truncated;
-        long end;
-        if (outFramesIterator.hasNext()) {
-          nextOutFrame = outFramesIterator.next();
-          end = nextOutFrame.start;
-          truncated = false;
-        } else {
-          end = outBytes.length;
-          truncated = nextOutFrame.truncated;
-        }
-
-        // Write a frame.
-        int length = (int) (end - start);
-        out.write(outBytes, (int) start, length);
-
-        // If the last frame was truncated, immediately close the connection.
-        if (truncated) {
-          socket.close();
-        }
-      } else {
-        // read a frame
-        InFrame inFrame = new InFrame(i, reader);
-        reader.nextFrame(false, inFrame);
-        inFrames.add(inFrame);
-      }
-    }
-  }
-
-  public Socket openSocket() throws IOException {
-    return new Socket("localhost", port);
-  }
-
-  @Override public synchronized void close() throws IOException {
-    executor.shutdown();
-    Util.closeQuietly(socket);
-    Util.closeQuietly(serverSocket);
-  }
-
-  @Override public String toString() {
-    return "MockHttp2Peer[" + port + "]";
-  }
-
-  private static class OutFrame {
-    private final int sequence;
-    private final long start;
-    private final boolean truncated;
-
-    private OutFrame(int sequence, long start, boolean truncated) {
-      this.sequence = sequence;
-      this.start = start;
-      this.truncated = truncated;
-    }
-  }
-
-  public static class InFrame implements Http2Reader.Handler {
-    public final int sequence;
-    public final Http2Reader reader;
-    public int type = -1;
-    public boolean clearPrevious;
-    public boolean outFinished;
-    public boolean inFinished;
-    public int streamId;
-    public int associatedStreamId;
-    public ErrorCode errorCode;
-    public long windowSizeIncrement;
-    public List<Header> headerBlock;
-    public byte[] data;
-    public Settings settings;
-    public boolean ack;
-    public int payload1;
-    public int payload2;
-
-    public InFrame(int sequence, Http2Reader reader) {
-      this.sequence = sequence;
-      this.reader = reader;
-    }
-
-    @Override public void settings(boolean clearPrevious, Settings settings) {
-      if (this.type != -1) throw new IllegalStateException();
-      this.type = Http2.TYPE_SETTINGS;
-      this.clearPrevious = clearPrevious;
-      this.settings = settings;
-    }
-
-    @Override public void ackSettings() {
-      if (this.type != -1) throw new IllegalStateException();
-      this.type = Http2.TYPE_SETTINGS;
-      this.ack = true;
-    }
-
-    @Override public void headers(boolean inFinished, int streamId,
-        int associatedStreamId, List<Header> headerBlock) {
-      if (this.type != -1) throw new IllegalStateException();
-      this.type = Http2.TYPE_HEADERS;
-      this.inFinished = inFinished;
-      this.streamId = streamId;
-      this.associatedStreamId = associatedStreamId;
-      this.headerBlock = headerBlock;
-    }
-
-    @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
-        throws IOException {
-      if (this.type != -1) throw new IllegalStateException();
-      this.type = Http2.TYPE_DATA;
-      this.inFinished = inFinished;
-      this.streamId = streamId;
-      this.data = source.readByteString(length).toByteArray();
-    }
-
-    @Override public void rstStream(int streamId, ErrorCode errorCode) {
-      if (this.type != -1) throw new IllegalStateException();
-      this.type = Http2.TYPE_RST_STREAM;
-      this.streamId = streamId;
-      this.errorCode = errorCode;
-    }
-
-    @Override public void ping(boolean ack, int payload1, int payload2) {
-      if (this.type != -1) throw new IllegalStateException();
-      this.type = Http2.TYPE_PING;
-      this.ack = ack;
-      this.payload1 = payload1;
-      this.payload2 = payload2;
-    }
-
-    @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
-      if (this.type != -1) throw new IllegalStateException();
-      this.type = Http2.TYPE_GOAWAY;
-      this.streamId = lastGoodStreamId;
-      this.errorCode = errorCode;
-      this.data = debugData.toByteArray();
-    }
-
-    @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
-      if (this.type != -1) throw new IllegalStateException();
-      this.type = Http2.TYPE_WINDOW_UPDATE;
-      this.streamId = streamId;
-      this.windowSizeIncrement = windowSizeIncrement;
-    }
-
-    @Override public void priority(int streamId, int streamDependency, int weight,
-        boolean exclusive) {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public void pushPromise(int streamId, int associatedStreamId, List<Header> headerBlock) {
-      this.type = Http2.TYPE_PUSH_PROMISE;
-      this.streamId = streamId;
-      this.associatedStreamId = associatedStreamId;
-      this.headerBlock = headerBlock;
-    }
-
-    @Override public void alternateService(int streamId, String origin, ByteString protocol,
-        String host, int port, long maxAge) {
-      throw new UnsupportedOperationException();
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/SettingsTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/SettingsTest.java
deleted file mode 100644
index 8e2aa424b2..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/SettingsTest.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import org.junit.Test;
-
-import static okhttp3.internal.http2.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
-import static okhttp3.internal.http2.Settings.MAX_CONCURRENT_STREAMS;
-import static org.assertj.core.api.Assertions.assertThat;
-
-public final class SettingsTest {
-  @Test public void unsetField() {
-    Settings settings = new Settings();
-    assertThat(settings.getMaxConcurrentStreams(-3)).isEqualTo(-3);
-  }
-
-  @Test public void setFields() {
-    Settings settings = new Settings();
-
-    settings.set(Settings.HEADER_TABLE_SIZE, 8096);
-    assertThat(settings.getHeaderTableSize()).isEqualTo(8096);
-
-    assertThat(settings.getEnablePush(true)).isTrue();
-    settings.set(Settings.ENABLE_PUSH, 1);
-    assertThat(settings.getEnablePush(false)).isTrue();
-    settings.clear();
-
-    assertThat(settings.getMaxConcurrentStreams(-3)).isEqualTo(-3);
-    settings.set(MAX_CONCURRENT_STREAMS, 75);
-    assertThat(settings.getMaxConcurrentStreams(-3)).isEqualTo(75);
-
-    settings.clear();
-    assertThat(settings.getMaxFrameSize(16384)).isEqualTo(16384);
-    settings.set(Settings.MAX_FRAME_SIZE, 16777215);
-    assertThat(settings.getMaxFrameSize(16384)).isEqualTo(16777215);
-
-    assertThat(settings.getMaxHeaderListSize(-1)).isEqualTo(-1);
-    settings.set(Settings.MAX_HEADER_LIST_SIZE, 16777215);
-    assertThat(settings.getMaxHeaderListSize(-1)).isEqualTo(16777215);
-
-    assertThat(settings.getInitialWindowSize()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE);
-    settings.set(Settings.INITIAL_WINDOW_SIZE, 108);
-    assertThat(settings.getInitialWindowSize()).isEqualTo(108);
-  }
-
-  @Test public void merge() {
-    Settings a = new Settings();
-    a.set(Settings.HEADER_TABLE_SIZE, 10000);
-    a.set(Settings.MAX_HEADER_LIST_SIZE, 20000);
-    a.set(Settings.INITIAL_WINDOW_SIZE, 30000);
-
-    Settings b = new Settings();
-    b.set(Settings.MAX_HEADER_LIST_SIZE, 40000);
-    b.set(Settings.INITIAL_WINDOW_SIZE, 50000);
-    b.set(Settings.MAX_CONCURRENT_STREAMS, 60000);
-
-    a.merge(b);
-    assertThat(a.getHeaderTableSize()).isEqualTo(10000);
-    assertThat(a.getMaxHeaderListSize(-1)).isEqualTo(40000);
-    assertThat(a.getInitialWindowSize()).isEqualTo(50000);
-    assertThat(a.getMaxConcurrentStreams(-1)).isEqualTo(60000);
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/io/FaultyFileSystem.java b/okhttp-tests/src/test/java/okhttp3/internal/io/FaultyFileSystem.java
deleted file mode 100644
index bc0263d830..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/io/FaultyFileSystem.java
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.io;
-
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.util.LinkedHashSet;
-import java.util.Set;
-import okio.Buffer;
-import okio.ForwardingSink;
-import okio.Sink;
-import okio.Source;
-
-public final class FaultyFileSystem implements FileSystem {
-  private final FileSystem delegate;
-  private final Set<File> writeFaults = new LinkedHashSet<>();
-  private final Set<File> deleteFaults = new LinkedHashSet<>();
-  private final Set<File> renameFaults = new LinkedHashSet<>();
-
-  public FaultyFileSystem(FileSystem delegate) {
-    this.delegate = delegate;
-  }
-
-  public void setFaultyWrite(File file, boolean faulty) {
-    if (faulty) {
-      writeFaults.add(file);
-    } else {
-      writeFaults.remove(file);
-    }
-  }
-
-  public void setFaultyDelete(File file, boolean faulty) {
-    if (faulty) {
-      deleteFaults.add(file);
-    } else {
-      deleteFaults.remove(file);
-    }
-  }
-
-  public void setFaultyRename(File file, boolean faulty) {
-    if (faulty) {
-      renameFaults.add(file);
-    } else {
-      renameFaults.remove(file);
-    }
-  }
-
-  @Override public Source source(File file) throws FileNotFoundException {
-    return delegate.source(file);
-  }
-
-  @Override public Sink sink(File file) throws FileNotFoundException {
-    return new FaultySink(delegate.sink(file), file);
-  }
-
-  @Override public Sink appendingSink(File file) throws FileNotFoundException {
-    return new FaultySink(delegate.appendingSink(file), file);
-  }
-
-  @Override public void delete(File file) throws IOException {
-    if (deleteFaults.contains(file)) throw new IOException("boom!");
-    delegate.delete(file);
-  }
-
-  @Override public boolean exists(File file) {
-    return delegate.exists(file);
-  }
-
-  @Override public long size(File file) {
-    return delegate.size(file);
-  }
-
-  @Override public void rename(File from, File to) throws IOException {
-    if (renameFaults.contains(from) || renameFaults.contains(to)) throw new IOException("boom!");
-    delegate.rename(from, to);
-  }
-
-  @Override public void deleteContents(File directory) throws IOException {
-    if (deleteFaults.contains(directory)) throw new IOException("boom!");
-    delegate.deleteContents(directory);
-  }
-
-  private class FaultySink extends ForwardingSink {
-    private final File file;
-
-    public FaultySink(Sink delegate, File file) {
-      super(delegate);
-      this.file = file;
-    }
-
-    @Override public void write(Buffer source, long byteCount) throws IOException {
-      if (writeFaults.contains(file)) throw new IOException("boom!");
-      super.write(source, byteCount);
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatformTest.java b/okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatformTest.java
deleted file mode 100644
index 3d9cd3ceaa..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatformTest.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.platform;
-
-import org.junit.Test;
-
-import static okhttp3.internal.platform.PlatformTest.getPlatform;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assume.assumeTrue;
-
-public class Jdk8WithJettyBootPlatformTest {
-  @Test
-  public void testBuildsWithJettyBoot() {
-    assumeTrue(getPlatform().equals("jdk-with-jetty-boot"));
-
-    assertThat(Jdk8WithJettyBootPlatform.buildIfSupported()).isNotNull();
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java b/okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java
deleted file mode 100644
index 2881fe0e17..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.platform;
-
-import org.junit.Test;
-
-import static okhttp3.internal.platform.PlatformTest.getPlatform;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assume.assumeTrue;
-
-public class Jdk9PlatformTest {
-  @Test
-  public void buildsWhenJdk9() {
-    assumeTrue(getPlatform().equals("jdk9"));
-
-    assertThat(Jdk9Platform.buildIfSupported()).isNotNull();
-  }
-
-  @Test
-  public void findsAlpnMethods() {
-    assumeTrue(getPlatform().equals("jdk9"));
-
-    Jdk9Platform platform = Jdk9Platform.buildIfSupported();
-
-    assertThat(platform.getProtocolMethod.getName()).isEqualTo("getApplicationProtocol");
-    assertThat(platform.setProtocolMethod.getName()).isEqualTo("setApplicationProtocols");
-  }
-
-  @Test
-  public void testToStringIsClassname() {
-    assertThat(new Jdk9Platform(null, null).toString()).isEqualTo("Jdk9Platform");
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/platform/PlatformTest.java b/okhttp-tests/src/test/java/okhttp3/internal/platform/PlatformTest.java
deleted file mode 100644
index a192b8c5e4..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/platform/PlatformTest.java
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.platform;
-
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public class PlatformTest {
-  @Test public void alwaysBuilds() {
-    new Platform();
-  }
-
-  /** Guard against the default value changing by accident. */
-  @Test public void defaultPrefix() {
-    assertThat(new Platform().getPrefix()).isEqualTo("OkHttp");
-  }
-
-  public static String getPlatform() {
-    return System.getProperty("okhttp.platform", "platform");
-  }
-
-  public static String getJvmSpecVersion() {
-    return System.getProperty("java.specification.version", "unknown");
-  }
-
-  @Test
-  public void testToStringIsClassname() {
-    assertThat(new Platform().toString()).isEqualTo("Platform");
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java b/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
deleted file mode 100644
index f707064cd9..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
+++ /dev/null
@@ -1,351 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.tls;
-
-import java.security.GeneralSecurityException;
-import java.security.SecureRandom;
-import java.security.cert.X509Certificate;
-import java.util.Collections;
-import javax.net.ssl.KeyManager;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.X509KeyManager;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.Call;
-import okhttp3.CertificatePinner;
-import okhttp3.OkHttpClient;
-import okhttp3.RecordingHostnameVerifier;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.platform.Platform;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.SocketPolicy;
-import okhttp3.tls.HandshakeCertificates;
-import okhttp3.tls.HeldCertificate;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static okhttp3.TestUtil.defaultClient;
-import static okhttp3.internal.platform.PlatformTest.getJvmSpecVersion;
-import static okhttp3.internal.platform.PlatformTest.getPlatform;
-import static okhttp3.tls.internal.TlsUtil.newKeyManager;
-import static okhttp3.tls.internal.TlsUtil.newTrustManager;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-import static org.junit.Assume.assumeFalse;
-
-public final class CertificatePinnerChainValidationTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  /** The pinner should pull the root certificate from the trust manager. */
-  @Test public void pinRootNotPresentInChain() throws Exception {
-    // TODO https://github.com/square/okhttp/issues/4703
-    assumeFalse(getJvmSpecVersion().equals("11"));
-
-    HeldCertificate rootCa = new HeldCertificate.Builder()
-        .serialNumber(1L)
-        .certificateAuthority(1)
-        .commonName("root")
-        .build();
-    HeldCertificate intermediateCa = new HeldCertificate.Builder()
-        .signedBy(rootCa)
-        .certificateAuthority(0)
-        .serialNumber(2L)
-        .commonName("intermediate_ca")
-        .build();
-    HeldCertificate certificate = new HeldCertificate.Builder()
-        .signedBy(intermediateCa)
-        .serialNumber(3L)
-        .commonName(server.getHostName())
-        .build();
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(server.getHostName(), CertificatePinner.pin(rootCa.certificate()))
-        .build();
-    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
-        .addTrustedCertificate(rootCa.certificate())
-        .build();
-    OkHttpClient client = defaultClient().newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .certificatePinner(certificatePinner)
-        .build();
-
-    HandshakeCertificates serverHandshakeCertificates = new HandshakeCertificates.Builder()
-        .heldCertificate(certificate, intermediateCa.certificate())
-        .build();
-    server.useHttps(serverHandshakeCertificates.sslSocketFactory(), false);
-
-    // The request should complete successfully.
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response1 = call1.execute();
-    assertThat(response1.body().string()).isEqualTo("abc");
-
-    // Confirm that a second request also succeeds. This should detect caching problems.
-    server.enqueue(new MockResponse()
-        .setBody("def")
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response2 = call2.execute();
-    assertThat(response2.body().string()).isEqualTo("def");
-  }
-
-  /** The pinner should accept an intermediate from the server's chain. */
-  @Test public void pinIntermediatePresentInChain() throws Exception {
-    // TODO https://github.com/square/okhttp/issues/4703
-    assumeFalse(getJvmSpecVersion().equals("11"));
-
-    HeldCertificate rootCa = new HeldCertificate.Builder()
-        .serialNumber(1L)
-        .certificateAuthority(1)
-        .commonName("root")
-        .build();
-    HeldCertificate intermediateCa = new HeldCertificate.Builder()
-        .signedBy(rootCa)
-        .certificateAuthority(0)
-        .serialNumber(2L)
-        .commonName("intermediate_ca")
-        .build();
-    HeldCertificate certificate = new HeldCertificate.Builder()
-        .signedBy(intermediateCa)
-        .serialNumber(3L)
-        .commonName(server.getHostName())
-        .build();
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(server.getHostName(), CertificatePinner.pin(intermediateCa.certificate()))
-        .build();
-    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
-        .addTrustedCertificate(rootCa.certificate())
-        .build();
-    OkHttpClient client = defaultClient().newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .certificatePinner(certificatePinner)
-        .build();
-
-    HandshakeCertificates serverHandshakeCertificates = new HandshakeCertificates.Builder()
-        .heldCertificate(certificate, intermediateCa.certificate())
-        .build();
-    server.useHttps(serverHandshakeCertificates.sslSocketFactory(), false);
-
-    // The request should complete successfully.
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response1 = call1.execute();
-    assertThat(response1.body().string()).isEqualTo("abc");
-    response1.close();
-
-    // Force a fresh connection for the next request.
-    client.connectionPool().evictAll();
-
-    // Confirm that a second request also succeeds. This should detect caching problems.
-    server.enqueue(new MockResponse()
-        .setBody("def")
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response2 = call2.execute();
-    assertThat(response2.body().string()).isEqualTo("def");
-    response2.close();
-  }
-
-  @Test public void unrelatedPinnedLeafCertificateInChain() throws Exception {
-    // Start with a trusted root CA certificate.
-    HeldCertificate rootCa = new HeldCertificate.Builder()
-        .serialNumber(1L)
-        .certificateAuthority(1)
-        .commonName("root")
-        .build();
-
-    // Add a good intermediate CA, and have that issue a good certificate to localhost. Prepare an
-    // SSL context for an HTTP client under attack. It includes the trusted CA and a pinned
-    // certificate.
-    HeldCertificate goodIntermediateCa = new HeldCertificate.Builder()
-        .signedBy(rootCa)
-        .certificateAuthority(0)
-        .serialNumber(2L)
-        .commonName("good_intermediate_ca")
-        .build();
-    HeldCertificate goodCertificate = new HeldCertificate.Builder()
-        .signedBy(goodIntermediateCa)
-        .serialNumber(3L)
-        .commonName(server.getHostName())
-        .build();
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(server.getHostName(), CertificatePinner.pin(goodCertificate.certificate()))
-        .build();
-    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
-        .addTrustedCertificate(rootCa.certificate())
-        .build();
-    OkHttpClient client = defaultClient().newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .certificatePinner(certificatePinner)
-        .build();
-
-    // Add a bad intermediate CA and have that issue a rogue certificate for localhost. Prepare
-    // an SSL context for an attacking webserver. It includes both these rogue certificates plus the
-    // trusted good certificate above. The attack is that by including the good certificate in the
-    // chain, we may trick the certificate pinner into accepting the rouge certificate.
-    HeldCertificate compromisedIntermediateCa = new HeldCertificate.Builder()
-        .signedBy(rootCa)
-        .certificateAuthority(0)
-        .serialNumber(4L)
-        .commonName("bad_intermediate_ca")
-        .build();
-    HeldCertificate rogueCertificate = new HeldCertificate.Builder()
-        .serialNumber(5L)
-        .signedBy(compromisedIntermediateCa)
-        .commonName(server.getHostName())
-        .build();
-
-    SSLSocketFactory socketFactory = newServerSocketFactory(rogueCertificate,
-        compromisedIntermediateCa.certificate(), goodCertificate.certificate());
-
-    server.useHttps(socketFactory, false);
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .addHeader("Content-Type: text/plain"));
-
-    // Make a request from client to server. It should succeed certificate checks (unfortunately the
-    // rogue CA is trusted) but it should fail certificate pinning.
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Call call = client.newCall(request);
-    try {
-      call.execute();
-      fail();
-    } catch (SSLPeerUnverifiedException expected) {
-      // Certificate pinning fails!
-      String message = expected.getMessage();
-      assertThat(message).startsWith("Certificate pinning failure!");
-    }
-  }
-
-  @Test public void unrelatedPinnedIntermediateCertificateInChain() throws Exception {
-    // Start with two root CA certificates, one is good and the other is compromised.
-    HeldCertificate rootCa = new HeldCertificate.Builder()
-        .serialNumber(1L)
-        .certificateAuthority(1)
-        .commonName("root")
-        .build();
-    HeldCertificate compromisedRootCa = new HeldCertificate.Builder()
-        .serialNumber(2L)
-        .certificateAuthority(1)
-        .commonName("compromised_root")
-        .build();
-
-    // Add a good intermediate CA, and have that issue a good certificate to localhost. Prepare an
-    // SSL context for an HTTP client under attack. It includes the trusted CA and a pinned
-    // certificate.
-    HeldCertificate goodIntermediateCa = new HeldCertificate.Builder()
-        .signedBy(rootCa)
-        .certificateAuthority(0)
-        .serialNumber(3L)
-        .commonName("intermediate_ca")
-        .build();
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(server.getHostName(), CertificatePinner.pin(goodIntermediateCa.certificate()))
-        .build();
-    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
-        .addTrustedCertificate(rootCa.certificate())
-        .addTrustedCertificate(compromisedRootCa.certificate())
-        .build();
-    OkHttpClient client = defaultClient().newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .certificatePinner(certificatePinner)
-        .build();
-
-    // The attacker compromises the root CA, issues an intermediate with the same common name
-    // "intermediate_ca" as the good CA. This signs a rogue certificate for localhost. The server
-    // serves the good CAs certificate in the chain, which means the certificate pinner sees a
-    // different set of certificates than the SSL verifier.
-    HeldCertificate compromisedIntermediateCa = new HeldCertificate.Builder()
-        .signedBy(compromisedRootCa)
-        .certificateAuthority(0)
-        .serialNumber(4L)
-        .commonName("intermediate_ca")
-        .build();
-    HeldCertificate rogueCertificate = new HeldCertificate.Builder()
-        .serialNumber(5L)
-        .signedBy(compromisedIntermediateCa)
-        .commonName(server.getHostName())
-        .build();
-
-    SSLSocketFactory socketFactory = newServerSocketFactory(rogueCertificate,
-        goodIntermediateCa.certificate(), compromisedIntermediateCa.certificate());
-    server.useHttps(socketFactory, false);
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .addHeader("Content-Type: text/plain"));
-
-    // Make a request from client to server. It should succeed certificate checks (unfortunately the
-    // rogue CA is trusted) but it should fail certificate pinning.
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Call call = client.newCall(request);
-    try {
-      call.execute();
-      fail();
-    } catch (SSLHandshakeException expected) {
-      // On Android, the handshake fails before the certificate pinner runs.
-      String message = expected.getMessage();
-      assertThat(message).contains("Could not validate certificate");
-    } catch (SSLPeerUnverifiedException expected) {
-      // On OpenJDK, the handshake succeeds but the certificate pinner fails.
-      String message = expected.getMessage();
-      assertThat(message).startsWith("Certificate pinning failure!");
-    }
-  }
-
-  private SSLSocketFactory newServerSocketFactory(HeldCertificate heldCertificate,
-      X509Certificate... intermediates) throws GeneralSecurityException {
-    // Test setup fails on JDK9
-    // java.security.KeyStoreException: Certificate chain is not valid
-    // at sun.security.pkcs12.PKCS12KeyStore.setKeyEntry
-    // http://openjdk.java.net/jeps/229
-    // http://hg.openjdk.java.net/jdk9/jdk9/jdk/file/2c1c21d11e58/src/share/classes/sun/security/pkcs12/PKCS12KeyStore.java#l596
-    String keystoreType = getPlatform().equals("jdk9") ? "JKS" : null;
-    X509KeyManager x509KeyManager = newKeyManager(keystoreType, heldCertificate, intermediates);
-    X509TrustManager trustManager = newTrustManager(keystoreType, Collections.emptyList());
-    SSLContext sslContext = Platform.get().getSSLContext();
-    sslContext.init(new KeyManager[] { x509KeyManager }, new TrustManager[] { trustManager },
-        new SecureRandom());
-    return sslContext.getSocketFactory();
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java b/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
deleted file mode 100644
index 252333bbae..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
+++ /dev/null
@@ -1,293 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.tls;
-
-import java.net.SocketException;
-import java.security.GeneralSecurityException;
-import java.security.SecureRandom;
-import java.security.cert.X509Certificate;
-import java.util.Arrays;
-import javax.net.ssl.KeyManager;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLException;
-import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.X509KeyManager;
-import javax.net.ssl.X509TrustManager;
-import javax.security.auth.x500.X500Principal;
-import okhttp3.Call;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.tls.HandshakeCertificates;
-import okhttp3.tls.HeldCertificate;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static okhttp3.TestUtil.defaultClient;
-import static okhttp3.internal.platform.PlatformTest.getJvmSpecVersion;
-import static okhttp3.internal.platform.PlatformTest.getPlatform;
-import static okhttp3.tls.internal.TlsUtil.newKeyManager;
-import static okhttp3.tls.internal.TlsUtil.newTrustManager;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-import static org.junit.Assume.assumeFalse;
-
-public final class ClientAuthTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  private HeldCertificate serverRootCa;
-  private HeldCertificate serverIntermediateCa;
-  private HeldCertificate serverCert;
-  private HeldCertificate clientRootCa;
-  private HeldCertificate clientIntermediateCa;
-  private HeldCertificate clientCert;
-
-  @Before
-  public void setUp() {
-    serverRootCa = new HeldCertificate.Builder()
-        .serialNumber(1L)
-        .certificateAuthority(1)
-        .commonName("root")
-        .addSubjectAlternativeName("root_ca.com")
-        .build();
-    serverIntermediateCa = new HeldCertificate.Builder()
-        .signedBy(serverRootCa)
-        .certificateAuthority(0)
-        .serialNumber(2L)
-        .commonName("intermediate_ca")
-        .addSubjectAlternativeName("intermediate_ca.com")
-        .build();
-
-    serverCert = new HeldCertificate.Builder()
-        .signedBy(serverIntermediateCa)
-        .serialNumber(3L)
-        .commonName("Local Host")
-        .addSubjectAlternativeName(server.getHostName())
-        .build();
-
-    clientRootCa = new HeldCertificate.Builder()
-        .serialNumber(1L)
-        .certificateAuthority(1)
-        .commonName("root")
-        .addSubjectAlternativeName("root_ca.com")
-        .build();
-    clientIntermediateCa = new HeldCertificate.Builder()
-        .signedBy(serverRootCa)
-        .certificateAuthority(0)
-        .serialNumber(2L)
-        .commonName("intermediate_ca")
-        .addSubjectAlternativeName("intermediate_ca.com")
-        .build();
-
-    clientCert = new HeldCertificate.Builder()
-        .signedBy(clientIntermediateCa)
-        .serialNumber(4L)
-        .commonName("Jethro Willis")
-        .addSubjectAlternativeName("jethrowillis.com")
-        .build();
-  }
-
-  @Test public void clientAuthForWants() throws Exception {
-    OkHttpClient client = buildClient(clientCert, clientIntermediateCa.certificate());
-
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
-
-    server.useHttps(socketFactory, false);
-    server.requestClientAuth();
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
-    Response response = call.execute();
-    assertThat(response.handshake().peerPrincipal()).isEqualTo(
-        new X500Principal("CN=Local Host"));
-    assertThat(response.handshake().localPrincipal()).isEqualTo(
-        new X500Principal("CN=Jethro Willis"));
-    assertThat(response.body().string()).isEqualTo("abc");
-  }
-
-  @Test public void clientAuthForNeeds() throws Exception {
-    OkHttpClient client = buildClient(clientCert, clientIntermediateCa.certificate());
-
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
-
-    server.useHttps(socketFactory, false);
-    server.requireClientAuth();
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
-    Response response = call.execute();
-    assertThat(response.handshake().peerPrincipal()).isEqualTo(
-        new X500Principal("CN=Local Host"));
-    assertThat(response.handshake().localPrincipal()).isEqualTo(
-        new X500Principal("CN=Jethro Willis"));
-    assertThat(response.body().string()).isEqualTo("abc");
-  }
-
-  @Test public void clientAuthSkippedForNone() throws Exception {
-    OkHttpClient client = buildClient(clientCert, clientIntermediateCa.certificate());
-
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
-
-    server.useHttps(socketFactory, false);
-    server.noClientAuth();
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
-    Response response = call.execute();
-    assertThat(response.handshake().peerPrincipal()).isEqualTo(
-        new X500Principal("CN=Local Host"));
-    assertThat(response.handshake().localPrincipal()).isNull();
-    assertThat(response.body().string()).isEqualTo("abc");
-  }
-
-  @Test public void missingClientAuthSkippedForWantsOnly() throws Exception {
-    OkHttpClient client = buildClient(null, clientIntermediateCa.certificate());
-
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
-
-    server.useHttps(socketFactory, false);
-    server.requestClientAuth();
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
-    Response response = call.execute();
-    assertThat(response.handshake().peerPrincipal()).isEqualTo(
-        new X500Principal("CN=Local Host"));
-    assertThat(response.handshake().localPrincipal()).isNull();
-    assertThat(response.body().string()).isEqualTo("abc");
-  }
-
-  @Test public void missingClientAuthFailsForNeeds() throws Exception {
-    // TODO https://github.com/square/okhttp/issues/4598
-    // StreamReset stream was reset: PROT...
-    assumeFalse(getJvmSpecVersion().equals("11"));
-
-    OkHttpClient client = buildClient(null, clientIntermediateCa.certificate());
-
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
-
-    server.useHttps(socketFactory, false);
-    server.requireClientAuth();
-
-    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
-
-    try {
-      call.execute();
-      fail();
-    } catch (SSLHandshakeException expected) {
-    } catch (SSLException expected) {
-      String jvmVersion = System.getProperty("java.specification.version");
-      assertThat(jvmVersion).isEqualTo("11");
-    } catch (SocketException expected) {
-      assertThat(getPlatform()).isEqualTo("jdk9");
-    }
-  }
-
-  @Test public void commonNameIsNotTrusted() throws Exception {
-    serverCert = new HeldCertificate.Builder()
-        .signedBy(serverIntermediateCa)
-        .serialNumber(3L)
-        .commonName(server.getHostName())
-        .addSubjectAlternativeName("different-host.com")
-        .build();
-
-    OkHttpClient client = buildClient(clientCert, clientIntermediateCa.certificate());
-
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
-
-    server.useHttps(socketFactory, false);
-    server.requireClientAuth();
-
-    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
-
-    try {
-      call.execute();
-      fail();
-    } catch (SSLPeerUnverifiedException expected) {
-    }
-  }
-
-  @Test public void invalidClientAuthFails() throws Throwable {
-    // TODO https://github.com/square/okhttp/issues/4598
-    // StreamReset stream was reset: PROT...
-    assumeFalse(getJvmSpecVersion().equals("11"));
-
-    HeldCertificate clientCert2 = new HeldCertificate.Builder()
-        .serialNumber(4L)
-        .commonName("Jethro Willis")
-        .build();
-
-    OkHttpClient client = buildClient(clientCert2);
-
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
-
-    server.useHttps(socketFactory, false);
-    server.requireClientAuth();
-
-    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
-
-    try {
-      call.execute();
-      fail();
-    } catch (SSLHandshakeException expected) {
-    } catch (SSLException expected) {
-      // javax.net.ssl.SSLException: readRecord
-      String jvmVersion = System.getProperty("java.specification.version");
-      assertThat(jvmVersion).isEqualTo("11");
-    } catch (SocketException expected) {
-      assertThat(getPlatform()).isEqualTo("jdk9");
-    }
-  }
-
-  private OkHttpClient buildClient(
-      HeldCertificate heldCertificate, X509Certificate... intermediates) {
-    HandshakeCertificates.Builder builder = new HandshakeCertificates.Builder()
-        .addTrustedCertificate(serverRootCa.certificate());
-
-    if (heldCertificate != null) {
-      builder.heldCertificate(heldCertificate, intermediates);
-    }
-
-    HandshakeCertificates handshakeCertificates = builder.build();
-    return defaultClient().newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .build();
-  }
-
-  private SSLSocketFactory buildServerSslSocketFactory() {
-    // The test uses JDK default SSL Context instead of the Platform provided one
-    // as Conscrypt seems to have some differences, we only want to test client side here.
-    try {
-      X509KeyManager keyManager = newKeyManager(
-          null, serverCert, serverIntermediateCa.certificate());
-      X509TrustManager trustManager = newTrustManager(
-          null, Arrays.asList(serverRootCa.certificate(), clientRootCa.certificate()));
-      SSLContext sslContext = SSLContext.getInstance("TLS");
-      sslContext.init(new KeyManager[] {keyManager}, new TrustManager[] {trustManager},
-          new SecureRandom());
-      return sslContext.getSocketFactory();
-    } catch (GeneralSecurityException e) {
-      throw new AssertionError(e);
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/DistinguishedNameParserTest.java b/okhttp-tests/src/test/java/okhttp3/internal/tls/DistinguishedNameParserTest.java
deleted file mode 100644
index 099b8982b0..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/tls/DistinguishedNameParserTest.java
+++ /dev/null
@@ -1,135 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.tls;
-
-
-import javax.security.auth.x500.X500Principal;
-
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class DistinguishedNameParserTest {
-  @Test public void regularCases() {
-    assertCn("xxx", "ou=xxx,cn=xxx");
-    assertCn("yyy", "ou=xxx+cn=yyy,cn=zzz+cn=abc");
-    assertCn("a", "cn=a,cn=b");
-    assertCn("a   c", "cn=a   c,cn=b");
-    assertCn("Cc", "cn=Cc,cn=Bb,cn=Aa");
-    assertCn("imap.gmail.com", "cn=imap.gmail.com");
-    assertCn("c", "l=\"abcn=a,b\", cn=c");
-    assertCn("c", "l=\"abcn=a,b\", cn=c");
-    assertCn("c", "l=\"abcn=a,b\", cn= c");
-    assertCn("a b", "cn=a b");
-    assertCn("a b", "cn   =a b");
-    assertCn("a b", "Cn=a b");
-    assertCn("a b", "cN=a b");
-    assertCn("a b", "CN=a b");
-    assertCn("a#b", "cn=a#b");
-    assertCn("a", "cn=#130161");
-    assertCn("p", "l=q\t+cn=p");
-    assertCn("p", "l=q\n+cn=p");
-    assertCn("p", "l=q\n,cn=p");
-    assertCn("p", "l=,cn=p");
-    assertCn("\tp", "l=\tq\n,cn=\tp");
-  }
-
-  @Test public void emptyValues() {
-    assertCn(null, "");
-    assertCn(null, "ou=xxx");
-    assertCn("", "l=,cn=+cn=q");
-    assertCn("", "l=,cn=,cn=q");
-    assertCn(null, "l=,cn=");
-    assertCn("q", "l=,cn=q,cn=   ");
-    assertCn("q", "l=,cn=q  ,cn=   ");
-    assertCn(null, "l=,cn=\"\"");
-    assertCn("", "l=,cn=  ,cn=  ");
-    assertCn("", "l=,cn=,cn=  ,cn=  ");
-  }
-
-  @Test public void escapedChars() {
-    assertCn(",", "cn=\\,");
-    assertCn("#", "cn=\\#");
-    assertCn("+", "cn=\\+");
-    assertCn("\"", "cn=\\\"");
-    assertCn("\\", "cn=\\\\");
-    assertCn("<", "cn=\\<");
-    assertCn(">", "cn=\\>");
-    assertCn(";", "cn=\\;");
-    assertCn("+", "cn=\\+");
-    assertCn("+", "cn=\"\\+\"");
-    assertCn(",", "cn=\"\\,\"");
-    assertCn("a =", "cn= a =");
-    assertCn("=", "cn==");
-  }
-
-  @Test public void whitespace() {
-    assertCn("p", "cn= p");
-    assertCn("p", "cn=\np");
-    assertCn("\tp", "cn=\tp");
-  }
-
-  @Test public void withOid() {
-    assertCn("a", "2.5.4.3=a,ou=xxx");
-    assertCn("a", "2.5.4.3=\" a \",ou=xxx");
-    assertCn("b", "2.5.5.3=a,ou=xxx,cn=b");
-  }
-
-  @Test public void quotedStrings() {
-    assertCn("\" a ,=<>#;", "cn=\"\\\" a ,=<>#;\"");
-    assertCn("abc,def", "cn=abc\\,def");
-    assertCn("\" a ,=<>#;", "cn=\"\\\" a ,\\=<>\\#;\"");
-  }
-
-  @Test public void utf8() {
-    assertCn("\u004c\u0075\u010d\u0069\u0107", "cn=\"Lu\\C4\\8Di\\C4\\87\"");
-    assertCn("\u004c\u0075\u010d\u0069\u0107", "cn=Lu\\C4\\8Di\\C4\\87");
-    assertCn("\u004c\u0075\u010d\u0069\u0107", "cn=Lu\\C4\\8di\\c4\\87");
-    assertCn("\u004c\u0075\u010d\u0069\u0107", "cn=\"Lu\\C4\\8di\\c4\\87\"");
-    assertCn("\u004c\u0075\u010d\u0069\u0107", "cn=\u004c\u0075\u010d\u0069\u0107");
-    // \63=c
-    expectExceptionInPrincipal("\\63n=ab");
-    expectExceptionInPrincipal("cn=\\a");
-  }
-
-  @Test public void trailingWhitespace() {
-    assertCn("a  b", "ou=a, cn=  a  b  ,o=x");
-    assertCn("a  b", "cn=\"  a  b  \" ,o=x");
-    assertCn("a", "cn=a   ,cn=b");
-    assertCn("", "l=,cn=\"  \",cn=\"  \"");
-  }
-
-  /**
-   * @param expected the value of the first "cn=" argument in {@code dn},
-   *                 or null if none is expected
-   */
-  private void assertCn(String expected, String dn) {
-    X500Principal principal = new X500Principal(dn);
-    DistinguishedNameParser parser = new DistinguishedNameParser(principal);
-    assertThat(parser.findMostSpecific("cn")).overridingErrorMessage(dn).isEqualTo(
-        expected);
-  }
-
-  private void expectExceptionInPrincipal(String dn) {
-    try {
-      new X500Principal(dn);
-      fail("Expected " + IllegalArgumentException.class.getName()
-          + " because of incorrect input name");
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java b/okhttp-tests/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java
deleted file mode 100644
index 9a878f1c41..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java
+++ /dev/null
@@ -1,553 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements. See the NOTICE file distributed with this
- * work for additional information regarding copyright ownership. The ASF
- * licenses this file to You under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations under
- * the License.
- */
-
-package okhttp3.internal.tls;
-
-import java.io.ByteArrayInputStream;
-import java.security.cert.CertificateFactory;
-import java.security.cert.X509Certificate;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLSession;
-import javax.security.auth.x500.X500Principal;
-import okhttp3.FakeSSLSession;
-import okhttp3.internal.Util;
-import org.junit.Ignore;
-import org.junit.Test;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.assertj.core.api.Assertions.assertThat;
-
-/**
- * Tests for our hostname verifier. Most of these tests are from AOSP, which itself includes tests
- * from the Apache HTTP Client test suite.
- */
-public final class HostnameVerifierTest {
-  private HostnameVerifier verifier = OkHostnameVerifier.INSTANCE;
-
-  @Test public void verify() throws Exception {
-    FakeSSLSession session = new FakeSSLSession();
-    assertThat(verifier.verify("localhost", session)).isFalse();
-  }
-
-  @Test public void verifyCn() throws Exception {
-    // CN=foo.com
-    SSLSession session = session(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIERjCCAy6gAwIBAgIJAIz+EYMBU6aQMA0GCSqGSIb3DQEBBQUAMIGiMQswCQYD\n"
-        + "VQQGEwJDQTELMAkGA1UECBMCQkMxEjAQBgNVBAcTCVZhbmNvdXZlcjEWMBQGA1UE\n"
-        + "ChMNd3d3LmN1Y2JjLmNvbTEUMBIGA1UECxQLY29tbW9uc19zc2wxHTAbBgNVBAMU\n"
-        + "FGRlbW9faW50ZXJtZWRpYXRlX2NhMSUwIwYJKoZIhvcNAQkBFhZqdWxpdXNkYXZp\n"
-        + "ZXNAZ21haWwuY29tMB4XDTA2MTIxMTE1MzE0MVoXDTI4MTEwNTE1MzE0MVowgaQx\n"
-        + "CzAJBgNVBAYTAlVTMREwDwYDVQQIEwhNYXJ5bGFuZDEUMBIGA1UEBxMLRm9yZXN0\n"
-        + "IEhpbGwxFzAVBgNVBAoTDmh0dHBjb21wb25lbnRzMRowGAYDVQQLExF0ZXN0IGNl\n"
-        + "cnRpZmljYXRlczEQMA4GA1UEAxMHZm9vLmNvbTElMCMGCSqGSIb3DQEJARYWanVs\n"
-        + "aXVzZGF2aWVzQGdtYWlsLmNvbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC\n"
-        + "ggEBAMhjr5aCPoyp0R1iroWAfnEyBMGYWoCidH96yGPFjYLowez5aYKY1IOKTY2B\n"
-        + "lYho4O84X244QrZTRl8kQbYtxnGh4gSCD+Z8gjZ/gMvLUlhqOb+WXPAUHMB39GRy\n"
-        + "zerA/ZtrlUqf+lKo0uWcocxeRc771KN8cPH3nHZ0rV0Hx4ZAZy6U4xxObe4rtSVY\n"
-        + "07hNKXAb2odnVqgzcYiDkLV8ilvEmoNWMWrp8UBqkTcpEhYhCYp3cTkgJwMSuqv8\n"
-        + "BqnGd87xQU3FVZI4tbtkB+KzjD9zz8QCDJAfDjZHR03KNQ5mxOgXwxwKw6lGMaiV\n"
-        + "JTxpTKqym93whYk93l3ocEe55c0CAwEAAaN7MHkwCQYDVR0TBAIwADAsBglghkgB\n"
-        + "hvhCAQ0EHxYdT3BlblNTTCBHZW5lcmF0ZWQgQ2VydGlmaWNhdGUwHQYDVR0OBBYE\n"
-        + "FJ8Ud78/OrbKOIJCSBYs2tDLXofYMB8GA1UdIwQYMBaAFHua2o+QmU5S0qzbswNS\n"
-        + "yoemDT4NMA0GCSqGSIb3DQEBBQUAA4IBAQC3jRmEya6sQCkmieULcvx8zz1euCk9\n"
-        + "fSez7BEtki8+dmfMXe3K7sH0lI8f4jJR0rbSCjpmCQLYmzC3NxBKeJOW0RcjNBpO\n"
-        + "c2JlGO9auXv2GDP4IYiXElLJ6VSqc8WvDikv0JmCCWm0Zga+bZbR/EWN5DeEtFdF\n"
-        + "815CLpJZNcYwiYwGy/CVQ7w2TnXlG+mraZOz+owr+cL6J/ZesbdEWfjoS1+cUEhE\n"
-        + "HwlNrAu8jlZ2UqSgskSWlhYdMTAP9CPHiUv9N7FcT58Itv/I4fKREINQYjDpvQcx\n"
-        + "SaTYb9dr5sB4WLNglk7zxDtM80H518VvihTcP7FHL+Gn6g4j5fkI98+S\n"
-        + "-----END CERTIFICATE-----\n");
-    assertThat(verifier.verify("foo.com", session)).isFalse();
-    assertThat(verifier.verify("a.foo.com", session)).isFalse();
-    assertThat(verifier.verify("bar.com", session)).isFalse();
-  }
-
-  @Test public void verifyNonAsciiCn() throws Exception {
-    // CN=&#x82b1;&#x5b50;.co.jp
-    SSLSession session = session(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIESzCCAzOgAwIBAgIJAIz+EYMBU6aTMA0GCSqGSIb3DQEBBQUAMIGiMQswCQYD\n"
-        + "VQQGEwJDQTELMAkGA1UECBMCQkMxEjAQBgNVBAcTCVZhbmNvdXZlcjEWMBQGA1UE\n"
-        + "ChMNd3d3LmN1Y2JjLmNvbTEUMBIGA1UECxQLY29tbW9uc19zc2wxHTAbBgNVBAMU\n"
-        + "FGRlbW9faW50ZXJtZWRpYXRlX2NhMSUwIwYJKoZIhvcNAQkBFhZqdWxpdXNkYXZp\n"
-        + "ZXNAZ21haWwuY29tMB4XDTA2MTIxMTE1NDIxNVoXDTI4MTEwNTE1NDIxNVowgakx\n"
-        + "CzAJBgNVBAYTAlVTMREwDwYDVQQIDAhNYXJ5bGFuZDEUMBIGA1UEBwwLRm9yZXN0\n"
-        + "IEhpbGwxFzAVBgNVBAoMDmh0dHBjb21wb25lbnRzMRowGAYDVQQLDBF0ZXN0IGNl\n"
-        + "cnRpZmljYXRlczEVMBMGA1UEAwwM6Iqx5a2QLmNvLmpwMSUwIwYJKoZIhvcNAQkB\n"
-        + "FhZqdWxpdXNkYXZpZXNAZ21haWwuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A\n"
-        + "MIIBCgKCAQEAyGOvloI+jKnRHWKuhYB+cTIEwZhagKJ0f3rIY8WNgujB7PlpgpjU\n"
-        + "g4pNjYGViGjg7zhfbjhCtlNGXyRBti3GcaHiBIIP5nyCNn+Ay8tSWGo5v5Zc8BQc\n"
-        + "wHf0ZHLN6sD9m2uVSp/6UqjS5ZyhzF5FzvvUo3xw8fecdnStXQfHhkBnLpTjHE5t\n"
-        + "7iu1JVjTuE0pcBvah2dWqDNxiIOQtXyKW8Sag1YxaunxQGqRNykSFiEJindxOSAn\n"
-        + "AxK6q/wGqcZ3zvFBTcVVkji1u2QH4rOMP3PPxAIMkB8ONkdHTco1DmbE6BfDHArD\n"
-        + "qUYxqJUlPGlMqrKb3fCFiT3eXehwR7nlzQIDAQABo3sweTAJBgNVHRMEAjAAMCwG\n"
-        + "CWCGSAGG+EIBDQQfFh1PcGVuU1NMIEdlbmVyYXRlZCBDZXJ0aWZpY2F0ZTAdBgNV\n"
-        + "HQ4EFgQUnxR3vz86tso4gkJIFiza0Mteh9gwHwYDVR0jBBgwFoAUe5raj5CZTlLS\n"
-        + "rNuzA1LKh6YNPg0wDQYJKoZIhvcNAQEFBQADggEBALJ27i3okV/KvlDp6KMID3gd\n"
-        + "ITl68PyItzzx+SquF8gahMh016NX73z/oVZoVUNdftla8wPUB1GwIkAnGkhQ9LHK\n"
-        + "spBdbRiCj0gMmLCsX8SrjFvr7cYb2cK6J/fJe92l1tg/7Y4o7V/s4JBe/cy9U9w8\n"
-        + "a0ctuDmEBCgC784JMDtT67klRfr/2LlqWhlOEq7pUFxRLbhpquaAHSOjmIcWnVpw\n"
-        + "9BsO7qe46hidgn39hKh1WjKK2VcL/3YRsC4wUi0PBtFW6ScMCuMhgIRXSPU55Rae\n"
-        + "UIlOdPjjr1SUNWGId1rD7W16Scpwnknn310FNxFMHVI0GTGFkNdkilNCFJcIoRA=\n"
-        + "-----END CERTIFICATE-----\n");
-    assertThat(verifier.verify("\u82b1\u5b50.co.jp", session)).isFalse();
-    assertThat(verifier.verify("a.\u82b1\u5b50.co.jp", session)).isFalse();
-  }
-
-  @Test public void verifySubjectAlt() throws Exception {
-    // CN=foo.com, subjectAlt=bar.com
-    SSLSession session = session(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIEXDCCA0SgAwIBAgIJAIz+EYMBU6aRMA0GCSqGSIb3DQEBBQUAMIGiMQswCQYD\n"
-        + "VQQGEwJDQTELMAkGA1UECBMCQkMxEjAQBgNVBAcTCVZhbmNvdXZlcjEWMBQGA1UE\n"
-        + "ChMNd3d3LmN1Y2JjLmNvbTEUMBIGA1UECxQLY29tbW9uc19zc2wxHTAbBgNVBAMU\n"
-        + "FGRlbW9faW50ZXJtZWRpYXRlX2NhMSUwIwYJKoZIhvcNAQkBFhZqdWxpdXNkYXZp\n"
-        + "ZXNAZ21haWwuY29tMB4XDTA2MTIxMTE1MzYyOVoXDTI4MTEwNTE1MzYyOVowgaQx\n"
-        + "CzAJBgNVBAYTAlVTMREwDwYDVQQIEwhNYXJ5bGFuZDEUMBIGA1UEBxMLRm9yZXN0\n"
-        + "IEhpbGwxFzAVBgNVBAoTDmh0dHBjb21wb25lbnRzMRowGAYDVQQLExF0ZXN0IGNl\n"
-        + "cnRpZmljYXRlczEQMA4GA1UEAxMHZm9vLmNvbTElMCMGCSqGSIb3DQEJARYWanVs\n"
-        + "aXVzZGF2aWVzQGdtYWlsLmNvbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC\n"
-        + "ggEBAMhjr5aCPoyp0R1iroWAfnEyBMGYWoCidH96yGPFjYLowez5aYKY1IOKTY2B\n"
-        + "lYho4O84X244QrZTRl8kQbYtxnGh4gSCD+Z8gjZ/gMvLUlhqOb+WXPAUHMB39GRy\n"
-        + "zerA/ZtrlUqf+lKo0uWcocxeRc771KN8cPH3nHZ0rV0Hx4ZAZy6U4xxObe4rtSVY\n"
-        + "07hNKXAb2odnVqgzcYiDkLV8ilvEmoNWMWrp8UBqkTcpEhYhCYp3cTkgJwMSuqv8\n"
-        + "BqnGd87xQU3FVZI4tbtkB+KzjD9zz8QCDJAfDjZHR03KNQ5mxOgXwxwKw6lGMaiV\n"
-        + "JTxpTKqym93whYk93l3ocEe55c0CAwEAAaOBkDCBjTAJBgNVHRMEAjAAMCwGCWCG\n"
-        + "SAGG+EIBDQQfFh1PcGVuU1NMIEdlbmVyYXRlZCBDZXJ0aWZpY2F0ZTAdBgNVHQ4E\n"
-        + "FgQUnxR3vz86tso4gkJIFiza0Mteh9gwHwYDVR0jBBgwFoAUe5raj5CZTlLSrNuz\n"
-        + "A1LKh6YNPg0wEgYDVR0RBAswCYIHYmFyLmNvbTANBgkqhkiG9w0BAQUFAAOCAQEA\n"
-        + "dQyprNZBmVnvuVWjV42sey/PTfkYShJwy1j0/jcFZR/ypZUovpiHGDO1DgL3Y3IP\n"
-        + "zVQ26uhUsSw6G0gGRiaBDe/0LUclXZoJzXX1qpS55OadxW73brziS0sxRgGrZE/d\n"
-        + "3g5kkio6IED47OP6wYnlmZ7EKP9cqjWwlnvHnnUcZ2SscoLNYs9rN9ccp8tuq2by\n"
-        + "88OyhKwGjJfhOudqfTNZcDzRHx4Fzm7UsVaycVw4uDmhEHJrAsmMPpj/+XRK9/42\n"
-        + "2xq+8bc6HojdtbCyug/fvBZvZqQXSmU8m8IVcMmWMz0ZQO8ee3QkBHMZfCy7P/kr\n"
-        + "VbWx/uETImUu+NZg22ewEw==\n"
-        + "-----END CERTIFICATE-----\n");
-    assertThat(verifier.verify("foo.com", session)).isFalse();
-    assertThat(verifier.verify("a.foo.com", session)).isFalse();
-    assertThat(verifier.verify("bar.com", session)).isTrue();
-    assertThat(verifier.verify("a.bar.com", session)).isFalse();
-  }
-
-  /**
-   * Ignored due to incompatibilities between Android and Java on how non-ASCII subject alt names
-   * are parsed. Android fails to parse these, which means we fall back to the CN. The RI does parse
-   * them, so the CN is unused.
-   */
-  @Test @Ignore public void verifyNonAsciiSubjectAlt() throws Exception {
-    // CN=foo.com, subjectAlt=bar.com, subjectAlt=&#x82b1;&#x5b50;.co.jp
-    // (hanako.co.jp in kanji)
-    SSLSession session = session(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIEajCCA1KgAwIBAgIJAIz+EYMBU6aSMA0GCSqGSIb3DQEBBQUAMIGiMQswCQYD\n"
-        + "VQQGEwJDQTELMAkGA1UECBMCQkMxEjAQBgNVBAcTCVZhbmNvdXZlcjEWMBQGA1UE\n"
-        + "ChMNd3d3LmN1Y2JjLmNvbTEUMBIGA1UECxQLY29tbW9uc19zc2wxHTAbBgNVBAMU\n"
-        + "FGRlbW9faW50ZXJtZWRpYXRlX2NhMSUwIwYJKoZIhvcNAQkBFhZqdWxpdXNkYXZp\n"
-        + "ZXNAZ21haWwuY29tMB4XDTA2MTIxMTE1MzgxM1oXDTI4MTEwNTE1MzgxM1owgaQx\n"
-        + "CzAJBgNVBAYTAlVTMREwDwYDVQQIEwhNYXJ5bGFuZDEUMBIGA1UEBxMLRm9yZXN0\n"
-        + "IEhpbGwxFzAVBgNVBAoTDmh0dHBjb21wb25lbnRzMRowGAYDVQQLExF0ZXN0IGNl\n"
-        + "cnRpZmljYXRlczEQMA4GA1UEAxMHZm9vLmNvbTElMCMGCSqGSIb3DQEJARYWanVs\n"
-        + "aXVzZGF2aWVzQGdtYWlsLmNvbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC\n"
-        + "ggEBAMhjr5aCPoyp0R1iroWAfnEyBMGYWoCidH96yGPFjYLowez5aYKY1IOKTY2B\n"
-        + "lYho4O84X244QrZTRl8kQbYtxnGh4gSCD+Z8gjZ/gMvLUlhqOb+WXPAUHMB39GRy\n"
-        + "zerA/ZtrlUqf+lKo0uWcocxeRc771KN8cPH3nHZ0rV0Hx4ZAZy6U4xxObe4rtSVY\n"
-        + "07hNKXAb2odnVqgzcYiDkLV8ilvEmoNWMWrp8UBqkTcpEhYhCYp3cTkgJwMSuqv8\n"
-        + "BqnGd87xQU3FVZI4tbtkB+KzjD9zz8QCDJAfDjZHR03KNQ5mxOgXwxwKw6lGMaiV\n"
-        + "JTxpTKqym93whYk93l3ocEe55c0CAwEAAaOBnjCBmzAJBgNVHRMEAjAAMCwGCWCG\n"
-        + "SAGG+EIBDQQfFh1PcGVuU1NMIEdlbmVyYXRlZCBDZXJ0aWZpY2F0ZTAdBgNVHQ4E\n"
-        + "FgQUnxR3vz86tso4gkJIFiza0Mteh9gwHwYDVR0jBBgwFoAUe5raj5CZTlLSrNuz\n"
-        + "A1LKh6YNPg0wIAYDVR0RBBkwF4IHYmFyLmNvbYIM6Iqx5a2QLmNvLmpwMA0GCSqG\n"
-        + "SIb3DQEBBQUAA4IBAQBeZs7ZIYyKtdnVxVvdLgwySEPOE4pBSXii7XYv0Q9QUvG/\n"
-        + "++gFGQh89HhABzA1mVUjH5dJTQqSLFvRfqTHqLpxSxSWqMHnvRM4cPBkIRp/XlMK\n"
-        + "PlXadYtJLPTgpbgvulA1ickC9EwlNYWnowZ4uxnfsMghW4HskBqaV+PnQ8Zvy3L0\n"
-        + "12c7Cg4mKKS5pb1HdRuiD2opZ+Hc77gRQLvtWNS8jQvd/iTbh6fuvTKfAOFoXw22\n"
-        + "sWIKHYrmhCIRshUNohGXv50m2o+1w9oWmQ6Dkq7lCjfXfUB4wIbggJjpyEtbNqBt\n"
-        + "j4MC2x5rfsLKKqToKmNE7pFEgqwe8//Aar1b+Qj+\n"
-        + "-----END CERTIFICATE-----\n");
-    assertThat(verifier.verify("foo.com", session)).isTrue();
-    assertThat(verifier.verify("a.foo.com", session)).isFalse();
-    // these checks test alternative subjects. The test data contains an
-    // alternative subject starting with a japanese kanji character. This is
-    // not supported by Android because the underlying implementation from
-    // harmony follows the definition from rfc 1034 page 10 for alternative
-    // subject names. This causes the code to drop all alternative subjects.
-    // assertTrue(verifier.verify("bar.com", session));
-    // assertFalse(verifier.verify("a.bar.com", session));
-    // assertFalse(verifier.verify("a.\u82b1\u5b50.co.jp", session));
-  }
-
-  @Test public void verifySubjectAltOnly() throws Exception {
-    // subjectAlt=foo.com
-    SSLSession session = session(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIESjCCAzKgAwIBAgIJAIz+EYMBU6aYMA0GCSqGSIb3DQEBBQUAMIGiMQswCQYD\n"
-        + "VQQGEwJDQTELMAkGA1UECBMCQkMxEjAQBgNVBAcTCVZhbmNvdXZlcjEWMBQGA1UE\n"
-        + "ChMNd3d3LmN1Y2JjLmNvbTEUMBIGA1UECxQLY29tbW9uc19zc2wxHTAbBgNVBAMU\n"
-        + "FGRlbW9faW50ZXJtZWRpYXRlX2NhMSUwIwYJKoZIhvcNAQkBFhZqdWxpdXNkYXZp\n"
-        + "ZXNAZ21haWwuY29tMB4XDTA2MTIxMTE2MjYxMFoXDTI4MTEwNTE2MjYxMFowgZIx\n"
-        + "CzAJBgNVBAYTAlVTMREwDwYDVQQIDAhNYXJ5bGFuZDEUMBIGA1UEBwwLRm9yZXN0\n"
-        + "IEhpbGwxFzAVBgNVBAoMDmh0dHBjb21wb25lbnRzMRowGAYDVQQLDBF0ZXN0IGNl\n"
-        + "cnRpZmljYXRlczElMCMGCSqGSIb3DQEJARYWanVsaXVzZGF2aWVzQGdtYWlsLmNv\n"
-        + "bTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMhjr5aCPoyp0R1iroWA\n"
-        + "fnEyBMGYWoCidH96yGPFjYLowez5aYKY1IOKTY2BlYho4O84X244QrZTRl8kQbYt\n"
-        + "xnGh4gSCD+Z8gjZ/gMvLUlhqOb+WXPAUHMB39GRyzerA/ZtrlUqf+lKo0uWcocxe\n"
-        + "Rc771KN8cPH3nHZ0rV0Hx4ZAZy6U4xxObe4rtSVY07hNKXAb2odnVqgzcYiDkLV8\n"
-        + "ilvEmoNWMWrp8UBqkTcpEhYhCYp3cTkgJwMSuqv8BqnGd87xQU3FVZI4tbtkB+Kz\n"
-        + "jD9zz8QCDJAfDjZHR03KNQ5mxOgXwxwKw6lGMaiVJTxpTKqym93whYk93l3ocEe5\n"
-        + "5c0CAwEAAaOBkDCBjTAJBgNVHRMEAjAAMCwGCWCGSAGG+EIBDQQfFh1PcGVuU1NM\n"
-        + "IEdlbmVyYXRlZCBDZXJ0aWZpY2F0ZTAdBgNVHQ4EFgQUnxR3vz86tso4gkJIFiza\n"
-        + "0Mteh9gwHwYDVR0jBBgwFoAUe5raj5CZTlLSrNuzA1LKh6YNPg0wEgYDVR0RBAsw\n"
-        + "CYIHZm9vLmNvbTANBgkqhkiG9w0BAQUFAAOCAQEAjl78oMjzFdsMy6F1sGg/IkO8\n"
-        + "tF5yUgPgFYrs41yzAca7IQu6G9qtFDJz/7ehh/9HoG+oqCCIHPuIOmS7Sd0wnkyJ\n"
-        + "Y7Y04jVXIb3a6f6AgBkEFP1nOT0z6kjT7vkA5LJ2y3MiDcXuRNMSta5PYVnrX8aZ\n"
-        + "yiqVUNi40peuZ2R8mAUSBvWgD7z2qWhF8YgDb7wWaFjg53I36vWKn90ZEti3wNCw\n"
-        + "qAVqixM+J0qJmQStgAc53i2aTMvAQu3A3snvH/PHTBo+5UL72n9S1kZyNCsVf1Qo\n"
-        + "n8jKTiRriEM+fMFlcgQP284EBFzYHyCXFb9O/hMjK2+6mY9euMB1U1aFFzM/Bg==\n"
-        + "-----END CERTIFICATE-----\n");
-    assertThat(verifier.verify("foo.com", session)).isTrue();
-    assertThat(verifier.verify("a.foo.com", session)).isFalse();
-    assertThat(verifier.verify("foo.com", session)).isTrue();
-    assertThat(verifier.verify("a.foo.com", session)).isFalse();
-  }
-
-  @Test public void verifyMultipleCn() throws Exception {
-    // CN=foo.com, CN=bar.com, CN=&#x82b1;&#x5b50;.co.jp
-    SSLSession session = session(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIEbzCCA1egAwIBAgIJAIz+EYMBU6aXMA0GCSqGSIb3DQEBBQUAMIGiMQswCQYD\n"
-        + "VQQGEwJDQTELMAkGA1UECBMCQkMxEjAQBgNVBAcTCVZhbmNvdXZlcjEWMBQGA1UE\n"
-        + "ChMNd3d3LmN1Y2JjLmNvbTEUMBIGA1UECxQLY29tbW9uc19zc2wxHTAbBgNVBAMU\n"
-        + "FGRlbW9faW50ZXJtZWRpYXRlX2NhMSUwIwYJKoZIhvcNAQkBFhZqdWxpdXNkYXZp\n"
-        + "ZXNAZ21haWwuY29tMB4XDTA2MTIxMTE2MTk0NVoXDTI4MTEwNTE2MTk0NVowgc0x\n"
-        + "CzAJBgNVBAYTAlVTMREwDwYDVQQIDAhNYXJ5bGFuZDEUMBIGA1UEBwwLRm9yZXN0\n"
-        + "IEhpbGwxFzAVBgNVBAoMDmh0dHBjb21wb25lbnRzMRowGAYDVQQLDBF0ZXN0IGNl\n"
-        + "cnRpZmljYXRlczEQMA4GA1UEAwwHZm9vLmNvbTEQMA4GA1UEAwwHYmFyLmNvbTEV\n"
-        + "MBMGA1UEAwwM6Iqx5a2QLmNvLmpwMSUwIwYJKoZIhvcNAQkBFhZqdWxpdXNkYXZp\n"
-        + "ZXNAZ21haWwuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAyGOv\n"
-        + "loI+jKnRHWKuhYB+cTIEwZhagKJ0f3rIY8WNgujB7PlpgpjUg4pNjYGViGjg7zhf\n"
-        + "bjhCtlNGXyRBti3GcaHiBIIP5nyCNn+Ay8tSWGo5v5Zc8BQcwHf0ZHLN6sD9m2uV\n"
-        + "Sp/6UqjS5ZyhzF5FzvvUo3xw8fecdnStXQfHhkBnLpTjHE5t7iu1JVjTuE0pcBva\n"
-        + "h2dWqDNxiIOQtXyKW8Sag1YxaunxQGqRNykSFiEJindxOSAnAxK6q/wGqcZ3zvFB\n"
-        + "TcVVkji1u2QH4rOMP3PPxAIMkB8ONkdHTco1DmbE6BfDHArDqUYxqJUlPGlMqrKb\n"
-        + "3fCFiT3eXehwR7nlzQIDAQABo3sweTAJBgNVHRMEAjAAMCwGCWCGSAGG+EIBDQQf\n"
-        + "Fh1PcGVuU1NMIEdlbmVyYXRlZCBDZXJ0aWZpY2F0ZTAdBgNVHQ4EFgQUnxR3vz86\n"
-        + "tso4gkJIFiza0Mteh9gwHwYDVR0jBBgwFoAUe5raj5CZTlLSrNuzA1LKh6YNPg0w\n"
-        + "DQYJKoZIhvcNAQEFBQADggEBAGuZb8ai1NO2j4v3y9TLZvd5s0vh5/TE7n7RX+8U\n"
-        + "y37OL5k7x9nt0mM1TyAKxlCcY+9h6frue8MemZIILSIvMrtzccqNz0V1WKgA+Orf\n"
-        + "uUrabmn+CxHF5gpy6g1Qs2IjVYWA5f7FROn/J+Ad8gJYc1azOWCLQqSyfpNRLSvY\n"
-        + "EriQFEV63XvkJ8JrG62b+2OT2lqT4OO07gSPetppdlSa8NBSKP6Aro9RIX1ZjUZQ\n"
-        + "SpQFCfo02NO0uNRDPUdJx2huycdNb+AXHaO7eXevDLJ+QnqImIzxWiY6zLOdzjjI\n"
-        + "VBMkLHmnP7SjGSQ3XA4ByrQOxfOUTyLyE7NuemhHppuQPxE=\n"
-        + "-----END CERTIFICATE-----\n");
-    assertThat(verifier.verify("foo.com", session)).isFalse();
-    assertThat(verifier.verify("a.foo.com", session)).isFalse();
-    assertThat(verifier.verify("bar.com", session)).isFalse();
-    assertThat(verifier.verify("a.bar.com", session)).isFalse();
-    assertThat(verifier.verify("\u82b1\u5b50.co.jp", session)).isFalse();
-    assertThat(verifier.verify("a.\u82b1\u5b50.co.jp", session)).isFalse();
-  }
-
-  @Test public void verifyWilcardCn() throws Exception {
-    // CN=*.foo.com
-    SSLSession session = session(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIESDCCAzCgAwIBAgIJAIz+EYMBU6aUMA0GCSqGSIb3DQEBBQUAMIGiMQswCQYD\n"
-        + "VQQGEwJDQTELMAkGA1UECBMCQkMxEjAQBgNVBAcTCVZhbmNvdXZlcjEWMBQGA1UE\n"
-        + "ChMNd3d3LmN1Y2JjLmNvbTEUMBIGA1UECxQLY29tbW9uc19zc2wxHTAbBgNVBAMU\n"
-        + "FGRlbW9faW50ZXJtZWRpYXRlX2NhMSUwIwYJKoZIhvcNAQkBFhZqdWxpdXNkYXZp\n"
-        + "ZXNAZ21haWwuY29tMB4XDTA2MTIxMTE2MTU1NVoXDTI4MTEwNTE2MTU1NVowgaYx\n"
-        + "CzAJBgNVBAYTAlVTMREwDwYDVQQIEwhNYXJ5bGFuZDEUMBIGA1UEBxMLRm9yZXN0\n"
-        + "IEhpbGwxFzAVBgNVBAoTDmh0dHBjb21wb25lbnRzMRowGAYDVQQLExF0ZXN0IGNl\n"
-        + "cnRpZmljYXRlczESMBAGA1UEAxQJKi5mb28uY29tMSUwIwYJKoZIhvcNAQkBFhZq\n"
-        + "dWxpdXNkYXZpZXNAZ21haWwuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB\n"
-        + "CgKCAQEAyGOvloI+jKnRHWKuhYB+cTIEwZhagKJ0f3rIY8WNgujB7PlpgpjUg4pN\n"
-        + "jYGViGjg7zhfbjhCtlNGXyRBti3GcaHiBIIP5nyCNn+Ay8tSWGo5v5Zc8BQcwHf0\n"
-        + "ZHLN6sD9m2uVSp/6UqjS5ZyhzF5FzvvUo3xw8fecdnStXQfHhkBnLpTjHE5t7iu1\n"
-        + "JVjTuE0pcBvah2dWqDNxiIOQtXyKW8Sag1YxaunxQGqRNykSFiEJindxOSAnAxK6\n"
-        + "q/wGqcZ3zvFBTcVVkji1u2QH4rOMP3PPxAIMkB8ONkdHTco1DmbE6BfDHArDqUYx\n"
-        + "qJUlPGlMqrKb3fCFiT3eXehwR7nlzQIDAQABo3sweTAJBgNVHRMEAjAAMCwGCWCG\n"
-        + "SAGG+EIBDQQfFh1PcGVuU1NMIEdlbmVyYXRlZCBDZXJ0aWZpY2F0ZTAdBgNVHQ4E\n"
-        + "FgQUnxR3vz86tso4gkJIFiza0Mteh9gwHwYDVR0jBBgwFoAUe5raj5CZTlLSrNuz\n"
-        + "A1LKh6YNPg0wDQYJKoZIhvcNAQEFBQADggEBAH0ipG6J561UKUfgkeW7GvYwW98B\n"
-        + "N1ZooWX+JEEZK7+Pf/96d3Ij0rw9ACfN4bpfnCq0VUNZVSYB+GthQ2zYuz7tf/UY\n"
-        + "A6nxVgR/IjG69BmsBl92uFO7JTNtHztuiPqBn59pt+vNx4yPvno7zmxsfI7jv0ww\n"
-        + "yfs+0FNm7FwdsC1k47GBSOaGw38kuIVWqXSAbL4EX9GkryGGOKGNh0qvAENCdRSB\n"
-        + "G9Z6tyMbmfRY+dLSh3a9JwoEcBUso6EWYBakLbq4nG/nvYdYvG9ehrnLVwZFL82e\n"
-        + "l3Q/RK95bnA6cuRClGusLad0e6bjkBzx/VQ3VarDEpAkTLUGVAa0CLXtnyc=\n"
-        + "-----END CERTIFICATE-----\n");
-    assertThat(verifier.verify("foo.com", session)).isFalse();
-    assertThat(verifier.verify("www.foo.com", session)).isFalse();
-    assertThat(verifier.verify("\u82b1\u5b50.foo.com", session)).isFalse();
-    assertThat(verifier.verify("a.b.foo.com", session)).isFalse();
-  }
-
-  @Test public void verifyWilcardCnOnTld() throws Exception {
-    // It's the CA's responsibility to not issue broad-matching certificates!
-    // CN=*.co.jp
-    SSLSession session = session(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIERjCCAy6gAwIBAgIJAIz+EYMBU6aVMA0GCSqGSIb3DQEBBQUAMIGiMQswCQYD\n"
-        + "VQQGEwJDQTELMAkGA1UECBMCQkMxEjAQBgNVBAcTCVZhbmNvdXZlcjEWMBQGA1UE\n"
-        + "ChMNd3d3LmN1Y2JjLmNvbTEUMBIGA1UECxQLY29tbW9uc19zc2wxHTAbBgNVBAMU\n"
-        + "FGRlbW9faW50ZXJtZWRpYXRlX2NhMSUwIwYJKoZIhvcNAQkBFhZqdWxpdXNkYXZp\n"
-        + "ZXNAZ21haWwuY29tMB4XDTA2MTIxMTE2MTYzMFoXDTI4MTEwNTE2MTYzMFowgaQx\n"
-        + "CzAJBgNVBAYTAlVTMREwDwYDVQQIEwhNYXJ5bGFuZDEUMBIGA1UEBxMLRm9yZXN0\n"
-        + "IEhpbGwxFzAVBgNVBAoTDmh0dHBjb21wb25lbnRzMRowGAYDVQQLExF0ZXN0IGNl\n"
-        + "cnRpZmljYXRlczEQMA4GA1UEAxQHKi5jby5qcDElMCMGCSqGSIb3DQEJARYWanVs\n"
-        + "aXVzZGF2aWVzQGdtYWlsLmNvbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC\n"
-        + "ggEBAMhjr5aCPoyp0R1iroWAfnEyBMGYWoCidH96yGPFjYLowez5aYKY1IOKTY2B\n"
-        + "lYho4O84X244QrZTRl8kQbYtxnGh4gSCD+Z8gjZ/gMvLUlhqOb+WXPAUHMB39GRy\n"
-        + "zerA/ZtrlUqf+lKo0uWcocxeRc771KN8cPH3nHZ0rV0Hx4ZAZy6U4xxObe4rtSVY\n"
-        + "07hNKXAb2odnVqgzcYiDkLV8ilvEmoNWMWrp8UBqkTcpEhYhCYp3cTkgJwMSuqv8\n"
-        + "BqnGd87xQU3FVZI4tbtkB+KzjD9zz8QCDJAfDjZHR03KNQ5mxOgXwxwKw6lGMaiV\n"
-        + "JTxpTKqym93whYk93l3ocEe55c0CAwEAAaN7MHkwCQYDVR0TBAIwADAsBglghkgB\n"
-        + "hvhCAQ0EHxYdT3BlblNTTCBHZW5lcmF0ZWQgQ2VydGlmaWNhdGUwHQYDVR0OBBYE\n"
-        + "FJ8Ud78/OrbKOIJCSBYs2tDLXofYMB8GA1UdIwQYMBaAFHua2o+QmU5S0qzbswNS\n"
-        + "yoemDT4NMA0GCSqGSIb3DQEBBQUAA4IBAQA0sWglVlMx2zNGvUqFC73XtREwii53\n"
-        + "CfMM6mtf2+f3k/d8KXhLNySrg8RRlN11zgmpPaLtbdTLrmG4UdAHHYr8O4y2BBmE\n"
-        + "1cxNfGxxechgF8HX10QV4dkyzp6Z1cfwvCeMrT5G/V1pejago0ayXx+GPLbWlNeZ\n"
-        + "S+Kl0m3p+QplXujtwG5fYcIpaGpiYraBLx3Tadih39QN65CnAh/zRDhLCUzKyt9l\n"
-        + "UGPLEUDzRHMPHLnSqT1n5UU5UDRytbjJPXzF+l/+WZIsanefWLsxnkgAuZe/oMMF\n"
-        + "EJMryEzOjg4Tfuc5qM0EXoPcQ/JlheaxZ40p2IyHqbsWV4MRYuFH4bkM\n"
-        + "-----END CERTIFICATE-----\n");
-    assertThat(verifier.verify("foo.co.jp", session)).isFalse();
-    assertThat(verifier.verify("\u82b1\u5b50.co.jp", session)).isFalse();
-  }
-
-  /**
-   * Ignored due to incompatibilities between Android and Java on how non-ASCII subject alt names
-   * are parsed. Android fails to parse these, which means we fall back to the CN. The RI does parse
-   * them, so the CN is unused.
-   */
-  @Test @Ignore public void testWilcardNonAsciiSubjectAlt() throws Exception {
-    // CN=*.foo.com, subjectAlt=*.bar.com, subjectAlt=*.&#x82b1;&#x5b50;.co.jp
-    // (*.hanako.co.jp in kanji)
-    SSLSession session = session(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIEcDCCA1igAwIBAgIJAIz+EYMBU6aWMA0GCSqGSIb3DQEBBQUAMIGiMQswCQYD\n"
-        + "VQQGEwJDQTELMAkGA1UECBMCQkMxEjAQBgNVBAcTCVZhbmNvdXZlcjEWMBQGA1UE\n"
-        + "ChMNd3d3LmN1Y2JjLmNvbTEUMBIGA1UECxQLY29tbW9uc19zc2wxHTAbBgNVBAMU\n"
-        + "FGRlbW9faW50ZXJtZWRpYXRlX2NhMSUwIwYJKoZIhvcNAQkBFhZqdWxpdXNkYXZp\n"
-        + "ZXNAZ21haWwuY29tMB4XDTA2MTIxMTE2MTczMVoXDTI4MTEwNTE2MTczMVowgaYx\n"
-        + "CzAJBgNVBAYTAlVTMREwDwYDVQQIEwhNYXJ5bGFuZDEUMBIGA1UEBxMLRm9yZXN0\n"
-        + "IEhpbGwxFzAVBgNVBAoTDmh0dHBjb21wb25lbnRzMRowGAYDVQQLExF0ZXN0IGNl\n"
-        + "cnRpZmljYXRlczESMBAGA1UEAxQJKi5mb28uY29tMSUwIwYJKoZIhvcNAQkBFhZq\n"
-        + "dWxpdXNkYXZpZXNAZ21haWwuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB\n"
-        + "CgKCAQEAyGOvloI+jKnRHWKuhYB+cTIEwZhagKJ0f3rIY8WNgujB7PlpgpjUg4pN\n"
-        + "jYGViGjg7zhfbjhCtlNGXyRBti3GcaHiBIIP5nyCNn+Ay8tSWGo5v5Zc8BQcwHf0\n"
-        + "ZHLN6sD9m2uVSp/6UqjS5ZyhzF5FzvvUo3xw8fecdnStXQfHhkBnLpTjHE5t7iu1\n"
-        + "JVjTuE0pcBvah2dWqDNxiIOQtXyKW8Sag1YxaunxQGqRNykSFiEJindxOSAnAxK6\n"
-        + "q/wGqcZ3zvFBTcVVkji1u2QH4rOMP3PPxAIMkB8ONkdHTco1DmbE6BfDHArDqUYx\n"
-        + "qJUlPGlMqrKb3fCFiT3eXehwR7nlzQIDAQABo4GiMIGfMAkGA1UdEwQCMAAwLAYJ\n"
-        + "YIZIAYb4QgENBB8WHU9wZW5TU0wgR2VuZXJhdGVkIENlcnRpZmljYXRlMB0GA1Ud\n"
-        + "DgQWBBSfFHe/Pzq2yjiCQkgWLNrQy16H2DAfBgNVHSMEGDAWgBR7mtqPkJlOUtKs\n"
-        + "27MDUsqHpg0+DTAkBgNVHREEHTAbggkqLmJhci5jb22CDiou6Iqx5a2QLmNvLmpw\n"
-        + "MA0GCSqGSIb3DQEBBQUAA4IBAQBobWC+D5/lx6YhX64CwZ26XLjxaE0S415ajbBq\n"
-        + "DK7lz+Rg7zOE3GsTAMi+ldUYnhyz0wDiXB8UwKXl0SDToB2Z4GOgqQjAqoMmrP0u\n"
-        + "WB6Y6dpkfd1qDRUzI120zPYgSdsXjHW9q2H77iV238hqIU7qCvEz+lfqqWEY504z\n"
-        + "hYNlknbUnR525ItosEVwXFBJTkZ3Yw8gg02c19yi8TAh5Li3Ad8XQmmSJMWBV4XK\n"
-        + "qFr0AIZKBlg6NZZFf/0dP9zcKhzSriW27bY0XfzA6GSiRDXrDjgXq6baRT6YwgIg\n"
-        + "pgJsDbJtZfHnV1nd3M6zOtQPm1TIQpNmMMMd/DPrGcUQerD3\n"
-        + "-----END CERTIFICATE-----\n");
-    // try the foo.com variations
-    assertThat(verifier.verify("foo.com", session)).isTrue();
-    assertThat(verifier.verify("www.foo.com", session)).isTrue();
-    assertThat(verifier.verify("\u82b1\u5b50.foo.com", session)).isTrue();
-    assertThat(verifier.verify("a.b.foo.com", session)).isFalse();
-    // these checks test alternative subjects. The test data contains an
-    // alternative subject starting with a japanese kanji character. This is
-    // not supported by Android because the underlying implementation from
-    // harmony follows the definition from rfc 1034 page 10 for alternative
-    // subject names. This causes the code to drop all alternative subjects.
-    // assertFalse(verifier.verify("bar.com", session));
-    // assertTrue(verifier.verify("www.bar.com", session));
-    // assertTrue(verifier.verify("\u82b1\u5b50.bar.com", session));
-    // assertTrue(verifier.verify("a.b.bar.com", session));
-  }
-
-  @Test public void subjectAltUsesLocalDomainAndIp() throws Exception {
-    // cat cert.cnf
-    // [req]
-    // distinguished_name=distinguished_name
-    // req_extensions=req_extensions
-    // x509_extensions=x509_extensions
-    // [distinguished_name]
-    // [req_extensions]
-    // [x509_extensions]
-    // subjectAltName=DNS:localhost.localdomain,DNS:localhost,IP:127.0.0.1
-    //
-    // $ openssl req -x509 -nodes -days 36500 -subj '/CN=localhost' -config ./cert.cnf \
-    //     -newkey rsa:512 -out cert.pem
-    X509Certificate certificate = certificate(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIBWDCCAQKgAwIBAgIJANS1EtICX2AZMA0GCSqGSIb3DQEBBQUAMBQxEjAQBgNV\n"
-        + "BAMTCWxvY2FsaG9zdDAgFw0xMjAxMDIxOTA4NThaGA8yMTExMTIwOTE5MDg1OFow\n"
-        + "FDESMBAGA1UEAxMJbG9jYWxob3N0MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAPpt\n"
-        + "atK8r4/hf4hSIs0os/BSlQLbRBaK9AfBReM4QdAklcQqe6CHsStKfI8pp0zs7Ptg\n"
-        + "PmMdpbttL0O7mUboBC8CAwEAAaM1MDMwMQYDVR0RBCowKIIVbG9jYWxob3N0Lmxv\n"
-        + "Y2FsZG9tYWlugglsb2NhbGhvc3SHBH8AAAEwDQYJKoZIhvcNAQEFBQADQQD0ntfL\n"
-        + "DCzOCv9Ma6Lv5o5jcYWVxvBSTsnt22hsJpWD1K7iY9lbkLwl0ivn73pG2evsAn9G\n"
-        + "X8YKH52fnHsCrhSD\n"
-        + "-----END CERTIFICATE-----");
-    assertThat(certificate.getSubjectX500Principal()).isEqualTo(
-        new X500Principal("CN=localhost"));
-
-    FakeSSLSession session = new FakeSSLSession(certificate);
-    assertThat(verifier.verify("localhost", session)).isTrue();
-    assertThat(verifier.verify("localhost.localdomain", session)).isTrue();
-    assertThat(verifier.verify("local.host", session)).isFalse();
-
-    assertThat(verifier.verify("127.0.0.1", session)).isTrue();
-    assertThat(verifier.verify("127.0.0.2", session)).isFalse();
-  }
-
-  @Test public void wildcardsCannotMatchIpAddresses() throws Exception {
-    // openssl req -x509 -nodes -days 36500 -subj '/CN=*.0.0.1' -newkey rsa:512 -out cert.pem
-    SSLSession session = session(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIBkjCCATygAwIBAgIJAMdemqOwd/BEMA0GCSqGSIb3DQEBBQUAMBIxEDAOBgNV\n"
-        + "BAMUByouMC4wLjEwIBcNMTAxMjIwMTY0NDI1WhgPMjExMDExMjYxNjQ0MjVaMBIx\n"
-        + "EDAOBgNVBAMUByouMC4wLjEwXDANBgkqhkiG9w0BAQEFAANLADBIAkEAqY8c9Qrt\n"
-        + "YPWCvb7lclI+aDHM6fgbJcHsS9Zg8nUOh5dWrS7AgeA25wyaokFl4plBbbHQe2j+\n"
-        + "cCjsRiJIcQo9HwIDAQABo3MwcTAdBgNVHQ4EFgQUJ436TZPJvwCBKklZZqIvt1Yt\n"
-        + "JjEwQgYDVR0jBDswOYAUJ436TZPJvwCBKklZZqIvt1YtJjGhFqQUMBIxEDAOBgNV\n"
-        + "BAMUByouMC4wLjGCCQDHXpqjsHfwRDAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEB\n"
-        + "BQUAA0EAk9i88xdjWoewqvE+iMC9tD2obMchgFDaHH0ogxxiRaIKeEly3g0uGxIt\n"
-        + "fl2WRY8hb4x+zRrwsFaLEpdEvqcjOQ==\n"
-        + "-----END CERTIFICATE-----");
-    assertThat(verifier.verify("127.0.0.1", session)).isFalse();
-  }
-
-  /**
-   * Earlier implementations of Android's hostname verifier required that wildcard names wouldn't
-   * match "*.com" or similar. This was a nonstandard check that we've since dropped. It is the CA's
-   * responsibility to not hand out certificates that match so broadly.
-   */
-  @Test public void wildcardsDoesNotNeedTwoDots() throws Exception {
-    // openssl req -x509 -nodes -days 36500 -subj '/CN=*.com' -newkey rsa:512 -out cert.pem
-    SSLSession session = session(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIBjDCCATagAwIBAgIJAOVulXCSu6HuMA0GCSqGSIb3DQEBBQUAMBAxDjAMBgNV\n"
-        + "BAMUBSouY29tMCAXDTEwMTIyMDE2NDkzOFoYDzIxMTAxMTI2MTY0OTM4WjAQMQ4w\n"
-        + "DAYDVQQDFAUqLmNvbTBcMA0GCSqGSIb3DQEBAQUAA0sAMEgCQQDJd8xqni+h7Iaz\n"
-        + "ypItivs9kPuiJUqVz+SuJ1C05SFc3PmlRCvwSIfhyD67fHcbMdl+A/LrIjhhKZJe\n"
-        + "1joO0+pFAgMBAAGjcTBvMB0GA1UdDgQWBBS4Iuzf5w8JdCp+EtBfdFNudf6+YzBA\n"
-        + "BgNVHSMEOTA3gBS4Iuzf5w8JdCp+EtBfdFNudf6+Y6EUpBIwEDEOMAwGA1UEAxQF\n"
-        + "Ki5jb22CCQDlbpVwkruh7jAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEBBQUAA0EA\n"
-        + "U6LFxmZr31lFyis2/T68PpjAppc0DpNQuA2m/Y7oTHBDi55Fw6HVHCw3lucuWZ5d\n"
-        + "qUYo4ES548JdpQtcLrW2sA==\n"
-        + "-----END CERTIFICATE-----");
-    assertThat(verifier.verify("google.com", session)).isFalse();
-  }
-
-  @Test public void subjectAltName() throws Exception {
-    // $ cat ./cert.cnf
-    // [req]
-    // distinguished_name=distinguished_name
-    // req_extensions=req_extensions
-    // x509_extensions=x509_extensions
-    // [distinguished_name]
-    // [req_extensions]
-    // [x509_extensions]
-    // subjectAltName=DNS:bar.com,DNS:baz.com
-    //
-    // $ openssl req -x509 -nodes -days 36500 -subj '/CN=foo.com' -config ./cert.cnf \
-    //     -newkey rsa:512 -out cert.pem
-    SSLSession session = session(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIBPTCB6KADAgECAgkA7zoHaaqNGHQwDQYJKoZIhvcNAQEFBQAwEjEQMA4GA1UE\n"
-        + "AxMHZm9vLmNvbTAgFw0xMDEyMjAxODM5MzZaGA8yMTEwMTEyNjE4MzkzNlowEjEQ\n"
-        + "MA4GA1UEAxMHZm9vLmNvbTBcMA0GCSqGSIb3DQEBAQUAA0sAMEgCQQC+gmoSxF+8\n"
-        + "hbV+rgRQqHIJd50216OWQJbU3BvdlPbca779NYO4+UZWTFdBM8BdQqs3H4B5Agvp\n"
-        + "y7HeSff1F7XRAgMBAAGjHzAdMBsGA1UdEQQUMBKCB2Jhci5jb22CB2Jhei5jb20w\n"
-        + "DQYJKoZIhvcNAQEFBQADQQBXpZZPOY2Dy1lGG81JTr8L4or9jpKacD7n51eS8iqI\n"
-        + "oTznPNuXHU5bFN0AAGX2ij47f/EahqTpo5RdS95P4sVm\n"
-        + "-----END CERTIFICATE-----");
-    assertThat(verifier.verify("foo.com", session)).isFalse();
-    assertThat(verifier.verify("bar.com", session)).isTrue();
-    assertThat(verifier.verify("baz.com", session)).isTrue();
-    assertThat(verifier.verify("a.foo.com", session)).isFalse();
-    assertThat(verifier.verify("quux.com", session)).isFalse();
-  }
-
-  @Test public void subjectAltNameWithWildcard() throws Exception {
-    // $ cat ./cert.cnf
-    // [req]
-    // distinguished_name=distinguished_name
-    // req_extensions=req_extensions
-    // x509_extensions=x509_extensions
-    // [distinguished_name]
-    // [req_extensions]
-    // [x509_extensions]
-    // subjectAltName=DNS:bar.com,DNS:*.baz.com
-    //
-    // $ openssl req -x509 -nodes -days 36500 -subj '/CN=foo.com' -config ./cert.cnf \
-    //     -newkey rsa:512 -out cert.pem
-    SSLSession session = session(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIBPzCB6qADAgECAgkAnv/7Jv5r7pMwDQYJKoZIhvcNAQEFBQAwEjEQMA4GA1UE\n"
-        + "AxMHZm9vLmNvbTAgFw0xMDEyMjAxODQ2MDFaGA8yMTEwMTEyNjE4NDYwMVowEjEQ\n"
-        + "MA4GA1UEAxMHZm9vLmNvbTBcMA0GCSqGSIb3DQEBAQUAA0sAMEgCQQDAz2YXnyog\n"
-        + "YdYLSFr/OEgSumtwqtZKJTB4wqTW/eKbBCEzxnyUMxWZIqUGu353PzwfOuWp2re3\n"
-        + "nvVV+QDYQlh9AgMBAAGjITAfMB0GA1UdEQQWMBSCB2Jhci5jb22CCSouYmF6LmNv\n"
-        + "bTANBgkqhkiG9w0BAQUFAANBAB8yrSl8zqy07i0SNYx2B/FnvQY734pxioaqFWfO\n"
-        + "Bqo1ZZl/9aPHEWIwBrxYNVB0SGu/kkbt/vxqOjzzrkXukmI=\n"
-        + "-----END CERTIFICATE-----");
-    assertThat(verifier.verify("foo.com", session)).isFalse();
-    assertThat(verifier.verify("bar.com", session)).isTrue();
-    assertThat(verifier.verify("a.baz.com", session)).isTrue();
-    assertThat(verifier.verify("baz.com", session)).isFalse();
-    assertThat(verifier.verify("a.foo.com", session)).isFalse();
-    assertThat(verifier.verify("a.bar.com", session)).isFalse();
-    assertThat(verifier.verify("quux.com", session)).isFalse();
-  }
-
-  @Test public void verifyAsIpAddress() {
-    // IPv4
-    assertThat(Util.verifyAsIpAddress("127.0.0.1")).isTrue();
-    assertThat(Util.verifyAsIpAddress("1.2.3.4")).isTrue();
-
-    // IPv6
-    assertThat(Util.verifyAsIpAddress("::1")).isTrue();
-    assertThat(Util.verifyAsIpAddress("2001:db8::1")).isTrue();
-    assertThat(Util.verifyAsIpAddress("::192.168.0.1")).isTrue();
-    assertThat(Util.verifyAsIpAddress("::ffff:192.168.0.1")).isTrue();
-    assertThat(Util.verifyAsIpAddress("FEDC:BA98:7654:3210:FEDC:BA98:7654:3210")).isTrue();
-    assertThat(Util.verifyAsIpAddress("1080:0:0:0:8:800:200C:417A")).isTrue();
-    assertThat(Util.verifyAsIpAddress("1080::8:800:200C:417A")).isTrue();
-    assertThat(Util.verifyAsIpAddress("FF01::101")).isTrue();
-    assertThat(Util.verifyAsIpAddress("0:0:0:0:0:0:13.1.68.3")).isTrue();
-    assertThat(Util.verifyAsIpAddress("0:0:0:0:0:FFFF:129.144.52.38")).isTrue();
-    assertThat(Util.verifyAsIpAddress("::13.1.68.3")).isTrue();
-    assertThat(Util.verifyAsIpAddress("::FFFF:129.144.52.38")).isTrue();
-
-    // Hostnames
-    assertThat(Util.verifyAsIpAddress("go")).isFalse();
-    assertThat(Util.verifyAsIpAddress("localhost")).isFalse();
-    assertThat(Util.verifyAsIpAddress("squareup.com")).isFalse();
-    assertThat(Util.verifyAsIpAddress("www.nintendo.co.jp")).isFalse();
-  }
-
-  private X509Certificate certificate(String certificate) throws Exception {
-    return (X509Certificate) CertificateFactory.getInstance("X.509").generateCertificate(
-        new ByteArrayInputStream(certificate.getBytes(UTF_8)));
-  }
-
-  private SSLSession session(String certificate) throws Exception {
-    return new FakeSSLSession(certificate(certificate));
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
deleted file mode 100644
index 044643cd4b..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
+++ /dev/null
@@ -1,396 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.ws;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.net.SocketTimeoutException;
-import java.util.Random;
-import java.util.concurrent.TimeUnit;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.Response;
-import okio.ByteString;
-import okio.Okio;
-import okio.Pipe;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.data.Offset.offset;
-import static org.junit.Assert.fail;
-
-public final class RealWebSocketTest {
-  // NOTE: Fields are named 'client' and 'server' for cognitive simplicity. This differentiation has
-  // zero effect on the behavior of the WebSocket API which is why tests are only written once
-  // from the perspective of a single peer.
-
-  private final Random random = new Random(0);
-  private final Pipe client2Server = new Pipe(1024L);
-  private final Pipe server2client = new Pipe(1024L);
-
-  private TestStreams client = new TestStreams(true, server2client, client2Server);
-  private TestStreams server = new TestStreams(false, client2Server, server2client);
-
-  @Before public void setUp() throws IOException {
-    client.initWebSocket(random, 0);
-    server.initWebSocket(random, 0);
-  }
-
-  @After public void tearDown() throws Exception {
-    client.listener.assertExhausted();
-    server.listener.assertExhausted();
-    server.source.close();
-    client.source.close();
-    server.webSocket.tearDown();
-    client.webSocket.tearDown();
-  }
-
-  @Test public void close() throws IOException {
-    client.webSocket.close(1000, "Hello!");
-    // This will trigger a close response.
-    assertThat(server.processNextFrame()).isFalse();
-    server.listener.assertClosing(1000, "Hello!");
-    server.webSocket.close(1000, "Goodbye!");
-    assertThat(client.processNextFrame()).isFalse();
-    client.listener.assertClosing(1000, "Goodbye!");
-    server.listener.assertClosed(1000, "Hello!");
-    client.listener.assertClosed(1000, "Goodbye!");
-  }
-
-  @Test public void clientCloseThenMethodsReturnFalse() throws IOException {
-    client.webSocket.close(1000, "Hello!");
-
-    assertThat(client.webSocket.close(1000, "Hello!")).isFalse();
-    assertThat(client.webSocket.send("Hello!")).isFalse();
-  }
-
-  @Test public void clientCloseWith0Fails() throws IOException {
-    try {
-      client.webSocket.close(0, null);
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertThat("Code must be in range [1000,5000): 0").isEqualTo(expected.getMessage());
-    }
-  }
-
-  @Test public void afterSocketClosedPingFailsWebSocket() throws IOException {
-    client2Server.source().close();
-    client.webSocket.pong(ByteString.encodeUtf8("Ping!"));
-    client.listener.assertFailure(IOException.class, "source is closed");
-
-    assertThat(client.webSocket.send("Hello!")).isFalse();
-  }
-
-  @Test public void socketClosedDuringMessageKillsWebSocket() throws IOException {
-    client2Server.source().close();
-
-    assertThat(client.webSocket.send("Hello!")).isTrue();
-    client.listener.assertFailure(IOException.class, "source is closed");
-
-    // A failed write prevents further use of the WebSocket instance.
-    assertThat(client.webSocket.send("Hello!")).isFalse();
-    assertThat(client.webSocket.pong(ByteString.encodeUtf8("Ping!"))).isFalse();
-  }
-
-  @Test public void serverCloseThenWritingPingSucceeds() throws IOException {
-    server.webSocket.close(1000, "Hello!");
-    client.processNextFrame();
-    client.listener.assertClosing(1000, "Hello!");
-
-    assertThat(client.webSocket.pong(ByteString.encodeUtf8("Pong?"))).isTrue();
-  }
-
-  @Test public void clientCanWriteMessagesAfterServerClose() throws IOException {
-    server.webSocket.close(1000, "Hello!");
-    client.processNextFrame();
-    client.listener.assertClosing(1000, "Hello!");
-
-    assertThat(client.webSocket.send("Hi!")).isTrue();
-    server.processNextFrame();
-    server.listener.assertTextMessage("Hi!");
-  }
-
-  @Test public void serverCloseThenClientClose() throws IOException {
-    server.webSocket.close(1000, "Hello!");
-    client.processNextFrame();
-    client.listener.assertClosing(1000, "Hello!");
-    assertThat(client.webSocket.close(1000, "Bye!")).isTrue();
-  }
-
-  @Test public void emptyCloseInitiatesShutdown() throws IOException {
-    server.sink.write(ByteString.decodeHex("8800")).emit(); // Close without code.
-    client.processNextFrame();
-    client.listener.assertClosing(1005, "");
-
-    assertThat(client.webSocket.close(1000, "Bye!")).isTrue();
-    server.processNextFrame();
-    server.listener.assertClosing(1000, "Bye!");
-
-    client.listener.assertClosed(1005, "");
-  }
-
-  @Test public void clientCloseClosesConnection() throws IOException {
-    client.webSocket.close(1000, "Hello!");
-    assertThat(client.closed).isFalse();
-    server.processNextFrame(); // Read client closing, send server close.
-    server.listener.assertClosing(1000, "Hello!");
-
-    server.webSocket.close(1000, "Goodbye!");
-    client.processNextFrame(); // Read server closing, close connection.
-    assertThat(client.closed).isTrue();
-    client.listener.assertClosing(1000, "Goodbye!");
-
-    // Server and client both finished closing, connection is closed.
-    server.listener.assertClosed(1000, "Hello!");
-    client.listener.assertClosed(1000, "Goodbye!");
-  }
-
-  @Test public void serverCloseClosesConnection() throws IOException {
-    server.webSocket.close(1000, "Hello!");
-
-    client.processNextFrame(); // Read server close, send client close, close connection.
-    assertThat(client.closed).isFalse();
-    client.listener.assertClosing(1000, "Hello!");
-
-    client.webSocket.close(1000, "Hello!");
-    server.processNextFrame();
-    server.listener.assertClosing(1000, "Hello!");
-
-    client.listener.assertClosed(1000, "Hello!");
-    server.listener.assertClosed(1000, "Hello!");
-  }
-
-  @Test public void clientAndServerCloseClosesConnection() throws Exception {
-    // Send close from both sides at the same time.
-    server.webSocket.close(1000, "Hello!");
-    client.processNextFrame(); // Read close, close connection close.
-
-    assertThat(client.closed).isFalse();
-    client.webSocket.close(1000, "Hi!");
-    server.processNextFrame();
-
-    client.listener.assertClosing(1000, "Hello!");
-    server.listener.assertClosing(1000, "Hi!");
-    client.listener.assertClosed(1000, "Hello!");
-    server.listener.assertClosed(1000, "Hi!");
-    client.webSocket.awaitTermination(5, TimeUnit.SECONDS);
-    assertThat(client.closed).isTrue();
-
-    server.listener.assertExhausted(); // Client should not have sent second close.
-    client.listener.assertExhausted(); // Server should not have sent second close.
-  }
-
-  @Test public void serverCloseBreaksReadMessageLoop() throws IOException {
-    server.webSocket.send("Hello!");
-    server.webSocket.close(1000, "Bye!");
-    assertThat(client.processNextFrame()).isTrue();
-    client.listener.assertTextMessage("Hello!");
-    assertThat(client.processNextFrame()).isFalse();
-    client.listener.assertClosing(1000, "Bye!");
-  }
-
-  @Test public void protocolErrorBeforeCloseSendsFailure() throws IOException {
-    server.sink.write(ByteString.decodeHex("0a00")).emit(); // Invalid non-final ping frame.
-
-    client.processNextFrame(); // Detects error, send close, close connection.
-    assertThat(client.closed).isTrue();
-    client.listener.assertFailure(ProtocolException.class, "Control frames must be final.");
-
-    server.processNextFrame();
-    server.listener.assertFailure(EOFException.class);
-  }
-
-  @Test public void protocolErrorInCloseResponseClosesConnection() throws IOException {
-    client.webSocket.close(1000, "Hello");
-    server.processNextFrame();
-    // Not closed until close reply is received.
-    assertThat(client.closed).isFalse();
-
-    // Manually write an invalid masked close frame.
-    server.sink.write(ByteString.decodeHex("888760b420bb635c68de0cd84f")).emit();
-
-    client.processNextFrame();// Detects error, disconnects immediately since close already sent.
-    assertThat(client.closed).isTrue();
-    client.listener.assertFailure(
-        ProtocolException.class, "Server-sent frames must not be masked.");
-
-    server.listener.assertClosing(1000, "Hello");
-    server.listener.assertExhausted(); // Client should not have sent second close.
-  }
-
-  @Test public void protocolErrorAfterCloseDoesNotSendClose() throws IOException {
-    client.webSocket.close(1000, "Hello!");
-    server.processNextFrame();
-
-    // Not closed until close reply is received.
-    assertThat(client.closed).isFalse();
-    server.sink.write(ByteString.decodeHex("0a00")).emit(); // Invalid non-final ping frame.
-
-    client.processNextFrame(); // Detects error, disconnects immediately since close already sent.
-    assertThat(client.closed).isTrue();
-    client.listener.assertFailure(ProtocolException.class, "Control frames must be final.");
-
-    server.listener.assertClosing(1000, "Hello!");
-
-    server.listener.assertExhausted(); // Client should not have sent second close.
-  }
-
-  @Test public void networkErrorReportedAsFailure() throws IOException {
-    server.sink.close();
-    client.processNextFrame();
-    client.listener.assertFailure(EOFException.class);
-  }
-
-  @Test public void closeThrowingFailsConnection() throws IOException {
-    client2Server.source().close();
-    client.webSocket.close(1000, null);
-    client.listener.assertFailure(IOException.class, "source is closed");
-  }
-
-  @Ignore // TODO(jwilson): come up with a way to test unchecked exceptions on the writer thread.
-  @Test public void closeMessageAndConnectionCloseThrowingDoesNotMaskOriginal() throws IOException {
-    client.sink.close();
-    client.closeThrows = true;
-
-    client.webSocket.close(1000, "Bye!");
-    client.listener.assertFailure(IOException.class, "failure");
-    assertThat(client.closed).isTrue();
-  }
-
-  @Ignore // TODO(jwilson): come up with a way to test unchecked exceptions on the writer thread.
-  @Test public void peerConnectionCloseThrowingPropagates() throws IOException {
-    client.closeThrows = true;
-
-    server.webSocket.close(1000, "Bye from Server!");
-    client.processNextFrame();
-    client.listener.assertClosing(1000, "Bye from Server!");
-
-    client.webSocket.close(1000, "Bye from Client!");
-    server.processNextFrame();
-    server.listener.assertClosing(1000, "Bye from Client!");
-  }
-
-  @Test public void pingOnInterval() throws IOException {
-    long startNanos = System.nanoTime();
-    client.initWebSocket(random, 500);
-
-    server.processNextFrame(); // Ping.
-    client.processNextFrame(); // Pong.
-    long elapsedUntilPing1 = System.nanoTime() - startNanos;
-    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing1)).isCloseTo((double) 500, offset(
-        250d));
-
-    server.processNextFrame(); // Ping.
-    client.processNextFrame(); // Pong.
-    long elapsedUntilPing2 = System.nanoTime() - startNanos;
-    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing2)).isCloseTo((double) 1000, offset(
-        250d));
-
-    server.processNextFrame(); // Ping.
-    client.processNextFrame(); // Pong.
-    long elapsedUntilPing3 = System.nanoTime() - startNanos;
-    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing3)).isCloseTo((double) 1500, offset(
-        250d));
-  }
-
-  @Test public void unacknowledgedPingFailsConnection() throws IOException {
-    long startNanos = System.nanoTime();
-    client.initWebSocket(random, 500);
-
-    // Don't process the ping and pong frames!
-    client.listener.assertFailure(SocketTimeoutException.class,
-        "sent ping but didn't receive pong within 500ms (after 0 successful ping/pongs)");
-    long elapsedUntilFailure = System.nanoTime() - startNanos;
-    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure)).isCloseTo((double) 1000, offset(
-        250d));
-  }
-
-  @Test public void unexpectedPongsDoNotInterfereWithFailureDetection() throws IOException {
-    long startNanos = System.nanoTime();
-    client.initWebSocket(random, 500);
-
-    // At 0ms the server sends 3 unexpected pongs. The client accepts 'em and ignores em.
-    server.webSocket.pong(ByteString.encodeUtf8("pong 1"));
-    client.processNextFrame();
-    server.webSocket.pong(ByteString.encodeUtf8("pong 2"));
-    client.processNextFrame();
-    server.webSocket.pong(ByteString.encodeUtf8("pong 3"));
-    client.processNextFrame();
-
-    // After 500ms the client automatically pings and the server pongs back.
-    server.processNextFrame(); // Ping.
-    client.processNextFrame(); // Pong.
-    long elapsedUntilPing = System.nanoTime() - startNanos;
-    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing)).isCloseTo((double) 500, offset(
-        250d));
-
-    // After 1000ms the client will attempt a ping 2, but we don't process it. That'll cause the
-    // client to fail at 1500ms when it's time to send ping 3 because pong 2 hasn't been received.
-    client.listener.assertFailure(SocketTimeoutException.class,
-        "sent ping but didn't receive pong within 500ms (after 1 successful ping/pongs)");
-    long elapsedUntilFailure = System.nanoTime() - startNanos;
-    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure)).isCloseTo((double) 1500, offset(
-        250d));
-  }
-
-  /** One peer's streams, listener, and web socket in the test. */
-  private static class TestStreams extends RealWebSocket.Streams {
-    private final String name;
-    private final WebSocketRecorder listener;
-    private RealWebSocket webSocket;
-    boolean closeThrows;
-    boolean closed;
-
-    public TestStreams(boolean client, Pipe source, Pipe sink) {
-      super(client, Okio.buffer(source.source()), Okio.buffer(sink.sink()));
-      this.name = client ? "client" : "server";
-      this.listener = new WebSocketRecorder(name);
-    }
-
-    public void initWebSocket(Random random, int pingIntervalMillis) throws IOException {
-      String url = "http://example.com/websocket";
-      Response response = new Response.Builder()
-          .code(101)
-          .message("OK")
-          .request(new Request.Builder().url(url).build())
-          .protocol(Protocol.HTTP_1_1)
-          .build();
-      webSocket = new RealWebSocket(response.request(), listener, random, pingIntervalMillis);
-      webSocket.initReaderAndWriter(name, this);
-    }
-
-    public boolean processNextFrame() throws IOException {
-      return webSocket.processNextFrame();
-    }
-
-    @Override public void close() throws IOException {
-      source.close();
-      sink.close();
-      if (closed) {
-        throw new AssertionError("Already closed");
-      }
-      closed = true;
-
-      if (closeThrows) {
-        throw new RuntimeException("Oops!");
-      }
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
deleted file mode 100644
index 2703579698..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
+++ /dev/null
@@ -1,815 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.ws;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.io.InterruptedIOException;
-import java.net.HttpURLConnection;
-import java.net.ProtocolException;
-import java.net.SocketTimeoutException;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Random;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.logging.Logger;
-import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
-import okhttp3.RecordingEventListener;
-import okhttp3.RecordingHostnameVerifier;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.TestLogHandler;
-import okhttp3.WebSocket;
-import okhttp3.WebSocketListener;
-import okhttp3.mockwebserver.Dispatcher;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
-import okhttp3.mockwebserver.SocketPolicy;
-import okhttp3.tls.HandshakeCertificates;
-import okio.Buffer;
-import okio.ByteString;
-import org.junit.After;
-import org.junit.Ignore;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static okhttp3.TestUtil.defaultClient;
-import static okhttp3.TestUtil.ensureAllConnectionsReleased;
-import static okhttp3.TestUtil.repeat;
-import static okhttp3.tls.internal.TlsUtil.localhost;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.data.Offset.offset;
-import static org.junit.Assert.fail;
-
-public final class WebSocketHttpTest {
-  @Rule public final MockWebServer webServer = new MockWebServer();
-
-  private final HandshakeCertificates handshakeCertificates = localhost();
-  private final WebSocketRecorder clientListener = new WebSocketRecorder("client");
-  private final WebSocketRecorder serverListener = new WebSocketRecorder("server");
-  private final Random random = new Random(0);
-  private OkHttpClient client = defaultClient().newBuilder()
-      .writeTimeout(500, TimeUnit.MILLISECONDS)
-      .readTimeout(500, TimeUnit.MILLISECONDS)
-      .addInterceptor(chain -> {
-        Response response = chain.proceed(chain.request());
-        // Ensure application interceptors never see a null body.
-        assertThat(response.body()).isNotNull();
-        return response;
-      })
-      .build();
-
-  @After public void tearDown() {
-    clientListener.assertExhausted();
-
-    // TODO: assert all connections are released once leaks are fixed
-  }
-
-  @Test public void textMessage() {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    WebSocket webSocket = newWebSocket();
-
-    clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
-
-    webSocket.send("Hello, WebSockets!");
-    serverListener.assertTextMessage("Hello, WebSockets!");
-
-    closeWebSockets(webSocket, server);
-  }
-
-  @Test public void binaryMessage() {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    WebSocket webSocket = newWebSocket();
-
-    clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
-
-    webSocket.send(ByteString.encodeUtf8("Hello!"));
-    serverListener.assertBinaryMessage(ByteString.of(new byte[] {'H', 'e', 'l', 'l', 'o', '!'}));
-
-    closeWebSockets(webSocket, server);
-  }
-
-  @Test public void nullStringThrows() {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    WebSocket webSocket = newWebSocket();
-
-    clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
-    try {
-      webSocket.send((String) null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e.getMessage()).isEqualTo("text == null");
-    }
-
-    closeWebSockets(webSocket, server);
-  }
-
-  @Test public void nullByteStringThrows() {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    WebSocket webSocket = newWebSocket();
-
-    clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
-    try {
-      webSocket.send((ByteString) null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e.getMessage()).isEqualTo("bytes == null");
-    }
-
-    closeWebSockets(webSocket, server);
-  }
-
-  @Test public void serverMessage() {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    WebSocket webSocket = newWebSocket();
-
-    clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
-
-    server.send("Hello, WebSockets!");
-    clientListener.assertTextMessage("Hello, WebSockets!");
-
-    closeWebSockets(webSocket, server);
-  }
-
-  @Test public void throwingOnOpenFailsImmediately() {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-
-    final RuntimeException e = new RuntimeException();
-    clientListener.setNextEventDelegate(new WebSocketListener() {
-      @Override public void onOpen(WebSocket webSocket, Response response) {
-        throw e;
-      }
-    });
-    newWebSocket();
-
-    serverListener.assertOpen();
-    serverListener.assertFailure(EOFException.class);
-    serverListener.assertExhausted();
-    clientListener.assertFailure(e);
-  }
-
-  @Ignore("AsyncCall currently lets runtime exceptions propagate.")
-  @Test public void throwingOnFailLogs() throws Exception {
-    TestLogHandler logs = new TestLogHandler();
-    Logger logger = Logger.getLogger(OkHttpClient.class.getName());
-    logger.addHandler(logs);
-
-    webServer.enqueue(new MockResponse().setResponseCode(200).setBody("Body"));
-
-    final RuntimeException e = new RuntimeException();
-    clientListener.setNextEventDelegate(new WebSocketListener() {
-      @Override public void onFailure(WebSocket webSocket, Throwable t, Response response) {
-        throw e;
-      }
-    });
-
-    newWebSocket();
-
-    assertThat(logs.take()).isEqualTo("");
-    logger.removeHandler(logs);
-  }
-
-  @Test public void throwingOnMessageClosesImmediatelyAndFails() {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    newWebSocket();
-
-    clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
-
-    final RuntimeException e = new RuntimeException();
-    clientListener.setNextEventDelegate(new WebSocketListener() {
-      @Override public void onMessage(WebSocket webSocket, String text) {
-        throw e;
-      }
-    });
-
-    server.send("Hello, WebSockets!");
-    clientListener.assertFailure(e);
-    serverListener.assertFailure(EOFException.class);
-    serverListener.assertExhausted();
-  }
-
-  @Test public void throwingOnClosingClosesImmediatelyAndFails() {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    newWebSocket();
-
-    clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
-
-    final RuntimeException e = new RuntimeException();
-    clientListener.setNextEventDelegate(new WebSocketListener() {
-      @Override public void onClosing(WebSocket webSocket, int code, String reason) {
-        throw e;
-      }
-    });
-
-    server.close(1000, "bye");
-    clientListener.assertFailure(e);
-    serverListener.assertFailure();
-    serverListener.assertExhausted();
-  }
-
-  @Test public void unplannedCloseHandledByCloseWithoutFailure() {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    newWebSocket();
-
-    clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
-    clientListener.setNextEventDelegate(new WebSocketListener() {
-      @Override public void onClosing(WebSocket webSocket, int code, String reason) {
-        webSocket.close(1000, null);
-      }
-    });
-
-    server.close(1001, "bye");
-    clientListener.assertClosed(1001, "bye");
-    clientListener.assertExhausted();
-    serverListener.assertClosing(1000,  "");
-    serverListener.assertClosed(1000,  "");
-    serverListener.assertExhausted();
-  }
-
-  @Test public void unplannedCloseHandledWithoutFailure() {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    newWebSocket();
-
-    WebSocket webSocket = clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
-
-    closeWebSockets(webSocket, server);
-  }
-
-  @Test public void non101RetainsBody() throws IOException {
-    webServer.enqueue(new MockResponse().setResponseCode(200).setBody("Body"));
-    newWebSocket();
-
-    clientListener.assertFailure(200, "Body", ProtocolException.class,
-        "Expected HTTP 101 response but was '200 OK'");
-  }
-
-  @Test public void notFound() throws IOException {
-    webServer.enqueue(new MockResponse().setStatus("HTTP/1.1 404 Not Found"));
-    newWebSocket();
-
-    clientListener.assertFailure(404, null, ProtocolException.class,
-        "Expected HTTP 101 response but was '404 Not Found'");
-  }
-
-  @Test public void clientTimeoutClosesBody() {
-    webServer.enqueue(new MockResponse().setResponseCode(408));
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    WebSocket webSocket = newWebSocket();
-
-    clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
-
-    webSocket.send("abc");
-    serverListener.assertTextMessage("abc");
-
-    server.send("def");
-    clientListener.assertTextMessage("def");
-
-    closeWebSockets(webSocket, server);
-  }
-
-  @Test public void missingConnectionHeader() throws IOException {
-    webServer.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Upgrade", "websocket")
-        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
-    newWebSocket();
-
-    clientListener.assertFailure(101, null, ProtocolException.class,
-        "Expected 'Connection' header value 'Upgrade' but was 'null'");
-
-    ensureAllConnectionsReleased(client);
-  }
-
-  @Test public void wrongConnectionHeader() throws IOException {
-    webServer.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Upgrade", "websocket")
-        .setHeader("Connection", "Downgrade")
-        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
-    newWebSocket();
-
-    clientListener.assertFailure(101, null, ProtocolException.class,
-        "Expected 'Connection' header value 'Upgrade' but was 'Downgrade'");
-  }
-
-  @Test public void missingUpgradeHeader() throws IOException {
-    webServer.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Connection", "Upgrade")
-        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
-    newWebSocket();
-
-    clientListener.assertFailure(101, null, ProtocolException.class,
-        "Expected 'Upgrade' header value 'websocket' but was 'null'");
-  }
-
-  @Test public void wrongUpgradeHeader() throws IOException {
-    webServer.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Connection", "Upgrade")
-        .setHeader("Upgrade", "Pepsi")
-        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
-    newWebSocket();
-
-    clientListener.assertFailure(101, null, ProtocolException.class,
-        "Expected 'Upgrade' header value 'websocket' but was 'Pepsi'");
-  }
-
-  @Test public void missingMagicHeader() throws IOException {
-    webServer.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Connection", "Upgrade")
-        .setHeader("Upgrade", "websocket"));
-    newWebSocket();
-
-    clientListener.assertFailure(101, null, ProtocolException.class,
-        "Expected 'Sec-WebSocket-Accept' header value 'ujmZX4KXZqjwy6vi1aQFH5p4Ygk=' but was 'null'");
-  }
-
-  @Test public void wrongMagicHeader() throws IOException {
-    webServer.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Connection", "Upgrade")
-        .setHeader("Upgrade", "websocket")
-        .setHeader("Sec-WebSocket-Accept", "magic"));
-    newWebSocket();
-
-    clientListener.assertFailure(101, null, ProtocolException.class,
-        "Expected 'Sec-WebSocket-Accept' header value 'ujmZX4KXZqjwy6vi1aQFH5p4Ygk=' but was 'magic'");
-  }
-
-  @Test public void webSocketAndApplicationInterceptors() {
-    final AtomicInteger interceptedCount = new AtomicInteger();
-
-    client = client.newBuilder()
-        .addInterceptor(chain -> {
-          assertThat(chain.request().body()).isNull();
-          Response response = chain.proceed(chain.request());
-          assertThat(response.header("Connection")).isEqualTo("Upgrade");
-          assertThat(response.body().source().exhausted()).isTrue();
-          interceptedCount.incrementAndGet();
-          return response;
-        })
-        .build();
-
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-
-    WebSocket webSocket = newWebSocket();
-    clientListener.assertOpen();
-    assertThat(interceptedCount.get()).isEqualTo(1);
-    webSocket.close(1000, null);
-
-    WebSocket server = serverListener.assertOpen();
-    server.close(1000, null);
-    clientListener.assertClosing(1000, "");
-    clientListener.assertClosed(1000, "");
-  }
-
-  @Test public void webSocketAndNetworkInterceptors() {
-    client = client.newBuilder()
-        .addNetworkInterceptor(chain -> {
-          throw new AssertionError(); // Network interceptors don't execute.
-        })
-        .build();
-
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-
-    WebSocket webSocket = newWebSocket();
-    clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
-
-    closeWebSockets(webSocket, server);
-  }
-
-  @Test public void overflowOutgoingQueue() {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-
-    WebSocket webSocket = newWebSocket();
-    clientListener.assertOpen();
-
-    // Send messages until the client's outgoing buffer overflows!
-    ByteString message = ByteString.of(new byte[1024 * 1024]);
-    int messageCount = 0;
-    while (true) {
-      boolean success = webSocket.send(message);
-      if (!success) break;
-
-      messageCount++;
-      long queueSize = webSocket.queueSize();
-      assertThat(queueSize >= 0 && queueSize <= messageCount * message.size()).isTrue();
-      // Expect to fail before enqueueing 32 MiB.
-      assertThat(messageCount < 32).isTrue();
-    }
-
-    // Confirm all sent messages were received, followed by a client-initiated close.
-    WebSocket server = serverListener.assertOpen();
-    for (int i = 0; i < messageCount; i++) {
-      serverListener.assertBinaryMessage(message);
-    }
-    serverListener.assertClosing(1001, "");
-
-    // When the server acknowledges the close the connection shuts down gracefully.
-    server.close(1000, null);
-    clientListener.assertClosing(1000, "");
-    clientListener.assertClosed(1000, "");
-    serverListener.assertClosed(1001, "");
-  }
-
-  @Test public void closeReasonMaximumLength() {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-
-    String clientReason = repeat('C', 123);
-    String serverReason = repeat('S', 123);
-
-    WebSocket webSocket = newWebSocket();
-    WebSocket server = serverListener.assertOpen();
-
-    clientListener.assertOpen();
-    webSocket.close(1000, clientReason);
-    serverListener.assertClosing(1000, clientReason);
-
-    server.close(1000, serverReason);
-    clientListener.assertClosing(1000, serverReason);
-    clientListener.assertClosed(1000, serverReason);
-
-    serverListener.assertClosed(1000, clientReason);
-  }
-
-  @Test public void closeReasonTooLong() {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-
-    WebSocket webSocket = newWebSocket();
-    WebSocket server = serverListener.assertOpen();
-
-    clientListener.assertOpen();
-    String reason = repeat('X', 124);
-    try {
-      webSocket.close(1000, reason);
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo(("reason.size() > 123: " + reason));
-    }
-
-    webSocket.close(1000, null);
-    serverListener.assertClosing(1000, "");
-
-    server.close(1000, null);
-    clientListener.assertClosing(1000, "");
-    clientListener.assertClosed(1000, "");
-
-    serverListener.assertClosed(1000, "");
-  }
-
-  @Test public void wsScheme() {
-    websocketScheme("ws");
-  }
-
-  @Test public void wsUppercaseScheme() {
-    websocketScheme("WS");
-  }
-
-  @Test public void wssScheme() {
-    webServer.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-
-    websocketScheme("wss");
-  }
-
-  @Test public void httpsScheme() {
-    webServer.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-
-    websocketScheme("https");
-  }
-
-  @Test public void readTimeoutAppliesToHttpRequest() {
-    webServer.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.NO_RESPONSE));
-
-    WebSocket webSocket = newWebSocket();
-
-    clientListener.assertFailure(SocketTimeoutException.class, "timeout", "Read timed out");
-    assertThat(webSocket.close(1000, null)).isFalse();
-  }
-
-  /**
-   * There's no read timeout when reading the first byte of a new frame. But as soon as we start
-   * reading a frame we enable the read timeout. In this test we have the server returning the first
-   * byte of a frame but no more frames.
-   */
-  @Test public void readTimeoutAppliesWithinFrames() {
-    webServer.setDispatcher(new Dispatcher() {
-      @Override public MockResponse dispatch(RecordedRequest request) {
-        return upgradeResponse(request)
-            .setBody(new Buffer().write(ByteString.decodeHex("81"))) // Truncated frame.
-            .removeHeader("Content-Length")
-            .setSocketPolicy(SocketPolicy.KEEP_OPEN);
-      }
-    });
-
-    WebSocket webSocket = newWebSocket();
-    clientListener.assertOpen();
-
-    clientListener.assertFailure(SocketTimeoutException.class, "timeout", "Read timed out");
-    assertThat(webSocket.close(1000, null)).isFalse();
-  }
-
-  @Test public void readTimeoutDoesNotApplyAcrossFrames() throws Exception {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    WebSocket webSocket = newWebSocket();
-
-    clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
-
-    // Sleep longer than the HTTP client's read timeout.
-    Thread.sleep(client.readTimeoutMillis() + 500);
-
-    server.send("abc");
-    clientListener.assertTextMessage("abc");
-
-    closeWebSockets(webSocket, server);
-  }
-
-  @Test public void clientPingsServerOnInterval() throws Exception {
-    client = client.newBuilder()
-        .pingInterval(500, TimeUnit.MILLISECONDS)
-        .build();
-
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    RealWebSocket webSocket = newWebSocket();
-
-    clientListener.assertOpen();
-    RealWebSocket server = (RealWebSocket) serverListener.assertOpen();
-
-    long startNanos = System.nanoTime();
-    while (webSocket.receivedPongCount() < 3) {
-      Thread.sleep(50);
-    }
-
-    long elapsedUntilPong3 = System.nanoTime() - startNanos;
-    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilPong3)).isCloseTo((double) 1500, offset(
-        250d));
-
-    // The client pinged the server 3 times, and it has ponged back 3 times.
-    assertThat(webSocket.sentPingCount()).isEqualTo(3);
-    assertThat(server.receivedPingCount()).isEqualTo(3);
-    assertThat(webSocket.receivedPongCount()).isEqualTo(3);
-
-    // The server has never pinged the client.
-    assertThat(server.receivedPongCount()).isEqualTo(0);
-    assertThat(webSocket.receivedPingCount()).isEqualTo(0);
-
-    closeWebSockets(webSocket, server);
-  }
-
-  @Test public void clientDoesNotPingServerByDefault() throws Exception {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    RealWebSocket webSocket = newWebSocket();
-
-    clientListener.assertOpen();
-    RealWebSocket server = (RealWebSocket) serverListener.assertOpen();
-
-    Thread.sleep(1000);
-
-    // No pings and no pongs.
-    assertThat(webSocket.sentPingCount()).isEqualTo(0);
-    assertThat(webSocket.receivedPingCount()).isEqualTo(0);
-    assertThat(webSocket.receivedPongCount()).isEqualTo(0);
-    assertThat(server.sentPingCount()).isEqualTo(0);
-    assertThat(server.receivedPingCount()).isEqualTo(0);
-    assertThat(server.receivedPongCount()).isEqualTo(0);
-
-    closeWebSockets(webSocket, server);
-  }
-
-  /**
-   * Configure the websocket to send pings every 500 ms. Artificially prevent the server from
-   * responding to pings. The client should give up when attempting to send its 2nd ping, at about
-   * 1000 ms.
-   */
-  @Test public void unacknowledgedPingFailsConnection() {
-    client = client.newBuilder()
-        .pingInterval(500, TimeUnit.MILLISECONDS)
-        .build();
-
-    // Stall in onOpen to prevent pongs from being sent.
-    final CountDownLatch latch = new CountDownLatch(1);
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(new WebSocketListener() {
-      @Override public void onOpen(WebSocket webSocket, Response response) {
-        try {
-          latch.await(); // The server can't respond to pings!
-        } catch (InterruptedException e) {
-          throw new AssertionError(e);
-        }
-      }
-    }));
-
-    long openAtNanos = System.nanoTime();
-    newWebSocket();
-    clientListener.assertOpen();
-    clientListener.assertFailure(SocketTimeoutException.class,
-        "sent ping but didn't receive pong within 500ms (after 0 successful ping/pongs)");
-    latch.countDown();
-
-    long elapsedUntilFailure = System.nanoTime() - openAtNanos;
-    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure)).isCloseTo((double) 1000, offset(
-        250d));
-  }
-
-  /** https://github.com/square/okhttp/issues/2788 */
-  @Test public void clientCancelsIfCloseIsNotAcknowledged() {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    RealWebSocket webSocket = newWebSocket();
-
-    clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
-
-    // Initiate a close on the client, which will schedule a hard cancel in 500 ms.
-    long closeAtNanos = System.nanoTime();
-    webSocket.close(1000, "goodbye", 500);
-    serverListener.assertClosing(1000, "goodbye");
-
-    // Confirm that the hard cancel occurred after 500 ms.
-    clientListener.assertFailure();
-    long elapsedUntilFailure = System.nanoTime() - closeAtNanos;
-    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure)).isCloseTo((double) 500, offset(
-        250d));
-
-    // Close the server and confirm it saw what we expected.
-    server.close(1000, null);
-    serverListener.assertClosed(1000, "goodbye");
-  }
-
-  @Test public void webSocketsDontTriggerEventListener() {
-    RecordingEventListener listener = new RecordingEventListener();
-
-    client = client.newBuilder()
-        .eventListener(listener)
-        .build();
-
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    WebSocket webSocket = newWebSocket();
-
-    clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
-
-    webSocket.send("Web Sockets and Events?!");
-    serverListener.assertTextMessage("Web Sockets and Events?!");
-
-    webSocket.close(1000, "");
-    serverListener.assertClosing(1000, "");
-
-    server.close(1000, "");
-    clientListener.assertClosing(1000, "");
-    clientListener.assertClosed(1000, "");
-    serverListener.assertClosed(1000, "");
-
-    assertThat(listener.recordedEventTypes()).isEmpty();
-  }
-
-  @Test public void callTimeoutAppliesToSetup() throws Exception {
-    webServer.enqueue(new MockResponse()
-        .setHeadersDelay(500, TimeUnit.MILLISECONDS));
-
-    client = client.newBuilder()
-        .readTimeout(0, TimeUnit.MILLISECONDS)
-        .writeTimeout(0, TimeUnit.MILLISECONDS)
-        .callTimeout(100, TimeUnit.MILLISECONDS)
-        .build();
-
-    newWebSocket();
-    clientListener.assertFailure(InterruptedIOException.class, "timeout");
-  }
-
-  @Test public void callTimeoutDoesNotApplyOnceConnected() throws Exception {
-    client = client.newBuilder()
-        .callTimeout(100, TimeUnit.MILLISECONDS)
-        .build();
-
-    webServer.enqueue(new MockResponse()
-        .withWebSocketUpgrade(serverListener));
-    WebSocket webSocket = newWebSocket();
-
-    clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
-
-    Thread.sleep(500);
-
-    server.send("Hello, WebSockets!");
-    clientListener.assertTextMessage("Hello, WebSockets!");
-
-    closeWebSockets(webSocket, server);
-  }
-
-  /**
-   * We had a bug where web socket connections were leaked if the HTTP connection upgrade was not
-   * successful. This test confirms that connections are released back to the connection pool!
-   * https://github.com/square/okhttp/issues/4258
-   */
-  @Test public void webSocketConnectionIsReleased() throws Exception {
-    // This test assumes HTTP/1.1 pooling semantics.
-    client = client.newBuilder()
-        .protocols(Arrays.asList(Protocol.HTTP_1_1))
-        .build();
-
-    webServer.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_FOUND)
-        .setBody("not found!"));
-    webServer.enqueue(new MockResponse());
-
-    newWebSocket();
-    clientListener.assertFailure();
-
-    Request regularRequest = new Request.Builder()
-        .url(webServer.url("/"))
-        .build();
-    Response response = client.newCall(regularRequest).execute();
-    response.close();
-
-    assertThat(webServer.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(webServer.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  private MockResponse upgradeResponse(RecordedRequest request) {
-    String key = request.getHeader("Sec-WebSocket-Key");
-    return new MockResponse()
-        .setStatus("HTTP/1.1 101 Switching Protocols")
-        .setHeader("Connection", "Upgrade")
-        .setHeader("Upgrade", "websocket")
-        .setHeader("Sec-WebSocket-Accept", WebSocketProtocol.acceptHeader(key));
-  }
-
-  private void websocketScheme(String scheme) {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-
-    Request request = new Request.Builder()
-        .url(scheme + "://" + webServer.getHostName() + ":" + webServer.getPort() + "/")
-        .build();
-
-    RealWebSocket webSocket = newWebSocket(request);
-    clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
-
-    webSocket.send("abc");
-    serverListener.assertTextMessage("abc");
-
-    closeWebSockets(webSocket, server);
-  }
-
-  private RealWebSocket newWebSocket() {
-    return newWebSocket(new Request.Builder().get().url(webServer.url("/")).build());
-  }
-
-  private RealWebSocket newWebSocket(Request request) {
-    RealWebSocket webSocket = new RealWebSocket(
-        request, clientListener, random, client.pingIntervalMillis());
-    webSocket.connect(client);
-    return webSocket;
-  }
-
-  private void closeWebSockets(WebSocket webSocket, WebSocket server) {
-    server.close(1001, "");
-    clientListener.assertClosing(1001, "");
-    webSocket.close(1000, "");
-    serverListener.assertClosing(1000, "");
-    clientListener.assertClosed(1001, "");
-    serverListener.assertClosed(1000, "");
-    clientListener.assertExhausted();
-    serverListener.assertExhausted();
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
deleted file mode 100644
index 401f509265..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
+++ /dev/null
@@ -1,325 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.ws;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.util.Random;
-import java.util.regex.Pattern;
-import okhttp3.internal.Util;
-import okio.Buffer;
-import okio.ByteString;
-import org.junit.After;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class WebSocketReaderTest {
-  private final Buffer data = new Buffer();
-  private final WebSocketRecorder callback = new WebSocketRecorder("client");
-  private final Random random = new Random(0);
-
-  // Mutually exclusive. Use the one corresponding to the peer whose behavior you wish to test.
-  final WebSocketReader serverReader = new WebSocketReader(false, data, callback.asFrameCallback());
-  final WebSocketReader clientReader = new WebSocketReader(true, data, callback.asFrameCallback());
-
-  @After public void tearDown() {
-    callback.assertExhausted();
-  }
-
-  @Test public void controlFramesMustBeFinal() throws IOException {
-    data.write(ByteString.decodeHex("0a00")); // Empty ping.
-    try {
-      clientReader.processNextFrame();
-      fail();
-    } catch (ProtocolException e) {
-      assertThat(e.getMessage()).isEqualTo("Control frames must be final.");
-    }
-  }
-
-  @Test public void reservedFlagsAreUnsupported() throws IOException {
-    data.write(ByteString.decodeHex("9a00")); // Empty ping, flag 1 set.
-    try {
-      clientReader.processNextFrame();
-      fail();
-    } catch (ProtocolException e) {
-      assertThat(e.getMessage()).isEqualTo("Reserved flags are unsupported.");
-    }
-    data.clear();
-    data.write(ByteString.decodeHex("aa00")); // Empty ping, flag 2 set.
-    try {
-      clientReader.processNextFrame();
-      fail();
-    } catch (ProtocolException e) {
-      assertThat(e.getMessage()).isEqualTo("Reserved flags are unsupported.");
-    }
-    data.clear();
-    data.write(ByteString.decodeHex("ca00")); // Empty ping, flag 3 set.
-    try {
-      clientReader.processNextFrame();
-      fail();
-    } catch (ProtocolException e) {
-      assertThat(e.getMessage()).isEqualTo("Reserved flags are unsupported.");
-    }
-  }
-
-  @Test public void clientSentFramesMustBeMasked() throws IOException {
-    data.write(ByteString.decodeHex("8100"));
-    try {
-      serverReader.processNextFrame();
-      fail();
-    } catch (ProtocolException e) {
-      assertThat(e.getMessage()).isEqualTo("Client-sent frames must be masked.");
-    }
-  }
-
-  @Test public void serverSentFramesMustNotBeMasked() throws IOException {
-    data.write(ByteString.decodeHex("8180"));
-    try {
-      clientReader.processNextFrame();
-      fail();
-    } catch (ProtocolException e) {
-      assertThat(e.getMessage()).isEqualTo("Server-sent frames must not be masked.");
-    }
-  }
-
-  @Test public void controlFramePayloadMax() throws IOException {
-    data.write(ByteString.decodeHex("8a7e007e"));
-    try {
-      clientReader.processNextFrame();
-      fail();
-    } catch (ProtocolException e) {
-      assertThat(e.getMessage()).isEqualTo("Control frame must be less than 125B.");
-    }
-  }
-
-  @Test public void clientSimpleHello() throws IOException {
-    data.write(ByteString.decodeHex("810548656c6c6f")); // Hello
-    clientReader.processNextFrame();
-    callback.assertTextMessage("Hello");
-  }
-
-  @Test public void serverSimpleHello() throws IOException {
-    data.write(ByteString.decodeHex("818537fa213d7f9f4d5158")); // Hello
-    serverReader.processNextFrame();
-    callback.assertTextMessage("Hello");
-  }
-
-  @Test public void clientFramePayloadShort() throws IOException {
-    data.write(ByteString.decodeHex("817E000548656c6c6f")); // Hello
-    clientReader.processNextFrame();
-    callback.assertTextMessage("Hello");
-  }
-
-  @Test public void clientFramePayloadLong() throws IOException {
-    data.write(ByteString.decodeHex("817f000000000000000548656c6c6f")); // Hello
-    clientReader.processNextFrame();
-    callback.assertTextMessage("Hello");
-  }
-
-  @Test public void clientFramePayloadTooLongThrows() throws IOException {
-    data.write(ByteString.decodeHex("817f8000000000000000"));
-    try {
-      clientReader.processNextFrame();
-      fail();
-    } catch (ProtocolException e) {
-      assertThat(e.getMessage()).isEqualTo(
-          "Frame length 0x8000000000000000 > 0x7FFFFFFFFFFFFFFF");
-    }
-  }
-
-  @Test public void serverHelloTwoChunks() throws IOException {
-    data.write(ByteString.decodeHex("818537fa213d7f9f4d")); // Hel
-    data.write(ByteString.decodeHex("5158")); // lo
-
-    serverReader.processNextFrame();
-
-    callback.assertTextMessage("Hello");
-  }
-
-  @Test public void clientTwoFrameHello() throws IOException {
-    data.write(ByteString.decodeHex("010348656c")); // Hel
-    data.write(ByteString.decodeHex("80026c6f")); // lo
-    clientReader.processNextFrame();
-    callback.assertTextMessage("Hello");
-  }
-
-  @Test public void clientTwoFrameHelloWithPongs() throws IOException {
-    data.write(ByteString.decodeHex("010348656c")); // Hel
-    data.write(ByteString.decodeHex("8a00")); // Pong
-    data.write(ByteString.decodeHex("8a00")); // Pong
-    data.write(ByteString.decodeHex("8a00")); // Pong
-    data.write(ByteString.decodeHex("8a00")); // Pong
-    data.write(ByteString.decodeHex("80026c6f")); // lo
-    clientReader.processNextFrame();
-    callback.assertPong(ByteString.EMPTY);
-    callback.assertPong(ByteString.EMPTY);
-    callback.assertPong(ByteString.EMPTY);
-    callback.assertPong(ByteString.EMPTY);
-    callback.assertTextMessage("Hello");
-  }
-
-  @Test public void clientIncompleteMessageBodyThrows() throws IOException {
-    data.write(ByteString.decodeHex("810548656c")); // Length = 5, "Hel"
-    try {
-      clientReader.processNextFrame();
-      fail();
-    } catch (EOFException ignored) {
-    }
-  }
-
-  @Test public void clientIncompleteControlFrameBodyThrows() throws IOException {
-    data.write(ByteString.decodeHex("8a0548656c")); // Length = 5, "Hel"
-    try {
-      clientReader.processNextFrame();
-      fail();
-    } catch (EOFException ignored) {
-    }
-  }
-
-  @Test public void serverIncompleteMessageBodyThrows() throws IOException {
-    data.write(ByteString.decodeHex("818537fa213d7f9f4d")); // Length = 5, "Hel"
-    try {
-      serverReader.processNextFrame();
-      fail();
-    } catch (EOFException ignored) {
-    }
-  }
-
-  @Test public void serverIncompleteControlFrameBodyThrows() throws IOException {
-    data.write(ByteString.decodeHex("8a8537fa213d7f9f4d")); // Length = 5, "Hel"
-    try {
-      serverReader.processNextFrame();
-      fail();
-    } catch (EOFException ignored) {
-    }
-  }
-
-  @Test public void clientSimpleBinary() throws IOException {
-    byte[] bytes = binaryData(256);
-    data.write(ByteString.decodeHex("827E0100")).write(bytes);
-    clientReader.processNextFrame();
-    callback.assertBinaryMessage(ByteString.of(bytes));
-  }
-
-  @Test public void clientTwoFrameBinary() throws IOException {
-    byte[] bytes = binaryData(200);
-    data.write(ByteString.decodeHex("0264")).write(bytes, 0, 100);
-    data.write(ByteString.decodeHex("8064")).write(bytes, 100, 100);
-    clientReader.processNextFrame();
-    callback.assertBinaryMessage(ByteString.of(bytes));
-  }
-
-  @Test public void twoFrameNotContinuation() throws IOException {
-    byte[] bytes = binaryData(200);
-    data.write(ByteString.decodeHex("0264")).write(bytes, 0, 100);
-    data.write(ByteString.decodeHex("8264")).write(bytes, 100, 100);
-    try {
-      clientReader.processNextFrame();
-      fail();
-    } catch (ProtocolException e) {
-      assertThat(e.getMessage()).isEqualTo("Expected continuation opcode. Got: 2");
-    }
-  }
-
-  @Test public void emptyPingCallsCallback() throws IOException {
-    data.write(ByteString.decodeHex("8900")); // Empty ping
-    clientReader.processNextFrame();
-    callback.assertPing(ByteString.EMPTY);
-  }
-
-  @Test public void pingCallsCallback() throws IOException {
-    data.write(ByteString.decodeHex("890548656c6c6f")); // Ping with "Hello"
-    clientReader.processNextFrame();
-    callback.assertPing(ByteString.encodeUtf8("Hello"));
-  }
-
-  @Test public void emptyCloseCallsCallback() throws IOException {
-    data.write(ByteString.decodeHex("8800")); // Empty close
-    clientReader.processNextFrame();
-    callback.assertClosing(1005, "");
-  }
-
-  @Test public void closeLengthOfOneThrows() throws IOException {
-    data.write(ByteString.decodeHex("880100")); // Close with invalid 1-byte payload
-    try {
-      clientReader.processNextFrame();
-      fail();
-    } catch (ProtocolException e) {
-      assertThat(e.getMessage()).isEqualTo("Malformed close payload length of 1.");
-    }
-  }
-
-  @Test public void closeCallsCallback() throws IOException {
-    data.write(ByteString.decodeHex("880703e848656c6c6f")); // Close with code and reason
-    clientReader.processNextFrame();
-    callback.assertClosing(1000, "Hello");
-  }
-
-  @Test public void closeIncompleteCallsCallback() throws IOException {
-    data.write(ByteString.decodeHex("880703e948656c6c6f")); // Close with code and reason
-    data.close();
-    clientReader.processNextFrame();
-    callback.assertClosing(1001, "Hello");
-  }
-
-  @Test public void closeOutOfRangeThrows() throws IOException {
-    data.write(ByteString.decodeHex("88020001")); // Close with code 1
-    try {
-      clientReader.processNextFrame();
-      fail();
-    } catch (ProtocolException e) {
-      assertThat(e.getMessage()).isEqualTo("Code must be in range [1000,5000): 1");
-    }
-    data.write(ByteString.decodeHex("88021388")); // Close with code 5000
-    try {
-      clientReader.processNextFrame();
-      fail();
-    } catch (ProtocolException e) {
-      assertThat(e.getMessage()).isEqualTo("Code must be in range [1000,5000): 5000");
-    }
-  }
-
-  @Test public void closeReservedSetThrows() throws IOException {
-    data.write(ByteString.decodeHex("880203ec")); // Close with code 1004
-    data.write(ByteString.decodeHex("880203ed")); // Close with code 1005
-    data.write(ByteString.decodeHex("880203ee")); // Close with code 1006
-    for (int i = 1012; i <= 2999; i++) {
-      data.write(ByteString.decodeHex("8802" + Util.format("%04X", i))); // Close with code 'i'
-    }
-
-    int count = 0;
-    for (; !data.exhausted(); count++) {
-      try {
-        clientReader.processNextFrame();
-        fail();
-      } catch (ProtocolException e) {
-        String message = e.getMessage();
-        assertThat(Pattern.matches("Code \\d+ is reserved and may not be used.", message)).overridingErrorMessage(
-            message).isTrue();
-      }
-    }
-    assertThat(count).isEqualTo(1991);
-  }
-
-  private byte[] binaryData(int length) {
-    byte[] junk = new byte[length];
-    random.nextBytes(junk);
-    return junk;
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
deleted file mode 100644
index d46205c5f2..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
+++ /dev/null
@@ -1,404 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.ws;
-
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.Objects;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.TimeUnit;
-import javax.annotation.Nullable;
-import okhttp3.Response;
-import okhttp3.WebSocket;
-import okhttp3.WebSocketListener;
-import okhttp3.internal.platform.Platform;
-import okio.ByteString;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public final class WebSocketRecorder extends WebSocketListener {
-  private final String name;
-  private final BlockingQueue<Object> events = new LinkedBlockingQueue<>();
-  private WebSocketListener delegate;
-
-  public WebSocketRecorder(String name) {
-    this.name = name;
-  }
-
-  /** Sets a delegate for handling the next callback to this listener. Cleared after invoked. */
-  public void setNextEventDelegate(WebSocketListener delegate) {
-    this.delegate = delegate;
-  }
-
-  @Override public void onOpen(WebSocket webSocket, Response response) {
-    Platform.get().log(Platform.INFO, "[WS " + name + "] onOpen", null);
-
-    WebSocketListener delegate = this.delegate;
-    if (delegate != null) {
-      this.delegate = null;
-      delegate.onOpen(webSocket, response);
-    } else {
-      events.add(new Open(webSocket, response));
-    }
-  }
-
-  @Override public void onMessage(WebSocket webSocket, ByteString bytes) {
-    Platform.get().log(Platform.INFO, "[WS " + name + "] onMessage", null);
-
-    WebSocketListener delegate = this.delegate;
-    if (delegate != null) {
-      this.delegate = null;
-      delegate.onMessage(webSocket, bytes);
-    } else {
-      Message event = new Message(bytes);
-      events.add(event);
-    }
-  }
-
-  @Override public void onMessage(WebSocket webSocket, String text) {
-    Platform.get().log(Platform.INFO, "[WS " + name + "] onMessage", null);
-
-    WebSocketListener delegate = this.delegate;
-    if (delegate != null) {
-      this.delegate = null;
-      delegate.onMessage(webSocket, text);
-    } else {
-      Message event = new Message(text);
-      events.add(event);
-    }
-  }
-
-  @Override public void onClosing(WebSocket webSocket, int code, String reason) {
-    Platform.get().log(Platform.INFO, "[WS " + name + "] onClosing " + code, null);
-
-    WebSocketListener delegate = this.delegate;
-    if (delegate != null) {
-      this.delegate = null;
-      delegate.onClosing(webSocket, code, reason);
-    } else {
-      events.add(new Closing(code, reason));
-    }
-  }
-
-  @Override public void onClosed(WebSocket webSocket, int code, String reason) {
-    Platform.get().log(Platform.INFO, "[WS " + name + "] onClosed " + code, null);
-
-    WebSocketListener delegate = this.delegate;
-    if (delegate != null) {
-      this.delegate = null;
-      delegate.onClosed(webSocket, code, reason);
-    } else {
-      events.add(new Closed(code, reason));
-    }
-  }
-
-  @Override public void onFailure(WebSocket webSocket, Throwable t, @Nullable Response response)  {
-    Platform.get().log(Platform.INFO, "[WS " + name + "] onFailure", t);
-
-    WebSocketListener delegate = this.delegate;
-    if (delegate != null) {
-      this.delegate = null;
-      delegate.onFailure(webSocket, t, response);
-    } else {
-      events.add(new Failure(t, response));
-    }
-  }
-
-  private Object nextEvent() {
-    try {
-      Object event = events.poll(10, TimeUnit.SECONDS);
-      if (event == null) {
-        throw new AssertionError("Timed out waiting for event.");
-      }
-      return event;
-    } catch (InterruptedException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  public void assertTextMessage(String payload) {
-    Object actual = nextEvent();
-    assertThat(actual).isEqualTo(new Message(payload));
-  }
-
-  public void assertBinaryMessage(ByteString payload) {
-    Object actual = nextEvent();
-    assertThat(actual).isEqualTo(new Message(payload));
-  }
-
-  public void assertPing(ByteString payload) {
-    Object actual = nextEvent();
-    assertThat(actual).isEqualTo(new Ping(payload));
-  }
-
-  public void assertPong(ByteString payload) {
-    Object actual = nextEvent();
-    assertThat(actual).isEqualTo(new Pong(payload));
-  }
-
-  public void assertClosing(int code, String reason) {
-    Object actual = nextEvent();
-    assertThat(actual).isEqualTo(new Closing(code, reason));
-  }
-
-  public void assertClosed(int code, String reason) {
-    Object actual = nextEvent();
-    assertThat(actual).isEqualTo(new Closed(code, reason));
-  }
-
-  public void assertExhausted() {
-    assertThat(events.isEmpty()).overridingErrorMessage("Remaining events: " + events).isTrue();
-  }
-
-  public WebSocket assertOpen() {
-    Object event = nextEvent();
-    if (!(event instanceof Open)) {
-      throw new AssertionError("Expected Open but was " + event);
-    }
-    return ((Open) event).webSocket;
-  }
-
-  public void assertFailure(Throwable t) {
-    Object event = nextEvent();
-    if (!(event instanceof Failure)) {
-      throw new AssertionError("Expected Failure but was " + event);
-    }
-    Failure failure = (Failure) event;
-    assertThat(failure.response).isNull();
-    assertThat(failure.t).isSameAs(t);
-  }
-
-  public void assertFailure(Class<? extends IOException> cls, String... messages) {
-    Object event = nextEvent();
-    if (!(event instanceof Failure)) {
-      throw new AssertionError("Expected Failure but was " + event);
-    }
-    Failure failure = (Failure) event;
-    assertThat(failure.response).isNull();
-    assertThat(failure.t.getClass()).isEqualTo(cls);
-    if (messages.length > 0) {
-      assertThat(Arrays.asList(messages).contains(failure.t.getMessage())).overridingErrorMessage(
-          failure.t.getMessage()).isTrue();
-    }
-  }
-
-  public void assertFailure() {
-    Object event = nextEvent();
-    if (!(event instanceof Failure)) {
-      throw new AssertionError("Expected Failure but was " + event);
-    }
-  }
-
-  public void assertFailure(int code, String body, Class<? extends IOException> cls, String message)
-      throws IOException {
-    Object event = nextEvent();
-    if (!(event instanceof Failure)) {
-      throw new AssertionError("Expected Failure but was " + event);
-    }
-    Failure failure = (Failure) event;
-    assertThat(failure.response.code()).isEqualTo(code);
-    if (body != null) {
-      assertThat(failure.responseBody).isEqualTo(body);
-    }
-    assertThat(failure.t.getClass()).isEqualTo(cls);
-    assertThat(failure.t.getMessage()).isEqualTo(message);
-  }
-
-  /** Expose this recorder as a frame callback and shim in "ping" events. */
-  public WebSocketReader.FrameCallback asFrameCallback() {
-    return new WebSocketReader.FrameCallback() {
-      @Override public void onReadMessage(String text) throws IOException {
-        onMessage(null, text);
-      }
-
-      @Override public void onReadMessage(ByteString bytes) throws IOException {
-        onMessage(null, bytes);
-      }
-
-      @Override public void onReadPing(ByteString payload) {
-        events.add(new Ping(payload));
-      }
-
-      @Override public void onReadPong(ByteString payload) {
-        events.add(new Pong(payload));
-      }
-
-      @Override public void onReadClose(int code, String reason) {
-        onClosing(null, code, reason);
-      }
-    };
-  }
-
-  static final class Open {
-    final WebSocket webSocket;
-    final Response response;
-
-    Open(WebSocket webSocket, Response response) {
-      this.webSocket = webSocket;
-      this.response = response;
-    }
-
-    @Override public String toString() {
-      return "Open[" + response + "]";
-    }
-  }
-
-  static final class Failure {
-    final Throwable t;
-    final Response response;
-    final String responseBody;
-
-    Failure(Throwable t, Response response) {
-      this.t = t;
-      this.response = response;
-      String responseBody = null;
-      if (response != null) {
-        try {
-          responseBody = response.body().string();
-        } catch (IOException ignored) {
-        }
-      }
-      this.responseBody = responseBody;
-    }
-
-    @Override public String toString() {
-      if (response == null) {
-        return "Failure[" + t + "]";
-      }
-      return "Failure[" + response + "]";
-    }
-  }
-
-  static final class Message {
-    public final ByteString bytes;
-    public final String string;
-
-    public Message(ByteString bytes) {
-      this.bytes = bytes;
-      this.string = null;
-    }
-
-    public Message(String string) {
-      this.bytes = null;
-      this.string = string;
-    }
-
-    @Override public String toString() {
-      return "Message[" + (bytes != null ? bytes : string) + "]";
-    }
-
-    @Override public int hashCode() {
-      return (bytes != null ? bytes : string).hashCode();
-    }
-
-    @Override public boolean equals(Object other) {
-      return other instanceof Message
-          && Objects.equals(((Message) other).bytes, bytes)
-          && Objects.equals(((Message) other).string, string);
-    }
-  }
-
-  static final class Ping {
-    public final ByteString payload;
-
-    public Ping(ByteString payload) {
-      this.payload = payload;
-    }
-
-    @Override public String toString() {
-      return "Ping[" + payload + "]";
-    }
-
-    @Override public int hashCode() {
-      return payload.hashCode();
-    }
-
-    @Override public boolean equals(Object other) {
-      return other instanceof Ping
-          && ((Ping) other).payload.equals(payload);
-    }
-  }
-
-  static final class Pong {
-    public final ByteString payload;
-
-    public Pong(ByteString payload) {
-      this.payload = payload;
-    }
-
-    @Override public String toString() {
-      return "Pong[" + payload + "]";
-    }
-
-    @Override public int hashCode() {
-      return payload.hashCode();
-    }
-
-    @Override public boolean equals(Object other) {
-      return other instanceof Pong
-          && ((Pong) other).payload.equals(payload);
-    }
-  }
-
-  static final class Closing {
-    public final int code;
-    public final String reason;
-
-    Closing(int code, String reason) {
-      this.code = code;
-      this.reason = reason;
-    }
-
-    @Override public String toString() {
-      return "Closing[" + code + " " + reason + "]";
-    }
-
-    @Override public int hashCode() {
-      return code * 37 + reason.hashCode();
-    }
-
-    @Override public boolean equals(Object other) {
-      return other instanceof Closing
-          && ((Closing) other).code == code
-          && ((Closing) other).reason.equals(reason);
-    }
-  }
-
-  static final class Closed {
-    public final int code;
-    public final String reason;
-
-    Closed(int code, String reason) {
-      this.code = code;
-      this.reason = reason;
-    }
-
-    @Override public String toString() {
-      return "Closed[" + code + " " + reason + "]";
-    }
-
-    @Override public int hashCode() {
-      return code * 37 + reason.hashCode();
-    }
-
-    @Override public boolean equals(Object other) {
-      return other instanceof Closed
-          && ((Closed) other).code == code
-          && ((Closed) other).reason.equals(reason);
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
deleted file mode 100644
index 175df0ea7a..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
+++ /dev/null
@@ -1,411 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.ws;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.util.Random;
-import okhttp3.RequestBody;
-import okhttp3.internal.Util;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.ByteString;
-import okio.Okio;
-import okio.Sink;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TestRule;
-import org.junit.runners.model.Statement;
-
-import static okhttp3.TestUtil.repeat;
-import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_BINARY;
-import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_TEXT;
-import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_BYTE_MAX;
-import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_SHORT_MAX;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class WebSocketWriterTest {
-  private final Buffer data = new Buffer();
-  private final Random random = new Random(0);
-
-  /**
-   * Check all data as verified inside of the test. We do this in a rule instead of @After so that
-   * exceptions thrown from the test do not cause this check to fail.
-   */
-  @Rule public final TestRule noDataLeftBehind = (base, description) -> new Statement() {
-    @Override public void evaluate() throws Throwable {
-      base.evaluate();
-      assertThat(data.readByteString().hex()).overridingErrorMessage("Data not empty").isEqualTo(
-          "");
-    }
-  };
-
-  // Mutually exclusive. Use the one corresponding to the peer whose behavior you wish to test.
-  private final WebSocketWriter serverWriter = new WebSocketWriter(false, data, random);
-  private final WebSocketWriter clientWriter = new WebSocketWriter(true, data, random);
-
-  @Test public void serverTextMessage() throws IOException {
-    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT, -1));
-
-    sink.writeUtf8("Hel").flush();
-    assertData("010348656c");
-
-    sink.writeUtf8("lo").flush();
-    assertData("00026c6f");
-
-    sink.close();
-    assertData("8000");
-  }
-
-  @Test public void serverSmallBufferedPayloadWrittenAsOneFrame() throws IOException {
-    int length = 5;
-    byte[] bytes = binaryData(length);
-
-    RequestBody body = RequestBody.create(null, bytes);
-    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT, length));
-    body.writeTo(sink);
-    sink.close();
-
-    assertData("8105");
-    assertData(bytes);
-    assertThat(data.exhausted()).isTrue();
-  }
-
-  @Test public void serverLargeBufferedPayloadWrittenAsOneFrame() throws IOException {
-    int length = 12345;
-    byte[] bytes = binaryData(length);
-
-    RequestBody body = RequestBody.create(null, bytes);
-    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT, length));
-    body.writeTo(sink);
-    sink.close();
-
-    assertData("817e");
-    assertData(Util.format("%04x", length));
-    assertData(bytes);
-    assertThat(data.exhausted()).isTrue();
-  }
-
-  @Test public void serverLargeNonBufferedPayloadWrittenAsMultipleFrames() throws IOException {
-    int length = 100_000;
-    Buffer bytes = new Buffer().write(binaryData(length));
-
-    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT, length));
-    Buffer body = bytes.clone();
-    sink.write(body.readByteString(20_000));
-    sink.write(body.readByteString(20_000));
-    sink.write(body.readByteString(20_000));
-    sink.write(body.readByteString(20_000));
-    sink.write(body.readByteString(20_000));
-    sink.close();
-
-    assertData("017e4000");
-    assertData(bytes.readByteArray(16_384));
-    assertData("007e4000");
-    assertData(bytes.readByteArray(16_384));
-    assertData("007e6000");
-    assertData(bytes.readByteArray(24_576));
-    assertData("007e4000");
-    assertData(bytes.readByteArray(16_384));
-    assertData("007e6000");
-    assertData(bytes.readByteArray(24_576));
-    assertData("807e06a0");
-    assertData(bytes.readByteArray(1_696));
-    assertThat(data.exhausted()).isTrue();
-  }
-
-  @Test public void closeFlushes() throws IOException {
-    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT, -1));
-
-    sink.writeUtf8("Hel").flush();
-    assertData("010348656c");
-
-    sink.writeUtf8("lo").close();
-    assertData("80026c6f");
-  }
-
-  @Test public void noWritesAfterClose() throws IOException {
-    Sink sink = serverWriter.newMessageSink(OPCODE_TEXT, -1);
-
-    sink.close();
-    assertData("8100");
-
-    Buffer payload = new Buffer().writeUtf8("Hello");
-    try {
-      // Write to the unbuffered sink as BufferedSink keeps its own closed state.
-      sink.write(payload, payload.size());
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo("closed");
-    }
-  }
-
-  @Test public void clientTextMessage() throws IOException {
-    BufferedSink sink = Okio.buffer(clientWriter.newMessageSink(OPCODE_TEXT, -1));
-
-    sink.writeUtf8("Hel").flush();
-    assertData("018360b420bb28d14c");
-
-    sink.writeUtf8("lo").flush();
-    assertData("00823851d9d4543e");
-
-    sink.close();
-    assertData("80807acb933d");
-  }
-
-  @Test public void serverBinaryMessage() throws IOException {
-    ByteString data = ByteString.decodeHex(""
-        + "60b420bb3851d9d47acb933dbe70399bf6c92da33af01d4fb7"
-        + "70e98c0325f41d3ebaf8986da712c82bcd4d554bf0b54023c2");
-
-    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_BINARY, -1));
-
-    sink.write(data).flush();
-    assertData("0232");
-    assertData(data);
-
-    sink.write(data).flush();
-    assertData("0032");
-    assertData(data);
-
-    sink.close();
-    assertData("8000");
-  }
-
-  @Test public void serverMessageLengthShort() throws IOException {
-    Sink sink = serverWriter.newMessageSink(OPCODE_BINARY, -1);
-
-    // Create a payload which will overflow the normal payload byte size.
-    Buffer payload = new Buffer();
-    while (payload.completeSegmentByteCount() <= PAYLOAD_BYTE_MAX) {
-      payload.writeByte('0');
-    }
-    long byteCount = payload.completeSegmentByteCount();
-
-    // Write directly to the unbuffered sink. This ensures it will become single frame.
-    sink.write(payload.clone(), byteCount);
-    assertData("027e"); // 'e' == 4-byte follow-up length.
-    assertData(Util.format("%04X", payload.completeSegmentByteCount()));
-    assertData(payload.readByteArray());
-
-    sink.close();
-    assertData("8000");
-  }
-
-  @Test public void serverMessageLengthLong() throws IOException {
-    Sink sink = serverWriter.newMessageSink(OPCODE_BINARY, -1);
-
-    // Create a payload which will overflow the normal and short payload byte size.
-    Buffer payload = new Buffer();
-    while (payload.completeSegmentByteCount() <= PAYLOAD_SHORT_MAX) {
-      payload.writeByte('0');
-    }
-    long byteCount = payload.completeSegmentByteCount();
-
-    // Write directly to the unbuffered sink. This ensures it will become single frame.
-    sink.write(payload.clone(), byteCount);
-    assertData("027f"); // 'f' == 16-byte follow-up length.
-    assertData(Util.format("%016X", byteCount));
-    assertData(payload.readByteArray(byteCount));
-
-    sink.close();
-    assertData("8000");
-  }
-
-  @Test public void clientBinary() throws IOException {
-    ByteString data = ByteString.decodeHex(""
-        + "60b420bb3851d9d47acb933dbe70399bf6c92da33af01d4fb7"
-        + "70e98c0325f41d3ebaf8986da712c82bcd4d554bf0b54023c2");
-
-    BufferedSink sink = Okio.buffer(clientWriter.newMessageSink(OPCODE_BINARY, -1));
-
-    sink.write(data).flush();
-    assertData("02b2");
-    assertData("60b420bb");
-    assertData(""
-        + "0000000058e5f96f1a7fb386dec41920967d0d185a443df4d7"
-        + "c4c9376391d4a65e0ed8230d1332734b796dee2b4495fb4376");
-
-    sink.write(data).close();
-    assertData("80b2");
-    assertData("3851d9d4");
-    assertData(""
-        + "58e5f96f00000000429a4ae98621e04fce98f47702a1c49b8f"
-        + "2130583b742dc906eb214c55f6cb1c139c948173a16c941b93");
-  }
-
-  @Test public void serverEmptyClose() throws IOException {
-    serverWriter.writeClose(0, null);
-    assertData("8800");
-  }
-
-  @Test public void serverCloseWithCode() throws IOException {
-    serverWriter.writeClose(1001, null);
-    assertData("880203e9");
-  }
-
-  @Test public void serverCloseWithCodeAndReason() throws IOException {
-    serverWriter.writeClose(1001, ByteString.encodeUtf8("Hello"));
-    assertData("880703e948656c6c6f");
-  }
-
-  @Test public void clientEmptyClose() throws IOException {
-    clientWriter.writeClose(0, null);
-    assertData("888060b420bb");
-  }
-
-  @Test public void clientCloseWithCode() throws IOException {
-    clientWriter.writeClose(1001, null);
-    assertData("888260b420bb635d");
-  }
-
-  @Test public void clientCloseWithCodeAndReason() throws IOException {
-    clientWriter.writeClose(1001, ByteString.encodeUtf8("Hello"));
-    assertData("888760b420bb635d68de0cd84f");
-  }
-
-  @Test public void closeWithOnlyReasonThrows() throws IOException {
-    clientWriter.writeClose(0, ByteString.encodeUtf8("Hello"));
-    assertData("888760b420bb60b468de0cd84f");
-  }
-
-  @Test public void closeCodeOutOfRangeThrows() throws IOException {
-    try {
-      clientWriter.writeClose(98724976, ByteString.encodeUtf8("Hello"));
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).isEqualTo("Code must be in range [1000,5000): 98724976");
-    }
-  }
-
-  @Test public void closeReservedThrows() throws IOException {
-    try {
-      clientWriter.writeClose(1005, ByteString.encodeUtf8("Hello"));
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).isEqualTo("Code 1005 is reserved and may not be used.");
-    }
-  }
-
-  @Test public void serverEmptyPing() throws IOException {
-    serverWriter.writePing(ByteString.EMPTY);
-    assertData("8900");
-  }
-
-  @Test public void clientEmptyPing() throws IOException {
-    clientWriter.writePing(ByteString.EMPTY);
-    assertData("898060b420bb");
-  }
-
-  @Test public void serverPingWithPayload() throws IOException {
-    serverWriter.writePing(ByteString.encodeUtf8("Hello"));
-    assertData("890548656c6c6f");
-  }
-
-  @Test public void clientPingWithPayload() throws IOException {
-    clientWriter.writePing(ByteString.encodeUtf8("Hello"));
-    assertData("898560b420bb28d14cd70f");
-  }
-
-  @Test public void serverEmptyPong() throws IOException {
-    serverWriter.writePong(ByteString.EMPTY);
-    assertData("8a00");
-  }
-
-  @Test public void clientEmptyPong() throws IOException {
-    clientWriter.writePong(ByteString.EMPTY);
-    assertData("8a8060b420bb");
-  }
-
-  @Test public void serverPongWithPayload() throws IOException {
-    serverWriter.writePong(ByteString.encodeUtf8("Hello"));
-    assertData("8a0548656c6c6f");
-  }
-
-  @Test public void clientPongWithPayload() throws IOException {
-    clientWriter.writePong(ByteString.encodeUtf8("Hello"));
-    assertData("8a8560b420bb28d14cd70f");
-  }
-
-  @Test public void pingTooLongThrows() throws IOException {
-    try {
-      serverWriter.writePing(ByteString.of(binaryData(1000)));
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).isEqualTo(
-          "Payload size must be less than or equal to 125");
-    }
-  }
-
-  @Test public void pongTooLongThrows() throws IOException {
-    try {
-      serverWriter.writePong(ByteString.of(binaryData(1000)));
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).isEqualTo(
-          "Payload size must be less than or equal to 125");
-    }
-  }
-
-  @Test public void closeTooLongThrows() throws IOException {
-    try {
-      ByteString longReason = ByteString.encodeUtf8(repeat('X', 124));
-      serverWriter.writeClose(1000, longReason);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).isEqualTo(
-          "Payload size must be less than or equal to 125");
-    }
-  }
-
-  @Test public void twoMessageSinksThrows() {
-    clientWriter.newMessageSink(OPCODE_TEXT, -1);
-    try {
-      clientWriter.newMessageSink(OPCODE_TEXT, -1);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e.getMessage()).isEqualTo(
-          "Another message writer is active. Did you call close()?");
-    }
-  }
-
-  private void assertData(String hex) throws EOFException {
-    assertData(ByteString.decodeHex(hex));
-  }
-
-  private void assertData(ByteString expected) throws EOFException {
-    ByteString actual = data.readByteString(expected.size());
-    assertThat(actual).isEqualTo(expected);
-  }
-
-  private void assertData(byte[] data) throws IOException {
-    int byteCount = 16;
-    for (int i = 0; i < data.length; i += byteCount) {
-      int count = Math.min(byteCount, data.length - i);
-      Buffer expectedChunk = new Buffer();
-      expectedChunk.write(data, i, count);
-      assertThat(this.data.readByteString(count)).overridingErrorMessage("At " + i).isEqualTo(
-          expectedChunk.readByteString());
-    }
-  }
-
-  private static byte[] binaryData(int length) {
-    byte[] junk = new byte[length];
-    new Random(0).nextBytes(junk);
-    return junk;
-  }
-}
diff --git a/okhttp-tests/src/test/resources/web-platform-test-urltestdata.txt b/okhttp-tests/src/test/resources/web-platform-test-urltestdata.txt
deleted file mode 100644
index 87c4f67135..0000000000
--- a/okhttp-tests/src/test/resources/web-platform-test-urltestdata.txt
+++ /dev/null
@@ -1,342 +0,0 @@
-# FORMAT NOT DOCUMENTED YET (parser is urltestparser.js)
-
-# Based on http://trac.webkit.org/browser/trunk/LayoutTests/fast/url/script-tests/segments.js
-http://example\t.\norg http://example.org/foo/bar s:http h:example.org p:/
-http://user:pass@foo:21/bar;par?b#c  s:http u:user pass:pass h:foo port:21 p:/bar;par q:?b f:#c
-http:foo.com  s:http h:example.org p:/foo/foo.com
-\t\s\s\s:foo.com\s\s\s\n  s:http h:example.org p:/foo/:foo.com
-\sfoo.com\s\s  s:http h:example.org p:/foo/foo.com
-a:\t\sfoo.com  s:a p:\sfoo.com
-http://f:21/\sb\s?\sd\s#\se\s  s:http h:f port:21 p:/%20b%20 q:?%20d%20 f:#\se
-http://f:/c  s:http h:f p:/c
-http://f:0/c  s:http h:f port:0 p:/c
-http://f:00000000000000/c  s:http h:f port:0 p:/c
-http://f:00000000000000000000080/c  s:http h:f p:/c
-http://f:b/c
-http://f:\s/c
-http://f:\n/c  s:http h:f p:/c
-http://f:fifty-two/c
-http://f:999999/c  s:http h:f port:999999 p:/c
-http://f:\s21\s/\sb\s?\sd\s#\se\s
-  s:http h:example.org p:/foo/bar
-\s\s\t  s:http h:example.org p:/foo/bar
-:foo.com/  s:http h:example.org p:/foo/:foo.com/
-:foo.com\\  s:http h:example.org p:/foo/:foo.com/
-:  s:http h:example.org p:/foo/:
-:a  s:http h:example.org p:/foo/:a
-:/  s:http h:example.org p:/foo/:/
-:\\  s:http h:example.org p:/foo/:/
-:#  s:http h:example.org p:/foo/: f:#
-\#  s:http h:example.org p:/foo/bar f:#
-\#/  s:http h:example.org p:/foo/bar f:#/
-\#\\  s:http h:example.org p:/foo/bar f:#\\
-\#;?  s:http h:example.org p:/foo/bar f:#;?
-?  s:http h:example.org p:/foo/bar q:?
-/  s:http h:example.org p:/
-:23  s:http h:example.org p:/foo/:23
-/:23  s:http h:example.org p:/:23
-::  s:http h:example.org p:/foo/::
-::23  s:http h:example.org p:/foo/::23
-foo://  s:foo p://
-http://a:b@c:29/d  s:http u:a pass:b h:c port:29 p:/d
-http::@c:29  s:http h:example.org p:/foo/:@c:29
-http://&a:foo(b]c@d:2/  s:http u:&a pass:foo(b]c h:d port:2 p:/
-http://::@c@d:2  s:http pass::%40c h:d port:2 p:/
-http://foo.com:b@d/  s:http u:foo.com pass:b h:d p:/
-http://foo.com/\\@  s:http h:foo.com p://@
-http:\\\\foo.com\\  s:http h:foo.com p:/
-http:\\\\a\\b:c\\d@foo.com\\  s:http h:a p:/b:c/d@foo.com/
-foo:/  s:foo p:/
-foo:/bar.com/  s:foo p:/bar.com/
-foo://///////  s:foo p://///////
-foo://///////bar.com/  s:foo p://///////bar.com/
-foo:////://///  s:foo p:////://///
-c:/foo  s:c p:/foo
-//foo/bar  s:http h:foo p:/bar
-http://foo/path;a??e#f#g  s:http h:foo p:/path;a q:??e f:#f#g
-http://foo/abcd?efgh?ijkl  s:http h:foo p:/abcd q:?efgh?ijkl
-http://foo/abcd#foo?bar  s:http h:foo p:/abcd f:#foo?bar
-[61:24:74]:98  s:http h:example.org p:/foo/[61:24:74]:98
-http:[61:27]/:foo  s:http h:example.org p:/foo/[61:27]/:foo
-http://[1::2]:3:4
-http://2001::1
-http://2001::1]
-http://2001::1]:80
-http://[2001::1]  s:http h:[2001::1] p:/
-http://[2001::1]:80  s:http h:[2001::1] p:/
-http:/example.com/  s:http h:example.org p:/example.com/
-ftp:/example.com/  s:ftp h:example.com p:/
-https:/example.com/  s:https h:example.com p:/
-madeupscheme:/example.com/  s:madeupscheme p:/example.com/
-file:/example.com/  s:file p:/example.com/
-ftps:/example.com/  s:ftps p:/example.com/
-gopher:/example.com/  s:gopher h:example.com p:/
-ws:/example.com/  s:ws h:example.com p:/
-wss:/example.com/  s:wss h:example.com p:/
-data:/example.com/  s:data p:/example.com/
-javascript:/example.com/  s:javascript p:/example.com/
-mailto:/example.com/  s:mailto p:/example.com/
-http:example.com/  s:http h:example.org p:/foo/example.com/
-ftp:example.com/  s:ftp h:example.com p:/
-https:example.com/  s:https h:example.com p:/
-madeupscheme:example.com/  s:madeupscheme p:example.com/
-ftps:example.com/  s:ftps p:example.com/
-gopher:example.com/  s:gopher h:example.com p:/
-ws:example.com/  s:ws h:example.com p:/
-wss:example.com/  s:wss h:example.com p:/
-data:example.com/  s:data p:example.com/
-javascript:example.com/  s:javascript p:example.com/
-mailto:example.com/  s:mailto p:example.com/
-/a/b/c  s:http h:example.org p:/a/b/c
-/a/\s/c  s:http h:example.org p:/a/%20/c
-/a%2fc  s:http h:example.org p:/a%2fc
-/a/%2f/c  s:http h:example.org p:/a/%2f/c
-\#\u03B2  s:http h:example.org p:/foo/bar f:#\u03B2
-data:text/html,test#test  s:data p:text/html,test f:#test
-
-# Based on http://trac.webkit.org/browser/trunk/LayoutTests/fast/url/file.html
-
-# Basic canonicalization, uppercase should be converted to lowercase
-file:c:\\foo\\bar.html file:///tmp/mock/path s:file p:/c:/foo/bar.html
-
-# Spaces should fail
-\s\sFile:c|////foo\\bar.html  s:file p:/c:////foo/bar.html
-
-# This should fail
-C|/foo/bar  s:file p:/C:/foo/bar
-
-# This should fail
-/C|\\foo\\bar  s:file p:/C:/foo/bar
-//C|/foo/bar  s:file p:/C:/foo/bar
-//server/file  s:file h:server p:/file
-\\\\server\\file  s:file h:server p:/file
-/\\server/file  s:file h:server p:/file
-file:///foo/bar.txt  s:file p:/foo/bar.txt
-file:///home/me  s:file p:/home/me
-//  s:file p:/
-///  s:file p:/
-///test  s:file p:/test
-file://test  s:file h:test p:/
-file://localhost  s:file h:localhost p:/
-file://localhost/  s:file h:localhost p:/
-file://localhost/test  s:file h:localhost p:/test
-test  s:file p:/tmp/mock/test
-file:test  s:file p:/tmp/mock/test
-
-# Based on http://trac.webkit.org/browser/trunk/LayoutTests/fast/url/script-tests/path.js
-http://example.com/././foo about:blank s:http h:example.com p:/foo
-http://example.com/./.foo  s:http h:example.com p:/.foo
-http://example.com/foo/.  s:http h:example.com p:/foo/
-http://example.com/foo/./  s:http h:example.com p:/foo/
-http://example.com/foo/bar/..  s:http h:example.com p:/foo/
-http://example.com/foo/bar/../  s:http h:example.com p:/foo/
-http://example.com/foo/..bar  s:http h:example.com p:/foo/..bar
-http://example.com/foo/bar/../ton  s:http h:example.com p:/foo/ton
-http://example.com/foo/bar/../ton/../../a  s:http h:example.com p:/a
-http://example.com/foo/../../..  s:http h:example.com p:/
-http://example.com/foo/../../../ton  s:http h:example.com p:/ton
-http://example.com/foo/%2e  s:http h:example.com p:/foo/
-http://example.com/foo/%2e%2  s:http h:example.com p:/foo/%2e%2
-http://example.com/foo/%2e./%2e%2e/.%2e/%2e.bar  s:http h:example.com p:/%2e.bar
-http://example.com////../..  s:http h:example.com p://
-http://example.com/foo/bar//../..  s:http h:example.com p:/foo/
-http://example.com/foo/bar//..  s:http h:example.com p:/foo/bar/
-http://example.com/foo  s:http h:example.com p:/foo
-http://example.com/%20foo  s:http h:example.com p:/%20foo
-http://example.com/foo%  s:http h:example.com p:/foo%
-http://example.com/foo%2  s:http h:example.com p:/foo%2
-http://example.com/foo%2zbar  s:http h:example.com p:/foo%2zbar
-http://example.com/foo%2\u00C2\u00A9zbar  s:http h:example.com p:/foo%2%C3%82%C2%A9zbar
-http://example.com/foo%41%7a  s:http h:example.com p:/foo%41%7a
-http://example.com/foo\t\u0091%91  s:http h:example.com p:/foo%C2%91%91
-http://example.com/foo%00%51  s:http h:example.com p:/foo%00%51
-http://example.com/(%28:%3A%29)  s:http h:example.com p:/(%28:%3A%29)
-http://example.com/%3A%3a%3C%3c  s:http h:example.com p:/%3A%3a%3C%3c
-http://example.com/foo\tbar  s:http h:example.com p:/foobar
-http://example.com\\\\foo\\\\bar  s:http h:example.com p://foo//bar
-http://example.com/%7Ffp3%3Eju%3Dduvgw%3Dd  s:http h:example.com p:/%7Ffp3%3Eju%3Dduvgw%3Dd
-http://example.com/@asdf%40  s:http h:example.com p:/@asdf%40
-http://example.com/\u4F60\u597D\u4F60\u597D  s:http h:example.com p:/%E4%BD%A0%E5%A5%BD%E4%BD%A0%E5%A5%BD
-http://example.com/\u2025/foo  s:http h:example.com p:/%E2%80%A5/foo
-http://example.com/\uFEFF/foo  s:http h:example.com p:/%EF%BB%BF/foo
-http://example.com/\u202E/foo/\u202D/bar  s:http h:example.com p:/%E2%80%AE/foo/%E2%80%AD/bar
-
-# Based on http://trac.webkit.org/browser/trunk/LayoutTests/fast/url/script-tests/relative.js
-http://www.google.com/foo?bar=baz# about:blank s:http h:www.google.com p:/foo q:?bar=baz f:#
-http://www.google.com/foo?bar=baz#\s\u00BB  s:http h:www.google.com p:/foo q:?bar=baz f:#\s\u00BB
-data:test#\s\u00BB  s:data p:test f:#\s\u00BB
-http://[www.google.com]/
-http://www.google.com  s:http h:www.google.com p:/
-http://192.0x00A80001  s:http h:192.168.0.1 p:/
-http://www/foo%2Ehtml  s:http h:www p:/foo%2Ehtml
-http://www/foo/%2E/html  s:http h:www p:/foo/html
-http://user:pass@/
-http://%25DOMAIN:foobar@foodomain.com/  s:http u:%25DOMAIN pass:foobar h:foodomain.com p:/
-http:\\\\www.google.com\\foo  s:http h:www.google.com p:/foo
-http://foo:80/  s:http h:foo p:/
-http://foo:81/  s:http h:foo port:81 p:/
-httpa://foo:80/  s:httpa p://foo:80/
-http://foo:-80/
-https://foo:443/  s:https h:foo p:/
-https://foo:80/  s:https h:foo port:80 p:/
-ftp://foo:21/  s:ftp h:foo p:/
-ftp://foo:80/  s:ftp h:foo port:80 p:/
-gopher://foo:70/  s:gopher h:foo p:/
-gopher://foo:443/  s:gopher h:foo port:443 p:/
-ws://foo:80/  s:ws h:foo p:/
-ws://foo:81/  s:ws h:foo port:81 p:/
-ws://foo:443/  s:ws h:foo port:443 p:/
-ws://foo:815/  s:ws h:foo port:815 p:/
-wss://foo:80/  s:wss h:foo port:80 p:/
-wss://foo:81/  s:wss h:foo port:81 p:/
-wss://foo:443/  s:wss h:foo p:/
-wss://foo:815/  s:wss h:foo port:815 p:/
-http:/example.com/  s:http h:example.com p:/
-ftp:/example.com/  s:ftp h:example.com p:/
-https:/example.com/  s:https h:example.com p:/
-madeupscheme:/example.com/  s:madeupscheme p:/example.com/
-file:/example.com/  s:file p:/example.com/
-ftps:/example.com/  s:ftps p:/example.com/
-gopher:/example.com/  s:gopher h:example.com p:/
-ws:/example.com/  s:ws h:example.com p:/
-wss:/example.com/  s:wss h:example.com p:/
-data:/example.com/  s:data p:/example.com/
-javascript:/example.com/  s:javascript p:/example.com/
-mailto:/example.com/  s:mailto p:/example.com/
-http:example.com/  s:http h:example.com p:/
-ftp:example.com/  s:ftp h:example.com p:/
-https:example.com/  s:https h:example.com p:/
-madeupscheme:example.com/  s:madeupscheme p:example.com/
-ftps:example.com/  s:ftps p:example.com/
-gopher:example.com/  s:gopher h:example.com p:/
-ws:example.com/  s:ws h:example.com p:/
-wss:example.com/  s:wss h:example.com p:/
-data:example.com/  s:data p:example.com/
-javascript:example.com/  s:javascript p:example.com/
-mailto:example.com/  s:mailto p:example.com/
-
-# Based on http://trac.webkit.org/browser/trunk/LayoutTests/fast/url/segments-userinfo-vs-host.html
-http:@www.example.com about:blank s:http h:www.example.com p:/
-http:/@www.example.com  s:http h:www.example.com p:/
-http://@www.example.com  s:http h:www.example.com p:/
-http:a:b@www.example.com  s:http u:a pass:b h:www.example.com p:/
-http:/a:b@www.example.com  s:http u:a pass:b h:www.example.com p:/
-http://a:b@www.example.com  s:http u:a pass:b h:www.example.com p:/
-http://@pple.com  s:http h:pple.com p:/
-http::b@www.example.com  s:http pass:b h:www.example.com p:/
-http:/:b@www.example.com  s:http pass:b h:www.example.com p:/
-http://:b@www.example.com  s:http pass:b h:www.example.com p:/
-http:/:@/www.example.com
-http://user@/www.example.com
-http:@/www.example.com
-http:/@/www.example.com
-http://@/www.example.com
-https:@/www.example.com
-http:a:b@/www.example.com
-http:/a:b@/www.example.com
-http://a:b@/www.example.com
-http::@/www.example.com
-http:a:@www.example.com  s:http u:a pass: h:www.example.com p:/
-http:/a:@www.example.com  s:http u:a pass: h:www.example.com p:/
-http://a:@www.example.com  s:http u:a pass: h:www.example.com p:/
-http://www.@pple.com  s:http u:www. h:pple.com p:/
-http:@:www.example.com
-http:/@:www.example.com
-http://@:www.example.com
-http://:@www.example.com  s:http pass: h:www.example.com p:/
-
-#Others
-/ http://www.example.com/test s:http h:www.example.com p:/
-/test.txt  s:http h:www.example.com p:/test.txt
-.  s:http h:www.example.com p:/
-..  s:http h:www.example.com p:/
-test.txt  s:http h:www.example.com p:/test.txt
-./test.txt  s:http h:www.example.com p:/test.txt
-../test.txt  s:http h:www.example.com p:/test.txt
-../aaa/test.txt  s:http h:www.example.com p:/aaa/test.txt
-../../test.txt  s:http h:www.example.com p:/test.txt
-\u4E2D/test.txt  s:http h:www.example.com p:/%E4%B8%AD/test.txt
-http://www.example2.com  s:http h:www.example2.com p:/
-//www.example2.com  s:http h:www.example2.com p:/
-
-# Based on http://trac.webkit.org/browser/trunk/LayoutTests/fast/url/host.html
-
-# Basic canonicalization, uppercase should be converted to lowercase
-http://ExAmPlE.CoM http://other.com/ s:http p:/ h:example.com
-
-# Spaces should fail
-http://example\sexample.com
-
-# This should fail
-http://Goo%20\sgoo%7C|.com
-
-# U+3000 is mapped to U+0020 (space) which is disallowed
-http://GOO\u00a0\u3000goo.com
-
-# Other types of space (no-break, zero-width, zero-width-no-break) are
-# name-prepped away to nothing.
-# U+200B, U+2060, and U+FEFF, are ignored
-http://GOO\u200b\u2060\ufeffgoo.com  s:http p:/ h:googoo.com
-
-# Ideographic full stop (full-width period for Chinese, etc.) should be
-# treated as a dot.
-# U+3002 is mapped to U+002E (dot)
-http://www.foo\u3002bar.com  s:http p:/ h:www.foo.bar.com
-
-# Invalid unicode characters should fail...
-# U+FDD0 is disallowed; %ef%b7%90 is U+FDD0
-http://\ufdd0zyx.com
-
-# ...This is the same as previous but escaped.
-http://%ef%b7%90zyx.com
-
-# Test name prepping, fullwidth input should be converted to ASCII and NOT
-# IDN-ized. This is "Go" in fullwidth UTF-8/UTF-16.
-http://\uff27\uff4f.com  s:http p:/ h:go.com
-
-# URL spec forbids the following.
-# https://www.w3.org/Bugs/Public/show_bug.cgi?id=24257
-http://\uff05\uff14\uff11.com
-http://%ef%bc%85%ef%bc%94%ef%bc%91.com
-
-# ...%00 in fullwidth should fail (also as escaped UTF-8 input)
-http://\uff05\uff10\uff10.com
-http://%ef%bc%85%ef%bc%90%ef%bc%90.com
-
-# Basic IDN support, UTF-8 and UTF-16 input should be converted to IDN
-http://\u4f60\u597d\u4f60\u597d  s:http p:/ h:xn--6qqa088eba
-
-# Invalid escaped characters should fail and the percents should be
-# escaped. https://www.w3.org/Bugs/Public/show_bug.cgi?id=24191
-http://%zz%66%a.com
-
-# If we get an invalid character that has been escaped.
-http://%25
-http://hello%00
-
-# Escaped numbers should be treated like IP addresses if they are.
-# No special handling for IPv4 or IPv4-like URLs
-http://%30%78%63%30%2e%30%32%35%30.01  s:http p:/ h:192.168.0.1
-http://%30%78%63%30%2e%30%32%35%30.01%2e  s:http p:/ h:0xc0.0250.01.
-http://192.168.0.257
-
-# Invalid escaping should trigger the regular host error handling.
-http://%3g%78%63%30%2e%30%32%35%30%2E.01
-
-# Something that isn't exactly an IP should get treated as a host and
-# spaces escaped.
-http://192.168.0.1\shello
-
-# Fullwidth and escaped UTF-8 fullwidth should still be treated as IP.
-# These are "0Xc0.0250.01" in fullwidth.
-http://\uff10\uff38\uff43\uff10\uff0e\uff10\uff12\uff15\uff10\uff0e\uff10\uff11  s:http p:/ h:192.168.0.1
-
-# Broken IPv6
-http://[google.com]
-
-# Misc Unicode
-http://foo:\uD83D\uDCA9@example.com/bar  s:http h:example.com p:/bar u:foo pass:%F0%9F%92%A9
-
-# resolving a relative reference against an unknown scheme results in an error
-x test:test
-
diff --git a/okhttp-tls/README.md b/okhttp-tls/README.md
deleted file mode 100644
index 2ecaa5c3bf..0000000000
--- a/okhttp-tls/README.md
+++ /dev/null
@@ -1,246 +0,0 @@
-OkHttp TLS
-==========
-
-Approachable APIs for using TLS.
-
-A [`HeldCertificate`][held_certificate] is a certificate and its private key. Use the
-[builder][held_certificate_builder] to create a self-signed certificate that a test server can use
-for HTTPS:
-
-```java
-String localhost = InetAddress.getByName("localhost").getCanonicalHostName();
-HeldCertificate localhostCertificate = new HeldCertificate.Builder()
-    .addSubjectAlternativeName(localhost)
-    .build();
-```
-
-[`HandshakeCertificates`][handshake_certificates] keeps the certificates for a TLS handshake.
-Use its [builder][handshake_certificates_builder] to define which certificates the HTTPS server
-returns to its clients. The returned instance can create an `SSLSocketFactory` that implements this
-policy:
-
-```java
-HandshakeCertificates serverCertificates = new HandshakeCertificates.Builder()
-    .heldCertificate(localhostCertificate)
-    .build();
-MockWebServer server = new MockWebServer();
-server.useHttps(serverCertificates.sslSocketFactory(), false);
-```
-
-`HandshakeCertificates` also works for clients where its job is to define which root certificates
-to trust. In this simplified example we trust the server's self-signed certificate:
-
-```java
-HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder()
-    .addTrustedCertificate(localhostCertificate.certificate())
-    .build();
-OkHttpClient client = new OkHttpClient.Builder()
-    .sslSocketFactory(clientCertificates.sslSocketFactory(), clientCertificates.trustManager())
-    .build();
-```
-
-With a server that holds a certificate and a client that trusts it we have enough for an HTTPS
-handshake. The best part of this example is that we don't need to make our test code insecure with a
-a fake `HostnameVerifier` or `X509TrustManager`.
-
-Certificate Authorities
------------------------
-
-The above example uses a self-signed certificate. This is convenient for testing but not
-representative of real-world HTTPS deployment. To get closer to that we can use `HeldCertificate`
-to generate a trusted root certificate, an intermediate certificate, and a server certificate.
-We use `certificateAuthority(int)` to create certificates that can sign other certificates. The
-int specifies how many intermediate certificates are allowed beneath it in the chain.
-
-```java
-HeldCertificate rootCertificate = new HeldCertificate.Builder()
-    .certificateAuthority(1)
-    .build();
-
-HeldCertificate intermediateCertificate = new HeldCertificate.Builder()
-    .certificateAuthority(0)
-    .signedBy(rootCertificate)
-    .build();
-
-String localhost = InetAddress.getByName("localhost").getCanonicalHostName();
-HeldCertificate serverCertificate = new HeldCertificate.Builder()
-    .addSubjectAlternativeName(localhost)
-    .signedBy(intermediateCertificate)
-    .build();
-```
-
-To serve this configuration the server needs to provide its clients with a chain of certificates
-starting with its own and including everything up-to but not including the root. We don't need to
-include root certificates because the client already has them.
-
-```java
-HandshakeCertificates serverHandshakeCertificates = new HandshakeCertificates.Builder()
-    .heldCertificate(serverCertificate, intermediateCertificate.certificate())
-    .build();
-```
-
-The client only needs to know the trusted root certificate. It checks the server's certificate by
-validating the signatures within the chain.
-
-```java
-HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder()
-    .addTrustedCertificate(rootCertificate.certificate())
-    .build();
-OkHttpClient client = new OkHttpClient.Builder()
-    .sslSocketFactory(clientCertificates.sslSocketFactory(), clientCertificates.trustManager())
-    .build();
-```
-
-Client Authentication
----------------------
-
-The above scenario is representative of most TLS set ups: the client uses certificates to validate
-the identity of a server. The converse is also possible. Here we create a server that authenticates
-a client and a client that authenticates a server.
-
-```java
-// Create the root for client and server to trust. We could also use different roots for each!
-HeldCertificate rootCertificate = new HeldCertificate.Builder()
-    .certificateAuthority(0)
-    .build();
-
-// Create a server certificate and a server that uses it.
-HeldCertificate serverCertificate = new HeldCertificate.Builder()
-    .commonName("ingen")
-    .addSubjectAlternativeName(server.getHostName())
-    .signedBy(rootCertificate)
-    .build();
-HandshakeCertificates serverCertificates = new HandshakeCertificates.Builder()
-    .addTrustedCertificate(rootCertificate.certificate())
-    .heldCertificate(serverCertificate)
-    .build();
-MockWebServer server = new MockWebServer();
-server.useHttps(serverCertificates.sslSocketFactory(), false);
-server.requestClientAuth();
-server.enqueue(new MockResponse());
-
-// Create a client certificate and a client that uses it.
-HeldCertificate clientCertificate = new HeldCertificate.Builder()
-    .commonName("ianmalcolm")
-    .signedBy(rootCertificate)
-    .build();
-HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder()
-    .addTrustedCertificate(rootCertificate.certificate())
-    .heldCertificate(clientCertificate)
-    .build();
-OkHttpClient client = new OkHttpClient.Builder()
-    .sslSocketFactory(clientCertificates.sslSocketFactory(), clientCertificates.trustManager())
-    .build();
-
-// Connect 'em all together. Certificates are exchanged in the handshake.
-Call call = client.newCall(new Request.Builder()
-    .url(server.url("/"))
-    .build());
-Response response = call.execute();
-System.out.println(response.handshake().peerPrincipal());
-RecordedRequest recordedRequest = server.takeRequest();
-System.out.println(recordedRequest.getHandshake().peerPrincipal());
-```
-
-This handshake is successful because each party has prearranged to trust the root certificate that
-signs the other party's chain.
-
-Well-Known Certificate Authorities
-----------------------------------
-
-In these examples we've prearranged which root certificates to trust. But for regular HTTPS on the
-Internet this set of trusted root certificates is usually provided by default by the host platform.
-Such a set typically includes many root certificates from well-known certificate authorities like
-Entrust and Verisign.
-
-This is the behavior you'll get with your OkHttpClient if you don't specifically configure
-`HandshakeCertificates`. Or you can do it explicitly with `addPlatformTrustedCertificates()`:
-
-```java
-HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder()
-    .addPlatformTrustedCertificates()
-    .build();
-OkHttpClient client = new OkHttpClient.Builder()
-    .sslSocketFactory(clientCertificates.sslSocketFactory(), clientCertificates.trustManager())
-    .build();
-```
-
-PEM files
----------
-
-You can encode a `HeldCertificate` in PEM format:
-
-```java
-HeldCertificate heldCertificate = ...
-System.out.println(heldCertificate.certificatePem())
-```
-
-```
------BEGIN CERTIFICATE-----
-MIIBSjCB8aADAgECAgEBMAoGCCqGSM49BAMCMC8xLTArBgNVBAMTJDJiYWY3NzVl
-LWE4MzUtNDM5ZS1hYWE2LTgzNmNiNDlmMGM3MTAeFw0xODA3MTMxMjA0MzJaFw0x
-ODA3MTQxMjA0MzJaMC8xLTArBgNVBAMTJDJiYWY3NzVlLWE4MzUtNDM5ZS1hYWE2
-LTgzNmNiNDlmMGM3MTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABDmlOiZ3dxA2
-zw1KwqGNsKVUZbkUVj5cxV1jDbSTvTlOjSj6LR0Ovys9RFdrjcbbMLWvSvMQgHch
-k8Q50c6Kb34wCgYIKoZIzj0EAwIDSAAwRQIhAJkXiCbIR3zxuH5SQR5PEAPJ+ntg
-msOSMaAKwAePESf+AiBlxbEu6YpHt1ZJoAhMAv6raYnwSp/A94eJGlJynQ0igQ==
------END CERTIFICATE-----
-```
-
-You can also do so with the private key. Be careful with these!
-
-```java
-HeldCertificate heldCertificate = ...
-System.out.println(heldCertificate.privateKeyPkcs8Pem())
-```
-
-```
------BEGIN PRIVATE KEY-----
-MIGTAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBHkwdwIBAQQgQbYDQiewSnregm9e
-IjXEHQgc6w3ELHdnH1houEUom9CgCgYIKoZIzj0DAQehRANCAAQ5pTomd3cQNs8N
-SsKhjbClVGW5FFY+XMVdYw20k705To0o+i0dDr8rPURXa43G2zC1r0rzEIB3IZPE
-OdHOim9+
------END PRIVATE KEY-----
-```
-
-Recommendations
----------------
-
-Typically servers need a held certificate plus a chain of intermediates. Servers only need the
-private key for their own certificate. The chain served by a server doesn't need the root
-certificate.
-
-The trusted roots don't need to be the same for client and server when using client authentication.
-Clients might rely on the platform certificates and servers might use a private
-organization-specific certificate authority.
-
-By default `HeldCertificate` instances expire after 24 hours. Use `duration()` to adjust.
-
-By default server certificates need to identify which hostnames they're trusted for. You may add as
-many as necessary with `addSubjectAlternativeName()`. This mechanism also supports a very limited
-form of wildcards `*.example.com` where the `*` must be first and doesn't match nested subdomains.
-
-By default certificates use fast and secure 256-bit ECDSA keys. For interoperability with very old
-clients use `HeldCertificate.Builder.rsa2048()`.
-
-Download
---------
-
-Get via Maven:
-```xml
-<dependency>
-  <groupId>com.squareup.okhttp3</groupId>
-  <artifactId>okhttp-tls</artifactId>
-  <version>(insert latest version)</version>
-</dependency>
-```
-
-or via Gradle
-```groovy
-implementation 'com.squareup.okhttp3:okhttp-tls:(insert latest version)'
-```
-
- [held_certificate]: http://square.github.io/okhttp/3.x/okhttp-tls/okhttp3/tls/HeldCertificate.html
- [held_certificate_builder]: http://square.github.io/okhttp/3.x/okhttp-tls/okhttp3/tls/HeldCertificate.Builder.html
- [handshake_certificates]: http://square.github.io/okhttp/3.x/okhttp-tls/okhttp3/tls/HandshakeCertificates.html
- [handshake_certificates_builder]: http://square.github.io/okhttp/3.x/okhttp-tls/okhttp3/tls/HandshakeCertificates.Builder.html
diff --git a/okhttp-tls/pom.xml b/okhttp-tls/pom.xml
deleted file mode 100644
index 4d50ca96a4..0000000000
--- a/okhttp-tls/pom.xml
+++ /dev/null
@@ -1,76 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.14.3-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>okhttp-tls</artifactId>
-  <name>OkHttp Transport Layer Security (TLS)</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.google.code.findbugs</groupId>
-      <artifactId>jsr305</artifactId>
-      <scope>provided</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.bouncycastle</groupId>
-      <artifactId>bcprov-jdk15on</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-testing-support</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-javadoc-plugin</artifactId>
-        <version>3.0.1</version>
-        <configuration>
-          <excludePackageNames>okhttp3.tls.internal:okhttp3.tls.internal.*</excludePackageNames>
-          <links>
-            <link>http://square.github.io/okhttp/javadoc/</link>
-          </links>
-        </configuration>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-jar-plugin</artifactId>
-        <version>3.1.1</version>
-        <configuration>
-          <archive>
-            <manifestEntries>
-              <Automatic-Module-Name>okhttp3.tls</Automatic-Module-Name>
-            </manifestEntries>
-          </archive>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/okhttp-tls/src/main/java/okhttp3/tls/HandshakeCertificates.java b/okhttp-tls/src/main/java/okhttp3/tls/HandshakeCertificates.java
deleted file mode 100644
index 34e9e9a497..0000000000
--- a/okhttp-tls/src/main/java/okhttp3/tls/HandshakeCertificates.java
+++ /dev/null
@@ -1,172 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.tls;
-
-import java.security.GeneralSecurityException;
-import java.security.KeyManagementException;
-import java.security.SecureRandom;
-import java.security.cert.X509Certificate;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import javax.annotation.Nullable;
-import javax.net.ssl.KeyManager;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.X509KeyManager;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.CertificatePinner;
-import okhttp3.internal.Util;
-import okhttp3.internal.platform.Platform;
-
-import static okhttp3.tls.internal.TlsUtil.newKeyManager;
-import static okhttp3.tls.internal.TlsUtil.newTrustManager;
-
-/**
- * Certificates to identify which peers to trust and also to earn the trust of those peers in kind.
- * Client and server exchange these certificates during the handshake phase of a TLS connection.
- *
- * <h3>Server Authentication</h3>
- *
- * <p>This is the most common form of TLS authentication: clients verify that servers are trusted
- * and that they own the hostnames that they represent. Server authentication is required.
- *
- * <p>To perform server authentication:
- *
- * <ul>
- *   <li>The server's handshake certificates must have a {@linkplain HeldCertificate held
- *       certificate} (a certificate and its private key). The certificate's subject alternative
- *       names must match the server's hostname. The server must also have is a (possibly-empty)
- *       chain of intermediate certificates to establish trust from a root certificate to the
- *       server's certificate. The root certificate is not included in this chain.
- *   <li>The client's handshake certificates must include a set of trusted root certificates. They
- *       will be used to authenticate the server's certificate chain. Typically this is a set of
- *       well-known root certificates that is distributed with the HTTP client or its platform. It
- *       may be augmented by certificates private to an organization or service.
- * </ul>
- *
- * <h3>Client Authentication</h3>
- *
- * <p>This is authentication of the client by the server during the TLS handshake. Client
- * authentication is optional.
- *
- * <p>To perform client authentication:
- *
- * <ul>
- *   <li>The client's handshake certificates must have a {@linkplain HeldCertificate held
- *       certificate} (a certificate and its private key). The client must also have a
- *       (possibly-empty) chain of intermediate certificates to establish trust from a root
- *       certificate to the client's certificate. The root certificate is not included in this
- *       chain.
- *   <li>The server's handshake certificates must include a set of trusted root certificates. They
- *       will be used to authenticate the client's certificate chain. Typically this is not the same
- *       set of root certificates used in server authentication. Instead it will be a small set of
- *       roots private to an organization or service.
- * </ul>
- */
-public final class HandshakeCertificates {
-  private final X509KeyManager keyManager;
-  private final X509TrustManager trustManager;
-
-  private HandshakeCertificates(X509KeyManager keyManager, X509TrustManager trustManager) {
-    this.keyManager = keyManager;
-    this.trustManager = trustManager;
-  }
-
-  public X509KeyManager keyManager() {
-    return keyManager;
-  }
-
-  public X509TrustManager trustManager() {
-    return trustManager;
-  }
-
-  public SSLSocketFactory sslSocketFactory() {
-    return sslContext().getSocketFactory();
-  }
-
-  public SSLContext sslContext() {
-    try {
-      SSLContext sslContext = Platform.get().getSSLContext();
-      sslContext.init(new KeyManager[] { keyManager }, new TrustManager[] { trustManager },
-          new SecureRandom());
-      return sslContext;
-    } catch (KeyManagementException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  public static final class Builder {
-    private @Nullable HeldCertificate heldCertificate;
-    private @Nullable X509Certificate[] intermediates;
-
-    private final List<X509Certificate> trustedCertificates = new ArrayList<>();
-
-    /**
-     * Configure the certificate chain to use when being authenticated. The first certificate is
-     * the held certificate, further certificates are included in the handshake so the peer can
-     * build a trusted path to a trusted root certificate.
-     *
-     * <p>The chain should include all intermediate certificates but does not need the root
-     * certificate that we expect to be known by the remote peer. The peer already has that
-     * certificate so transmitting it is unnecessary.
-     */
-    public Builder heldCertificate(HeldCertificate heldCertificate,
-        X509Certificate... intermediates) {
-      this.heldCertificate = heldCertificate;
-      this.intermediates = intermediates.clone(); // Defensive copy.
-      return this;
-    }
-
-    /**
-     * Add a trusted root certificate to use when authenticating a peer. Peers must provide
-     * a chain of certificates whose root is one of these.
-     */
-    public Builder addTrustedCertificate(X509Certificate certificate) {
-      this.trustedCertificates.add(certificate);
-      return this;
-    }
-
-    /**
-     * Add all of the host platform's trusted root certificates. This set varies by platform
-     * (Android vs. Java), by platform release (Android 4.4 vs. Android 9), and with user
-     * customizations.
-     *
-     * <p>Most TLS clients that connect to hosts on the public Internet should call this method.
-     * Otherwise it is necessary to manually prepare a comprehensive set of trusted roots.
-     *
-     * <p>If the host platform is compromised or misconfigured this may contain untrustworthy root
-     * certificates. Applications that connect to a known set of servers may be able to mitigate
-     * this problem with {@linkplain CertificatePinner certificate pinning}.
-     */
-    public Builder addPlatformTrustedCertificates() {
-      X509TrustManager platformTrustManager = Util.platformTrustManager();
-      Collections.addAll(trustedCertificates, platformTrustManager.getAcceptedIssuers());
-      return this;
-    }
-
-    public HandshakeCertificates build() {
-      try {
-        X509KeyManager keyManager = newKeyManager(null, heldCertificate, intermediates);
-        X509TrustManager trustManager = newTrustManager(null, trustedCertificates);
-        return new HandshakeCertificates(keyManager, trustManager);
-      } catch (GeneralSecurityException gse) {
-        throw new AssertionError(gse);
-      }
-    }
-  }
-}
diff --git a/okhttp-tls/src/main/java/okhttp3/tls/HeldCertificate.java b/okhttp-tls/src/main/java/okhttp3/tls/HeldCertificate.java
deleted file mode 100644
index c659f58196..0000000000
--- a/okhttp-tls/src/main/java/okhttp3/tls/HeldCertificate.java
+++ /dev/null
@@ -1,433 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.tls;
-
-import java.io.IOException;
-import java.math.BigInteger;
-import java.security.GeneralSecurityException;
-import java.security.KeyPair;
-import java.security.KeyPairGenerator;
-import java.security.PrivateKey;
-import java.security.PublicKey;
-import java.security.SecureRandom;
-import java.security.Security;
-import java.security.cert.CertificateEncodingException;
-import java.security.cert.X509Certificate;
-import java.security.interfaces.RSAPrivateKey;
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.List;
-import java.util.UUID;
-import java.util.concurrent.TimeUnit;
-import javax.annotation.Nullable;
-import javax.security.auth.x500.X500Principal;
-import okio.ByteString;
-import org.bouncycastle.asn1.ASN1Encodable;
-import org.bouncycastle.asn1.DERSequence;
-import org.bouncycastle.asn1.pkcs.PrivateKeyInfo;
-import org.bouncycastle.asn1.x509.BasicConstraints;
-import org.bouncycastle.asn1.x509.GeneralName;
-import org.bouncycastle.asn1.x509.X509Extensions;
-import org.bouncycastle.jce.provider.BouncyCastleProvider;
-import org.bouncycastle.x509.X509V3CertificateGenerator;
-
-import static okhttp3.internal.Util.verifyAsIpAddress;
-
-/**
- * A certificate and its private key. These are some properties of certificates that are used with
- * TLS:
- *
- * <ul>
- *   <li><strong>A common name.</strong> This is a string identifier for the certificate. It usually
- *       describes the purpose of the certificate like "Entrust Root Certification Authority - G2"
- *       or "www.squareup.com".
- *   <li><strong>A set of hostnames.</strong> These are in the certificate's subject alternative
- *       name (SAN) extension. A subject alternative name is either a literal hostname ({@code
- *       squareup.com}), a literal IP address ({@code 74.122.190.80}), or a hostname pattern ({@code
- *       *.api.squareup.com}).
- *   <li><strong>A validity interval.</strong> A certificate should not be used before its validity
- *       interval starts or after it ends.
- *   <li><strong>A public key.</strong> This cryptographic key is used for asymmetric encryption
- *       digital signatures. Note that the private key is not a part of the certificate!
- *   <li><strong>A signature issued by another certificate's private key.</strong> This mechanism
- *       allows a trusted third-party to endorse a certificate. Third parties should only endorse
- *       certificates once they've confirmed that the owner of the private key is also the owner of
- *       the certificate's other properties.
- * </ul>
- *
- * <p>Certificates are signed by other certificates and a sequence of them is called a certificate
- * chain. The chain terminates in a self-signed "root" certificate. Signing certificates in the
- * middle of the chain are called "intermediates". Organizations that offer certificate signing are
- * called certificate authorities (CAs).
- *
- * <p>Browsers and other HTTP clients need a set of trusted root certificates to authenticate their
- * peers. Sets of root certificates are managed by either the HTTP client (like Firefox), or the
- * host platform (like Android). In July 2018 Android had 134 trusted root certificates for its HTTP
- * clients to trust.
- *
- * <p>For example, in order to establish a secure connection to {@code https://www.squareup.com/},
- * these three certificates are used. <pre>{@code
- *
- * www.squareup.com certificate:
- *
- *   Common Name: www.squareup.com
- *   Subject Alternative Names: www.squareup.com, squareup.com, account.squareup.com...
- *   Validity: 2018-07-03T20:18:17Z ‚Äì 2019-08-01T20:48:15Z
- *   Public Key: d107beecc17325f55da976bcbab207ba4df68bd3f8fce7c3b5850311128264fd53e1baa342f58d93...
- *   Signature: 1fb0e66fac05322721fe3a3917f7c98dee1729af39c99eab415f22d8347b508acdf0bab91781c3720...
- *
- * signed by intermediate certificate:
- *
- *   Common Name: Entrust Certification Authority - L1M
- *   Subject Alternative Names: none
- *   Validity: 2014-12-15T15:25:03Z ‚Äì 2030-10-15T15:55:03Z
- *   Public Key: d081c13923c2b1d1ecf757dd55243691202248f7fcca520ab0ab3f33b5b08407f6df4e7ab0fb9822...
- *   Signature: b487c784221a29c0a478ecf54f1bb484976f77eed4cf59afa843962f1d58dea6f3155b2ed9439c4c4...
- *
- * signed by root certificate:
- *
- *   Common Name: Entrust Root Certification Authority - G2
- *   Subject Alternative Names: none
- *   Validity: 2009-07-07T17:25:54Z ‚Äì 2030-12-07T17:55:54Z
- *   Public Key: ba84b672db9e0c6be299e93001a776ea32b895411ac9da614e5872cffef68279bf7361060aa527d8...
- *   Self-signed Signature: 799f1d96c6b6793f228d87d3870304606a6b9a2e59897311ac43d1f513ff8d392bc0f...
- *
- * }</pre>
- *
- * <p>In this example the HTTP client already knows and trusts the last certificate, "Entrust Root
- * Certification Authority - G2". That certificate is used to verify the signature of the
- * intermediate certificate, "Entrust Certification Authority - L1M". The intermediate certificate
- * is used to verify the signature of the "www.squareup.com" certificate.
- *
- * <p>This roles are reversed for client authentication. In that case the client has a private key
- * and a chain of certificates. The server uses a set of trusted root certificates to authenticate
- * the client. Subject alternative names are not used for client authentication.
- */
-public final class HeldCertificate {
-  private final X509Certificate certificate;
-  private final KeyPair keyPair;
-
-  public HeldCertificate(KeyPair keyPair, X509Certificate certificate) {
-    if (keyPair == null) throw new NullPointerException("keyPair == null");
-    if (certificate == null) throw new NullPointerException("certificate == null");
-    this.certificate = certificate;
-    this.keyPair = keyPair;
-  }
-
-  public X509Certificate certificate() {
-    return certificate;
-  }
-
-  public KeyPair keyPair() {
-    return keyPair;
-  }
-
-  /**
-   * Returns the certificate encoded in <a href="https://tools.ietf.org/html/rfc7468">PEM
-   * format</a>.
-   */
-  public String certificatePem() {
-    try {
-      StringBuilder result = new StringBuilder();
-      result.append("-----BEGIN CERTIFICATE-----\n");
-      encodeBase64Lines(result, ByteString.of(certificate.getEncoded()));
-      result.append("-----END CERTIFICATE-----\n");
-      return result.toString();
-    } catch (CertificateEncodingException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  /**
-   * Returns the RSA private key encoded in <a href="https://tools.ietf.org/html/rfc5208">PKCS
-   * #8</a> <a href="https://tools.ietf.org/html/rfc7468">PEM format</a>.
-   */
-  public String privateKeyPkcs8Pem() {
-    StringBuilder result = new StringBuilder();
-    result.append("-----BEGIN PRIVATE KEY-----\n");
-    encodeBase64Lines(result, ByteString.of(keyPair.getPrivate().getEncoded()));
-    result.append("-----END PRIVATE KEY-----\n");
-    return result.toString();
-  }
-
-  /**
-   * Returns the RSA private key encoded in <a href="https://tools.ietf.org/html/rfc8017">PKCS
-   * #1</a> <a href="https://tools.ietf.org/html/rfc7468">PEM format</a>.
-   */
-  public String privateKeyPkcs1Pem() {
-    if (!(keyPair.getPrivate() instanceof RSAPrivateKey)) {
-      throw new IllegalStateException("PKCS1 only supports RSA keys");
-    }
-    StringBuilder result = new StringBuilder();
-    result.append("-----BEGIN RSA PRIVATE KEY-----\n");
-    encodeBase64Lines(result, pkcs1Bytes());
-    result.append("-----END RSA PRIVATE KEY-----\n");
-    return result.toString();
-  }
-
-  private ByteString pkcs1Bytes() {
-    try {
-      PrivateKeyInfo privateKeyInfo = PrivateKeyInfo.getInstance(keyPair.getPrivate().getEncoded());
-      return ByteString.of(privateKeyInfo.parsePrivateKey().toASN1Primitive().getEncoded());
-    } catch (IOException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  private void encodeBase64Lines(StringBuilder out, ByteString data) {
-    String base64 = data.base64();
-    for (int i = 0; i < base64.length(); i += 64) {
-      out.append(base64, i, Math.min(i + 64, base64.length())).append('\n');
-    }
-  }
-
-  /** Build a held certificate with reasonable defaults. */
-  public static final class Builder {
-    private static final long DEFAULT_DURATION_MILLIS = 1000L * 60 * 60 * 24; // 24 hours.
-
-    static {
-      Security.addProvider(new BouncyCastleProvider());
-    }
-
-    private long notBefore = -1L;
-    private long notAfter = -1L;
-    private @Nullable String cn;
-    private @Nullable String ou;
-    private final List<String> altNames = new ArrayList<>();
-    private @Nullable BigInteger serialNumber;
-    private @Nullable KeyPair keyPair;
-    private @Nullable HeldCertificate signedBy;
-    private int maxIntermediateCas = -1;
-    private @Nullable String keyAlgorithm;
-    private int keySize;
-
-    public Builder() {
-      ecdsa256();
-    }
-
-    /**
-     * Sets the certificate to be valid in {@code [notBefore..notAfter]}. Both endpoints are
-     * specified in the format of {@link System#currentTimeMillis()}. Specify -1L for both values
-     * to use the default interval, 24 hours starting when the certificate is created.
-     */
-    public Builder validityInterval(long notBefore, long notAfter) {
-      if (notBefore > notAfter || (notBefore == -1L) != (notAfter == -1L)) {
-        throw new IllegalArgumentException("invalid interval: " + notBefore + ".." + notAfter);
-      }
-      this.notBefore = notBefore;
-      this.notAfter = notAfter;
-      return this;
-    }
-
-    /**
-     * Sets the certificate to be valid immediately and until the specified duration has elapsed.
-     * The precision of this field is seconds; further precision will be truncated.
-     */
-    public Builder duration(long duration, TimeUnit unit) {
-      long now = System.currentTimeMillis();
-      return validityInterval(now, now + unit.toMillis(duration));
-    }
-
-    /**
-     * Adds a subject alternative name (SAN) to the certificate. This is usually a literal hostname,
-     * a literal IP address, or a hostname pattern. If no subject alternative names are added that
-     * extension will be omitted.
-     */
-    public Builder addSubjectAlternativeName(String altName) {
-      if (altName == null) throw new NullPointerException("altName == null");
-      altNames.add(altName);
-      return this;
-    }
-
-    /**
-     * Set this certificate's common name (CN). Historically this held the hostname of TLS
-     * certificate, but that practice was deprecated by <a
-     * href="https://tools.ietf.org/html/rfc2818">RFC 2818</a> and replaced with {@link
-     * #addSubjectAlternativeName(String) subject alternative names}. If unset a random string will
-     * be used.
-     */
-    public Builder commonName(String cn) {
-      this.cn = cn;
-      return this;
-    }
-
-    /** Sets the certificate's organizational unit (OU). If unset this field will be omitted. */
-    public Builder organizationalUnit(String ou) {
-      this.ou = ou;
-      return this;
-    }
-
-    /** Sets this certificate's serial number. If unset the serial number will be 1. */
-    public Builder serialNumber(BigInteger serialNumber) {
-      this.serialNumber = serialNumber;
-      return this;
-    }
-
-    /** Sets this certificate's serial number. If unset the serial number will be 1. */
-    public Builder serialNumber(long serialNumber) {
-      return serialNumber(BigInteger.valueOf(serialNumber));
-    }
-
-    /**
-     * Sets the public/private key pair used for this certificate. If unset a key pair will be
-     * generated.
-     */
-    public Builder keyPair(KeyPair keyPair) {
-      this.keyPair = keyPair;
-      return this;
-    }
-
-    /**
-     * Sets the public/private key pair used for this certificate. If unset a key pair will be
-     * generated.
-     */
-    public Builder keyPair(PublicKey publicKey, PrivateKey privateKey) {
-      return keyPair(new KeyPair(publicKey, privateKey));
-    }
-
-    /**
-     * Set the certificate that will issue this certificate. If unset the certificate will be
-     * self-signed.
-     */
-    public Builder signedBy(HeldCertificate signedBy) {
-      this.signedBy = signedBy;
-      return this;
-    }
-
-    /**
-     * Set this certificate to be a signing certificate, with up to {@code maxIntermediateCas}
-     * intermediate signing certificates beneath it.
-     *
-     * <p>By default this certificate cannot not sign other certificates. Set this to 0 so this
-     * certificate can sign other certificates (but those certificates cannot themselves sign
-     * certificates). Set this to 1 so this certificate can sign intermediate certificates that can
-     * themselves sign certificates. Add one for each additional layer of intermediates to permit.
-     */
-    public Builder certificateAuthority(int maxIntermediateCas) {
-      if (maxIntermediateCas < 0) {
-        throw new IllegalArgumentException("maxIntermediateCas < 0: " + maxIntermediateCas);
-      }
-      this.maxIntermediateCas = maxIntermediateCas;
-      return this;
-    }
-
-    /**
-     * Configure the certificate to generate a 256-bit ECDSA key, which provides about 128 bits of
-     * security. ECDSA keys are noticeably faster than RSA keys.
-     *
-     * <p>This is the default configuration and has been since this API was introduced in OkHttp
-     * 3.11.0. Note that the default may change in future releases.
-     */
-    public Builder ecdsa256() {
-      keyAlgorithm = "EC";
-      keySize = 256;
-      return this;
-    }
-
-    /**
-     * Configure the certificate to generate a 2048-bit RSA key, which provides about 112 bits of
-     * security. RSA keys are interoperable with very old clients that don't support ECDSA.
-     */
-    public Builder rsa2048() {
-      keyAlgorithm = "RSA";
-      keySize = 2048;
-      return this;
-    }
-
-    public HeldCertificate build() {
-      // Subject, public & private keys for this certificate.
-      KeyPair heldKeyPair = keyPair != null
-          ? keyPair
-          : generateKeyPair();
-
-      X500Principal subject = buildSubject();
-
-      // Subject, public & private keys for this certificate's signer. It may be self signed!
-      KeyPair signedByKeyPair;
-      X500Principal signedByPrincipal;
-      if (signedBy != null) {
-        signedByKeyPair = signedBy.keyPair;
-        signedByPrincipal = signedBy.certificate.getSubjectX500Principal();
-      } else {
-        signedByKeyPair = heldKeyPair;
-        signedByPrincipal = subject;
-      }
-
-      // Generate & sign the certificate.
-      long notBefore = this.notBefore != -1L ? this.notBefore : System.currentTimeMillis();
-      long notAfter = this.notAfter != -1L ? this.notAfter : notBefore + DEFAULT_DURATION_MILLIS;
-      BigInteger serialNumber = this.serialNumber != null ? this.serialNumber : BigInteger.ONE;
-      X509V3CertificateGenerator generator = new X509V3CertificateGenerator();
-      generator.setSerialNumber(serialNumber);
-      generator.setIssuerDN(signedByPrincipal);
-      generator.setNotBefore(new Date(notBefore));
-      generator.setNotAfter(new Date(notAfter));
-      generator.setSubjectDN(subject);
-      generator.setPublicKey(heldKeyPair.getPublic());
-      generator.setSignatureAlgorithm(signedByKeyPair.getPrivate() instanceof RSAPrivateKey
-          ? "SHA256WithRSAEncryption"
-          : "SHA256withECDSA");
-
-      if (maxIntermediateCas != -1) {
-        generator.addExtension(X509Extensions.BasicConstraints, true,
-            new BasicConstraints(maxIntermediateCas));
-      }
-
-      if (!altNames.isEmpty()) {
-        ASN1Encodable[] encodableAltNames = new ASN1Encodable[altNames.size()];
-        for (int i = 0, size = altNames.size(); i < size; i++) {
-          String altName = altNames.get(i);
-          int tag = verifyAsIpAddress(altName)
-              ? GeneralName.iPAddress
-              : GeneralName.dNSName;
-          encodableAltNames[i] = new GeneralName(tag, altName);
-        }
-        generator.addExtension(X509Extensions.SubjectAlternativeName, true,
-            new DERSequence(encodableAltNames));
-      }
-
-      try {
-        X509Certificate certificate = generator.generate(signedByKeyPair.getPrivate());
-        return new HeldCertificate(heldKeyPair, certificate);
-      } catch (GeneralSecurityException e) {
-        throw new AssertionError(e);
-      }
-    }
-
-    private X500Principal buildSubject() {
-      StringBuilder nameBuilder = new StringBuilder();
-      if (cn != null) {
-        nameBuilder.append("CN=").append(cn);
-      } else {
-        nameBuilder.append("CN=").append(UUID.randomUUID());
-      }
-      if (ou != null) {
-        nameBuilder.append(", OU=").append(ou);
-      }
-      return new X500Principal(nameBuilder.toString());
-    }
-
-    private KeyPair generateKeyPair() {
-      try {
-        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(keyAlgorithm);
-        keyPairGenerator.initialize(keySize, new SecureRandom());
-        return keyPairGenerator.generateKeyPair();
-      } catch (GeneralSecurityException e) {
-        throw new AssertionError(e);
-      }
-    }
-  }
-}
diff --git a/okhttp-tls/src/main/java/okhttp3/tls/internal/TlsUtil.java b/okhttp-tls/src/main/java/okhttp3/tls/internal/TlsUtil.java
deleted file mode 100644
index b127b36861..0000000000
--- a/okhttp-tls/src/main/java/okhttp3/tls/internal/TlsUtil.java
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.tls.internal;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.security.GeneralSecurityException;
-import java.security.KeyStore;
-import java.security.cert.Certificate;
-import java.security.cert.X509Certificate;
-import java.util.Arrays;
-import java.util.List;
-import javax.net.ssl.KeyManager;
-import javax.net.ssl.KeyManagerFactory;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.TrustManagerFactory;
-import javax.net.ssl.X509KeyManager;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.tls.HeldCertificate;
-import okhttp3.tls.HandshakeCertificates;
-
-public final class TlsUtil {
-  public static final char[] password = "password".toCharArray();
-  private static HandshakeCertificates localhost; // Lazily initialized.
-
-  private TlsUtil() {
-  }
-
-  /** Returns an SSL client for this host's localhost address. */
-  public static synchronized HandshakeCertificates localhost() {
-    if (localhost != null) return localhost;
-
-    try {
-      // Generate a self-signed cert for the server to serve and the client to trust.
-      HeldCertificate heldCertificate = new HeldCertificate.Builder()
-          .commonName("localhost")
-          .addSubjectAlternativeName(InetAddress.getByName("localhost").getCanonicalHostName())
-          .build();
-
-      localhost = new HandshakeCertificates.Builder()
-          .heldCertificate(heldCertificate)
-          .addTrustedCertificate(heldCertificate.certificate())
-          .build();
-
-      return localhost;
-    } catch (UnknownHostException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  /** Returns a trust manager that trusts {@code trustedCertificates}. */
-  public static X509TrustManager newTrustManager(String keyStoreType,
-      List<X509Certificate> trustedCertificates) throws GeneralSecurityException {
-    KeyStore trustStore = newEmptyKeyStore(keyStoreType);
-    for (int i = 0; i < trustedCertificates.size(); i++) {
-      trustStore.setCertificateEntry("cert_" + i, trustedCertificates.get(i));
-    }
-    TrustManagerFactory factory = TrustManagerFactory.getInstance(
-        TrustManagerFactory.getDefaultAlgorithm());
-    factory.init(trustStore);
-    TrustManager[] result = factory.getTrustManagers();
-    if (result.length != 1 || !(result[0] instanceof X509TrustManager)) {
-      throw new IllegalStateException("Unexpected trust managers:" + Arrays.toString(result));
-    }
-    return (X509TrustManager) result[0];
-  }
-
-  /**
-   * Returns a key manager for the held certificate and its chain. Returns an empty key manager if
-   * {@code heldCertificate} is null.
-   */
-  public static X509KeyManager newKeyManager(String keyStoreType, HeldCertificate heldCertificate,
-      X509Certificate... intermediates) throws GeneralSecurityException {
-    KeyStore keyStore = newEmptyKeyStore(keyStoreType);
-
-    if (heldCertificate != null) {
-      Certificate[] chain = new Certificate[1 + intermediates.length];
-      chain[0] = heldCertificate.certificate();
-      System.arraycopy(intermediates, 0, chain, 1, intermediates.length);
-      keyStore.setKeyEntry("private", heldCertificate.keyPair().getPrivate(), password, chain);
-    }
-
-    KeyManagerFactory factory = KeyManagerFactory.getInstance(
-        KeyManagerFactory.getDefaultAlgorithm());
-    factory.init(keyStore, password);
-    KeyManager[] result = factory.getKeyManagers();
-    if (result.length != 1 || !(result[0] instanceof X509KeyManager)) {
-      throw new IllegalStateException("Unexpected key managers:" + Arrays.toString(result));
-    }
-    return (X509KeyManager) result[0];
-  }
-
-  private static KeyStore newEmptyKeyStore(String keyStoreType) throws GeneralSecurityException {
-    if (keyStoreType == null) {
-      keyStoreType = KeyStore.getDefaultType();
-    }
-
-    try {
-      KeyStore keyStore = KeyStore.getInstance(keyStoreType);
-      InputStream in = null; // By convention, 'null' creates an empty key store.
-      keyStore.load(in, password);
-      return keyStore;
-    } catch (IOException e) {
-      throw new AssertionError(e);
-    }
-  }
-}
diff --git a/okhttp-tls/src/main/java/okhttp3/tls/package-info.java b/okhttp-tls/src/main/java/okhttp3/tls/package-info.java
deleted file mode 100644
index 061e524be6..0000000000
--- a/okhttp-tls/src/main/java/okhttp3/tls/package-info.java
+++ /dev/null
@@ -1,3 +0,0 @@
-/** OkHttp Transport Layer Security (TLS) library. */
-@okhttp3.internal.annotations.EverythingIsNonNull
-package okhttp3.tls;
diff --git a/okhttp-tls/src/test/java/okhttp3/tls/HandshakeCertificatesTest.java b/okhttp-tls/src/test/java/okhttp3/tls/HandshakeCertificatesTest.java
deleted file mode 100644
index ac5bc6a53f..0000000000
--- a/okhttp-tls/src/test/java/okhttp3/tls/HandshakeCertificatesTest.java
+++ /dev/null
@@ -1,190 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.tls;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.ServerSocket;
-import java.net.Socket;
-import java.security.PrivateKey;
-import java.security.cert.X509Certificate;
-import java.util.Arrays;
-import java.util.LinkedHashSet;
-import java.util.Set;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import javax.net.ServerSocketFactory;
-import javax.net.SocketFactory;
-import javax.net.ssl.SSLSocket;
-import okhttp3.Handshake;
-import okio.ByteString;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import static okhttp3.internal.Util.closeQuietly;
-import static org.assertj.core.api.Assertions.assertThat;
-
-public final class HandshakeCertificatesTest {
-  private ExecutorService executorService;
-  private ServerSocket serverSocket;
-
-  @Before public void setUp() {
-    executorService = Executors.newCachedThreadPool();
-  }
-
-  @After public void tearDown() {
-    executorService.shutdown();
-    closeQuietly(serverSocket);
-  }
-
-  @Test public void clientAndServer() throws Exception {
-    HeldCertificate clientRoot = new HeldCertificate.Builder()
-        .certificateAuthority(1)
-        .build();
-    HeldCertificate clientIntermediate = new HeldCertificate.Builder()
-        .certificateAuthority(0)
-        .signedBy(clientRoot)
-        .build();
-    HeldCertificate clientCertificate = new HeldCertificate.Builder()
-        .signedBy(clientIntermediate)
-        .build();
-
-    HeldCertificate serverRoot = new HeldCertificate.Builder()
-        .certificateAuthority(1)
-        .build();
-    HeldCertificate serverIntermediate = new HeldCertificate.Builder()
-        .certificateAuthority(0)
-        .signedBy(serverRoot)
-        .build();
-    HeldCertificate serverCertificate = new HeldCertificate.Builder()
-        .signedBy(serverIntermediate)
-        .build();
-
-    HandshakeCertificates server = new HandshakeCertificates.Builder()
-        .addTrustedCertificate(clientRoot.certificate())
-        .heldCertificate(serverCertificate, serverIntermediate.certificate())
-        .build();
-
-    HandshakeCertificates client = new HandshakeCertificates.Builder()
-        .addTrustedCertificate(serverRoot.certificate())
-        .heldCertificate(clientCertificate, clientIntermediate.certificate())
-        .build();
-
-    InetSocketAddress serverAddress = startTlsServer();
-    Future<Handshake> serverHandshakeFuture = doServerHandshake(server);
-    Future<Handshake> clientHandshakeFuture = doClientHandshake(client, serverAddress);
-
-    Handshake serverHandshake = serverHandshakeFuture.get();
-    assertThat(Arrays.asList(clientCertificate.certificate(), clientIntermediate.certificate())).isEqualTo(
-        serverHandshake.peerCertificates());
-    assertThat(Arrays.asList(serverCertificate.certificate(), serverIntermediate.certificate())).isEqualTo(
-        serverHandshake.localCertificates());
-
-    Handshake clientHandshake = clientHandshakeFuture.get();
-    assertThat(Arrays.asList(serverCertificate.certificate(), serverIntermediate.certificate())).isEqualTo(
-        clientHandshake.peerCertificates());
-    assertThat(Arrays.asList(clientCertificate.certificate(), clientIntermediate.certificate())).isEqualTo(
-        clientHandshake.localCertificates());
-  }
-
-  @Test public void keyManager() {
-    HeldCertificate root = new HeldCertificate.Builder()
-        .certificateAuthority(1)
-        .build();
-    HeldCertificate intermediate = new HeldCertificate.Builder()
-        .certificateAuthority(0)
-        .signedBy(root)
-        .build();
-    HeldCertificate certificate = new HeldCertificate.Builder()
-        .signedBy(intermediate)
-        .build();
-
-    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
-        .heldCertificate(certificate, intermediate.certificate())
-        .build();
-    assertPrivateKeysEquals(certificate.keyPair().getPrivate(),
-        handshakeCertificates.keyManager().getPrivateKey("private"));
-    assertThat(Arrays.asList(handshakeCertificates.keyManager().getCertificateChain("private"))).isEqualTo(
-        Arrays.asList(certificate.certificate(), intermediate.certificate()));
-  }
-
-  @Test public void platformTrustedCertificates() {
-    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
-        .addPlatformTrustedCertificates()
-        .build();
-    Set<String> names = new LinkedHashSet<>();
-    for (X509Certificate certificate : handshakeCertificates.trustManager().getAcceptedIssuers()) {
-      // Abbreviate a long name like "CN=Entrust Root Certification Authority - G2, OU=..."
-      String name = certificate.getSubjectDN().getName();
-      names.add(name.substring(0, name.indexOf(" ")));
-    }
-    // It's safe to assume all platforms will have a major Internet certificate issuer.
-    assertThat(names.contains("CN=Entrust")).overridingErrorMessage(names.toString()).isTrue();
-  }
-
-  private InetSocketAddress startTlsServer() throws IOException {
-    ServerSocketFactory serverSocketFactory = ServerSocketFactory.getDefault();
-    serverSocket = serverSocketFactory.createServerSocket();
-    InetAddress serverAddress = InetAddress.getByName("localhost");
-    serverSocket.bind(new InetSocketAddress(serverAddress, 0), 50);
-    return new InetSocketAddress(serverAddress, serverSocket.getLocalPort());
-  }
-
-  private Future<Handshake> doServerHandshake(HandshakeCertificates server) {
-    return executorService.submit(() -> {
-      Socket rawSocket = null;
-      SSLSocket sslSocket = null;
-      try {
-        rawSocket = serverSocket.accept();
-        sslSocket = (SSLSocket) server.sslSocketFactory().createSocket(rawSocket,
-            rawSocket.getInetAddress().getHostAddress(), rawSocket.getPort(), true /* autoClose */);
-        sslSocket.setUseClientMode(false);
-        sslSocket.setWantClientAuth(true);
-        sslSocket.startHandshake();
-        return Handshake.get(sslSocket.getSession());
-      } finally {
-        closeQuietly(rawSocket);
-        closeQuietly(sslSocket);
-      }
-    });
-  }
-
-  private Future<Handshake> doClientHandshake(
-      HandshakeCertificates client, InetSocketAddress serverAddress) {
-    return executorService.submit(() -> {
-      Socket rawSocket = SocketFactory.getDefault().createSocket();
-      rawSocket.connect(serverAddress);
-      SSLSocket sslSocket = null;
-      try {
-        sslSocket = (SSLSocket) client.sslSocketFactory().createSocket(rawSocket,
-            rawSocket.getInetAddress().getHostAddress(), rawSocket.getPort(), true /* autoClose */);
-        sslSocket.startHandshake();
-        return Handshake.get(sslSocket.getSession());
-      } finally {
-        closeQuietly(rawSocket);
-        closeQuietly(sslSocket);
-      }
-    });
-  }
-
-  private void assertPrivateKeysEquals(PrivateKey expected, PrivateKey actual) {
-    assertThat(ByteString.of(actual.getEncoded())).isEqualTo(
-        ByteString.of(expected.getEncoded()));
-  }
-}
diff --git a/okhttp-tls/src/test/java/okhttp3/tls/HeldCertificateTest.java b/okhttp-tls/src/test/java/okhttp3/tls/HeldCertificateTest.java
deleted file mode 100644
index 4335d67f28..0000000000
--- a/okhttp-tls/src/test/java/okhttp3/tls/HeldCertificateTest.java
+++ /dev/null
@@ -1,226 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.tls;
-
-import java.math.BigInteger;
-import java.security.KeyFactory;
-import java.security.PrivateKey;
-import java.security.PublicKey;
-import java.security.cert.CertificateParsingException;
-import java.security.cert.X509Certificate;
-import java.security.spec.PKCS8EncodedKeySpec;
-import java.security.spec.X509EncodedKeySpec;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.concurrent.TimeUnit;
-import okio.ByteString;
-import org.bouncycastle.asn1.x509.GeneralName;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.data.Offset.offset;
-
-public final class HeldCertificateTest {
-  @Test public void defaultCertificate() throws CertificateParsingException {
-    long now = System.currentTimeMillis();
-    HeldCertificate heldCertificate = new HeldCertificate.Builder().build();
-
-    X509Certificate certificate = heldCertificate.certificate();
-    assertThat(certificate.getSubjectX500Principal().getName()).overridingErrorMessage(
-        "self-signed").isEqualTo(certificate.getIssuerX500Principal().getName());
-    assertThat(certificate.getIssuerX500Principal().getName().matches("CN=[0-9a-f-]{36}")).isTrue();
-    assertThat(certificate.getSerialNumber()).isEqualTo(BigInteger.ONE);
-    assertThat(certificate.getSubjectAlternativeNames()).isNull();
-
-    double deltaMillis = 1000.0;
-    long durationMillis = TimeUnit.MINUTES.toMillis(60 * 24);
-    assertThat((double) certificate.getNotBefore().getTime()).isCloseTo(
-        (double) now, offset(deltaMillis));
-    assertThat((double) certificate.getNotAfter().getTime()).isCloseTo(
-        (double) now + durationMillis, offset(deltaMillis));
-  }
-
-  @Test public void customInterval() {
-    // 5 seconds starting on 1970-01-01.
-    HeldCertificate heldCertificate = new HeldCertificate.Builder()
-        .validityInterval(5_000L, 10_000L)
-        .build();
-    X509Certificate certificate = heldCertificate.certificate();
-    assertThat(certificate.getNotBefore().getTime()).isEqualTo(5_000L);
-    assertThat(certificate.getNotAfter().getTime()).isEqualTo(10_000L);
-  }
-
-  @Test public void customDuration() {
-    long now = System.currentTimeMillis();
-
-    HeldCertificate heldCertificate = new HeldCertificate.Builder()
-        .duration(5, TimeUnit.SECONDS)
-        .build();
-    X509Certificate certificate = heldCertificate.certificate();
-
-    double deltaMillis = 1000.0;
-    long durationMillis = 5_000L;
-    assertThat((double) certificate.getNotBefore().getTime()).isCloseTo(
-        (double) now, offset(deltaMillis));
-    assertThat((double) certificate.getNotAfter().getTime()).isCloseTo(
-        (double) now + durationMillis, offset(deltaMillis));
-  }
-
-  @Test public void subjectAlternativeNames() throws CertificateParsingException {
-    HeldCertificate heldCertificate = new HeldCertificate.Builder()
-        .addSubjectAlternativeName("1.1.1.1")
-        .addSubjectAlternativeName("cash.app")
-        .build();
-
-    X509Certificate certificate = heldCertificate.certificate();
-    List<List<?>> subjectAlternativeNames = new ArrayList<>(
-        certificate.getSubjectAlternativeNames());
-    assertThat(Arrays.asList(
-        Arrays.asList(GeneralName.iPAddress, "1.1.1.1"),
-        Arrays.asList(GeneralName.dNSName, "cash.app"))).isEqualTo(subjectAlternativeNames);
-  }
-
-  @Test public void commonName() {
-    HeldCertificate heldCertificate = new HeldCertificate.Builder()
-        .commonName("cash.app")
-        .build();
-
-    X509Certificate certificate = heldCertificate.certificate();
-    assertThat(certificate.getSubjectX500Principal().getName()).isEqualTo("CN=cash.app");
-  }
-
-  @Test public void organizationalUnit() {
-    HeldCertificate heldCertificate = new HeldCertificate.Builder()
-        .commonName("cash.app")
-        .organizationalUnit("cash")
-        .build();
-
-    X509Certificate certificate = heldCertificate.certificate();
-    assertThat(certificate.getSubjectX500Principal().getName()).isEqualTo(
-        "CN=cash.app,OU=cash");
-  }
-
-  /** Confirm golden values of encoded PEMs. */
-  @Test public void pems() throws Exception {
-    KeyFactory keyFactory = KeyFactory.getInstance("RSA");
-
-    ByteString publicKeyBytes = ByteString.decodeBase64("MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCApF"
-        + "HhtrLan28q+oMolZuaTfWBA0V5aMIvq32BsloQu6LlvX1wJ4YEoUCjDlPOtpht7XLbUmBnbIzN89XK4UJVM6Sqp3"
-        + "K88Km8z7gMrdrfTom/274wL25fICR+yDEQ5fUVYBmJAKXZF1aoI0mIoEx0xFsQhIJ637v2MxJDupd61wIDAQAB");
-    PublicKey publicKey = keyFactory.generatePublic(
-        new X509EncodedKeySpec(publicKeyBytes.toByteArray()));
-
-    ByteString privateKeyBytes = ByteString.decodeBase64("MIICdQIBADANBgkqhkiG9w0BAQEFAASCAl8wggJbA"
-        + "gEAAoGBAICkUeG2stqfbyr6gyiVm5pN9YEDRXlowi+rfYGyWhC7ouW9fXAnhgShQKMOU862mG3tcttSYGdsjM3z1"
-        + "crhQlUzpKqncrzwqbzPuAyt2t9Oib/bvjAvbl8gJH7IMRDl9RVgGYkApdkXVqgjSYigTHTEWxCEgnrfu/YzEkO6l"
-        + "3rXAgMBAAECgYB99mhnB6piADOuddXv626NzUBTr4xbsYRTgSxHzwf50oFTTBSDuW+1IOBVyTWu94SSPyt0LllPb"
-        + "C8Di3sQSTnVGpSqAvEXknBMzIc0UO74Rn9p3gZjEenPt1l77fIBa2nK06/rdsJCoE/1P1JSfM9w7LU1RsTmseYML"
-        + "eJl5F79gQJBAO/BbAKqg1yzK7VijygvBoUrr+rt2lbmKgcUQ/rxu8IIQk0M/xgJqSkXDXuOnboGM7sQSKfJAZUtT"
-        + "7xozvLzV7ECQQCJW59w7NIM0qZ/gIX2gcNZr1B/V3zcGlolTDciRm+fnKGNt2EEDKnVL3swzbEfTCa48IT0QKgZJ"
-        + "qpXZERa26UHAkBLXmiP5f5pk8F3wcXzAeVw06z3k1IB41Tu6MX+CyPU+TeudRlz+wV8b0zDvK+EnRKCCbptVFj1B"
-        + "kt8lQ4JfcnhAkAk2Y3Gz+HySrkcT7Cg12M/NkdUQnZe3jr88pt/+IGNwomc6Wt/mJ4fcWONTkGMcfOZff1NQeNXD"
-        + "AZ6941XCsIVAkASOg02PlVHLidU7mIE65swMM5/RNhS4aFjez/MwxFNOHaxc9VgCwYPXCLOtdf7AVovdyG0XWgbU"
-        + "XH+NyxKwboE");
-    PrivateKey privateKey = keyFactory.generatePrivate(
-        new PKCS8EncodedKeySpec(privateKeyBytes.toByteArray()));
-
-    HeldCertificate heldCertificate = new HeldCertificate.Builder()
-        .keyPair(publicKey, privateKey)
-        .commonName("cash.app")
-        .validityInterval(0L, 1_000L)
-        .rsa2048()
-        .build();
-
-    assertThat((""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIBmjCCAQOgAwIBAgIBATANBgkqhkiG9w0BAQsFADATMREwDwYDVQQDEwhjYXNo\n"
-        + "LmFwcDAeFw03MDAxMDEwMDAwMDBaFw03MDAxMDEwMDAwMDFaMBMxETAPBgNVBAMT\n"
-        + "CGNhc2guYXBwMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCApFHhtrLan28q\n"
-        + "+oMolZuaTfWBA0V5aMIvq32BsloQu6LlvX1wJ4YEoUCjDlPOtpht7XLbUmBnbIzN\n"
-        + "89XK4UJVM6Sqp3K88Km8z7gMrdrfTom/274wL25fICR+yDEQ5fUVYBmJAKXZF1ao\n"
-        + "I0mIoEx0xFsQhIJ637v2MxJDupd61wIDAQABMA0GCSqGSIb3DQEBCwUAA4GBADam\n"
-        + "UVwKh5Ry7es3OxtY3IgQunPUoLc0Gw71gl9Z+7t2FJ5VkcI5gWfutmdxZ2bDXCI8\n"
-        + "8V0vxo1pHXnbBrnxhS/Z3TBerw8RyQqcaWOdp+pBXyIWmR+jHk9cHZCqQveTIBsY\n"
-        + "jaA9VEhgdaVhxBsT2qzUNDsXlOzGsliznDfoqETb\n"
-        + "-----END CERTIFICATE-----\n")).isEqualTo(heldCertificate.certificatePem());
-
-    assertThat((""
-        + "-----BEGIN RSA PRIVATE KEY-----\n"
-        + "MIICWwIBAAKBgQCApFHhtrLan28q+oMolZuaTfWBA0V5aMIvq32BsloQu6LlvX1w\n"
-        + "J4YEoUCjDlPOtpht7XLbUmBnbIzN89XK4UJVM6Sqp3K88Km8z7gMrdrfTom/274w\n"
-        + "L25fICR+yDEQ5fUVYBmJAKXZF1aoI0mIoEx0xFsQhIJ637v2MxJDupd61wIDAQAB\n"
-        + "AoGAffZoZweqYgAzrnXV7+tujc1AU6+MW7GEU4EsR88H+dKBU0wUg7lvtSDgVck1\n"
-        + "rveEkj8rdC5ZT2wvA4t7EEk51RqUqgLxF5JwTMyHNFDu+EZ/ad4GYxHpz7dZe+3y\n"
-        + "AWtpytOv63bCQqBP9T9SUnzPcOy1NUbE5rHmDC3iZeRe/YECQQDvwWwCqoNcsyu1\n"
-        + "Yo8oLwaFK6/q7dpW5ioHFEP68bvCCEJNDP8YCakpFw17jp26BjO7EEinyQGVLU+8\n"
-        + "aM7y81exAkEAiVufcOzSDNKmf4CF9oHDWa9Qf1d83BpaJUw3IkZvn5yhjbdhBAyp\n"
-        + "1S97MM2xH0wmuPCE9ECoGSaqV2REWtulBwJAS15oj+X+aZPBd8HF8wHlcNOs95NS\n"
-        + "AeNU7ujF/gsj1Pk3rnUZc/sFfG9Mw7yvhJ0Sggm6bVRY9QZLfJUOCX3J4QJAJNmN\n"
-        + "xs/h8kq5HE+woNdjPzZHVEJ2Xt46/PKbf/iBjcKJnOlrf5ieH3FjjU5BjHHzmX39\n"
-        + "TUHjVwwGeveNVwrCFQJAEjoNNj5VRy4nVO5iBOubMDDOf0TYUuGhY3s/zMMRTTh2\n"
-        + "sXPVYAsGD1wizrXX+wFaL3chtF1oG1Fx/jcsSsG6BA==\n"
-        + "-----END RSA PRIVATE KEY-----\n")).isEqualTo(heldCertificate.privateKeyPkcs1Pem());
-
-    assertThat((""
-        + "-----BEGIN PRIVATE KEY-----\n"
-        + "MIICdQIBADANBgkqhkiG9w0BAQEFAASCAl8wggJbAgEAAoGBAICkUeG2stqfbyr6\n"
-        + "gyiVm5pN9YEDRXlowi+rfYGyWhC7ouW9fXAnhgShQKMOU862mG3tcttSYGdsjM3z\n"
-        + "1crhQlUzpKqncrzwqbzPuAyt2t9Oib/bvjAvbl8gJH7IMRDl9RVgGYkApdkXVqgj\n"
-        + "SYigTHTEWxCEgnrfu/YzEkO6l3rXAgMBAAECgYB99mhnB6piADOuddXv626NzUBT\n"
-        + "r4xbsYRTgSxHzwf50oFTTBSDuW+1IOBVyTWu94SSPyt0LllPbC8Di3sQSTnVGpSq\n"
-        + "AvEXknBMzIc0UO74Rn9p3gZjEenPt1l77fIBa2nK06/rdsJCoE/1P1JSfM9w7LU1\n"
-        + "RsTmseYMLeJl5F79gQJBAO/BbAKqg1yzK7VijygvBoUrr+rt2lbmKgcUQ/rxu8II\n"
-        + "Qk0M/xgJqSkXDXuOnboGM7sQSKfJAZUtT7xozvLzV7ECQQCJW59w7NIM0qZ/gIX2\n"
-        + "gcNZr1B/V3zcGlolTDciRm+fnKGNt2EEDKnVL3swzbEfTCa48IT0QKgZJqpXZERa\n"
-        + "26UHAkBLXmiP5f5pk8F3wcXzAeVw06z3k1IB41Tu6MX+CyPU+TeudRlz+wV8b0zD\n"
-        + "vK+EnRKCCbptVFj1Bkt8lQ4JfcnhAkAk2Y3Gz+HySrkcT7Cg12M/NkdUQnZe3jr8\n"
-        + "8pt/+IGNwomc6Wt/mJ4fcWONTkGMcfOZff1NQeNXDAZ6941XCsIVAkASOg02PlVH\n"
-        + "LidU7mIE65swMM5/RNhS4aFjez/MwxFNOHaxc9VgCwYPXCLOtdf7AVovdyG0XWgb\n"
-        + "UXH+NyxKwboE\n"
-        + "-----END PRIVATE KEY-----\n")).isEqualTo(heldCertificate.privateKeyPkcs8Pem());
-  }
-
-  @Test public void ecdsaSignedByRsa() {
-    HeldCertificate root = new HeldCertificate.Builder()
-        .certificateAuthority(0)
-        .rsa2048()
-        .build();
-    HeldCertificate leaf = new HeldCertificate.Builder()
-        .certificateAuthority(0)
-        .ecdsa256()
-        .signedBy(root)
-        .build();
-
-    assertThat(root.certificate().getSigAlgName()).isEqualTo("SHA256WITHRSA");
-    assertThat(leaf.certificate().getSigAlgName()).isEqualTo("SHA256WITHRSA");
-  }
-
-  @Test public void rsaSignedByEcdsa() {
-    HeldCertificate root = new HeldCertificate.Builder()
-        .certificateAuthority(0)
-        .ecdsa256()
-        .build();
-    HeldCertificate leaf = new HeldCertificate.Builder()
-        .certificateAuthority(0)
-        .rsa2048()
-        .signedBy(root)
-        .build();
-
-    assertThat(root.certificate().getSigAlgName()).isEqualTo("SHA256WITHECDSA");
-    assertThat(leaf.certificate().getSigAlgName()).isEqualTo("SHA256WITHECDSA");
-  }
-}
diff --git a/okhttp-urlconnection/pom.xml b/okhttp-urlconnection/pom.xml
deleted file mode 100644
index aa4a1bb2b7..0000000000
--- a/okhttp-urlconnection/pom.xml
+++ /dev/null
@@ -1,90 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.14.3-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>okhttp-urlconnection</artifactId>
-  <name>OkHttp URLConnection</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.google.code.findbugs</groupId>
-      <artifactId>jsr305</artifactId>
-      <scope>provided</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.codehaus.mojo</groupId>
-      <artifactId>animal-sniffer-annotations</artifactId>
-      <version>${animal.sniffer.version}</version>
-      <optional>true</optional>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-testing-support</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-tls</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-javadoc-plugin</artifactId>
-        <version>3.0.1</version>
-        <configuration>
-          <excludePackageNames>okhttp3.internal:okhttp3.internal.*</excludePackageNames>
-          <links>
-            <link>http://square.github.io/okhttp/javadoc/</link>
-          </links>
-        </configuration>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-jar-plugin</artifactId>
-        <version>3.1.1</version>
-        <configuration>
-          <archive>
-            <manifestEntries>
-              <Automatic-Module-Name>okhttp3.urlconnection</Automatic-Module-Name>
-            </manifestEntries>
-          </archive>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java
deleted file mode 100644
index f1892b7199..0000000000
--- a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.net.Authenticator.RequestorType;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.PasswordAuthentication;
-import java.net.Proxy;
-import java.util.List;
-import okhttp3.internal.annotations.EverythingIsNonNull;
-
-/**
- * Adapts {@link java.net.Authenticator} to {@link Authenticator}. Configure OkHttp to use {@link
- * java.net.Authenticator} with {@link OkHttpClient.Builder#authenticator} or {@link
- * OkHttpClient.Builder#proxyAuthenticator(Authenticator)}.
- */
-@EverythingIsNonNull
-public final class JavaNetAuthenticator implements Authenticator {
-  @Override public Request authenticate(Route route, Response response) throws IOException {
-    List<Challenge> challenges = response.challenges();
-    Request request = response.request();
-    HttpUrl url = request.url();
-    boolean proxyAuthorization = response.code() == 407;
-    Proxy proxy = route.proxy();
-
-    for (int i = 0, size = challenges.size(); i < size; i++) {
-      Challenge challenge = challenges.get(i);
-      if (!"Basic".equalsIgnoreCase(challenge.scheme())) continue;
-
-      PasswordAuthentication auth;
-      if (proxyAuthorization) {
-        InetSocketAddress proxyAddress = (InetSocketAddress) proxy.address();
-        auth = java.net.Authenticator.requestPasswordAuthentication(
-            proxyAddress.getHostName(), getConnectToInetAddress(proxy, url), proxyAddress.getPort(),
-            url.scheme(), challenge.realm(), challenge.scheme(), url.url(),
-            RequestorType.PROXY);
-      } else {
-        auth = java.net.Authenticator.requestPasswordAuthentication(
-            url.host(), getConnectToInetAddress(proxy, url), url.port(), url.scheme(),
-            challenge.realm(), challenge.scheme(), url.url(), RequestorType.SERVER);
-      }
-
-      if (auth != null) {
-        String credential = Credentials.basic(
-            auth.getUserName(), new String(auth.getPassword()), challenge.charset());
-        return request.newBuilder()
-            .header(proxyAuthorization ? "Proxy-Authorization" : "Authorization", credential)
-            .build();
-      }
-    }
-
-    return null; // No challenges were satisfied!
-  }
-
-  private InetAddress getConnectToInetAddress(Proxy proxy, HttpUrl url) throws IOException {
-    return proxy.type() != Proxy.Type.DIRECT
-        ? ((InetSocketAddress) proxy.address()).getAddress()
-        : InetAddress.getByName(url.host());
-  }
-}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java
deleted file mode 100644
index 6faf288de7..0000000000
--- a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java
+++ /dev/null
@@ -1,114 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.net.CookieHandler;
-import java.net.HttpCookie;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
-import okhttp3.internal.annotations.EverythingIsNonNull;
-import okhttp3.internal.platform.Platform;
-
-import static okhttp3.internal.Util.delimiterOffset;
-import static okhttp3.internal.Util.trimSubstring;
-import static okhttp3.internal.platform.Platform.WARN;
-
-/** A cookie jar that delegates to a {@link java.net.CookieHandler}. */
-@EverythingIsNonNull
-public final class JavaNetCookieJar implements CookieJar {
-  private final CookieHandler cookieHandler;
-
-  public JavaNetCookieJar(CookieHandler cookieHandler) {
-    this.cookieHandler = cookieHandler;
-  }
-
-  @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {
-    if (cookieHandler != null) {
-      List<String> cookieStrings = new ArrayList<>();
-      for (Cookie cookie : cookies) {
-        cookieStrings.add(cookie.toString(true));
-      }
-      Map<String, List<String>> multimap = Collections.singletonMap("Set-Cookie", cookieStrings);
-      try {
-        cookieHandler.put(url.uri(), multimap);
-      } catch (IOException e) {
-        Platform.get().log(WARN, "Saving cookies failed for " + url.resolve("/..."), e);
-      }
-    }
-  }
-
-  @Override public List<Cookie> loadForRequest(HttpUrl url) {
-    // The RI passes all headers. We don't have 'em, so we don't pass 'em!
-    Map<String, List<String>> headers = Collections.emptyMap();
-    Map<String, List<String>> cookieHeaders;
-    try {
-      cookieHeaders = cookieHandler.get(url.uri(), headers);
-    } catch (IOException e) {
-      Platform.get().log(WARN, "Loading cookies failed for " + url.resolve("/..."), e);
-      return Collections.emptyList();
-    }
-
-    List<Cookie> cookies = null;
-    for (Map.Entry<String, List<String>> entry : cookieHeaders.entrySet()) {
-      String key = entry.getKey();
-      if (("Cookie".equalsIgnoreCase(key) || "Cookie2".equalsIgnoreCase(key))
-          && !entry.getValue().isEmpty()) {
-        for (String header : entry.getValue()) {
-          if (cookies == null) cookies = new ArrayList<>();
-          cookies.addAll(decodeHeaderAsJavaNetCookies(url, header));
-        }
-      }
-    }
-
-    return cookies != null
-        ? Collections.unmodifiableList(cookies)
-        : Collections.emptyList();
-  }
-
-  /**
-   * Convert a request header to OkHttp's cookies via {@link HttpCookie}. That extra step handles
-   * multiple cookies in a single request header, which {@link Cookie#parse} doesn't support.
-   */
-  private List<Cookie> decodeHeaderAsJavaNetCookies(HttpUrl url, String header) {
-    List<Cookie> result = new ArrayList<>();
-    for (int pos = 0, limit = header.length(), pairEnd; pos < limit; pos = pairEnd + 1) {
-      pairEnd = delimiterOffset(header, pos, limit, ";,");
-      int equalsSign = delimiterOffset(header, pos, pairEnd, '=');
-      String name = trimSubstring(header, pos, equalsSign);
-      if (name.startsWith("$")) continue;
-
-      // We have either name=value or just a name.
-      String value = equalsSign < pairEnd
-          ? trimSubstring(header, equalsSign + 1, pairEnd)
-          : "";
-
-      // If the value is "quoted", drop the quotes.
-      if (value.startsWith("\"") && value.endsWith("\"")) {
-        value = value.substring(1, value.length() - 1);
-      }
-
-      result.add(new Cookie.Builder()
-          .name(name)
-          .value(value)
-          .domain(url.host())
-          .build());
-    }
-    return result;
-  }
-}
diff --git a/okhttp/pom.xml b/okhttp/pom.xml
deleted file mode 100644
index a150bdb41b..0000000000
--- a/okhttp/pom.xml
+++ /dev/null
@@ -1,82 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.14.3-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>okhttp</artifactId>
-  <name>OkHttp</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup.okio</groupId>
-      <artifactId>okio</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>org.conscrypt</groupId>
-      <artifactId>conscrypt-openjdk-uber</artifactId>
-      <scope>provided</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.google.android</groupId>
-      <artifactId>android</artifactId>
-      <scope>provided</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.google.code.findbugs</groupId>
-      <artifactId>jsr305</artifactId>
-      <scope>provided</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.codehaus.mojo</groupId>
-      <artifactId>animal-sniffer-annotations</artifactId>
-      <version>1.17</version>
-      <scope>provided</scope>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.codehaus.mojo</groupId>
-        <artifactId>templating-maven-plugin</artifactId>
-        <version>1.0.0</version>
-        <executions>
-          <execution>
-            <goals>
-              <goal>filter-sources</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-javadoc-plugin</artifactId>
-        <version>3.0.1</version>
-        <configuration>
-          <excludePackageNames>okhttp3.internal:okhttp3.internal.*</excludePackageNames>
-          <links>
-            <link>http://square.github.io/okio/</link>
-          </links>
-        </configuration>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-jar-plugin</artifactId>
-        <version>3.1.1</version>
-        <configuration>
-          <archive>
-            <manifestEntries>
-              <Automatic-Module-Name>okhttp3</Automatic-Module-Name>
-            </manifestEntries>
-          </archive>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/okhttp/src/main/java-templates/okhttp3/internal/Version.java b/okhttp/src/main/java-templates/okhttp3/internal/Version.java
deleted file mode 100644
index fce1c067c0..0000000000
--- a/okhttp/src/main/java-templates/okhttp3/internal/Version.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal;
-
-public final class Version {
-  public static String userAgent() {
-    return "okhttp/${project.version}";
-  }
-
-  private Version() {
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Address.java b/okhttp/src/main/java/okhttp3/Address.java
deleted file mode 100644
index 5ad2a8d455..0000000000
--- a/okhttp/src/main/java/okhttp3/Address.java
+++ /dev/null
@@ -1,201 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.net.Proxy;
-import java.net.ProxySelector;
-import java.util.List;
-import java.util.Objects;
-import javax.annotation.Nullable;
-import javax.net.SocketFactory;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLSocketFactory;
-import okhttp3.internal.Util;
-
-/**
- * A specification for a connection to an origin server. For simple connections, this is the
- * server's hostname and port. If an explicit proxy is requested (or {@linkplain Proxy#NO_PROXY no
- * proxy} is explicitly requested), this also includes that proxy information. For secure
- * connections the address also includes the SSL socket factory, hostname verifier, and certificate
- * pinner.
- *
- * <p>HTTP requests that share the same {@code Address} may also share the same {@link Connection}.
- */
-public final class Address {
-  final HttpUrl url;
-  final Dns dns;
-  final SocketFactory socketFactory;
-  final Authenticator proxyAuthenticator;
-  final List<Protocol> protocols;
-  final List<ConnectionSpec> connectionSpecs;
-  final ProxySelector proxySelector;
-  final @Nullable Proxy proxy;
-  final @Nullable SSLSocketFactory sslSocketFactory;
-  final @Nullable HostnameVerifier hostnameVerifier;
-  final @Nullable CertificatePinner certificatePinner;
-
-  public Address(String uriHost, int uriPort, Dns dns, SocketFactory socketFactory,
-      @Nullable SSLSocketFactory sslSocketFactory, @Nullable HostnameVerifier hostnameVerifier,
-      @Nullable CertificatePinner certificatePinner, Authenticator proxyAuthenticator,
-      @Nullable Proxy proxy, List<Protocol> protocols, List<ConnectionSpec> connectionSpecs,
-      ProxySelector proxySelector) {
-    this.url = new HttpUrl.Builder()
-        .scheme(sslSocketFactory != null ? "https" : "http")
-        .host(uriHost)
-        .port(uriPort)
-        .build();
-
-    if (dns == null) throw new NullPointerException("dns == null");
-    this.dns = dns;
-
-    if (socketFactory == null) throw new NullPointerException("socketFactory == null");
-    this.socketFactory = socketFactory;
-
-    if (proxyAuthenticator == null) {
-      throw new NullPointerException("proxyAuthenticator == null");
-    }
-    this.proxyAuthenticator = proxyAuthenticator;
-
-    if (protocols == null) throw new NullPointerException("protocols == null");
-    this.protocols = Util.immutableList(protocols);
-
-    if (connectionSpecs == null) throw new NullPointerException("connectionSpecs == null");
-    this.connectionSpecs = Util.immutableList(connectionSpecs);
-
-    if (proxySelector == null) throw new NullPointerException("proxySelector == null");
-    this.proxySelector = proxySelector;
-
-    this.proxy = proxy;
-    this.sslSocketFactory = sslSocketFactory;
-    this.hostnameVerifier = hostnameVerifier;
-    this.certificatePinner = certificatePinner;
-  }
-
-  /**
-   * Returns a URL with the hostname and port of the origin server. The path, query, and fragment of
-   * this URL are always empty, since they are not significant for planning a route.
-   */
-  public HttpUrl url() {
-    return url;
-  }
-
-  /** Returns the service that will be used to resolve IP addresses for hostnames. */
-  public Dns dns() {
-    return dns;
-  }
-
-  /** Returns the socket factory for new connections. */
-  public SocketFactory socketFactory() {
-    return socketFactory;
-  }
-
-  /** Returns the client's proxy authenticator. */
-  public Authenticator proxyAuthenticator() {
-    return proxyAuthenticator;
-  }
-
-  /**
-   * Returns the protocols the client supports. This method always returns a non-null list that
-   * contains minimally {@link Protocol#HTTP_1_1}.
-   */
-  public List<Protocol> protocols() {
-    return protocols;
-  }
-
-  public List<ConnectionSpec> connectionSpecs() {
-    return connectionSpecs;
-  }
-
-  /**
-   * Returns this address's proxy selector. Only used if the proxy is null. If none of this
-   * selector's proxies are reachable, a direct connection will be attempted.
-   */
-  public ProxySelector proxySelector() {
-    return proxySelector;
-  }
-
-  /**
-   * Returns this address's explicitly-specified HTTP proxy, or null to delegate to the {@linkplain
-   * #proxySelector proxy selector}.
-   */
-  public @Nullable Proxy proxy() {
-    return proxy;
-  }
-
-  /** Returns the SSL socket factory, or null if this is not an HTTPS address. */
-  public @Nullable SSLSocketFactory sslSocketFactory() {
-    return sslSocketFactory;
-  }
-
-  /** Returns the hostname verifier, or null if this is not an HTTPS address. */
-  public @Nullable HostnameVerifier hostnameVerifier() {
-    return hostnameVerifier;
-  }
-
-  /** Returns this address's certificate pinner, or null if this is not an HTTPS address. */
-  public @Nullable CertificatePinner certificatePinner() {
-    return certificatePinner;
-  }
-
-  @Override public boolean equals(@Nullable Object other) {
-    return other instanceof Address
-        && url.equals(((Address) other).url)
-        && equalsNonHost((Address) other);
-  }
-
-  @Override public int hashCode() {
-    int result = 17;
-    result = 31 * result + url.hashCode();
-    result = 31 * result + dns.hashCode();
-    result = 31 * result + proxyAuthenticator.hashCode();
-    result = 31 * result + protocols.hashCode();
-    result = 31 * result + connectionSpecs.hashCode();
-    result = 31 * result + proxySelector.hashCode();
-    result = 31 * result + Objects.hashCode(proxy);
-    result = 31 * result + Objects.hashCode(sslSocketFactory);
-    result = 31 * result + Objects.hashCode(hostnameVerifier);
-    result = 31 * result + Objects.hashCode(certificatePinner);
-    return result;
-  }
-
-  boolean equalsNonHost(Address that) {
-    return this.dns.equals(that.dns)
-        && this.proxyAuthenticator.equals(that.proxyAuthenticator)
-        && this.protocols.equals(that.protocols)
-        && this.connectionSpecs.equals(that.connectionSpecs)
-        && this.proxySelector.equals(that.proxySelector)
-        && Objects.equals(this.proxy, that.proxy)
-        && Objects.equals(this.sslSocketFactory, that.sslSocketFactory)
-        && Objects.equals(this.hostnameVerifier, that.hostnameVerifier)
-        && Objects.equals(this.certificatePinner, that.certificatePinner)
-        && this.url().port() == that.url().port();
-  }
-
-  @Override public String toString() {
-    StringBuilder result = new StringBuilder()
-        .append("Address{")
-        .append(url.host()).append(":").append(url.port());
-
-    if (proxy != null) {
-      result.append(", proxy=").append(proxy);
-    } else {
-      result.append(", proxySelector=").append(proxySelector);
-    }
-
-    result.append("}");
-    return result.toString();
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Authenticator.java b/okhttp/src/main/java/okhttp3/Authenticator.java
deleted file mode 100644
index 6e1d1a4fd5..0000000000
--- a/okhttp/src/main/java/okhttp3/Authenticator.java
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import javax.annotation.Nullable;
-
-/**
- * Performs either <strong>preemptive</strong> authentication before connecting to a proxy server,
- * or <strong>reactive</strong> authentication after receiving a challenge from either an origin web
- * server or proxy server.
- *
- * <h3>Preemptive Authentication</h3>
- *
- * <p>To make HTTPS calls using an HTTP proxy server OkHttp must first negotiate a connection with
- * the proxy. This proxy connection is called a "TLS Tunnel" and is specified by <a
- * href="https://tools.ietf.org/html/rfc2817">RFC 2817</a>. The HTTP CONNECT request that creates
- * this tunnel connection is special: it does not participate in any {@linkplain Interceptor
- * interceptors} or {@linkplain EventListener event listeners}. It doesn't include the motivating
- * request's HTTP headers or even its full URL; only the target server's hostname is sent to the
- * proxy.
- *
- * <p>Prior to sending any CONNECT request OkHttp always calls the proxy authenticator so that it
- * may prepare preemptive authentication. OkHttp will call {@link #authenticate} with a fake {@code
- * HTTP/1.1 407 Proxy Authentication Required} response that has a {@code Proxy-Authenticate:
- * OkHttp-Preemptive} challenge. The proxy authenticator may return either either an authenticated
- * request, or null to connect without authentication.
- * <pre>   {@code
- *    for (Challenge challenge : response.challenges()) {
- *      // If this is preemptive auth, use a preemptive credential.
- *      if (challenge.scheme().equalsIgnoreCase("OkHttp-Preemptive")) {
- *        return response.request().newBuilder()
- *            .header("Proxy-Authorization", "secret")
- *            .build();
- *      }
- *    }
- *
- *    return null; // Didn't find a preemptive auth scheme.
- * }</pre>
- *
- * <h3>Reactive Authentication</h3>
- *
- * <p>Implementations authenticate by returning a follow-up request that includes an authorization
- * header, or they may decline the challenge by returning null. In this case the unauthenticated
- * response will be returned to the caller that triggered it.
- *
- * <p>Implementations should check if the initial request already included an attempt to
- * authenticate. If so it is likely that further attempts will not be useful and the authenticator
- * should give up.
- *
- * <p>When reactive authentication is requested by an origin web server, the response code is 401
- * and the implementation should respond with a new request that sets the "Authorization" header.
- * <pre>   {@code
- *
- *    if (response.request().header("Authorization") != null) {
- *      return null; // Give up, we've already failed to authenticate.
- *    }
- *
- *    String credential = Credentials.basic(...)
- *    return response.request().newBuilder()
- *        .header("Authorization", credential)
- *        .build();
- * }</pre>
- *
- * <p>When reactive authentication is requested by a proxy server, the response code is 407 and the
- * implementation should respond with a new request that sets the "Proxy-Authorization" header.
- * <pre>   {@code
- *
- *    if (response.request().header("Proxy-Authorization") != null) {
- *      return null; // Give up, we've already failed to authenticate.
- *    }
- *
- *    String credential = Credentials.basic(...)
- *    return response.request().newBuilder()
- *        .header("Proxy-Authorization", credential)
- *        .build();
- * }</pre>
- *
- * <p>The proxy authenticator may implement preemptive authentication, reactive authentication, or
- * both.
- *
- * <p>Applications may configure OkHttp with an authenticator for origin servers, or proxy servers,
- * or both.
- */
-public interface Authenticator {
-  /** An authenticator that knows no credentials and makes no attempt to authenticate. */
-  Authenticator NONE = (route, response) -> null;
-
-  /**
-   * Returns a request that includes a credential to satisfy an authentication challenge in {@code
-   * response}. Returns null if the challenge cannot be satisfied.
-   *
-   * <p>The route is best effort, it currently may not always be provided even when logically
-   * available. It may also not be provided when an authenticator is re-used manually in an
-   * application interceptor, such as when implementing client-specific retries.
-   */
-  @Nullable Request authenticate(@Nullable Route route, Response response) throws IOException;
-}
diff --git a/okhttp/src/main/java/okhttp3/Cache.java b/okhttp/src/main/java/okhttp3/Cache.java
deleted file mode 100644
index 2ba97ffd0f..0000000000
--- a/okhttp/src/main/java/okhttp3/Cache.java
+++ /dev/null
@@ -1,771 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.Closeable;
-import java.io.File;
-import java.io.Flushable;
-import java.io.IOException;
-import java.security.cert.Certificate;
-import java.security.cert.CertificateEncodingException;
-import java.security.cert.CertificateException;
-import java.security.cert.CertificateFactory;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-import java.util.NoSuchElementException;
-import javax.annotation.Nullable;
-import okhttp3.internal.Util;
-import okhttp3.internal.cache.CacheRequest;
-import okhttp3.internal.cache.CacheStrategy;
-import okhttp3.internal.cache.DiskLruCache;
-import okhttp3.internal.cache.InternalCache;
-import okhttp3.internal.http.HttpHeaders;
-import okhttp3.internal.http.HttpMethod;
-import okhttp3.internal.http.StatusLine;
-import okhttp3.internal.io.FileSystem;
-import okhttp3.internal.platform.Platform;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.ForwardingSink;
-import okio.ForwardingSource;
-import okio.Okio;
-import okio.Sink;
-import okio.Source;
-
-/**
- * Caches HTTP and HTTPS responses to the filesystem so they may be reused, saving time and
- * bandwidth.
- *
- * <h3>Cache Optimization</h3>
- *
- * <p>To measure cache effectiveness, this class tracks three statistics:
- * <ul>
- *     <li><strong>{@linkplain #requestCount() Request Count:}</strong> the number of HTTP
- *         requests issued since this cache was created.
- *     <li><strong>{@linkplain #networkCount() Network Count:}</strong> the number of those
- *         requests that required network use.
- *     <li><strong>{@linkplain #hitCount() Hit Count:}</strong> the number of those requests
- *         whose responses were served by the cache.
- * </ul>
- *
- * Sometimes a request will result in a conditional cache hit. If the cache contains a stale copy of
- * the response, the client will issue a conditional {@code GET}. The server will then send either
- * the updated response if it has changed, or a short 'not modified' response if the client's copy
- * is still valid. Such responses increment both the network count and hit count.
- *
- * <p>The best way to improve the cache hit rate is by configuring the web server to return
- * cacheable responses. Although this client honors all <a
- * href="http://tools.ietf.org/html/rfc7234">HTTP/1.1 (RFC 7234)</a> cache headers, it doesn't cache
- * partial responses.
- *
- * <h3>Force a Network Response</h3>
- *
- * <p>In some situations, such as after a user clicks a 'refresh' button, it may be necessary to
- * skip the cache, and fetch data directly from the server. To force a full refresh, add the {@code
- * no-cache} directive: <pre>   {@code
- *
- *   Request request = new Request.Builder()
- *       .cacheControl(new CacheControl.Builder().noCache().build())
- *       .url("http://publicobject.com/helloworld.txt")
- *       .build();
- * }</pre>
- *
- * If it is only necessary to force a cached response to be validated by the server, use the more
- * efficient {@code max-age=0} directive instead: <pre>   {@code
- *
- *   Request request = new Request.Builder()
- *       .cacheControl(new CacheControl.Builder()
- *           .maxAge(0, TimeUnit.SECONDS)
- *           .build())
- *       .url("http://publicobject.com/helloworld.txt")
- *       .build();
- * }</pre>
- *
- * <h3>Force a Cache Response</h3>
- *
- * <p>Sometimes you'll want to show resources if they are available immediately, but not otherwise.
- * This can be used so your application can show <i>something</i> while waiting for the latest data
- * to be downloaded. To restrict a request to locally-cached resources, add the {@code
- * only-if-cached} directive: <pre>   {@code
- *
- *     Request request = new Request.Builder()
- *         .cacheControl(new CacheControl.Builder()
- *             .onlyIfCached()
- *             .build())
- *         .url("http://publicobject.com/helloworld.txt")
- *         .build();
- *     Response forceCacheResponse = client.newCall(request).execute();
- *     if (forceCacheResponse.code() != 504) {
- *       // The resource was cached! Show it.
- *     } else {
- *       // The resource was not cached.
- *     }
- * }</pre>
- * This technique works even better in situations where a stale response is better than no response.
- * To permit stale cached responses, use the {@code max-stale} directive with the maximum staleness
- * in seconds: <pre>   {@code
- *
- *   Request request = new Request.Builder()
- *       .cacheControl(new CacheControl.Builder()
- *           .maxStale(365, TimeUnit.DAYS)
- *           .build())
- *       .url("http://publicobject.com/helloworld.txt")
- *       .build();
- * }</pre>
- *
- * <p>The {@link CacheControl} class can configure request caching directives and parse response
- * caching directives. It even offers convenient constants {@link CacheControl#FORCE_NETWORK} and
- * {@link CacheControl#FORCE_CACHE} that address the use cases above.
- */
-public final class Cache implements Closeable, Flushable {
-  private static final int VERSION = 201105;
-  private static final int ENTRY_METADATA = 0;
-  private static final int ENTRY_BODY = 1;
-  private static final int ENTRY_COUNT = 2;
-
-  final InternalCache internalCache = new InternalCache() {
-    @Override public @Nullable Response get(Request request) throws IOException {
-      return Cache.this.get(request);
-    }
-
-    @Override public @Nullable CacheRequest put(Response response) throws IOException {
-      return Cache.this.put(response);
-    }
-
-    @Override public void remove(Request request) throws IOException {
-      Cache.this.remove(request);
-    }
-
-    @Override public void update(Response cached, Response network) {
-      Cache.this.update(cached, network);
-    }
-
-    @Override public void trackConditionalCacheHit() {
-      Cache.this.trackConditionalCacheHit();
-    }
-
-    @Override public void trackResponse(CacheStrategy cacheStrategy) {
-      Cache.this.trackResponse(cacheStrategy);
-    }
-  };
-
-  final DiskLruCache cache;
-
-  /* read and write statistics, all guarded by 'this' */
-  int writeSuccessCount;
-  int writeAbortCount;
-  private int networkCount;
-  private int hitCount;
-  private int requestCount;
-
-  /**
-   * Create a cache of at most {@code maxSize} bytes in {@code directory}.
-   */
-  public Cache(File directory, long maxSize) {
-    this(directory, maxSize, FileSystem.SYSTEM);
-  }
-
-  Cache(File directory, long maxSize, FileSystem fileSystem) {
-    this.cache = DiskLruCache.create(fileSystem, directory, VERSION, ENTRY_COUNT, maxSize);
-  }
-
-  public static String key(HttpUrl url) {
-    return ByteString.encodeUtf8(url.toString()).md5().hex();
-  }
-
-  @Nullable Response get(Request request) {
-    String key = key(request.url());
-    DiskLruCache.Snapshot snapshot;
-    Entry entry;
-    try {
-      snapshot = cache.get(key);
-      if (snapshot == null) {
-        return null;
-      }
-    } catch (IOException e) {
-      // Give up because the cache cannot be read.
-      return null;
-    }
-
-    try {
-      entry = new Entry(snapshot.getSource(ENTRY_METADATA));
-    } catch (IOException e) {
-      Util.closeQuietly(snapshot);
-      return null;
-    }
-
-    Response response = entry.response(snapshot);
-
-    if (!entry.matches(request, response)) {
-      Util.closeQuietly(response.body());
-      return null;
-    }
-
-    return response;
-  }
-
-  @Nullable CacheRequest put(Response response) {
-    String requestMethod = response.request().method();
-
-    if (HttpMethod.invalidatesCache(response.request().method())) {
-      try {
-        remove(response.request());
-      } catch (IOException ignored) {
-        // The cache cannot be written.
-      }
-      return null;
-    }
-    if (!requestMethod.equals("GET")) {
-      // Don't cache non-GET responses. We're technically allowed to cache
-      // HEAD requests and some POST requests, but the complexity of doing
-      // so is high and the benefit is low.
-      return null;
-    }
-
-    if (HttpHeaders.hasVaryAll(response)) {
-      return null;
-    }
-
-    Entry entry = new Entry(response);
-    DiskLruCache.Editor editor = null;
-    try {
-      editor = cache.edit(key(response.request().url()));
-      if (editor == null) {
-        return null;
-      }
-      entry.writeTo(editor);
-      return new CacheRequestImpl(editor);
-    } catch (IOException e) {
-      abortQuietly(editor);
-      return null;
-    }
-  }
-
-  void remove(Request request) throws IOException {
-    cache.remove(key(request.url()));
-  }
-
-  void update(Response cached, Response network) {
-    Entry entry = new Entry(network);
-    DiskLruCache.Snapshot snapshot = ((CacheResponseBody) cached.body()).snapshot;
-    DiskLruCache.Editor editor = null;
-    try {
-      editor = snapshot.edit(); // Returns null if snapshot is not current.
-      if (editor != null) {
-        entry.writeTo(editor);
-        editor.commit();
-      }
-    } catch (IOException e) {
-      abortQuietly(editor);
-    }
-  }
-
-  private void abortQuietly(@Nullable DiskLruCache.Editor editor) {
-    // Give up because the cache cannot be written.
-    try {
-      if (editor != null) {
-        editor.abort();
-      }
-    } catch (IOException ignored) {
-    }
-  }
-
-  /**
-   * Initialize the cache. This will include reading the journal files from the storage and building
-   * up the necessary in-memory cache information.
-   *
-   * <p>The initialization time may vary depending on the journal file size and the current actual
-   * cache size. The application needs to be aware of calling this function during the
-   * initialization phase and preferably in a background worker thread.
-   *
-   * <p>Note that if the application chooses to not call this method to initialize the cache. By
-   * default, the okhttp will perform lazy initialization upon the first usage of the cache.
-   */
-  public void initialize() throws IOException {
-    cache.initialize();
-  }
-
-  /**
-   * Closes the cache and deletes all of its stored values. This will delete all files in the cache
-   * directory including files that weren't created by the cache.
-   */
-  public void delete() throws IOException {
-    cache.delete();
-  }
-
-  /**
-   * Deletes all values stored in the cache. In-flight writes to the cache will complete normally,
-   * but the corresponding responses will not be stored.
-   */
-  public void evictAll() throws IOException {
-    cache.evictAll();
-  }
-
-  /**
-   * Returns an iterator over the URLs in this cache. This iterator doesn't throw {@code
-   * ConcurrentModificationException}, but if new responses are added while iterating, their URLs
-   * will not be returned. If existing responses are evicted during iteration, they will be absent
-   * (unless they were already returned).
-   *
-   * <p>The iterator supports {@linkplain Iterator#remove}. Removing a URL from the iterator evicts
-   * the corresponding response from the cache. Use this to evict selected responses.
-   */
-  public Iterator<String> urls() throws IOException {
-    return new Iterator<String>() {
-      final Iterator<DiskLruCache.Snapshot> delegate = cache.snapshots();
-
-      @Nullable String nextUrl;
-      boolean canRemove;
-
-      @Override public boolean hasNext() {
-        if (nextUrl != null) return true;
-
-        canRemove = false; // Prevent delegate.remove() on the wrong item!
-        while (delegate.hasNext()) {
-          try (DiskLruCache.Snapshot snapshot = delegate.next()) {
-            BufferedSource metadata = Okio.buffer(snapshot.getSource(ENTRY_METADATA));
-            nextUrl = metadata.readUtf8LineStrict();
-            return true;
-          } catch (IOException ignored) {
-            // We couldn't read the metadata for this snapshot; possibly because the host filesystem
-            // has disappeared! Skip it.
-          }
-        }
-
-        return false;
-      }
-
-      @Override public String next() {
-        if (!hasNext()) throw new NoSuchElementException();
-        String result = nextUrl;
-        nextUrl = null;
-        canRemove = true;
-        return result;
-      }
-
-      @Override public void remove() {
-        if (!canRemove) throw new IllegalStateException("remove() before next()");
-        delegate.remove();
-      }
-    };
-  }
-
-  public synchronized int writeAbortCount() {
-    return writeAbortCount;
-  }
-
-  public synchronized int writeSuccessCount() {
-    return writeSuccessCount;
-  }
-
-  public long size() throws IOException {
-    return cache.size();
-  }
-
-  /** Max size of the cache (in bytes). */
-  public long maxSize() {
-    return cache.getMaxSize();
-  }
-
-  @Override public void flush() throws IOException {
-    cache.flush();
-  }
-
-  @Override public void close() throws IOException {
-    cache.close();
-  }
-
-  public File directory() {
-    return cache.getDirectory();
-  }
-
-  public boolean isClosed() {
-    return cache.isClosed();
-  }
-
-  synchronized void trackResponse(CacheStrategy cacheStrategy) {
-    requestCount++;
-
-    if (cacheStrategy.networkRequest != null) {
-      // If this is a conditional request, we'll increment hitCount if/when it hits.
-      networkCount++;
-    } else if (cacheStrategy.cacheResponse != null) {
-      // This response uses the cache and not the network. That's a cache hit.
-      hitCount++;
-    }
-  }
-
-  synchronized void trackConditionalCacheHit() {
-    hitCount++;
-  }
-
-  public synchronized int networkCount() {
-    return networkCount;
-  }
-
-  public synchronized int hitCount() {
-    return hitCount;
-  }
-
-  public synchronized int requestCount() {
-    return requestCount;
-  }
-
-  private final class CacheRequestImpl implements CacheRequest {
-    private final DiskLruCache.Editor editor;
-    private Sink cacheOut;
-    private Sink body;
-    boolean done;
-
-    CacheRequestImpl(final DiskLruCache.Editor editor) {
-      this.editor = editor;
-      this.cacheOut = editor.newSink(ENTRY_BODY);
-      this.body = new ForwardingSink(cacheOut) {
-        @Override public void close() throws IOException {
-          synchronized (Cache.this) {
-            if (done) {
-              return;
-            }
-            done = true;
-            writeSuccessCount++;
-          }
-          super.close();
-          editor.commit();
-        }
-      };
-    }
-
-    @Override public void abort() {
-      synchronized (Cache.this) {
-        if (done) {
-          return;
-        }
-        done = true;
-        writeAbortCount++;
-      }
-      Util.closeQuietly(cacheOut);
-      try {
-        editor.abort();
-      } catch (IOException ignored) {
-      }
-    }
-
-    @Override public Sink body() {
-      return body;
-    }
-  }
-
-  private static final class Entry {
-    /** Synthetic response header: the local time when the request was sent. */
-    private static final String SENT_MILLIS = Platform.get().getPrefix() + "-Sent-Millis";
-
-    /** Synthetic response header: the local time when the response was received. */
-    private static final String RECEIVED_MILLIS = Platform.get().getPrefix() + "-Received-Millis";
-
-    private final String url;
-    private final Headers varyHeaders;
-    private final String requestMethod;
-    private final Protocol protocol;
-    private final int code;
-    private final String message;
-    private final Headers responseHeaders;
-    private final @Nullable Handshake handshake;
-    private final long sentRequestMillis;
-    private final long receivedResponseMillis;
-
-    /**
-     * Reads an entry from an input stream. A typical entry looks like this:
-     * <pre>{@code
-     *   http://google.com/foo
-     *   GET
-     *   2
-     *   Accept-Language: fr-CA
-     *   Accept-Charset: UTF-8
-     *   HTTP/1.1 200 OK
-     *   3
-     *   Content-Type: image/png
-     *   Content-Length: 100
-     *   Cache-Control: max-age=600
-     * }</pre>
-     *
-     * <p>A typical HTTPS file looks like this:
-     * <pre>{@code
-     *   https://google.com/foo
-     *   GET
-     *   2
-     *   Accept-Language: fr-CA
-     *   Accept-Charset: UTF-8
-     *   HTTP/1.1 200 OK
-     *   3
-     *   Content-Type: image/png
-     *   Content-Length: 100
-     *   Cache-Control: max-age=600
-     *
-     *   AES_256_WITH_MD5
-     *   2
-     *   base64-encoded peerCertificate[0]
-     *   base64-encoded peerCertificate[1]
-     *   -1
-     *   TLSv1.2
-     * }</pre>
-     * The file is newline separated. The first two lines are the URL and the request method. Next
-     * is the number of HTTP Vary request header lines, followed by those lines.
-     *
-     * <p>Next is the response status line, followed by the number of HTTP response header lines,
-     * followed by those lines.
-     *
-     * <p>HTTPS responses also contain SSL session information. This begins with a blank line, and
-     * then a line containing the cipher suite. Next is the length of the peer certificate chain.
-     * These certificates are base64-encoded and appear each on their own line. The next line
-     * contains the length of the local certificate chain. These certificates are also
-     * base64-encoded and appear each on their own line. A length of -1 is used to encode a null
-     * array. The last line is optional. If present, it contains the TLS version.
-     */
-    Entry(Source in) throws IOException {
-      try {
-        BufferedSource source = Okio.buffer(in);
-        url = source.readUtf8LineStrict();
-        requestMethod = source.readUtf8LineStrict();
-        Headers.Builder varyHeadersBuilder = new Headers.Builder();
-        int varyRequestHeaderLineCount = readInt(source);
-        for (int i = 0; i < varyRequestHeaderLineCount; i++) {
-          varyHeadersBuilder.addLenient(source.readUtf8LineStrict());
-        }
-        varyHeaders = varyHeadersBuilder.build();
-
-        StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict());
-        protocol = statusLine.protocol;
-        code = statusLine.code;
-        message = statusLine.message;
-        Headers.Builder responseHeadersBuilder = new Headers.Builder();
-        int responseHeaderLineCount = readInt(source);
-        for (int i = 0; i < responseHeaderLineCount; i++) {
-          responseHeadersBuilder.addLenient(source.readUtf8LineStrict());
-        }
-        String sendRequestMillisString = responseHeadersBuilder.get(SENT_MILLIS);
-        String receivedResponseMillisString = responseHeadersBuilder.get(RECEIVED_MILLIS);
-        responseHeadersBuilder.removeAll(SENT_MILLIS);
-        responseHeadersBuilder.removeAll(RECEIVED_MILLIS);
-        sentRequestMillis = sendRequestMillisString != null
-            ? Long.parseLong(sendRequestMillisString)
-            : 0L;
-        receivedResponseMillis = receivedResponseMillisString != null
-            ? Long.parseLong(receivedResponseMillisString)
-            : 0L;
-        responseHeaders = responseHeadersBuilder.build();
-
-        if (isHttps()) {
-          String blank = source.readUtf8LineStrict();
-          if (blank.length() > 0) {
-            throw new IOException("expected \"\" but was \"" + blank + "\"");
-          }
-          String cipherSuiteString = source.readUtf8LineStrict();
-          CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);
-          List<Certificate> peerCertificates = readCertificateList(source);
-          List<Certificate> localCertificates = readCertificateList(source);
-          TlsVersion tlsVersion = !source.exhausted()
-              ? TlsVersion.forJavaName(source.readUtf8LineStrict())
-              : TlsVersion.SSL_3_0;
-          handshake = Handshake.get(tlsVersion, cipherSuite, peerCertificates, localCertificates);
-        } else {
-          handshake = null;
-        }
-      } finally {
-        in.close();
-      }
-    }
-
-    Entry(Response response) {
-      this.url = response.request().url().toString();
-      this.varyHeaders = HttpHeaders.varyHeaders(response);
-      this.requestMethod = response.request().method();
-      this.protocol = response.protocol();
-      this.code = response.code();
-      this.message = response.message();
-      this.responseHeaders = response.headers();
-      this.handshake = response.handshake();
-      this.sentRequestMillis = response.sentRequestAtMillis();
-      this.receivedResponseMillis = response.receivedResponseAtMillis();
-    }
-
-    public void writeTo(DiskLruCache.Editor editor) throws IOException {
-      BufferedSink sink = Okio.buffer(editor.newSink(ENTRY_METADATA));
-
-      sink.writeUtf8(url)
-          .writeByte('\n');
-      sink.writeUtf8(requestMethod)
-          .writeByte('\n');
-      sink.writeDecimalLong(varyHeaders.size())
-          .writeByte('\n');
-      for (int i = 0, size = varyHeaders.size(); i < size; i++) {
-        sink.writeUtf8(varyHeaders.name(i))
-            .writeUtf8(": ")
-            .writeUtf8(varyHeaders.value(i))
-            .writeByte('\n');
-      }
-
-      sink.writeUtf8(new StatusLine(protocol, code, message).toString())
-          .writeByte('\n');
-      sink.writeDecimalLong(responseHeaders.size() + 2)
-          .writeByte('\n');
-      for (int i = 0, size = responseHeaders.size(); i < size; i++) {
-        sink.writeUtf8(responseHeaders.name(i))
-            .writeUtf8(": ")
-            .writeUtf8(responseHeaders.value(i))
-            .writeByte('\n');
-      }
-      sink.writeUtf8(SENT_MILLIS)
-          .writeUtf8(": ")
-          .writeDecimalLong(sentRequestMillis)
-          .writeByte('\n');
-      sink.writeUtf8(RECEIVED_MILLIS)
-          .writeUtf8(": ")
-          .writeDecimalLong(receivedResponseMillis)
-          .writeByte('\n');
-
-      if (isHttps()) {
-        sink.writeByte('\n');
-        sink.writeUtf8(handshake.cipherSuite().javaName())
-            .writeByte('\n');
-        writeCertList(sink, handshake.peerCertificates());
-        writeCertList(sink, handshake.localCertificates());
-        sink.writeUtf8(handshake.tlsVersion().javaName()).writeByte('\n');
-      }
-      sink.close();
-    }
-
-    private boolean isHttps() {
-      return url.startsWith("https://");
-    }
-
-    private List<Certificate> readCertificateList(BufferedSource source) throws IOException {
-      int length = readInt(source);
-      if (length == -1) return Collections.emptyList(); // OkHttp v1.2 used -1 to indicate null.
-
-      try {
-        CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
-        List<Certificate> result = new ArrayList<>(length);
-        for (int i = 0; i < length; i++) {
-          String line = source.readUtf8LineStrict();
-          Buffer bytes = new Buffer();
-          bytes.write(ByteString.decodeBase64(line));
-          result.add(certificateFactory.generateCertificate(bytes.inputStream()));
-        }
-        return result;
-      } catch (CertificateException e) {
-        throw new IOException(e.getMessage());
-      }
-    }
-
-    private void writeCertList(BufferedSink sink, List<Certificate> certificates)
-        throws IOException {
-      try {
-        sink.writeDecimalLong(certificates.size())
-            .writeByte('\n');
-        for (int i = 0, size = certificates.size(); i < size; i++) {
-          byte[] bytes = certificates.get(i).getEncoded();
-          String line = ByteString.of(bytes).base64();
-          sink.writeUtf8(line)
-              .writeByte('\n');
-        }
-      } catch (CertificateEncodingException e) {
-        throw new IOException(e.getMessage());
-      }
-    }
-
-    public boolean matches(Request request, Response response) {
-      return url.equals(request.url().toString())
-          && requestMethod.equals(request.method())
-          && HttpHeaders.varyMatches(response, varyHeaders, request);
-    }
-
-    public Response response(DiskLruCache.Snapshot snapshot) {
-      String contentType = responseHeaders.get("Content-Type");
-      String contentLength = responseHeaders.get("Content-Length");
-      Request cacheRequest = new Request.Builder()
-          .url(url)
-          .method(requestMethod, null)
-          .headers(varyHeaders)
-          .build();
-      return new Response.Builder()
-          .request(cacheRequest)
-          .protocol(protocol)
-          .code(code)
-          .message(message)
-          .headers(responseHeaders)
-          .body(new CacheResponseBody(snapshot, contentType, contentLength))
-          .handshake(handshake)
-          .sentRequestAtMillis(sentRequestMillis)
-          .receivedResponseAtMillis(receivedResponseMillis)
-          .build();
-    }
-  }
-
-  static int readInt(BufferedSource source) throws IOException {
-    try {
-      long result = source.readDecimalLong();
-      String line = source.readUtf8LineStrict();
-      if (result < 0 || result > Integer.MAX_VALUE || !line.isEmpty()) {
-        throw new IOException("expected an int but was \"" + result + line + "\"");
-      }
-      return (int) result;
-    } catch (NumberFormatException e) {
-      throw new IOException(e.getMessage());
-    }
-  }
-
-  private static class CacheResponseBody extends ResponseBody {
-    final DiskLruCache.Snapshot snapshot;
-    private final BufferedSource bodySource;
-    private final @Nullable String contentType;
-    private final @Nullable String contentLength;
-
-    CacheResponseBody(final DiskLruCache.Snapshot snapshot,
-        String contentType, String contentLength) {
-      this.snapshot = snapshot;
-      this.contentType = contentType;
-      this.contentLength = contentLength;
-
-      Source source = snapshot.getSource(ENTRY_BODY);
-      bodySource = Okio.buffer(new ForwardingSource(source) {
-        @Override public void close() throws IOException {
-          snapshot.close();
-          super.close();
-        }
-      });
-    }
-
-    @Override public MediaType contentType() {
-      return contentType != null ? MediaType.parse(contentType) : null;
-    }
-
-    @Override public long contentLength() {
-      try {
-        return contentLength != null ? Long.parseLong(contentLength) : -1;
-      } catch (NumberFormatException e) {
-        return -1;
-      }
-    }
-
-    @Override public BufferedSource source() {
-      return bodySource;
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/CacheControl.java b/okhttp/src/main/java/okhttp3/CacheControl.java
deleted file mode 100644
index 9a6ed966bc..0000000000
--- a/okhttp/src/main/java/okhttp3/CacheControl.java
+++ /dev/null
@@ -1,388 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.util.concurrent.TimeUnit;
-import javax.annotation.Nullable;
-import okhttp3.internal.http.HttpHeaders;
-
-/**
- * A Cache-Control header with cache directives from a server or client. These directives set policy
- * on what responses can be stored, and which requests can be satisfied by those stored responses.
- *
- * <p>See <a href="https://tools.ietf.org/html/rfc7234#section-5.2">RFC 7234, 5.2</a>.
- */
-public final class CacheControl {
-  /**
-   * Cache control request directives that require network validation of responses. Note that such
-   * requests may be assisted by the cache via conditional GET requests.
-   */
-  public static final CacheControl FORCE_NETWORK = new Builder().noCache().build();
-
-  /**
-   * Cache control request directives that uses the cache only, even if the cached response is
-   * stale. If the response isn't available in the cache or requires server validation, the call
-   * will fail with a {@code 504 Unsatisfiable Request}.
-   */
-  public static final CacheControl FORCE_CACHE = new Builder()
-      .onlyIfCached()
-      .maxStale(Integer.MAX_VALUE, TimeUnit.SECONDS)
-      .build();
-
-  private final boolean noCache;
-  private final boolean noStore;
-  private final int maxAgeSeconds;
-  private final int sMaxAgeSeconds;
-  private final boolean isPrivate;
-  private final boolean isPublic;
-  private final boolean mustRevalidate;
-  private final int maxStaleSeconds;
-  private final int minFreshSeconds;
-  private final boolean onlyIfCached;
-  private final boolean noTransform;
-  private final boolean immutable;
-
-  @Nullable String headerValue; // Lazily computed, null if absent.
-
-  private CacheControl(boolean noCache, boolean noStore, int maxAgeSeconds, int sMaxAgeSeconds,
-      boolean isPrivate, boolean isPublic, boolean mustRevalidate, int maxStaleSeconds,
-      int minFreshSeconds, boolean onlyIfCached, boolean noTransform, boolean immutable,
-      @Nullable String headerValue) {
-    this.noCache = noCache;
-    this.noStore = noStore;
-    this.maxAgeSeconds = maxAgeSeconds;
-    this.sMaxAgeSeconds = sMaxAgeSeconds;
-    this.isPrivate = isPrivate;
-    this.isPublic = isPublic;
-    this.mustRevalidate = mustRevalidate;
-    this.maxStaleSeconds = maxStaleSeconds;
-    this.minFreshSeconds = minFreshSeconds;
-    this.onlyIfCached = onlyIfCached;
-    this.noTransform = noTransform;
-    this.immutable = immutable;
-    this.headerValue = headerValue;
-  }
-
-  CacheControl(Builder builder) {
-    this.noCache = builder.noCache;
-    this.noStore = builder.noStore;
-    this.maxAgeSeconds = builder.maxAgeSeconds;
-    this.sMaxAgeSeconds = -1;
-    this.isPrivate = false;
-    this.isPublic = false;
-    this.mustRevalidate = false;
-    this.maxStaleSeconds = builder.maxStaleSeconds;
-    this.minFreshSeconds = builder.minFreshSeconds;
-    this.onlyIfCached = builder.onlyIfCached;
-    this.noTransform = builder.noTransform;
-    this.immutable = builder.immutable;
-  }
-
-  /**
-   * In a response, this field's name "no-cache" is misleading. It doesn't prevent us from caching
-   * the response; it only means we have to validate the response with the origin server before
-   * returning it. We can do this with a conditional GET.
-   *
-   * <p>In a request, it means do not use a cache to satisfy the request.
-   */
-  public boolean noCache() {
-    return noCache;
-  }
-
-  /** If true, this response should not be cached. */
-  public boolean noStore() {
-    return noStore;
-  }
-
-  /**
-   * The duration past the response's served date that it can be served without validation.
-   */
-  public int maxAgeSeconds() {
-    return maxAgeSeconds;
-  }
-
-  /**
-   * The "s-maxage" directive is the max age for shared caches. Not to be confused with "max-age"
-   * for non-shared caches, As in Firefox and Chrome, this directive is not honored by this cache.
-   */
-  public int sMaxAgeSeconds() {
-    return sMaxAgeSeconds;
-  }
-
-  public boolean isPrivate() {
-    return isPrivate;
-  }
-
-  public boolean isPublic() {
-    return isPublic;
-  }
-
-  public boolean mustRevalidate() {
-    return mustRevalidate;
-  }
-
-  public int maxStaleSeconds() {
-    return maxStaleSeconds;
-  }
-
-  public int minFreshSeconds() {
-    return minFreshSeconds;
-  }
-
-  /**
-   * This field's name "only-if-cached" is misleading. It actually means "do not use the network".
-   * It is set by a client who only wants to make a request if it can be fully satisfied by the
-   * cache. Cached responses that would require validation (ie. conditional gets) are not permitted
-   * if this header is set.
-   */
-  public boolean onlyIfCached() {
-    return onlyIfCached;
-  }
-
-  public boolean noTransform() {
-    return noTransform;
-  }
-
-  public boolean immutable() {
-    return immutable;
-  }
-
-  /**
-   * Returns the cache directives of {@code headers}. This honors both Cache-Control and Pragma
-   * headers if they are present.
-   */
-  public static CacheControl parse(Headers headers) {
-    boolean noCache = false;
-    boolean noStore = false;
-    int maxAgeSeconds = -1;
-    int sMaxAgeSeconds = -1;
-    boolean isPrivate = false;
-    boolean isPublic = false;
-    boolean mustRevalidate = false;
-    int maxStaleSeconds = -1;
-    int minFreshSeconds = -1;
-    boolean onlyIfCached = false;
-    boolean noTransform = false;
-    boolean immutable = false;
-
-    boolean canUseHeaderValue = true;
-    String headerValue = null;
-
-    for (int i = 0, size = headers.size(); i < size; i++) {
-      String name = headers.name(i);
-      String value = headers.value(i);
-
-      if (name.equalsIgnoreCase("Cache-Control")) {
-        if (headerValue != null) {
-          // Multiple cache-control headers means we can't use the raw value.
-          canUseHeaderValue = false;
-        } else {
-          headerValue = value;
-        }
-      } else if (name.equalsIgnoreCase("Pragma")) {
-        // Might specify additional cache-control params. We invalidate just in case.
-        canUseHeaderValue = false;
-      } else {
-        continue;
-      }
-
-      int pos = 0;
-      while (pos < value.length()) {
-        int tokenStart = pos;
-        pos = HttpHeaders.skipUntil(value, pos, "=,;");
-        String directive = value.substring(tokenStart, pos).trim();
-        String parameter;
-
-        if (pos == value.length() || value.charAt(pos) == ',' || value.charAt(pos) == ';') {
-          pos++; // consume ',' or ';' (if necessary)
-          parameter = null;
-        } else {
-          pos++; // consume '='
-          pos = HttpHeaders.skipWhitespace(value, pos);
-
-          // quoted string
-          if (pos < value.length() && value.charAt(pos) == '\"') {
-            pos++; // consume '"' open quote
-            int parameterStart = pos;
-            pos = HttpHeaders.skipUntil(value, pos, "\"");
-            parameter = value.substring(parameterStart, pos);
-            pos++; // consume '"' close quote (if necessary)
-
-            // unquoted string
-          } else {
-            int parameterStart = pos;
-            pos = HttpHeaders.skipUntil(value, pos, ",;");
-            parameter = value.substring(parameterStart, pos).trim();
-          }
-        }
-
-        if ("no-cache".equalsIgnoreCase(directive)) {
-          noCache = true;
-        } else if ("no-store".equalsIgnoreCase(directive)) {
-          noStore = true;
-        } else if ("max-age".equalsIgnoreCase(directive)) {
-          maxAgeSeconds = HttpHeaders.parseSeconds(parameter, -1);
-        } else if ("s-maxage".equalsIgnoreCase(directive)) {
-          sMaxAgeSeconds = HttpHeaders.parseSeconds(parameter, -1);
-        } else if ("private".equalsIgnoreCase(directive)) {
-          isPrivate = true;
-        } else if ("public".equalsIgnoreCase(directive)) {
-          isPublic = true;
-        } else if ("must-revalidate".equalsIgnoreCase(directive)) {
-          mustRevalidate = true;
-        } else if ("max-stale".equalsIgnoreCase(directive)) {
-          maxStaleSeconds = HttpHeaders.parseSeconds(parameter, Integer.MAX_VALUE);
-        } else if ("min-fresh".equalsIgnoreCase(directive)) {
-          minFreshSeconds = HttpHeaders.parseSeconds(parameter, -1);
-        } else if ("only-if-cached".equalsIgnoreCase(directive)) {
-          onlyIfCached = true;
-        } else if ("no-transform".equalsIgnoreCase(directive)) {
-          noTransform = true;
-        } else if ("immutable".equalsIgnoreCase(directive)) {
-          immutable = true;
-        }
-      }
-    }
-
-    if (!canUseHeaderValue) {
-      headerValue = null;
-    }
-    return new CacheControl(noCache, noStore, maxAgeSeconds, sMaxAgeSeconds, isPrivate, isPublic,
-        mustRevalidate, maxStaleSeconds, minFreshSeconds, onlyIfCached, noTransform, immutable,
-        headerValue);
-  }
-
-  @Override public String toString() {
-    String result = headerValue;
-    return result != null ? result : (headerValue = headerValue());
-  }
-
-  private String headerValue() {
-    StringBuilder result = new StringBuilder();
-    if (noCache) result.append("no-cache, ");
-    if (noStore) result.append("no-store, ");
-    if (maxAgeSeconds != -1) result.append("max-age=").append(maxAgeSeconds).append(", ");
-    if (sMaxAgeSeconds != -1) result.append("s-maxage=").append(sMaxAgeSeconds).append(", ");
-    if (isPrivate) result.append("private, ");
-    if (isPublic) result.append("public, ");
-    if (mustRevalidate) result.append("must-revalidate, ");
-    if (maxStaleSeconds != -1) result.append("max-stale=").append(maxStaleSeconds).append(", ");
-    if (minFreshSeconds != -1) result.append("min-fresh=").append(minFreshSeconds).append(", ");
-    if (onlyIfCached) result.append("only-if-cached, ");
-    if (noTransform) result.append("no-transform, ");
-    if (immutable) result.append("immutable, ");
-    if (result.length() == 0) return "";
-    result.delete(result.length() - 2, result.length());
-    return result.toString();
-  }
-
-  /** Builds a {@code Cache-Control} request header. */
-  public static final class Builder {
-    boolean noCache;
-    boolean noStore;
-    int maxAgeSeconds = -1;
-    int maxStaleSeconds = -1;
-    int minFreshSeconds = -1;
-    boolean onlyIfCached;
-    boolean noTransform;
-    boolean immutable;
-
-    /** Don't accept an unvalidated cached response. */
-    public Builder noCache() {
-      this.noCache = true;
-      return this;
-    }
-
-    /** Don't store the server's response in any cache. */
-    public Builder noStore() {
-      this.noStore = true;
-      return this;
-    }
-
-    /**
-     * Sets the maximum age of a cached response. If the cache response's age exceeds {@code
-     * maxAge}, it will not be used and a network request will be made.
-     *
-     * @param maxAge a non-negative integer. This is stored and transmitted with {@link
-     * TimeUnit#SECONDS} precision; finer precision will be lost.
-     */
-    public Builder maxAge(int maxAge, TimeUnit timeUnit) {
-      if (maxAge < 0) throw new IllegalArgumentException("maxAge < 0: " + maxAge);
-      long maxAgeSecondsLong = timeUnit.toSeconds(maxAge);
-      this.maxAgeSeconds = maxAgeSecondsLong > Integer.MAX_VALUE
-          ? Integer.MAX_VALUE
-          : (int) maxAgeSecondsLong;
-      return this;
-    }
-
-    /**
-     * Accept cached responses that have exceeded their freshness lifetime by up to {@code
-     * maxStale}. If unspecified, stale cache responses will not be used.
-     *
-     * @param maxStale a non-negative integer. This is stored and transmitted with {@link
-     * TimeUnit#SECONDS} precision; finer precision will be lost.
-     */
-    public Builder maxStale(int maxStale, TimeUnit timeUnit) {
-      if (maxStale < 0) throw new IllegalArgumentException("maxStale < 0: " + maxStale);
-      long maxStaleSecondsLong = timeUnit.toSeconds(maxStale);
-      this.maxStaleSeconds = maxStaleSecondsLong > Integer.MAX_VALUE
-          ? Integer.MAX_VALUE
-          : (int) maxStaleSecondsLong;
-      return this;
-    }
-
-    /**
-     * Sets the minimum number of seconds that a response will continue to be fresh for. If the
-     * response will be stale when {@code minFresh} have elapsed, the cached response will not be
-     * used and a network request will be made.
-     *
-     * @param minFresh a non-negative integer. This is stored and transmitted with {@link
-     * TimeUnit#SECONDS} precision; finer precision will be lost.
-     */
-    public Builder minFresh(int minFresh, TimeUnit timeUnit) {
-      if (minFresh < 0) throw new IllegalArgumentException("minFresh < 0: " + minFresh);
-      long minFreshSecondsLong = timeUnit.toSeconds(minFresh);
-      this.minFreshSeconds = minFreshSecondsLong > Integer.MAX_VALUE
-          ? Integer.MAX_VALUE
-          : (int) minFreshSecondsLong;
-      return this;
-    }
-
-    /**
-     * Only accept the response if it is in the cache. If the response isn't cached, a {@code 504
-     * Unsatisfiable Request} response will be returned.
-     */
-    public Builder onlyIfCached() {
-      this.onlyIfCached = true;
-      return this;
-    }
-
-    /** Don't accept a transformed response. */
-    public Builder noTransform() {
-      this.noTransform = true;
-      return this;
-    }
-
-    public Builder immutable() {
-      this.immutable = true;
-      return this;
-    }
-
-    public CacheControl build() {
-      return new CacheControl(this);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Call.java b/okhttp/src/main/java/okhttp3/Call.java
deleted file mode 100644
index 67d0f88d3d..0000000000
--- a/okhttp/src/main/java/okhttp3/Call.java
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import okio.Timeout;
-
-/**
- * A call is a request that has been prepared for execution. A call can be canceled. As this object
- * represents a single request/response pair (stream), it cannot be executed twice.
- */
-public interface Call extends Cloneable {
-  /** Returns the original request that initiated this call. */
-  Request request();
-
-  /**
-   * Invokes the request immediately, and blocks until the response can be processed or is in
-   * error.
-   *
-   * <p>To avoid leaking resources callers should close the {@link Response} which in turn will
-   * close the underlying {@link ResponseBody}.
-   *
-   * <pre>{@code
-   *
-   *   // ensure the response (and underlying response body) is closed
-   *   try (Response response = client.newCall(request).execute()) {
-   *     ...
-   *   }
-   *
-   * }</pre>
-   *
-   * <p>The caller may read the response body with the response's {@link Response#body} method. To
-   * avoid leaking resources callers must {@linkplain ResponseBody close the response body} or the
-   * Response.
-   *
-   * <p>Note that transport-layer success (receiving a HTTP response code, headers and body) does
-   * not necessarily indicate application-layer success: {@code response} may still indicate an
-   * unhappy HTTP response code like 404 or 500.
-   *
-   * @throws IOException if the request could not be executed due to cancellation, a connectivity
-   * problem or timeout. Because networks can fail during an exchange, it is possible that the
-   * remote server accepted the request before the failure.
-   * @throws IllegalStateException when the call has already been executed.
-   */
-  Response execute() throws IOException;
-
-  /**
-   * Schedules the request to be executed at some point in the future.
-   *
-   * <p>The {@link OkHttpClient#dispatcher dispatcher} defines when the request will run: usually
-   * immediately unless there are several other requests currently being executed.
-   *
-   * <p>This client will later call back {@code responseCallback} with either an HTTP response or a
-   * failure exception.
-   *
-   * @throws IllegalStateException when the call has already been executed.
-   */
-  void enqueue(Callback responseCallback);
-
-  /** Cancels the request, if possible. Requests that are already complete cannot be canceled. */
-  void cancel();
-
-  /**
-   * Returns true if this call has been either {@linkplain #execute() executed} or {@linkplain
-   * #enqueue(Callback) enqueued}. It is an error to execute a call more than once.
-   */
-  boolean isExecuted();
-
-  boolean isCanceled();
-
-  /**
-   * Returns a timeout that spans the entire call: resolving DNS, connecting, writing the request
-   * body, server processing, and reading the response body. If the call requires redirects or
-   * retries all must complete within one timeout period.
-   *
-   * <p>Configure the client's default timeout with {@link OkHttpClient.Builder#callTimeout}.
-   */
-  Timeout timeout();
-
-  /**
-   * Create a new, identical call to this one which can be enqueued or executed even if this call
-   * has already been.
-   */
-  Call clone();
-
-  interface Factory {
-    Call newCall(Request request);
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Callback.java b/okhttp/src/main/java/okhttp3/Callback.java
deleted file mode 100644
index 3b7ed85bf4..0000000000
--- a/okhttp/src/main/java/okhttp3/Callback.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-
-public interface Callback {
-  /**
-   * Called when the request could not be executed due to cancellation, a connectivity problem or
-   * timeout. Because networks can fail during an exchange, it is possible that the remote server
-   * accepted the request before the failure.
-   */
-  void onFailure(Call call, IOException e);
-
-  /**
-   * Called when the HTTP response was successfully returned by the remote server. The callback may
-   * proceed to read the response body with {@link Response#body}. The response is still live until
-   * its response body is {@linkplain ResponseBody closed}. The recipient of the callback may
-   * consume the response body on another thread.
-   *
-   * <p>Note that transport-layer success (receiving a HTTP response code, headers and body) does
-   * not necessarily indicate application-layer success: {@code response} may still indicate an
-   * unhappy HTTP response code like 404 or 500.
-   */
-  void onResponse(Call call, Response response) throws IOException;
-}
diff --git a/okhttp/src/main/java/okhttp3/CertificatePinner.java b/okhttp/src/main/java/okhttp3/CertificatePinner.java
deleted file mode 100644
index 474c245ae6..0000000000
--- a/okhttp/src/main/java/okhttp3/CertificatePinner.java
+++ /dev/null
@@ -1,344 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.security.cert.Certificate;
-import java.security.cert.X509Certificate;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Objects;
-import java.util.Set;
-import javax.annotation.Nullable;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import okhttp3.internal.tls.CertificateChainCleaner;
-import okio.ByteString;
-
-/**
- * Constrains which certificates are trusted. Pinning certificates defends against attacks on
- * certificate authorities. It also prevents connections through man-in-the-middle certificate
- * authorities either known or unknown to the application's user.
- *
- * <p>This class currently pins a certificate's Subject Public Key Info as described on <a
- * href="http://goo.gl/AIx3e5">Adam Langley's Weblog</a>. Pins are either base64 SHA-256 hashes as
- * in <a href="http://tools.ietf.org/html/rfc7469">HTTP Public Key Pinning (HPKP)</a> or SHA-1
- * base64 hashes as in Chromium's <a href="http://goo.gl/XDh6je">static certificates</a>.
- *
- * <h3>Setting up Certificate Pinning</h3>
- *
- * <p>The easiest way to pin a host is turn on pinning with a broken configuration and read the
- * expected configuration when the connection fails. Be sure to do this on a trusted network, and
- * without man-in-the-middle tools like <a href="http://charlesproxy.com">Charles</a> or <a
- * href="http://fiddlertool.com">Fiddler</a>.
- *
- * <p>For example, to pin {@code https://publicobject.com}, start with a broken
- * configuration: <pre>   {@code
- *
- *     String hostname = "publicobject.com";
- *     CertificatePinner certificatePinner = new CertificatePinner.Builder()
- *         .add(hostname, "sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=")
- *         .build();
- *     OkHttpClient client = OkHttpClient.Builder()
- *         .certificatePinner(certificatePinner)
- *         .build();
- *
- *     Request request = new Request.Builder()
- *         .url("https://" + hostname)
- *         .build();
- *     client.newCall(request).execute();
- * }</pre>
- *
- * As expected, this fails with a certificate pinning exception: <pre>   {@code
- *
- * javax.net.ssl.SSLPeerUnverifiedException: Certificate pinning failure!
- *   Peer certificate chain:
- *     sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=: CN=publicobject.com, OU=PositiveSSL
- *     sha256/klO23nT2ehFDXCfx3eHTDRESMz3asj1muO+4aIdjiuY=: CN=COMODO RSA Secure Server CA
- *     sha256/grX4Ta9HpZx6tSHkmCrvpApTQGo67CYDnvprLg5yRME=: CN=COMODO RSA Certification Authority
- *     sha256/lCppFqbkrlJ3EcVFAkeip0+44VaoJUymbnOaEUk7tEU=: CN=AddTrust External CA Root
- *   Pinned certificates for publicobject.com:
- *     sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=
- *   at okhttp3.CertificatePinner.check(CertificatePinner.java)
- *   at okhttp3.Connection.upgradeToTls(Connection.java)
- *   at okhttp3.Connection.connect(Connection.java)
- *   at okhttp3.Connection.connectAndSetOwner(Connection.java)
- * }</pre>
- *
- * Follow up by pasting the public key hashes from the exception into the
- * certificate pinner's configuration: <pre>   {@code
- *
- *     CertificatePinner certificatePinner = new CertificatePinner.Builder()
- *       .add("publicobject.com", "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
- *       .add("publicobject.com", "sha256/klO23nT2ehFDXCfx3eHTDRESMz3asj1muO+4aIdjiuY=")
- *       .add("publicobject.com", "sha256/grX4Ta9HpZx6tSHkmCrvpApTQGo67CYDnvprLg5yRME=")
- *       .add("publicobject.com", "sha256/lCppFqbkrlJ3EcVFAkeip0+44VaoJUymbnOaEUk7tEU=")
- *       .build();
- * }</pre>
- *
- * Pinning is per-hostname and/or per-wildcard pattern. To pin both {@code publicobject.com} and
- * {@code www.publicobject.com}, you must configure both hostnames.
- *
- * <p>Wildcard pattern rules:
- * <ol>
- *     <li>Asterisk {@code *} is only permitted in the left-most domain name label and must be the
- *         only character in that label (i.e., must match the whole left-most label). For example,
- *         {@code *.example.com} is permitted, while {@code *a.example.com}, {@code a*.example.com},
- *         {@code a*b.example.com}, {@code a.*.example.com} are not permitted.
- *     <li>Asterisk {@code *} cannot match across domain name labels. For example,
- *         {@code *.example.com} matches {@code test.example.com} but does not match
- *         {@code sub.test.example.com}.
- *     <li>Wildcard patterns for single-label domain names are not permitted.
- * </ol>
- *
- * If hostname pinned directly and via wildcard pattern, both direct and wildcard pins will be used.
- * For example: {@code *.example.com} pinned with {@code pin1} and {@code a.example.com} pinned with
- * {@code pin2}, to check {@code a.example.com} both {@code pin1} and {@code pin2} will be used.
- *
- * <h3>Warning: Certificate Pinning is Dangerous!</h3>
- *
- * <p>Pinning certificates limits your server team's abilities to update their TLS certificates. By
- * pinning certificates, you take on additional operational complexity and limit your ability to
- * migrate between certificate authorities. Do not use certificate pinning without the blessing of
- * your server's TLS administrator!
- *
- * <h4>Note about self-signed certificates</h4>
- *
- * <p>{@link CertificatePinner} can not be used to pin self-signed certificate if such certificate
- * is not accepted by {@link javax.net.ssl.TrustManager}.
- *
- * @see <a href="https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning"> OWASP:
- * Certificate and Public Key Pinning</a>
- */
-public final class CertificatePinner {
-  public static final CertificatePinner DEFAULT = new Builder().build();
-
-  private final Set<Pin> pins;
-  private final @Nullable CertificateChainCleaner certificateChainCleaner;
-
-  CertificatePinner(Set<Pin> pins, @Nullable CertificateChainCleaner certificateChainCleaner) {
-    this.pins = pins;
-    this.certificateChainCleaner = certificateChainCleaner;
-  }
-
-  @Override public boolean equals(@Nullable Object other) {
-    if (other == this) return true;
-    return other instanceof CertificatePinner
-        && (Objects.equals(certificateChainCleaner,
-        ((CertificatePinner) other).certificateChainCleaner)
-        && pins.equals(((CertificatePinner) other).pins));
-  }
-
-  @Override public int hashCode() {
-    int result = Objects.hashCode(certificateChainCleaner);
-    result = 31 * result + pins.hashCode();
-    return result;
-  }
-
-  /**
-   * Confirms that at least one of the certificates pinned for {@code hostname} is in {@code
-   * peerCertificates}. Does nothing if there are no certificates pinned for {@code hostname}.
-   * OkHttp calls this after a successful TLS handshake, but before the connection is used.
-   *
-   * @throws SSLPeerUnverifiedException if {@code peerCertificates} don't match the certificates
-   * pinned for {@code hostname}.
-   */
-  public void check(String hostname, List<Certificate> peerCertificates)
-      throws SSLPeerUnverifiedException {
-    List<Pin> pins = findMatchingPins(hostname);
-    if (pins.isEmpty()) return;
-
-    if (certificateChainCleaner != null) {
-      peerCertificates = certificateChainCleaner.clean(peerCertificates, hostname);
-    }
-
-    for (int c = 0, certsSize = peerCertificates.size(); c < certsSize; c++) {
-      X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(c);
-
-      // Lazily compute the hashes for each certificate.
-      ByteString sha1 = null;
-      ByteString sha256 = null;
-
-      for (int p = 0, pinsSize = pins.size(); p < pinsSize; p++) {
-        Pin pin = pins.get(p);
-        if (pin.hashAlgorithm.equals("sha256/")) {
-          if (sha256 == null) sha256 = sha256(x509Certificate);
-          if (pin.hash.equals(sha256)) return; // Success!
-        } else if (pin.hashAlgorithm.equals("sha1/")) {
-          if (sha1 == null) sha1 = sha1(x509Certificate);
-          if (pin.hash.equals(sha1)) return; // Success!
-        } else {
-          throw new AssertionError("unsupported hashAlgorithm: " + pin.hashAlgorithm);
-        }
-      }
-    }
-
-    // If we couldn't find a matching pin, format a nice exception.
-    StringBuilder message = new StringBuilder()
-        .append("Certificate pinning failure!")
-        .append("\n  Peer certificate chain:");
-    for (int c = 0, certsSize = peerCertificates.size(); c < certsSize; c++) {
-      X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(c);
-      message.append("\n    ").append(pin(x509Certificate))
-          .append(": ").append(x509Certificate.getSubjectDN().getName());
-    }
-    message.append("\n  Pinned certificates for ").append(hostname).append(":");
-    for (int p = 0, pinsSize = pins.size(); p < pinsSize; p++) {
-      Pin pin = pins.get(p);
-      message.append("\n    ").append(pin);
-    }
-    throw new SSLPeerUnverifiedException(message.toString());
-  }
-
-  /** @deprecated replaced with {@link #check(String, List)}. */
-  public void check(String hostname, Certificate... peerCertificates)
-      throws SSLPeerUnverifiedException {
-    check(hostname, Arrays.asList(peerCertificates));
-  }
-
-  /**
-   * Returns list of matching certificates' pins for the hostname. Returns an empty list if the
-   * hostname does not have pinned certificates.
-   */
-  List<Pin> findMatchingPins(String hostname) {
-    List<Pin> result = Collections.emptyList();
-    for (Pin pin : pins) {
-      if (pin.matches(hostname)) {
-        if (result.isEmpty()) result = new ArrayList<>();
-        result.add(pin);
-      }
-    }
-    return result;
-  }
-
-  /** Returns a certificate pinner that uses {@code certificateChainCleaner}. */
-  CertificatePinner withCertificateChainCleaner(
-      @Nullable CertificateChainCleaner certificateChainCleaner) {
-    return Objects.equals(this.certificateChainCleaner, certificateChainCleaner)
-        ? this
-        : new CertificatePinner(pins, certificateChainCleaner);
-  }
-
-  /**
-   * Returns the SHA-256 of {@code certificate}'s public key.
-   *
-   * <p>In OkHttp 3.1.2 and earlier, this returned a SHA-1 hash of the public key. Both types are
-   * supported, but SHA-256 is preferred.
-   */
-  public static String pin(Certificate certificate) {
-    if (!(certificate instanceof X509Certificate)) {
-      throw new IllegalArgumentException("Certificate pinning requires X509 certificates");
-    }
-    return "sha256/" + sha256((X509Certificate) certificate).base64();
-  }
-
-  static ByteString sha1(X509Certificate x509Certificate) {
-    return ByteString.of(x509Certificate.getPublicKey().getEncoded()).sha1();
-  }
-
-  static ByteString sha256(X509Certificate x509Certificate) {
-    return ByteString.of(x509Certificate.getPublicKey().getEncoded()).sha256();
-  }
-
-  static final class Pin {
-    private static final String WILDCARD = "*.";
-    /** A hostname like {@code example.com} or a pattern like {@code *.example.com}. */
-    final String pattern;
-    /** The canonical hostname, i.e. {@code EXAMPLE.com} becomes {@code example.com}. */
-    final String canonicalHostname;
-    /** Either {@code sha1/} or {@code sha256/}. */
-    final String hashAlgorithm;
-    /** The hash of the pinned certificate using {@link #hashAlgorithm}. */
-    final ByteString hash;
-
-    Pin(String pattern, String pin) {
-      this.pattern = pattern;
-      this.canonicalHostname = pattern.startsWith(WILDCARD)
-          ? HttpUrl.get("http://" + pattern.substring(WILDCARD.length())).host()
-          : HttpUrl.get("http://" + pattern).host();
-      if (pin.startsWith("sha1/")) {
-        this.hashAlgorithm = "sha1/";
-        this.hash = ByteString.decodeBase64(pin.substring("sha1/".length()));
-      } else if (pin.startsWith("sha256/")) {
-        this.hashAlgorithm = "sha256/";
-        this.hash = ByteString.decodeBase64(pin.substring("sha256/".length()));
-      } else {
-        throw new IllegalArgumentException("pins must start with 'sha256/' or 'sha1/': " + pin);
-      }
-
-      if (this.hash == null) {
-        throw new IllegalArgumentException("pins must be base64: " + pin);
-      }
-    }
-
-    boolean matches(String hostname) {
-      if (pattern.startsWith(WILDCARD)) {
-        int firstDot = hostname.indexOf('.');
-        return (hostname.length() - firstDot - 1) == canonicalHostname.length()
-            && hostname.regionMatches(false, firstDot + 1, canonicalHostname, 0,
-            canonicalHostname.length());
-      }
-
-      return hostname.equals(canonicalHostname);
-    }
-
-    @Override public boolean equals(Object other) {
-      return other instanceof Pin
-          && pattern.equals(((Pin) other).pattern)
-          && hashAlgorithm.equals(((Pin) other).hashAlgorithm)
-          && hash.equals(((Pin) other).hash);
-    }
-
-    @Override public int hashCode() {
-      int result = 17;
-      result = 31 * result + pattern.hashCode();
-      result = 31 * result + hashAlgorithm.hashCode();
-      result = 31 * result + hash.hashCode();
-      return result;
-    }
-
-    @Override public String toString() {
-      return hashAlgorithm + hash.base64();
-    }
-  }
-
-  /** Builds a configured certificate pinner. */
-  public static final class Builder {
-    private final List<Pin> pins = new ArrayList<>();
-
-    /**
-     * Pins certificates for {@code pattern}.
-     *
-     * @param pattern lower-case host name or wildcard pattern such as {@code *.example.com}.
-     * @param pins SHA-256 or SHA-1 hashes. Each pin is a hash of a certificate's Subject Public Key
-     * Info, base64-encoded and prefixed with either {@code sha256/} or {@code sha1/}.
-     */
-    public Builder add(String pattern, String... pins) {
-      if (pattern == null) throw new NullPointerException("pattern == null");
-
-      for (String pin : pins) {
-        this.pins.add(new Pin(pattern, pin));
-      }
-
-      return this;
-    }
-
-    public CertificatePinner build() {
-      return new CertificatePinner(new LinkedHashSet<>(pins), null);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Challenge.java b/okhttp/src/main/java/okhttp3/Challenge.java
deleted file mode 100644
index 0fb4c868a6..0000000000
--- a/okhttp/src/main/java/okhttp3/Challenge.java
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.nio.charset.Charset;
-import java.util.LinkedHashMap;
-import java.util.Map;
-import java.util.Map.Entry;
-import javax.annotation.Nullable;
-
-import static java.nio.charset.StandardCharsets.ISO_8859_1;
-import static java.util.Collections.singletonMap;
-import static java.util.Collections.unmodifiableMap;
-import static java.util.Locale.US;
-
-/** An RFC 7235 challenge. */
-public final class Challenge {
-  private final String scheme;
-  private final Map<String, String> authParams;
-
-  public Challenge(String scheme, Map<String, String> authParams) {
-    if (scheme == null) throw new NullPointerException("scheme == null");
-    if (authParams == null) throw new NullPointerException("authParams == null");
-    this.scheme = scheme;
-    Map<String, String> newAuthParams = new LinkedHashMap<>();
-    for (Entry<String, String> authParam : authParams.entrySet()) {
-      String key = (authParam.getKey() == null) ? null : authParam.getKey().toLowerCase(US);
-      newAuthParams.put(key, authParam.getValue());
-    }
-    this.authParams = unmodifiableMap(newAuthParams);
-  }
-
-  public Challenge(String scheme, String realm) {
-    if (scheme == null) throw new NullPointerException("scheme == null");
-    if (realm == null) throw new NullPointerException("realm == null");
-    this.scheme = scheme;
-    this.authParams = singletonMap("realm", realm);
-  }
-
-  /** Returns a copy of this charset that expects a credential encoded with {@code charset}. */
-  public Challenge withCharset(Charset charset) {
-    if (charset == null) throw new NullPointerException("charset == null");
-    Map<String, String> authParams = new LinkedHashMap<>(this.authParams);
-    authParams.put("charset", charset.name());
-    return new Challenge(scheme, authParams);
-  }
-
-  /** Returns the authentication scheme, like {@code Basic}. */
-  public String scheme() {
-    return scheme;
-  }
-
-  /**
-   * Returns the auth params, including {@code realm} and {@code charset} if present, but as
-   * strings. The map's keys are lowercase and should be treated case-insensitively.
-   */
-  public Map<String, String> authParams() {
-    return authParams;
-  }
-
-  /** Returns the protection space. */
-  public String realm() {
-    return authParams.get("realm");
-  }
-
-  /** Returns the charset that should be used to encode the credentials. */
-  public Charset charset() {
-    String charset = authParams.get("charset");
-    if (charset != null) {
-      try {
-        return Charset.forName(charset);
-      } catch (Exception ignore) {
-      }
-    }
-    return ISO_8859_1;
-  }
-
-  @Override public boolean equals(@Nullable Object other) {
-    return other instanceof Challenge
-        && ((Challenge) other).scheme.equals(scheme)
-        && ((Challenge) other).authParams.equals(authParams);
-  }
-
-  @Override public int hashCode() {
-    int result = 29;
-    result = 31 * result + scheme.hashCode();
-    result = 31 * result + authParams.hashCode();
-    return result;
-  }
-
-  @Override public String toString() {
-    return scheme + " authParams=" + authParams;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/CipherSuite.java b/okhttp/src/main/java/okhttp3/CipherSuite.java
deleted file mode 100644
index 0843411893..0000000000
--- a/okhttp/src/main/java/okhttp3/CipherSuite.java
+++ /dev/null
@@ -1,473 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-
-/**
- * <a href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml">TLS cipher
- * suites</a>.
- *
- * <p><strong>Not all cipher suites are supported on all platforms.</strong> As newer cipher suites
- * are created (for stronger privacy, better performance, etc.) they will be adopted by the platform
- * and then exposed here. Cipher suites that are not available on either Android (through API level
- * 24) or Java (through JDK 9) are omitted for brevity.
- *
- * <p>See <a href="https://developer.android.com/reference/javax/net/ssl/SSLEngine.html">Android SSLEngine</a>
- * which lists the cipher suites supported by Android.
- *
- * <p>See <a href="https://docs.oracle.com/javase/10/security/oracle-providers.htm">JDK 10 Providers</a>
- * which lists the cipher suites supported by Oracle.
- *
- * <p>See <a href="https://github.com/google/conscrypt/blob/master/common/src/main/java/org/conscrypt/NativeCrypto.java">NativeCrypto.java</a>
- * from conscrypt, which lists the cipher suites supported by Conscrypt.
- */
-public final class CipherSuite {
-  /**
-   * Compares cipher suites names like "TLS_RSA_WITH_NULL_MD5" and "SSL_RSA_WITH_NULL_MD5", ignoring
-   * the "TLS_" or "SSL_" prefix which is not consistent across platforms. In particular some IBM
-   * JVMs use the "SSL_" prefix everywhere whereas Oracle JVMs mix "TLS_" and "SSL_".
-   */
-  static final Comparator<String> ORDER_BY_NAME = (a, b) -> {
-    for (int i = 4, limit = Math.min(a.length(), b.length()); i < limit; i++) {
-      char charA = a.charAt(i);
-      char charB = b.charAt(i);
-      if (charA != charB) return charA < charB ? -1 : 1;
-    }
-    int lengthA = a.length();
-    int lengthB = b.length();
-    if (lengthA != lengthB) return lengthA < lengthB ? -1 : 1;
-    return 0;
-  };
-
-  /**
-   * Holds interned instances. This needs to be above the init() calls below so that it's
-   * initialized by the time those parts of {@code <clinit>()} run. Guarded by CipherSuite.class.
-   */
-  private static final Map<String, CipherSuite> INSTANCES = new LinkedHashMap<>();
-
-  // Last updated 2016-07-03 using cipher suites from Android 24 and Java 9.
-
-  // public static final CipherSuite TLS_NULL_WITH_NULL_NULL = init("TLS_NULL_WITH_NULL_NULL", 0x0000);
-  public static final CipherSuite TLS_RSA_WITH_NULL_MD5 = init("SSL_RSA_WITH_NULL_MD5", 0x0001);
-  public static final CipherSuite TLS_RSA_WITH_NULL_SHA = init("SSL_RSA_WITH_NULL_SHA", 0x0002);
-  public static final CipherSuite TLS_RSA_EXPORT_WITH_RC4_40_MD5 = init("SSL_RSA_EXPORT_WITH_RC4_40_MD5", 0x0003);
-  public static final CipherSuite TLS_RSA_WITH_RC4_128_MD5 = init("SSL_RSA_WITH_RC4_128_MD5", 0x0004);
-  public static final CipherSuite TLS_RSA_WITH_RC4_128_SHA = init("SSL_RSA_WITH_RC4_128_SHA", 0x0005);
-  // public static final CipherSuite TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 = init("SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5", 0x0006);
-  // public static final CipherSuite TLS_RSA_WITH_IDEA_CBC_SHA = init("TLS_RSA_WITH_IDEA_CBC_SHA", 0x0007);
-  public static final CipherSuite TLS_RSA_EXPORT_WITH_DES40_CBC_SHA = init("SSL_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0008);
-  public static final CipherSuite TLS_RSA_WITH_DES_CBC_SHA = init("SSL_RSA_WITH_DES_CBC_SHA", 0x0009);
-  public static final CipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA = init("SSL_RSA_WITH_3DES_EDE_CBC_SHA", 0x000a);
-  // public static final CipherSuite TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA = init("SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x000b);
-  // public static final CipherSuite TLS_DH_DSS_WITH_DES_CBC_SHA = init("TLS_DH_DSS_WITH_DES_CBC_SHA", 0x000c);
-  // public static final CipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA = init("TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA", 0x000d);
-  // public static final CipherSuite TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA = init("SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x000e);
-  // public static final CipherSuite TLS_DH_RSA_WITH_DES_CBC_SHA = init("TLS_DH_RSA_WITH_DES_CBC_SHA", 0x000f);
-  // public static final CipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA = init("TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA", 0x0010);
-  public static final CipherSuite TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA = init("SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x0011);
-  public static final CipherSuite TLS_DHE_DSS_WITH_DES_CBC_SHA = init("SSL_DHE_DSS_WITH_DES_CBC_SHA", 0x0012);
-  public static final CipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA = init("SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA", 0x0013);
-  public static final CipherSuite TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA = init("SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0014);
-  public static final CipherSuite TLS_DHE_RSA_WITH_DES_CBC_SHA = init("SSL_DHE_RSA_WITH_DES_CBC_SHA", 0x0015);
-  public static final CipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA = init("SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA", 0x0016);
-  public static final CipherSuite TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 = init("SSL_DH_anon_EXPORT_WITH_RC4_40_MD5", 0x0017);
-  public static final CipherSuite TLS_DH_anon_WITH_RC4_128_MD5 = init("SSL_DH_anon_WITH_RC4_128_MD5", 0x0018);
-  public static final CipherSuite TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA = init("SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA", 0x0019);
-  public static final CipherSuite TLS_DH_anon_WITH_DES_CBC_SHA = init("SSL_DH_anon_WITH_DES_CBC_SHA", 0x001a);
-  public static final CipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA = init("SSL_DH_anon_WITH_3DES_EDE_CBC_SHA", 0x001b);
-  public static final CipherSuite TLS_KRB5_WITH_DES_CBC_SHA = init("TLS_KRB5_WITH_DES_CBC_SHA", 0x001e);
-  public static final CipherSuite TLS_KRB5_WITH_3DES_EDE_CBC_SHA = init("TLS_KRB5_WITH_3DES_EDE_CBC_SHA", 0x001f);
-  public static final CipherSuite TLS_KRB5_WITH_RC4_128_SHA = init("TLS_KRB5_WITH_RC4_128_SHA", 0x0020);
-  // public static final CipherSuite TLS_KRB5_WITH_IDEA_CBC_SHA = init("TLS_KRB5_WITH_IDEA_CBC_SHA", 0x0021);
-  public static final CipherSuite TLS_KRB5_WITH_DES_CBC_MD5 = init("TLS_KRB5_WITH_DES_CBC_MD5", 0x0022);
-  public static final CipherSuite TLS_KRB5_WITH_3DES_EDE_CBC_MD5 = init("TLS_KRB5_WITH_3DES_EDE_CBC_MD5", 0x0023);
-  public static final CipherSuite TLS_KRB5_WITH_RC4_128_MD5 = init("TLS_KRB5_WITH_RC4_128_MD5", 0x0024);
-  // public static final CipherSuite TLS_KRB5_WITH_IDEA_CBC_MD5 = init("TLS_KRB5_WITH_IDEA_CBC_MD5", 0x0025);
-  public static final CipherSuite TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA = init("TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA", 0x0026);
-  // public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA = init("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA", 0x0027);
-  public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC4_40_SHA = init("TLS_KRB5_EXPORT_WITH_RC4_40_SHA", 0x0028);
-  public static final CipherSuite TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5 = init("TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5", 0x0029);
-  // public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5 = init("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5", 0x002a);
-  public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC4_40_MD5 = init("TLS_KRB5_EXPORT_WITH_RC4_40_MD5", 0x002b);
-  // public static final CipherSuite TLS_PSK_WITH_NULL_SHA = init("TLS_PSK_WITH_NULL_SHA", 0x002c);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_NULL_SHA = init("TLS_DHE_PSK_WITH_NULL_SHA", 0x002d);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_NULL_SHA = init("TLS_RSA_PSK_WITH_NULL_SHA", 0x002e);
-  public static final CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA = init("TLS_RSA_WITH_AES_128_CBC_SHA", 0x002f);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA = init("TLS_DH_DSS_WITH_AES_128_CBC_SHA", 0x0030);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA = init("TLS_DH_RSA_WITH_AES_128_CBC_SHA", 0x0031);
-  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA = init("TLS_DHE_DSS_WITH_AES_128_CBC_SHA", 0x0032);
-  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA = init("TLS_DHE_RSA_WITH_AES_128_CBC_SHA", 0x0033);
-  public static final CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA = init("TLS_DH_anon_WITH_AES_128_CBC_SHA", 0x0034);
-  public static final CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA = init("TLS_RSA_WITH_AES_256_CBC_SHA", 0x0035);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA = init("TLS_DH_DSS_WITH_AES_256_CBC_SHA", 0x0036);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA = init("TLS_DH_RSA_WITH_AES_256_CBC_SHA", 0x0037);
-  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA = init("TLS_DHE_DSS_WITH_AES_256_CBC_SHA", 0x0038);
-  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA = init("TLS_DHE_RSA_WITH_AES_256_CBC_SHA", 0x0039);
-  public static final CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA = init("TLS_DH_anon_WITH_AES_256_CBC_SHA", 0x003a);
-  public static final CipherSuite TLS_RSA_WITH_NULL_SHA256 = init("TLS_RSA_WITH_NULL_SHA256", 0x003b);
-  public static final CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA256 = init("TLS_RSA_WITH_AES_128_CBC_SHA256", 0x003c);
-  public static final CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA256 = init("TLS_RSA_WITH_AES_256_CBC_SHA256", 0x003d);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA256 = init("TLS_DH_DSS_WITH_AES_128_CBC_SHA256", 0x003e);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA256 = init("TLS_DH_RSA_WITH_AES_128_CBC_SHA256", 0x003f);
-  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 = init("TLS_DHE_DSS_WITH_AES_128_CBC_SHA256", 0x0040);
-  public static final CipherSuite TLS_RSA_WITH_CAMELLIA_128_CBC_SHA = init("TLS_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0041);
-  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA = init("TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0042);
-  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA = init("TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0043);
-  public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA = init("TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0044);
-  public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA = init("TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0045);
-  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA = init("TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA", 0x0046);
-  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 = init("TLS_DHE_RSA_WITH_AES_128_CBC_SHA256", 0x0067);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA256 = init("TLS_DH_DSS_WITH_AES_256_CBC_SHA256", 0x0068);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA256 = init("TLS_DH_RSA_WITH_AES_256_CBC_SHA256", 0x0069);
-  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 = init("TLS_DHE_DSS_WITH_AES_256_CBC_SHA256", 0x006a);
-  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 = init("TLS_DHE_RSA_WITH_AES_256_CBC_SHA256", 0x006b);
-  public static final CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA256 = init("TLS_DH_anon_WITH_AES_128_CBC_SHA256", 0x006c);
-  public static final CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA256 = init("TLS_DH_anon_WITH_AES_256_CBC_SHA256", 0x006d);
-  public static final CipherSuite TLS_RSA_WITH_CAMELLIA_256_CBC_SHA = init("TLS_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0084);
-  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA = init("TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0085);
-  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA = init("TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0086);
-  public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA = init("TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0087);
-  public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA = init("TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0088);
-  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA = init("TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA", 0x0089);
-  public static final CipherSuite TLS_PSK_WITH_RC4_128_SHA = init("TLS_PSK_WITH_RC4_128_SHA", 0x008a);
-  public static final CipherSuite TLS_PSK_WITH_3DES_EDE_CBC_SHA = init("TLS_PSK_WITH_3DES_EDE_CBC_SHA", 0x008b);
-  public static final CipherSuite TLS_PSK_WITH_AES_128_CBC_SHA = init("TLS_PSK_WITH_AES_128_CBC_SHA", 0x008c);
-  public static final CipherSuite TLS_PSK_WITH_AES_256_CBC_SHA = init("TLS_PSK_WITH_AES_256_CBC_SHA", 0x008d);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_RC4_128_SHA = init("TLS_DHE_PSK_WITH_RC4_128_SHA", 0x008e);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA = init("TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA", 0x008f);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_CBC_SHA = init("TLS_DHE_PSK_WITH_AES_128_CBC_SHA", 0x0090);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_CBC_SHA = init("TLS_DHE_PSK_WITH_AES_256_CBC_SHA", 0x0091);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_RC4_128_SHA = init("TLS_RSA_PSK_WITH_RC4_128_SHA", 0x0092);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA = init("TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA", 0x0093);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_128_CBC_SHA = init("TLS_RSA_PSK_WITH_AES_128_CBC_SHA", 0x0094);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_256_CBC_SHA = init("TLS_RSA_PSK_WITH_AES_256_CBC_SHA", 0x0095);
-  public static final CipherSuite TLS_RSA_WITH_SEED_CBC_SHA = init("TLS_RSA_WITH_SEED_CBC_SHA", 0x0096);
-  // public static final CipherSuite TLS_DH_DSS_WITH_SEED_CBC_SHA = init("TLS_DH_DSS_WITH_SEED_CBC_SHA", 0x0097);
-  // public static final CipherSuite TLS_DH_RSA_WITH_SEED_CBC_SHA = init("TLS_DH_RSA_WITH_SEED_CBC_SHA", 0x0098);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_SEED_CBC_SHA = init("TLS_DHE_DSS_WITH_SEED_CBC_SHA", 0x0099);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_SEED_CBC_SHA = init("TLS_DHE_RSA_WITH_SEED_CBC_SHA", 0x009a);
-  // public static final CipherSuite TLS_DH_anon_WITH_SEED_CBC_SHA = init("TLS_DH_anon_WITH_SEED_CBC_SHA", 0x009b);
-  public static final CipherSuite TLS_RSA_WITH_AES_128_GCM_SHA256 = init("TLS_RSA_WITH_AES_128_GCM_SHA256", 0x009c);
-  public static final CipherSuite TLS_RSA_WITH_AES_256_GCM_SHA384 = init("TLS_RSA_WITH_AES_256_GCM_SHA384", 0x009d);
-  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 = init("TLS_DHE_RSA_WITH_AES_128_GCM_SHA256", 0x009e);
-  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 = init("TLS_DHE_RSA_WITH_AES_256_GCM_SHA384", 0x009f);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_GCM_SHA256 = init("TLS_DH_RSA_WITH_AES_128_GCM_SHA256", 0x00a0);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_GCM_SHA384 = init("TLS_DH_RSA_WITH_AES_256_GCM_SHA384", 0x00a1);
-  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_GCM_SHA256 = init("TLS_DHE_DSS_WITH_AES_128_GCM_SHA256", 0x00a2);
-  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_GCM_SHA384 = init("TLS_DHE_DSS_WITH_AES_256_GCM_SHA384", 0x00a3);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_GCM_SHA256 = init("TLS_DH_DSS_WITH_AES_128_GCM_SHA256", 0x00a4);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_GCM_SHA384 = init("TLS_DH_DSS_WITH_AES_256_GCM_SHA384", 0x00a5);
-  public static final CipherSuite TLS_DH_anon_WITH_AES_128_GCM_SHA256 = init("TLS_DH_anon_WITH_AES_128_GCM_SHA256", 0x00a6);
-  public static final CipherSuite TLS_DH_anon_WITH_AES_256_GCM_SHA384 = init("TLS_DH_anon_WITH_AES_256_GCM_SHA384", 0x00a7);
-  // public static final CipherSuite TLS_PSK_WITH_AES_128_GCM_SHA256 = init("TLS_PSK_WITH_AES_128_GCM_SHA256", 0x00a8);
-  // public static final CipherSuite TLS_PSK_WITH_AES_256_GCM_SHA384 = init("TLS_PSK_WITH_AES_256_GCM_SHA384", 0x00a9);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_GCM_SHA256 = init("TLS_DHE_PSK_WITH_AES_128_GCM_SHA256", 0x00aa);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_GCM_SHA384 = init("TLS_DHE_PSK_WITH_AES_256_GCM_SHA384", 0x00ab);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_128_GCM_SHA256 = init("TLS_RSA_PSK_WITH_AES_128_GCM_SHA256", 0x00ac);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_256_GCM_SHA384 = init("TLS_RSA_PSK_WITH_AES_256_GCM_SHA384", 0x00ad);
-  // public static final CipherSuite TLS_PSK_WITH_AES_128_CBC_SHA256 = init("TLS_PSK_WITH_AES_128_CBC_SHA256", 0x00ae);
-  // public static final CipherSuite TLS_PSK_WITH_AES_256_CBC_SHA384 = init("TLS_PSK_WITH_AES_256_CBC_SHA384", 0x00af);
-  // public static final CipherSuite TLS_PSK_WITH_NULL_SHA256 = init("TLS_PSK_WITH_NULL_SHA256", 0x00b0);
-  // public static final CipherSuite TLS_PSK_WITH_NULL_SHA384 = init("TLS_PSK_WITH_NULL_SHA384", 0x00b1);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_CBC_SHA256 = init("TLS_DHE_PSK_WITH_AES_128_CBC_SHA256", 0x00b2);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_CBC_SHA384 = init("TLS_DHE_PSK_WITH_AES_256_CBC_SHA384", 0x00b3);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_NULL_SHA256 = init("TLS_DHE_PSK_WITH_NULL_SHA256", 0x00b4);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_NULL_SHA384 = init("TLS_DHE_PSK_WITH_NULL_SHA384", 0x00b5);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_128_CBC_SHA256 = init("TLS_RSA_PSK_WITH_AES_128_CBC_SHA256", 0x00b6);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_256_CBC_SHA384 = init("TLS_RSA_PSK_WITH_AES_256_CBC_SHA384", 0x00b7);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_NULL_SHA256 = init("TLS_RSA_PSK_WITH_NULL_SHA256", 0x00b8);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_NULL_SHA384 = init("TLS_RSA_PSK_WITH_NULL_SHA384", 0x00b9);
-  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00ba);
-  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256", 0x00bb);
-  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00bc);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256", 0x00bd);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00be);
-  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256", 0x00bf);
-  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c0);
-  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256", 0x00c1);
-  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c2);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256", 0x00c3);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c4);
-  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256", 0x00c5);
-  public static final CipherSuite TLS_EMPTY_RENEGOTIATION_INFO_SCSV = init("TLS_EMPTY_RENEGOTIATION_INFO_SCSV", 0x00ff);
-  public static final CipherSuite TLS_FALLBACK_SCSV = init("TLS_FALLBACK_SCSV", 0x5600);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_NULL_SHA = init("TLS_ECDH_ECDSA_WITH_NULL_SHA", 0xc001);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_RC4_128_SHA = init("TLS_ECDH_ECDSA_WITH_RC4_128_SHA", 0xc002);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA", 0xc003);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA = init("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA", 0xc004);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA = init("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA", 0xc005);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_NULL_SHA = init("TLS_ECDHE_ECDSA_WITH_NULL_SHA", 0xc006);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_RC4_128_SHA = init("TLS_ECDHE_ECDSA_WITH_RC4_128_SHA", 0xc007);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA", 0xc008);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = init("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA", 0xc009);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = init("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA", 0xc00a);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_NULL_SHA = init("TLS_ECDH_RSA_WITH_NULL_SHA", 0xc00b);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_RC4_128_SHA = init("TLS_ECDH_RSA_WITH_RC4_128_SHA", 0xc00c);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA", 0xc00d);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA = init("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA", 0xc00e);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA = init("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA", 0xc00f);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_NULL_SHA = init("TLS_ECDHE_RSA_WITH_NULL_SHA", 0xc010);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_RC4_128_SHA = init("TLS_ECDHE_RSA_WITH_RC4_128_SHA", 0xc011);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA", 0xc012);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA = init("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA", 0xc013);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA = init("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA", 0xc014);
-  public static final CipherSuite TLS_ECDH_anon_WITH_NULL_SHA = init("TLS_ECDH_anon_WITH_NULL_SHA", 0xc015);
-  public static final CipherSuite TLS_ECDH_anon_WITH_RC4_128_SHA = init("TLS_ECDH_anon_WITH_RC4_128_SHA", 0xc016);
-  public static final CipherSuite TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA", 0xc017);
-  public static final CipherSuite TLS_ECDH_anon_WITH_AES_128_CBC_SHA = init("TLS_ECDH_anon_WITH_AES_128_CBC_SHA", 0xc018);
-  public static final CipherSuite TLS_ECDH_anon_WITH_AES_256_CBC_SHA = init("TLS_ECDH_anon_WITH_AES_256_CBC_SHA", 0xc019);
-  // public static final CipherSuite TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA = init("TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA", 0xc01a);
-  // public static final CipherSuite TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA = init("TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA", 0xc01b);
-  // public static final CipherSuite TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA = init("TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA", 0xc01c);
-  // public static final CipherSuite TLS_SRP_SHA_WITH_AES_128_CBC_SHA = init("TLS_SRP_SHA_WITH_AES_128_CBC_SHA", 0xc01d);
-  // public static final CipherSuite TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA = init("TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA", 0xc01e);
-  // public static final CipherSuite TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA = init("TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA", 0xc01f);
-  // public static final CipherSuite TLS_SRP_SHA_WITH_AES_256_CBC_SHA = init("TLS_SRP_SHA_WITH_AES_256_CBC_SHA", 0xc020);
-  // public static final CipherSuite TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA = init("TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA", 0xc021);
-  // public static final CipherSuite TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA = init("TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA", 0xc022);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 = init("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256", 0xc023);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 = init("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384", 0xc024);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 = init("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256", 0xc025);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 = init("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384", 0xc026);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 = init("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256", 0xc027);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 = init("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384", 0xc028);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 = init("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256", 0xc029);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 = init("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384", 0xc02a);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = init("TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02b);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = init("TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02c);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 = init("TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02d);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 = init("TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02e);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = init("TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256", 0xc02f);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = init("TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384", 0xc030);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 = init("TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256", 0xc031);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 = init("TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384", 0xc032);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_RC4_128_SHA = init("TLS_ECDHE_PSK_WITH_RC4_128_SHA", 0xc033);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA", 0xc034);
-  public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA = init("TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA", 0xc035);
-  public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA = init("TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA", 0xc036);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256 = init("TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256", 0xc037);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384 = init("TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384", 0xc038);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA = init("TLS_ECDHE_PSK_WITH_NULL_SHA", 0xc039);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA256 = init("TLS_ECDHE_PSK_WITH_NULL_SHA256", 0xc03a);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA384 = init("TLS_ECDHE_PSK_WITH_NULL_SHA384", 0xc03b);
-  // public static final CipherSuite TLS_RSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_RSA_WITH_ARIA_128_CBC_SHA256", 0xc03c);
-  // public static final CipherSuite TLS_RSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_RSA_WITH_ARIA_256_CBC_SHA384", 0xc03d);
-  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256 = init("TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256", 0xc03e);
-  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384 = init("TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384", 0xc03f);
-  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256", 0xc040);
-  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384", 0xc041);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256 = init("TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256", 0xc042);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384 = init("TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384", 0xc043);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256", 0xc044);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384", 0xc045);
-  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_128_CBC_SHA256 = init("TLS_DH_anon_WITH_ARIA_128_CBC_SHA256", 0xc046);
-  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_256_CBC_SHA384 = init("TLS_DH_anon_WITH_ARIA_256_CBC_SHA384", 0xc047);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256", 0xc048);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384", 0xc049);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256", 0xc04a);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384", 0xc04b);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256", 0xc04c);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384", 0xc04d);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256", 0xc04e);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384", 0xc04f);
-  // public static final CipherSuite TLS_RSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_RSA_WITH_ARIA_128_GCM_SHA256", 0xc050);
-  // public static final CipherSuite TLS_RSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_RSA_WITH_ARIA_256_GCM_SHA384", 0xc051);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256", 0xc052);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384", 0xc053);
-  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256", 0xc054);
-  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384", 0xc055);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256 = init("TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256", 0xc056);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384 = init("TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384", 0xc057);
-  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256 = init("TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256", 0xc058);
-  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384 = init("TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384", 0xc059);
-  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_128_GCM_SHA256 = init("TLS_DH_anon_WITH_ARIA_128_GCM_SHA256", 0xc05a);
-  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_256_GCM_SHA384 = init("TLS_DH_anon_WITH_ARIA_256_GCM_SHA384", 0xc05b);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256", 0xc05c);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384", 0xc05d);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256", 0xc05e);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384", 0xc05f);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256", 0xc060);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384", 0xc061);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256", 0xc062);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384", 0xc063);
-  // public static final CipherSuite TLS_PSK_WITH_ARIA_128_CBC_SHA256 = init("TLS_PSK_WITH_ARIA_128_CBC_SHA256", 0xc064);
-  // public static final CipherSuite TLS_PSK_WITH_ARIA_256_CBC_SHA384 = init("TLS_PSK_WITH_ARIA_256_CBC_SHA384", 0xc065);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256 = init("TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256", 0xc066);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384 = init("TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384", 0xc067);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256 = init("TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256", 0xc068);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384 = init("TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384", 0xc069);
-  // public static final CipherSuite TLS_PSK_WITH_ARIA_128_GCM_SHA256 = init("TLS_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06a);
-  // public static final CipherSuite TLS_PSK_WITH_ARIA_256_GCM_SHA384 = init("TLS_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06b);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256 = init("TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06c);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384 = init("TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06d);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256 = init("TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06e);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384 = init("TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06f);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256 = init("TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256", 0xc070);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384 = init("TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384", 0xc071);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc072);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc073);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc074);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc075);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc076);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc077);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc078);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc079);
-  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07a);
-  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07b);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07c);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07d);
-  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07e);
-  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07f);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256", 0xc080);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384", 0xc081);
-  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256", 0xc082);
-  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384", 0xc083);
-  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256", 0xc084);
-  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384", 0xc085);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc086);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc087);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc088);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc089);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc08a);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc08b);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc08c);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc08d);
-  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc08e);
-  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc08f);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc090);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc091);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc092);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc093);
-  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc094);
-  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc095);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc096);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc097);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc098);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc099);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc09a);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc09b);
-  // public static final CipherSuite TLS_RSA_WITH_AES_128_CCM = init("TLS_RSA_WITH_AES_128_CCM", 0xc09c);
-  // public static final CipherSuite TLS_RSA_WITH_AES_256_CCM = init("TLS_RSA_WITH_AES_256_CCM", 0xc09d);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CCM = init("TLS_DHE_RSA_WITH_AES_128_CCM", 0xc09e);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CCM = init("TLS_DHE_RSA_WITH_AES_256_CCM", 0xc09f);
-  // public static final CipherSuite TLS_RSA_WITH_AES_128_CCM_8 = init("TLS_RSA_WITH_AES_128_CCM_8", 0xc0a0);
-  // public static final CipherSuite TLS_RSA_WITH_AES_256_CCM_8 = init("TLS_RSA_WITH_AES_256_CCM_8", 0xc0a1);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CCM_8 = init("TLS_DHE_RSA_WITH_AES_128_CCM_8", 0xc0a2);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CCM_8 = init("TLS_DHE_RSA_WITH_AES_256_CCM_8", 0xc0a3);
-  // public static final CipherSuite TLS_PSK_WITH_AES_128_CCM = init("TLS_PSK_WITH_AES_128_CCM", 0xc0a4);
-  // public static final CipherSuite TLS_PSK_WITH_AES_256_CCM = init("TLS_PSK_WITH_AES_256_CCM", 0xc0a5);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_CCM = init("TLS_DHE_PSK_WITH_AES_128_CCM", 0xc0a6);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_CCM = init("TLS_DHE_PSK_WITH_AES_256_CCM", 0xc0a7);
-  // public static final CipherSuite TLS_PSK_WITH_AES_128_CCM_8 = init("TLS_PSK_WITH_AES_128_CCM_8", 0xc0a8);
-  // public static final CipherSuite TLS_PSK_WITH_AES_256_CCM_8 = init("TLS_PSK_WITH_AES_256_CCM_8", 0xc0a9);
-  // public static final CipherSuite TLS_PSK_DHE_WITH_AES_128_CCM_8 = init("TLS_PSK_DHE_WITH_AES_128_CCM_8", 0xc0aa);
-  // public static final CipherSuite TLS_PSK_DHE_WITH_AES_256_CCM_8 = init("TLS_PSK_DHE_WITH_AES_256_CCM_8", 0xc0ab);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CCM = init("TLS_ECDHE_ECDSA_WITH_AES_128_CCM", 0xc0ac);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CCM = init("TLS_ECDHE_ECDSA_WITH_AES_256_CCM", 0xc0ad);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 = init("TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8", 0xc0ae);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8 = init("TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8", 0xc0af);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256", 0xcca8);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256", 0xcca9);
-  public static final CipherSuite TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256", 0xccaa);
-  // public static final CipherSuite TLS_PSK_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccab);
-  public static final CipherSuite TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccac);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccad);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccae);
-
-  // TLS 1.3 https://tools.ietf.org/html/rfc8446
-  public static final CipherSuite TLS_AES_128_GCM_SHA256 = init("TLS_AES_128_GCM_SHA256", 0x1301);
-  public static final CipherSuite TLS_AES_256_GCM_SHA384 = init("TLS_AES_256_GCM_SHA384", 0x1302);
-  public static final CipherSuite TLS_CHACHA20_POLY1305_SHA256 = init("TLS_CHACHA20_POLY1305_SHA256", 0x1303);
-  public static final CipherSuite TLS_AES_128_CCM_SHA256 = init("TLS_AES_128_CCM_SHA256", 0x1304);
-  public static final CipherSuite TLS_AES_128_CCM_8_SHA256 = init("TLS_AES_128_CCM_8_SHA256", 0x1305);
-
-  final String javaName;
-
-  /**
-   * @param javaName the name used by Java APIs for this cipher suite. Different than the IANA name
-   *     for older cipher suites because the prefix is {@code SSL_} instead of {@code TLS_}.
-   */
-  public static synchronized CipherSuite forJavaName(String javaName) {
-    CipherSuite result = INSTANCES.get(javaName);
-    if (result == null) {
-      result = INSTANCES.get(secondaryName(javaName));
-
-      if (result == null) {
-        result = new CipherSuite(javaName);
-      }
-
-      // Add the new cipher suite, or a confirmed alias.
-      INSTANCES.put(javaName, result);
-    }
-    return result;
-  }
-
-  private static String secondaryName(String javaName) {
-    if (javaName.startsWith("TLS_")) {
-      return "SSL_" + javaName.substring(4);
-    } else if (javaName.startsWith("SSL_")) {
-      return "TLS_" + javaName.substring(4);
-    } else {
-      return javaName;
-    }
-  }
-
-  static List<CipherSuite> forJavaNames(String... cipherSuites) {
-    List<CipherSuite> result = new ArrayList<>(cipherSuites.length);
-    for (String cipherSuite : cipherSuites) {
-      result.add(forJavaName(cipherSuite));
-    }
-    return Collections.unmodifiableList(result);
-  }
-
-  private CipherSuite(String javaName) {
-    if (javaName == null) {
-      throw new NullPointerException();
-    }
-    this.javaName = javaName;
-  }
-
-  /**
-   * @param javaName the name used by Java APIs for this cipher suite. Different than the IANA name
-   *     for older cipher suites because the prefix is {@code SSL_} instead of {@code TLS_}.
-   * @param value the integer identifier for this cipher suite. (Documentation only.)
-   */
-  private static CipherSuite init(String javaName, int value) {
-    CipherSuite suite = new CipherSuite(javaName);
-    INSTANCES.put(javaName, suite);
-    return suite;
-  }
-
-  /**
-   * Returns the Java name of this cipher suite. For some older cipher suites the Java name has the
-   * prefix {@code SSL_}, causing the Java name to be different from the instance name which is
-   * always prefixed {@code TLS_}. For example, {@code TLS_RSA_EXPORT_WITH_RC4_40_MD5.javaName()}
-   * is {@code "SSL_RSA_EXPORT_WITH_RC4_40_MD5"}.
-   */
-  public String javaName() {
-    return javaName;
-  }
-
-  @Override public String toString() {
-    return javaName;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Connection.java b/okhttp/src/main/java/okhttp3/Connection.java
deleted file mode 100644
index cb6d70996d..0000000000
--- a/okhttp/src/main/java/okhttp3/Connection.java
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package okhttp3;
-
-import java.net.Socket;
-import javax.annotation.Nullable;
-
-/**
- * The sockets and streams of an HTTP, HTTPS, or HTTPS+HTTP/2 connection. May be used for multiple
- * HTTP request/response exchanges. Connections may be direct to the origin server or via a proxy.
- *
- * <p>Typically instances of this class are created, connected and exercised automatically by the
- * HTTP client. Applications may use this class to monitor HTTP connections as members of a
- * {@linkplain ConnectionPool connection pool}.
- *
- * <p>Do not confuse this class with the misnamed {@code HttpURLConnection}, which isn't so much a
- * connection as a single request/response exchange.
- *
- * <h3>Modern TLS</h3>
- *
- * <p>There are tradeoffs when selecting which options to include when negotiating a secure
- * connection to a remote host. Newer TLS options are quite useful:
- *
- * <ul>
- *     <li>Server Name Indication (SNI) enables one IP address to negotiate secure connections for
- *         multiple domain names.
- *     <li>Application Layer Protocol Negotiation (ALPN) enables the HTTPS port (443) to be used to
- *         negotiate HTTP/2.
- * </ul>
- *
- * <p>Unfortunately, older HTTPS servers refuse to connect when such options are presented. Rather
- * than avoiding these options entirely, this class allows a connection to be attempted with modern
- * options and then retried without them should the attempt fail.
- *
- * <h3>Connection Reuse</h3>
- *
- * <p>Each connection can carry a varying number of streams, depending on the underlying protocol
- * being used. HTTP/1.x connections can carry either zero or one streams. HTTP/2 connections can
- * carry any number of streams, dynamically configured with {@code SETTINGS_MAX_CONCURRENT_STREAMS}.
- * A connection currently carrying zero streams is an idle stream. We keep it alive because reusing
- * an existing connection is typically faster than establishing a new one.
- *
- * <p>When a single logical call requires multiple streams due to redirects or authorization
- * challenges, we prefer to use the same physical connection for all streams in the sequence. There
- * are potential performance and behavior consequences to this preference. To support this feature,
- * this class separates <i>allocations</i> from <i>streams</i>. An allocation is created by a call,
- * used for one or more streams, and then released. An allocated connection won't be stolen by other
- * calls while a redirect or authorization challenge is being handled.
- *
- * <p>When the maximum concurrent streams limit is reduced, some allocations will be rescinded.
- * Attempting to create new streams on these allocations will fail.
- *
- * <p>Note that an allocation may be released before its stream is completed. This is intended to
- * make bookkeeping easier for the caller: releasing the allocation as soon as the terminal stream
- * has been found. But only complete the stream once its data stream has been exhausted.
- */
-public interface Connection {
-  /** Returns the route used by this connection. */
-  Route route();
-
-  /**
-   * Returns the socket that this connection is using. Returns an {@linkplain
-   * javax.net.ssl.SSLSocket SSL socket} if this connection is HTTPS. If this is an HTTP/2
-   * connection the socket may be shared by multiple concurrent calls.
-   */
-  Socket socket();
-
-  /**
-   * Returns the TLS handshake used to establish this connection, or null if the connection is not
-   * HTTPS.
-   */
-  @Nullable Handshake handshake();
-
-  /**
-   * Returns the protocol negotiated by this connection, or {@link Protocol#HTTP_1_1} if no protocol
-   * has been negotiated. This method returns {@link Protocol#HTTP_1_1} even if the remote peer is
-   * using {@link Protocol#HTTP_1_0}.
-   */
-  Protocol protocol();
-}
diff --git a/okhttp/src/main/java/okhttp3/ConnectionPool.java b/okhttp/src/main/java/okhttp3/ConnectionPool.java
deleted file mode 100644
index c3c67772da..0000000000
--- a/okhttp/src/main/java/okhttp3/ConnectionPool.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package okhttp3;
-
-import java.util.concurrent.TimeUnit;
-import okhttp3.internal.connection.RealConnectionPool;
-
-/**
- * Manages reuse of HTTP and HTTP/2 connections for reduced network latency. HTTP requests that
- * share the same {@link Address} may share a {@link Connection}. This class implements the policy
- * of which connections to keep open for future use.
- */
-public final class ConnectionPool {
-  final RealConnectionPool delegate;
-
-  /**
-   * Create a new connection pool with tuning parameters appropriate for a single-user application.
-   * The tuning parameters in this pool are subject to change in future OkHttp releases. Currently
-   * this pool holds up to 5 idle connections which will be evicted after 5 minutes of inactivity.
-   */
-  public ConnectionPool() {
-    this(5, 5, TimeUnit.MINUTES);
-  }
-
-  public ConnectionPool(int maxIdleConnections, long keepAliveDuration, TimeUnit timeUnit) {
-    this.delegate = new RealConnectionPool(maxIdleConnections, keepAliveDuration, timeUnit);
-  }
-
-  /** Returns the number of idle connections in the pool. */
-  public int idleConnectionCount() {
-    return delegate.idleConnectionCount();
-  }
-
-  /** Returns total number of connections in the pool. */
-  public int connectionCount() {
-    return delegate.connectionCount();
-  }
-
-  /** Close and remove all idle connections in the pool. */
-  public void evictAll() {
-    delegate.evictAll();
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/ConnectionSpec.java b/okhttp/src/main/java/okhttp3/ConnectionSpec.java
deleted file mode 100644
index b49aad68fe..0000000000
--- a/okhttp/src/main/java/okhttp3/ConnectionSpec.java
+++ /dev/null
@@ -1,354 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.util.Arrays;
-import java.util.List;
-import java.util.Objects;
-import javax.annotation.Nullable;
-import javax.net.ssl.SSLSocket;
-import okhttp3.internal.Util;
-
-import static okhttp3.internal.Util.concat;
-import static okhttp3.internal.Util.indexOf;
-import static okhttp3.internal.Util.intersect;
-import static okhttp3.internal.Util.nonEmptyIntersection;
-
-/**
- * Specifies configuration for the socket connection that HTTP traffic travels through. For {@code
- * https:} URLs, this includes the TLS version and cipher suites to use when negotiating a secure
- * connection.
- *
- * <p>The TLS versions configured in a connection spec are only be used if they are also enabled in
- * the SSL socket. For example, if an SSL socket does not have TLS 1.3 enabled, it will not be used
- * even if it is present on the connection spec. The same policy also applies to cipher suites.
- *
- * <p>Use {@link Builder#allEnabledTlsVersions()} and {@link Builder#allEnabledCipherSuites} to
- * defer all feature selection to the underlying SSL socket.
- *
- * <p>The configuration of each spec changes with each OkHttp release. This is annoying: upgrading
- * your OkHttp library can break connectivity to certain web servers! But it‚Äôs a necessary annoyance
- * because the TLS ecosystem is dynamic and staying up to date is necessary to stay secure. See
- * <a href="https://github.com/square/okhttp/wiki/TLS-Configuration-History">OkHttp's TLS
- * Configuration History</a> to track these changes.
- */
-public final class ConnectionSpec {
-
-  // Most secure but generally supported list.
-  private static final CipherSuite[] RESTRICTED_CIPHER_SUITES = new CipherSuite[] {
-      // TLSv1.3.
-      CipherSuite.TLS_AES_128_GCM_SHA256,
-      CipherSuite.TLS_AES_256_GCM_SHA384,
-      CipherSuite.TLS_CHACHA20_POLY1305_SHA256,
-
-      // TLSv1.0, TLSv1.1, TLSv1.2.
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
-      CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
-      CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,
-      CipherSuite.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
-  };
-
-  // This is nearly equal to the cipher suites supported in Chrome 72, current as of 2019-02-24.
-  // See https://tinyurl.com/okhttp-cipher-suites for availability.
-  private static final CipherSuite[] APPROVED_CIPHER_SUITES = new CipherSuite[] {
-      // TLSv1.3.
-      CipherSuite.TLS_AES_128_GCM_SHA256,
-      CipherSuite.TLS_AES_256_GCM_SHA384,
-      CipherSuite.TLS_CHACHA20_POLY1305_SHA256,
-
-      // TLSv1.0, TLSv1.1, TLSv1.2.
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
-      CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
-      CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,
-      CipherSuite.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,
-
-      // Note that the following cipher suites are all on HTTP/2's bad cipher suites list. We'll
-      // continue to include them until better suites are commonly available.
-      CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
-      CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
-      CipherSuite.TLS_RSA_WITH_AES_128_GCM_SHA256,
-      CipherSuite.TLS_RSA_WITH_AES_256_GCM_SHA384,
-      CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA,
-      CipherSuite.TLS_RSA_WITH_AES_256_CBC_SHA,
-      CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
-  };
-
-  /** A secure TLS connection that requires a recent client platform and a recent server. */
-  public static final ConnectionSpec RESTRICTED_TLS = new Builder(true)
-      .cipherSuites(RESTRICTED_CIPHER_SUITES)
-      .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2)
-      .supportsTlsExtensions(true)
-      .build();
-
-  /**
-   * A modern TLS configuration that works on most client platforms and can connect to most servers.
-   * This is OkHttp's default configuration.
-   */
-  public static final ConnectionSpec MODERN_TLS = new Builder(true)
-      .cipherSuites(APPROVED_CIPHER_SUITES)
-      .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2)
-      .supportsTlsExtensions(true)
-      .build();
-
-  /**
-   * A backwards-compatible fallback configuration that works on obsolete client platforms and can
-   * connect to obsolete servers. When possible, prefer to upgrade your client platform or server
-   * rather than using this configuration.
-   */
-  public static final ConnectionSpec COMPATIBLE_TLS = new Builder(true)
-      .cipherSuites(APPROVED_CIPHER_SUITES)
-      .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0)
-      .supportsTlsExtensions(true)
-      .build();
-
-  /** Unencrypted, unauthenticated connections for {@code http:} URLs. */
-  public static final ConnectionSpec CLEARTEXT = new Builder(false).build();
-
-  final boolean tls;
-  final boolean supportsTlsExtensions;
-  final @Nullable String[] cipherSuites;
-  final @Nullable String[] tlsVersions;
-
-  ConnectionSpec(Builder builder) {
-    this.tls = builder.tls;
-    this.cipherSuites = builder.cipherSuites;
-    this.tlsVersions = builder.tlsVersions;
-    this.supportsTlsExtensions = builder.supportsTlsExtensions;
-  }
-
-  public boolean isTls() {
-    return tls;
-  }
-
-  /**
-   * Returns the cipher suites to use for a connection. Returns null if all of the SSL socket's
-   * enabled cipher suites should be used.
-   */
-  public @Nullable List<CipherSuite> cipherSuites() {
-    return cipherSuites != null ? CipherSuite.forJavaNames(cipherSuites) : null;
-  }
-
-  /**
-   * Returns the TLS versions to use when negotiating a connection. Returns null if all of the SSL
-   * socket's enabled TLS versions should be used.
-   */
-  public @Nullable List<TlsVersion> tlsVersions() {
-    return tlsVersions != null ? TlsVersion.forJavaNames(tlsVersions) : null;
-  }
-
-  public boolean supportsTlsExtensions() {
-    return supportsTlsExtensions;
-  }
-
-  /** Applies this spec to {@code sslSocket}. */
-  void apply(SSLSocket sslSocket, boolean isFallback) {
-    ConnectionSpec specToApply = supportedSpec(sslSocket, isFallback);
-
-    if (specToApply.tlsVersions != null) {
-      sslSocket.setEnabledProtocols(specToApply.tlsVersions);
-    }
-    if (specToApply.cipherSuites != null) {
-      sslSocket.setEnabledCipherSuites(specToApply.cipherSuites);
-    }
-  }
-
-  /**
-   * Returns a copy of this that omits cipher suites and TLS versions not enabled by {@code
-   * sslSocket}.
-   */
-  private ConnectionSpec supportedSpec(SSLSocket sslSocket, boolean isFallback) {
-    String[] cipherSuitesIntersection = cipherSuites != null
-        ? intersect(CipherSuite.ORDER_BY_NAME, sslSocket.getEnabledCipherSuites(), cipherSuites)
-        : sslSocket.getEnabledCipherSuites();
-    String[] tlsVersionsIntersection = tlsVersions != null
-        ? intersect(Util.NATURAL_ORDER, sslSocket.getEnabledProtocols(), tlsVersions)
-        : sslSocket.getEnabledProtocols();
-
-    // In accordance with https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00
-    // the SCSV cipher is added to signal that a protocol fallback has taken place.
-    String[] supportedCipherSuites = sslSocket.getSupportedCipherSuites();
-    int indexOfFallbackScsv = indexOf(
-        CipherSuite.ORDER_BY_NAME, supportedCipherSuites, "TLS_FALLBACK_SCSV");
-    if (isFallback && indexOfFallbackScsv != -1) {
-      cipherSuitesIntersection = concat(
-          cipherSuitesIntersection, supportedCipherSuites[indexOfFallbackScsv]);
-    }
-
-    return new Builder(this)
-        .cipherSuites(cipherSuitesIntersection)
-        .tlsVersions(tlsVersionsIntersection)
-        .build();
-  }
-
-  /**
-   * Returns {@code true} if the socket, as currently configured, supports this connection spec. In
-   * order for a socket to be compatible the enabled cipher suites and protocols must intersect.
-   *
-   * <p>For cipher suites, at least one of the {@link #cipherSuites() required cipher suites} must
-   * match the socket's enabled cipher suites. If there are no required cipher suites the socket
-   * must have at least one cipher suite enabled.
-   *
-   * <p>For protocols, at least one of the {@link #tlsVersions() required protocols} must match the
-   * socket's enabled protocols.
-   */
-  public boolean isCompatible(SSLSocket socket) {
-    if (!tls) {
-      return false;
-    }
-
-    if (tlsVersions != null && !nonEmptyIntersection(
-        Util.NATURAL_ORDER, tlsVersions, socket.getEnabledProtocols())) {
-      return false;
-    }
-
-    if (cipherSuites != null && !nonEmptyIntersection(
-        CipherSuite.ORDER_BY_NAME, cipherSuites, socket.getEnabledCipherSuites())) {
-      return false;
-    }
-
-    return true;
-  }
-
-  @Override public boolean equals(@Nullable Object other) {
-    if (!(other instanceof ConnectionSpec)) return false;
-    if (other == this) return true;
-
-    ConnectionSpec that = (ConnectionSpec) other;
-    if (this.tls != that.tls) return false;
-
-    if (tls) {
-      if (!Arrays.equals(this.cipherSuites, that.cipherSuites)) return false;
-      if (!Arrays.equals(this.tlsVersions, that.tlsVersions)) return false;
-      if (this.supportsTlsExtensions != that.supportsTlsExtensions) return false;
-    }
-
-    return true;
-  }
-
-  @Override public int hashCode() {
-    int result = 17;
-    if (tls) {
-      result = 31 * result + Arrays.hashCode(cipherSuites);
-      result = 31 * result + Arrays.hashCode(tlsVersions);
-      result = 31 * result + (supportsTlsExtensions ? 0 : 1);
-    }
-    return result;
-  }
-
-  @Override public String toString() {
-    if (!tls) {
-      return "ConnectionSpec()";
-    }
-
-    return "ConnectionSpec("
-        + "cipherSuites=" + Objects.toString(cipherSuites(), "[all enabled]")
-        + ", tlsVersions=" + Objects.toString(tlsVersions(), "[all enabled]")
-        + ", supportsTlsExtensions=" + supportsTlsExtensions
-        + ")";
-  }
-
-  public static final class Builder {
-    boolean tls;
-    @Nullable String[] cipherSuites;
-    @Nullable String[] tlsVersions;
-    boolean supportsTlsExtensions;
-
-    Builder(boolean tls) {
-      this.tls = tls;
-    }
-
-    public Builder(ConnectionSpec connectionSpec) {
-      this.tls = connectionSpec.tls;
-      this.cipherSuites = connectionSpec.cipherSuites;
-      this.tlsVersions = connectionSpec.tlsVersions;
-      this.supportsTlsExtensions = connectionSpec.supportsTlsExtensions;
-    }
-
-    public Builder allEnabledCipherSuites() {
-      if (!tls) throw new IllegalStateException("no cipher suites for cleartext connections");
-      this.cipherSuites = null;
-      return this;
-    }
-
-    public Builder cipherSuites(CipherSuite... cipherSuites) {
-      if (!tls) throw new IllegalStateException("no cipher suites for cleartext connections");
-
-      String[] strings = new String[cipherSuites.length];
-      for (int i = 0; i < cipherSuites.length; i++) {
-        strings[i] = cipherSuites[i].javaName;
-      }
-      return cipherSuites(strings);
-    }
-
-    public Builder cipherSuites(String... cipherSuites) {
-      if (!tls) throw new IllegalStateException("no cipher suites for cleartext connections");
-
-      if (cipherSuites.length == 0) {
-        throw new IllegalArgumentException("At least one cipher suite is required");
-      }
-
-      this.cipherSuites = cipherSuites.clone(); // Defensive copy.
-      return this;
-    }
-
-    public Builder allEnabledTlsVersions() {
-      if (!tls) throw new IllegalStateException("no TLS versions for cleartext connections");
-      this.tlsVersions = null;
-      return this;
-    }
-
-    public Builder tlsVersions(TlsVersion... tlsVersions) {
-      if (!tls) throw new IllegalStateException("no TLS versions for cleartext connections");
-
-      String[] strings = new String[tlsVersions.length];
-      for (int i = 0; i < tlsVersions.length; i++) {
-        strings[i] = tlsVersions[i].javaName;
-      }
-
-      return tlsVersions(strings);
-    }
-
-    public Builder tlsVersions(String... tlsVersions) {
-      if (!tls) throw new IllegalStateException("no TLS versions for cleartext connections");
-
-      if (tlsVersions.length == 0) {
-        throw new IllegalArgumentException("At least one TLS version is required");
-      }
-
-      this.tlsVersions = tlsVersions.clone(); // Defensive copy.
-      return this;
-    }
-
-    /**
-     * @deprecated since OkHttp 3.13 all TLS-connections are expected to support TLS extensions.
-     *     In a future release setting this to true will be unnecessary and setting it to false will
-     *     have no effect.
-     */
-    public Builder supportsTlsExtensions(boolean supportsTlsExtensions) {
-      if (!tls) throw new IllegalStateException("no TLS extensions for cleartext connections");
-      this.supportsTlsExtensions = supportsTlsExtensions;
-      return this;
-    }
-
-    public ConnectionSpec build() {
-      return new ConnectionSpec(this);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Cookie.java b/okhttp/src/main/java/okhttp3/Cookie.java
deleted file mode 100644
index 867451e387..0000000000
--- a/okhttp/src/main/java/okhttp3/Cookie.java
+++ /dev/null
@@ -1,612 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.util.ArrayList;
-import java.util.Calendar;
-import java.util.Collections;
-import java.util.Date;
-import java.util.GregorianCalendar;
-import java.util.List;
-import java.util.Locale;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-import javax.annotation.Nullable;
-import okhttp3.internal.Util;
-import okhttp3.internal.http.HttpDate;
-import okhttp3.internal.publicsuffix.PublicSuffixDatabase;
-
-import static okhttp3.internal.Util.UTC;
-import static okhttp3.internal.Util.canonicalizeHost;
-import static okhttp3.internal.Util.delimiterOffset;
-import static okhttp3.internal.Util.indexOfControlOrNonAscii;
-import static okhttp3.internal.Util.trimSubstring;
-import static okhttp3.internal.Util.verifyAsIpAddress;
-
-/**
- * An <a href="http://tools.ietf.org/html/rfc6265">RFC 6265</a> Cookie.
- *
- * <p>This class doesn't support additional attributes on cookies, like <a
- * href="https://code.google.com/p/chromium/issues/detail?id=232693">Chromium's Priority=HIGH
- * extension</a>.
- */
-public final class Cookie {
-  private static final Pattern YEAR_PATTERN
-      = Pattern.compile("(\\d{2,4})[^\\d]*");
-  private static final Pattern MONTH_PATTERN
-      = Pattern.compile("(?i)(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec).*");
-  private static final Pattern DAY_OF_MONTH_PATTERN
-      = Pattern.compile("(\\d{1,2})[^\\d]*");
-  private static final Pattern TIME_PATTERN
-      = Pattern.compile("(\\d{1,2}):(\\d{1,2}):(\\d{1,2})[^\\d]*");
-
-  private final String name;
-  private final String value;
-  private final long expiresAt;
-  private final String domain;
-  private final String path;
-  private final boolean secure;
-  private final boolean httpOnly;
-
-  private final boolean persistent; // True if 'expires' or 'max-age' is present.
-  private final boolean hostOnly; // True unless 'domain' is present.
-
-  private Cookie(String name, String value, long expiresAt, String domain, String path,
-      boolean secure, boolean httpOnly, boolean hostOnly, boolean persistent) {
-    this.name = name;
-    this.value = value;
-    this.expiresAt = expiresAt;
-    this.domain = domain;
-    this.path = path;
-    this.secure = secure;
-    this.httpOnly = httpOnly;
-    this.hostOnly = hostOnly;
-    this.persistent = persistent;
-  }
-
-  Cookie(Builder builder) {
-    if (builder.name == null) throw new NullPointerException("builder.name == null");
-    if (builder.value == null) throw new NullPointerException("builder.value == null");
-    if (builder.domain == null) throw new NullPointerException("builder.domain == null");
-
-    this.name = builder.name;
-    this.value = builder.value;
-    this.expiresAt = builder.expiresAt;
-    this.domain = builder.domain;
-    this.path = builder.path;
-    this.secure = builder.secure;
-    this.httpOnly = builder.httpOnly;
-    this.persistent = builder.persistent;
-    this.hostOnly = builder.hostOnly;
-  }
-
-  /** Returns a non-empty string with this cookie's name. */
-  public String name() {
-    return name;
-  }
-
-  /** Returns a possibly-empty string with this cookie's value. */
-  public String value() {
-    return value;
-  }
-
-  /** Returns true if this cookie does not expire at the end of the current session. */
-  public boolean persistent() {
-    return persistent;
-  }
-
-  /**
-   * Returns the time that this cookie expires, in the same format as {@link
-   * System#currentTimeMillis()}. This is December 31, 9999 if the cookie is {@linkplain
-   * #persistent() not persistent}, in which case it will expire at the end of the current session.
-   *
-   * <p>This may return a value less than the current time, in which case the cookie is already
-   * expired. Webservers may return expired cookies as a mechanism to delete previously set cookies
-   * that may or may not themselves be expired.
-   */
-  public long expiresAt() {
-    return expiresAt;
-  }
-
-  /**
-   * Returns true if this cookie's domain should be interpreted as a single host name, or false if
-   * it should be interpreted as a pattern. This flag will be false if its {@code Set-Cookie} header
-   * included a {@code domain} attribute.
-   *
-   * <p>For example, suppose the cookie's domain is {@code example.com}. If this flag is true it
-   * matches <strong>only</strong> {@code example.com}. If this flag is false it matches {@code
-   * example.com} and all subdomains including {@code api.example.com}, {@code www.example.com}, and
-   * {@code beta.api.example.com}.
-   */
-  public boolean hostOnly() {
-    return hostOnly;
-  }
-
-  /**
-   * Returns the cookie's domain. If {@link #hostOnly()} returns true this is the only domain that
-   * matches this cookie; otherwise it matches this domain and all subdomains.
-   */
-  public String domain() {
-    return domain;
-  }
-
-  /**
-   * Returns this cookie's path. This cookie matches URLs prefixed with path segments that match
-   * this path's segments. For example, if this path is {@code /foo} this cookie matches requests to
-   * {@code /foo} and {@code /foo/bar}, but not {@code /} or {@code /football}.
-   */
-  public String path() {
-    return path;
-  }
-
-  /**
-   * Returns true if this cookie should be limited to only HTTP APIs. In web browsers this prevents
-   * the cookie from being accessible to scripts.
-   */
-  public boolean httpOnly() {
-    return httpOnly;
-  }
-
-  /** Returns true if this cookie should be limited to only HTTPS requests. */
-  public boolean secure() {
-    return secure;
-  }
-
-  /**
-   * Returns true if this cookie should be included on a request to {@code url}. In addition to this
-   * check callers should also confirm that this cookie has not expired.
-   */
-  public boolean matches(HttpUrl url) {
-    boolean domainMatch = hostOnly
-        ? url.host().equals(domain)
-        : domainMatch(url.host(), domain);
-    if (!domainMatch) return false;
-
-    if (!pathMatch(url, path)) return false;
-
-    if (secure && !url.isHttps()) return false;
-
-    return true;
-  }
-
-  private static boolean domainMatch(String urlHost, String domain) {
-    if (urlHost.equals(domain)) {
-      return true; // As in 'example.com' matching 'example.com'.
-    }
-
-    if (urlHost.endsWith(domain)
-        && urlHost.charAt(urlHost.length() - domain.length() - 1) == '.'
-        && !verifyAsIpAddress(urlHost)) {
-      return true; // As in 'example.com' matching 'www.example.com'.
-    }
-
-    return false;
-  }
-
-  private static boolean pathMatch(HttpUrl url, String path) {
-    String urlPath = url.encodedPath();
-
-    if (urlPath.equals(path)) {
-      return true; // As in '/foo' matching '/foo'.
-    }
-
-    if (urlPath.startsWith(path)) {
-      if (path.endsWith("/")) return true; // As in '/' matching '/foo'.
-      if (urlPath.charAt(path.length()) == '/') return true; // As in '/foo' matching '/foo/bar'.
-    }
-
-    return false;
-  }
-
-  /**
-   * Attempt to parse a {@code Set-Cookie} HTTP header value {@code setCookie} as a cookie. Returns
-   * null if {@code setCookie} is not a well-formed cookie.
-   */
-  public static @Nullable Cookie parse(HttpUrl url, String setCookie) {
-    return parse(System.currentTimeMillis(), url, setCookie);
-  }
-
-  static @Nullable Cookie parse(long currentTimeMillis, HttpUrl url, String setCookie) {
-    int pos = 0;
-    int limit = setCookie.length();
-    int cookiePairEnd = delimiterOffset(setCookie, pos, limit, ';');
-
-    int pairEqualsSign = delimiterOffset(setCookie, pos, cookiePairEnd, '=');
-    if (pairEqualsSign == cookiePairEnd) return null;
-
-    String cookieName = trimSubstring(setCookie, pos, pairEqualsSign);
-    if (cookieName.isEmpty() || indexOfControlOrNonAscii(cookieName) != -1) return null;
-
-    String cookieValue = trimSubstring(setCookie, pairEqualsSign + 1, cookiePairEnd);
-    if (indexOfControlOrNonAscii(cookieValue) != -1) return null;
-
-    long expiresAt = HttpDate.MAX_DATE;
-    long deltaSeconds = -1L;
-    String domain = null;
-    String path = null;
-    boolean secureOnly = false;
-    boolean httpOnly = false;
-    boolean hostOnly = true;
-    boolean persistent = false;
-
-    pos = cookiePairEnd + 1;
-    while (pos < limit) {
-      int attributePairEnd = delimiterOffset(setCookie, pos, limit, ';');
-
-      int attributeEqualsSign = delimiterOffset(setCookie, pos, attributePairEnd, '=');
-      String attributeName = trimSubstring(setCookie, pos, attributeEqualsSign);
-      String attributeValue = attributeEqualsSign < attributePairEnd
-          ? trimSubstring(setCookie, attributeEqualsSign + 1, attributePairEnd)
-          : "";
-
-      if (attributeName.equalsIgnoreCase("expires")) {
-        try {
-          expiresAt = parseExpires(attributeValue, 0, attributeValue.length());
-          persistent = true;
-        } catch (IllegalArgumentException e) {
-          // Ignore this attribute, it isn't recognizable as a date.
-        }
-      } else if (attributeName.equalsIgnoreCase("max-age")) {
-        try {
-          deltaSeconds = parseMaxAge(attributeValue);
-          persistent = true;
-        } catch (NumberFormatException e) {
-          // Ignore this attribute, it isn't recognizable as a max age.
-        }
-      } else if (attributeName.equalsIgnoreCase("domain")) {
-        try {
-          domain = parseDomain(attributeValue);
-          hostOnly = false;
-        } catch (IllegalArgumentException e) {
-          // Ignore this attribute, it isn't recognizable as a domain.
-        }
-      } else if (attributeName.equalsIgnoreCase("path")) {
-        path = attributeValue;
-      } else if (attributeName.equalsIgnoreCase("secure")) {
-        secureOnly = true;
-      } else if (attributeName.equalsIgnoreCase("httponly")) {
-        httpOnly = true;
-      }
-
-      pos = attributePairEnd + 1;
-    }
-
-    // If 'Max-Age' is present, it takes precedence over 'Expires', regardless of the order the two
-    // attributes are declared in the cookie string.
-    if (deltaSeconds == Long.MIN_VALUE) {
-      expiresAt = Long.MIN_VALUE;
-    } else if (deltaSeconds != -1L) {
-      long deltaMilliseconds = deltaSeconds <= (Long.MAX_VALUE / 1000)
-          ? deltaSeconds * 1000
-          : Long.MAX_VALUE;
-      expiresAt = currentTimeMillis + deltaMilliseconds;
-      if (expiresAt < currentTimeMillis || expiresAt > HttpDate.MAX_DATE) {
-        expiresAt = HttpDate.MAX_DATE; // Handle overflow & limit the date range.
-      }
-    }
-
-    // If the domain is present, it must domain match. Otherwise we have a host-only cookie.
-    String urlHost = url.host();
-    if (domain == null) {
-      domain = urlHost;
-    } else if (!domainMatch(urlHost, domain)) {
-      return null; // No domain match? This is either incompetence or malice!
-    }
-
-    // If the domain is a suffix of the url host, it must not be a public suffix.
-    if (urlHost.length() != domain.length()
-        && PublicSuffixDatabase.get().getEffectiveTldPlusOne(domain) == null) {
-      return null;
-    }
-
-    // If the path is absent or didn't start with '/', use the default path. It's a string like
-    // '/foo/bar' for a URL like 'http://example.com/foo/bar/baz'. It always starts with '/'.
-    if (path == null || !path.startsWith("/")) {
-      String encodedPath = url.encodedPath();
-      int lastSlash = encodedPath.lastIndexOf('/');
-      path = lastSlash != 0 ? encodedPath.substring(0, lastSlash) : "/";
-    }
-
-    return new Cookie(cookieName, cookieValue, expiresAt, domain, path, secureOnly, httpOnly,
-        hostOnly, persistent);
-  }
-
-  /** Parse a date as specified in RFC 6265, section 5.1.1. */
-  private static long parseExpires(String s, int pos, int limit) {
-    pos = dateCharacterOffset(s, pos, limit, false);
-
-    int hour = -1;
-    int minute = -1;
-    int second = -1;
-    int dayOfMonth = -1;
-    int month = -1;
-    int year = -1;
-    Matcher matcher = TIME_PATTERN.matcher(s);
-
-    while (pos < limit) {
-      int end = dateCharacterOffset(s, pos + 1, limit, true);
-      matcher.region(pos, end);
-
-      if (hour == -1 && matcher.usePattern(TIME_PATTERN).matches()) {
-        hour = Integer.parseInt(matcher.group(1));
-        minute = Integer.parseInt(matcher.group(2));
-        second = Integer.parseInt(matcher.group(3));
-      } else if (dayOfMonth == -1 && matcher.usePattern(DAY_OF_MONTH_PATTERN).matches()) {
-        dayOfMonth = Integer.parseInt(matcher.group(1));
-      } else if (month == -1 && matcher.usePattern(MONTH_PATTERN).matches()) {
-        String monthString = matcher.group(1).toLowerCase(Locale.US);
-        month = MONTH_PATTERN.pattern().indexOf(monthString) / 4; // Sneaky! jan=1, dec=12.
-      } else if (year == -1 && matcher.usePattern(YEAR_PATTERN).matches()) {
-        year = Integer.parseInt(matcher.group(1));
-      }
-
-      pos = dateCharacterOffset(s, end + 1, limit, false);
-    }
-
-    // Convert two-digit years into four-digit years. 99 becomes 1999, 15 becomes 2015.
-    if (year >= 70 && year <= 99) year += 1900;
-    if (year >= 0 && year <= 69) year += 2000;
-
-    // If any partial is omitted or out of range, return -1. The date is impossible. Note that leap
-    // seconds are not supported by this syntax.
-    if (year < 1601) throw new IllegalArgumentException();
-    if (month == -1) throw new IllegalArgumentException();
-    if (dayOfMonth < 1 || dayOfMonth > 31) throw new IllegalArgumentException();
-    if (hour < 0 || hour > 23) throw new IllegalArgumentException();
-    if (minute < 0 || minute > 59) throw new IllegalArgumentException();
-    if (second < 0 || second > 59) throw new IllegalArgumentException();
-
-    Calendar calendar = new GregorianCalendar(UTC);
-    calendar.setLenient(false);
-    calendar.set(Calendar.YEAR, year);
-    calendar.set(Calendar.MONTH, month - 1);
-    calendar.set(Calendar.DAY_OF_MONTH, dayOfMonth);
-    calendar.set(Calendar.HOUR_OF_DAY, hour);
-    calendar.set(Calendar.MINUTE, minute);
-    calendar.set(Calendar.SECOND, second);
-    calendar.set(Calendar.MILLISECOND, 0);
-    return calendar.getTimeInMillis();
-  }
-
-  /**
-   * Returns the index of the next date character in {@code input}, or if {@code invert} the index
-   * of the next non-date character in {@code input}.
-   */
-  private static int dateCharacterOffset(String input, int pos, int limit, boolean invert) {
-    for (int i = pos; i < limit; i++) {
-      int c = input.charAt(i);
-      boolean dateCharacter = (c < ' ' && c != '\t') || (c >= '\u007f')
-          || (c >= '0' && c <= '9')
-          || (c >= 'a' && c <= 'z')
-          || (c >= 'A' && c <= 'Z')
-          || (c == ':');
-      if (dateCharacter == !invert) return i;
-    }
-    return limit;
-  }
-
-  /**
-   * Returns the positive value if {@code attributeValue} is positive, or {@link Long#MIN_VALUE} if
-   * it is either 0 or negative. If the value is positive but out of range, this returns {@link
-   * Long#MAX_VALUE}.
-   *
-   * @throws NumberFormatException if {@code s} is not an integer of any precision.
-   */
-  private static long parseMaxAge(String s) {
-    try {
-      long parsed = Long.parseLong(s);
-      return parsed <= 0L ? Long.MIN_VALUE : parsed;
-    } catch (NumberFormatException e) {
-      // Check if the value is an integer (positive or negative) that's too big for a long.
-      if (s.matches("-?\\d+")) {
-        return s.startsWith("-") ? Long.MIN_VALUE : Long.MAX_VALUE;
-      }
-      throw e;
-    }
-  }
-
-  /**
-   * Returns a domain string like {@code example.com} for an input domain like {@code EXAMPLE.COM}
-   * or {@code .example.com}.
-   */
-  private static String parseDomain(String s) {
-    if (s.endsWith(".")) {
-      throw new IllegalArgumentException();
-    }
-    if (s.startsWith(".")) {
-      s = s.substring(1);
-    }
-    String canonicalDomain = canonicalizeHost(s);
-    if (canonicalDomain == null) {
-      throw new IllegalArgumentException();
-    }
-    return canonicalDomain;
-  }
-
-  /** Returns all of the cookies from a set of HTTP response headers. */
-  public static List<Cookie> parseAll(HttpUrl url, Headers headers) {
-    List<String> cookieStrings = headers.values("Set-Cookie");
-    List<Cookie> cookies = null;
-
-    for (int i = 0, size = cookieStrings.size(); i < size; i++) {
-      Cookie cookie = Cookie.parse(url, cookieStrings.get(i));
-      if (cookie == null) continue;
-      if (cookies == null) cookies = new ArrayList<>();
-      cookies.add(cookie);
-    }
-
-    return cookies != null
-        ? Collections.unmodifiableList(cookies)
-        : Collections.emptyList();
-  }
-
-  /**
-   * Builds a cookie. The {@linkplain #name() name}, {@linkplain #value() value}, and {@linkplain
-   * #domain() domain} values must all be set before calling {@link #build}.
-   */
-  public static final class Builder {
-    @Nullable String name;
-    @Nullable String value;
-    long expiresAt = HttpDate.MAX_DATE;
-    @Nullable String domain;
-    String path = "/";
-    boolean secure;
-    boolean httpOnly;
-    boolean persistent;
-    boolean hostOnly;
-
-    public Builder name(String name) {
-      if (name == null) throw new NullPointerException("name == null");
-      if (!name.trim().equals(name)) throw new IllegalArgumentException("name is not trimmed");
-      this.name = name;
-      return this;
-    }
-
-    public Builder value(String value) {
-      if (value == null) throw new NullPointerException("value == null");
-      if (!value.trim().equals(value)) throw new IllegalArgumentException("value is not trimmed");
-      this.value = value;
-      return this;
-    }
-
-    public Builder expiresAt(long expiresAt) {
-      if (expiresAt <= 0) expiresAt = Long.MIN_VALUE;
-      if (expiresAt > HttpDate.MAX_DATE) expiresAt = HttpDate.MAX_DATE;
-      this.expiresAt = expiresAt;
-      this.persistent = true;
-      return this;
-    }
-
-    /**
-     * Set the domain pattern for this cookie. The cookie will match {@code domain} and all of its
-     * subdomains.
-     */
-    public Builder domain(String domain) {
-      return domain(domain, false);
-    }
-
-    /**
-     * Set the host-only domain for this cookie. The cookie will match {@code domain} but none of
-     * its subdomains.
-     */
-    public Builder hostOnlyDomain(String domain) {
-      return domain(domain, true);
-    }
-
-    private Builder domain(String domain, boolean hostOnly) {
-      if (domain == null) throw new NullPointerException("domain == null");
-      String canonicalDomain = Util.canonicalizeHost(domain);
-      if (canonicalDomain == null) {
-        throw new IllegalArgumentException("unexpected domain: " + domain);
-      }
-      this.domain = canonicalDomain;
-      this.hostOnly = hostOnly;
-      return this;
-    }
-
-    public Builder path(String path) {
-      if (!path.startsWith("/")) throw new IllegalArgumentException("path must start with '/'");
-      this.path = path;
-      return this;
-    }
-
-    public Builder secure() {
-      this.secure = true;
-      return this;
-    }
-
-    public Builder httpOnly() {
-      this.httpOnly = true;
-      return this;
-    }
-
-    public Cookie build() {
-      return new Cookie(this);
-    }
-  }
-
-  @Override public String toString() {
-    return toString(false);
-  }
-
-  /**
-   * @param forObsoleteRfc2965 true to include a leading {@code .} on the domain pattern. This is
-   *     necessary for {@code example.com} to match {@code www.example.com} under RFC 2965. This
-   *     extra dot is ignored by more recent specifications.
-   */
-  String toString(boolean forObsoleteRfc2965) {
-    StringBuilder result = new StringBuilder();
-    result.append(name);
-    result.append('=');
-    result.append(value);
-
-    if (persistent) {
-      if (expiresAt == Long.MIN_VALUE) {
-        result.append("; max-age=0");
-      } else {
-        result.append("; expires=").append(HttpDate.format(new Date(expiresAt)));
-      }
-    }
-
-    if (!hostOnly) {
-      result.append("; domain=");
-      if (forObsoleteRfc2965) {
-        result.append(".");
-      }
-      result.append(domain);
-    }
-
-    result.append("; path=").append(path);
-
-    if (secure) {
-      result.append("; secure");
-    }
-
-    if (httpOnly) {
-      result.append("; httponly");
-    }
-
-    return result.toString();
-  }
-
-  @Override public boolean equals(@Nullable Object other) {
-    if (!(other instanceof Cookie)) return false;
-    Cookie that = (Cookie) other;
-    return that.name.equals(name)
-        && that.value.equals(value)
-        && that.domain.equals(domain)
-        && that.path.equals(path)
-        && that.expiresAt == expiresAt
-        && that.secure == secure
-        && that.httpOnly == httpOnly
-        && that.persistent == persistent
-        && that.hostOnly == hostOnly;
-  }
-
-  @Override public int hashCode() {
-    int hash = 17;
-    hash = 31 * hash + name.hashCode();
-    hash = 31 * hash + value.hashCode();
-    hash = 31 * hash + domain.hashCode();
-    hash = 31 * hash + path.hashCode();
-    hash = 31 * hash + (int) (expiresAt ^ (expiresAt >>> 32));
-    hash = 31 * hash + (secure ? 0 : 1);
-    hash = 31 * hash + (httpOnly ? 0 : 1);
-    hash = 31 * hash + (persistent ? 0 : 1);
-    hash = 31 * hash + (hostOnly ? 0 : 1);
-    return hash;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/CookieJar.java b/okhttp/src/main/java/okhttp3/CookieJar.java
deleted file mode 100644
index bdb3cd552e..0000000000
--- a/okhttp/src/main/java/okhttp3/CookieJar.java
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.util.Collections;
-import java.util.List;
-
-/**
- * Provides <strong>policy</strong> and <strong>persistence</strong> for HTTP cookies.
- *
- * <p>As policy, implementations of this interface are responsible for selecting which cookies to
- * accept and which to reject. A reasonable policy is to reject all cookies, though that may
- * interfere with session-based authentication schemes that require cookies.
- *
- * <p>As persistence, implementations of this interface must also provide storage of cookies. Simple
- * implementations may store cookies in memory; sophisticated ones may use the file system or
- * database to hold accepted cookies. The <a
- * href="https://tools.ietf.org/html/rfc6265#section-5.3">cookie storage model</a> specifies
- * policies for updating and expiring cookies.
- */
-public interface CookieJar {
-  /** A cookie jar that never accepts any cookies. */
-  CookieJar NO_COOKIES = new CookieJar() {
-    @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {
-    }
-
-    @Override public List<Cookie> loadForRequest(HttpUrl url) {
-      return Collections.emptyList();
-    }
-  };
-
-  /**
-   * Saves {@code cookies} from an HTTP response to this store according to this jar's policy.
-   *
-   * <p>Note that this method may be called a second time for a single HTTP response if the response
-   * includes a trailer. For this obscure HTTP feature, {@code cookies} contains only the trailer's
-   * cookies.
-   */
-  void saveFromResponse(HttpUrl url, List<Cookie> cookies);
-
-  /**
-   * Load cookies from the jar for an HTTP request to {@code url}. This method returns a possibly
-   * empty list of cookies for the network request.
-   *
-   * <p>Simple implementations will return the accepted cookies that have not yet expired and that
-   * {@linkplain Cookie#matches match} {@code url}.
-   */
-  List<Cookie> loadForRequest(HttpUrl url);
-}
diff --git a/okhttp/src/main/java/okhttp3/Credentials.java b/okhttp/src/main/java/okhttp3/Credentials.java
deleted file mode 100644
index c06c1d61f0..0000000000
--- a/okhttp/src/main/java/okhttp3/Credentials.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.nio.charset.Charset;
-import okio.ByteString;
-
-import static java.nio.charset.StandardCharsets.ISO_8859_1;
-
-/** Factory for HTTP authorization credentials. */
-public final class Credentials {
-  private Credentials() {
-  }
-
-  /** Returns an auth credential for the Basic scheme. */
-  public static String basic(String username, String password) {
-    return basic(username, password, ISO_8859_1);
-  }
-
-  public static String basic(String username, String password, Charset charset) {
-    String usernameAndPassword = username + ":" + password;
-    String encoded = ByteString.encodeString(usernameAndPassword, charset).base64();
-    return "Basic " + encoded;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Dispatcher.java b/okhttp/src/main/java/okhttp3/Dispatcher.java
deleted file mode 100644
index d21e9df1b9..0000000000
--- a/okhttp/src/main/java/okhttp3/Dispatcher.java
+++ /dev/null
@@ -1,266 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.util.ArrayDeque;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Deque;
-import java.util.Iterator;
-import java.util.List;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.SynchronousQueue;
-import java.util.concurrent.ThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;
-import javax.annotation.Nullable;
-import okhttp3.RealCall.AsyncCall;
-import okhttp3.internal.Util;
-
-/**
- * Policy on when async requests are executed.
- *
- * <p>Each dispatcher uses an {@link ExecutorService} to run calls internally. If you supply your
- * own executor, it should be able to run {@linkplain #getMaxRequests the configured maximum} number
- * of calls concurrently.
- */
-public final class Dispatcher {
-  private int maxRequests = 64;
-  private int maxRequestsPerHost = 5;
-  private @Nullable Runnable idleCallback;
-
-  /** Executes calls. Created lazily. */
-  private @Nullable ExecutorService executorService;
-
-  /** Ready async calls in the order they'll be run. */
-  private final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<>();
-
-  /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */
-  private final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();
-
-  /** Running synchronous calls. Includes canceled calls that haven't finished yet. */
-  private final Deque<RealCall> runningSyncCalls = new ArrayDeque<>();
-
-  public Dispatcher(ExecutorService executorService) {
-    this.executorService = executorService;
-  }
-
-  public Dispatcher() {
-  }
-
-  public synchronized ExecutorService executorService() {
-    if (executorService == null) {
-      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,
-          new SynchronousQueue<>(), Util.threadFactory("OkHttp Dispatcher", false));
-    }
-    return executorService;
-  }
-
-  /**
-   * Set the maximum number of requests to execute concurrently. Above this requests queue in
-   * memory, waiting for the running calls to complete.
-   *
-   * <p>If more than {@code maxRequests} requests are in flight when this is invoked, those requests
-   * will remain in flight.
-   */
-  public void setMaxRequests(int maxRequests) {
-    if (maxRequests < 1) {
-      throw new IllegalArgumentException("max < 1: " + maxRequests);
-    }
-    synchronized (this) {
-      this.maxRequests = maxRequests;
-    }
-    promoteAndExecute();
-  }
-
-  public synchronized int getMaxRequests() {
-    return maxRequests;
-  }
-
-  /**
-   * Set the maximum number of requests for each host to execute concurrently. This limits requests
-   * by the URL's host name. Note that concurrent requests to a single IP address may still exceed
-   * this limit: multiple hostnames may share an IP address or be routed through the same HTTP
-   * proxy.
-   *
-   * <p>If more than {@code maxRequestsPerHost} requests are in flight when this is invoked, those
-   * requests will remain in flight.
-   *
-   * <p>WebSocket connections to hosts <b>do not</b> count against this limit.
-   */
-  public void setMaxRequestsPerHost(int maxRequestsPerHost) {
-    if (maxRequestsPerHost < 1) {
-      throw new IllegalArgumentException("max < 1: " + maxRequestsPerHost);
-    }
-    synchronized (this) {
-      this.maxRequestsPerHost = maxRequestsPerHost;
-    }
-    promoteAndExecute();
-  }
-
-  public synchronized int getMaxRequestsPerHost() {
-    return maxRequestsPerHost;
-  }
-
-  /**
-   * Set a callback to be invoked each time the dispatcher becomes idle (when the number of running
-   * calls returns to zero).
-   *
-   * <p>Note: The time at which a {@linkplain Call call} is considered idle is different depending
-   * on whether it was run {@linkplain Call#enqueue(Callback) asynchronously} or
-   * {@linkplain Call#execute() synchronously}. Asynchronous calls become idle after the
-   * {@link Callback#onResponse onResponse} or {@link Callback#onFailure onFailure} callback has
-   * returned. Synchronous calls become idle once {@link Call#execute() execute()} returns. This
-   * means that if you are doing synchronous calls the network layer will not truly be idle until
-   * every returned {@link Response} has been closed.
-   */
-  public synchronized void setIdleCallback(@Nullable Runnable idleCallback) {
-    this.idleCallback = idleCallback;
-  }
-
-  void enqueue(AsyncCall call) {
-    synchronized (this) {
-      readyAsyncCalls.add(call);
-
-      // Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to
-      // the same host.
-      if (!call.get().forWebSocket) {
-        AsyncCall existingCall = findExistingCallWithHost(call.host());
-        if (existingCall != null) call.reuseCallsPerHostFrom(existingCall);
-      }
-    }
-    promoteAndExecute();
-  }
-
-  @Nullable private AsyncCall findExistingCallWithHost(String host) {
-    for (AsyncCall existingCall : runningAsyncCalls) {
-      if (existingCall.host().equals(host)) return existingCall;
-    }
-    for (AsyncCall existingCall : readyAsyncCalls) {
-      if (existingCall.host().equals(host)) return existingCall;
-    }
-    return null;
-  }
-
-  /**
-   * Cancel all calls currently enqueued or executing. Includes calls executed both {@linkplain
-   * Call#execute() synchronously} and {@linkplain Call#enqueue asynchronously}.
-   */
-  public synchronized void cancelAll() {
-    for (AsyncCall call : readyAsyncCalls) {
-      call.get().cancel();
-    }
-
-    for (AsyncCall call : runningAsyncCalls) {
-      call.get().cancel();
-    }
-
-    for (RealCall call : runningSyncCalls) {
-      call.cancel();
-    }
-  }
-
-  /**
-   * Promotes eligible calls from {@link #readyAsyncCalls} to {@link #runningAsyncCalls} and runs
-   * them on the executor service. Must not be called with synchronization because executing calls
-   * can call into user code.
-   *
-   * @return true if the dispatcher is currently running calls.
-   */
-  private boolean promoteAndExecute() {
-    assert (!Thread.holdsLock(this));
-
-    List<AsyncCall> executableCalls = new ArrayList<>();
-    boolean isRunning;
-    synchronized (this) {
-      for (Iterator<AsyncCall> i = readyAsyncCalls.iterator(); i.hasNext(); ) {
-        AsyncCall asyncCall = i.next();
-
-        if (runningAsyncCalls.size() >= maxRequests) break; // Max capacity.
-        if (asyncCall.callsPerHost().get() >= maxRequestsPerHost) continue; // Host max capacity.
-
-        i.remove();
-        asyncCall.callsPerHost().incrementAndGet();
-        executableCalls.add(asyncCall);
-        runningAsyncCalls.add(asyncCall);
-      }
-      isRunning = runningCallsCount() > 0;
-    }
-
-    for (int i = 0, size = executableCalls.size(); i < size; i++) {
-      AsyncCall asyncCall = executableCalls.get(i);
-      asyncCall.executeOn(executorService());
-    }
-
-    return isRunning;
-  }
-
-  /** Used by {@code Call#execute} to signal it is in-flight. */
-  synchronized void executed(RealCall call) {
-    runningSyncCalls.add(call);
-  }
-
-  /** Used by {@code AsyncCall#run} to signal completion. */
-  void finished(AsyncCall call) {
-    call.callsPerHost().decrementAndGet();
-    finished(runningAsyncCalls, call);
-  }
-
-  /** Used by {@code Call#execute} to signal completion. */
-  void finished(RealCall call) {
-    finished(runningSyncCalls, call);
-  }
-
-  private <T> void finished(Deque<T> calls, T call) {
-    Runnable idleCallback;
-    synchronized (this) {
-      if (!calls.remove(call)) throw new AssertionError("Call wasn't in-flight!");
-      idleCallback = this.idleCallback;
-    }
-
-    boolean isRunning = promoteAndExecute();
-
-    if (!isRunning && idleCallback != null) {
-      idleCallback.run();
-    }
-  }
-
-  /** Returns a snapshot of the calls currently awaiting execution. */
-  public synchronized List<Call> queuedCalls() {
-    List<Call> result = new ArrayList<>();
-    for (AsyncCall asyncCall : readyAsyncCalls) {
-      result.add(asyncCall.get());
-    }
-    return Collections.unmodifiableList(result);
-  }
-
-  /** Returns a snapshot of the calls currently being executed. */
-  public synchronized List<Call> runningCalls() {
-    List<Call> result = new ArrayList<>();
-    result.addAll(runningSyncCalls);
-    for (AsyncCall asyncCall : runningAsyncCalls) {
-      result.add(asyncCall.get());
-    }
-    return Collections.unmodifiableList(result);
-  }
-
-  public synchronized int queuedCallsCount() {
-    return readyAsyncCalls.size();
-  }
-
-  public synchronized int runningCallsCount() {
-    return runningAsyncCalls.size() + runningSyncCalls.size();
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Dns.java b/okhttp/src/main/java/okhttp3/Dns.java
deleted file mode 100644
index feba0db7c9..0000000000
--- a/okhttp/src/main/java/okhttp3/Dns.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.util.Arrays;
-import java.util.List;
-
-/**
- * A domain name service that resolves IP addresses for host names. Most applications will use the
- * {@linkplain #SYSTEM system DNS service}, which is the default. Some applications may provide
- * their own implementation to use a different DNS server, to prefer IPv6 addresses, to prefer IPv4
- * addresses, or to force a specific known IP address.
- *
- * <p>Implementations of this interface must be safe for concurrent use.
- */
-public interface Dns {
-  /**
-   * A DNS that uses {@link InetAddress#getAllByName} to ask the underlying operating system to
-   * lookup IP addresses. Most custom {@link Dns} implementations should delegate to this instance.
-   */
-  Dns SYSTEM = hostname -> {
-    if (hostname == null) throw new UnknownHostException("hostname == null");
-    try {
-      return Arrays.asList(InetAddress.getAllByName(hostname));
-    } catch (NullPointerException e) {
-      UnknownHostException unknownHostException =
-          new UnknownHostException("Broken system behaviour for dns lookup of " + hostname);
-      unknownHostException.initCause(e);
-      throw unknownHostException;
-    }
-  };
-
-  /**
-   * Returns the IP addresses of {@code hostname}, in the order they will be attempted by OkHttp. If
-   * a connection to an address fails, OkHttp will retry the connection with the next address until
-   * either a connection is made, the set of IP addresses is exhausted, or a limit is exceeded.
-   */
-  List<InetAddress> lookup(String hostname) throws UnknownHostException;
-}
diff --git a/okhttp/src/main/java/okhttp3/EventListener.java b/okhttp/src/main/java/okhttp3/EventListener.java
deleted file mode 100644
index 28f3467982..0000000000
--- a/okhttp/src/main/java/okhttp3/EventListener.java
+++ /dev/null
@@ -1,307 +0,0 @@
-/*
- * Copyright (C) 2017 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import java.util.List;
-import javax.annotation.Nullable;
-
-/**
- * Listener for metrics events. Extend this class to monitor the quantity, size, and duration of
- * your application's HTTP calls.
- *
- * <p>All start/connect/acquire events will eventually receive a matching end/release event,
- * either successful (non-null parameters), or failed (non-null throwable).  The first common
- * parameters of each event pair are used to link the event in case of concurrent or repeated
- * events e.g. dnsStart(call, domainName) -&gt; dnsEnd(call, domainName, inetAddressList).
- *
- * <p>Nesting is as follows
- * <ul>
- *   <li>call -&gt; (dns -&gt; connect -&gt; secure connect)* -&gt; request events</li>
- *   <li>call -&gt; (connection acquire/release)*</li>
- * </ul>
- *
- * <p>Request events are ordered:
- * requestHeaders -&gt; requestBody -&gt; responseHeaders -&gt; responseBody
- *
- * <p>Since connections may be reused, the dns and connect events may not be present for a call,
- * or may be repeated in case of failure retries, even concurrently in case of happy eyeballs type
- * scenarios. A redirect cross domain, or to use https may cause additional connection and request
- * events.
- *
- * <p>All event methods must execute fast, without external locking, cannot throw exceptions,
- * attempt to mutate the event parameters, or be re-entrant back into the client.
- * Any IO - writing to files or network should be done asynchronously.
- */
-public abstract class EventListener {
-  public static final EventListener NONE = new EventListener() {
-  };
-
-  static EventListener.Factory factory(EventListener listener) {
-    return call -> listener;
-  }
-
-  /**
-   * Invoked as soon as a call is enqueued or executed by a client. In case of thread or stream
-   * limits, this call may be executed well before processing the request is able to begin.
-   *
-   * <p>This will be invoked only once for a single {@link Call}. Retries of different routes
-   * or redirects will be handled within the boundaries of a single callStart and {@link
-   * #callEnd}/{@link #callFailed} pair.
-   */
-  public void callStart(Call call) {
-  }
-
-  /**
-   * Invoked just prior to a DNS lookup. See {@link Dns#lookup(String)}.
-   *
-   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
-   * to the {@link Call#request()} is a redirect to a different host.
-   *
-   * <p>If the {@link Call} is able to reuse an existing pooled connection, this method will not be
-   * invoked. See {@link ConnectionPool}.
-   */
-  public void dnsStart(Call call, String domainName) {
-  }
-
-  /**
-   * Invoked immediately after a DNS lookup.
-   *
-   * <p>This method is invoked after {@link #dnsStart}.
-   */
-  public void dnsEnd(Call call, String domainName, List<InetAddress> inetAddressList) {
-  }
-
-  /**
-   * Invoked just prior to initiating a socket connection.
-   *
-   * <p>This method will be invoked if no existing connection in the {@link ConnectionPool} can be
-   * reused.
-   *
-   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
-   * to the {@link Call#request()} is a redirect to a different address, or a connection is retried.
-   */
-  public void connectStart(Call call, InetSocketAddress inetSocketAddress, Proxy proxy) {
-  }
-
-  /**
-   * Invoked just prior to initiating a TLS connection.
-   *
-   * <p>This method is invoked if the following conditions are met:
-   * <ul>
-   * <li>The {@link Call#request()} requires TLS.</li>
-   * <li>No existing connection from the {@link ConnectionPool} can be reused.</li>
-   * </ul>
-   *
-   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
-   * to the {@link Call#request()} is a redirect to a different address, or a connection is retried.
-   */
-  public void secureConnectStart(Call call) {
-  }
-
-  /**
-   * Invoked immediately after a TLS connection was attempted.
-   *
-   * <p>This method is invoked after {@link #secureConnectStart}.
-   */
-  public void secureConnectEnd(Call call, @Nullable Handshake handshake) {
-  }
-
-  /**
-   * Invoked immediately after a socket connection was attempted.
-   *
-   * <p>If the {@code call} uses HTTPS, this will be invoked after
-   * {@link #secureConnectEnd(Call, Handshake)}, otherwise it will invoked after
-   * {@link #connectStart(Call, InetSocketAddress, Proxy)}.
-   */
-  public void connectEnd(Call call, InetSocketAddress inetSocketAddress, Proxy proxy,
-      @Nullable Protocol protocol) {
-  }
-
-  /**
-   * Invoked when a connection attempt fails. This failure is not terminal if further routes are
-   * available and failure recovery is enabled.
-   *
-   * <p>If the {@code call} uses HTTPS, this will be invoked after {@link #secureConnectEnd(Call,
-   * Handshake)}, otherwise it will invoked after {@link #connectStart(Call, InetSocketAddress,
-   * Proxy)}.
-   */
-  public void connectFailed(Call call, InetSocketAddress inetSocketAddress, Proxy proxy,
-      @Nullable Protocol protocol, IOException ioe) {
-  }
-
-  /**
-   * Invoked after a connection has been acquired for the {@code call}.
-   *
-   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
-   * to the {@link Call#request()} is a redirect to a different address.
-   */
-  public void connectionAcquired(Call call, Connection connection) {
-  }
-
-  /**
-   * Invoked after a connection has been released for the {@code call}.
-   *
-   * <p>This method is always invoked after {@link #connectionAcquired(Call, Connection)}.
-   *
-   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
-   * to the {@link Call#request()} is a redirect to a different address.
-   */
-  public void connectionReleased(Call call, Connection connection) {
-  }
-
-  /**
-   * Invoked just prior to sending request headers.
-   *
-   * <p>The connection is implicit, and will generally relate to the last
-   * {@link #connectionAcquired(Call, Connection)} event.
-   *
-   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
-   * to the {@link Call#request()} is a redirect to a different address.
-   */
-  public void requestHeadersStart(Call call) {
-  }
-
-  /**
-   * Invoked immediately after sending request headers.
-   *
-   * <p>This method is always invoked after {@link #requestHeadersStart(Call)}.
-   *
-   * @param request the request sent over the network. It is an error to access the body of this
-   *     request.
-   */
-  public void requestHeadersEnd(Call call, Request request) {
-  }
-
-  /**
-   * Invoked just prior to sending a request body.  Will only be invoked for request allowing and
-   * having a request body to send.
-   *
-   * <p>The connection is implicit, and will generally relate to the last
-   * {@link #connectionAcquired(Call, Connection)} event.
-   *
-   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
-   * to the {@link Call#request()} is a redirect to a different address.
-   */
-  public void requestBodyStart(Call call) {
-  }
-
-  /**
-   * Invoked immediately after sending a request body.
-   *
-   * <p>This method is always invoked after {@link #requestBodyStart(Call)}.
-   */
-  public void requestBodyEnd(Call call, long byteCount) {
-  }
-
-  /**
-   * Invoked when a request fails to be written.
-   *
-   * <p>This method is invoked after {@link #requestHeadersStart} or {@link #requestBodyStart}. Note
-   * that request failures do not necessarily fail the entire call.
-   */
-  public void requestFailed(Call call, IOException ioe) {
-  }
-
-  /**
-   * Invoked just prior to receiving response headers.
-   *
-   * <p>The connection is implicit, and will generally relate to the last
-   * {@link #connectionAcquired(Call, Connection)} event.
-   *
-   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
-   * to the {@link Call#request()} is a redirect to a different address.
-   */
-  public void responseHeadersStart(Call call) {
-  }
-
-  /**
-   * Invoked immediately after receiving response headers.
-   *
-   * <p>This method is always invoked after {@link #responseHeadersStart}.
-   *
-   * @param response the response received over the network. It is an error to access the body of
-   *     this response.
-   */
-  public void responseHeadersEnd(Call call, Response response) {
-  }
-
-  /**
-   * Invoked just prior to receiving the response body.
-   *
-   * <p>The connection is implicit, and will generally relate to the last
-   * {@link #connectionAcquired(Call, Connection)} event.
-   *
-   * <p>This will usually be invoked only 1 time for a single {@link Call},
-   * exceptions are a limited set of cases including failure recovery.
-   */
-  public void responseBodyStart(Call call) {
-  }
-
-  /**
-   * Invoked immediately after receiving a response body and completing reading it.
-   *
-   * <p>Will only be invoked for requests having a response body e.g. won't be invoked for a
-   * websocket upgrade.
-   *
-   * <p>This method is always invoked after {@link #requestBodyStart(Call)}.
-   */
-  public void responseBodyEnd(Call call, long byteCount) {
-  }
-
-  /**
-   * Invoked when a response fails to be read.
-   *
-   * <p>This method is invoked after {@link #responseHeadersStart} or {@link #responseBodyStart}.
-   * Note that response failures do not necessarily fail the entire call.
-   */
-  public void responseFailed(Call call, IOException ioe) {
-  }
-
-  /**
-   * Invoked immediately after a call has completely ended.  This includes delayed consumption
-   * of response body by the caller.
-   *
-   * <p>This method is always invoked after {@link #callStart(Call)}.
-   */
-  public void callEnd(Call call) {
-  }
-
-  /**
-   * Invoked when a call fails permanently.
-   *
-   * <p>This method is always invoked after {@link #callStart(Call)}.
-   */
-  public void callFailed(Call call, IOException ioe) {
-  }
-
-  public interface Factory {
-    /**
-     * Creates an instance of the {@link EventListener} for a particular {@link Call}. The returned
-     * {@link EventListener} instance will be used during the lifecycle of the {@code call}.
-     *
-     * <p>This method is invoked after the {@code call} is created. See
-     * {@link OkHttpClient#newCall(Request)}.
-     *
-     * <p><strong>It is an error for implementations to issue any mutating operations on the
-     * {@code call} instance from this method.</strong>
-     */
-    EventListener create(Call call);
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/FormBody.java b/okhttp/src/main/java/okhttp3/FormBody.java
deleted file mode 100644
index 4216daccd5..0000000000
--- a/okhttp/src/main/java/okhttp3/FormBody.java
+++ /dev/null
@@ -1,140 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.nio.charset.Charset;
-import java.util.ArrayList;
-import java.util.List;
-import javax.annotation.Nullable;
-import okhttp3.internal.Util;
-import okio.Buffer;
-import okio.BufferedSink;
-
-import static okhttp3.HttpUrl.FORM_ENCODE_SET;
-import static okhttp3.HttpUrl.percentDecode;
-
-public final class FormBody extends RequestBody {
-  private static final MediaType CONTENT_TYPE = MediaType.get("application/x-www-form-urlencoded");
-
-  private final List<String> encodedNames;
-  private final List<String> encodedValues;
-
-  FormBody(List<String> encodedNames, List<String> encodedValues) {
-    this.encodedNames = Util.immutableList(encodedNames);
-    this.encodedValues = Util.immutableList(encodedValues);
-  }
-
-  /** The number of key-value pairs in this form-encoded body. */
-  public int size() {
-    return encodedNames.size();
-  }
-
-  public String encodedName(int index) {
-    return encodedNames.get(index);
-  }
-
-  public String name(int index) {
-    return percentDecode(encodedName(index), true);
-  }
-
-  public String encodedValue(int index) {
-    return encodedValues.get(index);
-  }
-
-  public String value(int index) {
-    return percentDecode(encodedValue(index), true);
-  }
-
-  @Override public MediaType contentType() {
-    return CONTENT_TYPE;
-  }
-
-  @Override public long contentLength() {
-    return writeOrCountBytes(null, true);
-  }
-
-  @Override public void writeTo(BufferedSink sink) throws IOException {
-    writeOrCountBytes(sink, false);
-  }
-
-  /**
-   * Either writes this request to {@code sink} or measures its content length. We have one method
-   * do double-duty to make sure the counting and content are consistent, particularly when it comes
-   * to awkward operations like measuring the encoded length of header strings, or the
-   * length-in-digits of an encoded integer.
-   */
-  private long writeOrCountBytes(@Nullable BufferedSink sink, boolean countBytes) {
-    long byteCount = 0L;
-
-    Buffer buffer;
-    if (countBytes) {
-      buffer = new Buffer();
-    } else {
-      buffer = sink.buffer();
-    }
-
-    for (int i = 0, size = encodedNames.size(); i < size; i++) {
-      if (i > 0) buffer.writeByte('&');
-      buffer.writeUtf8(encodedNames.get(i));
-      buffer.writeByte('=');
-      buffer.writeUtf8(encodedValues.get(i));
-    }
-
-    if (countBytes) {
-      byteCount = buffer.size();
-      buffer.clear();
-    }
-
-    return byteCount;
-  }
-
-  public static final class Builder {
-    private final List<String> names = new ArrayList<>();
-    private final List<String> values = new ArrayList<>();
-    private final @Nullable Charset charset;
-
-    public Builder() {
-      this(null);
-    }
-
-    public Builder(@Nullable Charset charset) {
-      this.charset = charset;
-    }
-
-    public Builder add(String name, String value) {
-      if (name == null) throw new NullPointerException("name == null");
-      if (value == null) throw new NullPointerException("value == null");
-
-      names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, false, false, true, true, charset));
-      values.add(HttpUrl.canonicalize(value, FORM_ENCODE_SET, false, false, true, true, charset));
-      return this;
-    }
-
-    public Builder addEncoded(String name, String value) {
-      if (name == null) throw new NullPointerException("name == null");
-      if (value == null) throw new NullPointerException("value == null");
-
-      names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, true, false, true, true, charset));
-      values.add(HttpUrl.canonicalize(value, FORM_ENCODE_SET, true, false, true, true, charset));
-      return this;
-    }
-
-    public FormBody build() {
-      return new FormBody(names, values);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Handshake.java b/okhttp/src/main/java/okhttp3/Handshake.java
deleted file mode 100644
index d2740c8f87..0000000000
--- a/okhttp/src/main/java/okhttp3/Handshake.java
+++ /dev/null
@@ -1,171 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.security.Principal;
-import java.security.cert.Certificate;
-import java.security.cert.X509Certificate;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import javax.annotation.Nullable;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSession;
-import okhttp3.internal.Util;
-
-/**
- * A record of a TLS handshake. For HTTPS clients, the client is <i>local</i> and the remote server
- * is its <i>peer</i>.
- *
- * <p>This value object describes a completed handshake. Use {@link ConnectionSpec} to set policy
- * for new handshakes.
- */
-public final class Handshake {
-  private final TlsVersion tlsVersion;
-  private final CipherSuite cipherSuite;
-  private final List<Certificate> peerCertificates;
-  private final List<Certificate> localCertificates;
-
-  private Handshake(TlsVersion tlsVersion, CipherSuite cipherSuite,
-      List<Certificate> peerCertificates, List<Certificate> localCertificates) {
-    this.tlsVersion = tlsVersion;
-    this.cipherSuite = cipherSuite;
-    this.peerCertificates = peerCertificates;
-    this.localCertificates = localCertificates;
-  }
-
-  public static Handshake get(SSLSession session) throws IOException {
-    String cipherSuiteString = session.getCipherSuite();
-    if (cipherSuiteString == null) throw new IllegalStateException("cipherSuite == null");
-    if ("SSL_NULL_WITH_NULL_NULL".equals(cipherSuiteString)) {
-      throw new IOException("cipherSuite == SSL_NULL_WITH_NULL_NULL");
-    }
-    CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);
-
-    String tlsVersionString = session.getProtocol();
-    if (tlsVersionString == null) throw new IllegalStateException("tlsVersion == null");
-    if ("NONE".equals(tlsVersionString)) throw new IOException("tlsVersion == NONE");
-    TlsVersion tlsVersion = TlsVersion.forJavaName(tlsVersionString);
-
-    Certificate[] peerCertificates;
-    try {
-      peerCertificates = session.getPeerCertificates();
-    } catch (SSLPeerUnverifiedException ignored) {
-      peerCertificates = null;
-    }
-    List<Certificate> peerCertificatesList = peerCertificates != null
-        ? Util.immutableList(peerCertificates)
-        : Collections.emptyList();
-
-    Certificate[] localCertificates = session.getLocalCertificates();
-    List<Certificate> localCertificatesList = localCertificates != null
-        ? Util.immutableList(localCertificates)
-        : Collections.emptyList();
-
-    return new Handshake(tlsVersion, cipherSuite, peerCertificatesList, localCertificatesList);
-  }
-
-  public static Handshake get(TlsVersion tlsVersion, CipherSuite cipherSuite,
-      List<Certificate> peerCertificates, List<Certificate> localCertificates) {
-    if (tlsVersion == null) throw new NullPointerException("tlsVersion == null");
-    if (cipherSuite == null) throw new NullPointerException("cipherSuite == null");
-    return new Handshake(tlsVersion, cipherSuite, Util.immutableList(peerCertificates),
-        Util.immutableList(localCertificates));
-  }
-
-  /**
-   * Returns the TLS version used for this connection. This value wasn't tracked prior to OkHttp
-   * 3.0. For responses cached by preceding versions this returns {@link TlsVersion#SSL_3_0}.
-   */
-  public TlsVersion tlsVersion() {
-    return tlsVersion;
-  }
-
-  /** Returns the cipher suite used for the connection. */
-  public CipherSuite cipherSuite() {
-    return cipherSuite;
-  }
-
-  /** Returns a possibly-empty list of certificates that identify the remote peer. */
-  public List<Certificate> peerCertificates() {
-    return peerCertificates;
-  }
-
-  /** Returns the remote peer's principle, or null if that peer is anonymous. */
-  public @Nullable Principal peerPrincipal() {
-    return !peerCertificates.isEmpty()
-        ? ((X509Certificate) peerCertificates.get(0)).getSubjectX500Principal()
-        : null;
-  }
-
-  /** Returns a possibly-empty list of certificates that identify this peer. */
-  public List<Certificate> localCertificates() {
-    return localCertificates;
-  }
-
-  /** Returns the local principle, or null if this peer is anonymous. */
-  public @Nullable Principal localPrincipal() {
-    return !localCertificates.isEmpty()
-        ? ((X509Certificate) localCertificates.get(0)).getSubjectX500Principal()
-        : null;
-  }
-
-  @Override public boolean equals(@Nullable Object other) {
-    if (!(other instanceof Handshake)) return false;
-    Handshake that = (Handshake) other;
-    return tlsVersion.equals(that.tlsVersion)
-        && cipherSuite.equals(that.cipherSuite)
-        && peerCertificates.equals(that.peerCertificates)
-        && localCertificates.equals(that.localCertificates);
-  }
-
-  @Override public int hashCode() {
-    int result = 17;
-    result = 31 * result + tlsVersion.hashCode();
-    result = 31 * result + cipherSuite.hashCode();
-    result = 31 * result + peerCertificates.hashCode();
-    result = 31 * result + localCertificates.hashCode();
-    return result;
-  }
-
-  @Override public String toString() {
-    return "Handshake{"
-        + "tlsVersion="
-        + tlsVersion
-        + " cipherSuite="
-        + cipherSuite
-        + " peerCertificates="
-        + names(peerCertificates)
-        + " localCertificates="
-        + names(localCertificates)
-        + '}';
-  }
-
-  private List<String> names(List<Certificate> certificates) {
-    ArrayList<String> strings = new ArrayList<>();
-
-    for (Certificate cert : certificates) {
-      if (cert instanceof X509Certificate) {
-        strings.add(String.valueOf(((X509Certificate) cert).getSubjectDN()));
-      } else {
-        strings.add(cert.getType());
-      }
-    }
-
-    return strings;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Headers.java b/okhttp/src/main/java/okhttp3/Headers.java
deleted file mode 100644
index 06d2a96ccd..0000000000
--- a/okhttp/src/main/java/okhttp3/Headers.java
+++ /dev/null
@@ -1,435 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package okhttp3;
-
-import java.time.Instant;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Date;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.Set;
-import java.util.TreeMap;
-import java.util.TreeSet;
-import javax.annotation.Nullable;
-import okhttp3.internal.Util;
-import okhttp3.internal.http.HttpDate;
-import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
-
-/**
- * The header fields of a single HTTP message. Values are uninterpreted strings; use {@code Request}
- * and {@code Response} for interpreted headers. This class maintains the order of the header fields
- * within the HTTP message.
- *
- * <p>This class tracks header values line-by-line. A field with multiple comma- separated values on
- * the same line will be treated as a field with a single value by this class. It is the caller's
- * responsibility to detect and split on commas if their field permits multiple values. This
- * simplifies use of single-valued fields whose values routinely contain commas, such as cookies or
- * dates.
- *
- * <p>This class trims whitespace from values. It never returns values with leading or trailing
- * whitespace.
- *
- * <p>Instances of this class are immutable. Use {@link Builder} to create instances.
- */
-public final class Headers {
-  private final String[] namesAndValues;
-
-  Headers(Builder builder) {
-    this.namesAndValues = builder.namesAndValues.toArray(new String[builder.namesAndValues.size()]);
-  }
-
-  private Headers(String[] namesAndValues) {
-    this.namesAndValues = namesAndValues;
-  }
-
-  /** Returns the last value corresponding to the specified field, or null. */
-  public @Nullable String get(String name) {
-    return get(namesAndValues, name);
-  }
-
-  /**
-   * Returns the last value corresponding to the specified field parsed as an HTTP date, or null if
-   * either the field is absent or cannot be parsed as a date.
-   */
-  public @Nullable Date getDate(String name) {
-    String value = get(name);
-    return value != null ? HttpDate.parse(value) : null;
-  }
-
-  /**
-   * Returns the last value corresponding to the specified field parsed as an HTTP date, or null if
-   * either the field is absent or cannot be parsed as a date.
-   */
-  @IgnoreJRERequirement
-  public @Nullable Instant getInstant(String name) {
-    Date value = getDate(name);
-    return value != null ? value.toInstant() : null;
-  }
-
-  /** Returns the number of field values. */
-  public int size() {
-    return namesAndValues.length / 2;
-  }
-
-  /** Returns the field at {@code position}. */
-  public String name(int index) {
-    return namesAndValues[index * 2];
-  }
-
-  /** Returns the value at {@code index}. */
-  public String value(int index) {
-    return namesAndValues[index * 2 + 1];
-  }
-
-  /** Returns an immutable case-insensitive set of header names. */
-  public Set<String> names() {
-    TreeSet<String> result = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
-    for (int i = 0, size = size(); i < size; i++) {
-      result.add(name(i));
-    }
-    return Collections.unmodifiableSet(result);
-  }
-
-  /** Returns an immutable list of the header values for {@code name}. */
-  public List<String> values(String name) {
-    List<String> result = null;
-    for (int i = 0, size = size(); i < size; i++) {
-      if (name.equalsIgnoreCase(name(i))) {
-        if (result == null) result = new ArrayList<>(2);
-        result.add(value(i));
-      }
-    }
-    return result != null
-        ? Collections.unmodifiableList(result)
-        : Collections.emptyList();
-  }
-
-  /**
-   * Returns the number of bytes required to encode these headers using HTTP/1.1. This is also the
-   * approximate size of HTTP/2 headers before they are compressed with HPACK. This value is
-   * intended to be used as a metric: smaller headers are more efficient to encode and transmit.
-   */
-  public long byteCount() {
-    // Each header name has 2 bytes of overhead for ': ' and every header value has 2 bytes of
-    // overhead for '\r\n'.
-    long result = namesAndValues.length * 2;
-
-    for (int i = 0, size = namesAndValues.length; i < size; i++) {
-      result += namesAndValues[i].length();
-    }
-
-    return result;
-  }
-
-  public Builder newBuilder() {
-    Builder result = new Builder();
-    Collections.addAll(result.namesAndValues, namesAndValues);
-    return result;
-  }
-
-  /**
-   * Returns true if {@code other} is a {@code Headers} object with the same headers, with the same
-   * casing, in the same order. Note that two headers instances may be <i>semantically</i> equal
-   * but not equal according to this method. In particular, none of the following sets of headers
-   * are equal according to this method: <pre>   {@code
-   *
-   *   1. Original
-   *   Content-Type: text/html
-   *   Content-Length: 50
-   *
-   *   2. Different order
-   *   Content-Length: 50
-   *   Content-Type: text/html
-   *
-   *   3. Different case
-   *   content-type: text/html
-   *   content-length: 50
-   *
-   *   4. Different values
-   *   Content-Type: text/html
-   *   Content-Length: 050
-   * }</pre>
-   *
-   * Applications that require semantically equal headers should convert them into a canonical form
-   * before comparing them for equality.
-   */
-  @Override public boolean equals(@Nullable Object other) {
-    return other instanceof Headers
-        && Arrays.equals(((Headers) other).namesAndValues, namesAndValues);
-  }
-
-  @Override public int hashCode() {
-    return Arrays.hashCode(namesAndValues);
-  }
-
-  @Override public String toString() {
-    StringBuilder result = new StringBuilder();
-    for (int i = 0, size = size(); i < size; i++) {
-      result.append(name(i)).append(": ").append(value(i)).append("\n");
-    }
-    return result.toString();
-  }
-
-  public Map<String, List<String>> toMultimap() {
-    Map<String, List<String>> result = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
-    for (int i = 0, size = size(); i < size; i++) {
-      String name = name(i).toLowerCase(Locale.US);
-      List<String> values = result.get(name);
-      if (values == null) {
-        values = new ArrayList<>(2);
-        result.put(name, values);
-      }
-      values.add(value(i));
-    }
-    return result;
-  }
-
-  private static @Nullable String get(String[] namesAndValues, String name) {
-    for (int i = namesAndValues.length - 2; i >= 0; i -= 2) {
-      if (name.equalsIgnoreCase(namesAndValues[i])) {
-        return namesAndValues[i + 1];
-      }
-    }
-    return null;
-  }
-
-  /**
-   * Returns headers for the alternating header names and values. There must be an even number of
-   * arguments, and they must alternate between header names and values.
-   */
-  public static Headers of(String... namesAndValues) {
-    if (namesAndValues == null) throw new NullPointerException("namesAndValues == null");
-    if (namesAndValues.length % 2 != 0) {
-      throw new IllegalArgumentException("Expected alternating header names and values");
-    }
-
-    // Make a defensive copy and clean it up.
-    namesAndValues = namesAndValues.clone();
-    for (int i = 0; i < namesAndValues.length; i++) {
-      if (namesAndValues[i] == null) throw new IllegalArgumentException("Headers cannot be null");
-      namesAndValues[i] = namesAndValues[i].trim();
-    }
-
-    // Check for malformed headers.
-    for (int i = 0; i < namesAndValues.length; i += 2) {
-      String name = namesAndValues[i];
-      String value = namesAndValues[i + 1];
-      checkName(name);
-      checkValue(value, name);
-    }
-
-    return new Headers(namesAndValues);
-  }
-
-  /**
-   * Returns headers for the header names and values in the {@link Map}.
-   */
-  public static Headers of(Map<String, String> headers) {
-    if (headers == null) throw new NullPointerException("headers == null");
-
-    // Make a defensive copy and clean it up.
-    String[] namesAndValues = new String[headers.size() * 2];
-    int i = 0;
-    for (Map.Entry<String, String> header : headers.entrySet()) {
-      if (header.getKey() == null || header.getValue() == null) {
-        throw new IllegalArgumentException("Headers cannot be null");
-      }
-      String name = header.getKey().trim();
-      String value = header.getValue().trim();
-      checkName(name);
-      checkValue(value, name);
-      namesAndValues[i] = name;
-      namesAndValues[i + 1] = value;
-      i += 2;
-    }
-
-    return new Headers(namesAndValues);
-  }
-
-  static void checkName(String name) {
-    if (name == null) throw new NullPointerException("name == null");
-    if (name.isEmpty()) throw new IllegalArgumentException("name is empty");
-    for (int i = 0, length = name.length(); i < length; i++) {
-      char c = name.charAt(i);
-      if (c <= '\u0020' || c >= '\u007f') {
-        throw new IllegalArgumentException(Util.format(
-            "Unexpected char %#04x at %d in header name: %s", (int) c, i, name));
-      }
-    }
-  }
-
-  static void checkValue(String value, String name) {
-    if (value == null) throw new NullPointerException("value for name " + name + " == null");
-    for (int i = 0, length = value.length(); i < length; i++) {
-      char c = value.charAt(i);
-      if ((c <= '\u001f' && c != '\t') || c >= '\u007f') {
-        throw new IllegalArgumentException(Util.format(
-            "Unexpected char %#04x at %d in %s value: %s", (int) c, i, name, value));
-      }
-    }
-  }
-
-  public static final class Builder {
-    final List<String> namesAndValues = new ArrayList<>(20);
-
-    /**
-     * Add a header line without any validation. Only appropriate for headers from the remote peer
-     * or cache.
-     */
-    Builder addLenient(String line) {
-      int index = line.indexOf(":", 1);
-      if (index != -1) {
-        return addLenient(line.substring(0, index), line.substring(index + 1));
-      } else if (line.startsWith(":")) {
-        // Work around empty header names and header names that start with a
-        // colon (created by old broken SPDY versions of the response cache).
-        return addLenient("", line.substring(1)); // Empty header name.
-      } else {
-        return addLenient("", line); // No header name.
-      }
-    }
-
-    /** Add an header line containing a field name, a literal colon, and a value. */
-    public Builder add(String line) {
-      int index = line.indexOf(":");
-      if (index == -1) {
-        throw new IllegalArgumentException("Unexpected header: " + line);
-      }
-      return add(line.substring(0, index).trim(), line.substring(index + 1));
-    }
-
-    /**
-     * Add a header with the specified name and value. Does validation of header names and values.
-     */
-    public Builder add(String name, String value) {
-      checkName(name);
-      checkValue(value, name);
-      return addLenient(name, value);
-    }
-
-    /**
-     * Add a header with the specified name and value. Does validation of header names, allowing
-     * non-ASCII values.
-     */
-    public Builder addUnsafeNonAscii(String name, String value) {
-      checkName(name);
-      return addLenient(name, value);
-    }
-
-    /**
-     * Adds all headers from an existing collection.
-     */
-    public Builder addAll(Headers headers) {
-      for (int i = 0, size = headers.size(); i < size; i++) {
-        addLenient(headers.name(i), headers.value(i));
-      }
-
-      return this;
-    }
-
-    /**
-     * Add a header with the specified name and formatted date. Does validation of header names and
-     * value.
-     */
-    public Builder add(String name, Date value) {
-      if (value == null) throw new NullPointerException("value for name " + name + " == null");
-      add(name, HttpDate.format(value));
-      return this;
-    }
-
-    /**
-     * Add a header with the specified name and formatted instant. Does validation of header names
-     * and value.
-     */
-    @IgnoreJRERequirement
-    public Builder add(String name, Instant value) {
-      if (value == null) throw new NullPointerException("value for name " + name + " == null");
-      return add(name, new Date(value.toEpochMilli()));
-    }
-
-    /**
-     * Set a field with the specified date. If the field is not found, it is added. If the field is
-     * found, the existing values are replaced.
-     */
-    public Builder set(String name, Date value) {
-      if (value == null) throw new NullPointerException("value for name " + name + " == null");
-      set(name, HttpDate.format(value));
-      return this;
-    }
-
-    /**
-     * Set a field with the specified instant. If the field is not found, it is added. If the field
-     * is found, the existing values are replaced.
-     */
-    @IgnoreJRERequirement
-    public Builder set(String name, Instant value) {
-      if (value == null) throw new NullPointerException("value for name " + name + " == null");
-      return set(name, new Date(value.toEpochMilli()));
-    }
-
-    /**
-     * Add a field with the specified value without any validation. Only appropriate for headers
-     * from the remote peer or cache.
-     */
-    Builder addLenient(String name, String value) {
-      namesAndValues.add(name);
-      namesAndValues.add(value.trim());
-      return this;
-    }
-
-    public Builder removeAll(String name) {
-      for (int i = 0; i < namesAndValues.size(); i += 2) {
-        if (name.equalsIgnoreCase(namesAndValues.get(i))) {
-          namesAndValues.remove(i); // name
-          namesAndValues.remove(i); // value
-          i -= 2;
-        }
-      }
-      return this;
-    }
-
-    /**
-     * Set a field with the specified value. If the field is not found, it is added. If the field is
-     * found, the existing values are replaced.
-     */
-    public Builder set(String name, String value) {
-      checkName(name);
-      checkValue(value, name);
-      removeAll(name);
-      addLenient(name, value);
-      return this;
-    }
-
-    /** Equivalent to {@code build().get(name)}, but potentially faster. */
-    public @Nullable String get(String name) {
-      for (int i = namesAndValues.size() - 2; i >= 0; i -= 2) {
-        if (name.equalsIgnoreCase(namesAndValues.get(i))) {
-          return namesAndValues.get(i + 1);
-        }
-      }
-      return null;
-    }
-
-    public Headers build() {
-      return new Headers(this);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Interceptor.java b/okhttp/src/main/java/okhttp3/Interceptor.java
deleted file mode 100644
index 1005592697..0000000000
--- a/okhttp/src/main/java/okhttp3/Interceptor.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.util.concurrent.TimeUnit;
-import javax.annotation.Nullable;
-
-/**
- * Observes, modifies, and potentially short-circuits requests going out and the corresponding
- * responses coming back in. Typically interceptors add, remove, or transform headers on the request
- * or response.
- */
-public interface Interceptor {
-  Response intercept(Chain chain) throws IOException;
-
-  interface Chain {
-    Request request();
-
-    Response proceed(Request request) throws IOException;
-
-    /**
-     * Returns the connection the request will be executed on. This is only available in the chains
-     * of network interceptors; for application interceptors this is always null.
-     */
-    @Nullable Connection connection();
-
-    Call call();
-
-    int connectTimeoutMillis();
-
-    Chain withConnectTimeout(int timeout, TimeUnit unit);
-
-    int readTimeoutMillis();
-
-    Chain withReadTimeout(int timeout, TimeUnit unit);
-
-    int writeTimeoutMillis();
-
-    Chain withWriteTimeout(int timeout, TimeUnit unit);
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/MediaType.java b/okhttp/src/main/java/okhttp3/MediaType.java
deleted file mode 100644
index ddbd8fcb16..0000000000
--- a/okhttp/src/main/java/okhttp3/MediaType.java
+++ /dev/null
@@ -1,161 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.nio.charset.Charset;
-import java.util.Locale;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-import javax.annotation.Nullable;
-
-/**
- * An <a href="http://tools.ietf.org/html/rfc2045">RFC 2045</a> Media Type, appropriate to describe
- * the content type of an HTTP request or response body.
- */
-public final class MediaType {
-  private static final String TOKEN = "([a-zA-Z0-9-!#$%&'*+.^_`{|}~]+)";
-  private static final String QUOTED = "\"([^\"]*)\"";
-  private static final Pattern TYPE_SUBTYPE = Pattern.compile(TOKEN + "/" + TOKEN);
-  private static final Pattern PARAMETER = Pattern.compile(
-      ";\\s*(?:" + TOKEN + "=(?:" + TOKEN + "|" + QUOTED + "))?");
-
-  private final String mediaType;
-  private final String type;
-  private final String subtype;
-  private final @Nullable String charset;
-
-  private MediaType(String mediaType, String type, String subtype, @Nullable String charset) {
-    this.mediaType = mediaType;
-    this.type = type;
-    this.subtype = subtype;
-    this.charset = charset;
-  }
-
-  /**
-   * Returns a media type for {@code string}.
-   *
-   * @throws IllegalArgumentException if {@code string} is not a well-formed media type.
-   */
-  public static MediaType get(String string) {
-    Matcher typeSubtype = TYPE_SUBTYPE.matcher(string);
-    if (!typeSubtype.lookingAt()) {
-      throw new IllegalArgumentException("No subtype found for: \"" + string + '"');
-    }
-    String type = typeSubtype.group(1).toLowerCase(Locale.US);
-    String subtype = typeSubtype.group(2).toLowerCase(Locale.US);
-
-    String charset = null;
-    Matcher parameter = PARAMETER.matcher(string);
-    for (int s = typeSubtype.end(); s < string.length(); s = parameter.end()) {
-      parameter.region(s, string.length());
-      if (!parameter.lookingAt()) {
-        throw new IllegalArgumentException("Parameter is not formatted correctly: \""
-            + string.substring(s)
-            + "\" for: \""
-            + string
-            + '"');
-      }
-
-      String name = parameter.group(1);
-      if (name == null || !name.equalsIgnoreCase("charset")) continue;
-      String charsetParameter;
-      String token = parameter.group(2);
-      if (token != null) {
-        // If the token is 'single-quoted' it's invalid! But we're lenient and strip the quotes.
-        charsetParameter = (token.startsWith("'") && token.endsWith("'") && token.length() > 2)
-            ? token.substring(1, token.length() - 1)
-            : token;
-      } else {
-        // Value is "double-quoted". That's valid and our regex group already strips the quotes.
-        charsetParameter = parameter.group(3);
-      }
-      if (charset != null && !charsetParameter.equalsIgnoreCase(charset)) {
-        throw new IllegalArgumentException("Multiple charsets defined: \""
-            + charset
-            + "\" and: \""
-            + charsetParameter
-            + "\" for: \""
-            + string
-            + '"');
-      }
-      charset = charsetParameter;
-    }
-
-    return new MediaType(string, type, subtype, charset);
-  }
-
-  /**
-   * Returns a media type for {@code string}, or null if {@code string} is not a well-formed media
-   * type.
-   */
-  public static @Nullable MediaType parse(String string) {
-    try {
-      return get(string);
-    } catch (IllegalArgumentException ignored) {
-      return null;
-    }
-  }
-
-  /**
-   * Returns the high-level media type, such as "text", "image", "audio", "video", or
-   * "application".
-   */
-  public String type() {
-    return type;
-  }
-
-  /**
-   * Returns a specific media subtype, such as "plain" or "png", "mpeg", "mp4" or "xml".
-   */
-  public String subtype() {
-    return subtype;
-  }
-
-  /**
-   * Returns the charset of this media type, or null if this media type doesn't specify a charset.
-   */
-  public @Nullable Charset charset() {
-    return charset(null);
-  }
-
-  /**
-   * Returns the charset of this media type, or {@code defaultValue} if either this media type
-   * doesn't specify a charset, of it its charset is unsupported by the current runtime.
-   */
-  public @Nullable Charset charset(@Nullable Charset defaultValue) {
-    try {
-      return charset != null ? Charset.forName(charset) : defaultValue;
-    } catch (IllegalArgumentException e) {
-      return defaultValue; // This charset is invalid or unsupported. Give up.
-    }
-  }
-
-  /**
-   * Returns the encoded media type, like "text/plain; charset=utf-8", appropriate for use in a
-   * Content-Type header.
-   */
-  @Override public String toString() {
-    return mediaType;
-  }
-
-  @Override public boolean equals(@Nullable Object other) {
-    return other instanceof MediaType && ((MediaType) other).mediaType.equals(mediaType);
-  }
-
-  @Override public int hashCode() {
-    return mediaType.hashCode();
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/MultipartBody.java b/okhttp/src/main/java/okhttp3/MultipartBody.java
deleted file mode 100644
index a3f4863fba..0000000000
--- a/okhttp/src/main/java/okhttp3/MultipartBody.java
+++ /dev/null
@@ -1,345 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.UUID;
-import javax.annotation.Nullable;
-import okhttp3.internal.Util;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.ByteString;
-
-/** An <a href="http://www.ietf.org/rfc/rfc2387.txt">RFC 2387</a>-compliant request body. */
-public final class MultipartBody extends RequestBody {
-  /**
-   * The "mixed" subtype of "multipart" is intended for use when the body parts are independent and
-   * need to be bundled in a particular order. Any "multipart" subtypes that an implementation does
-   * not recognize must be treated as being of subtype "mixed".
-   */
-  public static final MediaType MIXED = MediaType.get("multipart/mixed");
-
-  /**
-   * The "multipart/alternative" type is syntactically identical to "multipart/mixed", but the
-   * semantics are different. In particular, each of the body parts is an "alternative" version of
-   * the same information.
-   */
-  public static final MediaType ALTERNATIVE = MediaType.get("multipart/alternative");
-
-  /**
-   * This type is syntactically identical to "multipart/mixed", but the semantics are different. In
-   * particular, in a digest, the default {@code Content-Type} value for a body part is changed from
-   * "text/plain" to "message/rfc822".
-   */
-  public static final MediaType DIGEST = MediaType.get("multipart/digest");
-
-  /**
-   * This type is syntactically identical to "multipart/mixed", but the semantics are different. In
-   * particular, in a parallel entity, the order of body parts is not significant.
-   */
-  public static final MediaType PARALLEL = MediaType.get("multipart/parallel");
-
-  /**
-   * The media-type multipart/form-data follows the rules of all multipart MIME data streams as
-   * outlined in RFC 2046. In forms, there are a series of fields to be supplied by the user who
-   * fills out the form. Each field has a name. Within a given form, the names are unique.
-   */
-  public static final MediaType FORM = MediaType.get("multipart/form-data");
-
-  private static final byte[] COLONSPACE = {':', ' '};
-  private static final byte[] CRLF = {'\r', '\n'};
-  private static final byte[] DASHDASH = {'-', '-'};
-
-  private final ByteString boundary;
-  private final MediaType originalType;
-  private final MediaType contentType;
-  private final List<Part> parts;
-  private long contentLength = -1L;
-
-  MultipartBody(ByteString boundary, MediaType type, List<Part> parts) {
-    this.boundary = boundary;
-    this.originalType = type;
-    this.contentType = MediaType.get(type + "; boundary=" + boundary.utf8());
-    this.parts = Util.immutableList(parts);
-  }
-
-  public MediaType type() {
-    return originalType;
-  }
-
-  public String boundary() {
-    return boundary.utf8();
-  }
-
-  /** The number of parts in this multipart body. */
-  public int size() {
-    return parts.size();
-  }
-
-  public List<Part> parts() {
-    return parts;
-  }
-
-  public Part part(int index) {
-    return parts.get(index);
-  }
-
-  /** A combination of {@link #type()} and {@link #boundary()}. */
-  @Override public MediaType contentType() {
-    return contentType;
-  }
-
-  @Override public long contentLength() throws IOException {
-    long result = contentLength;
-    if (result != -1L) return result;
-    return contentLength = writeOrCountBytes(null, true);
-  }
-
-  @Override public void writeTo(BufferedSink sink) throws IOException {
-    writeOrCountBytes(sink, false);
-  }
-
-  /**
-   * Either writes this request to {@code sink} or measures its content length. We have one method
-   * do double-duty to make sure the counting and content are consistent, particularly when it comes
-   * to awkward operations like measuring the encoded length of header strings, or the
-   * length-in-digits of an encoded integer.
-   */
-  private long writeOrCountBytes(
-      @Nullable BufferedSink sink, boolean countBytes) throws IOException {
-    long byteCount = 0L;
-
-    Buffer byteCountBuffer = null;
-    if (countBytes) {
-      sink = byteCountBuffer = new Buffer();
-    }
-
-    for (int p = 0, partCount = parts.size(); p < partCount; p++) {
-      Part part = parts.get(p);
-      Headers headers = part.headers;
-      RequestBody body = part.body;
-
-      sink.write(DASHDASH);
-      sink.write(boundary);
-      sink.write(CRLF);
-
-      if (headers != null) {
-        for (int h = 0, headerCount = headers.size(); h < headerCount; h++) {
-          sink.writeUtf8(headers.name(h))
-              .write(COLONSPACE)
-              .writeUtf8(headers.value(h))
-              .write(CRLF);
-        }
-      }
-
-      MediaType contentType = body.contentType();
-      if (contentType != null) {
-        sink.writeUtf8("Content-Type: ")
-            .writeUtf8(contentType.toString())
-            .write(CRLF);
-      }
-
-      long contentLength = body.contentLength();
-      if (contentLength != -1) {
-        sink.writeUtf8("Content-Length: ")
-            .writeDecimalLong(contentLength)
-            .write(CRLF);
-      } else if (countBytes) {
-        // We can't measure the body's size without the sizes of its components.
-        byteCountBuffer.clear();
-        return -1L;
-      }
-
-      sink.write(CRLF);
-
-      if (countBytes) {
-        byteCount += contentLength;
-      } else {
-        body.writeTo(sink);
-      }
-
-      sink.write(CRLF);
-    }
-
-    sink.write(DASHDASH);
-    sink.write(boundary);
-    sink.write(DASHDASH);
-    sink.write(CRLF);
-
-    if (countBytes) {
-      byteCount += byteCountBuffer.size();
-      byteCountBuffer.clear();
-    }
-
-    return byteCount;
-  }
-
-  /**
-   * Appends a quoted-string to a StringBuilder.
-   *
-   * <p>RFC 2388 is rather vague about how one should escape special characters in form-data
-   * parameters, and as it turns out Firefox and Chrome actually do rather different things, and
-   * both say in their comments that they're not really sure what the right approach is. We go with
-   * Chrome's behavior (which also experimentally seems to match what IE does), but if you actually
-   * want to have a good chance of things working, please avoid double-quotes, newlines, percent
-   * signs, and the like in your field names.
-   */
-  static void appendQuotedString(StringBuilder target, String key) {
-    target.append('"');
-    for (int i = 0, len = key.length(); i < len; i++) {
-      char ch = key.charAt(i);
-      switch (ch) {
-        case '\n':
-          target.append("%0A");
-          break;
-        case '\r':
-          target.append("%0D");
-          break;
-        case '"':
-          target.append("%22");
-          break;
-        default:
-          target.append(ch);
-          break;
-      }
-    }
-    target.append('"');
-  }
-
-  public static final class Part {
-    public static Part create(RequestBody body) {
-      return create(null, body);
-    }
-
-    public static Part create(@Nullable Headers headers, RequestBody body) {
-      if (body == null) {
-        throw new NullPointerException("body == null");
-      }
-      if (headers != null && headers.get("Content-Type") != null) {
-        throw new IllegalArgumentException("Unexpected header: Content-Type");
-      }
-      if (headers != null && headers.get("Content-Length") != null) {
-        throw new IllegalArgumentException("Unexpected header: Content-Length");
-      }
-      return new Part(headers, body);
-    }
-
-    public static Part createFormData(String name, String value) {
-      return createFormData(name, null, RequestBody.create(null, value));
-    }
-
-    public static Part createFormData(String name, @Nullable String filename, RequestBody body) {
-      if (name == null) {
-        throw new NullPointerException("name == null");
-      }
-      StringBuilder disposition = new StringBuilder("form-data; name=");
-      appendQuotedString(disposition, name);
-
-      if (filename != null) {
-        disposition.append("; filename=");
-        appendQuotedString(disposition, filename);
-      }
-
-      Headers headers = new Headers.Builder()
-          .addUnsafeNonAscii("Content-Disposition", disposition.toString())
-          .build();
-
-      return create(headers, body);
-    }
-
-    final @Nullable Headers headers;
-    final RequestBody body;
-
-    private Part(@Nullable Headers headers, RequestBody body) {
-      this.headers = headers;
-      this.body = body;
-    }
-
-    public @Nullable Headers headers() {
-      return headers;
-    }
-
-    public RequestBody body() {
-      return body;
-    }
-  }
-
-  public static final class Builder {
-    private final ByteString boundary;
-    private MediaType type = MIXED;
-    private final List<Part> parts = new ArrayList<>();
-
-    public Builder() {
-      this(UUID.randomUUID().toString());
-    }
-
-    public Builder(String boundary) {
-      this.boundary = ByteString.encodeUtf8(boundary);
-    }
-
-    /**
-     * Set the MIME type. Expected values for {@code type} are {@link #MIXED} (the default), {@link
-     * #ALTERNATIVE}, {@link #DIGEST}, {@link #PARALLEL} and {@link #FORM}.
-     */
-    public Builder setType(MediaType type) {
-      if (type == null) {
-        throw new NullPointerException("type == null");
-      }
-      if (!type.type().equals("multipart")) {
-        throw new IllegalArgumentException("multipart != " + type);
-      }
-      this.type = type;
-      return this;
-    }
-
-    /** Add a part to the body. */
-    public Builder addPart(RequestBody body) {
-      return addPart(Part.create(body));
-    }
-
-    /** Add a part to the body. */
-    public Builder addPart(@Nullable Headers headers, RequestBody body) {
-      return addPart(Part.create(headers, body));
-    }
-
-    /** Add a form data part to the body. */
-    public Builder addFormDataPart(String name, String value) {
-      return addPart(Part.createFormData(name, value));
-    }
-
-    /** Add a form data part to the body. */
-    public Builder addFormDataPart(String name, @Nullable String filename, RequestBody body) {
-      return addPart(Part.createFormData(name, filename, body));
-    }
-
-    /** Add a part to the body. */
-    public Builder addPart(Part part) {
-      if (part == null) throw new NullPointerException("part == null");
-      parts.add(part);
-      return this;
-    }
-
-    /** Assemble the specified parts into a request body. */
-    public MultipartBody build() {
-      if (parts.isEmpty()) {
-        throw new IllegalStateException("Multipart body must have at least one part.");
-      }
-      return new MultipartBody(boundary, type, parts);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
deleted file mode 100644
index b8f05eaf3d..0000000000
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.java
+++ /dev/null
@@ -1,1018 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.net.Proxy;
-import java.net.ProxySelector;
-import java.net.Socket;
-import java.security.GeneralSecurityException;
-import java.time.Duration;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.Random;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.TimeUnit;
-import javax.annotation.Nullable;
-import javax.net.SocketFactory;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.internal.Internal;
-import okhttp3.internal.Util;
-import okhttp3.internal.cache.InternalCache;
-import okhttp3.internal.connection.Exchange;
-import okhttp3.internal.connection.RealConnectionPool;
-import okhttp3.internal.platform.Platform;
-import okhttp3.internal.proxy.NullProxySelector;
-import okhttp3.internal.tls.CertificateChainCleaner;
-import okhttp3.internal.tls.OkHostnameVerifier;
-import okhttp3.internal.ws.RealWebSocket;
-import okio.Sink;
-import okio.Source;
-import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
-
-import static okhttp3.internal.Util.checkDuration;
-
-/**
- * Factory for {@linkplain Call calls}, which can be used to send HTTP requests and read their
- * responses.
- *
- * <h3>OkHttpClients should be shared</h3>
- *
- * <p>OkHttp performs best when you create a single {@code OkHttpClient} instance and reuse it for
- * all of your HTTP calls. This is because each client holds its own connection pool and thread
- * pools. Reusing connections and threads reduces latency and saves memory. Conversely, creating a
- * client for each request wastes resources on idle pools.
- *
- * <p>Use {@code new OkHttpClient()} to create a shared instance with the default settings:
- * <pre>   {@code
- *
- *   // The singleton HTTP client.
- *   public final OkHttpClient client = new OkHttpClient();
- * }</pre>
- *
- * <p>Or use {@code new OkHttpClient.Builder()} to create a shared instance with custom settings:
- * <pre>   {@code
- *
- *   // The singleton HTTP client.
- *   public final OkHttpClient client = new OkHttpClient.Builder()
- *       .addInterceptor(new HttpLoggingInterceptor())
- *       .cache(new Cache(cacheDir, cacheSize))
- *       .build();
- * }</pre>
- *
- * <h3>Customize your client with newBuilder()</h3>
- *
- * <p>You can customize a shared OkHttpClient instance with {@link #newBuilder()}. This builds a
- * client that shares the same connection pool, thread pools, and configuration. Use the builder
- * methods to configure the derived client for a specific purpose.
- *
- * <p>This example shows a call with a short 500 millisecond timeout: <pre>   {@code
- *
- *   OkHttpClient eagerClient = client.newBuilder()
- *       .readTimeout(500, TimeUnit.MILLISECONDS)
- *       .build();
- *   Response response = eagerClient.newCall(request).execute();
- * }</pre>
- *
- * <h3>Shutdown isn't necessary</h3>
- *
- * <p>The threads and connections that are held will be released automatically if they remain idle.
- * But if you are writing a application that needs to aggressively release unused resources you may
- * do so.
- *
- * <p>Shutdown the dispatcher's executor service with {@link ExecutorService#shutdown shutdown()}.
- * This will also cause future calls to the client to be rejected. <pre>   {@code
- *
- *     client.dispatcher().executorService().shutdown();
- * }</pre>
- *
- * <p>Clear the connection pool with {@link ConnectionPool#evictAll() evictAll()}. Note that the
- * connection pool's daemon thread may not exit immediately. <pre>   {@code
- *
- *     client.connectionPool().evictAll();
- * }</pre>
- *
- * <p>If your client has a cache, call {@link Cache#close close()}. Note that it is an error to
- * create calls against a cache that is closed, and doing so will cause the call to crash.
- * <pre>   {@code
- *
- *     client.cache().close();
- * }</pre>
- *
- * <p>OkHttp also uses daemon threads for HTTP/2 connections. These will exit automatically if they
- * remain idle.
- */
-public class OkHttpClient implements Cloneable, Call.Factory, WebSocket.Factory {
-  static final List<Protocol> DEFAULT_PROTOCOLS = Util.immutableList(
-      Protocol.HTTP_2, Protocol.HTTP_1_1);
-
-  static final List<ConnectionSpec> DEFAULT_CONNECTION_SPECS = Util.immutableList(
-      ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT);
-
-  static {
-    Internal.instance = new Internal() {
-      @Override public void addLenient(Headers.Builder builder, String line) {
-        builder.addLenient(line);
-      }
-
-      @Override public void addLenient(Headers.Builder builder, String name, String value) {
-        builder.addLenient(name, value);
-      }
-
-      @Override public RealConnectionPool realConnectionPool(ConnectionPool connectionPool) {
-        return connectionPool.delegate;
-      }
-
-      @Override public boolean equalsNonHost(Address a, Address b) {
-        return a.equalsNonHost(b);
-      }
-
-      @Override public int code(Response.Builder responseBuilder) {
-        return responseBuilder.code;
-      }
-
-      @Override
-      public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean isFallback) {
-        tlsConfiguration.apply(sslSocket, isFallback);
-      }
-
-      @Override public Call newWebSocketCall(OkHttpClient client, Request originalRequest) {
-        return RealCall.newRealCall(client, originalRequest, true);
-      }
-
-      @Override public void initExchange(
-          Response.Builder responseBuilder, Exchange exchange) {
-        responseBuilder.initExchange(exchange);
-      }
-
-      @Override public @Nullable Exchange exchange(Response response) {
-        return response.exchange;
-      }
-    };
-  }
-
-  final Dispatcher dispatcher;
-  final @Nullable Proxy proxy;
-  final List<Protocol> protocols;
-  final List<ConnectionSpec> connectionSpecs;
-  final List<Interceptor> interceptors;
-  final List<Interceptor> networkInterceptors;
-  final EventListener.Factory eventListenerFactory;
-  final ProxySelector proxySelector;
-  final CookieJar cookieJar;
-  final @Nullable Cache cache;
-  final @Nullable InternalCache internalCache;
-  final SocketFactory socketFactory;
-  final SSLSocketFactory sslSocketFactory;
-  final CertificateChainCleaner certificateChainCleaner;
-  final HostnameVerifier hostnameVerifier;
-  final CertificatePinner certificatePinner;
-  final Authenticator proxyAuthenticator;
-  final Authenticator authenticator;
-  final ConnectionPool connectionPool;
-  final Dns dns;
-  final boolean followSslRedirects;
-  final boolean followRedirects;
-  final boolean retryOnConnectionFailure;
-  final int callTimeout;
-  final int connectTimeout;
-  final int readTimeout;
-  final int writeTimeout;
-  final int pingInterval;
-
-  public OkHttpClient() {
-    this(new Builder());
-  }
-
-  OkHttpClient(Builder builder) {
-    this.dispatcher = builder.dispatcher;
-    this.proxy = builder.proxy;
-    this.protocols = builder.protocols;
-    this.connectionSpecs = builder.connectionSpecs;
-    this.interceptors = Util.immutableList(builder.interceptors);
-    this.networkInterceptors = Util.immutableList(builder.networkInterceptors);
-    this.eventListenerFactory = builder.eventListenerFactory;
-    this.proxySelector = builder.proxySelector;
-    this.cookieJar = builder.cookieJar;
-    this.cache = builder.cache;
-    this.internalCache = builder.internalCache;
-    this.socketFactory = builder.socketFactory;
-
-    boolean isTLS = false;
-    for (ConnectionSpec spec : connectionSpecs) {
-      isTLS = isTLS || spec.isTls();
-    }
-
-    if (builder.sslSocketFactory != null || !isTLS) {
-      this.sslSocketFactory = builder.sslSocketFactory;
-      this.certificateChainCleaner = builder.certificateChainCleaner;
-    } else {
-      X509TrustManager trustManager = Util.platformTrustManager();
-      this.sslSocketFactory = newSslSocketFactory(trustManager);
-      this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
-    }
-
-    if (sslSocketFactory != null) {
-      Platform.get().configureSslSocketFactory(sslSocketFactory);
-    }
-
-    this.hostnameVerifier = builder.hostnameVerifier;
-    this.certificatePinner = builder.certificatePinner.withCertificateChainCleaner(
-        certificateChainCleaner);
-    this.proxyAuthenticator = builder.proxyAuthenticator;
-    this.authenticator = builder.authenticator;
-    this.connectionPool = builder.connectionPool;
-    this.dns = builder.dns;
-    this.followSslRedirects = builder.followSslRedirects;
-    this.followRedirects = builder.followRedirects;
-    this.retryOnConnectionFailure = builder.retryOnConnectionFailure;
-    this.callTimeout = builder.callTimeout;
-    this.connectTimeout = builder.connectTimeout;
-    this.readTimeout = builder.readTimeout;
-    this.writeTimeout = builder.writeTimeout;
-    this.pingInterval = builder.pingInterval;
-
-    if (interceptors.contains(null)) {
-      throw new IllegalStateException("Null interceptor: " + interceptors);
-    }
-    if (networkInterceptors.contains(null)) {
-      throw new IllegalStateException("Null network interceptor: " + networkInterceptors);
-    }
-  }
-
-  private static SSLSocketFactory newSslSocketFactory(X509TrustManager trustManager) {
-    try {
-      SSLContext sslContext = Platform.get().getSSLContext();
-      sslContext.init(null, new TrustManager[] { trustManager }, null);
-      return sslContext.getSocketFactory();
-    } catch (GeneralSecurityException e) {
-      throw new AssertionError("No System TLS", e); // The system has no TLS. Just give up.
-    }
-  }
-
-  /**
-   * Default call timeout (in milliseconds). By default there is no timeout for complete calls, but
-   * there is for the connect, write, and read actions within a call.
-   */
-  public int callTimeoutMillis() {
-    return callTimeout;
-  }
-
-  /** Default connect timeout (in milliseconds). The default is 10 seconds. */
-  public int connectTimeoutMillis() {
-    return connectTimeout;
-  }
-
-  /** Default read timeout (in milliseconds). The default is 10 seconds. */
-  public int readTimeoutMillis() {
-    return readTimeout;
-  }
-
-  /** Default write timeout (in milliseconds). The default is 10 seconds. */
-  public int writeTimeoutMillis() {
-    return writeTimeout;
-  }
-
-  /** Web socket and HTTP/2 ping interval (in milliseconds). By default pings are not sent. */
-  public int pingIntervalMillis() {
-    return pingInterval;
-  }
-
-  public @Nullable Proxy proxy() {
-    return proxy;
-  }
-
-  public ProxySelector proxySelector() {
-    return proxySelector;
-  }
-
-  public CookieJar cookieJar() {
-    return cookieJar;
-  }
-
-  public @Nullable Cache cache() {
-    return cache;
-  }
-
-  @Nullable InternalCache internalCache() {
-    return cache != null ? cache.internalCache : internalCache;
-  }
-
-  public Dns dns() {
-    return dns;
-  }
-
-  public SocketFactory socketFactory() {
-    return socketFactory;
-  }
-
-  public SSLSocketFactory sslSocketFactory() {
-    return sslSocketFactory;
-  }
-
-  public HostnameVerifier hostnameVerifier() {
-    return hostnameVerifier;
-  }
-
-  public CertificatePinner certificatePinner() {
-    return certificatePinner;
-  }
-
-  public Authenticator authenticator() {
-    return authenticator;
-  }
-
-  public Authenticator proxyAuthenticator() {
-    return proxyAuthenticator;
-  }
-
-  public ConnectionPool connectionPool() {
-    return connectionPool;
-  }
-
-  public boolean followSslRedirects() {
-    return followSslRedirects;
-  }
-
-  public boolean followRedirects() {
-    return followRedirects;
-  }
-
-  public boolean retryOnConnectionFailure() {
-    return retryOnConnectionFailure;
-  }
-
-  public Dispatcher dispatcher() {
-    return dispatcher;
-  }
-
-  public List<Protocol> protocols() {
-    return protocols;
-  }
-
-  public List<ConnectionSpec> connectionSpecs() {
-    return connectionSpecs;
-  }
-
-  /**
-   * Returns an immutable list of interceptors that observe the full span of each call: from before
-   * the connection is established (if any) until after the response source is selected (either the
-   * origin server, cache, or both).
-   */
-  public List<Interceptor> interceptors() {
-    return interceptors;
-  }
-
-  /**
-   * Returns an immutable list of interceptors that observe a single network request and response.
-   * These interceptors must call {@link Interceptor.Chain#proceed} exactly once: it is an error for
-   * a network interceptor to short-circuit or repeat a network request.
-   */
-  public List<Interceptor> networkInterceptors() {
-    return networkInterceptors;
-  }
-
-  public EventListener.Factory eventListenerFactory() {
-    return eventListenerFactory;
-  }
-
-  /**
-   * Prepares the {@code request} to be executed at some point in the future.
-   */
-  @Override public Call newCall(Request request) {
-    return RealCall.newRealCall(this, request, false /* for web socket */);
-  }
-
-  /**
-   * Uses {@code request} to connect a new web socket.
-   */
-  @Override public WebSocket newWebSocket(Request request, WebSocketListener listener) {
-    RealWebSocket webSocket = new RealWebSocket(request, listener, new Random(), pingInterval);
-    webSocket.connect(this);
-    return webSocket;
-  }
-
-  public Builder newBuilder() {
-    return new Builder(this);
-  }
-
-  public static final class Builder {
-    Dispatcher dispatcher;
-    @Nullable Proxy proxy;
-    List<Protocol> protocols;
-    List<ConnectionSpec> connectionSpecs;
-    final List<Interceptor> interceptors = new ArrayList<>();
-    final List<Interceptor> networkInterceptors = new ArrayList<>();
-    EventListener.Factory eventListenerFactory;
-    ProxySelector proxySelector;
-    CookieJar cookieJar;
-    @Nullable Cache cache;
-    @Nullable InternalCache internalCache;
-    SocketFactory socketFactory;
-    @Nullable SSLSocketFactory sslSocketFactory;
-    @Nullable CertificateChainCleaner certificateChainCleaner;
-    HostnameVerifier hostnameVerifier;
-    CertificatePinner certificatePinner;
-    Authenticator proxyAuthenticator;
-    Authenticator authenticator;
-    ConnectionPool connectionPool;
-    Dns dns;
-    boolean followSslRedirects;
-    boolean followRedirects;
-    boolean retryOnConnectionFailure;
-    int callTimeout;
-    int connectTimeout;
-    int readTimeout;
-    int writeTimeout;
-    int pingInterval;
-
-    public Builder() {
-      dispatcher = new Dispatcher();
-      protocols = DEFAULT_PROTOCOLS;
-      connectionSpecs = DEFAULT_CONNECTION_SPECS;
-      eventListenerFactory = EventListener.factory(EventListener.NONE);
-      proxySelector = ProxySelector.getDefault();
-      if (proxySelector == null) {
-        proxySelector = new NullProxySelector();
-      }
-      cookieJar = CookieJar.NO_COOKIES;
-      socketFactory = SocketFactory.getDefault();
-      hostnameVerifier = OkHostnameVerifier.INSTANCE;
-      certificatePinner = CertificatePinner.DEFAULT;
-      proxyAuthenticator = Authenticator.NONE;
-      authenticator = Authenticator.NONE;
-      connectionPool = new ConnectionPool();
-      dns = Dns.SYSTEM;
-      followSslRedirects = true;
-      followRedirects = true;
-      retryOnConnectionFailure = true;
-      callTimeout = 0;
-      connectTimeout = 10_000;
-      readTimeout = 10_000;
-      writeTimeout = 10_000;
-      pingInterval = 0;
-    }
-
-    Builder(OkHttpClient okHttpClient) {
-      this.dispatcher = okHttpClient.dispatcher;
-      this.proxy = okHttpClient.proxy;
-      this.protocols = okHttpClient.protocols;
-      this.connectionSpecs = okHttpClient.connectionSpecs;
-      this.interceptors.addAll(okHttpClient.interceptors);
-      this.networkInterceptors.addAll(okHttpClient.networkInterceptors);
-      this.eventListenerFactory = okHttpClient.eventListenerFactory;
-      this.proxySelector = okHttpClient.proxySelector;
-      this.cookieJar = okHttpClient.cookieJar;
-      this.internalCache = okHttpClient.internalCache;
-      this.cache = okHttpClient.cache;
-      this.socketFactory = okHttpClient.socketFactory;
-      this.sslSocketFactory = okHttpClient.sslSocketFactory;
-      this.certificateChainCleaner = okHttpClient.certificateChainCleaner;
-      this.hostnameVerifier = okHttpClient.hostnameVerifier;
-      this.certificatePinner = okHttpClient.certificatePinner;
-      this.proxyAuthenticator = okHttpClient.proxyAuthenticator;
-      this.authenticator = okHttpClient.authenticator;
-      this.connectionPool = okHttpClient.connectionPool;
-      this.dns = okHttpClient.dns;
-      this.followSslRedirects = okHttpClient.followSslRedirects;
-      this.followRedirects = okHttpClient.followRedirects;
-      this.retryOnConnectionFailure = okHttpClient.retryOnConnectionFailure;
-      this.callTimeout = okHttpClient.callTimeout;
-      this.connectTimeout = okHttpClient.connectTimeout;
-      this.readTimeout = okHttpClient.readTimeout;
-      this.writeTimeout = okHttpClient.writeTimeout;
-      this.pingInterval = okHttpClient.pingInterval;
-    }
-
-    /**
-     * Sets the default timeout for complete calls. A value of 0 means no timeout, otherwise values
-     * must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
-     *
-     * <p>The call timeout spans the entire call: resolving DNS, connecting, writing the request
-     * body, server processing, and reading the response body. If the call requires redirects or
-     * retries all must complete within one timeout period.
-     *
-     * <p>The default value is 0 which imposes no timeout.
-     */
-    public Builder callTimeout(long timeout, TimeUnit unit) {
-      callTimeout = checkDuration("timeout", timeout, unit);
-      return this;
-    }
-
-    /**
-     * Sets the default timeout for complete calls. A value of 0 means no timeout, otherwise values
-     * must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
-     *
-     * <p>The call timeout spans the entire call: resolving DNS, connecting, writing the request
-     * body, server processing, and reading the response body. If the call requires redirects or
-     * retries all must complete within one timeout period.
-     *
-     * <p>The default value is 0 which imposes no timeout.
-     */
-    @IgnoreJRERequirement
-    public Builder callTimeout(Duration duration) {
-      callTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
-      return this;
-    }
-
-    /**
-     * Sets the default connect timeout for new connections. A value of 0 means no timeout,
-     * otherwise values must be between 1 and {@link Integer#MAX_VALUE} when converted to
-     * milliseconds.
-     *
-     * <p>The connect timeout is applied when connecting a TCP socket to the target host.
-     * The default value is 10 seconds.
-     */
-    public Builder connectTimeout(long timeout, TimeUnit unit) {
-      connectTimeout = checkDuration("timeout", timeout, unit);
-      return this;
-    }
-
-    /**
-     * Sets the default connect timeout for new connections. A value of 0 means no timeout,
-     * otherwise values must be between 1 and {@link Integer#MAX_VALUE} when converted to
-     * milliseconds.
-     *
-     * <p>The connect timeout is applied when connecting a TCP socket to the target host.
-     * The default value is 10 seconds.
-     */
-    @IgnoreJRERequirement
-    public Builder connectTimeout(Duration duration) {
-      connectTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
-      return this;
-    }
-
-    /**
-     * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
-     * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
-     *
-     * <p>The read timeout is applied to both the TCP socket and for individual read IO operations
-     * including on {@link Source} of the {@link Response}. The default value is 10 seconds.
-     *
-     * @see Socket#setSoTimeout(int)
-     * @see Source#timeout()
-     */
-    public Builder readTimeout(long timeout, TimeUnit unit) {
-      readTimeout = checkDuration("timeout", timeout, unit);
-      return this;
-    }
-
-    /**
-     * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
-     * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
-     *
-     * <p>The read timeout is applied to both the TCP socket and for individual read IO operations
-     * including on {@link Source} of the {@link Response}. The default value is 10 seconds.
-     *
-     * @see Socket#setSoTimeout(int)
-     * @see Source#timeout()
-     */
-    @IgnoreJRERequirement
-    public Builder readTimeout(Duration duration) {
-      readTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
-      return this;
-    }
-
-    /**
-     * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
-     * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
-     *
-     * <p>The write timeout is applied for individual write IO operations.
-     * The default value is 10 seconds.
-     *
-     * @see Sink#timeout()
-     */
-    public Builder writeTimeout(long timeout, TimeUnit unit) {
-      writeTimeout = checkDuration("timeout", timeout, unit);
-      return this;
-    }
-
-    /**
-     * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
-     * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
-     *
-     * <p>The write timeout is applied for individual write IO operations.
-     * The default value is 10 seconds.
-     *
-     * @see Sink#timeout()
-     */
-    @IgnoreJRERequirement
-    public Builder writeTimeout(Duration duration) {
-      writeTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
-      return this;
-    }
-
-    /**
-     * Sets the interval between HTTP/2 and web socket pings initiated by this client. Use this to
-     * automatically send ping frames until either the connection fails or it is closed. This keeps
-     * the connection alive and may detect connectivity failures.
-     *
-     * <p>If the server does not respond to each ping with a pong within {@code interval}, this
-     * client will assume that connectivity has been lost. When this happens on a web socket the
-     * connection is canceled and its listener is {@linkplain WebSocketListener#onFailure notified
-     * of the failure}. When it happens on an HTTP/2 connection the connection is closed and any
-     * calls it is carrying {@linkplain java.io.IOException will fail with an IOException}.
-     *
-     * <p>The default value of 0 disables client-initiated pings.
-     */
-    public Builder pingInterval(long interval, TimeUnit unit) {
-      pingInterval = checkDuration("interval", interval, unit);
-      return this;
-    }
-
-    /**
-     * Sets the interval between HTTP/2 and web socket pings initiated by this client. Use this to
-     * automatically send ping frames until either the connection fails or it is closed. This keeps
-     * the connection alive and may detect connectivity failures.
-     *
-     * <p>If the server does not respond to each ping with a pong within {@code interval}, this
-     * client will assume that connectivity has been lost. When this happens on a web socket the
-     * connection is canceled and its listener is {@linkplain WebSocketListener#onFailure notified
-     * of the failure}. When it happens on an HTTP/2 connection the connection is closed and any
-     * calls it is carrying {@linkplain java.io.IOException will fail with an IOException}.
-     *
-     * <p>The default value of 0 disables client-initiated pings.
-     */
-    @IgnoreJRERequirement
-    public Builder pingInterval(Duration duration) {
-      pingInterval = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
-      return this;
-    }
-
-    /**
-     * Sets the HTTP proxy that will be used by connections created by this client. This takes
-     * precedence over {@link #proxySelector}, which is only honored when this proxy is null (which
-     * it is by default). To disable proxy use completely, call {@code proxy(Proxy.NO_PROXY)}.
-     */
-    public Builder proxy(@Nullable Proxy proxy) {
-      this.proxy = proxy;
-      return this;
-    }
-
-    /**
-     * Sets the proxy selection policy to be used if no {@link #proxy proxy} is specified
-     * explicitly. The proxy selector may return multiple proxies; in that case they will be tried
-     * in sequence until a successful connection is established.
-     *
-     * <p>If unset, the {@link ProxySelector#getDefault() system-wide default} proxy selector will
-     * be used.
-     */
-    public Builder proxySelector(ProxySelector proxySelector) {
-      if (proxySelector == null) throw new NullPointerException("proxySelector == null");
-      this.proxySelector = proxySelector;
-      return this;
-    }
-
-    /**
-     * Sets the handler that can accept cookies from incoming HTTP responses and provides cookies to
-     * outgoing HTTP requests.
-     *
-     * <p>If unset, {@linkplain CookieJar#NO_COOKIES no cookies} will be accepted nor provided.
-     */
-    public Builder cookieJar(CookieJar cookieJar) {
-      if (cookieJar == null) throw new NullPointerException("cookieJar == null");
-      this.cookieJar = cookieJar;
-      return this;
-    }
-
-    /** Sets the response cache to be used to read and write cached responses. */
-    public Builder cache(@Nullable Cache cache) {
-      this.cache = cache;
-      this.internalCache = null;
-      return this;
-    }
-
-    /**
-     * Sets the DNS service used to lookup IP addresses for hostnames.
-     *
-     * <p>If unset, the {@link Dns#SYSTEM system-wide default} DNS will be used.
-     */
-    public Builder dns(Dns dns) {
-      if (dns == null) throw new NullPointerException("dns == null");
-      this.dns = dns;
-      return this;
-    }
-
-    /**
-     * Sets the socket factory used to create connections. OkHttp only uses the parameterless {@link
-     * SocketFactory#createSocket() createSocket()} method to create unconnected sockets. Overriding
-     * this method, e. g., allows the socket to be bound to a specific local address.
-     *
-     * <p>If unset, the {@link SocketFactory#getDefault() system-wide default} socket factory will
-     * be used.
-     */
-    public Builder socketFactory(SocketFactory socketFactory) {
-      if (socketFactory == null) throw new NullPointerException("socketFactory == null");
-      if (socketFactory instanceof SSLSocketFactory) {
-        throw new IllegalArgumentException("socketFactory instanceof SSLSocketFactory");
-      }
-      this.socketFactory = socketFactory;
-      return this;
-    }
-
-    /**
-     * Sets the socket factory used to secure HTTPS connections. If unset, the system default will
-     * be used.
-     *
-     * @deprecated {@code SSLSocketFactory} does not expose its {@link X509TrustManager}, which is
-     *     a field that OkHttp needs to build a clean certificate chain. This method instead must
-     *     use reflection to extract the trust manager. Applications should prefer to call {@link
-     *     #sslSocketFactory(SSLSocketFactory, X509TrustManager)}, which avoids such reflection.
-     */
-    public Builder sslSocketFactory(SSLSocketFactory sslSocketFactory) {
-      if (sslSocketFactory == null) throw new NullPointerException("sslSocketFactory == null");
-      this.sslSocketFactory = sslSocketFactory;
-      this.certificateChainCleaner = Platform.get().buildCertificateChainCleaner(sslSocketFactory);
-      return this;
-    }
-
-    /**
-     * Sets the socket factory and trust manager used to secure HTTPS connections. If unset, the
-     * system defaults will be used.
-     *
-     * <p>Most applications should not call this method, and instead use the system defaults. Those
-     * classes include special optimizations that can be lost if the implementations are decorated.
-     *
-     * <p>If necessary, you can create and configure the defaults yourself with the following code:
-     *
-     * <pre>   {@code
-     *
-     *   TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
-     *       TrustManagerFactory.getDefaultAlgorithm());
-     *   trustManagerFactory.init((KeyStore) null);
-     *   TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
-     *   if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
-     *     throw new IllegalStateException("Unexpected default trust managers:"
-     *         + Arrays.toString(trustManagers));
-     *   }
-     *   X509TrustManager trustManager = (X509TrustManager) trustManagers[0];
-     *
-     *   SSLContext sslContext = SSLContext.getInstance("TLS");
-     *   sslContext.init(null, new TrustManager[] { trustManager }, null);
-     *   SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();
-     *
-     *   OkHttpClient client = new OkHttpClient.Builder()
-     *       .sslSocketFactory(sslSocketFactory, trustManager)
-     *       .build();
-     * }</pre>
-     */
-    public Builder sslSocketFactory(
-        SSLSocketFactory sslSocketFactory, X509TrustManager trustManager) {
-      if (sslSocketFactory == null) throw new NullPointerException("sslSocketFactory == null");
-      if (trustManager == null) throw new NullPointerException("trustManager == null");
-      this.sslSocketFactory = sslSocketFactory;
-      this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
-      return this;
-    }
-
-    /**
-     * Sets the verifier used to confirm that response certificates apply to requested hostnames for
-     * HTTPS connections.
-     *
-     * <p>If unset, a default hostname verifier will be used.
-     */
-    public Builder hostnameVerifier(HostnameVerifier hostnameVerifier) {
-      if (hostnameVerifier == null) throw new NullPointerException("hostnameVerifier == null");
-      this.hostnameVerifier = hostnameVerifier;
-      return this;
-    }
-
-    /**
-     * Sets the certificate pinner that constrains which certificates are trusted. By default HTTPS
-     * connections rely on only the {@link #sslSocketFactory SSL socket factory} to establish trust.
-     * Pinning certificates avoids the need to trust certificate authorities.
-     */
-    public Builder certificatePinner(CertificatePinner certificatePinner) {
-      if (certificatePinner == null) throw new NullPointerException("certificatePinner == null");
-      this.certificatePinner = certificatePinner;
-      return this;
-    }
-
-    /**
-     * Sets the authenticator used to respond to challenges from origin servers. Use {@link
-     * #proxyAuthenticator} to set the authenticator for proxy servers.
-     *
-     * <p>If unset, the {@linkplain Authenticator#NONE no authentication will be attempted}.
-     */
-    public Builder authenticator(Authenticator authenticator) {
-      if (authenticator == null) throw new NullPointerException("authenticator == null");
-      this.authenticator = authenticator;
-      return this;
-    }
-
-    /**
-     * Sets the authenticator used to respond to challenges from proxy servers. Use {@link
-     * #authenticator} to set the authenticator for origin servers.
-     *
-     * <p>If unset, the {@linkplain Authenticator#NONE no authentication will be attempted}.
-     */
-    public Builder proxyAuthenticator(Authenticator proxyAuthenticator) {
-      if (proxyAuthenticator == null) throw new NullPointerException("proxyAuthenticator == null");
-      this.proxyAuthenticator = proxyAuthenticator;
-      return this;
-    }
-
-    /**
-     * Sets the connection pool used to recycle HTTP and HTTPS connections.
-     *
-     * <p>If unset, a new connection pool will be used.
-     */
-    public Builder connectionPool(ConnectionPool connectionPool) {
-      if (connectionPool == null) throw new NullPointerException("connectionPool == null");
-      this.connectionPool = connectionPool;
-      return this;
-    }
-
-    /**
-     * Configure this client to follow redirects from HTTPS to HTTP and from HTTP to HTTPS.
-     *
-     * <p>If unset, protocol redirects will be followed. This is different than the built-in {@code
-     * HttpURLConnection}'s default.
-     */
-    public Builder followSslRedirects(boolean followProtocolRedirects) {
-      this.followSslRedirects = followProtocolRedirects;
-      return this;
-    }
-
-    /** Configure this client to follow redirects. If unset, redirects will be followed. */
-    public Builder followRedirects(boolean followRedirects) {
-      this.followRedirects = followRedirects;
-      return this;
-    }
-
-    /**
-     * Configure this client to retry or not when a connectivity problem is encountered. By default,
-     * this client silently recovers from the following problems:
-     *
-     * <ul>
-     *   <li><strong>Unreachable IP addresses.</strong> If the URL's host has multiple IP addresses,
-     *       failure to reach any individual IP address doesn't fail the overall request. This can
-     *       increase availability of multi-homed services.
-     *   <li><strong>Stale pooled connections.</strong> The {@link ConnectionPool} reuses sockets
-     *       to decrease request latency, but these connections will occasionally time out.
-     *   <li><strong>Unreachable proxy servers.</strong> A {@link ProxySelector} can be used to
-     *       attempt multiple proxy servers in sequence, eventually falling back to a direct
-     *       connection.
-     * </ul>
-     *
-     * Set this to false to avoid retrying requests when doing so is destructive. In this case the
-     * calling application should do its own recovery of connectivity failures.
-     */
-    public Builder retryOnConnectionFailure(boolean retryOnConnectionFailure) {
-      this.retryOnConnectionFailure = retryOnConnectionFailure;
-      return this;
-    }
-
-    /**
-     * Sets the dispatcher used to set policy and execute asynchronous requests. Must not be null.
-     */
-    public Builder dispatcher(Dispatcher dispatcher) {
-      if (dispatcher == null) throw new IllegalArgumentException("dispatcher == null");
-      this.dispatcher = dispatcher;
-      return this;
-    }
-
-    /**
-     * Configure the protocols used by this client to communicate with remote servers. By default
-     * this client will prefer the most efficient transport available, falling back to more
-     * ubiquitous protocols. Applications should only call this method to avoid specific
-     * compatibility problems, such as web servers that behave incorrectly when HTTP/2 is enabled.
-     *
-     * <p>The following protocols are currently supported:
-     *
-     * <ul>
-     *     <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>
-     *     <li><a href="https://tools.ietf.org/html/rfc7540">h2</a>
-     *     <li><a href="https://tools.ietf.org/html/rfc7540#section-3.4">h2 with prior knowledge
-     *         (cleartext only)</a>
-     * </ul>
-     *
-     * <p><strong>This is an evolving set.</strong> Future releases include support for transitional
-     * protocols. The http/1.1 transport will never be dropped.
-     *
-     * <p>If multiple protocols are specified, <a
-     * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a> will be used to
-     * negotiate a transport. Protocol negotiation is only attempted for HTTPS URLs.
-     *
-     * <p>{@link Protocol#HTTP_1_0} is not supported in this set. Requests are initiated with {@code
-     * HTTP/1.1}. If the server responds with {@code HTTP/1.0}, that will be exposed by {@link
-     * Response#protocol()}.
-     *
-     * @param protocols the protocols to use, in order of preference. If the list contains {@link
-     *     Protocol#H2_PRIOR_KNOWLEDGE} then that must be the only protocol and HTTPS URLs will not
-     *     be supported. Otherwise the list must contain {@link Protocol#HTTP_1_1}. The list must
-     *     not contain null or {@link Protocol#HTTP_1_0}.
-     */
-    public Builder protocols(List<Protocol> protocols) {
-      // Create a private copy of the list.
-      protocols = new ArrayList<>(protocols);
-
-      // Validate that the list has everything we require and nothing we forbid.
-      if (!protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE)
-          && !protocols.contains(Protocol.HTTP_1_1)) {
-        throw new IllegalArgumentException(
-            "protocols must contain h2_prior_knowledge or http/1.1: " + protocols);
-      }
-      if (protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE) && protocols.size() > 1) {
-        throw new IllegalArgumentException(
-            "protocols containing h2_prior_knowledge cannot use other protocols: " + protocols);
-      }
-      if (protocols.contains(Protocol.HTTP_1_0)) {
-        throw new IllegalArgumentException("protocols must not contain http/1.0: " + protocols);
-      }
-      if (protocols.contains(null)) {
-        throw new IllegalArgumentException("protocols must not contain null");
-      }
-
-      // Remove protocols that we no longer support.
-      protocols.remove(Protocol.SPDY_3);
-
-      // Assign as an unmodifiable list. This is effectively immutable.
-      this.protocols = Collections.unmodifiableList(protocols);
-      return this;
-    }
-
-    public Builder connectionSpecs(List<ConnectionSpec> connectionSpecs) {
-      this.connectionSpecs = Util.immutableList(connectionSpecs);
-      return this;
-    }
-
-    /**
-     * Returns a modifiable list of interceptors that observe the full span of each call: from
-     * before the connection is established (if any) until after the response source is selected
-     * (either the origin server, cache, or both).
-     */
-    public List<Interceptor> interceptors() {
-      return interceptors;
-    }
-
-    public Builder addInterceptor(Interceptor interceptor) {
-      if (interceptor == null) throw new IllegalArgumentException("interceptor == null");
-      interceptors.add(interceptor);
-      return this;
-    }
-
-    /**
-     * Returns a modifiable list of interceptors that observe a single network request and response.
-     * These interceptors must call {@link Interceptor.Chain#proceed} exactly once: it is an error
-     * for a network interceptor to short-circuit or repeat a network request.
-     */
-    public List<Interceptor> networkInterceptors() {
-      return networkInterceptors;
-    }
-
-    public Builder addNetworkInterceptor(Interceptor interceptor) {
-      if (interceptor == null) throw new IllegalArgumentException("interceptor == null");
-      networkInterceptors.add(interceptor);
-      return this;
-    }
-
-    /**
-     * Configure a single client scoped listener that will receive all analytic events
-     * for this client.
-     *
-     * @see EventListener for semantics and restrictions on listener implementations.
-     */
-    public Builder eventListener(EventListener eventListener) {
-      if (eventListener == null) throw new NullPointerException("eventListener == null");
-      this.eventListenerFactory = EventListener.factory(eventListener);
-      return this;
-    }
-
-    /**
-     * Configure a factory to provide per-call scoped listeners that will receive analytic events
-     * for this client.
-     *
-     * @see EventListener for semantics and restrictions on listener implementations.
-     */
-    public Builder eventListenerFactory(EventListener.Factory eventListenerFactory) {
-      if (eventListenerFactory == null) {
-        throw new NullPointerException("eventListenerFactory == null");
-      }
-      this.eventListenerFactory = eventListenerFactory;
-      return this;
-    }
-
-    public OkHttpClient build() {
-      return new OkHttpClient(this);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Protocol.java b/okhttp/src/main/java/okhttp3/Protocol.java
deleted file mode 100644
index a96070ed59..0000000000
--- a/okhttp/src/main/java/okhttp3/Protocol.java
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-
-/**
- * Protocols that OkHttp implements for <a
- * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a> selection.
- *
- * <h3>Protocol vs Scheme</h3> Despite its name, {@link java.net.URL#getProtocol()} returns the
- * {@linkplain java.net.URI#getScheme() scheme} (http, https, etc.) of the URL, not the protocol
- * (http/1.1, spdy/3.1, etc.). OkHttp uses the word <i>protocol</i> to identify how HTTP messages
- * are framed.
- */
-public enum Protocol {
-  /**
-   * An obsolete plaintext framing that does not use persistent sockets by default.
-   */
-  HTTP_1_0("http/1.0"),
-
-  /**
-   * A plaintext framing that includes persistent connections.
-   *
-   * <p>This version of OkHttp implements <a href="https://tools.ietf.org/html/rfc7230">RFC
-   * 7230</a>, and tracks revisions to that spec.
-   */
-  HTTP_1_1("http/1.1"),
-
-  /**
-   * Chromium's binary-framed protocol that includes header compression, multiplexing multiple
-   * requests on the same socket, and server-push. HTTP/1.1 semantics are layered on SPDY/3.
-   *
-   * <p>Current versions of OkHttp do not support this protocol.
-   *
-   * @deprecated OkHttp has dropped support for SPDY. Prefer {@link #HTTP_2}.
-   */
-  SPDY_3("spdy/3.1"),
-
-  /**
-   * The IETF's binary-framed protocol that includes header compression, multiplexing multiple
-   * requests on the same socket, and server-push. HTTP/1.1 semantics are layered on HTTP/2.
-   *
-   * <p>HTTP/2 requires deployments of HTTP/2 that use TLS 1.2 support {@linkplain
-   * CipherSuite#TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256} , present in Java 8+ and Android 5+. Servers
-   * that enforce this may send an exception message including the string {@code
-   * INADEQUATE_SECURITY}.
-   */
-  HTTP_2("h2"),
-
-  /**
-   * Cleartext HTTP/2 with no "upgrade" round trip. This option requires the client to have prior
-   * knowledge that the server supports cleartext HTTP/2.
-   *
-   * @see <a href="https://tools.ietf.org/html/rfc7540#section-3.4">Starting HTTP/2 with Prior
-   * Knowledge</a>
-   */
-  H2_PRIOR_KNOWLEDGE("h2_prior_knowledge"),
-
-  /**
-   * QUIC (Quick UDP Internet Connection) is a new multiplexed and secure transport atop UDP,
-   * designed from the ground up and optimized for HTTP/2 semantics.
-   * HTTP/1.1 semantics are layered on HTTP/2.
-   *
-   * <p>QUIC is not natively supported by OkHttp, but provided to allow a theoretical
-   * interceptor that provides support.
-   */
-  QUIC("quic");
-
-  private final String protocol;
-
-  Protocol(String protocol) {
-    this.protocol = protocol;
-  }
-
-  /**
-   * Returns the protocol identified by {@code protocol}.
-   *
-   * @throws IOException if {@code protocol} is unknown.
-   */
-  public static Protocol get(String protocol) throws IOException {
-    // Unroll the loop over values() to save an allocation.
-    if (protocol.equals(HTTP_1_0.protocol)) return HTTP_1_0;
-    if (protocol.equals(HTTP_1_1.protocol)) return HTTP_1_1;
-    if (protocol.equals(H2_PRIOR_KNOWLEDGE.protocol)) return H2_PRIOR_KNOWLEDGE;
-    if (protocol.equals(HTTP_2.protocol)) return HTTP_2;
-    if (protocol.equals(SPDY_3.protocol)) return SPDY_3;
-    if (protocol.equals(QUIC.protocol)) return QUIC;
-    throw new IOException("Unexpected protocol: " + protocol);
-  }
-
-  /**
-   * Returns the string used to identify this protocol for ALPN, like "http/1.1", "spdy/3.1" or
-   * "h2".
-   *
-   * @see <a href="https://www.iana.org/assignments/tls-extensiontype-values">IANA
-   * tls-extensiontype-values</a>
-   */
-  @Override public String toString() {
-    return protocol;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/RealCall.java b/okhttp/src/main/java/okhttp3/RealCall.java
deleted file mode 100644
index bb108764da..0000000000
--- a/okhttp/src/main/java/okhttp3/RealCall.java
+++ /dev/null
@@ -1,236 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.io.InterruptedIOException;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.RejectedExecutionException;
-import java.util.concurrent.atomic.AtomicInteger;
-import okhttp3.internal.NamedRunnable;
-import okhttp3.internal.cache.CacheInterceptor;
-import okhttp3.internal.connection.ConnectInterceptor;
-import okhttp3.internal.connection.Transmitter;
-import okhttp3.internal.http.BridgeInterceptor;
-import okhttp3.internal.http.CallServerInterceptor;
-import okhttp3.internal.http.RealInterceptorChain;
-import okhttp3.internal.http.RetryAndFollowUpInterceptor;
-import okhttp3.internal.platform.Platform;
-import okio.Timeout;
-
-import static okhttp3.internal.Util.closeQuietly;
-import static okhttp3.internal.platform.Platform.INFO;
-
-final class RealCall implements Call {
-  final OkHttpClient client;
-
-  /**
-   * There is a cycle between the {@link Call} and {@link Transmitter} that makes this awkward.
-   * This is set after immediately after creating the call instance.
-   */
-  private Transmitter transmitter;
-
-  /** The application's original request unadulterated by redirects or auth headers. */
-  final Request originalRequest;
-  final boolean forWebSocket;
-
-  // Guarded by this.
-  private boolean executed;
-
-  private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
-    this.client = client;
-    this.originalRequest = originalRequest;
-    this.forWebSocket = forWebSocket;
-  }
-
-  static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
-    // Safely publish the Call instance to the EventListener.
-    RealCall call = new RealCall(client, originalRequest, forWebSocket);
-    call.transmitter = new Transmitter(client, call);
-    return call;
-  }
-
-  @Override public Request request() {
-    return originalRequest;
-  }
-
-  @Override public Response execute() throws IOException {
-    synchronized (this) {
-      if (executed) throw new IllegalStateException("Already Executed");
-      executed = true;
-    }
-    transmitter.timeoutEnter();
-    transmitter.callStart();
-    try {
-      client.dispatcher().executed(this);
-      return getResponseWithInterceptorChain();
-    } finally {
-      client.dispatcher().finished(this);
-    }
-  }
-
-  @Override public void enqueue(Callback responseCallback) {
-    synchronized (this) {
-      if (executed) throw new IllegalStateException("Already Executed");
-      executed = true;
-    }
-    transmitter.callStart();
-    client.dispatcher().enqueue(new AsyncCall(responseCallback));
-  }
-
-  @Override public void cancel() {
-    transmitter.cancel();
-  }
-
-  @Override public Timeout timeout() {
-    return transmitter.timeout();
-  }
-
-  @Override public synchronized boolean isExecuted() {
-    return executed;
-  }
-
-  @Override public boolean isCanceled() {
-    return transmitter.isCanceled();
-  }
-
-  @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
-  @Override public RealCall clone() {
-    return RealCall.newRealCall(client, originalRequest, forWebSocket);
-  }
-
-  final class AsyncCall extends NamedRunnable {
-    private final Callback responseCallback;
-    private volatile AtomicInteger callsPerHost = new AtomicInteger(0);
-
-    AsyncCall(Callback responseCallback) {
-      super("OkHttp %s", redactedUrl());
-      this.responseCallback = responseCallback;
-    }
-
-    AtomicInteger callsPerHost() {
-      return callsPerHost;
-    }
-
-    void reuseCallsPerHostFrom(AsyncCall other) {
-      this.callsPerHost = other.callsPerHost;
-    }
-
-    String host() {
-      return originalRequest.url().host();
-    }
-
-    Request request() {
-      return originalRequest;
-    }
-
-    RealCall get() {
-      return RealCall.this;
-    }
-
-    /**
-     * Attempt to enqueue this async call on {@code executorService}. This will attempt to clean up
-     * if the executor has been shut down by reporting the call as failed.
-     */
-    void executeOn(ExecutorService executorService) {
-      assert (!Thread.holdsLock(client.dispatcher()));
-      boolean success = false;
-      try {
-        executorService.execute(this);
-        success = true;
-      } catch (RejectedExecutionException e) {
-        InterruptedIOException ioException = new InterruptedIOException("executor rejected");
-        ioException.initCause(e);
-        transmitter.noMoreExchanges(ioException);
-        responseCallback.onFailure(RealCall.this, ioException);
-      } finally {
-        if (!success) {
-          client.dispatcher().finished(this); // This call is no longer running!
-        }
-      }
-    }
-
-    @Override protected void execute() {
-      boolean signalledCallback = false;
-      transmitter.timeoutEnter();
-      try {
-        Response response = getResponseWithInterceptorChain();
-        signalledCallback = true;
-        responseCallback.onResponse(RealCall.this, response);
-      } catch (IOException e) {
-        if (signalledCallback) {
-          // Do not signal the callback twice!
-          Platform.get().log(INFO, "Callback failure for " + toLoggableString(), e);
-        } else {
-          responseCallback.onFailure(RealCall.this, e);
-        }
-      } finally {
-        client.dispatcher().finished(this);
-      }
-    }
-  }
-
-  /**
-   * Returns a string that describes this call. Doesn't include a full URL as that might contain
-   * sensitive information.
-   */
-  String toLoggableString() {
-    return (isCanceled() ? "canceled " : "")
-        + (forWebSocket ? "web socket" : "call")
-        + " to " + redactedUrl();
-  }
-
-  String redactedUrl() {
-    return originalRequest.url().redact();
-  }
-
-  Response getResponseWithInterceptorChain() throws IOException {
-    // Build a full stack of interceptors.
-    List<Interceptor> interceptors = new ArrayList<>();
-    interceptors.addAll(client.interceptors());
-    interceptors.add(new RetryAndFollowUpInterceptor(client));
-    interceptors.add(new BridgeInterceptor(client.cookieJar()));
-    interceptors.add(new CacheInterceptor(client.internalCache()));
-    interceptors.add(new ConnectInterceptor(client));
-    if (!forWebSocket) {
-      interceptors.addAll(client.networkInterceptors());
-    }
-    interceptors.add(new CallServerInterceptor(forWebSocket));
-
-    Interceptor.Chain chain = new RealInterceptorChain(interceptors, transmitter, null, 0,
-        originalRequest, this, client.connectTimeoutMillis(),
-        client.readTimeoutMillis(), client.writeTimeoutMillis());
-
-    boolean calledNoMoreExchanges = false;
-    try {
-      Response response = chain.proceed(originalRequest);
-      if (transmitter.isCanceled()) {
-        closeQuietly(response);
-        throw new IOException("Canceled");
-      }
-      return response;
-    } catch (IOException e) {
-      calledNoMoreExchanges = true;
-      throw transmitter.noMoreExchanges(e);
-    } finally {
-      if (!calledNoMoreExchanges) {
-        transmitter.noMoreExchanges(null);
-      }
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Request.java b/okhttp/src/main/java/okhttp3/Request.java
deleted file mode 100644
index 9bbdc86407..0000000000
--- a/okhttp/src/main/java/okhttp3/Request.java
+++ /dev/null
@@ -1,296 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.net.URL;
-import java.util.Collections;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import javax.annotation.Nullable;
-import okhttp3.internal.Util;
-import okhttp3.internal.http.HttpMethod;
-
-/**
- * An HTTP request. Instances of this class are immutable if their {@link #body} is null or itself
- * immutable.
- */
-public final class Request {
-  final HttpUrl url;
-  final String method;
-  final Headers headers;
-  final @Nullable RequestBody body;
-  final Map<Class<?>, Object> tags;
-
-  private volatile @Nullable CacheControl cacheControl; // Lazily initialized.
-
-  Request(Builder builder) {
-    this.url = builder.url;
-    this.method = builder.method;
-    this.headers = builder.headers.build();
-    this.body = builder.body;
-    this.tags = Util.immutableMap(builder.tags);
-  }
-
-  public HttpUrl url() {
-    return url;
-  }
-
-  public String method() {
-    return method;
-  }
-
-  public Headers headers() {
-    return headers;
-  }
-
-  public @Nullable String header(String name) {
-    return headers.get(name);
-  }
-
-  public List<String> headers(String name) {
-    return headers.values(name);
-  }
-
-  public @Nullable RequestBody body() {
-    return body;
-  }
-
-  /**
-   * Returns the tag attached with {@code Object.class} as a key, or null if no tag is attached with
-   * that key.
-   *
-   * <p>Prior to OkHttp 3.11, this method never returned null if no tag was attached. Instead it
-   * returned either this request, or the request upon which this request was derived with {@link
-   * #newBuilder()}.
-   */
-  public @Nullable Object tag() {
-    return tag(Object.class);
-  }
-
-  /**
-   * Returns the tag attached with {@code type} as a key, or null if no tag is attached with that
-   * key.
-   */
-  public @Nullable <T> T tag(Class<? extends T> type) {
-    return type.cast(tags.get(type));
-  }
-
-  public Builder newBuilder() {
-    return new Builder(this);
-  }
-
-  /**
-   * Returns the cache control directives for this response. This is never null, even if this
-   * response contains no {@code Cache-Control} header.
-   */
-  public CacheControl cacheControl() {
-    CacheControl result = cacheControl;
-    return result != null ? result : (cacheControl = CacheControl.parse(headers));
-  }
-
-  public boolean isHttps() {
-    return url.isHttps();
-  }
-
-  @Override public String toString() {
-    return "Request{method="
-        + method
-        + ", url="
-        + url
-        + ", tags="
-        + tags
-        + '}';
-  }
-
-  public static class Builder {
-    @Nullable HttpUrl url;
-    String method;
-    Headers.Builder headers;
-    @Nullable RequestBody body;
-
-    /** A mutable map of tags, or an immutable empty map if we don't have any. */
-    Map<Class<?>, Object> tags = Collections.emptyMap();
-
-    public Builder() {
-      this.method = "GET";
-      this.headers = new Headers.Builder();
-    }
-
-    Builder(Request request) {
-      this.url = request.url;
-      this.method = request.method;
-      this.body = request.body;
-      this.tags = request.tags.isEmpty()
-          ? Collections.emptyMap()
-          : new LinkedHashMap<>(request.tags);
-      this.headers = request.headers.newBuilder();
-    }
-
-    public Builder url(HttpUrl url) {
-      if (url == null) throw new NullPointerException("url == null");
-      this.url = url;
-      return this;
-    }
-
-    /**
-     * Sets the URL target of this request.
-     *
-     * @throws IllegalArgumentException if {@code url} is not a valid HTTP or HTTPS URL. Avoid this
-     * exception by calling {@link HttpUrl#parse}; it returns null for invalid URLs.
-     */
-    public Builder url(String url) {
-      if (url == null) throw new NullPointerException("url == null");
-
-      // Silently replace web socket URLs with HTTP URLs.
-      if (url.regionMatches(true, 0, "ws:", 0, 3)) {
-        url = "http:" + url.substring(3);
-      } else if (url.regionMatches(true, 0, "wss:", 0, 4)) {
-        url = "https:" + url.substring(4);
-      }
-
-      return url(HttpUrl.get(url));
-    }
-
-    /**
-     * Sets the URL target of this request.
-     *
-     * @throws IllegalArgumentException if the scheme of {@code url} is not {@code http} or {@code
-     * https}.
-     */
-    public Builder url(URL url) {
-      if (url == null) throw new NullPointerException("url == null");
-      return url(HttpUrl.get(url.toString()));
-    }
-
-    /**
-     * Sets the header named {@code name} to {@code value}. If this request already has any headers
-     * with that name, they are all replaced.
-     */
-    public Builder header(String name, String value) {
-      headers.set(name, value);
-      return this;
-    }
-
-    /**
-     * Adds a header with {@code name} and {@code value}. Prefer this method for multiply-valued
-     * headers like "Cookie".
-     *
-     * <p>Note that for some headers including {@code Content-Length} and {@code Content-Encoding},
-     * OkHttp may replace {@code value} with a header derived from the request body.
-     */
-    public Builder addHeader(String name, String value) {
-      headers.add(name, value);
-      return this;
-    }
-
-    /** Removes all headers named {@code name} on this builder. */
-    public Builder removeHeader(String name) {
-      headers.removeAll(name);
-      return this;
-    }
-
-    /** Removes all headers on this builder and adds {@code headers}. */
-    public Builder headers(Headers headers) {
-      this.headers = headers.newBuilder();
-      return this;
-    }
-
-    /**
-     * Sets this request's {@code Cache-Control} header, replacing any cache control headers already
-     * present. If {@code cacheControl} doesn't define any directives, this clears this request's
-     * cache-control headers.
-     */
-    public Builder cacheControl(CacheControl cacheControl) {
-      String value = cacheControl.toString();
-      if (value.isEmpty()) return removeHeader("Cache-Control");
-      return header("Cache-Control", value);
-    }
-
-    public Builder get() {
-      return method("GET", null);
-    }
-
-    public Builder head() {
-      return method("HEAD", null);
-    }
-
-    public Builder post(RequestBody body) {
-      return method("POST", body);
-    }
-
-    public Builder delete(@Nullable RequestBody body) {
-      return method("DELETE", body);
-    }
-
-    public Builder delete() {
-      return delete(Util.EMPTY_REQUEST);
-    }
-
-    public Builder put(RequestBody body) {
-      return method("PUT", body);
-    }
-
-    public Builder patch(RequestBody body) {
-      return method("PATCH", body);
-    }
-
-    public Builder method(String method, @Nullable RequestBody body) {
-      if (method == null) throw new NullPointerException("method == null");
-      if (method.length() == 0) throw new IllegalArgumentException("method.length() == 0");
-      if (body != null && !HttpMethod.permitsRequestBody(method)) {
-        throw new IllegalArgumentException("method " + method + " must not have a request body.");
-      }
-      if (body == null && HttpMethod.requiresRequestBody(method)) {
-        throw new IllegalArgumentException("method " + method + " must have a request body.");
-      }
-      this.method = method;
-      this.body = body;
-      return this;
-    }
-
-    /** Attaches {@code tag} to the request using {@code Object.class} as a key. */
-    public Builder tag(@Nullable Object tag) {
-      return tag(Object.class, tag);
-    }
-
-    /**
-     * Attaches {@code tag} to the request using {@code type} as a key. Tags can be read from a
-     * request using {@link Request#tag}. Use null to remove any existing tag assigned for {@code
-     * type}.
-     *
-     * <p>Use this API to attach timing, debugging, or other application data to a request so that
-     * you may read it in interceptors, event listeners, or callbacks.
-     */
-    public <T> Builder tag(Class<? super T> type, @Nullable T tag) {
-      if (type == null) throw new NullPointerException("type == null");
-
-      if (tag == null) {
-        tags.remove(type);
-      } else {
-        if (tags.isEmpty()) tags = new LinkedHashMap<>();
-        tags.put(type, type.cast(tag));
-      }
-
-      return this;
-    }
-
-    public Request build() {
-      if (url == null) throw new IllegalStateException("url == null");
-      return new Request(this);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/RequestBody.java b/okhttp/src/main/java/okhttp3/RequestBody.java
deleted file mode 100644
index 39107a86c5..0000000000
--- a/okhttp/src/main/java/okhttp3/RequestBody.java
+++ /dev/null
@@ -1,176 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.File;
-import java.io.IOException;
-import java.nio.charset.Charset;
-import javax.annotation.Nullable;
-import okhttp3.internal.Util;
-import okio.BufferedSink;
-import okio.ByteString;
-import okio.Okio;
-import okio.Source;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-
-public abstract class RequestBody {
-  /** Returns the Content-Type header for this body. */
-  public abstract @Nullable MediaType contentType();
-
-  /**
-   * Returns the number of bytes that will be written to {@code sink} in a call to {@link #writeTo},
-   * or -1 if that count is unknown.
-   */
-  public long contentLength() throws IOException {
-    return -1;
-  }
-
-  /** Writes the content of this request to {@code sink}. */
-  public abstract void writeTo(BufferedSink sink) throws IOException;
-
-  /**
-   * A duplex request body is special in how it is <strong>transmitted</strong> on the network and
-   * in the <strong>API contract</strong> between OkHttp and the application.
-   *
-   * <p>This method returns false unless it is overridden by a subclass.
-   *
-   * <h3>Duplex Transmission</h3>
-   *
-   * <p>With regular HTTP calls the request always completes sending before the response may begin
-   * receiving. With duplex the request and response may be interleaved! That is, request body bytes
-   * may be sent after response headers or body bytes have been received.
-   *
-   * <p>Though any call may be initiated as a duplex call, only web servers that are specially
-   * designed for this nonstandard interaction will use it. As of 2019-01, the only widely-used
-   * implementation of this pattern is <a
-   * href="https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md">gRPC</a>.
-   *
-   * <p>Because the encoding of interleaved data is not well-defined for HTTP/1, duplex request
-   * bodies may only be used with HTTP/2. Calls to HTTP/1 servers will fail before the HTTP request
-   * is transmitted. If you cannot ensure that your client and server both support HTTP/2, do not
-   * use this feature.
-   *
-   * <p>Duplex APIs</p>
-   *
-   * <p>With regular request bodies it is not legal to write bytes to the sink passed to {@link
-   * RequestBody#writeTo} after that method returns. For duplex requests bodies that condition is
-   * lifted. Such writes occur on an application-provided thread and may occur concurrently with
-   * reads of the {@link ResponseBody}. For duplex request bodies, {@link #writeTo} should return
-   * quickly, possibly by handing off the provided request body to another thread to perform
-   * writing.
-   */
-  public boolean isDuplex() {
-    return false;
-  }
-
-  /**
-   * Returns true if this body expects at most one call to {@link #writeTo} and can be transmitted
-   * at most once. This is typically used when writing the request body is destructive and it is not
-   * possible to recreate the request body after it has been sent.
-   *
-   * <p>This method returns false unless it is overridden by a subclass.
-   *
-   * <p>By default OkHttp will attempt to retransmit request bodies when the original request fails
-   * due to a stale connection, a client timeout (HTTP 408), a satisfied authorization challenge
-   * (HTTP 401 and 407), or a retryable server failure (HTTP 503 with a {@code Retry-After: 0}
-   * header).
-   */
-  public boolean isOneShot() {
-    return false;
-  }
-
-  /**
-   * Returns a new request body that transmits {@code content}. If {@code contentType} is non-null
-   * and lacks a charset, this will use UTF-8.
-   */
-  public static RequestBody create(@Nullable MediaType contentType, String content) {
-    Charset charset = UTF_8;
-    if (contentType != null) {
-      charset = contentType.charset();
-      if (charset == null) {
-        charset = UTF_8;
-        contentType = MediaType.parse(contentType + "; charset=utf-8");
-      }
-    }
-    byte[] bytes = content.getBytes(charset);
-    return create(contentType, bytes);
-  }
-
-  /** Returns a new request body that transmits {@code content}. */
-  public static RequestBody create(
-      final @Nullable MediaType contentType, final ByteString content) {
-    return new RequestBody() {
-      @Override public @Nullable MediaType contentType() {
-        return contentType;
-      }
-
-      @Override public long contentLength() throws IOException {
-        return content.size();
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        sink.write(content);
-      }
-    };
-  }
-
-  /** Returns a new request body that transmits {@code content}. */
-  public static RequestBody create(final @Nullable MediaType contentType, final byte[] content) {
-    return create(contentType, content, 0, content.length);
-  }
-
-  /** Returns a new request body that transmits {@code content}. */
-  public static RequestBody create(final @Nullable MediaType contentType, final byte[] content,
-      final int offset, final int byteCount) {
-    if (content == null) throw new NullPointerException("content == null");
-    Util.checkOffsetAndCount(content.length, offset, byteCount);
-    return new RequestBody() {
-      @Override public @Nullable MediaType contentType() {
-        return contentType;
-      }
-
-      @Override public long contentLength() {
-        return byteCount;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        sink.write(content, offset, byteCount);
-      }
-    };
-  }
-
-  /** Returns a new request body that transmits the content of {@code file}. */
-  public static RequestBody create(final @Nullable MediaType contentType, final File file) {
-    if (file == null) throw new NullPointerException("file == null");
-
-    return new RequestBody() {
-      @Override public @Nullable MediaType contentType() {
-        return contentType;
-      }
-
-      @Override public long contentLength() {
-        return file.length();
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        try (Source source = Okio.source(file)) {
-          sink.writeAll(source);
-        }
-      }
-    };
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Response.java b/okhttp/src/main/java/okhttp3/Response.java
deleted file mode 100644
index efa9f0dd2a..0000000000
--- a/okhttp/src/main/java/okhttp3/Response.java
+++ /dev/null
@@ -1,458 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.util.Collections;
-import java.util.List;
-import javax.annotation.Nullable;
-import okhttp3.internal.connection.Exchange;
-import okhttp3.internal.http.HttpHeaders;
-import okio.Buffer;
-import okio.BufferedSource;
-
-import static java.net.HttpURLConnection.HTTP_MOVED_PERM;
-import static java.net.HttpURLConnection.HTTP_MOVED_TEMP;
-import static java.net.HttpURLConnection.HTTP_MULT_CHOICE;
-import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
-import static java.net.HttpURLConnection.HTTP_SEE_OTHER;
-import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
-import static okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT;
-import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
-
-/**
- * An HTTP response. Instances of this class are not immutable: the response body is a one-shot
- * value that may be consumed only once and then closed. All other properties are immutable.
- *
- * <p>This class implements {@link Closeable}. Closing it simply closes its response body. See
- * {@link ResponseBody} for an explanation and examples.
- */
-public final class Response implements Closeable {
-  final Request request;
-  final Protocol protocol;
-  final int code;
-  final String message;
-  final @Nullable Handshake handshake;
-  final Headers headers;
-  final @Nullable ResponseBody body;
-  final @Nullable Response networkResponse;
-  final @Nullable Response cacheResponse;
-  final @Nullable Response priorResponse;
-  final long sentRequestAtMillis;
-  final long receivedResponseAtMillis;
-  final @Nullable Exchange exchange;
-
-  private volatile @Nullable CacheControl cacheControl; // Lazily initialized.
-
-  Response(Builder builder) {
-    this.request = builder.request;
-    this.protocol = builder.protocol;
-    this.code = builder.code;
-    this.message = builder.message;
-    this.handshake = builder.handshake;
-    this.headers = builder.headers.build();
-    this.body = builder.body;
-    this.networkResponse = builder.networkResponse;
-    this.cacheResponse = builder.cacheResponse;
-    this.priorResponse = builder.priorResponse;
-    this.sentRequestAtMillis = builder.sentRequestAtMillis;
-    this.receivedResponseAtMillis = builder.receivedResponseAtMillis;
-    this.exchange = builder.exchange;
-  }
-
-  /**
-   * The wire-level request that initiated this HTTP response. This is not necessarily the same
-   * request issued by the application:
-   *
-   * <ul>
-   *     <li>It may be transformed by the HTTP client. For example, the client may copy headers like
-   *         {@code Content-Length} from the request body.
-   *     <li>It may be the request generated in response to an HTTP redirect or authentication
-   *         challenge. In this case the request URL may be different than the initial request URL.
-   * </ul>
-   */
-  public Request request() {
-    return request;
-  }
-
-  /**
-   * Returns the HTTP protocol, such as {@link Protocol#HTTP_1_1} or {@link Protocol#HTTP_1_0}.
-   */
-  public Protocol protocol() {
-    return protocol;
-  }
-
-  /** Returns the HTTP status code. */
-  public int code() {
-    return code;
-  }
-
-  /**
-   * Returns true if the code is in [200..300), which means the request was successfully received,
-   * understood, and accepted.
-   */
-  public boolean isSuccessful() {
-    return code >= 200 && code < 300;
-  }
-
-  /** Returns the HTTP status message. */
-  public String message() {
-    return message;
-  }
-
-  /**
-   * Returns the TLS handshake of the connection that carried this response, or null if the response
-   * was received without TLS.
-   */
-  public @Nullable Handshake handshake() {
-    return handshake;
-  }
-
-  public List<String> headers(String name) {
-    return headers.values(name);
-  }
-
-  public @Nullable String header(String name) {
-    return header(name, null);
-  }
-
-  public @Nullable String header(String name, @Nullable String defaultValue) {
-    String result = headers.get(name);
-    return result != null ? result : defaultValue;
-  }
-
-  public Headers headers() {
-    return headers;
-  }
-
-  /**
-   * Returns the trailers after the HTTP response, which may be empty. It is an error to call this
-   * before the entire HTTP response body has been consumed.
-   */
-  public Headers trailers() throws IOException {
-    if (exchange == null) throw new IllegalStateException("trailers not available");
-    return exchange.trailers();
-  }
-
-  /**
-   * Peeks up to {@code byteCount} bytes from the response body and returns them as a new response
-   * body. If fewer than {@code byteCount} bytes are in the response body, the full response body is
-   * returned. If more than {@code byteCount} bytes are in the response body, the returned value
-   * will be truncated to {@code byteCount} bytes.
-   *
-   * <p>It is an error to call this method after the body has been consumed.
-   *
-   * <p><strong>Warning:</strong> this method loads the requested bytes into memory. Most
-   * applications should set a modest limit on {@code byteCount}, such as 1 MiB.
-   */
-  public ResponseBody peekBody(long byteCount) throws IOException {
-    BufferedSource peeked = body.source().peek();
-    Buffer buffer = new Buffer();
-    peeked.request(byteCount);
-    buffer.write(peeked, Math.min(byteCount, peeked.getBuffer().size()));
-    return ResponseBody.create(body.contentType(), buffer.size(), buffer);
-  }
-
-  /**
-   * Returns a non-null value if this response was passed to {@link Callback#onResponse} or returned
-   * from {@link Call#execute()}. Response bodies must be {@linkplain ResponseBody closed} and may
-   * be consumed only once.
-   *
-   * <p>This always returns null on responses returned from {@link #cacheResponse}, {@link
-   * #networkResponse}, and {@link #priorResponse()}.
-   */
-  public @Nullable ResponseBody body() {
-    return body;
-  }
-
-  public Builder newBuilder() {
-    return new Builder(this);
-  }
-
-  /** Returns true if this response redirects to another resource. */
-  public boolean isRedirect() {
-    switch (code) {
-      case HTTP_PERM_REDIRECT:
-      case HTTP_TEMP_REDIRECT:
-      case HTTP_MULT_CHOICE:
-      case HTTP_MOVED_PERM:
-      case HTTP_MOVED_TEMP:
-      case HTTP_SEE_OTHER:
-        return true;
-      default:
-        return false;
-    }
-  }
-
-  /**
-   * Returns the raw response received from the network. Will be null if this response didn't use
-   * the network, such as when the response is fully cached. The body of the returned response
-   * should not be read.
-   */
-  public @Nullable Response networkResponse() {
-    return networkResponse;
-  }
-
-  /**
-   * Returns the raw response received from the cache. Will be null if this response didn't use the
-   * cache. For conditional get requests the cache response and network response may both be
-   * non-null. The body of the returned response should not be read.
-   */
-  public @Nullable Response cacheResponse() {
-    return cacheResponse;
-  }
-
-  /**
-   * Returns the response for the HTTP redirect or authorization challenge that triggered this
-   * response, or null if this response wasn't triggered by an automatic retry. The body of the
-   * returned response should not be read because it has already been consumed by the redirecting
-   * client.
-   */
-  public @Nullable Response priorResponse() {
-    return priorResponse;
-  }
-
-  /**
-   * Returns the RFC 7235 authorization challenges appropriate for this response's code. If the
-   * response code is 401 unauthorized, this returns the "WWW-Authenticate" challenges. If the
-   * response code is 407 proxy unauthorized, this returns the "Proxy-Authenticate" challenges.
-   * Otherwise this returns an empty list of challenges.
-   *
-   * <p>If a challenge uses the {@code token68} variant instead of auth params, there is exactly one
-   * auth param in the challenge at key {@code null}. Invalid headers and challenges are ignored.
-   * No semantic validation is done, for example that {@code Basic} auth must have a {@code realm}
-   * auth param, this is up to the caller that interprets these challenges.
-   */
-  public List<Challenge> challenges() {
-    String responseField;
-    if (code == HTTP_UNAUTHORIZED) {
-      responseField = "WWW-Authenticate";
-    } else if (code == HTTP_PROXY_AUTH) {
-      responseField = "Proxy-Authenticate";
-    } else {
-      return Collections.emptyList();
-    }
-    return HttpHeaders.parseChallenges(headers(), responseField);
-  }
-
-  /**
-   * Returns the cache control directives for this response. This is never null, even if this
-   * response contains no {@code Cache-Control} header.
-   */
-  public CacheControl cacheControl() {
-    CacheControl result = cacheControl;
-    return result != null ? result : (cacheControl = CacheControl.parse(headers));
-  }
-
-  /**
-   * Returns a {@linkplain System#currentTimeMillis() timestamp} taken immediately before OkHttp
-   * transmitted the initiating request over the network. If this response is being served from the
-   * cache then this is the timestamp of the original request.
-   */
-  public long sentRequestAtMillis() {
-    return sentRequestAtMillis;
-  }
-
-  /**
-   * Returns a {@linkplain System#currentTimeMillis() timestamp} taken immediately after OkHttp
-   * received this response's headers from the network. If this response is being served from the
-   * cache then this is the timestamp of the original response.
-   */
-  public long receivedResponseAtMillis() {
-    return receivedResponseAtMillis;
-  }
-
-  /**
-   * Closes the response body. Equivalent to {@code body().close()}.
-   *
-   * <p>It is an error to close a response that is not eligible for a body. This includes the
-   * responses returned from {@link #cacheResponse}, {@link #networkResponse}, and {@link
-   * #priorResponse()}.
-   */
-  @Override public void close() {
-    if (body == null) {
-      throw new IllegalStateException("response is not eligible for a body and must not be closed");
-    }
-    body.close();
-  }
-
-  @Override public String toString() {
-    return "Response{protocol="
-        + protocol
-        + ", code="
-        + code
-        + ", message="
-        + message
-        + ", url="
-        + request.url()
-        + '}';
-  }
-
-  public static class Builder {
-    @Nullable Request request;
-    @Nullable Protocol protocol;
-    int code = -1;
-    String message;
-    @Nullable Handshake handshake;
-    Headers.Builder headers;
-    @Nullable ResponseBody body;
-    @Nullable Response networkResponse;
-    @Nullable Response cacheResponse;
-    @Nullable Response priorResponse;
-    long sentRequestAtMillis;
-    long receivedResponseAtMillis;
-    @Nullable Exchange exchange;
-
-    public Builder() {
-      headers = new Headers.Builder();
-    }
-
-    Builder(Response response) {
-      this.request = response.request;
-      this.protocol = response.protocol;
-      this.code = response.code;
-      this.message = response.message;
-      this.handshake = response.handshake;
-      this.headers = response.headers.newBuilder();
-      this.body = response.body;
-      this.networkResponse = response.networkResponse;
-      this.cacheResponse = response.cacheResponse;
-      this.priorResponse = response.priorResponse;
-      this.sentRequestAtMillis = response.sentRequestAtMillis;
-      this.receivedResponseAtMillis = response.receivedResponseAtMillis;
-      this.exchange = response.exchange;
-    }
-
-    public Builder request(Request request) {
-      this.request = request;
-      return this;
-    }
-
-    public Builder protocol(Protocol protocol) {
-      this.protocol = protocol;
-      return this;
-    }
-
-    public Builder code(int code) {
-      this.code = code;
-      return this;
-    }
-
-    public Builder message(String message) {
-      this.message = message;
-      return this;
-    }
-
-    public Builder handshake(@Nullable Handshake handshake) {
-      this.handshake = handshake;
-      return this;
-    }
-
-    /**
-     * Sets the header named {@code name} to {@code value}. If this request already has any headers
-     * with that name, they are all replaced.
-     */
-    public Builder header(String name, String value) {
-      headers.set(name, value);
-      return this;
-    }
-
-    /**
-     * Adds a header with {@code name} and {@code value}. Prefer this method for multiply-valued
-     * headers like "Set-Cookie".
-     */
-    public Builder addHeader(String name, String value) {
-      headers.add(name, value);
-      return this;
-    }
-
-    /** Removes all headers named {@code name} on this builder. */
-    public Builder removeHeader(String name) {
-      headers.removeAll(name);
-      return this;
-    }
-
-    /** Removes all headers on this builder and adds {@code headers}. */
-    public Builder headers(Headers headers) {
-      this.headers = headers.newBuilder();
-      return this;
-    }
-
-    public Builder body(@Nullable ResponseBody body) {
-      this.body = body;
-      return this;
-    }
-
-    public Builder networkResponse(@Nullable Response networkResponse) {
-      if (networkResponse != null) checkSupportResponse("networkResponse", networkResponse);
-      this.networkResponse = networkResponse;
-      return this;
-    }
-
-    public Builder cacheResponse(@Nullable Response cacheResponse) {
-      if (cacheResponse != null) checkSupportResponse("cacheResponse", cacheResponse);
-      this.cacheResponse = cacheResponse;
-      return this;
-    }
-
-    private void checkSupportResponse(String name, Response response) {
-      if (response.body != null) {
-        throw new IllegalArgumentException(name + ".body != null");
-      } else if (response.networkResponse != null) {
-        throw new IllegalArgumentException(name + ".networkResponse != null");
-      } else if (response.cacheResponse != null) {
-        throw new IllegalArgumentException(name + ".cacheResponse != null");
-      } else if (response.priorResponse != null) {
-        throw new IllegalArgumentException(name + ".priorResponse != null");
-      }
-    }
-
-    public Builder priorResponse(@Nullable Response priorResponse) {
-      if (priorResponse != null) checkPriorResponse(priorResponse);
-      this.priorResponse = priorResponse;
-      return this;
-    }
-
-    private void checkPriorResponse(Response response) {
-      if (response.body != null) {
-        throw new IllegalArgumentException("priorResponse.body != null");
-      }
-    }
-
-    public Builder sentRequestAtMillis(long sentRequestAtMillis) {
-      this.sentRequestAtMillis = sentRequestAtMillis;
-      return this;
-    }
-
-    public Builder receivedResponseAtMillis(long receivedResponseAtMillis) {
-      this.receivedResponseAtMillis = receivedResponseAtMillis;
-      return this;
-    }
-
-    void initExchange(Exchange deferredTrailers) {
-      this.exchange = deferredTrailers;
-    }
-
-    public Response build() {
-      if (request == null) throw new IllegalStateException("request == null");
-      if (protocol == null) throw new IllegalStateException("protocol == null");
-      if (code < 0) throw new IllegalStateException("code < 0: " + code);
-      if (message == null) throw new IllegalStateException("message == null");
-      return new Response(this);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/ResponseBody.java b/okhttp/src/main/java/okhttp3/ResponseBody.java
deleted file mode 100644
index 96b7e38a0f..0000000000
--- a/okhttp/src/main/java/okhttp3/ResponseBody.java
+++ /dev/null
@@ -1,275 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.Reader;
-import java.nio.charset.Charset;
-import javax.annotation.Nullable;
-import okhttp3.internal.Util;
-import okio.Buffer;
-import okio.BufferedSource;
-import okio.ByteString;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-
-/**
- * A one-shot stream from the origin server to the client application with the raw bytes of the
- * response body. Each response body is supported by an active connection to the webserver. This
- * imposes both obligations and limits on the client application.
- *
- * <h3>The response body must be closed.</h3>
- *
- * Each response body is backed by a limited resource like a socket (live network responses) or
- * an open file (for cached responses). Failing to close the response body will leak resources and
- * may ultimately cause the application to slow down or crash.
- *
- * <p>Both this class and {@link Response} implement {@link Closeable}. Closing a response simply
- * closes its response body. If you invoke {@link Call#execute()} or implement {@link
- * Callback#onResponse} you must close this body by calling any of the following methods:
- *
- * <ul>
- *   <li>Response.close()</li>
- *   <li>Response.body().close()</li>
- *   <li>Response.body().source().close()</li>
- *   <li>Response.body().charStream().close()</li>
- *   <li>Response.body().byteStream().close()</li>
- *   <li>Response.body().bytes()</li>
- *   <li>Response.body().string()</li>
- * </ul>
- *
- * <p>There is no benefit to invoking multiple {@code close()} methods for the same response body.
- *
- * <p>For synchronous calls, the easiest way to make sure a response body is closed is with a {@code
- * try} block. With this structure the compiler inserts an implicit {@code finally} clause that
- * calls {@code close()} for you.
- *
- * <pre>   {@code
- *
- *   Call call = client.newCall(request);
- *   try (Response response = call.execute()) {
- *     ... // Use the response.
- *   }
- * }</pre>
- *
- * You can use a similar block for asynchronous calls: <pre>   {@code
- *
- *   Call call = client.newCall(request);
- *   call.enqueue(new Callback() {
- *     public void onResponse(Call call, Response response) throws IOException {
- *       try (ResponseBody responseBody = response.body()) {
- *         ... // Use the response.
- *       }
- *     }
- *
- *     public void onFailure(Call call, IOException e) {
- *       ... // Handle the failure.
- *     }
- *   });
- * }</pre>
- *
- * These examples will not work if you're consuming the response body on another thread. In such
- * cases the consuming thread must call {@link #close} when it has finished reading the response
- * body.
- *
- * <h3>The response body can be consumed only once.</h3>
- *
- * <p>This class may be used to stream very large responses. For example, it is possible to use this
- * class to read a response that is larger than the entire memory allocated to the current process.
- * It can even stream a response larger than the total storage on the current device, which is a
- * common requirement for video streaming applications.
- *
- * <p>Because this class does not buffer the full response in memory, the application may not
- * re-read the bytes of the response. Use this one shot to read the entire response into memory with
- * {@link #bytes()} or {@link #string()}. Or stream the response with either {@link #source()},
- * {@link #byteStream()}, or {@link #charStream()}.
- */
-public abstract class ResponseBody implements Closeable {
-  /** Multiple calls to {@link #charStream()} must return the same instance. */
-  private @Nullable Reader reader;
-
-  public abstract @Nullable MediaType contentType();
-
-  /**
-   * Returns the number of bytes in that will returned by {@link #bytes}, or {@link #byteStream}, or
-   * -1 if unknown.
-   */
-  public abstract long contentLength();
-
-  public final InputStream byteStream() {
-    return source().inputStream();
-  }
-
-  public abstract BufferedSource source();
-
-  /**
-   * Returns the response as a byte array.
-   *
-   * <p>This method loads entire response body into memory. If the response body is very large this
-   * may trigger an {@link OutOfMemoryError}. Prefer to stream the response body if this is a
-   * possibility for your response.
-   */
-  public final byte[] bytes() throws IOException {
-    long contentLength = contentLength();
-    if (contentLength > Integer.MAX_VALUE) {
-      throw new IOException("Cannot buffer entire body for content length: " + contentLength);
-    }
-
-    byte[] bytes;
-    try (BufferedSource source = source()) {
-      bytes = source.readByteArray();
-    }
-    if (contentLength != -1 && contentLength != bytes.length) {
-      throw new IOException("Content-Length ("
-          + contentLength
-          + ") and stream length ("
-          + bytes.length
-          + ") disagree");
-    }
-    return bytes;
-  }
-
-  /**
-   * Returns the response as a character stream.
-   *
-   * <p>If the response starts with a <a href="https://en.wikipedia.org/wiki/Byte_order_mark">Byte
-   * Order Mark (BOM)</a>, it is consumed and used to determine the charset of the response bytes.
-   *
-   * <p>Otherwise if the response has a Content-Type header that specifies a charset, that is used
-   * to determine the charset of the response bytes.
-   *
-   * <p>Otherwise the response bytes are decoded as UTF-8.
-   */
-  public final Reader charStream() {
-    Reader r = reader;
-    return r != null ? r : (reader = new BomAwareReader(source(), charset()));
-  }
-
-  /**
-   * Returns the response as a string.
-   *
-   * <p>If the response starts with a <a href="https://en.wikipedia.org/wiki/Byte_order_mark">Byte
-   * Order Mark (BOM)</a>, it is consumed and used to determine the charset of the response bytes.
-   *
-   * <p>Otherwise if the response has a Content-Type header that specifies a charset, that is used
-   * to determine the charset of the response bytes.
-   *
-   * <p>Otherwise the response bytes are decoded as UTF-8.
-   *
-   * <p>This method loads entire response body into memory. If the response body is very large this
-   * may trigger an {@link OutOfMemoryError}. Prefer to stream the response body if this is a
-   * possibility for your response.
-   */
-  public final String string() throws IOException {
-    try (BufferedSource source = source()) {
-      Charset charset = Util.bomAwareCharset(source, charset());
-      return source.readString(charset);
-    }
-  }
-
-  private Charset charset() {
-    MediaType contentType = contentType();
-    return contentType != null ? contentType.charset(UTF_8) : UTF_8;
-  }
-
-  @Override public void close() {
-    Util.closeQuietly(source());
-  }
-
-  /**
-   * Returns a new response body that transmits {@code content}. If {@code contentType} is non-null
-   * and lacks a charset, this will use UTF-8.
-   */
-  public static ResponseBody create(@Nullable MediaType contentType, String content) {
-    Charset charset = UTF_8;
-    if (contentType != null) {
-      charset = contentType.charset();
-      if (charset == null) {
-        charset = UTF_8;
-        contentType = MediaType.parse(contentType + "; charset=utf-8");
-      }
-    }
-    Buffer buffer = new Buffer().writeString(content, charset);
-    return create(contentType, buffer.size(), buffer);
-  }
-
-  /** Returns a new response body that transmits {@code content}. */
-  public static ResponseBody create(final @Nullable MediaType contentType, byte[] content) {
-    Buffer buffer = new Buffer().write(content);
-    return create(contentType, content.length, buffer);
-  }
-
-  /** Returns a new response body that transmits {@code content}. */
-  public static ResponseBody create(@Nullable MediaType contentType, ByteString content) {
-    Buffer buffer = new Buffer().write(content);
-    return create(contentType, content.size(), buffer);
-  }
-
-  /** Returns a new response body that transmits {@code content}. */
-  public static ResponseBody create(final @Nullable MediaType contentType,
-      final long contentLength, final BufferedSource content) {
-    if (content == null) throw new NullPointerException("source == null");
-    return new ResponseBody() {
-      @Override public @Nullable MediaType contentType() {
-        return contentType;
-      }
-
-      @Override public long contentLength() {
-        return contentLength;
-      }
-
-      @Override public BufferedSource source() {
-        return content;
-      }
-    };
-  }
-
-  static final class BomAwareReader extends Reader {
-    private final BufferedSource source;
-    private final Charset charset;
-
-    private boolean closed;
-    private @Nullable Reader delegate;
-
-    BomAwareReader(BufferedSource source, Charset charset) {
-      this.source = source;
-      this.charset = charset;
-    }
-
-    @Override public int read(char[] cbuf, int off, int len) throws IOException {
-      if (closed) throw new IOException("Stream closed");
-
-      Reader delegate = this.delegate;
-      if (delegate == null) {
-        Charset charset = Util.bomAwareCharset(source, this.charset);
-        delegate = this.delegate = new InputStreamReader(source.inputStream(), charset);
-      }
-      return delegate.read(cbuf, off, len);
-    }
-
-    @Override public void close() throws IOException {
-      closed = true;
-      if (delegate != null) {
-        delegate.close();
-      } else {
-        source.close();
-      }
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Route.java b/okhttp/src/main/java/okhttp3/Route.java
deleted file mode 100644
index 14158673ca..0000000000
--- a/okhttp/src/main/java/okhttp3/Route.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import javax.annotation.Nullable;
-
-/**
- * The concrete route used by a connection to reach an abstract origin server. When creating a
- * connection the client has many options:
- *
- * <ul>
- *     <li><strong>HTTP proxy:</strong> a proxy server may be explicitly configured for the client.
- *         Otherwise the {@linkplain java.net.ProxySelector proxy selector} is used. It may return
- *         multiple proxies to attempt.
- *     <li><strong>IP address:</strong> whether connecting directly to an origin server or a proxy,
- *         opening a socket requires an IP address. The DNS server may return multiple IP addresses
- *         to attempt.
- * </ul>
- *
- * <p>Each route is a specific selection of these options.
- */
-public final class Route {
-  final Address address;
-  final Proxy proxy;
-  final InetSocketAddress inetSocketAddress;
-
-  public Route(Address address, Proxy proxy, InetSocketAddress inetSocketAddress) {
-    if (address == null) {
-      throw new NullPointerException("address == null");
-    }
-    if (proxy == null) {
-      throw new NullPointerException("proxy == null");
-    }
-    if (inetSocketAddress == null) {
-      throw new NullPointerException("inetSocketAddress == null");
-    }
-    this.address = address;
-    this.proxy = proxy;
-    this.inetSocketAddress = inetSocketAddress;
-  }
-
-  public Address address() {
-    return address;
-  }
-
-  /**
-   * Returns the {@link Proxy} of this route.
-   *
-   * <strong>Warning:</strong> This may disagree with {@link Address#proxy} when it is null. When
-   * the address's proxy is null, the proxy selector is used.
-   */
-  public Proxy proxy() {
-    return proxy;
-  }
-
-  public InetSocketAddress socketAddress() {
-    return inetSocketAddress;
-  }
-
-  /**
-   * Returns true if this route tunnels HTTPS through an HTTP proxy. See <a
-   * href="http://www.ietf.org/rfc/rfc2817.txt">RFC 2817, Section 5.2</a>.
-   */
-  public boolean requiresTunnel() {
-    return address.sslSocketFactory != null && proxy.type() == Proxy.Type.HTTP;
-  }
-
-  @Override public boolean equals(@Nullable Object other) {
-    return other instanceof Route
-        && ((Route) other).address.equals(address)
-        && ((Route) other).proxy.equals(proxy)
-        && ((Route) other).inetSocketAddress.equals(inetSocketAddress);
-  }
-
-  @Override public int hashCode() {
-    int result = 17;
-    result = 31 * result + address.hashCode();
-    result = 31 * result + proxy.hashCode();
-    result = 31 * result + inetSocketAddress.hashCode();
-    return result;
-  }
-
-  @Override public String toString() {
-    return "Route{" + inetSocketAddress + "}";
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/TlsVersion.java b/okhttp/src/main/java/okhttp3/TlsVersion.java
deleted file mode 100644
index 02cbeca3d1..0000000000
--- a/okhttp/src/main/java/okhttp3/TlsVersion.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-/**
- * Versions of TLS that can be offered when negotiating a secure socket. See {@link
- * javax.net.ssl.SSLSocket#setEnabledProtocols}.
- */
-public enum TlsVersion {
-  TLS_1_3("TLSv1.3"), // 2016.
-  TLS_1_2("TLSv1.2"), // 2008.
-  TLS_1_1("TLSv1.1"), // 2006.
-  TLS_1_0("TLSv1"),   // 1999.
-  SSL_3_0("SSLv3"),   // 1996.
-  ;
-
-  final String javaName;
-
-  TlsVersion(String javaName) {
-    this.javaName = javaName;
-  }
-
-  public static TlsVersion forJavaName(String javaName) {
-    switch (javaName) {
-      case "TLSv1.3":
-        return TLS_1_3;
-      case "TLSv1.2":
-        return TLS_1_2;
-      case "TLSv1.1":
-        return TLS_1_1;
-      case "TLSv1":
-        return TLS_1_0;
-      case "SSLv3":
-        return SSL_3_0;
-    }
-    throw new IllegalArgumentException("Unexpected TLS version: " + javaName);
-  }
-
-  static List<TlsVersion> forJavaNames(String... tlsVersions) {
-    List<TlsVersion> result = new ArrayList<>(tlsVersions.length);
-    for (String tlsVersion : tlsVersions) {
-      result.add(forJavaName(tlsVersion));
-    }
-    return Collections.unmodifiableList(result);
-  }
-
-  public String javaName() {
-    return javaName;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/WebSocket.java b/okhttp/src/main/java/okhttp3/WebSocket.java
deleted file mode 100644
index 244be951af..0000000000
--- a/okhttp/src/main/java/okhttp3/WebSocket.java
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import javax.annotation.Nullable;
-import okio.ByteString;
-
-/**
- * A non-blocking interface to a web socket. Use the {@linkplain WebSocket.Factory factory} to
- * create instances; usually this is {@link OkHttpClient}.
- *
- * <h3>Web Socket Lifecycle</h3>
- *
- * Upon normal operation each web socket progresses through a sequence of states:
- *
- * <ul>
- *   <li><strong>Connecting:</strong> the initial state of each web socket. Messages may be enqueued
- *       but they won't be transmitted until the web socket is open.
- *   <li><strong>Open:</strong> the web socket has been accepted by the remote peer and is fully
- *       operational. Messages in either direction are enqueued for immediate transmission.
- *   <li><strong>Closing:</strong> one of the peers on the web socket has initiated a graceful
- *       shutdown. The web socket will continue to transmit already-enqueued messages but will
- *       refuse to enqueue new ones.
- *   <li><strong>Closed:</strong> the web socket has transmitted all of its messages and has
- *       received all messages from the peer.
- * </ul>
- *
- * Web sockets may fail due to HTTP upgrade problems, connectivity problems, or if either peer
- * chooses to short-circuit the graceful shutdown process:
- *
- * <ul>
- *   <li><strong>Canceled:</strong> the web socket connection failed. Messages that were
- *       successfully enqueued by either peer may not have been transmitted to the other.
- * </ul>
- *
- * Note that the state progression is independent for each peer. Arriving at a gracefully-closed
- * state indicates that a peer has sent all of its outgoing messages and received all of its
- * incoming messages. But it does not guarantee that the other peer will successfully receive all of
- * its incoming messages.
- */
-public interface WebSocket {
-  /** Returns the original request that initiated this web socket. */
-  Request request();
-
-  /**
-   * Returns the size in bytes of all messages enqueued to be transmitted to the server. This
-   * doesn't include framing overhead. It also doesn't include any bytes buffered by the operating
-   * system or network intermediaries. This method returns 0 if no messages are waiting
-   * in the queue. If may return a nonzero value after the web socket has been canceled; this
-   * indicates that enqueued messages were not transmitted.
-   */
-  long queueSize();
-
-  /**
-   * Attempts to enqueue {@code text} to be UTF-8 encoded and sent as a the data of a text (type
-   * {@code 0x1}) message.
-   *
-   * <p>This method returns true if the message was enqueued. Messages that would overflow the
-   * outgoing message buffer will be rejected and trigger a {@linkplain #close graceful shutdown} of
-   * this web socket. This method returns false in that case, and in any other case where this
-   * web socket is closing, closed, or canceled.
-   *
-   * <p>This method returns immediately.
-   */
-  boolean send(String text);
-
-  /**
-   * Attempts to enqueue {@code bytes} to be sent as a the data of a binary (type {@code 0x2})
-   * message.
-   *
-   * <p>This method returns true if the message was enqueued. Messages that would overflow the
-   * outgoing message buffer (16 MiB) will be rejected and trigger a
-   * {@linkplain #close graceful shutdown} of this web socket. This method returns false in that
-   * case, and in any other case where this web socket is closing, closed, or canceled.
-   *
-   * <p>This method returns immediately.
-   */
-  boolean send(ByteString bytes);
-
-  /**
-   * Attempts to initiate a graceful shutdown of this web socket. Any already-enqueued messages will
-   * be transmitted before the close message is sent but subsequent calls to {@link #send} will
-   * return false and their messages will not be enqueued.
-   *
-   * <p>This returns true if a graceful shutdown was initiated by this call. It returns false if
-   * a graceful shutdown was already underway or if the web socket is already closed or canceled.
-   *
-   * @param code Status code as defined by <a
-   * href="http://tools.ietf.org/html/rfc6455#section-7.4">Section 7.4 of RFC 6455</a>.
-   * @param reason Reason for shutting down or {@code null}.
-   * @throws IllegalArgumentException if code is invalid.
-   */
-  boolean close(int code, @Nullable String reason);
-
-  /**
-   * Immediately and violently release resources held by this web socket, discarding any enqueued
-   * messages. This does nothing if the web socket has already been closed or canceled.
-   */
-  void cancel();
-
-  interface Factory {
-    /**
-     * Creates a new web socket and immediately returns it. Creating a web socket initiates an
-     * asynchronous process to connect the socket. Once that succeeds or fails, {@code listener}
-     * will be notified. The caller must either close or cancel the returned web socket when it is
-     * no longer in use.
-     */
-    WebSocket newWebSocket(Request request, WebSocketListener listener);
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/WebSocketListener.java b/okhttp/src/main/java/okhttp3/WebSocketListener.java
deleted file mode 100644
index 69276d933b..0000000000
--- a/okhttp/src/main/java/okhttp3/WebSocketListener.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import javax.annotation.Nullable;
-import okio.ByteString;
-
-public abstract class WebSocketListener {
-  /**
-   * Invoked when a web socket has been accepted by the remote peer and may begin transmitting
-   * messages.
-   */
-  public void onOpen(WebSocket webSocket, Response response) {
-  }
-
-  /** Invoked when a text (type {@code 0x1}) message has been received. */
-  public void onMessage(WebSocket webSocket, String text) {
-  }
-
-  /** Invoked when a binary (type {@code 0x2}) message has been received. */
-  public void onMessage(WebSocket webSocket, ByteString bytes) {
-  }
-
-  /**
-   * Invoked when the remote peer has indicated that no more incoming messages will be
-   * transmitted.
-   */
-  public void onClosing(WebSocket webSocket, int code, String reason) {
-  }
-
-  /**
-   * Invoked when both peers have indicated that no more messages will be transmitted and the
-   * connection has been successfully released. No further calls to this listener will be made.
-   */
-  public void onClosed(WebSocket webSocket, int code, String reason) {
-  }
-
-  /**
-   * Invoked when a web socket has been closed due to an error reading from or writing to the
-   * network. Both outgoing and incoming messages may have been lost. No further calls to this
-   * listener will be made.
-   */
-  public void onFailure(WebSocket webSocket, Throwable t, @Nullable Response response) {
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/Internal.java b/okhttp/src/main/java/okhttp3/internal/Internal.java
deleted file mode 100644
index d231165d82..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/Internal.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal;
-
-import javax.annotation.Nullable;
-import javax.net.ssl.SSLSocket;
-import okhttp3.Address;
-import okhttp3.Call;
-import okhttp3.ConnectionPool;
-import okhttp3.ConnectionSpec;
-import okhttp3.Headers;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.connection.Exchange;
-import okhttp3.internal.connection.RealConnectionPool;
-
-/**
- * Escalate internal APIs in {@code okhttp3} so they can be used from OkHttp's implementation
- * packages. The only implementation of this interface is in {@link OkHttpClient}.
- */
-public abstract class Internal {
-
-  public static void initializeInstanceForTests() {
-    // Needed in tests to ensure that the instance is actually pointing to something.
-    new OkHttpClient();
-  }
-
-  public static Internal instance;
-
-  public abstract void addLenient(Headers.Builder builder, String line);
-
-  public abstract void addLenient(Headers.Builder builder, String name, String value);
-
-  public abstract RealConnectionPool realConnectionPool(ConnectionPool connectionPool);
-
-  public abstract boolean equalsNonHost(Address a, Address b);
-
-  public abstract int code(Response.Builder responseBuilder);
-
-  public abstract void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket,
-      boolean isFallback);
-
-  public abstract Call newWebSocketCall(OkHttpClient client, Request request);
-
-  public abstract void initExchange(
-      Response.Builder responseBuilder, Exchange exchange);
-
-  public abstract @Nullable Exchange exchange(Response response);
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/NamedRunnable.java b/okhttp/src/main/java/okhttp3/internal/NamedRunnable.java
deleted file mode 100644
index ff9729e2af..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/NamedRunnable.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal;
-
-/**
- * Runnable implementation which always sets its thread name.
- */
-public abstract class NamedRunnable implements Runnable {
-  protected final String name;
-
-  public NamedRunnable(String format, Object... args) {
-    this.name = Util.format(format, args);
-  }
-
-  @Override public final void run() {
-    String oldName = Thread.currentThread().getName();
-    Thread.currentThread().setName(name);
-    try {
-      execute();
-    } finally {
-      Thread.currentThread().setName(oldName);
-    }
-  }
-
-  protected abstract void execute();
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/Util.java b/okhttp/src/main/java/okhttp3/internal/Util.java
deleted file mode 100644
index 3e1a2ba763..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/Util.java
+++ /dev/null
@@ -1,688 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.io.InterruptedIOException;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.net.IDN;
-import java.net.InetAddress;
-import java.net.ServerSocket;
-import java.net.Socket;
-import java.net.UnknownHostException;
-import java.nio.charset.Charset;
-import java.security.AccessControlException;
-import java.security.GeneralSecurityException;
-import java.security.KeyStore;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.TimeZone;
-import java.util.concurrent.ThreadFactory;
-import java.util.concurrent.TimeUnit;
-import java.util.regex.Pattern;
-import javax.annotation.Nullable;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.TrustManagerFactory;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.Headers;
-import okhttp3.HttpUrl;
-import okhttp3.RequestBody;
-import okhttp3.ResponseBody;
-import okhttp3.internal.http2.Header;
-import okio.Buffer;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.Options;
-import okio.Source;
-
-import static java.nio.charset.StandardCharsets.UTF_16BE;
-import static java.nio.charset.StandardCharsets.UTF_16LE;
-import static java.nio.charset.StandardCharsets.UTF_8;
-
-/** Junk drawer of utility methods. */
-public final class Util {
-  public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
-  public static final String[] EMPTY_STRING_ARRAY = new String[0];
-  public static final Headers EMPTY_HEADERS = Headers.of();
-
-  public static final ResponseBody EMPTY_RESPONSE = ResponseBody.create(null, EMPTY_BYTE_ARRAY);
-  public static final RequestBody EMPTY_REQUEST = RequestBody.create(null, EMPTY_BYTE_ARRAY);
-
-  /** Byte order marks. */
-  private static final Options UNICODE_BOMS = Options.of(
-      ByteString.decodeHex("efbbbf"),   // UTF-8
-      ByteString.decodeHex("feff"),     // UTF-16BE
-      ByteString.decodeHex("fffe"),     // UTF-16LE
-      ByteString.decodeHex("0000ffff"), // UTF-32BE
-      ByteString.decodeHex("ffff0000")  // UTF-32LE
-  );
-
-  private static final Charset UTF_32BE = Charset.forName("UTF-32BE");
-  private static final Charset UTF_32LE = Charset.forName("UTF-32LE");
-
-  /** GMT and UTC are equivalent for our purposes. */
-  public static final TimeZone UTC = TimeZone.getTimeZone("GMT");
-
-  public static final Comparator<String> NATURAL_ORDER = String::compareTo;
-
-  private static final Method addSuppressedExceptionMethod;
-
-  static {
-    Method m;
-    try {
-      m = Throwable.class.getDeclaredMethod("addSuppressed", Throwable.class);
-    } catch (Exception e) {
-      m = null;
-    }
-    addSuppressedExceptionMethod = m;
-  }
-
-  public static void addSuppressedIfPossible(Throwable e, Throwable suppressed) {
-    if (addSuppressedExceptionMethod != null) {
-      try {
-        addSuppressedExceptionMethod.invoke(e, suppressed);
-      } catch (InvocationTargetException | IllegalAccessException ignored) {
-      }
-    }
-  }
-
-  /**
-   * Quick and dirty pattern to differentiate IP addresses from hostnames. This is an approximation
-   * of Android's private InetAddress#isNumeric API.
-   *
-   * <p>This matches IPv6 addresses as a hex string containing at least one colon, and possibly
-   * including dots after the first colon. It matches IPv4 addresses as strings containing only
-   * decimal digits and dots. This pattern matches strings like "a:.23" and "54" that are neither IP
-   * addresses nor hostnames; they will be verified as IP addresses (which is a more strict
-   * verification).
-   */
-  private static final Pattern VERIFY_AS_IP_ADDRESS = Pattern.compile(
-      "([0-9a-fA-F]*:[0-9a-fA-F:.]*)|([\\d.]+)");
-
-  private Util() {
-  }
-
-  public static void checkOffsetAndCount(long arrayLength, long offset, long count) {
-    if ((offset | count) < 0 || offset > arrayLength || arrayLength - offset < count) {
-      throw new ArrayIndexOutOfBoundsException();
-    }
-  }
-
-  /**
-   * Closes {@code closeable}, ignoring any checked exceptions. Does nothing if {@code closeable} is
-   * null.
-   */
-  public static void closeQuietly(Closeable closeable) {
-    if (closeable != null) {
-      try {
-        closeable.close();
-      } catch (RuntimeException rethrown) {
-        throw rethrown;
-      } catch (Exception ignored) {
-      }
-    }
-  }
-
-  /**
-   * Closes {@code socket}, ignoring any checked exceptions. Does nothing if {@code socket} is
-   * null.
-   */
-  public static void closeQuietly(Socket socket) {
-    if (socket != null) {
-      try {
-        socket.close();
-      } catch (AssertionError e) {
-        if (!isAndroidGetsocknameError(e)) throw e;
-      } catch (RuntimeException rethrown) {
-        throw rethrown;
-      } catch (Exception ignored) {
-      }
-    }
-  }
-
-  /**
-   * Closes {@code serverSocket}, ignoring any checked exceptions. Does nothing if {@code
-   * serverSocket} is null.
-   */
-  public static void closeQuietly(ServerSocket serverSocket) {
-    if (serverSocket != null) {
-      try {
-        serverSocket.close();
-      } catch (RuntimeException rethrown) {
-        throw rethrown;
-      } catch (Exception ignored) {
-      }
-    }
-  }
-
-  /**
-   * Attempts to exhaust {@code source}, returning true if successful. This is useful when reading a
-   * complete source is helpful, such as when doing so completes a cache body or frees a socket
-   * connection for reuse.
-   */
-  public static boolean discard(Source source, int timeout, TimeUnit timeUnit) {
-    try {
-      return skipAll(source, timeout, timeUnit);
-    } catch (IOException e) {
-      return false;
-    }
-  }
-
-  /**
-   * Reads until {@code in} is exhausted or the deadline has been reached. This is careful to not
-   * extend the deadline if one exists already.
-   */
-  public static boolean skipAll(Source source, int duration, TimeUnit timeUnit) throws IOException {
-    long now = System.nanoTime();
-    long originalDuration = source.timeout().hasDeadline()
-        ? source.timeout().deadlineNanoTime() - now
-        : Long.MAX_VALUE;
-    source.timeout().deadlineNanoTime(now + Math.min(originalDuration, timeUnit.toNanos(duration)));
-    try {
-      Buffer skipBuffer = new Buffer();
-      while (source.read(skipBuffer, 8192) != -1) {
-        skipBuffer.clear();
-      }
-      return true; // Success! The source has been exhausted.
-    } catch (InterruptedIOException e) {
-      return false; // We ran out of time before exhausting the source.
-    } finally {
-      if (originalDuration == Long.MAX_VALUE) {
-        source.timeout().clearDeadline();
-      } else {
-        source.timeout().deadlineNanoTime(now + originalDuration);
-      }
-    }
-  }
-
-  /** Returns an immutable copy of {@code list}. */
-  public static <T> List<T> immutableList(List<T> list) {
-    return Collections.unmodifiableList(new ArrayList<>(list));
-  }
-
-  /** Returns an immutable copy of {@code map}. */
-  public static <K, V> Map<K, V> immutableMap(Map<K, V> map) {
-    return map.isEmpty()
-        ? Collections.emptyMap()
-        : Collections.unmodifiableMap(new LinkedHashMap<>(map));
-  }
-
-  /** Returns an immutable list containing {@code elements}. */
-  @SafeVarargs
-  public static <T> List<T> immutableList(T... elements) {
-    return Collections.unmodifiableList(Arrays.asList(elements.clone()));
-  }
-
-  public static ThreadFactory threadFactory(String name, boolean daemon) {
-    return runnable -> {
-      Thread result = new Thread(runnable, name);
-      result.setDaemon(daemon);
-      return result;
-    };
-  }
-
-  /**
-   * Returns an array containing only elements found in {@code first} and also in {@code
-   * second}. The returned elements are in the same order as in {@code first}.
-   */
-  public static String[] intersect(
-      Comparator<? super String> comparator, String[] first, String[] second) {
-    List<String> result = new ArrayList<>();
-    for (String a : first) {
-      for (String b : second) {
-        if (comparator.compare(a, b) == 0) {
-          result.add(a);
-          break;
-        }
-      }
-    }
-    return result.toArray(new String[result.size()]);
-  }
-
-  /**
-   * Returns true if there is an element in {@code first} that is also in {@code second}. This
-   * method terminates if any intersection is found. The sizes of both arguments are assumed to be
-   * so small, and the likelihood of an intersection so great, that it is not worth the CPU cost of
-   * sorting or the memory cost of hashing.
-   */
-  public static boolean nonEmptyIntersection(
-      Comparator<String> comparator, String[] first, String[] second) {
-    if (first == null || second == null || first.length == 0 || second.length == 0) {
-      return false;
-    }
-    for (String a : first) {
-      for (String b : second) {
-        if (comparator.compare(a, b) == 0) {
-          return true;
-        }
-      }
-    }
-    return false;
-  }
-
-  public static String hostHeader(HttpUrl url, boolean includeDefaultPort) {
-    String host = url.host().contains(":")
-        ? "[" + url.host() + "]"
-        : url.host();
-    return includeDefaultPort || url.port() != HttpUrl.defaultPort(url.scheme())
-        ? host + ":" + url.port()
-        : host;
-  }
-
-  /**
-   * Returns true if {@code e} is due to a firmware bug fixed after Android 4.2.2.
-   * https://code.google.com/p/android/issues/detail?id=54072
-   */
-  public static boolean isAndroidGetsocknameError(AssertionError e) {
-    return e.getCause() != null && e.getMessage() != null
-        && e.getMessage().contains("getsockname failed");
-  }
-
-  public static int indexOf(Comparator<String> comparator, String[] array, String value) {
-    for (int i = 0, size = array.length; i < size; i++) {
-      if (comparator.compare(array[i], value) == 0) return i;
-    }
-    return -1;
-  }
-
-  public static String[] concat(String[] array, String value) {
-    String[] result = new String[array.length + 1];
-    System.arraycopy(array, 0, result, 0, array.length);
-    result[result.length - 1] = value;
-    return result;
-  }
-
-  /**
-   * Increments {@code pos} until {@code input[pos]} is not ASCII whitespace. Stops at {@code
-   * limit}.
-   */
-  public static int skipLeadingAsciiWhitespace(String input, int pos, int limit) {
-    for (int i = pos; i < limit; i++) {
-      switch (input.charAt(i)) {
-        case '\t':
-        case '\n':
-        case '\f':
-        case '\r':
-        case ' ':
-          continue;
-        default:
-          return i;
-      }
-    }
-    return limit;
-  }
-
-  /**
-   * Decrements {@code limit} until {@code input[limit - 1]} is not ASCII whitespace. Stops at
-   * {@code pos}.
-   */
-  public static int skipTrailingAsciiWhitespace(String input, int pos, int limit) {
-    for (int i = limit - 1; i >= pos; i--) {
-      switch (input.charAt(i)) {
-        case '\t':
-        case '\n':
-        case '\f':
-        case '\r':
-        case ' ':
-          continue;
-        default:
-          return i + 1;
-      }
-    }
-    return pos;
-  }
-
-  /** Equivalent to {@code string.substring(pos, limit).trim()}. */
-  public static String trimSubstring(String string, int pos, int limit) {
-    int start = skipLeadingAsciiWhitespace(string, pos, limit);
-    int end = skipTrailingAsciiWhitespace(string, start, limit);
-    return string.substring(start, end);
-  }
-
-  /**
-   * Returns the index of the first character in {@code input} that contains a character in {@code
-   * delimiters}. Returns limit if there is no such character.
-   */
-  public static int delimiterOffset(String input, int pos, int limit, String delimiters) {
-    for (int i = pos; i < limit; i++) {
-      if (delimiters.indexOf(input.charAt(i)) != -1) return i;
-    }
-    return limit;
-  }
-
-  /**
-   * Returns the index of the first character in {@code input} that is {@code delimiter}. Returns
-   * limit if there is no such character.
-   */
-  public static int delimiterOffset(String input, int pos, int limit, char delimiter) {
-    for (int i = pos; i < limit; i++) {
-      if (input.charAt(i) == delimiter) return i;
-    }
-    return limit;
-  }
-
-  /**
-   * If {@code host} is an IP address, this returns the IP address in canonical form.
-   *
-   * <p>Otherwise this performs IDN ToASCII encoding and canonicalize the result to lowercase. For
-   * example this converts {@code ‚òÉ.net} to {@code xn--n3h.net}, and {@code WwW.GoOgLe.cOm} to
-   * {@code www.google.com}. {@code null} will be returned if the host cannot be ToASCII encoded or
-   * if the result contains unsupported ASCII characters.
-   */
-  public static String canonicalizeHost(String host) {
-    // If the input contains a :, it‚Äôs an IPv6 address.
-    if (host.contains(":")) {
-      // If the input is encased in square braces "[...]", drop 'em.
-      InetAddress inetAddress = host.startsWith("[") && host.endsWith("]")
-          ? decodeIpv6(host, 1, host.length() - 1)
-          : decodeIpv6(host, 0, host.length());
-      if (inetAddress == null) return null;
-      byte[] address = inetAddress.getAddress();
-      if (address.length == 16) return inet6AddressToAscii(address);
-      if (address.length == 4) return inetAddress.getHostAddress(); // An IPv4-mapped IPv6 address.
-      throw new AssertionError("Invalid IPv6 address: '" + host + "'");
-    }
-
-    try {
-      String result = IDN.toASCII(host).toLowerCase(Locale.US);
-      if (result.isEmpty()) return null;
-
-      // Confirm that the IDN ToASCII result doesn't contain any illegal characters.
-      if (containsInvalidHostnameAsciiCodes(result)) {
-        return null;
-      }
-      // TODO: implement all label limits.
-      return result;
-    } catch (IllegalArgumentException e) {
-      return null;
-    }
-  }
-
-  private static boolean containsInvalidHostnameAsciiCodes(String hostnameAscii) {
-    for (int i = 0; i < hostnameAscii.length(); i++) {
-      char c = hostnameAscii.charAt(i);
-      // The WHATWG Host parsing rules accepts some character codes which are invalid by
-      // definition for OkHttp's host header checks (and the WHATWG Host syntax definition). Here
-      // we rule out characters that would cause problems in host headers.
-      if (c <= '\u001f' || c >= '\u007f') {
-        return true;
-      }
-      // Check for the characters mentioned in the WHATWG Host parsing spec:
-      // U+0000, U+0009, U+000A, U+000D, U+0020, "#", "%", "/", ":", "?", "@", "[", "\", and "]"
-      // (excluding the characters covered above).
-      if (" #%/:?@[\\]".indexOf(c) != -1) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  /**
-   * Returns the index of the first character in {@code input} that is either a control character
-   * (like {@code \u0000 or \n}) or a non-ASCII character. Returns -1 if {@code input} has no such
-   * characters.
-   */
-  public static int indexOfControlOrNonAscii(String input) {
-    for (int i = 0, length = input.length(); i < length; i++) {
-      char c = input.charAt(i);
-      if (c <= '\u001f' || c >= '\u007f') {
-        return i;
-      }
-    }
-    return -1;
-  }
-
-  /** Returns true if {@code host} is not a host name and might be an IP address. */
-  public static boolean verifyAsIpAddress(String host) {
-    return VERIFY_AS_IP_ADDRESS.matcher(host).matches();
-  }
-
-  /** Returns a {@link Locale#US} formatted {@link String}. */
-  public static String format(String format, Object... args) {
-    return String.format(Locale.US, format, args);
-  }
-
-  public static Charset bomAwareCharset(BufferedSource source, Charset charset) throws IOException {
-    switch (source.select(UNICODE_BOMS)) {
-      case 0: return UTF_8;
-      case 1: return UTF_16BE;
-      case 2: return UTF_16LE;
-      case 3: return UTF_32BE;
-      case 4: return UTF_32LE;
-      case -1: return charset;
-      default: throw new AssertionError();
-    }
-  }
-
-  public static int checkDuration(String name, long duration, TimeUnit unit) {
-    if (duration < 0) throw new IllegalArgumentException(name + " < 0");
-    if (unit == null) throw new NullPointerException("unit == null");
-    long millis = unit.toMillis(duration);
-    if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException(name + " too large.");
-    if (millis == 0 && duration > 0) throw new IllegalArgumentException(name + " too small.");
-    return (int) millis;
-  }
-
-  public static int decodeHexDigit(char c) {
-    if (c >= '0' && c <= '9') return c - '0';
-    if (c >= 'a' && c <= 'f') return c - 'a' + 10;
-    if (c >= 'A' && c <= 'F') return c - 'A' + 10;
-    return -1;
-  }
-
-  /** Decodes an IPv6 address like 1111:2222:3333:4444:5555:6666:7777:8888 or ::1. */
-  private static @Nullable InetAddress decodeIpv6(String input, int pos, int limit) {
-    byte[] address = new byte[16];
-    int b = 0;
-    int compress = -1;
-    int groupOffset = -1;
-
-    for (int i = pos; i < limit; ) {
-      if (b == address.length) return null; // Too many groups.
-
-      // Read a delimiter.
-      if (i + 2 <= limit && input.regionMatches(i, "::", 0, 2)) {
-        // Compression "::" delimiter, which is anywhere in the input, including its prefix.
-        if (compress != -1) return null; // Multiple "::" delimiters.
-        i += 2;
-        b += 2;
-        compress = b;
-        if (i == limit) break;
-      } else if (b != 0) {
-        // Group separator ":" delimiter.
-        if (input.regionMatches(i, ":", 0, 1)) {
-          i++;
-        } else if (input.regionMatches(i, ".", 0, 1)) {
-          // If we see a '.', rewind to the beginning of the previous group and parse as IPv4.
-          if (!decodeIpv4Suffix(input, groupOffset, limit, address, b - 2)) return null;
-          b += 2; // We rewound two bytes and then added four.
-          break;
-        } else {
-          return null; // Wrong delimiter.
-        }
-      }
-
-      // Read a group, one to four hex digits.
-      int value = 0;
-      groupOffset = i;
-      for (; i < limit; i++) {
-        char c = input.charAt(i);
-        int hexDigit = decodeHexDigit(c);
-        if (hexDigit == -1) break;
-        value = (value << 4) + hexDigit;
-      }
-      int groupLength = i - groupOffset;
-      if (groupLength == 0 || groupLength > 4) return null; // Group is the wrong size.
-
-      // We've successfully read a group. Assign its value to our byte array.
-      address[b++] = (byte) ((value >>> 8) & 0xff);
-      address[b++] = (byte) (value & 0xff);
-    }
-
-    // All done. If compression happened, we need to move bytes to the right place in the
-    // address. Here's a sample:
-    //
-    //      input: "1111:2222:3333::7777:8888"
-    //     before: { 11, 11, 22, 22, 33, 33, 00, 00, 77, 77, 88, 88, 00, 00, 00, 00  }
-    //   compress: 6
-    //          b: 10
-    //      after: { 11, 11, 22, 22, 33, 33, 00, 00, 00, 00, 00, 00, 77, 77, 88, 88 }
-    //
-    if (b != address.length) {
-      if (compress == -1) return null; // Address didn't have compression or enough groups.
-      System.arraycopy(address, compress, address, address.length - (b - compress), b - compress);
-      Arrays.fill(address, compress, compress + (address.length - b), (byte) 0);
-    }
-
-    try {
-      return InetAddress.getByAddress(address);
-    } catch (UnknownHostException e) {
-      throw new AssertionError();
-    }
-  }
-
-  /** Decodes an IPv4 address suffix of an IPv6 address, like 1111::5555:6666:192.168.0.1. */
-  private static boolean decodeIpv4Suffix(
-      String input, int pos, int limit, byte[] address, int addressOffset) {
-    int b = addressOffset;
-
-    for (int i = pos; i < limit; ) {
-      if (b == address.length) return false; // Too many groups.
-
-      // Read a delimiter.
-      if (b != addressOffset) {
-        if (input.charAt(i) != '.') return false; // Wrong delimiter.
-        i++;
-      }
-
-      // Read 1 or more decimal digits for a value in 0..255.
-      int value = 0;
-      int groupOffset = i;
-      for (; i < limit; i++) {
-        char c = input.charAt(i);
-        if (c < '0' || c > '9') break;
-        if (value == 0 && groupOffset != i) return false; // Reject unnecessary leading '0's.
-        value = (value * 10) + c - '0';
-        if (value > 255) return false; // Value out of range.
-      }
-      int groupLength = i - groupOffset;
-      if (groupLength == 0) return false; // No digits.
-
-      // We've successfully read a byte.
-      address[b++] = (byte) value;
-    }
-
-    if (b != addressOffset + 4) return false; // Too few groups. We wanted exactly four.
-    return true; // Success.
-  }
-
-  /** Encodes an IPv6 address in canonical form according to RFC 5952. */
-  private static String inet6AddressToAscii(byte[] address) {
-    // Go through the address looking for the longest run of 0s. Each group is 2-bytes.
-    // A run must be longer than one group (section 4.2.2).
-    // If there are multiple equal runs, the first one must be used (section 4.2.3).
-    int longestRunOffset = -1;
-    int longestRunLength = 0;
-    for (int i = 0; i < address.length; i += 2) {
-      int currentRunOffset = i;
-      while (i < 16 && address[i] == 0 && address[i + 1] == 0) {
-        i += 2;
-      }
-      int currentRunLength = i - currentRunOffset;
-      if (currentRunLength > longestRunLength && currentRunLength >= 4) {
-        longestRunOffset = currentRunOffset;
-        longestRunLength = currentRunLength;
-      }
-    }
-
-    // Emit each 2-byte group in hex, separated by ':'. The longest run of zeroes is "::".
-    Buffer result = new Buffer();
-    for (int i = 0; i < address.length; ) {
-      if (i == longestRunOffset) {
-        result.writeByte(':');
-        i += longestRunLength;
-        if (i == 16) result.writeByte(':');
-      } else {
-        if (i > 0) result.writeByte(':');
-        int group = (address[i] & 0xff) << 8 | address[i + 1] & 0xff;
-        result.writeHexadecimalUnsignedLong(group);
-        i += 2;
-      }
-    }
-    return result.readUtf8();
-  }
-
-  public static X509TrustManager platformTrustManager() {
-    try {
-      TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
-          TrustManagerFactory.getDefaultAlgorithm());
-      trustManagerFactory.init((KeyStore) null);
-      TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
-      if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
-        throw new IllegalStateException("Unexpected default trust managers:"
-            + Arrays.toString(trustManagers));
-      }
-      return (X509TrustManager) trustManagers[0];
-    } catch (GeneralSecurityException e) {
-      throw new AssertionError("No System TLS", e); // The system has no TLS. Just give up.
-    }
-  }
-
-  public static Headers toHeaders(List<Header> headerBlock) {
-    Headers.Builder builder = new Headers.Builder();
-    for (Header header : headerBlock) {
-      Internal.instance.addLenient(builder, header.name.utf8(), header.value.utf8());
-    }
-    return builder.build();
-  }
-
-  public static List<Header> toHeaderBlock(Headers headers) {
-    List<Header> result = new ArrayList<>();
-    for (int i = 0; i < headers.size(); i++) {
-      result.add(new Header(headers.name(i), headers.value(i)));
-    }
-    return result;
-  }
-
-  /**
-   * Returns the system property, or defaultValue if the system property is null or
-   * cannot be read (e.g. because of security policy restrictions).
-   */
-  public static String getSystemProperty(String key, @Nullable String defaultValue) {
-    String value;
-    try {
-      value = System.getProperty(key);
-    } catch (AccessControlException ex) {
-      return defaultValue;
-    }
-    return value != null ? value : defaultValue;
-  }
-
-  /** Returns true if an HTTP request for {@code a} and {@code b} can reuse a connection. */
-  public static boolean sameConnection(HttpUrl a, HttpUrl b) {
-    return a.host().equals(b.host())
-        && a.port() == b.port()
-        && a.scheme().equals(b.scheme());
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/annotations/EverythingIsNonNull.java b/okhttp/src/main/java/okhttp3/internal/annotations/EverythingIsNonNull.java
deleted file mode 100644
index e97bb4d9cb..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/annotations/EverythingIsNonNull.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package okhttp3.internal.annotations;
-
-import java.lang.annotation.Documented;
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import javax.annotation.Nonnull;
-import javax.annotation.meta.TypeQualifierDefault;
-
-/**
- * Extends {@code ParametersAreNonnullByDefault} to also apply to Method results and fields.
- *
- * @see javax.annotation.ParametersAreNonnullByDefault
- */
-@Documented
-@Nonnull
-@TypeQualifierDefault({
-    ElementType.FIELD,
-    ElementType.METHOD,
-    ElementType.PARAMETER
-})
-@Retention(RetentionPolicy.RUNTIME)
-public @interface EverythingIsNonNull { }
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
deleted file mode 100644
index 5e7cb27974..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
+++ /dev/null
@@ -1,269 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package okhttp3.internal.cache;
-
-import java.io.IOException;
-import javax.annotation.Nullable;
-import okhttp3.Headers;
-import okhttp3.Interceptor;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.Internal;
-import okhttp3.internal.Util;
-import okhttp3.internal.http.ExchangeCodec;
-import okhttp3.internal.http.HttpHeaders;
-import okhttp3.internal.http.HttpMethod;
-import okhttp3.internal.http.RealResponseBody;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.Okio;
-import okio.Sink;
-import okio.Source;
-import okio.Timeout;
-
-import static java.net.HttpURLConnection.HTTP_NOT_MODIFIED;
-import static java.util.concurrent.TimeUnit.MILLISECONDS;
-import static okhttp3.internal.Util.closeQuietly;
-import static okhttp3.internal.Util.discard;
-
-/** Serves requests from the cache and writes responses to the cache. */
-public final class CacheInterceptor implements Interceptor {
-  final @Nullable InternalCache cache;
-
-  public CacheInterceptor(@Nullable InternalCache cache) {
-    this.cache = cache;
-  }
-
-  @Override public Response intercept(Chain chain) throws IOException {
-    Response cacheCandidate = cache != null
-        ? cache.get(chain.request())
-        : null;
-
-    long now = System.currentTimeMillis();
-
-    CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();
-    Request networkRequest = strategy.networkRequest;
-    Response cacheResponse = strategy.cacheResponse;
-
-    if (cache != null) {
-      cache.trackResponse(strategy);
-    }
-
-    if (cacheCandidate != null && cacheResponse == null) {
-      closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.
-    }
-
-    // If we're forbidden from using the network and the cache is insufficient, fail.
-    if (networkRequest == null && cacheResponse == null) {
-      return new Response.Builder()
-          .request(chain.request())
-          .protocol(Protocol.HTTP_1_1)
-          .code(504)
-          .message("Unsatisfiable Request (only-if-cached)")
-          .body(Util.EMPTY_RESPONSE)
-          .sentRequestAtMillis(-1L)
-          .receivedResponseAtMillis(System.currentTimeMillis())
-          .build();
-    }
-
-    // If we don't need the network, we're done.
-    if (networkRequest == null) {
-      return cacheResponse.newBuilder()
-          .cacheResponse(stripBody(cacheResponse))
-          .build();
-    }
-
-    Response networkResponse = null;
-    try {
-      networkResponse = chain.proceed(networkRequest);
-    } finally {
-      // If we're crashing on I/O or otherwise, don't leak the cache body.
-      if (networkResponse == null && cacheCandidate != null) {
-        closeQuietly(cacheCandidate.body());
-      }
-    }
-
-    // If we have a cache response too, then we're doing a conditional get.
-    if (cacheResponse != null) {
-      if (networkResponse.code() == HTTP_NOT_MODIFIED) {
-        Response response = cacheResponse.newBuilder()
-            .headers(combine(cacheResponse.headers(), networkResponse.headers()))
-            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())
-            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())
-            .cacheResponse(stripBody(cacheResponse))
-            .networkResponse(stripBody(networkResponse))
-            .build();
-        networkResponse.body().close();
-
-        // Update the cache after combining headers but before stripping the
-        // Content-Encoding header (as performed by initContentStream()).
-        cache.trackConditionalCacheHit();
-        cache.update(cacheResponse, response);
-        return response;
-      } else {
-        closeQuietly(cacheResponse.body());
-      }
-    }
-
-    Response response = networkResponse.newBuilder()
-        .cacheResponse(stripBody(cacheResponse))
-        .networkResponse(stripBody(networkResponse))
-        .build();
-
-    if (cache != null) {
-      if (HttpHeaders.hasBody(response) && CacheStrategy.isCacheable(response, networkRequest)) {
-        // Offer this request to the cache.
-        CacheRequest cacheRequest = cache.put(response);
-        return cacheWritingResponse(cacheRequest, response);
-      }
-
-      if (HttpMethod.invalidatesCache(networkRequest.method())) {
-        try {
-          cache.remove(networkRequest);
-        } catch (IOException ignored) {
-          // The cache cannot be written.
-        }
-      }
-    }
-
-    return response;
-  }
-
-  private static Response stripBody(Response response) {
-    return response != null && response.body() != null
-        ? response.newBuilder().body(null).build()
-        : response;
-  }
-
-  /**
-   * Returns a new source that writes bytes to {@code cacheRequest} as they are read by the source
-   * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we
-   * may never exhaust the source stream and therefore not complete the cached response.
-   */
-  private Response cacheWritingResponse(final CacheRequest cacheRequest, Response response)
-      throws IOException {
-    // Some apps return a null body; for compatibility we treat that like a null cache request.
-    if (cacheRequest == null) return response;
-    Sink cacheBodyUnbuffered = cacheRequest.body();
-    if (cacheBodyUnbuffered == null) return response;
-
-    final BufferedSource source = response.body().source();
-    final BufferedSink cacheBody = Okio.buffer(cacheBodyUnbuffered);
-
-    Source cacheWritingSource = new Source() {
-      boolean cacheRequestClosed;
-
-      @Override public long read(Buffer sink, long byteCount) throws IOException {
-        long bytesRead;
-        try {
-          bytesRead = source.read(sink, byteCount);
-        } catch (IOException e) {
-          if (!cacheRequestClosed) {
-            cacheRequestClosed = true;
-            cacheRequest.abort(); // Failed to write a complete cache response.
-          }
-          throw e;
-        }
-
-        if (bytesRead == -1) {
-          if (!cacheRequestClosed) {
-            cacheRequestClosed = true;
-            cacheBody.close(); // The cache response is complete!
-          }
-          return -1;
-        }
-
-        sink.copyTo(cacheBody.buffer(), sink.size() - bytesRead, bytesRead);
-        cacheBody.emitCompleteSegments();
-        return bytesRead;
-      }
-
-      @Override public Timeout timeout() {
-        return source.timeout();
-      }
-
-      @Override public void close() throws IOException {
-        if (!cacheRequestClosed
-            && !discard(this, ExchangeCodec.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-          cacheRequestClosed = true;
-          cacheRequest.abort();
-        }
-        source.close();
-      }
-    };
-
-    String contentType = response.header("Content-Type");
-    long contentLength = response.body().contentLength();
-    return response.newBuilder()
-        .body(new RealResponseBody(contentType, contentLength, Okio.buffer(cacheWritingSource)))
-        .build();
-  }
-
-  /** Combines cached headers with a network headers as defined by RFC 7234, 4.3.4. */
-  private static Headers combine(Headers cachedHeaders, Headers networkHeaders) {
-    Headers.Builder result = new Headers.Builder();
-
-    for (int i = 0, size = cachedHeaders.size(); i < size; i++) {
-      String fieldName = cachedHeaders.name(i);
-      String value = cachedHeaders.value(i);
-      if ("Warning".equalsIgnoreCase(fieldName) && value.startsWith("1")) {
-        continue; // Drop 100-level freshness warnings.
-      }
-      if (isContentSpecificHeader(fieldName)
-          || !isEndToEnd(fieldName)
-          || networkHeaders.get(fieldName) == null) {
-        Internal.instance.addLenient(result, fieldName, value);
-      }
-    }
-
-    for (int i = 0, size = networkHeaders.size(); i < size; i++) {
-      String fieldName = networkHeaders.name(i);
-      if (!isContentSpecificHeader(fieldName) && isEndToEnd(fieldName)) {
-        Internal.instance.addLenient(result, fieldName, networkHeaders.value(i));
-      }
-    }
-
-    return result.build();
-  }
-
-  /**
-   * Returns true if {@code fieldName} is an end-to-end HTTP header, as defined by RFC 2616,
-   * 13.5.1.
-   */
-  static boolean isEndToEnd(String fieldName) {
-    return !"Connection".equalsIgnoreCase(fieldName)
-        && !"Keep-Alive".equalsIgnoreCase(fieldName)
-        && !"Proxy-Authenticate".equalsIgnoreCase(fieldName)
-        && !"Proxy-Authorization".equalsIgnoreCase(fieldName)
-        && !"TE".equalsIgnoreCase(fieldName)
-        && !"Trailers".equalsIgnoreCase(fieldName)
-        && !"Transfer-Encoding".equalsIgnoreCase(fieldName)
-        && !"Upgrade".equalsIgnoreCase(fieldName);
-  }
-
-  /**
-   * Returns true if {@code fieldName} is content specific and therefore should always be used
-   * from cached headers.
-   */
-  static boolean isContentSpecificHeader(String fieldName) {
-    return "Content-Length".equalsIgnoreCase(fieldName)
-        || "Content-Encoding".equalsIgnoreCase(fieldName)
-        || "Content-Type".equalsIgnoreCase(fieldName);
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheRequest.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheRequest.java
deleted file mode 100644
index b4432b4e1d..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheRequest.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.cache;
-
-import java.io.IOException;
-import okio.Sink;
-
-public interface CacheRequest {
-  Sink body() throws IOException;
-
-  void abort();
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
deleted file mode 100644
index c7fb69ceba..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
+++ /dev/null
@@ -1,326 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.cache;
-
-import java.util.Date;
-import javax.annotation.Nullable;
-import okhttp3.CacheControl;
-import okhttp3.Headers;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.Internal;
-import okhttp3.internal.http.HttpDate;
-import okhttp3.internal.http.HttpHeaders;
-import okhttp3.internal.http.StatusLine;
-
-import static java.net.HttpURLConnection.HTTP_BAD_METHOD;
-import static java.net.HttpURLConnection.HTTP_GONE;
-import static java.net.HttpURLConnection.HTTP_MOVED_PERM;
-import static java.net.HttpURLConnection.HTTP_MOVED_TEMP;
-import static java.net.HttpURLConnection.HTTP_MULT_CHOICE;
-import static java.net.HttpURLConnection.HTTP_NOT_AUTHORITATIVE;
-import static java.net.HttpURLConnection.HTTP_NOT_FOUND;
-import static java.net.HttpURLConnection.HTTP_NOT_IMPLEMENTED;
-import static java.net.HttpURLConnection.HTTP_NO_CONTENT;
-import static java.net.HttpURLConnection.HTTP_OK;
-import static java.net.HttpURLConnection.HTTP_REQ_TOO_LONG;
-import static java.util.concurrent.TimeUnit.SECONDS;
-
-/**
- * Given a request and cached response, this figures out whether to use the network, the cache, or
- * both.
- *
- * <p>Selecting a cache strategy may add conditions to the request (like the "If-Modified-Since"
- * header for conditional GETs) or warnings to the cached response (if the cached data is
- * potentially stale).
- */
-public final class CacheStrategy {
-  /** The request to send on the network, or null if this call doesn't use the network. */
-  public final @Nullable Request networkRequest;
-
-  /** The cached response to return or validate; or null if this call doesn't use a cache. */
-  public final @Nullable Response cacheResponse;
-
-  CacheStrategy(Request networkRequest, Response cacheResponse) {
-    this.networkRequest = networkRequest;
-    this.cacheResponse = cacheResponse;
-  }
-
-  /** Returns true if {@code response} can be stored to later serve another request. */
-  public static boolean isCacheable(Response response, Request request) {
-    // Always go to network for uncacheable response codes (RFC 7231 section 6.1),
-    // This implementation doesn't support caching partial content.
-    switch (response.code()) {
-      case HTTP_OK:
-      case HTTP_NOT_AUTHORITATIVE:
-      case HTTP_NO_CONTENT:
-      case HTTP_MULT_CHOICE:
-      case HTTP_MOVED_PERM:
-      case HTTP_NOT_FOUND:
-      case HTTP_BAD_METHOD:
-      case HTTP_GONE:
-      case HTTP_REQ_TOO_LONG:
-      case HTTP_NOT_IMPLEMENTED:
-      case StatusLine.HTTP_PERM_REDIRECT:
-        // These codes can be cached unless headers forbid it.
-        break;
-
-      case HTTP_MOVED_TEMP:
-      case StatusLine.HTTP_TEMP_REDIRECT:
-        // These codes can only be cached with the right response headers.
-        // http://tools.ietf.org/html/rfc7234#section-3
-        // s-maxage is not checked because OkHttp is a private cache that should ignore s-maxage.
-        if (response.header("Expires") != null
-            || response.cacheControl().maxAgeSeconds() != -1
-            || response.cacheControl().isPublic()
-            || response.cacheControl().isPrivate()) {
-          break;
-        }
-        // Fall-through.
-
-      default:
-        // All other codes cannot be cached.
-        return false;
-    }
-
-    // A 'no-store' directive on request or response prevents the response from being cached.
-    return !response.cacheControl().noStore() && !request.cacheControl().noStore();
-  }
-
-  public static class Factory {
-    final long nowMillis;
-    final Request request;
-    final Response cacheResponse;
-
-    /** The server's time when the cached response was served, if known. */
-    private Date servedDate;
-    private String servedDateString;
-
-    /** The last modified date of the cached response, if known. */
-    private Date lastModified;
-    private String lastModifiedString;
-
-    /**
-     * The expiration date of the cached response, if known. If both this field and the max age are
-     * set, the max age is preferred.
-     */
-    private Date expires;
-
-    /**
-     * Extension header set by OkHttp specifying the timestamp when the cached HTTP request was
-     * first initiated.
-     */
-    private long sentRequestMillis;
-
-    /**
-     * Extension header set by OkHttp specifying the timestamp when the cached HTTP response was
-     * first received.
-     */
-    private long receivedResponseMillis;
-
-    /** Etag of the cached response. */
-    private String etag;
-
-    /** Age of the cached response. */
-    private int ageSeconds = -1;
-
-    public Factory(long nowMillis, Request request, Response cacheResponse) {
-      this.nowMillis = nowMillis;
-      this.request = request;
-      this.cacheResponse = cacheResponse;
-
-      if (cacheResponse != null) {
-        this.sentRequestMillis = cacheResponse.sentRequestAtMillis();
-        this.receivedResponseMillis = cacheResponse.receivedResponseAtMillis();
-        Headers headers = cacheResponse.headers();
-        for (int i = 0, size = headers.size(); i < size; i++) {
-          String fieldName = headers.name(i);
-          String value = headers.value(i);
-          if ("Date".equalsIgnoreCase(fieldName)) {
-            servedDate = HttpDate.parse(value);
-            servedDateString = value;
-          } else if ("Expires".equalsIgnoreCase(fieldName)) {
-            expires = HttpDate.parse(value);
-          } else if ("Last-Modified".equalsIgnoreCase(fieldName)) {
-            lastModified = HttpDate.parse(value);
-            lastModifiedString = value;
-          } else if ("ETag".equalsIgnoreCase(fieldName)) {
-            etag = value;
-          } else if ("Age".equalsIgnoreCase(fieldName)) {
-            ageSeconds = HttpHeaders.parseSeconds(value, -1);
-          }
-        }
-      }
-    }
-
-    /**
-     * Returns a strategy to satisfy {@code request} using the a cached response {@code response}.
-     */
-    public CacheStrategy get() {
-      CacheStrategy candidate = getCandidate();
-
-      if (candidate.networkRequest != null && request.cacheControl().onlyIfCached()) {
-        // We're forbidden from using the network and the cache is insufficient.
-        return new CacheStrategy(null, null);
-      }
-
-      return candidate;
-    }
-
-    /** Returns a strategy to use assuming the request can use the network. */
-    private CacheStrategy getCandidate() {
-      // No cached response.
-      if (cacheResponse == null) {
-        return new CacheStrategy(request, null);
-      }
-
-      // Drop the cached response if it's missing a required handshake.
-      if (request.isHttps() && cacheResponse.handshake() == null) {
-        return new CacheStrategy(request, null);
-      }
-
-      // If this response shouldn't have been stored, it should never be used
-      // as a response source. This check should be redundant as long as the
-      // persistence store is well-behaved and the rules are constant.
-      if (!isCacheable(cacheResponse, request)) {
-        return new CacheStrategy(request, null);
-      }
-
-      CacheControl requestCaching = request.cacheControl();
-      if (requestCaching.noCache() || hasConditions(request)) {
-        return new CacheStrategy(request, null);
-      }
-
-      CacheControl responseCaching = cacheResponse.cacheControl();
-
-      long ageMillis = cacheResponseAge();
-      long freshMillis = computeFreshnessLifetime();
-
-      if (requestCaching.maxAgeSeconds() != -1) {
-        freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));
-      }
-
-      long minFreshMillis = 0;
-      if (requestCaching.minFreshSeconds() != -1) {
-        minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());
-      }
-
-      long maxStaleMillis = 0;
-      if (!responseCaching.mustRevalidate() && requestCaching.maxStaleSeconds() != -1) {
-        maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());
-      }
-
-      if (!responseCaching.noCache() && ageMillis + minFreshMillis < freshMillis + maxStaleMillis) {
-        Response.Builder builder = cacheResponse.newBuilder();
-        if (ageMillis + minFreshMillis >= freshMillis) {
-          builder.addHeader("Warning", "110 HttpURLConnection \"Response is stale\"");
-        }
-        long oneDayMillis = 24 * 60 * 60 * 1000L;
-        if (ageMillis > oneDayMillis && isFreshnessLifetimeHeuristic()) {
-          builder.addHeader("Warning", "113 HttpURLConnection \"Heuristic expiration\"");
-        }
-        return new CacheStrategy(null, builder.build());
-      }
-
-      // Find a condition to add to the request. If the condition is satisfied, the response body
-      // will not be transmitted.
-      String conditionName;
-      String conditionValue;
-      if (etag != null) {
-        conditionName = "If-None-Match";
-        conditionValue = etag;
-      } else if (lastModified != null) {
-        conditionName = "If-Modified-Since";
-        conditionValue = lastModifiedString;
-      } else if (servedDate != null) {
-        conditionName = "If-Modified-Since";
-        conditionValue = servedDateString;
-      } else {
-        return new CacheStrategy(request, null); // No condition! Make a regular request.
-      }
-
-      Headers.Builder conditionalRequestHeaders = request.headers().newBuilder();
-      Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue);
-
-      Request conditionalRequest = request.newBuilder()
-          .headers(conditionalRequestHeaders.build())
-          .build();
-      return new CacheStrategy(conditionalRequest, cacheResponse);
-    }
-
-    /**
-     * Returns the number of milliseconds that the response was fresh for, starting from the served
-     * date.
-     */
-    private long computeFreshnessLifetime() {
-      CacheControl responseCaching = cacheResponse.cacheControl();
-      if (responseCaching.maxAgeSeconds() != -1) {
-        return SECONDS.toMillis(responseCaching.maxAgeSeconds());
-      } else if (expires != null) {
-        long servedMillis = servedDate != null
-            ? servedDate.getTime()
-            : receivedResponseMillis;
-        long delta = expires.getTime() - servedMillis;
-        return delta > 0 ? delta : 0;
-      } else if (lastModified != null
-          && cacheResponse.request().url().query() == null) {
-        // As recommended by the HTTP RFC and implemented in Firefox, the
-        // max age of a document should be defaulted to 10% of the
-        // document's age at the time it was served. Default expiration
-        // dates aren't used for URIs containing a query.
-        long servedMillis = servedDate != null
-            ? servedDate.getTime()
-            : sentRequestMillis;
-        long delta = servedMillis - lastModified.getTime();
-        return delta > 0 ? (delta / 10) : 0;
-      }
-      return 0;
-    }
-
-    /**
-     * Returns the current age of the response, in milliseconds. The calculation is specified by RFC
-     * 7234, 4.2.3 Calculating Age.
-     */
-    private long cacheResponseAge() {
-      long apparentReceivedAge = servedDate != null
-          ? Math.max(0, receivedResponseMillis - servedDate.getTime())
-          : 0;
-      long receivedAge = ageSeconds != -1
-          ? Math.max(apparentReceivedAge, SECONDS.toMillis(ageSeconds))
-          : apparentReceivedAge;
-      long responseDuration = receivedResponseMillis - sentRequestMillis;
-      long residentDuration = nowMillis - receivedResponseMillis;
-      return receivedAge + responseDuration + residentDuration;
-    }
-
-    /**
-     * Returns true if computeFreshnessLifetime used a heuristic. If we used a heuristic to serve a
-     * cached response older than 24 hours, we are required to attach a warning.
-     */
-    private boolean isFreshnessLifetimeHeuristic() {
-      return cacheResponse.cacheControl().maxAgeSeconds() == -1 && expires == null;
-    }
-
-    /**
-     * Returns true if the request contains conditions that save the server from sending a response
-     * that the client has locally. When a request is enqueued with its own conditions, the built-in
-     * response cache won't be used.
-     */
-    private static boolean hasConditions(Request request) {
-      return request.header("If-Modified-Since") != null || request.header("If-None-Match") != null;
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
deleted file mode 100644
index 3b193f3b91..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
+++ /dev/null
@@ -1,1047 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.cache;
-
-import java.io.Closeable;
-import java.io.EOFException;
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.Flushable;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Iterator;
-import java.util.LinkedHashMap;
-import java.util.NoSuchElementException;
-import java.util.concurrent.Executor;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.ThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-import javax.annotation.Nullable;
-import okhttp3.internal.Util;
-import okhttp3.internal.io.FileSystem;
-import okhttp3.internal.platform.Platform;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.Okio;
-import okio.Sink;
-import okio.Source;
-
-import static okhttp3.internal.platform.Platform.WARN;
-
-/**
- * A cache that uses a bounded amount of space on a filesystem. Each cache entry has a string key
- * and a fixed number of values. Each key must match the regex <strong>[a-z0-9_-]{1,64}</strong>.
- * Values are byte sequences, accessible as streams or files. Each value must be between {@code 0}
- * and {@code Integer.MAX_VALUE} bytes in length.
- *
- * <p>The cache stores its data in a directory on the filesystem. This directory must be exclusive
- * to the cache; the cache may delete or overwrite files from its directory. It is an error for
- * multiple processes to use the same cache directory at the same time.
- *
- * <p>This cache limits the number of bytes that it will store on the filesystem. When the number of
- * stored bytes exceeds the limit, the cache will remove entries in the background until the limit
- * is satisfied. The limit is not strict: the cache may temporarily exceed it while waiting for
- * files to be deleted. The limit does not include filesystem overhead or the cache journal so
- * space-sensitive applications should set a conservative limit.
- *
- * <p>Clients call {@link #edit} to create or update the values of an entry. An entry may have only
- * one editor at one time; if a value is not available to be edited then {@link #edit} will return
- * null.
- *
- * <ul>
- *     <li>When an entry is being <strong>created</strong> it is necessary to supply a full set of
- *         values; the empty value should be used as a placeholder if necessary.
- *     <li>When an entry is being <strong>edited</strong>, it is not necessary to supply data for
- *         every value; values default to their previous value.
- * </ul>
- *
- * <p>Every {@link #edit} call must be matched by a call to {@link Editor#commit} or {@link
- * Editor#abort}. Committing is atomic: a read observes the full set of values as they were before
- * or after the commit, but never a mix of values.
- *
- * <p>Clients call {@link #get} to read a snapshot of an entry. The read will observe the value at
- * the time that {@link #get} was called. Updates and removals after the call do not impact ongoing
- * reads.
- *
- * <p>This class is tolerant of some I/O errors. If files are missing from the filesystem, the
- * corresponding entries will be dropped from the cache. If an error occurs while writing a cache
- * value, the edit will fail silently. Callers should handle other problems by catching {@code
- * IOException} and responding appropriately.
- */
-public final class DiskLruCache implements Closeable, Flushable {
-  static final String JOURNAL_FILE = "journal";
-  static final String JOURNAL_FILE_TEMP = "journal.tmp";
-  static final String JOURNAL_FILE_BACKUP = "journal.bkp";
-  static final String MAGIC = "libcore.io.DiskLruCache";
-  static final String VERSION_1 = "1";
-  static final long ANY_SEQUENCE_NUMBER = -1;
-  static final Pattern LEGAL_KEY_PATTERN = Pattern.compile("[a-z0-9_-]{1,120}");
-  private static final String CLEAN = "CLEAN";
-  private static final String DIRTY = "DIRTY";
-  private static final String REMOVE = "REMOVE";
-  private static final String READ = "READ";
-
-    /*
-     * This cache uses a journal file named "journal". A typical journal file
-     * looks like this:
-     *     libcore.io.DiskLruCache
-     *     1
-     *     100
-     *     2
-     *
-     *     CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054
-     *     DIRTY 335c4c6028171cfddfbaae1a9c313c52
-     *     CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934 2342
-     *     REMOVE 335c4c6028171cfddfbaae1a9c313c52
-     *     DIRTY 1ab96a171faeeee38496d8b330771a7a
-     *     CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234
-     *     READ 335c4c6028171cfddfbaae1a9c313c52
-     *     READ 3400330d1dfc7f3f7f4b8d4d803dfcf6
-     *
-     * The first five lines of the journal form its header. They are the
-     * constant string "libcore.io.DiskLruCache", the disk cache's version,
-     * the application's version, the value count, and a blank line.
-     *
-     * Each of the subsequent lines in the file is a record of the state of a
-     * cache entry. Each line contains space-separated values: a state, a key,
-     * and optional state-specific values.
-     *   o DIRTY lines track that an entry is actively being created or updated.
-     *     Every successful DIRTY action should be followed by a CLEAN or REMOVE
-     *     action. DIRTY lines without a matching CLEAN or REMOVE indicate that
-     *     temporary files may need to be deleted.
-     *   o CLEAN lines track a cache entry that has been successfully published
-     *     and may be read. A publish line is followed by the lengths of each of
-     *     its values.
-     *   o READ lines track accesses for LRU.
-     *   o REMOVE lines track entries that have been deleted.
-     *
-     * The journal file is appended to as cache operations occur. The journal may
-     * occasionally be compacted by dropping redundant lines. A temporary file named
-     * "journal.tmp" will be used during compaction; that file should be deleted if
-     * it exists when the cache is opened.
-     */
-
-  final FileSystem fileSystem;
-  final File directory;
-  private final File journalFile;
-  private final File journalFileTmp;
-  private final File journalFileBackup;
-  private final int appVersion;
-  private long maxSize;
-  final int valueCount;
-  private long size = 0;
-  BufferedSink journalWriter;
-  final LinkedHashMap<String, Entry> lruEntries = new LinkedHashMap<>(0, 0.75f, true);
-  int redundantOpCount;
-  boolean hasJournalErrors;
-
-  // Must be read and written when synchronized on 'this'.
-  boolean initialized;
-  boolean closed;
-  boolean mostRecentTrimFailed;
-  boolean mostRecentRebuildFailed;
-
-  /**
-   * To differentiate between old and current snapshots, each entry is given a sequence number each
-   * time an edit is committed. A snapshot is stale if its sequence number is not equal to its
-   * entry's sequence number.
-   */
-  private long nextSequenceNumber = 0;
-
-  /** Used to run 'cleanupRunnable' for journal rebuilds. */
-  private final Executor executor;
-  private final Runnable cleanupRunnable = new Runnable() {
-    public void run() {
-      synchronized (DiskLruCache.this) {
-        if (!initialized | closed) {
-          return; // Nothing to do
-        }
-
-        try {
-          trimToSize();
-        } catch (IOException ignored) {
-          mostRecentTrimFailed = true;
-        }
-
-        try {
-          if (journalRebuildRequired()) {
-            rebuildJournal();
-            redundantOpCount = 0;
-          }
-        } catch (IOException e) {
-          mostRecentRebuildFailed = true;
-          journalWriter = Okio.buffer(Okio.blackhole());
-        }
-      }
-    }
-  };
-
-  DiskLruCache(FileSystem fileSystem, File directory, int appVersion, int valueCount, long maxSize,
-      Executor executor) {
-    this.fileSystem = fileSystem;
-    this.directory = directory;
-    this.appVersion = appVersion;
-    this.journalFile = new File(directory, JOURNAL_FILE);
-    this.journalFileTmp = new File(directory, JOURNAL_FILE_TEMP);
-    this.journalFileBackup = new File(directory, JOURNAL_FILE_BACKUP);
-    this.valueCount = valueCount;
-    this.maxSize = maxSize;
-    this.executor = executor;
-  }
-
-  public synchronized void initialize() throws IOException {
-    assert Thread.holdsLock(this);
-
-    if (initialized) {
-      return; // Already initialized.
-    }
-
-    // If a bkp file exists, use it instead.
-    if (fileSystem.exists(journalFileBackup)) {
-      // If journal file also exists just delete backup file.
-      if (fileSystem.exists(journalFile)) {
-        fileSystem.delete(journalFileBackup);
-      } else {
-        fileSystem.rename(journalFileBackup, journalFile);
-      }
-    }
-
-    // Prefer to pick up where we left off.
-    if (fileSystem.exists(journalFile)) {
-      try {
-        readJournal();
-        processJournal();
-        initialized = true;
-        return;
-      } catch (IOException journalIsCorrupt) {
-        Platform.get().log(WARN, "DiskLruCache " + directory + " is corrupt: "
-            + journalIsCorrupt.getMessage() + ", removing", journalIsCorrupt);
-      }
-
-      // The cache is corrupted, attempt to delete the contents of the directory. This can throw and
-      // we'll let that propagate out as it likely means there is a severe filesystem problem.
-      try {
-        delete();
-      } finally {
-        closed = false;
-      }
-    }
-
-    rebuildJournal();
-
-    initialized = true;
-  }
-
-  /**
-   * Create a cache which will reside in {@code directory}. This cache is lazily initialized on
-   * first access and will be created if it does not exist.
-   *
-   * @param directory a writable directory
-   * @param valueCount the number of values per cache entry. Must be positive.
-   * @param maxSize the maximum number of bytes this cache should use to store
-   */
-  public static DiskLruCache create(FileSystem fileSystem, File directory, int appVersion,
-      int valueCount, long maxSize) {
-    if (maxSize <= 0) {
-      throw new IllegalArgumentException("maxSize <= 0");
-    }
-    if (valueCount <= 0) {
-      throw new IllegalArgumentException("valueCount <= 0");
-    }
-
-    // Use a single background thread to evict entries.
-    Executor executor = new ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS,
-        new LinkedBlockingQueue<>(), Util.threadFactory("OkHttp DiskLruCache", true));
-
-    return new DiskLruCache(fileSystem, directory, appVersion, valueCount, maxSize, executor);
-  }
-
-  private void readJournal() throws IOException {
-    try (BufferedSource source = Okio.buffer(fileSystem.source(journalFile))) {
-      String magic = source.readUtf8LineStrict();
-      String version = source.readUtf8LineStrict();
-      String appVersionString = source.readUtf8LineStrict();
-      String valueCountString = source.readUtf8LineStrict();
-      String blank = source.readUtf8LineStrict();
-      if (!MAGIC.equals(magic)
-          || !VERSION_1.equals(version)
-          || !Integer.toString(appVersion).equals(appVersionString)
-          || !Integer.toString(valueCount).equals(valueCountString)
-          || !"".equals(blank)) {
-        throw new IOException("unexpected journal header: [" + magic + ", " + version + ", "
-            + valueCountString + ", " + blank + "]");
-      }
-
-      int lineCount = 0;
-      while (true) {
-        try {
-          readJournalLine(source.readUtf8LineStrict());
-          lineCount++;
-        } catch (EOFException endOfJournal) {
-          break;
-        }
-      }
-      redundantOpCount = lineCount - lruEntries.size();
-
-      // If we ended on a truncated line, rebuild the journal before appending to it.
-      if (!source.exhausted()) {
-        rebuildJournal();
-      } else {
-        journalWriter = newJournalWriter();
-      }
-    }
-  }
-
-  private BufferedSink newJournalWriter() throws FileNotFoundException {
-    Sink fileSink = fileSystem.appendingSink(journalFile);
-    Sink faultHidingSink = new FaultHidingSink(fileSink) {
-      @Override protected void onException(IOException e) {
-        assert (Thread.holdsLock(DiskLruCache.this));
-        hasJournalErrors = true;
-      }
-    };
-    return Okio.buffer(faultHidingSink);
-  }
-
-  private void readJournalLine(String line) throws IOException {
-    int firstSpace = line.indexOf(' ');
-    if (firstSpace == -1) {
-      throw new IOException("unexpected journal line: " + line);
-    }
-
-    int keyBegin = firstSpace + 1;
-    int secondSpace = line.indexOf(' ', keyBegin);
-    final String key;
-    if (secondSpace == -1) {
-      key = line.substring(keyBegin);
-      if (firstSpace == REMOVE.length() && line.startsWith(REMOVE)) {
-        lruEntries.remove(key);
-        return;
-      }
-    } else {
-      key = line.substring(keyBegin, secondSpace);
-    }
-
-    Entry entry = lruEntries.get(key);
-    if (entry == null) {
-      entry = new Entry(key);
-      lruEntries.put(key, entry);
-    }
-
-    if (secondSpace != -1 && firstSpace == CLEAN.length() && line.startsWith(CLEAN)) {
-      String[] parts = line.substring(secondSpace + 1).split(" ");
-      entry.readable = true;
-      entry.currentEditor = null;
-      entry.setLengths(parts);
-    } else if (secondSpace == -1 && firstSpace == DIRTY.length() && line.startsWith(DIRTY)) {
-      entry.currentEditor = new Editor(entry);
-    } else if (secondSpace == -1 && firstSpace == READ.length() && line.startsWith(READ)) {
-      // This work was already done by calling lruEntries.get().
-    } else {
-      throw new IOException("unexpected journal line: " + line);
-    }
-  }
-
-  /**
-   * Computes the initial size and collects garbage as a part of opening the cache. Dirty entries
-   * are assumed to be inconsistent and will be deleted.
-   */
-  private void processJournal() throws IOException {
-    fileSystem.delete(journalFileTmp);
-    for (Iterator<Entry> i = lruEntries.values().iterator(); i.hasNext(); ) {
-      Entry entry = i.next();
-      if (entry.currentEditor == null) {
-        for (int t = 0; t < valueCount; t++) {
-          size += entry.lengths[t];
-        }
-      } else {
-        entry.currentEditor = null;
-        for (int t = 0; t < valueCount; t++) {
-          fileSystem.delete(entry.cleanFiles[t]);
-          fileSystem.delete(entry.dirtyFiles[t]);
-        }
-        i.remove();
-      }
-    }
-  }
-
-  /**
-   * Creates a new journal that omits redundant information. This replaces the current journal if it
-   * exists.
-   */
-  synchronized void rebuildJournal() throws IOException {
-    if (journalWriter != null) {
-      journalWriter.close();
-    }
-
-    try (BufferedSink writer = Okio.buffer(fileSystem.sink(journalFileTmp))) {
-      writer.writeUtf8(MAGIC).writeByte('\n');
-      writer.writeUtf8(VERSION_1).writeByte('\n');
-      writer.writeDecimalLong(appVersion).writeByte('\n');
-      writer.writeDecimalLong(valueCount).writeByte('\n');
-      writer.writeByte('\n');
-
-      for (Entry entry : lruEntries.values()) {
-        if (entry.currentEditor != null) {
-          writer.writeUtf8(DIRTY).writeByte(' ');
-          writer.writeUtf8(entry.key);
-          writer.writeByte('\n');
-        } else {
-          writer.writeUtf8(CLEAN).writeByte(' ');
-          writer.writeUtf8(entry.key);
-          entry.writeLengths(writer);
-          writer.writeByte('\n');
-        }
-      }
-    }
-
-    if (fileSystem.exists(journalFile)) {
-      fileSystem.rename(journalFile, journalFileBackup);
-    }
-    fileSystem.rename(journalFileTmp, journalFile);
-    fileSystem.delete(journalFileBackup);
-
-    journalWriter = newJournalWriter();
-    hasJournalErrors = false;
-    mostRecentRebuildFailed = false;
-  }
-
-  /**
-   * Returns a snapshot of the entry named {@code key}, or null if it doesn't exist is not currently
-   * readable. If a value is returned, it is moved to the head of the LRU queue.
-   */
-  public synchronized Snapshot get(String key) throws IOException {
-    initialize();
-
-    checkNotClosed();
-    validateKey(key);
-    Entry entry = lruEntries.get(key);
-    if (entry == null || !entry.readable) return null;
-
-    Snapshot snapshot = entry.snapshot();
-    if (snapshot == null) return null;
-
-    redundantOpCount++;
-    journalWriter.writeUtf8(READ).writeByte(' ').writeUtf8(key).writeByte('\n');
-    if (journalRebuildRequired()) {
-      executor.execute(cleanupRunnable);
-    }
-
-    return snapshot;
-  }
-
-  /**
-   * Returns an editor for the entry named {@code key}, or null if another edit is in progress.
-   */
-  public @Nullable Editor edit(String key) throws IOException {
-    return edit(key, ANY_SEQUENCE_NUMBER);
-  }
-
-  synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException {
-    initialize();
-
-    checkNotClosed();
-    validateKey(key);
-    Entry entry = lruEntries.get(key);
-    if (expectedSequenceNumber != ANY_SEQUENCE_NUMBER && (entry == null
-        || entry.sequenceNumber != expectedSequenceNumber)) {
-      return null; // Snapshot is stale.
-    }
-    if (entry != null && entry.currentEditor != null) {
-      return null; // Another edit is in progress.
-    }
-    if (mostRecentTrimFailed || mostRecentRebuildFailed) {
-      // The OS has become our enemy! If the trim job failed, it means we are storing more data than
-      // requested by the user. Do not allow edits so we do not go over that limit any further. If
-      // the journal rebuild failed, the journal writer will not be active, meaning we will not be
-      // able to record the edit, causing file leaks. In both cases, we want to retry the clean up
-      // so we can get out of this state!
-      executor.execute(cleanupRunnable);
-      return null;
-    }
-
-    // Flush the journal before creating files to prevent file leaks.
-    journalWriter.writeUtf8(DIRTY).writeByte(' ').writeUtf8(key).writeByte('\n');
-    journalWriter.flush();
-
-    if (hasJournalErrors) {
-      return null; // Don't edit; the journal can't be written.
-    }
-
-    if (entry == null) {
-      entry = new Entry(key);
-      lruEntries.put(key, entry);
-    }
-    Editor editor = new Editor(entry);
-    entry.currentEditor = editor;
-    return editor;
-  }
-
-  /** Returns the directory where this cache stores its data. */
-  public File getDirectory() {
-    return directory;
-  }
-
-  /**
-   * Returns the maximum number of bytes that this cache should use to store its data.
-   */
-  public synchronized long getMaxSize() {
-    return maxSize;
-  }
-
-  /**
-   * Changes the maximum number of bytes the cache can store and queues a job to trim the existing
-   * store, if necessary.
-   */
-  public synchronized void setMaxSize(long maxSize) {
-    this.maxSize = maxSize;
-    if (initialized) {
-      executor.execute(cleanupRunnable);
-    }
-  }
-
-  /**
-   * Returns the number of bytes currently being used to store the values in this cache. This may be
-   * greater than the max size if a background deletion is pending.
-   */
-  public synchronized long size() throws IOException {
-    initialize();
-    return size;
-  }
-
-  synchronized void completeEdit(Editor editor, boolean success) throws IOException {
-    Entry entry = editor.entry;
-    if (entry.currentEditor != editor) {
-      throw new IllegalStateException();
-    }
-
-    // If this edit is creating the entry for the first time, every index must have a value.
-    if (success && !entry.readable) {
-      for (int i = 0; i < valueCount; i++) {
-        if (!editor.written[i]) {
-          editor.abort();
-          throw new IllegalStateException("Newly created entry didn't create value for index " + i);
-        }
-        if (!fileSystem.exists(entry.dirtyFiles[i])) {
-          editor.abort();
-          return;
-        }
-      }
-    }
-
-    for (int i = 0; i < valueCount; i++) {
-      File dirty = entry.dirtyFiles[i];
-      if (success) {
-        if (fileSystem.exists(dirty)) {
-          File clean = entry.cleanFiles[i];
-          fileSystem.rename(dirty, clean);
-          long oldLength = entry.lengths[i];
-          long newLength = fileSystem.size(clean);
-          entry.lengths[i] = newLength;
-          size = size - oldLength + newLength;
-        }
-      } else {
-        fileSystem.delete(dirty);
-      }
-    }
-
-    redundantOpCount++;
-    entry.currentEditor = null;
-    if (entry.readable | success) {
-      entry.readable = true;
-      journalWriter.writeUtf8(CLEAN).writeByte(' ');
-      journalWriter.writeUtf8(entry.key);
-      entry.writeLengths(journalWriter);
-      journalWriter.writeByte('\n');
-      if (success) {
-        entry.sequenceNumber = nextSequenceNumber++;
-      }
-    } else {
-      lruEntries.remove(entry.key);
-      journalWriter.writeUtf8(REMOVE).writeByte(' ');
-      journalWriter.writeUtf8(entry.key);
-      journalWriter.writeByte('\n');
-    }
-    journalWriter.flush();
-
-    if (size > maxSize || journalRebuildRequired()) {
-      executor.execute(cleanupRunnable);
-    }
-  }
-
-  /**
-   * We only rebuild the journal when it will halve the size of the journal and eliminate at least
-   * 2000 ops.
-   */
-  boolean journalRebuildRequired() {
-    final int redundantOpCompactThreshold = 2000;
-    return redundantOpCount >= redundantOpCompactThreshold
-        && redundantOpCount >= lruEntries.size();
-  }
-
-  /**
-   * Drops the entry for {@code key} if it exists and can be removed. If the entry for {@code key}
-   * is currently being edited, that edit will complete normally but its value will not be stored.
-   *
-   * @return true if an entry was removed.
-   */
-  public synchronized boolean remove(String key) throws IOException {
-    initialize();
-
-    checkNotClosed();
-    validateKey(key);
-    Entry entry = lruEntries.get(key);
-    if (entry == null) return false;
-    boolean removed = removeEntry(entry);
-    if (removed && size <= maxSize) mostRecentTrimFailed = false;
-    return removed;
-  }
-
-  boolean removeEntry(Entry entry) throws IOException {
-    if (entry.currentEditor != null) {
-      entry.currentEditor.detach(); // Prevent the edit from completing normally.
-    }
-
-    for (int i = 0; i < valueCount; i++) {
-      fileSystem.delete(entry.cleanFiles[i]);
-      size -= entry.lengths[i];
-      entry.lengths[i] = 0;
-    }
-
-    redundantOpCount++;
-    journalWriter.writeUtf8(REMOVE).writeByte(' ').writeUtf8(entry.key).writeByte('\n');
-    lruEntries.remove(entry.key);
-
-    if (journalRebuildRequired()) {
-      executor.execute(cleanupRunnable);
-    }
-
-    return true;
-  }
-
-  /** Returns true if this cache has been closed. */
-  public synchronized boolean isClosed() {
-    return closed;
-  }
-
-  private synchronized void checkNotClosed() {
-    if (isClosed()) {
-      throw new IllegalStateException("cache is closed");
-    }
-  }
-
-  /** Force buffered operations to the filesystem. */
-  @Override public synchronized void flush() throws IOException {
-    if (!initialized) return;
-
-    checkNotClosed();
-    trimToSize();
-    journalWriter.flush();
-  }
-
-  /** Closes this cache. Stored values will remain on the filesystem. */
-  @Override public synchronized void close() throws IOException {
-    if (!initialized || closed) {
-      closed = true;
-      return;
-    }
-    // Copying for safe iteration.
-    for (Entry entry : lruEntries.values().toArray(new Entry[lruEntries.size()])) {
-      if (entry.currentEditor != null) {
-        entry.currentEditor.abort();
-      }
-    }
-    trimToSize();
-    journalWriter.close();
-    journalWriter = null;
-    closed = true;
-  }
-
-  void trimToSize() throws IOException {
-    while (size > maxSize) {
-      Entry toEvict = lruEntries.values().iterator().next();
-      removeEntry(toEvict);
-    }
-    mostRecentTrimFailed = false;
-  }
-
-  /**
-   * Closes the cache and deletes all of its stored values. This will delete all files in the cache
-   * directory including files that weren't created by the cache.
-   */
-  public void delete() throws IOException {
-    close();
-    fileSystem.deleteContents(directory);
-  }
-
-  /**
-   * Deletes all stored values from the cache. In-flight edits will complete normally but their
-   * values will not be stored.
-   */
-  public synchronized void evictAll() throws IOException {
-    initialize();
-    // Copying for safe iteration.
-    for (Entry entry : lruEntries.values().toArray(new Entry[lruEntries.size()])) {
-      removeEntry(entry);
-    }
-    mostRecentTrimFailed = false;
-  }
-
-  private void validateKey(String key) {
-    Matcher matcher = LEGAL_KEY_PATTERN.matcher(key);
-    if (!matcher.matches()) {
-      throw new IllegalArgumentException(
-          "keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"");
-    }
-  }
-
-  /**
-   * Returns an iterator over the cache's current entries. This iterator doesn't throw {@code
-   * ConcurrentModificationException}, but if new entries are added while iterating, those new
-   * entries will not be returned by the iterator. If existing entries are removed during iteration,
-   * they will be absent (unless they were already returned).
-   *
-   * <p>If there are I/O problems during iteration, this iterator fails silently. For example, if
-   * the hosting filesystem becomes unreachable, the iterator will omit elements rather than
-   * throwing exceptions.
-   *
-   * <p><strong>The caller must {@link Snapshot#close close}</strong> each snapshot returned by
-   * {@link Iterator#next}. Failing to do so leaks open files!
-   *
-   * <p>The returned iterator supports {@link Iterator#remove}.
-   */
-  public synchronized Iterator<Snapshot> snapshots() throws IOException {
-    initialize();
-    return new Iterator<Snapshot>() {
-      /** Iterate a copy of the entries to defend against concurrent modification errors. */
-      final Iterator<Entry> delegate = new ArrayList<>(lruEntries.values()).iterator();
-
-      /** The snapshot to return from {@link #next}. Null if we haven't computed that yet. */
-      Snapshot nextSnapshot;
-
-      /** The snapshot to remove with {@link #remove}. Null if removal is illegal. */
-      Snapshot removeSnapshot;
-
-      @Override public boolean hasNext() {
-        if (nextSnapshot != null) return true;
-
-        synchronized (DiskLruCache.this) {
-          // If the cache is closed, truncate the iterator.
-          if (closed) return false;
-
-          while (delegate.hasNext()) {
-            Entry entry = delegate.next();
-            Snapshot snapshot = entry.snapshot();
-            if (snapshot == null) continue; // Evicted since we copied the entries.
-            nextSnapshot = snapshot;
-            return true;
-          }
-        }
-
-        return false;
-      }
-
-      @Override public Snapshot next() {
-        if (!hasNext()) throw new NoSuchElementException();
-        removeSnapshot = nextSnapshot;
-        nextSnapshot = null;
-        return removeSnapshot;
-      }
-
-      @Override public void remove() {
-        if (removeSnapshot == null) throw new IllegalStateException("remove() before next()");
-        try {
-          DiskLruCache.this.remove(removeSnapshot.key);
-        } catch (IOException ignored) {
-          // Nothing useful to do here. We failed to remove from the cache. Most likely that's
-          // because we couldn't update the journal, but the cached entry will still be gone.
-        } finally {
-          removeSnapshot = null;
-        }
-      }
-    };
-  }
-
-  /** A snapshot of the values for an entry. */
-  public final class Snapshot implements Closeable {
-    private final String key;
-    private final long sequenceNumber;
-    private final Source[] sources;
-    private final long[] lengths;
-
-    Snapshot(String key, long sequenceNumber, Source[] sources, long[] lengths) {
-      this.key = key;
-      this.sequenceNumber = sequenceNumber;
-      this.sources = sources;
-      this.lengths = lengths;
-    }
-
-    public String key() {
-      return key;
-    }
-
-    /**
-     * Returns an editor for this snapshot's entry, or null if either the entry has changed since
-     * this snapshot was created or if another edit is in progress.
-     */
-    public @Nullable Editor edit() throws IOException {
-      return DiskLruCache.this.edit(key, sequenceNumber);
-    }
-
-    /** Returns the unbuffered stream with the value for {@code index}. */
-    public Source getSource(int index) {
-      return sources[index];
-    }
-
-    /** Returns the byte length of the value for {@code index}. */
-    public long getLength(int index) {
-      return lengths[index];
-    }
-
-    public void close() {
-      for (Source in : sources) {
-        Util.closeQuietly(in);
-      }
-    }
-  }
-
-  /** Edits the values for an entry. */
-  public final class Editor {
-    final Entry entry;
-    final boolean[] written;
-    private boolean done;
-
-    Editor(Entry entry) {
-      this.entry = entry;
-      this.written = (entry.readable) ? null : new boolean[valueCount];
-    }
-
-    /**
-     * Prevents this editor from completing normally. This is necessary either when the edit causes
-     * an I/O error, or if the target entry is evicted while this editor is active. In either case
-     * we delete the editor's created files and prevent new files from being created. Note that once
-     * an editor has been detached it is possible for another editor to edit the entry.
-     */
-    void detach() {
-      if (entry.currentEditor == this) {
-        for (int i = 0; i < valueCount; i++) {
-          try {
-            fileSystem.delete(entry.dirtyFiles[i]);
-          } catch (IOException e) {
-            // This file is potentially leaked. Not much we can do about that.
-          }
-        }
-        entry.currentEditor = null;
-      }
-    }
-
-    /**
-     * Returns an unbuffered input stream to read the last committed value, or null if no value has
-     * been committed.
-     */
-    public Source newSource(int index) {
-      synchronized (DiskLruCache.this) {
-        if (done) {
-          throw new IllegalStateException();
-        }
-        if (!entry.readable || entry.currentEditor != this) {
-          return null;
-        }
-        try {
-          return fileSystem.source(entry.cleanFiles[index]);
-        } catch (FileNotFoundException e) {
-          return null;
-        }
-      }
-    }
-
-    /**
-     * Returns a new unbuffered output stream to write the value at {@code index}. If the underlying
-     * output stream encounters errors when writing to the filesystem, this edit will be aborted
-     * when {@link #commit} is called. The returned output stream does not throw IOExceptions.
-     */
-    public Sink newSink(int index) {
-      synchronized (DiskLruCache.this) {
-        if (done) {
-          throw new IllegalStateException();
-        }
-        if (entry.currentEditor != this) {
-          return Okio.blackhole();
-        }
-        if (!entry.readable) {
-          written[index] = true;
-        }
-        File dirtyFile = entry.dirtyFiles[index];
-        Sink sink;
-        try {
-          sink = fileSystem.sink(dirtyFile);
-        } catch (FileNotFoundException e) {
-          return Okio.blackhole();
-        }
-        return new FaultHidingSink(sink) {
-          @Override protected void onException(IOException e) {
-            synchronized (DiskLruCache.this) {
-              detach();
-            }
-          }
-        };
-      }
-    }
-
-    /**
-     * Commits this edit so it is visible to readers.  This releases the edit lock so another edit
-     * may be started on the same key.
-     */
-    public void commit() throws IOException {
-      synchronized (DiskLruCache.this) {
-        if (done) {
-          throw new IllegalStateException();
-        }
-        if (entry.currentEditor == this) {
-          completeEdit(this, true);
-        }
-        done = true;
-      }
-    }
-
-    /**
-     * Aborts this edit. This releases the edit lock so another edit may be started on the same
-     * key.
-     */
-    public void abort() throws IOException {
-      synchronized (DiskLruCache.this) {
-        if (done) {
-          throw new IllegalStateException();
-        }
-        if (entry.currentEditor == this) {
-          completeEdit(this, false);
-        }
-        done = true;
-      }
-    }
-
-    public void abortUnlessCommitted() {
-      synchronized (DiskLruCache.this) {
-        if (!done && entry.currentEditor == this) {
-          try {
-            completeEdit(this, false);
-          } catch (IOException ignored) {
-          }
-        }
-      }
-    }
-  }
-
-  private final class Entry {
-    final String key;
-
-    /** Lengths of this entry's files. */
-    final long[] lengths;
-    final File[] cleanFiles;
-    final File[] dirtyFiles;
-
-    /** True if this entry has ever been published. */
-    boolean readable;
-
-    /** The ongoing edit or null if this entry is not being edited. */
-    Editor currentEditor;
-
-    /** The sequence number of the most recently committed edit to this entry. */
-    long sequenceNumber;
-
-    Entry(String key) {
-      this.key = key;
-
-      lengths = new long[valueCount];
-      cleanFiles = new File[valueCount];
-      dirtyFiles = new File[valueCount];
-
-      // The names are repetitive so re-use the same builder to avoid allocations.
-      StringBuilder fileBuilder = new StringBuilder(key).append('.');
-      int truncateTo = fileBuilder.length();
-      for (int i = 0; i < valueCount; i++) {
-        fileBuilder.append(i);
-        cleanFiles[i] = new File(directory, fileBuilder.toString());
-        fileBuilder.append(".tmp");
-        dirtyFiles[i] = new File(directory, fileBuilder.toString());
-        fileBuilder.setLength(truncateTo);
-      }
-    }
-
-    /** Set lengths using decimal numbers like "10123". */
-    void setLengths(String[] strings) throws IOException {
-      if (strings.length != valueCount) {
-        throw invalidLengths(strings);
-      }
-
-      try {
-        for (int i = 0; i < strings.length; i++) {
-          lengths[i] = Long.parseLong(strings[i]);
-        }
-      } catch (NumberFormatException e) {
-        throw invalidLengths(strings);
-      }
-    }
-
-    /** Append space-prefixed lengths to {@code writer}. */
-    void writeLengths(BufferedSink writer) throws IOException {
-      for (long length : lengths) {
-        writer.writeByte(' ').writeDecimalLong(length);
-      }
-    }
-
-    private IOException invalidLengths(String[] strings) throws IOException {
-      throw new IOException("unexpected journal line: " + Arrays.toString(strings));
-    }
-
-    /**
-     * Returns a snapshot of this entry. This opens all streams eagerly to guarantee that we see a
-     * single published snapshot. If we opened streams lazily then the streams could come from
-     * different edits.
-     */
-    Snapshot snapshot() {
-      if (!Thread.holdsLock(DiskLruCache.this)) throw new AssertionError();
-
-      Source[] sources = new Source[valueCount];
-      long[] lengths = this.lengths.clone(); // Defensive copy since these can be zeroed out.
-      try {
-        for (int i = 0; i < valueCount; i++) {
-          sources[i] = fileSystem.source(cleanFiles[i]);
-        }
-        return new Snapshot(key, sequenceNumber, sources, lengths);
-      } catch (FileNotFoundException e) {
-        // A file must have been deleted manually!
-        for (int i = 0; i < valueCount; i++) {
-          if (sources[i] != null) {
-            Util.closeQuietly(sources[i]);
-          } else {
-            break;
-          }
-        }
-        // Since the entry is no longer valid, remove it so the metadata is accurate (i.e. the cache
-        // size.)
-        try {
-          removeEntry(this);
-        } catch (IOException ignored) {
-        }
-        return null;
-      }
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/FaultHidingSink.java b/okhttp/src/main/java/okhttp3/internal/cache/FaultHidingSink.java
deleted file mode 100644
index 561a30507e..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/cache/FaultHidingSink.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.cache;
-
-import java.io.IOException;
-import okio.Buffer;
-import okio.ForwardingSink;
-import okio.Sink;
-
-/** A sink that never throws IOExceptions, even if the underlying sink does. */
-class FaultHidingSink extends ForwardingSink {
-  private boolean hasErrors;
-
-  FaultHidingSink(Sink delegate) {
-    super(delegate);
-  }
-
-  @Override public void write(Buffer source, long byteCount) throws IOException {
-    if (hasErrors) {
-      source.skip(byteCount);
-      return;
-    }
-    try {
-      super.write(source, byteCount);
-    } catch (IOException e) {
-      hasErrors = true;
-      onException(e);
-    }
-  }
-
-  @Override public void flush() throws IOException {
-    if (hasErrors) return;
-    try {
-      super.flush();
-    } catch (IOException e) {
-      hasErrors = true;
-      onException(e);
-    }
-  }
-
-  @Override public void close() throws IOException {
-    if (hasErrors) return;
-    try {
-      super.close();
-    } catch (IOException e) {
-      hasErrors = true;
-      onException(e);
-    }
-  }
-
-  protected void onException(IOException e) {
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/InternalCache.java b/okhttp/src/main/java/okhttp3/internal/cache/InternalCache.java
deleted file mode 100644
index abb953472d..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/cache/InternalCache.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.cache;
-
-import java.io.IOException;
-import javax.annotation.Nullable;
-import okhttp3.Request;
-import okhttp3.Response;
-
-/**
- * OkHttp's internal cache interface. Applications shouldn't implement this: instead use {@link
- * okhttp3.Cache}.
- */
-public interface InternalCache {
-  @Nullable Response get(Request request) throws IOException;
-
-  @Nullable CacheRequest put(Response response) throws IOException;
-
-  /**
-   * Remove any cache entries for the supplied {@code request}. This is invoked when the client
-   * invalidates the cache, such as when making POST requests.
-   */
-  void remove(Request request) throws IOException;
-
-  /**
-   * Handles a conditional request hit by updating the stored cache response with the headers from
-   * {@code network}. The cached response body is not updated. If the stored response has changed
-   * since {@code cached} was returned, this does nothing.
-   */
-  void update(Response cached, Response network);
-
-  /** Track an conditional GET that was satisfied by this cache. */
-  void trackConditionalCacheHit();
-
-  /** Track an HTTP response being satisfied with {@code cacheStrategy}. */
-  void trackResponse(CacheStrategy cacheStrategy);
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/cache2/FileOperator.java b/okhttp/src/main/java/okhttp3/internal/cache2/FileOperator.java
deleted file mode 100644
index b4ce63012f..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/cache2/FileOperator.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.cache2;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.nio.channels.FileChannel;
-import okio.Buffer;
-import okio.Okio;
-
-/**
- * Read and write a target file. Unlike Okio's built-in {@linkplain Okio#source(java.io.File) file
- * source} and {@linkplain Okio#sink(java.io.File) file sink} this class offers:
- *
- * <ul>
- *   <li><strong>Read/write:</strong> read and write using the same operator.
- *   <li><strong>Random access:</strong> access any position within the file.
- *   <li><strong>Shared channels:</strong> read and write a file channel that's shared between
- *       multiple operators. Note that although the underlying {@code FileChannel} may be shared,
- *       each {@code FileOperator} should not be.
- * </ul>
- */
-final class FileOperator {
-  private final FileChannel fileChannel;
-
-  FileOperator(FileChannel fileChannel) {
-    this.fileChannel = fileChannel;
-  }
-
-  /** Write {@code byteCount} bytes from {@code source} to the file at {@code pos}. */
-  public void write(long pos, Buffer source, long byteCount) throws IOException {
-    if (byteCount < 0 || byteCount > source.size()) throw new IndexOutOfBoundsException();
-
-    while (byteCount > 0L) {
-      long bytesWritten = fileChannel.transferFrom(source, pos, byteCount);
-      pos += bytesWritten;
-      byteCount -= bytesWritten;
-    }
-  }
-
-  /**
-   * Copy {@code byteCount} bytes from the file at {@code pos} into to {@code source}. It is the
-   * caller's responsibility to make sure there are sufficient bytes to read: if there aren't this
-   * method throws an {@link EOFException}.
-   */
-  public void read(long pos, Buffer sink, long byteCount) throws IOException {
-    if (byteCount < 0) throw new IndexOutOfBoundsException();
-
-    while (byteCount > 0L) {
-      long bytesRead = fileChannel.transferTo(pos, byteCount, sink);
-      pos += bytesRead;
-      byteCount -= bytesRead;
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/cache2/Relay.java b/okhttp/src/main/java/okhttp3/internal/cache2/Relay.java
deleted file mode 100644
index 5131e6cd16..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/cache2/Relay.java
+++ /dev/null
@@ -1,361 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.cache2;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.RandomAccessFile;
-import okio.Buffer;
-import okio.ByteString;
-import okio.Source;
-import okio.Timeout;
-
-import static okhttp3.internal.Util.closeQuietly;
-
-/**
- * Replicates a single upstream source into multiple downstream sources. Each downstream source
- * returns the same bytes as the upstream source. Downstream sources may read data either as it
- * is returned by upstream, or after the upstream source has been exhausted.
- *
- * <p>As bytes are returned from upstream they are written to a local file. Downstream sources read
- * from this file as necessary.
- *
- * <p>This class also keeps a small buffer of bytes recently read from upstream. This is intended to
- * save a small amount of file I/O and data copying.
- */
-// TODO(jwilson): what to do about timeouts? They could be different and unfortunately when any
-//     timeout is hit we like to tear down the whole stream.
-final class Relay {
-  private static final int SOURCE_UPSTREAM = 1;
-  private static final int SOURCE_FILE = 2;
-
-  static final ByteString PREFIX_CLEAN = ByteString.encodeUtf8("OkHttp cache v1\n");
-  static final ByteString PREFIX_DIRTY = ByteString.encodeUtf8("OkHttp DIRTY :(\n");
-  private static final long FILE_HEADER_SIZE = 32L;
-
-  /**
-   * Read/write persistence of the upstream source and its metadata. Its layout is as follows:
-   *
-   * <ul>
-   *   <li>16 bytes: either {@code OkHttp cache v1\n} if the persisted file is complete. This is
-   *       another sequence of bytes if the file is incomplete and should not be used.
-   *   <li>8 bytes: <i>n</i>: upstream data size
-   *   <li>8 bytes: <i>m</i>: metadata size
-   *   <li><i>n</i> bytes: upstream data
-   *   <li><i>m</i> bytes: metadata
-   * </ul>
-   *
-   * <p>This is closed and assigned to null when the last source is closed and no further sources
-   * are permitted.
-   */
-  RandomAccessFile file;
-
-  /** The thread that currently has access to upstream. Possibly null. Guarded by this. */
-  Thread upstreamReader;
-
-  /**
-   * Null once the file has a complete copy of the upstream bytes. Only the {@code upstreamReader}
-   * thread may access this source.
-   */
-  Source upstream;
-
-  /**
-   * A buffer for {@code upstreamReader} to use when pulling bytes from upstream. Only the {@code
-   * upstreamReader} thread may access this buffer.
-   */
-  final Buffer upstreamBuffer = new Buffer();
-
-  /** The number of bytes consumed from {@link #upstream}. Guarded by this. */
-  long upstreamPos;
-
-  /** True if there are no further bytes to read from {@code upstream}. Guarded by this. */
-  boolean complete;
-
-  /** User-supplied additional data persisted with the source data. */
-  private final ByteString metadata;
-
-  /**
-   * The most recently read bytes from {@link #upstream}. This is a suffix of {@link #file}. Guarded
-   * by this.
-   */
-  final Buffer buffer = new Buffer();
-
-  /** The maximum size of {@code buffer}. */
-  final long bufferMaxSize;
-
-  /**
-   * Reference count of the number of active sources reading this stream. When decremented to 0
-   * resources are released and all following calls to {@link #newSource} return null. Guarded by
-   * this.
-   */
-  int sourceCount;
-
-  private Relay(RandomAccessFile file, Source upstream, long upstreamPos, ByteString metadata,
-      long bufferMaxSize) {
-    this.file = file;
-    this.upstream = upstream;
-    this.complete = upstream == null;
-    this.upstreamPos = upstreamPos;
-    this.metadata = metadata;
-    this.bufferMaxSize = bufferMaxSize;
-  }
-
-  /**
-   * Creates a new relay that reads a live stream from {@code upstream}, using {@code file} to share
-   * that data with other sources.
-   *
-   * <p><strong>Warning:</strong> callers to this method must immediately call {@link #newSource} to
-   * create a source and close that when they're done. Otherwise a handle to {@code file} will be
-   * leaked.
-   */
-  public static Relay edit(
-      File file, Source upstream, ByteString metadata, long bufferMaxSize) throws IOException {
-    RandomAccessFile randomAccessFile = new RandomAccessFile(file, "rw");
-    Relay result = new Relay(randomAccessFile, upstream, 0L, metadata, bufferMaxSize);
-
-    // Write a dirty header. That way if we crash we won't attempt to recover this.
-    randomAccessFile.setLength(0L);
-    result.writeHeader(PREFIX_DIRTY, -1L, -1L);
-
-    return result;
-  }
-
-  /**
-   * Creates a relay that reads a recorded stream from {@code file}.
-   *
-   * <p><strong>Warning:</strong> callers to this method must immediately call {@link #newSource} to
-   * create a source and close that when they're done. Otherwise a handle to {@code file} will be
-   * leaked.
-   */
-  public static Relay read(File file) throws IOException {
-    RandomAccessFile randomAccessFile = new RandomAccessFile(file, "rw");
-    FileOperator fileOperator = new FileOperator(randomAccessFile.getChannel());
-
-    // Read the header.
-    Buffer header = new Buffer();
-    fileOperator.read(0, header, FILE_HEADER_SIZE);
-    ByteString prefix = header.readByteString(PREFIX_CLEAN.size());
-    if (!prefix.equals(PREFIX_CLEAN)) throw new IOException("unreadable cache file");
-    long upstreamSize = header.readLong();
-    long metadataSize = header.readLong();
-
-    // Read the metadata.
-    Buffer metadataBuffer = new Buffer();
-    fileOperator.read(FILE_HEADER_SIZE + upstreamSize, metadataBuffer, metadataSize);
-    ByteString metadata = metadataBuffer.readByteString();
-
-    // Return the result.
-    return new Relay(randomAccessFile, null, upstreamSize, metadata, 0L);
-  }
-
-  private void writeHeader(
-      ByteString prefix, long upstreamSize, long metadataSize) throws IOException {
-    Buffer header = new Buffer();
-    header.write(prefix);
-    header.writeLong(upstreamSize);
-    header.writeLong(metadataSize);
-    if (header.size() != FILE_HEADER_SIZE) throw new IllegalArgumentException();
-
-    FileOperator fileOperator = new FileOperator(file.getChannel());
-    fileOperator.write(0, header, FILE_HEADER_SIZE);
-  }
-
-  private void writeMetadata(long upstreamSize) throws IOException {
-    Buffer metadataBuffer = new Buffer();
-    metadataBuffer.write(metadata);
-
-    FileOperator fileOperator = new FileOperator(file.getChannel());
-    fileOperator.write(FILE_HEADER_SIZE + upstreamSize, metadataBuffer, metadata.size());
-  }
-
-  void commit(long upstreamSize) throws IOException {
-    // Write metadata to the end of the file.
-    writeMetadata(upstreamSize);
-    file.getChannel().force(false);
-
-    // Once everything else is in place we can swap the dirty header for a clean one.
-    writeHeader(PREFIX_CLEAN, upstreamSize, metadata.size());
-    file.getChannel().force(false);
-
-    // This file is complete.
-    synchronized (Relay.this) {
-      complete = true;
-    }
-
-    closeQuietly(upstream);
-    upstream = null;
-  }
-
-  boolean isClosed() {
-    return file == null;
-  }
-
-  public ByteString metadata() {
-    return metadata;
-  }
-
-  /**
-   * Returns a new source that returns the same bytes as upstream. Returns null if this relay has
-   * been closed and no further sources are possible. In that case callers should retry after
-   * building a new relay with {@link #read}.
-   */
-  public Source newSource() {
-    synchronized (Relay.this) {
-      if (file == null) return null;
-      sourceCount++;
-    }
-
-    return new RelaySource();
-  }
-
-  class RelaySource implements Source {
-    private final Timeout timeout = new Timeout();
-
-    /** The operator to read and write the shared file. Null if this source is closed. */
-    private FileOperator fileOperator = new FileOperator(file.getChannel());
-
-    /** The next byte to read. This is always less than or equal to {@code upstreamPos}. */
-    private long sourcePos;
-
-    /**
-     * Selects where to find the bytes for a read and read them. This is one of three sources.
-     *
-     * <h3>Upstream:</h3>
-     * In this case the current thread is assigned as the upstream reader. We read bytes from
-     * upstream and copy them to both the file and to the buffer. Finally we release the upstream
-     * reader lock and return the new bytes.
-     *
-     * <h3>The file</h3>
-     * In this case we copy bytes from the file to the {@code sink}.
-     *
-     * <h3>The buffer</h3>
-     * In this case the bytes are immediately copied into {@code sink} and the number of bytes
-     * copied is returned.
-     *
-     * <p>If upstream would be selected but another thread is already reading upstream this will
-     * block until that read completes. It is possible to time out while waiting for that.
-     */
-    @Override public long read(Buffer sink, long byteCount) throws IOException {
-      if (fileOperator == null) throw new IllegalStateException("closed");
-
-      long upstreamPos;
-      int source;
-
-      selectSource:
-      synchronized (Relay.this) {
-        // We need new data from upstream.
-        while (sourcePos == (upstreamPos = Relay.this.upstreamPos)) {
-          // No more data upstream. We're done.
-          if (complete) return -1L;
-
-          // Another thread is already reading. Wait for that.
-          if (upstreamReader != null) {
-            timeout.waitUntilNotified(Relay.this);
-            continue;
-          }
-
-          // We will do the read.
-          upstreamReader = Thread.currentThread();
-          source = SOURCE_UPSTREAM;
-          break selectSource;
-        }
-
-        long bufferPos = upstreamPos - buffer.size();
-
-        // Bytes of the read precede the buffer. Read from the file.
-        if (sourcePos < bufferPos) {
-          source = SOURCE_FILE;
-          break selectSource;
-        }
-
-        // The buffer has the data we need. Read from there and return immediately.
-        long bytesToRead = Math.min(byteCount, upstreamPos - sourcePos);
-        buffer.copyTo(sink, sourcePos - bufferPos, bytesToRead);
-        sourcePos += bytesToRead;
-        return bytesToRead;
-      }
-
-      // Read from the file.
-      if (source == SOURCE_FILE) {
-        long bytesToRead = Math.min(byteCount, upstreamPos - sourcePos);
-        fileOperator.read(FILE_HEADER_SIZE + sourcePos, sink, bytesToRead);
-        sourcePos += bytesToRead;
-        return bytesToRead;
-      }
-
-      // Read from upstream. This always reads a full buffer: that might be more than what the
-      // current call to Source.read() has requested.
-      try {
-        long upstreamBytesRead = upstream.read(upstreamBuffer, bufferMaxSize);
-
-        // If we've exhausted upstream, we're done.
-        if (upstreamBytesRead == -1L) {
-          commit(upstreamPos);
-          return -1L;
-        }
-
-        // Update this source and prepare this call's result.
-        long bytesRead = Math.min(upstreamBytesRead, byteCount);
-        upstreamBuffer.copyTo(sink, 0, bytesRead);
-        sourcePos += bytesRead;
-
-        // Append the upstream bytes to the file.
-        fileOperator.write(
-            FILE_HEADER_SIZE + upstreamPos, upstreamBuffer.clone(), upstreamBytesRead);
-
-        synchronized (Relay.this) {
-          // Append new upstream bytes into the buffer. Trim it to its max size.
-          buffer.write(upstreamBuffer, upstreamBytesRead);
-          if (buffer.size() > bufferMaxSize) {
-            buffer.skip(buffer.size() - bufferMaxSize);
-          }
-
-          // Now that the file and buffer have bytes, adjust upstreamPos.
-          Relay.this.upstreamPos += upstreamBytesRead;
-        }
-
-        return bytesRead;
-      } finally {
-        synchronized (Relay.this) {
-          upstreamReader = null;
-          Relay.this.notifyAll();
-        }
-      }
-    }
-
-    @Override public Timeout timeout() {
-      return timeout;
-    }
-
-    @Override public void close() throws IOException {
-      if (fileOperator == null) return; // Already closed.
-      fileOperator = null;
-
-      RandomAccessFile fileToClose = null;
-      synchronized (Relay.this) {
-        sourceCount--;
-        if (sourceCount == 0) {
-          fileToClose = file;
-          file = null;
-        }
-      }
-
-      if (fileToClose != null) {
-        closeQuietly(fileToClose);
-      }
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java b/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java
deleted file mode 100644
index 3e071d46f1..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package okhttp3.internal.connection;
-
-import java.io.IOException;
-import okhttp3.Interceptor;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.http.RealInterceptorChain;
-
-/** Opens a connection to the target server and proceeds to the next interceptor. */
-public final class ConnectInterceptor implements Interceptor {
-  public final OkHttpClient client;
-
-  public ConnectInterceptor(OkHttpClient client) {
-    this.client = client;
-  }
-
-  @Override public Response intercept(Chain chain) throws IOException {
-    RealInterceptorChain realChain = (RealInterceptorChain) chain;
-    Request request = realChain.request();
-    Transmitter transmitter = realChain.transmitter();
-
-    // We need the network to satisfy this request. Possibly for validating a conditional GET.
-    boolean doExtensiveHealthChecks = !request.method().equals("GET");
-    Exchange exchange = transmitter.newExchange(chain, doExtensiveHealthChecks);
-
-    return realChain.proceed(request, transmitter, exchange);
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/ConnectionSpecSelector.java b/okhttp/src/main/java/okhttp3/internal/connection/ConnectionSpecSelector.java
deleted file mode 100644
index fdc8599671..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/connection/ConnectionSpecSelector.java
+++ /dev/null
@@ -1,139 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.connection;
-
-import java.io.IOException;
-import java.io.InterruptedIOException;
-import java.net.ProtocolException;
-import java.net.UnknownServiceException;
-import java.security.cert.CertificateException;
-import java.util.Arrays;
-import java.util.List;
-import javax.net.ssl.SSLException;
-import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSocket;
-import okhttp3.ConnectionSpec;
-import okhttp3.internal.Internal;
-
-/**
- * Handles the connection spec fallback strategy: When a secure socket connection fails due to a
- * handshake / protocol problem the connection may be retried with different protocols. Instances
- * are stateful and should be created and used for a single connection attempt.
- */
-final class ConnectionSpecSelector {
-  private final List<ConnectionSpec> connectionSpecs;
-  private int nextModeIndex;
-  private boolean isFallbackPossible;
-  private boolean isFallback;
-
-  ConnectionSpecSelector(List<ConnectionSpec> connectionSpecs) {
-    this.nextModeIndex = 0;
-    this.connectionSpecs = connectionSpecs;
-  }
-
-  /**
-   * Configures the supplied {@link SSLSocket} to connect to the specified host using an appropriate
-   * {@link ConnectionSpec}. Returns the chosen {@link ConnectionSpec}, never {@code null}.
-   *
-   * @throws IOException if the socket does not support any of the TLS modes available
-   */
-  ConnectionSpec configureSecureSocket(SSLSocket sslSocket) throws IOException {
-    ConnectionSpec tlsConfiguration = null;
-    for (int i = nextModeIndex, size = connectionSpecs.size(); i < size; i++) {
-      ConnectionSpec connectionSpec = connectionSpecs.get(i);
-      if (connectionSpec.isCompatible(sslSocket)) {
-        tlsConfiguration = connectionSpec;
-        nextModeIndex = i + 1;
-        break;
-      }
-    }
-
-    if (tlsConfiguration == null) {
-      // This may be the first time a connection has been attempted and the socket does not support
-      // any the required protocols, or it may be a retry (but this socket supports fewer
-      // protocols than was suggested by a prior socket).
-      throw new UnknownServiceException(
-          "Unable to find acceptable protocols. isFallback=" + isFallback
-              + ", modes=" + connectionSpecs
-              + ", supported protocols=" + Arrays.toString(sslSocket.getEnabledProtocols()));
-    }
-
-    isFallbackPossible = isFallbackPossible(sslSocket);
-
-    Internal.instance.apply(tlsConfiguration, sslSocket, isFallback);
-
-    return tlsConfiguration;
-  }
-
-  /**
-   * Reports a failure to complete a connection. Determines the next {@link ConnectionSpec} to try,
-   * if any.
-   *
-   * @return {@code true} if the connection should be retried using {@link
-   * #configureSecureSocket(SSLSocket)} or {@code false} if not
-   */
-  boolean connectionFailed(IOException e) {
-    // Any future attempt to connect using this strategy will be a fallback attempt.
-    isFallback = true;
-
-    if (!isFallbackPossible) {
-      return false;
-    }
-
-    // If there was a protocol problem, don't recover.
-    if (e instanceof ProtocolException) {
-      return false;
-    }
-
-    // If there was an interruption or timeout (SocketTimeoutException), don't recover.
-    // For the socket connect timeout case we do not try the same host with a different
-    // ConnectionSpec: we assume it is unreachable.
-    if (e instanceof InterruptedIOException) {
-      return false;
-    }
-
-    // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
-    // again with a different connection spec.
-    if (e instanceof SSLHandshakeException) {
-      // If the problem was a CertificateException from the X509TrustManager, do not retry.
-      if (e.getCause() instanceof CertificateException) {
-        return false;
-      }
-    }
-    if (e instanceof SSLPeerUnverifiedException) {
-      // e.g. a certificate pinning error.
-      return false;
-    }
-
-    // Retry for all other SSL failures.
-    return e instanceof SSLException;
-  }
-
-  /**
-   * Returns {@code true} if any later {@link ConnectionSpec} in the fallback strategy looks
-   * possible based on the supplied {@link SSLSocket}. It assumes that a future socket will have the
-   * same capabilities as the supplied socket.
-   */
-  private boolean isFallbackPossible(SSLSocket socket) {
-    for (int i = nextModeIndex; i < connectionSpecs.size(); i++) {
-      if (connectionSpecs.get(i).isCompatible(socket)) {
-        return true;
-      }
-    }
-    return false;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/Exchange.java b/okhttp/src/main/java/okhttp3/internal/connection/Exchange.java
deleted file mode 100644
index a5c59fda4a..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/connection/Exchange.java
+++ /dev/null
@@ -1,326 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.connection;
-
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.net.SocketException;
-import javax.annotation.Nullable;
-import okhttp3.Call;
-import okhttp3.EventListener;
-import okhttp3.Headers;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.internal.Internal;
-import okhttp3.internal.http.ExchangeCodec;
-import okhttp3.internal.http.RealResponseBody;
-import okhttp3.internal.ws.RealWebSocket;
-import okio.Buffer;
-import okio.ForwardingSink;
-import okio.ForwardingSource;
-import okio.Okio;
-import okio.Sink;
-import okio.Source;
-
-/**
- * Transmits a single HTTP request and a response pair. This layers connection management and events
- * on {@link ExchangeCodec}, which handles the actual I/O.
- */
-public final class Exchange {
-  final Transmitter transmitter;
-  final Call call;
-  final EventListener eventListener;
-  final ExchangeFinder finder;
-  final ExchangeCodec codec;
-  private boolean duplex;
-
-  public Exchange(Transmitter transmitter, Call call, EventListener eventListener,
-      ExchangeFinder finder, ExchangeCodec codec) {
-    this.transmitter = transmitter;
-    this.call = call;
-    this.eventListener = eventListener;
-    this.finder = finder;
-    this.codec = codec;
-  }
-
-  public RealConnection connection() {
-    return codec.connection();
-  }
-
-  /** Returns true if the request body need not complete before the response body starts. */
-  public boolean isDuplex() {
-    return duplex;
-  }
-
-  public void writeRequestHeaders(Request request) throws IOException {
-    try {
-      eventListener.requestHeadersStart(call);
-      codec.writeRequestHeaders(request);
-      eventListener.requestHeadersEnd(call, request);
-    } catch (IOException e) {
-      eventListener.requestFailed(call, e);
-      trackFailure(e);
-      throw e;
-    }
-  }
-
-  public Sink createRequestBody(Request request, boolean duplex) throws IOException {
-    this.duplex = duplex;
-    long contentLength = request.body().contentLength();
-    eventListener.requestBodyStart(call);
-    Sink rawRequestBody = codec.createRequestBody(request, contentLength);
-    return new RequestBodySink(rawRequestBody, contentLength);
-  }
-
-  public void flushRequest() throws IOException {
-    try {
-      codec.flushRequest();
-    } catch (IOException e) {
-      eventListener.requestFailed(call, e);
-      trackFailure(e);
-      throw e;
-    }
-  }
-
-  public void finishRequest() throws IOException {
-    try {
-      codec.finishRequest();
-    } catch (IOException e) {
-      eventListener.requestFailed(call, e);
-      trackFailure(e);
-      throw e;
-    }
-  }
-
-  public void responseHeadersStart() {
-    eventListener.responseHeadersStart(call);
-  }
-
-  public @Nullable Response.Builder readResponseHeaders(boolean expectContinue) throws IOException {
-    try {
-      Response.Builder result = codec.readResponseHeaders(expectContinue);
-      if (result != null) {
-        Internal.instance.initExchange(result, this);
-      }
-      return result;
-    } catch (IOException e) {
-      eventListener.responseFailed(call, e);
-      trackFailure(e);
-      throw e;
-    }
-  }
-
-  public void responseHeadersEnd(Response response) {
-    eventListener.responseHeadersEnd(call, response);
-  }
-
-  public ResponseBody openResponseBody(Response response) throws IOException {
-    try {
-      eventListener.responseBodyStart(call);
-      String contentType = response.header("Content-Type");
-      long contentLength = codec.reportedContentLength(response);
-      Source rawSource = codec.openResponseBodySource(response);
-      ResponseBodySource source = new ResponseBodySource(rawSource, contentLength);
-      return new RealResponseBody(contentType, contentLength, Okio.buffer(source));
-    } catch (IOException e) {
-      eventListener.responseFailed(call, e);
-      trackFailure(e);
-      throw e;
-    }
-  }
-
-  public Headers trailers() throws IOException {
-    return codec.trailers();
-  }
-
-  public void timeoutEarlyExit() {
-    transmitter.timeoutEarlyExit();
-  }
-
-  public RealWebSocket.Streams newWebSocketStreams() throws SocketException {
-    transmitter.timeoutEarlyExit();
-    return codec.connection().newWebSocketStreams(this);
-  }
-
-  public void webSocketUpgradeFailed() {
-    bodyComplete(-1L, true, true, null);
-  }
-
-  public void noNewExchangesOnConnection() {
-    codec.connection().noNewExchanges();
-  }
-
-  public void cancel() {
-    codec.cancel();
-  }
-
-  /**
-   * Revoke this exchange's access to streams. This is necessary when a follow-up request is
-   * required but the preceding exchange hasn't completed yet.
-   */
-  public void detachWithViolence() {
-    codec.cancel();
-    transmitter.exchangeMessageDone(this, true, true, null);
-  }
-
-  void trackFailure(IOException e) {
-    finder.trackFailure();
-    codec.connection().trackFailure(e);
-  }
-
-  @Nullable IOException bodyComplete(
-      long bytesRead, boolean responseDone, boolean requestDone, @Nullable IOException e) {
-    if (e != null) {
-      trackFailure(e);
-    }
-    if (requestDone) {
-      if (e != null) {
-        eventListener.requestFailed(call, e);
-      } else {
-        eventListener.requestBodyEnd(call, bytesRead);
-      }
-    }
-    if (responseDone) {
-      if (e != null) {
-        eventListener.responseFailed(call, e);
-      } else {
-        eventListener.responseBodyEnd(call, bytesRead);
-      }
-    }
-    return transmitter.exchangeMessageDone(this, requestDone, responseDone, e);
-  }
-
-  public void noRequestBody() {
-    transmitter.exchangeMessageDone(this, true, false, null);
-  }
-
-  /** A request body that fires events when it completes. */
-  private final class RequestBodySink extends ForwardingSink {
-    private boolean completed;
-    /** The exact number of bytes to be written, or -1L if that is unknown. */
-    private long contentLength;
-    private long bytesReceived;
-    private boolean closed;
-
-    RequestBodySink(Sink delegate, long contentLength) {
-      super(delegate);
-      this.contentLength = contentLength;
-    }
-
-    @Override public void write(Buffer source, long byteCount) throws IOException {
-      if (closed) throw new IllegalStateException("closed");
-      if (contentLength != -1L && bytesReceived + byteCount > contentLength) {
-        throw new ProtocolException("expected " + contentLength
-            + " bytes but received " + (bytesReceived + byteCount));
-      }
-      try {
-        super.write(source, byteCount);
-        this.bytesReceived += byteCount;
-      } catch (IOException e) {
-        throw complete(e);
-      }
-    }
-
-    @Override public void flush() throws IOException {
-      try {
-        super.flush();
-      } catch (IOException e) {
-        throw complete(e);
-      }
-    }
-
-    @Override public void close() throws IOException {
-      if (closed) return;
-      closed = true;
-      if (contentLength != -1L && bytesReceived != contentLength) {
-        throw new ProtocolException("unexpected end of stream");
-      }
-      try {
-        super.close();
-        complete(null);
-      } catch (IOException e) {
-        throw complete(e);
-      }
-    }
-
-    private @Nullable IOException complete(@Nullable IOException e) {
-      if (completed) return e;
-      completed = true;
-      return bodyComplete(bytesReceived, false, true, e);
-    }
-  }
-
-  /** A response body that fires events when it completes. */
-  final class ResponseBodySource extends ForwardingSource {
-    private final long contentLength;
-    private long bytesReceived;
-    private boolean completed;
-    private boolean closed;
-
-    ResponseBodySource(Source delegate, long contentLength) {
-      super(delegate);
-      this.contentLength = contentLength;
-
-      if (contentLength == 0L) {
-        complete(null);
-      }
-    }
-
-    @Override public long read(Buffer sink, long byteCount) throws IOException {
-      if (closed) throw new IllegalStateException("closed");
-      try {
-        long read = delegate().read(sink, byteCount);
-        if (read == -1L) {
-          complete(null);
-          return -1L;
-        }
-
-        long newBytesReceived = bytesReceived + read;
-        if (contentLength != -1L && newBytesReceived > contentLength) {
-          throw new ProtocolException("expected " + contentLength
-              + " bytes but received " + newBytesReceived);
-        }
-
-        bytesReceived = newBytesReceived;
-        if (newBytesReceived == contentLength) {
-          complete(null);
-        }
-
-        return read;
-      } catch (IOException e) {
-        throw complete(e);
-      }
-    }
-
-    @Override public void close() throws IOException {
-      if (closed) return;
-      closed = true;
-      try {
-        super.close();
-        complete(null);
-      } catch (IOException e) {
-        throw complete(e);
-      }
-    }
-
-    @Nullable IOException complete(@Nullable IOException e) {
-      if (completed) return e;
-      completed = true;
-      return bodyComplete(bytesReceived, true, false, e);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/ExchangeFinder.java b/okhttp/src/main/java/okhttp3/internal/connection/ExchangeFinder.java
deleted file mode 100644
index f8eff2c4a0..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/connection/ExchangeFinder.java
+++ /dev/null
@@ -1,294 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.connection;
-
-import java.io.IOException;
-import java.net.Socket;
-import java.util.List;
-import okhttp3.Address;
-import okhttp3.Call;
-import okhttp3.EventListener;
-import okhttp3.Interceptor;
-import okhttp3.OkHttpClient;
-import okhttp3.Route;
-import okhttp3.internal.Util;
-import okhttp3.internal.http.ExchangeCodec;
-
-import static okhttp3.internal.Util.closeQuietly;
-
-/**
- * Attempts to find the connections for a sequence of exchanges. This uses the following strategies:
- *
- * <ol>
- *   <li>If the current call already has a connection that can satisfy the request it is used.
- *       Using the same connection for an initial exchange and its follow-ups may improve locality.
- *
- *   <li>If there is a connection in the pool that can satisfy the request it is used. Note that
- *       it is possible for shared exchanges to make requests to different host names! See {@link
- *       RealConnection#isEligible} for details.
- *
- *   <li>If there's no existing connection, make a list of routes (which may require blocking DNS
- *       lookups) and attempt a new connection them. When failures occur, retries iterate the list
- *       of available routes.
- * </ol>
- *
- * <p>If the pool gains an eligible connection while DNS, TCP, or TLS work is in flight, this finder
- * will prefer pooled connections. Only pooled HTTP/2 connections are used for such de-duplication.
- *
- * <p>It is possible to cancel the finding process.
- */
-final class ExchangeFinder {
-  private final Transmitter transmitter;
-  private final Address address;
-  private final RealConnectionPool connectionPool;
-  private final Call call;
-  private final EventListener eventListener;
-
-  private RouteSelector.Selection routeSelection;
-
-  // State guarded by connectionPool.
-  private final RouteSelector routeSelector;
-  private RealConnection connectingConnection;
-  private boolean hasStreamFailure;
-  private Route nextRouteToTry;
-
-  ExchangeFinder(Transmitter transmitter, RealConnectionPool connectionPool,
-      Address address, Call call, EventListener eventListener) {
-    this.transmitter = transmitter;
-    this.connectionPool = connectionPool;
-    this.address = address;
-    this.call = call;
-    this.eventListener = eventListener;
-    this.routeSelector = new RouteSelector(
-        address, connectionPool.routeDatabase, call, eventListener);
-  }
-
-  public ExchangeCodec find(
-      OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) {
-    int connectTimeout = chain.connectTimeoutMillis();
-    int readTimeout = chain.readTimeoutMillis();
-    int writeTimeout = chain.writeTimeoutMillis();
-    int pingIntervalMillis = client.pingIntervalMillis();
-    boolean connectionRetryEnabled = client.retryOnConnectionFailure();
-
-    try {
-      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,
-          writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);
-      return resultConnection.newCodec(client, chain);
-    } catch (RouteException e) {
-      trackFailure();
-      throw e;
-    } catch (IOException e) {
-      trackFailure();
-      throw new RouteException(e);
-    }
-  }
-
-  /**
-   * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated
-   * until a healthy connection is found.
-   */
-  private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,
-      int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled,
-      boolean doExtensiveHealthChecks) throws IOException {
-    while (true) {
-      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,
-          pingIntervalMillis, connectionRetryEnabled);
-
-      // If this is a brand new connection, we can skip the extensive health checks.
-      synchronized (connectionPool) {
-        if (candidate.successCount == 0) {
-          return candidate;
-        }
-      }
-
-      // Do a (potentially slow) check to confirm that the pooled connection is still good. If it
-      // isn't, take it out of the pool and start again.
-      if (!candidate.isHealthy(doExtensiveHealthChecks)) {
-        candidate.noNewExchanges();
-        continue;
-      }
-
-      return candidate;
-    }
-  }
-
-  /**
-   * Returns a connection to host a new stream. This prefers the existing connection if it exists,
-   * then the pool, finally building a new connection.
-   */
-  private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,
-      int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException {
-    boolean foundPooledConnection = false;
-    RealConnection result = null;
-    Route selectedRoute = null;
-    RealConnection releasedConnection;
-    Socket toClose;
-    synchronized (connectionPool) {
-      if (transmitter.isCanceled()) throw new IOException("Canceled");
-      hasStreamFailure = false; // This is a fresh attempt.
-
-      // Attempt to use an already-allocated connection. We need to be careful here because our
-      // already-allocated connection may have been restricted from creating new exchanges.
-      releasedConnection = transmitter.connection;
-      toClose = transmitter.connection != null && transmitter.connection.noNewExchanges
-          ? transmitter.releaseConnectionNoEvents()
-          : null;
-
-      if (transmitter.connection != null) {
-        // We had an already-allocated connection and it's good.
-        result = transmitter.connection;
-        releasedConnection = null;
-      }
-
-      if (result == null) {
-        // Attempt to get a connection from the pool.
-        if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, null, false)) {
-          foundPooledConnection = true;
-          result = transmitter.connection;
-        } else if (nextRouteToTry != null) {
-          selectedRoute = nextRouteToTry;
-          nextRouteToTry = null;
-        } else if (retryCurrentRoute()) {
-          selectedRoute = transmitter.connection.route();
-        }
-      }
-    }
-    closeQuietly(toClose);
-
-    if (releasedConnection != null) {
-      eventListener.connectionReleased(call, releasedConnection);
-    }
-    if (foundPooledConnection) {
-      eventListener.connectionAcquired(call, result);
-    }
-    if (result != null) {
-      // If we found an already-allocated or pooled connection, we're done.
-      return result;
-    }
-
-    // If we need a route selection, make one. This is a blocking operation.
-    boolean newRouteSelection = false;
-    if (selectedRoute == null && (routeSelection == null || !routeSelection.hasNext())) {
-      newRouteSelection = true;
-      routeSelection = routeSelector.next();
-    }
-
-    List<Route> routes = null;
-    synchronized (connectionPool) {
-      if (transmitter.isCanceled()) throw new IOException("Canceled");
-
-      if (newRouteSelection) {
-        // Now that we have a set of IP addresses, make another attempt at getting a connection from
-        // the pool. This could match due to connection coalescing.
-        routes = routeSelection.getAll();
-        if (connectionPool.transmitterAcquirePooledConnection(
-            address, transmitter, routes, false)) {
-          foundPooledConnection = true;
-          result = transmitter.connection;
-        }
-      }
-
-      if (!foundPooledConnection) {
-        if (selectedRoute == null) {
-          selectedRoute = routeSelection.next();
-        }
-
-        // Create a connection and assign it to this allocation immediately. This makes it possible
-        // for an asynchronous cancel() to interrupt the handshake we're about to do.
-        result = new RealConnection(connectionPool, selectedRoute);
-        connectingConnection = result;
-      }
-    }
-
-    // If we found a pooled connection on the 2nd time around, we're done.
-    if (foundPooledConnection) {
-      eventListener.connectionAcquired(call, result);
-      return result;
-    }
-
-    // Do TCP + TLS handshakes. This is a blocking operation.
-    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,
-        connectionRetryEnabled, call, eventListener);
-    connectionPool.routeDatabase.connected(result.route());
-
-    Socket socket = null;
-    synchronized (connectionPool) {
-      connectingConnection = null;
-      // Last attempt at connection coalescing, which only occurs if we attempted multiple
-      // concurrent connections to the same host.
-      if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, true)) {
-        // We lost the race! Close the connection we created and return the pooled connection.
-        result.noNewExchanges = true;
-        socket = result.socket();
-        result = transmitter.connection;
-      } else {
-        connectionPool.put(result);
-        transmitter.acquireConnectionNoEvents(result);
-      }
-    }
-    closeQuietly(socket);
-
-    eventListener.connectionAcquired(call, result);
-    return result;
-  }
-
-  RealConnection connectingConnection() {
-    assert (Thread.holdsLock(connectionPool));
-    return connectingConnection;
-  }
-
-  void trackFailure() {
-    assert (!Thread.holdsLock(connectionPool));
-    synchronized (connectionPool) {
-      hasStreamFailure = true; // Permit retries.
-    }
-  }
-
-  /** Returns true if there is a failure that retrying might fix. */
-  boolean hasStreamFailure() {
-    synchronized (connectionPool) {
-      return hasStreamFailure;
-    }
-  }
-
-  /** Returns true if a current route is still good or if there are routes we haven't tried yet. */
-  boolean hasRouteToTry() {
-    synchronized (connectionPool) {
-      if (nextRouteToTry != null) {
-        return true;
-      }
-      if (retryCurrentRoute()) {
-        // Lock in the route because retryCurrentRoute() is racy and we don't want to call it twice.
-        nextRouteToTry = transmitter.connection.route();
-        return true;
-      }
-      return (routeSelection != null && routeSelection.hasNext())
-          || routeSelector.hasNext();
-    }
-  }
-
-  /**
-   * Return true if the route used for the current connection should be retried, even if the
-   * connection itself is unhealthy. The biggest gotcha here is that we shouldn't reuse routes from
-   * coalesced connections.
-   */
-  private boolean retryCurrentRoute() {
-    return transmitter.connection != null
-        && transmitter.connection.routeFailureCount == 0
-        && Util.sameConnection(transmitter.connection.route().address().url(), address.url());
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
deleted file mode 100644
index 72bd8d6b12..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
+++ /dev/null
@@ -1,684 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package okhttp3.internal.connection;
-
-import java.io.IOException;
-import java.lang.ref.Reference;
-import java.net.ConnectException;
-import java.net.HttpURLConnection;
-import java.net.ProtocolException;
-import java.net.Proxy;
-import java.net.Socket;
-import java.net.SocketException;
-import java.net.SocketTimeoutException;
-import java.net.UnknownServiceException;
-import java.security.cert.Certificate;
-import java.security.cert.X509Certificate;
-import java.util.ArrayList;
-import java.util.List;
-import javax.annotation.Nullable;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSession;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-import okhttp3.Address;
-import okhttp3.Call;
-import okhttp3.CertificatePinner;
-import okhttp3.Connection;
-import okhttp3.ConnectionSpec;
-import okhttp3.EventListener;
-import okhttp3.Handshake;
-import okhttp3.HttpUrl;
-import okhttp3.Interceptor;
-import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.Route;
-import okhttp3.internal.Internal;
-import okhttp3.internal.Util;
-import okhttp3.internal.Version;
-import okhttp3.internal.http.ExchangeCodec;
-import okhttp3.internal.http1.Http1ExchangeCodec;
-import okhttp3.internal.http2.ConnectionShutdownException;
-import okhttp3.internal.http2.ErrorCode;
-import okhttp3.internal.http2.Http2Connection;
-import okhttp3.internal.http2.Http2ExchangeCodec;
-import okhttp3.internal.http2.Http2Stream;
-import okhttp3.internal.http2.StreamResetException;
-import okhttp3.internal.platform.Platform;
-import okhttp3.internal.tls.OkHostnameVerifier;
-import okhttp3.internal.ws.RealWebSocket;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.Okio;
-
-import static java.net.HttpURLConnection.HTTP_OK;
-import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
-import static java.util.concurrent.TimeUnit.MILLISECONDS;
-import static okhttp3.internal.Util.closeQuietly;
-
-public final class RealConnection extends Http2Connection.Listener implements Connection {
-  private static final String NPE_THROW_WITH_NULL = "throw with null exception";
-  private static final int MAX_TUNNEL_ATTEMPTS = 21;
-
-  public final RealConnectionPool connectionPool;
-  private final Route route;
-
-  // The fields below are initialized by connect() and never reassigned.
-
-  /** The low-level TCP socket. */
-  private Socket rawSocket;
-
-  /**
-   * The application layer socket. Either an {@link SSLSocket} layered over {@link #rawSocket}, or
-   * {@link #rawSocket} itself if this connection does not use SSL.
-   */
-  private Socket socket;
-  private Handshake handshake;
-  private Protocol protocol;
-  private Http2Connection http2Connection;
-  private BufferedSource source;
-  private BufferedSink sink;
-
-  // The fields below track connection state and are guarded by connectionPool.
-
-  /**
-   * If true, no new exchanges can be created on this connection. Once true this is always true.
-   * Guarded by {@link #connectionPool}.
-   */
-  boolean noNewExchanges;
-
-  /**
-   * The number of times there was a problem establishing a stream that could be due to route
-   * chosen. Guarded by {@link #connectionPool}.
-   */
-  int routeFailureCount;
-
-  int successCount;
-  private int refusedStreamCount;
-
-  /**
-   * The maximum number of concurrent streams that can be carried by this connection. If {@code
-   * allocations.size() < allocationLimit} then new streams can be created on this connection.
-   */
-  private int allocationLimit = 1;
-
-  /** Current calls carried by this connection. */
-  final List<Reference<Transmitter>> transmitters = new ArrayList<>();
-
-  /** Nanotime timestamp when {@code allocations.size()} reached zero. */
-  long idleAtNanos = Long.MAX_VALUE;
-
-  public RealConnection(RealConnectionPool connectionPool, Route route) {
-    this.connectionPool = connectionPool;
-    this.route = route;
-  }
-
-  /** Prevent further exchanges from being created on this connection. */
-  public void noNewExchanges() {
-    assert (!Thread.holdsLock(connectionPool));
-    synchronized (connectionPool) {
-      noNewExchanges = true;
-    }
-  }
-
-  static RealConnection testConnection(
-      RealConnectionPool connectionPool, Route route, Socket socket, long idleAtNanos) {
-    RealConnection result = new RealConnection(connectionPool, route);
-    result.socket = socket;
-    result.idleAtNanos = idleAtNanos;
-    return result;
-  }
-
-  public void connect(int connectTimeout, int readTimeout, int writeTimeout,
-      int pingIntervalMillis, boolean connectionRetryEnabled, Call call,
-      EventListener eventListener) {
-    if (protocol != null) throw new IllegalStateException("already connected");
-
-    RouteException routeException = null;
-    List<ConnectionSpec> connectionSpecs = route.address().connectionSpecs();
-    ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);
-
-    if (route.address().sslSocketFactory() == null) {
-      if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {
-        throw new RouteException(new UnknownServiceException(
-            "CLEARTEXT communication not enabled for client"));
-      }
-      String host = route.address().url().host();
-      if (!Platform.get().isCleartextTrafficPermitted(host)) {
-        throw new RouteException(new UnknownServiceException(
-            "CLEARTEXT communication to " + host + " not permitted by network security policy"));
-      }
-    } else {
-      if (route.address().protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)) {
-        throw new RouteException(new UnknownServiceException(
-            "H2_PRIOR_KNOWLEDGE cannot be used with HTTPS"));
-      }
-    }
-
-    while (true) {
-      try {
-        if (route.requiresTunnel()) {
-          connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);
-          if (rawSocket == null) {
-            // We were unable to connect the tunnel but properly closed down our resources.
-            break;
-          }
-        } else {
-          connectSocket(connectTimeout, readTimeout, call, eventListener);
-        }
-        establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener);
-        eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol);
-        break;
-      } catch (IOException e) {
-        closeQuietly(socket);
-        closeQuietly(rawSocket);
-        socket = null;
-        rawSocket = null;
-        source = null;
-        sink = null;
-        handshake = null;
-        protocol = null;
-        http2Connection = null;
-
-        eventListener.connectFailed(call, route.socketAddress(), route.proxy(), null, e);
-
-        if (routeException == null) {
-          routeException = new RouteException(e);
-        } else {
-          routeException.addConnectException(e);
-        }
-
-        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {
-          throw routeException;
-        }
-      }
-    }
-
-    if (route.requiresTunnel() && rawSocket == null) {
-      ProtocolException exception = new ProtocolException("Too many tunnel connections attempted: "
-          + MAX_TUNNEL_ATTEMPTS);
-      throw new RouteException(exception);
-    }
-
-    if (http2Connection != null) {
-      synchronized (connectionPool) {
-        allocationLimit = http2Connection.maxConcurrentStreams();
-      }
-    }
-  }
-
-  /**
-   * Does all the work to build an HTTPS connection over a proxy tunnel. The catch here is that a
-   * proxy server can issue an auth challenge and then close the connection.
-   */
-  private void connectTunnel(int connectTimeout, int readTimeout, int writeTimeout, Call call,
-      EventListener eventListener) throws IOException {
-    Request tunnelRequest = createTunnelRequest();
-    HttpUrl url = tunnelRequest.url();
-    for (int i = 0; i < MAX_TUNNEL_ATTEMPTS; i++) {
-      connectSocket(connectTimeout, readTimeout, call, eventListener);
-      tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url);
-
-      if (tunnelRequest == null) break; // Tunnel successfully created.
-
-      // The proxy decided to close the connection after an auth challenge. We need to create a new
-      // connection, but this time with the auth credentials.
-      closeQuietly(rawSocket);
-      rawSocket = null;
-      sink = null;
-      source = null;
-      eventListener.connectEnd(call, route.socketAddress(), route.proxy(), null);
-    }
-  }
-
-  /** Does all the work necessary to build a full HTTP or HTTPS connection on a raw socket. */
-  private void connectSocket(int connectTimeout, int readTimeout, Call call,
-      EventListener eventListener) throws IOException {
-    Proxy proxy = route.proxy();
-    Address address = route.address();
-
-    rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP
-        ? address.socketFactory().createSocket()
-        : new Socket(proxy);
-
-    eventListener.connectStart(call, route.socketAddress(), proxy);
-    rawSocket.setSoTimeout(readTimeout);
-    try {
-      Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);
-    } catch (ConnectException e) {
-      ConnectException ce = new ConnectException("Failed to connect to " + route.socketAddress());
-      ce.initCause(e);
-      throw ce;
-    }
-
-    // The following try/catch block is a pseudo hacky way to get around a crash on Android 7.0
-    // More details:
-    // https://github.com/square/okhttp/issues/3245
-    // https://android-review.googlesource.com/#/c/271775/
-    try {
-      source = Okio.buffer(Okio.source(rawSocket));
-      sink = Okio.buffer(Okio.sink(rawSocket));
-    } catch (NullPointerException npe) {
-      if (NPE_THROW_WITH_NULL.equals(npe.getMessage())) {
-        throw new IOException(npe);
-      }
-    }
-  }
-
-  private void establishProtocol(ConnectionSpecSelector connectionSpecSelector,
-      int pingIntervalMillis, Call call, EventListener eventListener) throws IOException {
-    if (route.address().sslSocketFactory() == null) {
-      if (route.address().protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)) {
-        socket = rawSocket;
-        protocol = Protocol.H2_PRIOR_KNOWLEDGE;
-        startHttp2(pingIntervalMillis);
-        return;
-      }
-
-      socket = rawSocket;
-      protocol = Protocol.HTTP_1_1;
-      return;
-    }
-
-    eventListener.secureConnectStart(call);
-    connectTls(connectionSpecSelector);
-    eventListener.secureConnectEnd(call, handshake);
-
-    if (protocol == Protocol.HTTP_2) {
-      startHttp2(pingIntervalMillis);
-    }
-  }
-
-  private void startHttp2(int pingIntervalMillis) throws IOException {
-    socket.setSoTimeout(0); // HTTP/2 connection timeouts are set per-stream.
-    http2Connection = new Http2Connection.Builder(true)
-        .socket(socket, route.address().url().host(), source, sink)
-        .listener(this)
-        .pingIntervalMillis(pingIntervalMillis)
-        .build();
-    http2Connection.start();
-  }
-
-  private void connectTls(ConnectionSpecSelector connectionSpecSelector) throws IOException {
-    Address address = route.address();
-    SSLSocketFactory sslSocketFactory = address.sslSocketFactory();
-    boolean success = false;
-    SSLSocket sslSocket = null;
-    try {
-      // Create the wrapper over the connected socket.
-      sslSocket = (SSLSocket) sslSocketFactory.createSocket(
-          rawSocket, address.url().host(), address.url().port(), true /* autoClose */);
-
-      // Configure the socket's ciphers, TLS versions, and extensions.
-      ConnectionSpec connectionSpec = connectionSpecSelector.configureSecureSocket(sslSocket);
-      if (connectionSpec.supportsTlsExtensions()) {
-        Platform.get().configureTlsExtensions(
-            sslSocket, address.url().host(), address.protocols());
-      }
-
-      // Force handshake. This can throw!
-      sslSocket.startHandshake();
-      // block for session establishment
-      SSLSession sslSocketSession = sslSocket.getSession();
-      Handshake unverifiedHandshake = Handshake.get(sslSocketSession);
-
-      // Verify that the socket's certificates are acceptable for the target host.
-      if (!address.hostnameVerifier().verify(address.url().host(), sslSocketSession)) {
-        List<Certificate> peerCertificates = unverifiedHandshake.peerCertificates();
-        if (!peerCertificates.isEmpty()) {
-          X509Certificate cert = (X509Certificate) peerCertificates.get(0);
-          throw new SSLPeerUnverifiedException(
-              "Hostname " + address.url().host() + " not verified:"
-                  + "\n    certificate: " + CertificatePinner.pin(cert)
-                  + "\n    DN: " + cert.getSubjectDN().getName()
-                  + "\n    subjectAltNames: " + OkHostnameVerifier.allSubjectAltNames(cert));
-        } else {
-          throw new SSLPeerUnverifiedException(
-              "Hostname " + address.url().host() + " not verified (no certificates)");
-        }
-      }
-
-      // Check that the certificate pinner is satisfied by the certificates presented.
-      address.certificatePinner().check(address.url().host(),
-          unverifiedHandshake.peerCertificates());
-
-      // Success! Save the handshake and the ALPN protocol.
-      String maybeProtocol = connectionSpec.supportsTlsExtensions()
-          ? Platform.get().getSelectedProtocol(sslSocket)
-          : null;
-      socket = sslSocket;
-      source = Okio.buffer(Okio.source(socket));
-      sink = Okio.buffer(Okio.sink(socket));
-      handshake = unverifiedHandshake;
-      protocol = maybeProtocol != null
-          ? Protocol.get(maybeProtocol)
-          : Protocol.HTTP_1_1;
-      success = true;
-    } catch (AssertionError e) {
-      if (Util.isAndroidGetsocknameError(e)) throw new IOException(e);
-      throw e;
-    } finally {
-      if (sslSocket != null) {
-        Platform.get().afterHandshake(sslSocket);
-      }
-      if (!success) {
-        closeQuietly(sslSocket);
-      }
-    }
-  }
-
-  /**
-   * To make an HTTPS connection over an HTTP proxy, send an unencrypted CONNECT request to create
-   * the proxy connection. This may need to be retried if the proxy requires authorization.
-   */
-  private Request createTunnel(int readTimeout, int writeTimeout, Request tunnelRequest,
-      HttpUrl url) throws IOException {
-    // Make an SSL Tunnel on the first message pair of each SSL + proxy connection.
-    String requestLine = "CONNECT " + Util.hostHeader(url, true) + " HTTP/1.1";
-    while (true) {
-      Http1ExchangeCodec tunnelCodec = new Http1ExchangeCodec(null, null, source, sink);
-      source.timeout().timeout(readTimeout, MILLISECONDS);
-      sink.timeout().timeout(writeTimeout, MILLISECONDS);
-      tunnelCodec.writeRequest(tunnelRequest.headers(), requestLine);
-      tunnelCodec.finishRequest();
-      Response response = tunnelCodec.readResponseHeaders(false)
-          .request(tunnelRequest)
-          .build();
-      tunnelCodec.skipConnectBody(response);
-
-      switch (response.code()) {
-        case HTTP_OK:
-          // Assume the server won't send a TLS ServerHello until we send a TLS ClientHello. If
-          // that happens, then we will have buffered bytes that are needed by the SSLSocket!
-          // This check is imperfect: it doesn't tell us whether a handshake will succeed, just
-          // that it will almost certainly fail because the proxy has sent unexpected data.
-          if (!source.getBuffer().exhausted() || !sink.buffer().exhausted()) {
-            throw new IOException("TLS tunnel buffered too many bytes!");
-          }
-          return null;
-
-        case HTTP_PROXY_AUTH:
-          tunnelRequest = route.address().proxyAuthenticator().authenticate(route, response);
-          if (tunnelRequest == null) throw new IOException("Failed to authenticate with proxy");
-
-          if ("close".equalsIgnoreCase(response.header("Connection"))) {
-            return tunnelRequest;
-          }
-          break;
-
-        default:
-          throw new IOException(
-              "Unexpected response code for CONNECT: " + response.code());
-      }
-    }
-  }
-
-  /**
-   * Returns a request that creates a TLS tunnel via an HTTP proxy. Everything in the tunnel request
-   * is sent unencrypted to the proxy server, so tunnels include only the minimum set of headers.
-   * This avoids sending potentially sensitive data like HTTP cookies to the proxy unencrypted.
-   *
-   * <p>In order to support preemptive authentication we pass a fake ‚ÄúAuth Failed‚Äù response to the
-   * authenticator. This gives the authenticator the option to customize the CONNECT request. It can
-   * decline to do so by returning null, in which case OkHttp will use it as-is
-   */
-  private Request createTunnelRequest() throws IOException {
-    Request proxyConnectRequest = new Request.Builder()
-        .url(route.address().url())
-        .method("CONNECT", null)
-        .header("Host", Util.hostHeader(route.address().url(), true))
-        .header("Proxy-Connection", "Keep-Alive") // For HTTP/1.0 proxies like Squid.
-        .header("User-Agent", Version.userAgent())
-        .build();
-
-    Response fakeAuthChallengeResponse = new Response.Builder()
-        .request(proxyConnectRequest)
-        .protocol(Protocol.HTTP_1_1)
-        .code(HttpURLConnection.HTTP_PROXY_AUTH)
-        .message("Preemptive Authenticate")
-        .body(Util.EMPTY_RESPONSE)
-        .sentRequestAtMillis(-1L)
-        .receivedResponseAtMillis(-1L)
-        .header("Proxy-Authenticate", "OkHttp-Preemptive")
-        .build();
-
-    Request authenticatedRequest = route.address().proxyAuthenticator()
-        .authenticate(route, fakeAuthChallengeResponse);
-
-    return authenticatedRequest != null
-        ? authenticatedRequest
-        : proxyConnectRequest;
-  }
-
-  /**
-   * Returns true if this connection can carry a stream allocation to {@code address}. If non-null
-   * {@code route} is the resolved route for a connection.
-   */
-  boolean isEligible(Address address, @Nullable List<Route> routes) {
-    // If this connection is not accepting new exchanges, we're done.
-    if (transmitters.size() >= allocationLimit || noNewExchanges) return false;
-
-    // If the non-host fields of the address don't overlap, we're done.
-    if (!Internal.instance.equalsNonHost(this.route.address(), address)) return false;
-
-    // If the host exactly matches, we're done: this connection can carry the address.
-    if (address.url().host().equals(this.route().address().url().host())) {
-      return true; // This connection is a perfect match.
-    }
-
-    // At this point we don't have a hostname match. But we still be able to carry the request if
-    // our connection coalescing requirements are met. See also:
-    // https://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding
-    // https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/
-
-    // 1. This connection must be HTTP/2.
-    if (http2Connection == null) return false;
-
-    // 2. The routes must share an IP address.
-    if (routes == null || !routeMatchesAny(routes)) return false;
-
-    // 3. This connection's server certificate's must cover the new host.
-    if (address.hostnameVerifier() != OkHostnameVerifier.INSTANCE) return false;
-    if (!supportsUrl(address.url())) return false;
-
-    // 4. Certificate pinning must match the host.
-    try {
-      address.certificatePinner().check(address.url().host(), handshake().peerCertificates());
-    } catch (SSLPeerUnverifiedException e) {
-      return false;
-    }
-
-    return true; // The caller's address can be carried by this connection.
-  }
-
-  /**
-   * Returns true if this connection's route has the same address as any of {@code routes}. This
-   * requires us to have a DNS address for both hosts, which only happens after route planning. We
-   * can't coalesce connections that use a proxy, since proxies don't tell us the origin server's IP
-   * address.
-   */
-  private boolean routeMatchesAny(List<Route> candidates) {
-    for (int i = 0, size = candidates.size(); i < size; i++) {
-      Route candidate = candidates.get(i);
-      if (candidate.proxy().type() == Proxy.Type.DIRECT
-          && route.proxy().type() == Proxy.Type.DIRECT
-          && route.socketAddress().equals(candidate.socketAddress())) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  public boolean supportsUrl(HttpUrl url) {
-    if (url.port() != route.address().url().port()) {
-      return false; // Port mismatch.
-    }
-
-    if (!url.host().equals(route.address().url().host())) {
-      // We have a host mismatch. But if the certificate matches, we're still good.
-      return handshake != null && OkHostnameVerifier.INSTANCE.verify(
-          url.host(), (X509Certificate) handshake.peerCertificates().get(0));
-    }
-
-    return true; // Success. The URL is supported.
-  }
-
-  ExchangeCodec newCodec(OkHttpClient client, Interceptor.Chain chain) throws SocketException {
-    if (http2Connection != null) {
-      return new Http2ExchangeCodec(client, this, chain, http2Connection);
-    } else {
-      socket.setSoTimeout(chain.readTimeoutMillis());
-      source.timeout().timeout(chain.readTimeoutMillis(), MILLISECONDS);
-      sink.timeout().timeout(chain.writeTimeoutMillis(), MILLISECONDS);
-      return new Http1ExchangeCodec(client, this, source, sink);
-    }
-  }
-
-  RealWebSocket.Streams newWebSocketStreams(Exchange exchange) throws SocketException {
-    socket.setSoTimeout(0);
-    noNewExchanges();
-    return new RealWebSocket.Streams(true, source, sink) {
-      @Override public void close() throws IOException {
-        exchange.bodyComplete(-1L, true, true, null);
-      }
-    };
-  }
-
-  @Override public Route route() {
-    return route;
-  }
-
-  public void cancel() {
-    // Close the raw socket so we don't end up doing synchronous I/O.
-    closeQuietly(rawSocket);
-  }
-
-  @Override public Socket socket() {
-    return socket;
-  }
-
-  /** Returns true if this connection is ready to host new streams. */
-  public boolean isHealthy(boolean doExtensiveChecks) {
-    if (socket.isClosed() || socket.isInputShutdown() || socket.isOutputShutdown()) {
-      return false;
-    }
-
-    if (http2Connection != null) {
-      return !http2Connection.isShutdown();
-    }
-
-    if (doExtensiveChecks) {
-      try {
-        int readTimeout = socket.getSoTimeout();
-        try {
-          socket.setSoTimeout(1);
-          if (source.exhausted()) {
-            return false; // Stream is exhausted; socket is closed.
-          }
-          return true;
-        } finally {
-          socket.setSoTimeout(readTimeout);
-        }
-      } catch (SocketTimeoutException ignored) {
-        // Read timed out; socket is good.
-      } catch (IOException e) {
-        return false; // Couldn't read; socket is closed.
-      }
-    }
-
-    return true;
-  }
-
-  /** Refuse incoming streams. */
-  @Override public void onStream(Http2Stream stream) throws IOException {
-    stream.close(ErrorCode.REFUSED_STREAM, null);
-  }
-
-  /** When settings are received, adjust the allocation limit. */
-  @Override public void onSettings(Http2Connection connection) {
-    synchronized (connectionPool) {
-      allocationLimit = connection.maxConcurrentStreams();
-    }
-  }
-
-  @Override public Handshake handshake() {
-    return handshake;
-  }
-
-  /**
-   * Returns true if this is an HTTP/2 connection. Such connections can be used in multiple HTTP
-   * requests simultaneously.
-   */
-  public boolean isMultiplexed() {
-    return http2Connection != null;
-  }
-
-  /**
-   * Track a failure using this connection. This may prevent both the connection and its route from
-   * being used for future exchanges.
-   */
-  void trackFailure(@Nullable IOException e) {
-    assert (!Thread.holdsLock(connectionPool));
-    synchronized (connectionPool) {
-      if (e instanceof StreamResetException) {
-        ErrorCode errorCode = ((StreamResetException) e).errorCode;
-        if (errorCode == ErrorCode.REFUSED_STREAM) {
-          // Retry REFUSED_STREAM errors once on the same connection.
-          refusedStreamCount++;
-          if (refusedStreamCount > 1) {
-            noNewExchanges = true;
-            routeFailureCount++;
-          }
-        } else if (errorCode != ErrorCode.CANCEL) {
-          // Keep the connection for CANCEL errors. Everything else wants a fresh connection.
-          noNewExchanges = true;
-          routeFailureCount++;
-        }
-      } else if (!isMultiplexed() || e instanceof ConnectionShutdownException) {
-        noNewExchanges = true;
-
-        // If this route hasn't completed a call, avoid it for new connections.
-        if (successCount == 0) {
-          if (e != null) {
-            connectionPool.connectFailed(route, e);
-          }
-          routeFailureCount++;
-        }
-      }
-    }
-  }
-
-  @Override public Protocol protocol() {
-    return protocol;
-  }
-
-  @Override public String toString() {
-    return "Connection{"
-        + route.address().url().host() + ":" + route.address().url().port()
-        + ", proxy="
-        + route.proxy()
-        + " hostAddress="
-        + route.socketAddress()
-        + " cipherSuite="
-        + (handshake != null ? handshake.cipherSuite() : "none")
-        + " protocol="
-        + protocol
-        + '}';
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RealConnectionPool.java b/okhttp/src/main/java/okhttp3/internal/connection/RealConnectionPool.java
deleted file mode 100644
index 366bc09f73..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/connection/RealConnectionPool.java
+++ /dev/null
@@ -1,262 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package okhttp3.internal.connection;
-
-import java.io.IOException;
-import java.lang.ref.Reference;
-import java.net.Proxy;
-import java.util.ArrayDeque;
-import java.util.ArrayList;
-import java.util.Deque;
-import java.util.Iterator;
-import java.util.List;
-import java.util.concurrent.Executor;
-import java.util.concurrent.SynchronousQueue;
-import java.util.concurrent.ThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;
-import javax.annotation.Nullable;
-import okhttp3.Address;
-import okhttp3.Route;
-import okhttp3.internal.Util;
-import okhttp3.internal.connection.Transmitter.TransmitterReference;
-import okhttp3.internal.platform.Platform;
-
-import static okhttp3.internal.Util.closeQuietly;
-
-public final class RealConnectionPool {
-  /**
-   * Background threads are used to cleanup expired connections. There will be at most a single
-   * thread running per connection pool. The thread pool executor permits the pool itself to be
-   * garbage collected.
-   */
-  private static final Executor executor = new ThreadPoolExecutor(0 /* corePoolSize */,
-      Integer.MAX_VALUE /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS,
-      new SynchronousQueue<>(), Util.threadFactory("OkHttp ConnectionPool", true));
-
-  /** The maximum number of idle connections for each address. */
-  private final int maxIdleConnections;
-  private final long keepAliveDurationNs;
-  private final Runnable cleanupRunnable = () -> {
-    while (true) {
-      long waitNanos = cleanup(System.nanoTime());
-      if (waitNanos == -1) return;
-      if (waitNanos > 0) {
-        long waitMillis = waitNanos / 1000000L;
-        waitNanos -= (waitMillis * 1000000L);
-        synchronized (RealConnectionPool.this) {
-          try {
-            RealConnectionPool.this.wait(waitMillis, (int) waitNanos);
-          } catch (InterruptedException ignored) {
-          }
-        }
-      }
-    }
-  };
-
-  private final Deque<RealConnection> connections = new ArrayDeque<>();
-  final RouteDatabase routeDatabase = new RouteDatabase();
-  boolean cleanupRunning;
-
-  public RealConnectionPool(int maxIdleConnections, long keepAliveDuration, TimeUnit timeUnit) {
-    this.maxIdleConnections = maxIdleConnections;
-    this.keepAliveDurationNs = timeUnit.toNanos(keepAliveDuration);
-
-    // Put a floor on the keep alive duration, otherwise cleanup will spin loop.
-    if (keepAliveDuration <= 0) {
-      throw new IllegalArgumentException("keepAliveDuration <= 0: " + keepAliveDuration);
-    }
-  }
-
-  public synchronized int idleConnectionCount() {
-    int total = 0;
-    for (RealConnection connection : connections) {
-      if (connection.transmitters.isEmpty()) total++;
-    }
-    return total;
-  }
-
-  public synchronized int connectionCount() {
-    return connections.size();
-  }
-
-  /**
-   * Attempts to acquire a recycled connection to {@code address} for {@code transmitter}. Returns
-   * true if a connection was acquired.
-   *
-   * <p>If {@code routes} is non-null these are the resolved routes (ie. IP addresses) for the
-   * connection. This is used to coalesce related domains to the same HTTP/2 connection, such as
-   * {@code square.com} and {@code square.ca}.
-   */
-  boolean transmitterAcquirePooledConnection(Address address, Transmitter transmitter,
-      @Nullable List<Route> routes, boolean requireMultiplexed) {
-    assert (Thread.holdsLock(this));
-    for (RealConnection connection : connections) {
-      if (requireMultiplexed && !connection.isMultiplexed()) continue;
-      if (!connection.isEligible(address, routes)) continue;
-      transmitter.acquireConnectionNoEvents(connection);
-      return true;
-    }
-    return false;
-  }
-
-  void put(RealConnection connection) {
-    assert (Thread.holdsLock(this));
-    if (!cleanupRunning) {
-      cleanupRunning = true;
-      executor.execute(cleanupRunnable);
-    }
-    connections.add(connection);
-  }
-
-  /**
-   * Notify this pool that {@code connection} has become idle. Returns true if the connection has
-   * been removed from the pool and should be closed.
-   */
-  boolean connectionBecameIdle(RealConnection connection) {
-    assert (Thread.holdsLock(this));
-    if (connection.noNewExchanges || maxIdleConnections == 0) {
-      connections.remove(connection);
-      return true;
-    } else {
-      notifyAll(); // Awake the cleanup thread: we may have exceeded the idle connection limit.
-      return false;
-    }
-  }
-
-  public void evictAll() {
-    List<RealConnection> evictedConnections = new ArrayList<>();
-    synchronized (this) {
-      for (Iterator<RealConnection> i = connections.iterator(); i.hasNext(); ) {
-        RealConnection connection = i.next();
-        if (connection.transmitters.isEmpty()) {
-          connection.noNewExchanges = true;
-          evictedConnections.add(connection);
-          i.remove();
-        }
-      }
-    }
-
-    for (RealConnection connection : evictedConnections) {
-      closeQuietly(connection.socket());
-    }
-  }
-
-  /**
-   * Performs maintenance on this pool, evicting the connection that has been idle the longest if
-   * either it has exceeded the keep alive limit or the idle connections limit.
-   *
-   * <p>Returns the duration in nanos to sleep until the next scheduled call to this method. Returns
-   * -1 if no further cleanups are required.
-   */
-  long cleanup(long now) {
-    int inUseConnectionCount = 0;
-    int idleConnectionCount = 0;
-    RealConnection longestIdleConnection = null;
-    long longestIdleDurationNs = Long.MIN_VALUE;
-
-    // Find either a connection to evict, or the time that the next eviction is due.
-    synchronized (this) {
-      for (Iterator<RealConnection> i = connections.iterator(); i.hasNext(); ) {
-        RealConnection connection = i.next();
-
-        // If the connection is in use, keep searching.
-        if (pruneAndGetAllocationCount(connection, now) > 0) {
-          inUseConnectionCount++;
-          continue;
-        }
-
-        idleConnectionCount++;
-
-        // If the connection is ready to be evicted, we're done.
-        long idleDurationNs = now - connection.idleAtNanos;
-        if (idleDurationNs > longestIdleDurationNs) {
-          longestIdleDurationNs = idleDurationNs;
-          longestIdleConnection = connection;
-        }
-      }
-
-      if (longestIdleDurationNs >= this.keepAliveDurationNs
-          || idleConnectionCount > this.maxIdleConnections) {
-        // We've found a connection to evict. Remove it from the list, then close it below (outside
-        // of the synchronized block).
-        connections.remove(longestIdleConnection);
-      } else if (idleConnectionCount > 0) {
-        // A connection will be ready to evict soon.
-        return keepAliveDurationNs - longestIdleDurationNs;
-      } else if (inUseConnectionCount > 0) {
-        // All connections are in use. It'll be at least the keep alive duration 'til we run again.
-        return keepAliveDurationNs;
-      } else {
-        // No connections, idle or in use.
-        cleanupRunning = false;
-        return -1;
-      }
-    }
-
-    closeQuietly(longestIdleConnection.socket());
-
-    // Cleanup again immediately.
-    return 0;
-  }
-
-  /**
-   * Prunes any leaked transmitters and then returns the number of remaining live transmitters on
-   * {@code connection}. Transmitters are leaked if the connection is tracking them but the
-   * application code has abandoned them. Leak detection is imprecise and relies on garbage
-   * collection.
-   */
-  private int pruneAndGetAllocationCount(RealConnection connection, long now) {
-    List<Reference<Transmitter>> references = connection.transmitters;
-    for (int i = 0; i < references.size(); ) {
-      Reference<Transmitter> reference = references.get(i);
-
-      if (reference.get() != null) {
-        i++;
-        continue;
-      }
-
-      // We've discovered a leaked transmitter. This is an application bug.
-      TransmitterReference transmitterRef = (TransmitterReference) reference;
-      String message = "A connection to " + connection.route().address().url()
-          + " was leaked. Did you forget to close a response body?";
-      Platform.get().logCloseableLeak(message, transmitterRef.callStackTrace);
-
-      references.remove(i);
-      connection.noNewExchanges = true;
-
-      // If this was the last allocation, the connection is eligible for immediate eviction.
-      if (references.isEmpty()) {
-        connection.idleAtNanos = now - keepAliveDurationNs;
-        return 0;
-      }
-    }
-
-    return references.size();
-  }
-
-  /** Track a bad route in the route database. Other routes will be attempted first. */
-  public void connectFailed(Route failedRoute, IOException failure) {
-    // Tell the proxy selector when we fail to connect on a fresh connection.
-    if (failedRoute.proxy().type() != Proxy.Type.DIRECT) {
-      Address address = failedRoute.address();
-      address.proxySelector().connectFailed(
-          address.url().uri(), failedRoute.proxy().address(), failure);
-    }
-
-    routeDatabase.failed(failedRoute);
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RouteDatabase.java b/okhttp/src/main/java/okhttp3/internal/connection/RouteDatabase.java
deleted file mode 100644
index 3ceb87de2c..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/connection/RouteDatabase.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.connection;
-
-import java.util.LinkedHashSet;
-import java.util.Set;
-import okhttp3.Route;
-
-/**
- * A blacklist of failed routes to avoid when creating a new connection to a target address. This is
- * used so that OkHttp can learn from its mistakes: if there was a failure attempting to connect to
- * a specific IP address or proxy server, that failure is remembered and alternate routes are
- * preferred.
- */
-final class RouteDatabase {
-  private final Set<Route> failedRoutes = new LinkedHashSet<>();
-
-  /** Records a failure connecting to {@code failedRoute}. */
-  public synchronized void failed(Route failedRoute) {
-    failedRoutes.add(failedRoute);
-  }
-
-  /** Records success connecting to {@code route}. */
-  public synchronized void connected(Route route) {
-    failedRoutes.remove(route);
-  }
-
-  /** Returns true if {@code route} has failed recently and should be avoided. */
-  public synchronized boolean shouldPostpone(Route route) {
-    return failedRoutes.contains(route);
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RouteException.java b/okhttp/src/main/java/okhttp3/internal/connection/RouteException.java
deleted file mode 100644
index f6206f7f06..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/connection/RouteException.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.connection;
-
-import java.io.IOException;
-
-import static okhttp3.internal.Util.addSuppressedIfPossible;
-
-/**
- * An exception thrown to indicate a problem connecting via a single Route. Multiple attempts may
- * have been made with alternative protocols, none of which were successful.
- */
-public final class RouteException extends RuntimeException {
-  private IOException firstException;
-  private IOException lastException;
-
-  RouteException(IOException cause) {
-    super(cause);
-    firstException = cause;
-    lastException = cause;
-  }
-
-  public IOException getFirstConnectException() {
-    return firstException;
-  }
-
-  public IOException getLastConnectException() {
-    return lastException;
-  }
-
-  void addConnectException(IOException e) {
-    addSuppressedIfPossible(firstException, e);
-    lastException = e;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.java b/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.java
deleted file mode 100644
index dde5cafc4d..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.java
+++ /dev/null
@@ -1,227 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.connection;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import java.net.SocketAddress;
-import java.net.SocketException;
-import java.net.UnknownHostException;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.NoSuchElementException;
-import okhttp3.Address;
-import okhttp3.Call;
-import okhttp3.EventListener;
-import okhttp3.HttpUrl;
-import okhttp3.Route;
-import okhttp3.internal.Util;
-
-/**
- * Selects routes to connect to an origin server. Each connection requires a choice of proxy server,
- * IP address, and TLS mode. Connections may also be recycled.
- */
-final class RouteSelector {
-  private final Address address;
-  private final RouteDatabase routeDatabase;
-  private final Call call;
-  private final EventListener eventListener;
-
-  /* State for negotiating the next proxy to use. */
-  private List<Proxy> proxies = Collections.emptyList();
-  private int nextProxyIndex;
-
-  /* State for negotiating the next socket address to use. */
-  private List<InetSocketAddress> inetSocketAddresses = Collections.emptyList();
-
-  /* State for negotiating failed routes */
-  private final List<Route> postponedRoutes = new ArrayList<>();
-
-  RouteSelector(Address address, RouteDatabase routeDatabase, Call call,
-      EventListener eventListener) {
-    this.address = address;
-    this.routeDatabase = routeDatabase;
-    this.call = call;
-    this.eventListener = eventListener;
-
-    resetNextProxy(address.url(), address.proxy());
-  }
-
-  /**
-   * Returns true if there's another set of routes to attempt. Every address has at least one route.
-   */
-  public boolean hasNext() {
-    return hasNextProxy() || !postponedRoutes.isEmpty();
-  }
-
-  public Selection next() throws IOException {
-    if (!hasNext()) {
-      throw new NoSuchElementException();
-    }
-
-    // Compute the next set of routes to attempt.
-    List<Route> routes = new ArrayList<>();
-    while (hasNextProxy()) {
-      // Postponed routes are always tried last. For example, if we have 2 proxies and all the
-      // routes for proxy1 should be postponed, we'll move to proxy2. Only after we've exhausted
-      // all the good routes will we attempt the postponed routes.
-      Proxy proxy = nextProxy();
-      for (int i = 0, size = inetSocketAddresses.size(); i < size; i++) {
-        Route route = new Route(address, proxy, inetSocketAddresses.get(i));
-        if (routeDatabase.shouldPostpone(route)) {
-          postponedRoutes.add(route);
-        } else {
-          routes.add(route);
-        }
-      }
-
-      if (!routes.isEmpty()) {
-        break;
-      }
-    }
-
-    if (routes.isEmpty()) {
-      // We've exhausted all Proxies so fallback to the postponed routes.
-      routes.addAll(postponedRoutes);
-      postponedRoutes.clear();
-    }
-
-    return new Selection(routes);
-  }
-
-  /** Prepares the proxy servers to try. */
-  private void resetNextProxy(HttpUrl url, Proxy proxy) {
-    if (proxy != null) {
-      // If the user specifies a proxy, try that and only that.
-      proxies = Collections.singletonList(proxy);
-    } else {
-      // Try each of the ProxySelector choices until one connection succeeds.
-      List<Proxy> proxiesOrNull = address.proxySelector().select(url.uri());
-      proxies = proxiesOrNull != null && !proxiesOrNull.isEmpty()
-          ? Util.immutableList(proxiesOrNull)
-          : Util.immutableList(Proxy.NO_PROXY);
-    }
-    nextProxyIndex = 0;
-  }
-
-  /** Returns true if there's another proxy to try. */
-  private boolean hasNextProxy() {
-    return nextProxyIndex < proxies.size();
-  }
-
-  /** Returns the next proxy to try. May be PROXY.NO_PROXY but never null. */
-  private Proxy nextProxy() throws IOException {
-    if (!hasNextProxy()) {
-      throw new SocketException("No route to " + address.url().host()
-          + "; exhausted proxy configurations: " + proxies);
-    }
-    Proxy result = proxies.get(nextProxyIndex++);
-    resetNextInetSocketAddress(result);
-    return result;
-  }
-
-  /** Prepares the socket addresses to attempt for the current proxy or host. */
-  private void resetNextInetSocketAddress(Proxy proxy) throws IOException {
-    // Clear the addresses. Necessary if getAllByName() below throws!
-    inetSocketAddresses = new ArrayList<>();
-
-    String socketHost;
-    int socketPort;
-    if (proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.SOCKS) {
-      socketHost = address.url().host();
-      socketPort = address.url().port();
-    } else {
-      SocketAddress proxyAddress = proxy.address();
-      if (!(proxyAddress instanceof InetSocketAddress)) {
-        throw new IllegalArgumentException(
-            "Proxy.address() is not an " + "InetSocketAddress: " + proxyAddress.getClass());
-      }
-      InetSocketAddress proxySocketAddress = (InetSocketAddress) proxyAddress;
-      socketHost = getHostString(proxySocketAddress);
-      socketPort = proxySocketAddress.getPort();
-    }
-
-    if (socketPort < 1 || socketPort > 65535) {
-      throw new SocketException("No route to " + socketHost + ":" + socketPort
-          + "; port is out of range");
-    }
-
-    if (proxy.type() == Proxy.Type.SOCKS) {
-      inetSocketAddresses.add(InetSocketAddress.createUnresolved(socketHost, socketPort));
-    } else {
-      eventListener.dnsStart(call, socketHost);
-
-      // Try each address for best behavior in mixed IPv4/IPv6 environments.
-      List<InetAddress> addresses = address.dns().lookup(socketHost);
-      if (addresses.isEmpty()) {
-        throw new UnknownHostException(address.dns() + " returned no addresses for " + socketHost);
-      }
-
-      eventListener.dnsEnd(call, socketHost, addresses);
-
-      for (int i = 0, size = addresses.size(); i < size; i++) {
-        InetAddress inetAddress = addresses.get(i);
-        inetSocketAddresses.add(new InetSocketAddress(inetAddress, socketPort));
-      }
-    }
-  }
-
-  /**
-   * Obtain a "host" from an {@link InetSocketAddress}. This returns a string containing either an
-   * actual host name or a numeric IP address.
-   */
-  // Visible for testing
-  static String getHostString(InetSocketAddress socketAddress) {
-    InetAddress address = socketAddress.getAddress();
-    if (address == null) {
-      // The InetSocketAddress was specified with a string (either a numeric IP or a host name). If
-      // it is a name, all IPs for that name should be tried. If it is an IP address, only that IP
-      // address should be tried.
-      return socketAddress.getHostName();
-    }
-    // The InetSocketAddress has a specific address: we should only try that address. Therefore we
-    // return the address and ignore any host name that may be available.
-    return address.getHostAddress();
-  }
-
-  /** A set of selected Routes. */
-  public static final class Selection {
-    private final List<Route> routes;
-    private int nextRouteIndex = 0;
-
-    Selection(List<Route> routes) {
-      this.routes = routes;
-    }
-
-    public boolean hasNext() {
-      return nextRouteIndex < routes.size();
-    }
-
-    public Route next() {
-      if (!hasNext()) {
-        throw new NoSuchElementException();
-      }
-      return routes.get(nextRouteIndex++);
-    }
-
-    public List<Route> getAll() {
-      return new ArrayList<>(routes);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/Transmitter.java b/okhttp/src/main/java/okhttp3/internal/connection/Transmitter.java
deleted file mode 100644
index 59439c78ef..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/connection/Transmitter.java
+++ /dev/null
@@ -1,366 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.connection;
-
-import java.io.IOException;
-import java.io.InterruptedIOException;
-import java.lang.ref.Reference;
-import java.lang.ref.WeakReference;
-import java.net.Socket;
-import javax.annotation.Nullable;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLSocketFactory;
-import okhttp3.Address;
-import okhttp3.Call;
-import okhttp3.CertificatePinner;
-import okhttp3.Connection;
-import okhttp3.EventListener;
-import okhttp3.HttpUrl;
-import okhttp3.Interceptor;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.internal.Internal;
-import okhttp3.internal.http.ExchangeCodec;
-import okhttp3.internal.platform.Platform;
-import okio.AsyncTimeout;
-import okio.Timeout;
-
-import static java.util.concurrent.TimeUnit.MILLISECONDS;
-import static okhttp3.internal.Util.closeQuietly;
-import static okhttp3.internal.Util.sameConnection;
-
-/**
- * Bridge between OkHttp's application and network layers. This class exposes high-level application
- * layer primitives: connections, requests, responses, and streams.
- *
- * <p>This class supports {@linkplain #cancel asynchronous canceling}. This is intended to have the
- * smallest blast radius possible. If an HTTP/2 stream is active, canceling will cancel that stream
- * but not the other streams sharing its connection. But if the TLS handshake is still in progress
- * then canceling may break the entire connection.
- */
-public final class Transmitter {
-  private final OkHttpClient client;
-  private final RealConnectionPool connectionPool;
-  private final Call call;
-  private final EventListener eventListener;
-  private final AsyncTimeout timeout = new AsyncTimeout() {
-    @Override protected void timedOut() {
-      cancel();
-    }
-  };
-
-  private @Nullable Object callStackTrace;
-
-  private Request request;
-  private ExchangeFinder exchangeFinder;
-
-  // Guarded by connectionPool.
-  public RealConnection connection;
-  private @Nullable Exchange exchange;
-  private boolean exchangeRequestDone;
-  private boolean exchangeResponseDone;
-  private boolean canceled;
-  private boolean timeoutEarlyExit;
-  private boolean noMoreExchanges;
-
-  public Transmitter(OkHttpClient client, Call call) {
-    this.client = client;
-    this.connectionPool = Internal.instance.realConnectionPool(client.connectionPool());
-    this.call = call;
-    this.eventListener = client.eventListenerFactory().create(call);
-    this.timeout.timeout(client.callTimeoutMillis(), MILLISECONDS);
-  }
-
-  public Timeout timeout() {
-    return timeout;
-  }
-
-  public void timeoutEnter() {
-    timeout.enter();
-  }
-
-  /**
-   * Stops applying the timeout before the call is entirely complete. This is used for WebSockets
-   * and duplex calls where the timeout only applies to the initial setup.
-   */
-  public void timeoutEarlyExit() {
-    if (timeoutEarlyExit) throw new IllegalStateException();
-    timeoutEarlyExit = true;
-    timeout.exit();
-  }
-
-  private @Nullable IOException timeoutExit(@Nullable IOException cause) {
-    if (timeoutEarlyExit) return cause;
-    if (!timeout.exit()) return cause;
-
-    InterruptedIOException e = new InterruptedIOException("timeout");
-    if (cause != null) e.initCause(cause);
-
-    return e;
-  }
-
-  public void callStart() {
-    this.callStackTrace = Platform.get().getStackTraceForCloseable("response.body().close()");
-    eventListener.callStart(call);
-  }
-
-  /**
-   * Prepare to create a stream to carry {@code request}. This prefers to use the existing
-   * connection if it exists.
-   */
-  public void prepareToConnect(Request request) {
-    if (this.request != null) {
-      if (sameConnection(this.request.url(), request.url()) && exchangeFinder.hasRouteToTry()) {
-        return; // Already ready.
-      }
-      if (exchange != null) throw new IllegalStateException();
-
-      if (exchangeFinder != null) {
-        maybeReleaseConnection(null, true);
-        exchangeFinder = null;
-      }
-    }
-
-    this.request = request;
-    this.exchangeFinder = new ExchangeFinder(this, connectionPool, createAddress(request.url()),
-        call, eventListener);
-  }
-
-  private Address createAddress(HttpUrl url) {
-    SSLSocketFactory sslSocketFactory = null;
-    HostnameVerifier hostnameVerifier = null;
-    CertificatePinner certificatePinner = null;
-    if (url.isHttps()) {
-      sslSocketFactory = client.sslSocketFactory();
-      hostnameVerifier = client.hostnameVerifier();
-      certificatePinner = client.certificatePinner();
-    }
-
-    return new Address(url.host(), url.port(), client.dns(), client.socketFactory(),
-        sslSocketFactory, hostnameVerifier, certificatePinner, client.proxyAuthenticator(),
-        client.proxy(), client.protocols(), client.connectionSpecs(), client.proxySelector());
-  }
-
-  /** Returns a new exchange to carry a new request and response. */
-  Exchange newExchange(Interceptor.Chain chain, boolean doExtensiveHealthChecks) {
-    synchronized (connectionPool) {
-      if (noMoreExchanges) {
-        throw new IllegalStateException("released");
-      }
-      if (exchange != null) {
-        throw new IllegalStateException("cannot make a new request because the previous response "
-            + "is still open: please call response.close()");
-      }
-    }
-
-    ExchangeCodec codec = exchangeFinder.find(client, chain, doExtensiveHealthChecks);
-    Exchange result = new Exchange(this, call, eventListener, exchangeFinder, codec);
-
-    synchronized (connectionPool) {
-      this.exchange = result;
-      this.exchangeRequestDone = false;
-      this.exchangeResponseDone = false;
-      return result;
-    }
-  }
-
-  void acquireConnectionNoEvents(RealConnection connection) {
-    assert (Thread.holdsLock(connectionPool));
-
-    if (this.connection != null) throw new IllegalStateException();
-    this.connection = connection;
-    connection.transmitters.add(new TransmitterReference(this, callStackTrace));
-  }
-
-  /**
-   * Remove the transmitter from the connection's list of allocations. Returns a socket that the
-   * caller should close.
-   */
-  @Nullable Socket releaseConnectionNoEvents() {
-    assert (Thread.holdsLock(connectionPool));
-
-    int index = -1;
-    for (int i = 0, size = this.connection.transmitters.size(); i < size; i++) {
-      Reference<Transmitter> reference = this.connection.transmitters.get(i);
-      if (reference.get() == this) {
-        index = i;
-        break;
-      }
-    }
-
-    if (index == -1) throw new IllegalStateException();
-
-    RealConnection released = this.connection;
-    released.transmitters.remove(index);
-    this.connection = null;
-
-    if (released.transmitters.isEmpty()) {
-      released.idleAtNanos = System.nanoTime();
-      if (connectionPool.connectionBecameIdle(released)) {
-        return released.socket();
-      }
-    }
-
-    return null;
-  }
-
-  public void exchangeDoneDueToException() {
-    synchronized (connectionPool) {
-      if (noMoreExchanges) throw new IllegalStateException();
-      exchange = null;
-    }
-  }
-
-  /**
-   * Releases resources held with the request or response of {@code exchange}. This should be called
-   * when the request completes normally or when it fails due to an exception, in which case {@code
-   * e} should be non-null.
-   *
-   * <p>If the exchange was canceled or timed out, this will wrap {@code e} in an exception that
-   * provides that additional context. Otherwise {@code e} is returned as-is.
-   */
-  @Nullable IOException exchangeMessageDone(
-      Exchange exchange, boolean requestDone, boolean responseDone, @Nullable IOException e) {
-    boolean exchangeDone = false;
-    synchronized (connectionPool) {
-      if (exchange != this.exchange) {
-        return e; // This exchange was detached violently!
-      }
-      boolean changed = false;
-      if (requestDone) {
-        if (!exchangeRequestDone) changed = true;
-        this.exchangeRequestDone = true;
-      }
-      if (responseDone) {
-        if (!exchangeResponseDone) changed = true;
-        this.exchangeResponseDone = true;
-      }
-      if (exchangeRequestDone && exchangeResponseDone && changed) {
-        exchangeDone = true;
-        this.exchange.connection().successCount++;
-        this.exchange = null;
-      }
-    }
-    if (exchangeDone) {
-      e = maybeReleaseConnection(e, false);
-    }
-    return e;
-  }
-
-  public @Nullable IOException noMoreExchanges(@Nullable IOException e) {
-    synchronized (connectionPool) {
-      noMoreExchanges = true;
-    }
-    return maybeReleaseConnection(e, false);
-  }
-
-  /**
-   * Release the connection if it is no longer needed. This is called after each exchange completes
-   * and after the call signals that no more exchanges are expected.
-   *
-   * <p>If the transmitter was canceled or timed out, this will wrap {@code e} in an exception that
-   * provides that additional context. Otherwise {@code e} is returned as-is.
-   *
-   * @param force true to release the connection even if more exchanges are expected for the call.
-   */
-  private @Nullable IOException maybeReleaseConnection(@Nullable IOException e, boolean force) {
-    Socket socket;
-    Connection releasedConnection;
-    boolean callEnd;
-    synchronized (connectionPool) {
-      if (force && exchange != null) {
-        throw new IllegalStateException("cannot release connection while it is in use");
-      }
-      releasedConnection = this.connection;
-      socket = this.connection != null && exchange == null && (force || noMoreExchanges)
-          ? releaseConnectionNoEvents()
-          : null;
-      if (this.connection != null) releasedConnection = null;
-      callEnd = noMoreExchanges && exchange == null;
-    }
-    closeQuietly(socket);
-
-    if (releasedConnection != null) {
-      eventListener.connectionReleased(call, releasedConnection);
-    }
-
-    if (callEnd) {
-      boolean callFailed = (e != null);
-      e = timeoutExit(e);
-      if (callFailed) {
-        eventListener.callFailed(call, e);
-      } else {
-        eventListener.callEnd(call);
-      }
-    }
-    return e;
-  }
-
-  public boolean canRetry() {
-    return exchangeFinder.hasStreamFailure() && exchangeFinder.hasRouteToTry();
-  }
-
-  public boolean hasExchange() {
-    synchronized (connectionPool) {
-      return exchange != null;
-    }
-  }
-
-  /**
-   * Immediately closes the socket connection if it's currently held. Use this to interrupt an
-   * in-flight request from any thread. It's the caller's responsibility to close the request body
-   * and response body streams; otherwise resources may be leaked.
-   *
-   * <p>This method is safe to be called concurrently, but provides limited guarantees. If a
-   * transport layer connection has been established (such as a HTTP/2 stream) that is terminated.
-   * Otherwise if a socket connection is being established, that is terminated.
-   */
-  public void cancel() {
-    Exchange exchangeToCancel;
-    RealConnection connectionToCancel;
-    synchronized (connectionPool) {
-      canceled = true;
-      exchangeToCancel = exchange;
-      connectionToCancel = exchangeFinder != null && exchangeFinder.connectingConnection() != null
-          ? exchangeFinder.connectingConnection()
-          : connection;
-    }
-    if (exchangeToCancel != null) {
-      exchangeToCancel.cancel();
-    } else if (connectionToCancel != null) {
-      connectionToCancel.cancel();
-    }
-  }
-
-  public boolean isCanceled() {
-    synchronized (connectionPool) {
-      return canceled;
-    }
-  }
-
-  static final class TransmitterReference extends WeakReference<Transmitter> {
-    /**
-     * Captures the stack trace at the time the Call is executed or enqueued. This is helpful for
-     * identifying the origin of connection leaks.
-     */
-    final Object callStackTrace;
-
-    TransmitterReference(Transmitter referent, Object callStackTrace) {
-      super(referent);
-      this.callStackTrace = callStackTrace;
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
deleted file mode 100644
index c10dc34cdc..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
+++ /dev/null
@@ -1,128 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package okhttp3.internal.http;
-
-import java.io.IOException;
-import java.util.List;
-import okhttp3.Cookie;
-import okhttp3.CookieJar;
-import okhttp3.Headers;
-import okhttp3.Interceptor;
-import okhttp3.MediaType;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.internal.Version;
-import okio.GzipSource;
-import okio.Okio;
-
-import static okhttp3.internal.Util.hostHeader;
-
-/**
- * Bridges from application code to network code. First it builds a network request from a user
- * request. Then it proceeds to call the network. Finally it builds a user response from the network
- * response.
- */
-public final class BridgeInterceptor implements Interceptor {
-  private final CookieJar cookieJar;
-
-  public BridgeInterceptor(CookieJar cookieJar) {
-    this.cookieJar = cookieJar;
-  }
-
-  @Override public Response intercept(Chain chain) throws IOException {
-    Request userRequest = chain.request();
-    Request.Builder requestBuilder = userRequest.newBuilder();
-
-    RequestBody body = userRequest.body();
-    if (body != null) {
-      MediaType contentType = body.contentType();
-      if (contentType != null) {
-        requestBuilder.header("Content-Type", contentType.toString());
-      }
-
-      long contentLength = body.contentLength();
-      if (contentLength != -1) {
-        requestBuilder.header("Content-Length", Long.toString(contentLength));
-        requestBuilder.removeHeader("Transfer-Encoding");
-      } else {
-        requestBuilder.header("Transfer-Encoding", "chunked");
-        requestBuilder.removeHeader("Content-Length");
-      }
-    }
-
-    if (userRequest.header("Host") == null) {
-      requestBuilder.header("Host", hostHeader(userRequest.url(), false));
-    }
-
-    if (userRequest.header("Connection") == null) {
-      requestBuilder.header("Connection", "Keep-Alive");
-    }
-
-    // If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing
-    // the transfer stream.
-    boolean transparentGzip = false;
-    if (userRequest.header("Accept-Encoding") == null && userRequest.header("Range") == null) {
-      transparentGzip = true;
-      requestBuilder.header("Accept-Encoding", "gzip");
-    }
-
-    List<Cookie> cookies = cookieJar.loadForRequest(userRequest.url());
-    if (!cookies.isEmpty()) {
-      requestBuilder.header("Cookie", cookieHeader(cookies));
-    }
-
-    if (userRequest.header("User-Agent") == null) {
-      requestBuilder.header("User-Agent", Version.userAgent());
-    }
-
-    Response networkResponse = chain.proceed(requestBuilder.build());
-
-    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());
-
-    Response.Builder responseBuilder = networkResponse.newBuilder()
-        .request(userRequest);
-
-    if (transparentGzip
-        && "gzip".equalsIgnoreCase(networkResponse.header("Content-Encoding"))
-        && HttpHeaders.hasBody(networkResponse)) {
-      GzipSource responseBody = new GzipSource(networkResponse.body().source());
-      Headers strippedHeaders = networkResponse.headers().newBuilder()
-          .removeAll("Content-Encoding")
-          .removeAll("Content-Length")
-          .build();
-      responseBuilder.headers(strippedHeaders);
-      String contentType = networkResponse.header("Content-Type");
-      responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody)));
-    }
-
-    return responseBuilder.build();
-  }
-
-  /** Returns a 'Cookie' HTTP request header with all cookies, like {@code a=b; c=d}. */
-  private String cookieHeader(List<Cookie> cookies) {
-    StringBuilder cookieHeader = new StringBuilder();
-    for (int i = 0, size = cookies.size(); i < size; i++) {
-      if (i > 0) {
-        cookieHeader.append("; ");
-      }
-      Cookie cookie = cookies.get(i);
-      cookieHeader.append(cookie.name()).append('=').append(cookie.value());
-    }
-    return cookieHeader.toString();
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
deleted file mode 100644
index c3d21611fb..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
+++ /dev/null
@@ -1,143 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http;
-
-import java.io.IOException;
-import java.net.ProtocolException;
-import okhttp3.Interceptor;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.Util;
-import okhttp3.internal.connection.Exchange;
-import okio.BufferedSink;
-import okio.Okio;
-
-/** This is the last interceptor in the chain. It makes a network call to the server. */
-public final class CallServerInterceptor implements Interceptor {
-  private final boolean forWebSocket;
-
-  public CallServerInterceptor(boolean forWebSocket) {
-    this.forWebSocket = forWebSocket;
-  }
-
-  @Override public Response intercept(Chain chain) throws IOException {
-    RealInterceptorChain realChain = (RealInterceptorChain) chain;
-    Exchange exchange = realChain.exchange();
-    Request request = realChain.request();
-
-    long sentRequestMillis = System.currentTimeMillis();
-
-    exchange.writeRequestHeaders(request);
-
-    boolean responseHeadersStarted = false;
-    Response.Builder responseBuilder = null;
-    if (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {
-      // If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100
-      // Continue" response before transmitting the request body. If we don't get that, return
-      // what we did get (such as a 4xx response) without ever transmitting the request body.
-      if ("100-continue".equalsIgnoreCase(request.header("Expect"))) {
-        exchange.flushRequest();
-        responseHeadersStarted = true;
-        exchange.responseHeadersStart();
-        responseBuilder = exchange.readResponseHeaders(true);
-      }
-
-      if (responseBuilder == null) {
-        if (request.body().isDuplex()) {
-          // Prepare a duplex body so that the application can send a request body later.
-          exchange.flushRequest();
-          BufferedSink bufferedRequestBody = Okio.buffer(
-              exchange.createRequestBody(request, true));
-          request.body().writeTo(bufferedRequestBody);
-        } else {
-          // Write the request body if the "Expect: 100-continue" expectation was met.
-          BufferedSink bufferedRequestBody = Okio.buffer(
-              exchange.createRequestBody(request, false));
-          request.body().writeTo(bufferedRequestBody);
-          bufferedRequestBody.close();
-        }
-      } else {
-        exchange.noRequestBody();
-        if (!exchange.connection().isMultiplexed()) {
-          // If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection
-          // from being reused. Otherwise we're still obligated to transmit the request body to
-          // leave the connection in a consistent state.
-          exchange.noNewExchangesOnConnection();
-        }
-      }
-    } else {
-      exchange.noRequestBody();
-    }
-
-    if (request.body() == null || !request.body().isDuplex()) {
-      exchange.finishRequest();
-    }
-
-    if (!responseHeadersStarted) {
-      exchange.responseHeadersStart();
-    }
-
-    if (responseBuilder == null) {
-      responseBuilder = exchange.readResponseHeaders(false);
-    }
-
-    Response response = responseBuilder
-        .request(request)
-        .handshake(exchange.connection().handshake())
-        .sentRequestAtMillis(sentRequestMillis)
-        .receivedResponseAtMillis(System.currentTimeMillis())
-        .build();
-
-    int code = response.code();
-    if (code == 100) {
-      // server sent a 100-continue even though we did not request one.
-      // try again to read the actual response
-      response = exchange.readResponseHeaders(false)
-          .request(request)
-          .handshake(exchange.connection().handshake())
-          .sentRequestAtMillis(sentRequestMillis)
-          .receivedResponseAtMillis(System.currentTimeMillis())
-          .build();
-
-      code = response.code();
-    }
-
-    exchange.responseHeadersEnd(response);
-
-    if (forWebSocket && code == 101) {
-      // Connection is upgrading, but we need to ensure interceptors see a non-null response body.
-      response = response.newBuilder()
-          .body(Util.EMPTY_RESPONSE)
-          .build();
-    } else {
-      response = response.newBuilder()
-          .body(exchange.openResponseBody(response))
-          .build();
-    }
-
-    if ("close".equalsIgnoreCase(response.request().header("Connection"))
-        || "close".equalsIgnoreCase(response.header("Connection"))) {
-      exchange.noNewExchangesOnConnection();
-    }
-
-    if ((code == 204 || code == 205) && response.body().contentLength() > 0) {
-      throw new ProtocolException(
-          "HTTP " + code + " had non-zero Content-Length: " + response.body().contentLength());
-    }
-
-    return response;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/ExchangeCodec.java b/okhttp/src/main/java/okhttp3/internal/http/ExchangeCodec.java
deleted file mode 100644
index 071fa2b4f6..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http/ExchangeCodec.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http;
-
-import java.io.IOException;
-import javax.annotation.Nullable;
-import okhttp3.Headers;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.connection.RealConnection;
-import okio.Sink;
-import okio.Source;
-
-/** Encodes HTTP requests and decodes HTTP responses. */
-public interface ExchangeCodec {
-  /**
-   * The timeout to use while discarding a stream of input data. Since this is used for connection
-   * reuse, this timeout should be significantly less than the time it takes to establish a new
-   * connection.
-   */
-  int DISCARD_STREAM_TIMEOUT_MILLIS = 100;
-
-  /** Returns the connection that carries this codec. */
-  RealConnection connection();
-
-  /** Returns an output stream where the request body can be streamed. */
-  Sink createRequestBody(Request request, long contentLength) throws IOException;
-
-  /** This should update the HTTP engine's sentRequestMillis field. */
-  void writeRequestHeaders(Request request) throws IOException;
-
-  /** Flush the request to the underlying socket. */
-  void flushRequest() throws IOException;
-
-  /** Flush the request to the underlying socket and signal no more bytes will be transmitted. */
-  void finishRequest() throws IOException;
-
-  /**
-   * Parses bytes of a response header from an HTTP transport.
-   *
-   * @param expectContinue true to return null if this is an intermediate response with a "100"
-   *     response code. Otherwise this method never returns null.
-   */
-  @Nullable Response.Builder readResponseHeaders(boolean expectContinue) throws IOException;
-
-  long reportedContentLength(Response response) throws IOException;
-
-  Source openResponseBodySource(Response response) throws IOException;
-
-  /** Returns the trailers after the HTTP response. May be empty. */
-  Headers trailers() throws IOException;
-
-  /**
-   * Cancel this stream. Resources held by this stream will be cleaned up, though not synchronously.
-   * That may happen later by the connection pool thread.
-   */
-  void cancel();
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpDate.java b/okhttp/src/main/java/okhttp3/internal/http/HttpDate.java
deleted file mode 100644
index 6df2cfd2ec..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpDate.java
+++ /dev/null
@@ -1,119 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http;
-
-import java.text.DateFormat;
-import java.text.ParsePosition;
-import java.text.SimpleDateFormat;
-import java.util.Date;
-import java.util.Locale;
-
-import static okhttp3.internal.Util.UTC;
-
-/**
- * Best-effort parser for HTTP dates.
- */
-public final class HttpDate {
-  /** The last four-digit year: "Fri, 31 Dec 9999 23:59:59 GMT". */
-  public static final long MAX_DATE = 253402300799999L;
-
-  /**
-   * Most websites serve cookies in the blessed format. Eagerly create the parser to ensure such
-   * cookies are on the fast path.
-   */
-  private static final ThreadLocal<DateFormat> STANDARD_DATE_FORMAT =
-      new ThreadLocal<DateFormat>() {
-        @Override protected DateFormat initialValue() {
-          // Date format specified by RFC 7231 section 7.1.1.1.
-          DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss 'GMT'", Locale.US);
-          rfc1123.setLenient(false);
-          rfc1123.setTimeZone(UTC);
-          return rfc1123;
-        }
-      };
-
-  /** If we fail to parse a date in a non-standard format, try each of these formats in sequence. */
-  private static final String[] BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS = new String[] {
-      // HTTP formats required by RFC2616 but with any timezone.
-      "EEE, dd MMM yyyy HH:mm:ss zzz", // RFC 822, updated by RFC 1123 with any TZ
-      "EEEE, dd-MMM-yy HH:mm:ss zzz", // RFC 850, obsoleted by RFC 1036 with any TZ.
-      "EEE MMM d HH:mm:ss yyyy", // ANSI C's asctime() format
-      // Alternative formats.
-      "EEE, dd-MMM-yyyy HH:mm:ss z",
-      "EEE, dd-MMM-yyyy HH-mm-ss z",
-      "EEE, dd MMM yy HH:mm:ss z",
-      "EEE dd-MMM-yyyy HH:mm:ss z",
-      "EEE dd MMM yyyy HH:mm:ss z",
-      "EEE dd-MMM-yyyy HH-mm-ss z",
-      "EEE dd-MMM-yy HH:mm:ss z",
-      "EEE dd MMM yy HH:mm:ss z",
-      "EEE,dd-MMM-yy HH:mm:ss z",
-      "EEE,dd-MMM-yyyy HH:mm:ss z",
-      "EEE, dd-MM-yyyy HH:mm:ss z",
-
-      /* RI bug 6641315 claims a cookie of this format was once served by www.yahoo.com */
-      "EEE MMM d yyyy HH:mm:ss z",
-  };
-
-  private static final DateFormat[] BROWSER_COMPATIBLE_DATE_FORMATS =
-      new DateFormat[BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS.length];
-
-  /** Returns the date for {@code value}. Returns null if the value couldn't be parsed. */
-  public static Date parse(String value) {
-    if (value.length() == 0) {
-      return null;
-    }
-
-    ParsePosition position = new ParsePosition(0);
-    Date result = STANDARD_DATE_FORMAT.get().parse(value, position);
-    if (position.getIndex() == value.length()) {
-      // STANDARD_DATE_FORMAT must match exactly; all text must be consumed, e.g. no ignored
-      // non-standard trailing "+01:00". Those cases are covered below.
-      return result;
-    }
-    synchronized (BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS) {
-      for (int i = 0, count = BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS.length; i < count; i++) {
-        DateFormat format = BROWSER_COMPATIBLE_DATE_FORMATS[i];
-        if (format == null) {
-          format = new SimpleDateFormat(BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS[i], Locale.US);
-          // Set the timezone to use when interpreting formats that don't have a timezone. GMT is
-          // specified by RFC 7231.
-          format.setTimeZone(UTC);
-          BROWSER_COMPATIBLE_DATE_FORMATS[i] = format;
-        }
-        position.setIndex(0);
-        result = format.parse(value, position);
-        if (position.getIndex() != 0) {
-          // Something was parsed. It's possible the entire string was not consumed but we ignore
-          // that. If any of the BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS ended in "'GMT'" we'd have
-          // to also check that position.getIndex() == value.length() otherwise parsing might have
-          // terminated early, ignoring things like "+01:00". Leaving this as != 0 means that any
-          // trailing junk is ignored.
-          return result;
-        }
-      }
-    }
-    return null;
-  }
-
-  /** Returns the string for {@code value}. */
-  public static String format(Date value) {
-    return STANDARD_DATE_FORMAT.get().format(value);
-  }
-
-  private HttpDate() {
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java b/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java
deleted file mode 100644
index 7712934efb..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java
+++ /dev/null
@@ -1,391 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http;
-
-import java.io.EOFException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Set;
-import java.util.TreeSet;
-import okhttp3.Challenge;
-import okhttp3.Cookie;
-import okhttp3.CookieJar;
-import okhttp3.Headers;
-import okhttp3.HttpUrl;
-import okhttp3.Request;
-import okhttp3.Response;
-import okio.Buffer;
-import okio.ByteString;
-
-import static java.net.HttpURLConnection.HTTP_NOT_MODIFIED;
-import static java.net.HttpURLConnection.HTTP_NO_CONTENT;
-import static okhttp3.internal.Util.EMPTY_HEADERS;
-import static okhttp3.internal.http.StatusLine.HTTP_CONTINUE;
-
-/** Headers and utilities for internal use by OkHttp. */
-public final class HttpHeaders {
-  private static final ByteString QUOTED_STRING_DELIMITERS = ByteString.encodeUtf8("\"\\");
-  private static final ByteString TOKEN_DELIMITERS = ByteString.encodeUtf8("\t ,=");
-
-  private HttpHeaders() {
-  }
-
-  public static long contentLength(Response response) {
-    return contentLength(response.headers());
-  }
-
-  public static long contentLength(Headers headers) {
-    return stringToLong(headers.get("Content-Length"));
-  }
-
-  private static long stringToLong(String s) {
-    if (s == null) return -1;
-    try {
-      return Long.parseLong(s);
-    } catch (NumberFormatException e) {
-      return -1;
-    }
-  }
-
-  /**
-   * Returns true if none of the Vary headers have changed between {@code cachedRequest} and {@code
-   * newRequest}.
-   */
-  public static boolean varyMatches(
-      Response cachedResponse, Headers cachedRequest, Request newRequest) {
-    for (String field : varyFields(cachedResponse)) {
-      if (!Objects.equals(cachedRequest.values(field), newRequest.headers(field))) return false;
-    }
-    return true;
-  }
-
-  /**
-   * Returns true if a Vary header contains an asterisk. Such responses cannot be cached.
-   */
-  public static boolean hasVaryAll(Response response) {
-    return hasVaryAll(response.headers());
-  }
-
-  /**
-   * Returns true if a Vary header contains an asterisk. Such responses cannot be cached.
-   */
-  public static boolean hasVaryAll(Headers responseHeaders) {
-    return varyFields(responseHeaders).contains("*");
-  }
-
-  private static Set<String> varyFields(Response response) {
-    return varyFields(response.headers());
-  }
-
-  /**
-   * Returns the names of the request headers that need to be checked for equality when caching.
-   */
-  public static Set<String> varyFields(Headers responseHeaders) {
-    Set<String> result = Collections.emptySet();
-    for (int i = 0, size = responseHeaders.size(); i < size; i++) {
-      if (!"Vary".equalsIgnoreCase(responseHeaders.name(i))) continue;
-
-      String value = responseHeaders.value(i);
-      if (result.isEmpty()) {
-        result = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
-      }
-      for (String varyField : value.split(",")) {
-        result.add(varyField.trim());
-      }
-    }
-    return result;
-  }
-
-  /**
-   * Returns the subset of the headers in {@code response}'s request that impact the content of
-   * response's body.
-   */
-  public static Headers varyHeaders(Response response) {
-    // Use the request headers sent over the network, since that's what the
-    // response varies on. Otherwise OkHttp-supplied headers like
-    // "Accept-Encoding: gzip" may be lost.
-    Headers requestHeaders = response.networkResponse().request().headers();
-    Headers responseHeaders = response.headers();
-    return varyHeaders(requestHeaders, responseHeaders);
-  }
-
-  /**
-   * Returns the subset of the headers in {@code requestHeaders} that impact the content of
-   * response's body.
-   */
-  public static Headers varyHeaders(Headers requestHeaders, Headers responseHeaders) {
-    Set<String> varyFields = varyFields(responseHeaders);
-    if (varyFields.isEmpty()) return EMPTY_HEADERS;
-
-    Headers.Builder result = new Headers.Builder();
-    for (int i = 0, size = requestHeaders.size(); i < size; i++) {
-      String fieldName = requestHeaders.name(i);
-      if (varyFields.contains(fieldName)) {
-        result.add(fieldName, requestHeaders.value(i));
-      }
-    }
-    return result.build();
-  }
-
-  /**
-   * Parse RFC 7235 challenges. This is awkward because we need to look ahead to know how to
-   * interpret a token.
-   *
-   * <p>For example, the first line has a parameter name/value pair and the second line has a single
-   * token68:
-   *
-   * <pre>   {@code
-   *
-   *   WWW-Authenticate: Digest foo=bar
-   *   WWW-Authenticate: Digest foo=
-   * }</pre>
-   *
-   * <p>Similarly, the first line has one challenge and the second line has two challenges:
-   *
-   * <pre>   {@code
-   *
-   *   WWW-Authenticate: Digest ,foo=bar
-   *   WWW-Authenticate: Digest ,foo
-   * }</pre>
-   */
-  public static List<Challenge> parseChallenges(Headers responseHeaders, String headerName) {
-    List<Challenge> result = new ArrayList<>();
-    for (int h = 0; h < responseHeaders.size(); h++) {
-      if (headerName.equalsIgnoreCase(responseHeaders.name(h))) {
-        Buffer header = new Buffer().writeUtf8(responseHeaders.value(h));
-        parseChallengeHeader(result, header);
-      }
-    }
-    return result;
-  }
-
-  private static void parseChallengeHeader(List<Challenge> result, Buffer header) {
-    String peek = null;
-
-    while (true) {
-      // Read a scheme name for this challenge if we don't have one already.
-      if (peek == null) {
-        skipWhitespaceAndCommas(header);
-        peek = readToken(header);
-        if (peek == null) return;
-      }
-
-      String schemeName = peek;
-
-      // Read a token68, a sequence of parameters, or nothing.
-      boolean commaPrefixed = skipWhitespaceAndCommas(header);
-      peek = readToken(header);
-      if (peek == null) {
-        if (!header.exhausted()) return; // Expected a token; got something else.
-        result.add(new Challenge(schemeName, Collections.emptyMap()));
-        return;
-      }
-
-      int eqCount = skipAll(header, (byte) '=');
-      boolean commaSuffixed = skipWhitespaceAndCommas(header);
-
-      // It's a token68 because there isn't a value after it.
-      if (!commaPrefixed && (commaSuffixed || header.exhausted())) {
-        result.add(new Challenge(schemeName, Collections.singletonMap(
-            null, peek + repeat('=', eqCount))));
-        peek = null;
-        continue;
-      }
-
-      // It's a series of parameter names and values.
-      Map<String, String> parameters = new LinkedHashMap<>();
-      eqCount += skipAll(header, (byte) '=');
-      while (true) {
-        if (peek == null) {
-          peek = readToken(header);
-          if (skipWhitespaceAndCommas(header)) break; // We peeked a scheme name followed by ','.
-          eqCount = skipAll(header, (byte) '=');
-        }
-        if (eqCount == 0) break; // We peeked a scheme name.
-        if (eqCount > 1) return; // Unexpected '=' characters.
-        if (skipWhitespaceAndCommas(header)) return; // Unexpected ','.
-
-        String parameterValue = !header.exhausted() && header.getByte(0) == '"'
-            ? readQuotedString(header)
-            : readToken(header);
-        if (parameterValue == null) return; // Expected a value.
-        String replaced = parameters.put(peek, parameterValue);
-        peek = null;
-        if (replaced != null) return; // Unexpected duplicate parameter.
-        if (!skipWhitespaceAndCommas(header) && !header.exhausted()) return; // Expected ',' or EOF.
-      }
-      result.add(new Challenge(schemeName, parameters));
-    }
-  }
-
-  /** Returns true if any commas were skipped. */
-  private static boolean skipWhitespaceAndCommas(Buffer buffer) {
-    boolean commaFound = false;
-    while (!buffer.exhausted()) {
-      byte b = buffer.getByte(0);
-      if (b == ',') {
-        buffer.readByte(); // Consume ','.
-        commaFound = true;
-      } else if (b == ' ' || b == '\t') {
-        buffer.readByte(); // Consume space or tab.
-      } else {
-        break;
-      }
-    }
-    return commaFound;
-  }
-
-  private static int skipAll(Buffer buffer, byte b) {
-    int count = 0;
-    while (!buffer.exhausted() && buffer.getByte(0) == b) {
-      count++;
-      buffer.readByte();
-    }
-    return count;
-  }
-
-  /**
-   * Reads a double-quoted string, unescaping quoted pairs like {@code \"} to the 2nd character in
-   * each sequence. Returns the unescaped string, or null if the buffer isn't prefixed with a
-   * double-quoted string.
-   */
-  private static String readQuotedString(Buffer buffer) {
-    if (buffer.readByte() != '\"') throw new IllegalArgumentException();
-    Buffer result = new Buffer();
-    while (true) {
-      long i = buffer.indexOfElement(QUOTED_STRING_DELIMITERS);
-      if (i == -1L) return null; // Unterminated quoted string.
-
-      if (buffer.getByte(i) == '"') {
-        result.write(buffer, i);
-        buffer.readByte(); // Consume '"'.
-        return result.readUtf8();
-      }
-
-      if (buffer.size() == i + 1L) return null; // Dangling escape.
-      result.write(buffer, i);
-      buffer.readByte(); // Consume '\'.
-      result.write(buffer, 1L); // The escaped character.
-    }
-  }
-
-  /**
-   * Consumes and returns a non-empty token, terminating at special characters in {@link
-   * #TOKEN_DELIMITERS}. Returns null if the buffer is empty or prefixed with a delimiter.
-   */
-  private static String readToken(Buffer buffer) {
-    try {
-      long tokenSize = buffer.indexOfElement(TOKEN_DELIMITERS);
-      if (tokenSize == -1L) tokenSize = buffer.size();
-
-      return tokenSize != 0L
-          ? buffer.readUtf8(tokenSize)
-          : null;
-    } catch (EOFException e) {
-      throw new AssertionError();
-    }
-  }
-
-  private static String repeat(char c, int count) {
-    char[] array = new char[count];
-    Arrays.fill(array, c);
-    return new String(array);
-  }
-
-  public static void receiveHeaders(CookieJar cookieJar, HttpUrl url, Headers headers) {
-    if (cookieJar == CookieJar.NO_COOKIES) return;
-
-    List<Cookie> cookies = Cookie.parseAll(url, headers);
-    if (cookies.isEmpty()) return;
-
-    cookieJar.saveFromResponse(url, cookies);
-  }
-
-  /** Returns true if the response must have a (possibly 0-length) body. See RFC 7231. */
-  public static boolean hasBody(Response response) {
-    // HEAD requests never yield a body regardless of the response headers.
-    if (response.request().method().equals("HEAD")) {
-      return false;
-    }
-
-    int responseCode = response.code();
-    if ((responseCode < HTTP_CONTINUE || responseCode >= 200)
-        && responseCode != HTTP_NO_CONTENT
-        && responseCode != HTTP_NOT_MODIFIED) {
-      return true;
-    }
-
-    // If the Content-Length or Transfer-Encoding headers disagree with the response code, the
-    // response is malformed. For best compatibility, we honor the headers.
-    if (contentLength(response) != -1
-        || "chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {
-      return true;
-    }
-
-    return false;
-  }
-
-  /**
-   * Returns the next index in {@code input} at or after {@code pos} that contains a character from
-   * {@code characters}. Returns the input length if none of the requested characters can be found.
-   */
-  public static int skipUntil(String input, int pos, String characters) {
-    for (; pos < input.length(); pos++) {
-      if (characters.indexOf(input.charAt(pos)) != -1) {
-        break;
-      }
-    }
-    return pos;
-  }
-
-  /**
-   * Returns the next non-whitespace character in {@code input} that is white space. Result is
-   * undefined if input contains newline characters.
-   */
-  public static int skipWhitespace(String input, int pos) {
-    for (; pos < input.length(); pos++) {
-      char c = input.charAt(pos);
-      if (c != ' ' && c != '\t') {
-        break;
-      }
-    }
-    return pos;
-  }
-
-  /**
-   * Returns {@code value} as a positive integer, or 0 if it is negative, or {@code defaultValue} if
-   * it cannot be parsed.
-   */
-  public static int parseSeconds(String value, int defaultValue) {
-    try {
-      long seconds = Long.parseLong(value);
-      if (seconds > Integer.MAX_VALUE) {
-        return Integer.MAX_VALUE;
-      } else if (seconds < 0) {
-        return 0;
-      } else {
-        return (int) seconds;
-      }
-    } catch (NumberFormatException e) {
-      return defaultValue;
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.java b/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.java
deleted file mode 100644
index da45901512..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http;
-
-public final class HttpMethod {
-  public static boolean invalidatesCache(String method) {
-    return method.equals("POST")
-        || method.equals("PATCH")
-        || method.equals("PUT")
-        || method.equals("DELETE")
-        || method.equals("MOVE");     // WebDAV
-  }
-
-  public static boolean requiresRequestBody(String method) {
-    return method.equals("POST")
-        || method.equals("PUT")
-        || method.equals("PATCH")
-        || method.equals("PROPPATCH") // WebDAV
-        || method.equals("REPORT");   // CalDAV/CardDAV (defined in WebDAV Versioning)
-  }
-
-  public static boolean permitsRequestBody(String method) {
-    return !(method.equals("GET") || method.equals("HEAD"));
-  }
-
-  public static boolean redirectsWithBody(String method) {
-    return method.equals("PROPFIND"); // (WebDAV) redirects should also maintain the request body
-  }
-
-  public static boolean redirectsToGet(String method) {
-    // All requests but PROPFIND should redirect to a GET request.
-    return !method.equals("PROPFIND");
-  }
-
-  private HttpMethod() {
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
deleted file mode 100644
index 431ce536bb..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
+++ /dev/null
@@ -1,162 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http;
-
-import java.io.IOException;
-import java.util.List;
-import java.util.concurrent.TimeUnit;
-import javax.annotation.Nullable;
-import okhttp3.Call;
-import okhttp3.Connection;
-import okhttp3.Interceptor;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.connection.Exchange;
-import okhttp3.internal.connection.Transmitter;
-
-import static okhttp3.internal.Util.checkDuration;
-
-/**
- * A concrete interceptor chain that carries the entire interceptor chain: all application
- * interceptors, the OkHttp core, all network interceptors, and finally the network caller.
- *
- * <p>If the chain is for an application interceptor then {@link #connection} must be null.
- * Otherwise it is for a network interceptor and {@link #connection} must be non-null.
- */
-public final class RealInterceptorChain implements Interceptor.Chain {
-  private final List<Interceptor> interceptors;
-  private final Transmitter transmitter;
-  private final @Nullable Exchange exchange;
-  private final int index;
-  private final Request request;
-  private final Call call;
-  private final int connectTimeout;
-  private final int readTimeout;
-  private final int writeTimeout;
-  private int calls;
-
-  public RealInterceptorChain(List<Interceptor> interceptors, Transmitter transmitter,
-      @Nullable Exchange exchange, int index, Request request, Call call,
-      int connectTimeout, int readTimeout, int writeTimeout) {
-    this.interceptors = interceptors;
-    this.transmitter = transmitter;
-    this.exchange = exchange;
-    this.index = index;
-    this.request = request;
-    this.call = call;
-    this.connectTimeout = connectTimeout;
-    this.readTimeout = readTimeout;
-    this.writeTimeout = writeTimeout;
-  }
-
-  @Override public @Nullable Connection connection() {
-    return exchange != null ? exchange.connection() : null;
-  }
-
-  @Override public int connectTimeoutMillis() {
-    return connectTimeout;
-  }
-
-  @Override public Interceptor.Chain withConnectTimeout(int timeout, TimeUnit unit) {
-    int millis = checkDuration("timeout", timeout, unit);
-    return new RealInterceptorChain(interceptors, transmitter, exchange, index, request, call,
-        millis, readTimeout, writeTimeout);
-  }
-
-  @Override public int readTimeoutMillis() {
-    return readTimeout;
-  }
-
-  @Override public Interceptor.Chain withReadTimeout(int timeout, TimeUnit unit) {
-    int millis = checkDuration("timeout", timeout, unit);
-    return new RealInterceptorChain(interceptors, transmitter, exchange, index, request, call,
-        connectTimeout, millis, writeTimeout);
-  }
-
-  @Override public int writeTimeoutMillis() {
-    return writeTimeout;
-  }
-
-  @Override public Interceptor.Chain withWriteTimeout(int timeout, TimeUnit unit) {
-    int millis = checkDuration("timeout", timeout, unit);
-    return new RealInterceptorChain(interceptors, transmitter, exchange, index, request, call,
-        connectTimeout, readTimeout, millis);
-  }
-
-  public Transmitter transmitter() {
-    return transmitter;
-  }
-
-  public Exchange exchange() {
-    if (exchange == null) throw new IllegalStateException();
-    return exchange;
-  }
-
-  @Override public Call call() {
-    return call;
-  }
-
-  @Override public Request request() {
-    return request;
-  }
-
-  @Override public Response proceed(Request request) throws IOException {
-    return proceed(request, transmitter, exchange);
-  }
-
-  public Response proceed(Request request, Transmitter transmitter, @Nullable Exchange exchange)
-      throws IOException {
-    if (index >= interceptors.size()) throw new AssertionError();
-
-    calls++;
-
-    // If we already have a stream, confirm that the incoming request will use it.
-    if (this.exchange != null && !this.exchange.connection().supportsUrl(request.url())) {
-      throw new IllegalStateException("network interceptor " + interceptors.get(index - 1)
-          + " must retain the same host and port");
-    }
-
-    // If we already have a stream, confirm that this is the only call to chain.proceed().
-    if (this.exchange != null && calls > 1) {
-      throw new IllegalStateException("network interceptor " + interceptors.get(index - 1)
-          + " must call proceed() exactly once");
-    }
-
-    // Call the next interceptor in the chain.
-    RealInterceptorChain next = new RealInterceptorChain(interceptors, transmitter, exchange,
-        index + 1, request, call, connectTimeout, readTimeout, writeTimeout);
-    Interceptor interceptor = interceptors.get(index);
-    Response response = interceptor.intercept(next);
-
-    // Confirm that the next interceptor made its required call to chain.proceed().
-    if (exchange != null && index + 1 < interceptors.size() && next.calls != 1) {
-      throw new IllegalStateException("network interceptor " + interceptor
-          + " must call proceed() exactly once");
-    }
-
-    // Confirm that the intercepted response isn't null.
-    if (response == null) {
-      throw new NullPointerException("interceptor " + interceptor + " returned null");
-    }
-
-    if (response.body() == null) {
-      throw new IllegalStateException(
-          "interceptor " + interceptor + " returned a response with no body");
-    }
-
-    return response;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RealResponseBody.java b/okhttp/src/main/java/okhttp3/internal/http/RealResponseBody.java
deleted file mode 100644
index 970d7ca949..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http/RealResponseBody.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http;
-
-import javax.annotation.Nullable;
-import okhttp3.MediaType;
-import okhttp3.ResponseBody;
-import okio.BufferedSource;
-
-public final class RealResponseBody extends ResponseBody {
-  /**
-   * Use a string to avoid parsing the content type until needed. This also defers problems caused
-   * by malformed content types.
-   */
-  private final @Nullable String contentTypeString;
-  private final long contentLength;
-  private final BufferedSource source;
-
-  public RealResponseBody(
-      @Nullable String contentTypeString, long contentLength, BufferedSource source) {
-    this.contentTypeString = contentTypeString;
-    this.contentLength = contentLength;
-    this.source = source;
-  }
-
-  @Override public MediaType contentType() {
-    return contentTypeString != null ? MediaType.parse(contentTypeString) : null;
-  }
-
-  @Override public long contentLength() {
-    return contentLength;
-  }
-
-  @Override public BufferedSource source() {
-    return source;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RequestLine.java b/okhttp/src/main/java/okhttp3/internal/http/RequestLine.java
deleted file mode 100644
index 3e09098097..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http/RequestLine.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http;
-
-import java.net.HttpURLConnection;
-import java.net.Proxy;
-import okhttp3.HttpUrl;
-import okhttp3.Request;
-
-public final class RequestLine {
-  private RequestLine() {
-  }
-
-  /**
-   * Returns the request status line, like "GET / HTTP/1.1". This is exposed to the application by
-   * {@link HttpURLConnection#getHeaderFields}, so it needs to be set even if the transport is
-   * HTTP/2.
-   */
-  public static String get(Request request, Proxy.Type proxyType) {
-    StringBuilder result = new StringBuilder();
-    result.append(request.method());
-    result.append(' ');
-
-    if (includeAuthorityInRequestLine(request, proxyType)) {
-      result.append(request.url());
-    } else {
-      result.append(requestPath(request.url()));
-    }
-
-    result.append(" HTTP/1.1");
-    return result.toString();
-  }
-
-  /**
-   * Returns true if the request line should contain the full URL with host and port (like "GET
-   * http://android.com/foo HTTP/1.1") or only the path (like "GET /foo HTTP/1.1").
-   */
-  private static boolean includeAuthorityInRequestLine(Request request, Proxy.Type proxyType) {
-    return !request.isHttps() && proxyType == Proxy.Type.HTTP;
-  }
-
-  /**
-   * Returns the path to request, like the '/' in 'GET / HTTP/1.1'. Never empty, even if the request
-   * URL is. Includes the query component if it exists.
-   */
-  public static String requestPath(HttpUrl url) {
-    String path = url.encodedPath();
-    String query = url.encodedQuery();
-    return query != null ? (path + '?' + query) : path;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
deleted file mode 100644
index 65da93ce23..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
+++ /dev/null
@@ -1,344 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http;
-
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InterruptedIOException;
-import java.net.ProtocolException;
-import java.net.Proxy;
-import java.net.SocketTimeoutException;
-import java.security.cert.CertificateException;
-import javax.annotation.Nullable;
-import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import okhttp3.HttpUrl;
-import okhttp3.Interceptor;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.Route;
-import okhttp3.internal.Internal;
-import okhttp3.internal.connection.Exchange;
-import okhttp3.internal.connection.RouteException;
-import okhttp3.internal.connection.Transmitter;
-import okhttp3.internal.http2.ConnectionShutdownException;
-
-import static java.net.HttpURLConnection.HTTP_CLIENT_TIMEOUT;
-import static java.net.HttpURLConnection.HTTP_MOVED_PERM;
-import static java.net.HttpURLConnection.HTTP_MOVED_TEMP;
-import static java.net.HttpURLConnection.HTTP_MULT_CHOICE;
-import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
-import static java.net.HttpURLConnection.HTTP_SEE_OTHER;
-import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
-import static java.net.HttpURLConnection.HTTP_UNAVAILABLE;
-import static okhttp3.internal.Util.closeQuietly;
-import static okhttp3.internal.Util.sameConnection;
-import static okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT;
-import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
-
-/**
- * This interceptor recovers from failures and follows redirects as necessary. It may throw an
- * {@link IOException} if the call was canceled.
- */
-public final class RetryAndFollowUpInterceptor implements Interceptor {
-  /**
-   * How many redirects and auth challenges should we attempt? Chrome follows 21 redirects; Firefox,
-   * curl, and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5.
-   */
-  private static final int MAX_FOLLOW_UPS = 20;
-
-  private final OkHttpClient client;
-
-  public RetryAndFollowUpInterceptor(OkHttpClient client) {
-    this.client = client;
-  }
-
-  @Override public Response intercept(Chain chain) throws IOException {
-    Request request = chain.request();
-    RealInterceptorChain realChain = (RealInterceptorChain) chain;
-    Transmitter transmitter = realChain.transmitter();
-
-    int followUpCount = 0;
-    Response priorResponse = null;
-    while (true) {
-      transmitter.prepareToConnect(request);
-
-      if (transmitter.isCanceled()) {
-        throw new IOException("Canceled");
-      }
-
-      Response response;
-      boolean success = false;
-      try {
-        response = realChain.proceed(request, transmitter, null);
-        success = true;
-      } catch (RouteException e) {
-        // The attempt to connect via a route failed. The request will not have been sent.
-        if (!recover(e.getLastConnectException(), transmitter, false, request)) {
-          throw e.getFirstConnectException();
-        }
-        continue;
-      } catch (IOException e) {
-        // An attempt to communicate with a server failed. The request may have been sent.
-        boolean requestSendStarted = !(e instanceof ConnectionShutdownException);
-        if (!recover(e, transmitter, requestSendStarted, request)) throw e;
-        continue;
-      } finally {
-        // The network call threw an exception. Release any resources.
-        if (!success) {
-          transmitter.exchangeDoneDueToException();
-        }
-      }
-
-      // Attach the prior response if it exists. Such responses never have a body.
-      if (priorResponse != null) {
-        response = response.newBuilder()
-            .priorResponse(priorResponse.newBuilder()
-                    .body(null)
-                    .build())
-            .build();
-      }
-
-      Exchange exchange = Internal.instance.exchange(response);
-      Route route = exchange != null ? exchange.connection().route() : null;
-      Request followUp = followUpRequest(response, route);
-
-      if (followUp == null) {
-        if (exchange != null && exchange.isDuplex()) {
-          transmitter.timeoutEarlyExit();
-        }
-        return response;
-      }
-
-      RequestBody followUpBody = followUp.body();
-      if (followUpBody != null && followUpBody.isOneShot()) {
-        return response;
-      }
-
-      closeQuietly(response.body());
-      if (transmitter.hasExchange()) {
-        exchange.detachWithViolence();
-      }
-
-      if (++followUpCount > MAX_FOLLOW_UPS) {
-        throw new ProtocolException("Too many follow-up requests: " + followUpCount);
-      }
-
-      request = followUp;
-      priorResponse = response;
-    }
-  }
-
-  /**
-   * Report and attempt to recover from a failure to communicate with a server. Returns true if
-   * {@code e} is recoverable, or false if the failure is permanent. Requests with a body can only
-   * be recovered if the body is buffered or if the failure occurred before the request has been
-   * sent.
-   */
-  private boolean recover(IOException e, Transmitter transmitter,
-      boolean requestSendStarted, Request userRequest) {
-    // The application layer has forbidden retries.
-    if (!client.retryOnConnectionFailure()) return false;
-
-    // We can't send the request body again.
-    if (requestSendStarted && requestIsOneShot(e, userRequest)) return false;
-
-    // This exception is fatal.
-    if (!isRecoverable(e, requestSendStarted)) return false;
-
-    // No more routes to attempt.
-    if (!transmitter.canRetry()) return false;
-
-    // For failure recovery, use the same route selector with a new connection.
-    return true;
-  }
-
-  private boolean requestIsOneShot(IOException e, Request userRequest) {
-    RequestBody requestBody = userRequest.body();
-    return (requestBody != null && requestBody.isOneShot())
-        || e instanceof FileNotFoundException;
-  }
-
-  private boolean isRecoverable(IOException e, boolean requestSendStarted) {
-    // If there was a protocol problem, don't recover.
-    if (e instanceof ProtocolException) {
-      return false;
-    }
-
-    // If there was an interruption don't recover, but if there was a timeout connecting to a route
-    // we should try the next route (if there is one).
-    if (e instanceof InterruptedIOException) {
-      return e instanceof SocketTimeoutException && !requestSendStarted;
-    }
-
-    // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
-    // again with a different route.
-    if (e instanceof SSLHandshakeException) {
-      // If the problem was a CertificateException from the X509TrustManager,
-      // do not retry.
-      if (e.getCause() instanceof CertificateException) {
-        return false;
-      }
-    }
-    if (e instanceof SSLPeerUnverifiedException) {
-      // e.g. a certificate pinning error.
-      return false;
-    }
-
-    // An example of one we might want to retry with a different route is a problem connecting to a
-    // proxy and would manifest as a standard IOException. Unless it is one we know we should not
-    // retry, we return true and try a new route.
-    return true;
-  }
-
-  /**
-   * Figures out the HTTP request to make in response to receiving {@code userResponse}. This will
-   * either add authentication headers, follow redirects or handle a client request timeout. If a
-   * follow-up is either unnecessary or not applicable, this returns null.
-   */
-  private Request followUpRequest(Response userResponse, @Nullable Route route) throws IOException {
-    if (userResponse == null) throw new IllegalStateException();
-    int responseCode = userResponse.code();
-
-    final String method = userResponse.request().method();
-    switch (responseCode) {
-      case HTTP_PROXY_AUTH:
-        Proxy selectedProxy = route != null
-            ? route.proxy()
-            : client.proxy();
-        if (selectedProxy.type() != Proxy.Type.HTTP) {
-          throw new ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy");
-        }
-        return client.proxyAuthenticator().authenticate(route, userResponse);
-
-      case HTTP_UNAUTHORIZED:
-        return client.authenticator().authenticate(route, userResponse);
-
-      case HTTP_PERM_REDIRECT:
-      case HTTP_TEMP_REDIRECT:
-        // "If the 307 or 308 status code is received in response to a request other than GET
-        // or HEAD, the user agent MUST NOT automatically redirect the request"
-        if (!method.equals("GET") && !method.equals("HEAD")) {
-          return null;
-        }
-        // fall-through
-      case HTTP_MULT_CHOICE:
-      case HTTP_MOVED_PERM:
-      case HTTP_MOVED_TEMP:
-      case HTTP_SEE_OTHER:
-        // Does the client allow redirects?
-        if (!client.followRedirects()) return null;
-
-        String location = userResponse.header("Location");
-        if (location == null) return null;
-        HttpUrl url = userResponse.request().url().resolve(location);
-
-        // Don't follow redirects to unsupported protocols.
-        if (url == null) return null;
-
-        // If configured, don't follow redirects between SSL and non-SSL.
-        boolean sameScheme = url.scheme().equals(userResponse.request().url().scheme());
-        if (!sameScheme && !client.followSslRedirects()) return null;
-
-        // Most redirects don't include a request body.
-        Request.Builder requestBuilder = userResponse.request().newBuilder();
-        if (HttpMethod.permitsRequestBody(method)) {
-          final boolean maintainBody = HttpMethod.redirectsWithBody(method);
-          if (HttpMethod.redirectsToGet(method)) {
-            requestBuilder.method("GET", null);
-          } else {
-            RequestBody requestBody = maintainBody ? userResponse.request().body() : null;
-            requestBuilder.method(method, requestBody);
-          }
-          if (!maintainBody) {
-            requestBuilder.removeHeader("Transfer-Encoding");
-            requestBuilder.removeHeader("Content-Length");
-            requestBuilder.removeHeader("Content-Type");
-          }
-        }
-
-        // When redirecting across hosts, drop all authentication headers. This
-        // is potentially annoying to the application layer since they have no
-        // way to retain them.
-        if (!sameConnection(userResponse.request().url(), url)) {
-          requestBuilder.removeHeader("Authorization");
-        }
-
-        return requestBuilder.url(url).build();
-
-      case HTTP_CLIENT_TIMEOUT:
-        // 408's are rare in practice, but some servers like HAProxy use this response code. The
-        // spec says that we may repeat the request without modifications. Modern browsers also
-        // repeat the request (even non-idempotent ones.)
-        if (!client.retryOnConnectionFailure()) {
-          // The application layer has directed us not to retry the request.
-          return null;
-        }
-
-        RequestBody requestBody = userResponse.request().body();
-        if (requestBody != null && requestBody.isOneShot()) {
-          return null;
-        }
-
-        if (userResponse.priorResponse() != null
-            && userResponse.priorResponse().code() == HTTP_CLIENT_TIMEOUT) {
-          // We attempted to retry and got another timeout. Give up.
-          return null;
-        }
-
-        if (retryAfter(userResponse, 0) > 0) {
-          return null;
-        }
-
-        return userResponse.request();
-
-      case HTTP_UNAVAILABLE:
-        if (userResponse.priorResponse() != null
-            && userResponse.priorResponse().code() == HTTP_UNAVAILABLE) {
-          // We attempted to retry and got another timeout. Give up.
-          return null;
-        }
-
-        if (retryAfter(userResponse, Integer.MAX_VALUE) == 0) {
-          // specifically received an instruction to retry without delay
-          return userResponse.request();
-        }
-
-        return null;
-
-      default:
-        return null;
-    }
-  }
-
-  private int retryAfter(Response userResponse, int defaultDelay) {
-    String header = userResponse.header("Retry-After");
-
-    if (header == null) {
-      return defaultDelay;
-    }
-
-    // https://tools.ietf.org/html/rfc7231#section-7.1.3
-    // currently ignores a HTTP-date, and assumes any non int 0 is a delay
-    if (header.matches("\\d+")) {
-      return Integer.valueOf(header);
-    }
-
-    return Integer.MAX_VALUE;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/StatusLine.java b/okhttp/src/main/java/okhttp3/internal/http/StatusLine.java
deleted file mode 100644
index f3591a6bf9..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http/StatusLine.java
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http;
-
-import java.io.IOException;
-import java.net.ProtocolException;
-import okhttp3.Protocol;
-import okhttp3.Response;
-
-/** An HTTP response status line like "HTTP/1.1 200 OK". */
-public final class StatusLine {
-  /** Numeric status code, 307: Temporary Redirect. */
-  public static final int HTTP_TEMP_REDIRECT = 307;
-  public static final int HTTP_PERM_REDIRECT = 308;
-  public static final int HTTP_CONTINUE = 100;
-
-  public final Protocol protocol;
-  public final int code;
-  public final String message;
-
-  public StatusLine(Protocol protocol, int code, String message) {
-    this.protocol = protocol;
-    this.code = code;
-    this.message = message;
-  }
-
-  public static StatusLine get(Response response) {
-    return new StatusLine(response.protocol(), response.code(), response.message());
-  }
-
-  public static StatusLine parse(String statusLine) throws IOException {
-    // H T T P / 1 . 1   2 0 0   T e m p o r a r y   R e d i r e c t
-    // 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0
-
-    // Parse protocol like "HTTP/1.1" followed by a space.
-    int codeStart;
-    Protocol protocol;
-    if (statusLine.startsWith("HTTP/1.")) {
-      if (statusLine.length() < 9 || statusLine.charAt(8) != ' ') {
-        throw new ProtocolException("Unexpected status line: " + statusLine);
-      }
-      int httpMinorVersion = statusLine.charAt(7) - '0';
-      codeStart = 9;
-      if (httpMinorVersion == 0) {
-        protocol = Protocol.HTTP_1_0;
-      } else if (httpMinorVersion == 1) {
-        protocol = Protocol.HTTP_1_1;
-      } else {
-        throw new ProtocolException("Unexpected status line: " + statusLine);
-      }
-    } else if (statusLine.startsWith("ICY ")) {
-      // Shoutcast uses ICY instead of "HTTP/1.0".
-      protocol = Protocol.HTTP_1_0;
-      codeStart = 4;
-    } else {
-      throw new ProtocolException("Unexpected status line: " + statusLine);
-    }
-
-    // Parse response code like "200". Always 3 digits.
-    if (statusLine.length() < codeStart + 3) {
-      throw new ProtocolException("Unexpected status line: " + statusLine);
-    }
-    int code;
-    try {
-      code = Integer.parseInt(statusLine.substring(codeStart, codeStart + 3));
-    } catch (NumberFormatException e) {
-      throw new ProtocolException("Unexpected status line: " + statusLine);
-    }
-
-    // Parse an optional response message like "OK" or "Not Modified". If it
-    // exists, it is separated from the response code by a space.
-    String message = "";
-    if (statusLine.length() > codeStart + 3) {
-      if (statusLine.charAt(codeStart + 3) != ' ') {
-        throw new ProtocolException("Unexpected status line: " + statusLine);
-      }
-      message = statusLine.substring(codeStart + 4);
-    }
-
-    return new StatusLine(protocol, code, message);
-  }
-
-  @Override public String toString() {
-    StringBuilder result = new StringBuilder();
-    result.append(protocol == Protocol.HTTP_1_0 ? "HTTP/1.0" : "HTTP/1.1");
-    result.append(' ').append(code);
-    if (message != null) {
-      result.append(' ').append(message);
-    }
-    return result.toString();
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http1/Http1ExchangeCodec.java b/okhttp/src/main/java/okhttp3/internal/http1/Http1ExchangeCodec.java
deleted file mode 100644
index a5c34cfa0c..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http1/Http1ExchangeCodec.java
+++ /dev/null
@@ -1,546 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http1;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.util.concurrent.TimeUnit;
-import okhttp3.Headers;
-import okhttp3.HttpUrl;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.Internal;
-import okhttp3.internal.Util;
-import okhttp3.internal.connection.RealConnection;
-import okhttp3.internal.http.ExchangeCodec;
-import okhttp3.internal.http.HttpHeaders;
-import okhttp3.internal.http.RequestLine;
-import okhttp3.internal.http.StatusLine;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.ForwardingTimeout;
-import okio.Sink;
-import okio.Source;
-import okio.Timeout;
-
-import static java.util.concurrent.TimeUnit.MILLISECONDS;
-import static okhttp3.internal.Util.checkOffsetAndCount;
-import static okhttp3.internal.http.StatusLine.HTTP_CONTINUE;
-
-/**
- * A socket connection that can be used to send HTTP/1.1 messages. This class strictly enforces the
- * following lifecycle:
- *
- * <ol>
- *     <li>{@linkplain #writeRequest Send request headers}.
- *     <li>Open a sink to write the request body. Either {@linkplain #newKnownLengthSink known
- *         length} or {@link #newChunkedSink chunked}.
- *     <li>Write to and then close that sink.
- *     <li>{@linkplain #readResponseHeaders Read response headers}.
- *     <li>Open a source to read the response body. Either {@linkplain #newFixedLengthSource
- *         fixed-length}, {@linkplain #newChunkedSource chunked} or {@linkplain
- *         #newUnknownLengthSource unknown length}.
- *     <li>Read from and close that source.
- * </ol>
- *
- * <p>Exchanges that do not have a request body may skip creating and closing the request body.
- * Exchanges that do not have a response body can call {@link #newFixedLengthSource(long)
- * newFixedLengthSource(0)} and may skip reading and closing that source.
- */
-public final class Http1ExchangeCodec implements ExchangeCodec {
-  private static final int STATE_IDLE = 0; // Idle connections are ready to write request headers.
-  private static final int STATE_OPEN_REQUEST_BODY = 1;
-  private static final int STATE_WRITING_REQUEST_BODY = 2;
-  private static final int STATE_READ_RESPONSE_HEADERS = 3;
-  private static final int STATE_OPEN_RESPONSE_BODY = 4;
-  private static final int STATE_READING_RESPONSE_BODY = 5;
-  private static final int STATE_CLOSED = 6;
-  private static final int HEADER_LIMIT = 256 * 1024;
-
-  /** The client that configures this stream. May be null for HTTPS proxy tunnels. */
-  private final OkHttpClient client;
-
-  /** The connection that carries this stream. */
-  private final RealConnection realConnection;
-
-  private final BufferedSource source;
-  private final BufferedSink sink;
-  private int state = STATE_IDLE;
-  private long headerLimit = HEADER_LIMIT;
-
-  /**
-   * Received trailers. Null unless the response body uses chunked transfer-encoding and includes
-   * trailers. Undefined until the end of the response body.
-   */
-  private Headers trailers;
-
-  public Http1ExchangeCodec(OkHttpClient client, RealConnection realConnection,
-      BufferedSource source, BufferedSink sink) {
-    this.client = client;
-    this.realConnection = realConnection;
-    this.source = source;
-    this.sink = sink;
-  }
-
-  @Override public RealConnection connection() {
-    return realConnection;
-  }
-
-  @Override public Sink createRequestBody(Request request, long contentLength) throws IOException {
-    if (request.body() != null && request.body().isDuplex()) {
-      throw new ProtocolException("Duplex connections are not supported for HTTP/1");
-    }
-
-    if ("chunked".equalsIgnoreCase(request.header("Transfer-Encoding"))) {
-      // Stream a request body of unknown length.
-      return newChunkedSink();
-    }
-
-    if (contentLength != -1L) {
-      // Stream a request body of a known length.
-      return newKnownLengthSink();
-    }
-
-    throw new IllegalStateException(
-        "Cannot stream a request body without chunked encoding or a known content length!");
-  }
-
-  @Override public void cancel() {
-    if (realConnection != null) realConnection.cancel();
-  }
-
-  /**
-   * Prepares the HTTP headers and sends them to the server.
-   *
-   * <p>For streaming requests with a body, headers must be prepared <strong>before</strong> the
-   * output stream has been written to. Otherwise the body would need to be buffered!
-   *
-   * <p>For non-streaming requests with a body, headers must be prepared <strong>after</strong> the
-   * output stream has been written to and closed. This ensures that the {@code Content-Length}
-   * header field receives the proper value.
-   */
-  @Override public void writeRequestHeaders(Request request) throws IOException {
-    String requestLine = RequestLine.get(
-        request, realConnection.route().proxy().type());
-    writeRequest(request.headers(), requestLine);
-  }
-
-  @Override public long reportedContentLength(Response response) {
-    if (!HttpHeaders.hasBody(response)) {
-      return 0L;
-    }
-
-    if ("chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {
-      return -1L;
-    }
-
-    return HttpHeaders.contentLength(response);
-  }
-
-  @Override public Source openResponseBodySource(Response response) {
-    if (!HttpHeaders.hasBody(response)) {
-      return newFixedLengthSource(0);
-    }
-
-    if ("chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {
-      return newChunkedSource(response.request().url());
-    }
-
-    long contentLength = HttpHeaders.contentLength(response);
-    if (contentLength != -1) {
-      return newFixedLengthSource(contentLength);
-    }
-
-    return newUnknownLengthSource();
-  }
-
-  @Override public Headers trailers() {
-    if (state != STATE_CLOSED) {
-      throw new IllegalStateException("too early; can't read the trailers yet");
-    }
-    return trailers != null ? trailers : Util.EMPTY_HEADERS;
-  }
-
-  /** Returns true if this connection is closed. */
-  public boolean isClosed() {
-    return state == STATE_CLOSED;
-  }
-
-  @Override public void flushRequest() throws IOException {
-    sink.flush();
-  }
-
-  @Override public void finishRequest() throws IOException {
-    sink.flush();
-  }
-
-  /** Returns bytes of a request header for sending on an HTTP transport. */
-  public void writeRequest(Headers headers, String requestLine) throws IOException {
-    if (state != STATE_IDLE) throw new IllegalStateException("state: " + state);
-    sink.writeUtf8(requestLine).writeUtf8("\r\n");
-    for (int i = 0, size = headers.size(); i < size; i++) {
-      sink.writeUtf8(headers.name(i))
-          .writeUtf8(": ")
-          .writeUtf8(headers.value(i))
-          .writeUtf8("\r\n");
-    }
-    sink.writeUtf8("\r\n");
-    state = STATE_OPEN_REQUEST_BODY;
-  }
-
-  @Override public Response.Builder readResponseHeaders(boolean expectContinue) throws IOException {
-    if (state != STATE_OPEN_REQUEST_BODY && state != STATE_READ_RESPONSE_HEADERS) {
-      throw new IllegalStateException("state: " + state);
-    }
-
-    try {
-      StatusLine statusLine = StatusLine.parse(readHeaderLine());
-
-      Response.Builder responseBuilder = new Response.Builder()
-          .protocol(statusLine.protocol)
-          .code(statusLine.code)
-          .message(statusLine.message)
-          .headers(readHeaders());
-
-      if (expectContinue && statusLine.code == HTTP_CONTINUE) {
-        return null;
-      } else if (statusLine.code == HTTP_CONTINUE) {
-        state = STATE_READ_RESPONSE_HEADERS;
-        return responseBuilder;
-      }
-
-      state = STATE_OPEN_RESPONSE_BODY;
-      return responseBuilder;
-    } catch (EOFException e) {
-      // Provide more context if the server ends the stream before sending a response.
-      String address = "unknown";
-      if (realConnection != null) {
-        address = realConnection.route().address().url().redact();
-      }
-      throw new IOException("unexpected end of stream on "
-          + address, e);
-    }
-  }
-
-  private String readHeaderLine() throws IOException {
-    String line = source.readUtf8LineStrict(headerLimit);
-    headerLimit -= line.length();
-    return line;
-  }
-
-  /** Reads headers or trailers. */
-  private Headers readHeaders() throws IOException {
-    Headers.Builder headers = new Headers.Builder();
-    // parse the result headers until the first blank line
-    for (String line; (line = readHeaderLine()).length() != 0; ) {
-      Internal.instance.addLenient(headers, line);
-    }
-    return headers.build();
-  }
-
-  private Sink newChunkedSink() {
-    if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException("state: " + state);
-    state = STATE_WRITING_REQUEST_BODY;
-    return new ChunkedSink();
-  }
-
-  private Sink newKnownLengthSink() {
-    if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException("state: " + state);
-    state = STATE_WRITING_REQUEST_BODY;
-    return new KnownLengthSink();
-  }
-
-  private Source newFixedLengthSource(long length) {
-    if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
-    state = STATE_READING_RESPONSE_BODY;
-    return new FixedLengthSource(length);
-  }
-
-  private Source newChunkedSource(HttpUrl url) {
-    if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
-    state = STATE_READING_RESPONSE_BODY;
-    return new ChunkedSource(url);
-  }
-
-  private Source newUnknownLengthSource() {
-    if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
-    state = STATE_READING_RESPONSE_BODY;
-    realConnection.noNewExchanges();
-    return new UnknownLengthSource();
-  }
-
-  /**
-   * Sets the delegate of {@code timeout} to {@link Timeout#NONE} and resets its underlying timeout
-   * to the default configuration. Use this to avoid unexpected sharing of timeouts between pooled
-   * connections.
-   */
-  private void detachTimeout(ForwardingTimeout timeout) {
-    Timeout oldDelegate = timeout.delegate();
-    timeout.setDelegate(Timeout.NONE);
-    oldDelegate.clearDeadline();
-    oldDelegate.clearTimeout();
-  }
-
-  /**
-   * The response body from a CONNECT should be empty, but if it is not then we should consume it
-   * before proceeding.
-   */
-  public void skipConnectBody(Response response) throws IOException {
-    long contentLength = HttpHeaders.contentLength(response);
-    if (contentLength == -1L) return;
-    Source body = newFixedLengthSource(contentLength);
-    Util.skipAll(body, Integer.MAX_VALUE, TimeUnit.MILLISECONDS);
-    body.close();
-  }
-
-  /** An HTTP request body. */
-  private final class KnownLengthSink implements Sink {
-    private final ForwardingTimeout timeout = new ForwardingTimeout(sink.timeout());
-    private boolean closed;
-
-    @Override public Timeout timeout() {
-      return timeout;
-    }
-
-    @Override public void write(Buffer source, long byteCount) throws IOException {
-      if (closed) throw new IllegalStateException("closed");
-      checkOffsetAndCount(source.size(), 0, byteCount);
-      sink.write(source, byteCount);
-    }
-
-    @Override public void flush() throws IOException {
-      if (closed) return; // Don't throw; this stream might have been closed on the caller's behalf.
-      sink.flush();
-    }
-
-    @Override public void close() throws IOException {
-      if (closed) return;
-      closed = true;
-      detachTimeout(timeout);
-      state = STATE_READ_RESPONSE_HEADERS;
-    }
-  }
-
-  /**
-   * An HTTP body with alternating chunk sizes and chunk bodies. It is the caller's responsibility
-   * to buffer chunks; typically by using a buffered sink with this sink.
-   */
-  private final class ChunkedSink implements Sink {
-    private final ForwardingTimeout timeout = new ForwardingTimeout(sink.timeout());
-    private boolean closed;
-
-    ChunkedSink() {
-    }
-
-    @Override public Timeout timeout() {
-      return timeout;
-    }
-
-    @Override public void write(Buffer source, long byteCount) throws IOException {
-      if (closed) throw new IllegalStateException("closed");
-      if (byteCount == 0) return;
-
-      sink.writeHexadecimalUnsignedLong(byteCount);
-      sink.writeUtf8("\r\n");
-      sink.write(source, byteCount);
-      sink.writeUtf8("\r\n");
-    }
-
-    @Override public synchronized void flush() throws IOException {
-      if (closed) return; // Don't throw; this stream might have been closed on the caller's behalf.
-      sink.flush();
-    }
-
-    @Override public synchronized void close() throws IOException {
-      if (closed) return;
-      closed = true;
-      sink.writeUtf8("0\r\n\r\n");
-      detachTimeout(timeout);
-      state = STATE_READ_RESPONSE_HEADERS;
-    }
-  }
-
-  private abstract class AbstractSource implements Source {
-    protected final ForwardingTimeout timeout = new ForwardingTimeout(source.timeout());
-    protected boolean closed;
-
-    @Override public Timeout timeout() {
-      return timeout;
-    }
-
-    @Override public long read(Buffer sink, long byteCount) throws IOException {
-      try {
-        return source.read(sink, byteCount);
-      } catch (IOException e) {
-        realConnection.noNewExchanges();
-        responseBodyComplete();
-        throw e;
-      }
-    }
-
-    /**
-     * Closes the cache entry and makes the socket available for reuse. This should be invoked when
-     * the end of the body has been reached.
-     */
-    final void responseBodyComplete() {
-      if (state == STATE_CLOSED) return;
-      if (state != STATE_READING_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
-
-      detachTimeout(timeout);
-
-      state = STATE_CLOSED;
-    }
-  }
-
-  /** An HTTP body with a fixed length specified in advance. */
-  private class FixedLengthSource extends AbstractSource {
-    private long bytesRemaining;
-
-    FixedLengthSource(long length) {
-      bytesRemaining = length;
-      if (bytesRemaining == 0) {
-        responseBodyComplete();
-      }
-    }
-
-    @Override public long read(Buffer sink, long byteCount) throws IOException {
-      if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
-      if (closed) throw new IllegalStateException("closed");
-      if (bytesRemaining == 0) return -1;
-
-      long read = super.read(sink, Math.min(bytesRemaining, byteCount));
-      if (read == -1) {
-        realConnection.noNewExchanges(); // The server didn't supply the promised content length.
-        ProtocolException e = new ProtocolException("unexpected end of stream");
-        responseBodyComplete();
-        throw e;
-      }
-
-      bytesRemaining -= read;
-      if (bytesRemaining == 0) {
-        responseBodyComplete();
-      }
-      return read;
-    }
-
-    @Override public void close() throws IOException {
-      if (closed) return;
-
-      if (bytesRemaining != 0 && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-        realConnection.noNewExchanges(); // Unread bytes remain on the stream.
-        responseBodyComplete();
-      }
-
-      closed = true;
-    }
-  }
-
-  /** An HTTP body with alternating chunk sizes and chunk bodies. */
-  private class ChunkedSource extends AbstractSource {
-    private static final long NO_CHUNK_YET = -1L;
-    private final HttpUrl url;
-    private long bytesRemainingInChunk = NO_CHUNK_YET;
-    private boolean hasMoreChunks = true;
-
-    ChunkedSource(HttpUrl url) {
-      this.url = url;
-    }
-
-    @Override public long read(Buffer sink, long byteCount) throws IOException {
-      if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
-      if (closed) throw new IllegalStateException("closed");
-      if (!hasMoreChunks) return -1;
-
-      if (bytesRemainingInChunk == 0 || bytesRemainingInChunk == NO_CHUNK_YET) {
-        readChunkSize();
-        if (!hasMoreChunks) return -1;
-      }
-
-      long read = super.read(sink, Math.min(byteCount, bytesRemainingInChunk));
-      if (read == -1) {
-        realConnection.noNewExchanges(); // The server didn't supply the promised chunk length.
-        ProtocolException e = new ProtocolException("unexpected end of stream");
-        responseBodyComplete();
-        throw e;
-      }
-      bytesRemainingInChunk -= read;
-      return read;
-    }
-
-    private void readChunkSize() throws IOException {
-      // Read the suffix of the previous chunk.
-      if (bytesRemainingInChunk != NO_CHUNK_YET) {
-        source.readUtf8LineStrict();
-      }
-      try {
-        bytesRemainingInChunk = source.readHexadecimalUnsignedLong();
-        String extensions = source.readUtf8LineStrict().trim();
-        if (bytesRemainingInChunk < 0 || (!extensions.isEmpty() && !extensions.startsWith(";"))) {
-          throw new ProtocolException("expected chunk size and optional extensions but was \""
-              + bytesRemainingInChunk + extensions + "\"");
-        }
-      } catch (NumberFormatException e) {
-        throw new ProtocolException(e.getMessage());
-      }
-      if (bytesRemainingInChunk == 0L) {
-        hasMoreChunks = false;
-        trailers = readHeaders();
-        HttpHeaders.receiveHeaders(client.cookieJar(), url, trailers);
-        responseBodyComplete();
-      }
-    }
-
-    @Override public void close() throws IOException {
-      if (closed) return;
-      if (hasMoreChunks && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-        realConnection.noNewExchanges(); // Unread bytes remain on the stream.
-        responseBodyComplete();
-      }
-      closed = true;
-    }
-  }
-
-  /** An HTTP message body terminated by the end of the underlying stream. */
-  private class UnknownLengthSource extends AbstractSource {
-    private boolean inputExhausted;
-
-    @Override public long read(Buffer sink, long byteCount)
-        throws IOException {
-      if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
-      if (closed) throw new IllegalStateException("closed");
-      if (inputExhausted) return -1;
-
-      long read = super.read(sink, byteCount);
-      if (read == -1) {
-        inputExhausted = true;
-        responseBodyComplete();
-        return -1;
-      }
-      return read;
-    }
-
-    @Override public void close() throws IOException {
-      if (closed) return;
-      if (!inputExhausted) {
-        responseBodyComplete();
-      }
-      closed = true;
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/ConnectionShutdownException.java b/okhttp/src/main/java/okhttp3/internal/http2/ConnectionShutdownException.java
deleted file mode 100644
index 00c4f2441c..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http2/ConnectionShutdownException.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import java.io.IOException;
-
-/**
- * Thrown when an HTTP/2 connection is shutdown (either explicitly or if the peer has sent a GOAWAY
- * frame) and an attempt is made to use the connection.
- */
-public final class ConnectionShutdownException extends IOException {
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/ErrorCode.java b/okhttp/src/main/java/okhttp3/internal/http2/ErrorCode.java
deleted file mode 100644
index 6a704684fc..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http2/ErrorCode.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-// http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-7
-public enum ErrorCode {
-  /** Not an error! */
-  NO_ERROR(0),
-
-  PROTOCOL_ERROR(1),
-
-  INTERNAL_ERROR(2),
-
-  FLOW_CONTROL_ERROR(3),
-
-  REFUSED_STREAM(7),
-
-  CANCEL(8),
-
-  COMPRESSION_ERROR(9),
-
-  CONNECT_ERROR(0xa),
-
-  ENHANCE_YOUR_CALM(0xb),
-
-  INADEQUATE_SECURITY(0xc),
-
-  HTTP_1_1_REQUIRED(0xd);
-
-  public final int httpCode;
-
-  ErrorCode(int httpCode) {
-    this.httpCode = httpCode;
-  }
-
-  public static ErrorCode fromHttp2(int code) {
-    for (ErrorCode errorCode : ErrorCode.values()) {
-      if (errorCode.httpCode == code) return errorCode;
-    }
-    return null;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Header.java b/okhttp/src/main/java/okhttp3/internal/http2/Header.java
deleted file mode 100644
index a306ac4622..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http2/Header.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import okhttp3.internal.Util;
-import okio.ByteString;
-
-/** HTTP header: the name is an ASCII string, but the value can be UTF-8. */
-public final class Header {
-  // Special header names defined in HTTP/2 spec.
-  public static final ByteString PSEUDO_PREFIX = ByteString.encodeUtf8(":");
-
-  public static final String RESPONSE_STATUS_UTF8 = ":status";
-  public static final String TARGET_METHOD_UTF8 = ":method";
-  public static final String TARGET_PATH_UTF8 = ":path";
-  public static final String TARGET_SCHEME_UTF8 = ":scheme";
-  public static final String TARGET_AUTHORITY_UTF8 = ":authority";
-
-  public static final ByteString RESPONSE_STATUS = ByteString.encodeUtf8(RESPONSE_STATUS_UTF8);
-  public static final ByteString TARGET_METHOD = ByteString.encodeUtf8(TARGET_METHOD_UTF8);
-  public static final ByteString TARGET_PATH = ByteString.encodeUtf8(TARGET_PATH_UTF8);
-  public static final ByteString TARGET_SCHEME = ByteString.encodeUtf8(TARGET_SCHEME_UTF8);
-  public static final ByteString TARGET_AUTHORITY = ByteString.encodeUtf8(TARGET_AUTHORITY_UTF8);
-
-
-  /** Name in case-insensitive ASCII encoding. */
-  public final ByteString name;
-  /** Value in UTF-8 encoding. */
-  public final ByteString value;
-  final int hpackSize;
-
-  // TODO: search for toLowerCase and consider moving logic here.
-  public Header(String name, String value) {
-    this(ByteString.encodeUtf8(name), ByteString.encodeUtf8(value));
-  }
-
-  public Header(ByteString name, String value) {
-    this(name, ByteString.encodeUtf8(value));
-  }
-
-  public Header(ByteString name, ByteString value) {
-    this.name = name;
-    this.value = value;
-    this.hpackSize = 32 + name.size() + value.size();
-  }
-
-  @Override public boolean equals(Object other) {
-    if (other instanceof Header) {
-      Header that = (Header) other;
-      return this.name.equals(that.name)
-          && this.value.equals(that.value);
-    }
-    return false;
-  }
-
-  @Override public int hashCode() {
-    int result = 17;
-    result = 31 * result + name.hashCode();
-    result = 31 * result + value.hashCode();
-    return result;
-  }
-
-  @Override public String toString() {
-    return Util.format("%s: %s", name.utf8(), value.utf8());
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java b/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
deleted file mode 100644
index 615756cc48..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
+++ /dev/null
@@ -1,604 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Objects;
-import okio.Buffer;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.Okio;
-import okio.Source;
-
-/**
- * Read and write HPACK v10.
- *
- * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12
- *
- * This implementation uses an array for the dynamic table and a list for indexed entries.  Dynamic
- * entries are added to the array, starting in the last position moving forward.  When the array
- * fills, it is doubled.
- */
-final class Hpack {
-  private static final int PREFIX_4_BITS = 0x0f;
-  private static final int PREFIX_5_BITS = 0x1f;
-  private static final int PREFIX_6_BITS = 0x3f;
-  private static final int PREFIX_7_BITS = 0x7f;
-
-  static final Header[] STATIC_HEADER_TABLE = new Header[] {
-      new Header(Header.TARGET_AUTHORITY, ""),
-      new Header(Header.TARGET_METHOD, "GET"),
-      new Header(Header.TARGET_METHOD, "POST"),
-      new Header(Header.TARGET_PATH, "/"),
-      new Header(Header.TARGET_PATH, "/index.html"),
-      new Header(Header.TARGET_SCHEME, "http"),
-      new Header(Header.TARGET_SCHEME, "https"),
-      new Header(Header.RESPONSE_STATUS, "200"),
-      new Header(Header.RESPONSE_STATUS, "204"),
-      new Header(Header.RESPONSE_STATUS, "206"),
-      new Header(Header.RESPONSE_STATUS, "304"),
-      new Header(Header.RESPONSE_STATUS, "400"),
-      new Header(Header.RESPONSE_STATUS, "404"),
-      new Header(Header.RESPONSE_STATUS, "500"),
-      new Header("accept-charset", ""),
-      new Header("accept-encoding", "gzip, deflate"),
-      new Header("accept-language", ""),
-      new Header("accept-ranges", ""),
-      new Header("accept", ""),
-      new Header("access-control-allow-origin", ""),
-      new Header("age", ""),
-      new Header("allow", ""),
-      new Header("authorization", ""),
-      new Header("cache-control", ""),
-      new Header("content-disposition", ""),
-      new Header("content-encoding", ""),
-      new Header("content-language", ""),
-      new Header("content-length", ""),
-      new Header("content-location", ""),
-      new Header("content-range", ""),
-      new Header("content-type", ""),
-      new Header("cookie", ""),
-      new Header("date", ""),
-      new Header("etag", ""),
-      new Header("expect", ""),
-      new Header("expires", ""),
-      new Header("from", ""),
-      new Header("host", ""),
-      new Header("if-match", ""),
-      new Header("if-modified-since", ""),
-      new Header("if-none-match", ""),
-      new Header("if-range", ""),
-      new Header("if-unmodified-since", ""),
-      new Header("last-modified", ""),
-      new Header("link", ""),
-      new Header("location", ""),
-      new Header("max-forwards", ""),
-      new Header("proxy-authenticate", ""),
-      new Header("proxy-authorization", ""),
-      new Header("range", ""),
-      new Header("referer", ""),
-      new Header("refresh", ""),
-      new Header("retry-after", ""),
-      new Header("server", ""),
-      new Header("set-cookie", ""),
-      new Header("strict-transport-security", ""),
-      new Header("transfer-encoding", ""),
-      new Header("user-agent", ""),
-      new Header("vary", ""),
-      new Header("via", ""),
-      new Header("www-authenticate", "")
-  };
-
-  private Hpack() {
-  }
-
-  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-3.1
-  static final class Reader {
-
-    private final List<Header> headerList = new ArrayList<>();
-    private final BufferedSource source;
-
-    private final int headerTableSizeSetting;
-    private int maxDynamicTableByteCount;
-
-    // Visible for testing.
-    Header[] dynamicTable = new Header[8];
-    // Array is populated back to front, so new entries always have lowest index.
-    int nextHeaderIndex = dynamicTable.length - 1;
-    int headerCount = 0;
-    int dynamicTableByteCount = 0;
-
-    Reader(int headerTableSizeSetting, Source source) {
-      this(headerTableSizeSetting, headerTableSizeSetting, source);
-    }
-
-    Reader(int headerTableSizeSetting, int maxDynamicTableByteCount, Source source) {
-      this.headerTableSizeSetting = headerTableSizeSetting;
-      this.maxDynamicTableByteCount = maxDynamicTableByteCount;
-      this.source = Okio.buffer(source);
-    }
-
-    int maxDynamicTableByteCount() {
-      return maxDynamicTableByteCount;
-    }
-
-    private void adjustDynamicTableByteCount() {
-      if (maxDynamicTableByteCount < dynamicTableByteCount) {
-        if (maxDynamicTableByteCount == 0) {
-          clearDynamicTable();
-        } else {
-          evictToRecoverBytes(dynamicTableByteCount - maxDynamicTableByteCount);
-        }
-      }
-    }
-
-    private void clearDynamicTable() {
-      Arrays.fill(dynamicTable, null);
-      nextHeaderIndex = dynamicTable.length - 1;
-      headerCount = 0;
-      dynamicTableByteCount = 0;
-    }
-
-    /** Returns the count of entries evicted. */
-    private int evictToRecoverBytes(int bytesToRecover) {
-      int entriesToEvict = 0;
-      if (bytesToRecover > 0) {
-        // determine how many headers need to be evicted.
-        for (int j = dynamicTable.length - 1; j >= nextHeaderIndex && bytesToRecover > 0; j--) {
-          bytesToRecover -= dynamicTable[j].hpackSize;
-          dynamicTableByteCount -= dynamicTable[j].hpackSize;
-          headerCount--;
-          entriesToEvict++;
-        }
-        System.arraycopy(dynamicTable, nextHeaderIndex + 1, dynamicTable,
-            nextHeaderIndex + 1 + entriesToEvict, headerCount);
-        nextHeaderIndex += entriesToEvict;
-      }
-      return entriesToEvict;
-    }
-
-    /**
-     * Read {@code byteCount} bytes of headers from the source stream. This implementation does not
-     * propagate the never indexed flag of a header.
-     */
-    void readHeaders() throws IOException {
-      while (!source.exhausted()) {
-        int b = source.readByte() & 0xff;
-        if (b == 0x80) { // 10000000
-          throw new IOException("index == 0");
-        } else if ((b & 0x80) == 0x80) { // 1NNNNNNN
-          int index = readInt(b, PREFIX_7_BITS);
-          readIndexedHeader(index - 1);
-        } else if (b == 0x40) { // 01000000
-          readLiteralHeaderWithIncrementalIndexingNewName();
-        } else if ((b & 0x40) == 0x40) {  // 01NNNNNN
-          int index = readInt(b, PREFIX_6_BITS);
-          readLiteralHeaderWithIncrementalIndexingIndexedName(index - 1);
-        } else if ((b & 0x20) == 0x20) {  // 001NNNNN
-          maxDynamicTableByteCount = readInt(b, PREFIX_5_BITS);
-          if (maxDynamicTableByteCount < 0
-              || maxDynamicTableByteCount > headerTableSizeSetting) {
-            throw new IOException("Invalid dynamic table size update " + maxDynamicTableByteCount);
-          }
-          adjustDynamicTableByteCount();
-        } else if (b == 0x10 || b == 0) { // 000?0000 - Ignore never indexed bit.
-          readLiteralHeaderWithoutIndexingNewName();
-        } else { // 000?NNNN - Ignore never indexed bit.
-          int index = readInt(b, PREFIX_4_BITS);
-          readLiteralHeaderWithoutIndexingIndexedName(index - 1);
-        }
-      }
-    }
-
-    public List<Header> getAndResetHeaderList() {
-      List<Header> result = new ArrayList<>(headerList);
-      headerList.clear();
-      return result;
-    }
-
-    private void readIndexedHeader(int index) throws IOException {
-      if (isStaticHeader(index)) {
-        Header staticEntry = STATIC_HEADER_TABLE[index];
-        headerList.add(staticEntry);
-      } else {
-        int dynamicTableIndex = dynamicTableIndex(index - STATIC_HEADER_TABLE.length);
-        if (dynamicTableIndex < 0 || dynamicTableIndex >= dynamicTable.length) {
-          throw new IOException("Header index too large " + (index + 1));
-        }
-        headerList.add(dynamicTable[dynamicTableIndex]);
-      }
-    }
-
-    // referencedHeaders is relative to nextHeaderIndex + 1.
-    private int dynamicTableIndex(int index) {
-      return nextHeaderIndex + 1 + index;
-    }
-
-    private void readLiteralHeaderWithoutIndexingIndexedName(int index) throws IOException {
-      ByteString name = getName(index);
-      ByteString value = readByteString();
-      headerList.add(new Header(name, value));
-    }
-
-    private void readLiteralHeaderWithoutIndexingNewName() throws IOException {
-      ByteString name = checkLowercase(readByteString());
-      ByteString value = readByteString();
-      headerList.add(new Header(name, value));
-    }
-
-    private void readLiteralHeaderWithIncrementalIndexingIndexedName(int nameIndex)
-        throws IOException {
-      ByteString name = getName(nameIndex);
-      ByteString value = readByteString();
-      insertIntoDynamicTable(-1, new Header(name, value));
-    }
-
-    private void readLiteralHeaderWithIncrementalIndexingNewName() throws IOException {
-      ByteString name = checkLowercase(readByteString());
-      ByteString value = readByteString();
-      insertIntoDynamicTable(-1, new Header(name, value));
-    }
-
-    private ByteString getName(int index) throws IOException {
-      if (isStaticHeader(index)) {
-        return STATIC_HEADER_TABLE[index].name;
-      } else {
-        int dynamicTableIndex = dynamicTableIndex(index - STATIC_HEADER_TABLE.length);
-        if (dynamicTableIndex < 0 || dynamicTableIndex >= dynamicTable.length) {
-          throw new IOException("Header index too large " + (index + 1));
-        }
-
-        return dynamicTable[dynamicTableIndex].name;
-      }
-    }
-
-    private boolean isStaticHeader(int index) {
-      return index >= 0 && index <= STATIC_HEADER_TABLE.length - 1;
-    }
-
-    /** index == -1 when new. */
-    private void insertIntoDynamicTable(int index, Header entry) {
-      headerList.add(entry);
-
-      int delta = entry.hpackSize;
-      if (index != -1) { // Index -1 == new header.
-        delta -= dynamicTable[dynamicTableIndex(index)].hpackSize;
-      }
-
-      // if the new or replacement header is too big, drop all entries.
-      if (delta > maxDynamicTableByteCount) {
-        clearDynamicTable();
-        return;
-      }
-
-      // Evict headers to the required length.
-      int bytesToRecover = (dynamicTableByteCount + delta) - maxDynamicTableByteCount;
-      int entriesEvicted = evictToRecoverBytes(bytesToRecover);
-
-      if (index == -1) { // Adding a value to the dynamic table.
-        if (headerCount + 1 > dynamicTable.length) { // Need to grow the dynamic table.
-          Header[] doubled = new Header[dynamicTable.length * 2];
-          System.arraycopy(dynamicTable, 0, doubled, dynamicTable.length, dynamicTable.length);
-          nextHeaderIndex = dynamicTable.length - 1;
-          dynamicTable = doubled;
-        }
-        index = nextHeaderIndex--;
-        dynamicTable[index] = entry;
-        headerCount++;
-      } else { // Replace value at same position.
-        index += dynamicTableIndex(index) + entriesEvicted;
-        dynamicTable[index] = entry;
-      }
-      dynamicTableByteCount += delta;
-    }
-
-    private int readByte() throws IOException {
-      return source.readByte() & 0xff;
-    }
-
-    int readInt(int firstByte, int prefixMask) throws IOException {
-      int prefix = firstByte & prefixMask;
-      if (prefix < prefixMask) {
-        return prefix; // This was a single byte value.
-      }
-
-      // This is a multibyte value. Read 7 bits at a time.
-      int result = prefixMask;
-      int shift = 0;
-      while (true) {
-        int b = readByte();
-        if ((b & 0x80) != 0) { // Equivalent to (b >= 128) since b is in [0..255].
-          result += (b & 0x7f) << shift;
-          shift += 7;
-        } else {
-          result += b << shift; // Last byte.
-          break;
-        }
-      }
-      return result;
-    }
-
-    /** Reads a potentially Huffman encoded byte string. */
-    ByteString readByteString() throws IOException {
-      int firstByte = readByte();
-      boolean huffmanDecode = (firstByte & 0x80) == 0x80; // 1NNNNNNN
-      int length = readInt(firstByte, PREFIX_7_BITS);
-
-      if (huffmanDecode) {
-        return ByteString.of(Huffman.get().decode(source.readByteArray(length)));
-      } else {
-        return source.readByteString(length);
-      }
-    }
-  }
-
-  static final Map<ByteString, Integer> NAME_TO_FIRST_INDEX = nameToFirstIndex();
-
-  private static Map<ByteString, Integer> nameToFirstIndex() {
-    Map<ByteString, Integer> result = new LinkedHashMap<>(STATIC_HEADER_TABLE.length);
-    for (int i = 0; i < STATIC_HEADER_TABLE.length; i++) {
-      if (!result.containsKey(STATIC_HEADER_TABLE[i].name)) {
-        result.put(STATIC_HEADER_TABLE[i].name, i);
-      }
-    }
-    return Collections.unmodifiableMap(result);
-  }
-
-  static final class Writer {
-    private static final int SETTINGS_HEADER_TABLE_SIZE = 4096;
-
-    /**
-     * The decoder has ultimate control of the maximum size of the dynamic table but we can choose
-     * to use less. We'll put a cap at 16K. This is arbitrary but should be enough for most
-     * purposes.
-     */
-    private static final int SETTINGS_HEADER_TABLE_SIZE_LIMIT = 16384;
-
-    private final Buffer out;
-    private final boolean useCompression;
-
-    /**
-     * In the scenario where the dynamic table size changes multiple times between transmission of
-     * header blocks, we need to keep track of the smallest value in that interval.
-     */
-    private int smallestHeaderTableSizeSetting = Integer.MAX_VALUE;
-    private boolean emitDynamicTableSizeUpdate;
-
-    int headerTableSizeSetting;
-    int maxDynamicTableByteCount;
-
-    // Visible for testing.
-    Header[] dynamicTable = new Header[8];
-    // Array is populated back to front, so new entries always have lowest index.
-    int nextHeaderIndex = dynamicTable.length - 1;
-    int headerCount = 0;
-    int dynamicTableByteCount = 0;
-
-    Writer(Buffer out) {
-      this(SETTINGS_HEADER_TABLE_SIZE, true, out);
-    }
-
-    Writer(int headerTableSizeSetting, boolean useCompression, Buffer out) {
-      this.headerTableSizeSetting = headerTableSizeSetting;
-      this.maxDynamicTableByteCount = headerTableSizeSetting;
-      this.useCompression = useCompression;
-      this.out = out;
-    }
-
-    private void clearDynamicTable() {
-      Arrays.fill(dynamicTable, null);
-      nextHeaderIndex = dynamicTable.length - 1;
-      headerCount = 0;
-      dynamicTableByteCount = 0;
-    }
-
-    /** Returns the count of entries evicted. */
-    private int evictToRecoverBytes(int bytesToRecover) {
-      int entriesToEvict = 0;
-      if (bytesToRecover > 0) {
-        // determine how many headers need to be evicted.
-        for (int j = dynamicTable.length - 1; j >= nextHeaderIndex && bytesToRecover > 0; j--) {
-          bytesToRecover -= dynamicTable[j].hpackSize;
-          dynamicTableByteCount -= dynamicTable[j].hpackSize;
-          headerCount--;
-          entriesToEvict++;
-        }
-        System.arraycopy(dynamicTable, nextHeaderIndex + 1, dynamicTable,
-            nextHeaderIndex + 1 + entriesToEvict, headerCount);
-        Arrays.fill(dynamicTable, nextHeaderIndex + 1, nextHeaderIndex + 1 + entriesToEvict, null);
-        nextHeaderIndex += entriesToEvict;
-      }
-      return entriesToEvict;
-    }
-
-    private void insertIntoDynamicTable(Header entry) {
-      int delta = entry.hpackSize;
-
-      // if the new or replacement header is too big, drop all entries.
-      if (delta > maxDynamicTableByteCount) {
-        clearDynamicTable();
-        return;
-      }
-
-      // Evict headers to the required length.
-      int bytesToRecover = (dynamicTableByteCount + delta) - maxDynamicTableByteCount;
-      evictToRecoverBytes(bytesToRecover);
-
-      if (headerCount + 1 > dynamicTable.length) { // Need to grow the dynamic table.
-        Header[] doubled = new Header[dynamicTable.length * 2];
-        System.arraycopy(dynamicTable, 0, doubled, dynamicTable.length, dynamicTable.length);
-        nextHeaderIndex = dynamicTable.length - 1;
-        dynamicTable = doubled;
-      }
-      int index = nextHeaderIndex--;
-      dynamicTable[index] = entry;
-      headerCount++;
-      dynamicTableByteCount += delta;
-    }
-
-    /** This does not use "never indexed" semantics for sensitive headers. */
-    // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-6.2.3
-    void writeHeaders(List<Header> headerBlock) throws IOException {
-      if (emitDynamicTableSizeUpdate) {
-        if (smallestHeaderTableSizeSetting < maxDynamicTableByteCount) {
-          // Multiple dynamic table size updates!
-          writeInt(smallestHeaderTableSizeSetting, PREFIX_5_BITS, 0x20);
-        }
-        emitDynamicTableSizeUpdate = false;
-        smallestHeaderTableSizeSetting = Integer.MAX_VALUE;
-        writeInt(maxDynamicTableByteCount, PREFIX_5_BITS, 0x20);
-      }
-
-      for (int i = 0, size = headerBlock.size(); i < size; i++) {
-        Header header = headerBlock.get(i);
-        ByteString name = header.name.toAsciiLowercase();
-        ByteString value = header.value;
-        int headerIndex = -1;
-        int headerNameIndex = -1;
-
-        Integer staticIndex = NAME_TO_FIRST_INDEX.get(name);
-        if (staticIndex != null) {
-          headerNameIndex = staticIndex + 1;
-          if (headerNameIndex > 1 && headerNameIndex < 8) {
-            // Only search a subset of the static header table. Most entries have an empty value, so
-            // it's unnecessary to waste cycles looking at them. This check is built on the
-            // observation that the header entries we care about are in adjacent pairs, and we
-            // always know the first index of the pair.
-            if (Objects.equals(STATIC_HEADER_TABLE[headerNameIndex - 1].value, value)) {
-              headerIndex = headerNameIndex;
-            } else if (Objects.equals(STATIC_HEADER_TABLE[headerNameIndex].value, value)) {
-              headerIndex = headerNameIndex + 1;
-            }
-          }
-        }
-
-        if (headerIndex == -1) {
-          for (int j = nextHeaderIndex + 1, length = dynamicTable.length; j < length; j++) {
-            if (Objects.equals(dynamicTable[j].name, name)) {
-              if (Objects.equals(dynamicTable[j].value, value)) {
-                headerIndex = j - nextHeaderIndex + STATIC_HEADER_TABLE.length;
-                break;
-              } else if (headerNameIndex == -1) {
-                headerNameIndex = j - nextHeaderIndex + STATIC_HEADER_TABLE.length;
-              }
-            }
-          }
-        }
-
-        if (headerIndex != -1) {
-          // Indexed Header Field.
-          writeInt(headerIndex, PREFIX_7_BITS, 0x80);
-        } else if (headerNameIndex == -1) {
-          // Literal Header Field with Incremental Indexing - New Name.
-          out.writeByte(0x40);
-          writeByteString(name);
-          writeByteString(value);
-          insertIntoDynamicTable(header);
-        } else if (name.startsWith(Header.PSEUDO_PREFIX) && !Header.TARGET_AUTHORITY.equals(name)) {
-          // Follow Chromes lead - only include the :authority pseudo header, but exclude all other
-          // pseudo headers. Literal Header Field without Indexing - Indexed Name.
-          writeInt(headerNameIndex, PREFIX_4_BITS, 0);
-          writeByteString(value);
-        } else {
-          // Literal Header Field with Incremental Indexing - Indexed Name.
-          writeInt(headerNameIndex, PREFIX_6_BITS, 0x40);
-          writeByteString(value);
-          insertIntoDynamicTable(header);
-        }
-      }
-    }
-
-    // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-4.1.1
-    void writeInt(int value, int prefixMask, int bits) {
-      // Write the raw value for a single byte value.
-      if (value < prefixMask) {
-        out.writeByte(bits | value);
-        return;
-      }
-
-      // Write the mask to start a multibyte value.
-      out.writeByte(bits | prefixMask);
-      value -= prefixMask;
-
-      // Write 7 bits at a time 'til we're done.
-      while (value >= 0x80) {
-        int b = value & 0x7f;
-        out.writeByte(b | 0x80);
-        value >>>= 7;
-      }
-      out.writeByte(value);
-    }
-
-    void writeByteString(ByteString data) throws IOException {
-      if (useCompression && Huffman.get().encodedLength(data) < data.size()) {
-        Buffer huffmanBuffer = new Buffer();
-        Huffman.get().encode(data, huffmanBuffer);
-        ByteString huffmanBytes = huffmanBuffer.readByteString();
-        writeInt(huffmanBytes.size(), PREFIX_7_BITS, 0x80);
-        out.write(huffmanBytes);
-      } else {
-        writeInt(data.size(), PREFIX_7_BITS, 0);
-        out.write(data);
-      }
-    }
-
-    void setHeaderTableSizeSetting(int headerTableSizeSetting) {
-      this.headerTableSizeSetting = headerTableSizeSetting;
-      int effectiveHeaderTableSize = Math.min(headerTableSizeSetting,
-          SETTINGS_HEADER_TABLE_SIZE_LIMIT);
-
-      if (maxDynamicTableByteCount == effectiveHeaderTableSize) return; // No change.
-
-      if (effectiveHeaderTableSize < maxDynamicTableByteCount) {
-        smallestHeaderTableSizeSetting = Math.min(smallestHeaderTableSizeSetting,
-            effectiveHeaderTableSize);
-      }
-      emitDynamicTableSizeUpdate = true;
-      maxDynamicTableByteCount = effectiveHeaderTableSize;
-      adjustDynamicTableByteCount();
-    }
-
-    private void adjustDynamicTableByteCount() {
-      if (maxDynamicTableByteCount < dynamicTableByteCount) {
-        if (maxDynamicTableByteCount == 0) {
-          clearDynamicTable();
-        } else {
-          evictToRecoverBytes(dynamicTableByteCount - maxDynamicTableByteCount);
-        }
-      }
-    }
-  }
-
-  /**
-   * An HTTP/2 response cannot contain uppercase header characters and must be treated as
-   * malformed.
-   */
-  static ByteString checkLowercase(ByteString name) throws IOException {
-    for (int i = 0, length = name.size(); i < length; i++) {
-      byte c = name.getByte(i);
-      if (c >= 'A' && c <= 'Z') {
-        throw new IOException("PROTOCOL_ERROR response malformed: mixed case name: " + name.utf8());
-      }
-    }
-    return name;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2.java
deleted file mode 100644
index cecee406ce..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2.java
+++ /dev/null
@@ -1,167 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import java.io.IOException;
-import okio.ByteString;
-
-import static okhttp3.internal.Util.format;
-
-public final class Http2 {
-  static final ByteString CONNECTION_PREFACE
-      = ByteString.encodeUtf8("PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n");
-
-  /** The initial max frame size, applied independently writing to, or reading from the peer. */
-  static final int INITIAL_MAX_FRAME_SIZE = 0x4000; // 16384
-
-  static final byte TYPE_DATA = 0x0;
-  static final byte TYPE_HEADERS = 0x1;
-  static final byte TYPE_PRIORITY = 0x2;
-  static final byte TYPE_RST_STREAM = 0x3;
-  static final byte TYPE_SETTINGS = 0x4;
-  static final byte TYPE_PUSH_PROMISE = 0x5;
-  static final byte TYPE_PING = 0x6;
-  static final byte TYPE_GOAWAY = 0x7;
-  static final byte TYPE_WINDOW_UPDATE = 0x8;
-  static final byte TYPE_CONTINUATION = 0x9;
-
-  static final byte FLAG_NONE = 0x0;
-  static final byte FLAG_ACK = 0x1; // Used for settings and ping.
-  static final byte FLAG_END_STREAM = 0x1; // Used for headers and data.
-  static final byte FLAG_END_HEADERS = 0x4; // Used for headers and continuation.
-  static final byte FLAG_END_PUSH_PROMISE = 0x4;
-  static final byte FLAG_PADDED = 0x8; // Used for headers and data.
-  static final byte FLAG_PRIORITY = 0x20; // Used for headers.
-  static final byte FLAG_COMPRESSED = 0x20; // Used for data.
-
-  /** Lookup table for valid frame types. */
-  private static final String[] FRAME_NAMES = new String[] {
-      "DATA",
-      "HEADERS",
-      "PRIORITY",
-      "RST_STREAM",
-      "SETTINGS",
-      "PUSH_PROMISE",
-      "PING",
-      "GOAWAY",
-      "WINDOW_UPDATE",
-      "CONTINUATION"
-  };
-
-  /**
-   * Lookup table for valid flags for DATA, HEADERS, CONTINUATION. Invalid combinations are
-   * represented in binary.
-   */
-  static final String[] FLAGS = new String[0x40]; // Highest bit flag is 0x20.
-  static final String[] BINARY = new String[256];
-  static {
-    for (int i = 0; i < BINARY.length; i++) {
-      BINARY[i] = format("%8s", Integer.toBinaryString(i)).replace(' ', '0');
-    }
-
-    FLAGS[FLAG_NONE] = "";
-    FLAGS[FLAG_END_STREAM] = "END_STREAM";
-
-    int[] prefixFlags = new int[] {FLAG_END_STREAM};
-
-    FLAGS[FLAG_PADDED] = "PADDED";
-    for (int prefixFlag : prefixFlags) {
-      FLAGS[prefixFlag | FLAG_PADDED] = FLAGS[prefixFlag] + "|PADDED";
-    }
-
-    FLAGS[FLAG_END_HEADERS] = "END_HEADERS"; // Same as END_PUSH_PROMISE.
-    FLAGS[FLAG_PRIORITY] = "PRIORITY"; // Same as FLAG_COMPRESSED.
-    FLAGS[FLAG_END_HEADERS | FLAG_PRIORITY] = "END_HEADERS|PRIORITY"; // Only valid on HEADERS.
-    int[] frameFlags = new int[] {
-        FLAG_END_HEADERS, FLAG_PRIORITY, FLAG_END_HEADERS | FLAG_PRIORITY
-    };
-
-    for (int frameFlag : frameFlags) {
-      for (int prefixFlag : prefixFlags) {
-        FLAGS[prefixFlag | frameFlag] = FLAGS[prefixFlag] + '|' + FLAGS[frameFlag];
-        FLAGS[prefixFlag | frameFlag | FLAG_PADDED]
-            = FLAGS[prefixFlag] + '|' + FLAGS[frameFlag] + "|PADDED";
-      }
-    }
-
-    for (int i = 0; i < FLAGS.length; i++) { // Fill in holes with binary representation.
-      if (FLAGS[i] == null) FLAGS[i] = BINARY[i];
-    }
-  }
-
-  private Http2() {
-  }
-
-  static IllegalArgumentException illegalArgument(String message, Object... args) {
-    throw new IllegalArgumentException(format(message, args));
-  }
-
-  static IOException ioException(String message, Object... args) throws IOException {
-    throw new IOException(format(message, args));
-  }
-
-  /**
-   * Returns human-readable representation of HTTP/2 frame headers.
-   *
-   * <p>The format is:
-   *
-   * <pre>
-   *   direction streamID length type flags
-   * </pre>
-   *
-   * Where direction is {@code <<} for inbound and {@code >>} for outbound.
-   *
-   * <p>For example, the following would indicate a HEAD request sent from the client.
-   * <pre>
-   * {@code
-   *   << 0x0000000f    12 HEADERS       END_HEADERS|END_STREAM
-   * }
-   * </pre>
-   */
-  static String frameLog(boolean inbound, int streamId, int length, byte type, byte flags) {
-    String formattedType = type < FRAME_NAMES.length ? FRAME_NAMES[type] : format("0x%02x", type);
-    String formattedFlags = formatFlags(type, flags);
-    return format("%s 0x%08x %5d %-13s %s", inbound ? "<<" : ">>", streamId, length,
-        formattedType, formattedFlags);
-  }
-
-  /**
-   * Looks up valid string representing flags from the table. Invalid combinations are represented
-   * in binary.
-   */
-  // Visible for testing.
-  static String formatFlags(byte type, byte flags) {
-    if (flags == 0) return "";
-    switch (type) { // Special case types that have 0 or 1 flag.
-      case TYPE_SETTINGS:
-      case TYPE_PING:
-        return flags == FLAG_ACK ? "ACK" : BINARY[flags];
-      case TYPE_PRIORITY:
-      case TYPE_RST_STREAM:
-      case TYPE_GOAWAY:
-      case TYPE_WINDOW_UPDATE:
-        return BINARY[flags];
-    }
-    String result = flags < FLAGS.length ? FLAGS[flags] : BINARY[flags];
-    // Special case types that have overlap flag values.
-    if (type == TYPE_PUSH_PROMISE && (flags & FLAG_END_PUSH_PROMISE) != 0) {
-      return result.replace("HEADERS", "PUSH_PROMISE"); // TODO: Avoid allocation.
-    } else if (type == TYPE_DATA && (flags & FLAG_COMPRESSED) != 0) {
-      return result.replace("PRIORITY", "COMPRESSED"); // TODO: Avoid allocation.
-    }
-    return result;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
deleted file mode 100644
index e981655040..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
+++ /dev/null
@@ -1,943 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.io.InterruptedIOException;
-import java.net.InetSocketAddress;
-import java.net.Socket;
-import java.net.SocketAddress;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.RejectedExecutionException;
-import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.ScheduledThreadPoolExecutor;
-import java.util.concurrent.SynchronousQueue;
-import java.util.concurrent.ThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;
-import javax.annotation.Nullable;
-import okhttp3.Headers;
-import okhttp3.internal.NamedRunnable;
-import okhttp3.internal.Util;
-import okhttp3.internal.platform.Platform;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.Okio;
-
-import static java.util.concurrent.TimeUnit.MILLISECONDS;
-import static okhttp3.internal.http2.ErrorCode.REFUSED_STREAM;
-import static okhttp3.internal.http2.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
-import static okhttp3.internal.platform.Platform.INFO;
-
-/**
- * A socket connection to a remote peer. A connection hosts streams which can send and receive
- * data.
- *
- * <p>Many methods in this API are <strong>synchronous:</strong> the call is completed before the
- * method returns. This is typical for Java but atypical for HTTP/2. This is motivated by exception
- * transparency: an IOException that was triggered by a certain caller can be caught and handled by
- * that caller.
- */
-public final class Http2Connection implements Closeable {
-
-  // Internal state of this connection is guarded by 'this'. No blocking
-  // operations may be performed while holding this lock!
-  //
-  // Socket writes are guarded by frameWriter.
-  //
-  // Socket reads are unguarded but are only made by the reader thread.
-  //
-  // Certain operations (like SYN_STREAM) need to synchronize on both the
-  // frameWriter (to do blocking I/O) and this (to create streams). Such
-  // operations must synchronize on 'this' last. This ensures that we never
-  // wait for a blocking operation while holding 'this'.
-
-  static final int OKHTTP_CLIENT_WINDOW_SIZE = 16 * 1024 * 1024;
-
-  /**
-   * Shared executor to send notifications of incoming streams. This executor requires multiple
-   * threads because listeners are not required to return promptly.
-   */
-  private static final ExecutorService listenerExecutor = new ThreadPoolExecutor(0,
-      Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue<>(),
-      Util.threadFactory("OkHttp Http2Connection", true));
-
-  /** True if this peer initiated the connection. */
-  final boolean client;
-
-  /**
-   * User code to run in response to incoming streams or settings. Calls to this are always invoked
-   * on {@link #listenerExecutor}.
-   */
-  final Listener listener;
-  final Map<Integer, Http2Stream> streams = new LinkedHashMap<>();
-  final String connectionName;
-  int lastGoodStreamId;
-  int nextStreamId;
-  boolean shutdown;
-
-  /** Asynchronously writes frames to the outgoing socket. */
-  private final ScheduledExecutorService writerExecutor;
-
-  /** Ensures push promise callbacks events are sent in order per stream. */
-  private final ExecutorService pushExecutor;
-
-  /** User code to run in response to push promise events. */
-  final PushObserver pushObserver;
-
-  /** True if we have sent a ping that is still awaiting a reply. */
-  private boolean awaitingPong;
-
-  /**
-   * The total number of bytes consumed by the application, but not yet acknowledged by sending a
-   * {@code WINDOW_UPDATE} frame on this connection.
-   */
-  // Visible for testing
-  long unacknowledgedBytesRead = 0;
-
-  /**
-   * Count of bytes that can be written on the connection before receiving a window update.
-   */
-  // Visible for testing
-  long bytesLeftInWriteWindow;
-
-  /** Settings we communicate to the peer. */
-  Settings okHttpSettings = new Settings();
-
-  /** Settings we receive from the peer. */
-  // TODO: MWS will need to guard on this setting before attempting to push.
-  final Settings peerSettings = new Settings();
-
-  boolean receivedInitialPeerSettings = false;
-  final Socket socket;
-  final Http2Writer writer;
-
-  // Visible for testing
-  final ReaderRunnable readerRunnable;
-
-  Http2Connection(Builder builder) {
-    pushObserver = builder.pushObserver;
-    client = builder.client;
-    listener = builder.listener;
-    // http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-5.1.1
-    nextStreamId = builder.client ? 1 : 2;
-    if (builder.client) {
-      nextStreamId += 2; // In HTTP/2, 1 on client is reserved for Upgrade.
-    }
-
-    // Flow control was designed more for servers, or proxies than edge clients.
-    // If we are a client, set the flow control window to 16MiB.  This avoids
-    // thrashing window updates every 64KiB, yet small enough to avoid blowing
-    // up the heap.
-    if (builder.client) {
-      okHttpSettings.set(Settings.INITIAL_WINDOW_SIZE, OKHTTP_CLIENT_WINDOW_SIZE);
-    }
-
-    connectionName = builder.connectionName;
-
-    writerExecutor = new ScheduledThreadPoolExecutor(1,
-        Util.threadFactory(Util.format("OkHttp %s Writer", connectionName), false));
-    if (builder.pingIntervalMillis != 0) {
-      writerExecutor.scheduleAtFixedRate(new PingRunnable(false, 0, 0),
-          builder.pingIntervalMillis, builder.pingIntervalMillis, MILLISECONDS);
-    }
-
-    // Like newSingleThreadExecutor, except lazy creates the thread.
-    pushExecutor = new ThreadPoolExecutor(0, 1, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<>(),
-        Util.threadFactory(Util.format("OkHttp %s Push Observer", connectionName), true));
-    peerSettings.set(Settings.INITIAL_WINDOW_SIZE, DEFAULT_INITIAL_WINDOW_SIZE);
-    peerSettings.set(Settings.MAX_FRAME_SIZE, Http2.INITIAL_MAX_FRAME_SIZE);
-    bytesLeftInWriteWindow = peerSettings.getInitialWindowSize();
-    socket = builder.socket;
-    writer = new Http2Writer(builder.sink, client);
-
-    readerRunnable = new ReaderRunnable(new Http2Reader(builder.source, client));
-  }
-
-  /**
-   * Returns the number of {@link Http2Stream#isOpen() open streams} on this connection.
-   */
-  public synchronized int openStreamCount() {
-    return streams.size();
-  }
-
-  synchronized Http2Stream getStream(int id) {
-    return streams.get(id);
-  }
-
-  synchronized Http2Stream removeStream(int streamId) {
-    Http2Stream stream = streams.remove(streamId);
-    notifyAll(); // The removed stream may be blocked on a connection-wide window update.
-    return stream;
-  }
-
-  public synchronized int maxConcurrentStreams() {
-    return peerSettings.getMaxConcurrentStreams(Integer.MAX_VALUE);
-  }
-
-  synchronized void updateConnectionFlowControl(long read) {
-    unacknowledgedBytesRead += read;
-    if (unacknowledgedBytesRead >= okHttpSettings.getInitialWindowSize() / 2) {
-      writeWindowUpdateLater(0, unacknowledgedBytesRead);
-      unacknowledgedBytesRead = 0;
-    }
-  }
-
-  /**
-   * Returns a new server-initiated stream.
-   *
-   * @param associatedStreamId the stream that triggered the sender to create this stream.
-   * @param out true to create an output stream that we can use to send data to the remote peer.
-   * Corresponds to {@code FLAG_FIN}.
-   */
-  public Http2Stream pushStream(int associatedStreamId, List<Header> requestHeaders, boolean out)
-      throws IOException {
-    if (client) throw new IllegalStateException("Client cannot push requests.");
-    return newStream(associatedStreamId, requestHeaders, out);
-  }
-
-  /**
-   * Returns a new locally-initiated stream.
-   * @param out true to create an output stream that we can use to send data to the remote peer.
-   * Corresponds to {@code FLAG_FIN}.
-   */
-  public Http2Stream newStream(List<Header> requestHeaders, boolean out) throws IOException {
-    return newStream(0, requestHeaders, out);
-  }
-
-  private Http2Stream newStream(
-      int associatedStreamId, List<Header> requestHeaders, boolean out) throws IOException {
-    boolean outFinished = !out;
-    boolean inFinished = false;
-    boolean flushHeaders;
-    Http2Stream stream;
-    int streamId;
-
-    synchronized (writer) {
-      synchronized (this) {
-        if (nextStreamId > Integer.MAX_VALUE / 2) {
-          shutdown(REFUSED_STREAM);
-        }
-        if (shutdown) {
-          throw new ConnectionShutdownException();
-        }
-        streamId = nextStreamId;
-        nextStreamId += 2;
-        stream = new Http2Stream(streamId, this, outFinished, inFinished, null);
-        flushHeaders = !out || bytesLeftInWriteWindow == 0L || stream.bytesLeftInWriteWindow == 0L;
-        if (stream.isOpen()) {
-          streams.put(streamId, stream);
-        }
-      }
-      if (associatedStreamId == 0) {
-        writer.headers(outFinished, streamId, requestHeaders);
-      } else if (client) {
-        throw new IllegalArgumentException("client streams shouldn't have associated stream IDs");
-      } else { // HTTP/2 has a PUSH_PROMISE frame.
-        writer.pushPromise(associatedStreamId, streamId, requestHeaders);
-      }
-    }
-
-    if (flushHeaders) {
-      writer.flush();
-    }
-
-    return stream;
-  }
-
-  void writeHeaders(int streamId, boolean outFinished, List<Header> alternating)
-      throws IOException {
-    writer.headers(outFinished, streamId, alternating);
-  }
-
-  /**
-   * Callers of this method are not thread safe, and sometimes on application threads. Most often,
-   * this method will be called to send a buffer worth of data to the peer.
-   *
-   * <p>Writes are subject to the write window of the stream and the connection. Until there is a
-   * window sufficient to send {@code byteCount}, the caller will block. For example, a user of
-   * {@code HttpURLConnection} who flushes more bytes to the output stream than the connection's
-   * write window will block.
-   *
-   * <p>Zero {@code byteCount} writes are not subject to flow control and will not block. The only
-   * use case for zero {@code byteCount} is closing a flushed output stream.
-   */
-  public void writeData(int streamId, boolean outFinished, Buffer buffer, long byteCount)
-      throws IOException {
-    if (byteCount == 0) { // Empty data frames are not flow-controlled.
-      writer.data(outFinished, streamId, buffer, 0);
-      return;
-    }
-
-    while (byteCount > 0) {
-      int toWrite;
-      synchronized (Http2Connection.this) {
-        try {
-          while (bytesLeftInWriteWindow <= 0) {
-            // Before blocking, confirm that the stream we're writing is still open. It's possible
-            // that the stream has since been closed (such as if this write timed out.)
-            if (!streams.containsKey(streamId)) {
-              throw new IOException("stream closed");
-            }
-            Http2Connection.this.wait(); // Wait until we receive a WINDOW_UPDATE.
-          }
-        } catch (InterruptedException e) {
-          Thread.currentThread().interrupt(); // Retain interrupted status.
-          throw new InterruptedIOException();
-        }
-
-        toWrite = (int) Math.min(byteCount, bytesLeftInWriteWindow);
-        toWrite = Math.min(toWrite, writer.maxDataLength());
-        bytesLeftInWriteWindow -= toWrite;
-      }
-
-      byteCount -= toWrite;
-      writer.data(outFinished && byteCount == 0, streamId, buffer, toWrite);
-    }
-  }
-
-  void writeSynResetLater(final int streamId, final ErrorCode errorCode) {
-    try {
-      writerExecutor.execute(new NamedRunnable("OkHttp %s stream %d", connectionName, streamId) {
-        @Override public void execute() {
-          try {
-            writeSynReset(streamId, errorCode);
-          } catch (IOException e) {
-            failConnection(e);
-          }
-        }
-      });
-    } catch (RejectedExecutionException ignored) {
-      // This connection has been closed.
-    }
-  }
-
-  void writeSynReset(int streamId, ErrorCode statusCode) throws IOException {
-    writer.rstStream(streamId, statusCode);
-  }
-
-  void writeWindowUpdateLater(final int streamId, final long unacknowledgedBytesRead) {
-    try {
-      writerExecutor.execute(
-          new NamedRunnable("OkHttp Window Update %s stream %d", connectionName, streamId) {
-            @Override public void execute() {
-              try {
-                writer.windowUpdate(streamId, unacknowledgedBytesRead);
-              } catch (IOException e) {
-                failConnection(e);
-              }
-            }
-          });
-    } catch (RejectedExecutionException ignored) {
-      // This connection has been closed.
-    }
-  }
-
-  final class PingRunnable extends NamedRunnable {
-    final boolean reply;
-    final int payload1;
-    final int payload2;
-
-    PingRunnable(boolean reply, int payload1, int payload2) {
-      super("OkHttp %s ping %08x%08x", connectionName, payload1, payload2);
-      this.reply = reply;
-      this.payload1 = payload1;
-      this.payload2 = payload2;
-    }
-
-    @Override public void execute() {
-      writePing(reply, payload1, payload2);
-    }
-  }
-
-  void writePing(boolean reply, int payload1, int payload2) {
-    if (!reply) {
-      boolean failedDueToMissingPong;
-      synchronized (this) {
-        failedDueToMissingPong = awaitingPong;
-        awaitingPong = true;
-      }
-      if (failedDueToMissingPong) {
-        failConnection(null);
-        return;
-      }
-    }
-
-    try {
-      writer.ping(reply, payload1, payload2);
-    } catch (IOException e) {
-      failConnection(e);
-    }
-  }
-
-  /** For testing: sends a ping and waits for a pong. */
-  void writePingAndAwaitPong() throws InterruptedException {
-    writePing(false, 0x4f4b6f6b /* "OKok" */, 0xf09f8da9 /* donut */);
-    awaitPong();
-  }
-
-  /** For testing: waits until {@code requiredPongCount} pings have been received from the peer. */
-  synchronized void awaitPong() throws InterruptedException {
-    while (awaitingPong) {
-      wait();
-    }
-  }
-
-  public void flush() throws IOException {
-    writer.flush();
-  }
-
-  /**
-   * Degrades this connection such that new streams can neither be created locally, nor accepted
-   * from the remote peer. Existing streams are not impacted. This is intended to permit an endpoint
-   * to gracefully stop accepting new requests without harming previously established streams.
-   */
-  public void shutdown(ErrorCode statusCode) throws IOException {
-    synchronized (writer) {
-      int lastGoodStreamId;
-      synchronized (this) {
-        if (shutdown) {
-          return;
-        }
-        shutdown = true;
-        lastGoodStreamId = this.lastGoodStreamId;
-      }
-      // TODO: propagate exception message into debugData.
-      // TODO: configure a timeout on the reader so that it doesn‚Äôt block forever.
-      writer.goAway(lastGoodStreamId, statusCode, Util.EMPTY_BYTE_ARRAY);
-    }
-  }
-
-  /**
-   * Closes this connection. This cancels all open streams and unanswered pings. It closes the
-   * underlying input and output streams and shuts down internal executor services.
-   */
-  @Override public void close() {
-    close(ErrorCode.NO_ERROR, ErrorCode.CANCEL, null);
-  }
-
-  void close(ErrorCode connectionCode, ErrorCode streamCode, @Nullable IOException cause) {
-    assert (!Thread.holdsLock(this));
-    try {
-      shutdown(connectionCode);
-    } catch (IOException ignored) {
-    }
-
-    Http2Stream[] streamsToClose = null;
-    synchronized (this) {
-      if (!streams.isEmpty()) {
-        streamsToClose = streams.values().toArray(new Http2Stream[streams.size()]);
-        streams.clear();
-      }
-    }
-
-    if (streamsToClose != null) {
-      for (Http2Stream stream : streamsToClose) {
-        try {
-          stream.close(streamCode, cause);
-        } catch (IOException ignored) {
-        }
-      }
-    }
-
-    // Close the writer to release its resources (such as deflaters).
-    try {
-      writer.close();
-    } catch (IOException ignored) {
-    }
-
-    // Close the socket to break out the reader thread, which will clean up after itself.
-    try {
-      socket.close();
-    } catch (IOException ignored) {
-    }
-
-    // Release the threads.
-    writerExecutor.shutdown();
-    pushExecutor.shutdown();
-  }
-
-  private void failConnection(@Nullable IOException e) {
-    close(ErrorCode.PROTOCOL_ERROR, ErrorCode.PROTOCOL_ERROR, e);
-  }
-
-  /**
-   * Sends any initial frames and starts reading frames from the remote peer. This should be called
-   * after {@link Builder#build} for all new connections.
-   */
-  public void start() throws IOException {
-    start(true);
-  }
-
-  /**
-   * @param sendConnectionPreface true to send connection preface frames. This should always be true
-   *     except for in tests that don't check for a connection preface.
-   */
-  void start(boolean sendConnectionPreface) throws IOException {
-    if (sendConnectionPreface) {
-      writer.connectionPreface();
-      writer.settings(okHttpSettings);
-      int windowSize = okHttpSettings.getInitialWindowSize();
-      if (windowSize != Settings.DEFAULT_INITIAL_WINDOW_SIZE) {
-        writer.windowUpdate(0, windowSize - Settings.DEFAULT_INITIAL_WINDOW_SIZE);
-      }
-    }
-    new Thread(readerRunnable).start(); // Not a daemon thread.
-  }
-
-  /** Merges {@code settings} into this peer's settings and sends them to the remote peer. */
-  public void setSettings(Settings settings) throws IOException {
-    synchronized (writer) {
-      synchronized (this) {
-        if (shutdown) {
-          throw new ConnectionShutdownException();
-        }
-        okHttpSettings.merge(settings);
-      }
-      writer.settings(settings);
-    }
-  }
-
-  public synchronized boolean isShutdown() {
-    return shutdown;
-  }
-
-  public static class Builder {
-    Socket socket;
-    String connectionName;
-    BufferedSource source;
-    BufferedSink sink;
-    Listener listener = Listener.REFUSE_INCOMING_STREAMS;
-    PushObserver pushObserver = PushObserver.CANCEL;
-    boolean client;
-    int pingIntervalMillis;
-
-    /**
-     * @param client true if this peer initiated the connection; false if this peer accepted the
-     * connection.
-     */
-    public Builder(boolean client) {
-      this.client = client;
-    }
-
-    public Builder socket(Socket socket) throws IOException {
-      SocketAddress remoteSocketAddress = socket.getRemoteSocketAddress();
-      String connectionName = remoteSocketAddress instanceof InetSocketAddress
-          ? ((InetSocketAddress) remoteSocketAddress).getHostName()
-          : remoteSocketAddress.toString();
-      return socket(socket, connectionName,
-          Okio.buffer(Okio.source(socket)), Okio.buffer(Okio.sink(socket)));
-    }
-
-    public Builder socket(
-        Socket socket, String connectionName, BufferedSource source, BufferedSink sink) {
-      this.socket = socket;
-      this.connectionName = connectionName;
-      this.source = source;
-      this.sink = sink;
-      return this;
-    }
-
-    public Builder listener(Listener listener) {
-      this.listener = listener;
-      return this;
-    }
-
-    public Builder pushObserver(PushObserver pushObserver) {
-      this.pushObserver = pushObserver;
-      return this;
-    }
-
-    public Builder pingIntervalMillis(int pingIntervalMillis) {
-      this.pingIntervalMillis = pingIntervalMillis;
-      return this;
-    }
-
-    public Http2Connection build() {
-      return new Http2Connection(this);
-    }
-  }
-
-  /**
-   * Methods in this class must not lock FrameWriter.  If a method needs to write a frame, create an
-   * async task to do so.
-   */
-  class ReaderRunnable extends NamedRunnable implements Http2Reader.Handler {
-    final Http2Reader reader;
-
-    ReaderRunnable(Http2Reader reader) {
-      super("OkHttp %s", connectionName);
-      this.reader = reader;
-    }
-
-    @Override protected void execute() {
-      ErrorCode connectionErrorCode = ErrorCode.INTERNAL_ERROR;
-      ErrorCode streamErrorCode = ErrorCode.INTERNAL_ERROR;
-      IOException errorException = null;
-      try {
-        reader.readConnectionPreface(this);
-        while (reader.nextFrame(false, this)) {
-        }
-        connectionErrorCode = ErrorCode.NO_ERROR;
-        streamErrorCode = ErrorCode.CANCEL;
-      } catch (IOException e) {
-        errorException = e;
-        connectionErrorCode = ErrorCode.PROTOCOL_ERROR;
-        streamErrorCode = ErrorCode.PROTOCOL_ERROR;
-      } finally {
-        close(connectionErrorCode, streamErrorCode, errorException);
-        Util.closeQuietly(reader);
-      }
-    }
-
-    @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
-        throws IOException {
-      if (pushedStream(streamId)) {
-        pushDataLater(streamId, source, length, inFinished);
-        return;
-      }
-      Http2Stream dataStream = getStream(streamId);
-      if (dataStream == null) {
-        writeSynResetLater(streamId, ErrorCode.PROTOCOL_ERROR);
-        updateConnectionFlowControl(length);
-        source.skip(length);
-        return;
-      }
-      dataStream.receiveData(source, length);
-      if (inFinished) {
-        dataStream.receiveHeaders(Util.EMPTY_HEADERS, true);
-      }
-    }
-
-    @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,
-        List<Header> headerBlock) {
-      if (pushedStream(streamId)) {
-        pushHeadersLater(streamId, headerBlock, inFinished);
-        return;
-      }
-      Http2Stream stream;
-      synchronized (Http2Connection.this) {
-        stream = getStream(streamId);
-
-        if (stream == null) {
-          // If we're shutdown, don't bother with this stream.
-          if (shutdown) return;
-
-          // If the stream ID is less than the last created ID, assume it's already closed.
-          if (streamId <= lastGoodStreamId) return;
-
-          // If the stream ID is in the client's namespace, assume it's already closed.
-          if (streamId % 2 == nextStreamId % 2) return;
-
-          // Create a stream.
-          Headers headers = Util.toHeaders(headerBlock);
-          final Http2Stream newStream = new Http2Stream(streamId, Http2Connection.this,
-              false, inFinished, headers);
-          lastGoodStreamId = streamId;
-          streams.put(streamId, newStream);
-          listenerExecutor.execute(new NamedRunnable(
-              "OkHttp %s stream %d", connectionName, streamId) {
-            @Override public void execute() {
-              try {
-                listener.onStream(newStream);
-              } catch (IOException e) {
-                Platform.get().log(
-                    INFO, "Http2Connection.Listener failure for " + connectionName, e);
-                try {
-                  newStream.close(ErrorCode.PROTOCOL_ERROR, e);
-                } catch (IOException ignored) {
-                }
-              }
-            }
-          });
-          return;
-        }
-      }
-
-      // Update an existing stream.
-      stream.receiveHeaders(Util.toHeaders(headerBlock), inFinished);
-    }
-
-    @Override public void rstStream(int streamId, ErrorCode errorCode) {
-      if (pushedStream(streamId)) {
-        pushResetLater(streamId, errorCode);
-        return;
-      }
-      Http2Stream rstStream = removeStream(streamId);
-      if (rstStream != null) {
-        rstStream.receiveRstStream(errorCode);
-      }
-    }
-
-    @Override public void settings(boolean clearPrevious, Settings newSettings) {
-      long delta = 0;
-      Http2Stream[] streamsToNotify = null;
-      synchronized (Http2Connection.this) {
-        int priorWriteWindowSize = peerSettings.getInitialWindowSize();
-        if (clearPrevious) peerSettings.clear();
-        peerSettings.merge(newSettings);
-        applyAndAckSettings(newSettings);
-        int peerInitialWindowSize = peerSettings.getInitialWindowSize();
-        if (peerInitialWindowSize != -1 && peerInitialWindowSize != priorWriteWindowSize) {
-          delta = peerInitialWindowSize - priorWriteWindowSize;
-          if (!receivedInitialPeerSettings) {
-            receivedInitialPeerSettings = true;
-          }
-          if (!streams.isEmpty()) {
-            streamsToNotify = streams.values().toArray(new Http2Stream[streams.size()]);
-          }
-        }
-        listenerExecutor.execute(new NamedRunnable("OkHttp %s settings", connectionName) {
-          @Override public void execute() {
-            listener.onSettings(Http2Connection.this);
-          }
-        });
-      }
-      if (streamsToNotify != null && delta != 0) {
-        for (Http2Stream stream : streamsToNotify) {
-          synchronized (stream) {
-            stream.addBytesToWriteWindow(delta);
-          }
-        }
-      }
-    }
-
-    private void applyAndAckSettings(final Settings peerSettings) {
-      try {
-        writerExecutor.execute(new NamedRunnable("OkHttp %s ACK Settings", connectionName) {
-          @Override public void execute() {
-            try {
-              writer.applyAndAckSettings(peerSettings);
-            } catch (IOException e) {
-              failConnection(e);
-            }
-          }
-        });
-      } catch (RejectedExecutionException ignored) {
-        // This connection has been closed.
-      }
-    }
-
-    @Override public void ackSettings() {
-      // TODO: If we don't get this callback after sending settings to the peer, SETTINGS_TIMEOUT.
-    }
-
-    @Override public void ping(boolean reply, int payload1, int payload2) {
-      if (reply) {
-        synchronized (Http2Connection.this) {
-          awaitingPong = false;
-          Http2Connection.this.notifyAll();
-        }
-      } else {
-        try {
-          // Send a reply to a client ping if this is a server and vice versa.
-          writerExecutor.execute(new PingRunnable(true, payload1, payload2));
-        } catch (RejectedExecutionException ignored) {
-          // This connection has been closed.
-        }
-      }
-    }
-
-    @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
-      if (debugData.size() > 0) { // TODO: log the debugData
-      }
-
-      // Copy the streams first. We don't want to hold a lock when we call receiveRstStream().
-      Http2Stream[] streamsCopy;
-      synchronized (Http2Connection.this) {
-        streamsCopy = streams.values().toArray(new Http2Stream[streams.size()]);
-        shutdown = true;
-      }
-
-      // Fail all streams created after the last good stream ID.
-      for (Http2Stream http2Stream : streamsCopy) {
-        if (http2Stream.getId() > lastGoodStreamId && http2Stream.isLocallyInitiated()) {
-          http2Stream.receiveRstStream(REFUSED_STREAM);
-          removeStream(http2Stream.getId());
-        }
-      }
-    }
-
-    @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
-      if (streamId == 0) {
-        synchronized (Http2Connection.this) {
-          bytesLeftInWriteWindow += windowSizeIncrement;
-          Http2Connection.this.notifyAll();
-        }
-      } else {
-        Http2Stream stream = getStream(streamId);
-        if (stream != null) {
-          synchronized (stream) {
-            stream.addBytesToWriteWindow(windowSizeIncrement);
-          }
-        }
-      }
-    }
-
-    @Override public void priority(int streamId, int streamDependency, int weight,
-        boolean exclusive) {
-      // TODO: honor priority.
-    }
-
-    @Override
-    public void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders) {
-      pushRequestLater(promisedStreamId, requestHeaders);
-    }
-
-    @Override public void alternateService(int streamId, String origin, ByteString protocol,
-        String host, int port, long maxAge) {
-      // TODO: register alternate service.
-    }
-  }
-
-  /** Even, positive numbered streams are pushed streams in HTTP/2. */
-  boolean pushedStream(int streamId) {
-    return streamId != 0 && (streamId & 1) == 0;
-  }
-
-  // Guarded by this.
-  final Set<Integer> currentPushRequests = new LinkedHashSet<>();
-
-  void pushRequestLater(final int streamId, final List<Header> requestHeaders) {
-    synchronized (this) {
-      if (currentPushRequests.contains(streamId)) {
-        writeSynResetLater(streamId, ErrorCode.PROTOCOL_ERROR);
-        return;
-      }
-      currentPushRequests.add(streamId);
-    }
-    try {
-      pushExecutorExecute(new NamedRunnable(
-          "OkHttp %s Push Request[%s]", connectionName, streamId) {
-        @Override public void execute() {
-          boolean cancel = pushObserver.onRequest(streamId, requestHeaders);
-          try {
-            if (cancel) {
-              writer.rstStream(streamId, ErrorCode.CANCEL);
-              synchronized (Http2Connection.this) {
-                currentPushRequests.remove(streamId);
-              }
-            }
-          } catch (IOException ignored) {
-          }
-        }
-      });
-    } catch (RejectedExecutionException ignored) {
-      // This connection has been closed.
-    }
-  }
-
-  void pushHeadersLater(final int streamId, final List<Header> requestHeaders,
-      final boolean inFinished) {
-    try {
-      pushExecutorExecute(new NamedRunnable(
-          "OkHttp %s Push Headers[%s]", connectionName, streamId) {
-        @Override public void execute() {
-          boolean cancel = pushObserver.onHeaders(streamId, requestHeaders, inFinished);
-          try {
-            if (cancel) writer.rstStream(streamId, ErrorCode.CANCEL);
-            if (cancel || inFinished) {
-              synchronized (Http2Connection.this) {
-                currentPushRequests.remove(streamId);
-              }
-            }
-          } catch (IOException ignored) {
-          }
-        }
-      });
-    } catch (RejectedExecutionException ignored) {
-      // This connection has been closed.
-    }
-  }
-
-  /**
-   * Eagerly reads {@code byteCount} bytes from the source before launching a background task to
-   * process the data.  This avoids corrupting the stream.
-   */
-  void pushDataLater(final int streamId, final BufferedSource source, final int byteCount,
-      final boolean inFinished) throws IOException {
-    final Buffer buffer = new Buffer();
-    source.require(byteCount); // Eagerly read the frame before firing client thread.
-    source.read(buffer, byteCount);
-    if (buffer.size() != byteCount) throw new IOException(buffer.size() + " != " + byteCount);
-    pushExecutorExecute(new NamedRunnable("OkHttp %s Push Data[%s]", connectionName, streamId) {
-      @Override public void execute() {
-        try {
-          boolean cancel = pushObserver.onData(streamId, buffer, byteCount, inFinished);
-          if (cancel) writer.rstStream(streamId, ErrorCode.CANCEL);
-          if (cancel || inFinished) {
-            synchronized (Http2Connection.this) {
-              currentPushRequests.remove(streamId);
-            }
-          }
-        } catch (IOException ignored) {
-        }
-      }
-    });
-  }
-
-  void pushResetLater(final int streamId, final ErrorCode errorCode) {
-    pushExecutorExecute(new NamedRunnable("OkHttp %s Push Reset[%s]", connectionName, streamId) {
-      @Override public void execute() {
-        pushObserver.onReset(streamId, errorCode);
-        synchronized (Http2Connection.this) {
-          currentPushRequests.remove(streamId);
-        }
-      }
-    });
-  }
-
-  private synchronized void pushExecutorExecute(NamedRunnable namedRunnable) {
-    if (!isShutdown()) {
-      pushExecutor.execute(namedRunnable);
-    }
-  }
-
-  /** Listener of streams and settings initiated by the peer. */
-  public abstract static class Listener {
-    public static final Listener REFUSE_INCOMING_STREAMS = new Listener() {
-      @Override public void onStream(Http2Stream stream) throws IOException {
-        stream.close(REFUSED_STREAM, null);
-      }
-    };
-
-    /**
-     * Handle a new stream from this connection's peer. Implementations should respond by either
-     * {@linkplain Http2Stream#writeHeaders replying to the stream} or {@linkplain
-     * Http2Stream#close closing it}. This response does not need to be synchronous.
-     */
-    public abstract void onStream(Http2Stream stream) throws IOException;
-
-    /**
-     * Notification that the connection's peer's settings may have changed. Implementations should
-     * take appropriate action to handle the updated settings.
-     *
-     * <p>It is the implementation's responsibility to handle concurrent calls to this method. A
-     * remote peer that sends multiple settings frames will trigger multiple calls to this method,
-     * and those calls are not necessarily serialized.
-     */
-    public void onSettings(Http2Connection connection) {
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2ExchangeCodec.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2ExchangeCodec.java
deleted file mode 100644
index 8d6f2ecdc7..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2ExchangeCodec.java
+++ /dev/null
@@ -1,205 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Locale;
-import java.util.concurrent.TimeUnit;
-import okhttp3.Headers;
-import okhttp3.Interceptor;
-import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.Internal;
-import okhttp3.internal.Util;
-import okhttp3.internal.connection.RealConnection;
-import okhttp3.internal.http.ExchangeCodec;
-import okhttp3.internal.http.HttpHeaders;
-import okhttp3.internal.http.RequestLine;
-import okhttp3.internal.http.StatusLine;
-import okio.Sink;
-import okio.Source;
-
-import static okhttp3.internal.http.StatusLine.HTTP_CONTINUE;
-import static okhttp3.internal.http2.Header.RESPONSE_STATUS_UTF8;
-import static okhttp3.internal.http2.Header.TARGET_AUTHORITY;
-import static okhttp3.internal.http2.Header.TARGET_AUTHORITY_UTF8;
-import static okhttp3.internal.http2.Header.TARGET_METHOD;
-import static okhttp3.internal.http2.Header.TARGET_METHOD_UTF8;
-import static okhttp3.internal.http2.Header.TARGET_PATH;
-import static okhttp3.internal.http2.Header.TARGET_PATH_UTF8;
-import static okhttp3.internal.http2.Header.TARGET_SCHEME;
-import static okhttp3.internal.http2.Header.TARGET_SCHEME_UTF8;
-
-/** Encode requests and responses using HTTP/2 frames. */
-public final class Http2ExchangeCodec implements ExchangeCodec {
-  private static final String CONNECTION = "connection";
-  private static final String HOST = "host";
-  private static final String KEEP_ALIVE = "keep-alive";
-  private static final String PROXY_CONNECTION = "proxy-connection";
-  private static final String TRANSFER_ENCODING = "transfer-encoding";
-  private static final String TE = "te";
-  private static final String ENCODING = "encoding";
-  private static final String UPGRADE = "upgrade";
-
-  /** See http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-8.1.3. */
-  private static final List<String> HTTP_2_SKIPPED_REQUEST_HEADERS = Util.immutableList(
-      CONNECTION,
-      HOST,
-      KEEP_ALIVE,
-      PROXY_CONNECTION,
-      TE,
-      TRANSFER_ENCODING,
-      ENCODING,
-      UPGRADE,
-      TARGET_METHOD_UTF8,
-      TARGET_PATH_UTF8,
-      TARGET_SCHEME_UTF8,
-      TARGET_AUTHORITY_UTF8);
-  private static final List<String> HTTP_2_SKIPPED_RESPONSE_HEADERS = Util.immutableList(
-      CONNECTION,
-      HOST,
-      KEEP_ALIVE,
-      PROXY_CONNECTION,
-      TE,
-      TRANSFER_ENCODING,
-      ENCODING,
-      UPGRADE);
-
-  private final Interceptor.Chain chain;
-  private final RealConnection realConnection;
-  private final Http2Connection connection;
-  private volatile Http2Stream stream;
-  private final Protocol protocol;
-  private volatile boolean canceled;
-
-  public Http2ExchangeCodec(OkHttpClient client, RealConnection realConnection,
-      Interceptor.Chain chain, Http2Connection connection) {
-    this.realConnection = realConnection;
-    this.chain = chain;
-    this.connection = connection;
-    this.protocol = client.protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)
-        ? Protocol.H2_PRIOR_KNOWLEDGE
-        : Protocol.HTTP_2;
-  }
-
-  @Override public RealConnection connection() {
-    return realConnection;
-  }
-
-  @Override public Sink createRequestBody(Request request, long contentLength) {
-    return stream.getSink();
-  }
-
-  @Override public void writeRequestHeaders(Request request) throws IOException {
-    if (stream != null) return;
-
-    boolean hasRequestBody = request.body() != null;
-    List<Header> requestHeaders = http2HeadersList(request);
-    stream = connection.newStream(requestHeaders, hasRequestBody);
-    // We may have been asked to cancel while creating the new stream and sending the request
-    // headers, but there was still no stream to close.
-    if (canceled) {
-      stream.closeLater(ErrorCode.CANCEL);
-      throw new IOException("Canceled");
-    }
-    stream.readTimeout().timeout(chain.readTimeoutMillis(), TimeUnit.MILLISECONDS);
-    stream.writeTimeout().timeout(chain.writeTimeoutMillis(), TimeUnit.MILLISECONDS);
-  }
-
-  @Override public void flushRequest() throws IOException {
-    connection.flush();
-  }
-
-  @Override public void finishRequest() throws IOException {
-    stream.getSink().close();
-  }
-
-  @Override public Response.Builder readResponseHeaders(boolean expectContinue) throws IOException {
-    Headers headers = stream.takeHeaders();
-    Response.Builder responseBuilder = readHttp2HeadersList(headers, protocol);
-    if (expectContinue && Internal.instance.code(responseBuilder) == HTTP_CONTINUE) {
-      return null;
-    }
-    return responseBuilder;
-  }
-
-  public static List<Header> http2HeadersList(Request request) {
-    Headers headers = request.headers();
-    List<Header> result = new ArrayList<>(headers.size() + 4);
-    result.add(new Header(TARGET_METHOD, request.method()));
-    result.add(new Header(TARGET_PATH, RequestLine.requestPath(request.url())));
-    String host = request.header("Host");
-    if (host != null) {
-      result.add(new Header(TARGET_AUTHORITY, host)); // Optional.
-    }
-    result.add(new Header(TARGET_SCHEME, request.url().scheme()));
-
-    for (int i = 0, size = headers.size(); i < size; i++) {
-      // header names must be lowercase.
-      String name = headers.name(i).toLowerCase(Locale.US);
-      if (!HTTP_2_SKIPPED_REQUEST_HEADERS.contains(name)
-          || name.equals(TE) && headers.value(i).equals("trailers")) {
-        result.add(new Header(name, headers.value(i)));
-      }
-    }
-    return result;
-  }
-
-  /** Returns headers for a name value block containing an HTTP/2 response. */
-  public static Response.Builder readHttp2HeadersList(Headers headerBlock,
-      Protocol protocol) throws IOException {
-    StatusLine statusLine = null;
-    Headers.Builder headersBuilder = new Headers.Builder();
-    for (int i = 0, size = headerBlock.size(); i < size; i++) {
-      String name = headerBlock.name(i);
-      String value = headerBlock.value(i);
-      if (name.equals(RESPONSE_STATUS_UTF8)) {
-        statusLine = StatusLine.parse("HTTP/1.1 " + value);
-      } else if (!HTTP_2_SKIPPED_RESPONSE_HEADERS.contains(name)) {
-        Internal.instance.addLenient(headersBuilder, name, value);
-      }
-    }
-    if (statusLine == null) throw new ProtocolException("Expected ':status' header not present");
-
-    return new Response.Builder()
-        .protocol(protocol)
-        .code(statusLine.code)
-        .message(statusLine.message)
-        .headers(headersBuilder.build());
-  }
-
-  @Override public long reportedContentLength(Response response) {
-    return HttpHeaders.contentLength(response);
-  }
-
-  @Override public Source openResponseBodySource(Response response) {
-    return stream.getSource();
-  }
-
-  @Override public Headers trailers() throws IOException {
-    return stream.trailers();
-  }
-
-  @Override public void cancel() {
-    canceled = true;
-    if (stream != null) stream.closeLater(ErrorCode.CANCEL);
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java
deleted file mode 100644
index 3137131126..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java
+++ /dev/null
@@ -1,506 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import java.io.Closeable;
-import java.io.EOFException;
-import java.io.IOException;
-import java.util.List;
-import java.util.logging.Logger;
-import okio.Buffer;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.Source;
-import okio.Timeout;
-
-import static java.util.logging.Level.FINE;
-import static okhttp3.internal.Util.format;
-import static okhttp3.internal.http2.Http2.CONNECTION_PREFACE;
-import static okhttp3.internal.http2.Http2.FLAG_ACK;
-import static okhttp3.internal.http2.Http2.FLAG_COMPRESSED;
-import static okhttp3.internal.http2.Http2.FLAG_END_HEADERS;
-import static okhttp3.internal.http2.Http2.FLAG_END_STREAM;
-import static okhttp3.internal.http2.Http2.FLAG_PADDED;
-import static okhttp3.internal.http2.Http2.FLAG_PRIORITY;
-import static okhttp3.internal.http2.Http2.INITIAL_MAX_FRAME_SIZE;
-import static okhttp3.internal.http2.Http2.TYPE_CONTINUATION;
-import static okhttp3.internal.http2.Http2.TYPE_DATA;
-import static okhttp3.internal.http2.Http2.TYPE_GOAWAY;
-import static okhttp3.internal.http2.Http2.TYPE_HEADERS;
-import static okhttp3.internal.http2.Http2.TYPE_PING;
-import static okhttp3.internal.http2.Http2.TYPE_PRIORITY;
-import static okhttp3.internal.http2.Http2.TYPE_PUSH_PROMISE;
-import static okhttp3.internal.http2.Http2.TYPE_RST_STREAM;
-import static okhttp3.internal.http2.Http2.TYPE_SETTINGS;
-import static okhttp3.internal.http2.Http2.TYPE_WINDOW_UPDATE;
-import static okhttp3.internal.http2.Http2.frameLog;
-import static okhttp3.internal.http2.Http2.ioException;
-import static okio.ByteString.EMPTY;
-
-/**
- * Reads HTTP/2 transport frames.
- *
- * <p>This implementation assumes we do not send an increased {@link Settings#getMaxFrameSize frame
- * size setting} to the peer. Hence, we expect all frames to have a max length of {@link
- * Http2#INITIAL_MAX_FRAME_SIZE}.
- */
-final class Http2Reader implements Closeable {
-  static final Logger logger = Logger.getLogger(Http2.class.getName());
-
-  private final BufferedSource source;
-  private final ContinuationSource continuation;
-  private final boolean client;
-
-  // Visible for testing.
-  final Hpack.Reader hpackReader;
-
-  /** Creates a frame reader with max header table size of 4096. */
-  Http2Reader(BufferedSource source, boolean client) {
-    this.source = source;
-    this.client = client;
-    this.continuation = new ContinuationSource(this.source);
-    this.hpackReader = new Hpack.Reader(4096, continuation);
-  }
-
-  public void readConnectionPreface(Handler handler) throws IOException {
-    if (client) {
-      // The client reads the initial SETTINGS frame.
-      if (!nextFrame(true, handler)) {
-        throw ioException("Required SETTINGS preface not received");
-      }
-    } else {
-      // The server reads the CONNECTION_PREFACE byte string.
-      ByteString connectionPreface = source.readByteString(CONNECTION_PREFACE.size());
-      if (logger.isLoggable(FINE)) logger.fine(format("<< CONNECTION %s", connectionPreface.hex()));
-      if (!CONNECTION_PREFACE.equals(connectionPreface)) {
-        throw ioException("Expected a connection header but was %s", connectionPreface.utf8());
-      }
-    }
-  }
-
-  public boolean nextFrame(boolean requireSettings, Handler handler) throws IOException {
-    try {
-      source.require(9); // Frame header size
-    } catch (EOFException e) {
-      return false; // This might be a normal socket close.
-    }
-
-    //  0                   1                   2                   3
-    //  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
-    // +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    // |                 Length (24)                   |
-    // +---------------+---------------+---------------+
-    // |   Type (8)    |   Flags (8)   |
-    // +-+-+-----------+---------------+-------------------------------+
-    // |R|                 Stream Identifier (31)                      |
-    // +=+=============================================================+
-    // |                   Frame Payload (0...)                      ...
-    // +---------------------------------------------------------------+
-    int length = readMedium(source);
-    if (length < 0 || length > INITIAL_MAX_FRAME_SIZE) {
-      throw ioException("FRAME_SIZE_ERROR: %s", length);
-    }
-    byte type = (byte) (source.readByte() & 0xff);
-    if (requireSettings && type != TYPE_SETTINGS) {
-      throw ioException("Expected a SETTINGS frame but was %s", type);
-    }
-    byte flags = (byte) (source.readByte() & 0xff);
-    int streamId = (source.readInt() & 0x7fffffff); // Ignore reserved bit.
-    if (logger.isLoggable(FINE)) logger.fine(frameLog(true, streamId, length, type, flags));
-
-    switch (type) {
-      case TYPE_DATA:
-        readData(handler, length, flags, streamId);
-        break;
-
-      case TYPE_HEADERS:
-        readHeaders(handler, length, flags, streamId);
-        break;
-
-      case TYPE_PRIORITY:
-        readPriority(handler, length, flags, streamId);
-        break;
-
-      case TYPE_RST_STREAM:
-        readRstStream(handler, length, flags, streamId);
-        break;
-
-      case TYPE_SETTINGS:
-        readSettings(handler, length, flags, streamId);
-        break;
-
-      case TYPE_PUSH_PROMISE:
-        readPushPromise(handler, length, flags, streamId);
-        break;
-
-      case TYPE_PING:
-        readPing(handler, length, flags, streamId);
-        break;
-
-      case TYPE_GOAWAY:
-        readGoAway(handler, length, flags, streamId);
-        break;
-
-      case TYPE_WINDOW_UPDATE:
-        readWindowUpdate(handler, length, flags, streamId);
-        break;
-
-      default:
-        // Implementations MUST discard frames that have unknown or unsupported types.
-        source.skip(length);
-    }
-    return true;
-  }
-
-  private void readHeaders(Handler handler, int length, byte flags, int streamId)
-      throws IOException {
-    if (streamId == 0) throw ioException("PROTOCOL_ERROR: TYPE_HEADERS streamId == 0");
-
-    boolean endStream = (flags & FLAG_END_STREAM) != 0;
-
-    short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
-
-    if ((flags & FLAG_PRIORITY) != 0) {
-      readPriority(handler, streamId);
-      length -= 5; // account for above read.
-    }
-
-    length = lengthWithoutPadding(length, flags, padding);
-
-    List<Header> headerBlock = readHeaderBlock(length, padding, flags, streamId);
-
-    handler.headers(endStream, streamId, -1, headerBlock);
-  }
-
-  private List<Header> readHeaderBlock(int length, short padding, byte flags, int streamId)
-      throws IOException {
-    continuation.length = continuation.left = length;
-    continuation.padding = padding;
-    continuation.flags = flags;
-    continuation.streamId = streamId;
-
-    // TODO: Concat multi-value headers with 0x0, except COOKIE, which uses 0x3B, 0x20.
-    // http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-8.1.2.5
-    hpackReader.readHeaders();
-    return hpackReader.getAndResetHeaderList();
-  }
-
-  private void readData(Handler handler, int length, byte flags, int streamId)
-      throws IOException {
-    if (streamId == 0) throw ioException("PROTOCOL_ERROR: TYPE_DATA streamId == 0");
-
-    // TODO: checkState open or half-closed (local) or raise STREAM_CLOSED
-    boolean inFinished = (flags & FLAG_END_STREAM) != 0;
-    boolean gzipped = (flags & FLAG_COMPRESSED) != 0;
-    if (gzipped) {
-      throw ioException("PROTOCOL_ERROR: FLAG_COMPRESSED without SETTINGS_COMPRESS_DATA");
-    }
-
-    short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
-    length = lengthWithoutPadding(length, flags, padding);
-
-    handler.data(inFinished, streamId, source, length);
-    source.skip(padding);
-  }
-
-  private void readPriority(Handler handler, int length, byte flags, int streamId)
-      throws IOException {
-    if (length != 5) throw ioException("TYPE_PRIORITY length: %d != 5", length);
-    if (streamId == 0) throw ioException("TYPE_PRIORITY streamId == 0");
-    readPriority(handler, streamId);
-  }
-
-  private void readPriority(Handler handler, int streamId) throws IOException {
-    int w1 = source.readInt();
-    boolean exclusive = (w1 & 0x80000000) != 0;
-    int streamDependency = (w1 & 0x7fffffff);
-    int weight = (source.readByte() & 0xff) + 1;
-    handler.priority(streamId, streamDependency, weight, exclusive);
-  }
-
-  private void readRstStream(Handler handler, int length, byte flags, int streamId)
-      throws IOException {
-    if (length != 4) throw ioException("TYPE_RST_STREAM length: %d != 4", length);
-    if (streamId == 0) throw ioException("TYPE_RST_STREAM streamId == 0");
-    int errorCodeInt = source.readInt();
-    ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
-    if (errorCode == null) {
-      throw ioException("TYPE_RST_STREAM unexpected error code: %d", errorCodeInt);
-    }
-    handler.rstStream(streamId, errorCode);
-  }
-
-  private void readSettings(Handler handler, int length, byte flags, int streamId)
-      throws IOException {
-    if (streamId != 0) throw ioException("TYPE_SETTINGS streamId != 0");
-    if ((flags & FLAG_ACK) != 0) {
-      if (length != 0) throw ioException("FRAME_SIZE_ERROR ack frame should be empty!");
-      handler.ackSettings();
-      return;
-    }
-
-    if (length % 6 != 0) throw ioException("TYPE_SETTINGS length %% 6 != 0: %s", length);
-    Settings settings = new Settings();
-    for (int i = 0; i < length; i += 6) {
-      int id = source.readShort() & 0xFFFF;
-      int value = source.readInt();
-
-      switch (id) {
-        case 1: // SETTINGS_HEADER_TABLE_SIZE
-          break;
-        case 2: // SETTINGS_ENABLE_PUSH
-          if (value != 0 && value != 1) {
-            throw ioException("PROTOCOL_ERROR SETTINGS_ENABLE_PUSH != 0 or 1");
-          }
-          break;
-        case 3: // SETTINGS_MAX_CONCURRENT_STREAMS
-          id = 4; // Renumbered in draft 10.
-          break;
-        case 4: // SETTINGS_INITIAL_WINDOW_SIZE
-          id = 7; // Renumbered in draft 10.
-          if (value < 0) {
-            throw ioException("PROTOCOL_ERROR SETTINGS_INITIAL_WINDOW_SIZE > 2^31 - 1");
-          }
-          break;
-        case 5: // SETTINGS_MAX_FRAME_SIZE
-          if (value < INITIAL_MAX_FRAME_SIZE || value > 16777215) {
-            throw ioException("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: %s", value);
-          }
-          break;
-        case 6: // SETTINGS_MAX_HEADER_LIST_SIZE
-          break; // Advisory only, so ignored.
-        default:
-          break; // Must ignore setting with unknown id.
-      }
-      settings.set(id, value);
-    }
-    handler.settings(false, settings);
-  }
-
-  private void readPushPromise(Handler handler, int length, byte flags, int streamId)
-      throws IOException {
-    if (streamId == 0) {
-      throw ioException("PROTOCOL_ERROR: TYPE_PUSH_PROMISE streamId == 0");
-    }
-    short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
-    int promisedStreamId = source.readInt() & 0x7fffffff;
-    length -= 4; // account for above read.
-    length = lengthWithoutPadding(length, flags, padding);
-    List<Header> headerBlock = readHeaderBlock(length, padding, flags, streamId);
-    handler.pushPromise(streamId, promisedStreamId, headerBlock);
-  }
-
-  private void readPing(Handler handler, int length, byte flags, int streamId)
-      throws IOException {
-    if (length != 8) throw ioException("TYPE_PING length != 8: %s", length);
-    if (streamId != 0) throw ioException("TYPE_PING streamId != 0");
-    int payload1 = source.readInt();
-    int payload2 = source.readInt();
-    boolean ack = (flags & FLAG_ACK) != 0;
-    handler.ping(ack, payload1, payload2);
-  }
-
-  private void readGoAway(Handler handler, int length, byte flags, int streamId)
-      throws IOException {
-    if (length < 8) throw ioException("TYPE_GOAWAY length < 8: %s", length);
-    if (streamId != 0) throw ioException("TYPE_GOAWAY streamId != 0");
-    int lastStreamId = source.readInt();
-    int errorCodeInt = source.readInt();
-    int opaqueDataLength = length - 8;
-    ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
-    if (errorCode == null) {
-      throw ioException("TYPE_GOAWAY unexpected error code: %d", errorCodeInt);
-    }
-    ByteString debugData = EMPTY;
-    if (opaqueDataLength > 0) { // Must read debug data in order to not corrupt the connection.
-      debugData = source.readByteString(opaqueDataLength);
-    }
-    handler.goAway(lastStreamId, errorCode, debugData);
-  }
-
-  private void readWindowUpdate(Handler handler, int length, byte flags, int streamId)
-      throws IOException {
-    if (length != 4) throw ioException("TYPE_WINDOW_UPDATE length !=4: %s", length);
-    long increment = (source.readInt() & 0x7fffffffL);
-    if (increment == 0) throw ioException("windowSizeIncrement was 0", increment);
-    handler.windowUpdate(streamId, increment);
-  }
-
-  @Override public void close() throws IOException {
-    source.close();
-  }
-
-  /**
-   * Decompression of the header block occurs above the framing layer. This class lazily reads
-   * continuation frames as they are needed by {@link Hpack.Reader#readHeaders()}.
-   */
-  static final class ContinuationSource implements Source {
-    private final BufferedSource source;
-
-    int length;
-    byte flags;
-    int streamId;
-
-    int left;
-    short padding;
-
-    ContinuationSource(BufferedSource source) {
-      this.source = source;
-    }
-
-    @Override public long read(Buffer sink, long byteCount) throws IOException {
-      while (left == 0) {
-        source.skip(padding);
-        padding = 0;
-        if ((flags & FLAG_END_HEADERS) != 0) return -1;
-        readContinuationHeader();
-        // TODO: test case for empty continuation header?
-      }
-
-      long read = source.read(sink, Math.min(byteCount, left));
-      if (read == -1) return -1;
-      left -= read;
-      return read;
-    }
-
-    @Override public Timeout timeout() {
-      return source.timeout();
-    }
-
-    @Override public void close() throws IOException {
-    }
-
-    private void readContinuationHeader() throws IOException {
-      int previousStreamId = streamId;
-
-      length = left = readMedium(source);
-      byte type = (byte) (source.readByte() & 0xff);
-      flags = (byte) (source.readByte() & 0xff);
-      if (logger.isLoggable(FINE)) logger.fine(frameLog(true, streamId, length, type, flags));
-      streamId = (source.readInt() & 0x7fffffff);
-      if (type != TYPE_CONTINUATION) throw ioException("%s != TYPE_CONTINUATION", type);
-      if (streamId != previousStreamId) throw ioException("TYPE_CONTINUATION streamId changed");
-    }
-  }
-
-  static int readMedium(BufferedSource source) throws IOException {
-    return (source.readByte() & 0xff) << 16
-        | (source.readByte() & 0xff) << 8
-        | (source.readByte() & 0xff);
-  }
-
-  static int lengthWithoutPadding(int length, byte flags, short padding)
-      throws IOException {
-    if ((flags & FLAG_PADDED) != 0) length--; // Account for reading the padding length.
-    if (padding > length) {
-      throw ioException("PROTOCOL_ERROR padding %s > remaining length %s", padding, length);
-    }
-    return (short) (length - padding);
-  }
-
-  interface Handler {
-    void data(boolean inFinished, int streamId, BufferedSource source, int length)
-        throws IOException;
-
-    /**
-     * Create or update incoming headers, creating the corresponding streams if necessary. Frames
-     * that trigger this are HEADERS and PUSH_PROMISE.
-     *
-     * @param inFinished true if the sender will not send further frames.
-     * @param streamId the stream owning these headers.
-     * @param associatedStreamId the stream that triggered the sender to create this stream.
-     */
-    void headers(boolean inFinished, int streamId, int associatedStreamId,
-        List<Header> headerBlock);
-
-    void rstStream(int streamId, ErrorCode errorCode);
-
-    void settings(boolean clearPrevious, Settings settings);
-
-    /** HTTP/2 only. */
-    void ackSettings();
-
-    /**
-     * Read a connection-level ping from the peer. {@code ack} indicates this is a reply. The data
-     * in {@code payload1} and {@code payload2} opaque binary, and there are no rules on the
-     * content.
-     */
-    void ping(boolean ack, int payload1, int payload2);
-
-    /**
-     * The peer tells us to stop creating streams.  It is safe to replay streams with {@code ID >
-     * lastGoodStreamId} on a new connection.  In- flight streams with {@code ID <=
-     * lastGoodStreamId} can only be replayed on a new connection if they are idempotent.
-     *
-     * @param lastGoodStreamId the last stream ID the peer processed before sending this message. If
-     * {@code lastGoodStreamId} is zero, the peer processed no frames.
-     * @param errorCode reason for closing the connection.
-     * @param debugData only valid for HTTP/2; opaque debug data to send.
-     */
-    void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData);
-
-    /**
-     * Notifies that an additional {@code windowSizeIncrement} bytes can be sent on {@code
-     * streamId}, or the connection if {@code streamId} is zero.
-     */
-    void windowUpdate(int streamId, long windowSizeIncrement);
-
-    /**
-     * Called when reading a headers or priority frame. This may be used to change the stream's
-     * weight from the default (16) to a new value.
-     *
-     * @param streamId stream which has a priority change.
-     * @param streamDependency the stream ID this stream is dependent on.
-     * @param weight relative proportion of priority in [1..256].
-     * @param exclusive inserts this stream ID as the sole child of {@code streamDependency}.
-     */
-    void priority(int streamId, int streamDependency, int weight, boolean exclusive);
-
-    /**
-     * HTTP/2 only. Receive a push promise header block. <p> A push promise contains all the headers
-     * that pertain to a server-initiated request, and a {@code promisedStreamId} to which response
-     * frames will be delivered. Push promise frames are sent as a part of the response to {@code
-     * streamId}.
-     *
-     * @param streamId client-initiated stream ID.  Must be an odd number.
-     * @param promisedStreamId server-initiated stream ID.  Must be an even number.
-     * @param requestHeaders minimally includes {@code :method}, {@code :scheme}, {@code
-     * :authority}, and (@code :path}.
-     */
-    void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
-        throws IOException;
-
-    /**
-     * HTTP/2 only. Expresses that resources for the connection or a client- initiated stream are
-     * available from a different network location or protocol configuration.
-     *
-     * <p>See <a href="http://tools.ietf.org/html/draft-ietf-httpbis-alt-svc-01">alt-svc</a>
-     *
-     * @param streamId when a client-initiated stream ID (odd number), the origin of this alternate
-     * service is the origin of the stream. When zero, the origin is specified in the {@code origin}
-     * parameter.
-     * @param origin when present, the <a href="http://tools.ietf.org/html/rfc6454">origin</a> is
-     * typically represented as a combination of scheme, host and port. When empty, the origin is
-     * that of the {@code streamId}.
-     * @param protocol an ALPN protocol, such as {@code h2}.
-     * @param host an IP address or hostname.
-     * @param port the IP port associated with the service.
-     * @param maxAge time in seconds that this alternative is considered fresh.
-     */
-    void alternateService(int streamId, String origin, ByteString protocol, String host, int port,
-        long maxAge);
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
deleted file mode 100644
index c8049e9ace..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
+++ /dev/null
@@ -1,673 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.io.InterruptedIOException;
-import java.net.SocketTimeoutException;
-import java.util.ArrayDeque;
-import java.util.Deque;
-import java.util.List;
-import javax.annotation.Nullable;
-import okhttp3.Headers;
-import okhttp3.internal.Util;
-import okio.AsyncTimeout;
-import okio.Buffer;
-import okio.BufferedSource;
-import okio.Sink;
-import okio.Source;
-import okio.Timeout;
-
-/** A logical bidirectional stream. */
-public final class Http2Stream {
-  // Internal state is guarded by this. No long-running or potentially
-  // blocking operations are performed while the lock is held.
-
-  /**
-   * The total number of bytes consumed by the application (with {@link FramingSource#read}), but
-   * not yet acknowledged by sending a {@code WINDOW_UPDATE} frame on this stream.
-   */
-  // Visible for testing
-  long unacknowledgedBytesRead = 0;
-
-  /**
-   * Count of bytes that can be written on the stream before receiving a window update. Even if this
-   * is positive, writes will block until there available bytes in {@code
-   * connection.bytesLeftInWriteWindow}.
-   */
-  // guarded by this
-  long bytesLeftInWriteWindow;
-
-  final int id;
-  final Http2Connection connection;
-
-  /**
-   * Received headers yet to be {@linkplain #takeHeaders taken}, or {@linkplain FramingSource#read
-   * read}.
-   */
-  private final Deque<Headers> headersQueue = new ArrayDeque<>();
-
-  /** True if response headers have been sent or received. */
-  private boolean hasResponseHeaders;
-
-  private final FramingSource source;
-  final FramingSink sink;
-  final StreamTimeout readTimeout = new StreamTimeout();
-  final StreamTimeout writeTimeout = new StreamTimeout();
-
-  /**
-   * The reason why this stream was abnormally closed. If there are multiple reasons to abnormally
-   * close this stream (such as both peers closing it near-simultaneously) then this is the first
-   * reason known to this peer.
-   */
-  @Nullable ErrorCode errorCode;
-
-  /** The exception that explains {@code errorCode}. Null if no exception was provided. */
-  @Nullable IOException errorException;
-
-  Http2Stream(int id, Http2Connection connection, boolean outFinished, boolean inFinished,
-      @Nullable Headers headers) {
-    if (connection == null) throw new NullPointerException("connection == null");
-
-    this.id = id;
-    this.connection = connection;
-    this.bytesLeftInWriteWindow =
-        connection.peerSettings.getInitialWindowSize();
-    this.source = new FramingSource(connection.okHttpSettings.getInitialWindowSize());
-    this.sink = new FramingSink();
-    this.source.finished = inFinished;
-    this.sink.finished = outFinished;
-    if (headers != null) {
-      headersQueue.add(headers);
-    }
-
-    if (isLocallyInitiated() && headers != null) {
-      throw new IllegalStateException("locally-initiated streams shouldn't have headers yet");
-    } else if (!isLocallyInitiated() && headers == null) {
-      throw new IllegalStateException("remotely-initiated streams should have headers");
-    }
-  }
-
-  public int getId() {
-    return id;
-  }
-
-  /**
-   * Returns true if this stream is open. A stream is open until either:
-   *
-   * <ul>
-   *     <li>A {@code SYN_RESET} frame abnormally terminates the stream.
-   *     <li>Both input and output streams have transmitted all data and headers.
-   * </ul>
-   *
-   * <p>Note that the input stream may continue to yield data even after a stream reports itself as
-   * not open. This is because input data is buffered.
-   */
-  public synchronized boolean isOpen() {
-    if (errorCode != null) {
-      return false;
-    }
-    if ((source.finished || source.closed)
-        && (sink.finished || sink.closed)
-        && hasResponseHeaders) {
-      return false;
-    }
-    return true;
-  }
-
-  /** Returns true if this stream was created by this peer. */
-  public boolean isLocallyInitiated() {
-    boolean streamIsClient = ((id & 1) == 1);
-    return connection.client == streamIsClient;
-  }
-
-  public Http2Connection getConnection() {
-    return connection;
-  }
-
-  /**
-   * Removes and returns the stream's received response headers, blocking if necessary until headers
-   * have been received. If the returned list contains multiple blocks of headers the blocks will be
-   * delimited by 'null'.
-   */
-  public synchronized Headers takeHeaders() throws IOException {
-    readTimeout.enter();
-    try {
-      while (headersQueue.isEmpty() && errorCode == null) {
-        waitForIo();
-      }
-    } finally {
-      readTimeout.exitAndThrowIfTimedOut();
-    }
-    if (!headersQueue.isEmpty()) {
-      return headersQueue.removeFirst();
-    }
-    throw errorException != null ? errorException : new StreamResetException(errorCode);
-  }
-
-  /**
-   * Returns the trailers. It is only safe to call this once the source stream has been completely
-   * exhausted.
-   */
-  public synchronized Headers trailers() throws IOException {
-    if (errorCode != null) {
-      throw errorException != null ? errorException : new StreamResetException(errorCode);
-    }
-    if (!source.finished || !source.receiveBuffer.exhausted() || !source.readBuffer.exhausted()) {
-      throw new IllegalStateException("too early; can't read the trailers yet");
-    }
-    return source.trailers != null ? source.trailers : Util.EMPTY_HEADERS;
-  }
-
-  /**
-   * Returns the reason why this stream was closed, or null if it closed normally or has not yet
-   * been closed.
-   */
-  public synchronized ErrorCode getErrorCode() {
-    return errorCode;
-  }
-
-  /**
-   * Sends a reply to an incoming stream.
-   *
-   * @param outFinished true to eagerly finish the output stream to send data to the remote peer.
-   *     Corresponds to {@code FLAG_FIN}.
-   * @param flushHeaders true to force flush the response headers. This should be true unless the
-   *     response body exists and will be written immediately.
-   */
-  public void writeHeaders(List<Header> responseHeaders, boolean outFinished, boolean flushHeaders)
-      throws IOException {
-    assert (!Thread.holdsLock(Http2Stream.this));
-    if (responseHeaders == null) {
-      throw new NullPointerException("headers == null");
-    }
-    synchronized (this) {
-      this.hasResponseHeaders = true;
-      if (outFinished) {
-        this.sink.finished = true;
-      }
-    }
-
-    // Only DATA frames are subject to flow-control. Transmit the HEADER frame if the connection
-    // flow-control window is fully depleted.
-    if (!flushHeaders) {
-      synchronized (connection) {
-        flushHeaders = connection.bytesLeftInWriteWindow == 0L;
-      }
-    }
-
-    connection.writeHeaders(id, outFinished, responseHeaders);
-
-    if (flushHeaders) {
-      connection.flush();
-    }
-  }
-
-  public void enqueueTrailers(Headers trailers) {
-    synchronized (this) {
-      if (sink.finished) throw new IllegalStateException("already finished");
-      if (trailers.size() == 0) throw new IllegalArgumentException("trailers.size() == 0");
-      this.sink.trailers = trailers;
-    }
-  }
-
-  public Timeout readTimeout() {
-    return readTimeout;
-  }
-
-  public Timeout writeTimeout() {
-    return writeTimeout;
-  }
-
-  /** Returns a source that reads data from the peer. */
-  public Source getSource() {
-    return source;
-  }
-
-  /**
-   * Returns a sink that can be used to write data to the peer.
-   *
-   * @throws IllegalStateException if this stream was initiated by the peer and a {@link
-   *     #writeHeaders} has not yet been sent.
-   */
-  public Sink getSink() {
-    synchronized (this) {
-      if (!hasResponseHeaders && !isLocallyInitiated()) {
-        throw new IllegalStateException("reply before requesting the sink");
-      }
-    }
-    return sink;
-  }
-
-  /**
-   * Abnormally terminate this stream. This blocks until the {@code RST_STREAM} frame has been
-   * transmitted.
-   */
-  public void close(ErrorCode rstStatusCode, @Nullable IOException errorException)
-      throws IOException {
-    if (!closeInternal(rstStatusCode, errorException)) {
-      return; // Already closed.
-    }
-    connection.writeSynReset(id, rstStatusCode);
-  }
-
-  /**
-   * Abnormally terminate this stream. This enqueues a {@code RST_STREAM} frame and returns
-   * immediately.
-   */
-  public void closeLater(ErrorCode errorCode) {
-    if (!closeInternal(errorCode, null)) {
-      return; // Already closed.
-    }
-    connection.writeSynResetLater(id, errorCode);
-  }
-
-  /** Returns true if this stream was closed. */
-  private boolean closeInternal(ErrorCode errorCode, @Nullable IOException errorException) {
-    assert (!Thread.holdsLock(this));
-    synchronized (this) {
-      if (this.errorCode != null) {
-        return false;
-      }
-      if (source.finished && sink.finished) {
-        return false;
-      }
-      this.errorCode = errorCode;
-      this.errorException = errorException;
-      notifyAll();
-    }
-    connection.removeStream(id);
-    return true;
-  }
-
-  void receiveData(BufferedSource in, int length) throws IOException {
-    assert (!Thread.holdsLock(Http2Stream.this));
-    this.source.receive(in, length);
-  }
-
-  /**
-   * Accept headers from the network and store them until the client calls {@link #takeHeaders}, or
-   * {@link FramingSource#read} them.
-   */
-  void receiveHeaders(Headers headers, boolean inFinished) {
-    assert (!Thread.holdsLock(Http2Stream.this));
-    boolean open;
-    synchronized (this) {
-      if (!hasResponseHeaders || !inFinished) {
-        hasResponseHeaders = true;
-        headersQueue.add(headers);
-      } else {
-        this.source.trailers = headers;
-      }
-      if (inFinished) {
-        this.source.finished = true;
-      }
-      open = isOpen();
-      notifyAll();
-    }
-    if (!open) {
-      connection.removeStream(id);
-    }
-  }
-
-  synchronized void receiveRstStream(ErrorCode errorCode) {
-    if (this.errorCode == null) {
-      this.errorCode = errorCode;
-      notifyAll();
-    }
-  }
-
-  /**
-   * A source that reads the incoming data frames of a stream. Although this class uses
-   * synchronization to safely receive incoming data frames, it is not intended for use by multiple
-   * readers.
-   */
-  private final class FramingSource implements Source {
-    /** Buffer to receive data from the network into. Only accessed by the reader thread. */
-    private final Buffer receiveBuffer = new Buffer();
-
-    /** Buffer with readable data. Guarded by Http2Stream.this. */
-    private final Buffer readBuffer = new Buffer();
-
-    /** Maximum number of bytes to buffer before reporting a flow control error. */
-    private final long maxByteCount;
-
-    /**
-     * Received trailers. Null unless the server has provided trailers. Undefined until the stream
-     * is exhausted. Guarded by Http2Stream.this.
-     */
-    private Headers trailers;
-
-    /** True if the caller has closed this stream. */
-    boolean closed;
-
-    /**
-     * True if either side has cleanly shut down this stream. We will receive no more bytes beyond
-     * those already in the buffer.
-     */
-    boolean finished;
-
-    FramingSource(long maxByteCount) {
-      this.maxByteCount = maxByteCount;
-    }
-
-    @Override public long read(Buffer sink, long byteCount) throws IOException {
-      if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
-
-      while (true) {
-        long readBytesDelivered = -1;
-        IOException errorExceptionToDeliver = null;
-
-        // 1. Decide what to do in a synchronized block.
-
-        synchronized (Http2Stream.this) {
-          readTimeout.enter();
-          try {
-            if (errorCode != null) {
-              // Prepare to deliver an error.
-              errorExceptionToDeliver = errorException != null
-                  ? errorException
-                  : new StreamResetException(errorCode);
-            }
-
-            if (closed) {
-              throw new IOException("stream closed");
-
-            } else if (readBuffer.size() > 0) {
-              // Prepare to read bytes. Start by moving them to the caller's buffer.
-              readBytesDelivered = readBuffer.read(sink, Math.min(byteCount, readBuffer.size()));
-              unacknowledgedBytesRead += readBytesDelivered;
-
-              if (errorExceptionToDeliver == null
-                  && unacknowledgedBytesRead
-                  >= connection.okHttpSettings.getInitialWindowSize() / 2) {
-                // Flow control: notify the peer that we're ready for more data! Only send a
-                // WINDOW_UPDATE if the stream isn't in error.
-                connection.writeWindowUpdateLater(id, unacknowledgedBytesRead);
-                unacknowledgedBytesRead = 0;
-              }
-            } else if (!finished && errorExceptionToDeliver == null) {
-              // Nothing to do. Wait until that changes then try again.
-              waitForIo();
-              continue;
-            }
-          } finally {
-            readTimeout.exitAndThrowIfTimedOut();
-          }
-        }
-
-        // 2. Do it outside of the synchronized block and timeout.
-
-        if (readBytesDelivered != -1) {
-          // Update connection.unacknowledgedBytesRead outside the synchronized block.
-          updateConnectionFlowControl(readBytesDelivered);
-          return readBytesDelivered;
-        }
-
-        if (errorExceptionToDeliver != null) {
-          // We defer throwing the exception until now so that we can refill the connection
-          // flow-control window. This is necessary because we don't transmit window updates until
-          // the application reads the data. If we throw this prior to updating the connection
-          // flow-control window, we risk having it go to 0 preventing the server from sending data.
-          throw errorExceptionToDeliver;
-        }
-
-        return -1; // This source is exhausted.
-      }
-    }
-
-    private void updateConnectionFlowControl(long read) {
-      assert (!Thread.holdsLock(Http2Stream.this));
-      connection.updateConnectionFlowControl(read);
-    }
-
-    void receive(BufferedSource in, long byteCount) throws IOException {
-      assert (!Thread.holdsLock(Http2Stream.this));
-
-      while (byteCount > 0) {
-        boolean finished;
-        boolean flowControlError;
-        synchronized (Http2Stream.this) {
-          finished = this.finished;
-          flowControlError = byteCount + readBuffer.size() > maxByteCount;
-        }
-
-        // If the peer sends more data than we can handle, discard it and close the connection.
-        if (flowControlError) {
-          in.skip(byteCount);
-          closeLater(ErrorCode.FLOW_CONTROL_ERROR);
-          return;
-        }
-
-        // Discard data received after the stream is finished. It's probably a benign race.
-        if (finished) {
-          in.skip(byteCount);
-          return;
-        }
-
-        // Fill the receive buffer without holding any locks.
-        long read = in.read(receiveBuffer, byteCount);
-        if (read == -1) throw new EOFException();
-        byteCount -= read;
-
-        // Move the received data to the read buffer to the reader can read it.
-        synchronized (Http2Stream.this) {
-          boolean wasEmpty = readBuffer.size() == 0;
-          readBuffer.writeAll(receiveBuffer);
-          if (wasEmpty) {
-            Http2Stream.this.notifyAll();
-          }
-        }
-      }
-    }
-
-    @Override public Timeout timeout() {
-      return readTimeout;
-    }
-
-    @Override public void close() throws IOException {
-      long bytesDiscarded;
-      synchronized (Http2Stream.this) {
-        closed = true;
-        bytesDiscarded = readBuffer.size();
-        readBuffer.clear();
-        Http2Stream.this.notifyAll(); // TODO(jwilson): Unnecessary?
-      }
-      if (bytesDiscarded > 0) {
-        updateConnectionFlowControl(bytesDiscarded);
-      }
-      cancelStreamIfNecessary();
-    }
-  }
-
-  void cancelStreamIfNecessary() throws IOException {
-    assert (!Thread.holdsLock(Http2Stream.this));
-    boolean open;
-    boolean cancel;
-    synchronized (this) {
-      cancel = !source.finished && source.closed && (sink.finished || sink.closed);
-      open = isOpen();
-    }
-    if (cancel) {
-      // RST this stream to prevent additional data from being sent. This
-      // is safe because the input stream is closed (we won't use any
-      // further bytes) and the output stream is either finished or closed
-      // (so RSTing both streams doesn't cause harm).
-      Http2Stream.this.close(ErrorCode.CANCEL, null);
-    } else if (!open) {
-      connection.removeStream(id);
-    }
-  }
-
-  /** A sink that writes outgoing data frames of a stream. This class is not thread safe. */
-  final class FramingSink implements Sink {
-    private static final long EMIT_BUFFER_SIZE = 16384;
-
-    /**
-     * Buffer of outgoing data. This batches writes of small writes into this sink as larges frames
-     * written to the outgoing connection. Batching saves the (small) framing overhead.
-     */
-    private final Buffer sendBuffer = new Buffer();
-
-    /** Trailers to send at the end of the stream. */
-    private Headers trailers;
-
-    boolean closed;
-
-    /**
-     * True if either side has cleanly shut down this stream. We shall send no more bytes.
-     */
-    boolean finished;
-
-    @Override public void write(Buffer source, long byteCount) throws IOException {
-      assert (!Thread.holdsLock(Http2Stream.this));
-      sendBuffer.write(source, byteCount);
-      while (sendBuffer.size() >= EMIT_BUFFER_SIZE) {
-        emitFrame(false);
-      }
-    }
-
-    /**
-     * Emit a single data frame to the connection. The frame's size be limited by this stream's
-     * write window. This method will block until the write window is nonempty.
-     */
-    private void emitFrame(boolean outFinishedOnLastFrame) throws IOException {
-      long toWrite;
-      synchronized (Http2Stream.this) {
-        writeTimeout.enter();
-        try {
-          while (bytesLeftInWriteWindow <= 0 && !finished && !closed && errorCode == null) {
-            waitForIo(); // Wait until we receive a WINDOW_UPDATE for this stream.
-          }
-        } finally {
-          writeTimeout.exitAndThrowIfTimedOut();
-        }
-
-        checkOutNotClosed(); // Kick out if the stream was reset or closed while waiting.
-        toWrite = Math.min(bytesLeftInWriteWindow, sendBuffer.size());
-        bytesLeftInWriteWindow -= toWrite;
-      }
-
-      writeTimeout.enter();
-      try {
-        boolean outFinished = outFinishedOnLastFrame && toWrite == sendBuffer.size();
-        connection.writeData(id, outFinished, sendBuffer, toWrite);
-      } finally {
-        writeTimeout.exitAndThrowIfTimedOut();
-      }
-    }
-
-    @Override public void flush() throws IOException {
-      assert (!Thread.holdsLock(Http2Stream.this));
-      synchronized (Http2Stream.this) {
-        checkOutNotClosed();
-      }
-      while (sendBuffer.size() > 0) {
-        emitFrame(false);
-        connection.flush();
-      }
-    }
-
-    @Override public Timeout timeout() {
-      return writeTimeout;
-    }
-
-    @Override public void close() throws IOException {
-      assert (!Thread.holdsLock(Http2Stream.this));
-      synchronized (Http2Stream.this) {
-        if (closed) return;
-      }
-      if (!sink.finished) {
-        // We have 0 or more frames of data, and 0 or more frames of trailers. We need to send at
-        // least one frame with the END_STREAM flag set. That must be the last frame, and the
-        // trailers must be sent after all of the data.
-        boolean hasData = sendBuffer.size() > 0;
-        boolean hasTrailers = trailers != null;
-        if (hasTrailers) {
-          while (sendBuffer.size() > 0) {
-            emitFrame(false);
-          }
-          connection.writeHeaders(id, true, Util.toHeaderBlock(trailers));
-        } else if (hasData) {
-          while (sendBuffer.size() > 0) {
-            emitFrame(true);
-          }
-        } else {
-          connection.writeData(id, true, null, 0);
-        }
-      }
-      synchronized (Http2Stream.this) {
-        closed = true;
-      }
-      connection.flush();
-      cancelStreamIfNecessary();
-    }
-  }
-
-  /**
-   * {@code delta} will be negative if a settings frame initial window is smaller than the last.
-   */
-  void addBytesToWriteWindow(long delta) {
-    bytesLeftInWriteWindow += delta;
-    if (delta > 0) Http2Stream.this.notifyAll();
-  }
-
-  void checkOutNotClosed() throws IOException {
-    if (sink.closed) {
-      throw new IOException("stream closed");
-    } else if (sink.finished) {
-      throw new IOException("stream finished");
-    } else if (errorCode != null) {
-      throw errorException != null ? errorException : new StreamResetException(errorCode);
-    }
-  }
-
-  /**
-   * Like {@link #wait}, but throws an {@code InterruptedIOException} when interrupted instead of
-   * the more awkward {@link InterruptedException}.
-   */
-  void waitForIo() throws InterruptedIOException {
-    try {
-      wait();
-    } catch (InterruptedException e) {
-      Thread.currentThread().interrupt(); // Retain interrupted status.
-      throw new InterruptedIOException();
-    }
-  }
-
-  /**
-   * The Okio timeout watchdog will call {@link #timedOut} if the timeout is reached. In that case
-   * we close the stream (asynchronously) which will notify the waiting thread.
-   */
-  class StreamTimeout extends AsyncTimeout {
-    @Override protected void timedOut() {
-      closeLater(ErrorCode.CANCEL);
-    }
-
-    @Override protected IOException newTimeoutException(IOException cause) {
-      SocketTimeoutException socketTimeoutException = new SocketTimeoutException("timeout");
-      if (cause != null) {
-        socketTimeoutException.initCause(cause);
-      }
-      return socketTimeoutException;
-    }
-
-    public void exitAndThrowIfTimedOut() throws IOException {
-      if (exit()) throw newTimeoutException(null /* cause */);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.java
deleted file mode 100644
index b6456949de..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.java
+++ /dev/null
@@ -1,294 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.util.List;
-import java.util.logging.Logger;
-import okio.Buffer;
-import okio.BufferedSink;
-
-import static java.util.logging.Level.FINE;
-import static okhttp3.internal.Util.format;
-import static okhttp3.internal.http2.Http2.CONNECTION_PREFACE;
-import static okhttp3.internal.http2.Http2.FLAG_ACK;
-import static okhttp3.internal.http2.Http2.FLAG_END_HEADERS;
-import static okhttp3.internal.http2.Http2.FLAG_END_STREAM;
-import static okhttp3.internal.http2.Http2.FLAG_NONE;
-import static okhttp3.internal.http2.Http2.INITIAL_MAX_FRAME_SIZE;
-import static okhttp3.internal.http2.Http2.TYPE_CONTINUATION;
-import static okhttp3.internal.http2.Http2.TYPE_DATA;
-import static okhttp3.internal.http2.Http2.TYPE_GOAWAY;
-import static okhttp3.internal.http2.Http2.TYPE_HEADERS;
-import static okhttp3.internal.http2.Http2.TYPE_PING;
-import static okhttp3.internal.http2.Http2.TYPE_PUSH_PROMISE;
-import static okhttp3.internal.http2.Http2.TYPE_RST_STREAM;
-import static okhttp3.internal.http2.Http2.TYPE_SETTINGS;
-import static okhttp3.internal.http2.Http2.TYPE_WINDOW_UPDATE;
-import static okhttp3.internal.http2.Http2.frameLog;
-import static okhttp3.internal.http2.Http2.illegalArgument;
-
-/** Writes HTTP/2 transport frames. */
-final class Http2Writer implements Closeable {
-  private static final Logger logger = Logger.getLogger(Http2.class.getName());
-
-  private final BufferedSink sink;
-  private final boolean client;
-  private final Buffer hpackBuffer;
-  private int maxFrameSize;
-  private boolean closed;
-
-  final Hpack.Writer hpackWriter;
-
-  Http2Writer(BufferedSink sink, boolean client) {
-    this.sink = sink;
-    this.client = client;
-    this.hpackBuffer = new Buffer();
-    this.hpackWriter = new Hpack.Writer(hpackBuffer);
-    this.maxFrameSize = INITIAL_MAX_FRAME_SIZE;
-  }
-
-  public synchronized void connectionPreface() throws IOException {
-    if (closed) throw new IOException("closed");
-    if (!client) return; // Nothing to write; servers don't send connection headers!
-    if (logger.isLoggable(FINE)) {
-      logger.fine(format(">> CONNECTION %s", CONNECTION_PREFACE.hex()));
-    }
-    sink.write(CONNECTION_PREFACE.toByteArray());
-    sink.flush();
-  }
-
-  /** Applies {@code peerSettings} and then sends a settings ACK. */
-  public synchronized void applyAndAckSettings(Settings peerSettings) throws IOException {
-    if (closed) throw new IOException("closed");
-    this.maxFrameSize = peerSettings.getMaxFrameSize(maxFrameSize);
-    if (peerSettings.getHeaderTableSize() != -1) {
-      hpackWriter.setHeaderTableSizeSetting(peerSettings.getHeaderTableSize());
-    }
-    int length = 0;
-    byte type = TYPE_SETTINGS;
-    byte flags = FLAG_ACK;
-    int streamId = 0;
-    frameHeader(streamId, length, type, flags);
-    sink.flush();
-  }
-
-  /**
-   * HTTP/2 only. Send a push promise header block.
-   *
-   * <p>A push promise contains all the headers that pertain to a server-initiated request, and a
-   * {@code promisedStreamId} to which response frames will be delivered. Push promise frames are
-   * sent as a part of the response to {@code streamId}. The {@code promisedStreamId} has a priority
-   * of one greater than {@code streamId}.
-   *
-   * @param streamId client-initiated stream ID.  Must be an odd number.
-   * @param promisedStreamId server-initiated stream ID.  Must be an even number.
-   * @param requestHeaders minimally includes {@code :method}, {@code :scheme}, {@code :authority},
-   * and {@code :path}.
-   */
-  public synchronized void pushPromise(int streamId, int promisedStreamId,
-      List<Header> requestHeaders) throws IOException {
-    if (closed) throw new IOException("closed");
-    hpackWriter.writeHeaders(requestHeaders);
-
-    long byteCount = hpackBuffer.size();
-    int length = (int) Math.min(maxFrameSize - 4, byteCount);
-    byte type = TYPE_PUSH_PROMISE;
-    byte flags = byteCount == length ? FLAG_END_HEADERS : 0;
-    frameHeader(streamId, length + 4, type, flags);
-    sink.writeInt(promisedStreamId & 0x7fffffff);
-    sink.write(hpackBuffer, length);
-
-    if (byteCount > length) writeContinuationFrames(streamId, byteCount - length);
-  }
-
-  public synchronized void flush() throws IOException {
-    if (closed) throw new IOException("closed");
-    sink.flush();
-  }
-
-  public synchronized void rstStream(int streamId, ErrorCode errorCode)
-      throws IOException {
-    if (closed) throw new IOException("closed");
-    if (errorCode.httpCode == -1) throw new IllegalArgumentException();
-
-    int length = 4;
-    byte type = TYPE_RST_STREAM;
-    byte flags = FLAG_NONE;
-    frameHeader(streamId, length, type, flags);
-    sink.writeInt(errorCode.httpCode);
-    sink.flush();
-  }
-
-  /** The maximum size of bytes that may be sent in a single call to {@link #data}. */
-  public int maxDataLength() {
-    return maxFrameSize;
-  }
-
-  /**
-   * {@code source.length} may be longer than the max length of the variant's data frame.
-   * Implementations must send multiple frames as necessary.
-   *
-   * @param source the buffer to draw bytes from. May be null if byteCount is 0.
-   * @param byteCount must be between 0 and the minimum of {@code source.length} and {@link
-   * #maxDataLength}.
-   */
-  public synchronized void data(boolean outFinished, int streamId, Buffer source, int byteCount)
-      throws IOException {
-    if (closed) throw new IOException("closed");
-    byte flags = FLAG_NONE;
-    if (outFinished) flags |= FLAG_END_STREAM;
-    dataFrame(streamId, flags, source, byteCount);
-  }
-
-  void dataFrame(int streamId, byte flags, Buffer buffer, int byteCount) throws IOException {
-    byte type = TYPE_DATA;
-    frameHeader(streamId, byteCount, type, flags);
-    if (byteCount > 0) {
-      sink.write(buffer, byteCount);
-    }
-  }
-
-  /** Write okhttp's settings to the peer. */
-  public synchronized void settings(Settings settings) throws IOException {
-    if (closed) throw new IOException("closed");
-    int length = settings.size() * 6;
-    byte type = TYPE_SETTINGS;
-    byte flags = FLAG_NONE;
-    int streamId = 0;
-    frameHeader(streamId, length, type, flags);
-    for (int i = 0; i < Settings.COUNT; i++) {
-      if (!settings.isSet(i)) continue;
-      int id = i;
-      if (id == 4) {
-        id = 3; // SETTINGS_MAX_CONCURRENT_STREAMS renumbered.
-      } else if (id == 7) {
-        id = 4; // SETTINGS_INITIAL_WINDOW_SIZE renumbered.
-      }
-      sink.writeShort(id);
-      sink.writeInt(settings.get(i));
-    }
-    sink.flush();
-  }
-
-  /**
-   * Send a connection-level ping to the peer. {@code ack} indicates this is a reply. The data in
-   * {@code payload1} and {@code payload2} opaque binary, and there are no rules on the content.
-   */
-  public synchronized void ping(boolean ack, int payload1, int payload2) throws IOException {
-    if (closed) throw new IOException("closed");
-    int length = 8;
-    byte type = TYPE_PING;
-    byte flags = ack ? FLAG_ACK : FLAG_NONE;
-    int streamId = 0;
-    frameHeader(streamId, length, type, flags);
-    sink.writeInt(payload1);
-    sink.writeInt(payload2);
-    sink.flush();
-  }
-
-  /**
-   * Tell the peer to stop creating streams and that we last processed {@code lastGoodStreamId}, or
-   * zero if no streams were processed.
-   *
-   * @param lastGoodStreamId the last stream ID processed, or zero if no streams were processed.
-   * @param errorCode reason for closing the connection.
-   * @param debugData only valid for HTTP/2; opaque debug data to send.
-   */
-  public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
-      throws IOException {
-    if (closed) throw new IOException("closed");
-    if (errorCode.httpCode == -1) throw illegalArgument("errorCode.httpCode == -1");
-    int length = 8 + debugData.length;
-    byte type = TYPE_GOAWAY;
-    byte flags = FLAG_NONE;
-    int streamId = 0;
-    frameHeader(streamId, length, type, flags);
-    sink.writeInt(lastGoodStreamId);
-    sink.writeInt(errorCode.httpCode);
-    if (debugData.length > 0) {
-      sink.write(debugData);
-    }
-    sink.flush();
-  }
-
-  /**
-   * Inform peer that an additional {@code windowSizeIncrement} bytes can be sent on {@code
-   * streamId}, or the connection if {@code streamId} is zero.
-   */
-  public synchronized void windowUpdate(int streamId, long windowSizeIncrement) throws IOException {
-    if (closed) throw new IOException("closed");
-    if (windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL) {
-      throw illegalArgument("windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: %s",
-          windowSizeIncrement);
-    }
-    int length = 4;
-    byte type = TYPE_WINDOW_UPDATE;
-    byte flags = FLAG_NONE;
-    frameHeader(streamId, length, type, flags);
-    sink.writeInt((int) windowSizeIncrement);
-    sink.flush();
-  }
-
-  public void frameHeader(int streamId, int length, byte type, byte flags) throws IOException {
-    if (logger.isLoggable(FINE)) logger.fine(frameLog(false, streamId, length, type, flags));
-    if (length > maxFrameSize) {
-      throw illegalArgument("FRAME_SIZE_ERROR length > %d: %d", maxFrameSize, length);
-    }
-    if ((streamId & 0x80000000) != 0) throw illegalArgument("reserved bit set: %s", streamId);
-    writeMedium(sink, length);
-    sink.writeByte(type & 0xff);
-    sink.writeByte(flags & 0xff);
-    sink.writeInt(streamId & 0x7fffffff);
-  }
-
-  @Override public synchronized void close() throws IOException {
-    closed = true;
-    sink.close();
-  }
-
-  private static void writeMedium(BufferedSink sink, int i) throws IOException {
-    sink.writeByte((i >>> 16) & 0xff);
-    sink.writeByte((i >>> 8) & 0xff);
-    sink.writeByte(i & 0xff);
-  }
-
-  private void writeContinuationFrames(int streamId, long byteCount) throws IOException {
-    while (byteCount > 0) {
-      int length = (int) Math.min(maxFrameSize, byteCount);
-      byteCount -= length;
-      frameHeader(streamId, length, TYPE_CONTINUATION, byteCount == 0 ? FLAG_END_HEADERS : 0);
-      sink.write(hpackBuffer, length);
-    }
-  }
-
-  public synchronized void headers(
-      boolean outFinished, int streamId, List<Header> headerBlock) throws IOException {
-    if (closed) throw new IOException("closed");
-    hpackWriter.writeHeaders(headerBlock);
-
-    long byteCount = hpackBuffer.size();
-    int length = (int) Math.min(maxFrameSize, byteCount);
-    byte type = TYPE_HEADERS;
-    byte flags = byteCount == length ? FLAG_END_HEADERS : 0;
-    if (outFinished) flags |= FLAG_END_STREAM;
-    frameHeader(streamId, length, type, flags);
-    sink.write(hpackBuffer, length);
-
-    if (byteCount > length) writeContinuationFrames(streamId, byteCount - length);
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Huffman.java b/okhttp/src/main/java/okhttp3/internal/http2/Huffman.java
deleted file mode 100644
index 7aa8024b72..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http2/Huffman.java
+++ /dev/null
@@ -1,227 +0,0 @@
-/*
- * Copyright 2013 Twitter, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import okio.BufferedSink;
-import okio.ByteString;
-
-/**
- * This class was originally composed from the following classes in <a
- * href="https://github.com/twitter/hpack">Twitter Hpack</a>.
- *
- * <ul>
- *     <li>{@code com.twitter.hpack.HuffmanEncoder}</li>
- *     <li>{@code com.twitter.hpack.HuffmanDecoder}</li>
- *     <li>{@code com.twitter.hpack.HpackUtil}</li>
- * </ul>
- */
-class Huffman {
-
-  // Appendix C: Huffman Codes
-  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#appendix-B
-  private static final int[] CODES = {
-      0x1ff8, 0x7fffd8, 0xfffffe2, 0xfffffe3, 0xfffffe4, 0xfffffe5, 0xfffffe6, 0xfffffe7, 0xfffffe8,
-      0xffffea, 0x3ffffffc, 0xfffffe9, 0xfffffea, 0x3ffffffd, 0xfffffeb, 0xfffffec, 0xfffffed,
-      0xfffffee, 0xfffffef, 0xffffff0, 0xffffff1, 0xffffff2, 0x3ffffffe, 0xffffff3, 0xffffff4,
-      0xffffff5, 0xffffff6, 0xffffff7, 0xffffff8, 0xffffff9, 0xffffffa, 0xffffffb, 0x14, 0x3f8,
-      0x3f9, 0xffa, 0x1ff9, 0x15, 0xf8, 0x7fa, 0x3fa, 0x3fb, 0xf9, 0x7fb, 0xfa, 0x16, 0x17, 0x18,
-      0x0, 0x1, 0x2, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x5c, 0xfb, 0x7ffc, 0x20, 0xffb,
-      0x3fc, 0x1ffa, 0x21, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
-      0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0xfc, 0x73, 0xfd, 0x1ffb, 0x7fff0,
-      0x1ffc, 0x3ffc, 0x22, 0x7ffd, 0x3, 0x23, 0x4, 0x24, 0x5, 0x25, 0x26, 0x27, 0x6, 0x74, 0x75,
-      0x28, 0x29, 0x2a, 0x7, 0x2b, 0x76, 0x2c, 0x8, 0x9, 0x2d, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7ffe,
-      0x7fc, 0x3ffd, 0x1ffd, 0xffffffc, 0xfffe6, 0x3fffd2, 0xfffe7, 0xfffe8, 0x3fffd3, 0x3fffd4,
-      0x3fffd5, 0x7fffd9, 0x3fffd6, 0x7fffda, 0x7fffdb, 0x7fffdc, 0x7fffdd, 0x7fffde, 0xffffeb,
-      0x7fffdf, 0xffffec, 0xffffed, 0x3fffd7, 0x7fffe0, 0xffffee, 0x7fffe1, 0x7fffe2, 0x7fffe3,
-      0x7fffe4, 0x1fffdc, 0x3fffd8, 0x7fffe5, 0x3fffd9, 0x7fffe6, 0x7fffe7, 0xffffef, 0x3fffda,
-      0x1fffdd, 0xfffe9, 0x3fffdb, 0x3fffdc, 0x7fffe8, 0x7fffe9, 0x1fffde, 0x7fffea, 0x3fffdd,
-      0x3fffde, 0xfffff0, 0x1fffdf, 0x3fffdf, 0x7fffeb, 0x7fffec, 0x1fffe0, 0x1fffe1, 0x3fffe0,
-      0x1fffe2, 0x7fffed, 0x3fffe1, 0x7fffee, 0x7fffef, 0xfffea, 0x3fffe2, 0x3fffe3, 0x3fffe4,
-      0x7ffff0, 0x3fffe5, 0x3fffe6, 0x7ffff1, 0x3ffffe0, 0x3ffffe1, 0xfffeb, 0x7fff1, 0x3fffe7,
-      0x7ffff2, 0x3fffe8, 0x1ffffec, 0x3ffffe2, 0x3ffffe3, 0x3ffffe4, 0x7ffffde, 0x7ffffdf,
-      0x3ffffe5, 0xfffff1, 0x1ffffed, 0x7fff2, 0x1fffe3, 0x3ffffe6, 0x7ffffe0, 0x7ffffe1, 0x3ffffe7,
-      0x7ffffe2, 0xfffff2, 0x1fffe4, 0x1fffe5, 0x3ffffe8, 0x3ffffe9, 0xffffffd, 0x7ffffe3,
-      0x7ffffe4, 0x7ffffe5, 0xfffec, 0xfffff3, 0xfffed, 0x1fffe6, 0x3fffe9, 0x1fffe7, 0x1fffe8,
-      0x7ffff3, 0x3fffea, 0x3fffeb, 0x1ffffee, 0x1ffffef, 0xfffff4, 0xfffff5, 0x3ffffea, 0x7ffff4,
-      0x3ffffeb, 0x7ffffe6, 0x3ffffec, 0x3ffffed, 0x7ffffe7, 0x7ffffe8, 0x7ffffe9, 0x7ffffea,
-      0x7ffffeb, 0xffffffe, 0x7ffffec, 0x7ffffed, 0x7ffffee, 0x7ffffef, 0x7fffff0, 0x3ffffee
-  };
-
-  private static final byte[] CODE_LENGTHS = {
-      13, 23, 28, 28, 28, 28, 28, 28, 28, 24, 30, 28, 28, 30, 28, 28, 28, 28, 28, 28, 28, 28, 30,
-      28, 28, 28, 28, 28, 28, 28, 28, 28, 6, 10, 10, 12, 13, 6, 8, 11, 10, 10, 8, 11, 8, 6, 6, 6, 5,
-      5, 5, 6, 6, 6, 6, 6, 6, 6, 7, 8, 15, 6, 12, 10, 13, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
-      7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 8, 13, 19, 13, 14, 6, 15, 5, 6, 5, 6, 5, 6, 6, 6, 5, 7, 7, 6,
-      6, 6, 5, 6, 7, 6, 5, 5, 6, 7, 7, 7, 7, 7, 15, 11, 14, 13, 28, 20, 22, 20, 20, 22, 22, 22, 23,
-      22, 23, 23, 23, 23, 23, 24, 23, 24, 24, 22, 23, 24, 23, 23, 23, 23, 21, 22, 23, 22, 23, 23,
-      24, 22, 21, 20, 22, 22, 23, 23, 21, 23, 22, 22, 24, 21, 22, 23, 23, 21, 21, 22, 21, 23, 22,
-      23, 23, 20, 22, 22, 22, 23, 22, 22, 23, 26, 26, 20, 19, 22, 23, 22, 25, 26, 26, 26, 27, 27,
-      26, 24, 25, 19, 21, 26, 27, 27, 26, 27, 24, 21, 21, 26, 26, 28, 27, 27, 27, 20, 24, 20, 21,
-      22, 21, 21, 23, 22, 22, 25, 25, 24, 24, 26, 23, 26, 27, 26, 26, 27, 27, 27, 27, 27, 28, 27,
-      27, 27, 27, 27, 26
-  };
-
-  private static final Huffman INSTANCE = new Huffman();
-
-  public static Huffman get() {
-    return INSTANCE;
-  }
-
-  private final Node root = new Node();
-
-  private Huffman() {
-    buildTree();
-  }
-
-  void encode(ByteString data, BufferedSink sink) throws IOException {
-    long current = 0;
-    int n = 0;
-
-    for (int i = 0; i < data.size(); i++) {
-      int b = data.getByte(i) & 0xFF;
-      int code = CODES[b];
-      int nbits = CODE_LENGTHS[b];
-
-      current <<= nbits;
-      current |= code;
-      n += nbits;
-
-      while (n >= 8) {
-        n -= 8;
-        sink.writeByte(((int) (current >> n)));
-      }
-    }
-
-    if (n > 0) {
-      current <<= (8 - n);
-      current |= (0xFF >>> n);
-      sink.writeByte((int) current);
-    }
-  }
-
-  int encodedLength(ByteString bytes) {
-    long len = 0;
-
-    for (int i = 0; i < bytes.size(); i++) {
-      int b = bytes.getByte(i) & 0xFF;
-      len += CODE_LENGTHS[b];
-    }
-
-    return (int) ((len + 7) >> 3);
-  }
-
-  byte[] decode(byte[] buf) {
-    ByteArrayOutputStream baos = new ByteArrayOutputStream();
-    Node node = root;
-    int current = 0;
-    int nbits = 0;
-    for (int i = 0; i < buf.length; i++) {
-      int b = buf[i] & 0xFF;
-      current = (current << 8) | b;
-      nbits += 8;
-      while (nbits >= 8) {
-        int c = (current >>> (nbits - 8)) & 0xFF;
-        node = node.children[c];
-        if (node.children == null) {
-          // terminal node
-          baos.write(node.symbol);
-          nbits -= node.terminalBits;
-          node = root;
-        } else {
-          // non-terminal node
-          nbits -= 8;
-        }
-      }
-    }
-
-    while (nbits > 0) {
-      int c = (current << (8 - nbits)) & 0xFF;
-      node = node.children[c];
-      if (node.children != null || node.terminalBits > nbits) {
-        break;
-      }
-      baos.write(node.symbol);
-      nbits -= node.terminalBits;
-      node = root;
-    }
-
-    return baos.toByteArray();
-  }
-
-  private void buildTree() {
-    for (int i = 0; i < CODE_LENGTHS.length; i++) {
-      addCode(i, CODES[i], CODE_LENGTHS[i]);
-    }
-  }
-
-  private void addCode(int sym, int code, byte len) {
-    Node terminal = new Node(sym, len);
-
-    Node current = root;
-    while (len > 8) {
-      len -= 8;
-      int i = ((code >>> len) & 0xFF);
-      if (current.children == null) {
-        throw new IllegalStateException("invalid dictionary: prefix not unique");
-      }
-      if (current.children[i] == null) {
-        current.children[i] = new Node();
-      }
-      current = current.children[i];
-    }
-
-    int shift = 8 - len;
-    int start = (code << shift) & 0xFF;
-    int end = 1 << shift;
-    for (int i = start; i < start + end; i++) {
-      current.children[i] = terminal;
-    }
-  }
-
-  private static final class Node {
-
-    // Null if terminal.
-    final Node[] children;
-
-    // Terminal nodes have a symbol.
-    final int symbol;
-
-    // Number of bits represented in the terminal node.
-    final int terminalBits;
-
-    /** Construct an internal node. */
-    Node() {
-      this.children = new Node[256];
-      this.symbol = 0; // Not read.
-      this.terminalBits = 0; // Not read.
-    }
-
-    /**
-     * Construct a terminal node.
-     *
-     * @param symbol symbol the node represents
-     * @param bits length of Huffman code in bits
-     */
-    Node(int symbol, int bits) {
-      this.children = null;
-      this.symbol = symbol;
-      int b = bits & 0x07;
-      this.terminalBits = b == 0 ? 8 : b;
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/PushObserver.java b/okhttp/src/main/java/okhttp3/internal/http2/PushObserver.java
deleted file mode 100644
index 8c08ddb56a..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http2/PushObserver.java
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import java.io.IOException;
-import java.util.List;
-import okhttp3.Protocol;
-import okio.BufferedSource;
-
-/**
- * {@link Protocol#HTTP_2 HTTP/2} only. Processes server-initiated HTTP requests on the client.
- * Implementations must quickly dispatch callbacks to avoid creating a bottleneck.
- *
- * <p>While {@link #onReset} may occur at any time, the following callbacks are expected in order,
- * correlated by stream ID.
- *
- * <ul>
- *     <li>{@link #onRequest}</li> <li>{@link #onHeaders} (unless canceled)
- *     <li>{@link #onData} (optional sequence of data frames)
- * </ul>
- *
- * <p>As a stream ID is scoped to a single HTTP/2 connection, implementations which target multiple
- * connections should expect repetition of stream IDs.
- *
- * <p>Return true to request cancellation of a pushed stream.  Note that this does not guarantee
- * future frames won't arrive on the stream ID.
- */
-public interface PushObserver {
-  /**
-   * Describes the request that the server intends to push a response for.
-   *
-   * @param streamId server-initiated stream ID: an even number.
-   * @param requestHeaders minimally includes {@code :method}, {@code :scheme}, {@code :authority},
-   * and {@code :path}.
-   */
-  boolean onRequest(int streamId, List<Header> requestHeaders);
-
-  /**
-   * The response headers corresponding to a pushed request.  When {@code last} is true, there are
-   * no data frames to follow.
-   *
-   * @param streamId server-initiated stream ID: an even number.
-   * @param responseHeaders minimally includes {@code :status}.
-   * @param last when true, there is no response data.
-   */
-  boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last);
-
-  /**
-   * A chunk of response data corresponding to a pushed request.  This data must either be read or
-   * skipped.
-   *
-   * @param streamId server-initiated stream ID: an even number.
-   * @param source location of data corresponding with this stream ID.
-   * @param byteCount number of bytes to read or skip from the source.
-   * @param last when true, there are no data frames to follow.
-   */
-  boolean onData(int streamId, BufferedSource source, int byteCount, boolean last)
-      throws IOException;
-
-  /** Indicates the reason why this stream was canceled. */
-  void onReset(int streamId, ErrorCode errorCode);
-
-  PushObserver CANCEL = new PushObserver() {
-
-    @Override public boolean onRequest(int streamId, List<Header> requestHeaders) {
-      return true;
-    }
-
-    @Override public boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last) {
-      return true;
-    }
-
-    @Override public boolean onData(int streamId, BufferedSource source, int byteCount,
-        boolean last) throws IOException {
-      source.skip(byteCount);
-      return true;
-    }
-
-    @Override public void onReset(int streamId, ErrorCode errorCode) {
-    }
-  };
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Settings.java b/okhttp/src/main/java/okhttp3/internal/http2/Settings.java
deleted file mode 100644
index 5b548de484..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http2/Settings.java
+++ /dev/null
@@ -1,127 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import java.util.Arrays;
-
-/**
- * Settings describe characteristics of the sending peer, which are used by the receiving peer.
- * Settings are {@link Http2Connection connection} scoped.
- */
-public final class Settings {
-  /**
-   * From the HTTP/2 specs, the default initial window size for all streams is 64 KiB. (Chrome 25
-   * uses 10 MiB).
-   */
-  static final int DEFAULT_INITIAL_WINDOW_SIZE = 65535;
-
-  /** HTTP/2: Size in bytes of the table used to decode the sender's header blocks. */
-  static final int HEADER_TABLE_SIZE = 1;
-  /** HTTP/2: The peer must not send a PUSH_PROMISE frame when this is 0. */
-  static final int ENABLE_PUSH = 2;
-  /** Sender's maximum number of concurrent streams. */
-  static final int MAX_CONCURRENT_STREAMS = 4;
-  /** HTTP/2: Size in bytes of the largest frame payload the sender will accept. */
-  static final int MAX_FRAME_SIZE = 5;
-  /** HTTP/2: Advisory only. Size in bytes of the largest header list the sender will accept. */
-  static final int MAX_HEADER_LIST_SIZE = 6;
-  /** Window size in bytes. */
-  static final int INITIAL_WINDOW_SIZE = 7;
-
-  /** Total number of settings. */
-  static final int COUNT = 10;
-
-  /** Bitfield of which flags that values. */
-  private int set;
-
-  /** Flag values. */
-  private final int[] values = new int[COUNT];
-
-  void clear() {
-    set = 0;
-    Arrays.fill(values, 0);
-  }
-
-  Settings set(int id, int value) {
-    if (id < 0 || id >= values.length) {
-      return this; // Discard unknown settings.
-    }
-
-    int bit = 1 << id;
-    set |= bit;
-    values[id] = value;
-    return this;
-  }
-
-  /** Returns true if a value has been assigned for the setting {@code id}. */
-  boolean isSet(int id) {
-    int bit = 1 << id;
-    return (set & bit) != 0;
-  }
-
-  /** Returns the value for the setting {@code id}, or 0 if unset. */
-  int get(int id) {
-    return values[id];
-  }
-
-  /** Returns the number of settings that have values assigned. */
-  int size() {
-    return Integer.bitCount(set);
-  }
-
-  /** Returns -1 if unset. */
-  int getHeaderTableSize() {
-    int bit = 1 << HEADER_TABLE_SIZE;
-    return (bit & set) != 0 ? values[HEADER_TABLE_SIZE] : -1;
-  }
-
-  // TODO: honor this setting.
-  boolean getEnablePush(boolean defaultValue) {
-    int bit = 1 << ENABLE_PUSH;
-    return ((bit & set) != 0 ? values[ENABLE_PUSH] : defaultValue ? 1 : 0) == 1;
-  }
-
-  int getMaxConcurrentStreams(int defaultValue) {
-    int bit = 1 << MAX_CONCURRENT_STREAMS;
-    return (bit & set) != 0 ? values[MAX_CONCURRENT_STREAMS] : defaultValue;
-  }
-
-  int getMaxFrameSize(int defaultValue) {
-    int bit = 1 << MAX_FRAME_SIZE;
-    return (bit & set) != 0 ? values[MAX_FRAME_SIZE] : defaultValue;
-  }
-
-  int getMaxHeaderListSize(int defaultValue) {
-    int bit = 1 << MAX_HEADER_LIST_SIZE;
-    return (bit & set) != 0 ? values[MAX_HEADER_LIST_SIZE] : defaultValue;
-  }
-
-  int getInitialWindowSize() {
-    int bit = 1 << INITIAL_WINDOW_SIZE;
-    return (bit & set) != 0 ? values[INITIAL_WINDOW_SIZE] : DEFAULT_INITIAL_WINDOW_SIZE;
-  }
-
-  /**
-   * Writes {@code other} into this. If any setting is populated by this and {@code other}, the
-   * value and flags from {@code other} will be kept.
-   */
-  void merge(Settings other) {
-    for (int i = 0; i < COUNT; i++) {
-      if (!other.isSet(i)) continue;
-      set(i, other.get(i));
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/StreamResetException.java b/okhttp/src/main/java/okhttp3/internal/http2/StreamResetException.java
deleted file mode 100644
index 299f81e1b9..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http2/StreamResetException.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import java.io.IOException;
-
-/** Thrown when an HTTP/2 stream is canceled without damage to the socket that carries it. */
-public final class StreamResetException extends IOException {
-  public final ErrorCode errorCode;
-
-  public StreamResetException(ErrorCode errorCode) {
-    super("stream was reset: " + errorCode);
-    this.errorCode = errorCode;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/io/FileSystem.java b/okhttp/src/main/java/okhttp3/internal/io/FileSystem.java
deleted file mode 100644
index 0b1b1cfbc4..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/io/FileSystem.java
+++ /dev/null
@@ -1,137 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.io;
-
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import okio.Okio;
-import okio.Sink;
-import okio.Source;
-
-/**
- * Access to read and write files on a hierarchical data store. Most callers should use the {@link
- * #SYSTEM} implementation, which uses the host machine's local file system. Alternate
- * implementations may be used to inject faults (for testing) or to transform stored data (to add
- * encryption, for example).
- *
- * <p>All operations on a file system are racy. For example, guarding a call to {@link #source} with
- * {@link #exists} does not guarantee that {@link FileNotFoundException} will not be thrown. The
- * file may be moved between the two calls!
- *
- * <p>This interface is less ambitious than {@link java.nio.file.FileSystem} introduced in Java 7.
- * It lacks important features like file watching, metadata, permissions, and disk space
- * information. In exchange for these limitations, this interface is easier to implement and works
- * on all versions of Java and Android.
- */
-public interface FileSystem {
-  /** The host machine's local file system. */
-  FileSystem SYSTEM = new FileSystem() {
-    @Override public Source source(File file) throws FileNotFoundException {
-      return Okio.source(file);
-    }
-
-    @Override public Sink sink(File file) throws FileNotFoundException {
-      try {
-        return Okio.sink(file);
-      } catch (FileNotFoundException e) {
-        // Maybe the parent directory doesn't exist? Try creating it first.
-        file.getParentFile().mkdirs();
-        return Okio.sink(file);
-      }
-    }
-
-    @Override public Sink appendingSink(File file) throws FileNotFoundException {
-      try {
-        return Okio.appendingSink(file);
-      } catch (FileNotFoundException e) {
-        // Maybe the parent directory doesn't exist? Try creating it first.
-        file.getParentFile().mkdirs();
-        return Okio.appendingSink(file);
-      }
-    }
-
-    @Override public void delete(File file) throws IOException {
-      // If delete() fails, make sure it's because the file didn't exist!
-      if (!file.delete() && file.exists()) {
-        throw new IOException("failed to delete " + file);
-      }
-    }
-
-    @Override public boolean exists(File file) {
-      return file.exists();
-    }
-
-    @Override public long size(File file) {
-      return file.length();
-    }
-
-    @Override public void rename(File from, File to) throws IOException {
-      delete(to);
-      if (!from.renameTo(to)) {
-        throw new IOException("failed to rename " + from + " to " + to);
-      }
-    }
-
-    @Override public void deleteContents(File directory) throws IOException {
-      File[] files = directory.listFiles();
-      if (files == null) {
-        throw new IOException("not a readable directory: " + directory);
-      }
-      for (File file : files) {
-        if (file.isDirectory()) {
-          deleteContents(file);
-        }
-        if (!file.delete()) {
-          throw new IOException("failed to delete " + file);
-        }
-      }
-    }
-  };
-
-  /** Reads from {@code file}. */
-  Source source(File file) throws FileNotFoundException;
-
-  /**
-   * Writes to {@code file}, discarding any data already present. Creates parent directories if
-   * necessary.
-   */
-  Sink sink(File file) throws FileNotFoundException;
-
-  /**
-   * Writes to {@code file}, appending if data is already present. Creates parent directories if
-   * necessary.
-   */
-  Sink appendingSink(File file) throws FileNotFoundException;
-
-  /** Deletes {@code file} if it exists. Throws if the file exists and cannot be deleted. */
-  void delete(File file) throws IOException;
-
-  /** Returns true if {@code file} exists on the file system. */
-  boolean exists(File file);
-
-  /** Returns the number of bytes stored in {@code file}, or 0 if it does not exist. */
-  long size(File file);
-
-  /** Renames {@code from} to {@code to}. Throws if the file cannot be renamed. */
-  void rename(File from, File to) throws IOException;
-
-  /**
-   * Recursively delete the contents of {@code directory}. Throws an IOException if any file could
-   * not be deleted, or if {@code dir} is not a readable directory.
-   */
-  void deleteContents(File directory) throws IOException;
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java b/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java
deleted file mode 100644
index 632fbb0002..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java
+++ /dev/null
@@ -1,424 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.platform;
-
-import android.os.Build;
-import android.util.Log;
-import java.io.IOException;
-import java.lang.reflect.Constructor;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.net.InetSocketAddress;
-import java.net.Socket;
-import java.security.NoSuchAlgorithmException;
-import java.security.cert.Certificate;
-import java.security.cert.TrustAnchor;
-import java.security.cert.X509Certificate;
-import java.util.List;
-import javax.annotation.Nullable;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.Protocol;
-import okhttp3.internal.Util;
-import okhttp3.internal.tls.BasicTrustRootIndex;
-import okhttp3.internal.tls.CertificateChainCleaner;
-import okhttp3.internal.tls.TrustRootIndex;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-
-/** Android 5+. */
-class AndroidPlatform extends Platform {
-  private static final int MAX_LOG_LENGTH = 4000;
-
-  private final Class<?> sslParametersClass;
-  private final Class<?> sslSocketClass;
-  private final Method setUseSessionTickets;
-  private final Method setHostname;
-  private final Method getAlpnSelectedProtocol;
-  private final Method setAlpnProtocols;
-
-  private final CloseGuard closeGuard = CloseGuard.get();
-
-  AndroidPlatform(Class<?> sslParametersClass, Class<?> sslSocketClass, Method setUseSessionTickets,
-      Method setHostname, Method getAlpnSelectedProtocol, Method setAlpnProtocols) {
-    this.sslParametersClass = sslParametersClass;
-    this.sslSocketClass = sslSocketClass;
-    this.setUseSessionTickets = setUseSessionTickets;
-    this.setHostname = setHostname;
-    this.getAlpnSelectedProtocol = getAlpnSelectedProtocol;
-    this.setAlpnProtocols = setAlpnProtocols;
-  }
-
-  @Override public void connectSocket(Socket socket, InetSocketAddress address,
-      int connectTimeout) throws IOException {
-    try {
-      socket.connect(address, connectTimeout);
-    } catch (AssertionError e) {
-      if (Util.isAndroidGetsocknameError(e)) throw new IOException(e);
-      throw e;
-    } catch (ClassCastException e) {
-      // On android 8.0, socket.connect throws a ClassCastException due to a bug
-      // see https://issuetracker.google.com/issues/63649622
-      if (Build.VERSION.SDK_INT == 26) {
-        throw new IOException("Exception in connect", e);
-      } else {
-        throw e;
-      }
-    }
-  }
-
-  @Override protected @Nullable X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
-    Object context = readFieldOrNull(sslSocketFactory, sslParametersClass, "sslParameters");
-    if (context == null) {
-      // If that didn't work, try the Google Play Services SSL provider before giving up. This
-      // must be loaded by the SSLSocketFactory's class loader.
-      try {
-        Class<?> gmsSslParametersClass = Class.forName(
-            "com.google.android.gms.org.conscrypt.SSLParametersImpl", false,
-            sslSocketFactory.getClass().getClassLoader());
-        context = readFieldOrNull(sslSocketFactory, gmsSslParametersClass, "sslParameters");
-      } catch (ClassNotFoundException e) {
-        return super.trustManager(sslSocketFactory);
-      }
-    }
-
-    X509TrustManager x509TrustManager = readFieldOrNull(
-        context, X509TrustManager.class, "x509TrustManager");
-    if (x509TrustManager != null) return x509TrustManager;
-
-    return readFieldOrNull(context, X509TrustManager.class, "trustManager");
-  }
-
-  @Override public void configureTlsExtensions(
-      SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
-    if (!sslSocketClass.isInstance(sslSocket)) {
-      return; // No TLS extensions if the socket class is custom.
-    }
-    try {
-      // Enable SNI and session tickets.
-      if (hostname != null) {
-        setUseSessionTickets.invoke(sslSocket, true);
-        // This is SSLParameters.setServerNames() in API 24+.
-        setHostname.invoke(sslSocket, hostname);
-      }
-
-      // Enable ALPN.
-      setAlpnProtocols.invoke(sslSocket, concatLengthPrefixed(protocols));
-    } catch (IllegalAccessException | InvocationTargetException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  @Override public @Nullable String getSelectedProtocol(SSLSocket socket) {
-    if (!sslSocketClass.isInstance(socket)) {
-      return null; // No TLS extensions if the socket class is custom.
-    }
-    try {
-      byte[] alpnResult = (byte[]) getAlpnSelectedProtocol.invoke(socket);
-      return alpnResult != null ? new String(alpnResult, UTF_8) : null;
-    } catch (IllegalAccessException | InvocationTargetException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  @Override public void log(int level, String message, @Nullable Throwable t) {
-    int logLevel = level == WARN ? Log.WARN : Log.DEBUG;
-    if (t != null) message = message + '\n' + Log.getStackTraceString(t);
-
-    // Split by line, then ensure each line can fit into Log's maximum length.
-    for (int i = 0, length = message.length(); i < length; i++) {
-      int newline = message.indexOf('\n', i);
-      newline = newline != -1 ? newline : length;
-      do {
-        int end = Math.min(newline, i + MAX_LOG_LENGTH);
-        Log.println(logLevel, "OkHttp", message.substring(i, end));
-        i = end;
-      } while (i < newline);
-    }
-  }
-
-  @Override public @Nullable Object getStackTraceForCloseable(String closer) {
-    return closeGuard.createAndOpen(closer);
-  }
-
-  @Override public void logCloseableLeak(String message, Object stackTrace) {
-    boolean reported = closeGuard.warnIfOpen(stackTrace);
-    if (!reported) {
-      // Unable to report via CloseGuard. As a last-ditch effort, send it to the logger.
-      log(WARN, message, null);
-    }
-  }
-
-  @Override public boolean isCleartextTrafficPermitted(String hostname) {
-    try {
-      Class<?> networkPolicyClass = Class.forName("android.security.NetworkSecurityPolicy");
-      Method getInstanceMethod = networkPolicyClass.getMethod("getInstance");
-      Object networkSecurityPolicy = getInstanceMethod.invoke(null);
-      return api24IsCleartextTrafficPermitted(hostname, networkPolicyClass, networkSecurityPolicy);
-    } catch (ClassNotFoundException | NoSuchMethodException e) {
-      return super.isCleartextTrafficPermitted(hostname);
-    } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
-      throw new AssertionError("unable to determine cleartext support", e);
-    }
-  }
-
-  private boolean api24IsCleartextTrafficPermitted(String hostname, Class<?> networkPolicyClass,
-      Object networkSecurityPolicy) throws InvocationTargetException, IllegalAccessException {
-    try {
-      Method isCleartextTrafficPermittedMethod = networkPolicyClass
-          .getMethod("isCleartextTrafficPermitted", String.class);
-      return (boolean) isCleartextTrafficPermittedMethod.invoke(networkSecurityPolicy, hostname);
-    } catch (NoSuchMethodException e) {
-      return api23IsCleartextTrafficPermitted(hostname, networkPolicyClass, networkSecurityPolicy);
-    }
-  }
-
-  private boolean api23IsCleartextTrafficPermitted(String hostname, Class<?> networkPolicyClass,
-      Object networkSecurityPolicy) throws InvocationTargetException, IllegalAccessException {
-    try {
-      Method isCleartextTrafficPermittedMethod = networkPolicyClass
-          .getMethod("isCleartextTrafficPermitted");
-      return (boolean) isCleartextTrafficPermittedMethod.invoke(networkSecurityPolicy);
-    } catch (NoSuchMethodException e) {
-      return super.isCleartextTrafficPermitted(hostname);
-    }
-  }
-
-  public CertificateChainCleaner buildCertificateChainCleaner(X509TrustManager trustManager) {
-    try {
-      Class<?> extensionsClass = Class.forName("android.net.http.X509TrustManagerExtensions");
-      Constructor<?> constructor = extensionsClass.getConstructor(X509TrustManager.class);
-      Object extensions = constructor.newInstance(trustManager);
-      Method checkServerTrusted = extensionsClass.getMethod(
-          "checkServerTrusted", X509Certificate[].class, String.class, String.class);
-      return new AndroidCertificateChainCleaner(extensions, checkServerTrusted);
-    } catch (Exception e) {
-      return super.buildCertificateChainCleaner(trustManager);
-    }
-  }
-
-  public static @Nullable Platform buildIfSupported() {
-    // Attempt to find Android 5+ APIs.
-    Class<?> sslParametersClass;
-    Class<?> sslSocketClass;
-    try {
-      sslParametersClass = Class.forName("com.android.org.conscrypt.SSLParametersImpl");
-      sslSocketClass = Class.forName("com.android.org.conscrypt.OpenSSLSocketImpl");
-    } catch (ClassNotFoundException ignored) {
-      return null; // Not an Android runtime.
-    }
-    if (Build.VERSION.SDK_INT >= 21) {
-      try {
-        Method setUseSessionTickets = sslSocketClass.getDeclaredMethod(
-            "setUseSessionTickets", boolean.class);
-        Method setHostname = sslSocketClass.getMethod("setHostname", String.class);
-        Method getAlpnSelectedProtocol = sslSocketClass.getMethod("getAlpnSelectedProtocol");
-        Method setAlpnProtocols = sslSocketClass.getMethod("setAlpnProtocols", byte[].class);
-        return new AndroidPlatform(sslParametersClass, sslSocketClass, setUseSessionTickets,
-            setHostname, getAlpnSelectedProtocol, setAlpnProtocols);
-      } catch (NoSuchMethodException ignored) {
-      }
-    }
-    throw new IllegalStateException(
-        "Expected Android API level 21+ but was " + Build.VERSION.SDK_INT);
-  }
-
-  @Override public TrustRootIndex buildTrustRootIndex(X509TrustManager trustManager) {
-    try {
-      // From org.conscrypt.TrustManagerImpl, we want the method with this signature:
-      // private TrustAnchor findTrustAnchorByIssuerAndSignature(X509Certificate lastCert);
-      Method method = trustManager.getClass().getDeclaredMethod(
-          "findTrustAnchorByIssuerAndSignature", X509Certificate.class);
-      method.setAccessible(true);
-      return new CustomTrustRootIndex(trustManager, method);
-    } catch (NoSuchMethodException e) {
-      return super.buildTrustRootIndex(trustManager);
-    }
-  }
-
-  /**
-   * X509TrustManagerExtensions was added to Android in API 17 (Android 4.2, released in late 2012).
-   * This is the best way to get a clean chain on Android because it uses the same code as the TLS
-   * handshake.
-   */
-  static final class AndroidCertificateChainCleaner extends CertificateChainCleaner {
-    private final Object x509TrustManagerExtensions;
-    private final Method checkServerTrusted;
-
-    AndroidCertificateChainCleaner(Object x509TrustManagerExtensions, Method checkServerTrusted) {
-      this.x509TrustManagerExtensions = x509TrustManagerExtensions;
-      this.checkServerTrusted = checkServerTrusted;
-    }
-
-    @SuppressWarnings({"unchecked", "SuspiciousToArrayCall"}) // Reflection on List<Certificate>.
-    @Override public List<Certificate> clean(List<Certificate> chain, String hostname)
-        throws SSLPeerUnverifiedException {
-      try {
-        X509Certificate[] certificates = chain.toArray(new X509Certificate[chain.size()]);
-        return (List<Certificate>) checkServerTrusted.invoke(
-            x509TrustManagerExtensions, certificates, "RSA", hostname);
-      } catch (InvocationTargetException e) {
-        SSLPeerUnverifiedException exception = new SSLPeerUnverifiedException(e.getMessage());
-        exception.initCause(e);
-        throw exception;
-      } catch (IllegalAccessException e) {
-        throw new AssertionError(e);
-      }
-    }
-
-    @Override public boolean equals(Object other) {
-      return other instanceof AndroidCertificateChainCleaner; // All instances are equivalent.
-    }
-
-    @Override public int hashCode() {
-      return 0;
-    }
-  }
-
-  /**
-   * Provides access to the internal dalvik.system.CloseGuard class. Android uses this in
-   * combination with android.os.StrictMode to report on leaked java.io.Closeable's. Available since
-   * Android API 11.
-   */
-  static final class CloseGuard {
-    private final Method getMethod;
-    private final Method openMethod;
-    private final Method warnIfOpenMethod;
-
-    CloseGuard(Method getMethod, Method openMethod, Method warnIfOpenMethod) {
-      this.getMethod = getMethod;
-      this.openMethod = openMethod;
-      this.warnIfOpenMethod = warnIfOpenMethod;
-    }
-
-    Object createAndOpen(String closer) {
-      if (getMethod != null) {
-        try {
-          Object closeGuardInstance = getMethod.invoke(null);
-          openMethod.invoke(closeGuardInstance, closer);
-          return closeGuardInstance;
-        } catch (Exception ignored) {
-        }
-      }
-      return null;
-    }
-
-    boolean warnIfOpen(Object closeGuardInstance) {
-      boolean reported = false;
-      if (closeGuardInstance != null) {
-        try {
-          warnIfOpenMethod.invoke(closeGuardInstance);
-          reported = true;
-        } catch (Exception ignored) {
-        }
-      }
-      return reported;
-    }
-
-    static CloseGuard get() {
-      Method getMethod;
-      Method openMethod;
-      Method warnIfOpenMethod;
-
-      try {
-        Class<?> closeGuardClass = Class.forName("dalvik.system.CloseGuard");
-        getMethod = closeGuardClass.getMethod("get");
-        openMethod = closeGuardClass.getMethod("open", String.class);
-        warnIfOpenMethod = closeGuardClass.getMethod("warnIfOpen");
-      } catch (Exception ignored) {
-        getMethod = null;
-        openMethod = null;
-        warnIfOpenMethod = null;
-      }
-      return new CloseGuard(getMethod, openMethod, warnIfOpenMethod);
-    }
-  }
-
-  /**
-   * A trust manager for Android applications that customize the trust manager.
-   *
-   * <p>This class exploits knowledge of Android implementation details. This class is potentially
-   * much faster to initialize than {@link BasicTrustRootIndex} because it doesn't need to load and
-   * index trusted CA certificates.
-   */
-  static final class CustomTrustRootIndex implements TrustRootIndex {
-    private final X509TrustManager trustManager;
-    private final Method findByIssuerAndSignatureMethod;
-
-    CustomTrustRootIndex(X509TrustManager trustManager, Method findByIssuerAndSignatureMethod) {
-      this.findByIssuerAndSignatureMethod = findByIssuerAndSignatureMethod;
-      this.trustManager = trustManager;
-    }
-
-    @Override public X509Certificate findByIssuerAndSignature(X509Certificate cert) {
-      try {
-        TrustAnchor trustAnchor = (TrustAnchor) findByIssuerAndSignatureMethod.invoke(
-            trustManager, cert);
-        return trustAnchor != null
-            ? trustAnchor.getTrustedCert()
-            : null;
-      } catch (IllegalAccessException e) {
-        throw new AssertionError("unable to get issues and signature", e);
-      } catch (InvocationTargetException e) {
-        return null;
-      }
-    }
-
-    @Override public boolean equals(Object obj) {
-      if (obj == this) {
-        return true;
-      }
-      if (!(obj instanceof CustomTrustRootIndex)) {
-        return false;
-      }
-      CustomTrustRootIndex that = (CustomTrustRootIndex) obj;
-      return trustManager.equals(that.trustManager)
-          && findByIssuerAndSignatureMethod.equals(that.findByIssuerAndSignatureMethod);
-    }
-
-    @Override public int hashCode() {
-      return trustManager.hashCode() + 31 * findByIssuerAndSignatureMethod.hashCode();
-    }
-  }
-
-  @Override public SSLContext getSSLContext() {
-    boolean tryTls12;
-    try {
-      tryTls12 = (Build.VERSION.SDK_INT >= 16 && Build.VERSION.SDK_INT < 22);
-    } catch (NoClassDefFoundError e) {
-      // Not a real Android runtime; probably RoboVM or MoE
-      // Try to load TLS 1.2 explicitly.
-      tryTls12 = true;
-    }
-
-    if (tryTls12) {
-      try {
-        return SSLContext.getInstance("TLSv1.2");
-      } catch (NoSuchAlgorithmException e) {
-        // fallback to TLS
-      }
-    }
-
-    try {
-      return SSLContext.getInstance("TLS");
-    } catch (NoSuchAlgorithmException e) {
-      throw new IllegalStateException("No TLS provider", e);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.java b/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.java
deleted file mode 100644
index 7258735eed..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.java
+++ /dev/null
@@ -1,124 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.platform;
-
-import java.security.NoSuchAlgorithmException;
-import java.security.Provider;
-import java.util.List;
-import javax.annotation.Nullable;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.Protocol;
-import org.conscrypt.Conscrypt;
-
-/**
- * Platform using Conscrypt (conscrypt.org) if installed as the first Security Provider.
- *
- * Requires org.conscrypt:conscrypt-openjdk-uber on the classpath.
- */
-public class ConscryptPlatform extends Platform {
-  private ConscryptPlatform() {
-  }
-
-  @SuppressWarnings("deprecation") private Provider getProvider() {
-    // defaults to true, but allow for older versions of conscrypt if still compatible
-    // new form with boolean is only present in >= 2.0.0
-    return Conscrypt.newProviderBuilder().provideTrustManager().build();
-  }
-
-  @Override public @Nullable X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
-    if (!Conscrypt.isConscrypt(sslSocketFactory)) {
-      return super.trustManager(sslSocketFactory);
-    }
-
-    try {
-      // org.conscrypt.SSLParametersImpl
-      Object sp =
-          readFieldOrNull(sslSocketFactory, Object.class, "sslParameters");
-
-      if (sp != null) {
-        return readFieldOrNull(sp, X509TrustManager.class, "x509TrustManager");
-      }
-
-      return null;
-    } catch (Exception e) {
-      throw new UnsupportedOperationException(
-          "clientBuilder.sslSocketFactory(SSLSocketFactory) not supported on Conscrypt", e);
-    }
-  }
-
-  @Override public void configureTlsExtensions(
-      SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
-    if (Conscrypt.isConscrypt(sslSocket)) {
-      // Enable SNI and session tickets.
-      if (hostname != null) {
-        Conscrypt.setUseSessionTickets(sslSocket, true);
-        Conscrypt.setHostname(sslSocket, hostname);
-      }
-
-      // Enable ALPN.
-      List<String> names = Platform.alpnProtocolNames(protocols);
-      Conscrypt.setApplicationProtocols(sslSocket, names.toArray(new String[0]));
-    } else {
-      super.configureTlsExtensions(sslSocket, hostname, protocols);
-    }
-  }
-
-  @Override public @Nullable String getSelectedProtocol(SSLSocket sslSocket) {
-    if (Conscrypt.isConscrypt(sslSocket)) {
-      return Conscrypt.getApplicationProtocol(sslSocket);
-    } else {
-      return super.getSelectedProtocol(sslSocket);
-    }
-  }
-
-  @Override public SSLContext getSSLContext() {
-    try {
-      return SSLContext.getInstance("TLSv1.3", getProvider());
-    } catch (NoSuchAlgorithmException e) {
-      try {
-        // Allow for Conscrypt 1.2
-        return SSLContext.getInstance("TLS", getProvider());
-      } catch (NoSuchAlgorithmException e2) {
-        throw new IllegalStateException("No TLS provider", e);
-      }
-    }
-  }
-
-  public static ConscryptPlatform buildIfSupported() {
-    try {
-      // Trigger an early exception over a fatal error, prefer a RuntimeException over Error.
-      Class.forName("org.conscrypt.Conscrypt");
-
-      if (!Conscrypt.isAvailable()) {
-        return null;
-      }
-
-      return new ConscryptPlatform();
-    } catch (ClassNotFoundException e) {
-      return null;
-    }
-  }
-
-  @Override
-  public void configureSslSocketFactory(SSLSocketFactory socketFactory) {
-    if (Conscrypt.isConscrypt(socketFactory)) {
-      Conscrypt.setUseEngineSocket(socketFactory, true);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatform.java b/okhttp/src/main/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatform.java
deleted file mode 100644
index c2b6ce5f4d..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatform.java
+++ /dev/null
@@ -1,149 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.platform;
-
-import java.lang.reflect.InvocationHandler;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.lang.reflect.Proxy;
-import java.util.List;
-import javax.annotation.Nullable;
-import javax.net.ssl.SSLSocket;
-import okhttp3.Protocol;
-import okhttp3.internal.Util;
-
-/** OpenJDK 8 with {@code org.mortbay.jetty.alpn:alpn-boot} in the boot class path. */
-class Jdk8WithJettyBootPlatform extends Platform {
-  private final Method putMethod;
-  private final Method getMethod;
-  private final Method removeMethod;
-  private final Class<?> clientProviderClass;
-  private final Class<?> serverProviderClass;
-
-  Jdk8WithJettyBootPlatform(Method putMethod, Method getMethod, Method removeMethod,
-      Class<?> clientProviderClass, Class<?> serverProviderClass) {
-    this.putMethod = putMethod;
-    this.getMethod = getMethod;
-    this.removeMethod = removeMethod;
-    this.clientProviderClass = clientProviderClass;
-    this.serverProviderClass = serverProviderClass;
-  }
-
-  @Override public void configureTlsExtensions(
-      SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
-    List<String> names = alpnProtocolNames(protocols);
-
-    try {
-      Object alpnProvider = Proxy.newProxyInstance(Platform.class.getClassLoader(),
-          new Class[] {clientProviderClass, serverProviderClass}, new AlpnProvider(names));
-      putMethod.invoke(null, sslSocket, alpnProvider);
-    } catch (InvocationTargetException | IllegalAccessException e) {
-      throw new AssertionError("failed to set ALPN", e);
-    }
-  }
-
-  @Override public void afterHandshake(SSLSocket sslSocket) {
-    try {
-      removeMethod.invoke(null, sslSocket);
-    } catch (IllegalAccessException | InvocationTargetException e) {
-      throw new AssertionError("failed to remove ALPN", e);
-    }
-  }
-
-  @Override public @Nullable String getSelectedProtocol(SSLSocket socket) {
-    try {
-      AlpnProvider provider =
-          (AlpnProvider) Proxy.getInvocationHandler(getMethod.invoke(null, socket));
-      if (!provider.unsupported && provider.selected == null) {
-        Platform.get().log(INFO, "ALPN callback dropped: HTTP/2 is disabled. "
-            + "Is alpn-boot on the boot class path?", null);
-        return null;
-      }
-      return provider.unsupported ? null : provider.selected;
-    } catch (InvocationTargetException | IllegalAccessException e) {
-      throw new AssertionError("failed to get ALPN selected protocol", e);
-    }
-  }
-
-  public static Platform buildIfSupported() {
-    // Find Jetty's ALPN extension for OpenJDK.
-    try {
-      String alpnClassName = "org.eclipse.jetty.alpn.ALPN";
-      Class<?> alpnClass = Class.forName(alpnClassName, true, null);
-      Class<?> providerClass = Class.forName(alpnClassName + "$Provider", true, null);
-      Class<?> clientProviderClass = Class.forName(alpnClassName + "$ClientProvider", true, null);
-      Class<?> serverProviderClass = Class.forName(alpnClassName + "$ServerProvider", true, null);
-      Method putMethod = alpnClass.getMethod("put", SSLSocket.class, providerClass);
-      Method getMethod = alpnClass.getMethod("get", SSLSocket.class);
-      Method removeMethod = alpnClass.getMethod("remove", SSLSocket.class);
-      return new Jdk8WithJettyBootPlatform(
-          putMethod, getMethod, removeMethod, clientProviderClass, serverProviderClass);
-    } catch (ClassNotFoundException | NoSuchMethodException ignored) {
-    }
-
-    return null;
-  }
-
-  /**
-   * Handle the methods of ALPN's ClientProvider and ServerProvider without a compile-time
-   * dependency on those interfaces.
-   */
-  private static class AlpnProvider implements InvocationHandler {
-    /** This peer's supported protocols. */
-    private final List<String> protocols;
-    /** Set when remote peer notifies ALPN is unsupported. */
-    boolean unsupported;
-    /** The protocol the server selected. */
-    String selected;
-
-    AlpnProvider(List<String> protocols) {
-      this.protocols = protocols;
-    }
-
-    @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
-      String methodName = method.getName();
-      Class<?> returnType = method.getReturnType();
-      if (args == null) {
-        args = Util.EMPTY_STRING_ARRAY;
-      }
-      if (methodName.equals("supports") && boolean.class == returnType) {
-        return true; // ALPN is supported.
-      } else if (methodName.equals("unsupported") && void.class == returnType) {
-        this.unsupported = true; // Peer doesn't support ALPN.
-        return null;
-      } else if (methodName.equals("protocols") && args.length == 0) {
-        return protocols; // Client advertises these protocols.
-      } else if ((methodName.equals("selectProtocol") || methodName.equals("select"))
-          && String.class == returnType && args.length == 1 && args[0] instanceof List) {
-        List<?> peerProtocols = (List) args[0];
-        // Pick the first known protocol the peer advertises.
-        for (int i = 0, size = peerProtocols.size(); i < size; i++) {
-          String protocol = (String) peerProtocols.get(i);
-          if (protocols.contains(protocol)) {
-            return selected = protocol;
-          }
-        }
-        return selected = protocols.get(0); // On no intersection, try peer's first protocol.
-      } else if ((methodName.equals("protocolSelected") || methodName.equals("selected"))
-          && args.length == 1) {
-        this.selected = (String) args[0]; // Server selected this protocol.
-        return null;
-      } else {
-        return method.invoke(this, args);
-      }
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java b/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java
deleted file mode 100644
index 07cb67c885..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.platform;
-
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.util.List;
-import javax.annotation.Nullable;
-import javax.net.ssl.SSLParameters;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.Protocol;
-
-/** OpenJDK 9+. */
-final class Jdk9Platform extends Platform {
-  final Method setProtocolMethod;
-  final Method getProtocolMethod;
-
-  Jdk9Platform(Method setProtocolMethod, Method getProtocolMethod) {
-    this.setProtocolMethod = setProtocolMethod;
-    this.getProtocolMethod = getProtocolMethod;
-  }
-
-  @Override
-  public void configureTlsExtensions(SSLSocket sslSocket, String hostname,
-      List<Protocol> protocols) {
-    try {
-      SSLParameters sslParameters = sslSocket.getSSLParameters();
-
-      List<String> names = alpnProtocolNames(protocols);
-
-      setProtocolMethod.invoke(sslParameters,
-          new Object[] {names.toArray(new String[names.size()])});
-
-      sslSocket.setSSLParameters(sslParameters);
-    } catch (IllegalAccessException | InvocationTargetException e) {
-      throw new AssertionError("failed to set SSL parameters", e);
-    }
-  }
-
-  @Override
-  public @Nullable String getSelectedProtocol(SSLSocket socket) {
-    try {
-      String protocol = (String) getProtocolMethod.invoke(socket);
-
-      // SSLSocket.getApplicationProtocol returns "" if application protocols values will not
-      // be used. Observed if you didn't specify SSLParameters.setApplicationProtocols
-      if (protocol == null || protocol.equals("")) {
-        return null;
-      }
-
-      return protocol;
-    } catch (IllegalAccessException | InvocationTargetException e) {
-      throw new AssertionError("failed to get ALPN selected protocol", e);
-    }
-  }
-
-  @Override public X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
-    // Not supported due to access checks on JDK 9+:
-    // java.lang.reflect.InaccessibleObjectException: Unable to make member of class
-    // sun.security.ssl.SSLSocketFactoryImpl accessible:  module java.base does not export
-    // sun.security.ssl to unnamed module @xxx
-    throw new UnsupportedOperationException(
-        "clientBuilder.sslSocketFactory(SSLSocketFactory) not supported on JDK 9+");
-  }
-
-  public static Jdk9Platform buildIfSupported() {
-    // Find JDK 9 new methods
-    try {
-      Method setProtocolMethod =
-          SSLParameters.class.getMethod("setApplicationProtocols", String[].class);
-      Method getProtocolMethod = SSLSocket.class.getMethod("getApplicationProtocol");
-
-      return new Jdk9Platform(setProtocolMethod, getProtocolMethod);
-    } catch (NoSuchMethodException ignored) {
-      // pre JDK 9
-    }
-
-    return null;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Platform.java b/okhttp/src/main/java/okhttp3/internal/platform/Platform.java
deleted file mode 100644
index aa379e4058..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/platform/Platform.java
+++ /dev/null
@@ -1,288 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.platform;
-
-import java.io.IOException;
-import java.lang.reflect.Field;
-import java.net.InetSocketAddress;
-import java.net.Socket;
-import java.security.NoSuchAlgorithmException;
-import java.security.Security;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import javax.annotation.Nullable;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
-import okhttp3.internal.Util;
-import okhttp3.internal.tls.BasicCertificateChainCleaner;
-import okhttp3.internal.tls.BasicTrustRootIndex;
-import okhttp3.internal.tls.CertificateChainCleaner;
-import okhttp3.internal.tls.TrustRootIndex;
-import okio.Buffer;
-
-/**
- * Access to platform-specific features.
- *
- * <h3>Server name indication (SNI)</h3>
- *
- * <p>Supported on Android 2.3+.
- *
- * <p>Supported on OpenJDK 7+
- *
- * <h3>Session Tickets</h3>
- *
- * <p>Supported on Android 2.3+.
- *
- * <h3>Android Traffic Stats (Socket Tagging)</h3>
- *
- * <p>Supported on Android 4.0+.
- *
- * <h3>ALPN (Application Layer Protocol Negotiation)</h3>
- *
- * <p>Supported on Android 5.0+. The APIs were present in Android 4.4, but that implementation was
- * unstable.
- *
- * <p>Supported on OpenJDK 8 via the JettyALPN-boot library.
- *
- * <p>Supported on OpenJDK 9+ via SSLParameters and SSLSocket features.
- *
- * <h3>Trust Manager Extraction</h3>
- *
- * <p>Supported on Android 2.3+ and OpenJDK 7+. There are no public APIs to recover the trust
- * manager that was used to create an {@link SSLSocketFactory}.
- *
- * <h3>Android Cleartext Permit Detection</h3>
- *
- * <p>Supported on Android 6.0+ via {@code NetworkSecurityPolicy}.
- */
-public class Platform {
-  private static final Platform PLATFORM = findPlatform();
-  public static final int INFO = 4;
-  public static final int WARN = 5;
-  private static final Logger logger = Logger.getLogger(OkHttpClient.class.getName());
-
-  public static Platform get() {
-    return PLATFORM;
-  }
-
-  /** Prefix used on custom headers. */
-  public String getPrefix() {
-    return "OkHttp";
-  }
-
-  protected @Nullable X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
-    // Attempt to get the trust manager from an OpenJDK socket factory. We attempt this on all
-    // platforms in order to support Robolectric, which mixes classes from both Android and the
-    // Oracle JDK. Note that we don't support HTTP/2 or other nice features on Robolectric.
-    try {
-      Class<?> sslContextClass = Class.forName("sun.security.ssl.SSLContextImpl");
-      Object context = readFieldOrNull(sslSocketFactory, sslContextClass, "context");
-      if (context == null) return null;
-      return readFieldOrNull(context, X509TrustManager.class, "trustManager");
-    } catch (ClassNotFoundException e) {
-      return null;
-    }
-  }
-
-  /**
-   * Configure TLS extensions on {@code sslSocket} for {@code route}.
-   *
-   * @param hostname non-null for client-side handshakes; null for server-side handshakes.
-   */
-  public void configureTlsExtensions(SSLSocket sslSocket, @Nullable String hostname,
-      List<Protocol> protocols) {
-  }
-
-  /**
-   * Called after the TLS handshake to release resources allocated by {@link
-   * #configureTlsExtensions}.
-   */
-  public void afterHandshake(SSLSocket sslSocket) {
-  }
-
-  /** Returns the negotiated protocol, or null if no protocol was negotiated. */
-  public @Nullable String getSelectedProtocol(SSLSocket socket) {
-    return null;
-  }
-
-  public void connectSocket(Socket socket, InetSocketAddress address, int connectTimeout)
-      throws IOException {
-    socket.connect(address, connectTimeout);
-  }
-
-  public void log(int level, String message, @Nullable Throwable t) {
-    Level logLevel = level == WARN ? Level.WARNING : Level.INFO;
-    logger.log(logLevel, message, t);
-  }
-
-  public boolean isCleartextTrafficPermitted(String hostname) {
-    return true;
-  }
-
-  /**
-   * Returns an object that holds a stack trace created at the moment this method is executed. This
-   * should be used specifically for {@link java.io.Closeable} objects and in conjunction with
-   * {@link #logCloseableLeak(String, Object)}.
-   */
-  public @Nullable Object getStackTraceForCloseable(String closer) {
-    if (logger.isLoggable(Level.FINE)) {
-      return new Throwable(closer); // These are expensive to allocate.
-    }
-    return null;
-  }
-
-  public void logCloseableLeak(String message, Object stackTrace) {
-    if (stackTrace == null) {
-      message += " To see where this was allocated, set the OkHttpClient logger level to FINE: "
-          + "Logger.getLogger(OkHttpClient.class.getName()).setLevel(Level.FINE);";
-    }
-    log(WARN, message, (Throwable) stackTrace);
-  }
-
-  public static List<String> alpnProtocolNames(List<Protocol> protocols) {
-    List<String> names = new ArrayList<>(protocols.size());
-    for (int i = 0, size = protocols.size(); i < size; i++) {
-      Protocol protocol = protocols.get(i);
-      if (protocol == Protocol.HTTP_1_0) continue; // No HTTP/1.0 for ALPN.
-      names.add(protocol.toString());
-    }
-    return names;
-  }
-
-  public CertificateChainCleaner buildCertificateChainCleaner(X509TrustManager trustManager) {
-    return new BasicCertificateChainCleaner(buildTrustRootIndex(trustManager));
-  }
-
-  public CertificateChainCleaner buildCertificateChainCleaner(SSLSocketFactory sslSocketFactory) {
-    X509TrustManager trustManager = trustManager(sslSocketFactory);
-
-    if (trustManager == null) {
-      throw new IllegalStateException("Unable to extract the trust manager on "
-          + Platform.get()
-          + ", sslSocketFactory is "
-          + sslSocketFactory.getClass());
-    }
-
-    return buildCertificateChainCleaner(trustManager);
-  }
-
-  public static boolean isConscryptPreferred() {
-    // mainly to allow tests to run cleanly
-    if ("conscrypt".equals(Util.getSystemProperty("okhttp.platform", null))) {
-      return true;
-    }
-
-    // check if Provider manually installed
-    String preferredProvider = Security.getProviders()[0].getName();
-    return "Conscrypt".equals(preferredProvider);
-  }
-
-  /** Attempt to match the host runtime to a capable Platform implementation. */
-  private static Platform findPlatform() {
-    Platform android = AndroidPlatform.buildIfSupported();
-
-    if (android != null) {
-      return android;
-    }
-
-    if (isConscryptPreferred()) {
-      Platform conscrypt = ConscryptPlatform.buildIfSupported();
-
-      if (conscrypt != null) {
-        return conscrypt;
-      }
-    }
-
-    Platform jdk9 = Jdk9Platform.buildIfSupported();
-
-    if (jdk9 != null) {
-      return jdk9;
-    }
-
-    Platform jdkWithJettyBoot = Jdk8WithJettyBootPlatform.buildIfSupported();
-
-    if (jdkWithJettyBoot != null) {
-      return jdkWithJettyBoot;
-    }
-
-    // Probably an Oracle JDK like OpenJDK.
-    return new Platform();
-  }
-
-  /**
-   * Returns the concatenation of 8-bit, length prefixed protocol names.
-   * http://tools.ietf.org/html/draft-agl-tls-nextprotoneg-04#page-4
-   */
-  static byte[] concatLengthPrefixed(List<Protocol> protocols) {
-    Buffer result = new Buffer();
-    for (int i = 0, size = protocols.size(); i < size; i++) {
-      Protocol protocol = protocols.get(i);
-      if (protocol == Protocol.HTTP_1_0) continue; // No HTTP/1.0 for ALPN.
-      result.writeByte(protocol.toString().length());
-      result.writeUtf8(protocol.toString());
-    }
-    return result.readByteArray();
-  }
-
-  static @Nullable <T> T readFieldOrNull(Object instance, Class<T> fieldType, String fieldName) {
-    for (Class<?> c = instance.getClass(); c != Object.class; c = c.getSuperclass()) {
-      try {
-        Field field = c.getDeclaredField(fieldName);
-        field.setAccessible(true);
-        Object value = field.get(instance);
-        if (!fieldType.isInstance(value)) return null;
-        return fieldType.cast(value);
-      } catch (NoSuchFieldException ignored) {
-      } catch (IllegalAccessException e) {
-        throw new AssertionError();
-      }
-    }
-
-    // Didn't find the field we wanted. As a last gasp attempt, try to find the value on a delegate.
-    if (!fieldName.equals("delegate")) {
-      Object delegate = readFieldOrNull(instance, Object.class, "delegate");
-      if (delegate != null) return readFieldOrNull(delegate, fieldType, fieldName);
-    }
-
-    return null;
-  }
-
-  public SSLContext getSSLContext() {
-    try {
-      return SSLContext.getInstance("TLS");
-    } catch (NoSuchAlgorithmException e) {
-      throw new IllegalStateException("No TLS provider", e);
-    }
-  }
-
-  public TrustRootIndex buildTrustRootIndex(X509TrustManager trustManager) {
-    return new BasicTrustRootIndex(trustManager.getAcceptedIssuers());
-  }
-
-  public void configureSslSocketFactory(SSLSocketFactory socketFactory) {
-  }
-
-  @Override public String toString() {
-    return getClass().getSimpleName();
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/proxy/NullProxySelector.java b/okhttp/src/main/java/okhttp3/internal/proxy/NullProxySelector.java
deleted file mode 100644
index d18b6335f1..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/proxy/NullProxySelector.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.proxy;
-
-import java.io.IOException;
-import java.net.Proxy;
-import java.net.ProxySelector;
-import java.net.SocketAddress;
-import java.net.URI;
-import java.util.Collections;
-import java.util.List;
-
-/**
- * A proxy selector that always returns the {@link Proxy#NO_PROXY}.
- */
-public class NullProxySelector extends ProxySelector {
-  @Override public List<Proxy> select(URI uri) {
-    if (uri == null) {
-      throw new IllegalArgumentException("uri must not be null");
-    }
-    return Collections.singletonList(Proxy.NO_PROXY);
-  }
-
-  @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/BasicCertificateChainCleaner.java b/okhttp/src/main/java/okhttp3/internal/tls/BasicCertificateChainCleaner.java
deleted file mode 100644
index 8a8c1d11d2..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/tls/BasicCertificateChainCleaner.java
+++ /dev/null
@@ -1,124 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.tls;
-
-import java.security.GeneralSecurityException;
-import java.security.cert.Certificate;
-import java.security.cert.X509Certificate;
-import java.util.ArrayDeque;
-import java.util.ArrayList;
-import java.util.Deque;
-import java.util.Iterator;
-import java.util.List;
-import javax.net.ssl.SSLPeerUnverifiedException;
-
-/**
- * A certificate chain cleaner that uses a set of trusted root certificates to build the trusted
- * chain. This class duplicates the clean chain building performed during the TLS handshake. We
- * prefer other mechanisms where they exist, such as with
- * {@code okhttp3.internal.platform.AndroidPlatform.AndroidCertificateChainCleaner}.
- *
- * <p>This class includes code from <a href="https://conscrypt.org/">Conscrypt's</a> {@code
- * TrustManagerImpl} and {@code TrustedCertificateIndex}.
- */
-public final class BasicCertificateChainCleaner extends CertificateChainCleaner {
-  /** The maximum number of signers in a chain. We use 9 for consistency with OpenSSL. */
-  private static final int MAX_SIGNERS = 9;
-
-  private final TrustRootIndex trustRootIndex;
-
-  public BasicCertificateChainCleaner(TrustRootIndex trustRootIndex) {
-    this.trustRootIndex = trustRootIndex;
-  }
-
-  /**
-   * Returns a cleaned chain for {@code chain}.
-   *
-   * <p>This method throws if the complete chain to a trusted CA certificate cannot be constructed.
-   * This is unexpected unless the trust root index in this class has a different trust manager than
-   * what was used to establish {@code chain}.
-   */
-  @Override public List<Certificate> clean(List<Certificate> chain, String hostname)
-      throws SSLPeerUnverifiedException {
-    Deque<Certificate> queue = new ArrayDeque<>(chain);
-    List<Certificate> result = new ArrayList<>();
-    result.add(queue.removeFirst());
-    boolean foundTrustedCertificate = false;
-
-    followIssuerChain:
-    for (int c = 0; c < MAX_SIGNERS; c++) {
-      X509Certificate toVerify = (X509Certificate) result.get(result.size() - 1);
-
-      // If this cert has been signed by a trusted cert, use that. Add the trusted certificate to
-      // the end of the chain unless it's already present. (That would happen if the first
-      // certificate in the chain is itself a self-signed and trusted CA certificate.)
-      X509Certificate trustedCert = trustRootIndex.findByIssuerAndSignature(toVerify);
-      if (trustedCert != null) {
-        if (result.size() > 1 || !toVerify.equals(trustedCert)) {
-          result.add(trustedCert);
-        }
-        if (verifySignature(trustedCert, trustedCert)) {
-          return result; // The self-signed cert is a root CA. We're done.
-        }
-        foundTrustedCertificate = true;
-        continue;
-      }
-
-      // Search for the certificate in the chain that signed this certificate. This is typically
-      // the next element in the chain, but it could be any element.
-      for (Iterator<Certificate> i = queue.iterator(); i.hasNext(); ) {
-        X509Certificate signingCert = (X509Certificate) i.next();
-        if (verifySignature(toVerify, signingCert)) {
-          i.remove();
-          result.add(signingCert);
-          continue followIssuerChain;
-        }
-      }
-
-      // We've reached the end of the chain. If any cert in the chain is trusted, we're done.
-      if (foundTrustedCertificate) {
-        return result;
-      }
-
-      // The last link isn't trusted. Fail.
-      throw new SSLPeerUnverifiedException(
-          "Failed to find a trusted cert that signed " + toVerify);
-    }
-
-    throw new SSLPeerUnverifiedException("Certificate chain too long: " + result);
-  }
-
-  /** Returns true if {@code toVerify} was signed by {@code signingCert}'s public key. */
-  private boolean verifySignature(X509Certificate toVerify, X509Certificate signingCert) {
-    if (!toVerify.getIssuerDN().equals(signingCert.getSubjectDN())) return false;
-    try {
-      toVerify.verify(signingCert.getPublicKey());
-      return true;
-    } catch (GeneralSecurityException verifyFailed) {
-      return false;
-    }
-  }
-
-  @Override public int hashCode() {
-    return trustRootIndex.hashCode();
-  }
-
-  @Override public boolean equals(Object other) {
-    if (other == this) return true;
-    return other instanceof BasicCertificateChainCleaner
-        && ((BasicCertificateChainCleaner) other).trustRootIndex.equals(trustRootIndex);
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/BasicTrustRootIndex.java b/okhttp/src/main/java/okhttp3/internal/tls/BasicTrustRootIndex.java
deleted file mode 100644
index cfd8923668..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/tls/BasicTrustRootIndex.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.tls;
-
-import java.security.PublicKey;
-import java.security.cert.X509Certificate;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.Map;
-import java.util.Set;
-import javax.security.auth.x500.X500Principal;
-
-/** A simple index that of trusted root certificates that have been loaded into memory. */
-public final class BasicTrustRootIndex implements TrustRootIndex {
-  private final Map<X500Principal, Set<X509Certificate>> subjectToCaCerts;
-
-  public BasicTrustRootIndex(X509Certificate... caCerts) {
-    subjectToCaCerts = new LinkedHashMap<>();
-    for (X509Certificate caCert : caCerts) {
-      X500Principal subject = caCert.getSubjectX500Principal();
-      Set<X509Certificate> subjectCaCerts = subjectToCaCerts.get(subject);
-      if (subjectCaCerts == null) {
-        subjectCaCerts = new LinkedHashSet<>(1);
-        subjectToCaCerts.put(subject, subjectCaCerts);
-      }
-      subjectCaCerts.add(caCert);
-    }
-  }
-
-  @Override public X509Certificate findByIssuerAndSignature(X509Certificate cert) {
-    X500Principal issuer = cert.getIssuerX500Principal();
-    Set<X509Certificate> subjectCaCerts = subjectToCaCerts.get(issuer);
-    if (subjectCaCerts == null) return null;
-
-    for (X509Certificate caCert : subjectCaCerts) {
-      PublicKey publicKey = caCert.getPublicKey();
-      try {
-        cert.verify(publicKey);
-        return caCert;
-      } catch (Exception ignored) {
-      }
-    }
-
-    return null;
-  }
-
-  @Override public boolean equals(Object other) {
-    if (other == this) return true;
-    return other instanceof okhttp3.internal.tls.BasicTrustRootIndex
-        && ((okhttp3.internal.tls.BasicTrustRootIndex) other).subjectToCaCerts.equals(
-        subjectToCaCerts);
-  }
-
-  @Override public int hashCode() {
-    return subjectToCaCerts.hashCode();
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java b/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java
deleted file mode 100644
index 98060db27a..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package okhttp3.internal.tls;
-
-import java.security.cert.Certificate;
-import java.security.cert.X509Certificate;
-import java.util.List;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.internal.platform.Platform;
-
-/**
- * Computes the effective certificate chain from the raw array returned by Java's built in TLS APIs.
- * Cleaning a chain returns a list of certificates where the first element is {@code chain[0]}, each
- * certificate is signed by the certificate that follows, and the last certificate is a trusted CA
- * certificate.
- *
- * <p>Use of the chain cleaner is necessary to omit unexpected certificates that aren't relevant to
- * the TLS handshake and to extract the trusted CA certificate for the benefit of certificate
- * pinning.
- */
-public abstract class CertificateChainCleaner {
-  public abstract List<Certificate> clean(List<Certificate> chain, String hostname)
-      throws SSLPeerUnverifiedException;
-
-  public static CertificateChainCleaner get(X509TrustManager trustManager) {
-    return Platform.get().buildCertificateChainCleaner(trustManager);
-  }
-
-  public static CertificateChainCleaner get(X509Certificate... caCerts) {
-    return new BasicCertificateChainCleaner(new BasicTrustRootIndex(caCerts));
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/DistinguishedNameParser.java b/okhttp/src/main/java/okhttp3/internal/tls/DistinguishedNameParser.java
deleted file mode 100644
index cae8dfae76..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/tls/DistinguishedNameParser.java
+++ /dev/null
@@ -1,406 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package okhttp3.internal.tls;
-
-import javax.security.auth.x500.X500Principal;
-
-/**
- * A distinguished name (DN) parser. This parser only supports extracting a string value from a DN.
- * It doesn't support values in the hex-string style.
- */
-final class DistinguishedNameParser {
-  private final String dn;
-  private final int length;
-  private int pos;
-  private int beg;
-  private int end;
-
-  /** Temporary variable to store positions of the currently parsed item. */
-  private int cur;
-
-  /** Distinguished name characters. */
-  private char[] chars;
-
-  DistinguishedNameParser(X500Principal principal) {
-    // RFC2253 is used to ensure we get attributes in the reverse
-    // order of the underlying ASN.1 encoding, so that the most
-    // significant values of repeated attributes occur first.
-    this.dn = principal.getName(X500Principal.RFC2253);
-    this.length = this.dn.length();
-  }
-
-  // gets next attribute type: (ALPHA 1*keychar) / oid
-  private String nextAT() {
-    // skip preceding space chars, they can present after
-    // comma or semicolon (compatibility with RFC 1779)
-    for (; pos < length && chars[pos] == ' '; pos++) {
-    }
-    if (pos == length) {
-      return null; // reached the end of DN
-    }
-
-    // mark the beginning of attribute type
-    beg = pos;
-
-    // attribute type chars
-    pos++;
-    for (; pos < length && chars[pos] != '=' && chars[pos] != ' '; pos++) {
-      // we don't follow exact BNF syntax here:
-      // accept any char except space and '='
-    }
-    if (pos >= length) {
-      throw new IllegalStateException("Unexpected end of DN: " + dn);
-    }
-
-    // mark the end of attribute type
-    end = pos;
-
-    // skip trailing space chars between attribute type and '='
-    // (compatibility with RFC 1779)
-    if (chars[pos] == ' ') {
-      for (; pos < length && chars[pos] != '=' && chars[pos] == ' '; pos++) {
-      }
-
-      if (chars[pos] != '=' || pos == length) {
-        throw new IllegalStateException("Unexpected end of DN: " + dn);
-      }
-    }
-
-    pos++; //skip '=' char
-
-    // skip space chars between '=' and attribute value
-    // (compatibility with RFC 1779)
-    for (; pos < length && chars[pos] == ' '; pos++) {
-    }
-
-    // in case of oid attribute type skip its prefix: "oid." or "OID."
-    // (compatibility with RFC 1779)
-    if ((end - beg > 4) && (chars[beg + 3] == '.')
-        && (chars[beg] == 'O' || chars[beg] == 'o')
-        && (chars[beg + 1] == 'I' || chars[beg + 1] == 'i')
-        && (chars[beg + 2] == 'D' || chars[beg + 2] == 'd')) {
-      beg += 4;
-    }
-
-    return new String(chars, beg, end - beg);
-  }
-
-  // gets quoted attribute value: QUOTATION *( quotechar / pair ) QUOTATION
-  private String quotedAV() {
-    pos++;
-    beg = pos;
-    end = beg;
-    while (true) {
-
-      if (pos == length) {
-        throw new IllegalStateException("Unexpected end of DN: " + dn);
-      }
-
-      if (chars[pos] == '"') {
-        // enclosing quotation was found
-        pos++;
-        break;
-      } else if (chars[pos] == '\\') {
-        chars[end] = getEscaped();
-      } else {
-        // shift char: required for string with escaped chars
-        chars[end] = chars[pos];
-      }
-      pos++;
-      end++;
-    }
-
-    // skip trailing space chars before comma or semicolon.
-    // (compatibility with RFC 1779)
-    for (; pos < length && chars[pos] == ' '; pos++) {
-    }
-
-    return new String(chars, beg, end - beg);
-  }
-
-  // gets hex string attribute value: "#" hexstring
-  private String hexAV() {
-    if (pos + 4 >= length) {
-      // encoded byte array  must be not less then 4 c
-      throw new IllegalStateException("Unexpected end of DN: " + dn);
-    }
-
-    beg = pos; // store '#' position
-    pos++;
-    while (true) {
-
-      // check for end of attribute value
-      // looks for space and component separators
-      if (pos == length || chars[pos] == '+' || chars[pos] == ','
-          || chars[pos] == ';') {
-        end = pos;
-        break;
-      }
-
-      if (chars[pos] == ' ') {
-        end = pos;
-        pos++;
-        // skip trailing space chars before comma or semicolon.
-        // (compatibility with RFC 1779)
-        for (; pos < length && chars[pos] == ' '; pos++) {
-        }
-        break;
-      } else if (chars[pos] >= 'A' && chars[pos] <= 'F') {
-        chars[pos] += 32; //to low case
-      }
-
-      pos++;
-    }
-
-    // verify length of hex string
-    // encoded byte array  must be not less then 4 and must be even number
-    int hexLen = end - beg; // skip first '#' char
-    if (hexLen < 5 || (hexLen & 1) == 0) {
-      throw new IllegalStateException("Unexpected end of DN: " + dn);
-    }
-
-    // get byte encoding from string representation
-    byte[] encoded = new byte[hexLen / 2];
-    for (int i = 0, p = beg + 1; i < encoded.length; p += 2, i++) {
-      encoded[i] = (byte) getByte(p);
-    }
-
-    return new String(chars, beg, hexLen);
-  }
-
-  // gets string attribute value: *( stringchar / pair )
-  private String escapedAV() {
-    beg = pos;
-    end = pos;
-    while (true) {
-      if (pos >= length) {
-        // the end of DN has been found
-        return new String(chars, beg, end - beg);
-      }
-
-      switch (chars[pos]) {
-        case '+':
-        case ',':
-        case ';':
-          // separator char has been found
-          return new String(chars, beg, end - beg);
-        case '\\':
-          // escaped char
-          chars[end++] = getEscaped();
-          pos++;
-          break;
-        case ' ':
-          // need to figure out whether space defines
-          // the end of attribute value or not
-          cur = end;
-
-          pos++;
-          chars[end++] = ' ';
-
-          for (; pos < length && chars[pos] == ' '; pos++) {
-            chars[end++] = ' ';
-          }
-          if (pos == length || chars[pos] == ',' || chars[pos] == '+'
-              || chars[pos] == ';') {
-            // separator char or the end of DN has been found
-            return new String(chars, beg, cur - beg);
-          }
-          break;
-        default:
-          chars[end++] = chars[pos];
-          pos++;
-      }
-    }
-  }
-
-  // returns escaped char
-  private char getEscaped() {
-    pos++;
-    if (pos == length) {
-      throw new IllegalStateException("Unexpected end of DN: " + dn);
-    }
-
-    switch (chars[pos]) {
-      case '"':
-      case '\\':
-      case ',':
-      case '=':
-      case '+':
-      case '<':
-      case '>':
-      case '#':
-      case ';':
-      case ' ':
-      case '*':
-      case '%':
-      case '_':
-        //FIXME: escaping is allowed only for leading or trailing space char
-        return chars[pos];
-      default:
-        // RFC doesn't explicitly say that escaped hex pair is
-        // interpreted as UTF-8 char. It only contains an example of such DN.
-        return getUTF8();
-    }
-  }
-
-  // decodes UTF-8 char
-  // see http://www.unicode.org for UTF-8 bit distribution table
-  private char getUTF8() {
-    int res = getByte(pos);
-    pos++; //FIXME tmp
-
-    if (res < 128) { // one byte: 0-7F
-      return (char) res;
-    } else if (res >= 192 && res <= 247) {
-
-      int count;
-      if (res <= 223) { // two bytes: C0-DF
-        count = 1;
-        res = res & 0x1F;
-      } else if (res <= 239) { // three bytes: E0-EF
-        count = 2;
-        res = res & 0x0F;
-      } else { // four bytes: F0-F7
-        count = 3;
-        res = res & 0x07;
-      }
-
-      int b;
-      for (int i = 0; i < count; i++) {
-        pos++;
-        if (pos == length || chars[pos] != '\\') {
-          return 0x3F; //FIXME failed to decode UTF-8 char - return '?'
-        }
-        pos++;
-
-        b = getByte(pos);
-        pos++; //FIXME tmp
-        if ((b & 0xC0) != 0x80) {
-          return 0x3F; //FIXME failed to decode UTF-8 char - return '?'
-        }
-
-        res = (res << 6) + (b & 0x3F);
-      }
-      return (char) res;
-    } else {
-      return 0x3F; //FIXME failed to decode UTF-8 char - return '?'
-    }
-  }
-
-  // Returns byte representation of a char pair
-  // The char pair is composed of DN char in
-  // specified 'position' and the next char
-  // According to BNF syntax:
-  // hexchar    = DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
-  //                    / "a" / "b" / "c" / "d" / "e" / "f"
-  private int getByte(int position) {
-    if (position + 1 >= length) {
-      throw new IllegalStateException("Malformed DN: " + dn);
-    }
-
-    int b1, b2;
-
-    b1 = chars[position];
-    if (b1 >= '0' && b1 <= '9') {
-      b1 = b1 - '0';
-    } else if (b1 >= 'a' && b1 <= 'f') {
-      b1 = b1 - 87; // 87 = 'a' - 10
-    } else if (b1 >= 'A' && b1 <= 'F') {
-      b1 = b1 - 55; // 55 = 'A' - 10
-    } else {
-      throw new IllegalStateException("Malformed DN: " + dn);
-    }
-
-    b2 = chars[position + 1];
-    if (b2 >= '0' && b2 <= '9') {
-      b2 = b2 - '0';
-    } else if (b2 >= 'a' && b2 <= 'f') {
-      b2 = b2 - 87; // 87 = 'a' - 10
-    } else if (b2 >= 'A' && b2 <= 'F') {
-      b2 = b2 - 55; // 55 = 'A' - 10
-    } else {
-      throw new IllegalStateException("Malformed DN: " + dn);
-    }
-
-    return (b1 << 4) + b2;
-  }
-
-  /**
-   * Parses the DN and returns the most significant attribute value for an attribute type, or null
-   * if none found.
-   *
-   * @param attributeType attribute type to look for (e.g. "ca")
-   */
-  public String findMostSpecific(String attributeType) {
-    // Initialize internal state.
-    pos = 0;
-    beg = 0;
-    end = 0;
-    cur = 0;
-    chars = dn.toCharArray();
-
-    String attType = nextAT();
-    if (attType == null) {
-      return null;
-    }
-    while (true) {
-      String attValue = "";
-
-      if (pos == length) {
-        return null;
-      }
-
-      switch (chars[pos]) {
-        case '"':
-          attValue = quotedAV();
-          break;
-        case '#':
-          attValue = hexAV();
-          break;
-        case '+':
-        case ',':
-        case ';': // compatibility with RFC 1779: semicolon can separate RDNs
-          //empty attribute value
-          break;
-        default:
-          attValue = escapedAV();
-      }
-
-      // Values are ordered from most specific to least specific
-      // due to the RFC2253 formatting. So take the first match
-      // we see.
-      if (attributeType.equalsIgnoreCase(attType)) {
-        return attValue;
-      }
-
-      if (pos >= length) {
-        return null;
-      }
-
-      if (chars[pos] == ',' || chars[pos] == ';') {
-      } else if (chars[pos] != '+') {
-        throw new IllegalStateException("Malformed DN: " + dn);
-      }
-
-      pos++;
-      attType = nextAT();
-      if (attType == null) {
-        throw new IllegalStateException("Malformed DN: " + dn);
-      }
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java b/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java
deleted file mode 100644
index 36ac5b3813..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java
+++ /dev/null
@@ -1,216 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package okhttp3.internal.tls;
-
-import java.security.cert.Certificate;
-import java.security.cert.CertificateParsingException;
-import java.security.cert.X509Certificate;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.List;
-import java.util.Locale;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLException;
-import javax.net.ssl.SSLSession;
-
-import static okhttp3.internal.Util.verifyAsIpAddress;
-
-/**
- * A HostnameVerifier consistent with <a href="http://www.ietf.org/rfc/rfc2818.txt">RFC 2818</a>.
- */
-public final class OkHostnameVerifier implements HostnameVerifier {
-  public static final OkHostnameVerifier INSTANCE = new OkHostnameVerifier();
-
-  private static final int ALT_DNS_NAME = 2;
-  private static final int ALT_IPA_NAME = 7;
-
-  private OkHostnameVerifier() {
-  }
-
-  @Override
-  public boolean verify(String host, SSLSession session) {
-    try {
-      Certificate[] certificates = session.getPeerCertificates();
-      return verify(host, (X509Certificate) certificates[0]);
-    } catch (SSLException e) {
-      return false;
-    }
-  }
-
-  public boolean verify(String host, X509Certificate certificate) {
-    return verifyAsIpAddress(host)
-        ? verifyIpAddress(host, certificate)
-        : verifyHostname(host, certificate);
-  }
-
-  /** Returns true if {@code certificate} matches {@code ipAddress}. */
-  private boolean verifyIpAddress(String ipAddress, X509Certificate certificate) {
-    List<String> altNames = getSubjectAltNames(certificate, ALT_IPA_NAME);
-    for (int i = 0, size = altNames.size(); i < size; i++) {
-      if (ipAddress.equalsIgnoreCase(altNames.get(i))) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  /** Returns true if {@code certificate} matches {@code hostname}. */
-  private boolean verifyHostname(String hostname, X509Certificate certificate) {
-    hostname = hostname.toLowerCase(Locale.US);
-    List<String> altNames = getSubjectAltNames(certificate, ALT_DNS_NAME);
-    for (String altName : altNames) {
-      if (verifyHostname(hostname, altName)) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  public static List<String> allSubjectAltNames(X509Certificate certificate) {
-    List<String> altIpaNames = getSubjectAltNames(certificate, ALT_IPA_NAME);
-    List<String> altDnsNames = getSubjectAltNames(certificate, ALT_DNS_NAME);
-    List<String> result = new ArrayList<>(altIpaNames.size() + altDnsNames.size());
-    result.addAll(altIpaNames);
-    result.addAll(altDnsNames);
-    return result;
-  }
-
-  private static List<String> getSubjectAltNames(X509Certificate certificate, int type) {
-    List<String> result = new ArrayList<>();
-    try {
-      Collection<?> subjectAltNames = certificate.getSubjectAlternativeNames();
-      if (subjectAltNames == null) {
-        return Collections.emptyList();
-      }
-      for (Object subjectAltName : subjectAltNames) {
-        List<?> entry = (List<?>) subjectAltName;
-        if (entry == null || entry.size() < 2) {
-          continue;
-        }
-        Integer altNameType = (Integer) entry.get(0);
-        if (altNameType == null) {
-          continue;
-        }
-        if (altNameType == type) {
-          String altName = (String) entry.get(1);
-          if (altName != null) {
-            result.add(altName);
-          }
-        }
-      }
-      return result;
-    } catch (CertificateParsingException e) {
-      return Collections.emptyList();
-    }
-  }
-
-  /**
-   * Returns {@code true} iff {@code hostname} matches the domain name {@code pattern}.
-   *
-   * @param hostname lower-case host name.
-   * @param pattern domain name pattern from certificate. May be a wildcard pattern such as {@code
-   * *.android.com}.
-   */
-  public boolean verifyHostname(String hostname, String pattern) {
-    // Basic sanity checks
-    // Check length == 0 instead of .isEmpty() to support Java 5.
-    if ((hostname == null) || (hostname.length() == 0) || (hostname.startsWith("."))
-        || (hostname.endsWith(".."))) {
-      // Invalid domain name
-      return false;
-    }
-    if ((pattern == null) || (pattern.length() == 0) || (pattern.startsWith("."))
-        || (pattern.endsWith(".."))) {
-      // Invalid pattern/domain name
-      return false;
-    }
-
-    // Normalize hostname and pattern by turning them into absolute domain names if they are not
-    // yet absolute. This is needed because server certificates do not normally contain absolute
-    // names or patterns, but they should be treated as absolute. At the same time, any hostname
-    // presented to this method should also be treated as absolute for the purposes of matching
-    // to the server certificate.
-    //   www.android.com  matches www.android.com
-    //   www.android.com  matches www.android.com.
-    //   www.android.com. matches www.android.com.
-    //   www.android.com. matches www.android.com
-    if (!hostname.endsWith(".")) {
-      hostname += '.';
-    }
-    if (!pattern.endsWith(".")) {
-      pattern += '.';
-    }
-    // hostname and pattern are now absolute domain names.
-
-    pattern = pattern.toLowerCase(Locale.US);
-    // hostname and pattern are now in lower case -- domain names are case-insensitive.
-
-    if (!pattern.contains("*")) {
-      // Not a wildcard pattern -- hostname and pattern must match exactly.
-      return hostname.equals(pattern);
-    }
-    // Wildcard pattern
-
-    // WILDCARD PATTERN RULES:
-    // 1. Asterisk (*) is only permitted in the left-most domain name label and must be the
-    //    only character in that label (i.e., must match the whole left-most label).
-    //    For example, *.example.com is permitted, while *a.example.com, a*.example.com,
-    //    a*b.example.com, a.*.example.com are not permitted.
-    // 2. Asterisk (*) cannot match across domain name labels.
-    //    For example, *.example.com matches test.example.com but does not match
-    //    sub.test.example.com.
-    // 3. Wildcard patterns for single-label domain names are not permitted.
-
-    if ((!pattern.startsWith("*.")) || (pattern.indexOf('*', 1) != -1)) {
-      // Asterisk (*) is only permitted in the left-most domain name label and must be the only
-      // character in that label
-      return false;
-    }
-
-    // Optimization: check whether hostname is too short to match the pattern. hostName must be at
-    // least as long as the pattern because asterisk must match the whole left-most label and
-    // hostname starts with a non-empty label. Thus, asterisk has to match one or more characters.
-    if (hostname.length() < pattern.length()) {
-      // hostname too short to match the pattern.
-      return false;
-    }
-
-    if ("*.".equals(pattern)) {
-      // Wildcard pattern for single-label domain name -- not permitted.
-      return false;
-    }
-
-    // hostname must end with the region of pattern following the asterisk.
-    String suffix = pattern.substring(1);
-    if (!hostname.endsWith(suffix)) {
-      // hostname does not end with the suffix
-      return false;
-    }
-
-    // Check that asterisk did not match across domain name labels.
-    int suffixStartIndexInHostname = hostname.length() - suffix.length();
-    if ((suffixStartIndexInHostname > 0)
-        && (hostname.lastIndexOf('.', suffixStartIndexInHostname - 1) != -1)) {
-      // Asterisk is matching across domain name labels -- not permitted.
-      return false;
-    }
-
-    // hostname matches pattern
-    return true;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java b/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java
deleted file mode 100644
index 499f120e33..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.tls;
-
-import java.security.cert.X509Certificate;
-
-public interface TrustRootIndex {
-  /** Returns the trusted CA certificate that signed {@code cert}. */
-  X509Certificate findByIssuerAndSignature(X509Certificate cert);
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
deleted file mode 100644
index d056ad67e2..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
+++ /dev/null
@@ -1,615 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.ws;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.net.SocketTimeoutException;
-import java.util.ArrayDeque;
-import java.util.Collections;
-import java.util.List;
-import java.util.Random;
-import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.ScheduledFuture;
-import java.util.concurrent.ScheduledThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;
-import javax.annotation.Nullable;
-import okhttp3.Call;
-import okhttp3.Callback;
-import okhttp3.EventListener;
-import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.WebSocket;
-import okhttp3.WebSocketListener;
-import okhttp3.internal.Internal;
-import okhttp3.internal.Util;
-import okhttp3.internal.connection.Exchange;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.Okio;
-
-import static java.util.concurrent.TimeUnit.MILLISECONDS;
-import static okhttp3.internal.Util.closeQuietly;
-import static okhttp3.internal.ws.WebSocketProtocol.CLOSE_CLIENT_GOING_AWAY;
-import static okhttp3.internal.ws.WebSocketProtocol.CLOSE_MESSAGE_MAX;
-import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_BINARY;
-import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_TEXT;
-import static okhttp3.internal.ws.WebSocketProtocol.validateCloseCode;
-
-public final class RealWebSocket implements WebSocket, WebSocketReader.FrameCallback {
-  private static final List<Protocol> ONLY_HTTP1 = Collections.singletonList(Protocol.HTTP_1_1);
-
-  /**
-   * The maximum number of bytes to enqueue. Rather than enqueueing beyond this limit we tear down
-   * the web socket! It's possible that we're writing faster than the peer can read.
-   */
-  private static final long MAX_QUEUE_SIZE = 16 * 1024 * 1024; // 16 MiB.
-
-  /**
-   * The maximum amount of time after the client calls {@link #close} to wait for a graceful
-   * shutdown. If the server doesn't respond the websocket will be canceled.
-   */
-  private static final long CANCEL_AFTER_CLOSE_MILLIS = 60 * 1000;
-
-  /** The application's original request unadulterated by web socket headers. */
-  private final Request originalRequest;
-
-  final WebSocketListener listener;
-  private final Random random;
-  private final long pingIntervalMillis;
-  private final String key;
-
-  /** Non-null for client web sockets. These can be canceled. */
-  private Call call;
-
-  /** This runnable processes the outgoing queues. Call {@link #runWriter()} to after enqueueing. */
-  private final Runnable writerRunnable;
-
-  /** Null until this web socket is connected. Only accessed by the reader thread. */
-  private WebSocketReader reader;
-
-  // All mutable web socket state is guarded by this.
-
-  /** Null until this web socket is connected. Note that messages may be enqueued before that. */
-  private WebSocketWriter writer;
-
-  /** Null until this web socket is connected. Used for writes, pings, and close timeouts. */
-  private ScheduledExecutorService executor;
-
-  /**
-   * The streams held by this web socket. This is non-null until all incoming messages have been
-   * read and all outgoing messages have been written. It is closed when both reader and writer are
-   * exhausted, or if there is any failure.
-   */
-  private Streams streams;
-
-  /** Outgoing pongs in the order they should be written. */
-  private final ArrayDeque<ByteString> pongQueue = new ArrayDeque<>();
-
-  /** Outgoing messages and close frames in the order they should be written. */
-  private final ArrayDeque<Object> messageAndCloseQueue = new ArrayDeque<>();
-
-  /** The total size in bytes of enqueued but not yet transmitted messages. */
-  private long queueSize;
-
-  /** True if we've enqueued a close frame. No further message frames will be enqueued. */
-  private boolean enqueuedClose;
-
-  /**
-   * When executed this will cancel this websocket. This future itself should be canceled if that is
-   * unnecessary because the web socket is already closed or canceled.
-   */
-  private ScheduledFuture<?> cancelFuture;
-
-  /** The close code from the peer, or -1 if this web socket has not yet read a close frame. */
-  private int receivedCloseCode = -1;
-
-  /** The close reason from the peer, or null if this web socket has not yet read a close frame. */
-  private String receivedCloseReason;
-
-  /** True if this web socket failed and the listener has been notified. */
-  private boolean failed;
-
-  /** Total number of pings sent by this web socket. */
-  private int sentPingCount;
-
-  /** Total number of pings received by this web socket. */
-  private int receivedPingCount;
-
-  /** Total number of pongs received by this web socket. */
-  private int receivedPongCount;
-
-  /** True if we have sent a ping that is still awaiting a reply. */
-  private boolean awaitingPong;
-
-  public RealWebSocket(Request request, WebSocketListener listener, Random random,
-      long pingIntervalMillis) {
-    if (!"GET".equals(request.method())) {
-      throw new IllegalArgumentException("Request must be GET: " + request.method());
-    }
-    this.originalRequest = request;
-    this.listener = listener;
-    this.random = random;
-    this.pingIntervalMillis = pingIntervalMillis;
-
-    byte[] nonce = new byte[16];
-    random.nextBytes(nonce);
-    this.key = ByteString.of(nonce).base64();
-
-    this.writerRunnable = () -> {
-      try {
-        while (writeOneFrame()) {
-        }
-      } catch (IOException e) {
-        failWebSocket(e, null);
-      }
-    };
-  }
-
-  @Override public Request request() {
-    return originalRequest;
-  }
-
-  @Override public synchronized long queueSize() {
-    return queueSize;
-  }
-
-  @Override public void cancel() {
-    call.cancel();
-  }
-
-  public void connect(OkHttpClient client) {
-    client = client.newBuilder()
-        .eventListener(EventListener.NONE)
-        .protocols(ONLY_HTTP1)
-        .build();
-    final Request request = originalRequest.newBuilder()
-        .header("Upgrade", "websocket")
-        .header("Connection", "Upgrade")
-        .header("Sec-WebSocket-Key", key)
-        .header("Sec-WebSocket-Version", "13")
-        .build();
-    call = Internal.instance.newWebSocketCall(client, request);
-    call.enqueue(new Callback() {
-      @Override public void onResponse(Call call, Response response) {
-        Exchange exchange = Internal.instance.exchange(response);
-        Streams streams;
-        try {
-          checkUpgradeSuccess(response, exchange);
-          streams = exchange.newWebSocketStreams();
-        } catch (IOException e) {
-          if (exchange != null) exchange.webSocketUpgradeFailed();
-          failWebSocket(e, response);
-          closeQuietly(response);
-          return;
-        }
-
-        // Process all web socket messages.
-        try {
-          String name = "OkHttp WebSocket " + request.url().redact();
-          initReaderAndWriter(name, streams);
-          listener.onOpen(RealWebSocket.this, response);
-          loopReader();
-        } catch (Exception e) {
-          failWebSocket(e, null);
-        }
-      }
-
-      @Override public void onFailure(Call call, IOException e) {
-        failWebSocket(e, null);
-      }
-    });
-  }
-
-  void checkUpgradeSuccess(Response response, @Nullable Exchange exchange) throws IOException {
-    if (response.code() != 101) {
-      throw new ProtocolException("Expected HTTP 101 response but was '"
-          + response.code() + " " + response.message() + "'");
-    }
-
-    String headerConnection = response.header("Connection");
-    if (!"Upgrade".equalsIgnoreCase(headerConnection)) {
-      throw new ProtocolException("Expected 'Connection' header value 'Upgrade' but was '"
-          + headerConnection + "'");
-    }
-
-    String headerUpgrade = response.header("Upgrade");
-    if (!"websocket".equalsIgnoreCase(headerUpgrade)) {
-      throw new ProtocolException(
-          "Expected 'Upgrade' header value 'websocket' but was '" + headerUpgrade + "'");
-    }
-
-    String headerAccept = response.header("Sec-WebSocket-Accept");
-    String acceptExpected = ByteString.encodeUtf8(key + WebSocketProtocol.ACCEPT_MAGIC)
-        .sha1().base64();
-    if (!acceptExpected.equals(headerAccept)) {
-      throw new ProtocolException("Expected 'Sec-WebSocket-Accept' header value '"
-          + acceptExpected + "' but was '" + headerAccept + "'");
-    }
-
-    if (exchange == null) {
-      throw new ProtocolException("Web Socket exchange missing: bad interceptor?");
-    }
-  }
-
-  public void initReaderAndWriter(String name, Streams streams) throws IOException {
-    synchronized (this) {
-      this.streams = streams;
-      this.writer = new WebSocketWriter(streams.client, streams.sink, random);
-      this.executor = new ScheduledThreadPoolExecutor(1, Util.threadFactory(name, false));
-      if (pingIntervalMillis != 0) {
-        executor.scheduleAtFixedRate(
-            new PingRunnable(), pingIntervalMillis, pingIntervalMillis, MILLISECONDS);
-      }
-      if (!messageAndCloseQueue.isEmpty()) {
-        runWriter(); // Send messages that were enqueued before we were connected.
-      }
-    }
-
-    reader = new WebSocketReader(streams.client, streams.source, this);
-  }
-
-  /** Receive frames until there are no more. Invoked only by the reader thread. */
-  public void loopReader() throws IOException {
-    while (receivedCloseCode == -1) {
-      // This method call results in one or more onRead* methods being called on this thread.
-      reader.processNextFrame();
-    }
-  }
-
-  /**
-   * For testing: receive a single frame and return true if there are more frames to read. Invoked
-   * only by the reader thread.
-   */
-  boolean processNextFrame() throws IOException {
-    try {
-      reader.processNextFrame();
-      return receivedCloseCode == -1;
-    } catch (Exception e) {
-      failWebSocket(e, null);
-      return false;
-    }
-  }
-
-  /**
-   * For testing: wait until the web socket's executor has terminated.
-   */
-  void awaitTermination(int timeout, TimeUnit timeUnit) throws InterruptedException {
-    executor.awaitTermination(timeout, timeUnit);
-  }
-
-  /**
-   * For testing: force this web socket to release its threads.
-   */
-  void tearDown() throws InterruptedException {
-    if (cancelFuture != null) {
-      cancelFuture.cancel(false);
-    }
-    executor.shutdown();
-    executor.awaitTermination(10, TimeUnit.SECONDS);
-  }
-
-  synchronized int sentPingCount() {
-    return sentPingCount;
-  }
-
-  synchronized int receivedPingCount() {
-    return receivedPingCount;
-  }
-
-  synchronized int receivedPongCount() {
-    return receivedPongCount;
-  }
-
-  @Override public void onReadMessage(String text) throws IOException {
-    listener.onMessage(this, text);
-  }
-
-  @Override public void onReadMessage(ByteString bytes) throws IOException {
-    listener.onMessage(this, bytes);
-  }
-
-  @Override public synchronized void onReadPing(ByteString payload) {
-    // Don't respond to pings after we've failed or sent the close frame.
-    if (failed || (enqueuedClose && messageAndCloseQueue.isEmpty())) return;
-
-    pongQueue.add(payload);
-    runWriter();
-    receivedPingCount++;
-  }
-
-  @Override public synchronized void onReadPong(ByteString buffer) {
-    // This API doesn't expose pings.
-    receivedPongCount++;
-    awaitingPong = false;
-  }
-
-  @Override public void onReadClose(int code, String reason) {
-    if (code == -1) throw new IllegalArgumentException();
-
-    Streams toClose = null;
-    synchronized (this) {
-      if (receivedCloseCode != -1) throw new IllegalStateException("already closed");
-      receivedCloseCode = code;
-      receivedCloseReason = reason;
-      if (enqueuedClose && messageAndCloseQueue.isEmpty()) {
-        toClose = this.streams;
-        this.streams = null;
-        if (cancelFuture != null) cancelFuture.cancel(false);
-        this.executor.shutdown();
-      }
-    }
-
-    try {
-      listener.onClosing(this, code, reason);
-
-      if (toClose != null) {
-        listener.onClosed(this, code, reason);
-      }
-    } finally {
-      closeQuietly(toClose);
-    }
-  }
-
-  // Writer methods to enqueue frames. They'll be sent asynchronously by the writer thread.
-
-  @Override public boolean send(String text) {
-    if (text == null) throw new NullPointerException("text == null");
-    return send(ByteString.encodeUtf8(text), OPCODE_TEXT);
-  }
-
-  @Override public boolean send(ByteString bytes) {
-    if (bytes == null) throw new NullPointerException("bytes == null");
-    return send(bytes, OPCODE_BINARY);
-  }
-
-  private synchronized boolean send(ByteString data, int formatOpcode) {
-    // Don't send new frames after we've failed or enqueued a close frame.
-    if (failed || enqueuedClose) return false;
-
-    // If this frame overflows the buffer, reject it and close the web socket.
-    if (queueSize + data.size() > MAX_QUEUE_SIZE) {
-      close(CLOSE_CLIENT_GOING_AWAY, null);
-      return false;
-    }
-
-    // Enqueue the message frame.
-    queueSize += data.size();
-    messageAndCloseQueue.add(new Message(formatOpcode, data));
-    runWriter();
-    return true;
-  }
-
-  synchronized boolean pong(ByteString payload) {
-    // Don't send pongs after we've failed or sent the close frame.
-    if (failed || (enqueuedClose && messageAndCloseQueue.isEmpty())) return false;
-
-    pongQueue.add(payload);
-    runWriter();
-    return true;
-  }
-
-  @Override public boolean close(int code, String reason) {
-    return close(code, reason, CANCEL_AFTER_CLOSE_MILLIS);
-  }
-
-  synchronized boolean close(int code, String reason, long cancelAfterCloseMillis) {
-    validateCloseCode(code);
-
-    ByteString reasonBytes = null;
-    if (reason != null) {
-      reasonBytes = ByteString.encodeUtf8(reason);
-      if (reasonBytes.size() > CLOSE_MESSAGE_MAX) {
-        throw new IllegalArgumentException("reason.size() > " + CLOSE_MESSAGE_MAX + ": " + reason);
-      }
-    }
-
-    if (failed || enqueuedClose) return false;
-
-    // Immediately prevent further frames from being enqueued.
-    enqueuedClose = true;
-
-    // Enqueue the close frame.
-    messageAndCloseQueue.add(new Close(code, reasonBytes, cancelAfterCloseMillis));
-    runWriter();
-    return true;
-  }
-
-  private void runWriter() {
-    assert (Thread.holdsLock(this));
-
-    if (executor != null) {
-      executor.execute(writerRunnable);
-    }
-  }
-
-  /**
-   * Attempts to remove a single frame from a queue and send it. This prefers to write urgent pongs
-   * before less urgent messages and close frames. For example it's possible that a caller will
-   * enqueue messages followed by pongs, but this sends pongs followed by messages. Pongs are always
-   * written in the order they were enqueued.
-   *
-   * <p>If a frame cannot be sent - because there are none enqueued or because the web socket is not
-   * connected - this does nothing and returns false. Otherwise this returns true and the caller
-   * should immediately invoke this method again until it returns false.
-   *
-   * <p>This method may only be invoked by the writer thread. There may be only thread invoking this
-   * method at a time.
-   */
-  boolean writeOneFrame() throws IOException {
-    WebSocketWriter writer;
-    ByteString pong;
-    Object messageOrClose = null;
-    int receivedCloseCode = -1;
-    String receivedCloseReason = null;
-    Streams streamsToClose = null;
-
-    synchronized (RealWebSocket.this) {
-      if (failed) {
-        return false; // Failed web socket.
-      }
-
-      writer = this.writer;
-      pong = pongQueue.poll();
-      if (pong == null) {
-        messageOrClose = messageAndCloseQueue.poll();
-        if (messageOrClose instanceof Close) {
-          receivedCloseCode = this.receivedCloseCode;
-          receivedCloseReason = this.receivedCloseReason;
-          if (receivedCloseCode != -1) {
-            streamsToClose = this.streams;
-            this.streams = null;
-            this.executor.shutdown();
-          } else {
-            // When we request a graceful close also schedule a cancel of the websocket.
-            cancelFuture = executor.schedule(new CancelRunnable(),
-                ((Close) messageOrClose).cancelAfterCloseMillis, MILLISECONDS);
-          }
-        } else if (messageOrClose == null) {
-          return false; // The queue is exhausted.
-        }
-      }
-    }
-
-    try {
-      if (pong != null) {
-        writer.writePong(pong);
-
-      } else if (messageOrClose instanceof Message) {
-        ByteString data = ((Message) messageOrClose).data;
-        BufferedSink sink = Okio.buffer(writer.newMessageSink(
-            ((Message) messageOrClose).formatOpcode, data.size()));
-        sink.write(data);
-        sink.close();
-        synchronized (this) {
-          queueSize -= data.size();
-        }
-
-      } else if (messageOrClose instanceof Close) {
-        Close close = (Close) messageOrClose;
-        writer.writeClose(close.code, close.reason);
-
-        // We closed the writer: now both reader and writer are closed.
-        if (streamsToClose != null) {
-          listener.onClosed(this, receivedCloseCode, receivedCloseReason);
-        }
-
-      } else {
-        throw new AssertionError();
-      }
-
-      return true;
-    } finally {
-      closeQuietly(streamsToClose);
-    }
-  }
-
-  private final class PingRunnable implements Runnable {
-    PingRunnable() {
-    }
-
-    @Override public void run() {
-      writePingFrame();
-    }
-  }
-
-  void writePingFrame() {
-    WebSocketWriter writer;
-    int failedPing;
-    synchronized (this) {
-      if (failed) return;
-      writer = this.writer;
-      failedPing = awaitingPong ? sentPingCount : -1;
-      sentPingCount++;
-      awaitingPong = true;
-    }
-
-    if (failedPing != -1) {
-      failWebSocket(new SocketTimeoutException("sent ping but didn't receive pong within "
-          + pingIntervalMillis + "ms (after " + (failedPing - 1) + " successful ping/pongs)"),
-          null);
-      return;
-    }
-
-    try {
-      writer.writePing(ByteString.EMPTY);
-    } catch (IOException e) {
-      failWebSocket(e, null);
-    }
-  }
-
-  public void failWebSocket(Exception e, @Nullable Response response) {
-    Streams streamsToClose;
-    synchronized (this) {
-      if (failed) return; // Already failed.
-      failed = true;
-      streamsToClose = this.streams;
-      this.streams = null;
-      if (cancelFuture != null) cancelFuture.cancel(false);
-      if (executor != null) executor.shutdown();
-    }
-
-    try {
-      listener.onFailure(this, e, response);
-    } finally {
-      closeQuietly(streamsToClose);
-    }
-  }
-
-  static final class Message {
-    final int formatOpcode;
-    final ByteString data;
-
-    Message(int formatOpcode, ByteString data) {
-      this.formatOpcode = formatOpcode;
-      this.data = data;
-    }
-  }
-
-  static final class Close {
-    final int code;
-    final ByteString reason;
-    final long cancelAfterCloseMillis;
-
-    Close(int code, ByteString reason, long cancelAfterCloseMillis) {
-      this.code = code;
-      this.reason = reason;
-      this.cancelAfterCloseMillis = cancelAfterCloseMillis;
-    }
-  }
-
-  public abstract static class Streams implements Closeable {
-    public final boolean client;
-    public final BufferedSource source;
-    public final BufferedSink sink;
-
-    public Streams(boolean client, BufferedSource source, BufferedSink sink) {
-      this.client = client;
-      this.source = source;
-      this.sink = sink;
-    }
-  }
-
-  final class CancelRunnable implements Runnable {
-    @Override public void run() {
-      cancel();
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
deleted file mode 100644
index 489979845e..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.ws;
-
-import okio.Buffer;
-import okio.ByteString;
-
-public final class WebSocketProtocol {
-  /** Magic value which must be appended to the key in a response header. */
-  static final String ACCEPT_MAGIC = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
-
-  /*
-  Each frame starts with two bytes of data.
-
-   0 1 2 3 4 5 6 7    0 1 2 3 4 5 6 7
-  +-+-+-+-+-------+  +-+-------------+
-  |F|R|R|R| OP    |  |M| LENGTH      |
-  |I|S|S|S| CODE  |  |A|             |
-  |N|V|V|V|       |  |S|             |
-  | |1|2|3|       |  |K|             |
-  +-+-+-+-+-------+  +-+-------------+
-  */
-
-  /** Byte 0 flag for whether this is the final fragment in a message. */
-  static final int B0_FLAG_FIN = 0b10000000;
-  /** Byte 0 reserved flag 1. Must be 0 unless negotiated otherwise. */
-  static final int B0_FLAG_RSV1 = 0b01000000;
-  /** Byte 0 reserved flag 2. Must be 0 unless negotiated otherwise. */
-  static final int B0_FLAG_RSV2 = 0b00100000;
-  /** Byte 0 reserved flag 3. Must be 0 unless negotiated otherwise. */
-  static final int B0_FLAG_RSV3 = 0b00010000;
-  /** Byte 0 mask for the frame opcode. */
-  static final int B0_MASK_OPCODE = 0b00001111;
-  /** Flag in the opcode which indicates a control frame. */
-  static final int OPCODE_FLAG_CONTROL = 0b00001000;
-
-  /**
-   * Byte 1 flag for whether the payload data is masked. <p> If this flag is set, the next four
-   * bytes represent the mask key. These bytes appear after any additional bytes specified by {@link
-   * #B1_MASK_LENGTH}.
-   */
-  static final int B1_FLAG_MASK = 0b10000000;
-  /**
-   * Byte 1 mask for the payload length. <p> If this value is {@link #PAYLOAD_SHORT}, the next two
-   * bytes represent the length. If this value is {@link #PAYLOAD_LONG}, the next eight bytes
-   * represent the length.
-   */
-  static final int B1_MASK_LENGTH = 0b01111111;
-
-  static final int OPCODE_CONTINUATION = 0x0;
-  static final int OPCODE_TEXT = 0x1;
-  static final int OPCODE_BINARY = 0x2;
-
-  static final int OPCODE_CONTROL_CLOSE = 0x8;
-  static final int OPCODE_CONTROL_PING = 0x9;
-  static final int OPCODE_CONTROL_PONG = 0xa;
-
-  /**
-   * Maximum length of frame payload. Larger payloads, if supported by the frame type, can use the
-   * special values {@link #PAYLOAD_SHORT} or {@link #PAYLOAD_LONG}.
-   */
-  static final long PAYLOAD_BYTE_MAX = 125L;
-  /** Maximum length of close message in bytes. */
-  static final long CLOSE_MESSAGE_MAX = PAYLOAD_BYTE_MAX - 2;
-  /**
-   * Value for {@link #B1_MASK_LENGTH} which indicates the next two bytes are the unsigned length.
-   */
-  static final int PAYLOAD_SHORT = 126;
-  /** Maximum length of a frame payload to be denoted as {@link #PAYLOAD_SHORT}. */
-  static final long PAYLOAD_SHORT_MAX = 0xffffL;
-  /**
-   * Value for {@link #B1_MASK_LENGTH} which indicates the next eight bytes are the unsigned
-   * length.
-   */
-  static final int PAYLOAD_LONG = 127;
-
-  /** Used when an unchecked exception was thrown in a listener. */
-  static final int CLOSE_CLIENT_GOING_AWAY = 1001;
-  /** Used when an empty close frame was received (i.e., without a status code). */
-  static final int CLOSE_NO_STATUS_CODE = 1005;
-
-  static void toggleMask(Buffer.UnsafeCursor cursor, byte[] key) {
-    int keyIndex = 0;
-    int keyLength = key.length;
-    do {
-      byte[] buffer = cursor.data;
-      for (int i = cursor.start, end = cursor.end; i < end; i++, keyIndex++) {
-        keyIndex %= keyLength; // Reassign to prevent overflow breaking counter.
-        buffer[i] = (byte) (buffer[i] ^ key[keyIndex]);
-      }
-    } while (cursor.next() != -1);
-  }
-
-  static String closeCodeExceptionMessage(int code) {
-    if (code < 1000 || code >= 5000) {
-      return "Code must be in range [1000,5000): " + code;
-    } else if ((code >= 1004 && code <= 1006) || (code >= 1012 && code <= 2999)) {
-      return "Code " + code + " is reserved and may not be used.";
-    } else {
-      return null;
-    }
-  }
-
-  static void validateCloseCode(int code) {
-    String message = closeCodeExceptionMessage(code);
-    if (message != null) throw new IllegalArgumentException(message);
-  }
-
-  public static String acceptHeader(String key) {
-    return ByteString.encodeUtf8(key + WebSocketProtocol.ACCEPT_MAGIC).sha1().base64();
-  }
-
-  private WebSocketProtocol() {
-    throw new AssertionError("No instances.");
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java
deleted file mode 100644
index 6d5d22e67d..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java
+++ /dev/null
@@ -1,264 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.ws;
-
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.util.concurrent.TimeUnit;
-import okio.Buffer;
-import okio.BufferedSource;
-import okio.ByteString;
-
-import static java.lang.Integer.toHexString;
-import static okhttp3.internal.ws.WebSocketProtocol.B0_FLAG_FIN;
-import static okhttp3.internal.ws.WebSocketProtocol.B0_FLAG_RSV1;
-import static okhttp3.internal.ws.WebSocketProtocol.B0_FLAG_RSV2;
-import static okhttp3.internal.ws.WebSocketProtocol.B0_FLAG_RSV3;
-import static okhttp3.internal.ws.WebSocketProtocol.B0_MASK_OPCODE;
-import static okhttp3.internal.ws.WebSocketProtocol.B1_FLAG_MASK;
-import static okhttp3.internal.ws.WebSocketProtocol.B1_MASK_LENGTH;
-import static okhttp3.internal.ws.WebSocketProtocol.CLOSE_NO_STATUS_CODE;
-import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_BINARY;
-import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTINUATION;
-import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTROL_CLOSE;
-import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PING;
-import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PONG;
-import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_FLAG_CONTROL;
-import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_TEXT;
-import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_BYTE_MAX;
-import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_LONG;
-import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_SHORT;
-import static okhttp3.internal.ws.WebSocketProtocol.toggleMask;
-
-/**
- * An <a href="http://tools.ietf.org/html/rfc6455">RFC 6455</a>-compatible WebSocket frame reader.
- *
- * <p>This class is not thread safe.
- */
-final class WebSocketReader {
-  public interface FrameCallback {
-    void onReadMessage(String text) throws IOException;
-    void onReadMessage(ByteString bytes) throws IOException;
-    void onReadPing(ByteString buffer);
-    void onReadPong(ByteString buffer);
-    void onReadClose(int code, String reason);
-  }
-
-  final boolean isClient;
-  final BufferedSource source;
-  final FrameCallback frameCallback;
-
-  boolean closed;
-
-  // Stateful data about the current frame.
-  int opcode;
-  long frameLength;
-  boolean isFinalFrame;
-  boolean isControlFrame;
-
-  private final Buffer controlFrameBuffer = new Buffer();
-  private final Buffer messageFrameBuffer = new Buffer();
-
-  private final byte[] maskKey;
-  private final Buffer.UnsafeCursor maskCursor;
-
-  WebSocketReader(boolean isClient, BufferedSource source, FrameCallback frameCallback) {
-    if (source == null) throw new NullPointerException("source == null");
-    if (frameCallback == null) throw new NullPointerException("frameCallback == null");
-    this.isClient = isClient;
-    this.source = source;
-    this.frameCallback = frameCallback;
-
-    // Masks are only a concern for server writers.
-    maskKey = isClient ? null : new byte[4];
-    maskCursor = isClient ? null : new Buffer.UnsafeCursor();
-  }
-
-  /**
-   * Process the next protocol frame.
-   *
-   * <ul>
-   *     <li>If it is a control frame this will result in a single call to {@link FrameCallback}.
-   *     <li>If it is a message frame this will result in a single call to {@link
-   *         FrameCallback#onReadMessage}. If the message spans multiple frames, each interleaved
-   *         control frame will result in a corresponding call to {@link FrameCallback}.
-   * </ul>
-   */
-  void processNextFrame() throws IOException {
-    readHeader();
-    if (isControlFrame) {
-      readControlFrame();
-    } else {
-      readMessageFrame();
-    }
-  }
-
-  private void readHeader() throws IOException {
-    if (closed) throw new IOException("closed");
-
-    // Disable the timeout to read the first byte of a new frame.
-    int b0;
-    long timeoutBefore = source.timeout().timeoutNanos();
-    source.timeout().clearTimeout();
-    try {
-      b0 = source.readByte() & 0xff;
-    } finally {
-      source.timeout().timeout(timeoutBefore, TimeUnit.NANOSECONDS);
-    }
-
-    opcode = b0 & B0_MASK_OPCODE;
-    isFinalFrame = (b0 & B0_FLAG_FIN) != 0;
-    isControlFrame = (b0 & OPCODE_FLAG_CONTROL) != 0;
-
-    // Control frames must be final frames (cannot contain continuations).
-    if (isControlFrame && !isFinalFrame) {
-      throw new ProtocolException("Control frames must be final.");
-    }
-
-    boolean reservedFlag1 = (b0 & B0_FLAG_RSV1) != 0;
-    boolean reservedFlag2 = (b0 & B0_FLAG_RSV2) != 0;
-    boolean reservedFlag3 = (b0 & B0_FLAG_RSV3) != 0;
-    if (reservedFlag1 || reservedFlag2 || reservedFlag3) {
-      // Reserved flags are for extensions which we currently do not support.
-      throw new ProtocolException("Reserved flags are unsupported.");
-    }
-
-    int b1 = source.readByte() & 0xff;
-
-    boolean isMasked = (b1 & B1_FLAG_MASK) != 0;
-    if (isMasked == isClient) {
-      // Masked payloads must be read on the server. Unmasked payloads must be read on the client.
-      throw new ProtocolException(isClient
-          ? "Server-sent frames must not be masked."
-          : "Client-sent frames must be masked.");
-    }
-
-    // Get frame length, optionally reading from follow-up bytes if indicated by special values.
-    frameLength = b1 & B1_MASK_LENGTH;
-    if (frameLength == PAYLOAD_SHORT) {
-      frameLength = source.readShort() & 0xffffL; // Value is unsigned.
-    } else if (frameLength == PAYLOAD_LONG) {
-      frameLength = source.readLong();
-      if (frameLength < 0) {
-        throw new ProtocolException(
-            "Frame length 0x" + Long.toHexString(frameLength) + " > 0x7FFFFFFFFFFFFFFF");
-      }
-    }
-
-    if (isControlFrame && frameLength > PAYLOAD_BYTE_MAX) {
-      throw new ProtocolException("Control frame must be less than " + PAYLOAD_BYTE_MAX + "B.");
-    }
-
-    if (isMasked) {
-      // Read the masking key as bytes so that they can be used directly for unmasking.
-      source.readFully(maskKey);
-    }
-  }
-
-  private void readControlFrame() throws IOException {
-    if (frameLength > 0) {
-      source.readFully(controlFrameBuffer, frameLength);
-
-      if (!isClient) {
-        controlFrameBuffer.readAndWriteUnsafe(maskCursor);
-        maskCursor.seek(0);
-        toggleMask(maskCursor, maskKey);
-        maskCursor.close();
-      }
-    }
-
-    switch (opcode) {
-      case OPCODE_CONTROL_PING:
-        frameCallback.onReadPing(controlFrameBuffer.readByteString());
-        break;
-      case OPCODE_CONTROL_PONG:
-        frameCallback.onReadPong(controlFrameBuffer.readByteString());
-        break;
-      case OPCODE_CONTROL_CLOSE:
-        int code = CLOSE_NO_STATUS_CODE;
-        String reason = "";
-        long bufferSize = controlFrameBuffer.size();
-        if (bufferSize == 1) {
-          throw new ProtocolException("Malformed close payload length of 1.");
-        } else if (bufferSize != 0) {
-          code = controlFrameBuffer.readShort();
-          reason = controlFrameBuffer.readUtf8();
-          String codeExceptionMessage = WebSocketProtocol.closeCodeExceptionMessage(code);
-          if (codeExceptionMessage != null) throw new ProtocolException(codeExceptionMessage);
-        }
-        frameCallback.onReadClose(code, reason);
-        closed = true;
-        break;
-      default:
-        throw new ProtocolException("Unknown control opcode: " + toHexString(opcode));
-    }
-  }
-
-  private void readMessageFrame() throws IOException {
-    int opcode = this.opcode;
-    if (opcode != OPCODE_TEXT && opcode != OPCODE_BINARY) {
-      throw new ProtocolException("Unknown opcode: " + toHexString(opcode));
-    }
-
-    readMessage();
-
-    if (opcode == OPCODE_TEXT) {
-      frameCallback.onReadMessage(messageFrameBuffer.readUtf8());
-    } else {
-      frameCallback.onReadMessage(messageFrameBuffer.readByteString());
-    }
-  }
-
-  /** Read headers and process any control frames until we reach a non-control frame. */
-  private void readUntilNonControlFrame() throws IOException {
-    while (!closed) {
-      readHeader();
-      if (!isControlFrame) {
-        break;
-      }
-      readControlFrame();
-    }
-  }
-
-  /**
-   * Reads a message body into across one or more frames. Control frames that occur between
-   * fragments will be processed. If the message payload is masked this will unmask as it's being
-   * processed.
-   */
-  private void readMessage() throws IOException {
-    while (true) {
-      if (closed) throw new IOException("closed");
-
-      if (frameLength > 0) {
-        source.readFully(messageFrameBuffer, frameLength);
-
-        if (!isClient) {
-          messageFrameBuffer.readAndWriteUnsafe(maskCursor);
-          maskCursor.seek(messageFrameBuffer.size() - frameLength);
-          toggleMask(maskCursor, maskKey);
-          maskCursor.close();
-        }
-      }
-
-      if (isFinalFrame) break; // We are exhausted and have no continuations.
-
-      readUntilNonControlFrame();
-      if (opcode != OPCODE_CONTINUATION) {
-        throw new ProtocolException("Expected continuation opcode. Got: " + toHexString(opcode));
-      }
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
deleted file mode 100644
index 3ba1204987..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
+++ /dev/null
@@ -1,257 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.ws;
-
-import java.io.IOException;
-import java.util.Random;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.ByteString;
-import okio.Sink;
-import okio.Timeout;
-
-import static okhttp3.internal.ws.WebSocketProtocol.B0_FLAG_FIN;
-import static okhttp3.internal.ws.WebSocketProtocol.B1_FLAG_MASK;
-import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTINUATION;
-import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTROL_CLOSE;
-import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PING;
-import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PONG;
-import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_BYTE_MAX;
-import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_LONG;
-import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_SHORT;
-import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_SHORT_MAX;
-import static okhttp3.internal.ws.WebSocketProtocol.toggleMask;
-import static okhttp3.internal.ws.WebSocketProtocol.validateCloseCode;
-
-/**
- * An <a href="http://tools.ietf.org/html/rfc6455">RFC 6455</a>-compatible WebSocket frame writer.
- *
- * <p>This class is not thread safe.
- */
-final class WebSocketWriter {
-  final boolean isClient;
-  final Random random;
-
-  final BufferedSink sink;
-  /** The {@link Buffer} of {@link #sink}. Write to this and then flush/emit {@link #sink}. */
-  final Buffer sinkBuffer;
-  boolean writerClosed;
-
-  final Buffer buffer = new Buffer();
-  final FrameSink frameSink = new FrameSink();
-
-  boolean activeWriter;
-
-  private final byte[] maskKey;
-  private final Buffer.UnsafeCursor maskCursor;
-
-  WebSocketWriter(boolean isClient, BufferedSink sink, Random random) {
-    if (sink == null) throw new NullPointerException("sink == null");
-    if (random == null) throw new NullPointerException("random == null");
-    this.isClient = isClient;
-    this.sink = sink;
-    this.sinkBuffer = sink.buffer();
-    this.random = random;
-
-    // Masks are only a concern for client writers.
-    maskKey = isClient ? new byte[4] : null;
-    maskCursor = isClient ? new Buffer.UnsafeCursor() : null;
-  }
-
-  /** Send a ping with the supplied {@code payload}. */
-  void writePing(ByteString payload) throws IOException {
-    writeControlFrame(OPCODE_CONTROL_PING, payload);
-  }
-
-  /** Send a pong with the supplied {@code payload}. */
-  void writePong(ByteString payload) throws IOException {
-    writeControlFrame(OPCODE_CONTROL_PONG, payload);
-  }
-
-  /**
-   * Send a close frame with optional code and reason.
-   *
-   * @param code Status code as defined by <a
-   * href="http://tools.ietf.org/html/rfc6455#section-7.4">Section 7.4 of RFC 6455</a> or {@code 0}.
-   * @param reason Reason for shutting down or {@code null}.
-   */
-  void writeClose(int code, ByteString reason) throws IOException {
-    ByteString payload = ByteString.EMPTY;
-    if (code != 0 || reason != null) {
-      if (code != 0) {
-        validateCloseCode(code);
-      }
-      Buffer buffer = new Buffer();
-      buffer.writeShort(code);
-      if (reason != null) {
-        buffer.write(reason);
-      }
-      payload = buffer.readByteString();
-    }
-
-    try {
-      writeControlFrame(OPCODE_CONTROL_CLOSE, payload);
-    } finally {
-      writerClosed = true;
-    }
-  }
-
-  private void writeControlFrame(int opcode, ByteString payload) throws IOException {
-    if (writerClosed) throw new IOException("closed");
-
-    int length = payload.size();
-    if (length > PAYLOAD_BYTE_MAX) {
-      throw new IllegalArgumentException(
-          "Payload size must be less than or equal to " + PAYLOAD_BYTE_MAX);
-    }
-
-    int b0 = B0_FLAG_FIN | opcode;
-    sinkBuffer.writeByte(b0);
-
-    int b1 = length;
-    if (isClient) {
-      b1 |= B1_FLAG_MASK;
-      sinkBuffer.writeByte(b1);
-
-      random.nextBytes(maskKey);
-      sinkBuffer.write(maskKey);
-
-      if (length > 0) {
-        long payloadStart = sinkBuffer.size();
-        sinkBuffer.write(payload);
-
-        sinkBuffer.readAndWriteUnsafe(maskCursor);
-        maskCursor.seek(payloadStart);
-        toggleMask(maskCursor, maskKey);
-        maskCursor.close();
-      }
-    } else {
-      sinkBuffer.writeByte(b1);
-      sinkBuffer.write(payload);
-    }
-
-    sink.flush();
-  }
-
-  /**
-   * Stream a message payload as a series of frames. This allows control frames to be interleaved
-   * between parts of the message.
-   */
-  Sink newMessageSink(int formatOpcode, long contentLength) {
-    if (activeWriter) {
-      throw new IllegalStateException("Another message writer is active. Did you call close()?");
-    }
-    activeWriter = true;
-
-    // Reset FrameSink state for a new writer.
-    frameSink.formatOpcode = formatOpcode;
-    frameSink.contentLength = contentLength;
-    frameSink.isFirstFrame = true;
-    frameSink.closed = false;
-
-    return frameSink;
-  }
-
-  void writeMessageFrame(int formatOpcode, long byteCount, boolean isFirstFrame,
-      boolean isFinal) throws IOException {
-    if (writerClosed) throw new IOException("closed");
-
-    int b0 = isFirstFrame ? formatOpcode : OPCODE_CONTINUATION;
-    if (isFinal) {
-      b0 |= B0_FLAG_FIN;
-    }
-    sinkBuffer.writeByte(b0);
-
-    int b1 = 0;
-    if (isClient) {
-      b1 |= B1_FLAG_MASK;
-    }
-    if (byteCount <= PAYLOAD_BYTE_MAX) {
-      b1 |= (int) byteCount;
-      sinkBuffer.writeByte(b1);
-    } else if (byteCount <= PAYLOAD_SHORT_MAX) {
-      b1 |= PAYLOAD_SHORT;
-      sinkBuffer.writeByte(b1);
-      sinkBuffer.writeShort((int) byteCount);
-    } else {
-      b1 |= PAYLOAD_LONG;
-      sinkBuffer.writeByte(b1);
-      sinkBuffer.writeLong(byteCount);
-    }
-
-    if (isClient) {
-      random.nextBytes(maskKey);
-      sinkBuffer.write(maskKey);
-
-      if (byteCount > 0) {
-        long bufferStart = sinkBuffer.size();
-        sinkBuffer.write(buffer, byteCount);
-
-        sinkBuffer.readAndWriteUnsafe(maskCursor);
-        maskCursor.seek(bufferStart);
-        toggleMask(maskCursor, maskKey);
-        maskCursor.close();
-      }
-    } else {
-      sinkBuffer.write(buffer, byteCount);
-    }
-
-    sink.emit();
-  }
-
-  final class FrameSink implements Sink {
-    int formatOpcode;
-    long contentLength;
-    boolean isFirstFrame;
-    boolean closed;
-
-    @Override public void write(Buffer source, long byteCount) throws IOException {
-      if (closed) throw new IOException("closed");
-
-      buffer.write(source, byteCount);
-
-      // Determine if this is a buffered write which we can defer until close() flushes.
-      boolean deferWrite = isFirstFrame
-          && contentLength != -1
-          && buffer.size() > contentLength - 8192 /* segment size */;
-
-      long emitCount = buffer.completeSegmentByteCount();
-      if (emitCount > 0 && !deferWrite) {
-        writeMessageFrame(formatOpcode, emitCount, isFirstFrame, false /* final */);
-        isFirstFrame = false;
-      }
-    }
-
-    @Override public void flush() throws IOException {
-      if (closed) throw new IOException("closed");
-
-      writeMessageFrame(formatOpcode, buffer.size(), isFirstFrame, false /* final */);
-      isFirstFrame = false;
-    }
-
-    @Override public Timeout timeout() {
-      return sink.timeout();
-    }
-
-    @Override public void close() throws IOException {
-      if (closed) throw new IOException("closed");
-
-      writeMessageFrame(formatOpcode, buffer.size(), isFirstFrame, true /* final */);
-      closed = true;
-      activeWriter = false;
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/package-info.java b/okhttp/src/main/java/okhttp3/package-info.java
deleted file mode 100644
index 725b054363..0000000000
--- a/okhttp/src/main/java/okhttp3/package-info.java
+++ /dev/null
@@ -1,3 +0,0 @@
-/** An HTTP+HTTP/2 client for Android and Java applications. */
-@okhttp3.internal.annotations.EverythingIsNonNull
-package okhttp3;
diff --git a/okhttp/src/main/resources/META-INF/proguard/okhttp3.pro b/okhttp/src/main/resources/META-INF/proguard/okhttp3.pro
deleted file mode 100644
index 0c6f707575..0000000000
--- a/okhttp/src/main/resources/META-INF/proguard/okhttp3.pro
+++ /dev/null
@@ -1,11 +0,0 @@
-# JSR 305 annotations are for embedding nullability information.
--dontwarn javax.annotation.**
-
-# A resource is loaded with a relative path so the package of this class must be preserved.
--keepnames class okhttp3.internal.publicsuffix.PublicSuffixDatabase
-
-# Animal Sniffer compileOnly dependency to ensure APIs are compatible with older versions of Java.
--dontwarn org.codehaus.mojo.animal_sniffer.*
-
-# OkHttp platform used only on JVM and when Conscrypt dependency is available.
--dontwarn okhttp3.internal.platform.ConscryptPlatform
diff --git a/okhttp/src/main/resources/okhttp3/internal/publicsuffix/publicsuffixes.gz b/okhttp/src/main/resources/okhttp3/internal/publicsuffix/publicsuffixes.gz
deleted file mode 100644
index 795e941ae6..0000000000
Binary files a/okhttp/src/main/resources/okhttp3/internal/publicsuffix/publicsuffixes.gz and /dev/null differ
diff --git a/pom.xml b/pom.xml
index 9f0c4c1672..ef62995044 100644
--- a/pom.xml
+++ b/pom.xml
@@ -3,738 +3,131 @@
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
   <modelVersion>4.0.0</modelVersion>
 
-  <parent>
-    <groupId>org.sonatype.oss</groupId>
-    <artifactId>oss-parent</artifactId>
-    <version>7</version>
-  </parent>
+  <groupId>net.disy.oss</groupId>
+  <artifactId>disy-commons-web</artifactId>
+  <version>1.0-SNAPSHOT</version>
+  <packaging>jar</packaging>
 
-  <groupId>com.squareup.okhttp3</groupId>
-  <artifactId>parent</artifactId>
-  <version>3.14.3-SNAPSHOT</version>
-  <packaging>pom</packaging>
-
-  <name>OkHttp (Parent)</name>
-  <description>An HTTP+HTTP/2 client for Android and Java applications</description>
-  <url>https://github.com/square/okhttp</url>
-
-  <modules>
-    <module>okhttp</module>
-    <module>okhttp-tests</module>
-
-    <module>okhttp-sse</module>
-    <module>okhttp-testing-support</module>
-    <module>okhttp-tls</module>
-    <module>okhttp-urlconnection</module>
-
-    <module>okhttp-logging-interceptor</module>
-
-    <module>okhttp-dnsoverhttps</module>
-
-    <module>okcurl</module>
-    <module>mockwebserver</module>
-    <module>samples</module>
-  </modules>
+  <name>disy-commons-web</name>
+  <description>A URL class for HTTP and HTTPS, extracted from OkHttp and tracking their 3.x branch.</description>
+  <url>https://github.com/DisyInformationssysteme/disy-commons-web</url>
 
   <properties>
     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
 
     <!-- Compilation -->
-    <airlift.version>0.8</airlift.version>
-    <android.version>4.1.1.4</android.version>
-    <animal.sniffer.version>1.17</animal.sniffer.version>
-    <bouncycastle.version>1.60</bouncycastle.version>
-    <guava.version>27.0.1-jre</guava.version>
-    <java.version>1.8</java.version>
-    <moshi.version>1.8.0</moshi.version>
-    <jnr-unixsocket.version>0.22</jnr-unixsocket.version>
-    <okio.version>1.17.2</okio.version>
-    <conscrypt.version>2.0.0</conscrypt.version>
+    <java.version>11</java.version>
+    <okio.version>1.17.4</okio.version>
 
     <!-- Test Dependencies -->
     <junit.version>4.12</junit.version>
-    <assertj.version>3.11.0</assertj.version>
-
-    <!-- platform test mode -->
-    <okhttp.platform>platform</okhttp.platform>
+    <assertj.version>3.13.1</assertj.version>
   </properties>
 
-  <scm>
-    <url>https://github.com/square/okhttp/</url>
-    <connection>scm:git:https://github.com/square/okhttp.git</connection>
-    <developerConnection>scm:git:git@github.com:square/okhttp.git</developerConnection>
-    <tag>HEAD</tag>
-  </scm>
-
-  <issueManagement>
-    <system>GitHub Issues</system>
-    <url>https://github.com/square/okhttp/issues</url>
-  </issueManagement>
-
-  <licenses>
-    <license>
-      <name>Apache 2.0</name>
-      <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
-    </license>
-  </licenses>
-
-  <dependencyManagement>
-    <dependencies>
-      <dependency>
-        <groupId>com.squareup.okio</groupId>
-        <artifactId>okio</artifactId>
-        <version>${okio.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.google.code.findbugs</groupId>
-        <artifactId>jsr305</artifactId>
-        <version>3.0.2</version>
-        <scope>provided</scope>
-      </dependency>
-      <dependency>
-        <groupId>junit</groupId>
-        <artifactId>junit</artifactId>
-        <version>${junit.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>org.bouncycastle</groupId>
-        <artifactId>bcprov-jdk15on</artifactId>
-        <version>${bouncycastle.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>io.airlift</groupId>
-        <artifactId>airline</artifactId>
-        <version>${airlift.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.google.guava</groupId>
-        <artifactId>guava</artifactId>
-        <version>${guava.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.google.android</groupId>
-        <artifactId>android</artifactId>
-        <version>${android.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.squareup.moshi</groupId>
-        <artifactId>moshi</artifactId>
-        <version>${moshi.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.github.jnr</groupId>
-        <artifactId>jnr-unixsocket</artifactId>
-        <version>${jnr-unixsocket.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>org.conscrypt</groupId>
-        <artifactId>conscrypt-openjdk-uber</artifactId>
-        <version>${conscrypt.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>org.assertj</groupId>
-        <artifactId>assertj-core</artifactId>
-        <version>${assertj.version}</version>
-      </dependency>
-    </dependencies>
-  </dependencyManagement>
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.okio</groupId>
+      <artifactId>okio</artifactId>
+      <version>${okio.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <version>${junit.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <version>${assertj.version}</version>
+    </dependency>
+  </dependencies>
 
   <build>
-    <pluginManagement>
-      <plugins>
-        <plugin>
-          <groupId>org.apache.maven.plugins</groupId>
-          <artifactId>maven-compiler-plugin</artifactId>
-          <version>3.8.0</version>
-          <configuration>
-            <source>${java.version}</source>
-            <target>${java.version}</target>
-          </configuration>
-        </plugin>
-
-        <plugin>
-          <groupId>org.apache.maven.plugins</groupId>
-          <artifactId>maven-surefire-plugin</artifactId>
-          <version>2.22.1</version>
-          <configuration>
-            <systemPropertyVariables>
-              <okhttp.platform>${okhttp.platform}</okhttp.platform>
-            </systemPropertyVariables>
-            <redirectTestOutputToFile>true</redirectTestOutputToFile>
-            <properties>
-              <!--
-                Configure a listener for enforcing that no uncaught exceptions issue from OkHttp
-                tests. Every test must have a <scope>test</scope> dependency on
-                okhttp-testing-support.
-                -->
-              <property>
-                <name>listener</name>
-                <value>okhttp3.testing.InstallUncaughtExceptionHandlerListener</value>
-              </property>
-            </properties>
-          </configuration>
-          <dependencies>
-            <dependency>
-              <groupId>org.apache.maven.surefire</groupId>
-              <artifactId>surefire-junit47</artifactId>
-              <version>2.22.1</version>
-            </dependency>
-          </dependencies>
-        </plugin>
-
-        <plugin>
-          <groupId>org.apache.maven.plugins</groupId>
-          <artifactId>maven-javadoc-plugin</artifactId>
-          <version>3.0.1</version>
-          <configuration>
-            <failOnError>false</failOnError>
-            <doclint>none</doclint>
-          </configuration>
-        </plugin>
-      </plugins>
-    </pluginManagement>
-
     <plugins>
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-release-plugin</artifactId>
-        <version>2.5.3</version>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <version>3.8.1</version>
         <configuration>
-          <autoVersionSubmodules>true</autoVersionSubmodules>
+          <source>${java.version}</source>
+          <target>${java.version}</target>
         </configuration>
       </plugin>
-
       <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-checkstyle-plugin</artifactId>
-        <version>3.0.0</version>
-        <dependencies>
-          <dependency>
-            <groupId>com.puppycrawl.tools</groupId>
-            <artifactId>checkstyle</artifactId>
-            <version>8.15</version>
-          </dependency>
-        </dependencies>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>exec-maven-plugin</artifactId>
+        <version>1.6.0</version>
         <configuration>
-          <failsOnError>true</failsOnError>
-          <configLocation>checkstyle.xml</configLocation>
-          <consoleOutput>true</consoleOutput>
-          <excludes>**/CipherSuite.java</excludes>
+          <mainClass>net.disy.commons.web.PublicSuffixListGenerator</mainClass>
+          <classpathScope>test</classpathScope>
+          <daemonThreadJoinTimeout>3000</daemonThreadJoinTimeout>
         </configuration>
         <executions>
           <execution>
-            <phase>verify</phase>
+            <phase>test-compile</phase>
             <goals>
-              <goal>checkstyle</goal>
+              <goal>java</goal>
             </goals>
           </execution>
         </executions>
       </plugin>
       <plugin>
-        <groupId>org.codehaus.mojo</groupId>
-        <artifactId>animal-sniffer-maven-plugin</artifactId>
-        <version>${animal.sniffer.version}</version>
-        <executions>
-          <execution>
-            <id>sniff-java18</id>
-            <phase>test</phase>
-            <goals>
-              <goal>check</goal>
-            </goals>
-            <configuration>
-              <signature>
-                <groupId>org.codehaus.mojo.signature</groupId>
-                <artifactId>java18</artifactId>
-                <version>1.0</version>
-              </signature>
-            </configuration>
-          </execution>
-          <execution>
-            <id>sniff-android5</id>
-            <phase>test</phase>
-            <goals>
-              <goal>check</goal>
-            </goals>
-            <configuration>
-              <signature>
-                <groupId>net.sf.androidscents.signature</groupId>
-                <artifactId>android-api-level-21</artifactId>
-                <version>5.0.1_r2</version>
-              </signature>
-            </configuration>
-          </execution>
-        </executions>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-release-plugin</artifactId>
+        <version>2.5.3</version>
+        <configuration>
+          <autoVersionSubmodules>true</autoVersionSubmodules>
+        </configuration>
+      </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-javadoc-plugin</artifactId>
+        <version>3.1.1</version>
+        <configuration>
+          <failOnError>false</failOnError>
+          <doclint>none</doclint>
+        </configuration>
+      </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <version>3.1.2</version>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>net.disy.commons.web</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
       </plugin>
     </plugins>
   </build>
 
-  <profiles>
-    <profile>
-      <id>errorprone</id>
-      <activation>
-        <jdk>1.8</jdk>
-      </activation>
-      <build>
-        <plugins>
-          <plugin>
-            <groupId>org.apache.maven.plugins</groupId>
-            <artifactId>maven-compiler-plugin</artifactId>
-            <version>3.8.0</version>
-            <configuration>
-              <compilerId>javac-with-errorprone</compilerId>
-              <forceJavacCompilerUse>true</forceJavacCompilerUse>
-              <source>${java.version}</source>
-              <target>${java.version}</target>
-            </configuration>
-            <dependencies>
-              <dependency>
-                <groupId>org.codehaus.plexus</groupId>
-                <artifactId>plexus-compiler-javac-errorprone</artifactId>
-                <version>2.8.5</version>
-              </dependency>
-              <dependency>
-                <groupId>com.google.errorprone</groupId>
-                <artifactId>error_prone_core</artifactId>
-                <version>2.3.2</version>
-              </dependency>
-            </dependencies>
-          </plugin>
-        </plugins>
-      </build>
-    </profile>
-    <profile>
-      <id>javadoc-lenient</id>
-      <!-- MJAVADOC-555 Fixed in upcoming JDK builds -->
-      <activation>
-        <jdk>11</jdk>
-      </activation>
-      <build>
-        <plugins>
-          <plugin>
-            <groupId>org.apache.maven.plugins</groupId>
-            <artifactId>maven-javadoc-plugin</artifactId>
-            <configuration>
-              <skip>true</skip>
-            </configuration>
-          </plugin>
-        </plugins>
-      </build>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8</id>
-      <activation>
-        <jdk>1.8</jdk>
-      </activation>
-      <properties>
-        <bootclasspathPrefix>
-          ${settings.localRepository}/org/mortbay/jetty/alpn/alpn-boot/${alpn.jdk8.version}/alpn-boot-${alpn.jdk8.version}.jar
-        </bootclasspathPrefix>
-        <okhttp.platform>jdk-with-jetty-boot</okhttp.platform>
-      </properties>
-      <build>
-        <pluginManagement>
-          <plugins>
-            <plugin>
-              <groupId>org.apache.maven.plugins</groupId>
-              <artifactId>maven-surefire-plugin</artifactId>
-              <configuration>
-                <argLine>-Xbootclasspath/p:${bootclasspathPrefix} -Xms512m -Xmx512m</argLine>
-              </configuration>
-              <dependencies>
-                <dependency>
-                  <groupId>org.mortbay.jetty.alpn</groupId>
-                  <artifactId>alpn-boot</artifactId>
-                  <version>${alpn.jdk8.version}</version>
-                </dependency>
-              </dependencies>
-            </plugin>
-          </plugins>
-        </pluginManagement>
-      </build>
-    </profile>
-    <profile>
-      <id>jdk9</id>
-      <activation>
-        <jdk>9</jdk>
-      </activation>
-      <properties>
-        <okhttp.platform>jdk9</okhttp.platform>
-      </properties>
-    </profile>
-    <profile>
-      <id>jdk10</id>
-      <activation>
-        <jdk>10</jdk>
-      </activation>
-      <properties>
-        <okhttp.platform>jdk9</okhttp.platform>
-      </properties>
-    </profile>
-    <profile>
-      <id>jdk11</id>
-      <activation>
-        <jdk>11</jdk>
-      </activation>
-      <properties>
-        <okhttp.platform>jdk9</okhttp.platform>
-      </properties>
-    </profile>
-    <profile>
-      <id>jdk12</id>
-      <activation>
-        <jdk>12</jdk>
-      </activation>
-      <properties>
-        <okhttp.platform>jdk9</okhttp.platform>
-      </properties>
-    </profile>
-    <profile>
-      <id>conscrypt</id>
-      <properties>
-        <okhttp.platform>conscrypt</okhttp.platform>
-      </properties>
-      <dependencies>
-        <dependency>
-          <groupId>org.conscrypt</groupId>
-          <artifactId>conscrypt-openjdk-uber</artifactId>
-        </dependency>
-      </dependencies>
-    </profile>
-    <!-- ALPN Versions targeted for each Java 8 minor release -->
-    <!-- Check versions with this page: -->
-    <!-- http://www.eclipse.org/jetty/documentation/current/alpn-chapter.html#alpn-chapterchapterversions -->
-    <profile>
-      <id>alpn-when-jdk8_05</id>
-      <activation>
-        <jdk>1.8.0_05</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.0.v20141016</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_11</id>
-      <activation>
-        <jdk>1.8.0_11</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.0.v20141016</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_20</id>
-      <activation>
-        <jdk>1.8.0_20</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.0.v20141016</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_25</id>
-      <activation>
-        <jdk>1.8.0_25</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.2.v20141202</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_31</id>
-      <activation>
-        <jdk>1.8.0_31</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.3.v20150130</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_40</id>
-      <activation>
-        <jdk>1.8.0_40</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.3.v20150130</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_45</id>
-      <activation>
-        <jdk>1.8.0_45</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.3.v20150130</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_51</id>
-      <activation>
-        <jdk>1.8.0_51</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.4.v20150727</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_60</id>
-      <activation>
-        <jdk>1.8.0_60</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.5.v20150921</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_65</id>
-      <activation>
-        <jdk>1.8.0_65</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.6.v20151105</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_66</id>
-      <activation>
-        <jdk>1.8.0_66</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.6.v20151105</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_71</id>
-      <activation>
-        <jdk>1.8.0_71</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.7.v20160121</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_72</id>
-      <activation>
-        <jdk>1.8.0_72</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.7.v20160121</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_73</id>
-      <activation>
-        <jdk>1.8.0_73</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.7.v20160121</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_74</id>
-      <activation>
-        <jdk>1.8.0_74</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.7.v20160121</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_77</id>
-      <activation>
-        <jdk>1.8.0_77</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.7.v20160121</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_91</id>
-      <activation>
-        <jdk>1.8.0_91</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.7.v20160121</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_92</id>
-      <activation>
-        <jdk>1.8.0_92</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.8.v20160420</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_101</id>
-      <activation>
-        <jdk>1.8.0_101</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.8.v20160420</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_102</id>
-      <activation>
-        <jdk>1.8.0_102</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.9.v20160720</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_111</id>
-      <activation>
-        <jdk>1.8.0_111</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.9.v20160720</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_112</id>
-      <activation>
-        <jdk>1.8.0_112</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.9.v20160720</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_121</id>
-      <activation>
-        <jdk>1.8.0_121</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_131</id>
-      <activation>
-        <jdk>1.8.0_131</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_141</id>
-      <activation>
-        <jdk>1.8.0_141</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_144</id>
-      <activation>
-        <jdk>1.8.0_144</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_151</id>
-      <activation>
-        <jdk>1.8.0_151</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_152</id>
-      <activation>
-        <jdk>1.8.0_152</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_161</id>
-      <activation>
-        <jdk>1.8.0_161</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.12.v20180117</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_162</id>
-      <activation>
-        <jdk>1.8.0_162</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.12.v20180117</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_171</id>
-      <activation>
-        <jdk>1.8.0_171</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.12.v20180117</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_172</id>
-      <activation>
-        <jdk>1.8.0_172</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.12.v20180117</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_181</id>
-      <activation>
-        <jdk>1.8.0_181</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.12.v20180117</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_191</id>
-      <activation>
-        <jdk>1.8.0_191</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.13.v20181017</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_192</id>
-      <activation>
-        <jdk>1.8.0_192</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.13.v20181017</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_201</id>
-      <activation>
-        <jdk>1.8.0_201</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.13.v20181017</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_202</id>
-      <activation>
-        <jdk>1.8.0_202</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.13.v20181017</alpn.jdk8.version>
-      </properties>
-    </profile>
-  </profiles>
+  <distributionManagement>
+    <snapshotRepository>
+      <id>disy.internal-snapshots</id>
+      <url>${disy.internal-snapshots.deploy.url}</url>
+      <uniqueVersion>false</uniqueVersion>
+    </snapshotRepository>
+  </distributionManagement>
+
+  <scm>
+    <url>https://github.com/DisyInformationssysteme/disy-commons-web</url>
+    <connection>scm:git:https://github.com/DisyInformationssysteme/disy-commons-web.git</connection>
+    <developerConnection>scm:git:git@github.com:DisyInformationssysteme/disy-commons-web.git</developerConnection>
+    <tag>HEAD</tag>
+  </scm>
+
+  <issueManagement>
+    <system>GitHub Issues</system>
+    <url>https://github.com/DisyInformationssysteme/disy-commons-web/issues</url>
+  </issueManagement>
+
+  <licenses>
+    <license>
+      <name>Apache 2.0</name>
+      <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
+    </license>
+  </licenses>
+
 </project>
diff --git a/samples/crawler/pom.xml b/samples/crawler/pom.xml
deleted file mode 100644
index 2fcef4c418..0000000000
--- a/samples/crawler/pom.xml
+++ /dev/null
@@ -1,27 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3.sample</groupId>
-    <artifactId>sample-parent</artifactId>
-    <version>3.14.3-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>crawler</artifactId>
-  <name>Sample: Crawler</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>org.jsoup</groupId>
-      <artifactId>jsoup</artifactId>
-      <version>1.11.3</version>
-    </dependency>
-  </dependencies>
-</project>
diff --git a/samples/crawler/src/main/java/okhttp3/sample/Crawler.java b/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
deleted file mode 100644
index 95ba357def..0000000000
--- a/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
+++ /dev/null
@@ -1,145 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.sample;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.Collections;
-import java.util.LinkedHashSet;
-import java.util.Set;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.atomic.AtomicInteger;
-import okhttp3.Cache;
-import okhttp3.HttpUrl;
-import okhttp3.MediaType;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.NamedRunnable;
-import org.jsoup.Jsoup;
-import org.jsoup.nodes.Document;
-import org.jsoup.nodes.Element;
-
-/**
- * Fetches HTML from a requested URL, follows the links, and repeats.
- */
-public final class Crawler {
-  private final OkHttpClient client;
-  private final Set<HttpUrl> fetchedUrls = Collections.synchronizedSet(new LinkedHashSet<>());
-  private final LinkedBlockingQueue<HttpUrl> queue = new LinkedBlockingQueue<>();
-  private final ConcurrentHashMap<String, AtomicInteger> hostnames = new ConcurrentHashMap<>();
-
-  public Crawler(OkHttpClient client) {
-    this.client = client;
-  }
-
-  private void parallelDrainQueue(int threadCount) {
-    ExecutorService executor = Executors.newFixedThreadPool(threadCount);
-    for (int i = 0; i < threadCount; i++) {
-      executor.execute(new NamedRunnable("Crawler %s", i) {
-        @Override protected void execute() {
-          try {
-            drainQueue();
-          } catch (Exception e) {
-            e.printStackTrace();
-          }
-        }
-      });
-    }
-    executor.shutdown();
-  }
-
-  private void drainQueue() throws Exception {
-    for (HttpUrl url; (url = queue.take()) != null; ) {
-      if (!fetchedUrls.add(url)) {
-        continue;
-      }
-
-      Thread currentThread = Thread.currentThread();
-      String originalName = currentThread.getName();
-      currentThread.setName("Crawler " + url.toString());
-      try {
-        fetch(url);
-      } catch (IOException e) {
-        System.out.printf("XXX: %s %s%n", url, e);
-      } finally {
-        currentThread.setName(originalName);
-      }
-    }
-  }
-
-  public void fetch(HttpUrl url) throws IOException {
-    // Skip hosts that we've visited many times.
-    AtomicInteger hostnameCount = new AtomicInteger();
-    AtomicInteger previous = hostnames.putIfAbsent(url.host(), hostnameCount);
-    if (previous != null) hostnameCount = previous;
-    if (hostnameCount.incrementAndGet() > 100) return;
-
-    Request request = new Request.Builder()
-        .url(url)
-        .build();
-    try (Response response = client.newCall(request).execute()) {
-      String responseSource = response.networkResponse() != null ? ("(network: "
-          + response.networkResponse().code()
-          + " over "
-          + response.protocol()
-          + ")") : "(cache)";
-      int responseCode = response.code();
-
-      System.out.printf("%03d: %s %s%n", responseCode, url, responseSource);
-
-      String contentType = response.header("Content-Type");
-      if (responseCode != 200 || contentType == null) {
-        return;
-      }
-
-      MediaType mediaType = MediaType.parse(contentType);
-      if (mediaType == null || !mediaType.subtype().equalsIgnoreCase("html")) {
-        return;
-      }
-
-      Document document = Jsoup.parse(response.body().string(), url.toString());
-      for (Element element : document.select("a[href]")) {
-        String href = element.attr("href");
-        HttpUrl link = response.request().url().resolve(href);
-        if (link == null) continue; // URL is either invalid or its scheme isn't http/https.
-        queue.add(link.newBuilder().fragment(null).build());
-      }
-    }
-  }
-
-  public static void main(String[] args) throws IOException {
-    if (args.length != 2) {
-      System.out.println("Usage: Crawler <cache dir> <root>");
-      return;
-    }
-
-    int threadCount = 20;
-    long cacheByteCount = 1024L * 1024L * 100L;
-
-    Cache cache = new Cache(new File(args[0]), cacheByteCount);
-    OkHttpClient client = new OkHttpClient.Builder()
-        .cache(cache)
-        .build();
-
-    Crawler crawler = new Crawler(client);
-    crawler.queue.add(HttpUrl.get(args[1]));
-    crawler.parallelDrainQueue(threadCount);
-  }
-}
diff --git a/samples/guide/pom.xml b/samples/guide/pom.xml
deleted file mode 100644
index ceea2c99d8..0000000000
--- a/samples/guide/pom.xml
+++ /dev/null
@@ -1,36 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3.sample</groupId>
-    <artifactId>sample-parent</artifactId>
-    <version>3.14.3-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>guide</artifactId>
-  <name>Sample: Guide</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>okhttp-tls</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.moshi</groupId>
-      <artifactId>moshi</artifactId>
-    </dependency>
-  </dependencies>
-</project>
diff --git a/samples/guide/src/main/java/okhttp3/guide/GetExample.java b/samples/guide/src/main/java/okhttp3/guide/GetExample.java
deleted file mode 100644
index 35a1cc658c..0000000000
--- a/samples/guide/src/main/java/okhttp3/guide/GetExample.java
+++ /dev/null
@@ -1,26 +0,0 @@
-package okhttp3.guide;
-
-import java.io.IOException;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-
-public class GetExample {
-  OkHttpClient client = new OkHttpClient();
-
-  String run(String url) throws IOException {
-    Request request = new Request.Builder()
-        .url(url)
-        .build();
-
-    try (Response response = client.newCall(request).execute()) {
-      return response.body().string();
-    }
-  }
-
-  public static void main(String[] args) throws IOException {
-    GetExample example = new GetExample();
-    String response = example.run("https://raw.github.com/square/okhttp/master/README.md");
-    System.out.println(response);
-  }
-}
diff --git a/samples/guide/src/main/java/okhttp3/guide/PostExample.java b/samples/guide/src/main/java/okhttp3/guide/PostExample.java
deleted file mode 100644
index ddaacb6c5e..0000000000
--- a/samples/guide/src/main/java/okhttp3/guide/PostExample.java
+++ /dev/null
@@ -1,44 +0,0 @@
-package okhttp3.guide;
-
-import java.io.IOException;
-import okhttp3.MediaType;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-
-public class PostExample {
-  public static final MediaType JSON = MediaType.get("application/json; charset=utf-8");
-
-  OkHttpClient client = new OkHttpClient();
-
-  String post(String url, String json) throws IOException {
-    RequestBody body = RequestBody.create(JSON, json);
-    Request request = new Request.Builder()
-        .url(url)
-        .post(body)
-        .build();
-    try (Response response = client.newCall(request).execute()) {
-      return response.body().string();
-    }
-  }
-
-  String bowlingJson(String player1, String player2) {
-    return "{'winCondition':'HIGH_SCORE',"
-        + "'name':'Bowling',"
-        + "'round':4,"
-        + "'lastSaved':1367702411696,"
-        + "'dateStarted':1367702378785,"
-        + "'players':["
-        + "{'name':'" + player1 + "','history':[10,8,6,7,8],'color':-13388315,'total':39},"
-        + "{'name':'" + player2 + "','history':[6,10,5,10,10],'color':-48060,'total':41}"
-        + "]}";
-  }
-
-  public static void main(String[] args) throws IOException {
-    PostExample example = new PostExample();
-    String json = example.bowlingJson("Jesse", "Jake");
-    String response = example.post("http://www.roundsapp.com/post", json);
-    System.out.println(response);
-  }
-}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/AccessHeaders.java b/samples/guide/src/main/java/okhttp3/recipes/AccessHeaders.java
deleted file mode 100644
index 95fa49241c..0000000000
--- a/samples/guide/src/main/java/okhttp3/recipes/AccessHeaders.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.recipes;
-
-import java.io.IOException;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-
-public final class AccessHeaders {
-  private final OkHttpClient client = new OkHttpClient();
-
-  public void run() throws Exception {
-    Request request = new Request.Builder()
-        .url("https://api.github.com/repos/square/okhttp/issues")
-        .header("User-Agent", "OkHttp Headers.java")
-        .addHeader("Accept", "application/json; q=0.5")
-        .addHeader("Accept", "application/vnd.github.v3+json")
-        .build();
-
-    try (Response response = client.newCall(request).execute()) {
-      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-      System.out.println("Server: " + response.header("Server"));
-      System.out.println("Date: " + response.header("Date"));
-      System.out.println("Vary: " + response.headers("Vary"));
-    }
-  }
-
-  public static void main(String... args) throws Exception {
-    new AccessHeaders().run();
-  }
-}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/AsynchronousGet.java b/samples/guide/src/main/java/okhttp3/recipes/AsynchronousGet.java
deleted file mode 100644
index 68f1c2d591..0000000000
--- a/samples/guide/src/main/java/okhttp3/recipes/AsynchronousGet.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.recipes;
-
-import java.io.IOException;
-import okhttp3.Call;
-import okhttp3.Callback;
-import okhttp3.Headers;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-
-public final class AsynchronousGet {
-  private final OkHttpClient client = new OkHttpClient();
-
-  public void run() throws Exception {
-    Request request = new Request.Builder()
-        .url("http://publicobject.com/helloworld.txt")
-        .build();
-
-    client.newCall(request).enqueue(new Callback() {
-      @Override public void onFailure(Call call, IOException e) {
-        e.printStackTrace();
-      }
-
-      @Override public void onResponse(Call call, Response response) throws IOException {
-        try (ResponseBody responseBody = response.body()) {
-          if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-          Headers responseHeaders = response.headers();
-          for (int i = 0, size = responseHeaders.size(); i < size; i++) {
-            System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i));
-          }
-
-          System.out.println(responseBody.string());
-        }
-      }
-    });
-  }
-
-  public static void main(String... args) throws Exception {
-    new AsynchronousGet().run();
-  }
-}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/Authenticate.java b/samples/guide/src/main/java/okhttp3/recipes/Authenticate.java
deleted file mode 100644
index 4eb09d8f11..0000000000
--- a/samples/guide/src/main/java/okhttp3/recipes/Authenticate.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.recipes;
-
-import java.io.IOException;
-import okhttp3.Authenticator;
-import okhttp3.Credentials;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.Route;
-
-public final class Authenticate {
-  private final OkHttpClient client;
-
-  public Authenticate() {
-    client = new OkHttpClient.Builder()
-        .authenticator(new Authenticator() {
-          @Override public Request authenticate(Route route, Response response) throws IOException {
-            if (response.request().header("Authorization") != null) {
-              return null; // Give up, we've already attempted to authenticate.
-            }
-
-            System.out.println("Authenticating for response: " + response);
-            System.out.println("Challenges: " + response.challenges());
-            String credential = Credentials.basic("jesse", "password1");
-            return response.request().newBuilder()
-                .header("Authorization", credential)
-                .build();
-          }
-        })
-        .build();
-  }
-
-  public void run() throws Exception {
-    Request request = new Request.Builder()
-        .url("http://publicobject.com/secrets/hellosecret.txt")
-        .build();
-
-    try (Response response = client.newCall(request).execute()) {
-      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-      System.out.println(response.body().string());
-    }
-  }
-
-  public static void main(String... args) throws Exception {
-    new Authenticate().run();
-  }
-}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CacheResponse.java b/samples/guide/src/main/java/okhttp3/recipes/CacheResponse.java
deleted file mode 100644
index c43f9214ab..0000000000
--- a/samples/guide/src/main/java/okhttp3/recipes/CacheResponse.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.recipes;
-
-import java.io.File;
-import java.io.IOException;
-import okhttp3.Cache;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-
-public final class CacheResponse {
-  private final OkHttpClient client;
-
-  public CacheResponse(File cacheDirectory) throws Exception {
-    int cacheSize = 10 * 1024 * 1024; // 10 MiB
-    Cache cache = new Cache(cacheDirectory, cacheSize);
-
-    client = new OkHttpClient.Builder()
-        .cache(cache)
-        .build();
-  }
-
-  public void run() throws Exception {
-    Request request = new Request.Builder()
-        .url("http://publicobject.com/helloworld.txt")
-        .build();
-
-    String response1Body;
-    try (Response response1 = client.newCall(request).execute()) {
-      if (!response1.isSuccessful()) throw new IOException("Unexpected code " + response1);
-
-      response1Body = response1.body().string();
-      System.out.println("Response 1 response:          " + response1);
-      System.out.println("Response 1 cache response:    " + response1.cacheResponse());
-      System.out.println("Response 1 network response:  " + response1.networkResponse());
-    }
-
-    String response2Body;
-    try (Response response2 = client.newCall(request).execute()) {
-      if (!response2.isSuccessful()) throw new IOException("Unexpected code " + response2);
-
-      response2Body = response2.body().string();
-      System.out.println("Response 2 response:          " + response2);
-      System.out.println("Response 2 cache response:    " + response2.cacheResponse());
-      System.out.println("Response 2 network response:  " + response2.networkResponse());
-    }
-
-    System.out.println("Response 2 equals Response 1? " + response1Body.equals(response2Body));
-  }
-
-  public static void main(String... args) throws Exception {
-    new CacheResponse(new File("CacheResponse.tmp")).run();
-  }
-}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CancelCall.java b/samples/guide/src/main/java/okhttp3/recipes/CancelCall.java
deleted file mode 100644
index 58a791adc7..0000000000
--- a/samples/guide/src/main/java/okhttp3/recipes/CancelCall.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.recipes;
-
-import java.io.IOException;
-import java.util.concurrent.Executors;
-import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.TimeUnit;
-import okhttp3.Call;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-
-public class CancelCall {
-  private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
-  private final OkHttpClient client = new OkHttpClient();
-
-  public void run() throws Exception {
-    Request request = new Request.Builder()
-        .url("http://httpbin.org/delay/2") // This URL is served with a 2 second delay.
-        .build();
-
-    final long startNanos = System.nanoTime();
-    final Call call = client.newCall(request);
-
-    // Schedule a job to cancel the call in 1 second.
-    executor.schedule(() -> {
-      System.out.printf("%.2f Canceling call.%n", (System.nanoTime() - startNanos) / 1e9f);
-      call.cancel();
-      System.out.printf("%.2f Canceled call.%n", (System.nanoTime() - startNanos) / 1e9f);
-    }, 1, TimeUnit.SECONDS);
-
-    System.out.printf("%.2f Executing call.%n", (System.nanoTime() - startNanos) / 1e9f);
-    try (Response response = call.execute()) {
-      System.out.printf("%.2f Call was expected to fail, but completed: %s%n",
-          (System.nanoTime() - startNanos) / 1e9f, response);
-    } catch (IOException e) {
-      System.out.printf("%.2f Call failed as expected: %s%n",
-          (System.nanoTime() - startNanos) / 1e9f, e);
-    }
-  }
-
-  public static void main(String... args) throws Exception {
-    new CancelCall().run();
-  }
-}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java b/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java
deleted file mode 100644
index 91c3fcc59f..0000000000
--- a/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.recipes;
-
-import java.io.IOException;
-import java.security.cert.Certificate;
-import okhttp3.CertificatePinner;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-
-public final class CertificatePinning {
-  private final OkHttpClient client;
-
-  public CertificatePinning() {
-    client = new OkHttpClient.Builder()
-        .certificatePinner(
-            new CertificatePinner.Builder()
-                .add("publicobject.com", "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
-                .build())
-        .build();
-  }
-
-  public void run() throws Exception {
-    Request request = new Request.Builder()
-        .url("https://publicobject.com/robots.txt")
-        .build();
-
-    try (Response response = client.newCall(request).execute()) {
-      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-      for (Certificate certificate : response.handshake().peerCertificates()) {
-        System.out.println(CertificatePinner.pin(certificate));
-      }
-    }
-  }
-
-  public static void main(String... args) throws Exception {
-    new CertificatePinning().run();
-  }
-}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CheckHandshake.java b/samples/guide/src/main/java/okhttp3/recipes/CheckHandshake.java
deleted file mode 100644
index befd80983c..0000000000
--- a/samples/guide/src/main/java/okhttp3/recipes/CheckHandshake.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.recipes;
-
-import java.io.IOException;
-import java.security.cert.Certificate;
-import java.util.Collections;
-import java.util.Set;
-import okhttp3.CertificatePinner;
-import okhttp3.Interceptor;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-
-public final class CheckHandshake {
-  /** Rejects otherwise-trusted certificates. */
-  private static final Interceptor CHECK_HANDSHAKE_INTERCEPTOR = new Interceptor() {
-    Set<String> blacklist = Collections.singleton(
-        "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=");
-
-    @Override public Response intercept(Chain chain) throws IOException {
-      for (Certificate certificate : chain.connection().handshake().peerCertificates()) {
-        String pin = CertificatePinner.pin(certificate);
-        if (blacklist.contains(pin)) {
-          throw new IOException("Blacklisted peer certificate: " + pin);
-        }
-      }
-      return chain.proceed(chain.request());
-    }
-  };
-
-  private final OkHttpClient client = new OkHttpClient.Builder()
-      .addNetworkInterceptor(CHECK_HANDSHAKE_INTERCEPTOR)
-      .build();
-
-  public void run() throws Exception {
-    Request request = new Request.Builder()
-        .url("https://publicobject.com/helloworld.txt")
-        .build();
-
-    try (Response response = client.newCall(request).execute()) {
-      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-      System.out.println(response.body().string());
-    }
-  }
-
-  public static void main(String... args) throws Exception {
-    new CheckHandshake().run();
-  }
-}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/ConfigureTimeouts.java b/samples/guide/src/main/java/okhttp3/recipes/ConfigureTimeouts.java
deleted file mode 100644
index a6d3000732..0000000000
--- a/samples/guide/src/main/java/okhttp3/recipes/ConfigureTimeouts.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.recipes;
-
-import java.util.concurrent.TimeUnit;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-
-public final class ConfigureTimeouts {
-  private final OkHttpClient client;
-
-  public ConfigureTimeouts() throws Exception {
-    client = new OkHttpClient.Builder()
-        .connectTimeout(10, TimeUnit.SECONDS)
-        .writeTimeout(10, TimeUnit.SECONDS)
-        .readTimeout(30, TimeUnit.SECONDS)
-        .build();
-  }
-
-  public void run() throws Exception {
-    Request request = new Request.Builder()
-        .url("http://httpbin.org/delay/2") // This URL is served with a 2 second delay.
-        .build();
-
-    try (Response response = client.newCall(request).execute()) {
-      System.out.println("Response completed: " + response);
-    }
-  }
-
-  public static void main(String... args) throws Exception {
-    new ConfigureTimeouts().run();
-  }
-}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CurrentDateHeader.java b/samples/guide/src/main/java/okhttp3/recipes/CurrentDateHeader.java
deleted file mode 100644
index 6c15d700df..0000000000
--- a/samples/guide/src/main/java/okhttp3/recipes/CurrentDateHeader.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.recipes;
-
-import java.io.IOException;
-import java.util.Date;
-import okhttp3.Headers;
-import okhttp3.Interceptor;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-
-public final class CurrentDateHeader {
-  private final OkHttpClient client = new OkHttpClient.Builder()
-      .addInterceptor(new CurrentDateInterceptor())
-      .build();
-
-  public void run() throws Exception {
-    Request request = new Request.Builder()
-        .url("https://publicobject.com/helloworld.txt")
-        .build();
-
-    try (Response response = client.newCall(request).execute()) {
-      System.out.println(response.request().header("Date"));
-    }
-  }
-
-  static class CurrentDateInterceptor implements Interceptor {
-    @Override public Response intercept(Chain chain) throws IOException {
-      Request request = chain.request();
-      Headers newHeaders = request.headers()
-          .newBuilder()
-          .add("Date", new Date())
-          .build();
-      Request newRequest = request.newBuilder()
-          .headers(newHeaders)
-          .build();
-      return chain.proceed(newRequest);
-    }
-  }
-
-  public static void main(String... args) throws Exception {
-    new CurrentDateHeader().run();
-  }
-}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CustomCipherSuites.java b/samples/guide/src/main/java/okhttp3/recipes/CustomCipherSuites.java
deleted file mode 100644
index b568bdf01c..0000000000
--- a/samples/guide/src/main/java/okhttp3/recipes/CustomCipherSuites.java
+++ /dev/null
@@ -1,169 +0,0 @@
-/*
- * Copyright (C) 2017 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.recipes;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.Socket;
-import java.security.GeneralSecurityException;
-import java.security.KeyManagementException;
-import java.security.KeyStore;
-import java.security.NoSuchAlgorithmException;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.TrustManagerFactory;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.CipherSuite;
-import okhttp3.ConnectionSpec;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-
-public final class CustomCipherSuites {
-  private final OkHttpClient client;
-
-  public CustomCipherSuites() throws GeneralSecurityException {
-    // Configure cipher suites to demonstrate how to customize which cipher suites will be used for
-    // an OkHttp request. In order to be selected a cipher suite must be included in both OkHttp's
-    // connection spec and in the SSLSocket's enabled cipher suites array. Most applications should
-    // not customize the cipher suites list.
-    List<CipherSuite> customCipherSuites = Arrays.asList(
-        CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
-        CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
-        CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
-        CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384);
-    final ConnectionSpec spec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
-        .cipherSuites(customCipherSuites.toArray(new CipherSuite[0]))
-        .build();
-
-    X509TrustManager trustManager = defaultTrustManager();
-    SSLSocketFactory sslSocketFactory = defaultSslSocketFactory(trustManager);
-    SSLSocketFactory customSslSocketFactory = new DelegatingSSLSocketFactory(sslSocketFactory) {
-      @Override protected SSLSocket configureSocket(SSLSocket socket) throws IOException {
-        socket.setEnabledCipherSuites(javaNames(spec.cipherSuites()));
-        return socket;
-      }
-    };
-
-    client = new OkHttpClient.Builder()
-        .connectionSpecs(Collections.singletonList(spec))
-        .sslSocketFactory(customSslSocketFactory, trustManager)
-        .build();
-  }
-
-  /**
-   * Returns the VM's default SSL socket factory, using {@code trustManager} for trusted root
-   * certificates.
-   */
-  private SSLSocketFactory defaultSslSocketFactory(X509TrustManager trustManager)
-      throws NoSuchAlgorithmException, KeyManagementException {
-    SSLContext sslContext = SSLContext.getInstance("TLS");
-    sslContext.init(null, new TrustManager[] { trustManager }, null);
-
-    return sslContext.getSocketFactory();
-  }
-
-  /** Returns a trust manager that trusts the VM's default certificate authorities. */
-  private X509TrustManager defaultTrustManager() throws GeneralSecurityException {
-    TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
-        TrustManagerFactory.getDefaultAlgorithm());
-    trustManagerFactory.init((KeyStore) null);
-    TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
-    if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
-      throw new IllegalStateException("Unexpected default trust managers:"
-          + Arrays.toString(trustManagers));
-    }
-    return (X509TrustManager) trustManagers[0];
-  }
-
-  private String[] javaNames(List<CipherSuite> cipherSuites) {
-    String[] result = new String[cipherSuites.size()];
-    for (int i = 0; i < result.length; i++) {
-      result[i] = cipherSuites.get(i).javaName();
-    }
-    return result;
-  }
-
-  /**
-   * An SSL socket factory that forwards all calls to a delegate. Override {@link #configureSocket}
-   * to customize a created socket before it is returned.
-   */
-  static class DelegatingSSLSocketFactory extends SSLSocketFactory {
-    protected final SSLSocketFactory delegate;
-
-    DelegatingSSLSocketFactory(SSLSocketFactory delegate) {
-      this.delegate = delegate;
-    }
-
-    @Override public String[] getDefaultCipherSuites() {
-      return delegate.getDefaultCipherSuites();
-    }
-
-    @Override public String[] getSupportedCipherSuites() {
-      return delegate.getSupportedCipherSuites();
-    }
-
-    @Override public Socket createSocket(
-        Socket socket, String host, int port, boolean autoClose) throws IOException {
-      return configureSocket((SSLSocket) delegate.createSocket(socket, host, port, autoClose));
-    }
-
-    @Override public Socket createSocket(String host, int port) throws IOException {
-      return configureSocket((SSLSocket) delegate.createSocket(host, port));
-    }
-
-    @Override public Socket createSocket(
-        String host, int port, InetAddress localHost, int localPort) throws IOException {
-      return configureSocket((SSLSocket) delegate.createSocket(host, port, localHost, localPort));
-    }
-
-    @Override public Socket createSocket(InetAddress host, int port) throws IOException {
-      return configureSocket((SSLSocket) delegate.createSocket(host, port));
-    }
-
-    @Override public Socket createSocket(
-        InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
-      return configureSocket((SSLSocket) delegate.createSocket(
-          address, port, localAddress, localPort));
-    }
-
-    protected SSLSocket configureSocket(SSLSocket socket) throws IOException {
-      return socket;
-    }
-  }
-
-  public void run() throws Exception {
-    Request request = new Request.Builder()
-        .url("https://publicobject.com/helloworld.txt")
-        .build();
-
-    try (Response response = client.newCall(request).execute()) {
-      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-      System.out.println(response.handshake().cipherSuite());
-      System.out.println(response.body().string());
-    }
-  }
-
-  public static void main(String... args) throws Exception {
-    new CustomCipherSuites().run();
-  }
-}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CustomTrust.java b/samples/guide/src/main/java/okhttp3/recipes/CustomTrust.java
deleted file mode 100644
index a8df15ba32..0000000000
--- a/samples/guide/src/main/java/okhttp3/recipes/CustomTrust.java
+++ /dev/null
@@ -1,221 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.recipes;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.security.GeneralSecurityException;
-import java.security.KeyStore;
-import java.security.cert.Certificate;
-import java.security.cert.CertificateFactory;
-import java.util.Arrays;
-import java.util.Collection;
-import javax.net.ssl.KeyManagerFactory;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.TrustManagerFactory;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.CertificatePinner;
-import okhttp3.Headers;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-import okio.Buffer;
-
-public final class CustomTrust {
-  private final OkHttpClient client;
-
-  public CustomTrust() {
-    X509TrustManager trustManager;
-    SSLSocketFactory sslSocketFactory;
-    try {
-      trustManager = trustManagerForCertificates(trustedCertificatesInputStream());
-      SSLContext sslContext = SSLContext.getInstance("TLS");
-      sslContext.init(null, new TrustManager[] { trustManager }, null);
-      sslSocketFactory = sslContext.getSocketFactory();
-    } catch (GeneralSecurityException e) {
-      throw new RuntimeException(e);
-    }
-
-    client = new OkHttpClient.Builder()
-        .sslSocketFactory(sslSocketFactory, trustManager)
-        .build();
-  }
-
-  public void run() throws Exception {
-    Request request = new Request.Builder()
-        .url("https://publicobject.com/helloworld.txt")
-        .build();
-
-    try (Response response = client.newCall(request).execute()) {
-      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-      Headers responseHeaders = response.headers();
-      for (int i = 0; i < responseHeaders.size(); i++) {
-        System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i));
-      }
-
-      System.out.println(response.body().string());
-    }
-  }
-
-  /**
-   * Returns an input stream containing one or more certificate PEM files. This implementation just
-   * embeds the PEM files in Java strings; most applications will instead read this from a resource
-   * file that gets bundled with the application.
-   */
-  private InputStream trustedCertificatesInputStream() {
-    // PEM files for root certificates of Comodo and Entrust. These two CAs are sufficient to view
-    // https://publicobject.com (Comodo) and https://squareup.com (Entrust). But they aren't
-    // sufficient to connect to most HTTPS sites including https://godaddy.com and https://visa.com.
-    // Typically developers will need to get a PEM file from their organization's TLS administrator.
-    String comodoRsaCertificationAuthority = ""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIF2DCCA8CgAwIBAgIQTKr5yttjb+Af907YWwOGnTANBgkqhkiG9w0BAQwFADCB\n"
-        + "hTELMAkGA1UEBhMCR0IxGzAZBgNVBAgTEkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4G\n"
-        + "A1UEBxMHU2FsZm9yZDEaMBgGA1UEChMRQ09NT0RPIENBIExpbWl0ZWQxKzApBgNV\n"
-        + "BAMTIkNPTU9ETyBSU0EgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMTAwMTE5\n"
-        + "MDAwMDAwWhcNMzgwMTE4MjM1OTU5WjCBhTELMAkGA1UEBhMCR0IxGzAZBgNVBAgT\n"
-        + "EkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4GA1UEBxMHU2FsZm9yZDEaMBgGA1UEChMR\n"
-        + "Q09NT0RPIENBIExpbWl0ZWQxKzApBgNVBAMTIkNPTU9ETyBSU0EgQ2VydGlmaWNh\n"
-        + "dGlvbiBBdXRob3JpdHkwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCR\n"
-        + "6FSS0gpWsawNJN3Fz0RndJkrN6N9I3AAcbxT38T6KhKPS38QVr2fcHK3YX/JSw8X\n"
-        + "pz3jsARh7v8Rl8f0hj4K+j5c+ZPmNHrZFGvnnLOFoIJ6dq9xkNfs/Q36nGz637CC\n"
-        + "9BR++b7Epi9Pf5l/tfxnQ3K9DADWietrLNPtj5gcFKt+5eNu/Nio5JIk2kNrYrhV\n"
-        + "/erBvGy2i/MOjZrkm2xpmfh4SDBF1a3hDTxFYPwyllEnvGfDyi62a+pGx8cgoLEf\n"
-        + "Zd5ICLqkTqnyg0Y3hOvozIFIQ2dOciqbXL1MGyiKXCJ7tKuY2e7gUYPDCUZObT6Z\n"
-        + "+pUX2nwzV0E8jVHtC7ZcryxjGt9XyD+86V3Em69FmeKjWiS0uqlWPc9vqv9JWL7w\n"
-        + "qP/0uK3pN/u6uPQLOvnoQ0IeidiEyxPx2bvhiWC4jChWrBQdnArncevPDt09qZah\n"
-        + "SL0896+1DSJMwBGB7FY79tOi4lu3sgQiUpWAk2nojkxl8ZEDLXB0AuqLZxUpaVIC\n"
-        + "u9ffUGpVRr+goyhhf3DQw6KqLCGqR84onAZFdr+CGCe01a60y1Dma/RMhnEw6abf\n"
-        + "Fobg2P9A3fvQQoh/ozM6LlweQRGBY84YcWsr7KaKtzFcOmpH4MN5WdYgGq/yapiq\n"
-        + "crxXStJLnbsQ/LBMQeXtHT1eKJ2czL+zUdqnR+WEUwIDAQABo0IwQDAdBgNVHQ4E\n"
-        + "FgQUu69+Aj36pvE8hI6t7jiY7NkyMtQwDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB\n"
-        + "/wQFMAMBAf8wDQYJKoZIhvcNAQEMBQADggIBAArx1UaEt65Ru2yyTUEUAJNMnMvl\n"
-        + "wFTPoCWOAvn9sKIN9SCYPBMtrFaisNZ+EZLpLrqeLppysb0ZRGxhNaKatBYSaVqM\n"
-        + "4dc+pBroLwP0rmEdEBsqpIt6xf4FpuHA1sj+nq6PK7o9mfjYcwlYRm6mnPTXJ9OV\n"
-        + "2jeDchzTc+CiR5kDOF3VSXkAKRzH7JsgHAckaVd4sjn8OoSgtZx8jb8uk2Intzna\n"
-        + "FxiuvTwJaP+EmzzV1gsD41eeFPfR60/IvYcjt7ZJQ3mFXLrrkguhxuhoqEwWsRqZ\n"
-        + "CuhTLJK7oQkYdQxlqHvLI7cawiiFwxv/0Cti76R7CZGYZ4wUAc1oBmpjIXUDgIiK\n"
-        + "boHGhfKppC3n9KUkEEeDys30jXlYsQab5xoq2Z0B15R97QNKyvDb6KkBPvVWmcke\n"
-        + "jkk9u+UJueBPSZI9FoJAzMxZxuY67RIuaTxslbH9qh17f4a+Hg4yRvv7E491f0yL\n"
-        + "S0Zj/gA0QHDBw7mh3aZw4gSzQbzpgJHqZJx64SIDqZxubw5lT2yHh17zbqD5daWb\n"
-        + "QOhTsiedSrnAdyGN/4fy3ryM7xfft0kL0fJuMAsaDk527RH89elWsn2/x20Kk4yl\n"
-        + "0MC2Hb46TpSi125sC8KKfPog88Tk5c0NqMuRkrF8hey1FGlmDoLnzc7ILaZRfyHB\n"
-        + "NVOFBkpdn627G190\n"
-        + "-----END CERTIFICATE-----\n";
-    String entrustRootCertificateAuthority = ""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIEkTCCA3mgAwIBAgIERWtQVDANBgkqhkiG9w0BAQUFADCBsDELMAkGA1UEBhMC\n"
-        + "VVMxFjAUBgNVBAoTDUVudHJ1c3QsIEluYy4xOTA3BgNVBAsTMHd3dy5lbnRydXN0\n"
-        + "Lm5ldC9DUFMgaXMgaW5jb3Jwb3JhdGVkIGJ5IHJlZmVyZW5jZTEfMB0GA1UECxMW\n"
-        + "KGMpIDIwMDYgRW50cnVzdCwgSW5jLjEtMCsGA1UEAxMkRW50cnVzdCBSb290IENl\n"
-        + "cnRpZmljYXRpb24gQXV0aG9yaXR5MB4XDTA2MTEyNzIwMjM0MloXDTI2MTEyNzIw\n"
-        + "NTM0MlowgbAxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1FbnRydXN0LCBJbmMuMTkw\n"
-        + "NwYDVQQLEzB3d3cuZW50cnVzdC5uZXQvQ1BTIGlzIGluY29ycG9yYXRlZCBieSBy\n"
-        + "ZWZlcmVuY2UxHzAdBgNVBAsTFihjKSAyMDA2IEVudHJ1c3QsIEluYy4xLTArBgNV\n"
-        + "BAMTJEVudHJ1c3QgUm9vdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTCCASIwDQYJ\n"
-        + "KoZIhvcNAQEBBQADggEPADCCAQoCggEBALaVtkNC+sZtKm9I35RMOVcF7sN5EUFo\n"
-        + "Nu3s/poBj6E4KPz3EEZmLk0eGrEaTsbRwJWIsMn/MYszA9u3g3s+IIRe7bJWKKf4\n"
-        + "4LlAcTfFy0cOlypowCKVYhXbR9n10Cv/gkvJrT7eTNuQgFA/CYqEAOwwCj0Yzfv9\n"
-        + "KlmaI5UXLEWeH25DeW0MXJj+SKfFI0dcXv1u5x609mhF0YaDW6KKjbHjKYD+JXGI\n"
-        + "rb68j6xSlkuqUY3kEzEZ6E5Nn9uss2rVvDlUccp6en+Q3X0dgNmBu1kmwhH+5pPi\n"
-        + "94DkZfs0Nw4pgHBNrziGLp5/V6+eF67rHMsoIV+2HNjnogQi+dPa2MsCAwEAAaOB\n"
-        + "sDCBrTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zArBgNVHRAEJDAi\n"
-        + "gA8yMDA2MTEyNzIwMjM0MlqBDzIwMjYxMTI3MjA1MzQyWjAfBgNVHSMEGDAWgBRo\n"
-        + "kORnpKZTgMeGZqTx90tD+4S9bTAdBgNVHQ4EFgQUaJDkZ6SmU4DHhmak8fdLQ/uE\n"
-        + "vW0wHQYJKoZIhvZ9B0EABBAwDhsIVjcuMTo0LjADAgSQMA0GCSqGSIb3DQEBBQUA\n"
-        + "A4IBAQCT1DCw1wMgKtD5Y+iRDAUgqV8ZyntyTtSx29CW+1RaGSwMCPeyvIWonX9t\n"
-        + "O1KzKtvn1ISMY/YPyyYBkVBs9F8U4pN0wBOeMDpQ47RgxRzwIkSNcUesyBrJ6Zua\n"
-        + "AGAT/3B+XxFNSRuzFVJ7yVTav52Vr2ua2J7p8eRDjeIRRDq/r72DQnNSi6q7pynP\n"
-        + "9WQcCk3RvKqsnyrQ/39/2n3qse0wJcGE2jTSW3iDVuycNsMm4hH2Z0kdkquM++v/\n"
-        + "eu6FSqdQgPCnXEqULl8FmTxSQeDNtGPPAUO6nIPcj2A781q0tHuu2guQOHXvgR1m\n"
-        + "0vdXcDazv/wor3ElhVsT/h5/WrQ8\n"
-        + "-----END CERTIFICATE-----\n";
-    return new Buffer()
-        .writeUtf8(comodoRsaCertificationAuthority)
-        .writeUtf8(entrustRootCertificateAuthority)
-        .inputStream();
-  }
-
-  /**
-   * Returns a trust manager that trusts {@code certificates} and none other. HTTPS services whose
-   * certificates have not been signed by these certificates will fail with a {@code
-   * SSLHandshakeException}.
-   *
-   * <p>This can be used to replace the host platform's built-in trusted certificates with a custom
-   * set. This is useful in development where certificate authority-trusted certificates aren't
-   * available. Or in production, to avoid reliance on third-party certificate authorities.
-   *
-   * <p>See also {@link CertificatePinner}, which can limit trusted certificates while still using
-   * the host platform's built-in trust store.
-   *
-   * <h3>Warning: Customizing Trusted Certificates is Dangerous!</h3>
-   *
-   * <p>Relying on your own trusted certificates limits your server team's ability to update their
-   * TLS certificates. By installing a specific set of trusted certificates, you take on additional
-   * operational complexity and limit your ability to migrate between certificate authorities. Do
-   * not use custom trusted certificates in production without the blessing of your server's TLS
-   * administrator.
-   */
-  private X509TrustManager trustManagerForCertificates(InputStream in)
-      throws GeneralSecurityException {
-    CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
-    Collection<? extends Certificate> certificates = certificateFactory.generateCertificates(in);
-    if (certificates.isEmpty()) {
-      throw new IllegalArgumentException("expected non-empty set of trusted certificates");
-    }
-
-    // Put the certificates a key store.
-    char[] password = "password".toCharArray(); // Any password will work.
-    KeyStore keyStore = newEmptyKeyStore(password);
-    int index = 0;
-    for (Certificate certificate : certificates) {
-      String certificateAlias = Integer.toString(index++);
-      keyStore.setCertificateEntry(certificateAlias, certificate);
-    }
-
-    // Use it to build an X509 trust manager.
-    KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(
-        KeyManagerFactory.getDefaultAlgorithm());
-    keyManagerFactory.init(keyStore, password);
-    TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
-        TrustManagerFactory.getDefaultAlgorithm());
-    trustManagerFactory.init(keyStore);
-    TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
-    if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
-      throw new IllegalStateException("Unexpected default trust managers:"
-          + Arrays.toString(trustManagers));
-    }
-    return (X509TrustManager) trustManagers[0];
-  }
-
-  private KeyStore newEmptyKeyStore(char[] password) throws GeneralSecurityException {
-    try {
-      KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
-      InputStream in = null; // By convention, 'null' creates an empty key store.
-      keyStore.load(in, password);
-      return keyStore;
-    } catch (IOException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  public static void main(String... args) throws Exception {
-    new CustomTrust().run();
-  }
-}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/HttpsServer.java b/samples/guide/src/main/java/okhttp3/recipes/HttpsServer.java
deleted file mode 100644
index dd537f52b2..0000000000
--- a/samples/guide/src/main/java/okhttp3/recipes/HttpsServer.java
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.recipes;
-
-import java.net.InetAddress;
-import okhttp3.Call;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.tls.HandshakeCertificates;
-import okhttp3.tls.HeldCertificate;
-
-/**
- * Create an HTTPS server with a self-signed certificate that OkHttp trusts.
- */
-public class HttpsServer {
-  public void run() throws Exception {
-    String localhost = InetAddress.getByName("localhost").getCanonicalHostName();
-    HeldCertificate localhostCertificate = new HeldCertificate.Builder()
-        .addSubjectAlternativeName(localhost)
-        .build();
-
-    HandshakeCertificates serverCertificates = new HandshakeCertificates.Builder()
-        .heldCertificate(localhostCertificate)
-        .build();
-    MockWebServer server = new MockWebServer();
-    server.useHttps(serverCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse());
-
-    HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder()
-        .addTrustedCertificate(localhostCertificate.certificate())
-        .build();
-    OkHttpClient client = new OkHttpClient.Builder()
-        .sslSocketFactory(clientCertificates.sslSocketFactory(), clientCertificates.trustManager())
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    System.out.println(response.handshake().tlsVersion());
-  }
-
-  public static void main(String... args) throws Exception {
-    new HttpsServer().run();
-  }
-}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/LoggingInterceptors.java b/samples/guide/src/main/java/okhttp3/recipes/LoggingInterceptors.java
deleted file mode 100644
index 8cb72b4bc8..0000000000
--- a/samples/guide/src/main/java/okhttp3/recipes/LoggingInterceptors.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.recipes;
-
-import java.io.IOException;
-import java.util.logging.Logger;
-import okhttp3.Interceptor;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-
-public final class LoggingInterceptors {
-  private static final Logger logger = Logger.getLogger(LoggingInterceptors.class.getName());
-  private final OkHttpClient client = new OkHttpClient.Builder()
-      .addInterceptor(new LoggingInterceptor())
-      .build();
-
-  public void run() throws Exception {
-    Request request = new Request.Builder()
-        .url("https://publicobject.com/helloworld.txt")
-        .build();
-
-    Response response = client.newCall(request).execute();
-    response.body().close();
-  }
-
-  private static class LoggingInterceptor implements Interceptor {
-    @Override public Response intercept(Chain chain) throws IOException {
-      long t1 = System.nanoTime();
-      Request request = chain.request();
-      logger.info(String.format("Sending request %s on %s%n%s",
-          request.url(), chain.connection(), request.headers()));
-      Response response = chain.proceed(request);
-
-      long t2 = System.nanoTime();
-      logger.info(String.format("Received response for %s in %.1fms%n%s",
-          request.url(), (t2 - t1) / 1e6d, response.headers()));
-      return response;
-    }
-  }
-
-  public static void main(String... args) throws Exception {
-    new LoggingInterceptors().run();
-  }
-}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/ParseResponseWithMoshi.java b/samples/guide/src/main/java/okhttp3/recipes/ParseResponseWithMoshi.java
deleted file mode 100644
index 68570bf13f..0000000000
--- a/samples/guide/src/main/java/okhttp3/recipes/ParseResponseWithMoshi.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.recipes;
-
-import com.squareup.moshi.JsonAdapter;
-import com.squareup.moshi.Moshi;
-import java.io.IOException;
-import java.util.Map;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-
-public final class ParseResponseWithMoshi {
-  private final OkHttpClient client = new OkHttpClient();
-  private final Moshi moshi = new Moshi.Builder().build();
-  private final JsonAdapter<Gist> gistJsonAdapter = moshi.adapter(Gist.class);
-
-  public void run() throws Exception {
-    Request request = new Request.Builder()
-        .url("https://api.github.com/gists/c2a7c39532239ff261be")
-        .build();
-    try (Response response = client.newCall(request).execute()) {
-      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-      Gist gist = gistJsonAdapter.fromJson(response.body().source());
-
-      for (Map.Entry<String, GistFile> entry : gist.files.entrySet()) {
-        System.out.println(entry.getKey());
-        System.out.println(entry.getValue().content);
-      }
-    }
-  }
-
-  static class Gist {
-    Map<String, GistFile> files;
-  }
-
-  static class GistFile {
-    String content;
-  }
-
-  public static void main(String... args) throws Exception {
-    new ParseResponseWithMoshi().run();
-  }
-}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PerCallSettings.java b/samples/guide/src/main/java/okhttp3/recipes/PerCallSettings.java
deleted file mode 100644
index 6aa266c11d..0000000000
--- a/samples/guide/src/main/java/okhttp3/recipes/PerCallSettings.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.recipes;
-
-import java.io.IOException;
-import java.util.concurrent.TimeUnit;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-
-public final class PerCallSettings {
-  private final OkHttpClient client = new OkHttpClient();
-
-  public void run() throws Exception {
-    Request request = new Request.Builder()
-        .url("http://httpbin.org/delay/1") // This URL is served with a 1 second delay.
-        .build();
-
-    // Copy to customize OkHttp for this request.
-    OkHttpClient client1 = client.newBuilder()
-        .readTimeout(500, TimeUnit.MILLISECONDS)
-        .build();
-    try (Response response = client1.newCall(request).execute()) {
-      System.out.println("Response 1 succeeded: " + response);
-    } catch (IOException e) {
-      System.out.println("Response 1 failed: " + e);
-    }
-
-    // Copy to customize OkHttp for this request.
-    OkHttpClient client2 = client.newBuilder()
-        .readTimeout(3000, TimeUnit.MILLISECONDS)
-        .build();
-    try (Response response = client2.newCall(request).execute()) {
-      System.out.println("Response 2 succeeded: " + response);
-    } catch (IOException e) {
-      System.out.println("Response 2 failed: " + e);
-    }
-  }
-
-  public static void main(String... args) throws Exception {
-    new PerCallSettings().run();
-  }
-}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostFile.java b/samples/guide/src/main/java/okhttp3/recipes/PostFile.java
deleted file mode 100644
index 0e52cddd26..0000000000
--- a/samples/guide/src/main/java/okhttp3/recipes/PostFile.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.recipes;
-
-import java.io.File;
-import java.io.IOException;
-import okhttp3.MediaType;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-
-public final class PostFile {
-  public static final MediaType MEDIA_TYPE_MARKDOWN
-      = MediaType.get("text/x-markdown; charset=utf-8");
-
-  private final OkHttpClient client = new OkHttpClient();
-
-  public void run() throws Exception {
-    File file = new File("README.md");
-
-    Request request = new Request.Builder()
-        .url("https://api.github.com/markdown/raw")
-        .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file))
-        .build();
-
-    try (Response response = client.newCall(request).execute()) {
-      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-      System.out.println(response.body().string());
-    }
-  }
-
-  public static void main(String... args) throws Exception {
-    new PostFile().run();
-  }
-}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostForm.java b/samples/guide/src/main/java/okhttp3/recipes/PostForm.java
deleted file mode 100644
index eab32b01ab..0000000000
--- a/samples/guide/src/main/java/okhttp3/recipes/PostForm.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.recipes;
-
-import java.io.IOException;
-import okhttp3.FormBody;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-
-public final class PostForm {
-  private final OkHttpClient client = new OkHttpClient();
-
-  public void run() throws Exception {
-    RequestBody formBody = new FormBody.Builder()
-        .add("search", "Jurassic Park")
-        .build();
-    Request request = new Request.Builder()
-        .url("https://en.wikipedia.org/w/index.php")
-        .post(formBody)
-        .build();
-
-    try (Response response = client.newCall(request).execute()) {
-      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-      System.out.println(response.body().string());
-    }
-  }
-
-  public static void main(String... args) throws Exception {
-    new PostForm().run();
-  }
-}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java b/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java
deleted file mode 100644
index 60534d7de2..0000000000
--- a/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.recipes;
-
-import java.io.File;
-import java.io.IOException;
-import okhttp3.MediaType;
-import okhttp3.MultipartBody;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-
-public final class PostMultipart {
-  /**
-   * The imgur client ID for OkHttp recipes. If you're using imgur for anything other than running
-   * these examples, please request your own client ID! https://api.imgur.com/oauth2
-   */
-  private static final String IMGUR_CLIENT_ID = "9199fdef135c122";
-  private static final MediaType MEDIA_TYPE_PNG = MediaType.get("image/png");
-
-  private final OkHttpClient client = new OkHttpClient();
-
-  public void run() throws Exception {
-    // Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image
-    RequestBody requestBody = new MultipartBody.Builder()
-        .setType(MultipartBody.FORM)
-        .addFormDataPart("title", "Square Logo")
-        .addFormDataPart("image", "logo-square.png",
-            RequestBody.create(MEDIA_TYPE_PNG, new File("website/static/logo-square.png")))
-        .build();
-
-    Request request = new Request.Builder()
-        .header("Authorization", "Client-ID " + IMGUR_CLIENT_ID)
-        .url("https://api.imgur.com/3/image")
-        .post(requestBody)
-        .build();
-
-    try (Response response = client.newCall(request).execute()) {
-      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-      System.out.println(response.body().string());
-    }
-  }
-
-  public static void main(String... args) throws Exception {
-    new PostMultipart().run();
-  }
-}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java b/samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java
deleted file mode 100644
index 90ec01c6b8..0000000000
--- a/samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.recipes;
-
-import java.io.IOException;
-import okhttp3.MediaType;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okio.BufferedSink;
-
-public final class PostStreaming {
-  public static final MediaType MEDIA_TYPE_MARKDOWN
-      = MediaType.get("text/x-markdown; charset=utf-8");
-
-  private final OkHttpClient client = new OkHttpClient();
-
-  public void run() throws Exception {
-    RequestBody requestBody = new RequestBody() {
-      @Override public MediaType contentType() {
-        return MEDIA_TYPE_MARKDOWN;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        sink.writeUtf8("Numbers\n");
-        sink.writeUtf8("-------\n");
-        for (int i = 2; i <= 997; i++) {
-          sink.writeUtf8(String.format(" * %s = %s\n", i, factor(i)));
-        }
-      }
-
-      private String factor(int n) {
-        for (int i = 2; i < n; i++) {
-          int x = n / i;
-          if (x * i == n) return factor(x) + " √ó " + i;
-        }
-        return Integer.toString(n);
-      }
-    };
-
-    Request request = new Request.Builder()
-        .url("https://api.github.com/markdown/raw")
-        .post(requestBody)
-        .build();
-
-    try (Response response = client.newCall(request).execute()) {
-      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-      System.out.println(response.body().string());
-    }
-  }
-
-  public static void main(String... args) throws Exception {
-    new PostStreaming().run();
-  }
-}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostStreamingWithPipe.java b/samples/guide/src/main/java/okhttp3/recipes/PostStreamingWithPipe.java
deleted file mode 100644
index c73b9154ed..0000000000
--- a/samples/guide/src/main/java/okhttp3/recipes/PostStreamingWithPipe.java
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- * Copyright (C) 2017 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.recipes;
-
-import java.io.IOException;
-import okhttp3.MediaType;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okio.BufferedSink;
-import okio.Okio;
-import okio.Pipe;
-
-public final class PostStreamingWithPipe {
-  public static final MediaType MEDIA_TYPE_MARKDOWN
-      = MediaType.get("text/x-markdown; charset=utf-8");
-
-  private final OkHttpClient client = new OkHttpClient();
-
-  public void run() throws Exception {
-    final PipeBody pipeBody = new PipeBody();
-
-    Request request = new Request.Builder()
-        .url("https://api.github.com/markdown/raw")
-        .post(pipeBody)
-        .build();
-
-    streamPrimesToSinkAsynchronously(pipeBody.sink());
-
-    try (Response response = client.newCall(request).execute()) {
-      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-      System.out.println(response.body().string());
-    }
-  }
-
-  private void streamPrimesToSinkAsynchronously(final BufferedSink sink) {
-    Thread thread = new Thread("writer") {
-      @Override public void run() {
-        try {
-          sink.writeUtf8("Numbers\n");
-          sink.writeUtf8("-------\n");
-          for (int i = 2; i <= 997; i++) {
-            System.out.println(i);
-            Thread.sleep(10);
-            sink.writeUtf8(String.format(" * %s = %s\n", i, factor(i)));
-          }
-          sink.close();
-        } catch (IOException | InterruptedException e) {
-          e.printStackTrace();
-        }
-      }
-
-      private String factor(int n) {
-        for (int i = 2; i < n; i++) {
-          int x = n / i;
-          if (x * i == n) return factor(x) + " √ó " + i;
-        }
-        return Integer.toString(n);
-      }
-    };
-
-    thread.start();
-  }
-
-  /**
-   * This request body makes it possible for another thread to stream data to the uploading request.
-   * This is potentially useful for posting live event streams like video capture. Callers should
-   * write to {@code sink()} and close it to complete the post.
-   */
-  static final class PipeBody extends RequestBody {
-    private final Pipe pipe = new Pipe(8192);
-    private final BufferedSink sink = Okio.buffer(pipe.sink());
-
-    public BufferedSink sink() {
-      return sink;
-    }
-
-    @Override public MediaType contentType() {
-      return MEDIA_TYPE_MARKDOWN;
-    }
-
-    @Override public void writeTo(BufferedSink sink) throws IOException {
-      sink.writeAll(pipe.source());
-    }
-  }
-
-  public static void main(String... args) throws Exception {
-    new PostStreamingWithPipe().run();
-  }
-}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostString.java b/samples/guide/src/main/java/okhttp3/recipes/PostString.java
deleted file mode 100644
index 6c8ea4f9e3..0000000000
--- a/samples/guide/src/main/java/okhttp3/recipes/PostString.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.recipes;
-
-import java.io.IOException;
-import okhttp3.MediaType;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-
-public final class PostString {
-  public static final MediaType MEDIA_TYPE_MARKDOWN
-      = MediaType.get("text/x-markdown; charset=utf-8");
-
-  private final OkHttpClient client = new OkHttpClient();
-
-  public void run() throws Exception {
-    String postBody = ""
-        + "Releases\n"
-        + "--------\n"
-        + "\n"
-        + " * _1.0_ May 6, 2013\n"
-        + " * _1.1_ June 15, 2013\n"
-        + " * _1.2_ August 11, 2013\n";
-
-    Request request = new Request.Builder()
-        .url("https://api.github.com/markdown/raw")
-        .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody))
-        .build();
-
-    try (Response response = client.newCall(request).execute()) {
-      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-      System.out.println(response.body().string());
-    }
-  }
-
-  public static void main(String... args) throws Exception {
-    new PostString().run();
-  }
-}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PreemptiveAuth.java b/samples/guide/src/main/java/okhttp3/recipes/PreemptiveAuth.java
deleted file mode 100644
index abbf0eb0c0..0000000000
--- a/samples/guide/src/main/java/okhttp3/recipes/PreemptiveAuth.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.recipes;
-
-import java.io.IOException;
-import okhttp3.Credentials;
-import okhttp3.Interceptor;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-
-public final class PreemptiveAuth {
-  private final OkHttpClient client;
-
-  public PreemptiveAuth() {
-    client = new OkHttpClient.Builder()
-        .addInterceptor(
-            new BasicAuthInterceptor("publicobject.com", "jesse", "password1"))
-        .build();
-  }
-
-  public void run() throws Exception {
-    Request request = new Request.Builder()
-        .url("https://publicobject.com/secrets/hellosecret.txt")
-        .build();
-
-    try (Response response = client.newCall(request).execute()) {
-      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-      System.out.println(response.body().string());
-    }
-  }
-
-  public static void main(String... args) throws Exception {
-    new PreemptiveAuth().run();
-  }
-
-  static final class BasicAuthInterceptor implements Interceptor {
-    private final String credentials;
-    private final String host;
-
-    BasicAuthInterceptor(String host, String username, String password) {
-      this.credentials = Credentials.basic(username, password);
-      this.host = host;
-    }
-
-    @Override public Response intercept(Chain chain) throws IOException {
-      Request request = chain.request();
-      if (request.url().host().equals(host)) {
-        request = request.newBuilder()
-            .header("Authorization", credentials)
-            .build();
-      }
-      return chain.proceed(request);
-    }
-  }
-}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PrintEvents.java b/samples/guide/src/main/java/okhttp3/recipes/PrintEvents.java
deleted file mode 100644
index 6c9f71279f..0000000000
--- a/samples/guide/src/main/java/okhttp3/recipes/PrintEvents.java
+++ /dev/null
@@ -1,191 +0,0 @@
-/*
- * Copyright (C) 2017 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.recipes;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import java.util.List;
-import java.util.concurrent.atomic.AtomicLong;
-import okhttp3.Call;
-import okhttp3.Callback;
-import okhttp3.Connection;
-import okhttp3.EventListener;
-import okhttp3.Handshake;
-import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-
-public final class PrintEvents {
-  private final OkHttpClient client = new OkHttpClient.Builder()
-      .eventListenerFactory(PrintingEventListener.FACTORY)
-      .build();
-
-  public void run() throws Exception {
-    Request washingtonPostRequest = new Request.Builder()
-        .url("https://www.washingtonpost.com/")
-        .build();
-    client.newCall(washingtonPostRequest).enqueue(new Callback() {
-      @Override public void onFailure(Call call, IOException e) {
-      }
-
-      @Override public void onResponse(Call call, Response response) throws IOException {
-        try (ResponseBody body = response.body()) {
-          // Consume and discard the response body.
-          body.source().readByteString();
-        }
-      }
-    });
-
-    Request newYorkTimesRequest = new Request.Builder()
-        .url("https://www.nytimes.com/")
-        .build();
-    client.newCall(newYorkTimesRequest).enqueue(new Callback() {
-      @Override public void onFailure(Call call, IOException e) {
-      }
-
-      @Override public void onResponse(Call call, Response response) throws IOException {
-        try (ResponseBody body = response.body()) {
-          // Consume and discard the response body.
-          body.source().readByteString();
-        }
-      }
-    });
-  }
-
-  public static void main(String... args) throws Exception {
-    new PrintEvents().run();
-  }
-
-  private static final class PrintingEventListener extends EventListener {
-    private static final Factory FACTORY = new Factory() {
-      final AtomicLong nextCallId = new AtomicLong(1L);
-
-      @Override public EventListener create(Call call) {
-        long callId = nextCallId.getAndIncrement();
-        System.out.printf("%04d %s%n", callId, call.request().url());
-        return new PrintingEventListener(callId, System.nanoTime());
-      }
-    };
-
-    final long callId;
-    final long callStartNanos;
-
-    PrintingEventListener(long callId, long callStartNanos) {
-      this.callId = callId;
-      this.callStartNanos = callStartNanos;
-    }
-
-    private void printEvent(String name) {
-      long elapsedNanos = System.nanoTime() - callStartNanos;
-      System.out.printf("%04d %.3f %s%n", callId, elapsedNanos / 1000000000d, name);
-    }
-
-    @Override public void callStart(Call call) {
-      printEvent("callStart");
-    }
-
-    @Override public void dnsStart(Call call, String domainName) {
-      printEvent("dnsStart");
-    }
-
-    @Override public void dnsEnd(Call call, String domainName, List<InetAddress> inetAddressList) {
-      printEvent("dnsEnd");
-    }
-
-    @Override public void connectStart(
-        Call call, InetSocketAddress inetSocketAddress, Proxy proxy) {
-      printEvent("connectStart");
-    }
-
-    @Override public void secureConnectStart(Call call) {
-      printEvent("secureConnectStart");
-    }
-
-    @Override public void secureConnectEnd(Call call, Handshake handshake) {
-      printEvent("secureConnectEnd");
-    }
-
-    @Override public void connectEnd(
-        Call call, InetSocketAddress inetSocketAddress, Proxy proxy, Protocol protocol) {
-      printEvent("connectEnd");
-    }
-
-    @Override public void connectFailed(Call call, InetSocketAddress inetSocketAddress, Proxy proxy,
-        Protocol protocol, IOException ioe) {
-      printEvent("connectFailed");
-    }
-
-    @Override public void connectionAcquired(Call call, Connection connection) {
-      printEvent("connectionAcquired");
-    }
-
-    @Override public void connectionReleased(Call call, Connection connection) {
-      printEvent("connectionReleased");
-    }
-
-    @Override public void requestHeadersStart(Call call) {
-      printEvent("requestHeadersStart");
-    }
-
-    @Override public void requestHeadersEnd(Call call, Request request) {
-      printEvent("requestHeadersEnd");
-    }
-
-    @Override public void requestBodyStart(Call call) {
-      printEvent("requestBodyStart");
-    }
-
-    @Override public void requestBodyEnd(Call call, long byteCount) {
-      printEvent("requestBodyEnd");
-    }
-
-    @Override public void requestFailed(Call call, IOException ioe) {
-      printEvent("requestFailed");
-    }
-
-    @Override public void responseHeadersStart(Call call) {
-      printEvent("responseHeadersStart");
-    }
-
-    @Override public void responseHeadersEnd(Call call, Response response) {
-      printEvent("responseHeadersEnd");
-    }
-
-    @Override public void responseBodyStart(Call call) {
-      printEvent("responseBodyStart");
-    }
-
-    @Override public void responseBodyEnd(Call call, long byteCount) {
-      printEvent("responseBodyEnd");
-    }
-
-    @Override public void responseFailed(Call call, IOException ioe) {
-      printEvent("responseFailed");
-    }
-
-    @Override public void callEnd(Call call) {
-      printEvent("callEnd");
-    }
-
-    @Override public void callFailed(Call call, IOException ioe) {
-      printEvent("callFailed");
-    }
-  }
-}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PrintEventsNonConcurrent.java b/samples/guide/src/main/java/okhttp3/recipes/PrintEventsNonConcurrent.java
deleted file mode 100644
index c88895b794..0000000000
--- a/samples/guide/src/main/java/okhttp3/recipes/PrintEventsNonConcurrent.java
+++ /dev/null
@@ -1,166 +0,0 @@
-/*
- * Copyright (C) 2017 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.recipes;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import java.util.List;
-import okhttp3.Call;
-import okhttp3.Connection;
-import okhttp3.EventListener;
-import okhttp3.Handshake;
-import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.Response;
-
-/**
- * This prints events for a single in-flight call. It won't work for multiple concurrent calls
- * because we don't know what callStartNanos refers to.
- */
-public final class PrintEventsNonConcurrent {
-  private final OkHttpClient client = new OkHttpClient.Builder()
-      .eventListener(new PrintingEventListener())
-      .build();
-
-  public void run() throws Exception {
-    Request request = new Request.Builder()
-        .url("https://publicobject.com/helloworld.txt")
-        .build();
-
-    System.out.println("REQUEST 1 (new connection)");
-    try (Response response = client.newCall(request).execute()) {
-      // Consume and discard the response body.
-      response.body().source().readByteString();
-    }
-
-    System.out.println("REQUEST 2 (pooled connection)");
-    try (Response response = client.newCall(request).execute()) {
-      // Consume and discard the response body.
-      response.body().source().readByteString();
-    }
-  }
-
-  public static void main(String... args) throws Exception {
-    new PrintEventsNonConcurrent().run();
-  }
-
-  private static final class PrintingEventListener extends EventListener {
-    long callStartNanos;
-
-    private void printEvent(String name) {
-      long nowNanos = System.nanoTime();
-      if (name.equals("callStart")) {
-        callStartNanos = nowNanos;
-      }
-      long elapsedNanos = nowNanos - callStartNanos;
-      System.out.printf("%.3f %s%n", elapsedNanos / 1000000000d, name);
-    }
-
-    @Override public void callStart(Call call) {
-      printEvent("callStart");
-    }
-
-    @Override public void dnsStart(Call call, String domainName) {
-      printEvent("dnsStart");
-    }
-
-    @Override public void dnsEnd(Call call, String domainName, List<InetAddress> inetAddressList) {
-      printEvent("dnsEnd");
-    }
-
-    @Override public void connectStart(
-        Call call, InetSocketAddress inetSocketAddress, Proxy proxy) {
-      printEvent("connectStart");
-    }
-
-    @Override public void secureConnectStart(Call call) {
-      printEvent("secureConnectStart");
-    }
-
-    @Override public void secureConnectEnd(Call call, Handshake handshake) {
-      printEvent("secureConnectEnd");
-    }
-
-    @Override public void connectEnd(
-        Call call, InetSocketAddress inetSocketAddress, Proxy proxy, Protocol protocol) {
-      printEvent("connectEnd");
-    }
-
-    @Override public void connectFailed(Call call, InetSocketAddress inetSocketAddress, Proxy proxy,
-        Protocol protocol, IOException ioe) {
-      printEvent("connectFailed");
-    }
-
-    @Override public void connectionAcquired(Call call, Connection connection) {
-      printEvent("connectionAcquired");
-    }
-
-    @Override public void connectionReleased(Call call, Connection connection) {
-      printEvent("connectionReleased");
-    }
-
-    @Override public void requestHeadersStart(Call call) {
-      printEvent("requestHeadersStart");
-    }
-
-    @Override public void requestHeadersEnd(Call call, Request request) {
-      printEvent("requestHeadersEnd");
-    }
-
-    @Override public void requestBodyStart(Call call) {
-      printEvent("requestBodyStart");
-    }
-
-    @Override public void requestBodyEnd(Call call, long byteCount) {
-      printEvent("requestBodyEnd");
-    }
-
-    @Override public void requestFailed(Call call, IOException ioe) {
-      printEvent("requestFailed");
-    }
-
-    @Override public void responseHeadersStart(Call call) {
-      printEvent("responseHeadersStart");
-    }
-
-    @Override public void responseHeadersEnd(Call call, Response response) {
-      printEvent("responseHeadersEnd");
-    }
-
-    @Override public void responseBodyStart(Call call) {
-      printEvent("responseBodyStart");
-    }
-
-    @Override public void responseBodyEnd(Call call, long byteCount) {
-      printEvent("responseBodyEnd");
-    }
-
-    @Override public void responseFailed(Call call, IOException ioe) {
-      printEvent("responseFailed");
-    }
-
-    @Override public void callEnd(Call call) {
-      printEvent("callEnd");
-    }
-
-    @Override public void callFailed(Call call, IOException ioe) {
-      printEvent("callFailed");
-    }
-  }
-}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/Progress.java b/samples/guide/src/main/java/okhttp3/recipes/Progress.java
deleted file mode 100644
index 197401f205..0000000000
--- a/samples/guide/src/main/java/okhttp3/recipes/Progress.java
+++ /dev/null
@@ -1,126 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.recipes;
-
-import java.io.IOException;
-import okhttp3.MediaType;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okio.Buffer;
-import okio.BufferedSource;
-import okio.ForwardingSource;
-import okio.Okio;
-import okio.Source;
-
-public final class Progress {
-
-  public void run() throws Exception {
-    Request request = new Request.Builder()
-        .url("https://publicobject.com/helloworld.txt")
-        .build();
-
-    final ProgressListener progressListener = new ProgressListener() {
-      boolean firstUpdate = true;
-
-      @Override public void update(long bytesRead, long contentLength, boolean done) {
-        if (done) {
-          System.out.println("completed");
-        } else {
-          if (firstUpdate) {
-            firstUpdate = false;
-            if (contentLength == -1) {
-              System.out.println("content-length: unknown");
-            } else {
-              System.out.format("content-length: %d\n", contentLength);
-            }
-          }
-
-          System.out.println(bytesRead);
-
-          if (contentLength != -1) {
-            System.out.format("%d%% done\n", (100 * bytesRead) / contentLength);
-          }
-        }
-      }
-    };
-
-    OkHttpClient client = new OkHttpClient.Builder()
-        .addNetworkInterceptor(chain -> {
-          Response originalResponse = chain.proceed(chain.request());
-          return originalResponse.newBuilder()
-              .body(new ProgressResponseBody(originalResponse.body(), progressListener))
-              .build();
-        })
-        .build();
-
-    try (Response response = client.newCall(request).execute()) {
-      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-      System.out.println(response.body().string());
-    }
-  }
-
-  public static void main(String... args) throws Exception {
-    new Progress().run();
-  }
-
-  private static class ProgressResponseBody extends ResponseBody {
-
-    private final ResponseBody responseBody;
-    private final ProgressListener progressListener;
-    private BufferedSource bufferedSource;
-
-    ProgressResponseBody(ResponseBody responseBody, ProgressListener progressListener) {
-      this.responseBody = responseBody;
-      this.progressListener = progressListener;
-    }
-
-    @Override public MediaType contentType() {
-      return responseBody.contentType();
-    }
-
-    @Override public long contentLength() {
-      return responseBody.contentLength();
-    }
-
-    @Override public BufferedSource source() {
-      if (bufferedSource == null) {
-        bufferedSource = Okio.buffer(source(responseBody.source()));
-      }
-      return bufferedSource;
-    }
-
-    private Source source(Source source) {
-      return new ForwardingSource(source) {
-        long totalBytesRead = 0L;
-
-        @Override public long read(Buffer sink, long byteCount) throws IOException {
-          long bytesRead = super.read(sink, byteCount);
-          // read() returns the number of bytes read, or -1 if this source is exhausted.
-          totalBytesRead += bytesRead != -1 ? bytesRead : 0;
-          progressListener.update(totalBytesRead, responseBody.contentLength(), bytesRead == -1);
-          return bytesRead;
-        }
-      };
-    }
-  }
-
-  interface ProgressListener {
-    void update(long bytesRead, long contentLength, boolean done);
-  }
-}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/RequestBodyCompression.java b/samples/guide/src/main/java/okhttp3/recipes/RequestBodyCompression.java
deleted file mode 100644
index 5473f67011..0000000000
--- a/samples/guide/src/main/java/okhttp3/recipes/RequestBodyCompression.java
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.recipes;
-
-import com.squareup.moshi.JsonAdapter;
-import com.squareup.moshi.Moshi;
-import com.squareup.moshi.Types;
-import java.io.IOException;
-import java.util.LinkedHashMap;
-import java.util.Map;
-import okhttp3.Interceptor;
-import okhttp3.MediaType;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okio.BufferedSink;
-import okio.GzipSink;
-import okio.Okio;
-
-public final class RequestBodyCompression {
-  /**
-   * The Google API KEY for OkHttp recipes. If you're using Google APIs for anything other than
-   * running these examples, please request your own client ID!
-   *
-   * https://console.developers.google.com/project
-   */
-  public static final String GOOGLE_API_KEY = "AIzaSyAx2WZYe0My0i-uGurpvraYJxO7XNbwiGs";
-  public static final MediaType MEDIA_TYPE_JSON = MediaType.get("application/json");
-
-  private final OkHttpClient client = new OkHttpClient.Builder()
-      .addInterceptor(new GzipRequestInterceptor())
-      .build();
-  private final Moshi moshi = new Moshi.Builder().build();
-  private final JsonAdapter<Map<String, String>> mapJsonAdapter = moshi.adapter(
-      Types.newParameterizedType(Map.class, String.class, String.class));
-
-  public void run() throws Exception {
-    Map<String, String> requestBody = new LinkedHashMap<>();
-    requestBody.put("longUrl", "https://publicobject.com/2014/12/04/html-formatting-javadocs/");
-    RequestBody jsonRequestBody = RequestBody.create(
-        MEDIA_TYPE_JSON, mapJsonAdapter.toJson(requestBody));
-    Request request = new Request.Builder()
-        .url("https://www.googleapis.com/urlshortener/v1/url?key=" + GOOGLE_API_KEY)
-        .post(jsonRequestBody)
-        .build();
-
-    try (Response response = client.newCall(request).execute()) {
-      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-      System.out.println(response.body().string());
-    }
-  }
-
-  public static void main(String... args) throws Exception {
-    new RequestBodyCompression().run();
-  }
-
-  /** This interceptor compresses the HTTP request body. Many webservers can't handle this! */
-  static class GzipRequestInterceptor implements Interceptor {
-    @Override public Response intercept(Chain chain) throws IOException {
-      Request originalRequest = chain.request();
-      if (originalRequest.body() == null || originalRequest.header("Content-Encoding") != null) {
-        return chain.proceed(originalRequest);
-      }
-
-      Request compressedRequest = originalRequest.newBuilder()
-          .header("Content-Encoding", "gzip")
-          .method(originalRequest.method(), gzip(originalRequest.body()))
-          .build();
-      return chain.proceed(compressedRequest);
-    }
-
-    private RequestBody gzip(final RequestBody body) {
-      return new RequestBody() {
-        @Override public MediaType contentType() {
-          return body.contentType();
-        }
-
-        @Override public long contentLength() {
-          return -1; // We don't know the compressed length in advance!
-        }
-
-        @Override public void writeTo(BufferedSink sink) throws IOException {
-          BufferedSink gzipSink = Okio.buffer(new GzipSink(sink));
-          body.writeTo(gzipSink);
-          gzipSink.close();
-        }
-      };
-    }
-  }
-}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/RewriteResponseCacheControl.java b/samples/guide/src/main/java/okhttp3/recipes/RewriteResponseCacheControl.java
deleted file mode 100644
index 4d876bb201..0000000000
--- a/samples/guide/src/main/java/okhttp3/recipes/RewriteResponseCacheControl.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.recipes;
-
-import java.io.File;
-import java.io.IOException;
-import okhttp3.Cache;
-import okhttp3.Interceptor;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-
-public final class RewriteResponseCacheControl {
-  /** Dangerous interceptor that rewrites the server's cache-control header. */
-  private static final Interceptor REWRITE_CACHE_CONTROL_INTERCEPTOR = chain -> {
-    Response originalResponse = chain.proceed(chain.request());
-    return originalResponse.newBuilder()
-        .header("Cache-Control", "max-age=60")
-        .build();
-  };
-
-  private final OkHttpClient client;
-
-  public RewriteResponseCacheControl(File cacheDirectory) throws Exception {
-    Cache cache = new Cache(cacheDirectory, 1024 * 1024);
-    cache.evictAll();
-
-    client = new OkHttpClient.Builder()
-        .cache(cache)
-        .build();
-  }
-
-  public void run() throws Exception {
-    for (int i = 0; i < 5; i++) {
-      System.out.println("    Request: " + i);
-
-      Request request = new Request.Builder()
-          .url("https://api.github.com/search/repositories?q=http")
-          .build();
-
-      OkHttpClient clientForCall;
-      if (i == 2) {
-        // Force this request's response to be written to the cache. This way, subsequent responses
-        // can be read from the cache.
-        System.out.println("Force cache: true");
-        clientForCall = client.newBuilder()
-            .addNetworkInterceptor(REWRITE_CACHE_CONTROL_INTERCEPTOR)
-            .build();
-      } else {
-        System.out.println("Force cache: false");
-        clientForCall = client;
-      }
-
-      try (Response response = clientForCall.newCall(request).execute()) {
-        if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-        System.out.println("    Network: " + (response.networkResponse() != null));
-        System.out.println();
-      }
-    }
-  }
-
-  public static void main(String... args) throws Exception {
-    new RewriteResponseCacheControl(new File("RewriteResponseCacheControl.tmp")).run();
-  }
-}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/SynchronousGet.java b/samples/guide/src/main/java/okhttp3/recipes/SynchronousGet.java
deleted file mode 100644
index 38c91a50c2..0000000000
--- a/samples/guide/src/main/java/okhttp3/recipes/SynchronousGet.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.recipes;
-
-import java.io.IOException;
-import okhttp3.Headers;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-
-public final class SynchronousGet {
-  private final OkHttpClient client = new OkHttpClient();
-
-  public void run() throws Exception {
-    Request request = new Request.Builder()
-        .url("https://publicobject.com/helloworld.txt")
-        .build();
-
-    try (Response response = client.newCall(request).execute()) {
-      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-      Headers responseHeaders = response.headers();
-      for (int i = 0; i < responseHeaders.size(); i++) {
-        System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i));
-      }
-
-      System.out.println(response.body().string());
-    }
-  }
-
-  public static void main(String... args) throws Exception {
-    new SynchronousGet().run();
-  }
-}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java b/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java
deleted file mode 100644
index 288fadb7ce..0000000000
--- a/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java
+++ /dev/null
@@ -1,53 +0,0 @@
-package okhttp3.recipes;
-
-import java.util.concurrent.TimeUnit;
-import okhttp3.WebSocket;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.WebSocketListener;
-import okio.ByteString;
-
-public final class WebSocketEcho extends WebSocketListener {
-  private void run() {
-    OkHttpClient client = new OkHttpClient.Builder()
-        .readTimeout(0,  TimeUnit.MILLISECONDS)
-        .build();
-
-    Request request = new Request.Builder()
-        .url("ws://echo.websocket.org")
-        .build();
-    client.newWebSocket(request, this);
-
-    // Trigger shutdown of the dispatcher's executor so this process can exit cleanly.
-    client.dispatcher().executorService().shutdown();
-  }
-
-  @Override public void onOpen(WebSocket webSocket, Response response) {
-    webSocket.send("Hello...");
-    webSocket.send("...World!");
-    webSocket.send(ByteString.decodeHex("deadbeef"));
-    webSocket.close(1000, "Goodbye, World!");
-  }
-
-  @Override public void onMessage(WebSocket webSocket, String text) {
-    System.out.println("MESSAGE: " + text);
-  }
-
-  @Override public void onMessage(WebSocket webSocket, ByteString bytes) {
-    System.out.println("MESSAGE: " + bytes.hex());
-  }
-
-  @Override public void onClosing(WebSocket webSocket, int code, String reason) {
-    webSocket.close(1000, null);
-    System.out.println("CLOSE: " + code + " " + reason);
-  }
-
-  @Override public void onFailure(WebSocket webSocket, Throwable t, Response response) {
-    t.printStackTrace();
-  }
-
-  public static void main(String... args) {
-    new WebSocketEcho().run();
-  }
-}
diff --git a/samples/pom.xml b/samples/pom.xml
deleted file mode 100644
index 16f7f1aa38..0000000000
--- a/samples/pom.xml
+++ /dev/null
@@ -1,40 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.14.3-SNAPSHOT</version>
-  </parent>
-
-  <groupId>com.squareup.okhttp3.sample</groupId>
-  <artifactId>sample-parent</artifactId>
-  <packaging>pom</packaging>
-  <name>Samples (Parent)</name>
-
-  <modules>
-    <module>guide</module>
-    <module>crawler</module>
-    <module>simple-client</module>
-    <module>slack</module>
-    <module>static-server</module>
-    <module>unixdomainsockets</module>
-  </modules>
-
-  <build>
-    <plugins>
-      <plugin>
-        <!-- Fails on Throwable.addSuppressed() in ARM blocks. -->
-        <groupId>org.codehaus.mojo</groupId>
-        <artifactId>animal-sniffer-maven-plugin</artifactId>
-        <executions>
-          <execution>
-            <phase>none</phase>
-          </execution>
-        </executions>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/samples/simple-client/pom.xml b/samples/simple-client/pom.xml
deleted file mode 100644
index e439e80409..0000000000
--- a/samples/simple-client/pom.xml
+++ /dev/null
@@ -1,27 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3.sample</groupId>
-    <artifactId>sample-parent</artifactId>
-    <version>3.14.3-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>simple-client</artifactId>
-  <name>Sample: Simple Client</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-
-    <dependency>
-      <groupId>com.squareup.moshi</groupId>
-      <artifactId>moshi</artifactId>
-    </dependency>
-  </dependencies>
-</project>
diff --git a/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java b/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java
deleted file mode 100644
index cfd8632cb8..0000000000
--- a/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java
+++ /dev/null
@@ -1,51 +0,0 @@
-package okhttp3.sample;
-
-import com.squareup.moshi.JsonAdapter;
-import com.squareup.moshi.Moshi;
-import com.squareup.moshi.Types;
-import java.util.Collections;
-import java.util.List;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-
-public class OkHttpContributors {
-  private static final String ENDPOINT = "https://api.github.com/repos/square/okhttp/contributors";
-  private static final Moshi MOSHI = new Moshi.Builder().build();
-  private static final JsonAdapter<List<Contributor>> CONTRIBUTORS_JSON_ADAPTER = MOSHI.adapter(
-      Types.newParameterizedType(List.class, Contributor.class));
-
-  static class Contributor {
-    String login;
-    int contributions;
-  }
-
-  public static void main(String... args) throws Exception {
-    OkHttpClient client = new OkHttpClient();
-
-    // Create request for remote resource.
-    Request request = new Request.Builder()
-        .url(ENDPOINT)
-        .build();
-
-    // Execute the request and retrieve the response.
-    try (Response response = client.newCall(request).execute()) {
-      // Deserialize HTTP response to concrete type.
-      ResponseBody body = response.body();
-      List<Contributor> contributors = CONTRIBUTORS_JSON_ADAPTER.fromJson(body.source());
-
-      // Sort list by the most contributions.
-      Collections.sort(contributors, (c1, c2) -> c2.contributions - c1.contributions);
-
-      // Output list of contributors.
-      for (Contributor contributor : contributors) {
-        System.out.println(contributor.login + ": " + contributor.contributions);
-      }
-    }
-  }
-
-  private OkHttpContributors() {
-    // No instances.
-  }
-}
diff --git a/samples/slack/pom.xml b/samples/slack/pom.xml
deleted file mode 100644
index 929754c802..0000000000
--- a/samples/slack/pom.xml
+++ /dev/null
@@ -1,26 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3.sample</groupId>
-    <artifactId>sample-parent</artifactId>
-    <version>3.14.3-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>slack</artifactId>
-  <name>Sample: Slack</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.moshi</groupId>
-      <artifactId>moshi</artifactId>
-    </dependency>
-  </dependencies>
-</project>
diff --git a/samples/slack/src/main/java/okhttp3/slack/OAuthSession.java b/samples/slack/src/main/java/okhttp3/slack/OAuthSession.java
deleted file mode 100644
index 9a6869d2fb..0000000000
--- a/samples/slack/src/main/java/okhttp3/slack/OAuthSession.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.slack;
-
-/** Authorization for an application to make Slack API calls on behalf of a user. */
-@SuppressWarnings("checkstyle:membername")
-public final class OAuthSession {
-  public final boolean ok;
-  public final String access_token;
-  public final String scope;
-  public final String user_id;
-  public final String team_name;
-  public final String team_id;
-
-  public OAuthSession(
-      boolean ok, String accessToken, String scope, String userId, String teamName, String teamId) {
-    this.ok = ok;
-    this.access_token = accessToken;
-    this.scope = scope;
-    this.user_id = userId;
-    this.team_name = teamName;
-    this.team_id = teamId;
-  }
-
-  @Override public String toString() {
-    return String.format("(ok=%s, access_token=%s, scope=%s, user_id=%s, team_name=%s, team_id=%s)",
-        ok, access_token, scope, user_id, team_name, team_id);
-  }
-}
diff --git a/samples/slack/src/main/java/okhttp3/slack/OAuthSessionFactory.java b/samples/slack/src/main/java/okhttp3/slack/OAuthSessionFactory.java
deleted file mode 100644
index c0ad139aed..0000000000
--- a/samples/slack/src/main/java/okhttp3/slack/OAuthSessionFactory.java
+++ /dev/null
@@ -1,126 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.slack;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.security.SecureRandom;
-import java.util.LinkedHashMap;
-import java.util.Map;
-import okhttp3.HttpUrl;
-import okhttp3.mockwebserver.Dispatcher;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
-import okio.ByteString;
-
-/**
- * Runs a MockWebServer on localhost and uses it as the backend to receive an OAuth session.
- *
- * <p>Clients should call {@link #start}, {@link #newAuthorizeUrl} and {@link #close} in that order.
- * Clients may request multiple sessions.
- */
-public final class OAuthSessionFactory extends Dispatcher implements Closeable {
-  private final SecureRandom secureRandom = new SecureRandom();
-
-  private final SlackApi slackApi;
-  private MockWebServer mockWebServer;
-
-  /** Guarded by this. */
-  private Map<ByteString, Listener> listeners = new LinkedHashMap<>();
-
-  public OAuthSessionFactory(SlackApi slackApi) {
-    this.slackApi = slackApi;
-  }
-
-  public void start() throws Exception {
-    if (mockWebServer != null) throw new IllegalStateException();
-
-    mockWebServer = new MockWebServer();
-    mockWebServer.setDispatcher(this);
-    mockWebServer.start(slackApi.port);
-  }
-
-  public HttpUrl newAuthorizeUrl(String scopes, String team, Listener listener) {
-    if (mockWebServer == null) throw new IllegalStateException();
-
-    ByteString state = randomToken();
-    synchronized (this) {
-      listeners.put(state, listener);
-    }
-
-    return slackApi.authorizeUrl(scopes, redirectUrl(), state, team);
-  }
-
-  private ByteString randomToken() {
-    byte[] bytes = new byte[16];
-    secureRandom.nextBytes(bytes);
-    return ByteString.of(bytes);
-  }
-
-  private HttpUrl redirectUrl() {
-    return mockWebServer.url("/oauth/");
-  }
-
-  /** When the browser hits the redirect URL, use the provided code to ask Slack for a session. */
-  @Override public MockResponse dispatch(RecordedRequest request) {
-    HttpUrl requestUrl = mockWebServer.url(request.getPath());
-    String code = requestUrl.queryParameter("code");
-    String stateString = requestUrl.queryParameter("state");
-    ByteString state = stateString != null ? ByteString.decodeBase64(stateString) : null;
-
-    Listener listener;
-    synchronized (this) {
-      listener = listeners.get(state);
-    }
-
-    if (code == null || listener == null) {
-      return new MockResponse()
-          .setResponseCode(404)
-          .setBody("unexpected request");
-    }
-
-    try {
-      OAuthSession session = slackApi.exchangeCode(code, redirectUrl());
-      listener.sessionGranted(session);
-    } catch (IOException e) {
-      return new MockResponse()
-          .setResponseCode(400)
-          .setBody("code exchange failed: " + e.getMessage());
-    }
-
-    synchronized (this) {
-      listeners.remove(state);
-    }
-
-    // Success!
-    return new MockResponse()
-        .setResponseCode(302)
-        .addHeader("Location", "https://twitter.com/CuteEmergency/status/789457462864863232");
-  }
-
-  public interface Listener {
-    void sessionGranted(OAuthSession session);
-  }
-
-  @Override public void close() {
-    if (mockWebServer == null) throw new IllegalStateException();
-    try {
-      mockWebServer.close();
-    } catch (IOException ignored) {
-    }
-  }
-}
diff --git a/samples/slack/src/main/java/okhttp3/slack/RtmSession.java b/samples/slack/src/main/java/okhttp3/slack/RtmSession.java
deleted file mode 100644
index b5802ef4ad..0000000000
--- a/samples/slack/src/main/java/okhttp3/slack/RtmSession.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.slack;
-
-import java.io.Closeable;
-import java.io.IOException;
-import okhttp3.WebSocket;
-import okhttp3.Response;
-import okhttp3.WebSocketListener;
-
-/** A realtime messaging session. */
-public final class RtmSession extends WebSocketListener implements Closeable {
-  private final SlackApi slackApi;
-
-  /** Guarded by this. */
-  private WebSocket webSocket;
-
-  public RtmSession(SlackApi slackApi) {
-    this.slackApi = slackApi;
-  }
-
-  public void open(String accessToken) throws IOException {
-    if (webSocket != null) throw new IllegalStateException();
-
-    RtmStartResponse rtmStartResponse = slackApi.rtmStart(accessToken);
-    webSocket = slackApi.rtm(rtmStartResponse.url, this);
-  }
-
-  // TODO(jwilson): can I read the response body? Do I have to?
-  //                the body from slack is a 0-byte-buffer
-  @Override public synchronized void onOpen(WebSocket webSocket, Response response) {
-    System.out.println("onOpen: " + response);
-  }
-
-  // TOOD(jwilson): decode incoming messages and dispatch them somewhere.
-  @Override public void onMessage(WebSocket webSocket, String text) {
-    System.out.println("onMessage: " + text);
-  }
-
-  @Override public void onClosing(WebSocket webSocket, int code, String reason) {
-    webSocket.close(1000, null);
-    System.out.println("onClose (" + code + "): " + reason);
-  }
-
-  @Override public void onFailure(WebSocket webSocket, Throwable t, Response response) {
-    // TODO(jwilson): can I read the response body? Do I have to?
-    System.out.println("onFailure " + response);
-  }
-
-  @Override public void close() throws IOException {
-    if (webSocket == null) return;
-
-    WebSocket webSocket;
-    synchronized (this) {
-      webSocket = this.webSocket;
-    }
-
-    if (webSocket != null) {
-      webSocket.close(1000, "bye");
-    }
-  }
-}
diff --git a/samples/slack/src/main/java/okhttp3/slack/RtmStartResponse.java b/samples/slack/src/main/java/okhttp3/slack/RtmStartResponse.java
deleted file mode 100644
index b19fff6256..0000000000
--- a/samples/slack/src/main/java/okhttp3/slack/RtmStartResponse.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.slack;
-
-import java.util.List;
-import okhttp3.HttpUrl;
-
-/** See https://api.slack.com/methods/rtm.start. */
-public final class RtmStartResponse {
-  HttpUrl url;
-  Object self;
-  Object team;
-  List<Object> users;
-  List<Object> channels;
-  List<Object> groups;
-  List<Object> mpims;
-  List<Object> ims;
-  List<Object> bots;
-}
diff --git a/samples/slack/src/main/java/okhttp3/slack/SlackApi.java b/samples/slack/src/main/java/okhttp3/slack/SlackApi.java
deleted file mode 100644
index 4ab8565942..0000000000
--- a/samples/slack/src/main/java/okhttp3/slack/SlackApi.java
+++ /dev/null
@@ -1,126 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.slack;
-
-import com.squareup.moshi.FromJson;
-import com.squareup.moshi.JsonAdapter;
-import com.squareup.moshi.Moshi;
-import com.squareup.moshi.ToJson;
-import java.io.IOException;
-import okhttp3.Call;
-import okhttp3.HttpUrl;
-import okhttp3.WebSocket;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.WebSocketListener;
-import okio.ByteString;
-
-/**
- * API access to the <a href="https://api.slack.com/apps">Slack API</a> as an application. One
- * instance of this class may operate without a user, or on behalf of many users. Use the Slack API
- * dashboard to create a client ID and secret for this application.
- *
- * <p>You must configure your Slack API OAuth and Permissions page with a localhost URL like {@code
- * http://localhost:53203/oauth/}, passing the same port to this class‚Äô constructor.
- */
-public final class SlackApi {
-  private final HttpUrl baseUrl = HttpUrl.get("https://slack.com/api/");
-  private final OkHttpClient httpClient;
-  private final Moshi moshi;
-
-  public final String clientId;
-  public final String clientSecret;
-  public final int port;
-
-  public SlackApi(String clientId, String clientSecret, int port) {
-    this.httpClient = new OkHttpClient.Builder()
-        .build();
-    this.moshi = new Moshi.Builder()
-        .add(new SlackJsonAdapters())
-        .build();
-    this.clientId = clientId;
-    this.clientSecret = clientSecret;
-    this.port = port;
-  }
-
-  /** See https://api.slack.com/docs/oauth. */
-  public HttpUrl authorizeUrl(String scopes, HttpUrl redirectUrl, ByteString state, String team) {
-    HttpUrl.Builder builder = baseUrl.newBuilder("/oauth/authorize")
-        .addQueryParameter("client_id", clientId)
-        .addQueryParameter("scope", scopes)
-        .addQueryParameter("redirect_uri", redirectUrl.toString())
-        .addQueryParameter("state", state.base64());
-
-    if (team != null) {
-      builder.addQueryParameter("team", team);
-    }
-
-    return builder.build();
-  }
-
-  /** See https://api.slack.com/methods/oauth.access. */
-  public OAuthSession exchangeCode(String code, HttpUrl redirectUrl) throws IOException {
-    HttpUrl url = baseUrl.newBuilder("oauth.access")
-        .addQueryParameter("client_id", clientId)
-        .addQueryParameter("client_secret", clientSecret)
-        .addQueryParameter("code", code)
-        .addQueryParameter("redirect_uri", redirectUrl.toString())
-        .build();
-    Request request = new Request.Builder()
-        .url(url)
-        .build();
-    Call call = httpClient.newCall(request);
-    try (Response response = call.execute()) {
-      JsonAdapter<OAuthSession> jsonAdapter = moshi.adapter(OAuthSession.class);
-      return jsonAdapter.fromJson(response.body().source());
-    }
-  }
-
-  /** See https://api.slack.com/methods/rtm.start. */
-  public RtmStartResponse rtmStart(String accessToken) throws IOException {
-    HttpUrl url = baseUrl.newBuilder("rtm.start")
-        .addQueryParameter("token", accessToken)
-        .build();
-    Request request = new Request.Builder()
-        .url(url)
-        .build();
-    Call call = httpClient.newCall(request);
-    try (Response response = call.execute()) {
-      JsonAdapter<RtmStartResponse> jsonAdapter = moshi.adapter(RtmStartResponse.class);
-      return jsonAdapter.fromJson(response.body().source());
-    }
-  }
-
-  /** See https://api.slack.com/rtm. */
-  public WebSocket rtm(HttpUrl url, WebSocketListener listener) {
-    return httpClient.newWebSocket(new Request.Builder()
-        .url(url)
-        .build(), listener);
-  }
-
-  static final class SlackJsonAdapters {
-    @ToJson String urlToJson(HttpUrl httpUrl) {
-      return httpUrl.toString();
-    }
-
-    @FromJson HttpUrl urlFromJson(String urlString) {
-      if (urlString.startsWith("wss:")) urlString = "https:" + urlString.substring(4);
-      if (urlString.startsWith("ws:")) urlString = "http:" + urlString.substring(3);
-      return HttpUrl.get(urlString);
-    }
-  }
-}
diff --git a/samples/slack/src/main/java/okhttp3/slack/SlackClient.java b/samples/slack/src/main/java/okhttp3/slack/SlackClient.java
deleted file mode 100644
index 508a5fd467..0000000000
--- a/samples/slack/src/main/java/okhttp3/slack/SlackClient.java
+++ /dev/null
@@ -1,99 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.slack;
-
-import java.io.IOException;
-import java.io.InterruptedIOException;
-import okhttp3.HttpUrl;
-import okio.Timeout;
-
-/** A connection to Slack as a single user. */
-public final class SlackClient {
-  private final SlackApi slackApi;
-  private OAuthSessionFactory sessionFactory;
-
-  /** Guarded by this. */
-  private OAuthSession session;
-
-  public SlackClient(SlackApi slackApi) {
-    this.slackApi = slackApi;
-  }
-
-  /** Shows a browser URL to authorize this app to act as this user. */
-  public void requestOauthSession(String scopes, String team) throws Exception {
-    if (sessionFactory == null) {
-      sessionFactory = new OAuthSessionFactory(slackApi);
-      sessionFactory.start();
-    }
-
-    HttpUrl authorizeUrl = sessionFactory.newAuthorizeUrl(scopes, team, session -> {
-      initOauthSession(session);
-      System.out.printf("session granted: %s\n", session);
-    });
-
-    System.out.printf("open this URL in a browser: %s\n", authorizeUrl);
-  }
-
-  /** Set the OAuth session for this client. */
-  public synchronized void initOauthSession(OAuthSession session) {
-    this.session = session;
-    this.notifyAll();
-  }
-
-  /** Waits for an OAuth session for this client to be set. */
-  public synchronized void awaitAccessToken(Timeout timeout) throws InterruptedIOException {
-    while (session == null) {
-      timeout.waitUntilNotified(this);
-    }
-  }
-
-  /** Starts a real time messaging session. */
-  public void startRtm() throws IOException {
-    String accessToken;
-    synchronized (this) {
-      accessToken = session.access_token;
-    }
-
-    RtmSession rtmSession = new RtmSession(slackApi);
-    rtmSession.open(accessToken);
-  }
-
-  public static void main(String... args) throws Exception {
-    String clientId = "0000000000.00000000000";
-    String clientSecret = "00000000000000000000000000000000";
-    int port = 53203;
-    SlackApi slackApi = new SlackApi(clientId, clientSecret, port);
-
-    SlackClient client = new SlackClient(slackApi);
-    String scopes = "channels:history channels:read channels:write chat:write:bot chat:write:user "
-        + "dnd:read dnd:write emoji:read files:read files:write:user groups:history groups:read "
-        + "groups:write im:history im:read im:write mpim:history mpim:read mpim:write pins:read "
-        + "pins:write reactions:read reactions:write search:read stars:read stars:write team:read "
-        + "usergroups:read usergroups:write users:read users:write identify";
-
-    if (true) {
-      client.requestOauthSession(scopes, null);
-    } else {
-      OAuthSession session = new OAuthSession(true,
-          "xoxp-XXXXXXXXXX-XXXXXXXXXX-XXXXXXXXXXX-XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
-          scopes, "UXXXXXXXX", "My Slack Group", "TXXXXXXXX");
-      client.initOauthSession(session);
-    }
-
-    client.awaitAccessToken(Timeout.NONE);
-    client.startRtm();
-  }
-}
diff --git a/samples/static-server/pom.xml b/samples/static-server/pom.xml
deleted file mode 100644
index a794da1188..0000000000
--- a/samples/static-server/pom.xml
+++ /dev/null
@@ -1,62 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3.sample</groupId>
-    <artifactId>sample-parent</artifactId>
-    <version>3.14.3-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>static-server</artifactId>
-  <name>Sample: Static Server</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-shade-plugin</artifactId>
-        <version>3.2.1</version>
-        <configuration>
-          <shadedArtifactAttached>true</shadedArtifactAttached>
-          <shadedClassifierName>shaded</shadedClassifierName>
-          <transformers>
-            <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
-              <manifestEntries>
-                <Main-Class>okhttp3.sample.SampleServer</Main-Class>
-              </manifestEntries>
-            </transformer>
-          </transformers>
-          <filters>
-            <filter>
-              <artifact>*:*</artifact>
-              <excludes>
-                <exclude>META-INF/*.SF</exclude>
-                <exclude>META-INF/*.DSA</exclude>
-                <exclude>META-INF/*.RSA</exclude>
-              </excludes>
-            </filter>
-          </filters>
-        </configuration>
-        <executions>
-          <execution>
-            <phase>package</phase>
-            <goals>
-              <goal>shade</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/samples/static-server/src/main/java/okhttp3/sample/SampleServer.java b/samples/static-server/src/main/java/okhttp3/sample/SampleServer.java
deleted file mode 100644
index 88e0251bdb..0000000000
--- a/samples/static-server/src/main/java/okhttp3/sample/SampleServer.java
+++ /dev/null
@@ -1,140 +0,0 @@
-package okhttp3.sample;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.security.GeneralSecurityException;
-import java.security.KeyStore;
-import java.security.SecureRandom;
-import javax.net.ssl.KeyManagerFactory;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.TrustManagerFactory;
-import okhttp3.mockwebserver.Dispatcher;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
-import okio.Buffer;
-import okio.Okio;
-
-public class SampleServer extends Dispatcher {
-  private final SSLContext sslContext;
-  private final String root;
-  private final int port;
-
-  public SampleServer(SSLContext sslContext, String root, int port) {
-    this.sslContext = sslContext;
-    this.root = root;
-    this.port = port;
-  }
-
-  public void run() throws IOException {
-    MockWebServer server = new MockWebServer();
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.setDispatcher(this);
-    server.start(port);
-  }
-
-  @Override public MockResponse dispatch(RecordedRequest request) {
-    String path = request.getPath();
-    try {
-      if (!path.startsWith("/") || path.contains("..")) throw new FileNotFoundException();
-
-      File file = new File(root + path);
-      return file.isDirectory()
-          ? directoryToResponse(path, file)
-          : fileToResponse(path, file);
-    } catch (FileNotFoundException e) {
-      return new MockResponse()
-          .setStatus("HTTP/1.1 404")
-          .addHeader("content-type: text/plain; charset=utf-8")
-          .setBody("NOT FOUND: " + path);
-    } catch (IOException e) {
-      return new MockResponse()
-          .setStatus("HTTP/1.1 500")
-          .addHeader("content-type: text/plain; charset=utf-8")
-          .setBody("SERVER ERROR: " + e);
-    }
-  }
-
-  private MockResponse directoryToResponse(String basePath, File directory) {
-    if (!basePath.endsWith("/")) basePath += "/";
-
-    StringBuilder response = new StringBuilder();
-    response.append(String.format("<html><head><title>%s</title></head><body>", basePath));
-    response.append(String.format("<h1>%s</h1>", basePath));
-    for (String file : directory.list()) {
-      response.append(String.format("<div class='file'><a href='%s'>%s</a></div>",
-          basePath + file, file));
-    }
-    response.append("</body></html>");
-
-    return new MockResponse()
-        .setStatus("HTTP/1.1 200")
-        .addHeader("content-type: text/html; charset=utf-8")
-        .setBody(response.toString());
-  }
-
-  private MockResponse fileToResponse(String path, File file) throws IOException {
-    return new MockResponse()
-        .setStatus("HTTP/1.1 200")
-        .setBody(fileToBytes(file))
-        .addHeader("content-type: " + contentType(path));
-  }
-
-  private Buffer fileToBytes(File file) throws IOException {
-    Buffer result = new Buffer();
-    result.writeAll(Okio.source(file));
-    return result;
-  }
-
-  private String contentType(String path) {
-    if (path.endsWith(".png")) return "image/png";
-    if (path.endsWith(".jpg")) return "image/jpeg";
-    if (path.endsWith(".jpeg")) return "image/jpeg";
-    if (path.endsWith(".gif")) return "image/gif";
-    if (path.endsWith(".html")) return "text/html; charset=utf-8";
-    if (path.endsWith(".txt")) return "text/plain; charset=utf-8";
-    return "application/octet-stream";
-  }
-
-  public static void main(String[] args) throws Exception {
-    if (args.length != 4) {
-      System.out.println("Usage: SampleServer <keystore> <password> <root file> <port>");
-      return;
-    }
-
-    String keystoreFile = args[0];
-    String password = args[1];
-    String root = args[2];
-    int port = Integer.parseInt(args[3]);
-
-    SSLContext sslContext = sslContext(keystoreFile, password);
-    SampleServer server = new SampleServer(sslContext, root, port);
-    server.run();
-  }
-
-  private static SSLContext sslContext(String keystoreFile, String password)
-      throws GeneralSecurityException, IOException {
-    KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());
-    try (InputStream in = new FileInputStream(keystoreFile)) {
-      keystore.load(in, password.toCharArray());
-    }
-    KeyManagerFactory keyManagerFactory =
-        KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
-    keyManagerFactory.init(keystore, password.toCharArray());
-
-    TrustManagerFactory trustManagerFactory =
-        TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
-    trustManagerFactory.init(keystore);
-
-    SSLContext sslContext = SSLContext.getInstance("TLS");
-    sslContext.init(
-        keyManagerFactory.getKeyManagers(),
-        trustManagerFactory.getTrustManagers(),
-        new SecureRandom());
-
-    return sslContext;
-  }
-}
diff --git a/samples/unixdomainsockets/pom.xml b/samples/unixdomainsockets/pom.xml
deleted file mode 100644
index 16370e9a5e..0000000000
--- a/samples/unixdomainsockets/pom.xml
+++ /dev/null
@@ -1,31 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3.sample</groupId>
-    <artifactId>sample-parent</artifactId>
-    <version>3.14.3-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>unixdomainsockets</artifactId>
-  <name>Sample: UNIX domain sockets</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.github.jnr</groupId>
-      <artifactId>jnr-unixsocket</artifactId>
-    </dependency>
-  </dependencies>
-</project>
diff --git a/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/ClientAndServer.java b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/ClientAndServer.java
deleted file mode 100644
index f897565f52..0000000000
--- a/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/ClientAndServer.java
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.unixdomainsockets;
-
-import java.io.File;
-import java.util.Collections;
-import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-
-/**
- * Create UNIX domain sockets for MockWebServer and OkHttp and connect 'em together. Note that we
- * cannot do TLS over domain sockets.
- */
-public class ClientAndServer {
-  public void run() throws Exception {
-    File socketFile = new File("/tmp/ClientAndServer.sock");
-    socketFile.delete(); // Clean up from previous runs.
-
-    MockWebServer server = new MockWebServer();
-    server.setServerSocketFactory(new UnixDomainServerSocketFactory(socketFile));
-    server.setProtocols(Collections.singletonList(Protocol.H2_PRIOR_KNOWLEDGE));
-    server.enqueue(new MockResponse().setBody("hello"));
-    server.start();
-
-    OkHttpClient client = new OkHttpClient.Builder()
-        .socketFactory(new UnixDomainSocketFactory(socketFile))
-        .protocols(Collections.singletonList(Protocol.H2_PRIOR_KNOWLEDGE))
-        .build();
-
-    Request request = new Request.Builder()
-        .url("http://publicobject.com/helloworld.txt")
-        .build();
-
-    try (Response response = client.newCall(request).execute()) {
-      System.out.println(response.body().string());
-    }
-
-    server.shutdown();
-    socketFile.delete();
-  }
-
-  public static void main(String... args) throws Exception {
-    new ClientAndServer().run();
-  }
-}
diff --git a/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/TunnelingUnixSocket.java b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/TunnelingUnixSocket.java
deleted file mode 100644
index 678e04d4f7..0000000000
--- a/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/TunnelingUnixSocket.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.unixdomainsockets;
-
-import java.io.File;
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.SocketAddress;
-import jnr.unixsocket.UnixSocket;
-import jnr.unixsocket.UnixSocketAddress;
-import jnr.unixsocket.UnixSocketChannel;
-
-/**
- * Subtype UNIX socket for a higher-fidelity impersonation of TCP sockets. This is named "tunneling"
- * because it assumes the ultimate destination has a hostname and port.
- */
-final class TunnelingUnixSocket extends UnixSocket {
-  private final File path;
-  private InetSocketAddress inetSocketAddress;
-
-  TunnelingUnixSocket(File path, UnixSocketChannel channel) {
-    super(channel);
-    this.path = path;
-  }
-
-  TunnelingUnixSocket(File path, UnixSocketChannel channel, InetSocketAddress address) {
-    this(path, channel);
-    this.inetSocketAddress = address;
-  }
-
-  @Override public void connect(SocketAddress endpoint) throws IOException {
-    this.inetSocketAddress = (InetSocketAddress) endpoint;
-    super.connect(new UnixSocketAddress(path), 0);
-  }
-
-  @Override public void connect(SocketAddress endpoint, int timeout) throws IOException {
-    this.inetSocketAddress = (InetSocketAddress) endpoint;
-    super.connect(new UnixSocketAddress(path), timeout);
-  }
-
-  @Override public InetAddress getInetAddress() {
-    return inetSocketAddress.getAddress();
-  }
-}
diff --git a/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainServerSocketFactory.java b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainServerSocketFactory.java
deleted file mode 100644
index a96649e425..0000000000
--- a/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainServerSocketFactory.java
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.unixdomainsockets;
-
-import java.io.File;
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.ServerSocket;
-import java.net.Socket;
-import java.net.SocketAddress;
-import java.net.SocketException;
-import java.nio.channels.ClosedChannelException;
-import javax.net.ServerSocketFactory;
-import jnr.unixsocket.UnixServerSocketChannel;
-import jnr.unixsocket.UnixSocketAddress;
-import jnr.unixsocket.UnixSocketChannel;
-
-/** Impersonate TCP-style ServerSocketFactory over UNIX domain sockets. */
-public final class UnixDomainServerSocketFactory extends ServerSocketFactory {
-  private final File path;
-
-  public UnixDomainServerSocketFactory(File path) {
-    this.path = path;
-  }
-
-  @Override public ServerSocket createServerSocket() throws IOException {
-    return new UnixDomainServerSocket();
-  }
-
-  @Override public ServerSocket createServerSocket(int port) throws IOException {
-    return createServerSocket();
-  }
-
-  @Override public ServerSocket createServerSocket(int port, int backlog) throws IOException {
-    return createServerSocket();
-  }
-
-  @Override public ServerSocket createServerSocket(
-      int port, int backlog, InetAddress inetAddress) throws IOException {
-    return createServerSocket();
-  }
-
-  final class UnixDomainServerSocket extends ServerSocket {
-    private UnixServerSocketChannel serverSocketChannel;
-    private InetSocketAddress endpoint;
-
-    UnixDomainServerSocket() throws IOException {
-    }
-
-    @Override public void bind(SocketAddress endpoint, int backlog) throws IOException {
-      this.endpoint = (InetSocketAddress) endpoint;
-
-      UnixSocketAddress address = new UnixSocketAddress(path);
-      serverSocketChannel = UnixServerSocketChannel.open();
-      serverSocketChannel.configureBlocking(true);
-      serverSocketChannel.socket().bind(address);
-    }
-
-    @Override public int getLocalPort() {
-      return 1; // A white lie. There is no local port.
-    }
-
-    @Override public SocketAddress getLocalSocketAddress() {
-      return endpoint;
-    }
-
-    @Override public Socket accept() throws IOException {
-      try {
-        UnixSocketChannel channel = serverSocketChannel.accept();
-        return new TunnelingUnixSocket(path, channel, endpoint);
-      } catch (ClosedChannelException e) {
-        SocketException exception = new SocketException();
-        exception.initCause(e);
-        throw exception;
-      }
-    }
-
-    @Override public void close() throws IOException {
-      serverSocketChannel.close();
-    }
-  }
-}
diff --git a/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainSocketFactory.java b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainSocketFactory.java
deleted file mode 100644
index fc1c8e05a6..0000000000
--- a/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainSocketFactory.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.unixdomainsockets;
-
-import java.io.File;
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.Socket;
-import javax.net.SocketFactory;
-import jnr.unixsocket.UnixSocketChannel;
-
-/** Impersonate TCP-style SocketFactory over UNIX domain sockets. */
-public final class UnixDomainSocketFactory extends SocketFactory {
-  private final File path;
-
-  public UnixDomainSocketFactory(File path) {
-    this.path = path;
-  }
-
-  @Override public Socket createSocket() throws IOException {
-    UnixSocketChannel channel = UnixSocketChannel.open();
-    return new TunnelingUnixSocket(path, channel);
-  }
-
-  @Override public Socket createSocket(String host, int port) throws IOException {
-    Socket result = createSocket();
-    result.connect(new InetSocketAddress(host, port));
-    return result;
-  }
-
-  @Override public Socket createSocket(
-      String host, int port, InetAddress localHost, int localPort) throws IOException {
-    return createSocket(host, port);
-  }
-
-  @Override public Socket createSocket(InetAddress host, int port) throws IOException {
-    Socket result = createSocket();
-    result.connect(new InetSocketAddress(host, port));
-    return result;
-  }
-
-  @Override public Socket createSocket(
-      InetAddress host, int port, InetAddress localAddress, int localPort) throws IOException {
-    return createSocket(host, port);
-  }
-}
diff --git a/src/main/java/module-info.java.off b/src/main/java/module-info.java.off
new file mode 100644
index 0000000000..8be45227e2
--- /dev/null
+++ b/src/main/java/module-info.java.off
@@ -0,0 +1,9 @@
+module net.disy.commons.web {
+  // test only
+  requires java.net.http;
+
+  // test only
+  requires okio;
+
+  exports net.disy.commons.web;
+}
\ No newline at end of file
diff --git a/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.java b/src/main/java/net/disy/commons/web/PublicSuffixDatabase.java
similarity index 97%
rename from okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.java
rename to src/main/java/net/disy/commons/web/PublicSuffixDatabase.java
index 74fbd89b79..0d8ee0c2c1 100644
--- a/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.java
+++ b/src/main/java/net/disy/commons/web/PublicSuffixDatabase.java
@@ -13,7 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.publicsuffix;
+package net.disy.commons.web;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
 
 import java.io.IOException;
 import java.io.InputStream;
@@ -21,18 +23,16 @@
 import java.net.IDN;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicBoolean;
-import okhttp3.internal.platform.Platform;
+
 import okio.BufferedSource;
 import okio.GzipSource;
 import okio.Okio;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
-
 /**
  * A database of public suffixes provided by
  * <a href="https://publicsuffix.org/">publicsuffix.org</a>.
  */
-public final class PublicSuffixDatabase {
+final class PublicSuffixDatabase {
   public static final String PUBLIC_SUFFIX_RESOURCE = "publicsuffixes.gz";
 
   private static final byte[] WILDCARD_LABEL = new byte[]{'*'};
@@ -119,8 +119,8 @@ public String getEffectiveTldPlusOne(String domain) {
 
     synchronized (this) {
       if (publicSuffixListBytes == null) {
-        throw new IllegalStateException("Unable to load " + PUBLIC_SUFFIX_RESOURCE + " resource "
-            + "from the classpath.");
+        throw new IllegalStateException(
+            "Unable to load " + PUBLIC_SUFFIX_RESOURCE + " resource " + "from the classpath.");
       }
     }
 
@@ -294,7 +294,7 @@ private void readTheListUninterruptibly() {
           Thread.interrupted(); // Temporarily clear the interrupted state.
           interrupted = true;
         } catch (IOException e) {
-          Platform.get().log(Platform.WARN, "Failed to read public suffix list", e);
+          //Platform.get().log(Platform.WARN, "Failed to read public suffix list", e);
           return;
         }
       }
diff --git a/okhttp/src/main/java/okhttp3/HttpUrl.java b/src/main/java/net/disy/commons/web/WebUrl.java
similarity index 93%
rename from okhttp/src/main/java/okhttp3/HttpUrl.java
rename to src/main/java/net/disy/commons/web/WebUrl.java
index 26125e306d..6279a9adb3 100644
--- a/okhttp/src/main/java/okhttp3/HttpUrl.java
+++ b/src/main/java/net/disy/commons/web/WebUrl.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3;
+package net.disy.commons.web;
 
 import java.net.InetAddress;
 import java.net.MalformedURLException;
@@ -21,29 +21,23 @@
 import java.net.URISyntaxException;
 import java.net.URL;
 import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Set;
-import javax.annotation.Nullable;
-import okhttp3.internal.Util;
-import okhttp3.internal.publicsuffix.PublicSuffixDatabase;
+
 import okio.Buffer;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static okhttp3.internal.Util.decodeHexDigit;
-import static okhttp3.internal.Util.delimiterOffset;
-import static okhttp3.internal.Util.skipLeadingAsciiWhitespace;
-import static okhttp3.internal.Util.skipTrailingAsciiWhitespace;
-import static okhttp3.internal.Util.verifyAsIpAddress;
+//import javax.annotation.Nullable;
 
 /**
  * A uniform resource locator (URL) with a scheme of either {@code http} or {@code https}. Use this
  * class to compose and decompose Internet addresses. For example, this code will compose and print
  * a URL for Google search: <pre>   {@code
  *
- *   HttpUrl url = new HttpUrl.Builder()
+ *   WebUrl url = new WebUrl.Builder()
  *       .scheme("https")
  *       .host("www.google.com")
  *       .addPathSegment("search")
@@ -60,7 +54,7 @@
  * As another example, this code prints the human-readable query parameters of a Twitter search:
  * <pre>   {@code
  *
- *   HttpUrl url = HttpUrl.parse("https://twitter.com/search?q=cute%20%23puppies&f=images");
+ *   WebUrl url = WebUrl.parse("https://twitter.com/search?q=cute%20%23puppies&f=images");
  *   for (int i = 0, size = url.querySize(); i < size; i++) {
  *     System.out.println(url.queryParameterName(i) + ": " + url.queryParameterValue(i));
  *   }
@@ -76,8 +70,8 @@
  * component parts, this class implements relative URL resolution: what address you'd reach by
  * clicking a relative link on a specified page. For example: <pre>   {@code
  *
- *   HttpUrl base = HttpUrl.parse("https://www.youtube.com/user/WatchTheDaily/videos");
- *   HttpUrl link = base.resolve("../../watch?v=cbP2N1BQdYc");
+ *   WebUrl base = WebUrl.parse("https://www.youtube.com/user/WatchTheDaily/videos");
+ *   WebUrl link = base.resolve("../../watch?v=cbP2N1BQdYc");
  *   System.out.println(link);
  * }</pre>
  *
@@ -166,7 +160,7 @@
  * start of the URL's query. But within the query and fragment components, the {@code ?} character
  * doesn't delimit anything and doesn't need to be escaped. <pre>   {@code
  *
- *   HttpUrl url = HttpUrl.parse("http://who-let-the-dogs.out").newBuilder()
+ *   WebUrl url = WebUrl.parse("http://who-let-the-dogs.out").newBuilder()
  *       .addPathSegment("_Who?_")
  *       .query("_Who?_")
  *       .fragment("_Who?_")
@@ -243,7 +237,7 @@
  *   String attack = "http://example.com/static/images/../../../../../etc/passwd";
  *   System.out.println(new URL(attack).getPath());
  *   System.out.println(new URI(attack).getPath());
- *   System.out.println(HttpUrl.parse(attack).encodedPath());
+ *   System.out.println(WebUrl.parse(attack).encodedPath());
  * }</pre>
  *
  * By canonicalizing the input paths, they are complicit in directory traversal attacks. Code that
@@ -260,7 +254,7 @@
  * <p>The {@code java.net.URI} class is strict around what URLs it accepts. It rejects URLs like
  * "http://example.com/abc|def" because the '|' character is unsupported. This class is more
  * forgiving: it will automatically percent-encode the '|', yielding "http://example.com/abc%7Cdef".
- * This kind behavior is consistent with web browsers. {@code HttpUrl} prefers consistency with
+ * This kind behavior is consistent with web browsers. {@code WebUrl} prefers consistency with
  * major web browsers over consistency with obsolete specifications.
  *
  * <h4>Paths and Queries should decompose</h4>
@@ -277,7 +271,7 @@
  * constructors. For example, there's no API to compose a URI with a custom port without also
  * providing a query and fragment.
  *
- * <p>Instances of {@link HttpUrl} are well-formed and always have a scheme, host, and path. With
+ * <p>Instances of {@link WebUrl} are well-formed and always have a scheme, host, and path. With
  * {@code java.net.URL} it's possible to create an awkward URL like {@code http:/} with scheme and
  * path but no hostname. Building APIs that consume such malformed values is difficult!
  *
@@ -286,7 +280,7 @@
  * returns null if the input is an invalid URL. You can even be explicit about whether each
  * component has been encoded already.
  */
-public final class HttpUrl {
+public final class WebUrl {
   private static final char[] HEX_DIGITS =
       {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
   static final String USERNAME_ENCODE_SET = " \"':;<=>@[]^`{}|/\\?#";
@@ -328,15 +322,15 @@
    * non-empty, but never null. Values are null if the name has no corresponding '=' separator, or
    * empty, or non-empty.
    */
-  private final @Nullable List<String> queryNamesAndValues;
+  private final /*@Nullable*/ List<String> queryNamesAndValues;
 
   /** Decoded fragment. */
-  private final @Nullable String fragment;
+  private final /*@Nullable*/ String fragment;
 
   /** Canonical URL. */
   private final String url;
 
-  HttpUrl(Builder builder) {
+  WebUrl(Builder builder) {
     this.scheme = builder.scheme;
     this.username = percentDecode(builder.encodedUsername, false);
     this.password = percentDecode(builder.encodedPassword, false);
@@ -412,7 +406,7 @@ public boolean isHttps() {
   public String encodedUsername() {
     if (username.isEmpty()) return "";
     int usernameStart = scheme.length() + 3; // "://".length() == 3.
-    int usernameEnd = delimiterOffset(url, usernameStart, url.length(), ":@");
+    int usernameEnd = WebUrlUtilities.delimiterOffset(url, usernameStart, url.length(), ":@");
     return url.substring(usernameStart, usernameEnd);
   }
 
@@ -545,7 +539,7 @@ public int pathSize() {
    */
   public String encodedPath() {
     int pathStart = url.indexOf('/', scheme.length() + 3); // "://".length() == 3.
-    int pathEnd = delimiterOffset(url, pathStart, url.length(), "?#");
+    int pathEnd = WebUrlUtilities.delimiterOffset(url, pathStart, url.length(), "?#");
     return url.substring(pathStart, pathEnd);
   }
 
@@ -569,11 +563,11 @@ static void pathSegmentsToString(StringBuilder out, List<String> pathSegments) {
    */
   public List<String> encodedPathSegments() {
     int pathStart = url.indexOf('/', scheme.length() + 3);
-    int pathEnd = delimiterOffset(url, pathStart, url.length(), "?#");
+    int pathEnd = WebUrlUtilities.delimiterOffset(url, pathStart, url.length(), "?#");
     List<String> result = new ArrayList<>();
     for (int i = pathStart; i < pathEnd; ) {
       i++; // Skip the '/'.
-      int segmentEnd = delimiterOffset(url, i, pathEnd, '/');
+      int segmentEnd = WebUrlUtilities.delimiterOffset(url, i, pathEnd, '/');
       result.add(url.substring(i, segmentEnd));
       i = segmentEnd;
     }
@@ -610,10 +604,10 @@ static void pathSegmentsToString(StringBuilder out, List<String> pathSegments) {
    *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code "a=apple&b"}</td></tr>
    * </table>
    */
-  public @Nullable String encodedQuery() {
+  public /*@Nullable*/ String encodedQuery() {
     if (queryNamesAndValues == null) return null; // No query.
     int queryStart = url.indexOf('?') + 1;
-    int queryEnd = delimiterOffset(url, queryStart, url.length(), '#');
+    int queryEnd = WebUrlUtilities.delimiterOffset(url, queryStart, url.length(), '#');
     return url.substring(queryStart, queryEnd);
   }
 
@@ -670,7 +664,7 @@ static void namesAndValuesToQueryString(StringBuilder out, List<String> namesAnd
    *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code "a=apple&b"}</td></tr>
    * </table>
    */
-  public @Nullable String query() {
+  public /*@Nullable*/ String query() {
     if (queryNamesAndValues == null) return null; // No query.
     StringBuilder result = new StringBuilder();
     namesAndValuesToQueryString(result, queryNamesAndValues);
@@ -708,7 +702,7 @@ public int querySize() {
    *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code "apple"}</td></tr>
    * </table>
    */
-  public @Nullable String queryParameter(String name) {
+  public /*@Nullable*/ String queryParameter(String name) {
     if (queryNamesAndValues == null) return null;
     for (int i = 0, size = queryNamesAndValues.size(); i < size; i += 2) {
       if (name.equals(queryNamesAndValues.get(i))) {
@@ -825,7 +819,7 @@ public String queryParameterValue(int index) {
    *   <tr><td>{@code http://host/#abc|def}</td><td>{@code "abc|def"}</td></tr>
    * </table>
    */
-  public @Nullable String encodedFragment() {
+  public /*@Nullable*/ String encodedFragment() {
     if (fragment == null) return null;
     int fragmentStart = url.indexOf('#') + 1;
     return url.substring(fragmentStart);
@@ -843,7 +837,7 @@ public String queryParameterValue(int index) {
    *   <tr><td>{@code http://host/#abc|def}</td><td>{@code "abc|def"}</td></tr>
    * </table>
    */
-  public @Nullable String fragment() {
+  public /*@Nullable*/ String fragment() {
     return fragment;
   }
 
@@ -864,7 +858,7 @@ public String redact() {
    * Returns the URL that would be retrieved by following {@code link} from this URL, or null if
    * the resulting URL is not well-formed.
    */
-  public @Nullable HttpUrl resolve(String link) {
+  public /*@Nullable*/ WebUrl resolve(String link) {
     Builder builder = newBuilder(link);
     return builder != null ? builder.build() : null;
   }
@@ -888,7 +882,7 @@ public Builder newBuilder() {
    * Returns a builder for the URL that would be retrieved by following {@code link} from this URL,
    * or null if the resulting URL is not well-formed.
    */
-  public @Nullable Builder newBuilder(String link) {
+  public /*@Nullable*/ Builder newBuilder(String link) {
     try {
       return new Builder().parse(this, link);
     } catch (IllegalArgumentException ignored) {
@@ -897,10 +891,10 @@ public Builder newBuilder() {
   }
 
   /**
-   * Returns a new {@code HttpUrl} representing {@code url} if it is a well-formed HTTP or HTTPS
+   * Returns a new {@code WebUrl} representing {@code url} if it is a well-formed HTTP or HTTPS
    * URL, or null if it isn't.
    */
-  public static @Nullable HttpUrl parse(String url) {
+  public static /*@Nullable*/ WebUrl parse(String url) {
     try {
       return get(url);
     } catch (IllegalArgumentException ignored) {
@@ -909,28 +903,32 @@ public Builder newBuilder() {
   }
 
   /**
-   * Returns a new {@code HttpUrl} representing {@code url}.
+   * Returns a new {@code WebUrl} representing {@code url}.
    *
    * @throws IllegalArgumentException If {@code url} is not a well-formed HTTP or HTTPS URL.
    */
-  public static HttpUrl get(String url) {
+  public static WebUrl get(String url) {
     return new Builder().parse(null, url).build();
   }
 
   /**
-   * Returns an {@link HttpUrl} for {@code url} if its protocol is {@code http} or {@code https}, or
+   * Returns an {@link WebUrl} for {@code url} if its protocol is {@code http} or {@code https}, or
    * null if it has any other protocol.
    */
-  public static @Nullable HttpUrl get(URL url) {
+  static /*@Nullable*/ WebUrl get(URL url) {
     return parse(url.toString());
   }
 
-  public static @Nullable HttpUrl get(URI uri) {
+  /**
+   * Returns an {@link WebUrl} for {@code uri} if its protocol is {@code http} or {@code https}, or
+   * null if it has any other protocol.
+   */
+  public static /*@Nullable*/ WebUrl get(URI uri) {
     return parse(uri.toString());
   }
 
-  @Override public boolean equals(@Nullable Object other) {
-    return other instanceof HttpUrl && ((HttpUrl) other).url.equals(url);
+  @Override public boolean equals(/*@Nullable*/ Object other) {
+    return other instanceof WebUrl && ((WebUrl) other).url.equals(url);
   }
 
   @Override public int hashCode() {
@@ -960,20 +958,20 @@ public static HttpUrl get(String url) {
    *   <tr><td>{@code http://127.0.0.1}</td><td>null</td></tr>
    * </table>
    */
-  public @Nullable String topPrivateDomain() {
-    if (verifyAsIpAddress(host)) return null;
+  public /*@Nullable*/ String topPrivateDomain() {
+    if (WebUrlUtilities.verifyAsIpAddress(host)) return null;
     return PublicSuffixDatabase.get().getEffectiveTldPlusOne(host);
   }
 
   public static final class Builder {
-    @Nullable String scheme;
+    /*@Nullable*/ String scheme;
     String encodedUsername = "";
     String encodedPassword = "";
-    @Nullable String host;
+    /*@Nullable*/ String host;
     int port = -1;
     final List<String> encodedPathSegments = new ArrayList<>();
-    @Nullable List<String> encodedQueryNamesAndValues;
-    @Nullable String encodedFragment;
+    /*@Nullable*/ List<String> encodedQueryNamesAndValues;
+    /*@Nullable*/ String encodedFragment;
 
     public Builder() {
       encodedPathSegments.add(""); // The default path is '/' which needs a trailing space.
@@ -1078,7 +1076,7 @@ public Builder addEncodedPathSegments(String encodedPathSegments) {
     private Builder addPathSegments(String pathSegments, boolean alreadyEncoded) {
       int offset = 0;
       do {
-        int segmentEnd = delimiterOffset(pathSegments, offset, pathSegments.length(), "/\\");
+        int segmentEnd = WebUrlUtilities.delimiterOffset(pathSegments, offset, pathSegments.length(), "/\\");
         boolean addTrailingSlash = segmentEnd < pathSegments.length();
         push(pathSegments, offset, segmentEnd, addTrailingSlash, alreadyEncoded);
         offset = segmentEnd + 1;
@@ -1127,7 +1125,7 @@ public Builder encodedPath(String encodedPath) {
       return this;
     }
 
-    public Builder query(@Nullable String query) {
+    public Builder query(/*@Nullable*/ String query) {
       this.encodedQueryNamesAndValues = query != null
           ? queryStringToNamesAndValues(canonicalize(
           query, QUERY_ENCODE_SET, false, false, true, true))
@@ -1135,7 +1133,7 @@ public Builder query(@Nullable String query) {
       return this;
     }
 
-    public Builder encodedQuery(@Nullable String encodedQuery) {
+    public Builder encodedQuery(/*@Nullable*/ String encodedQuery) {
       this.encodedQueryNamesAndValues = encodedQuery != null
           ? queryStringToNamesAndValues(
           canonicalize(encodedQuery, QUERY_ENCODE_SET, true, false, true, true))
@@ -1144,7 +1142,7 @@ public Builder encodedQuery(@Nullable String encodedQuery) {
     }
 
     /** Encodes the query parameter using UTF-8 and adds it to this URL's query string. */
-    public Builder addQueryParameter(String name, @Nullable String value) {
+    public Builder addQueryParameter(String name, /*@Nullable*/ String value) {
       if (name == null) throw new NullPointerException("name == null");
       if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = new ArrayList<>();
       encodedQueryNamesAndValues.add(
@@ -1156,7 +1154,7 @@ public Builder addQueryParameter(String name, @Nullable String value) {
     }
 
     /** Adds the pre-encoded query parameter to this URL's query string. */
-    public Builder addEncodedQueryParameter(String encodedName, @Nullable String encodedValue) {
+    public Builder addEncodedQueryParameter(String encodedName, /*@Nullable*/ String encodedValue) {
       if (encodedName == null) throw new NullPointerException("encodedName == null");
       if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = new ArrayList<>();
       encodedQueryNamesAndValues.add(
@@ -1167,13 +1165,13 @@ public Builder addEncodedQueryParameter(String encodedName, @Nullable String enc
       return this;
     }
 
-    public Builder setQueryParameter(String name, @Nullable String value) {
+    public Builder setQueryParameter(String name, /*@Nullable*/ String value) {
       removeAllQueryParameters(name);
       addQueryParameter(name, value);
       return this;
     }
 
-    public Builder setEncodedQueryParameter(String encodedName, @Nullable String encodedValue) {
+    public Builder setEncodedQueryParameter(String encodedName, /*@Nullable*/ String encodedValue) {
       removeAllEncodedQueryParameters(encodedName);
       addEncodedQueryParameter(encodedName, encodedValue);
       return this;
@@ -1209,14 +1207,14 @@ private void removeAllCanonicalQueryParameters(String canonicalName) {
       }
     }
 
-    public Builder fragment(@Nullable String fragment) {
+    public Builder fragment(/*@Nullable*/ String fragment) {
       this.encodedFragment = fragment != null
           ? canonicalize(fragment, FRAGMENT_ENCODE_SET, false, false, false, false)
           : null;
       return this;
     }
 
-    public Builder encodedFragment(@Nullable String encodedFragment) {
+    public Builder encodedFragment(/*@Nullable*/ String encodedFragment) {
       this.encodedFragment = encodedFragment != null
           ? canonicalize(encodedFragment, FRAGMENT_ENCODE_SET, true, false, false, false)
           : null;
@@ -1249,10 +1247,10 @@ Builder reencodeForUri() {
       return this;
     }
 
-    public HttpUrl build() {
+    public WebUrl build() {
       if (scheme == null) throw new IllegalStateException("scheme == null");
       if (host == null) throw new IllegalStateException("host == null");
-      return new HttpUrl(this);
+      return new WebUrl(this);
     }
 
     @Override public String toString() {
@@ -1309,9 +1307,9 @@ public HttpUrl build() {
 
     static final String INVALID_HOST = "Invalid URL host";
 
-    Builder parse(@Nullable HttpUrl base, String input) {
-      int pos = skipLeadingAsciiWhitespace(input, 0, input.length());
-      int limit = skipTrailingAsciiWhitespace(input, pos, input.length());
+    Builder parse(/*@Nullable*/ WebUrl base, String input) {
+      int pos = WebUrlUtilities.skipLeadingAsciiWhitespace(input, 0, input.length());
+      int limit = WebUrlUtilities.skipTrailingAsciiWhitespace(input, pos, input.length());
 
       // Scheme.
       int schemeDelimiterOffset = schemeDelimiterOffset(input, pos, limit);
@@ -1350,7 +1348,7 @@ Builder parse(@Nullable HttpUrl base, String input) {
         pos += slashCount;
         authority:
         while (true) {
-          int componentDelimiterOffset = delimiterOffset(input, pos, limit, "@/\\?#");
+          int componentDelimiterOffset = WebUrlUtilities.delimiterOffset(input, pos, limit, "@/\\?#");
           int c = componentDelimiterOffset != limit
               ? input.charAt(componentDelimiterOffset)
               : -1;
@@ -1358,7 +1356,7 @@ Builder parse(@Nullable HttpUrl base, String input) {
             case '@':
               // User info precedes.
               if (!hasPassword) {
-                int passwordColonOffset = delimiterOffset(
+                int passwordColonOffset = WebUrlUtilities.delimiterOffset(
                     input, pos, componentDelimiterOffset, ':');
                 String canonicalUsername = canonicalize(input, pos, passwordColonOffset,
                     USERNAME_ENCODE_SET, true, false, false, true, null);
@@ -1419,13 +1417,13 @@ Builder parse(@Nullable HttpUrl base, String input) {
       }
 
       // Resolve the relative path.
-      int pathDelimiterOffset = delimiterOffset(input, pos, limit, "?#");
+      int pathDelimiterOffset = WebUrlUtilities.delimiterOffset(input, pos, limit, "?#");
       resolvePath(input, pos, pathDelimiterOffset);
       pos = pathDelimiterOffset;
 
       // Query.
       if (pos < limit && input.charAt(pos) == '?') {
-        int queryDelimiterOffset = delimiterOffset(input, pos, limit, '#');
+        int queryDelimiterOffset = WebUrlUtilities.delimiterOffset(input, pos, limit, '#');
         this.encodedQueryNamesAndValues = queryStringToNamesAndValues(canonicalize(
             input, pos + 1, queryDelimiterOffset, QUERY_ENCODE_SET, true, false, true, true, null));
         pos = queryDelimiterOffset;
@@ -1459,7 +1457,7 @@ private void resolvePath(String input, int pos, int limit) {
 
       // Read path segments.
       for (int i = pos; i < limit; ) {
-        int pathSegmentDelimiterOffset = delimiterOffset(input, i, limit, "/\\");
+        int pathSegmentDelimiterOffset = WebUrlUtilities.delimiterOffset(input, i, limit, "/\\");
         boolean segmentHasTrailingSlash = pathSegmentDelimiterOffset < limit;
         push(input, i, pathSegmentDelimiterOffset, segmentHasTrailingSlash, true);
         i = pathSegmentDelimiterOffset;
@@ -1582,11 +1580,11 @@ private static int portColonOffset(String input, int pos, int limit) {
       return limit; // No colon.
     }
 
-    private static @Nullable String canonicalizeHost(String input, int pos, int limit) {
+    private static /*@Nullable*/ String canonicalizeHost(String input, int pos, int limit) {
       // Start by percent decoding the host. The WHATWG spec suggests doing this only after we've
       // checked for IPv6 square braces. But Chrome does it first, and that's more lenient.
       String percentDecoded = percentDecode(input, pos, limit, false);
-      return Util.canonicalizeHost(percentDecoded);
+      return WebUrlUtilities.canonicalizeHost(percentDecoded);
     }
 
     private static int parsePort(String input, int pos, int limit) {
@@ -1637,8 +1635,8 @@ static void percentDecode(Buffer out, String encoded, int pos, int limit, boolea
     for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
       codePoint = encoded.codePointAt(i);
       if (codePoint == '%' && i + 2 < limit) {
-        int d1 = decodeHexDigit(encoded.charAt(i + 1));
-        int d2 = decodeHexDigit(encoded.charAt(i + 2));
+        int d1 = WebUrlUtilities.decodeHexDigit(encoded.charAt(i + 1));
+        int d2 = WebUrlUtilities.decodeHexDigit(encoded.charAt(i + 2));
         if (d1 != -1 && d2 != -1) {
           out.writeByte((d1 << 4) + d2);
           i += 2;
@@ -1655,8 +1653,8 @@ static void percentDecode(Buffer out, String encoded, int pos, int limit, boolea
   static boolean percentEncoded(String encoded, int pos, int limit) {
     return pos + 2 < limit
         && encoded.charAt(pos) == '%'
-        && decodeHexDigit(encoded.charAt(pos + 1)) != -1
-        && decodeHexDigit(encoded.charAt(pos + 2)) != -1;
+        && WebUrlUtilities.decodeHexDigit(encoded.charAt(pos + 1)) != -1
+        && WebUrlUtilities.decodeHexDigit(encoded.charAt(pos + 2)) != -1;
   }
 
   /**
@@ -1678,7 +1676,7 @@ static boolean percentEncoded(String encoded, int pos, int limit) {
    */
   static String canonicalize(String input, int pos, int limit, String encodeSet,
       boolean alreadyEncoded, boolean strict, boolean plusIsSpace, boolean asciiOnly,
-      @Nullable Charset charset) {
+      /*@Nullable*/ Charset charset) {
     int codePoint;
     for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
       codePoint = input.codePointAt(i);
@@ -1703,7 +1701,7 @@ static String canonicalize(String input, int pos, int limit, String encodeSet,
 
   static void canonicalize(Buffer out, String input, int pos, int limit, String encodeSet,
       boolean alreadyEncoded, boolean strict, boolean plusIsSpace, boolean asciiOnly,
-      @Nullable Charset charset) {
+      /*@Nullable*/ Charset charset) {
     Buffer encodedCharBuffer = null; // Lazily allocated.
     int codePoint;
     for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
@@ -1724,7 +1722,7 @@ static void canonicalize(Buffer out, String input, int pos, int limit, String en
           encodedCharBuffer = new Buffer();
         }
 
-        if (charset == null || charset.equals(UTF_8)) {
+        if (charset == null || charset.equals(StandardCharsets.UTF_8)) {
           encodedCharBuffer.writeUtf8CodePoint(codePoint);
         } else {
           encodedCharBuffer.writeString(input, i, i + Character.charCount(codePoint), charset);
@@ -1744,7 +1742,7 @@ static void canonicalize(Buffer out, String input, int pos, int limit, String en
   }
 
   static String canonicalize(String input, String encodeSet, boolean alreadyEncoded, boolean strict,
-      boolean plusIsSpace, boolean asciiOnly, @Nullable Charset charset) {
+      boolean plusIsSpace, boolean asciiOnly, /*@Nullable*/ Charset charset) {
     return canonicalize(input, 0, input.length(), encodeSet, alreadyEncoded, strict, plusIsSpace,
         asciiOnly, charset);
   }
diff --git a/src/main/java/net/disy/commons/web/WebUrlUtilities.java b/src/main/java/net/disy/commons/web/WebUrlUtilities.java
new file mode 100644
index 0000000000..1aa896bbc7
--- /dev/null
+++ b/src/main/java/net/disy/commons/web/WebUrlUtilities.java
@@ -0,0 +1,318 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package net.disy.commons.web;
+
+import java.net.IDN;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.Arrays;
+import java.util.Locale;
+import java.util.regex.Pattern;
+
+import okio.Buffer;
+
+//import javax.annotation.Nullable;
+
+/** Junk drawer of utility methods. */
+final class WebUrlUtilities {
+
+  /**
+   * Quick and dirty pattern to differentiate IP addresses from hostnames. This is an approximation
+   * of Android's private InetAddress#isNumeric API.
+   *
+   * <p>This matches IPv6 addresses as a hex string containing at least one colon, and possibly
+   * including dots after the first colon. It matches IPv4 addresses as strings containing only
+   * decimal digits and dots. This pattern matches strings like "a:.23" and "54" that are neither IP
+   * addresses nor hostnames; they will be verified as IP addresses (which is a more strict
+   * verification).
+   */
+  private static final Pattern VERIFY_AS_IP_ADDRESS =
+      Pattern.compile("([0-9a-fA-F]*:[0-9a-fA-F:.]*)|([\\d.]+)");
+
+  private WebUrlUtilities() {}
+
+  /**
+   * Increments {@code pos} until {@code input[pos]} is not ASCII whitespace. Stops at {@code
+   * limit}.
+   */
+  static int skipLeadingAsciiWhitespace(String input, int pos, int limit) {
+    for (int i = pos; i < limit; i++) {
+      switch (input.charAt(i)) {
+        case '\t':
+        case '\n':
+        case '\f':
+        case '\r':
+        case ' ':
+          continue;
+        default:
+          return i;
+      }
+    }
+    return limit;
+  }
+
+  /**
+   * Decrements {@code limit} until {@code input[limit - 1]} is not ASCII whitespace. Stops at
+   * {@code pos}.
+   */
+  static int skipTrailingAsciiWhitespace(String input, int pos, int limit) {
+    for (int i = limit - 1; i >= pos; i--) {
+      switch (input.charAt(i)) {
+        case '\t':
+        case '\n':
+        case '\f':
+        case '\r':
+        case ' ':
+          continue;
+        default:
+          return i + 1;
+      }
+    }
+    return pos;
+  }
+
+  /**
+   * Returns the index of the first character in {@code input} that contains a character in {@code
+   * delimiters}. Returns limit if there is no such character.
+   */
+  static int delimiterOffset(String input, int pos, int limit, String delimiters) {
+    for (int i = pos; i < limit; i++) {
+      if (delimiters.indexOf(input.charAt(i)) != -1) return i;
+    }
+    return limit;
+  }
+
+  /**
+   * Returns the index of the first character in {@code input} that is {@code delimiter}. Returns
+   * limit if there is no such character.
+   */
+  static int delimiterOffset(String input, int pos, int limit, char delimiter) {
+    for (int i = pos; i < limit; i++) {
+      if (input.charAt(i) == delimiter) return i;
+    }
+    return limit;
+  }
+
+  /**
+   * If {@code host} is an IP address, this returns the IP address in canonical form.
+   *
+   * <p>Otherwise this performs IDN ToASCII encoding and canonicalize the result to lowercase. For
+   * example this converts {@code ‚òÉ.net} to {@code xn--n3h.net}, and {@code WwW.GoOgLe.cOm} to
+   * {@code www.google.com}. {@code null} will be returned if the host cannot be ToASCII encoded or
+   * if the result contains unsupported ASCII characters.
+   */
+  static String canonicalizeHost(String host) {
+    // If the input contains a :, it‚Äôs an IPv6 address.
+    if (host.contains(":")) {
+      // If the input is encased in square braces "[...]", drop 'em.
+      InetAddress inetAddress = host.startsWith("[") && host.endsWith("]")
+          ? decodeIpv6(host, 1, host.length() - 1)
+          : decodeIpv6(host, 0, host.length());
+      if (inetAddress == null) return null;
+      byte[] address = inetAddress.getAddress();
+      if (address.length == 16) return inet6AddressToAscii(address);
+      if (address.length == 4) return inetAddress.getHostAddress(); // An IPv4-mapped IPv6 address.
+      throw new AssertionError("Invalid IPv6 address: '" + host + "'");
+    }
+
+    try {
+      String result = IDN.toASCII(host).toLowerCase(Locale.US);
+      if (result.isEmpty()) return null;
+
+      // Confirm that the IDN ToASCII result doesn't contain any illegal characters.
+      if (containsInvalidHostnameAsciiCodes(result)) {
+        return null;
+      }
+      // TODO: implement all label limits.
+      return result;
+    } catch (IllegalArgumentException e) {
+      return null;
+    }
+  }
+
+  private static boolean containsInvalidHostnameAsciiCodes(String hostnameAscii) {
+    for (int i = 0; i < hostnameAscii.length(); i++) {
+      char c = hostnameAscii.charAt(i);
+      // The WHATWG Host parsing rules accepts some character codes which are invalid by
+      // definition for OkHttp's host header checks (and the WHATWG Host syntax definition). Here
+      // we rule out characters that would cause problems in host headers.
+      if (c <= '\u001f' || c >= '\u007f') {
+        return true;
+      }
+      // Check for the characters mentioned in the WHATWG Host parsing spec:
+      // U+0000, U+0009, U+000A, U+000D, U+0020, "#", "%", "/", ":", "?", "@", "[", "\", and "]"
+      // (excluding the characters covered above).
+      if (" #%/:?@[\\]".indexOf(c) != -1) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  /** Returns true if {@code host} is not a host name and might be an IP address. */
+  static boolean verifyAsIpAddress(String host) {
+    return VERIFY_AS_IP_ADDRESS.matcher(host).matches();
+  }
+
+  static int decodeHexDigit(char c) {
+    if (c >= '0' && c <= '9') return c - '0';
+    if (c >= 'a' && c <= 'f') return c - 'a' + 10;
+    if (c >= 'A' && c <= 'F') return c - 'A' + 10;
+    return -1;
+  }
+
+  /** Decodes an IPv6 address like 1111:2222:3333:4444:5555:6666:7777:8888 or ::1. */
+  private static /*@Nullable*/ InetAddress decodeIpv6(String input, int pos, int limit) {
+    byte[] address = new byte[16];
+    int b = 0;
+    int compress = -1;
+    int groupOffset = -1;
+
+    for (int i = pos; i < limit; ) {
+      if (b == address.length) return null; // Too many groups.
+
+      // Read a delimiter.
+      if (i + 2 <= limit && input.regionMatches(i, "::", 0, 2)) {
+        // Compression "::" delimiter, which is anywhere in the input, including its prefix.
+        if (compress != -1) return null; // Multiple "::" delimiters.
+        i += 2;
+        b += 2;
+        compress = b;
+        if (i == limit) break;
+      } else if (b != 0) {
+        // Group separator ":" delimiter.
+        if (input.regionMatches(i, ":", 0, 1)) {
+          i++;
+        } else if (input.regionMatches(i, ".", 0, 1)) {
+          // If we see a '.', rewind to the beginning of the previous group and parse as IPv4.
+          if (!decodeIpv4Suffix(input, groupOffset, limit, address, b - 2)) return null;
+          b += 2; // We rewound two bytes and then added four.
+          break;
+        } else {
+          return null; // Wrong delimiter.
+        }
+      }
+
+      // Read a group, one to four hex digits.
+      int value = 0;
+      groupOffset = i;
+      for (; i < limit; i++) {
+        char c = input.charAt(i);
+        int hexDigit = decodeHexDigit(c);
+        if (hexDigit == -1) break;
+        value = (value << 4) + hexDigit;
+      }
+      int groupLength = i - groupOffset;
+      if (groupLength == 0 || groupLength > 4) return null; // Group is the wrong size.
+
+      // We've successfully read a group. Assign its value to our byte array.
+      address[b++] = (byte) ((value >>> 8) & 0xff);
+      address[b++] = (byte) (value & 0xff);
+    }
+
+    // All done. If compression happened, we need to move bytes to the right place in the
+    // address. Here's a sample:
+    //
+    //      input: "1111:2222:3333::7777:8888"
+    //     before: { 11, 11, 22, 22, 33, 33, 00, 00, 77, 77, 88, 88, 00, 00, 00, 00  }
+    //   compress: 6
+    //          b: 10
+    //      after: { 11, 11, 22, 22, 33, 33, 00, 00, 00, 00, 00, 00, 77, 77, 88, 88 }
+    //
+    if (b != address.length) {
+      if (compress == -1) return null; // Address didn't have compression or enough groups.
+      System.arraycopy(address, compress, address, address.length - (b - compress), b - compress);
+      Arrays.fill(address, compress, compress + (address.length - b), (byte) 0);
+    }
+
+    try {
+      return InetAddress.getByAddress(address);
+    } catch (UnknownHostException e) {
+      throw new AssertionError();
+    }
+  }
+
+  /** Decodes an IPv4 address suffix of an IPv6 address, like 1111::5555:6666:192.168.0.1. */
+  private static boolean decodeIpv4Suffix(
+      String input, int pos, int limit, byte[] address, int addressOffset) {
+    int b = addressOffset;
+
+    for (int i = pos; i < limit; ) {
+      if (b == address.length) return false; // Too many groups.
+
+      // Read a delimiter.
+      if (b != addressOffset) {
+        if (input.charAt(i) != '.') return false; // Wrong delimiter.
+        i++;
+      }
+
+      // Read 1 or more decimal digits for a value in 0..255.
+      int value = 0;
+      int groupOffset = i;
+      for (; i < limit; i++) {
+        char c = input.charAt(i);
+        if (c < '0' || c > '9') break;
+        if (value == 0 && groupOffset != i) return false; // Reject unnecessary leading '0's.
+        value = (value * 10) + c - '0';
+        if (value > 255) return false; // Value out of range.
+      }
+      int groupLength = i - groupOffset;
+      if (groupLength == 0) return false; // No digits.
+
+      // We've successfully read a byte.
+      address[b++] = (byte) value;
+    }
+
+    if (b != addressOffset + 4) return false; // Too few groups. We wanted exactly four.
+    return true; // Success.
+  }
+
+  /** Encodes an IPv6 address in canonical form according to RFC 5952. */
+  private static String inet6AddressToAscii(byte[] address) {
+    // Go through the address looking for the longest run of 0s. Each group is 2-bytes.
+    // A run must be longer than one group (section 4.2.2).
+    // If there are multiple equal runs, the first one must be used (section 4.2.3).
+    int longestRunOffset = -1;
+    int longestRunLength = 0;
+    for (int i = 0; i < address.length; i += 2) {
+      int currentRunOffset = i;
+      while (i < 16 && address[i] == 0 && address[i + 1] == 0) {
+        i += 2;
+      }
+      int currentRunLength = i - currentRunOffset;
+      if (currentRunLength > longestRunLength && currentRunLength >= 4) {
+        longestRunOffset = currentRunOffset;
+        longestRunLength = currentRunLength;
+      }
+    }
+
+    // Emit each 2-byte group in hex, separated by ':'. The longest run of zeroes is "::".
+    Buffer result = new Buffer();
+    for (int i = 0; i < address.length; ) {
+      if (i == longestRunOffset) {
+        result.writeByte(':');
+        i += longestRunLength;
+        if (i == 16) result.writeByte(':');
+      } else {
+        if (i > 0) result.writeByte(':');
+        int group = (address[i] & 0xff) << 8 | address[i + 1] & 0xff;
+        result.writeHexadecimalUnsignedLong(group);
+        i += 2;
+      }
+    }
+    return result.readUtf8();
+  }
+}
diff --git a/okhttp/src/main/resources/okhttp3/internal/publicsuffix/NOTICE b/src/main/resources/net/disy/commons/web/NOTICE
similarity index 100%
rename from okhttp/src/main/resources/okhttp3/internal/publicsuffix/NOTICE
rename to src/main/resources/net/disy/commons/web/NOTICE
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java b/src/test/java/net/disy/commons/web/PublicSuffixDatabaseTest.java
similarity index 96%
rename from okhttp-tests/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java
rename to src/test/java/net/disy/commons/web/PublicSuffixDatabaseTest.java
index 70d44bbe28..6606ce2955 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java
+++ b/src/test/java/net/disy/commons/web/PublicSuffixDatabaseTest.java
@@ -13,20 +13,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.publicsuffix;
+package net.disy.commons.web;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
 
 import java.io.IOException;
 import java.io.InputStream;
-import okhttp3.internal.Util;
+
+import org.junit.Test;
+
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.GzipSource;
 import okio.Okio;
-import org.junit.Test;
-
-import static okhttp3.internal.publicsuffix.PublicSuffixDatabase.PUBLIC_SUFFIX_RESOURCE;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
 
 public final class PublicSuffixDatabaseTest {
   private final PublicSuffixDatabase publicSuffixDatabase = new PublicSuffixDatabase();
@@ -108,7 +108,7 @@
 
   @Test public void allPublicSuffixes() throws IOException {
     InputStream resource = PublicSuffixDatabaseTest.class
-        .getResourceAsStream(PUBLIC_SUFFIX_RESOURCE);
+        .getResourceAsStream(PublicSuffixDatabase.PUBLIC_SUFFIX_RESOURCE);
     BufferedSource source = Okio.buffer(new GzipSource(Okio.source(resource)));
     int length = source.readInt();
     Buffer buffer = new Buffer();
@@ -129,8 +129,7 @@
   }
 
   @Test public void publicSuffixExceptions() throws IOException {
-    InputStream resource = PublicSuffixDatabaseTest.class
-        .getResourceAsStream(PUBLIC_SUFFIX_RESOURCE);
+    InputStream resource = PublicSuffixDatabaseTest.class.getResourceAsStream(PublicSuffixDatabase.PUBLIC_SUFFIX_RESOURCE);
     BufferedSource source = Okio.buffer(new GzipSource(Okio.source(resource)));
     int length = source.readInt();
     source.skip(length);
@@ -274,14 +273,14 @@ private void checkPublicSuffix(String domain, String registrablePart) {
       return;
     }
 
-    String canonicalDomain = Util.canonicalizeHost(domain);
+    String canonicalDomain = WebUrlUtilities.canonicalizeHost(domain);
     if (canonicalDomain == null) return;
 
     String result = publicSuffixDatabase.getEffectiveTldPlusOne(canonicalDomain);
     if (registrablePart == null) {
       assertThat(result).isNull();
     } else {
-      assertThat(result).isEqualTo(Util.canonicalizeHost(registrablePart));
+      assertThat(result).isEqualTo(WebUrlUtilities.canonicalizeHost(registrablePart));
     }
   }
 }
diff --git a/okhttp/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixListGenerator.java b/src/test/java/net/disy/commons/web/PublicSuffixListGenerator.java
similarity index 58%
rename from okhttp/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixListGenerator.java
rename to src/test/java/net/disy/commons/web/PublicSuffixListGenerator.java
index 50b1f8703a..eadd5c0188 100644
--- a/okhttp/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixListGenerator.java
+++ b/src/test/java/net/disy/commons/web/PublicSuffixListGenerator.java
@@ -13,15 +13,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.publicsuffix;
+package net.disy.commons.web;
 
-import java.io.File;
 import java.io.IOException;
+import java.io.InputStream;
+import java.net.URI;
+import java.net.http.HttpClient;
+import java.net.http.HttpRequest;
+import java.net.http.HttpResponse;
+import java.net.http.HttpResponse.BodyHandlers;
+import java.nio.file.Files;
+import java.nio.file.Path;
 import java.util.SortedSet;
 import java.util.TreeSet;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
+
 import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.ByteString;
@@ -39,62 +44,57 @@
  * <p>The resulting file is used by {@link PublicSuffixDatabase}.
  */
 public final class PublicSuffixListGenerator {
-  private static final String OKHTTP_RESOURCE_DIR = "okhttp" + File.separator + "src"
-      + File.separator + "main" + File.separator + "resources" + File.separator
-      + "okhttp3" + File.separator + "internal" + File.separator + "publicsuffix";
+  private static final Path OKHTTP_RESOURCE_DIR =
+      Path.of("src/main/resources/net/disy/commons/web");
 
   private static final ByteString EXCEPTION_RULE_MARKER = ByteString.encodeUtf8("!");
   private static final String WILDCARD_CHAR = "*";
 
-  public static void main(String... args) throws IOException {
-    OkHttpClient client = new OkHttpClient.Builder().build();
-    Request request = new Request.Builder()
-        .url("https://publicsuffix.org/list/public_suffix_list.dat")
-        .build();
+  public static void main(String... args) throws IOException, InterruptedException {
+    HttpClient client = HttpClient.newHttpClient();
+    var request =
+        HttpRequest.newBuilder(URI.create("https://publicsuffix.org/list/public_suffix_list.dat")).build();
     SortedSet<ByteString> sortedRules = new TreeSet<>();
     SortedSet<ByteString> sortedExceptionRules = new TreeSet<>();
-    try (Response response = client.newCall(request).execute()) {
-      BufferedSource source = response.body().source();
-      int totalRuleBytes = 0;
-      int totalExceptionRuleBytes = 0;
-      while (!source.exhausted()) {
-        String line = source.readUtf8LineStrict();
-        if (line.trim().isEmpty() || line.startsWith("//")) continue;
-
-        if (line.contains(WILDCARD_CHAR)) {
-          assertWildcardRule(line);
-        }
+    HttpResponse<InputStream> response = client.send(request, BodyHandlers.ofInputStream());
+    BufferedSource source = Okio.buffer(Okio.source(response.body()));
+    int totalRuleBytes = 0;
+    int totalExceptionRuleBytes = 0;
+    while (!source.exhausted()) {
+      String line = source.readUtf8LineStrict();
+      if (line.trim().isEmpty() || line.startsWith("//")) continue;
 
-        ByteString rule = ByteString.encodeUtf8(line);
-        if (rule.startsWith(EXCEPTION_RULE_MARKER)) {
-          rule = rule.substring(1);
-          // We use '\n' for end of value.
-          totalExceptionRuleBytes += rule.size() + 1;
-          sortedExceptionRules.add(rule);
-        } else {
-          totalRuleBytes += rule.size() + 1; // We use '\n' for end of value.
-          sortedRules.add(rule);
-        }
+      if (line.contains(WILDCARD_CHAR)) {
+        assertWildcardRule(line);
       }
 
-      File resources = new File(OKHTTP_RESOURCE_DIR);
-      if (!resources.mkdirs() && !resources.exists()) {
-        throw new RuntimeException("Unable to create resource directory!");
+      ByteString rule = ByteString.encodeUtf8(line);
+      if (rule.startsWith(EXCEPTION_RULE_MARKER)) {
+        rule = rule.substring(1);
+        // We use '\n' for end of value.
+        totalExceptionRuleBytes += rule.size() + 1;
+        sortedExceptionRules.add(rule);
+      } else {
+        totalRuleBytes += rule.size() + 1; // We use '\n' for end of value.
+        sortedRules.add(rule);
       }
+    }
 
-      Sink fileSink = Okio.sink(new File(resources, PublicSuffixDatabase.PUBLIC_SUFFIX_RESOURCE));
-      try (BufferedSink sink = Okio.buffer(new GzipSink(fileSink))) {
-        sink.writeInt(totalRuleBytes);
-        for (ByteString domain : sortedRules) {
-          sink.write(domain).writeByte('\n');
-        }
+    Path resources = Files.createDirectories(OKHTTP_RESOURCE_DIR);
+
+    Sink fileSink = Okio.sink(resources.resolve(PublicSuffixDatabase.PUBLIC_SUFFIX_RESOURCE));
+    try (BufferedSink sink = Okio.buffer(new GzipSink(fileSink))) {
+      sink.writeInt(totalRuleBytes);
+      for (ByteString domain : sortedRules) {
+        sink.write(domain).writeByte('\n');
+      }
 
-        sink.writeInt(totalExceptionRuleBytes);
-        for (ByteString domain : sortedExceptionRules) {
-          sink.write(domain).writeByte('\n');
-        }
+      sink.writeInt(totalExceptionRuleBytes);
+      for (ByteString domain : sortedExceptionRules) {
+        sink.write(domain).writeByte('\n');
       }
     }
+    System.out.println("PublicSuffixListGenerator completed successfully!");
   }
 
   /**
diff --git a/okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java b/src/test/java/net/disy/commons/web/UrlComponentEncodingTester.java
similarity index 84%
rename from okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java
rename to src/test/java/net/disy/commons/web/UrlComponentEncodingTester.java
index 5875bc3970..2fc5f223d2 100644
--- a/okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java
+++ b/src/test/java/net/disy/commons/web/UrlComponentEncodingTester.java
@@ -13,19 +13,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3;
+package net.disy.commons.web;
+
+import static org.junit.Assert.fail;
 
 import java.net.URI;
 import java.net.URL;
 import java.util.Collections;
 import java.util.LinkedHashMap;
+import java.util.Locale;
 import java.util.Map;
-import okhttp3.internal.Util;
+
 import okio.Buffer;
 import okio.ByteString;
 
-import static org.junit.Assert.fail;
-
 /** Tests how each code point is encoded and decoded in the context of each URL component. */
 class UrlComponentEncodingTester {
   private static final int UNICODE_2 = 0x07ff; // Arbitrary code point that's 2 bytes in UTF-8.
@@ -230,20 +231,20 @@ public UrlComponentEncodingTester test(Component component) {
   private void testParseAlreadyEncoded(int codePoint, Encoding encoding, Component component) {
     String encoded = encoding.encode(codePoint);
     String urlString = component.urlString(encoded);
-    HttpUrl url = HttpUrl.get(urlString);
+    WebUrl url = WebUrl.get(urlString);
     if (!component.encodedValue(url).equals(encoded)) {
-      fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
+      fail(format("Encoding %s %#x using %s", component, codePoint, encoding));
     }
   }
 
   private void testEncodeAndDecode(int codePoint, Component component) {
     String expected = Encoding.IDENTITY.encode(codePoint);
-    HttpUrl.Builder builder = HttpUrl.get("http://host/").newBuilder();
+    WebUrl.Builder builder = WebUrl.get("http://host/").newBuilder();
     component.set(builder, expected);
-    HttpUrl url = builder.build();
+    WebUrl url = builder.build();
     String actual = component.get(url);
     if (!expected.equals(actual)) {
-      fail(Util.format("Roundtrip %s %#x %s", component, codePoint, url));
+      fail(format("Roundtrip %s %#x %s", component, codePoint, url));
     }
   }
 
@@ -252,29 +253,29 @@ private void testParseOriginal(int codePoint, Encoding encoding, Component compo
     if (encoding != Encoding.PERCENT) return;
     String identity = Encoding.IDENTITY.encode(codePoint);
     String urlString = component.urlString(identity);
-    HttpUrl url = HttpUrl.get(urlString);
+    WebUrl url = WebUrl.get(urlString);
 
     String s = component.encodedValue(url);
     if (!s.equals(encoded)) {
-      fail(Util.format("Encoding %s %#02x using %s", component, codePoint, encoding));
+      fail(format("Encoding %s %#02x using %s", component, codePoint, encoding));
     }
   }
 
   private void testToUrl(int codePoint, Encoding encoding, Component component) {
     String encoded = encoding.encode(codePoint);
-    HttpUrl httpUrl = HttpUrl.get(component.urlString(encoded));
+    WebUrl httpUrl = WebUrl.get(component.urlString(encoded));
     URL javaNetUrl = httpUrl.url();
     if (!javaNetUrl.toString().equals(javaNetUrl.toString())) {
-      fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
+      fail(format("Encoding %s %#x using %s", component, codePoint, encoding));
     }
   }
 
   private void testFromUrl(int codePoint, Encoding encoding, Component component) {
     String encoded = encoding.encode(codePoint);
-    HttpUrl httpUrl = HttpUrl.get(component.urlString(encoded));
-    HttpUrl toAndFromJavaNetUrl = HttpUrl.get(httpUrl.url());
+    WebUrl httpUrl = WebUrl.get(component.urlString(encoded));
+    WebUrl toAndFromJavaNetUrl = WebUrl.get(httpUrl.url()).orElse(null);
     if (!toAndFromJavaNetUrl.equals(httpUrl)) {
-      fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
+      fail(format("Encoding %s %#x using %s", component, codePoint, encoding));
     }
   }
 
@@ -282,24 +283,24 @@ private void testUri(
       int codePoint, Encoding encoding, Component component, boolean uriEscaped) {
     String string = new String(new int[] {codePoint}, 0, 1);
     String encoded = encoding.encode(codePoint);
-    HttpUrl httpUrl = HttpUrl.get(component.urlString(encoded));
+    WebUrl httpUrl = WebUrl.get(component.urlString(encoded));
     URI uri = httpUrl.uri();
-    HttpUrl toAndFromUri = HttpUrl.get(uri);
+    WebUrl toAndFromUri = WebUrl.get(uri).orElse(null);
     if (uriEscaped) {
       // The URI has more escaping than the HttpURL. Check that the decoded values still match.
       if (uri.toString().equals(httpUrl.toString())) {
-        fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
+        fail(format("Encoding %s %#x using %s", component, codePoint, encoding));
       }
       if (!component.get(toAndFromUri).equals(string)) {
-        fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
+        fail(format("Encoding %s %#x using %s", component, codePoint, encoding));
       }
     } else {
       // Check that the URI and HttpURL have the exact same escaping.
       if (!toAndFromUri.equals(httpUrl)) {
-        fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
+        fail(format("Encoding %s %#x using %s", component, codePoint, encoding));
       }
       if (!uri.toString().equals(httpUrl.toString())) {
-        fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
+        fail(format("Encoding %s %#x using %s", component, codePoint, encoding));
       }
     }
   }
@@ -316,7 +317,7 @@ public String encode(int codePoint) {
         ByteString utf8 = ByteString.encodeUtf8(IDENTITY.encode(codePoint));
         Buffer percentEncoded = new Buffer();
         for (int i = 0; i < utf8.size(); i++) {
-          percentEncoded.writeUtf8(Util.format("%%%02X", utf8.getByte(i) & 0xff));
+          percentEncoded.writeUtf8(format("%%%02X", utf8.getByte(i) & 0xff));
         }
         return percentEncoded.readUtf8();
       }
@@ -335,15 +336,15 @@ public String encode(int codePoint) {
         return "http://" + value + "@example.com/";
       }
 
-      @Override public String encodedValue(HttpUrl url) {
+      @Override public String encodedValue(WebUrl url) {
         return url.encodedUsername();
       }
 
-      @Override public void set(HttpUrl.Builder builder, String value) {
+      @Override public void set(WebUrl.Builder builder, String value) {
         builder.username(value);
       }
 
-      @Override public String get(HttpUrl url) {
+      @Override public String get(WebUrl url) {
         return url.username();
       }
     },
@@ -352,15 +353,15 @@ public String encode(int codePoint) {
         return "http://:" + value + "@example.com/";
       }
 
-      @Override public String encodedValue(HttpUrl url) {
+      @Override public String encodedValue(WebUrl url) {
         return url.encodedPassword();
       }
 
-      @Override public void set(HttpUrl.Builder builder, String value) {
+      @Override public void set(WebUrl.Builder builder, String value) {
         builder.password(value);
       }
 
-      @Override public String get(HttpUrl url) {
+      @Override public String get(WebUrl url) {
         return url.password();
       }
     },
@@ -369,16 +370,16 @@ public String encode(int codePoint) {
         return "http://example.com/a" + value + "z/";
       }
 
-      @Override public String encodedValue(HttpUrl url) {
+      @Override public String encodedValue(WebUrl url) {
         String path = url.encodedPath();
         return path.substring(2, path.length() - 2);
       }
 
-      @Override public void set(HttpUrl.Builder builder, String value) {
+      @Override public void set(WebUrl.Builder builder, String value) {
         builder.addPathSegment("a" + value + "z");
       }
 
-      @Override public String get(HttpUrl url) {
+      @Override public String get(WebUrl url) {
         String pathSegment = url.pathSegments().get(0);
         return pathSegment.substring(1, pathSegment.length() - 1);
       }
@@ -388,16 +389,16 @@ public String encode(int codePoint) {
         return "http://example.com/?a" + value + "z";
       }
 
-      @Override public String encodedValue(HttpUrl url) {
+      @Override public String encodedValue(WebUrl url) {
         String query = url.encodedQuery();
         return query.substring(1, query.length() - 1);
       }
 
-      @Override public void set(HttpUrl.Builder builder, String value) {
+      @Override public void set(WebUrl.Builder builder, String value) {
         builder.query("a" + value + "z");
       }
 
-      @Override public String get(HttpUrl url) {
+      @Override public String get(WebUrl url) {
         String query = url.query();
         return query.substring(1, query.length() - 1);
       }
@@ -407,16 +408,16 @@ public String encode(int codePoint) {
         return "http://example.com/?q=a" + value + "z";
       }
 
-      @Override public String encodedValue(HttpUrl url) {
+      @Override public String encodedValue(WebUrl url) {
         String query = url.encodedQuery();
         return query.substring(3, query.length() - 1);
       }
 
-      @Override public void set(HttpUrl.Builder builder, String value) {
+      @Override public void set(WebUrl.Builder builder, String value) {
         builder.addQueryParameter("q", "a" + value + "z");
       }
 
-      @Override public String get(HttpUrl url) {
+      @Override public String get(WebUrl url) {
         String value = url.queryParameter("q");
         return value.substring(1, value.length() - 1);
       }
@@ -426,16 +427,16 @@ public String encode(int codePoint) {
         return "http://example.com/#a" + value + "z";
       }
 
-      @Override public String encodedValue(HttpUrl url) {
+      @Override public String encodedValue(WebUrl url) {
         String fragment = url.encodedFragment();
         return fragment.substring(1, fragment.length() - 1);
       }
 
-      @Override public void set(HttpUrl.Builder builder, String value) {
+      @Override public void set(WebUrl.Builder builder, String value) {
         builder.fragment("a" + value + "z");
       }
 
-      @Override public String get(HttpUrl url) {
+      @Override public String get(WebUrl url) {
         String fragment = url.fragment();
         return fragment.substring(1, fragment.length() - 1);
       }
@@ -443,10 +444,15 @@ public String encode(int codePoint) {
 
     public abstract String urlString(String value);
 
-    public abstract String encodedValue(HttpUrl url);
+    public abstract String encodedValue(WebUrl url);
+
+    public abstract void set(WebUrl.Builder builder, String value);
 
-    public abstract void set(HttpUrl.Builder builder, String value);
+    public abstract String get(WebUrl url);
+  }
 
-    public abstract String get(HttpUrl url);
+  /** Returns a {@link Locale#US} formatted {@link String}. */
+  private static String format(String format, Object... args) {
+    return String.format(Locale.US, format, args);
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java b/src/test/java/net/disy/commons/web/WebUrlTest.java
similarity index 92%
rename from okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
rename to src/test/java/net/disy/commons/web/WebUrlTest.java
index edd04aceda..b0decebd69 100644
--- a/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
+++ b/src/test/java/net/disy/commons/web/WebUrlTest.java
@@ -13,7 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3;
+package net.disy.commons.web;
+
+import static java.util.Collections.singletonList;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
 
 import java.net.URI;
 import java.net.URL;
@@ -21,19 +25,18 @@
 import java.util.Collection;
 import java.util.Collections;
 import java.util.LinkedHashSet;
-import okhttp3.UrlComponentEncodingTester.Component;
-import okhttp3.UrlComponentEncodingTester.Encoding;
+
 import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
-import static java.util.Collections.singletonList;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
+import net.disy.commons.web.UrlComponentEncodingTester.Component;
+import net.disy.commons.web.UrlComponentEncodingTester.Encoding;
+import net.disy.commons.web.WebUrl.Builder;
 
 @RunWith(Parameterized.class)
-public final class HttpUrlTest {
+public final class WebUrlTest {
   @Parameterized.Parameters(name = "Use get = {0}")
   public static Collection<Object[]> parameters() {
     return Arrays.asList(
@@ -45,14 +48,14 @@
   @Parameterized.Parameter
   public boolean useGet;
 
-  HttpUrl parse(String url) {
+  WebUrl parse(String url) {
     return useGet
-        ? HttpUrl.get(url)
-        : HttpUrl.parse(url);
+        ? WebUrl.get(url)
+        : WebUrl.parse(url);
   }
 
   @Test public void parseTrimsAsciiWhitespace() throws Exception {
-    HttpUrl expected = parse("http://host/");
+    WebUrl expected = parse("http://host/");
     // Leading.
     assertThat(parse("http://host/\f\n\t \r")).isEqualTo(expected);
     // Trailing.
@@ -163,7 +166,7 @@ HttpUrl parse(String url) {
 
   @Test public void newBuilderResolve() throws Exception {
     // Non-exhaustive tests because implementation is the same as resolve.
-    HttpUrl base = parse("http://host/a/b");
+    WebUrl base = parse("http://host/a/b");
     assertThat(base.newBuilder("https://host2").build()).isEqualTo(parse("https://host2/"));
     assertThat(base.newBuilder("//host2").build()).isEqualTo(parse("http://host2/"));
     assertThat(base.newBuilder("/path").build()).isEqualTo(parse("http://host/path"));
@@ -179,16 +182,16 @@ HttpUrl parse(String url) {
   }
 
   @Test public void redactedUrl() {
-    HttpUrl baseWithPasswordAndUsername = parse("http://username:password@host/a/b#fragment");
-    HttpUrl baseWithUsernameOnly = parse("http://username@host/a/b#fragment");
-    HttpUrl baseWithPasswordOnly = parse("http://password@host/a/b#fragment");
+    WebUrl baseWithPasswordAndUsername = parse("http://username:password@host/a/b#fragment");
+    WebUrl baseWithUsernameOnly = parse("http://username@host/a/b#fragment");
+    WebUrl baseWithPasswordOnly = parse("http://password@host/a/b#fragment");
     assertThat(baseWithPasswordAndUsername.redact()).isEqualTo("http://host/...");
     assertThat(baseWithUsernameOnly.redact()).isEqualTo("http://host/...");
     assertThat(baseWithPasswordOnly.redact()).isEqualTo("http://host/...");
   }
 
   @Test public void resolveNoScheme() throws Exception {
-    HttpUrl base = parse("http://host/a/b");
+    WebUrl base = parse("http://host/a/b");
     assertThat(base.resolve("//host2")).isEqualTo(parse("http://host2/"));
     assertThat(base.resolve("/path")).isEqualTo(parse("http://host/path"));
     assertThat(base.resolve("path")).isEqualTo(parse("http://host/a/path"));
@@ -199,7 +202,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void resolveUnsupportedScheme() throws Exception {
-    HttpUrl base = parse("http://a/");
+    WebUrl base = parse("http://a/");
     assertThat(base.resolve("ftp://b")).isNull();
     assertThat(base.resolve("ht+tp://b")).isNull();
     assertThat(base.resolve("ht-tp://b")).isNull();
@@ -207,7 +210,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void resolveSchemeLikePath() throws Exception {
-    HttpUrl base = parse("http://a/");
+    WebUrl base = parse("http://a/");
     assertThat(base.resolve("http//b/")).isEqualTo(parse("http://a/http//b/"));
     assertThat(base.resolve("ht+tp//b/")).isEqualTo(parse("http://a/ht+tp//b/"));
     assertThat(base.resolve("ht-tp//b/")).isEqualTo(parse("http://a/ht-tp//b/"));
@@ -216,8 +219,8 @@ HttpUrl parse(String url) {
 
   /** https://tools.ietf.org/html/rfc3986#section-5.4.1 */
   @Test public void rfc3886NormalExamples() {
-    HttpUrl url = parse("http://a/b/c/d;p?q");
-    // No 'g:' scheme in HttpUrl.
+    WebUrl url = parse("http://a/b/c/d;p?q");
+    // No 'g:' scheme in WebUrl.
     assertThat(url.resolve("g:h")).isNull();
     assertThat(url.resolve("g")).isEqualTo(parse("http://a/b/c/g"));
     assertThat(url.resolve("./g")).isEqualTo(parse("http://a/b/c/g"));
@@ -245,7 +248,7 @@ HttpUrl parse(String url) {
 
   /** https://tools.ietf.org/html/rfc3986#section-5.4.2 */
   @Test public void rfc3886AbnormalExamples() {
-    HttpUrl url = parse("http://a/b/c/d;p?q");
+    WebUrl url = parse("http://a/b/c/d;p?q");
     assertThat(url.resolve("../../../g")).isEqualTo(parse("http://a/g"));
     assertThat(url.resolve("../../../../g")).isEqualTo(parse("http://a/g"));
     assertThat(url.resolve("/./g")).isEqualTo(parse("http://a/g"));
@@ -287,7 +290,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void resolveAuthoritySlashCountDoesntMatterWithDifferentScheme() throws Exception {
-    HttpUrl base = parse("https://a/b/c");
+    WebUrl base = parse("https://a/b/c");
     assertThat(base.resolve("http:host/path")).isEqualTo(parse("http://host/path"));
     assertThat(base.resolve("http:/host/path")).isEqualTo(parse("http://host/path"));
     assertThat(base.resolve("http:\\host/path")).isEqualTo(parse("http://host/path"));
@@ -306,7 +309,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void resolveAuthoritySlashCountMattersWithSameScheme() throws Exception {
-    HttpUrl base = parse("http://a/b/c");
+    WebUrl base = parse("http://a/b/c");
     assertThat(base.resolve("http:host/path")).isEqualTo(parse("http://a/b/host/path"));
     assertThat(base.resolve("http:/host/path")).isEqualTo(parse("http://a/host/path"));
     assertThat(base.resolve("http:\\host/path")).isEqualTo(parse("http://a/host/path"));
@@ -331,7 +334,7 @@ HttpUrl parse(String url) {
 
   /** Given multiple '@' characters, the last one is the delimiter. */
   @Test public void authorityWithMultipleAtSigns() throws Exception {
-    HttpUrl httpUrl = parse("http://foo@bar@baz/path");
+    WebUrl httpUrl = parse("http://foo@bar@baz/path");
     assertThat(httpUrl.username()).isEqualTo("foo@bar");
     assertThat(httpUrl.password()).isEqualTo("");
     assertThat(httpUrl).isEqualTo(parse("http://foo%40bar@baz/path"));
@@ -339,7 +342,7 @@ HttpUrl parse(String url) {
 
   /** Given multiple ':' characters, the first one is the delimiter. */
   @Test public void authorityWithMultipleColons() throws Exception {
-    HttpUrl httpUrl = parse("http://foo:pass1@bar:pass2@baz/path");
+    WebUrl httpUrl = parse("http://foo:pass1@bar:pass2@baz/path");
     assertThat(httpUrl.username()).isEqualTo("foo");
     assertThat(httpUrl.password()).isEqualTo("pass1@bar:pass2");
     assertThat(httpUrl).isEqualTo(parse("http://foo:pass1%40bar%3Apass2@baz/path"));
@@ -604,7 +607,7 @@ HttpUrl parse(String url) {
 
   /** The builder permits square braces but does not require them. */
   @Test public void hostIpv6Builder() throws Exception {
-    HttpUrl base = parse("http://example.com/");
+    WebUrl base = parse("http://example.com/");
     assertThat(base.newBuilder().host("[::1]").build().toString()).isEqualTo(
         "http://[::1]/");
     assertThat(base.newBuilder().host("[::0001]").build().toString()).isEqualTo(
@@ -671,7 +674,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void fragmentNonAscii() throws Exception {
-    HttpUrl url = parse("http://host/#Œ£");
+    WebUrl url = parse("http://host/#Œ£");
     assertThat(url.toString()).isEqualTo("http://host/#Œ£");
     assertThat(url.fragment()).isEqualTo("Œ£");
     assertThat(url.encodedFragment()).isEqualTo("Œ£");
@@ -679,7 +682,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void fragmentNonAsciiThatOffendsJavaNetUri() throws Exception {
-    HttpUrl url = parse("http://host/#\u0080");
+    WebUrl url = parse("http://host/#\u0080");
     assertThat(url.toString()).isEqualTo("http://host/#\u0080");
     assertThat(url.fragment()).isEqualTo("\u0080");
     assertThat(url.encodedFragment()).isEqualTo("\u0080");
@@ -688,7 +691,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void fragmentPercentEncodedNonAscii() throws Exception {
-    HttpUrl url = parse("http://host/#%C2%80");
+    WebUrl url = parse("http://host/#%C2%80");
     assertThat(url.toString()).isEqualTo("http://host/#%C2%80");
     assertThat(url.fragment()).isEqualTo("\u0080");
     assertThat(url.encodedFragment()).isEqualTo("%C2%80");
@@ -696,7 +699,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void fragmentPercentEncodedPartialCodePoint() throws Exception {
-    HttpUrl url = parse("http://host/#%80");
+    WebUrl url = parse("http://host/#%80");
     assertThat(url.toString()).isEqualTo("http://host/#%80");
     // Unicode replacement character.
     assertThat(url.fragment()).isEqualTo("\ufffd");
@@ -705,7 +708,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void relativePath() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
+    WebUrl base = parse("http://host/a/b/c");
     assertThat(base.resolve("d/e/f")).isEqualTo(parse("http://host/a/b/d/e/f"));
     assertThat(base.resolve("../../d/e/f")).isEqualTo(parse("http://host/d/e/f"));
     assertThat(base.resolve("..")).isEqualTo(parse("http://host/a/"));
@@ -727,7 +730,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void relativePathWithTrailingSlash() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c/");
+    WebUrl base = parse("http://host/a/b/c/");
     assertThat(base.resolve("..")).isEqualTo(parse("http://host/a/b/"));
     assertThat(base.resolve("../")).isEqualTo(parse("http://host/a/b/"));
     assertThat(base.resolve("../..")).isEqualTo(parse("http://host/a/"));
@@ -742,14 +745,14 @@ HttpUrl parse(String url) {
   }
 
   @Test public void pathWithBackslash() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
+    WebUrl base = parse("http://host/a/b/c");
     assertThat(base.resolve("d\\e\\f")).isEqualTo(parse("http://host/a/b/d/e/f"));
     assertThat(base.resolve("../..\\d\\e\\f")).isEqualTo(parse("http://host/d/e/f"));
     assertThat(base.resolve("..\\..")).isEqualTo(parse("http://host/"));
   }
 
   @Test public void relativePathWithSameScheme() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
+    WebUrl base = parse("http://host/a/b/c");
     assertThat(base.resolve("http:d/e/f")).isEqualTo(parse("http://host/a/b/d/e/f"));
     assertThat(base.resolve("http:../../d/e/f")).isEqualTo(parse("http://host/d/e/f"));
   }
@@ -806,13 +809,13 @@ HttpUrl parse(String url) {
 
   @Test public void incompleteUrlComposition() throws Exception {
     try {
-      new HttpUrl.Builder().scheme("http").build();
+      new Builder().scheme("http").build();
       fail();
     } catch (IllegalStateException expected) {
       assertThat(expected.getMessage()).isEqualTo("host == null");
     }
     try {
-      new HttpUrl.Builder().host("host").build();
+      new Builder().host("host").build();
       fail();
     } catch (IllegalStateException expected) {
       assertThat(expected.getMessage()).isEqualTo("scheme == null");
@@ -825,17 +828,17 @@ HttpUrl parse(String url) {
   }
 
   @Test public void incompleteBuilderToString() {
-    assertThat(new HttpUrl.Builder().scheme("https").encodedPath("/path").toString()).isEqualTo(
+    assertThat(new Builder().scheme("https").encodedPath("/path").toString()).isEqualTo(
         "https:///path");
-    assertThat(new HttpUrl.Builder().host("host.com").encodedPath("/path").toString()).isEqualTo(
+    assertThat(new Builder().host("host.com").encodedPath("/path").toString()).isEqualTo(
         "//host.com/path");
     assertThat(
-        (Object) new HttpUrl.Builder().host("host.com").encodedPath("/path").port(8080).toString()).isEqualTo(
+        (Object) new Builder().host("host.com").encodedPath("/path").port(8080).toString()).isEqualTo(
         "//host.com:8080/path");
   }
 
   @Test public void minimalUrlComposition() throws Exception {
-    HttpUrl url = new HttpUrl.Builder().scheme("http").host("host").build();
+    WebUrl url = new Builder().scheme("http").host("host").build();
     assertThat(url.toString()).isEqualTo("http://host/");
     assertThat(url.scheme()).isEqualTo("http");
     assertThat(url.username()).isEqualTo("");
@@ -848,7 +851,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void fullUrlComposition() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
+    WebUrl url = new Builder()
         .scheme("http")
         .username("username")
         .password("password")
@@ -888,7 +891,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void composeEncodesWhitespace() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
+    WebUrl url = new Builder()
         .scheme("http")
         .username("a\r\n\f\t b")
         .password("c\r\n\f\t d")
@@ -907,7 +910,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void composeFromUnencodedComponents() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
+    WebUrl url = new Builder()
         .scheme("http")
         .username("a:\u0001@/\\?#%b")
         .password("c:\u0001@/\\?#%d")
@@ -934,7 +937,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void composeFromEncodedComponents() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
+    WebUrl url = new Builder()
         .scheme("http")
         .encodedUsername("a:\u0001@/\\?#%25b")
         .encodedPassword("c:\u0001@/\\?#%25d")
@@ -961,7 +964,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void composeWithEncodedPath() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
+    WebUrl url = new Builder()
         .scheme("http")
         .host("host")
         .encodedPath("/a%2Fb/c")
@@ -972,7 +975,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void composeMixingPathSegments() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
+    WebUrl url = new Builder()
         .scheme("http")
         .host("host")
         .encodedPath("/a%2fb/c")
@@ -987,7 +990,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void composeWithAddSegment() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
+    WebUrl base = parse("http://host/a/b/c");
     assertThat(base.newBuilder().addPathSegment("").build().encodedPath()).isEqualTo(
         "/a/b/c/");
     assertThat(
@@ -1007,7 +1010,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void addPathSegments() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
+    WebUrl base = parse("http://host/a/b/c");
 
     // Add a string with zero slashes: resulting URL gains one slash.
     assertThat(base.newBuilder().addPathSegments("").build().encodedPath()).isEqualTo(
@@ -1037,7 +1040,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void addPathSegmentsOntoTrailingSlash() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c/");
+    WebUrl base = parse("http://host/a/b/c/");
 
     // Add a string with zero slashes: resulting URL gains zero slashes.
     assertThat(base.newBuilder().addPathSegments("").build().encodedPath()).isEqualTo(
@@ -1067,7 +1070,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void addPathSegmentsWithBackslash() throws Exception {
-    HttpUrl base = parse("http://host/");
+    WebUrl base = parse("http://host/");
     assertThat(base.newBuilder().addPathSegments("d\\e").build().encodedPath()).isEqualTo(
         "/d/e");
     assertThat(base.newBuilder().addEncodedPathSegments("d\\e").build().encodedPath()).isEqualTo(
@@ -1075,26 +1078,26 @@ HttpUrl parse(String url) {
   }
 
   @Test public void addPathSegmentsWithEmptyPaths() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
+    WebUrl base = parse("http://host/a/b/c");
     assertThat(base.newBuilder().addPathSegments("/d/e///f").build().encodedPath()).isEqualTo(
         "/a/b/c//d/e///f");
   }
 
   @Test public void addEncodedPathSegments() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
+    WebUrl base = parse("http://host/a/b/c");
     assertThat(
         (Object) base.newBuilder().addEncodedPathSegments("d/e/%20/\n").build().encodedPath()).isEqualTo(
         "/a/b/c/d/e/%20/");
   }
 
   @Test public void addPathSegmentDotDoesNothing() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
+    WebUrl base = parse("http://host/a/b/c");
     assertThat(base.newBuilder().addPathSegment(".").build().encodedPath()).isEqualTo(
         "/a/b/c");
   }
 
   @Test public void addPathSegmentEncodes() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
+    WebUrl base = parse("http://host/a/b/c");
     assertThat(base.newBuilder().addPathSegment("%2e").build().encodedPath()).isEqualTo(
         "/a/b/c/%252e");
     assertThat(base.newBuilder().addPathSegment("%2e%2e").build().encodedPath()).isEqualTo(
@@ -1102,31 +1105,31 @@ HttpUrl parse(String url) {
   }
 
   @Test public void addPathSegmentDotDotPopsDirectory() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
+    WebUrl base = parse("http://host/a/b/c");
     assertThat(base.newBuilder().addPathSegment("..").build().encodedPath()).isEqualTo(
         "/a/b/");
   }
 
   @Test public void addPathSegmentDotAndIgnoredCharacter() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
+    WebUrl base = parse("http://host/a/b/c");
     assertThat(base.newBuilder().addPathSegment(".\n").build().encodedPath()).isEqualTo(
         "/a/b/c/.%0A");
   }
 
   @Test public void addEncodedPathSegmentDotAndIgnoredCharacter() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
+    WebUrl base = parse("http://host/a/b/c");
     assertThat(base.newBuilder().addEncodedPathSegment(".\n").build().encodedPath()).isEqualTo(
         "/a/b/c");
   }
 
   @Test public void addEncodedPathSegmentDotDotAndIgnoredCharacter() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
+    WebUrl base = parse("http://host/a/b/c");
     assertThat(base.newBuilder().addEncodedPathSegment("..\n").build().encodedPath()).isEqualTo(
         "/a/b/");
   }
 
   @Test public void setPathSegment() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
+    WebUrl base = parse("http://host/a/b/c");
     assertThat(base.newBuilder().setPathSegment(0, "d").build().encodedPath()).isEqualTo(
         "/d/b/c");
     assertThat(base.newBuilder().setPathSegment(1, "d").build().encodedPath()).isEqualTo(
@@ -1136,7 +1139,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void setPathSegmentEncodes() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
+    WebUrl base = parse("http://host/a/b/c");
     assertThat(base.newBuilder().setPathSegment(0, "%25").build().encodedPath()).isEqualTo(
         "/%2525/b/c");
     assertThat(base.newBuilder().setPathSegment(0, ".\n").build().encodedPath()).isEqualTo(
@@ -1146,7 +1149,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void setPathSegmentAcceptsEmpty() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
+    WebUrl base = parse("http://host/a/b/c");
     assertThat(base.newBuilder().setPathSegment(0, "").build().encodedPath()).isEqualTo(
         "//b/c");
     assertThat(base.newBuilder().setPathSegment(2, "").build().encodedPath()).isEqualTo(
@@ -1154,7 +1157,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void setPathSegmentRejectsDot() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
+    WebUrl base = parse("http://host/a/b/c");
     try {
       base.newBuilder().setPathSegment(0, ".");
       fail();
@@ -1163,7 +1166,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void setPathSegmentRejectsDotDot() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
+    WebUrl base = parse("http://host/a/b/c");
     try {
       base.newBuilder().setPathSegment(0, "..");
       fail();
@@ -1172,27 +1175,27 @@ HttpUrl parse(String url) {
   }
 
   @Test public void setPathSegmentWithSlash() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    HttpUrl url = base.newBuilder().setPathSegment(1, "/").build();
+    WebUrl base = parse("http://host/a/b/c");
+    WebUrl url = base.newBuilder().setPathSegment(1, "/").build();
     assertThat(url.encodedPath()).isEqualTo("/a/%2F/c");
   }
 
   @Test public void setPathSegmentOutOfBounds() throws Exception {
     try {
-      new HttpUrl.Builder().setPathSegment(1, "a");
+      new Builder().setPathSegment(1, "a");
       fail();
     } catch (IndexOutOfBoundsException expected) {
     }
   }
 
   @Test public void setEncodedPathSegmentEncodes() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
+    WebUrl base = parse("http://host/a/b/c");
     assertThat(base.newBuilder().setEncodedPathSegment(0, "%25").build().encodedPath()).isEqualTo(
         "/%25/b/c");
   }
 
   @Test public void setEncodedPathSegmentRejectsDot() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
+    WebUrl base = parse("http://host/a/b/c");
     try {
       base.newBuilder().setEncodedPathSegment(0, ".");
       fail();
@@ -1201,7 +1204,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void setEncodedPathSegmentRejectsDotAndIgnoredCharacter() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
+    WebUrl base = parse("http://host/a/b/c");
     try {
       base.newBuilder().setEncodedPathSegment(0, ".\n");
       fail();
@@ -1210,7 +1213,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void setEncodedPathSegmentRejectsDotDot() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
+    WebUrl base = parse("http://host/a/b/c");
     try {
       base.newBuilder().setEncodedPathSegment(0, "..");
       fail();
@@ -1219,7 +1222,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void setEncodedPathSegmentRejectsDotDotAndIgnoredCharacter() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
+    WebUrl base = parse("http://host/a/b/c");
     try {
       base.newBuilder().setEncodedPathSegment(0, "..\n");
       fail();
@@ -1228,30 +1231,30 @@ HttpUrl parse(String url) {
   }
 
   @Test public void setEncodedPathSegmentWithSlash() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    HttpUrl url = base.newBuilder().setEncodedPathSegment(1, "/").build();
+    WebUrl base = parse("http://host/a/b/c");
+    WebUrl url = base.newBuilder().setEncodedPathSegment(1, "/").build();
     assertThat(url.encodedPath()).isEqualTo("/a/%2F/c");
   }
 
   @Test public void setEncodedPathSegmentOutOfBounds() throws Exception {
     try {
-      new HttpUrl.Builder().setEncodedPathSegment(1, "a");
+      new Builder().setEncodedPathSegment(1, "a");
       fail();
     } catch (IndexOutOfBoundsException expected) {
     }
   }
 
   @Test public void removePathSegment() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    HttpUrl url = base.newBuilder()
+    WebUrl base = parse("http://host/a/b/c");
+    WebUrl url = base.newBuilder()
         .removePathSegment(0)
         .build();
     assertThat(url.encodedPath()).isEqualTo("/b/c");
   }
 
   @Test public void removePathSegmentDoesntRemovePath() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    HttpUrl url = base.newBuilder()
+    WebUrl base = parse("http://host/a/b/c");
+    WebUrl url = base.newBuilder()
         .removePathSegment(0)
         .removePathSegment(0)
         .removePathSegment(0)
@@ -1262,34 +1265,34 @@ HttpUrl parse(String url) {
 
   @Test public void removePathSegmentOutOfBounds() throws Exception {
     try {
-      new HttpUrl.Builder().removePathSegment(1);
+      new Builder().removePathSegment(1);
       fail();
     } catch (IndexOutOfBoundsException expected) {
     }
   }
 
   @Test public void toJavaNetUrl() throws Exception {
-    HttpUrl httpUrl = parse("http://username:password@host/path?query#fragment");
+    WebUrl httpUrl = parse("http://username:password@host/path?query#fragment");
     URL javaNetUrl = httpUrl.url();
     assertThat(javaNetUrl.toString()).isEqualTo(
         "http://username:password@host/path?query#fragment");
   }
 
   @Test public void toUri() throws Exception {
-    HttpUrl httpUrl = parse("http://username:password@host/path?query#fragment");
+    WebUrl httpUrl = parse("http://username:password@host/path?query#fragment");
     URI uri = httpUrl.uri();
     assertThat(uri.toString()).isEqualTo(
         "http://username:password@host/path?query#fragment");
   }
 
   @Test public void toUriSpecialQueryCharacters() throws Exception {
-    HttpUrl httpUrl = parse("http://host/?d=abc!@[]^`{}|\\");
+    WebUrl httpUrl = parse("http://host/?d=abc!@[]^`{}|\\");
     URI uri = httpUrl.uri();
     assertThat(uri.toString()).isEqualTo("http://host/?d=abc!@[]%5E%60%7B%7D%7C%5C");
   }
 
   @Test public void toUriWithUsernameNoPassword() throws Exception {
-    HttpUrl httpUrl = new HttpUrl.Builder()
+    WebUrl httpUrl = new Builder()
         .scheme("http")
         .username("user")
         .host("host")
@@ -1299,7 +1302,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void toUriUsernameSpecialCharacters() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
+    WebUrl url = new Builder()
         .scheme("http")
         .host("host")
         .username("=[]:;\"~|?#@^/$%*")
@@ -1311,7 +1314,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void toUriPasswordSpecialCharacters() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
+    WebUrl url = new Builder()
         .scheme("http")
         .host("host")
         .username("user")
@@ -1324,7 +1327,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void toUriPathSpecialCharacters() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
+    WebUrl url = new Builder()
         .scheme("http")
         .host("host")
         .addPathSegment("=[]:;\"~|?#@^/$%*")
@@ -1335,7 +1338,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void toUriQueryParameterNameSpecialCharacters() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
+    WebUrl url = new Builder()
         .scheme("http")
         .host("host")
         .addQueryParameter("=[]:;\"~|?#@^/$%*", "a")
@@ -1348,7 +1351,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void toUriQueryParameterValueSpecialCharacters() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
+    WebUrl url = new Builder()
         .scheme("http")
         .host("host")
         .addQueryParameter("a", "=[]:;\"~|?#@^/$%*")
@@ -1361,7 +1364,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void toUriQueryValueSpecialCharacters() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
+    WebUrl url = new Builder()
         .scheme("http")
         .host("host")
         .query("=[]:;\"~|?#@^/$%*")
@@ -1371,7 +1374,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void queryCharactersEncodedWhenComposed() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
+    WebUrl url = new Builder()
         .scheme("http")
         .host("host")
         .addQueryParameter("a", "!$(),/:;?@[]\\^`{|}~")
@@ -1386,7 +1389,7 @@ HttpUrl parse(String url) {
    * We retain the encoded (or non-encoded) state of the input.
    */
   @Test public void queryCharactersNotReencodedWhenComposedWithAddEncoded() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
+    WebUrl url = new Builder()
         .scheme("http")
         .host("host")
         .addEncodedQueryParameter("a", "!$(),/:;?@[]\\^`{|}~")
@@ -1400,13 +1403,13 @@ HttpUrl parse(String url) {
    * into a canonical form because doing so could be semantically different.
    */
   @Test public void queryCharactersNotReencodedWhenParsed() throws Exception {
-    HttpUrl url = parse("http://host/?a=!$(),/:;?@[]\\^`{|}~");
+    WebUrl url = parse("http://host/?a=!$(),/:;?@[]\\^`{|}~");
     assertThat(url.toString()).isEqualTo("http://host/?a=!$(),/:;?@[]\\^`{|}~");
     assertThat(url.queryParameter("a")).isEqualTo("!$(),/:;?@[]\\^`{|}~");
   }
 
   @Test public void toUriFragmentSpecialCharacters() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
+    WebUrl url = new Builder()
         .scheme("http")
         .host("host")
         .fragment("=[]:;\"~|?#@^/$%*")
@@ -1471,36 +1474,36 @@ HttpUrl parse(String url) {
 
   @Test public void fromJavaNetUrl() throws Exception {
     URL javaNetUrl = new URL("http://username:password@host/path?query#fragment");
-    HttpUrl httpUrl = HttpUrl.get(javaNetUrl);
+    WebUrl httpUrl = WebUrl.get(javaNetUrl);
     assertThat(httpUrl.toString()).isEqualTo(
         "http://username:password@host/path?query#fragment");
   }
 
   @Test public void fromJavaNetUrlUnsupportedScheme() throws Exception {
     URL javaNetUrl = new URL("mailto:user@example.com");
-    assertThat(HttpUrl.get(javaNetUrl)).isNull();
+    assertThat(WebUrl.get(javaNetUrl)).isNull();
   }
 
   @Test public void fromUri() throws Exception {
     URI uri = new URI("http://username:password@host/path?query#fragment");
-    HttpUrl httpUrl = HttpUrl.get(uri);
+    WebUrl httpUrl = WebUrl.get(uri);
     assertThat(httpUrl.toString()).isEqualTo(
         "http://username:password@host/path?query#fragment");
   }
 
   @Test public void fromUriUnsupportedScheme() throws Exception {
     URI uri = new URI("mailto:user@example.com");
-    assertThat(HttpUrl.get(uri)).isNull();
+    assertThat(WebUrl.get(uri)).isNull();
   }
 
   @Test public void fromUriPartial() throws Exception {
     URI uri = new URI("/path");
-    assertThat(HttpUrl.get(uri)).isNull();
+    assertThat(WebUrl.get(uri)).isNull();
   }
 
   @Test public void composeQueryWithComponents() throws Exception {
-    HttpUrl base = parse("http://host/");
-    HttpUrl url = base.newBuilder().addQueryParameter("a+=& b", "c+=& d").build();
+    WebUrl base = parse("http://host/");
+    WebUrl url = base.newBuilder().addQueryParameter("a+=& b", "c+=& d").build();
     assertThat(url.toString()).isEqualTo("http://host/?a%2B%3D%26%20b=c%2B%3D%26%20d");
     assertThat(url.queryParameterValue(0)).isEqualTo("c+=& d");
     assertThat(url.queryParameterName(0)).isEqualTo("a+=& b");
@@ -1514,14 +1517,14 @@ HttpUrl parse(String url) {
   }
 
   @Test public void composeQueryWithEncodedComponents() throws Exception {
-    HttpUrl base = parse("http://host/");
-    HttpUrl url = base.newBuilder().addEncodedQueryParameter("a+=& b", "c+=& d").build();
+    WebUrl base = parse("http://host/");
+    WebUrl url = base.newBuilder().addEncodedQueryParameter("a+=& b", "c+=& d").build();
     assertThat(url.toString()).isEqualTo("http://host/?a+%3D%26%20b=c+%3D%26%20d");
     assertThat(url.queryParameter("a =& b")).isEqualTo("c =& d");
   }
 
   @Test public void composeQueryRemoveQueryParameter() throws Exception {
-    HttpUrl url = parse("http://host/").newBuilder()
+    WebUrl url = parse("http://host/").newBuilder()
         .addQueryParameter("a+=& b", "c+=& d")
         .removeAllQueryParameters("a+=& b")
         .build();
@@ -1530,7 +1533,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void composeQueryRemoveEncodedQueryParameter() throws Exception {
-    HttpUrl url = parse("http://host/").newBuilder()
+    WebUrl url = parse("http://host/").newBuilder()
         .addEncodedQueryParameter("a+=& b", "c+=& d")
         .removeAllEncodedQueryParameters("a+=& b")
         .build();
@@ -1539,7 +1542,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void composeQuerySetQueryParameter() throws Exception {
-    HttpUrl url = parse("http://host/").newBuilder()
+    WebUrl url = parse("http://host/").newBuilder()
         .addQueryParameter("a+=& b", "c+=& d")
         .setQueryParameter("a+=& b", "ef")
         .build();
@@ -1548,7 +1551,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void composeQuerySetEncodedQueryParameter() throws Exception {
-    HttpUrl url = parse("http://host/").newBuilder()
+    WebUrl url = parse("http://host/").newBuilder()
         .addEncodedQueryParameter("a+=& b", "c+=& d")
         .setEncodedQueryParameter("a+=& b", "ef")
         .build();
@@ -1557,7 +1560,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void composeQueryMultipleEncodedValuesForParameter() throws Exception {
-    HttpUrl url = parse("http://host/").newBuilder()
+    WebUrl url = parse("http://host/").newBuilder()
         .addQueryParameter("a+=& b", "c+=& d")
         .addQueryParameter("a+=& b", "e+=& f")
         .build();
@@ -1570,14 +1573,14 @@ HttpUrl parse(String url) {
   }
 
   @Test public void absentQueryIsZeroNameValuePairs() throws Exception {
-    HttpUrl url = parse("http://host/").newBuilder()
+    WebUrl url = parse("http://host/").newBuilder()
         .query(null)
         .build();
     assertThat(url.querySize()).isEqualTo(0);
   }
 
   @Test public void emptyQueryIsSingleNameValuePairWithEmptyKey() throws Exception {
-    HttpUrl url = parse("http://host/").newBuilder()
+    WebUrl url = parse("http://host/").newBuilder()
         .query("")
         .build();
     assertThat(url.querySize()).isEqualTo(1);
@@ -1586,7 +1589,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void ampersandQueryIsTwoNameValuePairsWithEmptyKeys() throws Exception {
-    HttpUrl url = parse("http://host/").newBuilder()
+    WebUrl url = parse("http://host/").newBuilder()
         .query("&")
         .build();
     assertThat(url.querySize()).isEqualTo(2);
@@ -1597,7 +1600,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void removeAllDoesNotRemoveQueryIfNoParametersWereRemoved() throws Exception {
-    HttpUrl url = parse("http://host/").newBuilder()
+    WebUrl url = parse("http://host/").newBuilder()
         .query("")
         .removeAllQueryParameters("a")
         .build();
@@ -1605,7 +1608,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void queryParametersWithoutValues() throws Exception {
-    HttpUrl url = parse("http://host/?foo&bar&baz");
+    WebUrl url = parse("http://host/?foo&bar&baz");
     assertThat(url.querySize()).isEqualTo(3);
     assertThat(url.queryParameterNames()).isEqualTo(
         new LinkedHashSet<>(Arrays.asList("foo", "bar", "baz")));
@@ -1618,7 +1621,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void queryParametersWithEmptyValues() throws Exception {
-    HttpUrl url = parse("http://host/?foo=&bar=&baz=");
+    WebUrl url = parse("http://host/?foo=&bar=&baz=");
     assertThat(url.querySize()).isEqualTo(3);
     assertThat(url.queryParameterNames()).isEqualTo(
         new LinkedHashSet<>(Arrays.asList("foo", "bar", "baz")));
@@ -1631,7 +1634,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void queryParametersWithRepeatedName() throws Exception {
-    HttpUrl url = parse("http://host/?foo[]=1&foo[]=2&foo[]=3");
+    WebUrl url = parse("http://host/?foo[]=1&foo[]=2&foo[]=3");
     assertThat(url.querySize()).isEqualTo(3);
     assertThat(url.queryParameterNames()).isEqualTo(Collections.singleton("foo[]"));
     assertThat(url.queryParameterValue(0)).isEqualTo("1");
@@ -1641,7 +1644,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void queryParameterLookupWithNonCanonicalEncoding() throws Exception {
-    HttpUrl url = parse("http://host/?%6d=m&+=%20");
+    WebUrl url = parse("http://host/?%6d=m&+=%20");
     assertThat(url.queryParameterName(0)).isEqualTo("m");
     assertThat(url.queryParameterName(1)).isEqualTo(" ");
     assertThat(url.queryParameter("m")).isEqualTo("m");
@@ -1649,14 +1652,14 @@ HttpUrl parse(String url) {
   }
 
   @Test public void parsedQueryDoesntIncludeFragment() {
-    HttpUrl url = parse("http://host/?#fragment");
+    WebUrl url = parse("http://host/?#fragment");
     assertThat(url.fragment()).isEqualTo("fragment");
     assertThat(url.query()).isEqualTo("");
     assertThat(url.encodedQuery()).isEqualTo("");
   }
 
   @Test public void roundTripBuilder() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
+    WebUrl url = new Builder()
         .scheme("http")
         .username("%")
         .password("%")
@@ -1672,12 +1675,12 @@ HttpUrl parse(String url) {
   }
 
   /**
-   * Although HttpUrl prefers percent-encodings in uppercase, it should preserve the exact structure
+   * Although WebUrl prefers percent-encodings in uppercase, it should preserve the exact structure
    * of the original encoding.
    */
   @Test public void rawEncodingRetained() throws Exception {
     String urlString = "http://%6d%6D:%6d%6D@host/%6d%6D?%6d%6D#%6d%6D";
-    HttpUrl url = parse(urlString);
+    WebUrl url = parse(urlString);
     assertThat(url.encodedUsername()).isEqualTo("%6d%6D");
     assertThat(url.encodedPassword()).isEqualTo("%6d%6D");
     assertThat(url.encodedPath()).isEqualTo("/%6d%6D");
@@ -1691,7 +1694,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void clearFragment() throws Exception {
-    HttpUrl url = parse("http://host/#fragment")
+    WebUrl url = parse("http://host/#fragment")
         .newBuilder()
         .fragment(null)
         .build();
@@ -1701,7 +1704,7 @@ HttpUrl parse(String url) {
   }
 
   @Test public void clearEncodedFragment() throws Exception {
-    HttpUrl url = parse("http://host/#fragment")
+    WebUrl url = parse("http://host/#fragment")
         .newBuilder()
         .encodedFragment(null)
         .build();
diff --git a/website/index.html b/website/index.html
deleted file mode 100644
index 6da9861707..0000000000
--- a/website/index.html
+++ /dev/null
@@ -1,227 +0,0 @@
-<!DOCTYPE html>
-<html lang="en">
-  <head>
-    <meta charset="utf-8">
-    <title>OkHttp</title>
-    <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <meta name="description" content="An HTTP &amp; HTTP/2 client for Android and Java applications">
-    <link href="static/bootstrap-combined.min.css" rel="stylesheet">
-    <link href="static/app.css" rel="stylesheet">
-    <link href="static/app-theme.css" rel="stylesheet">
-    <link href="https://fonts.googleapis.com/css?family=Roboto:400,300italic,100,100italic,300" rel="stylesheet" type="text/css">
-    <!--[if lt IE 9]><script src="static/html5shiv.min.js"></script><![endif]-->
-  </head>
-  <body data-target=".content-nav">
-    <header>
-      <div class="container">
-        <div class="row">
-          <div class="span5">
-            <h1>OkHttp</h1>
-          </div>
-          <div class="span7">
-            <menu>
-              <ul>
-                <li><a href="#download" class="menu download">Download <span class="version-tag">Latest</span></a></li>
-                <li><a href="https://github.com/square/okhttp" data-title="View GitHub Project" class="menu github"><img src="static/icon-github.png" alt="GitHub"/></a></li>
-                <li><a href="https://square.github.io/" data-title="Square Open Source Portal" class="menu square"><img src="static/icon-square.png" alt="Square"/></a></li>
-              </ul>
-            </menu>
-          </div>
-        </div>
-      </div>
-    </header>
-    <section id="subtitle">
-      <div class="container">
-        <div class="row">
-          <div class="span12">
-            <h2>An <strong>HTTP &amp; HTTP/2</strong> client for Android and Java applications</h2>
-          </div>
-        </div>
-      </div>
-    </section>
-    <section id="body">
-      <div class="container">
-        <div class="row">
-          <div class="span9">
-            <h3 id="overview">Overview</h3>
-            <p>HTTP is the way modern applications network. It‚Äôs how we exchange data &amp; media.
-                Doing HTTP efficiently makes your stuff load faster and saves bandwidth.</p>
-
-            <p>OkHttp is an HTTP client that‚Äôs efficient by default:</p>
-            <ul>
-                <li>HTTP/2 support allows all requests to the same host to share a socket.</li>
-                <li>Connection pooling reduces request latency (if HTTP/2 isn‚Äôt available).</li>
-                <li>Transparent GZIP shrinks download sizes.</li>
-                <li>Response caching avoids the network completely for repeat requests.</li>
-            </ul>
-
-            <p>OkHttp perseveres when the network is troublesome: it will silently recover from
-                common connection problems. If your service has multiple IP addresses OkHttp will
-                attempt alternate addresses if the first connect fails. This is necessary for IPv4+IPv6
-                and for services hosted in redundant data centers. OkHttp supports modern TLS
-                features (TLS 1.3, ALPN, certificate pinning). It can be configured to fall back for
-                broad connectivity.</p>
-
-            <p>Using OkHttp is easy. Its request/response API is designed with fluent builders and
-                immutability. It supports both synchronous blocking calls and async calls with
-                callbacks.</p>
-
-            <p>OkHttp supports Android 5.0+ (API level 21+) and Java 8+.</p>
-
-            <h3 id="examples">Examples</h3>
-            <h4>Get a URL</h4>
-            <p>This program downloads a URL and prints its contents as a string. <a href="https://raw.github.com/square/okhttp/master/samples/guide/src/main/java/okhttp3/guide/GetExample.java">Full source</a>.
-<pre class="prettyprint">
-OkHttpClient client = new OkHttpClient();
-
-String run(String url) throws IOException {
-  Request request = new Request.Builder()
-      .url(url)
-      .build();
-
-  try (Response response = client.newCall(request).execute()) {
-    return response.body().string();
-  }
-}
-</pre>
-            <h4>Post to a Server</h4>
-            <p>This program posts data to a service. <a href="https://raw.github.com/square/okhttp/master/samples/guide/src/main/java/okhttp3/guide/PostExample.java">Full source</a>.
-
-<pre class="prettyprint">
-public static final MediaType JSON
-    = MediaType.get("application/json; charset=utf-8");
-
-OkHttpClient client = new OkHttpClient();
-
-String post(String url, String json) throws IOException {
-  RequestBody body = RequestBody.create(JSON, json);
-  Request request = new Request.Builder()
-      .url(url)
-      .post(body)
-      .build();
-  try (Response response = client.newCall(request).execute()) {
-    return response.body().string();
-  }
-}
-</pre>
-
-            <h3 id="download">Download</h3>
-            <p><a href="https://search.maven.org/remote_content?g=com.squareup.okhttp3&a=okhttp&v=LATEST" class="dl version-href">&darr; <span class="version-tag">Latest</span> JAR</a></p>
-            <p>You'll also need <a href="https://github.com/square/okio">Okio</a>, which OkHttp
-                uses for fast I/O and resizable buffers. Download the
-                <a href="https://search.maven.org/remote_content?g=com.squareup.okio&a=okio&v=LATEST">latest JAR</a>.
-            <p>The source code to OkHttp, its samples, and this website is <a href="https://github.com/square/okhttp">available on GitHub</a>.</p>
-
-            <h4>Maven</h4>
-            <pre class="prettyprint">&lt;dependency>
-  &lt;groupId>com.squareup.okhttp3&lt;/groupId>
-  &lt;artifactId>okhttp&lt;/artifactId>
-  &lt;version><span class="version pln"><em>(insert latest version)</em></span>&lt;/version>
-&lt;/dependency></pre>
-
-            <h4>Gradle</h4>
-            <pre class="prettyprint">implementation 'com.squareup.okhttp3:okhttp:<span class="version pln"><em>(insert latest version)</em></span>'</pre>
-
-            <h3 id="contributing">Contributing</h3>
-            <p>If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request.</p>
-            <p>When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles by running <code>mvn clean verify</code>.</p>
-
-            <p>Some general advice</p>
-            <ul>
-                <li>Don‚Äôt change public API lightly, avoid if possible, and include your reasoning in the PR if essential. It causes pain for developers who use OkHttp and sometimes runtime errors.</li>
-                <li>Favour a working external library if appropriate. There are many examples of OkHttp libraries that can sit on top or hook in via existing APIs.</li>
-                <li>Get working code on a personal branch with tests before you submit a PR.</li>
-                <li>OkHttp is a small and light dependency. Don't introduce new dependencies or major new functionality.</li>
-                <li>OkHttp targets the intersection of RFC correct and widely implemented. Incorrect implementations that are very widely implemented e.g. a bug in Apache, Nginx, Google, Firefox should also be handled.</li>
-            </ul>
-
-            <p>Before your code can be accepted into the project you must also sign the <a href="https://squ.re/sign-the-cla">Individual Contributor License Agreement (CLA)</a>.</p>
-
-            <h3 id="license">License</h3>
-            <pre>Copyright 2016 Square, Inc.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-   http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.</pre>
-          </div>
-          <div class="span3">
-            <div class="content-nav" data-spy="affix" data-offset-top="80">
-              <ul class="nav nav-tabs nav-stacked primary">
-                <li><a href="#overview">Overview</a></li>
-                <li><a href="#examples">Examples</a></li>
-                <li><a href="#download">Download</a></li>
-                <li><a href="#contributing">Contributing</a></li>
-                <li><a href="#license">License</a></li>
-              </ul>
-              <ul class="nav nav-pills nav-stacked secondary">
-                <li><a href="3.x/okhttp/">Javadoc</a></li>
-                <li><a href="https://stackoverflow.com/questions/tagged/okhttp?sort=active">StackOverflow</a></li>
-              </ul>
-            </div>
-          </div>
-        </div>
-        <div class="row">
-          <div class="span12 logo">
-            <a href="https://squareup.com"><img src="static/logo-square.png" alt="Square, Inc."/></a>
-          </div>
-        </div>
-      </div>
-    </section>
-    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
-    <script src="static/bootstrap.min.js"></script>
-    <script src="static/jquery.smooth-scroll.min.js"></script>
-    <script src="static/jquery-maven-artifact.min.js"></script>
-    <script src="static/prettify.js"></script>
-    <script type="text/javascript">
-      $(function() {
-        // Syntax highlight code blocks.
-        prettyPrint();
-
-        // Spy on scroll position for real-time updating of current section.
-        $('body').scrollspy();
-
-        // Use smooth-scroll for internal links.
-        $('a').smoothScroll();
-
-        // Enable tooltips on the header nav image items.
-        $('.menu').tooltip({
-          placement: 'bottom',
-          trigger: 'hover',
-          container: 'body',
-          delay: {
-            show: 500,
-            hide: 0
-          }
-        });
-
-        // Look up the latest version of the library.
-        $.fn.artifactVersion({
-          'groupId': 'com.squareup.okhttp3',
-          'artifactId': 'okhttp'
-        }, function(version, url) {
-          $('.version').text(version);
-          $('.version-tag').text('v' + version);
-          $('.version-href').attr('href', url);
-        });
-      });
-
-      var _gaq = _gaq || [];
-      _gaq.push(['_setAccount', 'UA-40704740-2']);
-      _gaq.push(['_trackPageview']);
-
-      (function() {
-        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
-        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
-        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
-      })();
-    </script>
-  </body>
-</html>
diff --git a/website/static/app-theme.css b/website/static/app-theme.css
deleted file mode 100644
index d7d00c4a93..0000000000
--- a/website/static/app-theme.css
+++ /dev/null
@@ -1,51 +0,0 @@
-/* http://www.colorhexa.com/487fb9 */
-
-/*** Primary ***/
-
-header,
-#subtitle,
-a.dl {
-  background-color: #48b7b9;
-}
-
-.content-nav li.active a,
-.content-nav li.active a:hover {
-  border-left-color: #48b7b9;
-}
-
-/*** One step left on the monochromatic scale ***/
-
-header menu li a:hover,
-a.dl:hover {
-  background-color: #40a6a7;
-}
-a {
-  color: #40a6a7;
-}
-
-/*** Three steps left on the monochromatic scale ***/
-
-a:hover {
-  color: #328183;
-}
-
-
-/****************************************************************\
- **** Syntax highlighting styles ********************************
-\****************************************************************/
-
-.pln { color: #000; }
-.str { color: #399395; }
-.kwd { color: #666; }
-.com { color: #399395; }
-.typ { color: #222; }
-.lit { color: #666; }
-.pun { color: #888; }
-.opn { color: #888; }
-.clo { color: #888; }
-.tag { color: #399395; }
-.atn { color: #606; }
-.atv { color: #080; }
-.dec { color: #606; }
-.var { color: #606; }
-.fun { color: #f00; }
diff --git a/website/static/app.css b/website/static/app.css
deleted file mode 100644
index e3574b739d..0000000000
--- a/website/static/app.css
+++ /dev/null
@@ -1,188 +0,0 @@
-html, body {
-  font-family: 'Roboto', sans-serif;
-  font-size: 15px;
-}
-body {
-  background-color: #f6f6f6;
-  padding-bottom: 50px;
-  padding-top: 80px;
-}
-
-header {
-  min-height: 80px;
-  color: #f6f6f6;
-  position: fixed;
-  top: 0;
-  left: 0;
-  width: 100%;
-  z-index: 99;
-}
-header h1 {
-  margin: 10px 0;
-  font-size: 50px;
-  line-height: 60px;
-  font-weight: 100;
-  text-rendering: auto;
-}
-header menu {
-  margin: 20px 0 0;
-  padding: 0;
-  height: 40px;
-}
-header menu ul {
-  margin: 0;
-  padding: 0;
-  float: right;
-}
-header menu li {
-  list-style: none;
-  float: left;
-  margin: 0;
-  padding: 0;
-}
-header menu li a {
-  display: inline-block;
-  height: 40px;
-  font-size: 17px;
-  line-height: 40px;
-  padding: 0 20px;
-  color: #f6f6f6;
-}
-header menu li a:hover {
-  color: #f6f6f6;
-  text-decoration: none;
-}
-header menu li a img {
-  margin: 0;
-  padding: 5px 0;
-  vertical-align: bottom;
-  width: 30px;
-  height: 30px;
-}
-
-#subtitle {
-  position: absolute;
-  top: 80px;
-  left: 0;
-  width: 100%;
-}
-h2 {
-  font-weight: 200;
-  font-size: 26px;
-  line-height: 30px;
-  padding: 15px 0;
-  margin: 0;
-  color: #eee;
-}
-h2 strong {
-  font-weight: 300;
-}
-
-a.dl {
-  font-weight: 300;
-  font-size: 30px;
-  line-height: 40px;
-  padding: 3px 10px;
-  display: inline-block;
-  border-radius: 6px;
-  color: #f0f0f0;
-  margin: 5px 0;
-}
-a.dl:hover {
-  color: #f0f0f0;
-  text-decoration: none;
-}
-
-.content-nav {
-  margin-top: 130px;
-  width: 220px;
-}
-.content-nav.affix {
-  top: 0;
-}
-.content-nav li.active a, .content-nav li.active a:hover {
-  background-color: transparent;
-  color: #555;
-  border-left-width: 2px;
-}
-.content-nav .secondary a {
-  color: #aaa;
-}
-.content-nav .secondary a:hover {
-  color: #888;
-}
-
-h3 {
-  font-weight: 300;
-  font-style: italic;
-  color: #888;
-  font-size: 20px;
-  padding-top: 115px;
-  margin-top: 0;
-}
-
-h4 {
-  font-weight: 400;
-  text-transform: uppercase;
-  color: #888;
-  font-size: 15px;
-  padding-top: 20px;
-}
-
-p.license {
-  font-family: fixed-width;
-}
-
-.row .logo {
-  text-align: center;
-  margin-top: 150px;
-}
-.row .logo img {
-  height: 30px;
-}
-
-pre, code {
-  color: #666;
-}
-code {
-  border: 0;
-  background-color: transparent;
-}
-
-/* Widescreen desktop. */
-@media (min-width: 1200px) {
-  .content-nav {
-    width: 270px;
-  }
-}
-
-/* Smaller width browser, tablets. */
-@media (max-width: 979px) {
-  .content-nav {
-    width: 166px;
-  }
-}
-
-/* One-column mobile display. */
-@media (max-width: 767px) {
-  header {
-    position: absolute;
-    top: 0;
-    left: 0;
-    width: 100%;
-    padding-left: 20px;
-  }
-  header menu {
-    display: none;
-  }
-  #subtitle {
-    position: absolute;
-    top: 80px;
-    left: 0;
-    width: 100%;
-    padding-left: 20px;
-  }
-  .content-nav {
-    display: none;
-  }
-}
\ No newline at end of file
diff --git a/website/static/bootstrap-combined.min.css b/website/static/bootstrap-combined.min.css
deleted file mode 100644
index 1334dfa697..0000000000
--- a/website/static/bootstrap-combined.min.css
+++ /dev/null
@@ -1,18 +0,0 @@
-/*!
- * Bootstrap v2.3.1
- *
- * Copyright 2012 Twitter, Inc
- * Licensed under the Apache License v2.0
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Designed and built with all the love in the world @twitter by @mdo and @fat.
- */.clearfix{*zoom:1}.clearfix:before,.clearfix:after{display:table;line-height:0;content:""}.clearfix:after{clear:both}.hide-text{font:0/0 a;color:transparent;text-shadow:none;background-color:transparent;border:0}.input-block-level{display:block;width:100%;min-height:30px;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}article,aside,details,figcaption,figure,footer,header,hgroup,nav,section{display:block}audio,canvas,video{display:inline-block;*display:inline;*zoom:1}audio:not([controls]){display:none}html{font-size:100%;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%}a:focus{outline:thin dotted #333;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}a:hover,a:active{outline:0}sub,sup{position:relative;font-size:75%;line-height:0;vertical-align:baseline}sup{top:-0.5em}sub{bottom:-0.25em}img{width:auto\9;height:auto;max-width:100%;vertical-align:middle;border:0;-ms-interpolation-mode:bicubic}#map_canvas img,.google-maps img{max-width:none}button,input,select,textarea{margin:0;font-size:100%;vertical-align:middle}button,input{*overflow:visible;line-height:normal}button::-moz-focus-inner,input::-moz-focus-inner{padding:0;border:0}button,html input[type="button"],input[type="reset"],input[type="submit"]{cursor:pointer;-webkit-appearance:button}label,select,button,input[type="button"],input[type="reset"],input[type="submit"],input[type="radio"],input[type="checkbox"]{cursor:pointer}input[type="search"]{-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;-webkit-appearance:textfield}input[type="search"]::-webkit-search-decoration,input[type="search"]::-webkit-search-cancel-button{-webkit-appearance:none}textarea{overflow:auto;vertical-align:top}@media print{*{color:#000!important;text-shadow:none!important;background:transparent!important;box-shadow:none!important}a,a:visited{text-decoration:underline}a[href]:after{content:" (" attr(href) ")"}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100%!important}@page{margin:.5cm}p,h2,h3{orphans:3;widows:3}h2,h3{page-break-after:avoid}}body{margin:0;font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;font-size:14px;line-height:20px;color:#333;background-color:#fff}a{color:#08c;text-decoration:none}a:hover,a:focus{color:#005580;text-decoration:underline}.img-rounded{-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px}.img-polaroid{padding:4px;background-color:#fff;border:1px solid #ccc;border:1px solid rgba(0,0,0,0.2);-webkit-box-shadow:0 1px 3px rgba(0,0,0,0.1);-moz-box-shadow:0 1px 3px rgba(0,0,0,0.1);box-shadow:0 1px 3px rgba(0,0,0,0.1)}.img-circle{-webkit-border-radius:500px;-moz-border-radius:500px;border-radius:500px}.row{margin-left:-20px;*zoom:1}.row:before,.row:after{display:table;line-height:0;content:""}.row:after{clear:both}[class*="span"]{float:left;min-height:1px;margin-left:20px}.container,.navbar-static-top .container,.navbar-fixed-top .container,.navbar-fixed-bottom .container{width:940px}.span12{width:940px}.span11{width:860px}.span10{width:780px}.span9{width:700px}.span8{width:620px}.span7{width:540px}.span6{width:460px}.span5{width:380px}.span4{width:300px}.span3{width:220px}.span2{width:140px}.span1{width:60px}.offset12{margin-left:980px}.offset11{margin-left:900px}.offset10{margin-left:820px}.offset9{margin-left:740px}.offset8{margin-left:660px}.offset7{margin-left:580px}.offset6{margin-left:500px}.offset5{margin-left:420px}.offset4{margin-left:340px}.offset3{margin-left:260px}.offset2{margin-left:180px}.offset1{margin-left:100px}.row-fluid{width:100%;*zoom:1}.row-fluid:before,.row-fluid:after{display:table;line-height:0;content:""}.row-fluid:after{clear:both}.row-fluid [class*="span"]{display:block;float:left;width:100%;min-height:30px;margin-left:2.127659574468085%;*margin-left:2.074468085106383%;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}.row-fluid [class*="span"]:first-child{margin-left:0}.row-fluid .controls-row [class*="span"]+[class*="span"]{margin-left:2.127659574468085%}.row-fluid .span12{width:100%;*width:99.94680851063829%}.row-fluid .span11{width:91.48936170212765%;*width:91.43617021276594%}.row-fluid .span10{width:82.97872340425532%;*width:82.92553191489361%}.row-fluid .span9{width:74.46808510638297%;*width:74.41489361702126%}.row-fluid .span8{width:65.95744680851064%;*width:65.90425531914893%}.row-fluid .span7{width:57.44680851063829%;*width:57.39361702127659%}.row-fluid .span6{width:48.93617021276595%;*width:48.88297872340425%}.row-fluid .span5{width:40.42553191489362%;*width:40.37234042553192%}.row-fluid .span4{width:31.914893617021278%;*width:31.861702127659576%}.row-fluid .span3{width:23.404255319148934%;*width:23.351063829787233%}.row-fluid .span2{width:14.893617021276595%;*width:14.840425531914894%}.row-fluid .span1{width:6.382978723404255%;*width:6.329787234042553%}.row-fluid .offset12{margin-left:104.25531914893617%;*margin-left:104.14893617021275%}.row-fluid .offset12:first-child{margin-left:102.12765957446808%;*margin-left:102.02127659574467%}.row-fluid .offset11{margin-left:95.74468085106382%;*margin-left:95.6382978723404%}.row-fluid .offset11:first-child{margin-left:93.61702127659574%;*margin-left:93.51063829787232%}.row-fluid .offset10{margin-left:87.23404255319149%;*margin-left:87.12765957446807%}.row-fluid .offset10:first-child{margin-left:85.1063829787234%;*margin-left:84.99999999999999%}.row-fluid .offset9{margin-left:78.72340425531914%;*margin-left:78.61702127659572%}.row-fluid .offset9:first-child{margin-left:76.59574468085106%;*margin-left:76.48936170212764%}.row-fluid .offset8{margin-left:70.2127659574468%;*margin-left:70.10638297872339%}.row-fluid .offset8:first-child{margin-left:68.08510638297872%;*margin-left:67.9787234042553%}.row-fluid .offset7{margin-left:61.70212765957446%;*margin-left:61.59574468085106%}.row-fluid .offset7:first-child{margin-left:59.574468085106375%;*margin-left:59.46808510638297%}.row-fluid .offset6{margin-left:53.191489361702125%;*margin-left:53.085106382978715%}.row-fluid .offset6:first-child{margin-left:51.063829787234035%;*margin-left:50.95744680851063%}.row-fluid .offset5{margin-left:44.68085106382979%;*margin-left:44.57446808510638%}.row-fluid .offset5:first-child{margin-left:42.5531914893617%;*margin-left:42.4468085106383%}.row-fluid .offset4{margin-left:36.170212765957444%;*margin-left:36.06382978723405%}.row-fluid .offset4:first-child{margin-left:34.04255319148936%;*margin-left:33.93617021276596%}.row-fluid .offset3{margin-left:27.659574468085104%;*margin-left:27.5531914893617%}.row-fluid .offset3:first-child{margin-left:25.53191489361702%;*margin-left:25.425531914893618%}.row-fluid .offset2{margin-left:19.148936170212764%;*margin-left:19.04255319148936%}.row-fluid .offset2:first-child{margin-left:17.02127659574468%;*margin-left:16.914893617021278%}.row-fluid .offset1{margin-left:10.638297872340425%;*margin-left:10.53191489361702%}.row-fluid .offset1:first-child{margin-left:8.51063829787234%;*margin-left:8.404255319148938%}[class*="span"].hide,.row-fluid [class*="span"].hide{display:none}[class*="span"].pull-right,.row-fluid [class*="span"].pull-right{float:right}.container{margin-right:auto;margin-left:auto;*zoom:1}.container:before,.container:after{display:table;line-height:0;content:""}.container:after{clear:both}.container-fluid{padding-right:20px;padding-left:20px;*zoom:1}.container-fluid:before,.container-fluid:after{display:table;line-height:0;content:""}.container-fluid:after{clear:both}p{margin:0 0 10px}.lead{margin-bottom:20px;font-size:21px;font-weight:200;line-height:30px}small{font-size:85%}strong{font-weight:bold}em{font-style:italic}cite{font-style:normal}.muted{color:#999}a.muted:hover,a.muted:focus{color:#808080}.text-warning{color:#c09853}a.text-warning:hover,a.text-warning:focus{color:#a47e3c}.text-error{color:#b94a48}a.text-error:hover,a.text-error:focus{color:#953b39}.text-info{color:#3a87ad}a.text-info:hover,a.text-info:focus{color:#2d6987}.text-success{color:#468847}a.text-success:hover,a.text-success:focus{color:#356635}.text-left{text-align:left}.text-right{text-align:right}.text-center{text-align:center}h1,h2,h3,h4,h5,h6{margin:10px 0;font-family:inherit;font-weight:bold;line-height:20px;color:inherit;text-rendering:optimizelegibility}h1 small,h2 small,h3 small,h4 small,h5 small,h6 small{font-weight:normal;line-height:1;color:#999}h1,h2,h3{line-height:40px}h1{font-size:38.5px}h2{font-size:31.5px}h3{font-size:24.5px}h4{font-size:17.5px}h5{font-size:14px}h6{font-size:11.9px}h1 small{font-size:24.5px}h2 small{font-size:17.5px}h3 small{font-size:14px}h4 small{font-size:14px}.page-header{padding-bottom:9px;margin:20px 0 30px;border-bottom:1px solid #eee}ul,ol{padding:0;margin:0 0 10px 25px}ul ul,ul ol,ol ol,ol ul{margin-bottom:0}li{line-height:20px}ul.unstyled,ol.unstyled{margin-left:0;list-style:none}ul.inline,ol.inline{margin-left:0;list-style:none}ul.inline>li,ol.inline>li{display:inline-block;*display:inline;padding-right:5px;padding-left:5px;*zoom:1}dl{margin-bottom:20px}dt,dd{line-height:20px}dt{font-weight:bold}dd{margin-left:10px}.dl-horizontal{*zoom:1}.dl-horizontal:before,.dl-horizontal:after{display:table;line-height:0;content:""}.dl-horizontal:after{clear:both}.dl-horizontal dt{float:left;width:160px;overflow:hidden;clear:left;text-align:right;text-overflow:ellipsis;white-space:nowrap}.dl-horizontal dd{margin-left:180px}hr{margin:20px 0;border:0;border-top:1px solid #eee;border-bottom:1px solid #fff}abbr[title],abbr[data-original-title]{cursor:help;border-bottom:1px dotted #999}abbr.initialism{font-size:90%;text-transform:uppercase}blockquote{padding:0 0 0 15px;margin:0 0 20px;border-left:5px solid #eee}blockquote p{margin-bottom:0;font-size:17.5px;font-weight:300;line-height:1.25}blockquote small{display:block;line-height:20px;color:#999}blockquote small:before{content:'\2014 \00A0'}blockquote.pull-right{float:right;padding-right:15px;padding-left:0;border-right:5px solid #eee;border-left:0}blockquote.pull-right p,blockquote.pull-right small{text-align:right}blockquote.pull-right small:before{content:''}blockquote.pull-right small:after{content:'\00A0 \2014'}q:before,q:after,blockquote:before,blockquote:after{content:""}address{display:block;margin-bottom:20px;font-style:normal;line-height:20px}code,pre{padding:0 3px 2px;font-family:Monaco,Menlo,Consolas,"Courier New",monospace;font-size:12px;color:#333;-webkit-border-radius:3px;-moz-border-radius:3px;border-radius:3px}code{padding:2px 4px;color:#d14;white-space:nowrap;background-color:#f7f7f9;border:1px solid #e1e1e8}pre{display:block;padding:9.5px;margin:0 0 10px;font-size:13px;line-height:20px;word-break:break-all;word-wrap:break-word;white-space:pre;white-space:pre-wrap;background-color:#f5f5f5;border:1px solid #ccc;border:1px solid rgba(0,0,0,0.15);-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}pre.prettyprint{margin-bottom:20px}pre code{padding:0;color:inherit;white-space:pre;white-space:pre-wrap;background-color:transparent;border:0}.pre-scrollable{max-height:340px;overflow-y:scroll}form{margin:0 0 20px}fieldset{padding:0;margin:0;border:0}legend{display:block;width:100%;padding:0;margin-bottom:20px;font-size:21px;line-height:40px;color:#333;border:0;border-bottom:1px solid #e5e5e5}legend small{font-size:15px;color:#999}label,input,button,select,textarea{font-size:14px;font-weight:normal;line-height:20px}input,button,select,textarea{font-family:"Helvetica Neue",Helvetica,Arial,sans-serif}label{display:block;margin-bottom:5px}select,textarea,input[type="text"],input[type="password"],input[type="datetime"],input[type="datetime-local"],input[type="date"],input[type="month"],input[type="time"],input[type="week"],input[type="number"],input[type="email"],input[type="url"],input[type="search"],input[type="tel"],input[type="color"],.uneditable-input{display:inline-block;height:20px;padding:4px 6px;margin-bottom:10px;font-size:14px;line-height:20px;color:#555;vertical-align:middle;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}input,textarea,.uneditable-input{width:206px}textarea{height:auto}textarea,input[type="text"],input[type="password"],input[type="datetime"],input[type="datetime-local"],input[type="date"],input[type="month"],input[type="time"],input[type="week"],input[type="number"],input[type="email"],input[type="url"],input[type="search"],input[type="tel"],input[type="color"],.uneditable-input{background-color:#fff;border:1px solid #ccc;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);-webkit-transition:border linear .2s,box-shadow linear .2s;-moz-transition:border linear .2s,box-shadow linear .2s;-o-transition:border linear .2s,box-shadow linear .2s;transition:border linear .2s,box-shadow linear .2s}textarea:focus,input[type="text"]:focus,input[type="password"]:focus,input[type="datetime"]:focus,input[type="datetime-local"]:focus,input[type="date"]:focus,input[type="month"]:focus,input[type="time"]:focus,input[type="week"]:focus,input[type="number"]:focus,input[type="email"]:focus,input[type="url"]:focus,input[type="search"]:focus,input[type="tel"]:focus,input[type="color"]:focus,.uneditable-input:focus{border-color:rgba(82,168,236,0.8);outline:0;outline:thin dotted \9;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 8px rgba(82,168,236,0.6);-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 8px rgba(82,168,236,0.6);box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 8px rgba(82,168,236,0.6)}input[type="radio"],input[type="checkbox"]{margin:4px 0 0;margin-top:1px \9;*margin-top:0;line-height:normal}input[type="file"],input[type="image"],input[type="submit"],input[type="reset"],input[type="button"],input[type="radio"],input[type="checkbox"]{width:auto}select,input[type="file"]{height:30px;*margin-top:4px;line-height:30px}select{width:220px;background-color:#fff;border:1px solid #ccc}select[multiple],select[size]{height:auto}select:focus,input[type="file"]:focus,input[type="radio"]:focus,input[type="checkbox"]:focus{outline:thin dotted #333;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}.uneditable-input,.uneditable-textarea{color:#999;cursor:not-allowed;background-color:#fcfcfc;border-color:#ccc;-webkit-box-shadow:inset 0 1px 2px rgba(0,0,0,0.025);-moz-box-shadow:inset 0 1px 2px rgba(0,0,0,0.025);box-shadow:inset 0 1px 2px rgba(0,0,0,0.025)}.uneditable-input{overflow:hidden;white-space:nowrap}.uneditable-textarea{width:auto;height:auto}input:-moz-placeholder,textarea:-moz-placeholder{color:#999}input:-ms-input-placeholder,textarea:-ms-input-placeholder{color:#999}input::-webkit-input-placeholder,textarea::-webkit-input-placeholder{color:#999}.radio,.checkbox{min-height:20px;padding-left:20px}.radio input[type="radio"],.checkbox input[type="checkbox"]{float:left;margin-left:-20px}.controls>.radio:first-child,.controls>.checkbox:first-child{padding-top:5px}.radio.inline,.checkbox.inline{display:inline-block;padding-top:5px;margin-bottom:0;vertical-align:middle}.radio.inline+.radio.inline,.checkbox.inline+.checkbox.inline{margin-left:10px}.input-mini{width:60px}.input-small{width:90px}.input-medium{width:150px}.input-large{width:210px}.input-xlarge{width:270px}.input-xxlarge{width:530px}input[class*="span"],select[class*="span"],textarea[class*="span"],.uneditable-input[class*="span"],.row-fluid input[class*="span"],.row-fluid select[class*="span"],.row-fluid textarea[class*="span"],.row-fluid .uneditable-input[class*="span"]{float:none;margin-left:0}.input-append input[class*="span"],.input-append .uneditable-input[class*="span"],.input-prepend input[class*="span"],.input-prepend .uneditable-input[class*="span"],.row-fluid input[class*="span"],.row-fluid select[class*="span"],.row-fluid textarea[class*="span"],.row-fluid .uneditable-input[class*="span"],.row-fluid .input-prepend [class*="span"],.row-fluid .input-append [class*="span"]{display:inline-block}input,textarea,.uneditable-input{margin-left:0}.controls-row [class*="span"]+[class*="span"]{margin-left:20px}input.span12,textarea.span12,.uneditable-input.span12{width:926px}input.span11,textarea.span11,.uneditable-input.span11{width:846px}input.span10,textarea.span10,.uneditable-input.span10{width:766px}input.span9,textarea.span9,.uneditable-input.span9{width:686px}input.span8,textarea.span8,.uneditable-input.span8{width:606px}input.span7,textarea.span7,.uneditable-input.span7{width:526px}input.span6,textarea.span6,.uneditable-input.span6{width:446px}input.span5,textarea.span5,.uneditable-input.span5{width:366px}input.span4,textarea.span4,.uneditable-input.span4{width:286px}input.span3,textarea.span3,.uneditable-input.span3{width:206px}input.span2,textarea.span2,.uneditable-input.span2{width:126px}input.span1,textarea.span1,.uneditable-input.span1{width:46px}.controls-row{*zoom:1}.controls-row:before,.controls-row:after{display:table;line-height:0;content:""}.controls-row:after{clear:both}.controls-row [class*="span"],.row-fluid .controls-row [class*="span"]{float:left}.controls-row .checkbox[class*="span"],.controls-row .radio[class*="span"]{padding-top:5px}input[disabled],select[disabled],textarea[disabled],input[readonly],select[readonly],textarea[readonly]{cursor:not-allowed;background-color:#eee}input[type="radio"][disabled],input[type="checkbox"][disabled],input[type="radio"][readonly],input[type="checkbox"][readonly]{background-color:transparent}.control-group.warning .control-label,.control-group.warning .help-block,.control-group.warning .help-inline{color:#c09853}.control-group.warning .checkbox,.control-group.warning .radio,.control-group.warning input,.control-group.warning select,.control-group.warning textarea{color:#c09853}.control-group.warning input,.control-group.warning select,.control-group.warning textarea{border-color:#c09853;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);box-shadow:inset 0 1px 1px rgba(0,0,0,0.075)}.control-group.warning input:focus,.control-group.warning select:focus,.control-group.warning textarea:focus{border-color:#a47e3c;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #dbc59e;-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #dbc59e;box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #dbc59e}.control-group.warning .input-prepend .add-on,.control-group.warning .input-append .add-on{color:#c09853;background-color:#fcf8e3;border-color:#c09853}.control-group.error .control-label,.control-group.error .help-block,.control-group.error .help-inline{color:#b94a48}.control-group.error .checkbox,.control-group.error .radio,.control-group.error input,.control-group.error select,.control-group.error textarea{color:#b94a48}.control-group.error input,.control-group.error select,.control-group.error textarea{border-color:#b94a48;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);box-shadow:inset 0 1px 1px rgba(0,0,0,0.075)}.control-group.error input:focus,.control-group.error select:focus,.control-group.error textarea:focus{border-color:#953b39;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #d59392;-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #d59392;box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #d59392}.control-group.error .input-prepend .add-on,.control-group.error .input-append .add-on{color:#b94a48;background-color:#f2dede;border-color:#b94a48}.control-group.success .control-label,.control-group.success .help-block,.control-group.success .help-inline{color:#468847}.control-group.success .checkbox,.control-group.success .radio,.control-group.success input,.control-group.success select,.control-group.success textarea{color:#468847}.control-group.success input,.control-group.success select,.control-group.success textarea{border-color:#468847;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);box-shadow:inset 0 1px 1px rgba(0,0,0,0.075)}.control-group.success input:focus,.control-group.success select:focus,.control-group.success textarea:focus{border-color:#356635;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #7aba7b;-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #7aba7b;box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #7aba7b}.control-group.success .input-prepend .add-on,.control-group.success .input-append .add-on{color:#468847;background-color:#dff0d8;border-color:#468847}.control-group.info .control-label,.control-group.info .help-block,.control-group.info .help-inline{color:#3a87ad}.control-group.info .checkbox,.control-group.info .radio,.control-group.info input,.control-group.info select,.control-group.info textarea{color:#3a87ad}.control-group.info input,.control-group.info select,.control-group.info textarea{border-color:#3a87ad;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);box-shadow:inset 0 1px 1px rgba(0,0,0,0.075)}.control-group.info input:focus,.control-group.info select:focus,.control-group.info textarea:focus{border-color:#2d6987;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #7ab5d3;-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #7ab5d3;box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #7ab5d3}.control-group.info .input-prepend .add-on,.control-group.info .input-append .add-on{color:#3a87ad;background-color:#d9edf7;border-color:#3a87ad}input:focus:invalid,textarea:focus:invalid,select:focus:invalid{color:#b94a48;border-color:#ee5f5b}input:focus:invalid:focus,textarea:focus:invalid:focus,select:focus:invalid:focus{border-color:#e9322d;-webkit-box-shadow:0 0 6px #f8b9b7;-moz-box-shadow:0 0 6px #f8b9b7;box-shadow:0 0 6px #f8b9b7}.form-actions{padding:19px 20px 20px;margin-top:20px;margin-bottom:20px;background-color:#f5f5f5;border-top:1px solid #e5e5e5;*zoom:1}.form-actions:before,.form-actions:after{display:table;line-height:0;content:""}.form-actions:after{clear:both}.help-block,.help-inline{color:#595959}.help-block{display:block;margin-bottom:10px}.help-inline{display:inline-block;*display:inline;padding-left:5px;vertical-align:middle;*zoom:1}.input-append,.input-prepend{display:inline-block;margin-bottom:10px;font-size:0;white-space:nowrap;vertical-align:middle}.input-append input,.input-prepend input,.input-append select,.input-prepend select,.input-append .uneditable-input,.input-prepend .uneditable-input,.input-append .dropdown-menu,.input-prepend .dropdown-menu,.input-append .popover,.input-prepend .popover{font-size:14px}.input-append input,.input-prepend input,.input-append select,.input-prepend select,.input-append .uneditable-input,.input-prepend .uneditable-input{position:relative;margin-bottom:0;*margin-left:0;vertical-align:top;-webkit-border-radius:0 4px 4px 0;-moz-border-radius:0 4px 4px 0;border-radius:0 4px 4px 0}.input-append input:focus,.input-prepend input:focus,.input-append select:focus,.input-prepend select:focus,.input-append .uneditable-input:focus,.input-prepend .uneditable-input:focus{z-index:2}.input-append .add-on,.input-prepend .add-on{display:inline-block;width:auto;height:20px;min-width:16px;padding:4px 5px;font-size:14px;font-weight:normal;line-height:20px;text-align:center;text-shadow:0 1px 0 #fff;background-color:#eee;border:1px solid #ccc}.input-append .add-on,.input-prepend .add-on,.input-append .btn,.input-prepend .btn,.input-append .btn-group>.dropdown-toggle,.input-prepend .btn-group>.dropdown-toggle{vertical-align:top;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.input-append .active,.input-prepend .active{background-color:#a9dba9;border-color:#46a546}.input-prepend .add-on,.input-prepend .btn{margin-right:-1px}.input-prepend .add-on:first-child,.input-prepend .btn:first-child{-webkit-border-radius:4px 0 0 4px;-moz-border-radius:4px 0 0 4px;border-radius:4px 0 0 4px}.input-append input,.input-append select,.input-append .uneditable-input{-webkit-border-radius:4px 0 0 4px;-moz-border-radius:4px 0 0 4px;border-radius:4px 0 0 4px}.input-append input+.btn-group .btn:last-child,.input-append select+.btn-group .btn:last-child,.input-append .uneditable-input+.btn-group .btn:last-child{-webkit-border-radius:0 4px 4px 0;-moz-border-radius:0 4px 4px 0;border-radius:0 4px 4px 0}.input-append .add-on,.input-append .btn,.input-append .btn-group{margin-left:-1px}.input-append .add-on:last-child,.input-append .btn:last-child,.input-append .btn-group:last-child>.dropdown-toggle{-webkit-border-radius:0 4px 4px 0;-moz-border-radius:0 4px 4px 0;border-radius:0 4px 4px 0}.input-prepend.input-append input,.input-prepend.input-append select,.input-prepend.input-append .uneditable-input{-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.input-prepend.input-append input+.btn-group .btn,.input-prepend.input-append select+.btn-group .btn,.input-prepend.input-append .uneditable-input+.btn-group .btn{-webkit-border-radius:0 4px 4px 0;-moz-border-radius:0 4px 4px 0;border-radius:0 4px 4px 0}.input-prepend.input-append .add-on:first-child,.input-prepend.input-append .btn:first-child{margin-right:-1px;-webkit-border-radius:4px 0 0 4px;-moz-border-radius:4px 0 0 4px;border-radius:4px 0 0 4px}.input-prepend.input-append .add-on:last-child,.input-prepend.input-append .btn:last-child{margin-left:-1px;-webkit-border-radius:0 4px 4px 0;-moz-border-radius:0 4px 4px 0;border-radius:0 4px 4px 0}.input-prepend.input-append .btn-group:first-child{margin-left:0}input.search-query{padding-right:14px;padding-right:4px \9;padding-left:14px;padding-left:4px \9;margin-bottom:0;-webkit-border-radius:15px;-moz-border-radius:15px;border-radius:15px}.form-search .input-append .search-query,.form-search .input-prepend .search-query{-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.form-search .input-append .search-query{-webkit-border-radius:14px 0 0 14px;-moz-border-radius:14px 0 0 14px;border-radius:14px 0 0 14px}.form-search .input-append .btn{-webkit-border-radius:0 14px 14px 0;-moz-border-radius:0 14px 14px 0;border-radius:0 14px 14px 0}.form-search .input-prepend .search-query{-webkit-border-radius:0 14px 14px 0;-moz-border-radius:0 14px 14px 0;border-radius:0 14px 14px 0}.form-search .input-prepend .btn{-webkit-border-radius:14px 0 0 14px;-moz-border-radius:14px 0 0 14px;border-radius:14px 0 0 14px}.form-search input,.form-inline input,.form-horizontal input,.form-search textarea,.form-inline textarea,.form-horizontal textarea,.form-search select,.form-inline select,.form-horizontal select,.form-search .help-inline,.form-inline .help-inline,.form-horizontal .help-inline,.form-search .uneditable-input,.form-inline .uneditable-input,.form-horizontal .uneditable-input,.form-search .input-prepend,.form-inline .input-prepend,.form-horizontal .input-prepend,.form-search .input-append,.form-inline .input-append,.form-horizontal .input-append{display:inline-block;*display:inline;margin-bottom:0;vertical-align:middle;*zoom:1}.form-search .hide,.form-inline .hide,.form-horizontal .hide{display:none}.form-search label,.form-inline label,.form-search .btn-group,.form-inline .btn-group{display:inline-block}.form-search .input-append,.form-inline .input-append,.form-search .input-prepend,.form-inline .input-prepend{margin-bottom:0}.form-search .radio,.form-search .checkbox,.form-inline .radio,.form-inline .checkbox{padding-left:0;margin-bottom:0;vertical-align:middle}.form-search .radio input[type="radio"],.form-search .checkbox input[type="checkbox"],.form-inline .radio input[type="radio"],.form-inline .checkbox input[type="checkbox"]{float:left;margin-right:3px;margin-left:0}.control-group{margin-bottom:10px}legend+.control-group{margin-top:20px;-webkit-margin-top-collapse:separate}.form-horizontal .control-group{margin-bottom:20px;*zoom:1}.form-horizontal .control-group:before,.form-horizontal .control-group:after{display:table;line-height:0;content:""}.form-horizontal .control-group:after{clear:both}.form-horizontal .control-label{float:left;width:160px;padding-top:5px;text-align:right}.form-horizontal .controls{*display:inline-block;*padding-left:20px;margin-left:180px;*margin-left:0}.form-horizontal .controls:first-child{*padding-left:180px}.form-horizontal .help-block{margin-bottom:0}.form-horizontal input+.help-block,.form-horizontal select+.help-block,.form-horizontal textarea+.help-block,.form-horizontal .uneditable-input+.help-block,.form-horizontal .input-prepend+.help-block,.form-horizontal .input-append+.help-block{margin-top:10px}.form-horizontal .form-actions{padding-left:180px}table{max-width:100%;background-color:transparent;border-collapse:collapse;border-spacing:0}.table{width:100%;margin-bottom:20px}.table th,.table td{padding:8px;line-height:20px;text-align:left;vertical-align:top;border-top:1px solid #ddd}.table th{font-weight:bold}.table thead th{vertical-align:bottom}.table caption+thead tr:first-child th,.table caption+thead tr:first-child td,.table colgroup+thead tr:first-child th,.table colgroup+thead tr:first-child td,.table thead:first-child tr:first-child th,.table thead:first-child tr:first-child td{border-top:0}.table tbody+tbody{border-top:2px solid #ddd}.table .table{background-color:#fff}.table-condensed th,.table-condensed td{padding:4px 5px}.table-bordered{border:1px solid #ddd;border-collapse:separate;*border-collapse:collapse;border-left:0;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}.table-bordered th,.table-bordered td{border-left:1px solid #ddd}.table-bordered caption+thead tr:first-child th,.table-bordered caption+tbody tr:first-child th,.table-bordered caption+tbody tr:first-child td,.table-bordered colgroup+thead tr:first-child th,.table-bordered colgroup+tbody tr:first-child th,.table-bordered colgroup+tbody tr:first-child td,.table-bordered thead:first-child tr:first-child th,.table-bordered tbody:first-child tr:first-child th,.table-bordered tbody:first-child tr:first-child td{border-top:0}.table-bordered thead:first-child tr:first-child>th:first-child,.table-bordered tbody:first-child tr:first-child>td:first-child,.table-bordered tbody:first-child tr:first-child>th:first-child{-webkit-border-top-left-radius:4px;border-top-left-radius:4px;-moz-border-radius-topleft:4px}.table-bordered thead:first-child tr:first-child>th:last-child,.table-bordered tbody:first-child tr:first-child>td:last-child,.table-bordered tbody:first-child tr:first-child>th:last-child{-webkit-border-top-right-radius:4px;border-top-right-radius:4px;-moz-border-radius-topright:4px}.table-bordered thead:last-child tr:last-child>th:first-child,.table-bordered tbody:last-child tr:last-child>td:first-child,.table-bordered tbody:last-child tr:last-child>th:first-child,.table-bordered tfoot:last-child tr:last-child>td:first-child,.table-bordered tfoot:last-child tr:last-child>th:first-child{-webkit-border-bottom-left-radius:4px;border-bottom-left-radius:4px;-moz-border-radius-bottomleft:4px}.table-bordered thead:last-child tr:last-child>th:last-child,.table-bordered tbody:last-child tr:last-child>td:last-child,.table-bordered tbody:last-child tr:last-child>th:last-child,.table-bordered tfoot:last-child tr:last-child>td:last-child,.table-bordered tfoot:last-child tr:last-child>th:last-child{-webkit-border-bottom-right-radius:4px;border-bottom-right-radius:4px;-moz-border-radius-bottomright:4px}.table-bordered tfoot+tbody:last-child tr:last-child td:first-child{-webkit-border-bottom-left-radius:0;border-bottom-left-radius:0;-moz-border-radius-bottomleft:0}.table-bordered tfoot+tbody:last-child tr:last-child td:last-child{-webkit-border-bottom-right-radius:0;border-bottom-right-radius:0;-moz-border-radius-bottomright:0}.table-bordered caption+thead tr:first-child th:first-child,.table-bordered caption+tbody tr:first-child td:first-child,.table-bordered colgroup+thead tr:first-child th:first-child,.table-bordered colgroup+tbody tr:first-child td:first-child{-webkit-border-top-left-radius:4px;border-top-left-radius:4px;-moz-border-radius-topleft:4px}.table-bordered caption+thead tr:first-child th:last-child,.table-bordered caption+tbody tr:first-child td:last-child,.table-bordered colgroup+thead tr:first-child th:last-child,.table-bordered colgroup+tbody tr:first-child td:last-child{-webkit-border-top-right-radius:4px;border-top-right-radius:4px;-moz-border-radius-topright:4px}.table-striped tbody>tr:nth-child(odd)>td,.table-striped tbody>tr:nth-child(odd)>th{background-color:#f9f9f9}.table-hover tbody tr:hover>td,.table-hover tbody tr:hover>th{background-color:#f5f5f5}table td[class*="span"],table th[class*="span"],.row-fluid table td[class*="span"],.row-fluid table th[class*="span"]{display:table-cell;float:none;margin-left:0}.table td.span1,.table th.span1{float:none;width:44px;margin-left:0}.table td.span2,.table th.span2{float:none;width:124px;margin-left:0}.table td.span3,.table th.span3{float:none;width:204px;margin-left:0}.table td.span4,.table th.span4{float:none;width:284px;margin-left:0}.table td.span5,.table th.span5{float:none;width:364px;margin-left:0}.table td.span6,.table th.span6{float:none;width:444px;margin-left:0}.table td.span7,.table th.span7{float:none;width:524px;margin-left:0}.table td.span8,.table th.span8{float:none;width:604px;margin-left:0}.table td.span9,.table th.span9{float:none;width:684px;margin-left:0}.table td.span10,.table th.span10{float:none;width:764px;margin-left:0}.table td.span11,.table th.span11{float:none;width:844px;margin-left:0}.table td.span12,.table th.span12{float:none;width:924px;margin-left:0}.table tbody tr.success>td{background-color:#dff0d8}.table tbody tr.error>td{background-color:#f2dede}.table tbody tr.warning>td{background-color:#fcf8e3}.table tbody tr.info>td{background-color:#d9edf7}.table-hover tbody tr.success:hover>td{background-color:#d0e9c6}.table-hover tbody tr.error:hover>td{background-color:#ebcccc}.table-hover tbody tr.warning:hover>td{background-color:#faf2cc}.table-hover tbody tr.info:hover>td{background-color:#c4e3f3}[class^="icon-"],[class*=" icon-"]{display:inline-block;width:14px;height:14px;margin-top:1px;*margin-right:.3em;line-height:14px;vertical-align:text-top;background-image:url("../img/glyphicons-halflings.png");background-position:14px 14px;background-repeat:no-repeat}.icon-white,.nav-pills>.active>a>[class^="icon-"],.nav-pills>.active>a>[class*=" icon-"],.nav-list>.active>a>[class^="icon-"],.nav-list>.active>a>[class*=" icon-"],.navbar-inverse .nav>.active>a>[class^="icon-"],.navbar-inverse .nav>.active>a>[class*=" icon-"],.dropdown-menu>li>a:hover>[class^="icon-"],.dropdown-menu>li>a:focus>[class^="icon-"],.dropdown-menu>li>a:hover>[class*=" icon-"],.dropdown-menu>li>a:focus>[class*=" icon-"],.dropdown-menu>.active>a>[class^="icon-"],.dropdown-menu>.active>a>[class*=" icon-"],.dropdown-submenu:hover>a>[class^="icon-"],.dropdown-submenu:focus>a>[class^="icon-"],.dropdown-submenu:hover>a>[class*=" icon-"],.dropdown-submenu:focus>a>[class*=" icon-"]{background-image:url("../img/glyphicons-halflings-white.png")}.icon-glass{background-position:0 0}.icon-music{background-position:-24px 0}.icon-search{background-position:-48px 0}.icon-envelope{background-position:-72px 0}.icon-heart{background-position:-96px 0}.icon-star{background-position:-120px 0}.icon-star-empty{background-position:-144px 0}.icon-user{background-position:-168px 0}.icon-film{background-position:-192px 0}.icon-th-large{background-position:-216px 0}.icon-th{background-position:-240px 0}.icon-th-list{background-position:-264px 0}.icon-ok{background-position:-288px 0}.icon-remove{background-position:-312px 0}.icon-zoom-in{background-position:-336px 0}.icon-zoom-out{background-position:-360px 0}.icon-off{background-position:-384px 0}.icon-signal{background-position:-408px 0}.icon-cog{background-position:-432px 0}.icon-trash{background-position:-456px 0}.icon-home{background-position:0 -24px}.icon-file{background-position:-24px -24px}.icon-time{background-position:-48px -24px}.icon-road{background-position:-72px -24px}.icon-download-alt{background-position:-96px -24px}.icon-download{background-position:-120px -24px}.icon-upload{background-position:-144px -24px}.icon-inbox{background-position:-168px -24px}.icon-play-circle{background-position:-192px -24px}.icon-repeat{background-position:-216px -24px}.icon-refresh{background-position:-240px -24px}.icon-list-alt{background-position:-264px -24px}.icon-lock{background-position:-287px -24px}.icon-flag{background-position:-312px -24px}.icon-headphones{background-position:-336px -24px}.icon-volume-off{background-position:-360px -24px}.icon-volume-down{background-position:-384px -24px}.icon-volume-up{background-position:-408px -24px}.icon-qrcode{background-position:-432px -24px}.icon-barcode{background-position:-456px -24px}.icon-tag{background-position:0 -48px}.icon-tags{background-position:-25px -48px}.icon-book{background-position:-48px -48px}.icon-bookmark{background-position:-72px -48px}.icon-print{background-position:-96px -48px}.icon-camera{background-position:-120px -48px}.icon-font{background-position:-144px -48px}.icon-bold{background-position:-167px -48px}.icon-italic{background-position:-192px -48px}.icon-text-height{background-position:-216px -48px}.icon-text-width{background-position:-240px -48px}.icon-align-left{background-position:-264px -48px}.icon-align-center{background-position:-288px -48px}.icon-align-right{background-position:-312px -48px}.icon-align-justify{background-position:-336px -48px}.icon-list{background-position:-360px -48px}.icon-indent-left{background-position:-384px -48px}.icon-indent-right{background-position:-408px -48px}.icon-facetime-video{background-position:-432px -48px}.icon-picture{background-position:-456px -48px}.icon-pencil{background-position:0 -72px}.icon-map-marker{background-position:-24px -72px}.icon-adjust{background-position:-48px -72px}.icon-tint{background-position:-72px -72px}.icon-edit{background-position:-96px -72px}.icon-share{background-position:-120px -72px}.icon-check{background-position:-144px -72px}.icon-move{background-position:-168px -72px}.icon-step-backward{background-position:-192px -72px}.icon-fast-backward{background-position:-216px -72px}.icon-backward{background-position:-240px -72px}.icon-play{background-position:-264px -72px}.icon-pause{background-position:-288px -72px}.icon-stop{background-position:-312px -72px}.icon-forward{background-position:-336px -72px}.icon-fast-forward{background-position:-360px -72px}.icon-step-forward{background-position:-384px -72px}.icon-eject{background-position:-408px -72px}.icon-chevron-left{background-position:-432px -72px}.icon-chevron-right{background-position:-456px -72px}.icon-plus-sign{background-position:0 -96px}.icon-minus-sign{background-position:-24px -96px}.icon-remove-sign{background-position:-48px -96px}.icon-ok-sign{background-position:-72px -96px}.icon-question-sign{background-position:-96px -96px}.icon-info-sign{background-position:-120px -96px}.icon-screenshot{background-position:-144px -96px}.icon-remove-circle{background-position:-168px -96px}.icon-ok-circle{background-position:-192px -96px}.icon-ban-circle{background-position:-216px -96px}.icon-arrow-left{background-position:-240px -96px}.icon-arrow-right{background-position:-264px -96px}.icon-arrow-up{background-position:-289px -96px}.icon-arrow-down{background-position:-312px -96px}.icon-share-alt{background-position:-336px -96px}.icon-resize-full{background-position:-360px -96px}.icon-resize-small{background-position:-384px -96px}.icon-plus{background-position:-408px -96px}.icon-minus{background-position:-433px -96px}.icon-asterisk{background-position:-456px -96px}.icon-exclamation-sign{background-position:0 -120px}.icon-gift{background-position:-24px -120px}.icon-leaf{background-position:-48px -120px}.icon-fire{background-position:-72px -120px}.icon-eye-open{background-position:-96px -120px}.icon-eye-close{background-position:-120px -120px}.icon-warning-sign{background-position:-144px -120px}.icon-plane{background-position:-168px -120px}.icon-calendar{background-position:-192px -120px}.icon-random{width:16px;background-position:-216px -120px}.icon-comment{background-position:-240px -120px}.icon-magnet{background-position:-264px -120px}.icon-chevron-up{background-position:-288px -120px}.icon-chevron-down{background-position:-313px -119px}.icon-retweet{background-position:-336px -120px}.icon-shopping-cart{background-position:-360px -120px}.icon-folder-close{width:16px;background-position:-384px -120px}.icon-folder-open{width:16px;background-position:-408px -120px}.icon-resize-vertical{background-position:-432px -119px}.icon-resize-horizontal{background-position:-456px -118px}.icon-hdd{background-position:0 -144px}.icon-bullhorn{background-position:-24px -144px}.icon-bell{background-position:-48px -144px}.icon-certificate{background-position:-72px -144px}.icon-thumbs-up{background-position:-96px -144px}.icon-thumbs-down{background-position:-120px -144px}.icon-hand-right{background-position:-144px -144px}.icon-hand-left{background-position:-168px -144px}.icon-hand-up{background-position:-192px -144px}.icon-hand-down{background-position:-216px -144px}.icon-circle-arrow-right{background-position:-240px -144px}.icon-circle-arrow-left{background-position:-264px -144px}.icon-circle-arrow-up{background-position:-288px -144px}.icon-circle-arrow-down{background-position:-312px -144px}.icon-globe{background-position:-336px -144px}.icon-wrench{background-position:-360px -144px}.icon-tasks{background-position:-384px -144px}.icon-filter{background-position:-408px -144px}.icon-briefcase{background-position:-432px -144px}.icon-fullscreen{background-position:-456px -144px}.dropup,.dropdown{position:relative}.dropdown-toggle{*margin-bottom:-3px}.dropdown-toggle:active,.open .dropdown-toggle{outline:0}.caret{display:inline-block;width:0;height:0;vertical-align:top;border-top:4px solid #000;border-right:4px solid transparent;border-left:4px solid transparent;content:""}.dropdown .caret{margin-top:8px;margin-left:2px}.dropdown-menu{position:absolute;top:100%;left:0;z-index:1000;display:none;float:left;min-width:160px;padding:5px 0;margin:2px 0 0;list-style:none;background-color:#fff;border:1px solid #ccc;border:1px solid rgba(0,0,0,0.2);*border-right-width:2px;*border-bottom-width:2px;-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px;-webkit-box-shadow:0 5px 10px rgba(0,0,0,0.2);-moz-box-shadow:0 5px 10px rgba(0,0,0,0.2);box-shadow:0 5px 10px rgba(0,0,0,0.2);-webkit-background-clip:padding-box;-moz-background-clip:padding;background-clip:padding-box}.dropdown-menu.pull-right{right:0;left:auto}.dropdown-menu .divider{*width:100%;height:1px;margin:9px 1px;*margin:-5px 0 5px;overflow:hidden;background-color:#e5e5e5;border-bottom:1px solid #fff}.dropdown-menu>li>a{display:block;padding:3px 20px;clear:both;font-weight:normal;line-height:20px;color:#333;white-space:nowrap}.dropdown-menu>li>a:hover,.dropdown-menu>li>a:focus,.dropdown-submenu:hover>a,.dropdown-submenu:focus>a{color:#fff;text-decoration:none;background-color:#0081c2;background-image:-moz-linear-gradient(top,#08c,#0077b3);background-image:-webkit-gradient(linear,0 0,0 100%,from(#08c),to(#0077b3));background-image:-webkit-linear-gradient(top,#08c,#0077b3);background-image:-o-linear-gradient(top,#08c,#0077b3);background-image:linear-gradient(to bottom,#08c,#0077b3);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff0088cc',endColorstr='#ff0077b3',GradientType=0)}.dropdown-menu>.active>a,.dropdown-menu>.active>a:hover,.dropdown-menu>.active>a:focus{color:#fff;text-decoration:none;background-color:#0081c2;background-image:-moz-linear-gradient(top,#08c,#0077b3);background-image:-webkit-gradient(linear,0 0,0 100%,from(#08c),to(#0077b3));background-image:-webkit-linear-gradient(top,#08c,#0077b3);background-image:-o-linear-gradient(top,#08c,#0077b3);background-image:linear-gradient(to bottom,#08c,#0077b3);background-repeat:repeat-x;outline:0;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff0088cc',endColorstr='#ff0077b3',GradientType=0)}.dropdown-menu>.disabled>a,.dropdown-menu>.disabled>a:hover,.dropdown-menu>.disabled>a:focus{color:#999}.dropdown-menu>.disabled>a:hover,.dropdown-menu>.disabled>a:focus{text-decoration:none;cursor:default;background-color:transparent;background-image:none;filter:progid:DXImageTransform.Microsoft.gradient(enabled=false)}.open{*z-index:1000}.open>.dropdown-menu{display:block}.pull-right>.dropdown-menu{right:0;left:auto}.dropup .caret,.navbar-fixed-bottom .dropdown .caret{border-top:0;border-bottom:4px solid #000;content:""}.dropup .dropdown-menu,.navbar-fixed-bottom .dropdown .dropdown-menu{top:auto;bottom:100%;margin-bottom:1px}.dropdown-submenu{position:relative}.dropdown-submenu>.dropdown-menu{top:0;left:100%;margin-top:-6px;margin-left:-1px;-webkit-border-radius:0 6px 6px 6px;-moz-border-radius:0 6px 6px 6px;border-radius:0 6px 6px 6px}.dropdown-submenu:hover>.dropdown-menu{display:block}.dropup .dropdown-submenu>.dropdown-menu{top:auto;bottom:0;margin-top:0;margin-bottom:-2px;-webkit-border-radius:5px 5px 5px 0;-moz-border-radius:5px 5px 5px 0;border-radius:5px 5px 5px 0}.dropdown-submenu>a:after{display:block;float:right;width:0;height:0;margin-top:5px;margin-right:-10px;border-color:transparent;border-left-color:#ccc;border-style:solid;border-width:5px 0 5px 5px;content:" "}.dropdown-submenu:hover>a:after{border-left-color:#fff}.dropdown-submenu.pull-left{float:none}.dropdown-submenu.pull-left>.dropdown-menu{left:-100%;margin-left:10px;-webkit-border-radius:6px 0 6px 6px;-moz-border-radius:6px 0 6px 6px;border-radius:6px 0 6px 6px}.dropdown .dropdown-menu .nav-header{padding-right:20px;padding-left:20px}.typeahead{z-index:1051;margin-top:2px;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}.well{min-height:20px;padding:19px;margin-bottom:20px;background-color:#f5f5f5;border:1px solid #e3e3e3;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.05);-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.05);box-shadow:inset 0 1px 1px rgba(0,0,0,0.05)}.well blockquote{border-color:#ddd;border-color:rgba(0,0,0,0.15)}.well-large{padding:24px;-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px}.well-small{padding:9px;-webkit-border-radius:3px;-moz-border-radius:3px;border-radius:3px}.fade{opacity:0;-webkit-transition:opacity .15s linear;-moz-transition:opacity .15s linear;-o-transition:opacity .15s linear;transition:opacity .15s linear}.fade.in{opacity:1}.collapse{position:relative;height:0;overflow:hidden;-webkit-transition:height .35s ease;-moz-transition:height .35s ease;-o-transition:height .35s ease;transition:height .35s ease}.collapse.in{height:auto}.close{float:right;font-size:20px;font-weight:bold;line-height:20px;color:#000;text-shadow:0 1px 0 #fff;opacity:.2;filter:alpha(opacity=20)}.close:hover,.close:focus{color:#000;text-decoration:none;cursor:pointer;opacity:.4;filter:alpha(opacity=40)}button.close{padding:0;cursor:pointer;background:transparent;border:0;-webkit-appearance:none}.btn{display:inline-block;*display:inline;padding:4px 12px;margin-bottom:0;*margin-left:.3em;font-size:14px;line-height:20px;color:#333;text-align:center;text-shadow:0 1px 1px rgba(255,255,255,0.75);vertical-align:middle;cursor:pointer;background-color:#f5f5f5;*background-color:#e6e6e6;background-image:-moz-linear-gradient(top,#fff,#e6e6e6);background-image:-webkit-gradient(linear,0 0,0 100%,from(#fff),to(#e6e6e6));background-image:-webkit-linear-gradient(top,#fff,#e6e6e6);background-image:-o-linear-gradient(top,#fff,#e6e6e6);background-image:linear-gradient(to bottom,#fff,#e6e6e6);background-repeat:repeat-x;border:1px solid #ccc;*border:0;border-color:#e6e6e6 #e6e6e6 #bfbfbf;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);border-bottom-color:#b3b3b3;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffffffff',endColorstr='#ffe6e6e6',GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false);*zoom:1;-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,0.2),0 1px 2px rgba(0,0,0,0.05);-moz-box-shadow:inset 0 1px 0 rgba(255,255,255,0.2),0 1px 2px rgba(0,0,0,0.05);box-shadow:inset 0 1px 0 rgba(255,255,255,0.2),0 1px 2px rgba(0,0,0,0.05)}.btn:hover,.btn:focus,.btn:active,.btn.active,.btn.disabled,.btn[disabled]{color:#333;background-color:#e6e6e6;*background-color:#d9d9d9}.btn:active,.btn.active{background-color:#ccc \9}.btn:first-child{*margin-left:0}.btn:hover,.btn:focus{color:#333;text-decoration:none;background-position:0 -15px;-webkit-transition:background-position .1s linear;-moz-transition:background-position .1s linear;-o-transition:background-position .1s linear;transition:background-position .1s linear}.btn:focus{outline:thin dotted #333;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}.btn.active,.btn:active{background-image:none;outline:0;-webkit-box-shadow:inset 0 2px 4px rgba(0,0,0,0.15),0 1px 2px rgba(0,0,0,0.05);-moz-box-shadow:inset 0 2px 4px rgba(0,0,0,0.15),0 1px 2px rgba(0,0,0,0.05);box-shadow:inset 0 2px 4px rgba(0,0,0,0.15),0 1px 2px rgba(0,0,0,0.05)}.btn.disabled,.btn[disabled]{cursor:default;background-image:none;opacity:.65;filter:alpha(opacity=65);-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none}.btn-large{padding:11px 19px;font-size:17.5px;-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px}.btn-large [class^="icon-"],.btn-large [class*=" icon-"]{margin-top:4px}.btn-small{padding:2px 10px;font-size:11.9px;-webkit-border-radius:3px;-moz-border-radius:3px;border-radius:3px}.btn-small [class^="icon-"],.btn-small [class*=" icon-"]{margin-top:0}.btn-mini [class^="icon-"],.btn-mini [class*=" icon-"]{margin-top:-1px}.btn-mini{padding:0 6px;font-size:10.5px;-webkit-border-radius:3px;-moz-border-radius:3px;border-radius:3px}.btn-block{display:block;width:100%;padding-right:0;padding-left:0;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}.btn-block+.btn-block{margin-top:5px}input[type="submit"].btn-block,input[type="reset"].btn-block,input[type="button"].btn-block{width:100%}.btn-primary.active,.btn-warning.active,.btn-danger.active,.btn-success.active,.btn-info.active,.btn-inverse.active{color:rgba(255,255,255,0.75)}.btn-primary{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,0.25);background-color:#006dcc;*background-color:#04c;background-image:-moz-linear-gradient(top,#08c,#04c);background-image:-webkit-gradient(linear,0 0,0 100%,from(#08c),to(#04c));background-image:-webkit-linear-gradient(top,#08c,#04c);background-image:-o-linear-gradient(top,#08c,#04c);background-image:linear-gradient(to bottom,#08c,#04c);background-repeat:repeat-x;border-color:#04c #04c #002a80;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff0088cc',endColorstr='#ff0044cc',GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false)}.btn-primary:hover,.btn-primary:focus,.btn-primary:active,.btn-primary.active,.btn-primary.disabled,.btn-primary[disabled]{color:#fff;background-color:#04c;*background-color:#003bb3}.btn-primary:active,.btn-primary.active{background-color:#039 \9}.btn-warning{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,0.25);background-color:#faa732;*background-color:#f89406;background-image:-moz-linear-gradient(top,#fbb450,#f89406);background-image:-webkit-gradient(linear,0 0,0 100%,from(#fbb450),to(#f89406));background-image:-webkit-linear-gradient(top,#fbb450,#f89406);background-image:-o-linear-gradient(top,#fbb450,#f89406);background-image:linear-gradient(to bottom,#fbb450,#f89406);background-repeat:repeat-x;border-color:#f89406 #f89406 #ad6704;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#fffbb450',endColorstr='#fff89406',GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false)}.btn-warning:hover,.btn-warning:focus,.btn-warning:active,.btn-warning.active,.btn-warning.disabled,.btn-warning[disabled]{color:#fff;background-color:#f89406;*background-color:#df8505}.btn-warning:active,.btn-warning.active{background-color:#c67605 \9}.btn-danger{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,0.25);background-color:#da4f49;*background-color:#bd362f;background-image:-moz-linear-gradient(top,#ee5f5b,#bd362f);background-image:-webkit-gradient(linear,0 0,0 100%,from(#ee5f5b),to(#bd362f));background-image:-webkit-linear-gradient(top,#ee5f5b,#bd362f);background-image:-o-linear-gradient(top,#ee5f5b,#bd362f);background-image:linear-gradient(to bottom,#ee5f5b,#bd362f);background-repeat:repeat-x;border-color:#bd362f #bd362f #802420;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffee5f5b',endColorstr='#ffbd362f',GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false)}.btn-danger:hover,.btn-danger:focus,.btn-danger:active,.btn-danger.active,.btn-danger.disabled,.btn-danger[disabled]{color:#fff;background-color:#bd362f;*background-color:#a9302a}.btn-danger:active,.btn-danger.active{background-color:#942a25 \9}.btn-success{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,0.25);background-color:#5bb75b;*background-color:#51a351;background-image:-moz-linear-gradient(top,#62c462,#51a351);background-image:-webkit-gradient(linear,0 0,0 100%,from(#62c462),to(#51a351));background-image:-webkit-linear-gradient(top,#62c462,#51a351);background-image:-o-linear-gradient(top,#62c462,#51a351);background-image:linear-gradient(to bottom,#62c462,#51a351);background-repeat:repeat-x;border-color:#51a351 #51a351 #387038;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff62c462',endColorstr='#ff51a351',GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false)}.btn-success:hover,.btn-success:focus,.btn-success:active,.btn-success.active,.btn-success.disabled,.btn-success[disabled]{color:#fff;background-color:#51a351;*background-color:#499249}.btn-success:active,.btn-success.active{background-color:#408140 \9}.btn-info{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,0.25);background-color:#49afcd;*background-color:#2f96b4;background-image:-moz-linear-gradient(top,#5bc0de,#2f96b4);background-image:-webkit-gradient(linear,0 0,0 100%,from(#5bc0de),to(#2f96b4));background-image:-webkit-linear-gradient(top,#5bc0de,#2f96b4);background-image:-o-linear-gradient(top,#5bc0de,#2f96b4);background-image:linear-gradient(to bottom,#5bc0de,#2f96b4);background-repeat:repeat-x;border-color:#2f96b4 #2f96b4 #1f6377;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff5bc0de',endColorstr='#ff2f96b4',GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false)}.btn-info:hover,.btn-info:focus,.btn-info:active,.btn-info.active,.btn-info.disabled,.btn-info[disabled]{color:#fff;background-color:#2f96b4;*background-color:#2a85a0}.btn-info:active,.btn-info.active{background-color:#24748c \9}.btn-inverse{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,0.25);background-color:#363636;*background-color:#222;background-image:-moz-linear-gradient(top,#444,#222);background-image:-webkit-gradient(linear,0 0,0 100%,from(#444),to(#222));background-image:-webkit-linear-gradient(top,#444,#222);background-image:-o-linear-gradient(top,#444,#222);background-image:linear-gradient(to bottom,#444,#222);background-repeat:repeat-x;border-color:#222 #222 #000;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff444444',endColorstr='#ff222222',GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false)}.btn-inverse:hover,.btn-inverse:focus,.btn-inverse:active,.btn-inverse.active,.btn-inverse.disabled,.btn-inverse[disabled]{color:#fff;background-color:#222;*background-color:#151515}.btn-inverse:active,.btn-inverse.active{background-color:#080808 \9}button.btn,input[type="submit"].btn{*padding-top:3px;*padding-bottom:3px}button.btn::-moz-focus-inner,input[type="submit"].btn::-moz-focus-inner{padding:0;border:0}button.btn.btn-large,input[type="submit"].btn.btn-large{*padding-top:7px;*padding-bottom:7px}button.btn.btn-small,input[type="submit"].btn.btn-small{*padding-top:3px;*padding-bottom:3px}button.btn.btn-mini,input[type="submit"].btn.btn-mini{*padding-top:1px;*padding-bottom:1px}.btn-link,.btn-link:active,.btn-link[disabled]{background-color:transparent;background-image:none;-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none}.btn-link{color:#08c;cursor:pointer;border-color:transparent;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.btn-link:hover,.btn-link:focus{color:#005580;text-decoration:underline;background-color:transparent}.btn-link[disabled]:hover,.btn-link[disabled]:focus{color:#333;text-decoration:none}.btn-group{position:relative;display:inline-block;*display:inline;*margin-left:.3em;font-size:0;white-space:nowrap;vertical-align:middle;*zoom:1}.btn-group:first-child{*margin-left:0}.btn-group+.btn-group{margin-left:5px}.btn-toolbar{margin-top:10px;margin-bottom:10px;font-size:0}.btn-toolbar>.btn+.btn,.btn-toolbar>.btn-group+.btn,.btn-toolbar>.btn+.btn-group{margin-left:5px}.btn-group>.btn{position:relative;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.btn-group>.btn+.btn{margin-left:-1px}.btn-group>.btn,.btn-group>.dropdown-menu,.btn-group>.popover{font-size:14px}.btn-group>.btn-mini{font-size:10.5px}.btn-group>.btn-small{font-size:11.9px}.btn-group>.btn-large{font-size:17.5px}.btn-group>.btn:first-child{margin-left:0;-webkit-border-bottom-left-radius:4px;border-bottom-left-radius:4px;-webkit-border-top-left-radius:4px;border-top-left-radius:4px;-moz-border-radius-bottomleft:4px;-moz-border-radius-topleft:4px}.btn-group>.btn:last-child,.btn-group>.dropdown-toggle{-webkit-border-top-right-radius:4px;border-top-right-radius:4px;-webkit-border-bottom-right-radius:4px;border-bottom-right-radius:4px;-moz-border-radius-topright:4px;-moz-border-radius-bottomright:4px}.btn-group>.btn.large:first-child{margin-left:0;-webkit-border-bottom-left-radius:6px;border-bottom-left-radius:6px;-webkit-border-top-left-radius:6px;border-top-left-radius:6px;-moz-border-radius-bottomleft:6px;-moz-border-radius-topleft:6px}.btn-group>.btn.large:last-child,.btn-group>.large.dropdown-toggle{-webkit-border-top-right-radius:6px;border-top-right-radius:6px;-webkit-border-bottom-right-radius:6px;border-bottom-right-radius:6px;-moz-border-radius-topright:6px;-moz-border-radius-bottomright:6px}.btn-group>.btn:hover,.btn-group>.btn:focus,.btn-group>.btn:active,.btn-group>.btn.active{z-index:2}.btn-group .dropdown-toggle:active,.btn-group.open .dropdown-toggle{outline:0}.btn-group>.btn+.dropdown-toggle{*padding-top:5px;padding-right:8px;*padding-bottom:5px;padding-left:8px;-webkit-box-shadow:inset 1px 0 0 rgba(255,255,255,0.125),inset 0 1px 0 rgba(255,255,255,0.2),0 1px 2px rgba(0,0,0,0.05);-moz-box-shadow:inset 1px 0 0 rgba(255,255,255,0.125),inset 0 1px 0 rgba(255,255,255,0.2),0 1px 2px rgba(0,0,0,0.05);box-shadow:inset 1px 0 0 rgba(255,255,255,0.125),inset 0 1px 0 rgba(255,255,255,0.2),0 1px 2px rgba(0,0,0,0.05)}.btn-group>.btn-mini+.dropdown-toggle{*padding-top:2px;padding-right:5px;*padding-bottom:2px;padding-left:5px}.btn-group>.btn-small+.dropdown-toggle{*padding-top:5px;*padding-bottom:4px}.btn-group>.btn-large+.dropdown-toggle{*padding-top:7px;padding-right:12px;*padding-bottom:7px;padding-left:12px}.btn-group.open .dropdown-toggle{background-image:none;-webkit-box-shadow:inset 0 2px 4px rgba(0,0,0,0.15),0 1px 2px rgba(0,0,0,0.05);-moz-box-shadow:inset 0 2px 4px rgba(0,0,0,0.15),0 1px 2px rgba(0,0,0,0.05);box-shadow:inset 0 2px 4px rgba(0,0,0,0.15),0 1px 2px rgba(0,0,0,0.05)}.btn-group.open .btn.dropdown-toggle{background-color:#e6e6e6}.btn-group.open .btn-primary.dropdown-toggle{background-color:#04c}.btn-group.open .btn-warning.dropdown-toggle{background-color:#f89406}.btn-group.open .btn-danger.dropdown-toggle{background-color:#bd362f}.btn-group.open .btn-success.dropdown-toggle{background-color:#51a351}.btn-group.open .btn-info.dropdown-toggle{background-color:#2f96b4}.btn-group.open .btn-inverse.dropdown-toggle{background-color:#222}.btn .caret{margin-top:8px;margin-left:0}.btn-large .caret{margin-top:6px}.btn-large .caret{border-top-width:5px;border-right-width:5px;border-left-width:5px}.btn-mini .caret,.btn-small .caret{margin-top:8px}.dropup .btn-large .caret{border-bottom-width:5px}.btn-primary .caret,.btn-warning .caret,.btn-danger .caret,.btn-info .caret,.btn-success .caret,.btn-inverse .caret{border-top-color:#fff;border-bottom-color:#fff}.btn-group-vertical{display:inline-block;*display:inline;*zoom:1}.btn-group-vertical>.btn{display:block;float:none;max-width:100%;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.btn-group-vertical>.btn+.btn{margin-top:-1px;margin-left:0}.btn-group-vertical>.btn:first-child{-webkit-border-radius:4px 4px 0 0;-moz-border-radius:4px 4px 0 0;border-radius:4px 4px 0 0}.btn-group-vertical>.btn:last-child{-webkit-border-radius:0 0 4px 4px;-moz-border-radius:0 0 4px 4px;border-radius:0 0 4px 4px}.btn-group-vertical>.btn-large:first-child{-webkit-border-radius:6px 6px 0 0;-moz-border-radius:6px 6px 0 0;border-radius:6px 6px 0 0}.btn-group-vertical>.btn-large:last-child{-webkit-border-radius:0 0 6px 6px;-moz-border-radius:0 0 6px 6px;border-radius:0 0 6px 6px}.alert{padding:8px 35px 8px 14px;margin-bottom:20px;text-shadow:0 1px 0 rgba(255,255,255,0.5);background-color:#fcf8e3;border:1px solid #fbeed5;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}.alert,.alert h4{color:#c09853}.alert h4{margin:0}.alert .close{position:relative;top:-2px;right:-21px;line-height:20px}.alert-success{color:#468847;background-color:#dff0d8;border-color:#d6e9c6}.alert-success h4{color:#468847}.alert-danger,.alert-error{color:#b94a48;background-color:#f2dede;border-color:#eed3d7}.alert-danger h4,.alert-error h4{color:#b94a48}.alert-info{color:#3a87ad;background-color:#d9edf7;border-color:#bce8f1}.alert-info h4{color:#3a87ad}.alert-block{padding-top:14px;padding-bottom:14px}.alert-block>p,.alert-block>ul{margin-bottom:0}.alert-block p+p{margin-top:5px}.nav{margin-bottom:20px;margin-left:0;list-style:none}.nav>li>a{display:block}.nav>li>a:hover,.nav>li>a:focus{text-decoration:none;background-color:#eee}.nav>li>a>img{max-width:none}.nav>.pull-right{float:right}.nav-header{display:block;padding:3px 15px;font-size:11px;font-weight:bold;line-height:20px;color:#999;text-shadow:0 1px 0 rgba(255,255,255,0.5);text-transform:uppercase}.nav li+.nav-header{margin-top:9px}.nav-list{padding-right:15px;padding-left:15px;margin-bottom:0}.nav-list>li>a,.nav-list .nav-header{margin-right:-15px;margin-left:-15px;text-shadow:0 1px 0 rgba(255,255,255,0.5)}.nav-list>li>a{padding:3px 15px}.nav-list>.active>a,.nav-list>.active>a:hover,.nav-list>.active>a:focus{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,0.2);background-color:#08c}.nav-list [class^="icon-"],.nav-list [class*=" icon-"]{margin-right:2px}.nav-list .divider{*width:100%;height:1px;margin:9px 1px;*margin:-5px 0 5px;overflow:hidden;background-color:#e5e5e5;border-bottom:1px solid #fff}.nav-tabs,.nav-pills{*zoom:1}.nav-tabs:before,.nav-pills:before,.nav-tabs:after,.nav-pills:after{display:table;line-height:0;content:""}.nav-tabs:after,.nav-pills:after{clear:both}.nav-tabs>li,.nav-pills>li{float:left}.nav-tabs>li>a,.nav-pills>li>a{padding-right:12px;padding-left:12px;margin-right:2px;line-height:14px}.nav-tabs{border-bottom:1px solid #ddd}.nav-tabs>li{margin-bottom:-1px}.nav-tabs>li>a{padding-top:8px;padding-bottom:8px;line-height:20px;border:1px solid transparent;-webkit-border-radius:4px 4px 0 0;-moz-border-radius:4px 4px 0 0;border-radius:4px 4px 0 0}.nav-tabs>li>a:hover,.nav-tabs>li>a:focus{border-color:#eee #eee #ddd}.nav-tabs>.active>a,.nav-tabs>.active>a:hover,.nav-tabs>.active>a:focus{color:#555;cursor:default;background-color:#fff;border:1px solid #ddd;border-bottom-color:transparent}.nav-pills>li>a{padding-top:8px;padding-bottom:8px;margin-top:2px;margin-bottom:2px;-webkit-border-radius:5px;-moz-border-radius:5px;border-radius:5px}.nav-pills>.active>a,.nav-pills>.active>a:hover,.nav-pills>.active>a:focus{color:#fff;background-color:#08c}.nav-stacked>li{float:none}.nav-stacked>li>a{margin-right:0}.nav-tabs.nav-stacked{border-bottom:0}.nav-tabs.nav-stacked>li>a{border:1px solid #ddd;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.nav-tabs.nav-stacked>li:first-child>a{-webkit-border-top-right-radius:4px;border-top-right-radius:4px;-webkit-border-top-left-radius:4px;border-top-left-radius:4px;-moz-border-radius-topright:4px;-moz-border-radius-topleft:4px}.nav-tabs.nav-stacked>li:last-child>a{-webkit-border-bottom-right-radius:4px;border-bottom-right-radius:4px;-webkit-border-bottom-left-radius:4px;border-bottom-left-radius:4px;-moz-border-radius-bottomright:4px;-moz-border-radius-bottomleft:4px}.nav-tabs.nav-stacked>li>a:hover,.nav-tabs.nav-stacked>li>a:focus{z-index:2;border-color:#ddd}.nav-pills.nav-stacked>li>a{margin-bottom:3px}.nav-pills.nav-stacked>li:last-child>a{margin-bottom:1px}.nav-tabs .dropdown-menu{-webkit-border-radius:0 0 6px 6px;-moz-border-radius:0 0 6px 6px;border-radius:0 0 6px 6px}.nav-pills .dropdown-menu{-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px}.nav .dropdown-toggle .caret{margin-top:6px;border-top-color:#08c;border-bottom-color:#08c}.nav .dropdown-toggle:hover .caret,.nav .dropdown-toggle:focus .caret{border-top-color:#005580;border-bottom-color:#005580}.nav-tabs .dropdown-toggle .caret{margin-top:8px}.nav .active .dropdown-toggle .caret{border-top-color:#fff;border-bottom-color:#fff}.nav-tabs .active .dropdown-toggle .caret{border-top-color:#555;border-bottom-color:#555}.nav>.dropdown.active>a:hover,.nav>.dropdown.active>a:focus{cursor:pointer}.nav-tabs .open .dropdown-toggle,.nav-pills .open .dropdown-toggle,.nav>li.dropdown.open.active>a:hover,.nav>li.dropdown.open.active>a:focus{color:#fff;background-color:#999;border-color:#999}.nav li.dropdown.open .caret,.nav li.dropdown.open.active .caret,.nav li.dropdown.open a:hover .caret,.nav li.dropdown.open a:focus .caret{border-top-color:#fff;border-bottom-color:#fff;opacity:1;filter:alpha(opacity=100)}.tabs-stacked .open>a:hover,.tabs-stacked .open>a:focus{border-color:#999}.tabbable{*zoom:1}.tabbable:before,.tabbable:after{display:table;line-height:0;content:""}.tabbable:after{clear:both}.tab-content{overflow:auto}.tabs-below>.nav-tabs,.tabs-right>.nav-tabs,.tabs-left>.nav-tabs{border-bottom:0}.tab-content>.tab-pane,.pill-content>.pill-pane{display:none}.tab-content>.active,.pill-content>.active{display:block}.tabs-below>.nav-tabs{border-top:1px solid #ddd}.tabs-below>.nav-tabs>li{margin-top:-1px;margin-bottom:0}.tabs-below>.nav-tabs>li>a{-webkit-border-radius:0 0 4px 4px;-moz-border-radius:0 0 4px 4px;border-radius:0 0 4px 4px}.tabs-below>.nav-tabs>li>a:hover,.tabs-below>.nav-tabs>li>a:focus{border-top-color:#ddd;border-bottom-color:transparent}.tabs-below>.nav-tabs>.active>a,.tabs-below>.nav-tabs>.active>a:hover,.tabs-below>.nav-tabs>.active>a:focus{border-color:transparent #ddd #ddd #ddd}.tabs-left>.nav-tabs>li,.tabs-right>.nav-tabs>li{float:none}.tabs-left>.nav-tabs>li>a,.tabs-right>.nav-tabs>li>a{min-width:74px;margin-right:0;margin-bottom:3px}.tabs-left>.nav-tabs{float:left;margin-right:19px;border-right:1px solid #ddd}.tabs-left>.nav-tabs>li>a{margin-right:-1px;-webkit-border-radius:4px 0 0 4px;-moz-border-radius:4px 0 0 4px;border-radius:4px 0 0 4px}.tabs-left>.nav-tabs>li>a:hover,.tabs-left>.nav-tabs>li>a:focus{border-color:#eee #ddd #eee #eee}.tabs-left>.nav-tabs .active>a,.tabs-left>.nav-tabs .active>a:hover,.tabs-left>.nav-tabs .active>a:focus{border-color:#ddd transparent #ddd #ddd;*border-right-color:#fff}.tabs-right>.nav-tabs{float:right;margin-left:19px;border-left:1px solid #ddd}.tabs-right>.nav-tabs>li>a{margin-left:-1px;-webkit-border-radius:0 4px 4px 0;-moz-border-radius:0 4px 4px 0;border-radius:0 4px 4px 0}.tabs-right>.nav-tabs>li>a:hover,.tabs-right>.nav-tabs>li>a:focus{border-color:#eee #eee #eee #ddd}.tabs-right>.nav-tabs .active>a,.tabs-right>.nav-tabs .active>a:hover,.tabs-right>.nav-tabs .active>a:focus{border-color:#ddd #ddd #ddd transparent;*border-left-color:#fff}.nav>.disabled>a{color:#999}.nav>.disabled>a:hover,.nav>.disabled>a:focus{text-decoration:none;cursor:default;background-color:transparent}.navbar{*position:relative;*z-index:2;margin-bottom:20px;overflow:visible}.navbar-inner{min-height:40px;padding-right:20px;padding-left:20px;background-color:#fafafa;background-image:-moz-linear-gradient(top,#fff,#f2f2f2);background-image:-webkit-gradient(linear,0 0,0 100%,from(#fff),to(#f2f2f2));background-image:-webkit-linear-gradient(top,#fff,#f2f2f2);background-image:-o-linear-gradient(top,#fff,#f2f2f2);background-image:linear-gradient(to bottom,#fff,#f2f2f2);background-repeat:repeat-x;border:1px solid #d4d4d4;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffffffff',endColorstr='#fff2f2f2',GradientType=0);*zoom:1;-webkit-box-shadow:0 1px 4px rgba(0,0,0,0.065);-moz-box-shadow:0 1px 4px rgba(0,0,0,0.065);box-shadow:0 1px 4px rgba(0,0,0,0.065)}.navbar-inner:before,.navbar-inner:after{display:table;line-height:0;content:""}.navbar-inner:after{clear:both}.navbar .container{width:auto}.nav-collapse.collapse{height:auto;overflow:visible}.navbar .brand{display:block;float:left;padding:10px 20px 10px;margin-left:-20px;font-size:20px;font-weight:200;color:#777;text-shadow:0 1px 0 #fff}.navbar .brand:hover,.navbar .brand:focus{text-decoration:none}.navbar-text{margin-bottom:0;line-height:40px;color:#777}.navbar-link{color:#777}.navbar-link:hover,.navbar-link:focus{color:#333}.navbar .divider-vertical{height:40px;margin:0 9px;border-right:1px solid #fff;border-left:1px solid #f2f2f2}.navbar .btn,.navbar .btn-group{margin-top:5px}.navbar .btn-group .btn,.navbar .input-prepend .btn,.navbar .input-append .btn,.navbar .input-prepend .btn-group,.navbar .input-append .btn-group{margin-top:0}.navbar-form{margin-bottom:0;*zoom:1}.navbar-form:before,.navbar-form:after{display:table;line-height:0;content:""}.navbar-form:after{clear:both}.navbar-form input,.navbar-form select,.navbar-form .radio,.navbar-form .checkbox{margin-top:5px}.navbar-form input,.navbar-form select,.navbar-form .btn{display:inline-block;margin-bottom:0}.navbar-form input[type="image"],.navbar-form input[type="checkbox"],.navbar-form input[type="radio"]{margin-top:3px}.navbar-form .input-append,.navbar-form .input-prepend{margin-top:5px;white-space:nowrap}.navbar-form .input-append input,.navbar-form .input-prepend input{margin-top:0}.navbar-search{position:relative;float:left;margin-top:5px;margin-bottom:0}.navbar-search .search-query{padding:4px 14px;margin-bottom:0;font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;font-size:13px;font-weight:normal;line-height:1;-webkit-border-radius:15px;-moz-border-radius:15px;border-radius:15px}.navbar-static-top{position:static;margin-bottom:0}.navbar-static-top .navbar-inner{-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.navbar-fixed-top,.navbar-fixed-bottom{position:fixed;right:0;left:0;z-index:1030;margin-bottom:0}.navbar-fixed-top .navbar-inner,.navbar-static-top .navbar-inner{border-width:0 0 1px}.navbar-fixed-bottom .navbar-inner{border-width:1px 0 0}.navbar-fixed-top .navbar-inner,.navbar-fixed-bottom .navbar-inner{padding-right:0;padding-left:0;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.navbar-static-top .container,.navbar-fixed-top .container,.navbar-fixed-bottom .container{width:940px}.navbar-fixed-top{top:0}.navbar-fixed-top .navbar-inner,.navbar-static-top .navbar-inner{-webkit-box-shadow:0 1px 10px rgba(0,0,0,0.1);-moz-box-shadow:0 1px 10px rgba(0,0,0,0.1);box-shadow:0 1px 10px rgba(0,0,0,0.1)}.navbar-fixed-bottom{bottom:0}.navbar-fixed-bottom .navbar-inner{-webkit-box-shadow:0 -1px 10px rgba(0,0,0,0.1);-moz-box-shadow:0 -1px 10px rgba(0,0,0,0.1);box-shadow:0 -1px 10px rgba(0,0,0,0.1)}.navbar .nav{position:relative;left:0;display:block;float:left;margin:0 10px 0 0}.navbar .nav.pull-right{float:right;margin-right:0}.navbar .nav>li{float:left}.navbar .nav>li>a{float:none;padding:10px 15px 10px;color:#777;text-decoration:none;text-shadow:0 1px 0 #fff}.navbar .nav .dropdown-toggle .caret{margin-top:8px}.navbar .nav>li>a:focus,.navbar .nav>li>a:hover{color:#333;text-decoration:none;background-color:transparent}.navbar .nav>.active>a,.navbar .nav>.active>a:hover,.navbar .nav>.active>a:focus{color:#555;text-decoration:none;background-color:#e5e5e5;-webkit-box-shadow:inset 0 3px 8px rgba(0,0,0,0.125);-moz-box-shadow:inset 0 3px 8px rgba(0,0,0,0.125);box-shadow:inset 0 3px 8px rgba(0,0,0,0.125)}.navbar .btn-navbar{display:none;float:right;padding:7px 10px;margin-right:5px;margin-left:5px;color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,0.25);background-color:#ededed;*background-color:#e5e5e5;background-image:-moz-linear-gradient(top,#f2f2f2,#e5e5e5);background-image:-webkit-gradient(linear,0 0,0 100%,from(#f2f2f2),to(#e5e5e5));background-image:-webkit-linear-gradient(top,#f2f2f2,#e5e5e5);background-image:-o-linear-gradient(top,#f2f2f2,#e5e5e5);background-image:linear-gradient(to bottom,#f2f2f2,#e5e5e5);background-repeat:repeat-x;border-color:#e5e5e5 #e5e5e5 #bfbfbf;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#fff2f2f2',endColorstr='#ffe5e5e5',GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false);-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,0.1),0 1px 0 rgba(255,255,255,0.075);-moz-box-shadow:inset 0 1px 0 rgba(255,255,255,0.1),0 1px 0 rgba(255,255,255,0.075);box-shadow:inset 0 1px 0 rgba(255,255,255,0.1),0 1px 0 rgba(255,255,255,0.075)}.navbar .btn-navbar:hover,.navbar .btn-navbar:focus,.navbar .btn-navbar:active,.navbar .btn-navbar.active,.navbar .btn-navbar.disabled,.navbar .btn-navbar[disabled]{color:#fff;background-color:#e5e5e5;*background-color:#d9d9d9}.navbar .btn-navbar:active,.navbar .btn-navbar.active{background-color:#ccc \9}.navbar .btn-navbar .icon-bar{display:block;width:18px;height:2px;background-color:#f5f5f5;-webkit-border-radius:1px;-moz-border-radius:1px;border-radius:1px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,0.25);-moz-box-shadow:0 1px 0 rgba(0,0,0,0.25);box-shadow:0 1px 0 rgba(0,0,0,0.25)}.btn-navbar .icon-bar+.icon-bar{margin-top:3px}.navbar .nav>li>.dropdown-menu:before{position:absolute;top:-7px;left:9px;display:inline-block;border-right:7px solid transparent;border-bottom:7px solid #ccc;border-left:7px solid transparent;border-bottom-color:rgba(0,0,0,0.2);content:''}.navbar .nav>li>.dropdown-menu:after{position:absolute;top:-6px;left:10px;display:inline-block;border-right:6px solid transparent;border-bottom:6px solid #fff;border-left:6px solid transparent;content:''}.navbar-fixed-bottom .nav>li>.dropdown-menu:before{top:auto;bottom:-7px;border-top:7px solid #ccc;border-bottom:0;border-top-color:rgba(0,0,0,0.2)}.navbar-fixed-bottom .nav>li>.dropdown-menu:after{top:auto;bottom:-6px;border-top:6px solid #fff;border-bottom:0}.navbar .nav li.dropdown>a:hover .caret,.navbar .nav li.dropdown>a:focus .caret{border-top-color:#333;border-bottom-color:#333}.navbar .nav li.dropdown.open>.dropdown-toggle,.navbar .nav li.dropdown.active>.dropdown-toggle,.navbar .nav li.dropdown.open.active>.dropdown-toggle{color:#555;background-color:#e5e5e5}.navbar .nav li.dropdown>.dropdown-toggle .caret{border-top-color:#777;border-bottom-color:#777}.navbar .nav li.dropdown.open>.dropdown-toggle .caret,.navbar .nav li.dropdown.active>.dropdown-toggle .caret,.navbar .nav li.dropdown.open.active>.dropdown-toggle .caret{border-top-color:#555;border-bottom-color:#555}.navbar .pull-right>li>.dropdown-menu,.navbar .nav>li>.dropdown-menu.pull-right{right:0;left:auto}.navbar .pull-right>li>.dropdown-menu:before,.navbar .nav>li>.dropdown-menu.pull-right:before{right:12px;left:auto}.navbar .pull-right>li>.dropdown-menu:after,.navbar .nav>li>.dropdown-menu.pull-right:after{right:13px;left:auto}.navbar .pull-right>li>.dropdown-menu .dropdown-menu,.navbar .nav>li>.dropdown-menu.pull-right .dropdown-menu{right:100%;left:auto;margin-right:-1px;margin-left:0;-webkit-border-radius:6px 0 6px 6px;-moz-border-radius:6px 0 6px 6px;border-radius:6px 0 6px 6px}.navbar-inverse .navbar-inner{background-color:#1b1b1b;background-image:-moz-linear-gradient(top,#222,#111);background-image:-webkit-gradient(linear,0 0,0 100%,from(#222),to(#111));background-image:-webkit-linear-gradient(top,#222,#111);background-image:-o-linear-gradient(top,#222,#111);background-image:linear-gradient(to bottom,#222,#111);background-repeat:repeat-x;border-color:#252525;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff222222',endColorstr='#ff111111',GradientType=0)}.navbar-inverse .brand,.navbar-inverse .nav>li>a{color:#999;text-shadow:0 -1px 0 rgba(0,0,0,0.25)}.navbar-inverse .brand:hover,.navbar-inverse .nav>li>a:hover,.navbar-inverse .brand:focus,.navbar-inverse .nav>li>a:focus{color:#fff}.navbar-inverse .brand{color:#999}.navbar-inverse .navbar-text{color:#999}.navbar-inverse .nav>li>a:focus,.navbar-inverse .nav>li>a:hover{color:#fff;background-color:transparent}.navbar-inverse .nav .active>a,.navbar-inverse .nav .active>a:hover,.navbar-inverse .nav .active>a:focus{color:#fff;background-color:#111}.navbar-inverse .navbar-link{color:#999}.navbar-inverse .navbar-link:hover,.navbar-inverse .navbar-link:focus{color:#fff}.navbar-inverse .divider-vertical{border-right-color:#222;border-left-color:#111}.navbar-inverse .nav li.dropdown.open>.dropdown-toggle,.navbar-inverse .nav li.dropdown.active>.dropdown-toggle,.navbar-inverse .nav li.dropdown.open.active>.dropdown-toggle{color:#fff;background-color:#111}.navbar-inverse .nav li.dropdown>a:hover .caret,.navbar-inverse .nav li.dropdown>a:focus .caret{border-top-color:#fff;border-bottom-color:#fff}.navbar-inverse .nav li.dropdown>.dropdown-toggle .caret{border-top-color:#999;border-bottom-color:#999}.navbar-inverse .nav li.dropdown.open>.dropdown-toggle .caret,.navbar-inverse .nav li.dropdown.active>.dropdown-toggle .caret,.navbar-inverse .nav li.dropdown.open.active>.dropdown-toggle .caret{border-top-color:#fff;border-bottom-color:#fff}.navbar-inverse .navbar-search .search-query{color:#fff;background-color:#515151;border-color:#111;-webkit-box-shadow:inset 0 1px 2px rgba(0,0,0,0.1),0 1px 0 rgba(255,255,255,0.15);-moz-box-shadow:inset 0 1px 2px rgba(0,0,0,0.1),0 1px 0 rgba(255,255,255,0.15);box-shadow:inset 0 1px 2px rgba(0,0,0,0.1),0 1px 0 rgba(255,255,255,0.15);-webkit-transition:none;-moz-transition:none;-o-transition:none;transition:none}.navbar-inverse .navbar-search .search-query:-moz-placeholder{color:#ccc}.navbar-inverse .navbar-search .search-query:-ms-input-placeholder{color:#ccc}.navbar-inverse .navbar-search .search-query::-webkit-input-placeholder{color:#ccc}.navbar-inverse .navbar-search .search-query:focus,.navbar-inverse .navbar-search .search-query.focused{padding:5px 15px;color:#333;text-shadow:0 1px 0 #fff;background-color:#fff;border:0;outline:0;-webkit-box-shadow:0 0 3px rgba(0,0,0,0.15);-moz-box-shadow:0 0 3px rgba(0,0,0,0.15);box-shadow:0 0 3px rgba(0,0,0,0.15)}.navbar-inverse .btn-navbar{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,0.25);background-color:#0e0e0e;*background-color:#040404;background-image:-moz-linear-gradient(top,#151515,#040404);background-image:-webkit-gradient(linear,0 0,0 100%,from(#151515),to(#040404));background-image:-webkit-linear-gradient(top,#151515,#040404);background-image:-o-linear-gradient(top,#151515,#040404);background-image:linear-gradient(to bottom,#151515,#040404);background-repeat:repeat-x;border-color:#040404 #040404 #000;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff151515',endColorstr='#ff040404',GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false)}.navbar-inverse .btn-navbar:hover,.navbar-inverse .btn-navbar:focus,.navbar-inverse .btn-navbar:active,.navbar-inverse .btn-navbar.active,.navbar-inverse .btn-navbar.disabled,.navbar-inverse .btn-navbar[disabled]{color:#fff;background-color:#040404;*background-color:#000}.navbar-inverse .btn-navbar:active,.navbar-inverse .btn-navbar.active{background-color:#000 \9}.breadcrumb{padding:8px 15px;margin:0 0 20px;list-style:none;background-color:#f5f5f5;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}.breadcrumb>li{display:inline-block;*display:inline;text-shadow:0 1px 0 #fff;*zoom:1}.breadcrumb>li>.divider{padding:0 5px;color:#ccc}.breadcrumb>.active{color:#999}.pagination{margin:20px 0}.pagination ul{display:inline-block;*display:inline;margin-bottom:0;margin-left:0;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px;*zoom:1;-webkit-box-shadow:0 1px 2px rgba(0,0,0,0.05);-moz-box-shadow:0 1px 2px rgba(0,0,0,0.05);box-shadow:0 1px 2px rgba(0,0,0,0.05)}.pagination ul>li{display:inline}.pagination ul>li>a,.pagination ul>li>span{float:left;padding:4px 12px;line-height:20px;text-decoration:none;background-color:#fff;border:1px solid #ddd;border-left-width:0}.pagination ul>li>a:hover,.pagination ul>li>a:focus,.pagination ul>.active>a,.pagination ul>.active>span{background-color:#f5f5f5}.pagination ul>.active>a,.pagination ul>.active>span{color:#999;cursor:default}.pagination ul>.disabled>span,.pagination ul>.disabled>a,.pagination ul>.disabled>a:hover,.pagination ul>.disabled>a:focus{color:#999;cursor:default;background-color:transparent}.pagination ul>li:first-child>a,.pagination ul>li:first-child>span{border-left-width:1px;-webkit-border-bottom-left-radius:4px;border-bottom-left-radius:4px;-webkit-border-top-left-radius:4px;border-top-left-radius:4px;-moz-border-radius-bottomleft:4px;-moz-border-radius-topleft:4px}.pagination ul>li:last-child>a,.pagination ul>li:last-child>span{-webkit-border-top-right-radius:4px;border-top-right-radius:4px;-webkit-border-bottom-right-radius:4px;border-bottom-right-radius:4px;-moz-border-radius-topright:4px;-moz-border-radius-bottomright:4px}.pagination-centered{text-align:center}.pagination-right{text-align:right}.pagination-large ul>li>a,.pagination-large ul>li>span{padding:11px 19px;font-size:17.5px}.pagination-large ul>li:first-child>a,.pagination-large ul>li:first-child>span{-webkit-border-bottom-left-radius:6px;border-bottom-left-radius:6px;-webkit-border-top-left-radius:6px;border-top-left-radius:6px;-moz-border-radius-bottomleft:6px;-moz-border-radius-topleft:6px}.pagination-large ul>li:last-child>a,.pagination-large ul>li:last-child>span{-webkit-border-top-right-radius:6px;border-top-right-radius:6px;-webkit-border-bottom-right-radius:6px;border-bottom-right-radius:6px;-moz-border-radius-topright:6px;-moz-border-radius-bottomright:6px}.pagination-mini ul>li:first-child>a,.pagination-small ul>li:first-child>a,.pagination-mini ul>li:first-child>span,.pagination-small ul>li:first-child>span{-webkit-border-bottom-left-radius:3px;border-bottom-left-radius:3px;-webkit-border-top-left-radius:3px;border-top-left-radius:3px;-moz-border-radius-bottomleft:3px;-moz-border-radius-topleft:3px}.pagination-mini ul>li:last-child>a,.pagination-small ul>li:last-child>a,.pagination-mini ul>li:last-child>span,.pagination-small ul>li:last-child>span{-webkit-border-top-right-radius:3px;border-top-right-radius:3px;-webkit-border-bottom-right-radius:3px;border-bottom-right-radius:3px;-moz-border-radius-topright:3px;-moz-border-radius-bottomright:3px}.pagination-small ul>li>a,.pagination-small ul>li>span{padding:2px 10px;font-size:11.9px}.pagination-mini ul>li>a,.pagination-mini ul>li>span{padding:0 6px;font-size:10.5px}.pager{margin:20px 0;text-align:center;list-style:none;*zoom:1}.pager:before,.pager:after{display:table;line-height:0;content:""}.pager:after{clear:both}.pager li{display:inline}.pager li>a,.pager li>span{display:inline-block;padding:5px 14px;background-color:#fff;border:1px solid #ddd;-webkit-border-radius:15px;-moz-border-radius:15px;border-radius:15px}.pager li>a:hover,.pager li>a:focus{text-decoration:none;background-color:#f5f5f5}.pager .next>a,.pager .next>span{float:right}.pager .previous>a,.pager .previous>span{float:left}.pager .disabled>a,.pager .disabled>a:hover,.pager .disabled>a:focus,.pager .disabled>span{color:#999;cursor:default;background-color:#fff}.modal-backdrop{position:fixed;top:0;right:0;bottom:0;left:0;z-index:1040;background-color:#000}.modal-backdrop.fade{opacity:0}.modal-backdrop,.modal-backdrop.fade.in{opacity:.8;filter:alpha(opacity=80)}.modal{position:fixed;top:10%;left:50%;z-index:1050;width:560px;margin-left:-280px;background-color:#fff;border:1px solid #999;border:1px solid rgba(0,0,0,0.3);*border:1px solid #999;-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px;outline:0;-webkit-box-shadow:0 3px 7px rgba(0,0,0,0.3);-moz-box-shadow:0 3px 7px rgba(0,0,0,0.3);box-shadow:0 3px 7px rgba(0,0,0,0.3);-webkit-background-clip:padding-box;-moz-background-clip:padding-box;background-clip:padding-box}.modal.fade{top:-25%;-webkit-transition:opacity .3s linear,top .3s ease-out;-moz-transition:opacity .3s linear,top .3s ease-out;-o-transition:opacity .3s linear,top .3s ease-out;transition:opacity .3s linear,top .3s ease-out}.modal.fade.in{top:10%}.modal-header{padding:9px 15px;border-bottom:1px solid #eee}.modal-header .close{margin-top:2px}.modal-header h3{margin:0;line-height:30px}.modal-body{position:relative;max-height:400px;padding:15px;overflow-y:auto}.modal-form{margin-bottom:0}.modal-footer{padding:14px 15px 15px;margin-bottom:0;text-align:right;background-color:#f5f5f5;border-top:1px solid #ddd;-webkit-border-radius:0 0 6px 6px;-moz-border-radius:0 0 6px 6px;border-radius:0 0 6px 6px;*zoom:1;-webkit-box-shadow:inset 0 1px 0 #fff;-moz-box-shadow:inset 0 1px 0 #fff;box-shadow:inset 0 1px 0 #fff}.modal-footer:before,.modal-footer:after{display:table;line-height:0;content:""}.modal-footer:after{clear:both}.modal-footer .btn+.btn{margin-bottom:0;margin-left:5px}.modal-footer .btn-group .btn+.btn{margin-left:-1px}.modal-footer .btn-block+.btn-block{margin-left:0}.tooltip{position:absolute;z-index:1030;display:block;font-size:11px;line-height:1.4;opacity:0;filter:alpha(opacity=0);visibility:visible}.tooltip.in{opacity:.8;filter:alpha(opacity=80)}.tooltip.top{padding:5px 0;margin-top:-3px}.tooltip.right{padding:0 5px;margin-left:3px}.tooltip.bottom{padding:5px 0;margin-top:3px}.tooltip.left{padding:0 5px;margin-left:-3px}.tooltip-inner{max-width:200px;padding:8px;color:#fff;text-align:center;text-decoration:none;background-color:#000;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}.tooltip-arrow{position:absolute;width:0;height:0;border-color:transparent;border-style:solid}.tooltip.top .tooltip-arrow{bottom:0;left:50%;margin-left:-5px;border-top-color:#000;border-width:5px 5px 0}.tooltip.right .tooltip-arrow{top:50%;left:0;margin-top:-5px;border-right-color:#000;border-width:5px 5px 5px 0}.tooltip.left .tooltip-arrow{top:50%;right:0;margin-top:-5px;border-left-color:#000;border-width:5px 0 5px 5px}.tooltip.bottom .tooltip-arrow{top:0;left:50%;margin-left:-5px;border-bottom-color:#000;border-width:0 5px 5px}.popover{position:absolute;top:0;left:0;z-index:1010;display:none;max-width:276px;padding:1px;text-align:left;white-space:normal;background-color:#fff;border:1px solid #ccc;border:1px solid rgba(0,0,0,0.2);-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px;-webkit-box-shadow:0 5px 10px rgba(0,0,0,0.2);-moz-box-shadow:0 5px 10px rgba(0,0,0,0.2);box-shadow:0 5px 10px rgba(0,0,0,0.2);-webkit-background-clip:padding-box;-moz-background-clip:padding;background-clip:padding-box}.popover.top{margin-top:-10px}.popover.right{margin-left:10px}.popover.bottom{margin-top:10px}.popover.left{margin-left:-10px}.popover-title{padding:8px 14px;margin:0;font-size:14px;font-weight:normal;line-height:18px;background-color:#f7f7f7;border-bottom:1px solid #ebebeb;-webkit-border-radius:5px 5px 0 0;-moz-border-radius:5px 5px 0 0;border-radius:5px 5px 0 0}.popover-title:empty{display:none}.popover-content{padding:9px 14px}.popover .arrow,.popover .arrow:after{position:absolute;display:block;width:0;height:0;border-color:transparent;border-style:solid}.popover .arrow{border-width:11px}.popover .arrow:after{border-width:10px;content:""}.popover.top .arrow{bottom:-11px;left:50%;margin-left:-11px;border-top-color:#999;border-top-color:rgba(0,0,0,0.25);border-bottom-width:0}.popover.top .arrow:after{bottom:1px;margin-left:-10px;border-top-color:#fff;border-bottom-width:0}.popover.right .arrow{top:50%;left:-11px;margin-top:-11px;border-right-color:#999;border-right-color:rgba(0,0,0,0.25);border-left-width:0}.popover.right .arrow:after{bottom:-10px;left:1px;border-right-color:#fff;border-left-width:0}.popover.bottom .arrow{top:-11px;left:50%;margin-left:-11px;border-bottom-color:#999;border-bottom-color:rgba(0,0,0,0.25);border-top-width:0}.popover.bottom .arrow:after{top:1px;margin-left:-10px;border-bottom-color:#fff;border-top-width:0}.popover.left .arrow{top:50%;right:-11px;margin-top:-11px;border-left-color:#999;border-left-color:rgba(0,0,0,0.25);border-right-width:0}.popover.left .arrow:after{right:1px;bottom:-10px;border-left-color:#fff;border-right-width:0}.thumbnails{margin-left:-20px;list-style:none;*zoom:1}.thumbnails:before,.thumbnails:after{display:table;line-height:0;content:""}.thumbnails:after{clear:both}.row-fluid .thumbnails{margin-left:0}.thumbnails>li{float:left;margin-bottom:20px;margin-left:20px}.thumbnail{display:block;padding:4px;line-height:20px;border:1px solid #ddd;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px;-webkit-box-shadow:0 1px 3px rgba(0,0,0,0.055);-moz-box-shadow:0 1px 3px rgba(0,0,0,0.055);box-shadow:0 1px 3px rgba(0,0,0,0.055);-webkit-transition:all .2s ease-in-out;-moz-transition:all .2s ease-in-out;-o-transition:all .2s ease-in-out;transition:all .2s ease-in-out}a.thumbnail:hover,a.thumbnail:focus{border-color:#08c;-webkit-box-shadow:0 1px 4px rgba(0,105,214,0.25);-moz-box-shadow:0 1px 4px rgba(0,105,214,0.25);box-shadow:0 1px 4px rgba(0,105,214,0.25)}.thumbnail>img{display:block;max-width:100%;margin-right:auto;margin-left:auto}.thumbnail .caption{padding:9px;color:#555}.media,.media-body{overflow:hidden;*overflow:visible;zoom:1}.media,.media .media{margin-top:15px}.media:first-child{margin-top:0}.media-object{display:block}.media-heading{margin:0 0 5px}.media>.pull-left{margin-right:10px}.media>.pull-right{margin-left:10px}.media-list{margin-left:0;list-style:none}.label,.badge{display:inline-block;padding:2px 4px;font-size:11.844px;font-weight:bold;line-height:14px;color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,0.25);white-space:nowrap;vertical-align:baseline;background-color:#999}.label{-webkit-border-radius:3px;-moz-border-radius:3px;border-radius:3px}.badge{padding-right:9px;padding-left:9px;-webkit-border-radius:9px;-moz-border-radius:9px;border-radius:9px}.label:empty,.badge:empty{display:none}a.label:hover,a.label:focus,a.badge:hover,a.badge:focus{color:#fff;text-decoration:none;cursor:pointer}.label-important,.badge-important{background-color:#b94a48}.label-important[href],.badge-important[href]{background-color:#953b39}.label-warning,.badge-warning{background-color:#f89406}.label-warning[href],.badge-warning[href]{background-color:#c67605}.label-success,.badge-success{background-color:#468847}.label-success[href],.badge-success[href]{background-color:#356635}.label-info,.badge-info{background-color:#3a87ad}.label-info[href],.badge-info[href]{background-color:#2d6987}.label-inverse,.badge-inverse{background-color:#333}.label-inverse[href],.badge-inverse[href]{background-color:#1a1a1a}.btn .label,.btn .badge{position:relative;top:-1px}.btn-mini .label,.btn-mini .badge{top:0}@-webkit-keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}@-moz-keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}@-ms-keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}@-o-keyframes progress-bar-stripes{from{background-position:0 0}to{background-position:40px 0}}@keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}.progress{height:20px;margin-bottom:20px;overflow:hidden;background-color:#f7f7f7;background-image:-moz-linear-gradient(top,#f5f5f5,#f9f9f9);background-image:-webkit-gradient(linear,0 0,0 100%,from(#f5f5f5),to(#f9f9f9));background-image:-webkit-linear-gradient(top,#f5f5f5,#f9f9f9);background-image:-o-linear-gradient(top,#f5f5f5,#f9f9f9);background-image:linear-gradient(to bottom,#f5f5f5,#f9f9f9);background-repeat:repeat-x;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#fff5f5f5',endColorstr='#fff9f9f9',GradientType=0);-webkit-box-shadow:inset 0 1px 2px rgba(0,0,0,0.1);-moz-box-shadow:inset 0 1px 2px rgba(0,0,0,0.1);box-shadow:inset 0 1px 2px rgba(0,0,0,0.1)}.progress .bar{float:left;width:0;height:100%;font-size:12px;color:#fff;text-align:center;text-shadow:0 -1px 0 rgba(0,0,0,0.25);background-color:#0e90d2;background-image:-moz-linear-gradient(top,#149bdf,#0480be);background-image:-webkit-gradient(linear,0 0,0 100%,from(#149bdf),to(#0480be));background-image:-webkit-linear-gradient(top,#149bdf,#0480be);background-image:-o-linear-gradient(top,#149bdf,#0480be);background-image:linear-gradient(to bottom,#149bdf,#0480be);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff149bdf',endColorstr='#ff0480be',GradientType=0);-webkit-box-shadow:inset 0 -1px 0 rgba(0,0,0,0.15);-moz-box-shadow:inset 0 -1px 0 rgba(0,0,0,0.15);box-shadow:inset 0 -1px 0 rgba(0,0,0,0.15);-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;-webkit-transition:width .6s ease;-moz-transition:width .6s ease;-o-transition:width .6s ease;transition:width .6s ease}.progress .bar+.bar{-webkit-box-shadow:inset 1px 0 0 rgba(0,0,0,0.15),inset 0 -1px 0 rgba(0,0,0,0.15);-moz-box-shadow:inset 1px 0 0 rgba(0,0,0,0.15),inset 0 -1px 0 rgba(0,0,0,0.15);box-shadow:inset 1px 0 0 rgba(0,0,0,0.15),inset 0 -1px 0 rgba(0,0,0,0.15)}.progress-striped .bar{background-color:#149bdf;background-image:-webkit-gradient(linear,0 100%,100% 0,color-stop(0.25,rgba(255,255,255,0.15)),color-stop(0.25,transparent),color-stop(0.5,transparent),color-stop(0.5,rgba(255,255,255,0.15)),color-stop(0.75,rgba(255,255,255,0.15)),color-stop(0.75,transparent),to(transparent));background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-moz-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);-webkit-background-size:40px 40px;-moz-background-size:40px 40px;-o-background-size:40px 40px;background-size:40px 40px}.progress.active .bar{-webkit-animation:progress-bar-stripes 2s linear infinite;-moz-animation:progress-bar-stripes 2s linear infinite;-ms-animation:progress-bar-stripes 2s linear infinite;-o-animation:progress-bar-stripes 2s linear infinite;animation:progress-bar-stripes 2s linear infinite}.progress-danger .bar,.progress .bar-danger{background-color:#dd514c;background-image:-moz-linear-gradient(top,#ee5f5b,#c43c35);background-image:-webkit-gradient(linear,0 0,0 100%,from(#ee5f5b),to(#c43c35));background-image:-webkit-linear-gradient(top,#ee5f5b,#c43c35);background-image:-o-linear-gradient(top,#ee5f5b,#c43c35);background-image:linear-gradient(to bottom,#ee5f5b,#c43c35);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffee5f5b',endColorstr='#ffc43c35',GradientType=0)}.progress-danger.progress-striped .bar,.progress-striped .bar-danger{background-color:#ee5f5b;background-image:-webkit-gradient(linear,0 100%,100% 0,color-stop(0.25,rgba(255,255,255,0.15)),color-stop(0.25,transparent),color-stop(0.5,transparent),color-stop(0.5,rgba(255,255,255,0.15)),color-stop(0.75,rgba(255,255,255,0.15)),color-stop(0.75,transparent),to(transparent));background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-moz-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent)}.progress-success .bar,.progress .bar-success{background-color:#5eb95e;background-image:-moz-linear-gradient(top,#62c462,#57a957);background-image:-webkit-gradient(linear,0 0,0 100%,from(#62c462),to(#57a957));background-image:-webkit-linear-gradient(top,#62c462,#57a957);background-image:-o-linear-gradient(top,#62c462,#57a957);background-image:linear-gradient(to bottom,#62c462,#57a957);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff62c462',endColorstr='#ff57a957',GradientType=0)}.progress-success.progress-striped .bar,.progress-striped .bar-success{background-color:#62c462;background-image:-webkit-gradient(linear,0 100%,100% 0,color-stop(0.25,rgba(255,255,255,0.15)),color-stop(0.25,transparent),color-stop(0.5,transparent),color-stop(0.5,rgba(255,255,255,0.15)),color-stop(0.75,rgba(255,255,255,0.15)),color-stop(0.75,transparent),to(transparent));background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-moz-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent)}.progress-info .bar,.progress .bar-info{background-color:#4bb1cf;background-image:-moz-linear-gradient(top,#5bc0de,#339bb9);background-image:-webkit-gradient(linear,0 0,0 100%,from(#5bc0de),to(#339bb9));background-image:-webkit-linear-gradient(top,#5bc0de,#339bb9);background-image:-o-linear-gradient(top,#5bc0de,#339bb9);background-image:linear-gradient(to bottom,#5bc0de,#339bb9);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff5bc0de',endColorstr='#ff339bb9',GradientType=0)}.progress-info.progress-striped .bar,.progress-striped .bar-info{background-color:#5bc0de;background-image:-webkit-gradient(linear,0 100%,100% 0,color-stop(0.25,rgba(255,255,255,0.15)),color-stop(0.25,transparent),color-stop(0.5,transparent),color-stop(0.5,rgba(255,255,255,0.15)),color-stop(0.75,rgba(255,255,255,0.15)),color-stop(0.75,transparent),to(transparent));background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-moz-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent)}.progress-warning .bar,.progress .bar-warning{background-color:#faa732;background-image:-moz-linear-gradient(top,#fbb450,#f89406);background-image:-webkit-gradient(linear,0 0,0 100%,from(#fbb450),to(#f89406));background-image:-webkit-linear-gradient(top,#fbb450,#f89406);background-image:-o-linear-gradient(top,#fbb450,#f89406);background-image:linear-gradient(to bottom,#fbb450,#f89406);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#fffbb450',endColorstr='#fff89406',GradientType=0)}.progress-warning.progress-striped .bar,.progress-striped .bar-warning{background-color:#fbb450;background-image:-webkit-gradient(linear,0 100%,100% 0,color-stop(0.25,rgba(255,255,255,0.15)),color-stop(0.25,transparent),color-stop(0.5,transparent),color-stop(0.5,rgba(255,255,255,0.15)),color-stop(0.75,rgba(255,255,255,0.15)),color-stop(0.75,transparent),to(transparent));background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-moz-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent)}.accordion{margin-bottom:20px}.accordion-group{margin-bottom:2px;border:1px solid #e5e5e5;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}.accordion-heading{border-bottom:0}.accordion-heading .accordion-toggle{display:block;padding:8px 15px}.accordion-toggle{cursor:pointer}.accordion-inner{padding:9px 15px;border-top:1px solid #e5e5e5}.carousel{position:relative;margin-bottom:20px;line-height:1}.carousel-inner{position:relative;width:100%;overflow:hidden}.carousel-inner>.item{position:relative;display:none;-webkit-transition:.6s ease-in-out left;-moz-transition:.6s ease-in-out left;-o-transition:.6s ease-in-out left;transition:.6s ease-in-out left}.carousel-inner>.item>img,.carousel-inner>.item>a>img{display:block;line-height:1}.carousel-inner>.active,.carousel-inner>.next,.carousel-inner>.prev{display:block}.carousel-inner>.active{left:0}.carousel-inner>.next,.carousel-inner>.prev{position:absolute;top:0;width:100%}.carousel-inner>.next{left:100%}.carousel-inner>.prev{left:-100%}.carousel-inner>.next.left,.carousel-inner>.prev.right{left:0}.carousel-inner>.active.left{left:-100%}.carousel-inner>.active.right{left:100%}.carousel-control{position:absolute;top:40%;left:15px;width:40px;height:40px;margin-top:-20px;font-size:60px;font-weight:100;line-height:30px;color:#fff;text-align:center;background:#222;border:3px solid #fff;-webkit-border-radius:23px;-moz-border-radius:23px;border-radius:23px;opacity:.5;filter:alpha(opacity=50)}.carousel-control.right{right:15px;left:auto}.carousel-control:hover,.carousel-control:focus{color:#fff;text-decoration:none;opacity:.9;filter:alpha(opacity=90)}.carousel-indicators{position:absolute;top:15px;right:15px;z-index:5;margin:0;list-style:none}.carousel-indicators li{display:block;float:left;width:10px;height:10px;margin-left:5px;text-indent:-999px;background-color:#ccc;background-color:rgba(255,255,255,0.25);border-radius:5px}.carousel-indicators .active{background-color:#fff}.carousel-caption{position:absolute;right:0;bottom:0;left:0;padding:15px;background:#333;background:rgba(0,0,0,0.75)}.carousel-caption h4,.carousel-caption p{line-height:20px;color:#fff}.carousel-caption h4{margin:0 0 5px}.carousel-caption p{margin-bottom:0}.hero-unit{padding:60px;margin-bottom:30px;font-size:18px;font-weight:200;line-height:30px;color:inherit;background-color:#eee;-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px}.hero-unit h1{margin-bottom:0;font-size:60px;line-height:1;letter-spacing:-1px;color:inherit}.hero-unit li{line-height:30px}.pull-right{float:right}.pull-left{float:left}.hide{display:none}.show{display:block}.invisible{visibility:hidden}.affix{position:fixed}
-/*!
- * Bootstrap Responsive v2.3.1
- *
- * Copyright 2012 Twitter, Inc
- * Licensed under the Apache License v2.0
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Designed and built with all the love in the world @twitter by @mdo and @fat.
- */.clearfix{*zoom:1}.clearfix:before,.clearfix:after{display:table;line-height:0;content:""}.clearfix:after{clear:both}.hide-text{font:0/0 a;color:transparent;text-shadow:none;background-color:transparent;border:0}.input-block-level{display:block;width:100%;min-height:30px;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}@-ms-viewport{width:device-width}.hidden{display:none;visibility:hidden}.visible-phone{display:none!important}.visible-tablet{display:none!important}.hidden-desktop{display:none!important}.visible-desktop{display:inherit!important}@media(min-width:768px) and (max-width:979px){.hidden-desktop{display:inherit!important}.visible-desktop{display:none!important}.visible-tablet{display:inherit!important}.hidden-tablet{display:none!important}}@media(max-width:767px){.hidden-desktop{display:inherit!important}.visible-desktop{display:none!important}.visible-phone{display:inherit!important}.hidden-phone{display:none!important}}.visible-print{display:none!important}@media print{.visible-print{display:inherit!important}.hidden-print{display:none!important}}@media(min-width:1200px){.row{margin-left:-30px;*zoom:1}.row:before,.row:after{display:table;line-height:0;content:""}.row:after{clear:both}[class*="span"]{float:left;min-height:1px;margin-left:30px}.container,.navbar-static-top .container,.navbar-fixed-top .container,.navbar-fixed-bottom .container{width:1170px}.span12{width:1170px}.span11{width:1070px}.span10{width:970px}.span9{width:870px}.span8{width:770px}.span7{width:670px}.span6{width:570px}.span5{width:470px}.span4{width:370px}.span3{width:270px}.span2{width:170px}.span1{width:70px}.offset12{margin-left:1230px}.offset11{margin-left:1130px}.offset10{margin-left:1030px}.offset9{margin-left:930px}.offset8{margin-left:830px}.offset7{margin-left:730px}.offset6{margin-left:630px}.offset5{margin-left:530px}.offset4{margin-left:430px}.offset3{margin-left:330px}.offset2{margin-left:230px}.offset1{margin-left:130px}.row-fluid{width:100%;*zoom:1}.row-fluid:before,.row-fluid:after{display:table;line-height:0;content:""}.row-fluid:after{clear:both}.row-fluid [class*="span"]{display:block;float:left;width:100%;min-height:30px;margin-left:2.564102564102564%;*margin-left:2.5109110747408616%;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}.row-fluid [class*="span"]:first-child{margin-left:0}.row-fluid .controls-row [class*="span"]+[class*="span"]{margin-left:2.564102564102564%}.row-fluid .span12{width:100%;*width:99.94680851063829%}.row-fluid .span11{width:91.45299145299145%;*width:91.39979996362975%}.row-fluid .span10{width:82.90598290598291%;*width:82.8527914166212%}.row-fluid .span9{width:74.35897435897436%;*width:74.30578286961266%}.row-fluid .span8{width:65.81196581196582%;*width:65.75877432260411%}.row-fluid .span7{width:57.26495726495726%;*width:57.21176577559556%}.row-fluid .span6{width:48.717948717948715%;*width:48.664757228587014%}.row-fluid .span5{width:40.17094017094017%;*width:40.11774868157847%}.row-fluid .span4{width:31.623931623931625%;*width:31.570740134569924%}.row-fluid .span3{width:23.076923076923077%;*width:23.023731587561375%}.row-fluid .span2{width:14.52991452991453%;*width:14.476723040552828%}.row-fluid .span1{width:5.982905982905983%;*width:5.929714493544281%}.row-fluid .offset12{margin-left:105.12820512820512%;*margin-left:105.02182214948171%}.row-fluid .offset12:first-child{margin-left:102.56410256410257%;*margin-left:102.45771958537915%}.row-fluid .offset11{margin-left:96.58119658119658%;*margin-left:96.47481360247316%}.row-fluid .offset11:first-child{margin-left:94.01709401709402%;*margin-left:93.91071103837061%}.row-fluid .offset10{margin-left:88.03418803418803%;*margin-left:87.92780505546462%}.row-fluid .offset10:first-child{margin-left:85.47008547008548%;*margin-left:85.36370249136206%}.row-fluid .offset9{margin-left:79.48717948717949%;*margin-left:79.38079650845607%}.row-fluid .offset9:first-child{margin-left:76.92307692307693%;*margin-left:76.81669394435352%}.row-fluid .offset8{margin-left:70.94017094017094%;*margin-left:70.83378796144753%}.row-fluid .offset8:first-child{margin-left:68.37606837606839%;*margin-left:68.26968539734497%}.row-fluid .offset7{margin-left:62.393162393162385%;*margin-left:62.28677941443899%}.row-fluid .offset7:first-child{margin-left:59.82905982905982%;*margin-left:59.72267685033642%}.row-fluid .offset6{margin-left:53.84615384615384%;*margin-left:53.739770867430444%}.row-fluid .offset6:first-child{margin-left:51.28205128205128%;*margin-left:51.175668303327875%}.row-fluid .offset5{margin-left:45.299145299145295%;*margin-left:45.1927623204219%}.row-fluid .offset5:first-child{margin-left:42.73504273504273%;*margin-left:42.62865975631933%}.row-fluid .offset4{margin-left:36.75213675213675%;*margin-left:36.645753773413354%}.row-fluid .offset4:first-child{margin-left:34.18803418803419%;*margin-left:34.081651209310785%}.row-fluid .offset3{margin-left:28.205128205128204%;*margin-left:28.0987452264048%}.row-fluid .offset3:first-child{margin-left:25.641025641025642%;*margin-left:25.53464266230224%}.row-fluid .offset2{margin-left:19.65811965811966%;*margin-left:19.551736679396257%}.row-fluid .offset2:first-child{margin-left:17.094017094017094%;*margin-left:16.98763411529369%}.row-fluid .offset1{margin-left:11.11111111111111%;*margin-left:11.004728132387708%}.row-fluid .offset1:first-child{margin-left:8.547008547008547%;*margin-left:8.440625568285142%}input,textarea,.uneditable-input{margin-left:0}.controls-row [class*="span"]+[class*="span"]{margin-left:30px}input.span12,textarea.span12,.uneditable-input.span12{width:1156px}input.span11,textarea.span11,.uneditable-input.span11{width:1056px}input.span10,textarea.span10,.uneditable-input.span10{width:956px}input.span9,textarea.span9,.uneditable-input.span9{width:856px}input.span8,textarea.span8,.uneditable-input.span8{width:756px}input.span7,textarea.span7,.uneditable-input.span7{width:656px}input.span6,textarea.span6,.uneditable-input.span6{width:556px}input.span5,textarea.span5,.uneditable-input.span5{width:456px}input.span4,textarea.span4,.uneditable-input.span4{width:356px}input.span3,textarea.span3,.uneditable-input.span3{width:256px}input.span2,textarea.span2,.uneditable-input.span2{width:156px}input.span1,textarea.span1,.uneditable-input.span1{width:56px}.thumbnails{margin-left:-30px}.thumbnails>li{margin-left:30px}.row-fluid .thumbnails{margin-left:0}}@media(min-width:768px) and (max-width:979px){.row{margin-left:-20px;*zoom:1}.row:before,.row:after{display:table;line-height:0;content:""}.row:after{clear:both}[class*="span"]{float:left;min-height:1px;margin-left:20px}.container,.navbar-static-top .container,.navbar-fixed-top .container,.navbar-fixed-bottom .container{width:724px}.span12{width:724px}.span11{width:662px}.span10{width:600px}.span9{width:538px}.span8{width:476px}.span7{width:414px}.span6{width:352px}.span5{width:290px}.span4{width:228px}.span3{width:166px}.span2{width:104px}.span1{width:42px}.offset12{margin-left:764px}.offset11{margin-left:702px}.offset10{margin-left:640px}.offset9{margin-left:578px}.offset8{margin-left:516px}.offset7{margin-left:454px}.offset6{margin-left:392px}.offset5{margin-left:330px}.offset4{margin-left:268px}.offset3{margin-left:206px}.offset2{margin-left:144px}.offset1{margin-left:82px}.row-fluid{width:100%;*zoom:1}.row-fluid:before,.row-fluid:after{display:table;line-height:0;content:""}.row-fluid:after{clear:both}.row-fluid [class*="span"]{display:block;float:left;width:100%;min-height:30px;margin-left:2.7624309392265194%;*margin-left:2.709239449864817%;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}.row-fluid [class*="span"]:first-child{margin-left:0}.row-fluid .controls-row [class*="span"]+[class*="span"]{margin-left:2.7624309392265194%}.row-fluid .span12{width:100%;*width:99.94680851063829%}.row-fluid .span11{width:91.43646408839778%;*width:91.38327259903608%}.row-fluid .span10{width:82.87292817679558%;*width:82.81973668743387%}.row-fluid .span9{width:74.30939226519337%;*width:74.25620077583166%}.row-fluid .span8{width:65.74585635359117%;*width:65.69266486422946%}.row-fluid .span7{width:57.18232044198895%;*width:57.12912895262725%}.row-fluid .span6{width:48.61878453038674%;*width:48.56559304102504%}.row-fluid .span5{width:40.05524861878453%;*width:40.00205712942283%}.row-fluid .span4{width:31.491712707182323%;*width:31.43852121782062%}.row-fluid .span3{width:22.92817679558011%;*width:22.87498530621841%}.row-fluid .span2{width:14.3646408839779%;*width:14.311449394616199%}.row-fluid .span1{width:5.801104972375691%;*width:5.747913483013988%}.row-fluid .offset12{margin-left:105.52486187845304%;*margin-left:105.41847889972962%}.row-fluid .offset12:first-child{margin-left:102.76243093922652%;*margin-left:102.6560479605031%}.row-fluid .offset11{margin-left:96.96132596685082%;*margin-left:96.8549429881274%}.row-fluid .offset11:first-child{margin-left:94.1988950276243%;*margin-left:94.09251204890089%}.row-fluid .offset10{margin-left:88.39779005524862%;*margin-left:88.2914070765252%}.row-fluid .offset10:first-child{margin-left:85.6353591160221%;*margin-left:85.52897613729868%}.row-fluid .offset9{margin-left:79.8342541436464%;*margin-left:79.72787116492299%}.row-fluid .offset9:first-child{margin-left:77.07182320441989%;*margin-left:76.96544022569647%}.row-fluid .offset8{margin-left:71.2707182320442%;*margin-left:71.16433525332079%}.row-fluid .offset8:first-child{margin-left:68.50828729281768%;*margin-left:68.40190431409427%}.row-fluid .offset7{margin-left:62.70718232044199%;*margin-left:62.600799341718584%}.row-fluid .offset7:first-child{margin-left:59.94475138121547%;*margin-left:59.838368402492065%}.row-fluid .offset6{margin-left:54.14364640883978%;*margin-left:54.037263430116376%}.row-fluid .offset6:first-child{margin-left:51.38121546961326%;*margin-left:51.27483249088986%}.row-fluid .offset5{margin-left:45.58011049723757%;*margin-left:45.47372751851417%}.row-fluid .offset5:first-child{margin-left:42.81767955801105%;*margin-left:42.71129657928765%}.row-fluid .offset4{margin-left:37.01657458563536%;*margin-left:36.91019160691196%}.row-fluid .offset4:first-child{margin-left:34.25414364640884%;*margin-left:34.14776066768544%}.row-fluid .offset3{margin-left:28.45303867403315%;*margin-left:28.346655695309746%}.row-fluid .offset3:first-child{margin-left:25.69060773480663%;*margin-left:25.584224756083227%}.row-fluid .offset2{margin-left:19.88950276243094%;*margin-left:19.783119783707537%}.row-fluid .offset2:first-child{margin-left:17.12707182320442%;*margin-left:17.02068884448102%}.row-fluid .offset1{margin-left:11.32596685082873%;*margin-left:11.219583872105325%}.row-fluid .offset1:first-child{margin-left:8.56353591160221%;*margin-left:8.457152932878806%}input,textarea,.uneditable-input{margin-left:0}.controls-row [class*="span"]+[class*="span"]{margin-left:20px}input.span12,textarea.span12,.uneditable-input.span12{width:710px}input.span11,textarea.span11,.uneditable-input.span11{width:648px}input.span10,textarea.span10,.uneditable-input.span10{width:586px}input.span9,textarea.span9,.uneditable-input.span9{width:524px}input.span8,textarea.span8,.uneditable-input.span8{width:462px}input.span7,textarea.span7,.uneditable-input.span7{width:400px}input.span6,textarea.span6,.uneditable-input.span6{width:338px}input.span5,textarea.span5,.uneditable-input.span5{width:276px}input.span4,textarea.span4,.uneditable-input.span4{width:214px}input.span3,textarea.span3,.uneditable-input.span3{width:152px}input.span2,textarea.span2,.uneditable-input.span2{width:90px}input.span1,textarea.span1,.uneditable-input.span1{width:28px}}@media(max-width:767px){body{padding-right:20px;padding-left:20px}.navbar-fixed-top,.navbar-fixed-bottom,.navbar-static-top{margin-right:-20px;margin-left:-20px}.container-fluid{padding:0}.dl-horizontal dt{float:none;width:auto;clear:none;text-align:left}.dl-horizontal dd{margin-left:0}.container{width:auto}.row-fluid{width:100%}.row,.thumbnails{margin-left:0}.thumbnails>li{float:none;margin-left:0}[class*="span"],.uneditable-input[class*="span"],.row-fluid [class*="span"]{display:block;float:none;width:100%;margin-left:0;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}.span12,.row-fluid .span12{width:100%;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}.row-fluid [class*="offset"]:first-child{margin-left:0}.input-large,.input-xlarge,.input-xxlarge,input[class*="span"],select[class*="span"],textarea[class*="span"],.uneditable-input{display:block;width:100%;min-height:30px;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}.input-prepend input,.input-append input,.input-prepend input[class*="span"],.input-append input[class*="span"]{display:inline-block;width:auto}.controls-row [class*="span"]+[class*="span"]{margin-left:0}.modal{position:fixed;top:20px;right:20px;left:20px;width:auto;margin:0}.modal.fade{top:-100px}.modal.fade.in{top:20px}}@media(max-width:480px){.nav-collapse{-webkit-transform:translate3d(0,0,0)}.page-header h1 small{display:block;line-height:20px}input[type="checkbox"],input[type="radio"]{border:1px solid #ccc}.form-horizontal .control-label{float:none;width:auto;padding-top:0;text-align:left}.form-horizontal .controls{margin-left:0}.form-horizontal .control-list{padding-top:0}.form-horizontal .form-actions{padding-right:10px;padding-left:10px}.media .pull-left,.media .pull-right{display:block;float:none;margin-bottom:10px}.media-object{margin-right:0;margin-left:0}.modal{top:10px;right:10px;left:10px}.modal-header .close{padding:10px;margin:-10px}.carousel-caption{position:static}}@media(max-width:979px){body{padding-top:0}.navbar-fixed-top,.navbar-fixed-bottom{position:static}.navbar-fixed-top{margin-bottom:20px}.navbar-fixed-bottom{margin-top:20px}.navbar-fixed-top .navbar-inner,.navbar-fixed-bottom .navbar-inner{padding:5px}.navbar .container{width:auto;padding:0}.navbar .brand{padding-right:10px;padding-left:10px;margin:0 0 0 -5px}.nav-collapse{clear:both}.nav-collapse .nav{float:none;margin:0 0 10px}.nav-collapse .nav>li{float:none}.nav-collapse .nav>li>a{margin-bottom:2px}.nav-collapse .nav>.divider-vertical{display:none}.nav-collapse .nav .nav-header{color:#777;text-shadow:none}.nav-collapse .nav>li>a,.nav-collapse .dropdown-menu a{padding:9px 15px;font-weight:bold;color:#777;-webkit-border-radius:3px;-moz-border-radius:3px;border-radius:3px}.nav-collapse .btn{padding:4px 10px 4px;font-weight:normal;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}.nav-collapse .dropdown-menu li+li a{margin-bottom:2px}.nav-collapse .nav>li>a:hover,.nav-collapse .nav>li>a:focus,.nav-collapse .dropdown-menu a:hover,.nav-collapse .dropdown-menu a:focus{background-color:#f2f2f2}.navbar-inverse .nav-collapse .nav>li>a,.navbar-inverse .nav-collapse .dropdown-menu a{color:#999}.navbar-inverse .nav-collapse .nav>li>a:hover,.navbar-inverse .nav-collapse .nav>li>a:focus,.navbar-inverse .nav-collapse .dropdown-menu a:hover,.navbar-inverse .nav-collapse .dropdown-menu a:focus{background-color:#111}.nav-collapse.in .btn-group{padding:0;margin-top:5px}.nav-collapse .dropdown-menu{position:static;top:auto;left:auto;display:none;float:none;max-width:none;padding:0;margin:0 15px;background-color:transparent;border:0;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0;-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none}.nav-collapse .open>.dropdown-menu{display:block}.nav-collapse .dropdown-menu:before,.nav-collapse .dropdown-menu:after{display:none}.nav-collapse .dropdown-menu .divider{display:none}.nav-collapse .nav>li>.dropdown-menu:before,.nav-collapse .nav>li>.dropdown-menu:after{display:none}.nav-collapse .navbar-form,.nav-collapse .navbar-search{float:none;padding:10px 15px;margin:10px 0;border-top:1px solid #f2f2f2;border-bottom:1px solid #f2f2f2;-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,0.1),0 1px 0 rgba(255,255,255,0.1);-moz-box-shadow:inset 0 1px 0 rgba(255,255,255,0.1),0 1px 0 rgba(255,255,255,0.1);box-shadow:inset 0 1px 0 rgba(255,255,255,0.1),0 1px 0 rgba(255,255,255,0.1)}.navbar-inverse .nav-collapse .navbar-form,.navbar-inverse .nav-collapse .navbar-search{border-top-color:#111;border-bottom-color:#111}.navbar .nav-collapse .nav.pull-right{float:none;margin-left:0}.nav-collapse,.nav-collapse.collapse{height:0;overflow:hidden}.navbar .btn-navbar{display:block}.navbar-static .navbar-inner{padding-right:10px;padding-left:10px}}@media(min-width:980px){.nav-collapse.collapse{height:auto!important;overflow:visible!important}}
diff --git a/website/static/bootstrap.min.js b/website/static/bootstrap.min.js
deleted file mode 100644
index 95c5ac5ee6..0000000000
--- a/website/static/bootstrap.min.js
+++ /dev/null
@@ -1,6 +0,0 @@
-/*!
-* Bootstrap.js by @fat & @mdo
-* Copyright 2012 Twitter, Inc.
-* http://www.apache.org/licenses/LICENSE-2.0.txt
-*/
-!function(e){"use strict";e(function(){e.support.transition=function(){var e=function(){var e=document.createElement("bootstrap"),t={WebkitTransition:"webkitTransitionEnd",MozTransition:"transitionend",OTransition:"oTransitionEnd otransitionend",transition:"transitionend"},n;for(n in t)if(e.style[n]!==undefined)return t[n]}();return e&&{end:e}}()})}(window.jQuery),!function(e){"use strict";var t='[data-dismiss="alert"]',n=function(n){e(n).on("click",t,this.close)};n.prototype.close=function(t){function s(){i.trigger("closed").remove()}var n=e(this),r=n.attr("data-target"),i;r||(r=n.attr("href"),r=r&&r.replace(/.*(?=#[^\s]*$)/,"")),i=e(r),t&&t.preventDefault(),i.length||(i=n.hasClass("alert")?n:n.parent()),i.trigger(t=e.Event("close"));if(t.isDefaultPrevented())return;i.removeClass("in"),e.support.transition&&i.hasClass("fade")?i.on(e.support.transition.end,s):s()};var r=e.fn.alert;e.fn.alert=function(t){return this.each(function(){var r=e(this),i=r.data("alert");i||r.data("alert",i=new n(this)),typeof t=="string"&&i[t].call(r)})},e.fn.alert.Constructor=n,e.fn.alert.noConflict=function(){return e.fn.alert=r,this},e(document).on("click.alert.data-api",t,n.prototype.close)}(window.jQuery),!function(e){"use strict";var t=function(t,n){this.$element=e(t),this.options=e.extend({},e.fn.button.defaults,n)};t.prototype.setState=function(e){var t="disabled",n=this.$element,r=n.data(),i=n.is("input")?"val":"html";e+="Text",r.resetText||n.data("resetText",n[i]()),n[i](r[e]||this.options[e]),setTimeout(function(){e=="loadingText"?n.addClass(t).attr(t,t):n.removeClass(t).removeAttr(t)},0)},t.prototype.toggle=function(){var e=this.$element.closest('[data-toggle="buttons-radio"]');e&&e.find(".active").removeClass("active"),this.$element.toggleClass("active")};var n=e.fn.button;e.fn.button=function(n){return this.each(function(){var r=e(this),i=r.data("button"),s=typeof n=="object"&&n;i||r.data("button",i=new t(this,s)),n=="toggle"?i.toggle():n&&i.setState(n)})},e.fn.button.defaults={loadingText:"loading..."},e.fn.button.Constructor=t,e.fn.button.noConflict=function(){return e.fn.button=n,this},e(document).on("click.button.data-api","[data-toggle^=button]",function(t){var n=e(t.target);n.hasClass("btn")||(n=n.closest(".btn")),n.button("toggle")})}(window.jQuery),!function(e){"use strict";var t=function(t,n){this.$element=e(t),this.$indicators=this.$element.find(".carousel-indicators"),this.options=n,this.options.pause=="hover"&&this.$element.on("mouseenter",e.proxy(this.pause,this)).on("mouseleave",e.proxy(this.cycle,this))};t.prototype={cycle:function(t){return t||(this.paused=!1),this.interval&&clearInterval(this.interval),this.options.interval&&!this.paused&&(this.interval=setInterval(e.proxy(this.next,this),this.options.interval)),this},getActiveIndex:function(){return this.$active=this.$element.find(".item.active"),this.$items=this.$active.parent().children(),this.$items.index(this.$active)},to:function(t){var n=this.getActiveIndex(),r=this;if(t>this.$items.length-1||t<0)return;return this.sliding?this.$element.one("slid",function(){r.to(t)}):n==t?this.pause().cycle():this.slide(t>n?"next":"prev",e(this.$items[t]))},pause:function(t){return t||(this.paused=!0),this.$element.find(".next, .prev").length&&e.support.transition.end&&(this.$element.trigger(e.support.transition.end),this.cycle(!0)),clearInterval(this.interval),this.interval=null,this},next:function(){if(this.sliding)return;return this.slide("next")},prev:function(){if(this.sliding)return;return this.slide("prev")},slide:function(t,n){var r=this.$element.find(".item.active"),i=n||r[t](),s=this.interval,o=t=="next"?"left":"right",u=t=="next"?"first":"last",a=this,f;this.sliding=!0,s&&this.pause(),i=i.length?i:this.$element.find(".item")[u](),f=e.Event("slide",{relatedTarget:i[0],direction:o});if(i.hasClass("active"))return;this.$indicators.length&&(this.$indicators.find(".active").removeClass("active"),this.$element.one("slid",function(){var t=e(a.$indicators.children()[a.getActiveIndex()]);t&&t.addClass("active")}));if(e.support.transition&&this.$element.hasClass("slide")){this.$element.trigger(f);if(f.isDefaultPrevented())return;i.addClass(t),i[0].offsetWidth,r.addClass(o),i.addClass(o),this.$element.one(e.support.transition.end,function(){i.removeClass([t,o].join(" ")).addClass("active"),r.removeClass(["active",o].join(" ")),a.sliding=!1,setTimeout(function(){a.$element.trigger("slid")},0)})}else{this.$element.trigger(f);if(f.isDefaultPrevented())return;r.removeClass("active"),i.addClass("active"),this.sliding=!1,this.$element.trigger("slid")}return s&&this.cycle(),this}};var n=e.fn.carousel;e.fn.carousel=function(n){return this.each(function(){var r=e(this),i=r.data("carousel"),s=e.extend({},e.fn.carousel.defaults,typeof n=="object"&&n),o=typeof n=="string"?n:s.slide;i||r.data("carousel",i=new t(this,s)),typeof n=="number"?i.to(n):o?i[o]():s.interval&&i.pause().cycle()})},e.fn.carousel.defaults={interval:5e3,pause:"hover"},e.fn.carousel.Constructor=t,e.fn.carousel.noConflict=function(){return e.fn.carousel=n,this},e(document).on("click.carousel.data-api","[data-slide], [data-slide-to]",function(t){var n=e(this),r,i=e(n.attr("data-target")||(r=n.attr("href"))&&r.replace(/.*(?=#[^\s]+$)/,"")),s=e.extend({},i.data(),n.data()),o;i.carousel(s),(o=n.attr("data-slide-to"))&&i.data("carousel").pause().to(o).cycle(),t.preventDefault()})}(window.jQuery),!function(e){"use strict";var t=function(t,n){this.$element=e(t),this.options=e.extend({},e.fn.collapse.defaults,n),this.options.parent&&(this.$parent=e(this.options.parent)),this.options.toggle&&this.toggle()};t.prototype={constructor:t,dimension:function(){var e=this.$element.hasClass("width");return e?"width":"height"},show:function(){var t,n,r,i;if(this.transitioning||this.$element.hasClass("in"))return;t=this.dimension(),n=e.camelCase(["scroll",t].join("-")),r=this.$parent&&this.$parent.find("> .accordion-group > .in");if(r&&r.length){i=r.data("collapse");if(i&&i.transitioning)return;r.collapse("hide"),i||r.data("collapse",null)}this.$element[t](0),this.transition("addClass",e.Event("show"),"shown"),e.support.transition&&this.$element[t](this.$element[0][n])},hide:function(){var t;if(this.transitioning||!this.$element.hasClass("in"))return;t=this.dimension(),this.reset(this.$element[t]()),this.transition("removeClass",e.Event("hide"),"hidden"),this.$element[t](0)},reset:function(e){var t=this.dimension();return this.$element.removeClass("collapse")[t](e||"auto")[0].offsetWidth,this.$element[e!==null?"addClass":"removeClass"]("collapse"),this},transition:function(t,n,r){var i=this,s=function(){n.type=="show"&&i.reset(),i.transitioning=0,i.$element.trigger(r)};this.$element.trigger(n);if(n.isDefaultPrevented())return;this.transitioning=1,this.$element[t]("in"),e.support.transition&&this.$element.hasClass("collapse")?this.$element.one(e.support.transition.end,s):s()},toggle:function(){this[this.$element.hasClass("in")?"hide":"show"]()}};var n=e.fn.collapse;e.fn.collapse=function(n){return this.each(function(){var r=e(this),i=r.data("collapse"),s=e.extend({},e.fn.collapse.defaults,r.data(),typeof n=="object"&&n);i||r.data("collapse",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.collapse.defaults={toggle:!0},e.fn.collapse.Constructor=t,e.fn.collapse.noConflict=function(){return e.fn.collapse=n,this},e(document).on("click.collapse.data-api","[data-toggle=collapse]",function(t){var n=e(this),r,i=n.attr("data-target")||t.preventDefault()||(r=n.attr("href"))&&r.replace(/.*(?=#[^\s]+$)/,""),s=e(i).data("collapse")?"toggle":n.data();n[e(i).hasClass("in")?"addClass":"removeClass"]("collapsed"),e(i).collapse(s)})}(window.jQuery),!function(e){"use strict";function r(){e(t).each(function(){i(e(this)).removeClass("open")})}function i(t){var n=t.attr("data-target"),r;n||(n=t.attr("href"),n=n&&/#/.test(n)&&n.replace(/.*(?=#[^\s]*$)/,"")),r=n&&e(n);if(!r||!r.length)r=t.parent();return r}var t="[data-toggle=dropdown]",n=function(t){var n=e(t).on("click.dropdown.data-api",this.toggle);e("html").on("click.dropdown.data-api",function(){n.parent().removeClass("open")})};n.prototype={constructor:n,toggle:function(t){var n=e(this),s,o;if(n.is(".disabled, :disabled"))return;return s=i(n),o=s.hasClass("open"),r(),o||s.toggleClass("open"),n.focus(),!1},keydown:function(n){var r,s,o,u,a,f;if(!/(38|40|27)/.test(n.keyCode))return;r=e(this),n.preventDefault(),n.stopPropagation();if(r.is(".disabled, :disabled"))return;u=i(r),a=u.hasClass("open");if(!a||a&&n.keyCode==27)return n.which==27&&u.find(t).focus(),r.click();s=e("[role=menu] li:not(.divider):visible a",u);if(!s.length)return;f=s.index(s.filter(":focus")),n.keyCode==38&&f>0&&f--,n.keyCode==40&&f<s.length-1&&f++,~f||(f=0),s.eq(f).focus()}};var s=e.fn.dropdown;e.fn.dropdown=function(t){return this.each(function(){var r=e(this),i=r.data("dropdown");i||r.data("dropdown",i=new n(this)),typeof t=="string"&&i[t].call(r)})},e.fn.dropdown.Constructor=n,e.fn.dropdown.noConflict=function(){return e.fn.dropdown=s,this},e(document).on("click.dropdown.data-api",r).on("click.dropdown.data-api",".dropdown form",function(e){e.stopPropagation()}).on("click.dropdown-menu",function(e){e.stopPropagation()}).on("click.dropdown.data-api",t,n.prototype.toggle).on("keydown.dropdown.data-api",t+", [role=menu]",n.prototype.keydown)}(window.jQuery),!function(e){"use strict";var t=function(t,n){this.options=n,this.$element=e(t).delegate('[data-dismiss="modal"]',"click.dismiss.modal",e.proxy(this.hide,this)),this.options.remote&&this.$element.find(".modal-body").load(this.options.remote)};t.prototype={constructor:t,toggle:function(){return this[this.isShown?"hide":"show"]()},show:function(){var t=this,n=e.Event("show");this.$element.trigger(n);if(this.isShown||n.isDefaultPrevented())return;this.isShown=!0,this.escape(),this.backdrop(function(){var n=e.support.transition&&t.$element.hasClass("fade");t.$element.parent().length||t.$element.appendTo(document.body),t.$element.show(),n&&t.$element[0].offsetWidth,t.$element.addClass("in").attr("aria-hidden",!1),t.enforceFocus(),n?t.$element.one(e.support.transition.end,function(){t.$element.focus().trigger("shown")}):t.$element.focus().trigger("shown")})},hide:function(t){t&&t.preventDefault();var n=this;t=e.Event("hide"),this.$element.trigger(t);if(!this.isShown||t.isDefaultPrevented())return;this.isShown=!1,this.escape(),e(document).off("focusin.modal"),this.$element.removeClass("in").attr("aria-hidden",!0),e.support.transition&&this.$element.hasClass("fade")?this.hideWithTransition():this.hideModal()},enforceFocus:function(){var t=this;e(document).on("focusin.modal",function(e){t.$element[0]!==e.target&&!t.$element.has(e.target).length&&t.$element.focus()})},escape:function(){var e=this;this.isShown&&this.options.keyboard?this.$element.on("keyup.dismiss.modal",function(t){t.which==27&&e.hide()}):this.isShown||this.$element.off("keyup.dismiss.modal")},hideWithTransition:function(){var t=this,n=setTimeout(function(){t.$element.off(e.support.transition.end),t.hideModal()},500);this.$element.one(e.support.transition.end,function(){clearTimeout(n),t.hideModal()})},hideModal:function(){var e=this;this.$element.hide(),this.backdrop(function(){e.removeBackdrop(),e.$element.trigger("hidden")})},removeBackdrop:function(){this.$backdrop&&this.$backdrop.remove(),this.$backdrop=null},backdrop:function(t){var n=this,r=this.$element.hasClass("fade")?"fade":"";if(this.isShown&&this.options.backdrop){var i=e.support.transition&&r;this.$backdrop=e('<div class="modal-backdrop '+r+'" />').appendTo(document.body),this.$backdrop.click(this.options.backdrop=="static"?e.proxy(this.$element[0].focus,this.$element[0]):e.proxy(this.hide,this)),i&&this.$backdrop[0].offsetWidth,this.$backdrop.addClass("in");if(!t)return;i?this.$backdrop.one(e.support.transition.end,t):t()}else!this.isShown&&this.$backdrop?(this.$backdrop.removeClass("in"),e.support.transition&&this.$element.hasClass("fade")?this.$backdrop.one(e.support.transition.end,t):t()):t&&t()}};var n=e.fn.modal;e.fn.modal=function(n){return this.each(function(){var r=e(this),i=r.data("modal"),s=e.extend({},e.fn.modal.defaults,r.data(),typeof n=="object"&&n);i||r.data("modal",i=new t(this,s)),typeof n=="string"?i[n]():s.show&&i.show()})},e.fn.modal.defaults={backdrop:!0,keyboard:!0,show:!0},e.fn.modal.Constructor=t,e.fn.modal.noConflict=function(){return e.fn.modal=n,this},e(document).on("click.modal.data-api",'[data-toggle="modal"]',function(t){var n=e(this),r=n.attr("href"),i=e(n.attr("data-target")||r&&r.replace(/.*(?=#[^\s]+$)/,"")),s=i.data("modal")?"toggle":e.extend({remote:!/#/.test(r)&&r},i.data(),n.data());t.preventDefault(),i.modal(s).one("hide",function(){n.focus()})})}(window.jQuery),!function(e){"use strict";var t=function(e,t){this.init("tooltip",e,t)};t.prototype={constructor:t,init:function(t,n,r){var i,s,o,u,a;this.type=t,this.$element=e(n),this.options=this.getOptions(r),this.enabled=!0,o=this.options.trigger.split(" ");for(a=o.length;a--;)u=o[a],u=="click"?this.$element.on("click."+this.type,this.options.selector,e.proxy(this.toggle,this)):u!="manual"&&(i=u=="hover"?"mouseenter":"focus",s=u=="hover"?"mouseleave":"blur",this.$element.on(i+"."+this.type,this.options.selector,e.proxy(this.enter,this)),this.$element.on(s+"."+this.type,this.options.selector,e.proxy(this.leave,this)));this.options.selector?this._options=e.extend({},this.options,{trigger:"manual",selector:""}):this.fixTitle()},getOptions:function(t){return t=e.extend({},e.fn[this.type].defaults,this.$element.data(),t),t.delay&&typeof t.delay=="number"&&(t.delay={show:t.delay,hide:t.delay}),t},enter:function(t){var n=e.fn[this.type].defaults,r={},i;this._options&&e.each(this._options,function(e,t){n[e]!=t&&(r[e]=t)},this),i=e(t.currentTarget)[this.type](r).data(this.type);if(!i.options.delay||!i.options.delay.show)return i.show();clearTimeout(this.timeout),i.hoverState="in",this.timeout=setTimeout(function(){i.hoverState=="in"&&i.show()},i.options.delay.show)},leave:function(t){var n=e(t.currentTarget)[this.type](this._options).data(this.type);this.timeout&&clearTimeout(this.timeout);if(!n.options.delay||!n.options.delay.hide)return n.hide();n.hoverState="out",this.timeout=setTimeout(function(){n.hoverState=="out"&&n.hide()},n.options.delay.hide)},show:function(){var t,n,r,i,s,o,u=e.Event("show");if(this.hasContent()&&this.enabled){this.$element.trigger(u);if(u.isDefaultPrevented())return;t=this.tip(),this.setContent(),this.options.animation&&t.addClass("fade"),s=typeof this.options.placement=="function"?this.options.placement.call(this,t[0],this.$element[0]):this.options.placement,t.detach().css({top:0,left:0,display:"block"}),this.options.container?t.appendTo(this.options.container):t.insertAfter(this.$element),n=this.getPosition(),r=t[0].offsetWidth,i=t[0].offsetHeight;switch(s){case"bottom":o={top:n.top+n.height,left:n.left+n.width/2-r/2};break;case"top":o={top:n.top-i,left:n.left+n.width/2-r/2};break;case"left":o={top:n.top+n.height/2-i/2,left:n.left-r};break;case"right":o={top:n.top+n.height/2-i/2,left:n.left+n.width}}this.applyPlacement(o,s),this.$element.trigger("shown")}},applyPlacement:function(e,t){var n=this.tip(),r=n[0].offsetWidth,i=n[0].offsetHeight,s,o,u,a;n.offset(e).addClass(t).addClass("in"),s=n[0].offsetWidth,o=n[0].offsetHeight,t=="top"&&o!=i&&(e.top=e.top+i-o,a=!0),t=="bottom"||t=="top"?(u=0,e.left<0&&(u=e.left*-2,e.left=0,n.offset(e),s=n[0].offsetWidth,o=n[0].offsetHeight),this.replaceArrow(u-r+s,s,"left")):this.replaceArrow(o-i,o,"top"),a&&n.offset(e)},replaceArrow:function(e,t,n){this.arrow().css(n,e?50*(1-e/t)+"%":"")},setContent:function(){var e=this.tip(),t=this.getTitle();e.find(".tooltip-inner")[this.options.html?"html":"text"](t),e.removeClass("fade in top bottom left right")},hide:function(){function i(){var t=setTimeout(function(){n.off(e.support.transition.end).detach()},500);n.one(e.support.transition.end,function(){clearTimeout(t),n.detach()})}var t=this,n=this.tip(),r=e.Event("hide");this.$element.trigger(r);if(r.isDefaultPrevented())return;return n.removeClass("in"),e.support.transition&&this.$tip.hasClass("fade")?i():n.detach(),this.$element.trigger("hidden"),this},fixTitle:function(){var e=this.$element;(e.attr("title")||typeof e.attr("data-original-title")!="string")&&e.attr("data-original-title",e.attr("title")||"").attr("title","")},hasContent:function(){return this.getTitle()},getPosition:function(){var t=this.$element[0];return e.extend({},typeof t.getBoundingClientRect=="function"?t.getBoundingClientRect():{width:t.offsetWidth,height:t.offsetHeight},this.$element.offset())},getTitle:function(){var e,t=this.$element,n=this.options;return e=t.attr("data-original-title")||(typeof n.title=="function"?n.title.call(t[0]):n.title),e},tip:function(){return this.$tip=this.$tip||e(this.options.template)},arrow:function(){return this.$arrow=this.$arrow||this.tip().find(".tooltip-arrow")},validate:function(){this.$element[0].parentNode||(this.hide(),this.$element=null,this.options=null)},enable:function(){this.enabled=!0},disable:function(){this.enabled=!1},toggleEnabled:function(){this.enabled=!this.enabled},toggle:function(t){var n=t?e(t.currentTarget)[this.type](this._options).data(this.type):this;n.tip().hasClass("in")?n.hide():n.show()},destroy:function(){this.hide().$element.off("."+this.type).removeData(this.type)}};var n=e.fn.tooltip;e.fn.tooltip=function(n){return this.each(function(){var r=e(this),i=r.data("tooltip"),s=typeof n=="object"&&n;i||r.data("tooltip",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.tooltip.Constructor=t,e.fn.tooltip.defaults={animation:!0,placement:"top",selector:!1,template:'<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',trigger:"hover focus",title:"",delay:0,html:!1,container:!1},e.fn.tooltip.noConflict=function(){return e.fn.tooltip=n,this}}(window.jQuery),!function(e){"use strict";var t=function(e,t){this.init("popover",e,t)};t.prototype=e.extend({},e.fn.tooltip.Constructor.prototype,{constructor:t,setContent:function(){var e=this.tip(),t=this.getTitle(),n=this.getContent();e.find(".popover-title")[this.options.html?"html":"text"](t),e.find(".popover-content")[this.options.html?"html":"text"](n),e.removeClass("fade top bottom left right in")},hasContent:function(){return this.getTitle()||this.getContent()},getContent:function(){var e,t=this.$element,n=this.options;return e=(typeof n.content=="function"?n.content.call(t[0]):n.content)||t.attr("data-content"),e},tip:function(){return this.$tip||(this.$tip=e(this.options.template)),this.$tip},destroy:function(){this.hide().$element.off("."+this.type).removeData(this.type)}});var n=e.fn.popover;e.fn.popover=function(n){return this.each(function(){var r=e(this),i=r.data("popover"),s=typeof n=="object"&&n;i||r.data("popover",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.popover.Constructor=t,e.fn.popover.defaults=e.extend({},e.fn.tooltip.defaults,{placement:"right",trigger:"click",content:"",template:'<div class="popover"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'}),e.fn.popover.noConflict=function(){return e.fn.popover=n,this}}(window.jQuery),!function(e){"use strict";function t(t,n){var r=e.proxy(this.process,this),i=e(t).is("body")?e(window):e(t),s;this.options=e.extend({},e.fn.scrollspy.defaults,n),this.$scrollElement=i.on("scroll.scroll-spy.data-api",r),this.selector=(this.options.target||(s=e(t).attr("href"))&&s.replace(/.*(?=#[^\s]+$)/,"")||"")+" .nav li > a",this.$body=e("body"),this.refresh(),this.process()}t.prototype={constructor:t,refresh:function(){var t=this,n;this.offsets=e([]),this.targets=e([]),n=this.$body.find(this.selector).map(function(){var n=e(this),r=n.data("target")||n.attr("href"),i=/^#\w/.test(r)&&e(r);return i&&i.length&&[[i.position().top+(!e.isWindow(t.$scrollElement.get(0))&&t.$scrollElement.scrollTop()),r]]||null}).sort(function(e,t){return e[0]-t[0]}).each(function(){t.offsets.push(this[0]),t.targets.push(this[1])})},process:function(){var e=this.$scrollElement.scrollTop()+this.options.offset,t=this.$scrollElement[0].scrollHeight||this.$body[0].scrollHeight,n=t-this.$scrollElement.height(),r=this.offsets,i=this.targets,s=this.activeTarget,o;if(e>=n)return s!=(o=i.last()[0])&&this.activate(o);for(o=r.length;o--;)s!=i[o]&&e>=r[o]&&(!r[o+1]||e<=r[o+1])&&this.activate(i[o])},activate:function(t){var n,r;this.activeTarget=t,e(this.selector).parent(".active").removeClass("active"),r=this.selector+'[data-target="'+t+'"],'+this.selector+'[href="'+t+'"]',n=e(r).parent("li").addClass("active"),n.parent(".dropdown-menu").length&&(n=n.closest("li.dropdown").addClass("active")),n.trigger("activate")}};var n=e.fn.scrollspy;e.fn.scrollspy=function(n){return this.each(function(){var r=e(this),i=r.data("scrollspy"),s=typeof n=="object"&&n;i||r.data("scrollspy",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.scrollspy.Constructor=t,e.fn.scrollspy.defaults={offset:10},e.fn.scrollspy.noConflict=function(){return e.fn.scrollspy=n,this},e(window).on("load",function(){e('[data-spy="scroll"]').each(function(){var t=e(this);t.scrollspy(t.data())})})}(window.jQuery),!function(e){"use strict";var t=function(t){this.element=e(t)};t.prototype={constructor:t,show:function(){var t=this.element,n=t.closest("ul:not(.dropdown-menu)"),r=t.attr("data-target"),i,s,o;r||(r=t.attr("href"),r=r&&r.replace(/.*(?=#[^\s]*$)/,""));if(t.parent("li").hasClass("active"))return;i=n.find(".active:last a")[0],o=e.Event("show",{relatedTarget:i}),t.trigger(o);if(o.isDefaultPrevented())return;s=e(r),this.activate(t.parent("li"),n),this.activate(s,s.parent(),function(){t.trigger({type:"shown",relatedTarget:i})})},activate:function(t,n,r){function o(){i.removeClass("active").find("> .dropdown-menu > .active").removeClass("active"),t.addClass("active"),s?(t[0].offsetWidth,t.addClass("in")):t.removeClass("fade"),t.parent(".dropdown-menu")&&t.closest("li.dropdown").addClass("active"),r&&r()}var i=n.find("> .active"),s=r&&e.support.transition&&i.hasClass("fade");s?i.one(e.support.transition.end,o):o(),i.removeClass("in")}};var n=e.fn.tab;e.fn.tab=function(n){return this.each(function(){var r=e(this),i=r.data("tab");i||r.data("tab",i=new t(this)),typeof n=="string"&&i[n]()})},e.fn.tab.Constructor=t,e.fn.tab.noConflict=function(){return e.fn.tab=n,this},e(document).on("click.tab.data-api",'[data-toggle="tab"], [data-toggle="pill"]',function(t){t.preventDefault(),e(this).tab("show")})}(window.jQuery),!function(e){"use strict";var t=function(t,n){this.$element=e(t),this.options=e.extend({},e.fn.typeahead.defaults,n),this.matcher=this.options.matcher||this.matcher,this.sorter=this.options.sorter||this.sorter,this.highlighter=this.options.highlighter||this.highlighter,this.updater=this.options.updater||this.updater,this.source=this.options.source,this.$menu=e(this.options.menu),this.shown=!1,this.listen()};t.prototype={constructor:t,select:function(){var e=this.$menu.find(".active").attr("data-value");return this.$element.val(this.updater(e)).change(),this.hide()},updater:function(e){return e},show:function(){var t=e.extend({},this.$element.position(),{height:this.$element[0].offsetHeight});return this.$menu.insertAfter(this.$element).css({top:t.top+t.height,left:t.left}).show(),this.shown=!0,this},hide:function(){return this.$menu.hide(),this.shown=!1,this},lookup:function(t){var n;return this.query=this.$element.val(),!this.query||this.query.length<this.options.minLength?this.shown?this.hide():this:(n=e.isFunction(this.source)?this.source(this.query,e.proxy(this.process,this)):this.source,n?this.process(n):this)},process:function(t){var n=this;return t=e.grep(t,function(e){return n.matcher(e)}),t=this.sorter(t),t.length?this.render(t.slice(0,this.options.items)).show():this.shown?this.hide():this},matcher:function(e){return~e.toLowerCase().indexOf(this.query.toLowerCase())},sorter:function(e){var t=[],n=[],r=[],i;while(i=e.shift())i.toLowerCase().indexOf(this.query.toLowerCase())?~i.indexOf(this.query)?n.push(i):r.push(i):t.push(i);return t.concat(n,r)},highlighter:function(e){var t=this.query.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&");return e.replace(new RegExp("("+t+")","ig"),function(e,t){return"<strong>"+t+"</strong>"})},render:function(t){var n=this;return t=e(t).map(function(t,r){return t=e(n.options.item).attr("data-value",r),t.find("a").html(n.highlighter(r)),t[0]}),t.first().addClass("active"),this.$menu.html(t),this},next:function(t){var n=this.$menu.find(".active").removeClass("active"),r=n.next();r.length||(r=e(this.$menu.find("li")[0])),r.addClass("active")},prev:function(e){var t=this.$menu.find(".active").removeClass("active"),n=t.prev();n.length||(n=this.$menu.find("li").last()),n.addClass("active")},listen:function(){this.$element.on("focus",e.proxy(this.focus,this)).on("blur",e.proxy(this.blur,this)).on("keypress",e.proxy(this.keypress,this)).on("keyup",e.proxy(this.keyup,this)),this.eventSupported("keydown")&&this.$element.on("keydown",e.proxy(this.keydown,this)),this.$menu.on("click",e.proxy(this.click,this)).on("mouseenter","li",e.proxy(this.mouseenter,this)).on("mouseleave","li",e.proxy(this.mouseleave,this))},eventSupported:function(e){var t=e in this.$element;return t||(this.$element.setAttribute(e,"return;"),t=typeof this.$element[e]=="function"),t},move:function(e){if(!this.shown)return;switch(e.keyCode){case 9:case 13:case 27:e.preventDefault();break;case 38:e.preventDefault(),this.prev();break;case 40:e.preventDefault(),this.next()}e.stopPropagation()},keydown:function(t){this.suppressKeyPressRepeat=~e.inArray(t.keyCode,[40,38,9,13,27]),this.move(t)},keypress:function(e){if(this.suppressKeyPressRepeat)return;this.move(e)},keyup:function(e){switch(e.keyCode){case 40:case 38:case 16:case 17:case 18:break;case 9:case 13:if(!this.shown)return;this.select();break;case 27:if(!this.shown)return;this.hide();break;default:this.lookup()}e.stopPropagation(),e.preventDefault()},focus:function(e){this.focused=!0},blur:function(e){this.focused=!1,!this.mousedover&&this.shown&&this.hide()},click:function(e){e.stopPropagation(),e.preventDefault(),this.select(),this.$element.focus()},mouseenter:function(t){this.mousedover=!0,this.$menu.find(".active").removeClass("active"),e(t.currentTarget).addClass("active")},mouseleave:function(e){this.mousedover=!1,!this.focused&&this.shown&&this.hide()}};var n=e.fn.typeahead;e.fn.typeahead=function(n){return this.each(function(){var r=e(this),i=r.data("typeahead"),s=typeof n=="object"&&n;i||r.data("typeahead",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.typeahead.defaults={source:[],items:8,menu:'<ul class="typeahead dropdown-menu"></ul>',item:'<li><a href="#"></a></li>',minLength:1},e.fn.typeahead.Constructor=t,e.fn.typeahead.noConflict=function(){return e.fn.typeahead=n,this},e(document).on("focus.typeahead.data-api",'[data-provide="typeahead"]',function(t){var n=e(this);if(n.data("typeahead"))return;n.typeahead(n.data())})}(window.jQuery),!function(e){"use strict";var t=function(t,n){this.options=e.extend({},e.fn.affix.defaults,n),this.$window=e(window).on("scroll.affix.data-api",e.proxy(this.checkPosition,this)).on("click.affix.data-api",e.proxy(function(){setTimeout(e.proxy(this.checkPosition,this),1)},this)),this.$element=e(t),this.checkPosition()};t.prototype.checkPosition=function(){if(!this.$element.is(":visible"))return;var t=e(document).height(),n=this.$window.scrollTop(),r=this.$element.offset(),i=this.options.offset,s=i.bottom,o=i.top,u="affix affix-top affix-bottom",a;typeof i!="object"&&(s=o=i),typeof o=="function"&&(o=i.top()),typeof s=="function"&&(s=i.bottom()),a=this.unpin!=null&&n+this.unpin<=r.top?!1:s!=null&&r.top+this.$element.height()>=t-s?"bottom":o!=null&&n<=o?"top":!1;if(this.affixed===a)return;this.affixed=a,this.unpin=a=="bottom"?r.top-n:null,this.$element.removeClass(u).addClass("affix"+(a?"-"+a:""))};var n=e.fn.affix;e.fn.affix=function(n){return this.each(function(){var r=e(this),i=r.data("affix"),s=typeof n=="object"&&n;i||r.data("affix",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.affix.Constructor=t,e.fn.affix.defaults={offset:0},e.fn.affix.noConflict=function(){return e.fn.affix=n,this},e(window).on("load",function(){e('[data-spy="affix"]').each(function(){var t=e(this),n=t.data();n.offset=n.offset||{},n.offsetBottom&&(n.offset.bottom=n.offsetBottom),n.offsetTop&&(n.offset.top=n.offsetTop),t.affix(n)})})}(window.jQuery);
\ No newline at end of file
diff --git a/website/static/html5shiv.min.js b/website/static/html5shiv.min.js
deleted file mode 100644
index 784f221caf..0000000000
--- a/website/static/html5shiv.min.js
+++ /dev/null
@@ -1,8 +0,0 @@
-/*
- HTML5 Shiv v3.6.2pre | @afarkas @jdalton @jon_neal @rem | MIT/GPL2 Licensed
-*/
-(function(l,f){function m(){var a=e.elements;return"string"==typeof a?a.split(" "):a}function i(a){var b=n[a[o]];b||(b={},h++,a[o]=h,n[h]=b);return b}function p(a,b,c){b||(b=f);if(g)return b.createElement(a);c||(c=i(b));b=c.cache[a]?c.cache[a].cloneNode():r.test(a)?(c.cache[a]=c.createElem(a)).cloneNode():c.createElem(a);return b.canHaveChildren&&!s.test(a)?c.frag.appendChild(b):b}function t(a,b){if(!b.cache)b.cache={},b.createElem=a.createElement,b.createFrag=a.createDocumentFragment,b.frag=b.createFrag();
-a.createElement=function(c){return!e.shivMethods?b.createElem(c):p(c,a,b)};a.createDocumentFragment=Function("h,f","return function(){var n=f.cloneNode(),c=n.createElement;h.shivMethods&&("+m().join().replace(/\w+/g,function(a){b.createElem(a);b.frag.createElement(a);return'c("'+a+'")'})+");return n}")(e,b.frag)}function q(a){a||(a=f);var b=i(a);if(e.shivCSS&&!j&&!b.hasCSS){var c,d=a;c=d.createElement("p");d=d.getElementsByTagName("head")[0]||d.documentElement;c.innerHTML="x<style>article,aside,figcaption,figure,footer,header,hgroup,nav,section{display:block}mark{background:#FF0;color:#000}</style>";
-c=d.insertBefore(c.lastChild,d.firstChild);b.hasCSS=!!c}g||t(a,b);return a}var k=l.html5||{},s=/^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i,r=/^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i,j,o="_html5shiv",h=0,n={},g;(function(){try{var a=f.createElement("a");a.innerHTML="<xyz></xyz>";j="hidden"in a;var b;if(!(b=1==a.childNodes.length)){f.createElement("a");var c=f.createDocumentFragment();b="undefined"==typeof c.cloneNode||
-"undefined"==typeof c.createDocumentFragment||"undefined"==typeof c.createElement}g=b}catch(d){g=j=!0}})();var e={elements:k.elements||"abbr article aside audio bdi canvas data datalist details figcaption figure footer header hgroup mark meter nav output progress section summary time video",version:"3.6.2pre",shivCSS:!1!==k.shivCSS,supportsUnknownElements:g,shivMethods:!1!==k.shivMethods,type:"default",shivDocument:q,createElement:p,createDocumentFragment:function(a,b){a||(a=f);if(g)return a.createDocumentFragment();
-for(var b=b||i(a),c=b.frag.cloneNode(),d=0,e=m(),h=e.length;d<h;d++)c.createElement(e[d]);return c}};l.html5=e;q(f)})(this,document);
diff --git a/website/static/icon-github.png b/website/static/icon-github.png
deleted file mode 100644
index a9c6940069..0000000000
Binary files a/website/static/icon-github.png and /dev/null differ
diff --git a/website/static/icon-square.png b/website/static/icon-square.png
deleted file mode 100644
index bdc98d1c2f..0000000000
Binary files a/website/static/icon-square.png and /dev/null differ
diff --git a/website/static/jquery-maven-artifact.min.js b/website/static/jquery-maven-artifact.min.js
deleted file mode 100644
index 6e134dd857..0000000000
--- a/website/static/jquery-maven-artifact.min.js
+++ /dev/null
@@ -1,7 +0,0 @@
-/**
- * jQuery Maven Artifact Plugin
- *
- * Version: 2.0.0
- * Author: Jake Wharton
- * License: Apache 2.0
- */(function(e){function n(e,t){var n=e.groupId.replace(/\./g,"/"),r="https://repo1.maven.org/maven2/"+n+"/"+e.artifactId+"/"+t+"/"+e.artifactId+"-"+t;return typeof e.classifier!="undefined"&&(r+="-"+e.classifier),r+="."+e.packaging,r}function r(e){var t={groupId:"g",artifactId:"a",packaging:"p",classifier:"l"},n="";for(var r in t)t.hasOwnProperty(r)&&e.hasOwnProperty(r)&&(n!==""&&(n+="+AND+"),n+=t[r]+':"'+e[r]+'"');return n}var t={packaging:"jar"};e.fn.artifactVersion=function(i,s){if(typeof i=="undefined"){alert("Error: config object is required.");return}if(typeof s=="undefined"){alert("Error: callback function required.");return}var i=e.extend({},t,i),o="https://search.maven.org/solrsearch/select/?q="+r(i)+"&wt=json&json.wrf=?";e.getJSON(o,function(e){var t=e.response.docs;if(t.length==0)return;var r=t[0].latestVersion||t[0].v,o=n(i,r);s(r,o)})},e.fn.artifactVersions=function(i,s){if(typeof i=="undefined"){alert("Error: config object is required.");return}if(typeof s=="undefined"){alert("Error: callback function required.");return}var i=e.extend({},t,i),o="https://search.maven.org/solrsearch/select/?q="+r(i)+"&wt=json&rows=10&core=gav&json.wrf=?";e.getJSON(o,function(e){var t=e.response.docs;if(t.length==0)return;t.sort(function(e,t){return e.v>t.v?-1:1});var r=[];for(var o=0;o<t.length;o++){var u=t[o].v;r.push({name:u,url:n(i,u)})}s(r)})}})(jQuery);
diff --git a/website/static/jquery.smooth-scroll.min.js b/website/static/jquery.smooth-scroll.min.js
deleted file mode 100644
index 2af596ee83..0000000000
--- a/website/static/jquery.smooth-scroll.min.js
+++ /dev/null
@@ -1,7 +0,0 @@
-/*!
- * Smooth Scroll - v1.4.10 - 2013-03-02
- * https://github.com/kswedberg/jquery-smooth-scroll
- * Copyright (c) 2013 Karl Swedberg
- * Licensed MIT (https://github.com/kswedberg/jquery-smooth-scroll/blob/master/LICENSE-MIT)
- */
-(function(l){function t(l){return l.replace(/(:|\.)/g,"\\$1")}var e="1.4.10",o={exclude:[],excludeWithin:[],offset:0,direction:"top",scrollElement:null,scrollTarget:null,beforeScroll:function(){},afterScroll:function(){},easing:"swing",speed:400,autoCoefficent:2},r=function(t){var e=[],o=!1,r=t.dir&&"left"==t.dir?"scrollLeft":"scrollTop";return this.each(function(){if(this!=document&&this!=window){var t=l(this);t[r]()>0?e.push(this):(t[r](1),o=t[r]()>0,o&&e.push(this),t[r](0))}}),e.length||this.each(function(){"BODY"===this.nodeName&&(e=[this])}),"first"===t.el&&e.length>1&&(e=[e[0]]),e};l.fn.extend({scrollable:function(l){var t=r.call(this,{dir:l});return this.pushStack(t)},firstScrollable:function(l){var t=r.call(this,{el:"first",dir:l});return this.pushStack(t)},smoothScroll:function(e){e=e||{};var o=l.extend({},l.fn.smoothScroll.defaults,e),r=l.smoothScroll.filterPath(location.pathname);return this.unbind("click.smoothscroll").bind("click.smoothscroll",function(e){var n=this,s=l(this),c=o.exclude,i=o.excludeWithin,a=0,f=0,h=!0,u={},d=location.hostname===n.hostname||!n.hostname,m=o.scrollTarget||(l.smoothScroll.filterPath(n.pathname)||r)===r,p=t(n.hash);if(o.scrollTarget||d&&m&&p){for(;h&&c.length>a;)s.is(t(c[a++]))&&(h=!1);for(;h&&i.length>f;)s.closest(i[f++]).length&&(h=!1)}else h=!1;h&&(e.preventDefault(),l.extend(u,o,{scrollTarget:o.scrollTarget||p,link:n}),l.smoothScroll(u))}),this}}),l.smoothScroll=function(t,e){var o,r,n,s,c=0,i="offset",a="scrollTop",f={},h={};"number"==typeof t?(o=l.fn.smoothScroll.defaults,n=t):(o=l.extend({},l.fn.smoothScroll.defaults,t||{}),o.scrollElement&&(i="position","static"==o.scrollElement.css("position")&&o.scrollElement.css("position","relative"))),o=l.extend({link:null},o),a="left"==o.direction?"scrollLeft":a,o.scrollElement?(r=o.scrollElement,c=r[a]()):r=l("html, body").firstScrollable(),o.beforeScroll.call(r,o),n="number"==typeof t?t:e||l(o.scrollTarget)[i]()&&l(o.scrollTarget)[i]()[o.direction]||0,f[a]=n+c+o.offset,s=o.speed,"auto"===s&&(s=f[a]||r.scrollTop(),s/=o.autoCoefficent),h={duration:s,easing:o.easing,complete:function(){o.afterScroll.call(o.link,o)}},o.step&&(h.step=o.step),r.length?r.stop().animate(f,h):o.afterScroll.call(o.link,o)},l.smoothScroll.version=e,l.smoothScroll.filterPath=function(l){return l.replace(/^\//,"").replace(/(index|default).[a-zA-Z]{3,4}$/,"").replace(/\/$/,"")},l.fn.smoothScroll.defaults=o})(jQuery);
\ No newline at end of file
diff --git a/website/static/logo-square.png b/website/static/logo-square.png
deleted file mode 100644
index 788b301adb..0000000000
Binary files a/website/static/logo-square.png and /dev/null differ
diff --git a/website/static/prettify.js b/website/static/prettify.js
deleted file mode 100644
index 7b990496dd..0000000000
--- a/website/static/prettify.js
+++ /dev/null
@@ -1,30 +0,0 @@
-!function(){var q=null;window.PR_SHOULD_USE_CONTINUATION=!0;
-(function(){function S(a){function d(e){var b=e.charCodeAt(0);if(b!==92)return b;var a=e.charAt(1);return(b=r[a])?b:"0"<=a&&a<="7"?parseInt(e.substring(1),8):a==="u"||a==="x"?parseInt(e.substring(2),16):e.charCodeAt(1)}function g(e){if(e<32)return(e<16?"\\x0":"\\x")+e.toString(16);e=String.fromCharCode(e);return e==="\\"||e==="-"||e==="]"||e==="^"?"\\"+e:e}function b(e){var b=e.substring(1,e.length-1).match(/\\u[\dA-Fa-f]{4}|\\x[\dA-Fa-f]{2}|\\[0-3][0-7]{0,2}|\\[0-7]{1,2}|\\[\S\s]|[^\\]/g),e=[],a=
-b[0]==="^",c=["["];a&&c.push("^");for(var a=a?1:0,f=b.length;a<f;++a){var h=b[a];if(/\\[bdsw]/i.test(h))c.push(h);else{var h=d(h),l;a+2<f&&"-"===b[a+1]?(l=d(b[a+2]),a+=2):l=h;e.push([h,l]);l<65||h>122||(l<65||h>90||e.push([Math.max(65,h)|32,Math.min(l,90)|32]),l<97||h>122||e.push([Math.max(97,h)&-33,Math.min(l,122)&-33]))}}e.sort(function(e,a){return e[0]-a[0]||a[1]-e[1]});b=[];f=[];for(a=0;a<e.length;++a)h=e[a],h[0]<=f[1]+1?f[1]=Math.max(f[1],h[1]):b.push(f=h);for(a=0;a<b.length;++a)h=b[a],c.push(g(h[0])),
-h[1]>h[0]&&(h[1]+1>h[0]&&c.push("-"),c.push(g(h[1])));c.push("]");return c.join("")}function s(e){for(var a=e.source.match(/\[(?:[^\\\]]|\\[\S\s])*]|\\u[\dA-Fa-f]{4}|\\x[\dA-Fa-f]{2}|\\\d+|\\[^\dux]|\(\?[!:=]|[()^]|[^()[\\^]+/g),c=a.length,d=[],f=0,h=0;f<c;++f){var l=a[f];l==="("?++h:"\\"===l.charAt(0)&&(l=+l.substring(1))&&(l<=h?d[l]=-1:a[f]=g(l))}for(f=1;f<d.length;++f)-1===d[f]&&(d[f]=++x);for(h=f=0;f<c;++f)l=a[f],l==="("?(++h,d[h]||(a[f]="(?:")):"\\"===l.charAt(0)&&(l=+l.substring(1))&&l<=h&&
-(a[f]="\\"+d[l]);for(f=0;f<c;++f)"^"===a[f]&&"^"!==a[f+1]&&(a[f]="");if(e.ignoreCase&&m)for(f=0;f<c;++f)l=a[f],e=l.charAt(0),l.length>=2&&e==="["?a[f]=b(l):e!=="\\"&&(a[f]=l.replace(/[A-Za-z]/g,function(a){a=a.charCodeAt(0);return"["+String.fromCharCode(a&-33,a|32)+"]"}));return a.join("")}for(var x=0,m=!1,j=!1,k=0,c=a.length;k<c;++k){var i=a[k];if(i.ignoreCase)j=!0;else if(/[a-z]/i.test(i.source.replace(/\\u[\da-f]{4}|\\x[\da-f]{2}|\\[^UXux]/gi,""))){m=!0;j=!1;break}}for(var r={b:8,t:9,n:10,v:11,
-f:12,r:13},n=[],k=0,c=a.length;k<c;++k){i=a[k];if(i.global||i.multiline)throw Error(""+i);n.push("(?:"+s(i)+")")}return RegExp(n.join("|"),j?"gi":"g")}function T(a,d){function g(a){var c=a.nodeType;if(c==1){if(!b.test(a.className)){for(c=a.firstChild;c;c=c.nextSibling)g(c);c=a.nodeName.toLowerCase();if("br"===c||"li"===c)s[j]="\n",m[j<<1]=x++,m[j++<<1|1]=a}}else if(c==3||c==4)c=a.nodeValue,c.length&&(c=d?c.replace(/\r\n?/g,"\n"):c.replace(/[\t\n\r ]+/g," "),s[j]=c,m[j<<1]=x,x+=c.length,m[j++<<1|1]=
-a)}var b=/(?:^|\s)nocode(?:\s|$)/,s=[],x=0,m=[],j=0;g(a);return{a:s.join("").replace(/\n$/,""),d:m}}function H(a,d,g,b){d&&(a={a:d,e:a},g(a),b.push.apply(b,a.g))}function U(a){for(var d=void 0,g=a.firstChild;g;g=g.nextSibling)var b=g.nodeType,d=b===1?d?a:g:b===3?V.test(g.nodeValue)?a:d:d;return d===a?void 0:d}function C(a,d){function g(a){for(var j=a.e,k=[j,"pln"],c=0,i=a.a.match(s)||[],r={},n=0,e=i.length;n<e;++n){var z=i[n],w=r[z],t=void 0,f;if(typeof w==="string")f=!1;else{var h=b[z.charAt(0)];
-if(h)t=z.match(h[1]),w=h[0];else{for(f=0;f<x;++f)if(h=d[f],t=z.match(h[1])){w=h[0];break}t||(w="pln")}if((f=w.length>=5&&"lang-"===w.substring(0,5))&&!(t&&typeof t[1]==="string"))f=!1,w="src";f||(r[z]=w)}h=c;c+=z.length;if(f){f=t[1];var l=z.indexOf(f),B=l+f.length;t[2]&&(B=z.length-t[2].length,l=B-f.length);w=w.substring(5);H(j+h,z.substring(0,l),g,k);H(j+h+l,f,I(w,f),k);H(j+h+B,z.substring(B),g,k)}else k.push(j+h,w)}a.g=k}var b={},s;(function(){for(var g=a.concat(d),j=[],k={},c=0,i=g.length;c<i;++c){var r=
-g[c],n=r[3];if(n)for(var e=n.length;--e>=0;)b[n.charAt(e)]=r;r=r[1];n=""+r;k.hasOwnProperty(n)||(j.push(r),k[n]=q)}j.push(/[\S\s]/);s=S(j)})();var x=d.length;return g}function v(a){var d=[],g=[];a.tripleQuotedStrings?d.push(["str",/^(?:'''(?:[^'\\]|\\[\S\s]|''?(?=[^']))*(?:'''|$)|"""(?:[^"\\]|\\[\S\s]|""?(?=[^"]))*(?:"""|$)|'(?:[^'\\]|\\[\S\s])*(?:'|$)|"(?:[^"\\]|\\[\S\s])*(?:"|$))/,q,"'\""]):a.multiLineStrings?d.push(["str",/^(?:'(?:[^'\\]|\\[\S\s])*(?:'|$)|"(?:[^"\\]|\\[\S\s])*(?:"|$)|`(?:[^\\`]|\\[\S\s])*(?:`|$))/,
-q,"'\"`"]):d.push(["str",/^(?:'(?:[^\n\r'\\]|\\.)*(?:'|$)|"(?:[^\n\r"\\]|\\.)*(?:"|$))/,q,"\"'"]);a.verbatimStrings&&g.push(["str",/^@"(?:[^"]|"")*(?:"|$)/,q]);var b=a.hashComments;b&&(a.cStyleComments?(b>1?d.push(["com",/^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/,q,"#"]):d.push(["com",/^#(?:(?:define|e(?:l|nd)if|else|error|ifn?def|include|line|pragma|undef|warning)\b|[^\n\r]*)/,q,"#"]),g.push(["str",/^<(?:(?:(?:\.\.\/)*|\/?)(?:[\w-]+(?:\/[\w-]+)+)?[\w-]+\.h(?:h|pp|\+\+)?|[a-z]\w*)>/,q])):d.push(["com",
-/^#[^\n\r]*/,q,"#"]));a.cStyleComments&&(g.push(["com",/^\/\/[^\n\r]*/,q]),g.push(["com",/^\/\*[\S\s]*?(?:\*\/|$)/,q]));if(b=a.regexLiterals){var s=(b=b>1?"":"\n\r")?".":"[\\S\\s]";g.push(["lang-regex",RegExp("^(?:^^\\.?|[+-]|[!=]=?=?|\\#|%=?|&&?=?|\\(|\\*=?|[+\\-]=|->|\\/=?|::?|<<?=?|>>?>?=?|,|;|\\?|@|\\[|~|{|\\^\\^?=?|\\|\\|?=?|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\s*("+("/(?=[^/*"+b+"])(?:[^/\\x5B\\x5C"+b+"]|\\x5C"+s+"|\\x5B(?:[^\\x5C\\x5D"+b+"]|\\x5C"+
-s+")*(?:\\x5D|$))+/")+")")])}(b=a.types)&&g.push(["typ",b]);b=(""+a.keywords).replace(/^ | $/g,"");b.length&&g.push(["kwd",RegExp("^(?:"+b.replace(/[\s,]+/g,"|")+")\\b"),q]);d.push(["pln",/^\s+/,q," \r\n\t\u00a0"]);b="^.[^\\s\\w.$@'\"`/\\\\]*";a.regexLiterals&&(b+="(?!s*/)");g.push(["lit",/^@[$_a-z][\w$@]*/i,q],["typ",/^(?:[@_]?[A-Z]+[a-z][\w$@]*|\w+_t\b)/,q],["pln",/^[$_a-z][\w$@]*/i,q],["lit",/^(?:0x[\da-f]+|(?:\d(?:_\d+)*\d*(?:\.\d*)?|\.\d\+)(?:e[+-]?\d+)?)[a-z]*/i,q,"0123456789"],["pln",/^\\[\S\s]?/,
-q],["pun",RegExp(b),q]);return C(d,g)}function J(a,d,g){function b(a){var c=a.nodeType;if(c==1&&!x.test(a.className))if("br"===a.nodeName)s(a),a.parentNode&&a.parentNode.removeChild(a);else for(a=a.firstChild;a;a=a.nextSibling)b(a);else if((c==3||c==4)&&g){var d=a.nodeValue,i=d.match(m);if(i)c=d.substring(0,i.index),a.nodeValue=c,(d=d.substring(i.index+i[0].length))&&a.parentNode.insertBefore(j.createTextNode(d),a.nextSibling),s(a),c||a.parentNode.removeChild(a)}}function s(a){function b(a,c){var d=
-c?a.cloneNode(!1):a,e=a.parentNode;if(e){var e=b(e,1),g=a.nextSibling;e.appendChild(d);for(var i=g;i;i=g)g=i.nextSibling,e.appendChild(i)}return d}for(;!a.nextSibling;)if(a=a.parentNode,!a)return;for(var a=b(a.nextSibling,0),d;(d=a.parentNode)&&d.nodeType===1;)a=d;c.push(a)}for(var x=/(?:^|\s)nocode(?:\s|$)/,m=/\r\n?|\n/,j=a.ownerDocument,k=j.createElement("li");a.firstChild;)k.appendChild(a.firstChild);for(var c=[k],i=0;i<c.length;++i)b(c[i]);d===(d|0)&&c[0].setAttribute("value",d);var r=j.createElement("ol");
-r.className="linenums";for(var d=Math.max(0,d-1|0)||0,i=0,n=c.length;i<n;++i)k=c[i],k.className="L"+(i+d)%10,k.firstChild||k.appendChild(j.createTextNode("\u00a0")),r.appendChild(k);a.appendChild(r)}function p(a,d){for(var g=d.length;--g>=0;){var b=d[g];F.hasOwnProperty(b)?D.console&&console.warn("cannot override language handler %s",b):F[b]=a}}function I(a,d){if(!a||!F.hasOwnProperty(a))a=/^\s*</.test(d)?"default-markup":"default-code";return F[a]}function K(a){var d=a.h;try{var g=T(a.c,a.i),b=g.a;
-a.a=b;a.d=g.d;a.e=0;I(d,b)(a);var s=/\bMSIE\s(\d+)/.exec(navigator.userAgent),s=s&&+s[1]<=8,d=/\n/g,x=a.a,m=x.length,g=0,j=a.d,k=j.length,b=0,c=a.g,i=c.length,r=0;c[i]=m;var n,e;for(e=n=0;e<i;)c[e]!==c[e+2]?(c[n++]=c[e++],c[n++]=c[e++]):e+=2;i=n;for(e=n=0;e<i;){for(var p=c[e],w=c[e+1],t=e+2;t+2<=i&&c[t+1]===w;)t+=2;c[n++]=p;c[n++]=w;e=t}c.length=n;var f=a.c,h;if(f)h=f.style.display,f.style.display="none";try{for(;b<k;){var l=j[b+2]||m,B=c[r+2]||m,t=Math.min(l,B),A=j[b+1],G;if(A.nodeType!==1&&(G=x.substring(g,
-t))){s&&(G=G.replace(d,"\r"));A.nodeValue=G;var L=A.ownerDocument,o=L.createElement("span");o.className=c[r+1];var v=A.parentNode;v.replaceChild(o,A);o.appendChild(A);g<l&&(j[b+1]=A=L.createTextNode(x.substring(t,l)),v.insertBefore(A,o.nextSibling))}g=t;g>=l&&(b+=2);g>=B&&(r+=2)}}finally{if(f)f.style.display=h}}catch(u){D.console&&console.log(u&&u.stack||u)}}var D=window,y=["break,continue,do,else,for,if,return,while"],E=[[y,"auto,case,char,const,default,double,enum,extern,float,goto,inline,int,long,register,short,signed,sizeof,static,struct,switch,typedef,union,unsigned,void,volatile"],
-"catch,class,delete,false,import,new,operator,private,protected,public,this,throw,true,try,typeof"],M=[E,"alignof,align_union,asm,axiom,bool,concept,concept_map,const_cast,constexpr,decltype,delegate,dynamic_cast,explicit,export,friend,generic,late_check,mutable,namespace,nullptr,property,reinterpret_cast,static_assert,static_cast,template,typeid,typename,using,virtual,where"],N=[E,"abstract,assert,boolean,byte,extends,final,finally,implements,import,instanceof,interface,null,native,package,strictfp,super,synchronized,throws,transient"],
-O=[N,"as,base,by,checked,decimal,delegate,descending,dynamic,event,fixed,foreach,from,group,implicit,in,internal,into,is,let,lock,object,out,override,orderby,params,partial,readonly,ref,sbyte,sealed,stackalloc,string,select,uint,ulong,unchecked,unsafe,ushort,var,virtual,where"],E=[E,"debugger,eval,export,function,get,null,set,undefined,var,with,Infinity,NaN"],P=[y,"and,as,assert,class,def,del,elif,except,exec,finally,from,global,import,in,is,lambda,nonlocal,not,or,pass,print,raise,try,with,yield,False,True,None"],
-Q=[y,"alias,and,begin,case,class,def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,rescue,retry,self,super,then,true,undef,unless,until,when,yield,BEGIN,END"],W=[y,"as,assert,const,copy,drop,enum,extern,fail,false,fn,impl,let,log,loop,match,mod,move,mut,priv,pub,pure,ref,self,static,struct,true,trait,type,unsafe,use"],y=[y,"case,done,elif,esac,eval,fi,function,in,local,set,then,until"],R=/^(DIR|FILE|vector|(de|priority_)?queue|list|stack|(const_)?iterator|(multi)?(set|map)|bitset|u?(int|float)\d*)\b/,
-V=/\S/,X=v({keywords:[M,O,E,"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END",P,Q,y],hashComments:!0,cStyleComments:!0,multiLineStrings:!0,regexLiterals:!0}),F={};p(X,["default-code"]);p(C([],[["pln",/^[^<?]+/],["dec",/^<!\w[^>]*(?:>|$)/],["com",/^<\!--[\S\s]*?(?:--\>|$)/],["lang-",/^<\?([\S\s]+?)(?:\?>|$)/],["lang-",/^<%([\S\s]+?)(?:%>|$)/],["pun",/^(?:<[%?]|[%?]>)/],["lang-",
-/^<xmp\b[^>]*>([\S\s]+?)<\/xmp\b[^>]*>/i],["lang-js",/^<script\b[^>]*>([\S\s]*?)(<\/script\b[^>]*>)/i],["lang-css",/^<style\b[^>]*>([\S\s]*?)(<\/style\b[^>]*>)/i],["lang-in.tag",/^(<\/?[a-z][^<>]*>)/i]]),["default-markup","htm","html","mxml","xhtml","xml","xsl"]);p(C([["pln",/^\s+/,q," \t\r\n"],["atv",/^(?:"[^"]*"?|'[^']*'?)/,q,"\"'"]],[["tag",/^^<\/?[a-z](?:[\w-.:]*\w)?|\/?>$/i],["atn",/^(?!style[\s=]|on)[a-z](?:[\w:-]*\w)?/i],["lang-uq.val",/^=\s*([^\s"'>]*(?:[^\s"'/>]|\/(?=\s)))/],["pun",/^[/<->]+/],
-["lang-js",/^on\w+\s*=\s*"([^"]+)"/i],["lang-js",/^on\w+\s*=\s*'([^']+)'/i],["lang-js",/^on\w+\s*=\s*([^\s"'>]+)/i],["lang-css",/^style\s*=\s*"([^"]+)"/i],["lang-css",/^style\s*=\s*'([^']+)'/i],["lang-css",/^style\s*=\s*([^\s"'>]+)/i]]),["in.tag"]);p(C([],[["atv",/^[\S\s]+/]]),["uq.val"]);p(v({keywords:M,hashComments:!0,cStyleComments:!0,types:R}),["c","cc","cpp","cxx","cyc","m"]);p(v({keywords:"null,true,false"}),["json"]);p(v({keywords:O,hashComments:!0,cStyleComments:!0,verbatimStrings:!0,types:R}),
-["cs"]);p(v({keywords:N,cStyleComments:!0}),["java"]);p(v({keywords:y,hashComments:!0,multiLineStrings:!0}),["bash","bsh","csh","sh"]);p(v({keywords:P,hashComments:!0,multiLineStrings:!0,tripleQuotedStrings:!0}),["cv","py","python"]);p(v({keywords:"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END",hashComments:!0,multiLineStrings:!0,regexLiterals:2}),["perl","pl","pm"]);p(v({keywords:Q,
-hashComments:!0,multiLineStrings:!0,regexLiterals:!0}),["rb","ruby"]);p(v({keywords:E,cStyleComments:!0,regexLiterals:!0}),["javascript","js"]);p(v({keywords:"all,and,by,catch,class,else,extends,false,finally,for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,throw,true,try,unless,until,when,while,yes",hashComments:3,cStyleComments:!0,multilineStrings:!0,tripleQuotedStrings:!0,regexLiterals:!0}),["coffee"]);p(v({keywords:W,cStyleComments:!0,multilineStrings:!0}),["rc","rs","rust"]);
-p(C([],[["str",/^[\S\s]+/]]),["regex"]);var Y=D.PR={createSimpleLexer:C,registerLangHandler:p,sourceDecorator:v,PR_ATTRIB_NAME:"atn",PR_ATTRIB_VALUE:"atv",PR_COMMENT:"com",PR_DECLARATION:"dec",PR_KEYWORD:"kwd",PR_LITERAL:"lit",PR_NOCODE:"nocode",PR_PLAIN:"pln",PR_PUNCTUATION:"pun",PR_SOURCE:"src",PR_STRING:"str",PR_TAG:"tag",PR_TYPE:"typ",prettyPrintOne:D.prettyPrintOne=function(a,d,g){var b=document.createElement("div");b.innerHTML="<pre>"+a+"</pre>";b=b.firstChild;g&&J(b,g,!0);K({h:d,j:g,c:b,i:1});
-return b.innerHTML},prettyPrint:D.prettyPrint=function(a,d){function g(){for(var b=D.PR_SHOULD_USE_CONTINUATION?c.now()+250:Infinity;i<p.length&&c.now()<b;i++){for(var d=p[i],j=h,k=d;k=k.previousSibling;){var m=k.nodeType,o=(m===7||m===8)&&k.nodeValue;if(o?!/^\??prettify\b/.test(o):m!==3||/\S/.test(k.nodeValue))break;if(o){j={};o.replace(/\b(\w+)=([\w%+\-.:]+)/g,function(a,b,c){j[b]=c});break}}k=d.className;if((j!==h||e.test(k))&&!v.test(k)){m=!1;for(o=d.parentNode;o;o=o.parentNode)if(f.test(o.tagName)&&
-o.className&&e.test(o.className)){m=!0;break}if(!m){d.className+=" prettyprinted";m=j.lang;if(!m){var m=k.match(n),y;if(!m&&(y=U(d))&&t.test(y.tagName))m=y.className.match(n);m&&(m=m[1])}if(w.test(d.tagName))o=1;else var o=d.currentStyle,u=s.defaultView,o=(o=o?o.whiteSpace:u&&u.getComputedStyle?u.getComputedStyle(d,q).getPropertyValue("white-space"):0)&&"pre"===o.substring(0,3);u=j.linenums;if(!(u=u==="true"||+u))u=(u=k.match(/\blinenums\b(?::(\d+))?/))?u[1]&&u[1].length?+u[1]:!0:!1;u&&J(d,u,o);r=
-{h:m,c:d,j:u,i:o};K(r)}}}i<p.length?setTimeout(g,250):"function"===typeof a&&a()}for(var b=d||document.body,s=b.ownerDocument||document,b=[b.getElementsByTagName("pre"),b.getElementsByTagName("code"),b.getElementsByTagName("xmp")],p=[],m=0;m<b.length;++m)for(var j=0,k=b[m].length;j<k;++j)p.push(b[m][j]);var b=q,c=Date;c.now||(c={now:function(){return+new Date}});var i=0,r,n=/\blang(?:uage)?-([\w.]+)(?!\S)/,e=/\bprettyprint\b/,v=/\bprettyprinted\b/,w=/pre|xmp/i,t=/^code$/i,f=/^(?:pre|code|xmp)$/i,
-h={};g()}};typeof define==="function"&&define.amd&&define("google-code-prettify",[],function(){return Y})})();}()
