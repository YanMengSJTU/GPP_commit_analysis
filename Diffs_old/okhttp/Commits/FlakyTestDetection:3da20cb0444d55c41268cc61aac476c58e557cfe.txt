diff --git a/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java b/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
index 4283e5a812..d11ea05bb4 100644
--- a/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
@@ -20,12 +20,26 @@
 import java.net.InetSocketAddress;
 import java.net.Proxy;
 import java.net.UnknownHostException;
-import java.util.ArrayDeque;
-import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
-import java.util.Deque;
 import java.util.List;
+import okhttp3.RecordingEventListener.CallEvent;
+import okhttp3.RecordingEventListener.ConnectEnd;
+import okhttp3.RecordingEventListener.ConnectStart;
+import okhttp3.RecordingEventListener.ConnectionAcquired;
+import okhttp3.RecordingEventListener.ConnectionReleased;
+import okhttp3.RecordingEventListener.DnsEnd;
+import okhttp3.RecordingEventListener.DnsStart;
+import okhttp3.RecordingEventListener.FetchEnd;
+import okhttp3.RecordingEventListener.FetchStart;
+import okhttp3.RecordingEventListener.RequestHeadersEnd;
+import okhttp3.RecordingEventListener.RequestHeadersStart;
+import okhttp3.RecordingEventListener.ResponseBodyEnd;
+import okhttp3.RecordingEventListener.ResponseBodyStart;
+import okhttp3.RecordingEventListener.ResponseHeadersEnd;
+import okhttp3.RecordingEventListener.ResponseHeadersStart;
+import okhttp3.RecordingEventListener.SecureConnectEnd;
+import okhttp3.RecordingEventListener.SecureConnectStart;
 import okhttp3.internal.DoubleInetAddressDns;
 import okhttp3.internal.RecordingOkAuthenticator;
 import okhttp3.internal.SingleInetAddressDns;
@@ -80,10 +94,12 @@
     assertEquals(200, response.code());
     response.body().close();
 
-    List<Class<?>> expectedEvents = Arrays.asList(
-        DnsStart.class, DnsEnd.class,
-        ConnectStart.class, ConnectEnd.class,
-        ConnectionAcquired.class);
+    // TODO ResponseBodyEnd should not be last event
+    List<String> expectedEvents = Arrays.asList("FetchStart",
+        "DnsStart", "DnsEnd", "ConnectStart", "ConnectEnd",
+        "ConnectionAcquired", "RequestHeadersStart", "RequestHeadersEnd",
+        "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
+        "ConnectionReleased", "FetchEnd", "ResponseBodyEnd");
     assertEquals(expectedEvents, listener.recordedEventTypes());
   }
 
@@ -98,11 +114,13 @@
     assertEquals(200, response.code());
     response.body().close();
 
-    List<Class<?>> expectedEvents = Arrays.asList(
-        DnsStart.class, DnsEnd.class,
-        ConnectStart.class, SecureConnectStart.class,
-        SecureConnectEnd.class, ConnectEnd.class,
-        ConnectionAcquired.class);
+    // TODO ResponseBodyEnd should not be last event
+    List<String> expectedEvents = Arrays.asList("FetchStart",
+        "DnsStart", "DnsEnd", "ConnectStart", "SecureConnectStart",
+        "SecureConnectEnd", "ConnectEnd",
+        "ConnectionAcquired", "RequestHeadersStart", "RequestHeadersEnd",
+        "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
+        "ConnectionReleased", "FetchEnd", "ResponseBodyEnd");
     assertEquals(expectedEvents, listener.recordedEventTypes());
   }
 
@@ -148,9 +166,9 @@
     assertEquals(200, response2.code());
     response2.body().close();
 
-    List<Class<?>> recordedEvents = listener.recordedEventTypes();
-    assertFalse(recordedEvents.contains(DnsStart.class));
-    assertFalse(recordedEvents.contains(DnsEnd.class));
+    List<String> recordedEvents = listener.recordedEventTypes();
+    assertFalse(recordedEvents.contains("DnsStart"));
+    assertFalse(recordedEvents.contains("DnsEnd"));
   }
 
   @Test public void multipleDnsLookupsForSingleCall() throws IOException {
@@ -520,9 +538,9 @@
     assertEquals(200, response2.code());
     response2.body().close();
 
-    List<Class<?>> recordedEvents = listener.recordedEventTypes();
-    assertFalse(recordedEvents.contains(SecureConnectStart.class));
-    assertFalse(recordedEvents.contains(SecureConnectEnd.class));
+    List<String> recordedEvents = listener.recordedEventTypes();
+    assertFalse(recordedEvents.contains("SecureConnectStart"));
+    assertFalse(recordedEvents.contains("SecureConnectEnd"));
   }
 
   @Test public void successfulConnectionFound() throws IOException {
@@ -555,8 +573,8 @@
 
     listener.removeUpToEvent(ConnectionAcquired.class);
 
-    List<Class<?>> remainingEvents = listener.recordedEventTypes();
-    assertFalse(remainingEvents.contains(ConnectionAcquired.class));
+    List<String> remainingEvents = listener.recordedEventTypes();
+    assertFalse(remainingEvents.contains("ConnectionAcquired"));
   }
 
   @Test public void pooledConnectionFound() throws IOException {
@@ -610,158 +628,4 @@ private void enableTlsWithTunnel(boolean tunnelProxy) {
         .build();
     server.useHttps(sslClient.socketFactory, tunnelProxy);
   }
-
-  static final class DnsStart {
-    final Call call;
-    final String domainName;
-
-    DnsStart(Call call, String domainName) {
-      this.call = call;
-      this.domainName = domainName;
-    }
-  }
-
-  static final class DnsEnd {
-    final Call call;
-    final String domainName;
-    final List<InetAddress> inetAddressList;
-    final Throwable throwable;
-
-    DnsEnd(Call call, String domainName, List<InetAddress> inetAddressList, Throwable throwable) {
-      this.call = call;
-      this.domainName = domainName;
-      this.inetAddressList = inetAddressList;
-      this.throwable = throwable;
-    }
-  }
-
-  static final class ConnectStart {
-    final Call call;
-    final InetSocketAddress inetSocketAddress;
-    final Proxy proxy;
-
-    ConnectStart(Call call, InetSocketAddress inetSocketAddress, Proxy proxy) {
-      this.call = call;
-      this.inetSocketAddress = inetSocketAddress;
-      this.proxy = proxy;
-    }
-  }
-
-  static final class ConnectEnd {
-    final Call call;
-    final InetSocketAddress inetSocketAddress;
-    final Protocol protocol;
-    final Throwable throwable;
-
-    ConnectEnd(Call call, InetSocketAddress inetSocketAddress, Protocol protocol, Throwable throwable) {
-      this.call = call;
-      this.inetSocketAddress = inetSocketAddress;
-      this.protocol = protocol;
-      this.throwable = throwable;
-    }
-  }
-
-  static final class SecureConnectStart {
-    final Call call;
-
-    SecureConnectStart(Call call) {
-      this.call = call;
-    }
-  }
-
-  static final class SecureConnectEnd {
-    final Call call;
-    final Handshake handshake;
-    final Throwable throwable;
-
-    SecureConnectEnd(Call call, Handshake handshake, Throwable throwable) {
-      this.call = call;
-      this.handshake = handshake;
-      this.throwable = throwable;
-    }
-  }
-
-  static final class ConnectionAcquired {
-    final Call call;
-    final Connection connection;
-
-    ConnectionAcquired(Call call, Connection connection) {
-      this.call = call;
-      this.connection = connection;
-    }
-  }
-
-  static final class ConnectionReleased {
-    final Call call;
-    final Connection connection;
-
-    ConnectionReleased(Call call, Connection connection) {
-      this.call = call;
-      this.connection = connection;
-    }
-  }
-
-  static final class RecordingEventListener extends EventListener {
-    final Deque<Object> eventSequence = new ArrayDeque<>();
-
-    /**
-     * Removes recorded events up to (and including) an event is found whose class equals
-     * {@code eventClass} and returns it.
-     */
-    <T> T removeUpToEvent(Class<T> eventClass) {
-      Object event = eventSequence.poll();
-      while (event != null && !eventClass.isInstance(event)) {
-        event = eventSequence.poll();
-      }
-      if (event == null) throw new AssertionError();
-      return (T) event;
-    }
-
-    List<Class<?>> recordedEventTypes() {
-      List<Class<?>> eventTypes = new ArrayList<>();
-      for (Object event : eventSequence) {
-        eventTypes.add(event.getClass());
-      }
-      return eventTypes;
-    }
-
-    void clearAllEvents() {
-      eventSequence.clear();
-    }
-
-    @Override public void dnsStart(Call call, String domainName) {
-      eventSequence.offer(new DnsStart(call, domainName));
-    }
-
-    @Override public void dnsEnd(Call call, String domainName, List<InetAddress> inetAddressList,
-        Throwable throwable) {
-      eventSequence.offer(new DnsEnd(call, domainName, inetAddressList, throwable));
-    }
-
-    @Override public void connectStart(Call call, InetSocketAddress inetSocketAddress,
-        Proxy proxy) {
-      eventSequence.offer(new ConnectStart(call, inetSocketAddress, proxy));
-    }
-
-    @Override public void secureConnectStart(Call call) {
-      eventSequence.offer(new SecureConnectStart(call));
-    }
-
-    @Override public void secureConnectEnd(Call call, Handshake handshake, Throwable throwable) {
-      eventSequence.offer(new SecureConnectEnd(call, handshake, throwable));
-    }
-
-    @Override public void connectEnd(Call call, InetSocketAddress inetSocketAddress,
-        Proxy proxy, Protocol protocol, Throwable throwable) {
-      eventSequence.offer(new ConnectEnd(call, inetSocketAddress, protocol, throwable));
-    }
-
-    @Override public void connectionAcquired(Call call, Connection connection) {
-      eventSequence.offer(new ConnectionAcquired(call, connection));
-    }
-
-    @Override public void connectionReleased(Call call, Connection connection) {
-      eventSequence.offer(new ConnectionReleased(call, connection));
-    }
-  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/RecordingEventListener.java b/okhttp-tests/src/test/java/okhttp3/RecordingEventListener.java
new file mode 100644
index 0000000000..c4dfa7b8e4
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/RecordingEventListener.java
@@ -0,0 +1,374 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Deque;
+import java.util.List;
+import javax.annotation.Nullable;
+
+import static org.junit.Assert.assertTrue;
+
+final class RecordingEventListener extends EventListener {
+  final Deque<CallEvent> eventSequence = new ArrayDeque<>();
+
+  /**
+   * Removes recorded events up to (and including) an event is found whose class equals
+   * {@code eventClass} and returns it.
+   */
+  <T> T removeUpToEvent(Class<T> eventClass) {
+    Object event = eventSequence.poll();
+    while (event != null && !eventClass.isInstance(event)) {
+      event = eventSequence.poll();
+    }
+    if (event == null) throw new AssertionError();
+    return (T) event;
+  }
+
+  List<String> recordedEventTypes() {
+    List<String> eventTypes = new ArrayList<>();
+    for (CallEvent event : eventSequence) {
+      eventTypes.add(event.getName());
+    }
+    return eventTypes;
+  }
+
+  void clearAllEvents() {
+    eventSequence.clear();
+  }
+
+  private void logEvent(CallEvent e) {
+    CallEvent startEvent = e.closes();
+
+    if (startEvent != null) {
+      assertTrue(e.getName() + " without matching " + startEvent.getName(),
+          eventSequence.contains(startEvent));
+    }
+
+    eventSequence.offer(e);
+  }
+
+  @Override public void dnsStart(Call call, String domainName) {
+    logEvent(new DnsStart(call, domainName));
+  }
+
+  @Override public void dnsEnd(Call call, String domainName, List<InetAddress> inetAddressList,
+      Throwable throwable) {
+    logEvent(new DnsEnd(call, domainName, inetAddressList, throwable));
+  }
+
+  @Override public void connectStart(Call call, InetSocketAddress inetSocketAddress,
+      Proxy proxy) {
+    logEvent(new ConnectStart(call, inetSocketAddress, proxy));
+  }
+
+  @Override public void secureConnectStart(Call call) {
+    logEvent(new SecureConnectStart(call));
+  }
+
+  @Override public void secureConnectEnd(Call call, Handshake handshake, Throwable throwable) {
+    logEvent(new SecureConnectEnd(call, handshake, throwable));
+  }
+
+  @Override public void connectEnd(Call call, InetSocketAddress inetSocketAddress,
+      @Nullable Proxy proxy, Protocol protocol, Throwable throwable) {
+    logEvent(new ConnectEnd(call, inetSocketAddress, proxy, protocol, throwable));
+  }
+
+  @Override public void connectionAcquired(Call call, Connection connection) {
+    logEvent(new ConnectionAcquired(call, connection));
+  }
+
+  @Override public void connectionReleased(Call call, Connection connection) {
+    logEvent(new ConnectionReleased(call, connection));
+  }
+
+  @Override public void fetchStart(Call call) {
+    logEvent(new FetchStart(call));
+  }
+
+  @Override public void requestHeadersStart(Call call) {
+    logEvent(new RequestHeadersStart(call));
+  }
+
+  @Override public void requestHeadersEnd(Call call, Throwable throwable) {
+    logEvent(new RequestHeadersEnd(call, throwable));
+  }
+
+  @Override public void requestBodyStart(Call call) {
+    logEvent(new RequestBodyStart(call));
+  }
+
+  @Override public void requestBodyEnd(Call call, Throwable throwable) {
+    logEvent(new RequestBodyEnd(call, throwable));
+  }
+
+  @Override public void responseHeadersStart(Call call) {
+    logEvent(new ResponseHeadersStart(call));
+  }
+
+  @Override public void responseHeadersEnd(Call call, Throwable throwable) {
+    logEvent(new ResponseHeadersEnd(call, throwable));
+  }
+
+  @Override public void responseBodyStart(Call call) {
+    logEvent(new ResponseBodyStart(call));
+  }
+
+  @Override public void responseBodyEnd(Call call, Throwable throwable) {
+    logEvent(new ResponseBodyEnd(call, throwable));
+  }
+
+  @Override public void fetchEnd(Call call, Throwable throwable) {
+    logEvent(new FetchEnd(call, throwable));
+  }
+
+  static class CallEvent {
+    final Call call;
+    final List<Object> params;
+
+    CallEvent(Call call, Object... params) {
+      this.call = call;
+      this.params = Arrays.asList(params);
+    }
+
+    public String getName() {
+      return getClass().getSimpleName();
+    }
+
+    @Override public boolean equals(Object o) {
+      if (this == o) return true;
+      if (!(o instanceof CallEvent)) return false;
+
+      CallEvent callEvent = (CallEvent) o;
+
+      if (!getName().equals(callEvent.getName())) return false;
+      if (!call.equals(callEvent.call)) return false;
+      return params.equals(callEvent.params);
+    }
+
+    @Override public int hashCode() {
+      int result = call.hashCode();
+      result = 31 * result + getName().hashCode();
+      result = 31 * result + params.hashCode();
+      return result;
+    }
+
+    public @Nullable CallEvent closes() {
+      return null;
+    }
+  }
+
+  static final class DnsStart extends CallEvent {
+    final String domainName;
+
+    DnsStart(Call call, String domainName) {
+      super(call, domainName);
+      this.domainName = domainName;
+    }
+  }
+
+  static final class DnsEnd extends CallEvent {
+    final String domainName;
+    final List<InetAddress> inetAddressList;
+    final Throwable throwable;
+
+    DnsEnd(Call call, String domainName, List<InetAddress> inetAddressList, Throwable throwable) {
+      super(call, domainName, inetAddressList, throwable);
+      this.domainName = domainName;
+      this.inetAddressList = inetAddressList;
+      this.throwable = throwable;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new DnsStart(call, domainName);
+    }
+  }
+
+  static final class ConnectStart extends CallEvent {
+    final InetSocketAddress inetSocketAddress;
+    final Proxy proxy;
+
+    ConnectStart(Call call, InetSocketAddress inetSocketAddress, Proxy proxy) {
+      super(call, inetSocketAddress, proxy);
+      this.inetSocketAddress = inetSocketAddress;
+      this.proxy = proxy;
+    }
+  }
+
+  static final class ConnectEnd extends CallEvent {
+    final InetSocketAddress inetSocketAddress;
+    final Protocol protocol;
+    final Throwable throwable;
+    final Proxy proxy;
+
+    ConnectEnd(Call call, InetSocketAddress inetSocketAddress, Proxy proxy, Protocol protocol,
+        Throwable throwable) {
+      super(call, inetSocketAddress, proxy, protocol, throwable);
+      this.inetSocketAddress = inetSocketAddress;
+      this.proxy = proxy;
+      this.protocol = protocol;
+      this.throwable = throwable;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new ConnectStart(call, inetSocketAddress, proxy);
+    }
+  }
+
+  static final class SecureConnectStart extends CallEvent {
+    SecureConnectStart(Call call) {
+      super(call);
+    }
+  }
+
+  static final class SecureConnectEnd extends CallEvent {
+    final Handshake handshake;
+    final Throwable throwable;
+
+    SecureConnectEnd(Call call, Handshake handshake, Throwable throwable) {
+      super(call, handshake, throwable);
+      this.handshake = handshake;
+      this.throwable = throwable;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new SecureConnectStart(call);
+    }
+  }
+
+  static final class ConnectionAcquired extends CallEvent {
+    final Connection connection;
+
+    ConnectionAcquired(Call call, Connection connection) {
+      super(call, connection);
+      this.connection = connection;
+    }
+  }
+
+  static final class ConnectionReleased extends CallEvent {
+    final Connection connection;
+
+    ConnectionReleased(Call call, Connection connection) {
+      super(call, connection);
+      this.connection = connection;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new ConnectionAcquired(call, connection);
+    }
+  }
+
+  static final class FetchStart extends CallEvent {
+    FetchStart(Call call) {
+      super(call);
+    }
+  }
+
+  static final class FetchEnd extends CallEvent {
+    final Throwable throwable;
+
+    FetchEnd(Call call, Throwable throwable) {
+      super(call, throwable);
+      this.throwable = throwable;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new FetchStart(call);
+    }
+  }
+
+  static final class RequestHeadersStart extends CallEvent {
+    RequestHeadersStart(Call call) {
+      super(call);
+    }
+  }
+
+  static final class RequestHeadersEnd extends CallEvent {
+    final Throwable throwable;
+
+    RequestHeadersEnd(Call call, Throwable throwable) {
+      super(call, throwable);
+      this.throwable = throwable;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new RequestHeadersStart(call);
+    }
+  }
+
+  static final class RequestBodyStart extends CallEvent {
+    RequestBodyStart(Call call) {
+      super(call);
+    }
+  }
+
+  static final class RequestBodyEnd extends CallEvent {
+    final Throwable throwable;
+
+    RequestBodyEnd(Call call, Throwable throwable) {
+      super(call, throwable);
+      this.throwable = throwable;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new RequestBodyStart(call);
+    }
+  }
+
+  static final class ResponseHeadersStart extends CallEvent {
+    ResponseHeadersStart(Call call) {
+      super(call);
+    }
+  }
+
+  static final class ResponseHeadersEnd extends CallEvent {
+    final Throwable throwable;
+
+    ResponseHeadersEnd(Call call, Throwable throwable) {
+      super(call, throwable);
+      this.throwable = throwable;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new RequestHeadersStart(call);
+    }
+  }
+
+  static final class ResponseBodyStart extends CallEvent {
+    ResponseBodyStart(Call call) {
+      super(call);
+    }
+  }
+
+  static final class ResponseBodyEnd extends CallEvent {
+    final Throwable throwable;
+
+    ResponseBodyEnd(Call call, Throwable throwable) {
+      super(call, throwable);
+      this.throwable = throwable;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new ResponseBodyStart(call);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/EventListener.java b/okhttp/src/main/java/okhttp3/EventListener.java
index 38d2b7b989..f4d8940f9a 100644
--- a/okhttp/src/main/java/okhttp3/EventListener.java
+++ b/okhttp/src/main/java/okhttp3/EventListener.java
@@ -127,7 +127,8 @@ public void secureConnectEnd(Call call, @Nullable Handshake handshake,
    * the case of a failed connection attempt.
    */
   public void connectEnd(Call call, InetSocketAddress inetSocketAddress,
-      Proxy proxy, @Nullable Protocol protocol, @Nullable Throwable throwable) {
+      @Nullable Proxy proxy, @Nullable Protocol protocol,
+      @Nullable Throwable throwable) {
   }
 
   /**
diff --git a/okhttp/src/main/java/okhttp3/RealCall.java b/okhttp/src/main/java/okhttp3/RealCall.java
index 6fa2c9a46a..89998a5b32 100644
--- a/okhttp/src/main/java/okhttp3/RealCall.java
+++ b/okhttp/src/main/java/okhttp3/RealCall.java
@@ -71,11 +71,16 @@ static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolea
       executed = true;
     }
     captureCallStackTrace();
+    eventListener.fetchStart(this);
     try {
       client.dispatcher().executed(this);
       Response result = getResponseWithInterceptorChain();
       if (result == null) throw new IOException("Canceled");
+      eventListener.fetchEnd(this, null);
       return result;
+    } catch (IOException e) {
+      eventListener.fetchEnd(this, e);
+      throw e;
     } finally {
       client.dispatcher().finished(this);
     }
@@ -92,6 +97,7 @@ private void captureCallStackTrace() {
       executed = true;
     }
     captureCallStackTrace();
+    eventListener.fetchStart(this);
     client.dispatcher().enqueue(new AsyncCall(responseCallback));
   }
 
@@ -147,11 +153,13 @@ RealCall get() {
           signalledCallback = true;
           responseCallback.onResponse(RealCall.this, response);
         }
+        eventListener.fetchEnd(RealCall.this, null);
       } catch (IOException e) {
         if (signalledCallback) {
           // Do not signal the callback twice!
           Platform.get().log(INFO, "Callback failure for " + toLoggableString(), e);
         } else {
+          eventListener.fetchEnd(RealCall.this, e);
           responseCallback.onFailure(RealCall.this, e);
         }
       } finally {
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
index c9bb6f9dd3..2e0458a8cf 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
@@ -267,11 +267,11 @@ private void establishProtocol(ConnectionSpecSelector connectionSpecSelector, Ca
     eventListener.secureConnectStart(call);
     try {
       connectTls(connectionSpecSelector);
+      eventListener.secureConnectEnd(call, handshake, null);
     } catch (Exception e) {
       eventListener.secureConnectEnd(call, null, e);
       throw e;
     }
-    eventListener.secureConnectEnd(call, handshake, null);
 
     if (protocol == Protocol.HTTP_2) {
       socket.setSoTimeout(0); // HTTP/2 connection timeouts are set per-stream.
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
index 656a69de12..cb7b77c5d9 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
@@ -78,8 +78,8 @@
   private RouteSelector.Selection routeSelection;
   private Route route;
   private final ConnectionPool connectionPool;
-  private final Call call;
-  private final EventListener eventListener;
+  public final Call call;
+  public final EventListener eventListener;
   private final Object callStackTrace;
 
   // State guarded by connectionPool.
@@ -301,6 +301,9 @@ private Socket deallocate(boolean noNewStreams, boolean released, boolean stream
       this.codec = null;
     }
     if (released) {
+      if (connection != null) {
+        eventListener.connectionReleased(call, connection);
+      }
       this.released = true;
     }
     Socket socket = null;
diff --git a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
index 3bc47183eb..65fd234e24 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
@@ -43,36 +43,61 @@ public CallServerInterceptor(boolean forWebSocket) {
     Request request = realChain.request();
 
     long sentRequestMillis = System.currentTimeMillis();
-    httpCodec.writeRequestHeaders(request);
+
+    realChain.eventListener().requestHeadersStart(realChain.call());
+    try {
+      httpCodec.writeRequestHeaders(request);
+      realChain.eventListener().requestHeadersEnd(realChain.call(), null);
+    } catch (IOException ioe) {
+      realChain.eventListener().requestHeadersEnd(realChain.call(), ioe);
+      throw ioe;
+    }
 
     Response.Builder responseBuilder = null;
     if (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {
-      // If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100
-      // Continue" response before transmitting the request body. If we don't get that, return what
-      // we did get (such as a 4xx response) without ever transmitting the request body.
-      if ("100-continue".equalsIgnoreCase(request.header("Expect"))) {
-        httpCodec.flushRequest();
-        responseBuilder = httpCodec.readResponseHeaders(true);
-      }
+      realChain.eventListener().requestBodyStart(realChain.call());
+      try {
+        // If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100
+        // Continue" response before transmitting the request body. If we don't get that, return
+        // what we did get (such as a 4xx response) without ever transmitting the request body.
+        if ("100-continue".equalsIgnoreCase(request.header("Expect"))) {
+          httpCodec.flushRequest();
+          // TODO event listener
+          responseBuilder = httpCodec.readResponseHeaders(true);
+        }
 
-      if (responseBuilder == null) {
-        // Write the request body if the "Expect: 100-continue" expectation was met.
-        Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());
-        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
-        request.body().writeTo(bufferedRequestBody);
-        bufferedRequestBody.close();
-      } else if (!connection.isMultiplexed()) {
-        // If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection from
-        // being reused. Otherwise we're still obligated to transmit the request body to leave the
-        // connection in a consistent state.
-        streamAllocation.noNewStreams();
+        if (responseBuilder == null) {
+          // Write the request body if the "Expect: 100-continue" expectation was met.
+          Sink requestBodyOut =
+              httpCodec.createRequestBody(request, request.body().contentLength());
+          BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
+
+          request.body().writeTo(bufferedRequestBody);
+          bufferedRequestBody.close();
+        } else if (!connection.isMultiplexed()) {
+          // If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection
+          // from being reused. Otherwise we're still obligated to transmit the request body to
+          // leave the connection in a consistent state.
+          streamAllocation.noNewStreams();
+        }
+        realChain.eventListener().requestBodyEnd(realChain.call(), null);
+      } catch (IOException ioe) {
+        realChain.eventListener().requestBodyEnd(realChain.call(), ioe);
+        throw ioe;
       }
     }
 
     httpCodec.finishRequest();
 
     if (responseBuilder == null) {
-      responseBuilder = httpCodec.readResponseHeaders(false);
+      realChain.eventListener().responseHeadersStart(realChain.call());
+      try {
+        responseBuilder = httpCodec.readResponseHeaders(false);
+        realChain.eventListener().responseHeadersEnd(realChain.call(), null);
+      } catch (IOException ioe) {
+        realChain.eventListener().responseHeadersEnd(realChain.call(), ioe);
+        throw ioe;
+      }
     }
 
     Response response = responseBuilder
diff --git a/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
index 4be3a32ccc..1421099db0 100644
--- a/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
@@ -36,6 +36,7 @@
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
+import okio.ForwardingSource;
 import okio.ForwardingTimeout;
 import okio.Okio;
 import okio.Sink;
@@ -129,10 +130,36 @@ public Http1Codec(OkHttpClient client, StreamAllocation streamAllocation, Buffer
   }
 
   @Override public ResponseBody openResponseBody(Response response) throws IOException {
-    Source source = getTransferStream(response);
+    streamAllocation.eventListener.responseBodyStart(streamAllocation.call);
+    Source source = new EventListenerSource(getTransferStream(response));
     return new RealResponseBody(response.headers(), Okio.buffer(source));
   }
 
+  class EventListenerSource extends ForwardingSource {
+    private boolean completed = false;
+
+    EventListenerSource(Source delegate) {
+      super(delegate);
+    }
+
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
+      try {
+        return super.read(sink, byteCount);
+      } catch (IOException ioe) {
+        completed = true;
+        streamAllocation.eventListener.responseBodyEnd(streamAllocation.call, ioe);
+        throw ioe;
+      }
+    }
+
+    @Override public void close() throws IOException {
+      if (!completed) {
+        streamAllocation.eventListener.responseBodyEnd(streamAllocation.call, null);
+      }
+      super.close();
+    }
+  }
+
   private Source getTransferStream(Response response) throws IOException {
     if (!HttpHeaders.hasBody(response)) {
       return newFixedLengthSource(0);
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
index c13c1afec5..5267584990 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
@@ -35,6 +35,7 @@
 import okhttp3.internal.http.RealResponseBody;
 import okhttp3.internal.http.RequestLine;
 import okhttp3.internal.http.StatusLine;
+import okio.Buffer;
 import okio.ByteString;
 import okio.ForwardingSource;
 import okio.Okio;
@@ -184,6 +185,7 @@ public Http2Codec(OkHttpClient client, Interceptor.Chain chain, StreamAllocation
   }
 
   @Override public ResponseBody openResponseBody(Response response) throws IOException {
+    streamAllocation.eventListener.responseBodyStart(streamAllocation.call);
     Source source = new StreamFinishingSource(stream.getSource());
     return new RealResponseBody(response.headers(), Okio.buffer(source));
   }
@@ -193,11 +195,26 @@ public Http2Codec(OkHttpClient client, Interceptor.Chain chain, StreamAllocation
   }
 
   class StreamFinishingSource extends ForwardingSource {
+    private boolean completed = false;
+
     StreamFinishingSource(Source delegate) {
       super(delegate);
     }
 
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
+      try {
+        return super.read(sink, byteCount);
+      } catch (IOException ioe) {
+        completed = true;
+        streamAllocation.eventListener.responseBodyEnd(streamAllocation.call, ioe);
+        throw ioe;
+      }
+    }
+
     @Override public void close() throws IOException {
+      if (!completed) {
+        streamAllocation.eventListener.responseBodyEnd(streamAllocation.call, null);
+      }
       streamAllocation.streamFinished(false, Http2Codec.this);
       super.close();
     }
