diff --git a/okhttp/src/main/java/okhttp3/RealCall.java b/okhttp/src/main/java/okhttp3/RealCall.java
index 58285e6c86..b129a92bcd 100644
--- a/okhttp/src/main/java/okhttp3/RealCall.java
+++ b/okhttp/src/main/java/okhttp3/RealCall.java
@@ -215,6 +215,11 @@ String redactedUrl() {
    *  CallServerInterceptor
    *
    *  Response返回(向上)
+   *
+   *  -------
+   *  开发这自定义的interceptor和networkInterceptor
+   *  普通interceptor：对发出去的请求做最初的处理，对最终得到的响应做处理
+   *  networkInterceptor：对发出去的请求做最后的处理，对收到的响应做最初的处理
    */
   Response getResponseWithInterceptorChain() throws IOException {
     // Build a full stack of interceptors.
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
index f5eca7d75a..42e32f864b 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
@@ -41,7 +41,12 @@
 import static okhttp3.internal.Util.closeQuietly;
 import static okhttp3.internal.Util.discard;
 
-/** Serves requests from the cache and writes responses to the cache. */
+/**
+ * HTTP 协议中的缓存机制，其主要功能如下：
+ * 从缓存中读取缓存，并创建缓存策略对象
+ * 根据创建的缓存策略对象，从缓存、网络获取响应并生成最终的响应对象
+ * 更新缓存内容，并返回响应对象
+ */
 public final class CacheInterceptor implements Interceptor {
   final InternalCache cache;
 
@@ -49,13 +54,21 @@ public CacheInterceptor(InternalCache cache) {
     this.cache = cache;
   }
 
-  @Override public Response intercept(Chain chain) throws IOException {
+  /**
+   *
+   * @param chain
+   * @return
+   * @throws IOException
+   */
+  @Override
+  public Response intercept(Chain chain) throws IOException {
     Response cacheCandidate = cache != null
-        ? cache.get(chain.request())////通过request得到缓存
+        ? cache.get(chain.request())////通过request得到候选缓存
         : null;
 
     long now = System.currentTimeMillis();
 
+    // 创建缓存策略对象，并从中得到请求和响应
     CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();
     Request networkRequest = strategy.networkRequest;
     Response cacheResponse = strategy.cacheResponse;
@@ -68,7 +81,7 @@ public CacheInterceptor(InternalCache cache) {
       closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.
     }
 
-    // 如果我们禁止使用网络，且缓存为null，失败
+    // 如果没有网络，且缓存为null，创建504的错误码 并返回
     if (networkRequest == null && cacheResponse == null) {
       return new Response.Builder()
           .request(chain.request())
@@ -81,7 +94,7 @@ public CacheInterceptor(InternalCache cache) {
           .build();
     }
 
-    //没有网络请求，跳过网络，返回缓存
+    //没有网络请求 且 有缓存，跳过网络，返回缓存
     if (networkRequest == null) {
       return cacheResponse.newBuilder()
           .cacheResponse(stripBody(cacheResponse))
@@ -90,15 +103,24 @@ public CacheInterceptor(InternalCache cache) {
 
     Response networkResponse = null;
     try {
+      //前面的条件都不满足,则发送给  ConnectInterceptor 进行网络处理
       networkResponse = chain.proceed(networkRequest);
     } finally {
-      //如果我们因为I/O或其他原因崩溃，不要泄漏缓存体
+      //如果在Connectinterceptor中发送了错误导致了 响应 为空，则释放掉缓存
       if (networkResponse == null && cacheCandidate != null) {
         closeQuietly(cacheCandidate.body());
       }
     }
 
-    //如果我们有一个缓存的response，然后我们正在做一个条件GET
+    /**
+     * 304 表示资源没有更改过。
+     * HttpEngine的invalidate()方法用于判断是采用缓存还是网络的Response
+     * 如果netWork.code = 304，则直接使用缓存数据。
+     * 如果netWork.code != 304, 会继续去判断缓存和网络的Last-Modified。
+     * 缓存的最后修改时间更大，就采用缓存。
+     * 网络的最后修改时间更大，就采用网络数据。
+     */
+    // 如果得到的缓存响应不是空的，并且网络响应的状态码为 304，则根据缓存响应结果生成最终的响应并返回
     if (cacheResponse != null) {
       if (networkResponse.code() == HTTP_NOT_MODIFIED) {
         Response response = cacheResponse.newBuilder()
@@ -112,7 +134,7 @@ public CacheInterceptor(InternalCache cache) {
 
         // Update the cache after combining headers but before stripping the
         // Content-Encoding header (as performed by initContentStream()).
-        //更新缓存，在剥离content-Encoding之前
+        //更新缓存中的response
         cache.trackConditionalCacheHit();
         cache.update(cacheResponse, response);
         return response;
@@ -121,11 +143,13 @@ public CacheInterceptor(InternalCache cache) {
       }
     }
 
+    // 根据网络请求响应生成最终的响应
     Response response = networkResponse.newBuilder()
         .cacheResponse(stripBody(cacheResponse))
         .networkResponse(stripBody(networkResponse))
         .build();
 
+    // 如果缓存对象不为空，则将响应加入到缓存中
     if (cache != null) {
       if (HttpHeaders.hasBody(response) && CacheStrategy.isCacheable(response, networkRequest)) {
         // Offer this request to the cache.
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java b/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java
index b33e62afc9..d60033f2cd 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java
@@ -24,7 +24,14 @@
 import okhttp3.internal.http.HttpCodec;
 import okhttp3.internal.http.RealInterceptorChain;
 
-/** Opens a connection to the target server and proceeds to the next interceptor. */
+/**
+ * 主要功能是：
+ * 得到从 RetryAndFollowUpInterceptor 中创建的 StreamAllocation 对象
+ * 通过 StreamAllocation 对象创建 HttpCodec 对象
+ * 通过 StreamAllocation 对象创建 RealConnection 对象
+ * 最终通过 RealInterceptorChain 的 proceed(Request request, StreamAllocation streamAllocation, HttpCodec
+ * httpCodec,RealConnection connection) 方法得到响应对象并返回。
+ */
 public final class ConnectInterceptor implements Interceptor {
   public final OkHttpClient client;
 
@@ -32,7 +39,8 @@ public ConnectInterceptor(OkHttpClient client) {
     this.client = client;
   }
 
-  @Override public Response intercept(Chain chain) throws IOException {
+  @Override
+  public Response intercept(Chain chain) throws IOException {
     RealInterceptorChain realChain = (RealInterceptorChain) chain;
     Request request = realChain.request();
     StreamAllocation streamAllocation = realChain.streamAllocation();
@@ -40,7 +48,7 @@ public ConnectInterceptor(OkHttpClient client) {
     // We need the network to satisfy this request. Possibly for validating a conditional GET.
     boolean doExtensiveHealthChecks = !request.method().equals("GET");
     /**
-     * 际上建立连接就是创建了一个HttpCodec对象，它将在后面的步骤中被使用，
+     * 实际上建立连接就是创建了一个HttpCodec对象，它将在后面的步骤中被使用，
      * 它是对 HTTP 协议操作的抽象，有两个实现：Http1Codec和Http2Codec，
      * 它们分别对应 HTTP/1.1 和 HTTP/2 版本的实现
      */
diff --git a/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
index 4bb5a7ae95..34e3140c77 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
@@ -18,6 +18,7 @@
 
 import java.io.IOException;
 import java.util.List;
+
 import okhttp3.Cookie;
 import okhttp3.CookieJar;
 import okhttp3.Headers;
@@ -37,7 +38,11 @@
  * request. Then it proceeds to call the network. Finally it builds a user response from the network
  * response.
  *
- * 负责把用户构造的请求转换为发送到服务器的请求、把服务器返回的响应转换为用户友好的响应的
+ * 负责把用户构造的请求转换为发送到服务器的请求、把服务器返回的响应转换为用户友好的响应的；
+ *
+ * 设置一些请求和响应首部，如：Content-Type、Content-Length、Host 等常见的请求和响应首部。
+ * 处理 HTTP 请求和响应中的 Cookie
+ * 如果在请求中设置了编码，要从响应流中解码
  */
 public final class BridgeInterceptor implements Interceptor {
   private final CookieJar cookieJar;
@@ -51,14 +56,14 @@ public BridgeInterceptor(CookieJar cookieJar) {
     Request.Builder requestBuilder = userRequest.newBuilder();
     //检查request。将用户的request转换为发送到server的请求
     RequestBody body = userRequest.body();
-    if (body != null) {
+    if (body != null) { // 在请求中设置实体首部 Content-Type
       MediaType contentType = body.contentType();
       if (contentType != null) {
         requestBuilder.header("Content-Type", contentType.toString());
       }
 
       long contentLength = body.contentLength();
-      if (contentLength != -1) {
+      if (contentLength != -1) {// 在请求中设置实体首部 Content-Length 和 Transfer-Encoding
         requestBuilder.header("Content-Length", Long.toString(contentLength));
         requestBuilder.removeHeader("Transfer-Encoding");
       } else {
@@ -75,14 +80,14 @@ public BridgeInterceptor(CookieJar cookieJar) {
       requestBuilder.header("Connection", "Keep-Alive");
     }
 
-    // If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing
-    // the transfer stream.
+    // 设置Accept-Encoding
     boolean transparentGzip = false;
     if (userRequest.header("Accept-Encoding") == null && userRequest.header("Range") == null) {
       transparentGzip = true;
       requestBuilder.header("Accept-Encoding", "gzip");
     }
 
+    //从响应这个拿到cookie
     List<Cookie> cookies = cookieJar.loadForRequest(userRequest.url());
     if (!cookies.isEmpty()) {
       requestBuilder.header("Cookie", cookieHeader(cookies));
@@ -99,6 +104,7 @@ public BridgeInterceptor(CookieJar cookieJar) {
     Response.Builder responseBuilder = networkResponse.newBuilder()
         .request(userRequest);
 
+    // 如果之前在请求中设置了 "Accept-Encoding: gzip" 编码，则需要对响应流进行解码操作并移除响应中的首部字段 “Content-Encoding” 和 “Content-Length”
     if (transparentGzip
         && "gzip".equalsIgnoreCase(networkResponse.header("Content-Encoding"))
         && HttpHeaders.hasBody(networkResponse)) {
diff --git a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
index abdd69aed6..9b56760417 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
@@ -29,7 +29,11 @@
 import okio.Okio;
 import okio.Sink;
 
-/** This is the last interceptor in the chain. It makes a network call to the server. */
+/**
+ * 主要的功能就是：
+ * 遵循 HTTP 协议规范，通过 HttpCodec 对象写入请求头、请求主体、读取响应头和响应主体
+ * 生成最初的响应对象并返回
+ */
 public final class CallServerInterceptor implements Interceptor {
   private final boolean forWebSocket;
 
@@ -43,7 +47,8 @@ public CallServerInterceptor(boolean forWebSocket) {
    * @return 执行完成后 并没有调用RealIntercept的intercept方法，而是逆向返回response对象
    * @throws IOException
    */
-  @Override public Response intercept(Chain chain) throws IOException {
+  @Override
+  public Response intercept(Chain chain) throws IOException {
     RealInterceptorChain realChain = (RealInterceptorChain) chain;
     //Okhttp1Codec okhttp2Codec实现了它，对应这个http1 http2.x的请求
     HttpCodec httpCodec = realChain.httpStream();//codec内部的请求 都依赖于okio(对Socket的封装 )
@@ -52,16 +57,18 @@ public CallServerInterceptor(boolean forWebSocket) {
     Request request = realChain.request();
 
     long sentRequestMillis = System.currentTimeMillis();
-
+    // 向 HttpCodec 对象中写入请求头部信息
     realChain.eventListener().requestHeadersStart(realChain.call());
     httpCodec.writeRequestHeaders(request);
     realChain.eventListener().requestHeadersEnd(realChain.call(), request);
 
     Response.Builder responseBuilder = null;
+    // 判断该请求的请求方法是否允许被发送请求体，请求体是否为空
     if (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {
       // If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100
       // Continue" response before transmitting the request body. If we don't get that, return
       // what we did get (such as a 4xx response) without ever transmitting the request body.
+      // 若在请求头部中存在 ”Expect: 100-continue“，先不发送请求主体，只有收到 ”100-continue“ 响应报文才会将请求主体发送出去。
       if ("100-continue".equalsIgnoreCase(request.header("Expect"))) {
         httpCodec.flushRequest();
         realChain.eventListener().responseHeadersStart(realChain.call());
@@ -69,9 +76,10 @@ public CallServerInterceptor(boolean forWebSocket) {
       }
 
       if (responseBuilder == null) {
-        // Write the request body if the "Expect: 100-continue" expectation was met.
+        // 如果满足了“Expect: 100-continue”，编写请求主体。
         realChain.eventListener().requestBodyStart(realChain.call());
         long contentLength = request.body().contentLength();
+
         CountingSink requestBodyOut =
             new CountingSink(httpCodec.createRequestBody(request, contentLength));
         BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
@@ -95,14 +103,20 @@ public CallServerInterceptor(boolean forWebSocket) {
       responseBuilder = httpCodec.readResponseHeaders(false);
     }
 
+    // 创建请求响应对象
     Response response = responseBuilder
         .request(request)
         .handshake(streamAllocation.connection().handshake())
         .sentRequestAtMillis(sentRequestMillis)
         .receivedResponseAtMillis(System.currentTimeMillis())
         .build();
-
+    //获取响应码，后续根据响应码做一些处理
     int code = response.code();
+    /**
+     * 100 Continue
+     * 客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。
+     * 客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。
+     */
     if (code == 100) {
       // server sent a 100-continue even though we did not request one.
       // try again to read the actual response
@@ -115,28 +129,33 @@ public CallServerInterceptor(boolean forWebSocket) {
               .receivedResponseAtMillis(System.currentTimeMillis())
               .build();
 
-      code = response.code();
+      code = response.code();//处理完100，重新获取一次code
     }
 
     realChain.eventListener()
             .responseHeadersEnd(realChain.call(), response);
-
+    // 判断是否返回一个空的响应
     if (forWebSocket && code == 101) {
       // Connection is upgrading, but we need to ensure interceptors see a non-null response body.
       response = response.newBuilder()
           .body(Util.EMPTY_RESPONSE)
           .build();
-    } else {
+    } else {// 读取响应中的响应体信息
       response = response.newBuilder()
           .body(httpCodec.openResponseBody(response))
           .build();
     }
-
+    // 判断是否关闭长连接
     if ("close".equalsIgnoreCase(response.request().header("Connection"))
         || "close".equalsIgnoreCase(response.header("Connection"))) {
       streamAllocation.noNewStreams();
     }
 
+    /**
+     * 204 和 205
+     * 服务器处理了请求 但是没有返回任何信息
+     */
+    // 如果响应的状态码为 204 和 205 并且响应体不为空，则抛出异常
     if ((code == 204 || code == 205) && response.body().contentLength() > 0) {
       throw new ProtocolException(
           "HTTP " + code + " had non-zero Content-Length: " + response.body().contentLength());
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java b/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java
index 3f9e4f35f5..0558cbf324 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java
@@ -16,6 +16,7 @@
 package okhttp3.internal.http;
 
 import java.io.IOException;
+
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.ResponseBody;
@@ -39,7 +40,9 @@
   /** Flush the request to the underlying socket. */
   void flushRequest() throws IOException;
 
-  /** Flush the request to the underlying socket and signal no more bytes will be transmitted. */
+  /** Flush the request to the underlying socket and signal no more bytes will be transmitted.
+   * 将请求刷新到基础套接字，不再发送任何字节。
+   * */
   void finishRequest() throws IOException;
 
   /**
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
index 43d2069a7b..a7c7e56586 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
@@ -57,6 +57,11 @@
  * This interceptor recovers from failures and follows redirects as necessary. It may throw an
  * {@link IOException} if the call was canceled.
  */
+
+
+/**
+ * 主要负责实现 HTTP 协议中的认证质询、重定向和超时重试等协议机制。
+ */
 public final class RetryAndFollowUpInterceptor implements Interceptor {
   /**
    * How many redirects and auth challenges should we attempt? Chrome follows 21 redirects; Firefox,
@@ -114,6 +119,7 @@ public StreamAllocation streamAllocation() {
 
     int followUpCount = 0;
     Response priorResponse = null;
+    //启动一个while死循环，判断是否已经取消，若已取消 则抛io异常
     while (true) {
       if (canceled) {
         streamAllocation.release();
@@ -127,27 +133,28 @@ public StreamAllocation streamAllocation() {
         response = realChain.proceed(request, streamAllocation, null, null);
         releaseConnection = false;
       } catch (RouteException e) {
-        // The attempt to connect via a route failed. The request will not have been sent.
+        // 如果进入 RouteException 路由异常，则尝试是否可以重新进行请求，若可以则从头开始新的请求
+        if (!recover(e.getLastConnectException(), false, request)) {
         if (!recover(e.getLastConnectException(), streamAllocation, false, request)) {
           throw e.getFirstConnectException();
         }
         releaseConnection = false;
         continue;
       } catch (IOException e) {
-        // An attempt to communicate with a server failed. The request may have been sent.
+          // 若是进入 IOException IO异常，若可以重新尝试请求，则从头开始新的请求
         boolean requestSendStarted = !(e instanceof ConnectionShutdownException);
         if (!recover(e, streamAllocation, requestSendStarted, request)) throw e;
         releaseConnection = false;
         continue;
       } finally {
-        // We're throwing an unchecked exception. Release any resources.
+        // 调用下一个拦截器时 没有抛出异常  释放资源
         if (releaseConnection) {
           streamAllocation.streamFailed(null);
           streamAllocation.release();
         }
       }
 
-      // Attach the prior response if it exists. Such responses never have a body.
+      // 如果之前发生过重定向，并且 priorResponse 不为空，则创建新的 响应对象，并将其 body 置位空
       if (priorResponse != null) {
         response = response.newBuilder()
             .priorResponse(priorResponse.newBuilder()
@@ -158,13 +165,15 @@ public StreamAllocation streamAllocation() {
 
       Request followUp;
       try {
-        //判断状态码
+        // 添加认证需要的头部，处理重定向或超时重试，得到新的请求
+        // followUpRequest() 方法涉及到 HTTP 中认证质询、重定向和重试等协议的实现
         followUp = followUpRequest(response, streamAllocation.route());
       } catch (IOException e) {
         streamAllocation.release();
         throw e;
       }
 
+        // 若 followUp 重试请求为空，则当前请求结束，并返回当前的响应
       if (followUp == null) {
         if (!forWebSocket) {
           streamAllocation.release();
@@ -173,7 +182,7 @@ public StreamAllocation streamAllocation() {
       }
 
       closeQuietly(response.body());
-
+      // 若重定向、认证质询、重试次数超过 MAX_FOLLOW_UPS，则抛出 ProtocolException 异常
       if (++followUpCount > MAX_FOLLOW_UPS) {
         streamAllocation.release();
         throw new ProtocolException("Too many follow-up requests: " + followUpCount);
@@ -183,7 +192,7 @@ public StreamAllocation streamAllocation() {
         streamAllocation.release();
         throw new HttpRetryException("Cannot retry streamed HTTP body", response.code());
       }
-
+      // 判断是否是相同的连接，若不相同则释放 streamAllocation，并重新创建新的 streamAllocation 对象
       if (!sameConnection(response, followUp.url())) {
         streamAllocation.release();
         streamAllocation = new StreamAllocation(client.connectionPool(),
@@ -408,8 +417,7 @@ private int retryAfter(Response userResponse, int defaultDelay) {
   }
 
   /**
-   * Returns true if an HTTP request for {@code followUp} can reuse the connection used by this
-   * engine.
+   * 如果HTTP请求{@code followUp}可以重用此引擎使用的连接，则返回true。
    */
   private boolean sameConnection(Response response, HttpUrl followUp) {
     HttpUrl url = response.request().url();
