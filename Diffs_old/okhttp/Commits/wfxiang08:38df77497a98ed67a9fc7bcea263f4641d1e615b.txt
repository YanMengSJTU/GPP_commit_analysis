diff --git a/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/RealWebSocketTest.java b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/RealWebSocketTest.java
index 2ac84d6f9e..a70435fbfd 100644
--- a/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/RealWebSocketTest.java
+++ b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/RealWebSocketTest.java
@@ -18,16 +18,19 @@
 import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.ws.WebSocketRecorder;
+import java.io.Closeable;
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.util.Random;
-import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Executor;
-import java.util.concurrent.Executors;
-import java.util.concurrent.TimeUnit;
 import okio.Buffer;
 import okio.BufferedSink;
+import okio.BufferedSource;
 import okio.ByteString;
+import okio.Okio;
+import okio.Sink;
+import okio.Source;
+import okio.Timeout;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -36,6 +39,8 @@
 import static com.squareup.okhttp.ws.WebSocket.TEXT;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -44,34 +49,43 @@
   // zero effect on the behavior of the WebSocket API which is why tests are only written once
   // from the perspective of a single peer.
 
-  private final Executor clientExecutor = Executors.newSingleThreadExecutor();
+  private final Executor clientExecutor = new SynchronousExecutor();
   private RealWebSocket client;
   private boolean clientConnectionCloseThrows;
   private boolean clientConnectionClosed;
-  private final Buffer client2Server = new Buffer();
+  private final MemorySocket client2Server = new MemorySocket();
   private final WebSocketRecorder clientListener = new WebSocketRecorder();
 
-  private final Executor serverExecutor = Executors.newSingleThreadExecutor();
+  private final Executor serverExecutor = new SynchronousExecutor();
   private RealWebSocket server;
-  private final Buffer server2client = new Buffer();
+  private boolean serverConnectionClosed;
+  private final MemorySocket server2client = new MemorySocket();
   private final WebSocketRecorder serverListener = new WebSocketRecorder();
 
   @Before public void setUp() {
     Random random = new Random(0);
     String url = "http://example.com/websocket";
 
-    client = new RealWebSocket(true, server2client, client2Server, random, clientExecutor,
-        clientListener, url) {
+    client = new RealWebSocket(true, server2client.source(), client2Server.sink(), random,
+        clientExecutor, clientListener, url) {
       @Override protected void close() throws IOException {
+        if (clientConnectionClosed) {
+          throw new AssertionError("Already closed");
+        }
         clientConnectionClosed = true;
+
         if (clientConnectionCloseThrows) {
           throw new IOException("Oops!");
         }
       }
     };
-    server = new RealWebSocket(false, client2Server, server2client, random, serverExecutor,
-        serverListener, url) {
+    server = new RealWebSocket(false, client2Server.source(), server2client.sink(), random,
+        serverExecutor, serverListener, url) {
       @Override protected void close() throws IOException {
+        if (serverConnectionClosed) {
+          throw new AssertionError("Already closed");
+        }
+        serverConnectionClosed = true;
       }
     };
   }
@@ -157,7 +171,6 @@
     client.sendMessage(message);
     server.readMessage();
     serverListener.assertTextMessage("Hello!");
-    waitForExecutor(serverExecutor); // Pong write happens asynchronously.
     client.readMessage();
     clientListener.assertPong(new Buffer().writeUtf8("Pong?"));
   }
@@ -165,7 +178,6 @@
   @Test public void pingWritesPong() throws IOException, InterruptedException {
     client.sendPing(new Buffer().writeUtf8("Hello!"));
     server.readMessage(); // Read the ping, write the pong.
-    waitForExecutor(serverExecutor); // Pong write happens asynchronously.
     client.readMessage(); // Read the pong.
     clientListener.assertPong(new Buffer().writeUtf8("Hello!"));
   }
@@ -207,7 +219,92 @@
     }
   }
 
-  @Test public void serverCloseThenWritingThrows() throws IOException {
+  @Test public void clientWritingThrowsSendsClientClose() throws IOException {
+    final IOException brokenException = new IOException("Broken!");
+    RequestBody brokenBody = new RequestBody() {
+      @Override public MediaType contentType() {
+        return TEXT;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        throw brokenException;
+      }
+    };
+
+    try {
+      client.sendMessage(brokenBody);
+      fail();
+    } catch (IOException e) {
+      assertSame(brokenException, e);
+    }
+
+    // A failed write prevents further use of the WebSocket instance.
+    try {
+      client.sendPing(new Buffer().writeUtf8("Ping!"));
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals("closed", e.getMessage());
+    }
+
+    server.readMessage();
+    serverListener.assertClose(1001, "");
+  }
+
+  @Test public void socketClosedDuringPingKillsWebSocket() throws IOException {
+    client2Server.close();
+
+    try {
+      client.sendPing(new Buffer().writeUtf8("Ping!"));
+      fail();
+    } catch (IOException ignored) {
+    }
+
+    // A failed write prevents further use of the WebSocket instance.
+    try {
+      client.sendPing(new Buffer().writeUtf8("Ping!"));
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals("closed", e.getMessage());
+    }
+  }
+
+  @Test public void socketClosedDuringMessageKillsWebSocket() throws IOException {
+    client2Server.close();
+
+    try {
+      client.sendMessage(RequestBody.create(TEXT, "Hello!"));
+      fail();
+    } catch (IOException ignored) {
+    }
+
+    // A failed write prevents further use of the WebSocket instance.
+    try {
+      client.sendPing(new Buffer().writeUtf8("Ping!"));
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals("closed", e.getMessage());
+    }
+  }
+
+  @Test public void socketClosedDuringCloseKillsWebSocket() throws IOException {
+    client2Server.close();
+
+    try {
+      client.close(1000, "I'm done.");
+      fail();
+    } catch (IOException ignored) {
+    }
+
+    // A failed write prevents further use of the WebSocket instance.
+    try {
+      client.sendPing(new Buffer().writeUtf8("Ping!"));
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals("closed", e.getMessage());
+    }
+  }
+
+  @Test public void serverCloseThenWritingPingThrows() throws IOException {
     server.close(1000, "Hello!");
     client.readMessage();
     clientListener.assertClose(1000, "Hello!");
@@ -218,12 +315,26 @@
     } catch (IOException e) {
       assertEquals("closed", e.getMessage());
     }
+  }
+
+  @Test public void serverCloseThenWritingMessageThrows() throws IOException {
+    server.close(1000, "Hello!");
+    client.readMessage();
+    clientListener.assertClose(1000, "Hello!");
+
     try {
       client.sendMessage(RequestBody.create(TEXT, "Hi!"));
       fail();
     } catch (IOException e) {
       assertEquals("closed", e.getMessage());
     }
+  }
+
+  @Test public void serverCloseThenWritingCloseThrows() throws IOException {
+    server.close(1000, "Hello!");
+    client.readMessage();
+    clientListener.assertClose(1000, "Hello!");
+
     try {
       client.close(1000, "Bye!");
       fail();
@@ -269,8 +380,7 @@
     server.readMessage(); // Read client close, send server close.
     serverListener.assertClose(1000, "Hello!");
 
-    client.readMessage(); // Read server close.
-    waitForExecutor(clientExecutor); // Close happens asynchronously.
+    client.readMessage(); // Read server close, close connection.
     assertTrue(clientConnectionClosed);
     clientListener.assertClose(1000, "Hello!");
   }
@@ -278,9 +388,9 @@
   @Test public void serverCloseClosesConnection() throws IOException {
     server.close(1000, "Hello!");
 
-    client.readMessage(); // Read server close, send client close, close connection.
-    clientListener.assertClose(1000, "Hello!");
+    client.readMessage(); // Read server close, sense client close, close connection.
     assertTrue(clientConnectionClosed);
+    clientListener.assertClose(1000, "Hello!");
 
     server.readMessage();
     serverListener.assertClose(1000, "Hello!");
@@ -292,8 +402,7 @@
     client.close(1000, "Hi!");
     assertFalse(clientConnectionClosed);
 
-    client.readMessage(); // Read close, should NOT send close.
-    waitForExecutor(clientExecutor); // Close happens asynchronously.
+    client.readMessage(); // Read close, close connection close.
     assertTrue(clientConnectionClosed);
     clientListener.assertClose(1000, "Hello!");
 
@@ -314,7 +423,7 @@
   }
 
   @Test public void protocolErrorBeforeCloseSendsClose() throws IOException {
-    server2client.write(ByteString.decodeHex("0a00")); // Invalid non-final ping frame.
+    server2client.raw().write(ByteString.decodeHex("0a00")); // Invalid non-final ping frame.
 
     client.readMessage(); // Detects error, send close, close connection.
     clientListener.assertFailure(ProtocolException.class, "Control frames must be final.");
@@ -327,7 +436,7 @@
   @Test public void protocolErrorAfterCloseDoesNotSendClose() throws IOException {
     client.close(1000, "Hello!");
     assertFalse(clientConnectionClosed); // Not closed until close reply is received.
-    server2client.write(ByteString.decodeHex("0a00")); // Invalid non-final ping frame.
+    server2client.raw().write(ByteString.decodeHex("0a00")); // Invalid non-final ping frame.
 
     client.readMessage(); // Detects error, closes connection immediately since close already sent.
     clientListener.assertFailure(ProtocolException.class, "Control frames must be final.");
@@ -337,31 +446,84 @@
     serverListener.assertClose(1000, "Hello!");
   }
 
+  @Test public void closeMessageAndConnectionCloseThrowingDoesNotMaskOriginal() throws IOException {
+    client2Server.close();
+    clientConnectionCloseThrows = true;
+
+    try {
+      client.close(1000, "Bye!");
+      fail();
+    } catch (IOException e) {
+      assertNotEquals("Oops!", e.getMessage());
+    }
+    assertTrue(clientConnectionClosed);
+  }
+
   @Test public void peerConnectionCloseThrowingDoesNotPropagate() throws IOException {
     clientConnectionCloseThrows = true;
 
     server.close(1000, "Bye!");
     client.readMessage();
-    clientListener.assertClose(1000, "Bye!");
     assertTrue(clientConnectionClosed);
+    clientListener.assertClose(1000, "Bye!");
 
     server.readMessage();
     serverListener.assertClose(1000, "Bye!");
   }
 
-  private static void waitForExecutor(Executor executor) {
-    final CountDownLatch latch = new CountDownLatch(1);
-    executor.execute(new Runnable() {
-      @Override public void run() {
-        latch.countDown();
-      }
-    });
-    try {
-      if (!latch.await(10, TimeUnit.SECONDS)) {
-        throw new IllegalStateException("Timed out waiting for executor.");
-      }
-    } catch (InterruptedException e) {
-      Thread.currentThread().interrupt();
+  static final class MemorySocket implements Closeable {
+    private final Buffer buffer = new Buffer();
+    private boolean closed;
+
+    @Override public void close() {
+      closed = true;
+    }
+
+    Buffer raw() {
+      return buffer;
+    }
+
+    BufferedSource source() {
+      return Okio.buffer(new Source() {
+        @Override public long read(Buffer sink, long byteCount) throws IOException {
+          if (closed) throw new IOException("closed");
+          return buffer.read(sink, byteCount);
+        }
+
+        @Override public Timeout timeout() {
+          return Timeout.NONE;
+        }
+
+        @Override public void close() throws IOException {
+          closed = true;
+        }
+      });
+    }
+
+    BufferedSink sink() {
+      return Okio.buffer(new Sink() {
+        @Override public void write(Buffer source, long byteCount) throws IOException {
+          if (closed) throw new IOException("closed");
+          buffer.write(source, byteCount);
+        }
+
+        @Override public void flush() throws IOException {
+        }
+
+        @Override public Timeout timeout() {
+          return Timeout.NONE;
+        }
+
+        @Override public void close() throws IOException {
+          closed = true;
+        }
+      });
+    }
+  }
+
+  static final class SynchronousExecutor implements Executor {
+    @Override public void execute(Runnable command) {
+      command.run();
     }
   }
 }
diff --git a/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/RealWebSocket.java b/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/RealWebSocket.java
index fdc90f3b9b..dd5e96c2d0 100644
--- a/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/RealWebSocket.java
+++ b/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/RealWebSocket.java
@@ -25,6 +25,7 @@
 import java.net.ProtocolException;
 import java.util.Random;
 import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicBoolean;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -35,7 +36,7 @@
 import static com.squareup.okhttp.internal.ws.WebSocketReader.FrameCallback;
 
 public abstract class RealWebSocket implements WebSocket {
-  /** A close code which indicates that the peer encountered a protocol exception. */
+  private static final int CLOSE_GOING_AWAY = 1001;
   private static final int CLOSE_PROTOCOL_EXCEPTION = 1002;
 
   private final WebSocketWriter writer;
@@ -45,9 +46,10 @@
   /** True after calling {@link #close(int, String)}. No writes are allowed afterward. */
   private volatile boolean writerSentClose;
   /** True after a close frame was read by the reader. No frames will follow it. */
-  private volatile boolean readerSentClose;
-  /** Lock required to negotiate closing the connection. */
-  private final Object closeLock = new Object();
+  private boolean readerSentClose;
+
+  /** True after calling {@link #close()} to free connection resources. */
+  private final AtomicBoolean connectionClosed = new AtomicBoolean();
 
   public RealWebSocket(boolean isClient, BufferedSource source, BufferedSink sink, Random random,
       final Executor replyExecutor, final WebSocketListener listener, final String url) {
@@ -75,17 +77,10 @@ public RealWebSocket(boolean isClient, BufferedSource source, BufferedSink sink,
       }
 
       @Override public void onClose(final int code, final String reason) {
-        final boolean writeCloseResponse;
-        synchronized (closeLock) {
-          readerSentClose = true;
-
-          // If the writer has not indicated a desire to close we will write a close response.
-          writeCloseResponse = !writerSentClose;
-        }
-
+        readerSentClose = true;
         replyExecutor.execute(new NamedRunnable("OkHttp %s WebSocket Close Reply", url) {
           @Override protected void execute() {
-            peerClose(code, reason, writeCloseResponse);
+            peerClose(code, reason);
           }
         });
       }
@@ -129,51 +124,77 @@ public boolean readMessage() {
     }
 
     BufferedSink sink = Okio.buffer(writer.newMessageSink(formatOpcode));
-    message.writeTo(sink);
-    sink.close();
+    try {
+      message.writeTo(sink);
+      sink.close();
+    } catch (IOException e) {
+      try {
+        close(CLOSE_GOING_AWAY, null);
+      } catch (IOException ignored) {
+      }
+      throw e;
+    }
   }
 
   @Override public void sendPing(Buffer payload) throws IOException {
     if (writerSentClose) throw new IllegalStateException("closed");
-    writer.writePing(payload);
+    try {
+      writer.writePing(payload);
+    } catch (IOException e) {
+      try {
+        close(CLOSE_GOING_AWAY, null);
+      } catch (IOException ignored) {
+      }
+      throw e;
+    }
   }
 
   /** Send an unsolicited pong with the specified payload. */
   public void sendPong(Buffer payload) throws IOException {
     if (writerSentClose) throw new IllegalStateException("closed");
-    writer.writePong(payload);
+    try {
+      writer.writePong(payload);
+    } catch (IOException e) {
+      try {
+        close(CLOSE_GOING_AWAY, null);
+      } catch (IOException ignored) {
+      }
+      throw e;
+    }
   }
 
   @Override public void close(int code, String reason) throws IOException {
     if (writerSentClose) throw new IllegalStateException("closed");
+    writerSentClose = true;
 
-    boolean performClose;
-    synchronized (closeLock) {
-      writerSentClose = true;
-
-      // If the reader has also indicated a desire to close we will close the connection.
-      performClose = readerSentClose;
-    }
-
-    writer.writeClose(code, reason);
-
-    if (performClose) {
-      close();
+    try {
+      writer.writeClose(code, reason);
+    } catch (IOException e) {
+      if (connectionClosed.compareAndSet(false, true)) {
+        // Try to close the connection without masking the original exception.
+        try {
+          close();
+        } catch (IOException ignored) {
+        }
+      }
+      throw e;
     }
   }
 
   /** Replies and closes this web socket when a close frame is read from the peer. */
-  private void peerClose(int code, String reason, boolean writeCloseResponse) {
-    if (writeCloseResponse) {
+  private void peerClose(int code, String reason) {
+    if (!writerSentClose) {
       try {
         writer.writeClose(code, reason);
       } catch (IOException ignored) {
       }
     }
 
-    try {
-      close();
-    } catch (IOException ignored) {
+    if (connectionClosed.compareAndSet(false, true)) {
+      try {
+        close();
+      } catch (IOException ignored) {
+      }
     }
 
     listener.onClose(code, reason);
@@ -181,25 +202,19 @@ private void peerClose(int code, String reason, boolean writeCloseResponse) {
 
   /** Called on the reader thread when an error occurs. */
   private void readerErrorClose(IOException e) {
-    boolean canSendClose;
-    synchronized (closeLock) {
-      readerSentClose = true;
-
-      // If the writer has not closed we may inform the server of the close.
-      canSendClose = !writerSentClose;
-    }
-
     // For protocol exceptions, try to inform the server of such.
-    if (canSendClose && e instanceof ProtocolException) {
+    if (!writerSentClose && e instanceof ProtocolException) {
       try {
         writer.writeClose(CLOSE_PROTOCOL_EXCEPTION, null);
       } catch (IOException ignored) {
       }
     }
 
-    try {
-      close();
-    } catch (IOException ignored) {
+    if (connectionClosed.compareAndSet(false, true)) {
+      try {
+        close();
+      } catch (IOException ignored) {
+      }
     }
 
     listener.onFailure(e, null);
diff --git a/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocket.java b/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocket.java
index df1490d5b8..eb1df7394e 100644
--- a/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocket.java
+++ b/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocket.java
@@ -33,6 +33,8 @@
    * <p>The {@linkplain RequestBody#contentType() content type} of {@code message} should be either
    * {@link #TEXT} or {@link #BINARY}.
    *
+   * @throws IOException if unable to write the message. If thrown, an attempt to send a close
+   * frame with code 1001 will be made and this instance will no longer be valid to use.
    * @throws IllegalStateException if not connected, already closed, or another writer is active.
    */
   void sendMessage(RequestBody message) throws IOException;
@@ -40,6 +42,8 @@
   /**
    * Send a ping to the server with optional payload.
    *
+   * @throws IOException if unable to write the ping. If thrown, an attempt to send a close frame
+   * with code 1001 will be made and this instance will no longer be valid to use.
    * @throws IllegalStateException if already closed.
    */
   void sendPing(Buffer payload) throws IOException;
@@ -53,6 +57,8 @@
    * It is an error to call this method before calling close on an active writer. Calling this
    * method more than once has no effect.
    *
+   * @throws IOException if unable to write the close message. If thrown this instance will no
+   * longer be valid to use.
    * @throws IllegalStateException if already closed.
    */
   void close(int code, String reason) throws IOException;
