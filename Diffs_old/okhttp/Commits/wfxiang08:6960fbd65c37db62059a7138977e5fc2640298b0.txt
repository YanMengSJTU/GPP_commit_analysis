diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/HpackTest.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/HpackTest.java
index 068ab647e7..6ca2abab52 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/HpackTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/HpackTest.java
@@ -82,6 +82,12 @@
 
   /** Oldest entries are evicted to support newer ones. */
   @Test public void testEviction() throws IOException {
+    List<Header> headerBlock =
+        headerEntries(
+            "custom-foo", "custom-header",
+            "custom-bar", "custom-header",
+            "custom-baz", "custom-header");
+
     bytesIn.writeByte(0x40); // Literal indexed
     bytesIn.writeByte(0x0a); // Literal name (len = 10)
     bytesIn.writeUtf8("custom-foo");
@@ -103,26 +109,37 @@
     bytesIn.writeByte(0x0d); // Literal value (len = 13)
     bytesIn.writeUtf8("custom-header");
 
+    // Set to only support 110 bytes (enough for 2 headers).
+    // Use a new Writer because we don't support change the dynamic table
+    // size after Writer constructed.
+    Hpack.Writer writer = new Hpack.Writer(110, bytesOut);
+    writer.writeHeaders(headerBlock);
+
+    assertEquals(bytesIn, bytesOut);
+    assertEquals(2, writer.headerCount);
+
+    int tableLength = writer.dynamicTable.length;
+    Header entry = writer.dynamicTable[tableLength - 1];
+    checkEntry(entry, "custom-bar", "custom-header", 55);
+
+    entry = writer.dynamicTable[tableLength - 2];
+    checkEntry(entry, "custom-baz", "custom-header", 55);
+
     // Set to only support 110 bytes (enough for 2 headers).
     hpackReader.headerTableSizeSetting(110);
     hpackReader.readHeaders();
 
     assertEquals(2, hpackReader.headerCount);
 
-    Header entry = hpackReader.dynamicTable[headerTableLength() - 1];
+    entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
     checkEntry(entry, "custom-bar", "custom-header", 55);
 
-    entry = hpackReader.dynamicTable[headerTableLength() - 2];
+    entry = hpackReader.dynamicTable[readerHeaderTableLength() - 2];
     checkEntry(entry, "custom-baz", "custom-header", 55);
 
     // Once a header field is decoded and added to the reconstructed header
     // list, it cannot be removed from it. Hence, foo is here.
-    assertEquals(
-        headerEntries(
-            "custom-foo", "custom-header",
-            "custom-bar", "custom-header",
-            "custom-baz", "custom-header"),
-        hpackReader.getAndResetHeaderList());
+    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
 
     // Simulate receiving a small settings frame, that implies eviction.
     hpackReader.headerTableSizeSetting(55);
@@ -158,7 +175,7 @@
     assertEquals(1, hpackReader.headerCount);
     assertEquals(52, hpackReader.dynamicTableByteCount);
 
-    Header entry = hpackReader.dynamicTable[headerTableLength() - 1];
+    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
     checkEntry(entry, ":path", "www.example.com", 52);
   }
 
@@ -178,7 +195,7 @@
     assertEquals(1, hpackReader.headerCount);
     assertEquals(55, hpackReader.dynamicTableByteCount);
 
-    Header entry = hpackReader.dynamicTable[headerTableLength() - 1];
+    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
     checkEntry(entry, "custom-key", "custom-header", 55);
 
     assertEquals(headerEntries("custom-key", "custom-header"), hpackReader.getAndResetHeaderList());
@@ -215,9 +232,6 @@
     bytesIn.writeByte(0x0d); // Literal value (len = 13)
     bytesIn.writeUtf8("custom-header");
 
-    hpackWriter.writeHeaders(headerBlock);
-    assertEquals(bytesIn, bytesOut);
-
     hpackReader.readHeaders();
 
     assertEquals(0, hpackReader.headerCount);
@@ -239,6 +253,8 @@
   }
 
   @Test public void literalHeaderFieldNeverIndexedNewName() throws IOException {
+    List<Header> headerBlock = headerEntries("custom-key", "custom-header");
+
     bytesIn.writeByte(0x10); // Never indexed
     bytesIn.writeByte(0x0a); // Literal name (len = 10)
     bytesIn.writeUtf8("custom-key");
@@ -250,7 +266,76 @@
 
     assertEquals(0, hpackReader.headerCount);
 
-    assertEquals(headerEntries("custom-key", "custom-header"), hpackReader.getAndResetHeaderList());
+    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
+  }
+
+  @Test public void literalHeaderFieldWithIncrementalIndexingIndexedName() throws IOException {
+    List<Header> headerBlock = headerEntries(":path", "/sample/path");
+
+    bytesIn.writeByte(0x44); // Indexed name (idx = 4) -> :path
+    bytesIn.writeByte(0x0c); // Literal value (len = 12)
+    bytesIn.writeUtf8("/sample/path");
+
+    hpackReader.readHeaders();
+
+    assertEquals(1, hpackReader.headerCount);
+
+    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
+  }
+
+  @Test public void literalHeaderFieldWithIncrementalIndexingNewName() throws IOException {
+    List<Header> headerBlock = headerEntries("custom-key", "custom-header");
+
+    bytesIn.writeByte(0x40); // Never indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-key");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
+
+    hpackWriter.writeHeaders(headerBlock);
+    assertEquals(bytesIn, bytesOut);
+
+    assertEquals(1, hpackWriter.headerCount);
+
+    Header entry = hpackWriter.dynamicTable[hpackWriter.dynamicTable.length - 1];
+    checkEntry(entry, "custom-key", "custom-header", 55);
+
+    hpackReader.readHeaders();
+
+    assertEquals(1, hpackReader.headerCount);
+
+    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
+  }
+
+  @Test public void theSameHeaderAfterOneIncrementalIndexed() throws IOException {
+    List<Header> headerBlock =
+        headerEntries(
+            "custom-key", "custom-header",
+            "custom-key", "custom-header");
+
+    bytesIn.writeByte(0x40); // Never indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-key");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
+
+    bytesIn.writeByte(0xbe); // Indexed name and value (idx = 63)
+
+    hpackWriter.writeHeaders(headerBlock);
+    assertEquals(bytesIn, bytesOut);
+
+    assertEquals(1, hpackWriter.headerCount);
+
+    Header entry = hpackWriter.dynamicTable[hpackWriter.dynamicTable.length - 1];
+    checkEntry(entry, "custom-key", "custom-header", 55);
+
+    hpackReader.readHeaders();
+
+    assertEquals(1, hpackReader.headerCount);
+
+    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
   }
 
   @Test public void staticHeaderIsNotCopiedIntoTheIndexedTable() throws IOException {
@@ -262,7 +347,7 @@
     assertEquals(0, hpackReader.headerCount);
     assertEquals(0, hpackReader.dynamicTableByteCount);
 
-    assertEquals(null, hpackReader.dynamicTable[headerTableLength() - 1]);
+    assertEquals(null, hpackReader.dynamicTable[readerHeaderTableLength() - 1]);
 
     assertEquals(headerEntries(":method", "GET"), hpackReader.getAndResetHeaderList());
   }
@@ -396,7 +481,7 @@ private void checkReadFirstRequestWithoutHuffman() {
     assertEquals(1, hpackReader.headerCount);
 
     // [  1] (s =  57) :authority: www.example.com
-    Header entry = hpackReader.dynamicTable[headerTableLength() - 1];
+    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
     checkEntry(entry, ":authority", "www.example.com", 57);
 
     // Table size: 57
@@ -429,11 +514,11 @@ private void checkReadSecondRequestWithoutHuffman() {
     assertEquals(2, hpackReader.headerCount);
 
     // [  1] (s =  53) cache-control: no-cache
-    Header entry = hpackReader.dynamicTable[headerTableLength() - 2];
+    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 2];
     checkEntry(entry, "cache-control", "no-cache", 53);
 
     // [  2] (s =  57) :authority: www.example.com
-    entry = hpackReader.dynamicTable[headerTableLength() - 1];
+    entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
     checkEntry(entry, ":authority", "www.example.com", 57);
 
     // Table size: 110
@@ -468,15 +553,15 @@ private void checkReadThirdRequestWithoutHuffman() {
     assertEquals(3, hpackReader.headerCount);
 
     // [  1] (s =  54) custom-key: custom-value
-    Header entry = hpackReader.dynamicTable[headerTableLength() - 3];
+    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 3];
     checkEntry(entry, "custom-key", "custom-value", 54);
 
     // [  2] (s =  53) cache-control: no-cache
-    entry = hpackReader.dynamicTable[headerTableLength() - 2];
+    entry = hpackReader.dynamicTable[readerHeaderTableLength() - 2];
     checkEntry(entry, "cache-control", "no-cache", 53);
 
     // [  3] (s =  57) :authority: www.example.com
-    entry = hpackReader.dynamicTable[headerTableLength() - 1];
+    entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
     checkEntry(entry, ":authority", "www.example.com", 57);
 
     // Table size: 164
@@ -526,7 +611,7 @@ private void checkReadFirstRequestWithHuffman() {
     assertEquals(1, hpackReader.headerCount);
 
     // [  1] (s =  57) :authority: www.example.com
-    Header entry = hpackReader.dynamicTable[headerTableLength() - 1];
+    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
     checkEntry(entry, ":authority", "www.example.com", 57);
 
     // Table size: 57
@@ -560,11 +645,11 @@ private void checkReadSecondRequestWithHuffman() {
     assertEquals(2, hpackReader.headerCount);
 
     // [  1] (s =  53) cache-control: no-cache
-    Header entry = hpackReader.dynamicTable[headerTableLength() - 2];
+    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 2];
     checkEntry(entry, "cache-control", "no-cache", 53);
 
     // [  2] (s =  57) :authority: www.example.com
-    entry = hpackReader.dynamicTable[headerTableLength() - 1];
+    entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
     checkEntry(entry, ":authority", "www.example.com", 57);
 
     // Table size: 110
@@ -601,15 +686,15 @@ private void checkReadThirdRequestWithHuffman() {
     assertEquals(3, hpackReader.headerCount);
 
     // [  1] (s =  54) custom-key: custom-value
-    Header entry = hpackReader.dynamicTable[headerTableLength() - 3];
+    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 3];
     checkEntry(entry, "custom-key", "custom-value", 54);
 
     // [  2] (s =  53) cache-control: no-cache
-    entry = hpackReader.dynamicTable[headerTableLength() - 2];
+    entry = hpackReader.dynamicTable[readerHeaderTableLength() - 2];
     checkEntry(entry, "cache-control", "no-cache", 53);
 
     // [  3] (s =  57) :authority: www.example.com
-    entry = hpackReader.dynamicTable[headerTableLength() - 1];
+    entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
     checkEntry(entry, ":authority", "www.example.com", 57);
 
     // Table size: 164
@@ -674,7 +759,7 @@ private void checkReadThirdRequestWithHuffman() {
 
   @Test public void lowercaseHeaderNameBeforeEmit() throws IOException {
     hpackWriter.writeHeaders(Arrays.asList(new Header("FoO", "BaR")));
-    assertBytes(0, 3, 'f', 'o', 'o', 3, 'B', 'a', 'R');
+    assertBytes(0x40, 3, 'f', 'o', 'o', 3, 'B', 'a', 'R');
   }
 
   @Test public void mixedCaseHeaderNameIsMalformed() throws IOException {
@@ -720,7 +805,7 @@ private ByteString intArrayToByteArray(int[] bytes) {
     return ByteString.of(data);
   }
 
-  private int headerTableLength() {
+  private int readerHeaderTableLength() {
     return hpackReader.dynamicTable.length;
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/Hpack.java b/okhttp/src/main/java/okhttp3/internal/framed/Hpack.java
index 2b49784e9b..793f7b93a7 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/Hpack.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/Hpack.java
@@ -367,27 +367,128 @@ ByteString readByteString() throws IOException {
   }
 
   static final class Writer {
+    private static final byte SEPARATED_TOKEN = ':';
+    private static final int SETTINGS_HEADER_TABLE_SIZE = 4096;
+
     private final Buffer out;
+    private final Map<ByteString, Integer> headerStringToDynamicIndex =
+        new LinkedHashMap<ByteString, Integer>();
+
+    private int headerTableSizeSetting;
+    private int maxDynamicTableByteCount;
+    // Visible for testing.
+    Header[] dynamicTable = new Header[8];
+    // Array is populated back to front, so new entries always have lowest index.
+    int nextHeaderIndex = dynamicTable.length - 1;
+    int headerCount = 0;
+    int dynamicTableByteCount = 0;
 
     Writer(Buffer out) {
+      this(SETTINGS_HEADER_TABLE_SIZE, out);
+    }
+
+    // This is the only method to set the dynamic table size.
+    // Don't support to change the dynamic table size after Writer constructed.
+    Writer(int headerTableSizeSetting, Buffer out) {
+      this.headerTableSizeSetting = headerTableSizeSetting;
+      this.maxDynamicTableByteCount = headerTableSizeSetting;
       this.out = out;
     }
 
+    ByteString getHeaderString(Header entry) {
+      byte[] ret = new byte[entry.name.size() + 1 + entry.value.size()];
+      System.arraycopy(entry.name.toByteArray(), 0, ret, 0, entry.name.size());
+      ret[entry.name.size()] = SEPARATED_TOKEN;
+      System.arraycopy(entry.value.toByteArray(), 0, ret, entry.name.size() + 1,
+          entry.value.size());
+      return ByteString.of(ret);
+    }
+
+    private void clearDynamicTable() {
+      Arrays.fill(dynamicTable, null);
+      headerStringToDynamicIndex.clear();
+      nextHeaderIndex = dynamicTable.length - 1;
+      headerCount = 0;
+      dynamicTableByteCount = 0;
+    }
+
+    /** Returns the count of entries evicted. */
+    private int evictToRecoverBytes(int bytesToRecover) {
+      int entriesToEvict = 0;
+      if (bytesToRecover > 0) {
+        // determine how many headers need to be evicted.
+        for (int j = dynamicTable.length - 1; j >= nextHeaderIndex && bytesToRecover > 0; j--) {
+          bytesToRecover -= dynamicTable[j].hpackSize;
+          dynamicTableByteCount -= dynamicTable[j].hpackSize;
+          headerCount--;
+          entriesToEvict++;
+        }
+        System.arraycopy(dynamicTable, nextHeaderIndex + 1, dynamicTable,
+            nextHeaderIndex + 1 + entriesToEvict, headerCount);
+        for (Map.Entry<ByteString, Integer> p : headerStringToDynamicIndex.entrySet()) {
+          p.setValue(p.getValue() + entriesToEvict);
+        }
+        nextHeaderIndex += entriesToEvict;
+      }
+      return entriesToEvict;
+    }
+
+    private void insertIntoDynamicTable(Header entry) {
+      int delta = entry.hpackSize;
+
+      // if the new or replacement header is too big, drop all entries.
+      if (delta > maxDynamicTableByteCount) {
+        clearDynamicTable();
+        return;
+      }
+
+      // Evict headers to the required length.
+      int bytesToRecover = (dynamicTableByteCount + delta) - maxDynamicTableByteCount;
+      evictToRecoverBytes(bytesToRecover);
+
+      if (headerCount + 1 > dynamicTable.length) { // Need to grow the dynamic table.
+        Header[] doubled = new Header[dynamicTable.length * 2];
+        System.arraycopy(dynamicTable, 0, doubled, dynamicTable.length, dynamicTable.length);
+        for (Map.Entry<ByteString, Integer> p : headerStringToDynamicIndex.entrySet()) {
+          p.setValue(p.getValue() + dynamicTable.length);
+        }
+        nextHeaderIndex = dynamicTable.length - 1;
+        dynamicTable = doubled;
+      }
+      int index = nextHeaderIndex--;
+      dynamicTable[index] = entry;
+      headerStringToDynamicIndex.put(getHeaderString(entry), index);
+      headerCount++;
+      dynamicTableByteCount += delta;
+    }
+
     /** This does not use "never indexed" semantics for sensitive headers. */
     // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-6.2.3
     void writeHeaders(List<Header> headerBlock) throws IOException {
       // TODO: implement index tracking
       for (int i = 0, size = headerBlock.size(); i < size; i++) {
-        ByteString name = headerBlock.get(i).name.toAsciiLowercase();
+        Header header = headerBlock.get(i);
+        ByteString name = header.name.toAsciiLowercase();
+        ByteString value = header.value;
         Integer staticIndex = NAME_TO_FIRST_INDEX.get(name);
         if (staticIndex != null) {
           // Literal Header Field without Indexing - Indexed Name.
           writeInt(staticIndex + 1, PREFIX_4_BITS, 0);
-          writeByteString(headerBlock.get(i).value);
+          writeByteString(value);
         } else {
-          out.writeByte(0x00); // Literal Header without Indexing - New Name.
-          writeByteString(name);
-          writeByteString(headerBlock.get(i).value);
+          ByteString headerString = getHeaderString(header);
+          Integer dynamicIndex = headerStringToDynamicIndex.get(headerString);
+          if (dynamicIndex != null) {
+            // Indexed Header.
+            writeInt(dynamicTable.length - dynamicIndex + STATIC_HEADER_TABLE.length, PREFIX_7_BITS,
+                0x80);
+          } else {
+            // Literal Header Field with Incremental Indexing - New Name
+            out.writeByte(0x40);
+            writeByteString(name);
+            writeByteString(value);
+            insertIntoDynamicTable(header);
+          }
         }
       }
     }
