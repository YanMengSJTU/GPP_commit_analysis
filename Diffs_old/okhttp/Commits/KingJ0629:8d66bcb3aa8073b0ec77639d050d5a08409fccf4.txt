diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
index 9b0bdcc1f1..92e8e8bf32 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.java
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java
@@ -58,13 +58,20 @@
  * Factory for {@linkplain Call calls}, which can be used to send HTTP requests and read their
  * responses.
  *
+ * calls的工厂，用来发送HTTP请求和读取它们的响应
+ *
  * <h3>OkHttpClients should be shared</h3>
  *
+ * OkHttpClients应该被共享
+ *
  * <p>OkHttp performs best when you create a single {@code OkHttpClient} instance and reuse it for
  * all of your HTTP calls. This is because each client holds its own connection pool and thread
  * pools. Reusing connections and threads reduces latency and saves memory. Conversely, creating a
  * client for each request wastes resources on idle pools.
  *
+ * OkHttp在单例的时候是最佳执行策略。因为每个client持有它自己的连接池和线程池。复用连接和线程池能减少延迟和节约内存
+ * 相反，为每个请求都创建一个client是浪费空闲池中的资源
+ *
  * <p>Use {@code new OkHttpClient()} to create a shared instance with the default settings:
  * <pre>   {@code
  *
@@ -84,10 +91,15 @@
  *
  * <h3>Customize your client with newBuilder()</h3>
  *
+ * 使用newBuilder()来定制你的client
+ *
  * <p>You can customize a shared OkHttpClient instance with {@link #newBuilder()}. This builds a
  * client that shares the same connection pool, thread pools, and configuration. Use the builder
  * methods to configure the derived client for a specific purpose.
  *
+ * 你可以用newBuilder()来定制一个共享的OkHttpClient实例，这个client共享共同的连接池、线程池和配置
+ * 用builder methods配置各种client
+ *
  * <p>This example shows a call with a short 500 millisecond timeout: <pre>   {@code
  *
  *   OkHttpClient eagerClient = client.newBuilder()
@@ -108,12 +120,17 @@
  *     client.dispatcher().executorService().shutdown();
  * }</pre>
  *
+ * 当空闲时，线程和链接会被自动释放,shutdown不是必须的
+ * client.dispatcher().executorService().shutdown()，也会导致接下来的请求被拒绝
+ *
  * <p>Clear the connection pool with {@link ConnectionPool#evictAll() evictAll()}. Note that the
  * connection pool's daemon thread may not exit immediately. <pre>   {@code
  *
  *     client.connectionPool().evictAll();
  * }</pre>
  *
+ * 使用{@ConnectionPool＃evictAll（）evictAll（）}清除连接池。 请注意，连接池的守护进程线程可能不会立即退出。
+ *
  * <p>If your client has a cache, call {@link Cache#close close()}. Note that it is an error to
  * create calls against a cache that is closed, and doing so will cause the call to crash.
  * <pre>   {@code
@@ -121,8 +138,12 @@
  *     client.cache().close();
  * }</pre>
  *
+ * 如果您的客户端有缓存，call{@link Cache＃close close（）}。 请注意，针对已关闭的缓存创建调用是错误的，这样做会导致调用崩溃。
+ *
  * <p>OkHttp also uses daemon threads for HTTP/2 connections. These will exit automatically if they
  * remain idle.
+ *
+ * OkHttp同样在http2连接中使用守护线程，当空闲时会自动退出。
  */
 public class OkHttpClient implements Cloneable, Call.Factory, WebSocket.Factory {
   static final List<Protocol> DEFAULT_PROTOCOLS = Util.immutableList(
