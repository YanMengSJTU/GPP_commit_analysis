diff --git a/okhttp-tests/src/test/java/okhttp3/CacheTest.java b/okhttp-tests/src/test/java/okhttp3/CacheTest.java
index 83ce5c8b22..8182800d2a 100644
--- a/okhttp-tests/src/test/java/okhttp3/CacheTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CacheTest.java
@@ -564,6 +564,7 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
       in.readByte();
       fail("Expected an IllegalStateException because the source is closed.");
     } catch (IllegalStateException expected) {
+      //错误信息：closed
     }
 
     assertEquals(1, cache.writeAbortCount());
@@ -618,6 +619,8 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
     assertEquals("A", get(server.url("/")).body().string());
     Response response = get(server.url("/"));
     assertEquals("A", response.body().string());
+    assertEquals(200,response.code());
+    //113:响应的使用期超过24小时（有效缓存的设定时间大于24小时的情况下）
     assertEquals("113 HttpURLConnection \"Heuristic expiration\"", response.header("Warning"));
   }
 
@@ -2500,6 +2503,8 @@ private RecordedRequest assertConditionallyCached(MockResponse response) throws
     assertEquals("A-OK", response1.message());
     Response response2 = get(valid);
     assertEquals("A", response2.body().string());
+    //为什么返回的响应码不是304？
+    //应该是碰到了304响应，然后就去请求本地的缓存代理服务器，最后返回了200。
     assertEquals(HttpURLConnection.HTTP_OK, response2.code());
     assertEquals("A-OK", response2.message());
 
@@ -2513,6 +2518,8 @@ private RecordedRequest assertConditionallyCached(MockResponse response) throws
     assertEquals(HttpURLConnection.HTTP_OK, response4.code());
     assertEquals("C-OK", response4.message());
 
+    assertEquals(4, server.getRequestCount());
+
     server.takeRequest(); // regular get
     return server.takeRequest(); // conditional get
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/DisconnectTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/DisconnectTest.java
index aad2bfc8dd..99b3e04ed9 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/DisconnectTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/DisconnectTest.java
@@ -89,6 +89,10 @@
       }
       fail("Expected connection to be closed");
     } catch (IOException expected) {
+      //错误信息：timeout
+      //10秒后，测试才完成。应该是向服务端传输数据时，比如，上传文件，调用disconnect后，
+      //客户端不知道与服务端的连接已断开(这种想法有待商榷)。
+      //客户端还在等待服务器的响应。而okhttp的默认writeTimeout为10_000
     }
 
     connection.disconnect();
@@ -112,6 +116,9 @@
       }
       fail("Expected connection to be closed");
     } catch (IOException expected) {
+      //错误信息：Socket closed
+      //700多毫秒后，测试立刻完成。应该是从服务端读取数据时，
+      //比如下载文件，调用disconnect，会直接关闭socket。
     }
 
     responseBody.close();
diff --git a/okhttp/src/main/java/okhttp3/HttpUrl.java b/okhttp/src/main/java/okhttp3/HttpUrl.java
index 85292eec88..a67fb27c74 100644
--- a/okhttp/src/main/java/okhttp3/HttpUrl.java
+++ b/okhttp/src/main/java/okhttp3/HttpUrl.java
@@ -1364,6 +1364,7 @@ ParseResult parse(@Nullable HttpUrl base, String input) {
             case '@':
               // User info precedes.
               if (!hasPassword) {
+                //如果input中没有':'，返回的值是componentDelimiterOffset
                 int passwordColonOffset = delimiterOffset(
                     input, pos, componentDelimiterOffset, ':');
                 String canonicalUsername = canonicalize(
@@ -1688,6 +1689,9 @@ static String canonicalize(String input, int pos, int limit, String encodeSet,
           || codePoint == 0x7f
           || codePoint >= 0x80 && asciiOnly
           || encodeSet.indexOf(codePoint) != -1
+              //&&的优先级高于||，并且是左结合（从左往右）。
+              //A&&B||C&&D  即(A&&B)||(C&&D)。
+              //先算A&&B，如果为true，||的特性，整个表达式为true。如果为false，再算C&&D
           || codePoint == '%' && (!alreadyEncoded || strict && !percentEncoded(input, i, limit))
           || codePoint == '+' && plusIsSpace) {
         // Slow path: the character at i requires encoding!
@@ -1733,8 +1737,16 @@ static void canonicalize(Buffer out, String input, int pos, int limit, String en
         }
 
         while (!encodedCharBuffer.exhausted()) {
+          /**int c = bs[i] & 0xFF ; // 等同于 unsigned int c = bs[i];
+           *在窄类型向宽类型拓展的时候，为了保证不丢失二进制的存储，即在二进制数据保持一致的时候才会用到。
+           *但对应的十进制数据可能就不一样了，
+           *比如：byte b = -1,& 0xff后，获得的int是255。负数，都是这样。但b为正数时，比如1时，& 0xff，获得的int值仍是原数。
+           *
+           * @see <a href="https://www.cnblogs.com/think-in-java/p/5527389.html">byte为什么要与上0xff？</a>
+           */
           int b = encodedCharBuffer.readByte() & 0xff;
           out.writeByte('%');
+          //1111对应16进制的f。所以0000~1111分别对应16进制的0~f。
           out.writeByte(HEX_DIGITS[(b >> 4) & 0xf]);
           out.writeByte(HEX_DIGITS[b & 0xf]);
         }
diff --git a/okhttp/src/main/java/okhttp3/Test.java b/okhttp/src/main/java/okhttp3/Test.java
new file mode 100644
index 0000000000..d9d638f051
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Test.java
@@ -0,0 +1,24 @@
+package okhttp3;
+
+/**
+ * @author TuFei
+ * @date 18-9-23.
+ */
+public class Test {
+    public static void main(String[] args) {
+        byte b = 127;
+        int value = b;
+        System.out.println(b);
+        System.out.println(value);
+
+        byte[] a = new byte[10];
+        a[0]= -1;
+        System.out.println(a[0]);
+        int c = a[0]&0xff;
+        System.out.println(c);
+
+        byte d = -127;
+        int e = d;
+        System.out.println(d);
+    }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/Util.java b/okhttp/src/main/java/okhttp3/internal/Util.java
index 85c6cabcf1..4a3565a373 100644
--- a/okhttp/src/main/java/okhttp3/internal/Util.java
+++ b/okhttp/src/main/java/okhttp3/internal/Util.java
@@ -488,6 +488,11 @@ public static AssertionError assertionError(String message, Exception e) {
     return assertionError;
   }
 
+  /**
+   * 解码16进制的数字。
+   * @param c 要解码的char
+   * @return  如果char在特定的范围内，返回相应的10进制数值:0~15。否则，返回-1。
+   */
   public static int decodeHexDigit(char c) {
     if (c >= '0' && c <= '9') return c - '0';
     if (c >= 'a' && c <= 'f') return c - 'a' + 10;
diff --git a/okhttp/src/main/java/okhttp3/internal/Version.java b/okhttp/src/main/java/okhttp3/internal/Version.java
new file mode 100644
index 0000000000..a2450c6e8c
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/Version.java
@@ -0,0 +1,14 @@
+package okhttp3.internal;
+
+/**
+ * @author TuFei
+ * @date 18-9-21.
+ */
+public final class Version {
+    public static String userAgent() {
+        return "okhttp/3.8.1";
+    }
+
+    private Version() {
+    }
+}
