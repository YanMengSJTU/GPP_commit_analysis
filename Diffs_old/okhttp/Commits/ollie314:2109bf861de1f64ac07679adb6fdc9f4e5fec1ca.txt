diff --git a/.travis.yml b/.travis.yml
index ed135a7902..1835d337fb 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -24,3 +24,8 @@ sudo: false
 cache:
   directories:
     - $HOME/.m2
+
+addons:
+  apt:
+    packages:
+      - oracle-java8-installer
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 960d7d2f60..efb1ecdb1e 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,139 @@
 Change Log
 ==========
 
+## Version 3.4.1
+
+_2016-07-10_
+
+ *  **Fix a major bug in encoding HTTP headers.** In 3.4.0 and 3.4.0-RC1 OkHttp
+    had an off-by-one bug in our HPACK encoder. This bug could have caused the
+    wrong headers to be emitted after a sequence of HTTP/2 requests! Everyone
+    who is using OkHttp 3.4.0 or 3.4.0-RC1 should upgrade for this bug fix.
+
+
+## Version 3.4.0
+
+_2016-07-08_
+
+ *  New: Support dynamic table size changes to HPACK Encoder.
+ *  Fix: Use `TreeMap` in `Headers.toMultimap()`. This makes string lookups on
+    the returned map case-insensitive.
+ *  Fix: Don't share the OkHttpClient's `Dispatcher` in `HttpURLConnection`.
+
+
+## Version 3.4.0-RC1
+
+_2016-07-02_
+
+ *  **We’ve rewritten HttpURLConnection and HttpsURLConnection.** Previously we
+    shared a single HTTP engine between two frontend APIs: `HttpURLConnection`
+    and `Call`. With this release we’ve rearranged things so that the
+    `HttpURLConnection` frontend now delegates to the `Call` APIs internally.
+    This has enabled substantial simplifications and optimizations in the OkHttp
+    core for both frontends.
+
+    For most HTTP requests the consequences of this change will be negligible.
+    If your application uses `HttpURLConnection.connect()`,
+    `setFixedLengthStreamingMode()`, or `setChunkedStreamingMode()`, OkHttp will
+    now use a async dispatcher thread to establish the HTTP connection.
+
+    We don’t expect this change to have any behavior or performance
+    consequences. Regardless, please exercise your `OkUrlFactory` and
+    `HttpURLConnection` code when applying this update.
+
+ *  **Cipher suites may now have arbitrary names.** Previously `CipherSuite` was
+    a Java enum and it was impossible to define new cipher suites without first
+    upgrading OkHttp. With this change it is now a regular Java class with
+    enum-like constants. Application code that uses enum methods on cipher
+    suites (`ordinal()`, `name()`, etc.) will break with this change.
+
+ *  Fix: `CertificatePinner` now matches canonicalized hostnames. Previously
+    this was case sensitive. This change should also make it easier to configure
+    certificate pinning for internationalized domain names.
+ *  Fix: Don’t crash on non-ASCII `ETag` headers. Previously OkHttp would reject
+    these headers when validating a cached response.
+ *  Fix: Don’t allow remote peer to arbitrarily size the HPACK decoder dynamic
+    table.
+ *  Fix: Honor per-host configuration in Android’s network security config.
+    Previously disabling cleartext for any host would disable cleartext for all
+    hosts. Note that this setting is only available on Android 24+.
+ *  New: HPACK compression is now dynamic. This should improve performance when
+    transmitting request headers over HTTP/2.
+ *  New: `Dispatcher.setIdleCallback()` can be used to signal when there are no
+    calls in flight. This is useful for [testing with
+    Espresso][okhttp_idling_resource].
+ *  New: Upgrade to Okio 1.9.0.
+
+     ```xml
+     <dependency>
+       <groupId>com.squareup.okio</groupId>
+       <artifactId>okio</artifactId>
+       <version>1.9.0</version>
+     </dependency>
+     ```
+
+
+## Version 3.3.1
+
+_2016-05-28_
+
+ *  Fix: The plaintext check in HttpLoggingInterceptor incorrectly classified
+    newline characters as control characters. This is fixed.
+ *  Fix: Don't crash reading non-ASCII characters in HTTP/2 headers or in cached
+    HTTP headers.
+ *  Fix: Retain the response body when an attempt to open a web socket returns a
+    non-101 response code.
+
+
+## Version 3.3.0
+
+_2016-05-24_
+
+ *  New: `Response.sentRequestAtMillis()` and `receivedResponseAtMillis()`
+    methods track the system's local time when network calls are made. These
+    replace the `OkHttp-Sent-Millis` and `OkHttp-Received-Millis` headers that were
+    present in earlier versions of OkHttp.
+ *  New: Accept user-provided trust managers in `OkHttpClient.Builder`. This
+    allows OkHttp to satisfy its TLS requirements directly. Otherwise OkHttp
+    will use reflection to extract the `TrustManager` from the
+    `SSLSocketFactory`.
+ *  New: Support prerelease Java 9. This gets ALPN from the platform rather than
+    relying on the alpn-boot bootclasspath override.
+ *  New: `HttpLoggingInterceptor` now logs connection failures.
+ *  New: Upgrade to Okio 1.8.0.
+
+     ```xml
+     <dependency>
+       <groupId>com.squareup.okio</groupId>
+       <artifactId>okio</artifactId>
+       <version>1.8.0</version>
+     </dependency>
+     ```
+
+ *  Fix: Gracefully recover from a failure to rebuild the cache journal.
+ *  Fix: Don't corrupt cache entries when a cache entry is evicted while it is
+    being updated.
+ *  Fix: Make logging more consistent throughout OkHttp.
+ *  Fix: Log plaintext bodies only. This uses simple heuristics to differentiate
+    text from other data.
+ *  Fix: Recover from `REFUSED_STREAM` errors in HTTP/2. This should improve
+    interoperability with Nginx 1.10.0, which [refuses][nginx_959] streams
+    created before HTTP/2 settings have been acknowledged.
+ *  Fix: Improve recovery from failed routes.
+ *  Fix: Accommodate tunneling proxies that close the connection after an auth
+    challenge.
+ *  Fix: Use the proxy authenticator when authenticating HTTP proxies. This
+    regression was introduced in OkHttp 3.0.
+ *  Fix: Fail fast if network interceptors transform the response body such that
+    closing it doesn't also close the underlying stream. We had a bug where
+    OkHttp would attempt to reuse a connection but couldn't because it was still
+    held by a prior request.
+ *  Fix: Ensure network interceptors always have access to the underlying
+    connection.
+ *  Fix: Use `X509TrustManagerExtensions` on Android 17+.
+ *  Fix: Unblock waiting dispatchers on MockWebServer shutdown.
+
+
 ## Version 3.2.0
 
 _2016-02-25_
@@ -1002,3 +1135,5 @@ Initial release.
  [brick]: https://noncombatant.org/2015/05/01/about-http-public-key-pinning/
  [webdav]: https://tools.ietf.org/html/rfc4918
  [major_versions]: http://jakewharton.com/java-interoperability-policy-for-major-version-updates/
+ [nginx_959]: https://trac.nginx.org/nginx/ticket/959
+ [okhttp_idling_resource]: https://github.com/JakeWharton/okhttp-idling-resource
diff --git a/README.md b/README.md
index b6b059deb4..ffb46f8f70 100644
--- a/README.md
+++ b/README.md
@@ -11,12 +11,12 @@ Download [the latest JAR][3] or grab via Maven:
 <dependency>
   <groupId>com.squareup.okhttp3</groupId>
   <artifactId>okhttp</artifactId>
-  <version>3.2.0</version>
+  <version>3.4.1</version>
 </dependency>
 ```
 or Gradle:
 ```groovy
-compile 'com.squareup.okhttp3:okhttp:3.2.0'
+compile 'com.squareup.okhttp3:okhttp:3.4.1'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
@@ -25,9 +25,9 @@ Snapshots of the development version are available in [Sonatype's `snapshots` re
 MockWebServer
 -------------
 
-A library for testing HTTP, HTTPS, HTTP/2.0, and SPDY clients.
+A library for testing HTTP, HTTPS, and HTTP/2 clients.
 
-MockWebServer coupling with OkHttp is essential for proper testing of HTTP/2.0 so that code can be shared.
+MockWebServer coupling with OkHttp is essential for proper testing of HTTP/2 so that code can be shared.
 
 ### Download
 
@@ -36,13 +36,13 @@ Download [the latest JAR][4] or grab via Maven:
 <dependency>
   <groupId>com.squareup.okhttp3</groupId>
   <artifactId>mockwebserver</artifactId>
-  <version>3.2.0</version>
+  <version>3.4.1</version>
   <scope>test</scope>
 </dependency>
 ```
 or Gradle:
 ```groovy
-testCompile 'com.squareup.okhttp3:mockwebserver:3.2.0'
+testCompile 'com.squareup.okhttp3:mockwebserver:3.4.1'
 ```
 
 
diff --git a/benchmarks/pom.xml b/benchmarks/pom.xml
index 2dab72f0ef..0065b25634 100644
--- a/benchmarks/pom.xml
+++ b/benchmarks/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.3.0-SNAPSHOT</version>
+    <version>3.5.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>benchmarks</artifactId>
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java b/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java
index 2f97519a29..a5c632fa0f 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java
@@ -19,9 +19,8 @@
 import java.io.InputStream;
 import java.util.concurrent.TimeUnit;
 import java.util.zip.GZIPInputStream;
-import javax.net.ssl.SSLContext;
 import okhttp3.HttpUrl;
-import okhttp3.internal.SslContextBuilder;
+import okhttp3.internal.tls.SslClient;
 import org.apache.http.Header;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.HttpClient;
@@ -42,9 +41,9 @@
     super.prepare(benchmark);
     ClientConnectionManager connectionManager = new PoolingClientConnectionManager();
     if (benchmark.tls) {
-      SSLContext sslContext = SslContextBuilder.localhost();
+      SslClient sslClient = SslClient.localhost();
       connectionManager.getSchemeRegistry().register(
-          new Scheme("https", 443, new SSLSocketFactory(sslContext)));
+          new Scheme("https", 443, new SSLSocketFactory(sslClient.sslContext)));
     }
     client = new DefaultHttpClient(connectionManager);
   }
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java b/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java
index d69530fe0e..0ec59a0573 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java
@@ -26,10 +26,9 @@
 import java.util.concurrent.TimeUnit;
 import java.util.logging.Level;
 import java.util.logging.Logger;
-import javax.net.ssl.SSLContext;
 import okhttp3.HttpUrl;
 import okhttp3.Protocol;
-import okhttp3.internal.SslContextBuilder;
+import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.Dispatcher;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
@@ -69,7 +68,7 @@
   @Param
   boolean gzip;
 
-  /** Don't combine chunked with SPDY_3 or HTTP_2; that's not allowed. */
+  /** Don't combine chunked with HTTP_2; that's not allowed. */
   @Param
   boolean chunked;
 
@@ -161,8 +160,8 @@ private MockWebServer startServer() throws IOException {
     MockWebServer server = new MockWebServer();
 
     if (tls) {
-      SSLContext sslContext = SslContextBuilder.localhost();
-      server.useHttps(sslContext.getSocketFactory(), false);
+      SslClient sslClient = SslClient.localhost();
+      server.useHttps(sslClient.socketFactory, false);
       server.setProtocols(protocols);
     }
 
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java b/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java
index 8caa046c73..01e6f6e257 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java
@@ -42,10 +42,9 @@
 import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.concurrent.TimeUnit;
-import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLEngine;
 import okhttp3.HttpUrl;
-import okhttp3.internal.SslContextBuilder;
+import okhttp3.internal.tls.SslClient;
 
 /** Netty isn't an HTTP client, but it's almost one. */
 class NettyHttpClient implements HttpClient {
@@ -69,8 +68,8 @@
         ChannelPipeline pipeline = channel.pipeline();
 
         if (benchmark.tls) {
-          SSLContext sslContext = SslContextBuilder.localhost();
-          SSLEngine engine = sslContext.createSSLEngine();
+          SslClient sslClient = SslClient.localhost();
+          SSLEngine engine = sslClient.sslContext.createSSLEngine();
           engine.setUseClientMode(true);
           pipeline.addLast("ssl", new SslHandler(engine));
         }
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java
index 05eb5044d2..7c90e5e6b5 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java
@@ -18,7 +18,6 @@
 import java.io.IOException;
 import java.util.concurrent.TimeUnit;
 import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSession;
 import javax.net.ssl.SSLSocketFactory;
 import okhttp3.Call;
@@ -26,7 +25,7 @@
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.ResponseBody;
-import okhttp3.internal.SslContextBuilder;
+import okhttp3.internal.tls.SslClient;
 
 class OkHttp extends SynchronousHttpClient {
   private static final boolean VERBOSE = false;
@@ -40,15 +39,15 @@
         .build();
 
     if (benchmark.tls) {
-      SSLContext sslContext = SslContextBuilder.localhost();
-      SSLSocketFactory socketFactory = sslContext.getSocketFactory();
+      SslClient sslClient = SslClient.localhost();
+      SSLSocketFactory socketFactory = sslClient.socketFactory;
       HostnameVerifier hostnameVerifier = new HostnameVerifier() {
         @Override public boolean verify(String s, SSLSession session) {
           return true;
         }
       };
       client = new OkHttpClient.Builder()
-          .sslSocketFactory(socketFactory)
+          .sslSocketFactory(socketFactory, sslClient.trustManager)
           .hostnameVerifier(hostnameVerifier)
           .build();
     }
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/OkHttpAsync.java b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttpAsync.java
index 09bd3a73e3..57cb75cacc 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/OkHttpAsync.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttpAsync.java
@@ -21,7 +21,6 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSession;
 import javax.net.ssl.SSLSocketFactory;
 import okhttp3.Call;
@@ -32,7 +31,7 @@
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.ResponseBody;
-import okhttp3.internal.SslContextBuilder;
+import okhttp3.internal.tls.SslClient;
 
 class OkHttpAsync implements HttpClient {
   private static final boolean VERBOSE = false;
@@ -55,15 +54,15 @@
         .build();
 
     if (benchmark.tls) {
-      SSLContext sslContext = SslContextBuilder.localhost();
-      SSLSocketFactory socketFactory = sslContext.getSocketFactory();
+      SslClient sslClient = SslClient.localhost();
+      SSLSocketFactory socketFactory = sslClient.socketFactory;
       HostnameVerifier hostnameVerifier = new HostnameVerifier() {
         @Override public boolean verify(String s, SSLSession session) {
           return true;
         }
       };
       client = client.newBuilder()
-          .sslSocketFactory(socketFactory)
+          .sslSocketFactory(socketFactory, sslClient.trustManager)
           .hostnameVerifier(hostnameVerifier)
           .build();
     }
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java b/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java
index f5c02ce0b6..f75d160835 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java
@@ -22,11 +22,10 @@
 import java.util.zip.GZIPInputStream;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSession;
 import javax.net.ssl.SSLSocketFactory;
 import okhttp3.HttpUrl;
-import okhttp3.internal.SslContextBuilder;
+import okhttp3.internal.tls.SslClient;
 
 class UrlConnection extends SynchronousHttpClient {
   private static final boolean VERBOSE = false;
@@ -34,8 +33,8 @@
   @Override public void prepare(Benchmark benchmark) {
     super.prepare(benchmark);
     if (benchmark.tls) {
-      SSLContext sslContext = SslContextBuilder.localhost();
-      SSLSocketFactory socketFactory = sslContext.getSocketFactory();
+      SslClient sslClient = SslClient.localhost();
+      SSLSocketFactory socketFactory = sslClient.socketFactory;
       HostnameVerifier hostnameVerifier = new HostnameVerifier() {
         @Override public boolean verify(String s, SSLSession session) {
           return true;
diff --git a/mockwebserver/pom.xml b/mockwebserver/pom.xml
index 0d858e5524..9f68096de5 100644
--- a/mockwebserver/pom.xml
+++ b/mockwebserver/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.3.0-SNAPSHOT</version>
+    <version>3.5.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>mockwebserver</artifactId>
@@ -24,11 +24,6 @@
       <version>${project.version}</version>
       <scope>test</scope>
     </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-ws</artifactId>
-      <version>${project.version}</version>
-    </dependency>
     <dependency>
       <groupId>org.bouncycastle</groupId>
       <artifactId>bcprov-jdk15on</artifactId>
diff --git a/mockwebserver/src/main/java/okhttp3/internal/SslContextBuilder.java b/mockwebserver/src/main/java/okhttp3/internal/SslContextBuilder.java
deleted file mode 100644
index b161e106e2..0000000000
--- a/mockwebserver/src/main/java/okhttp3/internal/SslContextBuilder.java
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.security.GeneralSecurityException;
-import java.security.KeyStore;
-import java.security.SecureRandom;
-import java.security.cert.Certificate;
-import java.security.cert.X509Certificate;
-import java.util.ArrayList;
-import java.util.List;
-import javax.net.ssl.KeyManagerFactory;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.TrustManagerFactory;
-
-/**
- * Constructs an SSL context for testing. This uses Bouncy Castle to generate a self-signed
- * certificate for a single hostname such as "localhost".
- *
- * <p>The crypto performed by this class is relatively slow. Clients should reuse SSL context
- * instances where possible.
- */
-public final class SslContextBuilder {
-  private static SSLContext localhost; // Lazily initialized.
-
-  /** Returns a new SSL context for this host's current localhost address. */
-  public static synchronized SSLContext localhost() {
-    if (localhost != null) return localhost;
-
-    try {
-      // Generate a self-signed cert for the server to serve and the client to trust.
-      HeldCertificate heldCertificate = new HeldCertificate.Builder()
-          .serialNumber("1")
-          .commonName(InetAddress.getByName("localhost").getHostName())
-          .build();
-
-      localhost = new SslContextBuilder()
-          .certificateChain(heldCertificate)
-          .addTrustedCertificate(heldCertificate.certificate)
-          .build();
-
-      return localhost;
-    } catch (GeneralSecurityException e) {
-      throw new RuntimeException(e);
-    } catch (UnknownHostException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  private HeldCertificate[] chain;
-  private List<X509Certificate> trustedCertificates = new ArrayList<>();
-
-  /**
-   * Configure the certificate chain to use when serving HTTPS responses. The first certificate
-   * in this chain is the server's certificate, further certificates are included in the handshake
-   * so the client can build a trusted path to a CA certificate.
-   */
-  public SslContextBuilder certificateChain(HeldCertificate... chain) {
-    this.chain = chain;
-    return this;
-  }
-
-  /**
-   * Add a certificate authority that this client trusts. Servers that provide certificate chains
-   * signed by these roots (or their intermediates) will be accepted.
-   */
-  public SslContextBuilder addTrustedCertificate(X509Certificate certificate) {
-    trustedCertificates.add(certificate);
-    return this;
-  }
-
-  public SSLContext build() throws GeneralSecurityException {
-    // Put the certificate in a key store.
-    char[] password = "password".toCharArray();
-    KeyStore keyStore = newEmptyKeyStore(password);
-
-    if (chain != null) {
-      Certificate[] certificates = new Certificate[chain.length];
-      for (int i = 0; i < chain.length; i++) {
-        certificates[i] = chain[i].certificate;
-      }
-      keyStore.setKeyEntry("private", chain[0].keyPair.getPrivate(), password, certificates);
-    }
-
-    for (int i = 0; i < trustedCertificates.size(); i++) {
-      keyStore.setCertificateEntry("cert_" + i, trustedCertificates.get(i));
-    }
-
-    // Wrap it up in an SSL context.
-    KeyManagerFactory keyManagerFactory =
-        KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
-    keyManagerFactory.init(keyStore, password);
-    TrustManagerFactory trustManagerFactory =
-        TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
-    trustManagerFactory.init(keyStore);
-    SSLContext sslContext = SSLContext.getInstance("TLS");
-    sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(),
-        new SecureRandom());
-    return sslContext;
-  }
-
-  private KeyStore newEmptyKeyStore(char[] password) throws GeneralSecurityException {
-    try {
-      KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
-      InputStream in = null; // By convention, 'null' creates an empty key store.
-      keyStore.load(in, password);
-      return keyStore;
-    } catch (IOException e) {
-      throw new AssertionError(e);
-    }
-  }
-}
diff --git a/mockwebserver/src/main/java/okhttp3/internal/framed/FramedServer.java b/mockwebserver/src/main/java/okhttp3/internal/http2/Http2Server.java
similarity index 80%
rename from mockwebserver/src/main/java/okhttp3/internal/framed/FramedServer.java
rename to mockwebserver/src/main/java/okhttp3/internal/http2/Http2Server.java
index 1cab011721..9823d01343 100644
--- a/mockwebserver/src/main/java/okhttp3/internal/framed/FramedServer.java
+++ b/mockwebserver/src/main/java/okhttp3/internal/http2/Http2Server.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package okhttp3.internal.framed;
+package okhttp3.internal.http2;
 
 import java.io.File;
 import java.io.IOException;
@@ -22,30 +22,30 @@
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 import okhttp3.Protocol;
-import okhttp3.internal.Platform;
-import okhttp3.internal.SslContextBuilder;
 import okhttp3.internal.Util;
+import okhttp3.internal.platform.Platform;
+import okhttp3.internal.tls.SslClient;
 import okio.BufferedSink;
 import okio.Okio;
 import okio.Source;
 
-/** A basic SPDY/HTTP_2 server that serves the contents of a local directory. */
-public final class FramedServer extends FramedConnection.Listener {
-  static final Logger logger = Logger.getLogger(FramedServer.class.getName());
+import static okhttp3.internal.platform.Platform.INFO;
 
-  private final List<Protocol> framedProtocols =
-      Util.immutableList(Protocol.HTTP_2, Protocol.SPDY_3);
+/** A basic HTTP/2 server that serves the contents of a local directory. */
+public final class Http2Server extends Http2Connection.Listener {
+  static final Logger logger = Logger.getLogger(Http2Server.class.getName());
 
   private final File baseDirectory;
   private final SSLSocketFactory sslSocketFactory;
 
-  public FramedServer(File baseDirectory, SSLSocketFactory sslSocketFactory) {
+  public Http2Server(File baseDirectory, SSLSocketFactory sslSocketFactory) {
     this.baseDirectory = baseDirectory;
     this.sslSocketFactory = sslSocketFactory;
   }
@@ -62,15 +62,14 @@ private void run() throws Exception {
         SSLSocket sslSocket = doSsl(socket);
         String protocolString = Platform.get().getSelectedProtocol(sslSocket);
         Protocol protocol = protocolString != null ? Protocol.get(protocolString) : null;
-        if (protocol == null || !framedProtocols.contains(protocol)) {
+        if (protocol != Protocol.HTTP_2) {
           throw new ProtocolException("Protocol " + protocol + " unsupported");
         }
-        FramedConnection framedConnection = new FramedConnection.Builder(false)
+        Http2Connection connection = new Http2Connection.Builder(false)
             .socket(sslSocket)
-            .protocol(protocol)
             .listener(this)
             .build();
-        framedConnection.start();
+        connection.start();
       } catch (IOException e) {
         logger.log(Level.INFO, "FramedServer connection failure: " + e);
         Util.closeQuietly(socket);
@@ -85,12 +84,13 @@ private SSLSocket doSsl(Socket socket) throws IOException {
     SSLSocket sslSocket = (SSLSocket) sslSocketFactory.createSocket(
         socket, socket.getInetAddress().getHostAddress(), socket.getPort(), true);
     sslSocket.setUseClientMode(false);
-    Platform.get().configureTlsExtensions(sslSocket, null, framedProtocols);
+    Platform.get().configureTlsExtensions(sslSocket, null,
+        Collections.singletonList(Protocol.HTTP_2));
     sslSocket.startHandshake();
     return sslSocket;
   }
 
-  @Override public void onStream(final FramedStream stream) throws IOException {
+  @Override public void onStream(final Http2Stream stream) throws IOException {
     try {
       List<Header> requestHeaders = stream.getRequestHeaders();
       String path = null;
@@ -116,11 +116,11 @@ private SSLSocket doSsl(Socket socket) throws IOException {
         send404(stream, path);
       }
     } catch (IOException e) {
-      System.out.println(e.getMessage());
+      Platform.get().log(INFO, "Failure serving FramedStream: " + e.getMessage(), null);
     }
   }
 
-  private void send404(FramedStream stream, String path) throws IOException {
+  private void send404(Http2Stream stream, String path) throws IOException {
     List<Header> responseHeaders = Arrays.asList(
         new Header(":status", "404"),
         new Header(":version", "HTTP/1.1"),
@@ -132,7 +132,7 @@ private void send404(FramedStream stream, String path) throws IOException {
     out.close();
   }
 
-  private void serveDirectory(FramedStream stream, File[] files) throws IOException {
+  private void serveDirectory(Http2Stream stream, File[] files) throws IOException {
     List<Header> responseHeaders = Arrays.asList(
         new Header(":status", "200"),
         new Header(":version", "HTTP/1.1"),
@@ -147,7 +147,7 @@ private void serveDirectory(FramedStream stream, File[] files) throws IOExceptio
     out.close();
   }
 
-  private void serveFile(FramedStream stream, File file) throws IOException {
+  private void serveFile(Http2Stream stream, File file) throws IOException {
     List<Header> responseHeaders = Arrays.asList(
         new Header(":status", "200"),
         new Header(":version", "HTTP/1.1"),
@@ -181,8 +181,8 @@ public static void main(String... args) throws Exception {
       return;
     }
 
-    FramedServer server = new FramedServer(new File(args[0]),
-        SslContextBuilder.localhost().getSocketFactory());
+    Http2Server server = new Http2Server(new File(args[0]),
+        SslClient.localhost().sslContext.getSocketFactory());
     server.run();
   }
 }
diff --git a/mockwebserver/src/main/java/okhttp3/internal/HeldCertificate.java b/mockwebserver/src/main/java/okhttp3/internal/tls/HeldCertificate.java
similarity index 99%
rename from mockwebserver/src/main/java/okhttp3/internal/HeldCertificate.java
rename to mockwebserver/src/main/java/okhttp3/internal/tls/HeldCertificate.java
index d6c45bd30b..a7fe81f0ef 100644
--- a/mockwebserver/src/main/java/okhttp3/internal/HeldCertificate.java
+++ b/mockwebserver/src/main/java/okhttp3/internal/tls/HeldCertificate.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal;
+package okhttp3.internal.tls;
 
 import java.math.BigInteger;
 import java.security.GeneralSecurityException;
diff --git a/mockwebserver/src/main/java/okhttp3/internal/tls/SslClient.java b/mockwebserver/src/main/java/okhttp3/internal/tls/SslClient.java
new file mode 100644
index 0000000000..8fb994394a
--- /dev/null
+++ b/mockwebserver/src/main/java/okhttp3/internal/tls/SslClient.java
@@ -0,0 +1,169 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.tls;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.security.GeneralSecurityException;
+import java.security.KeyPair;
+import java.security.KeyStore;
+import java.security.SecureRandom;
+import java.security.cert.Certificate;
+import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import javax.net.ssl.KeyManagerFactory;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.X509TrustManager;
+
+/**
+ * Combines an SSL socket factory and trust manager, a pairing enough for OkHttp or MockWebServer to
+ * create a secure connection.
+ */
+public final class SslClient {
+  private static SslClient localhost; // Lazily initialized.
+
+  public final SSLContext sslContext;
+  public final SSLSocketFactory socketFactory;
+  public final X509TrustManager trustManager;
+
+  private SslClient(SSLContext sslContext, X509TrustManager trustManager) {
+    this.sslContext = sslContext;
+    this.socketFactory = sslContext.getSocketFactory();
+    this.trustManager = trustManager;
+  }
+
+  /** Returns an SSL client for this host's localhost address. */
+  public static synchronized SslClient localhost() {
+    if (localhost != null) return localhost;
+
+    try {
+      // Generate a self-signed cert for the server to serve and the client to trust.
+      HeldCertificate heldCertificate = new HeldCertificate.Builder()
+          .serialNumber("1")
+          .commonName(InetAddress.getByName("localhost").getHostName())
+          .build();
+
+      localhost = new Builder()
+          .certificateChain(heldCertificate.keyPair, heldCertificate.certificate)
+          .addTrustedCertificate(heldCertificate.certificate)
+          .build();
+
+      return localhost;
+    } catch (GeneralSecurityException | UnknownHostException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  public static class Builder {
+    private final List<X509Certificate> chainCertificates = new ArrayList<>();
+    private final List<X509Certificate> certificates = new ArrayList<>();
+    private KeyPair keyPair;
+    private String keyStoreType = KeyStore.getDefaultType();
+
+    /**
+     * Configure the certificate chain to use when serving HTTPS responses. The first certificate is
+     * the server's certificate, further certificates are included in the handshake so the client
+     * can build a trusted path to a CA certificate.
+     */
+    public Builder certificateChain(HeldCertificate localCert, HeldCertificate... chain) {
+      X509Certificate[] certificates = new X509Certificate[chain.length];
+      for (int i = 0; i < chain.length; i++) {
+        certificates[i] = chain[i].certificate;
+      }
+      return certificateChain(localCert.keyPair, localCert.certificate, certificates);
+    }
+
+    public Builder certificateChain(KeyPair keyPair, X509Certificate keyCert,
+        X509Certificate... certificates) {
+      this.keyPair = keyPair;
+      this.chainCertificates.add(keyCert);
+      this.chainCertificates.addAll(Arrays.asList(certificates));
+      this.certificates.addAll(Arrays.asList(certificates));
+      return this;
+    }
+
+    /**
+     * Add a certificate authority that this client trusts. Servers that provide certificate chains
+     * signed by these roots (or their intermediates) will be accepted.
+     */
+    public Builder addTrustedCertificate(X509Certificate certificate) {
+      this.certificates.add(certificate);
+      return this;
+    }
+
+    public Builder keyStoreType(String keyStoreType) {
+      this.keyStoreType = keyStoreType;
+      return this;
+    }
+
+    public SslClient build() {
+      try {
+        // Put the certificate in a key store.
+        char[] password = "password".toCharArray();
+        KeyStore keyStore = newEmptyKeyStore(password);
+
+        if (keyPair != null) {
+          Certificate[] certificates = chainCertificates.toArray(
+              new Certificate[chainCertificates.size()]);
+          keyStore.setKeyEntry("private", keyPair.getPrivate(), password, certificates);
+        }
+
+        for (int i = 0; i < certificates.size(); i++) {
+          keyStore.setCertificateEntry("cert_" + i, certificates.get(i));
+        }
+
+        // Wrap it up in an SSL context.
+        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(
+            KeyManagerFactory.getDefaultAlgorithm());
+        keyManagerFactory.init(keyStore, password);
+        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+            TrustManagerFactory.getDefaultAlgorithm());
+        trustManagerFactory.init(keyStore);
+        TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
+
+        if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
+          throw new IllegalStateException("Unexpected default trust managers:"
+              + Arrays.toString(trustManagers));
+        }
+
+        SSLContext sslContext = SSLContext.getInstance("TLS");
+        sslContext.init(keyManagerFactory.getKeyManagers(), trustManagers, new SecureRandom());
+
+        return new SslClient(sslContext, (X509TrustManager) trustManagers[0]);
+      } catch (GeneralSecurityException gse) {
+        throw new AssertionError(gse);
+      }
+    }
+
+    private KeyStore newEmptyKeyStore(char[] password) throws GeneralSecurityException {
+      try {
+        KeyStore keyStore = KeyStore.getInstance(keyStoreType);
+        InputStream in = null; // By convention, 'null' creates an empty key store.
+        keyStore.load(in, password);
+        return keyStore;
+      } catch (IOException e) {
+        throw new AssertionError(e);
+      }
+    }
+  }
+}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/Dispatcher.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/Dispatcher.java
index c7cff55202..9f4fc9fb66 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/Dispatcher.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/Dispatcher.java
@@ -32,4 +32,12 @@
   public MockResponse peek() {
     return new MockResponse().setSocketPolicy(SocketPolicy.KEEP_OPEN);
   }
+
+  /**
+   * Release any resources held by this dispatcher. Any requests that are currently being dispatched
+   * should return immediately. Responses returned after shutdown will not be transmitted: their
+   * socket connections have already been closed.
+   */
+  public void shutdown() {
+  }
 }
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
index 9f56b34f99..8452b84634 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
@@ -20,8 +20,8 @@
 import java.util.concurrent.TimeUnit;
 import okhttp3.Headers;
 import okhttp3.internal.Internal;
-import okhttp3.internal.framed.Settings;
-import okhttp3.ws.WebSocketListener;
+import okhttp3.internal.http2.Settings;
+import okhttp3.WebSocketListener;
 import okio.Buffer;
 
 /** A scripted response to be replayed by the mock web server. */
@@ -38,6 +38,7 @@
   private TimeUnit throttlePeriodUnit = TimeUnit.SECONDS;
 
   private SocketPolicy socketPolicy = SocketPolicy.KEEP_OPEN;
+  private int http2ErrorCode = -1;
 
   private long bodyDelayAmount = 0;
   private TimeUnit bodyDelayUnit = TimeUnit.MILLISECONDS;
@@ -205,6 +206,20 @@ public MockResponse setSocketPolicy(SocketPolicy socketPolicy) {
     return this;
   }
 
+  public int getHttp2ErrorCode() {
+    return http2ErrorCode;
+  }
+
+  /**
+   * Sets the <a href="https://tools.ietf.org/html/rfc7540#section-7">HTTP/2 error code</a> to be
+   * returned when resetting the stream. This is only valid with {@link
+   * SocketPolicy#RESET_STREAM_AT_START}.
+   */
+  public MockResponse setHttp2ErrorCode(int http2ErrorCode) {
+    this.http2ErrorCode = http2ErrorCode;
+    return this;
+  }
+
   /**
    * Throttles the request reader and response writer to sleep for the given period after each
    * series of {@code bytesPerPeriod} bytes are transferred. Use this to simulate network behavior.
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
index 8ff4708d72..59b50c70af 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
@@ -17,7 +17,9 @@
 
 package okhttp3.mockwebserver;
 
+import java.io.Closeable;
 import java.io.IOException;
+import java.io.InterruptedIOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.ProtocolException;
@@ -57,18 +59,18 @@
 import okhttp3.Protocol;
 import okhttp3.Request;
 import okhttp3.Response;
+import okhttp3.internal.Internal;
 import okhttp3.internal.NamedRunnable;
-import okhttp3.internal.Platform;
 import okhttp3.internal.Util;
-import okhttp3.internal.framed.ErrorCode;
-import okhttp3.internal.framed.FramedConnection;
-import okhttp3.internal.framed.FramedStream;
-import okhttp3.internal.framed.Header;
-import okhttp3.internal.framed.Settings;
 import okhttp3.internal.http.HttpMethod;
+import okhttp3.internal.http2.ErrorCode;
+import okhttp3.internal.http2.Header;
+import okhttp3.internal.http2.Http2Connection;
+import okhttp3.internal.http2.Http2Stream;
+import okhttp3.internal.http2.Settings;
+import okhttp3.internal.platform.Platform;
 import okhttp3.internal.ws.RealWebSocket;
 import okhttp3.internal.ws.WebSocketProtocol;
-import okhttp3.ws.WebSocketListener;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -88,6 +90,7 @@
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY;
 import static okhttp3.mockwebserver.SocketPolicy.FAIL_HANDSHAKE;
 import static okhttp3.mockwebserver.SocketPolicy.NO_RESPONSE;
+import static okhttp3.mockwebserver.SocketPolicy.RESET_STREAM_AT_START;
 import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
 import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END;
 import static okhttp3.mockwebserver.SocketPolicy.UPGRADE_TO_SSL_AT_END;
@@ -96,7 +99,11 @@
  * A scriptable web server. Callers supply canned responses and the server replays them upon request
  * in sequence.
  */
-public final class MockWebServer implements TestRule {
+public final class MockWebServer implements TestRule, Closeable {
+  static {
+    Internal.initializeInstanceForTests();
+  }
+
   private static final X509TrustManager UNTRUSTED_TRUST_MANAGER = new X509TrustManager() {
     @Override public void checkClientTrusted(X509Certificate[] chain, String authType)
         throws CertificateException {
@@ -118,8 +125,8 @@
 
   private final Set<Socket> openClientSockets =
       Collections.newSetFromMap(new ConcurrentHashMap<Socket, Boolean>());
-  private final Set<FramedConnection> openFramedConnections =
-      Collections.newSetFromMap(new ConcurrentHashMap<FramedConnection, Boolean>());
+  private final Set<Http2Connection> openConnections =
+      Collections.newSetFromMap(new ConcurrentHashMap<Http2Connection, Boolean>());
   private final AtomicInteger requestCount = new AtomicInteger();
   private long bodyLimit = Long.MAX_VALUE;
   private ServerSocketFactory serverSocketFactory = ServerSocketFactory.getDefault();
@@ -132,8 +139,7 @@
   private int port = -1;
   private InetSocketAddress inetSocketAddress;
   private boolean protocolNegotiationEnabled = true;
-  private List<Protocol> protocols
-      = Util.immutableList(Protocol.HTTP_2, Protocol.SPDY_3, Protocol.HTTP_1_1);
+  private List<Protocol> protocols = Util.immutableList(Protocol.HTTP_2, Protocol.HTTP_1_1);
 
   private boolean started;
 
@@ -346,10 +352,11 @@ private synchronized void start(InetSocketAddress inetSocketAddress) throws IOEx
           Util.closeQuietly(s.next());
           s.remove();
         }
-        for (Iterator<FramedConnection> s = openFramedConnections.iterator(); s.hasNext(); ) {
+        for (Iterator<Http2Connection> s = openConnections.iterator(); s.hasNext(); ) {
           Util.closeQuietly(s.next());
           s.remove();
         }
+        dispatcher.shutdown();
         executor.shutdown();
       }
 
@@ -442,17 +449,18 @@ public void processConnection() throws Exception {
           socket = raw;
         }
 
-        if (protocol != Protocol.HTTP_1_1) {
+        if (protocol == Protocol.HTTP_2) {
           FramedSocketHandler framedSocketListener = new FramedSocketHandler(socket, protocol);
-          FramedConnection framedConnection = new FramedConnection.Builder(false)
+          Http2Connection connection = new Http2Connection.Builder(false)
               .socket(socket)
-              .protocol(protocol)
               .listener(framedSocketListener)
               .build();
-          framedConnection.start();
-          openFramedConnections.add(framedConnection);
+          connection.start();
+          openConnections.add(connection);
           openClientSockets.remove(socket);
           return;
+        } else if (protocol != Protocol.HTTP_1_1) {
+          throw new AssertionError();
         }
 
         BufferedSource source = Okio.buffer(Okio.source(socket));
@@ -561,8 +569,11 @@ private void processHandshakeFailure(Socket raw) throws Exception {
 
   private void dispatchBookkeepingRequest(int sequenceNumber, Socket socket)
       throws InterruptedException {
+    RecordedRequest request = new RecordedRequest(
+        null, null, null, -1, null, sequenceNumber, socket);
     requestCount.incrementAndGet();
-    dispatcher.dispatch(new RecordedRequest(null, null, null, -1, null, sequenceNumber, socket));
+    requestQueue.add(request);
+    dispatcher.dispatch(request);
   }
 
   /** @param sequenceNumber the index of this request on this connection. */
@@ -584,7 +595,7 @@ private RecordedRequest readRequest(Socket socket, BufferedSource source, Buffer
     boolean expectContinue = false;
     String header;
     while ((header = source.readUtf8LineStrict()).length() != 0) {
-      headers.add(header);
+      Internal.instance.addLenient(headers, header);
       String lowercaseHeader = header.toLowerCase(Locale.US);
       if (contentLength == -1 && lowercaseHeader.startsWith("content-length:")) {
         contentLength = Long.parseLong(header.substring(15).trim());
@@ -644,22 +655,6 @@ private void handleWebSocketUpgrade(Socket socket, BufferedSource source, Buffer
 
     writeHttpResponse(socket, sink, response);
 
-    final WebSocketListener listener = response.getWebSocketListener();
-    final CountDownLatch connectionClose = new CountDownLatch(1);
-
-    ThreadPoolExecutor replyExecutor =
-        new ThreadPoolExecutor(1, 1, 1, SECONDS, new LinkedBlockingDeque<Runnable>(),
-            Util.threadFactory(String.format("MockWebServer %s WebSocket", request.getPath()),
-                true));
-    replyExecutor.allowCoreThreadTimeOut(true);
-    final RealWebSocket webSocket =
-        new RealWebSocket(false /* is server */, source, sink, new SecureRandom(), replyExecutor,
-            listener, request.getPath()) {
-          @Override protected void close() throws IOException {
-            connectionClose.countDown();
-          }
-        };
-
     // Adapt the request and response into our Request and Response domain model.
     String scheme = request.getTlsVersion() != null ? "https" : "http";
     String authority = request.getHeader("Host"); // Has host and port.
@@ -675,16 +670,27 @@ private void handleWebSocketUpgrade(Socket socket, BufferedSource source, Buffer
         .protocol(Protocol.HTTP_1_1)
         .build();
 
-    listener.onOpen(webSocket, fancyResponse);
+    String name = request.getPath();
+    ThreadPoolExecutor replyExecutor =
+        new ThreadPoolExecutor(1, 1, 1, SECONDS, new LinkedBlockingDeque<Runnable>(),
+            Util.threadFactory(Util.format("MockWebServer %s WebSocket Replier", name), true));
+    replyExecutor.allowCoreThreadTimeOut(true);
 
-    while (webSocket.readMessage()) {
-    }
+    final CountDownLatch connectionClose = new CountDownLatch(1);
+    RealWebSocket webSocket =
+        new RealWebSocket(false /* is server */, source, sink, new SecureRandom(), replyExecutor,
+            response.getWebSocketListener(), fancyResponse, name) {
+          @Override protected void shutdown() {
+            connectionClose.countDown();
+          }
+        };
+
+    webSocket.loopReader();
 
     // Even if messages are no longer being read we need to wait for the connection close signal.
     try {
       connectionClose.await();
-    } catch (InterruptedException e) {
-      throw new RuntimeException(e);
+    } catch (InterruptedException ignored) {
     }
 
     replyExecutor.shutdown();
@@ -796,6 +802,10 @@ public void setDispatcher(Dispatcher dispatcher) {
     return "MockWebServer[" + port + "]";
   }
 
+  @Override public void close() throws IOException {
+    shutdown();
+  }
+
   /** A buffer wrapper that drops data after {@code bodyLimit} bytes. */
   private static class TruncatingBuffer implements Sink {
     private final Buffer buffer = new Buffer();
@@ -831,7 +841,7 @@ public void setDispatcher(Dispatcher dispatcher) {
   }
 
   /** Processes HTTP requests layered over framed protocols. */
-  private class FramedSocketHandler extends FramedConnection.Listener {
+  private class FramedSocketHandler extends Http2Connection.Listener {
     private final Socket socket;
     private final Protocol protocol;
     private final AtomicInteger sequenceNumber = new AtomicInteger();
@@ -841,8 +851,20 @@ private FramedSocketHandler(Socket socket, Protocol protocol) {
       this.protocol = protocol;
     }
 
-    @Override public void onStream(FramedStream stream) throws IOException {
+    @Override public void onStream(Http2Stream stream) throws IOException {
+      MockResponse peekedResponse = dispatcher.peek();
+      if (peekedResponse.getSocketPolicy() == RESET_STREAM_AT_START) {
+        try {
+          dispatchBookkeepingRequest(sequenceNumber.getAndIncrement(), socket);
+          stream.close(ErrorCode.fromHttp2(peekedResponse.getHttp2ErrorCode()));
+          return;
+        } catch (InterruptedException e) {
+          throw new InterruptedIOException();
+        }
+      }
+
       RecordedRequest request = readRequest(stream);
+      requestCount.incrementAndGet();
       requestQueue.add(request);
       MockResponse response;
       try {
@@ -857,12 +879,11 @@ private FramedSocketHandler(Socket socket, Protocol protocol) {
       }
     }
 
-    private RecordedRequest readRequest(FramedStream stream) throws IOException {
+    private RecordedRequest readRequest(Http2Stream stream) throws IOException {
       List<Header> streamHeaders = stream.getRequestHeaders();
       Headers.Builder httpHeaders = new Headers.Builder();
       String method = "<:method omitted>";
       String path = "<:path omitted>";
-      String version = protocol == Protocol.SPDY_3 ? "<:version omitted>" : "HTTP/1.1";
       for (int i = 0, size = streamHeaders.size(); i < size; i++) {
         ByteString name = streamHeaders.get(i).name;
         String value = streamHeaders.get(i).value.utf8();
@@ -870,12 +891,6 @@ private RecordedRequest readRequest(FramedStream stream) throws IOException {
           method = value;
         } else if (name.equals(Header.TARGET_PATH)) {
           path = value;
-        } else if (name.equals(Header.VERSION)) {
-          version = value;
-        } else if (protocol == Protocol.SPDY_3) {
-          for (String s : value.split("\u0000", -1)) {
-            httpHeaders.add(name.utf8(), s);
-          }
         } else if (protocol == Protocol.HTTP_2) {
           httpHeaders.add(name.utf8(), value);
         } else {
@@ -887,13 +902,13 @@ private RecordedRequest readRequest(FramedStream stream) throws IOException {
       body.writeAll(stream.getSource());
       body.close();
 
-      String requestLine = method + ' ' + path + ' ' + version;
-      List<Integer> chunkSizes = Collections.emptyList(); // No chunked encoding for SPDY.
+      String requestLine = method + ' ' + path + " HTTP/1.1";
+      List<Integer> chunkSizes = Collections.emptyList(); // No chunked encoding for HTTP/2.
       return new RecordedRequest(requestLine, httpHeaders.build(), chunkSizes, body.size(), body,
           sequenceNumber.getAndIncrement(), socket);
     }
 
-    private void writeResponse(FramedStream stream, MockResponse response) throws IOException {
+    private void writeResponse(Http2Stream stream, MockResponse response) throws IOException {
       Settings settings = response.getSettings();
       if (settings != null) {
         stream.getConnection().setSettings(settings);
@@ -902,24 +917,21 @@ private void writeResponse(FramedStream stream, MockResponse response) throws IO
       if (response.getSocketPolicy() == NO_RESPONSE) {
         return;
       }
-      List<Header> spdyHeaders = new ArrayList<>();
+      List<Header> http2Headers = new ArrayList<>();
       String[] statusParts = response.getStatus().split(" ", 2);
       if (statusParts.length != 2) {
         throw new AssertionError("Unexpected status: " + response.getStatus());
       }
       // TODO: constants for well-known header names.
-      spdyHeaders.add(new Header(Header.RESPONSE_STATUS, statusParts[1]));
-      if (protocol == Protocol.SPDY_3) {
-        spdyHeaders.add(new Header(Header.VERSION, statusParts[0]));
-      }
+      http2Headers.add(new Header(Header.RESPONSE_STATUS, statusParts[1]));
       Headers headers = response.getHeaders();
       for (int i = 0, size = headers.size(); i < size; i++) {
-        spdyHeaders.add(new Header(headers.name(i), headers.value(i)));
+        http2Headers.add(new Header(headers.name(i), headers.value(i)));
       }
 
       Buffer body = response.getBody();
       boolean closeStreamAfterHeaders = body != null || !response.getPushPromises().isEmpty();
-      stream.reply(spdyHeaders, closeStreamAfterHeaders);
+      stream.reply(http2Headers, closeStreamAfterHeaders);
       pushPromises(stream, response.getPushPromises());
       if (body != null) {
         BufferedSink sink = Okio.buffer(stream.getSink());
@@ -931,12 +943,10 @@ private void writeResponse(FramedStream stream, MockResponse response) throws IO
       }
     }
 
-    private void pushPromises(FramedStream stream, List<PushPromise> promises) throws IOException {
+    private void pushPromises(Http2Stream stream, List<PushPromise> promises) throws IOException {
       for (PushPromise pushPromise : promises) {
         List<Header> pushedHeaders = new ArrayList<>();
-        pushedHeaders.add(new Header(stream.getConnection().getProtocol() == Protocol.SPDY_3
-            ? Header.TARGET_HOST
-            : Header.TARGET_AUTHORITY, url(pushPromise.path()).host()));
+        pushedHeaders.add(new Header(Header.TARGET_AUTHORITY, url(pushPromise.path()).host()));
         pushedHeaders.add(new Header(Header.TARGET_METHOD, pushPromise.method()));
         pushedHeaders.add(new Header(Header.TARGET_PATH, pushPromise.path()));
         Headers pushPromiseHeaders = pushPromise.headers();
@@ -944,11 +954,11 @@ private void pushPromises(FramedStream stream, List<PushPromise> promises) throw
           pushedHeaders.add(new Header(pushPromiseHeaders.name(i), pushPromiseHeaders.value(i)));
         }
         String requestLine = pushPromise.method() + ' ' + pushPromise.path() + " HTTP/1.1";
-        List<Integer> chunkSizes = Collections.emptyList(); // No chunked encoding for SPDY.
+        List<Integer> chunkSizes = Collections.emptyList(); // No chunked encoding for HTTP/2.
         requestQueue.add(new RecordedRequest(requestLine, pushPromise.headers(), chunkSizes, 0,
             new Buffer(), sequenceNumber.getAndIncrement(), socket));
         boolean hasBody = pushPromise.response().getBody() != null;
-        FramedStream pushedStream =
+        Http2Stream pushedStream =
             stream.getConnection().pushStream(stream.getId(), pushedHeaders, hasBody);
         writeResponse(pushedStream, pushPromise.response());
       }
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/QueueDispatcher.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/QueueDispatcher.java
index be87280377..4071d4718b 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/QueueDispatcher.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/QueueDispatcher.java
@@ -25,6 +25,13 @@
  * #enqueueResponse(MockResponse)}.
  */
 public class QueueDispatcher extends Dispatcher {
+  /**
+   * Enqueued on shutdown to release threads waiting on {@link #dispatch}. Note that this response
+   * isn't transmitted because the connection is closed before this response is returned.
+   */
+  private static final MockResponse DEAD_LETTER = new MockResponse()
+      .setStatus("HTTP/1.1 " + 503 + " shutting down");
+
   private static final Logger logger = Logger.getLogger(QueueDispatcher.class.getName());
   protected final BlockingQueue<MockResponse> responseQueue = new LinkedBlockingQueue<>();
   private MockResponse failFastResponse;
@@ -42,7 +49,13 @@
       return failFastResponse;
     }
 
-    return responseQueue.take();
+    MockResponse result = responseQueue.take();
+
+    // If take() returned because we're shutting down, then enqueue another dead letter so that any
+    // other threads waiting on take() will also return.
+    if (result == DEAD_LETTER) responseQueue.add(DEAD_LETTER);
+
+    return result;
   }
 
   @Override public MockResponse peek() {
@@ -56,6 +69,10 @@ public void enqueueResponse(MockResponse response) {
     responseQueue.add(response);
   }
 
+  @Override public void shutdown() {
+    responseQueue.add(DEAD_LETTER);
+  }
+
   public void setFailFast(boolean failFast) {
     MockResponse failFastResponse = failFast
         ? new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_FOUND)
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java
index 3142cb0767..eddb7557a4 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java
@@ -88,5 +88,11 @@
    * Don't respond to the request but keep the socket open. For testing read response header timeout
    * issue.
    */
-  NO_RESPONSE
+  NO_RESPONSE,
+
+  /**
+   * Fail HTTP/2 requests without processing them by sending an {@linkplain
+   * MockResponse#getHttp2ErrorCode() HTTP/2 error code}.
+   */
+  RESET_STREAM_AT_START
 }
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
index 9a1b0daf8f..b0a3ec06ee 100644
--- a/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
@@ -16,6 +16,7 @@
 package okhttp3.mockwebserver;
 
 import java.io.BufferedReader;
+import java.io.Closeable;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
@@ -32,6 +33,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import okhttp3.Headers;
+import okhttp3.internal.Util;
 import org.junit.After;
 import org.junit.Rule;
 import org.junit.Test;
@@ -231,8 +233,8 @@
     long elapsedNanos = System.nanoTime() - startNanos;
     long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
 
-    assertTrue(String.format("Request + Response: %sms", elapsedMillis), elapsedMillis >= 500);
-    assertTrue(String.format("Request + Response: %sms", elapsedMillis), elapsedMillis < 1000);
+    assertTrue(Util.format("Request + Response: %sms", elapsedMillis), elapsedMillis >= 500);
+    assertTrue(Util.format("Request + Response: %sms", elapsedMillis), elapsedMillis < 1000);
   }
 
   /**
@@ -257,8 +259,8 @@
     long elapsedNanos = System.nanoTime() - startNanos;
     long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
 
-    assertTrue(String.format("Request + Response: %sms", elapsedMillis), elapsedMillis >= 500);
-    assertTrue(String.format("Request + Response: %sms", elapsedMillis), elapsedMillis < 1000);
+    assertTrue(Util.format("Request + Response: %sms", elapsedMillis), elapsedMillis >= 500);
+    assertTrue(Util.format("Request + Response: %sms", elapsedMillis), elapsedMillis < 1000);
   }
 
   /** Delay the response body by sleeping 1s. */
@@ -273,13 +275,16 @@
     assertEquals('A', in.read());
     long elapsedNanos = System.nanoTime() - startNanos;
     long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
-    assertTrue(String.format("Request + Response: %sms", elapsedMillis), elapsedMillis >= 1000);
+    assertTrue(Util.format("Request + Response: %sms", elapsedMillis), elapsedMillis >= 1000);
 
     in.close();
   }
 
   @Test public void disconnectRequestHalfway() throws IOException {
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_DURING_REQUEST_BODY));
+    // Limit the size of the request body that the server holds in memory to an arbitrary
+    // 3.5 MBytes so this test can pass on devices with little memory.
+    server.setBodyLimit(7 * 512 * 1024);
 
     HttpURLConnection connection = (HttpURLConnection) server.url("/").url().openConnection();
     connection.setRequestMethod("POST");
@@ -335,6 +340,11 @@
     server.shutdown();
   }
 
+  @Test public void closeViaClosable() throws IOException {
+    Closeable server = new MockWebServer();
+    server.close();
+  }
+
   @Test public void shutdownWithoutEnqueue() throws IOException {
     MockWebServer server = new MockWebServer();
     server.start();
@@ -381,4 +391,18 @@
     } catch (ConnectException expected) {
     }
   }
+
+  @Test public void shutdownWhileBlockedDispatching() throws Exception {
+    // Enqueue a request that'll cause MockWebServer to hang on QueueDispatcher.dispatch().
+    HttpURLConnection connection = (HttpURLConnection) server.url("/").url().openConnection();
+    connection.setReadTimeout(500);
+    try {
+      connection.getResponseCode();
+      fail();
+    } catch (SocketTimeoutException expected) {
+    }
+
+    // Shutting down the server should unblock the dispatcher.
+    server.shutdown();
+  }
 }
diff --git a/okcurl/README.md b/okcurl/README.md
index cea5be4064..4c65202b11 100644
--- a/okcurl/README.md
+++ b/okcurl/README.md
@@ -4,4 +4,4 @@ OkCurl
 _A curl for the next-generation web._
 
 OkCurl is an OkHttp-backed curl clone which allows you to test OkHttp's HTTP engine (including
-SPDY and HTTP/2) against web servers.
+HTTP/2) against web servers.
diff --git a/okcurl/pom.xml b/okcurl/pom.xml
index 63b1cc8c8b..edc86849cf 100644
--- a/okcurl/pom.xml
+++ b/okcurl/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.3.0-SNAPSHOT</version>
+    <version>3.5.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okcurl</artifactId>
diff --git a/okcurl/src/main/java/okhttp3/curl/Main.java b/okcurl/src/main/java/okhttp3/curl/Main.java
index 91d1da7cd5..ddff8e6790 100644
--- a/okcurl/src/main/java/okhttp3/curl/Main.java
+++ b/okcurl/src/main/java/okhttp3/curl/Main.java
@@ -23,7 +23,6 @@
 import io.airlift.airline.SingleCommand;
 import java.io.IOException;
 import java.io.InputStream;
-import java.security.cert.CertificateException;
 import java.security.cert.X509Certificate;
 import java.util.List;
 import java.util.Properties;
@@ -45,8 +44,9 @@
 import okhttp3.Request;
 import okhttp3.RequestBody;
 import okhttp3.Response;
-import okhttp3.internal.framed.Http2;
+import okhttp3.internal.Util;
 import okhttp3.internal.http.StatusLine;
+import okhttp3.internal.http2.Http2;
 import okio.BufferedSource;
 import okio.Okio;
 import okio.Sink;
@@ -57,6 +57,7 @@
 public class Main extends HelpOption implements Runnable {
   static final String NAME = "okcurl";
   static final int DEFAULT_TIMEOUT = -1;
+  private static Logger frameLogger;
 
   static Main fromArgs(String... args) {
     return SingleCommand.singleCommand(Main.class).parse(args);
@@ -177,7 +178,9 @@ private OkHttpClient createClient() {
       builder.readTimeout(readTimeout, SECONDS);
     }
     if (allowInsecure) {
-      builder.sslSocketFactory(createInsecureSslSocketFactory());
+      X509TrustManager trustManager = createInsecureTrustManager();
+      SSLSocketFactory sslSocketFactory = createInsecureSslSocketFactory(trustManager);
+      builder.sslSocketFactory(sslSocketFactory, trustManager);
       builder.hostnameVerifier(createInsecureHostnameVerifier());
     }
     return builder.build();
@@ -238,23 +241,24 @@ private void close() {
     client.connectionPool().evictAll(); // Close any persistent connections.
   }
 
-  private static SSLSocketFactory createInsecureSslSocketFactory() {
-    try {
-      SSLContext context = SSLContext.getInstance("TLS");
-      TrustManager permissive = new X509TrustManager() {
-        @Override public void checkClientTrusted(X509Certificate[] chain, String authType)
-            throws CertificateException {
-        }
+  private static X509TrustManager createInsecureTrustManager() {
+    return new X509TrustManager() {
+      @Override public void checkClientTrusted(X509Certificate[] chain, String authType) {
+      }
 
-        @Override public void checkServerTrusted(X509Certificate[] chain, String authType)
-            throws CertificateException {
-        }
+      @Override public void checkServerTrusted(X509Certificate[] chain, String authType) {
+      }
 
-        @Override public X509Certificate[] getAcceptedIssuers() {
-          return new X509Certificate[0];
-        }
-      };
-      context.init(null, new TrustManager[] {permissive}, null);
+      @Override public X509Certificate[] getAcceptedIssuers() {
+        return new X509Certificate[0];
+      }
+    };
+  }
+
+  private static SSLSocketFactory createInsecureSslSocketFactory(TrustManager trustManager) {
+    try {
+      SSLContext context = SSLContext.getInstance("TLS");
+      context.init(null, new TrustManager[] {trustManager}, null);
       return context.getSocketFactory();
     } catch (Exception e) {
       throw new AssertionError(e);
@@ -270,15 +274,15 @@ private static HostnameVerifier createInsecureHostnameVerifier() {
   }
 
   private static void enableHttp2FrameLogging() {
-    Logger logger = Logger.getLogger(Http2.class.getName() + "$FrameLogger");
-    logger.setLevel(Level.FINE);
+    frameLogger = Logger.getLogger(Http2.class.getName());
+    frameLogger.setLevel(Level.FINE);
     ConsoleHandler handler = new ConsoleHandler();
     handler.setLevel(Level.FINE);
     handler.setFormatter(new SimpleFormatter() {
       @Override public String format(LogRecord record) {
-        return String.format("%s%n", record.getMessage());
+        return Util.format("%s%n", record.getMessage());
       }
     });
-    logger.addHandler(handler);
+    frameLogger.addHandler(handler);
   }
 }
diff --git a/okhttp-android-support/pom.xml b/okhttp-android-support/pom.xml
index 9f6f647bc6..1485393521 100644
--- a/okhttp-android-support/pom.xml
+++ b/okhttp-android-support/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.3.0-SNAPSHOT</version>
+    <version>3.5.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-android-support</artifactId>
diff --git a/okhttp-android-support/src/main/java/okhttp3/AndroidShimResponseCache.java b/okhttp-android-support/src/main/java/okhttp3/AndroidShimResponseCache.java
index b0bb9fcf73..c46a0cb9fd 100644
--- a/okhttp-android-support/src/main/java/okhttp3/AndroidShimResponseCache.java
+++ b/okhttp-android-support/src/main/java/okhttp3/AndroidShimResponseCache.java
@@ -70,7 +70,7 @@ public Cache getCache() {
       // The URLConnection is not cacheable or could not be converted. Stop.
       return null;
     }
-    okhttp3.internal.http.CacheRequest okCacheRequest =
+    okhttp3.internal.cache.CacheRequest okCacheRequest =
         delegate.internalCache.put(okResponse);
     if (okCacheRequest == null) {
       return null;
diff --git a/okhttp-android-support/src/main/java/okhttp3/internal/huc/CacheAdapter.java b/okhttp-android-support/src/main/java/okhttp3/internal/huc/CacheAdapter.java
index 8e02239dea..5bca95b937 100644
--- a/okhttp-android-support/src/main/java/okhttp3/internal/huc/CacheAdapter.java
+++ b/okhttp-android-support/src/main/java/okhttp3/internal/huc/CacheAdapter.java
@@ -25,9 +25,9 @@
 import java.util.Map;
 import okhttp3.Request;
 import okhttp3.Response;
-import okhttp3.internal.InternalCache;
-import okhttp3.internal.http.CacheRequest;
-import okhttp3.internal.http.CacheStrategy;
+import okhttp3.internal.cache.CacheRequest;
+import okhttp3.internal.cache.CacheStrategy;
+import okhttp3.internal.cache.InternalCache;
 import okio.Okio;
 import okio.Sink;
 
@@ -78,7 +78,7 @@ public ResponseCache getDelegate() {
     // cacheable or the client should be careful about caching it.
   }
 
-  @Override public void update(Response cached, Response network) throws IOException {
+  @Override public void update(Response cached, Response network) {
     // This method is treated as optional and there is no obvious way of implementing it with
     // ResponseCache. Updating headers is useful if the server changes the metadata for a resource
     // (e.g. max age) to extend or truncate the life of that resource in the cache. If the metadata
diff --git a/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java b/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java
index 0c7a75a87e..b65d463b51 100644
--- a/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java
+++ b/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java
@@ -45,10 +45,11 @@
 import okhttp3.internal.Internal;
 import okhttp3.internal.JavaNetHeaders;
 import okhttp3.internal.Util;
-import okhttp3.internal.http.CacheRequest;
+import okhttp3.internal.cache.CacheRequest;
+import okhttp3.internal.http.HttpHeaders;
 import okhttp3.internal.http.HttpMethod;
-import okhttp3.internal.http.OkHeaders;
 import okhttp3.internal.http.StatusLine;
+import okhttp3.internal.platform.Platform;
 import okio.BufferedSource;
 import okio.Okio;
 import okio.Sink;
@@ -57,7 +58,11 @@
  * Helper methods that convert between Java and OkHttp representations.
  */
 public final class JavaApiConverter {
-  private static final RequestBody EMPTY_REQUEST_BODY = RequestBody.create(null, new byte[0]);
+  /** Synthetic response header: the local time when the request was sent. */
+  private static final String SENT_MILLIS = Platform.get().getPrefix() + "-Sent-Millis";
+
+  /** Synthetic response header: the local time when the response was received. */
+  private static final String RECEIVED_MILLIS = Platform.get().getPrefix() + "-Received-Millis";
 
   private JavaApiConverter() {
   }
@@ -85,7 +90,7 @@ public static Response createOkResponseForCachePut(URI uri, URLConnection urlCon
     // OkHttp's Call API requires a placeholder body; the real body will be streamed separately.
     String requestMethod = httpUrlConnection.getRequestMethod();
     RequestBody placeholderBody = HttpMethod.requiresRequestBody(requestMethod)
-        ? EMPTY_REQUEST_BODY
+        ? Util.EMPTY_REQUEST
         : null;
 
     Request okRequest = new Request.Builder()
@@ -106,7 +111,7 @@ public static Response createOkResponseForCachePut(URI uri, URLConnection urlCon
     okResponseBuilder.networkResponse(networkResponse);
 
     // Response headers
-    Headers okHeaders = extractOkResponseHeaders(httpUrlConnection);
+    Headers okHeaders = extractOkResponseHeaders(httpUrlConnection, okResponseBuilder);
     okResponseBuilder.headers(okHeaders);
 
     // Response body
@@ -155,11 +160,11 @@ private static Headers createHeaders(Map<String, List<String>> headers) {
   }
 
   private static Headers varyHeaders(URLConnection urlConnection, Headers responseHeaders) {
-    if (OkHeaders.hasVaryAll(responseHeaders)) {
+    if (HttpHeaders.hasVaryAll(responseHeaders)) {
       // "*" means that this will be treated as uncacheable anyway.
       return null;
     }
-    Set<String> varyFields = OkHeaders.varyFields(responseHeaders);
+    Set<String> varyFields = HttpHeaders.varyFields(responseHeaders);
     if (varyFields.isEmpty()) {
       return new Headers.Builder().build();
     }
@@ -205,11 +210,11 @@ static Response createOkResponseForCacheGet(Request request, CacheResponse javaR
     // Build a cache request for the response to use.
     Headers responseHeaders = createHeaders(javaResponse.getHeaders());
     Headers varyHeaders;
-    if (OkHeaders.hasVaryAll(responseHeaders)) {
+    if (HttpHeaders.hasVaryAll(responseHeaders)) {
       // "*" means that this will be treated as uncacheable anyway.
       varyHeaders = new Headers.Builder().build();
     } else {
-      varyHeaders = OkHeaders.varyHeaders(request.headers(), responseHeaders);
+      varyHeaders = HttpHeaders.varyHeaders(request.headers(), responseHeaders);
     }
 
     Request cacheRequest = new Request.Builder()
@@ -230,7 +235,7 @@ static Response createOkResponseForCacheGet(Request request, CacheResponse javaR
     okResponseBuilder.message(statusLine.message);
 
     // Response headers
-    Headers okHeaders = extractOkHeaders(javaResponse);
+    Headers okHeaders = extractOkHeaders(javaResponse, okResponseBuilder);
     okResponseBuilder.headers(okHeaders);
 
     // Response body
@@ -273,7 +278,7 @@ public static Request createOkRequest(
       URI uri, String requestMethod, Map<String, List<String>> requestHeaders) {
     // OkHttp's Call API requires a placeholder body; the real body will be streamed separately.
     RequestBody placeholderBody = HttpMethod.requiresRequestBody(requestMethod)
-        ? EMPTY_REQUEST_BODY
+        ? Util.EMPTY_REQUEST
         : null;
 
     Request.Builder builder = new Request.Builder()
@@ -281,7 +286,7 @@ public static Request createOkRequest(
         .method(requestMethod, placeholderBody);
 
     if (requestHeaders != null) {
-      Headers headers = extractOkHeaders(requestHeaders);
+      Headers headers = extractOkHeaders(requestHeaders, null);
       builder.headers(headers);
     }
     return builder.build();
@@ -292,7 +297,7 @@ public static Request createOkRequest(
    * from the supplied {@link Response}.
    */
   public static CacheResponse createJavaCacheResponse(final Response response) {
-    final Headers headers = response.headers();
+    final Headers headers = withSyntheticHeaders(response);
     final ResponseBody body = response.body();
     if (response.request().isHttps()) {
       final Handshake handshake = response.handshake();
@@ -382,6 +387,10 @@ public OutputStream getBody() throws IOException {
    * {@link Response}.
    */
   static HttpURLConnection createJavaUrlConnectionForCachePut(Response okResponse) {
+    okResponse = okResponse.newBuilder()
+        .body(null)
+        .headers(withSyntheticHeaders(okResponse))
+        .build();
     Request request = okResponse.request();
     // Create an object of the correct class in case the ResponseCache uses instanceof.
     if (request.isHttps()) {
@@ -391,6 +400,13 @@ static HttpURLConnection createJavaUrlConnectionForCachePut(Response okResponse)
     }
   }
 
+  private static Headers withSyntheticHeaders(Response okResponse) {
+    return okResponse.headers().newBuilder()
+        .add(SENT_MILLIS, Long.toString(okResponse.sentRequestAtMillis()))
+        .add(RECEIVED_MILLIS, Long.toString(okResponse.receivedResponseAtMillis()))
+        .build();
+  }
+
   /**
    * Extracts an immutable request header map from the supplied {@link Headers}.
    */
@@ -402,26 +418,30 @@ static HttpURLConnection createJavaUrlConnectionForCachePut(Response okResponse)
    * Extracts OkHttp headers from the supplied {@link java.net.CacheResponse}. Only real headers are
    * extracted. See {@link #extractStatusLine(java.net.CacheResponse)}.
    */
-  private static Headers extractOkHeaders(CacheResponse javaResponse) throws IOException {
+  private static Headers extractOkHeaders(
+      CacheResponse javaResponse, Response.Builder okResponseBuilder) throws IOException {
     Map<String, List<String>> javaResponseHeaders = javaResponse.getHeaders();
-    return extractOkHeaders(javaResponseHeaders);
+    return extractOkHeaders(javaResponseHeaders, okResponseBuilder);
   }
 
   /**
    * Extracts OkHttp headers from the supplied {@link java.net.HttpURLConnection}. Only real headers
    * are extracted. See {@link #extractStatusLine(java.net.HttpURLConnection)}.
    */
-  private static Headers extractOkResponseHeaders(HttpURLConnection httpUrlConnection) {
+  private static Headers extractOkResponseHeaders(
+      HttpURLConnection httpUrlConnection, Response.Builder okResponseBuilder) {
     Map<String, List<String>> javaResponseHeaders = httpUrlConnection.getHeaderFields();
-    return extractOkHeaders(javaResponseHeaders);
+    return extractOkHeaders(javaResponseHeaders, okResponseBuilder);
   }
 
   /**
    * Extracts OkHttp headers from the supplied {@link Map}. Only real headers are extracted. Any
-   * entry (one with a {@code null} key) is discarded.
+   * entry (one with a {@code null} key) is discarded. Special internal headers used to track cache
+   * metadata are omitted from the result and added to {@code okResponseBuilder} instead.
    */
   // @VisibleForTesting
-  static Headers extractOkHeaders(Map<String, List<String>> javaHeaders) {
+  static Headers extractOkHeaders(
+      Map<String, List<String>> javaHeaders, Response.Builder okResponseBuilder) {
     Headers.Builder okHeadersBuilder = new Headers.Builder();
     for (Map.Entry<String, List<String>> javaHeader : javaHeaders.entrySet()) {
       String name = javaHeader.getKey();
@@ -432,6 +452,16 @@ static Headers extractOkHeaders(Map<String, List<String>> javaHeaders) {
         // explicitly ignored because Headers.Builder does not support null keys.
         continue;
       }
+      if (okResponseBuilder != null && javaHeader.getValue().size() == 1) {
+        if (name.equals(SENT_MILLIS)) {
+          okResponseBuilder.sentRequestAtMillis(Long.valueOf(javaHeader.getValue().get(0)));
+          continue;
+        }
+        if (name.equals(RECEIVED_MILLIS)) {
+          okResponseBuilder.receivedResponseAtMillis(Long.valueOf(javaHeader.getValue().get(0)));
+          continue;
+        }
+      }
       for (String value : javaHeader.getValue()) {
         Internal.instance.addLenient(okHeadersBuilder, name, value);
       }
@@ -487,7 +517,7 @@ public MediaType contentType() {
 
       @Override
       public long contentLength() {
-        return OkHeaders.contentLength(okHeaders);
+        return HttpHeaders.contentLength(okHeaders);
       }
 
       @Override public BufferedSource source() {
@@ -827,18 +857,6 @@ public CacheHttpsURLConnection(CacheHttpURLConnection delegate) {
     @Override public SSLSocketFactory getSSLSocketFactory() {
       throw throwRequestSslAccessException();
     }
-
-    @Override public long getContentLengthLong() {
-      return delegate.getContentLengthLong();
-    }
-
-    @Override public void setFixedLengthStreamingMode(long contentLength) {
-      delegate.setFixedLengthStreamingMode(contentLength);
-    }
-
-    @Override public long getHeaderFieldLong(String field, long defaultValue) {
-      return delegate.getHeaderFieldLong(field, defaultValue);
-    }
   }
 
   private static RuntimeException throwRequestModificationException() {
diff --git a/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java
index 81aeaf2b9a..53470ce87b 100644
--- a/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java
+++ b/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java
@@ -29,16 +29,15 @@
 import java.util.Map;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLContext;
 import okhttp3.AbstractResponseCache;
 import okhttp3.OkHttpClient;
 import okhttp3.OkUrlFactory;
+import okhttp3.RecordingHostnameVerifier;
 import okhttp3.internal.Internal;
-import okhttp3.internal.InternalCache;
-import okhttp3.internal.SslContextBuilder;
+import okhttp3.internal.cache.InternalCache;
+import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.RecordingHostnameVerifier;
 import okio.Buffer;
 import org.junit.After;
 import org.junit.Before;
@@ -59,7 +58,7 @@
  * </ul>
  */
 public class CacheAdapterTest {
-  private SSLContext sslContext = SslContextBuilder.localhost();
+  private SslClient sslClient = SslClient.localhost();
   private HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
   private MockWebServer server;
   private OkHttpClient client;
@@ -84,11 +83,15 @@
     ResponseCache responseCache = new AbstractResponseCache() {
       @Override public CacheResponse get(
           URI uri, String method, Map<String, List<String>> headers) throws IOException {
-        assertEquals(toUri(serverUrl), uri);
-        assertEquals("GET", method);
-        assertTrue("Arbitrary standard header not present", headers.containsKey("User-Agent"));
-        assertEquals(Collections.singletonList("value1"), headers.get("key1"));
-        return null;
+        try {
+          assertEquals(toUri(serverUrl), uri);
+          assertEquals("GET", method);
+          assertTrue("Arbitrary standard header not present", headers.containsKey("User-Agent"));
+          assertEquals(Collections.singletonList("value1"), headers.get("key1"));
+          return null;
+        } catch (Throwable t) {
+          throw new IOException("unexpected cache failure", t);
+        }
       }
     };
     setInternalCache(new CacheAdapter(responseCache));
@@ -106,17 +109,21 @@
     ResponseCache responseCache = new AbstractResponseCache() {
       @Override public CacheResponse get(URI uri, String method, Map<String, List<String>> headers)
           throws IOException {
-        assertEquals("https", uri.getScheme());
-        assertEquals(toUri(serverUrl), uri);
-        assertEquals("GET", method);
-        assertTrue("Arbitrary standard header not present", headers.containsKey("User-Agent"));
-        assertEquals(Collections.singletonList("value1"), headers.get("key1"));
-        return null;
+        try {
+          assertEquals("https", uri.getScheme());
+          assertEquals(toUri(serverUrl), uri);
+          assertEquals("GET", method);
+          assertTrue("Arbitrary standard header not present", headers.containsKey("User-Agent"));
+          assertEquals(Collections.singletonList("value1"), headers.get("key1"));
+          return null;
+        } catch (Throwable t) {
+          throw new IOException("unexpected cache failure", t);
+        }
       }
     };
     setInternalCache(new CacheAdapter(responseCache));
     client = client.newBuilder()
-        .sslSocketFactory(sslContext.getSocketFactory())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
         .hostnameVerifier(hostnameVerifier)
         .build();
 
@@ -137,27 +144,31 @@
 
     ResponseCache responseCache = new AbstractResponseCache() {
       @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-        assertTrue(connection instanceof HttpURLConnection);
-        assertFalse(connection instanceof HttpsURLConnection);
-
-        assertEquals(response.length, connection.getContentLength());
-
-        HttpURLConnection httpUrlConnection = (HttpURLConnection) connection;
-        assertEquals("GET", httpUrlConnection.getRequestMethod());
-        assertTrue(httpUrlConnection.getDoInput());
-        assertFalse(httpUrlConnection.getDoOutput());
-
-        assertEquals("Fantastic", httpUrlConnection.getResponseMessage());
-        assertEquals(toUri(serverUrl), uri);
-        assertEquals(serverUrl, connection.getURL());
-        assertEquals("value", connection.getRequestProperty("key"));
-
-        // Check retrieval by string key.
-        assertEquals(statusLine, httpUrlConnection.getHeaderField(null));
-        assertEquals("c", httpUrlConnection.getHeaderField("A"));
-        // The RI and OkHttp supports case-insensitive matching for this method.
-        assertEquals("c", httpUrlConnection.getHeaderField("a"));
-        return null;
+        try {
+          assertTrue(connection instanceof HttpURLConnection);
+          assertFalse(connection instanceof HttpsURLConnection);
+
+          assertEquals(response.length, connection.getContentLength());
+
+          HttpURLConnection httpUrlConnection = (HttpURLConnection) connection;
+          assertEquals("GET", httpUrlConnection.getRequestMethod());
+          assertTrue(httpUrlConnection.getDoInput());
+          assertFalse(httpUrlConnection.getDoOutput());
+
+          assertEquals("Fantastic", httpUrlConnection.getResponseMessage());
+          assertEquals(toUri(serverUrl), uri);
+          assertEquals(serverUrl, connection.getURL());
+          assertEquals("value", connection.getRequestProperty("key"));
+
+          // Check retrieval by string key.
+          assertEquals(statusLine, httpUrlConnection.getHeaderField(null));
+          assertEquals("c", httpUrlConnection.getHeaderField("A"));
+          // The RI and OkHttp supports case-insensitive matching for this method.
+          assertEquals("c", httpUrlConnection.getHeaderField("a"));
+          return null;
+        } catch (Throwable t) {
+          throw new IOException("unexpected cache failure", t);
+        }
       }
     };
     setInternalCache(new CacheAdapter(responseCache));
@@ -176,27 +187,31 @@
 
     ResponseCache responseCache = new AbstractResponseCache() {
       @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-        assertTrue(connection instanceof HttpURLConnection);
-        assertFalse(connection instanceof HttpsURLConnection);
-
-        assertEquals(0, connection.getContentLength());
-
-        HttpURLConnection httpUrlConnection = (HttpURLConnection) connection;
-        assertEquals("POST", httpUrlConnection.getRequestMethod());
-        assertTrue(httpUrlConnection.getDoInput());
-        assertTrue(httpUrlConnection.getDoOutput());
-
-        assertEquals("Fantastic", httpUrlConnection.getResponseMessage());
-        assertEquals(toUri(serverUrl), uri);
-        assertEquals(serverUrl, connection.getURL());
-        assertEquals("value", connection.getRequestProperty("key"));
-
-        // Check retrieval by string key.
-        assertEquals(statusLine, httpUrlConnection.getHeaderField(null));
-        assertEquals("c", httpUrlConnection.getHeaderField("A"));
-        // The RI and OkHttp supports case-insensitive matching for this method.
-        assertEquals("c", httpUrlConnection.getHeaderField("a"));
-        return null;
+        try {
+          assertTrue(connection instanceof HttpURLConnection);
+          assertFalse(connection instanceof HttpsURLConnection);
+
+          assertEquals(0, connection.getContentLength());
+
+          HttpURLConnection httpUrlConnection = (HttpURLConnection) connection;
+          assertEquals("POST", httpUrlConnection.getRequestMethod());
+          assertTrue(httpUrlConnection.getDoInput());
+          assertTrue(httpUrlConnection.getDoOutput());
+
+          assertEquals("Fantastic", httpUrlConnection.getResponseMessage());
+          assertEquals(toUri(serverUrl), uri);
+          assertEquals(serverUrl, connection.getURL());
+          assertEquals("value", connection.getRequestProperty("key"));
+
+          // Check retrieval by string key.
+          assertEquals(statusLine, httpUrlConnection.getHeaderField(null));
+          assertEquals("c", httpUrlConnection.getHeaderField("A"));
+          // The RI and OkHttp supports case-insensitive matching for this method.
+          assertEquals("c", httpUrlConnection.getHeaderField("a"));
+          return null;
+        } catch (Throwable t) {
+          throw new IOException("unexpected cache failure", t);
+        }
       }
     };
     setInternalCache(new CacheAdapter(responseCache));
@@ -212,29 +227,33 @@
 
     ResponseCache responseCache = new AbstractResponseCache() {
       @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-        assertTrue(connection instanceof HttpsURLConnection);
-        assertEquals(toUri(serverUrl), uri);
-        assertEquals(serverUrl, connection.getURL());
-
-        HttpsURLConnection cacheHttpsUrlConnection = (HttpsURLConnection) connection;
-        HttpsURLConnection realHttpsUrlConnection =
-            (HttpsURLConnection) CacheAdapterTest.this.connection;
-        assertEquals(realHttpsUrlConnection.getCipherSuite(),
-            cacheHttpsUrlConnection.getCipherSuite());
-        assertEquals(realHttpsUrlConnection.getPeerPrincipal(),
-            cacheHttpsUrlConnection.getPeerPrincipal());
-        assertArrayEquals(realHttpsUrlConnection.getLocalCertificates(),
-            cacheHttpsUrlConnection.getLocalCertificates());
-        assertArrayEquals(realHttpsUrlConnection.getServerCertificates(),
-            cacheHttpsUrlConnection.getServerCertificates());
-        assertEquals(realHttpsUrlConnection.getLocalPrincipal(),
-            cacheHttpsUrlConnection.getLocalPrincipal());
-        return null;
+        try {
+          assertTrue(connection instanceof HttpsURLConnection);
+          assertEquals(toUri(serverUrl), uri);
+          assertEquals(serverUrl, connection.getURL());
+
+          HttpsURLConnection cacheHttpsUrlConnection = (HttpsURLConnection) connection;
+          HttpsURLConnection realHttpsUrlConnection =
+              (HttpsURLConnection) CacheAdapterTest.this.connection;
+          assertEquals(realHttpsUrlConnection.getCipherSuite(),
+              cacheHttpsUrlConnection.getCipherSuite());
+          assertEquals(realHttpsUrlConnection.getPeerPrincipal(),
+              cacheHttpsUrlConnection.getPeerPrincipal());
+          assertArrayEquals(realHttpsUrlConnection.getLocalCertificates(),
+              cacheHttpsUrlConnection.getLocalCertificates());
+          assertArrayEquals(realHttpsUrlConnection.getServerCertificates(),
+              cacheHttpsUrlConnection.getServerCertificates());
+          assertEquals(realHttpsUrlConnection.getLocalPrincipal(),
+              cacheHttpsUrlConnection.getLocalPrincipal());
+          return null;
+        } catch (Throwable t) {
+          throw new IOException("unexpected cache failure", t);
+        }
       }
     };
     setInternalCache(new CacheAdapter(responseCache));
     client = client.newBuilder()
-        .sslSocketFactory(sslContext.getSocketFactory())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
         .hostnameVerifier(hostnameVerifier)
         .build();
 
@@ -262,7 +281,7 @@ private URL configureServer(MockResponse mockResponse) throws Exception {
   }
 
   private URL configureHttpsServer(MockResponse mockResponse) throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false /* tunnelProxy */);
+    server.useHttps(sslClient.socketFactory, false /* tunnelProxy */);
     server.enqueue(mockResponse);
     server.start();
     return server.url("/").url();
diff --git a/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java
index 13f9382492..f4c9b95dab 100644
--- a/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java
+++ b/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java
@@ -597,7 +597,7 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
     javaResponseHeaders.put("key1", Arrays.asList("value1_1", "value1_2"));
     javaResponseHeaders.put("key2", Arrays.asList("value2"));
 
-    Headers okHeaders = JavaApiConverter.extractOkHeaders(javaResponseHeaders);
+    Headers okHeaders = JavaApiConverter.extractOkHeaders(javaResponseHeaders, null);
     assertEquals(3, okHeaders.size()); // null entry should be stripped out
     assertEquals(Arrays.asList("value1_1", "value1_2"), okHeaders.values("key1"));
     assertEquals(Arrays.asList("value2"), okHeaders.values("key2"));
diff --git a/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java
index a73ca54854..287b4bc662 100644
--- a/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java
+++ b/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java
@@ -54,21 +54,20 @@
 import java.util.concurrent.atomic.AtomicReference;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLContext;
 import okhttp3.AbstractResponseCache;
 import okhttp3.AndroidInternal;
 import okhttp3.AndroidShimResponseCache;
 import okhttp3.Headers;
 import okhttp3.OkHttpClient;
 import okhttp3.OkUrlFactory;
+import okhttp3.RecordingHostnameVerifier;
 import okhttp3.internal.Internal;
-import okhttp3.internal.InternalCache;
-import okhttp3.internal.SslContextBuilder;
+import okhttp3.internal.cache.InternalCache;
+import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
 import okhttp3.mockwebserver.SocketPolicy;
-import okhttp3.RecordingHostnameVerifier;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.GzipSink;
@@ -85,6 +84,7 @@
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeFalse;
 
 /**
  * Tests the interaction between OkHttp and {@link ResponseCache}. Based on okhttp3.CacheTest with
@@ -96,7 +96,7 @@
   @Rule public MockWebServer server2 = new MockWebServer();
 
   private HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-  private SSLContext sslContext = SslContextBuilder.localhost();
+  private SslClient sslClient = SslClient.localhost();
   private ResponseCache cache;
   private CookieManager cookieManager;
   private OkUrlFactory urlFactory;
@@ -191,6 +191,9 @@ private void assertCached(boolean shouldPut, int responseCode) throws Exception
       mockResponse.addHeader("Proxy-Authenticate: Basic realm=\"protected area\"");
     } else if (responseCode == HttpURLConnection.HTTP_UNAUTHORIZED) {
       mockResponse.addHeader("WWW-Authenticate: Basic realm=\"protected area\"");
+    } else if (responseCode == HttpURLConnection.HTTP_NO_CONTENT
+        || responseCode == HttpURLConnection.HTTP_RESET) {
+      mockResponse.setBody(""); // We forbid bodies for 204 and 205.
     }
     server.enqueue(mockResponse);
 
@@ -267,14 +270,16 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
   }
 
   @Test public void secureResponseCaching() throws IOException {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    assumeFalse(getPlatform().equals("jdk9"));
+
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse()
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
 
     HttpsURLConnection c1 = (HttpsURLConnection) openConnection(server.url("/").url());
-    c1.setSSLSocketFactory(sslContext.getSocketFactory());
+    c1.setSSLSocketFactory(sslClient.socketFactory);
     c1.setHostnameVerifier(hostnameVerifier);
     assertEquals("ABC", readAscii(c1));
 
@@ -286,7 +291,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     Principal localPrincipal = c1.getLocalPrincipal();
 
     HttpsURLConnection c2 = (HttpsURLConnection) openConnection(server.url("/").url()); // cached!
-    c2.setSSLSocketFactory(sslContext.getSocketFactory());
+    c2.setSSLSocketFactory(sslClient.socketFactory);
     c2.setHostnameVerifier(hostnameVerifier);
     assertEquals("ABC", readAscii(c2));
 
@@ -345,7 +350,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
   }
 
   @Test public void secureResponseCachingAndRedirects() throws IOException {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse()
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
@@ -359,7 +364,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .setBody("DEF"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslContext.getSocketFactory())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
         .hostnameVerifier(hostnameVerifier)
         .build());
 
@@ -383,7 +388,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
    * https://github.com/square/okhttp/issues/214
    */
   @Test public void secureResponseCachingAndProtocolRedirects() throws IOException {
-    server2.useHttps(sslContext.getSocketFactory(), false);
+    server2.useHttps(sslClient.socketFactory, false);
     server2.enqueue(new MockResponse()
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
@@ -398,7 +403,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .addHeader("Location: " + server2.url("/").url()));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslContext.getSocketFactory())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
         .hostnameVerifier(hostnameVerifier)
         .build());
 
@@ -1461,7 +1466,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   }
 
   @Test public void varyAndHttps() throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse()
         .addHeader("Cache-Control: max-age=60")
         .addHeader("Vary: Accept-Language")
@@ -1470,7 +1475,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("B"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslContext.getSocketFactory())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
         .hostnameVerifier(hostnameVerifier)
         .build());
 
@@ -1981,20 +1986,22 @@ private InsecureResponseCache(ResponseCache delegate) {
   }
 
   @Test public void cacheReturnsInsecureResponseForSecureRequest() throws IOException {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    assumeFalse(getPlatform().equals("jdk9"));
+
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse().setBody("ABC"));
     server.enqueue(new MockResponse().setBody("DEF"));
 
     AndroidInternal.setResponseCache(urlFactory, new InsecureResponseCache(cache));
 
     HttpsURLConnection connection1 = (HttpsURLConnection) openConnection(server.url("/").url());
-    connection1.setSSLSocketFactory(sslContext.getSocketFactory());
+    connection1.setSSLSocketFactory(sslClient.socketFactory);
     connection1.setHostnameVerifier(hostnameVerifier);
     assertEquals("ABC", readAscii(connection1));
 
     // Not cached!
     HttpsURLConnection connection2 = (HttpsURLConnection) openConnection(server.url("/").url());
-    connection2.setSSLSocketFactory(sslContext.getSocketFactory());
+    connection2.setSSLSocketFactory(sslClient.socketFactory);
     connection2.setHostnameVerifier(hostnameVerifier);
     assertEquals("DEF", readAscii(connection2));
   }
@@ -2100,11 +2107,11 @@ private InsecureResponseCache(ResponseCache delegate) {
 
     // Use the platform's HTTP stack.
     URLConnection connection = server.url("/").url().openConnection();
-    assertFalse(connection instanceof HttpURLConnectionImpl);
+    assertFalse(connection instanceof OkHttpURLConnection);
     assertEquals("A", readAscii(connection));
 
     URLConnection connection2 = server.url("/").url().openConnection();
-    assertFalse(connection2 instanceof HttpURLConnectionImpl);
+    assertFalse(connection2 instanceof OkHttpURLConnection);
     assertEquals("A", readAscii(connection2));
   }
 
@@ -2124,11 +2131,11 @@ private InsecureResponseCache(ResponseCache delegate) {
 
     // Use the platform's HTTP stack.
     URLConnection connection = server.url("/").url().openConnection();
-    assertFalse(connection instanceof HttpURLConnectionImpl);
+    assertFalse(connection instanceof OkHttpURLConnection);
     assertEquals("A", readAscii(connection));
 
     URLConnection connection2 = server.url("/").url().openConnection();
-    assertFalse(connection2 instanceof HttpURLConnectionImpl);
+    assertFalse(connection2 instanceof OkHttpURLConnection);
     assertEquals("B", readAscii(connection2));
   }
 
@@ -2148,12 +2155,12 @@ private InsecureResponseCache(ResponseCache delegate) {
 
     // Use the platform's HTTP stack.
     URLConnection connection = server.url("/").url().openConnection();
-    assertFalse(connection instanceof HttpURLConnectionImpl);
+    assertFalse(connection instanceof OkHttpURLConnection);
     connection.setRequestProperty("Accept-Language", "en-US");
     assertEquals("A", readAscii(connection));
 
     URLConnection connection2 = server.url("/").url().openConnection();
-    assertFalse(connection2 instanceof HttpURLConnectionImpl);
+    assertFalse(connection2 instanceof OkHttpURLConnection);
     assertEquals("B", readAscii(connection2));
   }
 
@@ -2173,11 +2180,11 @@ private InsecureResponseCache(ResponseCache delegate) {
 
     // Use the platform's HTTP stack.
     URLConnection connection = server.url("/").url().openConnection();
-    assertFalse(connection instanceof HttpURLConnectionImpl);
+    assertFalse(connection instanceof OkHttpURLConnection);
     assertEquals("A", readAscii(connection));
 
     URLConnection connection2 = server.url("/").url().openConnection();
-    assertFalse(connection2 instanceof HttpURLConnectionImpl);
+    assertFalse(connection2 instanceof OkHttpURLConnection);
     assertEquals("B", readAscii(connection2));
   }
 
@@ -2186,4 +2193,8 @@ private void setInternalCache(InternalCache internalCache) {
     Internal.instance.setCache(builder, internalCache);
     urlFactory.setClient(builder.build());
   }
+
+  private String getPlatform() {
+    return System.getProperty("okhttp.platform", "platform");
+  }
 }
diff --git a/okhttp-apache/pom.xml b/okhttp-apache/pom.xml
index 68fcf1add9..ed13f59fb2 100644
--- a/okhttp-apache/pom.xml
+++ b/okhttp-apache/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.3.0-SNAPSHOT</version>
+    <version>3.5.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-apache</artifactId>
diff --git a/okhttp-apache/src/main/java/okhttp3/apache/OkApacheClient.java b/okhttp-apache/src/main/java/okhttp3/apache/OkApacheClient.java
index a1af89f867..d1241d3d01 100644
--- a/okhttp-apache/src/main/java/okhttp3/apache/OkApacheClient.java
+++ b/okhttp-apache/src/main/java/okhttp3/apache/OkApacheClient.java
@@ -10,6 +10,7 @@
 import okhttp3.RequestBody;
 import okhttp3.Response;
 import okhttp3.ResponseBody;
+import okhttp3.internal.Util;
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
 import org.apache.http.HttpEntityEnclosingRequest;
@@ -66,7 +67,7 @@ private static Request transformRequest(HttpRequest request) {
           builder.header(encoding.getName(), encoding.getValue());
         }
       } else {
-        body = RequestBody.create(null, new byte[0]);
+        body = Util.EMPTY_REQUEST;
       }
     }
     builder.method(method, body);
@@ -74,7 +75,7 @@ private static Request transformRequest(HttpRequest request) {
     return builder.build();
   }
 
-  private static HttpResponse transformResponse(Response response) throws IOException {
+  private static HttpResponse transformResponse(Response response) {
     int code = response.code();
     String message = response.message();
     BasicHttpResponse httpResponse = new BasicHttpResponse(HTTP_1_1, code, message);
diff --git a/okhttp-hpacktests/pom.xml b/okhttp-hpacktests/pom.xml
index 0a64ace197..12bc4e4b49 100644
--- a/okhttp-hpacktests/pom.xml
+++ b/okhttp-hpacktests/pom.xml
@@ -8,7 +8,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.0.0-SNAPSHOT</version>
+    <version>3.5.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-hpacktests</artifactId>
@@ -19,6 +19,10 @@
       <groupId>com.squareup.okio</groupId>
       <artifactId>okio</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.squareup.moshi</groupId>
+      <artifactId>moshi</artifactId>
+    </dependency>
     <dependency>
       <groupId>${project.groupId}</groupId>
       <artifactId>okhttp</artifactId>
@@ -41,12 +45,6 @@
       <version>${project.version}</version>
       <scope>test</scope>
     </dependency>
-    <!--  Gson: Java to Json conversion -->
-    <dependency>
-      <groupId>com.google.code.gson</groupId>
-      <artifactId>gson</artifactId>
-      <scope>compile</scope>
-    </dependency>
   </dependencies>
 
   <build>
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/HpackDecodeInteropTest.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackDecodeInteropTest.java
similarity index 87%
rename from okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/HpackDecodeInteropTest.java
rename to okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackDecodeInteropTest.java
index 74ca6a2fb2..dbcc99f55f 100644
--- a/okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/HpackDecodeInteropTest.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackDecodeInteropTest.java
@@ -13,15 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.spdy;
+package okhttp3.internal.http2;
 
 import java.util.Collection;
-import okhttp3.internal.spdy.hpackjson.Story;
+import okhttp3.internal.http2.hpackjson.Story;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
-import static okhttp3.internal.spdy.hpackjson.HpackJsonUtil.storiesForCurrentDraft;
+import static okhttp3.internal.http2.hpackjson.HpackJsonUtil.storiesForCurrentDraft;
 
 @RunWith(Parameterized.class)
 public class HpackDecodeInteropTest extends HpackDecodeTestBase {
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/HpackDecodeTestBase.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackDecodeTestBase.java
similarity index 93%
rename from okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/HpackDecodeTestBase.java
rename to okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackDecodeTestBase.java
index 77c7ddf1aa..a3f69da38c 100644
--- a/okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/HpackDecodeTestBase.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackDecodeTestBase.java
@@ -13,15 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.spdy;
+package okhttp3.internal.http2;
 
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.LinkedHashSet;
 import java.util.List;
-import okhttp3.internal.spdy.hpackjson.Case;
-import okhttp3.internal.spdy.hpackjson.HpackJsonUtil;
-import okhttp3.internal.spdy.hpackjson.Story;
+import okhttp3.internal.http2.hpackjson.Case;
+import okhttp3.internal.http2.hpackjson.HpackJsonUtil;
+import okhttp3.internal.http2.hpackjson.Story;
 import okio.Buffer;
 
 import static org.junit.Assert.assertEquals;
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/HpackRoundTripTest.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackRoundTripTest.java
similarity index 93%
rename from okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/HpackRoundTripTest.java
rename to okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackRoundTripTest.java
index 22eecd7766..55325ce53d 100644
--- a/okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/HpackRoundTripTest.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackRoundTripTest.java
@@ -13,11 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.spdy;
+package okhttp3.internal.http2;
 
 import java.util.Collection;
-import okhttp3.internal.spdy.hpackjson.Case;
-import okhttp3.internal.spdy.hpackjson.Story;
+import okhttp3.internal.http2.hpackjson.Case;
+import okhttp3.internal.http2.hpackjson.Story;
 import okio.Buffer;
 import org.junit.Test;
 import org.junit.runner.RunWith;
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/hpackjson/Case.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/Case.java
similarity index 91%
rename from okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/hpackjson/Case.java
rename to okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/Case.java
index 6ff0eb0578..f1685f3800 100644
--- a/okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/hpackjson/Case.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/Case.java
@@ -13,18 +13,18 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.spdy.hpackjson;
+package okhttp3.internal.http2.hpackjson;
 
 import java.util.ArrayList;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
-import okhttp3.internal.framed.Header;
+import okhttp3.internal.http2.Header;
 import okio.ByteString;
 
 /**
  * Representation of an individual case (set of headers and wire format). There are many cases for a
- * single story.  This class is used reflectively with Gson to parse stories.
+ * single story.  This class is used reflectively with Moshi to parse stories.
  */
 public class Case implements Cloneable {
 
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/hpackjson/HpackJsonUtil.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/HpackJsonUtil.java
similarity index 80%
rename from okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/hpackjson/HpackJsonUtil.java
rename to okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/HpackJsonUtil.java
index f53ab78859..39b1489d4b 100644
--- a/okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/hpackjson/HpackJsonUtil.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/HpackJsonUtil.java
@@ -13,19 +13,18 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.spdy.hpackjson;
+package okhttp3.internal.http2.hpackjson;
 
-import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
+import com.squareup.moshi.JsonAdapter;
+import com.squareup.moshi.Moshi;
 import java.io.File;
-import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.InputStreamReader;
 import java.net.URISyntaxException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
+import okio.Okio;
 
 /**
  * Utilities for reading HPACK tests.
@@ -36,20 +35,25 @@
 
   private static final String STORY_RESOURCE_FORMAT = "/hpack-test-case/%s/story_%02d.json";
 
-  private static final Gson GSON = new GsonBuilder().create();
+  private static final Moshi MOSHI = new Moshi.Builder().build();
+  private static final JsonAdapter<Story> STORY_JSON_ADAPTER = MOSHI.adapter(Story.class);
 
   private static Story readStory(InputStream jsonResource) throws IOException {
-    return GSON.fromJson(new InputStreamReader(jsonResource, "UTF-8"), Story.class);
+    return STORY_JSON_ADAPTER.fromJson(Okio.buffer(Okio.source(jsonResource)));
+  }
+
+  private static Story readStory(File file) throws IOException {
+    return STORY_JSON_ADAPTER.fromJson(Okio.buffer(Okio.source(file)));
   }
 
   /** Iterate through the hpack-test-case resources, only picking stories for the current draft. */
   public static String[] storiesForCurrentDraft() throws URISyntaxException {
     File testCaseDirectory = new File(HpackJsonUtil.class.getResource("/hpack-test-case").toURI());
-    List<String> storyNames = new ArrayList<String>();
+    List<String> storyNames = new ArrayList<>();
     for (File path : testCaseDirectory.listFiles()) {
       if (path.isDirectory() && Arrays.asList(path.list()).contains("story_00.json")) {
         try {
-          Story firstStory = readStory(new FileInputStream(new File(path, "story_00.json")));
+          Story firstStory = readStory(new File(path, "story_00.json"));
           if (firstStory.getDraft() >= BASE_DRAFT) {
             storyNames.add(path.getName());
           }
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/hpackjson/Story.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/Story.java
similarity index 94%
rename from okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/hpackjson/Story.java
rename to okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/Story.java
index 417d426c7b..288a87b81f 100644
--- a/okhttp-hpacktests/src/test/java/okhttp3/internal/spdy/hpackjson/Story.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/Story.java
@@ -13,14 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.spdy.hpackjson;
+package okhttp3.internal.http2.hpackjson;
 
 import java.util.ArrayList;
 import java.util.List;
 
 /**
  * Representation of one story, a set of request headers to encode or decode. This class is used
- * reflectively with Gson to parse stories from files.
+ * reflectively with Moshi to parse stories from files.
  */
 public class Story implements Cloneable {
 
diff --git a/okhttp-logging-interceptor/pom.xml b/okhttp-logging-interceptor/pom.xml
index a837c6c898..5f9d7862c8 100644
--- a/okhttp-logging-interceptor/pom.xml
+++ b/okhttp-logging-interceptor/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.3.0-SNAPSHOT</version>
+    <version>3.5.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>logging-interceptor</artifactId>
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
index 532b80ce4a..c5217b16c9 100644
--- a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
+++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
@@ -30,11 +30,13 @@
 import okhttp3.RequestBody;
 import okhttp3.Response;
 import okhttp3.ResponseBody;
-import okhttp3.internal.Platform;
-import okhttp3.internal.http.HttpEngine;
+import okhttp3.internal.http.HttpHeaders;
+import okhttp3.internal.platform.Platform;
 import okio.Buffer;
 import okio.BufferedSource;
 
+import static okhttp3.internal.platform.Platform.INFO;
+
 /**
  * An OkHttp interceptor which logs request and response information. Can be applied as an
  * {@linkplain OkHttpClient#interceptors() application interceptor} or as a {@linkplain
@@ -88,7 +90,7 @@
      * Content-Length: 3
      *
      * Hi?
-     * --> END GET
+     * --> END POST
      *
      * <-- 200 OK (22ms)
      * Content-Type: plain/text
@@ -107,7 +109,7 @@
     /** A {@link Logger} defaults output appropriate for the current platform. */
     Logger DEFAULT = new Logger() {
       @Override public void log(String message) {
-        Platform.get().log(message);
+        Platform.get().log(INFO, message, null);
       }
     };
   }
@@ -205,7 +207,13 @@ public Level getLevel() {
     }
 
     long startNs = System.nanoTime();
-    Response response = chain.proceed(request);
+    Response response;
+    try {
+      response = chain.proceed(request);
+    } catch (Exception e) {
+      logger.log("<-- HTTP FAILED: " + e);
+      throw e;
+    }
     long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNs);
 
     ResponseBody responseBody = response.body();
@@ -221,7 +229,7 @@ public Level getLevel() {
         logger.log(headers.name(i) + ": " + headers.value(i));
       }
 
-      if (!logBody || !HttpEngine.hasBody(response)) {
+      if (!logBody || !HttpHeaders.hasBody(response)) {
         logger.log("<-- END HTTP");
       } else if (bodyEncoded(response.headers())) {
         logger.log("<-- END HTTP (encoded body omitted)");
@@ -266,7 +274,7 @@ public Level getLevel() {
    * Returns true if the body in question probably contains human readable text. Uses a small sample
    * of code points to detect unicode control characters commonly used in binary file signatures.
    */
-  static boolean isPlaintext(Buffer buffer) throws EOFException {
+  static boolean isPlaintext(Buffer buffer) {
     try {
       Buffer prefix = new Buffer();
       long byteCount = buffer.size() < 64 ? buffer.size() : 64;
@@ -275,7 +283,8 @@ static boolean isPlaintext(Buffer buffer) throws EOFException {
         if (prefix.exhausted()) {
           break;
         }
-        if (Character.isISOControl(prefix.readUtf8CodePoint())) {
+        int codePoint = prefix.readUtf8CodePoint();
+        if (Character.isISOControl(codePoint) && !Character.isWhitespace(codePoint)) {
           return false;
         }
       }
diff --git a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
index 3159ad2f75..caa6cd72bd 100644
--- a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
+++ b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
@@ -16,9 +16,12 @@
 package okhttp3.logging;
 
 import java.io.IOException;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.regex.Pattern;
+import okhttp3.Dns;
 import okhttp3.HttpUrl;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
@@ -193,8 +196,6 @@ private void setLevel(Level level) {
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 0")
-        .assertLogMatch("OkHttp-Sent-Millis: \\d+")
-        .assertLogMatch("OkHttp-Received-Millis: \\d+")
         .assertLogEqual("<-- END HTTP")
         .assertNoMoreLogs();
 
@@ -207,8 +208,6 @@ private void setLevel(Level level) {
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 0")
-        .assertLogMatch("OkHttp-Sent-Millis: \\d+")
-        .assertLogMatch("OkHttp-Received-Millis: \\d+")
         .assertLogEqual("<-- END HTTP")
         .assertNoMoreLogs();
   }
@@ -228,8 +227,6 @@ private void setLevel(Level level) {
         .assertLogEqual("--> END POST")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 0")
-        .assertLogMatch("OkHttp-Sent-Millis: \\d+")
-        .assertLogMatch("OkHttp-Received-Millis: \\d+")
         .assertLogEqual("<-- END HTTP")
         .assertNoMoreLogs();
 
@@ -244,8 +241,6 @@ private void setLevel(Level level) {
         .assertLogEqual("--> END POST")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 0")
-        .assertLogMatch("OkHttp-Sent-Millis: \\d+")
-        .assertLogMatch("OkHttp-Received-Millis: \\d+")
         .assertLogEqual("<-- END HTTP")
         .assertNoMoreLogs();
   }
@@ -264,8 +259,6 @@ private void setLevel(Level level) {
         .assertLogEqual("--> END POST")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 0")
-        .assertLogMatch("OkHttp-Sent-Millis: \\d+")
-        .assertLogMatch("OkHttp-Received-Millis: \\d+")
         .assertLogEqual("<-- END HTTP")
         .assertNoMoreLogs();
 
@@ -279,8 +272,6 @@ private void setLevel(Level level) {
         .assertLogEqual("--> END POST")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 0")
-        .assertLogMatch("OkHttp-Sent-Millis: \\d+")
-        .assertLogMatch("OkHttp-Received-Millis: \\d+")
         .assertLogEqual("<-- END HTTP")
         .assertNoMoreLogs();
   }
@@ -307,8 +298,6 @@ private void setLevel(Level level) {
         .assertLogEqual("--> END POST")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 0")
-        .assertLogMatch("OkHttp-Sent-Millis: \\d+")
-        .assertLogMatch("OkHttp-Received-Millis: \\d+")
         .assertLogEqual("<-- END HTTP")
         .assertNoMoreLogs();
 
@@ -323,8 +312,6 @@ private void setLevel(Level level) {
         .assertLogEqual("--> END POST")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 0")
-        .assertLogMatch("OkHttp-Sent-Millis: \\d+")
-        .assertLogMatch("OkHttp-Received-Millis: \\d+")
         .assertLogEqual("<-- END HTTP")
         .assertNoMoreLogs();
   }
@@ -344,8 +331,6 @@ private void setLevel(Level level) {
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 6")
         .assertLogEqual("Content-Type: text/plain; charset=utf-8")
-        .assertLogMatch("OkHttp-Sent-Millis: \\d+")
-        .assertLogMatch("OkHttp-Received-Millis: \\d+")
         .assertLogEqual("<-- END HTTP")
         .assertNoMoreLogs();
 
@@ -359,8 +344,6 @@ private void setLevel(Level level) {
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 6")
         .assertLogEqual("Content-Type: text/plain; charset=utf-8")
-        .assertLogMatch("OkHttp-Sent-Millis: \\d+")
-        .assertLogMatch("OkHttp-Received-Millis: \\d+")
         .assertLogEqual("<-- END HTTP")
         .assertNoMoreLogs();
   }
@@ -377,8 +360,6 @@ private void setLevel(Level level) {
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 0")
-        .assertLogMatch("OkHttp-Sent-Millis: \\d+")
-        .assertLogMatch("OkHttp-Received-Millis: \\d+")
         .assertLogEqual("<-- END HTTP (0-byte body)")
         .assertNoMoreLogs();
 
@@ -391,8 +372,6 @@ private void setLevel(Level level) {
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 0")
-        .assertLogMatch("OkHttp-Sent-Millis: \\d+")
-        .assertLogMatch("OkHttp-Received-Millis: \\d+")
         .assertLogEqual("<-- END HTTP (0-byte body)")
         .assertNoMoreLogs();
   }
@@ -418,8 +397,6 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- " + code + " No Content " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 0")
-        .assertLogMatch("OkHttp-Sent-Millis: \\d+")
-        .assertLogMatch("OkHttp-Received-Millis: \\d+")
         .assertLogEqual("<-- END HTTP (0-byte body)")
         .assertNoMoreLogs();
 
@@ -432,8 +409,6 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- " + code + " No Content " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 0")
-        .assertLogMatch("OkHttp-Sent-Millis: \\d+")
-        .assertLogMatch("OkHttp-Received-Millis: \\d+")
         .assertLogEqual("<-- END HTTP (0-byte body)")
         .assertNoMoreLogs();
   }
@@ -455,8 +430,6 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertLogEqual("--> END POST (3-byte body)")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 0")
-        .assertLogMatch("OkHttp-Sent-Millis: \\d+")
-        .assertLogMatch("OkHttp-Received-Millis: \\d+")
         .assertLogEqual("<-- END HTTP (0-byte body)")
         .assertNoMoreLogs();
 
@@ -473,8 +446,6 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertLogEqual("--> END POST (3-byte body)")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 0")
-        .assertLogMatch("OkHttp-Sent-Millis: \\d+")
-        .assertLogMatch("OkHttp-Received-Millis: \\d+")
         .assertLogEqual("<-- END HTTP (0-byte body)")
         .assertNoMoreLogs();
   }
@@ -494,8 +465,6 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 6")
         .assertLogEqual("Content-Type: text/plain; charset=utf-8")
-        .assertLogMatch("OkHttp-Sent-Millis: \\d+")
-        .assertLogMatch("OkHttp-Received-Millis: \\d+")
         .assertLogEqual("")
         .assertLogEqual("Hello!")
         .assertLogEqual("<-- END HTTP (6-byte body)")
@@ -511,8 +480,6 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 6")
         .assertLogEqual("Content-Type: text/plain; charset=utf-8")
-        .assertLogMatch("OkHttp-Sent-Millis: \\d+")
-        .assertLogMatch("OkHttp-Received-Millis: \\d+")
         .assertLogEqual("")
         .assertLogEqual("Hello!")
         .assertLogEqual("<-- END HTTP (6-byte body)")
@@ -534,8 +501,6 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Transfer-encoding: chunked")
         .assertLogEqual("Content-Type: text/plain; charset=utf-8")
-        .assertLogMatch("OkHttp-Sent-Millis: \\d+")
-        .assertLogMatch("OkHttp-Received-Millis: \\d+")
         .assertLogEqual("")
         .assertLogEqual("Hello!")
         .assertLogEqual("<-- END HTTP (6-byte body)")
@@ -551,8 +516,6 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Transfer-encoding: chunked")
         .assertLogEqual("Content-Type: text/plain; charset=utf-8")
-        .assertLogMatch("OkHttp-Sent-Millis: \\d+")
-        .assertLogMatch("OkHttp-Received-Millis: \\d+")
         .assertLogEqual("")
         .assertLogEqual("Hello!")
         .assertLogEqual("<-- END HTTP (6-byte body)")
@@ -581,8 +544,6 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertLogEqual("Content-Encoding: gzip")
         .assertLogEqual("Content-Type: text/plain; charset=utf-8")
         .assertLogMatch("Content-Length: \\d+")
-        .assertLogMatch("OkHttp-Sent-Millis: \\d+")
-        .assertLogMatch("OkHttp-Received-Millis: \\d+")
         .assertLogEqual("<-- END HTTP (encoded body omitted)")
         .assertNoMoreLogs();
 
@@ -591,8 +552,6 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Type: text/plain; charset=utf-8")
-        .assertLogMatch("OkHttp-Sent-Millis: \\d+")
-        .assertLogMatch("OkHttp-Received-Millis: \\d+")
         .assertLogEqual("")
         .assertLogEqual("Hello, Hello, Hello")
         .assertLogEqual("<-- END HTTP (19-byte body)")
@@ -618,8 +577,6 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Type: text/html; charset=0")
         .assertLogMatch("Content-Length: \\d+")
-        .assertLogMatch("OkHttp-Sent-Millis: \\d+")
-        .assertLogMatch("OkHttp-Received-Millis: \\d+")
         .assertLogMatch("")
         .assertLogEqual("Couldn't decode the response body; charset is likely malformed.")
         .assertLogEqual("<-- END HTTP")
@@ -631,8 +588,6 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Type: text/html; charset=0")
         .assertLogMatch("Content-Length: \\d+")
-        .assertLogMatch("OkHttp-Sent-Millis: \\d+")
-        .assertLogMatch("OkHttp-Received-Millis: \\d+")
         .assertLogEqual("")
         .assertLogEqual("Couldn't decode the response body; charset is likely malformed.")
         .assertLogEqual("<-- END HTTP")
@@ -642,6 +597,8 @@ private void bodyGetNoBody(int code) throws IOException {
   @Test public void isPlaintext() throws IOException {
     assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer()));
     assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer().writeUtf8("abc")));
+    assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer().writeUtf8("new\r\nlines")));
+    assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer().writeUtf8("white\t space")));
     assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer().writeByte(0x80)));
     assertFalse(HttpLoggingInterceptor.isPlaintext(new Buffer().writeByte(0x00)));
     assertFalse(HttpLoggingInterceptor.isPlaintext(new Buffer().writeByte(0xc0)));
@@ -670,8 +627,6 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 9")
         .assertLogEqual("Content-Type: image/png; charset=utf-8")
-        .assertLogMatch("OkHttp-Sent-Millis: \\d+")
-        .assertLogMatch("OkHttp-Received-Millis: \\d+")
         .assertLogEqual("")
         .assertLogEqual("<-- END HTTP (binary 9-byte body omitted)")
         .assertNoMoreLogs();
@@ -686,13 +641,34 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 9")
         .assertLogEqual("Content-Type: image/png; charset=utf-8")
-        .assertLogMatch("OkHttp-Sent-Millis: \\d+")
-        .assertLogMatch("OkHttp-Received-Millis: \\d+")
         .assertLogEqual("")
         .assertLogEqual("<-- END HTTP (binary 9-byte body omitted)")
         .assertNoMoreLogs();
   }
 
+  @Test public void connectFail() throws IOException {
+    setLevel(Level.BASIC);
+    client = new OkHttpClient.Builder()
+        .dns(new Dns() {
+          @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
+            throw new UnknownHostException("reason");
+          }
+        })
+        .addInterceptor(applicationInterceptor)
+        .build();
+
+    try {
+      client.newCall(request().build()).execute();
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("<-- HTTP FAILED: java.net.UnknownHostException: reason")
+        .assertNoMoreLogs();
+  }
+
   private Request.Builder request() {
     return new Request.Builder().url(url);
   }
diff --git a/okhttp-testing-support/pom.xml b/okhttp-testing-support/pom.xml
index 7b6ad7cd7e..18f83cc3b6 100644
--- a/okhttp-testing-support/pom.xml
+++ b/okhttp-testing-support/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.3.0-SNAPSHOT</version>
+    <version>3.5.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-testing-support</artifactId>
diff --git a/okhttp-ws-tests/fuzzingserver-config.json b/okhttp-tests/fuzzingserver-config.json
similarity index 100%
rename from okhttp-ws-tests/fuzzingserver-config.json
rename to okhttp-tests/fuzzingserver-config.json
diff --git a/okhttp-ws-tests/fuzzingserver-expected.txt b/okhttp-tests/fuzzingserver-expected.txt
similarity index 100%
rename from okhttp-ws-tests/fuzzingserver-expected.txt
rename to okhttp-tests/fuzzingserver-expected.txt
diff --git a/okhttp-ws-tests/fuzzingserver-test.sh b/okhttp-tests/fuzzingserver-test.sh
similarity index 90%
rename from okhttp-ws-tests/fuzzingserver-test.sh
rename to okhttp-tests/fuzzingserver-test.sh
index af89a42422..78ad71f59e 100755
--- a/okhttp-ws-tests/fuzzingserver-test.sh
+++ b/okhttp-tests/fuzzingserver-test.sh
@@ -21,7 +21,7 @@ set -ex
 wstest -m fuzzingserver -s fuzzingserver-config.json &
 sleep 2 # wait for wstest to start
 
-java -jar target/okhttp-ws-tests-*-jar-with-dependencies.jar
+java -jar target/okhttp-tests-*-jar-with-dependencies.jar
 
 jq '.[] as $in | $in | keys[] | . + " " + $in[.].behavior' target/fuzzingserver-report/index.json > target/fuzzingserver-actual.txt
 
diff --git a/okhttp-ws-tests/fuzzingserver-update-expected.sh b/okhttp-tests/fuzzingserver-update-expected.sh
similarity index 100%
rename from okhttp-ws-tests/fuzzingserver-update-expected.sh
rename to okhttp-tests/fuzzingserver-update-expected.sh
diff --git a/okhttp-tests/pom.xml b/okhttp-tests/pom.xml
index d9f8596922..4b3a04ac78 100644
--- a/okhttp-tests/pom.xml
+++ b/okhttp-tests/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.3.0-SNAPSHOT</version>
+    <version>3.5.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-tests</artifactId>
@@ -45,15 +45,32 @@
       <version>${project.version}</version>
       <scope>test</scope>
     </dependency>
-    <dependency>
-      <groupId>com.google.code.gson</groupId>
-      <artifactId>gson</artifactId>
-      <scope>test</scope>
-    </dependency>
   </dependencies>
 
   <build>
     <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-assembly-plugin</artifactId>
+        <configuration>
+          <descriptorRefs>
+            <descriptorRef>jar-with-dependencies</descriptorRef>
+          </descriptorRefs>
+          <archive>
+            <manifest>
+              <mainClass>okhttp3.AutobahnTester</mainClass>
+            </manifest>
+          </archive>
+        </configuration>
+        <executions>
+          <execution>
+            <phase>package</phase>
+            <goals>
+              <goal>single</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
       <!-- Do not deploy this as an artifact to Maven central. -->
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
diff --git a/okhttp-ws-tests/src/main/java/okhttp3/ws/AutobahnTester.java b/okhttp-tests/src/main/java/okhttp3/AutobahnTester.java
similarity index 84%
rename from okhttp-ws-tests/src/main/java/okhttp3/ws/AutobahnTester.java
rename to okhttp-tests/src/main/java/okhttp3/AutobahnTester.java
index 707f58c116..c9be7b6d1e 100644
--- a/okhttp-ws-tests/src/main/java/okhttp3/ws/AutobahnTester.java
+++ b/okhttp-tests/src/main/java/okhttp3/AutobahnTester.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.ws;
+package okhttp3;
 
 import java.io.IOException;
 import java.util.concurrent.CountDownLatch;
@@ -22,17 +22,12 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
 import okhttp3.internal.Version;
-import okio.Buffer;
 import okio.BufferedSource;
+import okio.ByteString;
 
-import static okhttp3.ws.WebSocket.BINARY;
-import static okhttp3.ws.WebSocket.TEXT;
+import static okhttp3.WebSocket.BINARY;
+import static okhttp3.WebSocket.TEXT;
 
 /**
  * Exercises the web socket implementation against the <a
@@ -49,7 +44,7 @@ public static void main(String... args) throws IOException {
 
   private WebSocketCall newWebSocket(String path) {
     Request request = new Request.Builder().url(HOST + path).build();
-    return WebSocketCall.create(client, request);
+    return client.newWebSocketCall(request);
   }
 
   public void run() throws IOException {
@@ -67,7 +62,7 @@ public void run() throws IOException {
     }
   }
 
-  private void runTest(final long number, final long count) throws IOException {
+  private void runTest(final long number, final long count) {
     final CountDownLatch latch = new CountDownLatch(1);
     final AtomicLong startNanos = new AtomicLong();
     newWebSocket("/runCase?case=" + number + "&agent=okhttp") //
@@ -102,7 +97,7 @@ private void runTest(final long number, final long count) throws IOException {
             });
           }
 
-          @Override public void onPong(Buffer payload) {
+          @Override public void onPong(ByteString payload) {
           }
 
           @Override public void onClose(int code, String reason) {
@@ -110,8 +105,8 @@ private void runTest(final long number, final long count) throws IOException {
             latch.countDown();
           }
 
-          @Override public void onFailure(IOException e, Response response) {
-            e.printStackTrace(System.out);
+          @Override public void onFailure(Throwable t, Response response) {
+            t.printStackTrace(System.out);
             latch.countDown();
           }
         });
@@ -131,7 +126,7 @@ private void runTest(final long number, final long count) throws IOException {
   private long getTestCount() throws IOException {
     final CountDownLatch latch = new CountDownLatch(1);
     final AtomicLong countRef = new AtomicLong();
-    final AtomicReference<IOException> failureRef = new AtomicReference<>();
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
     newWebSocket("/getCaseCount").enqueue(new WebSocketListener() {
       @Override public void onOpen(WebSocket webSocket, Response response) {
       }
@@ -141,15 +136,15 @@ private long getTestCount() throws IOException {
         message.close();
       }
 
-      @Override public void onPong(Buffer payload) {
+      @Override public void onPong(ByteString payload) {
       }
 
       @Override public void onClose(int code, String reason) {
         latch.countDown();
       }
 
-      @Override public void onFailure(IOException e, Response response) {
-        failureRef.set(e);
+      @Override public void onFailure(Throwable t, Response response) {
+        failureRef.set(t);
         latch.countDown();
       }
     });
@@ -160,9 +155,9 @@ private long getTestCount() throws IOException {
     } catch (InterruptedException e) {
       throw new AssertionError();
     }
-    IOException failure = failureRef.get();
+    Throwable failure = failureRef.get();
     if (failure != null) {
-      throw failure;
+      throw new RuntimeException(failure);
     }
     return countRef.get();
   }
@@ -176,14 +171,14 @@ private void updateReports() {
       @Override public void onMessage(ResponseBody message) throws IOException {
       }
 
-      @Override public void onPong(Buffer payload) {
+      @Override public void onPong(ByteString payload) {
       }
 
       @Override public void onClose(int code, String reason) {
         latch.countDown();
       }
 
-      @Override public void onFailure(IOException e, Response response) {
+      @Override public void onFailure(Throwable t, Response response) {
         latch.countDown();
       }
     });
diff --git a/okhttp-tests/src/test/java/okhttp3/CacheTest.java b/okhttp-tests/src/test/java/okhttp3/CacheTest.java
index 418f7bd293..f7a24c2e44 100644
--- a/okhttp-tests/src/test/java/okhttp3/CacheTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CacheTest.java
@@ -37,12 +37,12 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
 import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSession;
 import okhttp3.internal.Internal;
-import okhttp3.internal.SslContextBuilder;
 import okhttp3.internal.Util;
 import okhttp3.internal.io.InMemoryFileSystem;
+import okhttp3.internal.platform.Platform;
+import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
@@ -75,7 +75,7 @@
   @Rule public MockWebServer server2 = new MockWebServer();
   @Rule public InMemoryFileSystem fileSystem = new InMemoryFileSystem();
 
-  private final SSLContext sslContext = SslContextBuilder.localhost();
+  private final SslClient sslClient = SslClient.localhost();
   private OkHttpClient client;
   private Cache cache;
   private final CookieManager cookieManager = new CookieManager();
@@ -256,14 +256,14 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
   }
 
   @Test public void secureResponseCaching() throws IOException {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse()
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
 
     client = client.newBuilder()
-        .sslSocketFactory(sslContext.getSocketFactory())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
         .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
         .build();
 
@@ -352,7 +352,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
   }
 
   @Test public void secureResponseCachingAndRedirects() throws IOException {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse()
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
@@ -366,7 +366,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .setBody("DEF"));
 
     client = client.newBuilder()
-        .sslSocketFactory(sslContext.getSocketFactory())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
         .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
         .build();
 
@@ -392,7 +392,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
    * https://github.com/square/okhttp/issues/214
    */
   @Test public void secureResponseCachingAndProtocolRedirects() throws IOException {
-    server2.useHttps(sslContext.getSocketFactory(), false);
+    server2.useHttps(sslClient.socketFactory, false);
     server2.enqueue(new MockResponse()
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
@@ -407,7 +407,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .addHeader("Location: " + server2.url("/")));
 
     client = client.newBuilder()
-        .sslSocketFactory(sslContext.getSocketFactory())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
         .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
         .build();
 
@@ -1681,7 +1681,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   }
 
   @Test public void varyAndHttps() throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse()
         .addHeader("Cache-Control: max-age=60")
         .addHeader("Vary: Accept-Language")
@@ -1690,7 +1690,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("B"));
 
     client = client.newBuilder()
-        .sslSocketFactory(sslContext.getSocketFactory())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
         .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
         .build();
 
@@ -1981,6 +1981,7 @@ public void assertCookies(HttpUrl url, String... expectedCookies) throws Excepti
   @Test public void testGoldenCacheHttpsResponseOkHttp27() throws Exception {
     HttpUrl url = server.url("/");
     String urlKey = Util.md5Hex(url.toString());
+    String prefix = Platform.get().getPrefix();
     String entryMetadata = ""
         + "" + url + "\n"
         + "GET\n"
@@ -1988,8 +1989,8 @@ public void assertCookies(HttpUrl url, String... expectedCookies) throws Excepti
         + "HTTP/1.1 200 OK\n"
         + "4\n"
         + "Content-Length: 3\n"
-        + "OkHttp-Received-Millis: " + System.currentTimeMillis() + "\n"
-        + "OkHttp-Sent-Millis: " + System.currentTimeMillis() + "\n"
+        + prefix + "-Received-Millis: " + System.currentTimeMillis() + "\n"
+        + prefix + "-Sent-Millis: " + System.currentTimeMillis() + "\n"
         + "Cache-Control: max-age=60\n"
         + "\n"
         + "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\n"
@@ -2029,6 +2030,7 @@ public void assertCookies(HttpUrl url, String... expectedCookies) throws Excepti
   @Test public void testGoldenCacheHttpsResponseOkHttp30() throws Exception {
     HttpUrl url = server.url("/");
     String urlKey = Util.md5Hex(url.toString());
+    String prefix = Platform.get().getPrefix();
     String entryMetadata = ""
         + "" + url + "\n"
         + "GET\n"
@@ -2036,8 +2038,8 @@ public void assertCookies(HttpUrl url, String... expectedCookies) throws Excepti
         + "HTTP/1.1 200 OK\n"
         + "4\n"
         + "Content-Length: 3\n"
-        + "OkHttp-Received-Millis: " + System.currentTimeMillis() + "\n"
-        + "OkHttp-Sent-Millis: " + System.currentTimeMillis() + "\n"
+        + prefix + "-Received-Millis: " + System.currentTimeMillis() + "\n"
+        + prefix + "-Sent-Millis: " + System.currentTimeMillis() + "\n"
         + "Cache-Control: max-age=60\n"
         + "\n"
         + "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\n"
@@ -2077,6 +2079,7 @@ public void assertCookies(HttpUrl url, String... expectedCookies) throws Excepti
   @Test public void testGoldenCacheHttpResponseOkHttp30() throws Exception {
     HttpUrl url = server.url("/");
     String urlKey = Util.md5Hex(url.toString());
+    String prefix = Platform.get().getPrefix();
     String entryMetadata = ""
         + "" + url + "\n"
         + "GET\n"
@@ -2085,8 +2088,8 @@ public void assertCookies(HttpUrl url, String... expectedCookies) throws Excepti
         + "4\n"
         + "Cache-Control: max-age=60\n"
         + "Content-Length: 3\n"
-        + "OkHttp-Received-Millis: " + System.currentTimeMillis() + "\n"
-        + "OkHttp-Sent-Millis: " + System.currentTimeMillis() + "\n";
+        + prefix + "-Received-Millis: " + System.currentTimeMillis() + "\n"
+        + prefix + "-Sent-Millis: " + System.currentTimeMillis() + "\n";
     String entryBody = "abc";
     String journalBody = ""
         + "libcore.io.DiskLruCache\n"
@@ -2320,6 +2323,50 @@ public void assertCookies(HttpUrl url, String... expectedCookies) throws Excepti
     assertEquals("v2", server.takeRequest().getHeader("If-None-Match"));
   }
 
+  @Test public void combinedCacheHeadersCanBeNonAscii() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .addHeaderLenient("Alpha", "α")
+        .addHeaderLenient("β", "Beta")
+        .setBody("abcd"));
+    server.enqueue(new MockResponse()
+        .addHeader("Transfer-Encoding: none")
+        .addHeaderLenient("Gamma", "Γ")
+        .addHeaderLenient("Δ", "Delta")
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    Response response1 = get(server.url("/"));
+    assertEquals("α", response1.header("Alpha"));
+    assertEquals("Beta", response1.header("β"));
+    assertEquals("abcd", response1.body().string());
+
+    Response response2 = get(server.url("/"));
+    assertEquals("α", response2.header("Alpha"));
+    assertEquals("Beta", response2.header("β"));
+    assertEquals("Γ", response2.header("Gamma"));
+    assertEquals("Delta", response2.header("Δ"));
+    assertEquals("abcd", response2.body().string());
+  }
+
+  @Test public void etagConditionCanBeNonAscii() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeaderLenient("Etag", "α")
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("abcd"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    Response response1 = get(server.url("/"));
+    assertEquals("abcd", response1.body().string());
+
+    Response response2 = get(server.url("/"));
+    assertEquals("abcd", response2.body().string());
+
+    assertEquals(null, server.takeRequest().getHeader("If-None-Match"));
+    assertEquals("α", server.takeRequest().getHeader("If-None-Match"));
+  }
+
   private Response get(HttpUrl url) throws IOException {
     Request request = new Request.Builder()
         .url(url)
diff --git a/okhttp-tests/src/test/java/okhttp3/CallTest.java b/okhttp-tests/src/test/java/okhttp3/CallTest.java
index c097fb6bbe..bbc2a59bbd 100644
--- a/okhttp-tests/src/test/java/okhttp3/CallTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CallTest.java
@@ -34,7 +34,9 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.LinkedHashSet;
 import java.util.List;
+import java.util.Set;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.Callable;
 import java.util.concurrent.CountDownLatch;
@@ -45,8 +47,10 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import java.util.logging.SimpleFormatter;
 import javax.net.ServerSocketFactory;
-import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLProtocolException;
@@ -55,11 +59,11 @@
 import okhttp3.internal.DoubleInetAddressDns;
 import okhttp3.internal.RecordingOkAuthenticator;
 import okhttp3.internal.SingleInetAddressDns;
-import okhttp3.internal.SslContextBuilder;
 import okhttp3.internal.Util;
 import okhttp3.internal.Version;
 import okhttp3.internal.http.RecordingProxySelector;
 import okhttp3.internal.io.InMemoryFileSystem;
+import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.Dispatcher;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
@@ -79,8 +83,8 @@
 import org.junit.rules.Timeout;
 
 import static java.net.CookiePolicy.ACCEPT_ORIGINAL_SERVER;
+import static okhttp3.TestUtil.awaitGarbageCollection;
 import static okhttp3.TestUtil.defaultClient;
-import static okhttp3.internal.Internal.logger;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotSame;
@@ -94,12 +98,13 @@
   @Rule public final MockWebServer server2 = new MockWebServer();
   @Rule public final InMemoryFileSystem fileSystem = new InMemoryFileSystem();
 
-  private SSLContext sslContext = SslContextBuilder.localhost();
+  private SslClient sslClient = SslClient.localhost();
   private OkHttpClient client = defaultClient();
   private RecordingCallback callback = new RecordingCallback();
   private TestLogHandler logHandler = new TestLogHandler();
   private Cache cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
   private ServerSocket nullServer;
+  private Logger logger = Logger.getLogger(OkHttpClient.class.getName());
 
   @Before public void setUp() throws Exception {
     logger.addHandler(logHandler);
@@ -112,13 +117,25 @@
   }
 
   @Test public void get() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc").addHeader("Content-Type: text/plain"));
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .clearHeaders()
+        .addHeader("content-type: text/plain")
+        .addHeader("content-length", "3"));
 
-    executeSynchronously("/", "User-Agent", "SyncApiTest")
-        .assertCode(200)
+    long sentAt = System.currentTimeMillis();
+    RecordedResponse recordedResponse = executeSynchronously("/", "User-Agent", "SyncApiTest");
+    long receivedAt = System.currentTimeMillis();
+
+    recordedResponse.assertCode(200)
         .assertSuccessful()
-        .assertHeader("Content-Type", "text/plain")
-        .assertBody("abc");
+        .assertHeaders(new Headers.Builder()
+            .add("content-type", "text/plain")
+            .add("content-length", "3")
+            .build())
+        .assertBody("abc")
+        .assertSentRequestAtMillis(sentAt, receivedAt)
+        .assertReceivedResponseAtMillis(sentAt, receivedAt);
 
     RecordedRequest recordedRequest = server.takeRequest();
     assertEquals("GET", recordedRequest.getMethod());
@@ -169,11 +186,6 @@
     get();
   }
 
-  @Test public void get_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    get();
-  }
-
   @Test public void repeatedHeaderNames() throws Exception {
     server.enqueue(new MockResponse()
         .addHeader("B", "123")
@@ -187,11 +199,6 @@
     assertEquals(Arrays.asList("345", "456"), recordedRequest.getHeaders().values("A"));
   }
 
-  @Test public void repeatedHeaderNames_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    repeatedHeaderNames();
-  }
-
   @Test public void repeatedHeaderNames_HTTP_2() throws Exception {
     enableProtocol(Protocol.HTTP_2);
     repeatedHeaderNames();
@@ -237,11 +244,6 @@
     head();
   }
 
-  @Test public void head_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    head();
-  }
-
   @Test public void post() throws Exception {
     server.enqueue(new MockResponse().setBody("abc"));
 
@@ -271,11 +273,6 @@
     post();
   }
 
-  @Test public void post_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    post();
-  }
-
   @Test public void postZeroLength() throws Exception {
     server.enqueue(new MockResponse().setBody("abc"));
 
@@ -305,11 +302,6 @@
     postZeroLength();
   }
 
-  @Test public void postZeroLength_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    postZeroLength();
-  }
-
   @Test public void postBodyRetransmittedAfterAuthorizationFail() throws Exception {
     postBodyRetransmittedAfterAuthorizationFail("abc");
   }
@@ -324,11 +316,6 @@
     postBodyRetransmittedAfterAuthorizationFail("abc");
   }
 
-  @Test public void postBodyRetransmittedAfterAuthorizationFail_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    postBodyRetransmittedAfterAuthorizationFail("abc");
-  }
-
   /** Don't explode when resending an empty post. https://github.com/square/okhttp/issues/1131 */
   @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail() throws Exception {
     postBodyRetransmittedAfterAuthorizationFail("");
@@ -344,11 +331,6 @@
     postBodyRetransmittedAfterAuthorizationFail("");
   }
 
-  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    postBodyRetransmittedAfterAuthorizationFail("");
-  }
-
   private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exception {
     server.enqueue(new MockResponse().setResponseCode(401));
     server.enqueue(new MockResponse());
@@ -365,6 +347,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Response response = client.newCall(request).execute();
     assertEquals(200, response.code());
+    response.body().close();
 
     RecordedRequest recordedRequest1 = server.takeRequest();
     assertEquals("POST", recordedRequest1.getMethod());
@@ -440,11 +423,6 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     delete();
   }
 
-  @Test public void delete_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    delete();
-  }
-
   @Test public void deleteWithRequestBody() throws Exception {
     server.enqueue(new MockResponse().setBody("abc"));
 
@@ -491,11 +469,6 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     put();
   }
 
-  @Test public void put_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    put();
-  }
-
   @Test public void patch() throws Exception {
     server.enqueue(new MockResponse().setBody("abc"));
 
@@ -525,11 +498,6 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     patch();
   }
 
-  @Test public void patch_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    patch();
-  }
-
   @Test public void unspecifiedRequestBodyContentTypeDoesNotGetDefault() throws Exception {
     server.enqueue(new MockResponse());
 
@@ -607,6 +575,49 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     assertEquals("SyncApiTest", server.takeRequest().getHeader("User-Agent"));
   }
 
+  @Test public void legalToExecuteTwiceCloning() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Call call = client.newCall(request);
+    Response response1 = call.execute();
+
+    Call cloned = call.clone();
+    Response response2 = cloned.execute();
+
+    assertEquals(response1.body().string(), "abc");
+    assertEquals(response2.body().string(), "def");
+  }
+
+  @Test public void legalToExecuteTwiceCloning_Async() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Call call = client.newCall(request);
+    call.enqueue(callback);
+
+    Call cloned = call.clone();
+    cloned.enqueue(callback);
+
+    RecordedResponse firstResponse = callback.await(request.url()).assertSuccessful();
+    RecordedResponse secondResponse = callback.await(request.url()).assertSuccessful();
+
+    Set<String> bodies = new LinkedHashSet<>();
+    bodies.add(firstResponse.getBody());
+    bodies.add(secondResponse.getBody());
+
+    assertTrue(bodies.contains("abc"));
+    assertTrue(bodies.contains("def"));
+  }
+
   @Test public void get_Async() throws Exception {
     server.enqueue(new MockResponse()
         .setBody("abc")
@@ -734,7 +745,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
       // Timed out as expected.
       long elapsedNanos = System.nanoTime() - startNanos;
       long elapsedMillis = TimeUnit.NANOSECONDS.toMillis(elapsedNanos);
-      assertTrue(String.format("Timed out: %sms", elapsedMillis), elapsedMillis < 500);
+      assertTrue(Util.format("Timed out: %sms", elapsedMillis), elapsedMillis < 500);
     } finally {
       bodySource.close();
     }
@@ -951,14 +962,14 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   }
 
   @Test public void recoverFromTlsHandshakeFailure() throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
     server.enqueue(new MockResponse().setBody("abc"));
 
     client = client.newBuilder()
         .hostnameVerifier(new RecordingHostnameVerifier())
         .dns(new SingleInetAddressDns())
-        .sslSocketFactory(suppressTlsFallbackClientSocketFactory())
+        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
         .build();
 
     executeSynchronously("/").assertBody("abc");
@@ -967,19 +978,19 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   @Test public void recoverFromTlsHandshakeFailure_tlsFallbackScsvEnabled() throws Exception {
     final String tlsFallbackScsv = "TLS_FALLBACK_SCSV";
     List<String> supportedCiphers =
-        Arrays.asList(sslContext.getSocketFactory().getSupportedCipherSuites());
+        Arrays.asList(sslClient.socketFactory.getSupportedCipherSuites());
     if (!supportedCiphers.contains(tlsFallbackScsv)) {
       // This only works if the client socket supports TLS_FALLBACK_SCSV.
       return;
     }
 
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
 
     RecordingSSLSocketFactory clientSocketFactory =
-        new RecordingSSLSocketFactory(sslContext.getSocketFactory());
+        new RecordingSSLSocketFactory(sslClient.socketFactory);
     client = client.newBuilder()
-        .sslSocketFactory(clientSocketFactory)
+        .sslSocketFactory(clientSocketFactory, sslClient.trustManager)
         .hostnameVerifier(new RecordingHostnameVerifier())
         .dns(new SingleInetAddressDns())
         .build();
@@ -999,13 +1010,13 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   }
 
   @Test public void recoverFromTlsHandshakeFailure_Async() throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
     server.enqueue(new MockResponse().setBody("abc"));
 
     client = client.newBuilder()
         .hostnameVerifier(new RecordingHostnameVerifier())
-        .sslSocketFactory(suppressTlsFallbackClientSocketFactory())
+        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
         .build();
 
     Request request = new Request.Builder()
@@ -1021,10 +1032,10 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT))
         .hostnameVerifier(new RecordingHostnameVerifier())
         .dns(new SingleInetAddressDns())
-        .sslSocketFactory(suppressTlsFallbackClientSocketFactory())
+        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
         .build();
 
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
 
     Request request = new Request.Builder().url(server.url("/")).build();
@@ -1051,7 +1062,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
       client.newCall(request).execute();
       fail();
     } catch (UnknownServiceException expected) {
-      assertTrue(expected.getMessage().contains("CLEARTEXT communication not supported"));
+      assertEquals("CLEARTEXT communication not enabled for client", expected.getMessage());
     }
   }
 
@@ -1177,31 +1188,48 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     // Store a response in the cache.
     HttpUrl url = server.url("/");
+    long request1SentAt = System.currentTimeMillis();
     executeSynchronously("/", "Accept-Language", "fr-CA", "Accept-Charset", "UTF-8")
         .assertCode(200)
         .assertBody("A");
+    long request1ReceivedAt = System.currentTimeMillis();
     assertNull(server.takeRequest().getHeader("If-None-Match"));
 
     // Hit that stored response. It's different, but Vary says it doesn't matter.
+    Thread.sleep(10); // Make sure the timestamps are unique.
     RecordedResponse cacheHit = executeSynchronously(
         "/", "Accept-Language", "en-US", "Accept-Charset", "UTF-8");
 
     // Check the merged response. The request is the application's original request.
     cacheHit.assertCode(200)
         .assertBody("A")
-        .assertHeader("ETag", "v1")
+        .assertHeaders(new Headers.Builder()
+            .add("ETag", "v1")
+            .add("Cache-Control", "max-age=60")
+            .add("Vary", "Accept-Charset")
+            .add("Content-Length", "1")
+            .build())
         .assertRequestUrl(url)
         .assertRequestHeader("Accept-Language", "en-US")
-        .assertRequestHeader("Accept-Charset", "UTF-8");
+        .assertRequestHeader("Accept-Charset", "UTF-8")
+        .assertSentRequestAtMillis(request1SentAt, request1ReceivedAt)
+        .assertReceivedResponseAtMillis(request1SentAt, request1ReceivedAt);
 
     // Check the cached response. Its request contains only the saved Vary headers.
     cacheHit.cacheResponse()
         .assertCode(200)
-        .assertHeader("ETag", "v1")
+        .assertHeaders(new Headers.Builder()
+            .add("ETag", "v1")
+            .add("Cache-Control", "max-age=60")
+            .add("Vary", "Accept-Charset")
+            .add("Content-Length", "1")
+            .build())
         .assertRequestMethod("GET")
         .assertRequestUrl(url)
         .assertRequestHeader("Accept-Language")
-        .assertRequestHeader("Accept-Charset", "UTF-8");
+        .assertRequestHeader("Accept-Charset", "UTF-8")
+        .assertSentRequestAtMillis(request1SentAt, request1ReceivedAt)
+        .assertReceivedResponseAtMillis(request1SentAt, request1ReceivedAt);
 
     cacheHit.assertNoNetworkResponse();
   }
@@ -1221,15 +1249,20 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .build();
 
     // Store a response in the cache.
+    long request1At = System.currentTimeMillis();
     executeSynchronously("/", "Accept-Language", "fr-CA", "Accept-Charset", "UTF-8")
         .assertCode(200)
         .assertHeader("Donut", "a")
         .assertBody("A");
+    long request1ReceivedAt = System.currentTimeMillis();
     assertNull(server.takeRequest().getHeader("If-None-Match"));
 
     // Hit that stored response. It's different, but Vary says it doesn't matter.
+    Thread.sleep(10); // Make sure the timestamps are unique.
+    long request2SentAt = System.currentTimeMillis();
     RecordedResponse cacheHit = executeSynchronously(
         "/", "Accept-Language", "en-US", "Accept-Charset", "UTF-8");
+    long request2ReceivedAt = System.currentTimeMillis();
     assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
 
     // Check the merged response. The request is the application's original request.
@@ -1239,7 +1272,9 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertRequestUrl(server.url("/"))
         .assertRequestHeader("Accept-Language", "en-US")
         .assertRequestHeader("Accept-Charset", "UTF-8")
-        .assertRequestHeader("If-None-Match"); // No If-None-Match on the user's request.
+        .assertRequestHeader("If-None-Match") // No If-None-Match on the user's request.
+        .assertSentRequestAtMillis(request1At, request1ReceivedAt)
+        .assertReceivedResponseAtMillis(request1At, request1ReceivedAt);
 
     // Check the cached response. Its request contains only the saved Vary headers.
     cacheHit.cacheResponse()
@@ -1249,7 +1284,9 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertRequestUrl(server.url("/"))
         .assertRequestHeader("Accept-Language") // No Vary on Accept-Language.
         .assertRequestHeader("Accept-Charset", "UTF-8") // Because of Vary on Accept-Charset.
-        .assertRequestHeader("If-None-Match"); // This wasn't present in the original request.
+        .assertRequestHeader("If-None-Match") // This wasn't present in the original request.
+        .assertSentRequestAtMillis(request1At, request1ReceivedAt)
+        .assertReceivedResponseAtMillis(request1At, request1ReceivedAt);
 
     // Check the network response. It has the caller's request, plus some caching headers.
     cacheHit.networkResponse()
@@ -1257,7 +1294,9 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertHeader("Donut", "b")
         .assertRequestHeader("Accept-Language", "en-US")
         .assertRequestHeader("Accept-Charset", "UTF-8")
-        .assertRequestHeader("If-None-Match", "v1"); // If-None-Match in the validation request.
+        .assertRequestHeader("If-None-Match", "v1") // If-None-Match in the validation request.
+        .assertSentRequestAtMillis(request2SentAt, request2ReceivedAt)
+        .assertReceivedResponseAtMillis(request2SentAt, request2ReceivedAt);
   }
 
   @Test public void conditionalCacheHit_Async() throws Exception {
@@ -1299,35 +1338,46 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .cache(cache)
         .build();
 
+    long request1SentAt = System.currentTimeMillis();
     executeSynchronously("/", "Accept-Language", "fr-CA", "Accept-Charset", "UTF-8")
         .assertCode(200)
         .assertBody("A");
+    long request1ReceivedAt = System.currentTimeMillis();
     assertNull(server.takeRequest().getHeader("If-None-Match"));
 
     // Different request, but Vary says it doesn't matter.
-    RecordedResponse cacheHit = executeSynchronously(
+    Thread.sleep(10); // Make sure the timestamps are unique.
+    long request2SentAt = System.currentTimeMillis();
+    RecordedResponse cacheMiss = executeSynchronously(
         "/", "Accept-Language", "en-US", "Accept-Charset", "UTF-8");
+    long request2ReceivedAt = System.currentTimeMillis();
     assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
 
     // Check the user response. It has the application's original request.
-    cacheHit.assertCode(200)
+    cacheMiss.assertCode(200)
         .assertBody("B")
         .assertHeader("Donut", "b")
-        .assertRequestUrl(server.url("/"));
+        .assertRequestUrl(server.url("/"))
+        .assertSentRequestAtMillis(request2SentAt, request2ReceivedAt)
+        .assertReceivedResponseAtMillis(request2SentAt, request2ReceivedAt);
 
     // Check the cache response. Even though it's a miss, we used the cache.
-    cacheHit.cacheResponse()
+    cacheMiss.cacheResponse()
         .assertCode(200)
         .assertHeader("Donut", "a")
         .assertHeader("ETag", "v1")
-        .assertRequestUrl(server.url("/"));
+        .assertRequestUrl(server.url("/"))
+        .assertSentRequestAtMillis(request1SentAt, request1ReceivedAt)
+        .assertReceivedResponseAtMillis(request1SentAt, request1ReceivedAt);
 
     // Check the network response. It has the network request, plus caching headers.
-    cacheHit.networkResponse()
+    cacheMiss.networkResponse()
         .assertCode(200)
         .assertHeader("Donut", "b")
         .assertRequestHeader("If-None-Match", "v1")  // If-None-Match in the validation request.
-        .assertRequestUrl(server.url("/"));
+        .assertRequestUrl(server.url("/"))
+        .assertSentRequestAtMillis(request2SentAt, request2ReceivedAt)
+        .assertReceivedResponseAtMillis(request2SentAt, request2ReceivedAt);
   }
 
   @Test public void conditionalCacheMiss_Async() throws Exception {
@@ -1466,17 +1516,21 @@ private void enqueueRequestTimeoutResponses() {
     assertEquals("Hello", request2.getBody().readUtf8());
   }
 
-  @Test public void propfindRedirectsToPropfind() throws Exception {
+  @Test public void propfindRedirectsToPropfindAndMaintainsRequestBody() throws Exception {
+    // given
     server.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .addHeader("Location: /page2")
         .setBody("This page has moved!"));
     server.enqueue(new MockResponse().setBody("Page 2"));
 
+    // when
     Response response = client.newCall(new Request.Builder()
         .url(server.url("/page1"))
         .method("PROPFIND", RequestBody.create(MediaType.parse("text/plain"), "Request Body"))
         .build()).execute();
+
+    // then
     assertEquals("Page 2", response.body().string());
 
     RecordedRequest page1 = server.takeRequest();
@@ -1485,6 +1539,7 @@ private void enqueueRequestTimeoutResponses() {
 
     RecordedRequest page2 = server.takeRequest();
     assertEquals("PROPFIND /page2 HTTP/1.1", page2.getRequestLine());
+    assertEquals("Request Body", page2.getBody().readUtf8());
   }
 
   @Test public void responseCookies() throws Exception {
@@ -1741,7 +1796,7 @@ private InetSocketAddress startNullServer() throws IOException {
         .build());
     call.enqueue(callback);
     call.cancel();
-    callback.await(server.url("/a")).assertFailure("Canceled");
+    callback.await(server.url("/a")).assertFailure("Canceled", "Socket closed");
   }
 
   @Test public void cancelAll() throws Exception {
@@ -1750,7 +1805,7 @@ private InetSocketAddress startNullServer() throws IOException {
         .build());
     call.enqueue(callback);
     client.dispatcher().cancelAll();
-    callback.await(server.url("/")).assertFailure("Canceled");
+    callback.await(server.url("/")).assertFailure("Canceled", "Socket closed");
   }
 
   @Test public void cancelBeforeBodyIsRead() throws Exception {
@@ -1803,17 +1858,17 @@ private InetSocketAddress startNullServer() throws IOException {
     cancelInFlightBeforeResponseReadThrowsIOE();
   }
 
-  @Test public void cancelInFlightBeforeResponseReadThrowsIOE_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    cancelInFlightBeforeResponseReadThrowsIOE();
-  }
-
   /**
    * This test puts a request in front of one that is to be canceled, so that it is canceled before
    * I/O takes place.
    */
   @Test public void canceledBeforeIOSignalsOnFailure() throws Exception {
-    client.dispatcher().setMaxRequests(1); // Force requests to be executed serially.
+    // Force requests to be executed serially.
+    okhttp3.Dispatcher dispatcher = new okhttp3.Dispatcher(client.dispatcher().executorService());
+    dispatcher.setMaxRequests(1);
+    client = client.newBuilder()
+        .dispatcher(dispatcher)
+        .build();
 
     Request requestA = new Request.Builder().url(server.url("/a")).build();
     Request requestB = new Request.Builder().url(server.url("/b")).build();
@@ -1835,7 +1890,7 @@ private InetSocketAddress startNullServer() throws IOException {
 
     callback.await(requestA.url()).assertBody("A");
     // At this point we know the callback is ready, and that it will receive a cancel failure.
-    callback.await(requestB.url()).assertFailure("Canceled");
+    callback.await(requestB.url()).assertFailure("Canceled", "Socket closed");
   }
 
   @Test public void canceledBeforeIOSignalsOnFailure_HTTPS() throws Exception {
@@ -1848,11 +1903,6 @@ private InetSocketAddress startNullServer() throws IOException {
     canceledBeforeIOSignalsOnFailure();
   }
 
-  @Test public void canceledBeforeIOSignalsOnFailure_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    canceledBeforeIOSignalsOnFailure();
-  }
-
   @Test public void canceledBeforeResponseReadSignalsOnFailure() throws Exception {
     Request requestA = new Request.Builder().url(server.url("/a")).build();
     final Call call = client.newCall(requestA);
@@ -1880,11 +1930,6 @@ private InetSocketAddress startNullServer() throws IOException {
     canceledBeforeResponseReadSignalsOnFailure();
   }
 
-  @Test public void canceledBeforeResponseReadSignalsOnFailure_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    canceledBeforeResponseReadSignalsOnFailure();
-  }
-
   /**
    * There's a race condition where the cancel may apply after the stream has already been
    * processed.
@@ -1934,12 +1979,6 @@ private InetSocketAddress startNullServer() throws IOException {
     canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce();
   }
 
-  @Test public void canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce_SPDY_3()
-      throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce();
-  }
-
   @Test public void cancelWithInterceptor() throws Exception {
     client = client.newBuilder()
         .addInterceptor(new Interceptor() {
@@ -2154,7 +2193,7 @@ private InetSocketAddress startNullServer() throws IOException {
 
   /** Test which headers are sent unencrypted to the HTTP proxy. */
   @Test public void proxyConnectOmitsApplicationHeaders() throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), true);
+    server.useHttps(sslClient.socketFactory, true);
     server.enqueue(new MockResponse()
         .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
         .clearHeaders());
@@ -2163,7 +2202,7 @@ private InetSocketAddress startNullServer() throws IOException {
 
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
     client = client.newBuilder()
-        .sslSocketFactory(sslContext.getSocketFactory())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
         .proxy(server.toProxyAddress())
         .hostnameVerifier(hostnameVerifier)
         .build();
@@ -2191,7 +2230,7 @@ private InetSocketAddress startNullServer() throws IOException {
 
   /** Respond to a proxy authorization challenge. */
   @Test public void proxyAuthenticateOnConnect() throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), true);
+    server.useHttps(sslClient.socketFactory, true);
     server.enqueue(new MockResponse()
         .setResponseCode(407)
         .addHeader("Proxy-Authenticate: Basic realm=\"localhost\""));
@@ -2202,7 +2241,7 @@ private InetSocketAddress startNullServer() throws IOException {
         .setBody("response body"));
 
     client = client.newBuilder()
-        .sslSocketFactory(sslContext.getSocketFactory())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
         .proxy(server.toProxyAddress())
         .proxyAuthenticator(new RecordingOkAuthenticator("password"))
         .hostnameVerifier(new RecordingHostnameVerifier())
@@ -2256,11 +2295,11 @@ private InetSocketAddress startNullServer() throws IOException {
   }
 
   /**
-   * OkHttp has a bug where a `Connection: close` response header is not honored when establishing
-   * a TLS tunnel. https://github.com/square/okhttp/issues/2426
+   * OkHttp has a bug where a `Connection: close` response header is not honored when establishing a
+   * TLS tunnel. https://github.com/square/okhttp/issues/2426
    */
   @Test public void proxyAuthenticateOnConnectWithConnectionClose() throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), true);
+    server.useHttps(sslClient.socketFactory, true);
     server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
     server.enqueue(new MockResponse()
         .setResponseCode(407)
@@ -2273,7 +2312,7 @@ private InetSocketAddress startNullServer() throws IOException {
         .setBody("response body"));
 
     client = client.newBuilder()
-        .sslSocketFactory(sslContext.getSocketFactory())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
         .proxy(server.toProxyAddress())
         .proxyAuthenticator(new RecordingOkAuthenticator("password"))
         .hostnameVerifier(new RecordingHostnameVerifier())
@@ -2296,7 +2335,7 @@ private InetSocketAddress startNullServer() throws IOException {
   }
 
   @Test public void tooManyProxyAuthFailuresWithConnectionClose() throws IOException {
-    server.useHttps(sslContext.getSocketFactory(), true);
+    server.useHttps(sslClient.socketFactory, true);
     server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
     for (int i = 0; i < 21; i++) {
       server.enqueue(new MockResponse()
@@ -2306,7 +2345,7 @@ private InetSocketAddress startNullServer() throws IOException {
     }
 
     client = client.newBuilder()
-        .sslSocketFactory(sslContext.getSocketFactory())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
         .proxy(server.toProxyAddress())
         .proxyAuthenticator(new RecordingOkAuthenticator("password"))
         .hostnameVerifier(new RecordingHostnameVerifier())
@@ -2328,7 +2367,7 @@ private InetSocketAddress startNullServer() throws IOException {
    * credentials. Worse, that approach leaks proxy credentials to the origin server.
    */
   @Test public void noProactiveProxyAuthorization() throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), true);
+    server.useHttps(sslClient.socketFactory, true);
     server.enqueue(new MockResponse()
         .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
         .clearHeaders());
@@ -2336,7 +2375,7 @@ private InetSocketAddress startNullServer() throws IOException {
         .setBody("response body"));
 
     client = client.newBuilder()
-        .sslSocketFactory(sslContext.getSocketFactory())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
         .proxy(server.toProxyAddress())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build();
@@ -2484,7 +2523,7 @@ private void upload(
   /** https://github.com/square/okhttp/issues/2344 */
   @Test public void ipv6HostHasSquareBraces() throws Exception {
     // Use a proxy to fake IPv6 connectivity, even if localhost doesn't have IPv6.
-    server.useHttps(sslContext.getSocketFactory(), true);
+    server.useHttps(sslClient.socketFactory, true);
     server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
     server.enqueue(new MockResponse()
         .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
@@ -2493,7 +2532,7 @@ private void upload(
         .setBody("response body"));
 
     client = client.newBuilder()
-        .sslSocketFactory(sslContext.getSocketFactory())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
         .hostnameVerifier(new RecordingHostnameVerifier())
         .proxy(server.toProxyAddress())
         .build();
@@ -2543,6 +2582,78 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
         .assertBody("");
   }
 
+  @Test public void leakedResponseBodyLogsStackTrace() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("This gets leaked."));
+
+    client = new OkHttpClient.Builder()
+        .connectionPool(new ConnectionPool(0, 10, TimeUnit.MILLISECONDS))
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Level original = logger.getLevel();
+    logger.setLevel(Level.FINE);
+    logHandler.setFormatter(new SimpleFormatter());
+    try {
+      client.newCall(request).execute(); // Ignore the response so it gets leaked then GC'd.
+      awaitGarbageCollection();
+
+      String message = logHandler.take();
+      assertTrue(message.contains("WARNING: A connection to " + server.url("/") + " was leaked."
+          + " Did you forget to close a response body?"));
+      assertTrue(message.contains("okhttp3.RealCall.execute("));
+      assertTrue(message.contains("okhttp3.CallTest.leakedResponseBodyLogsStackTrace("));
+    } finally {
+      logger.setLevel(original);
+    }
+  }
+
+  @Test public void asyncLeakedResponseBodyLogsStackTrace() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("This gets leaked."));
+
+    client = new OkHttpClient.Builder()
+        .connectionPool(new ConnectionPool(0, 10, TimeUnit.MILLISECONDS))
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Level original = logger.getLevel();
+    logger.setLevel(Level.FINE);
+    logHandler.setFormatter(new SimpleFormatter());
+    try {
+      final CountDownLatch latch = new CountDownLatch(1);
+      client.newCall(request).enqueue(new Callback() {
+        @Override public void onFailure(Call call, IOException e) {
+          fail();
+        }
+
+        @Override public void onResponse(Call call, Response response) throws IOException {
+          // Ignore the response so it gets leaked then GC'd.
+          latch.countDown();
+        }
+      });
+      latch.await();
+      // There's some flakiness when triggering a GC for objects in a separate thread. Adding a
+      // small delay appears to ensure the objects will get GC'd.
+      Thread.sleep(200);
+      awaitGarbageCollection();
+
+      String message = logHandler.take();
+      assertTrue(message.contains("WARNING: A connection to " + server.url("/") + " was leaked."
+          + " Did you forget to close a response body?"));
+      assertTrue(message.contains("okhttp3.RealCall.enqueue("));
+      assertTrue(message.contains("okhttp3.CallTest.asyncLeakedResponseBodyLogsStackTrace("));
+    } finally {
+      logger.setLevel(original);
+    }
+  }
+
   private void makeFailingCall() {
     RequestBody requestBody = new RequestBody() {
       @Override public MediaType contentType() {
@@ -2606,10 +2717,10 @@ private void enableProtocol(Protocol protocol) {
 
   private void enableTls() {
     client = client.newBuilder()
-        .sslSocketFactory(sslContext.getSocketFactory())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build();
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
   }
 
   private Buffer gzip(String data) throws IOException {
@@ -2658,6 +2769,6 @@ protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
    * for details.
    */
   private FallbackTestClientSocketFactory suppressTlsFallbackClientSocketFactory() {
-    return new FallbackTestClientSocketFactory(sslContext.getSocketFactory());
+    return new FallbackTestClientSocketFactory(sslClient.socketFactory);
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java b/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
index 8bfcb8c2ae..d3e0cb8764 100644
--- a/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
@@ -21,8 +21,8 @@
 import java.util.ArrayList;
 import java.util.List;
 import javax.net.ssl.SSLPeerUnverifiedException;
-import okhttp3.internal.HeldCertificate;
 import okhttp3.internal.tls.CertificateChainCleaner;
+import okhttp3.internal.tls.HeldCertificate;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
diff --git a/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java b/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
index 9442ddaf71..26207c5980 100644
--- a/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
@@ -21,7 +21,7 @@
 import java.util.List;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import okhttp3.CertificatePinner.Pin;
-import okhttp3.internal.HeldCertificate;
+import okhttp3.internal.tls.HeldCertificate;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
@@ -253,4 +253,26 @@
     assertEquals(Collections.emptyList(), certificatePinner.findMatchingPins("example.com"));
     assertEquals(Collections.emptyList(), certificatePinner.findMatchingPins("a.b.example.com"));
   }
+
+  @Test public void successfulFindMatchingPinsIgnoresCase() {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("EXAMPLE.com", certA1Sha256Pin)
+        .add("*.MyExample.Com", certB1Sha256Pin)
+        .build();
+
+    List<Pin> expectedPin1 = Arrays.asList(new Pin("EXAMPLE.com", certA1Sha256Pin));
+    assertEquals(expectedPin1, certificatePinner.findMatchingPins("example.com"));
+
+    List<Pin> expectedPin2 = Arrays.asList(new Pin("*.MyExample.Com", certB1Sha256Pin));
+    assertEquals(expectedPin2, certificatePinner.findMatchingPins("a.myexample.com"));
+  }
+
+  @Test public void successfulFindMatchingPinPunycode() {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("σkhttp.com", certA1Sha256Pin)
+        .build();
+
+    List<Pin> expectedPin = Arrays.asList(new Pin("σkhttp.com", certA1Sha256Pin));
+    assertEquals(expectedPin, certificatePinner.findMatchingPins("xn--khttp-fde.com"));
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/CipherSuiteTest.java b/okhttp-tests/src/test/java/okhttp3/CipherSuiteTest.java
new file mode 100644
index 0000000000..683ef9be25
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/CipherSuiteTest.java
@@ -0,0 +1,112 @@
+/*
+ * Copyright (C) 2016 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import org.junit.Test;
+
+import static okhttp3.CipherSuite.TLS_KRB5_WITH_DES_CBC_MD5;
+import static okhttp3.CipherSuite.TLS_RSA_EXPORT_WITH_RC4_40_MD5;
+import static okhttp3.CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA256;
+import static okhttp3.CipherSuite.forJavaName;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.fail;
+
+public class CipherSuiteTest {
+  @Test public void nullCipherName() {
+    try {
+      forJavaName(null);
+      fail("Should have thrown");
+    } catch (NullPointerException expected) {
+    }
+  }
+
+  @Test public void hashCode_usesIdentityHashCode_legacyCase() {
+    CipherSuite cs = TLS_RSA_EXPORT_WITH_RC4_40_MD5; // This one's javaName starts with "SSL_".
+    assertEquals(cs.toString(), System.identityHashCode(cs), cs.hashCode());
+  }
+
+  @Test public void hashCode_usesIdentityHashCode_regularCase() {
+    CipherSuite cs = TLS_RSA_WITH_AES_128_CBC_SHA256; // This one's javaName matches the identifier.
+    assertEquals(cs.toString(), System.identityHashCode(cs), cs.hashCode());
+  }
+
+  @Test public void instancesAreInterned() {
+    assertSame(forJavaName("TestCipherSuite"), forJavaName("TestCipherSuite"));
+    assertSame(CipherSuite.TLS_KRB5_WITH_DES_CBC_MD5,
+        forJavaName(TLS_KRB5_WITH_DES_CBC_MD5.javaName()));
+  }
+
+  /**
+   * Tests that interned CipherSuite instances remain the case across garbage collections, even if
+   * the String used to construct them is no longer strongly referenced outside of the CipherSuite.
+   */
+  @SuppressWarnings("RedundantStringConstructorCall")
+  @Test public void instancesAreInterned_survivesGarbageCollection() {
+    // We're not holding onto a reference to this String instance outside of the CipherSuite...
+    CipherSuite cs = forJavaName(new String("FakeCipherSuite_instancesAreInterned"));
+    System.gc(); // Unless cs references the String instance, it may now be garbage collected.
+    assertSame(cs, forJavaName(new String(cs.javaName())));
+  }
+
+  @Test public void equals() {
+    assertEquals(forJavaName("cipher"), forJavaName("cipher"));
+    assertNotEquals(forJavaName("cipherA"), forJavaName("cipherB"));
+    assertEquals(forJavaName("SSL_RSA_EXPORT_WITH_RC4_40_MD5"), TLS_RSA_EXPORT_WITH_RC4_40_MD5);
+    assertNotEquals(TLS_RSA_EXPORT_WITH_RC4_40_MD5, TLS_RSA_WITH_AES_128_CBC_SHA256);
+  }
+
+  @Test public void forJavaName_acceptsArbitraryStrings() {
+    // Shouldn't throw.
+    forJavaName("example CipherSuite name that is not in the whitelist");
+  }
+
+  @Test public void javaName_examples() {
+    assertEquals("SSL_RSA_EXPORT_WITH_RC4_40_MD5", TLS_RSA_EXPORT_WITH_RC4_40_MD5.javaName());
+    assertEquals("TLS_RSA_WITH_AES_128_CBC_SHA256", TLS_RSA_WITH_AES_128_CBC_SHA256.javaName());
+    assertEquals("TestCipherSuite", forJavaName("TestCipherSuite").javaName());
+  }
+
+  @Test public void javaName_equalsToString() {
+    assertEquals(TLS_RSA_EXPORT_WITH_RC4_40_MD5.javaName,
+        TLS_RSA_EXPORT_WITH_RC4_40_MD5.toString());
+    assertEquals(TLS_RSA_WITH_AES_128_CBC_SHA256.javaName,
+        TLS_RSA_WITH_AES_128_CBC_SHA256.toString());
+  }
+
+  /**
+   * Legacy ciphers (whose javaName starts with "SSL_") are now considered different from the
+   * corresponding "TLS_" ciphers. In OkHttp 3.3.1, only 19 of those would have been valid; those 19
+   * would have been considered equal to the corresponding "TLS_" ciphers.
+   */
+  @Test public void forJavaName_fromLegacyEnumName() {
+    // These would have been considered equal in OkHttp 3.3.1, but now aren't.
+    assertNotEquals(
+        forJavaName("TLS_RSA_EXPORT_WITH_RC4_40_MD5"),
+        forJavaName("SSL_RSA_EXPORT_WITH_RC4_40_MD5"));
+
+    // The SSL_ one of these would have been invalid in OkHttp 3.3.1; it now is valid and not equal.
+    assertNotEquals(
+        forJavaName("TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA"),
+        forJavaName("SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA"));
+
+    // These would have not been valid in OkHttp 3.3.1, and now aren't equal.
+    assertNotEquals(
+        forJavaName("TLS_FAKE_NEW_CIPHER"),
+        forJavaName("SSL_FAKE_NEW_CIPHER"));
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java
index 84ebbc6824..80346ba443 100644
--- a/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java
@@ -24,10 +24,11 @@
 import javax.net.SocketFactory;
 import okhttp3.internal.Internal;
 import okhttp3.internal.RecordingOkAuthenticator;
-import okhttp3.internal.http.StreamAllocation;
-import okhttp3.internal.io.RealConnection;
+import okhttp3.internal.connection.RealConnection;
+import okhttp3.internal.connection.StreamAllocation;
 import org.junit.Test;
 
+import static okhttp3.TestUtil.awaitGarbageCollection;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -81,8 +82,10 @@
     pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
 
     RealConnection c1 = newConnection(pool, routeA1, 50L);
-    StreamAllocation streamAllocation = new StreamAllocation(pool, addressA);
-    streamAllocation.acquire(c1);
+    synchronized (pool) {
+      StreamAllocation streamAllocation = new StreamAllocation(pool, addressA, null);
+      streamAllocation.acquire(c1);
+    }
 
     // Running at time 50, the pool returns that nothing can be evicted until time 150.
     assertEquals(100L, pool.cleanup(50L));
@@ -172,19 +175,10 @@
 
   /** Use a helper method so there's no hidden reference remaining on the stack. */
   private void allocateAndLeakAllocation(ConnectionPool pool, RealConnection connection) {
-    StreamAllocation leak = new StreamAllocation(pool, connection.route().address());
-    leak.acquire(connection);
-  }
-
-  /**
-   * See FinalizationTester for discussion on how to best trigger GC in tests.
-   * https://android.googlesource.com/platform/libcore/+/master/support/src/test/java/libcore/
-   * java/lang/ref/FinalizationTester.java
-   */
-  private void awaitGarbageCollection() throws InterruptedException {
-    Runtime.getRuntime().gc();
-    Thread.sleep(100);
-    System.runFinalization();
+    synchronized (pool) {
+      StreamAllocation leak = new StreamAllocation(pool, connection.route().address(), null);
+      leak.acquire(connection);
+    }
   }
 
   private RealConnection newConnection(ConnectionPool pool, Route route, long idleAtNanos) {
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java
index a25d8debef..6f9014bb34 100644
--- a/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java
@@ -15,12 +15,11 @@
  */
 package okhttp3;
 
+import java.io.IOException;
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
-import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLException;
-import javax.net.ssl.SSLSocketFactory;
-import okhttp3.internal.SslContextBuilder;
+import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.SocketPolicy;
@@ -31,13 +30,14 @@
 
 import static okhttp3.TestUtil.defaultClient;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class ConnectionReuseTest {
   @Rule public final TestRule timeout = new Timeout(30_000);
   @Rule public final MockWebServer server = new MockWebServer();
 
-  private SSLContext sslContext = SslContextBuilder.localhost();
+  private SslClient sslClient = SslClient.localhost();
   private OkHttpClient client = defaultClient();
 
   @Test public void connectionsAreReused() throws Exception {
@@ -186,6 +186,9 @@
     assertEquals("a", responseA.body().string());
     assertEquals(0, server.takeRequest().getSequenceNumber());
 
+    // Give the socket a chance to become stale.
+    Thread.sleep(250);
+
     Request requestB = new Request.Builder()
         .url(server.url("/"))
         .post(RequestBody.create(MediaType.parse("text/plain"), "b"))
@@ -248,11 +251,9 @@
     response.body().close();
 
     // This client shares a connection pool but has a different SSL socket factory.
-    SSLContext sslContext2 = SSLContext.getInstance("TLS");
-    sslContext2.init(null, null, null);
-    SSLSocketFactory sslSocketFactory2 = sslContext2.getSocketFactory();
+    SslClient sslClient2 = new SslClient.Builder().build();
     OkHttpClient anotherClient = client.newBuilder()
-        .sslSocketFactory(sslSocketFactory2)
+        .sslSocketFactory(sslClient2.socketFactory, sslClient2.trustManager)
         .build();
 
     // This client fails to connect because the new SSL socket factory refuses.
@@ -287,6 +288,42 @@
     assertEquals(0, server.takeRequest().getSequenceNumber());
   }
 
+  /**
+   * Regression test for an edge case where closing response body in the HTTP engine doesn't release
+   * the corresponding stream allocation. This test keeps those response bodies alive and reads
+   * them after the redirect has completed. This forces a connection to not be reused where it would
+   * be otherwise.
+   *
+   * https://github.com/square/okhttp/issues/2409
+   */
+  @Test public void connectionsAreNotReusedIfNetworkInterceptorInterferes() throws Exception {
+    client = client.newBuilder().addNetworkInterceptor(new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        Response response = chain.proceed(chain.request());
+        return response.newBuilder()
+            .body(ResponseBody.create(null, "unrelated response body!"))
+            .build();
+      }
+    }).build();
+
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location: /b")
+        .setBody("/a has moved!"));
+    server.enqueue(new MockResponse()
+        .setBody("/b is here"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertTrue(expected.getMessage().startsWith("Closing the body of"));
+    }
+  }
+
   private void enableHttps() {
     enableHttpsAndAlpn(Protocol.HTTP_1_1);
   }
@@ -297,11 +334,11 @@ private void enableHttp2() {
 
   private void enableHttpsAndAlpn(Protocol... protocols) {
     client = client.newBuilder()
-        .sslSocketFactory(sslContext.getSocketFactory())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
         .hostnameVerifier(new RecordingHostnameVerifier())
         .protocols(Arrays.asList(protocols))
         .build();
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     server.setProtocols(client.protocols());
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionSpecTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionSpecTest.java
index 7fbd08e628..c74a6b314c 100644
--- a/okhttp-tests/src/test/java/okhttp3/ConnectionSpecTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/ConnectionSpecTest.java
@@ -293,7 +293,7 @@
         .tlsVersions(TlsVersion.TLS_1_2)
         .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
         .build();
-    assertEquals("ConnectionSpec(cipherSuites=[TLS_RSA_WITH_RC4_128_MD5], tlsVersions=[TLS_1_2], "
+    assertEquals("ConnectionSpec(cipherSuites=[SSL_RSA_WITH_RC4_128_MD5], tlsVersions=[TLS_1_2], "
         + "supportsTlsExtensions=true)", connectionSpec.toString());
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/CookiesTest.java b/okhttp-tests/src/test/java/okhttp3/CookiesTest.java
similarity index 80%
rename from okhttp-tests/src/test/java/okhttp3/internal/http/CookiesTest.java
rename to okhttp-tests/src/test/java/okhttp3/CookiesTest.java
index bf01f36fac..79219fdaa4 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/CookiesTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CookiesTest.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package okhttp3.internal.http;
+package okhttp3;
 
 import java.io.IOException;
 import java.net.CookieHandler;
@@ -23,16 +23,11 @@
 import java.net.HttpURLConnection;
 import java.net.InetAddress;
 import java.net.URI;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import okhttp3.Call;
-import okhttp3.HttpUrl;
-import okhttp3.JavaNetCookieJar;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
@@ -277,6 +272,58 @@ public void testNetscapeResponse() throws Exception {
     assertNull(request.getHeader("Quux"));
   }
 
+  @Test public void acceptOriginalServerMatchesSubdomain() throws Exception {
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
+
+    HttpUrl url = HttpUrl.parse("https://www.squareup.com/");
+    cookieJar.saveFromResponse(url, Arrays.asList(
+        Cookie.parse(url, "a=android; Domain=squareup.com")));
+    List<Cookie> actualCookies = cookieJar.loadForRequest(url);
+    assertEquals(1, actualCookies.size());
+    assertEquals("a", actualCookies.get(0).name());
+    assertEquals("android", actualCookies.get(0).value());
+  }
+
+  @Test public void acceptOriginalServerMatchesRfc2965Dot() throws Exception {
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
+
+    HttpUrl url = HttpUrl.parse("https://www.squareup.com/");
+    cookieJar.saveFromResponse(url, Arrays.asList(
+        Cookie.parse(url, "a=android; Domain=.squareup.com")));
+    List<Cookie> actualCookies = cookieJar.loadForRequest(url);
+    assertEquals(1, actualCookies.size());
+    assertEquals("a", actualCookies.get(0).name());
+    assertEquals("android", actualCookies.get(0).value());
+  }
+
+  @Test public void acceptOriginalServerMatchesExactly() throws Exception {
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
+
+    HttpUrl url = HttpUrl.parse("https://squareup.com/");
+    cookieJar.saveFromResponse(url, Arrays.asList(
+        Cookie.parse(url, "a=android; Domain=squareup.com")));
+    List<Cookie> actualCookies = cookieJar.loadForRequest(url);
+    assertEquals(1, actualCookies.size());
+    assertEquals("a", actualCookies.get(0).name());
+    assertEquals("android", actualCookies.get(0).value());
+  }
+
+  @Test public void acceptOriginalServerDoesNotMatchDifferentServer() throws Exception {
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
+
+    HttpUrl url1 = HttpUrl.parse("https://api.squareup.com/");
+    cookieJar.saveFromResponse(url1, Arrays.asList(
+        Cookie.parse(url1, "a=android; Domain=api.squareup.com")));
+
+    HttpUrl url2 = HttpUrl.parse("https://www.squareup.com/");
+    List<Cookie> actualCookies = cookieJar.loadForRequest(url2);
+    assertEquals(Collections.<Cookie>emptyList(), actualCookies);
+  }
+
   private HttpUrl urlWithIpAddress(MockWebServer server, String path) throws Exception {
     return server.url(path)
         .newBuilder()
diff --git a/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocket.java b/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocket.java
index f07559387b..fc863c2022 100644
--- a/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocket.java
+++ b/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocket.java
@@ -18,10 +18,14 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.lang.reflect.InvocationTargetException;
 import java.net.InetAddress;
+import java.net.Socket;
 import java.net.SocketAddress;
 import java.net.SocketException;
+import java.net.SocketOption;
 import java.nio.channels.SocketChannel;
+import java.util.Set;
 import javax.net.ssl.HandshakeCompletedListener;
 import javax.net.ssl.SSLParameters;
 import javax.net.ssl.SSLSession;
@@ -280,4 +284,55 @@ public DelegatingSSLSocket(SSLSocket delegate) {
   @Override public void setPerformancePreferences(int connectionTime, int latency, int bandwidth) {
     delegate.setPerformancePreferences(connectionTime, latency, bandwidth);
   }
+
+  // Java 9 methods.
+
+  public SSLSession getHandshakeSession() {
+    try {
+      return (SSLSession) SSLSocket.class.getMethod("getHandshakeSession").invoke(delegate);
+    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
+      throw new AssertionError();
+    }
+  }
+
+  public String getApplicationProtocol() {
+    try {
+      return (String) SSLSocket.class.getMethod("getApplicationProtocol").invoke(delegate);
+    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
+      throw new AssertionError();
+    }
+  }
+
+  public String getHandshakeApplicationProtocol() {
+    try {
+      return (String) SSLSocket.class.getMethod("getHandshakeApplicationProtocol").invoke(delegate);
+    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
+      throw new AssertionError();
+    }
+  }
+
+  public <T> Socket setOption(SocketOption<T> name, T value) throws IOException {
+    try {
+      SSLSocket.class.getMethod("setOption", SocketOption.class, Object.class).invoke(delegate, name, value);
+      return this;
+    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
+      throw new AssertionError();
+    }
+  }
+
+  public <T> T getOption(SocketOption<T> name) throws IOException {
+    try {
+      return (T) SSLSocket.class.getMethod("getOption", SocketOption.class).invoke(delegate, name);
+    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
+      throw new AssertionError();
+    }
+  }
+
+  public Set<SocketOption<?>> supportedOptions() {
+    try {
+      return (Set<SocketOption<?>>) SSLSocket.class.getMethod("supportedOptions").invoke(delegate);
+    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
+      throw new AssertionError();
+    }
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocketFactory.java b/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocketFactory.java
index 5a14d0fbd6..5a5a3dc20a 100644
--- a/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocketFactory.java
+++ b/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocketFactory.java
@@ -18,7 +18,6 @@
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.Socket;
-import java.net.UnknownHostException;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 
diff --git a/okhttp-tests/src/test/java/okhttp3/DelegatingSocketFactory.java b/okhttp-tests/src/test/java/okhttp3/DelegatingSocketFactory.java
index d21f37a31a..33ac2f4e1a 100644
--- a/okhttp-tests/src/test/java/okhttp3/DelegatingSocketFactory.java
+++ b/okhttp-tests/src/test/java/okhttp3/DelegatingSocketFactory.java
@@ -18,7 +18,6 @@
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.Socket;
-import java.net.UnknownHostException;
 import javax.net.SocketFactory;
 
 /**
@@ -26,41 +25,35 @@
  * overriding {@link #configureSocket(java.net.Socket)}.
  */
 public class DelegatingSocketFactory extends SocketFactory {
-
   private final SocketFactory delegate;
 
   public DelegatingSocketFactory(SocketFactory delegate) {
     this.delegate = delegate;
   }
 
-  @Override
-  public Socket createSocket() throws IOException {
+  @Override public Socket createSocket() throws IOException {
     Socket socket = delegate.createSocket();
     return configureSocket(socket);
   }
 
-  @Override
-  public Socket createSocket(String host, int port) throws IOException, UnknownHostException {
+  @Override public Socket createSocket(String host, int port) throws IOException {
     Socket socket = delegate.createSocket(host, port);
     return configureSocket(socket);
   }
 
-  @Override
-  public Socket createSocket(String host, int port, InetAddress localAddress, int localPort)
-      throws IOException, UnknownHostException {
+  @Override public Socket createSocket(String host, int port, InetAddress localAddress,
+      int localPort) throws IOException {
     Socket socket = delegate.createSocket(host, port, localAddress, localPort);
     return configureSocket(socket);
   }
 
-  @Override
-  public Socket createSocket(InetAddress host, int port) throws IOException {
+  @Override public Socket createSocket(InetAddress host, int port) throws IOException {
     Socket socket = delegate.createSocket(host, port);
     return configureSocket(socket);
   }
 
-  @Override
-  public Socket createSocket(InetAddress host, int port, InetAddress localAddress, int localPort)
-      throws IOException {
+  @Override public Socket createSocket(InetAddress host, int port, InetAddress localAddress,
+      int localPort) throws IOException {
     Socket socket = delegate.createSocket(host, port, localAddress, localPort);
     return configureSocket(socket);
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java b/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
index 4dc3d0c6bd..b49379dffe 100644
--- a/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
@@ -11,10 +11,12 @@
 import java.util.concurrent.AbstractExecutorService;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
 import okhttp3.RealCall.AsyncCall;
 import org.junit.Before;
 import org.junit.Test;
 
+import static java.util.concurrent.TimeUnit.SECONDS;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -213,6 +215,45 @@
     assertFalse(a4.isCanceled());
   }
 
+  @Test public void idleCallbackInvokedWhenIdle() throws InterruptedException {
+    final AtomicBoolean idle = new AtomicBoolean();
+    dispatcher.setIdleCallback(new Runnable() {
+      @Override public void run() {
+        idle.set(true);
+      }
+    });
+
+    client.newCall(newRequest("http://a/1")).enqueue(callback);
+    client.newCall(newRequest("http://a/2")).enqueue(callback);
+    executor.finishJob("http://a/1");
+    assertFalse(idle.get());
+
+    final CountDownLatch ready = new CountDownLatch(1);
+    final CountDownLatch proceed = new CountDownLatch(1);
+    client = client.newBuilder()
+        .addInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            ready.countDown();
+            try {
+              proceed.await(5, SECONDS);
+            } catch (InterruptedException e) {
+              throw new RuntimeException(e);
+            }
+            return chain.proceed(chain.request());
+          }
+        })
+        .build();
+
+    Thread t1 = makeSynchronousCall(client.newCall(newRequest("http://a/3")));
+    ready.await(5, SECONDS);
+    executor.finishJob("http://a/2");
+    assertFalse(idle.get());
+
+    proceed.countDown();
+    t1.join();
+    assertTrue(idle.get());
+  }
+
   private <T> Set<T> set(T... values) {
     return set(Arrays.asList(values));
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/FallbackTestClientSocketFactory.java b/okhttp-tests/src/test/java/okhttp3/FallbackTestClientSocketFactory.java
index eb9aaaa2d3..d829566e20 100644
--- a/okhttp-tests/src/test/java/okhttp3/FallbackTestClientSocketFactory.java
+++ b/okhttp-tests/src/test/java/okhttp3/FallbackTestClientSocketFactory.java
@@ -49,7 +49,7 @@ public TlsFallbackScsvDisabledSSLSocket(SSLSocket socket) {
     }
 
     @Override public void setEnabledCipherSuites(String[] suites) {
-      List<String> enabledCipherSuites = new ArrayList<String>(suites.length);
+      List<String> enabledCipherSuites = new ArrayList<>(suites.length);
       for (String suite : suites) {
         if (!suite.equals(TLS_FALLBACK_SCSV)) {
           enabledCipherSuites.add(suite);
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/HeadersTest.java b/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
similarity index 71%
rename from okhttp-tests/src/test/java/okhttp3/internal/http/HeadersTest.java
rename to okhttp-tests/src/test/java/okhttp3/HeadersTest.java
index 4e649dc88c..d906affb04 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/HeadersTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.http;
+package okhttp3;
 
 import java.io.IOException;
 import java.util.Arrays;
@@ -21,54 +21,20 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import okhttp3.Headers;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.framed.Header;
-import org.junit.Assert;
+import okhttp3.internal.Internal;
+import okhttp3.internal.http2.Header;
+import okhttp3.internal.http2.Http2Codec;
 import org.junit.Test;
 
 import static okhttp3.TestUtil.headerEntries;
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class HeadersTest {
-  @Test public void parseNameValueBlock() throws IOException {
-    List<Header> headerBlock = headerEntries(
-        "cache-control", "no-cache, no-store",
-        "set-cookie", "Cookie1\u0000Cookie2",
-        ":status", "200 OK",
-        ":version", "HTTP/1.1");
-    Request request = new Request.Builder().url("http://square.com/").build();
-    Response response = Http2xStream.readSpdy3HeadersList(headerBlock).request(request).build();
-    Headers headers = response.headers();
-    assertEquals(3, headers.size());
-    Assert.assertEquals(Protocol.SPDY_3, response.protocol());
-    assertEquals(200, response.code());
-    assertEquals("OK", response.message());
-    assertEquals("no-cache, no-store", headers.get("cache-control"));
-    assertEquals("Cookie2", headers.get("set-cookie"));
-    assertEquals("cache-control", headers.name(0));
-    assertEquals("no-cache, no-store", headers.value(0));
-    assertEquals("set-cookie", headers.name(1));
-    assertEquals("Cookie1", headers.value(1));
-    assertEquals("set-cookie", headers.name(2));
-    assertEquals("Cookie2", headers.value(2));
-    assertNull(headers.get(":status"));
-    assertNull(headers.get(":version"));
-  }
-
-  @Test public void readNameValueBlockDropsForbiddenHeadersSpdy3() throws IOException {
-    List<Header> headerBlock = headerEntries(
-        ":status", "200 OK",
-        ":version", "HTTP/1.1",
-        "connection", "close");
-    Request request = new Request.Builder().url("http://square.com/").build();
-    Response response = Http2xStream.readSpdy3HeadersList(headerBlock).request(request).build();
-    Headers headers = response.headers();
-    assertEquals(0, headers.size());
+  static {
+    Internal.initializeInstanceForTests();
   }
 
   @Test public void readNameValueBlockDropsForbiddenHeadersHttp2() throws IOException {
@@ -77,49 +43,13 @@
         ":version", "HTTP/1.1",
         "connection", "close");
     Request request = new Request.Builder().url("http://square.com/").build();
-    Response response = Http2xStream.readHttp2HeadersList(headerBlock).request(request).build();
+    Response response = Http2Codec.readHttp2HeadersList(headerBlock).request(request).build();
     Headers headers = response.headers();
     assertEquals(1, headers.size());
     assertEquals(":version", headers.name(0));
     assertEquals("HTTP/1.1", headers.value(0));
   }
 
-  @Test public void spdy3HeadersList() {
-    Request request = new Request.Builder()
-        .url("http://square.com/")
-        .header("cache-control", "no-cache, no-store")
-        .addHeader("set-cookie", "Cookie1")
-        .addHeader("set-cookie", "Cookie2")
-        .header(":status", "200 OK")
-        .build();
-    List<Header> headerBlock = Http2xStream.spdy3HeadersList(request);
-    List<Header> expected = headerEntries(
-        ":method", "GET",
-        ":path", "/",
-        ":version", "HTTP/1.1",
-        ":host", "square.com",
-        ":scheme", "http",
-        "cache-control", "no-cache, no-store",
-        "set-cookie", "Cookie1\u0000Cookie2",
-        ":status", "200 OK");
-    assertEquals(expected, headerBlock);
-  }
-
-  @Test public void spdy3HeadersListDropsForbiddenHeadersSpdy3() {
-    Request request = new Request.Builder()
-        .url("http://square.com/")
-        .header("Connection", "close")
-        .header("Transfer-Encoding", "chunked")
-        .build();
-    List<Header> expected = headerEntries(
-        ":method", "GET",
-        ":path", "/",
-        ":version", "HTTP/1.1",
-        ":host", "square.com",
-        ":scheme", "http");
-    assertEquals(expected, Http2xStream.spdy3HeadersList(request));
-  }
-
   @Test public void http2HeadersListDropsForbiddenHeadersHttp2() {
     Request request = new Request.Builder()
         .url("http://square.com/")
@@ -131,7 +61,7 @@
         ":path", "/",
         ":authority", "square.com",
         ":scheme", "http");
-    assertEquals(expected, Http2xStream.http2HeadersList(request));
+    assertEquals(expected, Http2Codec.http2HeadersList(request));
   }
 
   @Test public void ofTrims() {
@@ -145,10 +75,12 @@
         .add("foo: bar")
         .add(" foo: baz") // Name leading whitespace is trimmed.
         .add("foo : bak") // Name trailing whitespace is trimmed.
+        .add("\tkey\t:\tvalue\t") // '\t' also counts as whitespace
         .add("ping:  pong  ") // Value whitespace is trimmed.
         .add("kit:kat") // Space after colon is not required.
         .build();
     assertEquals(Arrays.asList("bar", "baz", "bak"), headers.values("foo"));
+    assertEquals(Arrays.asList("value"), headers.values("key"));
     assertEquals(Arrays.asList("pong"), headers.values("ping"));
     assertEquals(Arrays.asList("kat"), headers.values("kit"));
   }
@@ -303,6 +235,25 @@
     assertEquals(1, headerMap.get("user-agent").size());
   }
 
+  @Test public void toMultimapUsesCanonicalCase() {
+    Headers headers = Headers.of(
+        "cache-control", "no-store",
+        "Cache-Control", "no-cache",
+        "User-Agent", "OkHttp");
+    Map<String, List<String>> headerMap = headers.toMultimap();
+    assertEquals(2, headerMap.get("cache-control").size());
+    assertEquals(1, headerMap.get("user-agent").size());
+  }
+
+  @Test public void toMultimapAllowsCaseInsensitiveGet() {
+    Headers headers = Headers.of(
+            "cache-control", "no-store",
+            "Cache-Control", "no-cache");
+    Map<String, List<String>> headerMap = headers.toMultimap();
+    assertEquals(2, headerMap.get("cache-control").size());
+    assertEquals(2, headerMap.get("Cache-Control").size());
+  }
+
   @Test public void nameIndexesAreStrict() {
     Headers headers = Headers.of("a", "b", "c", "d");
     try {
@@ -354,4 +305,38 @@
           expected.getMessage());
     }
   }
+
+  @Test public void headersEquals() {
+    Headers headers1 = new Headers.Builder()
+        .add("Connection", "close")
+        .add("Transfer-Encoding", "chunked")
+        .build();
+    Headers headers2 = new Headers.Builder()
+        .add("Connection", "close")
+        .add("Transfer-Encoding", "chunked")
+        .build();
+    assertTrue(headers1.equals(headers2));
+    assertEquals(headers1.hashCode(), headers2.hashCode());
+  }
+
+  @Test public void headersNotEquals() {
+    Headers headers1 = new Headers.Builder()
+        .add("Connection", "close")
+        .add("Transfer-Encoding", "chunked")
+        .build();
+    Headers headers2 = new Headers.Builder()
+        .add("Connection", "keep-alive")
+        .add("Transfer-Encoding", "chunked")
+        .build();
+    assertFalse(headers1.equals(headers2));
+    assertFalse(headers1.hashCode() == headers2.hashCode());
+  }
+
+  @Test public void headersToString() {
+    Headers headers = new Headers.Builder()
+        .add("A", "a")
+        .add("B", "bb")
+        .build();
+    assertEquals("A: a\nB: bb\n", headers.toString());
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java b/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
index f7d655dbf0..33f4952651 100644
--- a/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
@@ -29,6 +29,7 @@
 
 import static java.util.Collections.singletonList;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.fail;
 
@@ -124,6 +125,15 @@
     assertEquals(null, base.newBuilder("ht.tp://b"));
   }
 
+  @Test public void redactedUrl() {
+    HttpUrl baseWithPasswordAndUsername = HttpUrl.parse("http://username:password@host/a/b#fragment");
+    HttpUrl baseWithUsernameOnly = HttpUrl.parse("http://username@host/a/b#fragment");
+    HttpUrl baseWithPasswordOnly = HttpUrl.parse("http://password@host/a/b#fragment");
+    assertEquals(HttpUrl.parse("http://host/..."), baseWithPasswordAndUsername.redact());
+    assertEquals(HttpUrl.parse("http://host/..."), baseWithUsernameOnly.redact());
+    assertEquals(HttpUrl.parse("http://host/..."), baseWithPasswordOnly.redact());
+  }
+
   @Test public void resolveNoScheme() throws Exception {
     HttpUrl base = HttpUrl.parse("http://host/a/b");
     assertEquals(HttpUrl.parse("http://host2/"), base.resolve("//host2"));
diff --git a/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java b/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
index 287f12a317..dd72d07f74 100644
--- a/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
@@ -597,8 +597,7 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
       client.newCall(request).execute();
       fail();
     } catch (NullPointerException expected) {
-      assertEquals("application interceptor " + interceptor
-          + " returned null", expected.getMessage());
+      assertEquals("interceptor " + interceptor + " returned null", expected.getMessage());
     }
   }
 
@@ -627,7 +626,7 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
       client.newCall(request).execute();
       fail();
     } catch (NullPointerException expected) {
-      assertEquals("network interceptor " + interceptor + " returned null", expected.getMessage());
+      assertEquals("interceptor " + interceptor + " returned null", expected.getMessage());
     }
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java b/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java
index b4e9c2ec2a..5e4a14f484 100644
--- a/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java
@@ -87,6 +87,16 @@
     assertInvalid("text/plain ; a=1");
   }
 
+  @Test public void testDoubleQuotesAreSpecial() throws Exception {
+    MediaType mediaType = MediaType.parse("text/plain;a=\";charset=utf-8;b=\"");
+    assertNull(mediaType.charset());
+  }
+
+  @Test public void testSingleQuotesAreNotSpecial() throws Exception {
+    MediaType mediaType = MediaType.parse("text/plain;a=';charset=utf-8;b='");
+    assertEquals("UTF-8", mediaType.charset().name());
+  }
+
   @Test public void testParseWithSpecialCharacters() throws Exception {
     MediaType mediaType = MediaType.parse(
         "!#$%&'*+-.{|}~/!#$%&'*+-.{|}~; !#$%&'*+-.{|}~=!#$%&'*+-.{|}~");
@@ -138,6 +148,33 @@
     }
   }
 
+  /**
+   * This is invalid according to RFC 822. But it's what Chrome does and it avoids a potentially
+   * unpleasant IllegalCharsetNameException.
+   */
+  @Test public void testCharsetNameIsSingleQuoted() throws Exception {
+    MediaType mediaType = MediaType.parse("text/plain;charset='utf-8'");
+    assertEquals("UTF-8", mediaType.charset().name());
+  }
+
+  @Test public void testCharsetNameIsDoubleQuotedAndSingleQuoted() throws Exception {
+    MediaType mediaType = MediaType.parse("text/plain;charset=\"'utf-8'\"");
+    try {
+      mediaType.charset();
+      fail();
+    } catch (IllegalCharsetNameException expected) {
+    }
+  }
+
+  @Test public void testCharsetNameIsDoubleQuotedSingleQuote() throws Exception {
+    MediaType mediaType = MediaType.parse("text/plain;charset=\"'\"");
+    try {
+      mediaType.charset();
+      fail();
+    } catch (IllegalCharsetNameException expected) {
+    }
+  }
+
   @Test public void testDefaultCharset() throws Exception {
     MediaType noCharset = MediaType.parse("text/plain");
     assertEquals("UTF-8", noCharset.charset(Util.UTF_8).name());
diff --git a/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java b/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java
index a5a8664a87..35d2f67906 100644
--- a/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java
@@ -258,4 +258,17 @@
     } catch (IllegalArgumentException expected) {
     }
   }
+
+  @Test public void partAccessors() throws IOException {
+    MultipartBody body = new MultipartBody.Builder()
+        .addPart(Headers.of("Foo", "Bar"), RequestBody.create(null, "Baz"))
+        .build();
+    assertEquals(1, body.parts().size());
+
+    Buffer part1Buffer = new Buffer();
+    MultipartBody.Part part1 = body.part(0);
+    part1.body().writeTo(part1Buffer);
+    assertEquals(Headers.of("Foo", "Bar"), part1.headers());
+    assertEquals("Baz", part1Buffer.readUtf8());
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java b/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
index 6e1f0728bf..3410775b6c 100644
--- a/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
+++ b/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
@@ -16,8 +16,9 @@
 package okhttp3;
 
 import java.io.IOException;
+import java.text.SimpleDateFormat;
 import java.util.Arrays;
-import okhttp3.ws.WebSocket;
+import java.util.Date;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -79,6 +80,11 @@ public RecordedResponse assertHeader(String name, String... values) {
     return this;
   }
 
+  public RecordedResponse assertHeaders(Headers headers) {
+    assertEquals(headers, response.headers());
+    return this;
+  }
+
   public RecordedResponse assertBody(String expectedBody) {
     assertEquals(expectedBody, body);
     return this;
@@ -147,4 +153,27 @@ public RecordedResponse assertFailure(String... messages) {
     assertTrue(failure.getMessage(), Arrays.asList(messages).contains(failure.getMessage()));
     return this;
   }
+
+  public RecordedResponse assertSentRequestAtMillis(long minimum, long maximum) {
+    assertDateInRange(minimum, response.sentRequestAtMillis(), maximum);
+    return this;
+  }
+
+  public RecordedResponse assertReceivedResponseAtMillis(long minimum, long maximum) {
+    assertDateInRange(minimum, response.receivedResponseAtMillis(), maximum);
+    return this;
+  }
+
+  private void assertDateInRange(long minimum, long actual, long maximum) {
+    assertTrue("actual " + format(actual) + " < minimum " + format(maximum), actual >= minimum);
+    assertTrue("actual " + format(actual) + " > maximum " + format(minimum), actual <= maximum);
+  }
+
+  private String format(long time) {
+    return new SimpleDateFormat("HH:mm:ss.SSS").format(new Date(time));
+  }
+
+  public String getBody() {
+    return body;
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/RequestTest.java b/okhttp-tests/src/test/java/okhttp3/RequestTest.java
index 4668f6005d..bd6092b4a8 100644
--- a/okhttp-tests/src/test/java/okhttp3/RequestTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/RequestTest.java
@@ -198,11 +198,20 @@
     }
   }
 
+  @Test public void headerAllowsTabOnlyInValues() throws Exception {
+    Request.Builder builder = new Request.Builder();
+    builder.header("key", "sample\tvalue");
+    try {
+      builder.header("sample\tkey", "value");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
   @Test public void headerForbidsControlCharacters() throws Exception {
     assertForbiddenHeader("\u0000");
     assertForbiddenHeader("\r");
     assertForbiddenHeader("\n");
-    assertForbiddenHeader("\t");
     assertForbiddenHeader("\u001f");
     assertForbiddenHeader("\u007f");
     assertForbiddenHeader("\u0080");
diff --git a/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java b/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java
new file mode 100644
index 0000000000..beba4bd0d8
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java
@@ -0,0 +1,412 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.Reader;
+import java.util.concurrent.atomic.AtomicBoolean;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.ForwardingSource;
+import okio.Okio;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class ResponseBodyTest {
+  @Test public void stringEmpty() throws IOException {
+    ResponseBody body = body("");
+    assertEquals("", body.string());
+  }
+
+  @Test public void stringLooksLikeBomButTooShort() throws IOException {
+    ResponseBody body = body("000048");
+    assertEquals("\0\0H", body.string());
+  }
+
+  @Test public void stringDefaultsToUtf8() throws IOException {
+    ResponseBody body = body("68656c6c6f");
+    assertEquals("hello", body.string());
+  }
+
+  @Test public void stringExplicitCharset() throws IOException {
+    ResponseBody body = body("00000068000000650000006c0000006c0000006f", "utf-32be");
+    assertEquals("hello", body.string());
+  }
+
+  @Test public void stringBomOverridesExplicitCharset() throws IOException {
+    ResponseBody body = body("0000ffff00000068000000650000006c0000006c0000006f", "utf-8");
+    assertEquals("hello", body.string());
+  }
+
+  @Test public void stringBomUtf8() throws IOException {
+    ResponseBody body = body("efbbff68656c6c6f");
+    assertEquals("hello", body.string());
+  }
+
+  @Test public void stringBomUtf16Be() throws IOException {
+    ResponseBody body = body("feff00680065006c006c006f");
+    assertEquals("hello", body.string());
+  }
+
+  @Test public void stringBomUtf16Le() throws IOException {
+    ResponseBody body = body("fffe680065006c006c006f00");
+    assertEquals("hello", body.string());
+  }
+
+  @Test public void stringBomUtf32Be() throws IOException {
+    ResponseBody body = body("0000ffff00000068000000650000006c0000006c0000006f");
+    assertEquals("hello", body.string());
+  }
+
+  @Test public void stringBomUtf32Le() throws IOException {
+    ResponseBody body = body("ffff000068000000650000006c0000006c0000006f000000");
+    assertEquals("hello", body.string());
+  }
+
+  @Test public void stringClosesUnderlyingSource() throws IOException {
+    final AtomicBoolean closed = new AtomicBoolean();
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return 5;
+      }
+
+      @Override public BufferedSource source() {
+        Buffer source = new Buffer().writeUtf8("hello");
+        return Okio.buffer(new ForwardingSource(source) {
+          @Override public void close() throws IOException {
+            closed.set(true);
+            super.close();
+          }
+        });
+      }
+    };
+    assertEquals("hello", body.string());
+    assertTrue(closed.get());
+  }
+
+  @Test public void readerEmpty() throws IOException {
+    ResponseBody body = body("");
+    assertEquals("", exhaust(body.charStream()));
+  }
+
+  @Test public void readerLooksLikeBomButTooShort() throws IOException {
+    ResponseBody body = body("000048");
+    assertEquals("\0\0H", exhaust(body.charStream()));
+  }
+
+  @Test public void readerDefaultsToUtf8() throws IOException {
+    ResponseBody body = body("68656c6c6f");
+    assertEquals("hello", exhaust(body.charStream()));
+  }
+
+  @Test public void readerExplicitCharset() throws IOException {
+    ResponseBody body = body("00000068000000650000006c0000006c0000006f", "utf-32be");
+    assertEquals("hello", exhaust(body.charStream()));
+  }
+
+  @Test public void readerBomUtf8() throws IOException {
+    ResponseBody body = body("efbbff68656c6c6f");
+    assertEquals("hello", exhaust(body.charStream()));
+  }
+
+  @Test public void readerBomUtf16Be() throws IOException {
+    ResponseBody body = body("feff00680065006c006c006f");
+    assertEquals("hello", exhaust(body.charStream()));
+  }
+
+  @Test public void readerBomUtf16Le() throws IOException {
+    ResponseBody body = body("fffe680065006c006c006f00");
+    assertEquals("hello", exhaust(body.charStream()));
+  }
+
+  @Test public void readerBomUtf32Be() throws IOException {
+    ResponseBody body = body("0000ffff00000068000000650000006c0000006c0000006f");
+    assertEquals("hello", exhaust(body.charStream()));
+  }
+
+  @Test public void readerBomUtf32Le() throws IOException {
+    ResponseBody body = body("ffff000068000000650000006c0000006c0000006f000000");
+    assertEquals("hello", exhaust(body.charStream()));
+  }
+
+  @Test public void readerClosedBeforeBomClosesUnderlyingSource() throws IOException {
+    final AtomicBoolean closed = new AtomicBoolean();
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return 5;
+      }
+
+      @Override public BufferedSource source() {
+        ResponseBody body = body("fffe680065006c006c006f00");
+        return Okio.buffer(new ForwardingSource(body.source()) {
+          @Override public void close() throws IOException {
+            closed.set(true);
+            super.close();
+          }
+        });
+      }
+    };
+    body.charStream().close();
+    assertTrue(closed.get());
+  }
+
+  @Test public void readerClosedAfterBomClosesUnderlyingSource() throws IOException {
+    final AtomicBoolean closed = new AtomicBoolean();
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return 5;
+      }
+
+      @Override public BufferedSource source() {
+        ResponseBody body = body("fffe680065006c006c006f00");
+        return Okio.buffer(new ForwardingSource(body.source()) {
+          @Override public void close() throws IOException {
+            closed.set(true);
+            super.close();
+          }
+        });
+      }
+    };
+    Reader reader = body.charStream();
+    assertEquals('h', reader.read());
+    reader.close();
+    assertTrue(closed.get());
+  }
+
+  @Test public void sourceEmpty() throws IOException {
+    ResponseBody body = body("");
+    BufferedSource source = body.source();
+    assertTrue(source.exhausted());
+    assertEquals("", source.readUtf8());
+  }
+
+  @Test public void sourceSeesBom() throws IOException {
+    ResponseBody body = body("efbbff68656c6c6f");
+    BufferedSource source = body.source();
+    assertEquals(0xef, source.readByte() & 0xff);
+    assertEquals(0xbb, source.readByte() & 0xff);
+    assertEquals(0xff, source.readByte() & 0xff);
+    assertEquals("hello", source.readUtf8());
+  }
+
+  @Test public void sourceClosesUnderlyingSource() throws IOException {
+    final AtomicBoolean closed = new AtomicBoolean();
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return 5;
+      }
+
+      @Override public BufferedSource source() {
+        Buffer source = new Buffer().writeUtf8("hello");
+        return Okio.buffer(new ForwardingSource(source) {
+          @Override public void close() throws IOException {
+            closed.set(true);
+            super.close();
+          }
+        });
+      }
+    };
+    body.source().close();
+    assertTrue(closed.get());
+  }
+
+  @Test public void bytesEmpty() throws IOException {
+    ResponseBody body = body("");
+    assertEquals(0, body.bytes().length);
+  }
+
+  @Test public void bytesSeesBom() throws IOException {
+    ResponseBody body = body("efbbff68656c6c6f");
+    byte[] bytes = body.bytes();
+    assertEquals(0xef, bytes[0] & 0xff);
+    assertEquals(0xbb, bytes[1] & 0xff);
+    assertEquals(0xff, bytes[2] & 0xff);
+    assertEquals("hello", new String(bytes, 3, 5, "UTF-8"));
+  }
+
+  @Test public void bytesClosesUnderlyingSource() throws IOException {
+    final AtomicBoolean closed = new AtomicBoolean();
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return 5;
+      }
+
+      @Override public BufferedSource source() {
+        Buffer source = new Buffer().writeUtf8("hello");
+        return Okio.buffer(new ForwardingSource(source) {
+          @Override public void close() throws IOException {
+            closed.set(true);
+            super.close();
+          }
+        });
+      }
+    };
+    assertEquals(5, body.bytes().length);
+    assertTrue(closed.get());
+  }
+
+  @Test public void bytesThrowsWhenLengthsDisagree() {
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return 10;
+      }
+
+      @Override public BufferedSource source() {
+        return new Buffer().writeUtf8("hello");
+      }
+    };
+    try {
+      body.bytes();
+      fail();
+    } catch (IOException e) {
+      assertEquals("Content-Length (10) and stream length (5) disagree", e.getMessage());
+    }
+  }
+
+  @Test public void bytesThrowsMoreThanIntMaxValue() {
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return Integer.MAX_VALUE + 1L;
+      }
+
+      @Override public BufferedSource source() {
+        throw new AssertionError();
+      }
+    };
+    try {
+      body.bytes();
+      fail();
+    } catch (IOException e) {
+      assertEquals("Cannot buffer entire body for content length: 2147483648", e.getMessage());
+    }
+  }
+
+  @Test public void byteStreamEmpty() throws IOException {
+    ResponseBody body = body("");
+    InputStream bytes = body.byteStream();
+    assertEquals(-1, bytes.read());
+  }
+
+  @Test public void byteStreamSeesBom() throws IOException {
+    ResponseBody body = body("efbbff68656c6c6f");
+    InputStream bytes = body.byteStream();
+    assertEquals(0xef, bytes.read());
+    assertEquals(0xbb, bytes.read());
+    assertEquals(0xff, bytes.read());
+    assertEquals("hello", exhaust(new InputStreamReader(bytes, "utf-8")));
+  }
+
+  @Test public void byteStreamClosesUnderlyingSource() throws IOException {
+    final AtomicBoolean closed = new AtomicBoolean();
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return 5;
+      }
+
+      @Override public BufferedSource source() {
+        Buffer source = new Buffer().writeUtf8("hello");
+        return Okio.buffer(new ForwardingSource(source) {
+          @Override public void close() throws IOException {
+            closed.set(true);
+            super.close();
+          }
+        });
+      }
+    };
+    body.byteStream().close();
+    assertTrue(closed.get());
+  }
+
+  @Test public void throwingUnderlyingSourceClosesQuietly() throws IOException {
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return 5;
+      }
+
+      @Override public BufferedSource source() {
+        Buffer source = new Buffer().writeUtf8("hello");
+        return Okio.buffer(new ForwardingSource(source) {
+          @Override public void close() throws IOException {
+            throw new IOException("Broken!");
+          }
+        });
+      }
+    };
+    assertEquals("hello", body.source().readUtf8());
+    body.close();
+  }
+
+  static ResponseBody body(String hex) {
+    return body(hex, null);
+  }
+
+  static ResponseBody body(String hex, String charset) {
+    MediaType mediaType = charset == null ? null : MediaType.parse("any/thing; charset=" + charset);
+    return ResponseBody.create(mediaType, ByteString.decodeHex(hex).toByteArray());
+  }
+
+  static String exhaust(Reader reader) throws IOException {
+    StringBuilder builder = new StringBuilder();
+    char[] buf = new char[10];
+    int read;
+    while ((read = reader.read(buf)) != -1) {
+      builder.append(buf, 0, read);
+    }
+    return builder.toString();
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/SocksProxy.java b/okhttp-tests/src/test/java/okhttp3/SocksProxy.java
index ce949ebaef..69ce1fab8c 100644
--- a/okhttp-tests/src/test/java/okhttp3/SocksProxy.java
+++ b/okhttp-tests/src/test/java/okhttp3/SocksProxy.java
@@ -160,7 +160,7 @@ private void acceptCommand(InetAddress fromAddress, BufferedSource fromSource,
         String domainName = fromSource.readUtf8(domainNameLength);
         // Resolve HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS to localhost.
         toAddress = domainName.equalsIgnoreCase(HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS)
-            ? InetAddress.getLoopbackAddress()
+            ? InetAddress.getByName("localhost")
             : InetAddress.getByName(domainName);
         break;
 
@@ -208,7 +208,7 @@ private void transfer(final InetAddress fromAddress, final InetAddress toAddress
         Buffer buffer = new Buffer();
         try {
           while (true) {
-            long byteCount = source.read(buffer, 2048L);
+            long byteCount = source.read(buffer, 8192L);
             if (byteCount == -1L) break;
             sink.write(buffer, byteCount);
             sink.emit();
diff --git a/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java b/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java
index 10f3cbb9d2..0ec9bc34fb 100644
--- a/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java
+++ b/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java
@@ -15,8 +15,9 @@
  */
 package okhttp3;
 
-import java.util.ArrayList;
-import java.util.List;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
 import java.util.logging.Handler;
 import java.util.logging.LogRecord;
 
@@ -25,23 +26,27 @@
  * assertions about them.
  */
 public final class TestLogHandler extends Handler {
-  private final List<String> logs = new ArrayList<>();
+  private final BlockingQueue<String> logs = new LinkedBlockingQueue<>();
 
-  @Override public synchronized void publish(LogRecord logRecord) {
-    logs.add(logRecord.getLevel() + ": " + logRecord.getMessage());
-    notifyAll();
+  @Override public void publish(LogRecord logRecord) {
+    if (getFormatter() == null) {
+      logs.add(logRecord.getLevel() + ": " + logRecord.getMessage());
+    } else {
+      logs.add(getFormatter().format(logRecord));
+    }
   }
 
   @Override public void flush() {
   }
 
-  @Override public void close() throws SecurityException {
+  @Override public void close() {
   }
 
-  public synchronized String take() throws InterruptedException {
-    while (logs.isEmpty()) {
-      wait();
+  public String take() throws InterruptedException {
+    String message = logs.poll(10, TimeUnit.SECONDS);
+    if (message == null) {
+      throw new AssertionError("Timed out waiting for log message.");
     }
-    return logs.remove(0);
+    return message;
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/TestUtil.java b/okhttp-tests/src/test/java/okhttp3/TestUtil.java
index a4581960eb..6f44cc5ba5 100644
--- a/okhttp-tests/src/test/java/okhttp3/TestUtil.java
+++ b/okhttp-tests/src/test/java/okhttp3/TestUtil.java
@@ -2,18 +2,16 @@
 
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collection;
-import java.util.LinkedHashSet;
 import java.util.List;
-import java.util.Set;
 import okhttp3.internal.SingleInetAddressDns;
-import okhttp3.internal.framed.Header;
+import okhttp3.internal.http2.Header;
 
 public final class TestUtil {
   private TestUtil() {
   }
 
   private static final ConnectionPool connectionPool = new ConnectionPool();
+  private static final Dispatcher dispatcher = new Dispatcher();
 
   /**
    * Returns an OkHttpClient for all tests to use as a starting point.
@@ -27,6 +25,7 @@ private TestUtil() {
   public static OkHttpClient defaultClient() {
     return new OkHttpClient.Builder()
         .connectionPool(connectionPool)
+        .dispatcher(dispatcher)
         .dns(new SingleInetAddressDns()) // Prevent unexpected fallback addresses.
         .build();
   }
@@ -39,17 +38,20 @@ public static OkHttpClient defaultClient() {
     return result;
   }
 
-  public static <T> Set<T> setOf(T... elements) {
-    return setOf(Arrays.asList(elements));
-  }
-
-  public static <T> Set<T> setOf(Collection<T> elements) {
-    return new LinkedHashSet<>(elements);
-  }
-
   public static String repeat(char c, int count) {
     char[] array = new char[count];
     Arrays.fill(array, c);
     return new String(array);
   }
+
+  /**
+   * See FinalizationTester for discussion on how to best trigger GC in tests.
+   * https://android.googlesource.com/platform/libcore/+/master/support/src/test/java/libcore/
+   * java/lang/ref/FinalizationTester.java
+   */
+  public static void awaitGarbageCollection() throws InterruptedException {
+    Runtime.getRuntime().gc();
+    Thread.sleep(100);
+    System.runFinalization();
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
index c50838c2fa..2e71146771 100644
--- a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
@@ -34,7 +34,7 @@
 import java.net.URL;
 import java.net.URLConnection;
 import java.net.UnknownHostException;
-import java.security.SecureRandom;
+import java.security.KeyStore;
 import java.security.cert.CertificateException;
 import java.security.cert.X509Certificate;
 import java.util.ArrayList;
@@ -56,16 +56,16 @@
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
 import javax.net.ssl.X509TrustManager;
 import okhttp3.internal.DoubleInetAddressDns;
 import okhttp3.internal.Internal;
-import okhttp3.internal.Platform;
 import okhttp3.internal.RecordingAuthenticator;
 import okhttp3.internal.RecordingOkAuthenticator;
 import okhttp3.internal.SingleInetAddressDns;
-import okhttp3.internal.SslContextBuilder;
 import okhttp3.internal.Util;
 import okhttp3.internal.Version;
+import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
@@ -85,9 +85,9 @@
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 import static okhttp3.TestUtil.defaultClient;
 import static okhttp3.internal.Util.UTF_8;
-import static okhttp3.internal.http.OkHeaders.SELECTED_PROTOCOL;
 import static okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT;
 import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
+import static okhttp3.internal.huc.OkHttpURLConnection.SELECTED_PROTOCOL;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
@@ -101,6 +101,7 @@
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeTrue;
 
 /** Android's URLConnectionTest. */
 public final class URLConnectionTest {
@@ -108,7 +109,7 @@
   @Rule public final MockWebServer server2 = new MockWebServer();
   @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
 
-  private SSLContext sslContext = SslContextBuilder.localhost();
+  private SslClient sslClient = SslClient.localhost();
   private OkUrlFactory urlFactory;
   private HttpURLConnection connection;
   private Cache cache;
@@ -321,6 +322,29 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
     assertEquals("body", server.takeRequest().getBody().readUtf8());
   }
 
+  @Test public void streamedBodyIsNotRetried() throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
+
+    urlFactory = new OkUrlFactory(new OkHttpClient.Builder()
+        .dns(new DoubleInetAddressDns())
+        .build());
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
+    connection.setDoOutput(true);
+    connection.setChunkedStreamingMode(100);
+    OutputStream os = connection.getOutputStream();
+    os.write("OutputStream is no fun.".getBytes("UTF-8"));
+    os.close();
+
+    try {
+      connection.getResponseCode();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    assertEquals(1, server.getRequestCount());
+  }
+
   @Test public void getErrorStreamOnSuccessfulRequest() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
     connection = urlFactory.open(server.url("/").url());
@@ -404,6 +428,9 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
   @Test public void invalidHost() throws Exception {
     // Note that 1234.1.1.1 is an invalid host in a URI, but URL isn't as strict.
     URL url = new URL("http://1234.1.1.1/index.html");
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .dns(new FakeDns())
+        .build());
     HttpURLConnection connection = urlFactory.open(url);
     try {
       connection.connect();
@@ -519,11 +546,11 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
   }
 
   @Test public void connectViaHttps() throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslContext.getSocketFactory())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build());
     connection = urlFactory.open(server.url("/foo").url());
@@ -535,11 +562,11 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
   }
 
   @Test public void inspectHandshakeThroughoutRequestLifecycle() throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse());
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslContext.getSocketFactory())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build());
 
@@ -567,16 +594,16 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
   }
 
   @Test public void connectViaHttpsReusingConnections() throws IOException, InterruptedException {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
     server.enqueue(new MockResponse().setBody("another response via HTTPS"));
 
     // The pool will only reuse sockets if the SSL socket factories are the same.
-    SSLSocketFactory clientSocketFactory = sslContext.getSocketFactory();
+    SSLSocketFactory clientSocketFactory = sslClient.socketFactory;
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(clientSocketFactory)
+        .sslSocketFactory(clientSocketFactory, sslClient.trustManager)
         .hostnameVerifier(hostnameVerifier)
         .build());
     connection = urlFactory.open(server.url("/").url());
@@ -590,13 +617,13 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
   }
 
   @Test public void connectViaHttpsReusingConnectionsDifferentFactories() throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
     server.enqueue(new MockResponse().setBody("another response via HTTPS"));
 
     // install a custom SSL socket factory so the server can be authorized
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslContext.getSocketFactory())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build());
     HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
@@ -605,8 +632,14 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
     SSLContext sslContext2 = SSLContext.getInstance("TLS");
     sslContext2.init(null, null, null);
     SSLSocketFactory sslSocketFactory2 = sslContext2.getSocketFactory();
+
+    TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+        TrustManagerFactory.getDefaultAlgorithm());
+    trustManagerFactory.init((KeyStore) null);
+    X509TrustManager trustManager = (X509TrustManager) trustManagerFactory.getTrustManagers()[0];
+
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslSocketFactory2)
+        .sslSocketFactory(sslSocketFactory2, trustManager)
         .build());
     HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
     try {
@@ -619,32 +652,35 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
   // TODO(jwilson): tests below this marker need to be migrated to OkHttp's request/response API.
 
   @Test public void connectViaHttpsWithSSLFallback() throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
     server.enqueue(new MockResponse().setBody("this response comes via SSL"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
         .hostnameVerifier(new RecordingHostnameVerifier())
-        .sslSocketFactory(suppressTlsFallbackClientSocketFactory())
+        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
         .build());
     connection = urlFactory.open(server.url("/foo").url());
 
     assertContent("this response comes via SSL", connection);
 
-    RecordedRequest request = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-    assertEquals(TlsVersion.TLS_1_0, request.getTlsVersion());
+    RecordedRequest failHandshakeRequest = server.takeRequest();
+    assertNull(failHandshakeRequest.getRequestLine());
+
+    RecordedRequest fallbackRequest = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", fallbackRequest.getRequestLine());
+    assertEquals(TlsVersion.TLS_1_0, fallbackRequest.getTlsVersion());
   }
 
   @Test public void connectViaHttpsWithSSLFallbackFailuresRecorded() throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
     server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
         .dns(new SingleInetAddressDns())
         .hostnameVerifier(new RecordingHostnameVerifier())
-        .sslSocketFactory(suppressTlsFallbackClientSocketFactory())
+        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
         .build());
     connection = urlFactory.open(server.url("/foo").url());
 
@@ -663,7 +699,7 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
    * https://github.com/square/okhttp/issues/515
    */
   @Test public void sslFallbackNotUsedWhenRecycledConnectionFails() throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse()
         .setBody("abc")
         .setSocketPolicy(DISCONNECT_AT_END));
@@ -671,7 +707,7 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
 
     urlFactory.setClient(urlFactory.client().newBuilder()
         .hostnameVerifier(new RecordingHostnameVerifier())
-        .sslSocketFactory(suppressTlsFallbackClientSocketFactory())
+        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
         .build());
 
     assertContent("abc", urlFactory.open(server.url("/").url()));
@@ -697,7 +733,7 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
    * http://code.google.com/p/android/issues/detail?id=13178
    */
   @Test public void connectViaHttpsToUntrustedServer() throws IOException, InterruptedException {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse()); // unused
 
     connection = urlFactory.open(server.url("/foo").url());
@@ -779,9 +815,9 @@ public Socket createSocket(String host, int port, InetAddress localHost, int loc
     };
 
     if (useHttps) {
-      server.useHttps(sslContext.getSocketFactory(), false);
+      server.useHttps(sslClient.socketFactory, false);
       urlFactory.setClient(urlFactory.client().newBuilder()
-          .sslSocketFactory(sslContext.getSocketFactory())
+          .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
           .hostnameVerifier(new RecordingHostnameVerifier())
           .build());
     }
@@ -859,12 +895,12 @@ public Socket createSocket(String host, int port, InetAddress localHost, int loc
   }
 
   private void testConnectViaDirectProxyToHttps(ProxyConfig proxyConfig) throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
 
     URL url = server.url("/foo").url();
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslContext.getSocketFactory())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build());
     connection = proxyConfig.connect(server, urlFactory, url);
@@ -898,14 +934,14 @@ private void testConnectViaDirectProxyToHttps(ProxyConfig proxyConfig) throws Ex
   private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exception {
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
 
-    server.useHttps(sslContext.getSocketFactory(), true);
+    server.useHttps(sslClient.socketFactory, true);
     server.enqueue(
         new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("this response comes via a secure proxy"));
 
     URL url = new URL("https://android.com/foo");
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslContext.getSocketFactory())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
         .hostnameVerifier(hostnameVerifier)
         .build());
     connection = proxyConfig.connect(server, urlFactory, url);
@@ -927,7 +963,7 @@ private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exce
   @Test public void connectViaHttpProxyToHttpsUsingBadProxyAndHttpResponseCache() throws Exception {
     initResponseCache();
 
-    server.useHttps(sslContext.getSocketFactory(), true);
+    server.useHttps(sslClient.socketFactory, true);
     // The inclusion of a body in the response to a CONNECT is key to reproducing b/6754912.
     MockResponse badProxyResponse = new MockResponse()
         .setSocketPolicy(UPGRADE_TO_SSL_AT_END)
@@ -939,7 +975,7 @@ private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exce
     // failure to fail permanently.
     urlFactory.setClient(urlFactory.client().newBuilder()
         .dns(new SingleInetAddressDns())
-        .sslSocketFactory(sslContext.getSocketFactory())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
         .connectionSpecs(Util.immutableList(ConnectionSpec.MODERN_TLS))
         .hostnameVerifier(new RecordingHostnameVerifier())
         .proxy(server.toProxyAddress())
@@ -966,14 +1002,14 @@ private void initResponseCache() throws IOException {
       throws IOException, InterruptedException {
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
 
-    server.useHttps(sslContext.getSocketFactory(), true);
+    server.useHttps(sslClient.socketFactory, true);
     server.enqueue(
         new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("encrypted response from the origin server"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
         .proxy(server.toProxyAddress())
-        .sslSocketFactory(sslContext.getSocketFactory())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
         .hostnameVerifier(hostnameVerifier)
         .build());
 
@@ -998,7 +1034,7 @@ private void initResponseCache() throws IOException {
 
   @Test public void proxyAuthenticateOnConnect() throws Exception {
     Authenticator.setDefault(new RecordingAuthenticator());
-    server.useHttps(sslContext.getSocketFactory(), true);
+    server.useHttps(sslClient.socketFactory, true);
     server.enqueue(new MockResponse().setResponseCode(407)
         .addHeader("Proxy-Authenticate: Basic realm=\"localhost\""));
     server.enqueue(
@@ -1008,7 +1044,7 @@ private void initResponseCache() throws IOException {
     urlFactory.setClient(urlFactory.client().newBuilder()
         .proxyAuthenticator(new JavaNetAuthenticator())
         .proxy(server.toProxyAddress())
-        .sslSocketFactory(sslContext.getSocketFactory())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build());
 
@@ -1033,14 +1069,14 @@ private void initResponseCache() throws IOException {
   // Don't disconnect after building a tunnel with CONNECT
   // http://code.google.com/p/android/issues/detail?id=37221
   @Test public void proxyWithConnectionClose() throws IOException {
-    server.useHttps(sslContext.getSocketFactory(), true);
+    server.useHttps(sslClient.socketFactory, true);
     server.enqueue(
         new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("this response comes via a proxy"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
         .proxy(server.toProxyAddress())
-        .sslSocketFactory(sslContext.getSocketFactory())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build());
 
@@ -1052,7 +1088,7 @@ private void initResponseCache() throws IOException {
   }
 
   @Test public void proxyWithConnectionReuse() throws IOException {
-    SSLSocketFactory socketFactory = sslContext.getSocketFactory();
+    SSLSocketFactory socketFactory = sslClient.socketFactory;
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
 
     server.useHttps(socketFactory, true);
@@ -1063,7 +1099,7 @@ private void initResponseCache() throws IOException {
 
     urlFactory.setClient(urlFactory.client().newBuilder()
         .proxy(server.toProxyAddress())
-        .sslSocketFactory(socketFactory)
+        .sslSocketFactory(socketFactory, sslClient.trustManager)
         .hostnameVerifier(hostnameVerifier)
         .build());
     URL url = new URL("https://android.com/foo");
@@ -1301,11 +1337,11 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
   private void testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind transferKind,
       boolean tls) throws Exception {
     if (tls) {
-      SSLSocketFactory socketFactory = sslContext.getSocketFactory();
+      SSLSocketFactory socketFactory = sslClient.socketFactory;
       RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
       server.useHttps(socketFactory, false);
       urlFactory.setClient(urlFactory.client().newBuilder()
-          .sslSocketFactory(socketFactory)
+          .sslSocketFactory(socketFactory, sslClient.trustManager)
           .hostnameVerifier(hostnameVerifier)
           .build());
     }
@@ -1412,7 +1448,7 @@ private void testEarlyDisconnectDoesntHarmPooling(TransferKind transferKind) thr
     // If we're working correctly, this should be greater than 100ms, but less than double that.
     // Previously we had a bug where we would download the entire response body as long as no
     // individual read took longer than 100ms.
-    assertTrue(String.format("Time to close: %sms", elapsedMillis), elapsedMillis < 500);
+    assertTrue(Util.format("Time to close: %sms", elapsedMillis), elapsedMillis < 500);
 
     // Do another request to confirm that the discarded connection was not pooled.
     assertContent("A", urlFactory.open(server.url("/").url()));
@@ -1483,11 +1519,6 @@ private void testAuthenticateWithStreamingPost(StreamingMode streamingMode) thro
     postBodyRetransmittedAfterAuthorizationFail("abc");
   }
 
-  @Test public void postBodyRetransmittedAfterAuthorizationFail_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    postBodyRetransmittedAfterAuthorizationFail("abc");
-  }
-
   @Test public void postBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
     enableProtocol(Protocol.HTTP_2);
     postBodyRetransmittedAfterAuthorizationFail("abc");
@@ -1498,11 +1529,6 @@ private void testAuthenticateWithStreamingPost(StreamingMode streamingMode) thro
     postBodyRetransmittedAfterAuthorizationFail("");
   }
 
-  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    postBodyRetransmittedAfterAuthorizationFail("");
-  }
-
   @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
     enableProtocol(Protocol.HTTP_2);
     postBodyRetransmittedAfterAuthorizationFail("");
@@ -1523,6 +1549,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     outputStream.write(body.getBytes("UTF-8"));
     outputStream.close();
     assertEquals(200, connection.getResponseCode());
+    connection.getInputStream().close();
 
     RecordedRequest recordedRequest1 = server.takeRequest();
     assertEquals("POST", recordedRequest1.getMethod());
@@ -1741,11 +1768,11 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
    * http://code.google.com/p/android/issues/detail?id=12860
    */
   private void testSecureStreamingPost(StreamingMode streamingMode) throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse().setBody("Success!"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslContext.getSocketFactory())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build());
     connection = urlFactory.open(server.url("/").url());
@@ -1926,14 +1953,14 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
   }
 
   @Test public void redirectedOnHttps() throws IOException, InterruptedException {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .addHeader("Location: /foo")
         .setBody("This page has moved!"));
     server.enqueue(new MockResponse().setBody("This is the new location!"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslContext.getSocketFactory())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build());
     connection = urlFactory.open(server.url("/").url());
@@ -1948,14 +1975,14 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
   }
 
   @Test public void notRedirectedFromHttpsToHttp() throws IOException, InterruptedException {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .addHeader("Location: http://anyhost/foo")
         .setBody("This page has moved!"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
         .followSslRedirects(false)
-        .sslSocketFactory(sslContext.getSocketFactory())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build());
     connection = urlFactory.open(server.url("/").url());
@@ -1977,13 +2004,13 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
   @Test public void redirectedFromHttpsToHttpFollowingProtocolRedirects() throws Exception {
     server2.enqueue(new MockResponse().setBody("This is insecure HTTP!"));
 
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .addHeader("Location: " + server2.url("/").url())
         .setBody("This page has moved!"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslContext.getSocketFactory())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
         .hostnameVerifier(new RecordingHostnameVerifier())
         .followSslRedirects(true)
         .build());
@@ -1997,7 +2024,7 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
   }
 
   @Test public void redirectedFromHttpToHttpsFollowingProtocolRedirects() throws Exception {
-    server2.useHttps(sslContext.getSocketFactory(), false);
+    server2.useHttps(sslClient.socketFactory, false);
     server2.enqueue(new MockResponse().setBody("This is secure HTTPS!"));
 
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
@@ -2005,7 +2032,7 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
         .setBody("This page has moved!"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslContext.getSocketFactory())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
         .hostnameVerifier(new RecordingHostnameVerifier())
         .followSslRedirects(true)
         .build());
@@ -2024,11 +2051,11 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
 
   private void redirectToAnotherOriginServer(boolean https) throws Exception {
     if (https) {
-      server.useHttps(sslContext.getSocketFactory(), false);
-      server2.useHttps(sslContext.getSocketFactory(), false);
+      server.useHttps(sslClient.socketFactory, false);
+      server2.useHttps(sslClient.socketFactory, false);
       server2.setProtocolNegotiationEnabled(false);
       urlFactory.setClient(urlFactory.client().newBuilder()
-          .sslSocketFactory(sslContext.getSocketFactory())
+          .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
           .hostnameVerifier(new RecordingHostnameVerifier())
           .build());
     }
@@ -2058,7 +2085,7 @@ private void redirectToAnotherOriginServer(boolean https) throws Exception {
   }
 
   @Test public void redirectWithProxySelector() throws Exception {
-    final List<URI> proxySelectionRequests = new ArrayList<URI>();
+    final List<URI> proxySelectionRequests = new ArrayList<>();
     urlFactory.setClient(urlFactory.client().newBuilder()
         .proxySelector(new ProxySelector() {
           @Override public List<Proxy> select(URI uri) {
@@ -2299,22 +2326,21 @@ private void testRedirect(boolean temporary, String method) throws Exception {
     } catch (ProtocolException expected) {
       assertEquals(HttpURLConnection.HTTP_MOVED_TEMP, connection.getResponseCode());
       assertEquals("Too many follow-up requests: 21", expected.getMessage());
-      assertContent("Redirecting to /21", connection);
       assertEquals(server.url("/20").url(), connection.getURL());
     }
   }
 
   @Test public void httpsWithCustomTrustManager() throws Exception {
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-    RecordingTrustManager trustManager = new RecordingTrustManager(sslContext);
-    SSLContext sc = SSLContext.getInstance("TLS");
-    sc.init(null, new TrustManager[] {trustManager}, new SecureRandom());
+    RecordingTrustManager trustManager = new RecordingTrustManager(sslClient.trustManager);
+    SSLContext sslContext = SSLContext.getInstance("TLS");
+    sslContext.init(null, new TrustManager[] { trustManager }, null);
 
     urlFactory.setClient(urlFactory.client().newBuilder()
         .hostnameVerifier(hostnameVerifier)
-        .sslSocketFactory(sc.getSocketFactory())
+        .sslSocketFactory(sslContext.getSocketFactory(), trustManager)
         .build());
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse().setBody("ABC"));
     server.enqueue(new MockResponse().setBody("DEF"));
     server.enqueue(new MockResponse().setBody("GHI"));
@@ -2374,6 +2400,7 @@ private void enqueueClientRequestTimeoutResponses() {
 
     assertEquals(408, connection.getResponseCode());
     assertEquals(1, server.getRequestCount());
+    connection.getErrorStream().close();
   }
 
   @Test public void readTimeouts() throws IOException {
@@ -2508,9 +2535,8 @@ protected ServerSocket configureServerSocket(ServerSocket serverSocket)
    * https://code.google.com/p/android/issues/detail?id=41576
    */
   @Test public void sameConnectionRedirectAndReuse() throws Exception {
-    // TODO(jwilson): this behavior shouldn't rely on having another IP address to attempt.
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .dns(new DoubleInetAddressDns())
+        .dns(new SingleInetAddressDns())
         .build());
     server.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
@@ -2526,12 +2552,17 @@ protected ServerSocket configureServerSocket(ServerSocket serverSocket)
   }
 
   @Test public void responseCodeDisagreesWithHeaders() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NO_CONTENT)
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NO_CONTENT)
         .setBody("This body is not allowed!"));
 
     URLConnection connection = urlFactory.open(server.url("/").url());
-    assertEquals("This body is not allowed!",
-        readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+    try {
+      connection.getInputStream();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("HTTP 204 had non-zero Content-Length: 25", expected.getMessage());
+    }
   }
 
   @Test public void singleByteReadIsSigned() throws IOException {
@@ -2604,6 +2635,9 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
   }
 
   @Test public void dnsFailureThrowsIOException() throws IOException {
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .dns(new FakeDns())
+        .build());
     connection = urlFactory.open(new URL("http://host.unlikelytld"));
     try {
       connection.connect();
@@ -2939,16 +2973,6 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     fail("TODO");
   }
 
-  @Test @Ignore public void headerNamesContainingNullCharacter() {
-    // This is relevant for SPDY
-    fail("TODO");
-  }
-
-  @Test @Ignore public void headerValuesContainingNullCharacter() {
-    // This is relevant for SPDY
-    fail("TODO");
-  }
-
   @Test public void emptyRequestHeaderValueIsAllowed() throws Exception {
     server.enqueue(new MockResponse().setBody("body"));
     connection = urlFactory.open(server.url("/").url());
@@ -3143,10 +3167,6 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     }
   }
 
-  @Test public void setsNegotiatedProtocolHeader_SPDY_3() throws Exception {
-    setsNegotiatedProtocolHeader(Protocol.SPDY_3);
-  }
-
   @Test public void setsNegotiatedProtocolHeader_HTTP_2() throws Exception {
     setsNegotiatedProtocolHeader(Protocol.HTTP_2);
   }
@@ -3182,11 +3202,6 @@ private void setsNegotiatedProtocolHeader(Protocol protocol) throws IOException
     zeroLengthPayload("POST");
   }
 
-  @Test public void zeroLengthPost_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    zeroLengthPost();
-  }
-
   @Test public void zeroLengthPost_HTTP_2() throws Exception {
     enableProtocol(Protocol.HTTP_2);
     zeroLengthPost();
@@ -3197,11 +3212,6 @@ private void setsNegotiatedProtocolHeader(Protocol protocol) throws IOException
     zeroLengthPayload("PUT");
   }
 
-  @Test public void zeroLengthPut_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    zeroLengthPut();
-  }
-
   @Test public void zeroLengthPut_HTTP_2() throws Exception {
     enableProtocol(Protocol.HTTP_2);
     zeroLengthPut();
@@ -3246,7 +3256,7 @@ private void zeroLengthPayload(String method)
 
   @Test public void setProtocolsWithoutHttp11() throws Exception {
     try {
-      new OkHttpClient.Builder().protocols(Arrays.asList(Protocol.SPDY_3));
+      new OkHttpClient.Builder().protocols(Arrays.asList(Protocol.HTTP_2));
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -3448,6 +3458,78 @@ private void zeroLengthPayload(String method)
     testInstanceFollowsRedirects("https://www.google.com/");
   }
 
+  @Test public void setSslSocketFactoryFailsOnJdk9() throws Exception {
+    assumeTrue(getPlatform().equals("jdk9"));
+
+    enableProtocol(Protocol.HTTP_2);
+    URL url = server.url("/").url();
+    HttpsURLConnection connection = (HttpsURLConnection) urlFactory.open(url);
+    try {
+      connection.setSSLSocketFactory(sslClient.socketFactory);
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+  }
+
+  /** Confirm that runtime exceptions thrown inside of OkHttp propagate to the caller. */
+  @Test public void unexpectedExceptionSync() throws Exception {
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .dns(new Dns() {
+          @Override public List<InetAddress> lookup(String hostname) {
+            throw new RuntimeException("boom!");
+          }
+        })
+        .build());
+
+    server.enqueue(new MockResponse());
+
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
+    try {
+      connection.getResponseCode(); // Use the synchronous implementation.
+      fail();
+    } catch (RuntimeException expected) {
+      assertEquals("boom!", expected.getMessage());
+    }
+  }
+
+  /** Confirm that runtime exceptions thrown inside of OkHttp propagate to the caller. */
+  @Test public void unexpectedExceptionAsync() throws Exception {
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .dns(new Dns() {
+          @Override public List<InetAddress> lookup(String hostname) {
+            throw new RuntimeException("boom!");
+          }
+        })
+        .build());
+
+    server.enqueue(new MockResponse());
+
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
+    try {
+      connection.connect(); // Force the async implementation.
+      fail();
+    } catch (RuntimeException expected) {
+      assertEquals("boom!", expected.getMessage());
+    }
+  }
+
+  @Test public void callsNotManagedByDispatcher() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    Dispatcher dispatcher = urlFactory.client().dispatcher();
+    assertEquals(0, dispatcher.runningCallsCount());
+
+    connection = urlFactory.open(server.url("/").url());
+    assertEquals(0, dispatcher.runningCallsCount());
+
+    connection.connect();
+    assertEquals(0, dispatcher.runningCallsCount());
+
+    assertContent("abc", connection);
+    assertEquals(0, dispatcher.runningCallsCount());
+  }
+
   private void testInstanceFollowsRedirects(String spec) throws Exception {
     URL url = new URL(spec);
     HttpURLConnection urlConnection = urlFactory.open(url);
@@ -3583,11 +3665,11 @@ public abstract HttpURLConnection connect(
   }
 
   private static class RecordingTrustManager implements X509TrustManager {
-    private final List<String> calls = new ArrayList<String>();
+    private final List<String> calls = new ArrayList<>();
     private final X509TrustManager delegate;
 
-    public RecordingTrustManager(SSLContext sslContext) {
-      this.delegate = Platform.get().trustManager(sslContext.getSocketFactory());
+    public RecordingTrustManager(X509TrustManager delegate) {
+      this.delegate = delegate;
     }
 
     public X509Certificate[] getAcceptedIssuers() {
@@ -3605,7 +3687,7 @@ public void checkServerTrusted(X509Certificate[] chain, String authType)
     }
 
     private String certificatesToString(X509Certificate[] certificates) {
-      List<String> result = new ArrayList<String>();
+      List<String> result = new ArrayList<>();
       for (X509Certificate certificate : certificates) {
         result.add(certificate.getSubjectDN() + " " + certificate.getSerialNumber());
       }
@@ -3619,11 +3701,11 @@ private String certificatesToString(X509Certificate[] certificates) {
    */
   private void enableProtocol(Protocol protocol) {
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslContext.getSocketFactory())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
         .hostnameVerifier(new RecordingHostnameVerifier())
         .protocols(Arrays.asList(protocol, Protocol.HTTP_1_1))
         .build());
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     server.setProtocolNegotiationEnabled(true);
     server.setProtocols(urlFactory.client().protocols());
   }
@@ -3634,6 +3716,10 @@ private void enableProtocol(Protocol protocol) {
    * for details.
    */
   private FallbackTestClientSocketFactory suppressTlsFallbackClientSocketFactory() {
-    return new FallbackTestClientSocketFactory(sslContext.getSocketFactory());
+    return new FallbackTestClientSocketFactory(sslClient.socketFactory);
+  }
+
+  private String getPlatform() {
+    return System.getProperty("okhttp.platform", "platform");
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java b/okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java
index 1645acc907..56611be40a 100644
--- a/okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java
+++ b/okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java
@@ -20,6 +20,7 @@
 import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.Map;
+import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.ByteString;
 
@@ -231,7 +232,7 @@ private void testParseAlreadyEncoded(int codePoint, Encoding encoding, Component
     String urlString = component.urlString(encoded);
     HttpUrl url = HttpUrl.parse(urlString);
     if (!component.encodedValue(url).equals(encoded)) {
-      fail(String.format("Encoding %s %#x using %s", component, codePoint, encoding));
+      fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
     }
   }
 
@@ -242,7 +243,7 @@ private void testEncodeAndDecode(int codePoint, Component component) {
     HttpUrl url = builder.build();
     String actual = component.get(url);
     if (!expected.equals(actual)) {
-      fail(String.format("Roundtrip %s %#x %s", component, codePoint, url));
+      fail(Util.format("Roundtrip %s %#x %s", component, codePoint, url));
     }
   }
 
@@ -255,7 +256,7 @@ private void testParseOriginal(int codePoint, Encoding encoding, Component compo
 
     String s = component.encodedValue(url);
     if (!s.equals(encoded)) {
-      fail(String.format("Encoding %s %#02x using %s", component, codePoint, encoding));
+      fail(Util.format("Encoding %s %#02x using %s", component, codePoint, encoding));
     }
   }
 
@@ -264,7 +265,7 @@ private void testToUrl(int codePoint, Encoding encoding, Component component) {
     HttpUrl httpUrl = HttpUrl.parse(component.urlString(encoded));
     URL javaNetUrl = httpUrl.url();
     if (!javaNetUrl.toString().equals(javaNetUrl.toString())) {
-      fail(String.format("Encoding %s %#x using %s", component, codePoint, encoding));
+      fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
     }
   }
 
@@ -273,7 +274,7 @@ private void testFromUrl(int codePoint, Encoding encoding, Component component)
     HttpUrl httpUrl = HttpUrl.parse(component.urlString(encoded));
     HttpUrl toAndFromJavaNetUrl = HttpUrl.get(httpUrl.url());
     if (!toAndFromJavaNetUrl.equals(httpUrl)) {
-      fail(String.format("Encoding %s %#x using %s", component, codePoint, encoding));
+      fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
     }
   }
 
@@ -287,18 +288,18 @@ private void testUri(
     if (uriEscaped) {
       // The URI has more escaping than the HttpURL. Check that the decoded values still match.
       if (uri.toString().equals(httpUrl.toString())) {
-        fail(String.format("Encoding %s %#x using %s", component, codePoint, encoding));
+        fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
       }
       if (!component.get(toAndFromUri).equals(string)) {
-        fail(String.format("Encoding %s %#x using %s", component, codePoint, encoding));
+        fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
       }
     } else {
       // Check that the URI and HttpURL have the exact same escaping.
       if (!toAndFromUri.equals(httpUrl)) {
-        fail(String.format("Encoding %s %#x using %s", component, codePoint, encoding));
+        fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
       }
       if (!uri.toString().equals(httpUrl.toString())) {
-        fail(String.format("Encoding %s %#x using %s", component, codePoint, encoding));
+        fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
       }
     }
   }
@@ -315,7 +316,7 @@ public String encode(int codePoint) {
         ByteString utf8 = ByteString.encodeUtf8(IDENTITY.encode(codePoint));
         Buffer percentEncoded = new Buffer();
         for (int i = 0; i < utf8.size(); i++) {
-          percentEncoded.writeUtf8(String.format("%%%02X", utf8.getByte(i) & 0xff));
+          percentEncoded.writeUtf8(Util.format("%%%02X", utf8.getByte(i) & 0xff));
         }
         return percentEncoded.readUtf8();
       }
diff --git a/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTestData.java b/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTestData.java
index 881811139d..72f92f9abf 100644
--- a/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTestData.java
+++ b/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTestData.java
@@ -19,6 +19,7 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
+import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSource;
 
@@ -81,7 +82,7 @@ private void set(String name, String value) {
   }
 
   @Override public String toString() {
-    return String.format("Parsing: <%s> against <%s>", input, base);
+    return Util.format("Parsing: <%s> against <%s>", input, base);
   }
 
   public static List<WebPlatformUrlTestData> load(BufferedSource source) throws IOException {
diff --git a/okhttp-tests/src/test/java/okhttp3/WebSocketCallTest.java b/okhttp-tests/src/test/java/okhttp3/WebSocketCallTest.java
new file mode 100644
index 0000000000..d7eadbedb9
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/WebSocketCallTest.java
@@ -0,0 +1,399 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.util.Random;
+import java.util.logging.Logger;
+import okhttp3.internal.tls.SslClient;
+import okhttp3.internal.ws.EmptyWebSocketListener;
+import okhttp3.internal.ws.WebSocketRecorder;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okio.ByteString;
+import org.junit.After;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static okhttp3.WebSocket.BINARY;
+import static okhttp3.WebSocket.TEXT;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.fail;
+
+public final class WebSocketCallTest {
+  @Rule public final MockWebServer webServer = new MockWebServer();
+
+  private final SslClient sslClient = SslClient.localhost();
+  private final WebSocketRecorder clientListener = new WebSocketRecorder("client");
+  private final WebSocketRecorder serverListener = new WebSocketRecorder("server");
+  private final Random random = new Random(0);
+  private OkHttpClient client = new OkHttpClient.Builder()
+      .addInterceptor(new Interceptor() {
+        @Override public Response intercept(Chain chain) throws IOException {
+          Response response = chain.proceed(chain.request());
+          assertNotNull(response.body()); // Ensure application interceptors never see a null body.
+          return response;
+        }
+      })
+      .build();
+
+  @After public void tearDown() {
+    clientListener.assertExhausted();
+  }
+
+  @Test public void textMessage() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    enqueueClientWebSocket();
+
+    WebSocket client = clientListener.assertOpen();
+    serverListener.assertOpen();
+
+    client.sendMessage(RequestBody.create(TEXT, "Hello, WebSockets!"));
+    serverListener.assertTextMessage("Hello, WebSockets!");
+  }
+
+  @Test public void binaryMessage() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    enqueueClientWebSocket();
+
+    WebSocket client = clientListener.assertOpen();
+    serverListener.assertOpen();
+
+    client.sendMessage(RequestBody.create(BINARY, "Hello!"));
+    serverListener.assertBinaryMessage(new byte[] {'H', 'e', 'l', 'l', 'o', '!'});
+  }
+
+  @Test public void nullMessageThrows() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    enqueueClientWebSocket();
+
+    WebSocket client = clientListener.assertOpen();
+    try {
+      client.sendMessage(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertEquals("message == null", e.getMessage());
+    }
+  }
+
+  @Test public void missingContentTypeThrows() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    enqueueClientWebSocket();
+
+    WebSocket client = clientListener.assertOpen();
+    try {
+      client.sendMessage(RequestBody.create(null, "Hey!"));
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("Message content type was null. Must use WebSocket.TEXT or WebSocket.BINARY.",
+          e.getMessage());
+    }
+  }
+
+  @Test public void unknownContentTypeThrows() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    enqueueClientWebSocket();
+
+    WebSocket client = clientListener.assertOpen();
+    try {
+      client.sendMessage(RequestBody.create(MediaType.parse("text/plain"), "Hey!"));
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals(
+          "Unknown message content type: text/plain. Must use WebSocket.TEXT or WebSocket.BINARY.",
+          e.getMessage());
+    }
+  }
+
+  @Test public void pingPong() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    enqueueClientWebSocket();
+
+    WebSocket client = clientListener.assertOpen();
+
+    client.sendPing(ByteString.encodeUtf8("Hello, WebSockets!"));
+    clientListener.assertPong(ByteString.encodeUtf8("Hello, WebSockets!"));
+  }
+
+  @Test public void nullPingPayloadThrows() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    enqueueClientWebSocket();
+
+    WebSocket client = clientListener.assertOpen();
+    try {
+      client.sendPing(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertEquals("payload == null", e.getMessage());
+    }
+  }
+
+  @Test public void serverMessage() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    enqueueClientWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+
+    server.sendMessage(RequestBody.create(TEXT, "Hello, WebSockets!"));
+    clientListener.assertTextMessage("Hello, WebSockets!");
+  }
+
+  @Test public void throwingOnOpenClosesAndFails() {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    final RuntimeException e = new RuntimeException();
+    clientListener.setNextEventDelegate(new EmptyWebSocketListener() {
+      @Override public void onOpen(WebSocket webSocket, Response response) {
+        throw e;
+      }
+    });
+    enqueueClientWebSocket();
+
+    serverListener.assertOpen();
+    serverListener.assertClose(1001, "");
+    clientListener.assertFailure(e);
+  }
+
+  @Ignore("AsyncCall currently lets runtime exceptions propagate.")
+  @Test public void throwingOnFailLogs() throws InterruptedException {
+    TestLogHandler logs = new TestLogHandler();
+    Logger logger = Logger.getLogger(OkHttpClient.class.getName());
+    logger.addHandler(logs);
+
+    webServer.enqueue(new MockResponse().setResponseCode(200).setBody("Body"));
+
+    final RuntimeException e = new RuntimeException();
+    clientListener.setNextEventDelegate(new EmptyWebSocketListener() {
+      @Override public void onFailure(Throwable t, Response response) {
+        throw e;
+      }
+    });
+
+    enqueueClientWebSocket();
+
+    assertEquals("", logs.take());
+    logger.removeHandler(logs);
+  }
+
+  @Test public void throwingOnMessageClosesAndFails() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    enqueueClientWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+
+    final RuntimeException e = new RuntimeException();
+    clientListener.setNextEventDelegate(new EmptyWebSocketListener() {
+      @Override public void onMessage(ResponseBody message) {
+        throw e;
+      }
+    });
+
+    server.sendMessage(RequestBody.create(TEXT, "Hello, WebSockets!"));
+    clientListener.assertFailure(e);
+    serverListener.assertClose(1001, "");
+  }
+
+  @Test public void throwingOnOnPongClosesAndFails() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    enqueueClientWebSocket();
+
+    WebSocket client = clientListener.assertOpen();
+    serverListener.assertOpen();
+
+    final RuntimeException e = new RuntimeException();
+    clientListener.setNextEventDelegate(new EmptyWebSocketListener() {
+      @Override public void onPong(ByteString payload) {
+        throw e;
+      }
+    });
+
+    client.sendPing(ByteString.EMPTY);
+    clientListener.assertFailure(e);
+    serverListener.assertClose(1001, "");
+  }
+
+  @Test public void throwingOnCloseClosesNormallyAndFails() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    enqueueClientWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+
+    final RuntimeException e = new RuntimeException();
+    clientListener.setNextEventDelegate(new EmptyWebSocketListener() {
+      @Override public void onClose(int code, String reason) {
+        throw e;
+      }
+    });
+
+    server.close(1000, "bye");
+    clientListener.assertFailure(e);
+    serverListener.assertClose(1000, "bye");
+  }
+
+  @Test public void non101RetainsBody() throws IOException {
+    webServer.enqueue(new MockResponse().setResponseCode(200).setBody("Body"));
+    enqueueClientWebSocket();
+
+    clientListener.assertFailure(200, "Body", ProtocolException.class,
+        "Expected HTTP 101 response but was '200 OK'");
+  }
+
+  @Test public void notFound() throws IOException {
+    webServer.enqueue(new MockResponse().setStatus("HTTP/1.1 404 Not Found"));
+    enqueueClientWebSocket();
+
+    clientListener.assertFailure(404, null, ProtocolException.class,
+        "Expected HTTP 101 response but was '404 Not Found'");
+  }
+
+  @Test public void clientTimeoutClosesBody() throws IOException {
+    webServer.enqueue(new MockResponse().setResponseCode(408));
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    enqueueClientWebSocket();
+
+    WebSocket client = clientListener.assertOpen();
+
+    client.sendPing(ByteString.encodeUtf8("WebSockets are fun!"));
+    clientListener.assertPong(ByteString.encodeUtf8("WebSockets are fun!"));
+  }
+
+  @Test public void missingConnectionHeader() throws IOException {
+    webServer.enqueue(new MockResponse()
+        .setResponseCode(101)
+        .setHeader("Upgrade", "websocket")
+        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
+    enqueueClientWebSocket();
+
+    clientListener.assertFailure(101, null, ProtocolException.class,
+        "Expected 'Connection' header value 'Upgrade' but was 'null'");
+  }
+
+  @Test public void wrongConnectionHeader() throws IOException {
+    webServer.enqueue(new MockResponse()
+        .setResponseCode(101)
+        .setHeader("Upgrade", "websocket")
+        .setHeader("Connection", "Downgrade")
+        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
+    enqueueClientWebSocket();
+
+    clientListener.assertFailure(101, null, ProtocolException.class,
+        "Expected 'Connection' header value 'Upgrade' but was 'Downgrade'");
+  }
+
+  @Test public void missingUpgradeHeader() throws IOException {
+    webServer.enqueue(new MockResponse()
+        .setResponseCode(101)
+        .setHeader("Connection", "Upgrade")
+        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
+    enqueueClientWebSocket();
+
+    clientListener.assertFailure(101, null, ProtocolException.class,
+        "Expected 'Upgrade' header value 'websocket' but was 'null'");
+  }
+
+  @Test public void wrongUpgradeHeader() throws IOException {
+    webServer.enqueue(new MockResponse()
+        .setResponseCode(101)
+        .setHeader("Connection", "Upgrade")
+        .setHeader("Upgrade", "Pepsi")
+        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
+    enqueueClientWebSocket();
+
+    clientListener.assertFailure(101, null, ProtocolException.class,
+        "Expected 'Upgrade' header value 'websocket' but was 'Pepsi'");
+  }
+
+  @Test public void missingMagicHeader() throws IOException {
+    webServer.enqueue(new MockResponse()
+        .setResponseCode(101)
+        .setHeader("Connection", "Upgrade")
+        .setHeader("Upgrade", "websocket"));
+    enqueueClientWebSocket();
+
+    clientListener.assertFailure(101, null, ProtocolException.class,
+        "Expected 'Sec-WebSocket-Accept' header value 'ujmZX4KXZqjwy6vi1aQFH5p4Ygk=' but was 'null'");
+  }
+
+  @Test public void wrongMagicHeader() throws IOException {
+    webServer.enqueue(new MockResponse()
+        .setResponseCode(101)
+        .setHeader("Connection", "Upgrade")
+        .setHeader("Upgrade", "websocket")
+        .setHeader("Sec-WebSocket-Accept", "magic"));
+    enqueueClientWebSocket();
+
+    clientListener.assertFailure(101, null, ProtocolException.class,
+        "Expected 'Sec-WebSocket-Accept' header value 'ujmZX4KXZqjwy6vi1aQFH5p4Ygk=' but was 'magic'");
+  }
+
+  @Test public void wsScheme() throws IOException {
+    websocketScheme("ws");
+  }
+
+  @Test public void wsUppercaseScheme() throws IOException {
+    websocketScheme("WS");
+  }
+
+  @Test public void wssScheme() throws IOException {
+    webServer.useHttps(sslClient.socketFactory, false);
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+
+    websocketScheme("wss");
+  }
+
+  @Test public void httpsScheme() throws IOException {
+    webServer.useHttps(sslClient.socketFactory, false);
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+
+    websocketScheme("https");
+  }
+
+  private void websocketScheme(String scheme) throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    Request request = new Request.Builder()
+        .url(scheme + "://" + webServer.getHostName() + ":" + webServer.getPort() + "/")
+        .build();
+
+    enqueueClientWebSocket(request);
+    WebSocket webSocket = clientListener.assertOpen();
+    serverListener.assertOpen();
+
+    webSocket.sendMessage(RequestBody.create(TEXT, "abc"));
+    serverListener.assertTextMessage("abc");
+  }
+
+  private void enqueueClientWebSocket() {
+    enqueueClientWebSocket(new Request.Builder().get().url(webServer.url("/")).build());
+  }
+
+  private void enqueueClientWebSocket(Request request) {
+    WebSocketCall call = new RealWebSocketCall(client, request, random);
+    call.enqueue(clientListener);
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/DiskLruCacheTest.java b/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
similarity index 99%
rename from okhttp-tests/src/test/java/okhttp3/internal/DiskLruCacheTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
index be2d0be61d..d4ae88b84a 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/DiskLruCacheTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal;
+package okhttp3.internal.cache;
 
 import java.io.File;
 import java.io.IOException;
@@ -25,6 +25,7 @@
 import java.util.List;
 import java.util.NoSuchElementException;
 import java.util.concurrent.Executor;
+import okhttp3.internal.io.FaultyFileSystem;
 import okhttp3.internal.io.FileSystem;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -37,10 +38,10 @@
 import org.junit.rules.TemporaryFolder;
 import org.junit.rules.Timeout;
 
-import static okhttp3.internal.DiskLruCache.JOURNAL_FILE;
-import static okhttp3.internal.DiskLruCache.JOURNAL_FILE_BACKUP;
-import static okhttp3.internal.DiskLruCache.MAGIC;
-import static okhttp3.internal.DiskLruCache.VERSION_1;
+import static okhttp3.internal.cache.DiskLruCache.JOURNAL_FILE;
+import static okhttp3.internal.cache.DiskLruCache.JOURNAL_FILE_BACKUP;
+import static okhttp3.internal.cache.DiskLruCache.MAGIC;
+import static okhttp3.internal.cache.DiskLruCache.VERSION_1;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/cache2/FileOperatorTest.java b/okhttp-tests/src/test/java/okhttp3/internal/cache2/FileOperatorTest.java
new file mode 100644
index 0000000000..21bbd49358
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/cache2/FileOperatorTest.java
@@ -0,0 +1,200 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.cache2;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.RandomAccessFile;
+import java.util.Random;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.Okio;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class FileOperatorTest {
+  @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
+
+  private File file;
+  private RandomAccessFile randomAccessFile;
+
+  @Before public void setUp() throws Exception {
+    file = tempDir.newFile();
+    randomAccessFile = new RandomAccessFile(file, "rw");
+  }
+
+  @After public void tearDown() throws Exception {
+    randomAccessFile.close();
+  }
+
+  @Test public void read() throws Exception {
+    write(ByteString.encodeUtf8("Hello, World"));
+
+    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
+
+    Buffer buffer = new Buffer();
+    operator.read(0, buffer, 5);
+    assertEquals("Hello", buffer.readUtf8());
+
+    operator.read(4, buffer, 5);
+    assertEquals("o, Wo", buffer.readUtf8());
+  }
+
+  @Test public void write() throws Exception {
+    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
+
+    Buffer buffer1 = new Buffer().writeUtf8("Hello, World");
+    operator.write(0, buffer1, 5);
+    assertEquals(", World", buffer1.readUtf8());
+
+    Buffer buffer2 = new Buffer().writeUtf8("icopter!");
+    operator.write(3, buffer2, 7);
+    assertEquals("!", buffer2.readUtf8());
+
+    assertEquals(ByteString.encodeUtf8("Helicopter"), snapshot());
+  }
+
+  @Test public void readAndWrite() throws Exception {
+    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
+
+    write(ByteString.encodeUtf8("woman god creates dinosaurs destroys. "));
+    Buffer buffer = new Buffer();
+    operator.read(6, buffer, 21);
+    operator.read(36, buffer, 1);
+    operator.read(5, buffer, 5);
+    operator.read(28, buffer, 8);
+    operator.read(17, buffer, 10);
+    operator.read(36, buffer, 2);
+    operator.read(2, buffer, 4);
+    operator.write(0, buffer, buffer.size());
+    operator.read(0, buffer, 12);
+    operator.read(47, buffer, 3);
+    operator.read(45, buffer, 2);
+    operator.read(47, buffer, 3);
+    operator.read(26, buffer, 10);
+    operator.read(23, buffer, 3);
+    operator.write(47, buffer, buffer.size());
+    operator.read(62, buffer, 6);
+    operator.read(4, buffer, 19);
+    operator.write(80, buffer, buffer.size());
+
+    assertEquals(snapshot(), ByteString.encodeUtf8(""
+        + "god creates dinosaurs. "
+        + "god destroys dinosaurs. "
+        + "god creates man. "
+        + "man destroys god. "
+        + "man creates dinosaurs. "));
+  }
+
+  @Test public void multipleOperatorsShareOneFile() throws Exception {
+    FileOperator operatorA = new FileOperator(randomAccessFile.getChannel());
+    FileOperator operatorB = new FileOperator(randomAccessFile.getChannel());
+
+    Buffer bufferA = new Buffer();
+    Buffer bufferB = new Buffer();
+
+    bufferA.writeUtf8("Dodgson!\n");
+    operatorA.write(0, bufferA, 9);
+
+    bufferB.writeUtf8("You shouldn't use my name.\n");
+    operatorB.write(9, bufferB, 27);
+
+    bufferA.writeUtf8("Dodgson, we've got Dodgson here!\n");
+    operatorA.write(36, bufferA, 33);
+
+    operatorB.read(0, bufferB, 9);
+    assertEquals("Dodgson!\n", bufferB.readUtf8());
+
+    operatorA.read(9, bufferA, 27);
+    assertEquals("You shouldn't use my name.\n", bufferA.readUtf8());
+
+    operatorB.read(36, bufferB, 33);
+    assertEquals("Dodgson, we've got Dodgson here!\n", bufferB.readUtf8());
+  }
+
+  @Test public void largeRead() throws Exception {
+    ByteString data = randomByteString(1000000);
+    write(data);
+
+    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
+
+    Buffer buffer = new Buffer();
+    operator.read(0, buffer, data.size());
+    assertEquals(data, buffer.readByteString());
+  }
+
+  @Test public void largeWrite() throws Exception {
+    ByteString data = randomByteString(1000000);
+
+    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
+
+    Buffer buffer = new Buffer().write(data);
+    operator.write(0, buffer, data.size());
+
+    assertEquals(data, snapshot());
+  }
+
+  @Test public void readBounds() throws Exception {
+    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
+    Buffer buffer = new Buffer();
+    try {
+      operator.read(0, buffer, -1L);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+  }
+
+  @Test public void writeBounds() throws Exception {
+    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
+    Buffer buffer = new Buffer().writeUtf8("abc");
+    try {
+      operator.write(0, buffer, -1L);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+    try {
+      operator.write(0, buffer, 4L);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+  }
+
+  private ByteString randomByteString(int byteCount) {
+    byte[] bytes = new byte[byteCount];
+    new Random(0).nextBytes(bytes);
+    return ByteString.of(bytes);
+  }
+
+  private ByteString snapshot() throws IOException {
+    randomAccessFile.getChannel().force(false);
+    BufferedSource source = Okio.buffer(Okio.source(file));
+    return source.readByteString();
+  }
+
+  private void write(ByteString data) throws IOException {
+    BufferedSink sink = Okio.buffer(Okio.sink(file));
+    sink.write(data);
+    sink.close();
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/cache2/RelayTest.java b/okhttp-tests/src/test/java/okhttp3/internal/cache2/RelayTest.java
new file mode 100644
index 0000000000..cbffa87d09
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/cache2/RelayTest.java
@@ -0,0 +1,255 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.cache2;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.Okio;
+import okio.Pipe;
+import okio.Source;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class RelayTest {
+  @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
+
+  private ExecutorService executor = Executors.newCachedThreadPool();
+  private ByteString metadata = ByteString.encodeUtf8("great metadata!");
+  private File file;
+
+  @Before public void setUp() throws Exception {
+    file = tempDir.newFile();
+  }
+
+  @After public void tearDown() throws Exception {
+    executor.shutdown();
+  }
+
+  @Test public void singleSource() throws Exception {
+    Buffer upstream = new Buffer();
+    upstream.writeUtf8("abcdefghijklm");
+
+    Relay relay = Relay.edit(file, upstream, metadata, 1024);
+    Source source = relay.newSource();
+    Buffer sourceBuffer = new Buffer();
+
+    assertEquals(5, source.read(sourceBuffer, 5));
+    assertEquals("abcde", sourceBuffer.readUtf8());
+
+    assertEquals(8, source.read(sourceBuffer, 1024));
+    assertEquals("fghijklm", sourceBuffer.readUtf8());
+
+    assertEquals(-1, source.read(sourceBuffer, 1024));
+    assertEquals(0, sourceBuffer.size());
+
+    source.close();
+    assertTrue(relay.isClosed());
+    assertFile(Relay.PREFIX_CLEAN, 13L, metadata.size(), "abcdefghijklm", metadata);
+  }
+
+  @Test public void multipleSources() throws Exception {
+    Buffer upstream = new Buffer();
+    upstream.writeUtf8("abcdefghijklm");
+
+    Relay relay = Relay.edit(file, upstream, metadata, 1024);
+    BufferedSource source1 = Okio.buffer(relay.newSource());
+    BufferedSource source2 = Okio.buffer(relay.newSource());
+
+    assertEquals("abcdefghijklm", source1.readUtf8());
+    assertEquals("abcdefghijklm", source2.readUtf8());
+    source1.close();
+    source2.close();
+    assertTrue(relay.isClosed());
+
+    assertFile(Relay.PREFIX_CLEAN, 13L, metadata.size(), "abcdefghijklm", metadata);
+  }
+
+  @Test public void readFromBuffer() throws Exception {
+    Buffer upstream = new Buffer();
+    upstream.writeUtf8("abcdefghij");
+
+    Relay relay = Relay.edit(file, upstream, metadata, 5);
+    BufferedSource source1 = Okio.buffer(relay.newSource());
+    BufferedSource source2 = Okio.buffer(relay.newSource());
+
+    assertEquals("abcde", source1.readUtf8(5));
+    assertEquals("abcde", source2.readUtf8(5));
+    assertEquals("fghij", source2.readUtf8(5));
+    assertEquals("fghij", source1.readUtf8(5));
+    assertTrue(source1.exhausted());
+    assertTrue(source2.exhausted());
+    source1.close();
+    source2.close();
+    assertTrue(relay.isClosed());
+
+    assertFile(Relay.PREFIX_CLEAN, 10L, metadata.size(), "abcdefghij", metadata);
+  }
+
+  @Test public void readFromFile() throws Exception {
+    Buffer upstream = new Buffer();
+    upstream.writeUtf8("abcdefghijklmnopqrst");
+
+    Relay relay = Relay.edit(file, upstream, metadata, 5);
+    BufferedSource source1 = Okio.buffer(relay.newSource());
+    BufferedSource source2 = Okio.buffer(relay.newSource());
+
+    assertEquals("abcdefghij", source1.readUtf8(10));
+    assertEquals("abcdefghij", source2.readUtf8(10));
+    assertEquals("klmnopqrst", source2.readUtf8(10));
+    assertEquals("klmnopqrst", source1.readUtf8(10));
+    assertTrue(source1.exhausted());
+    assertTrue(source2.exhausted());
+    source1.close();
+    source2.close();
+    assertTrue(relay.isClosed());
+
+    assertFile(Relay.PREFIX_CLEAN, 20L, metadata.size(), "abcdefghijklmnopqrst", metadata);
+  }
+
+  @Test public void readAfterEdit() throws Exception {
+    Buffer upstream = new Buffer();
+    upstream.writeUtf8("abcdefghij");
+
+    Relay relay1 = Relay.edit(file, upstream, metadata, 5);
+    BufferedSource source1 = Okio.buffer(relay1.newSource());
+    assertEquals("abcdefghij", source1.readUtf8(10));
+    assertTrue(source1.exhausted());
+    source1.close();
+    assertTrue(relay1.isClosed());
+
+    // Since relay1 is closed, new sources cannot be created.
+    assertNull(relay1.newSource());
+
+    Relay relay2 = Relay.read(file);
+    assertEquals(metadata, relay2.metadata());
+    BufferedSource source2 = Okio.buffer(relay2.newSource());
+    assertEquals("abcdefghij", source2.readUtf8(10));
+    assertTrue(source2.exhausted());
+    source2.close();
+    assertTrue(relay2.isClosed());
+
+    // Since relay2 is closed, new sources cannot be created.
+    assertNull(relay2.newSource());
+
+    assertFile(Relay.PREFIX_CLEAN, 10L, metadata.size(), "abcdefghij", metadata);
+  }
+
+  @Test public void closeBeforeExhaustLeavesDirtyFile() throws Exception {
+    Buffer upstream = new Buffer();
+    upstream.writeUtf8("abcdefghij");
+
+    Relay relay1 = Relay.edit(file, upstream, metadata, 5);
+    BufferedSource source1 = Okio.buffer(relay1.newSource());
+    assertEquals("abcdefghij", source1.readUtf8(10));
+    source1.close(); // Not exhausted!
+    assertTrue(relay1.isClosed());
+
+    try {
+      Relay.read(file);
+      fail();
+    } catch (IOException expected) {
+      assertEquals("unreadable cache file", expected.getMessage());
+    }
+
+    assertFile(Relay.PREFIX_DIRTY, -1L, -1, null, null);
+  }
+
+  @Test public void redundantCallsToCloseAreIgnored() throws Exception {
+    Buffer upstream = new Buffer();
+    upstream.writeUtf8("abcde");
+
+    Relay relay = Relay.edit(file, upstream, metadata, 1024);
+    Source source1 = relay.newSource();
+    Source source2 = relay.newSource();
+
+    source1.close();
+    source1.close(); // Unnecessary. Shouldn't decrement the reference count.
+    assertFalse(relay.isClosed());
+
+    source2.close();
+    assertTrue(relay.isClosed());
+    assertFile(Relay.PREFIX_DIRTY, -1L, -1, null, null);
+  }
+
+  @Test public void racingReaders() throws Exception {
+    Pipe pipe = new Pipe(1024);
+    BufferedSink sink = Okio.buffer(pipe.sink());
+
+    Relay relay = Relay.edit(file, pipe.source(), metadata, 5);
+
+    Future<ByteString> future1 = executor.submit(sourceReader(relay.newSource()));
+    Future<ByteString> future2 = executor.submit(sourceReader(relay.newSource()));
+
+    Thread.sleep(500);
+    sink.writeUtf8("abcdefghij");
+
+    Thread.sleep(500);
+    sink.writeUtf8("klmnopqrst");
+    sink.close();
+
+    assertEquals(ByteString.encodeUtf8("abcdefghijklmnopqrst"), future1.get());
+    assertEquals(ByteString.encodeUtf8("abcdefghijklmnopqrst"), future2.get());
+
+    assertTrue(relay.isClosed());
+
+    assertFile(Relay.PREFIX_CLEAN, 20L, metadata.size(), "abcdefghijklmnopqrst", metadata);
+  }
+
+  /** Returns a callable that reads all of source, closes it, and returns the bytes. */
+  private Callable<ByteString> sourceReader(final Source source) {
+    return new Callable<ByteString>() {
+      @Override public ByteString call() throws Exception {
+        Buffer buffer = new Buffer();
+        while (source.read(buffer, 16384) != -1) {
+        }
+        source.close();
+        return buffer.readByteString();
+      }
+    };
+  }
+
+  private void assertFile(ByteString prefix, long upstreamSize, int metadataSize, String upstream,
+      ByteString metadata) throws IOException {
+    BufferedSource source = Okio.buffer(Okio.source(file));
+    assertEquals(prefix, source.readByteString(prefix.size()));
+    assertEquals(upstreamSize, source.readLong());
+    assertEquals(metadataSize, source.readLong());
+    if (upstream != null) {
+      assertEquals(upstream, source.readUtf8(upstreamSize));
+    }
+    if (metadata != null) {
+      assertEquals(metadata, source.readByteString(metadataSize));
+    }
+    source.close();
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ConnectionSpecSelectorTest.java b/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java
similarity index 95%
rename from okhttp-tests/src/test/java/okhttp3/internal/ConnectionSpecSelectorTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java
index b6aa5344c2..b0b06e9f87 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ConnectionSpecSelectorTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java
@@ -13,18 +13,19 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal;
+package okhttp3.internal.connection;
 
 import java.io.IOException;
 import java.security.cert.CertificateException;
 import java.util.Arrays;
 import java.util.LinkedHashSet;
 import java.util.Set;
-import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLSocket;
 import okhttp3.ConnectionSpec;
 import okhttp3.TlsVersion;
+import okhttp3.internal.Internal;
+import okhttp3.internal.tls.SslClient;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
@@ -39,7 +40,7 @@
   public static final SSLHandshakeException RETRYABLE_EXCEPTION = new SSLHandshakeException(
       "Simulated handshake exception");
 
-  private SSLContext sslContext = SslContextBuilder.localhost();
+  private SslClient sslClient = SslClient.localhost();
 
   @Test
   public void nonRetryableIOException() throws Exception {
@@ -120,7 +121,7 @@ private static ConnectionSpecSelector createConnectionSpecSelector(
   }
 
   private SSLSocket createSocketWithEnabledProtocols(TlsVersion... tlsVersions) throws IOException {
-    SSLSocket socket = (SSLSocket) sslContext.getSocketFactory().createSocket();
+    SSLSocket socket = (SSLSocket) sslClient.socketFactory.createSocket();
     socket.setEnabledProtocols(javaNames(tlsVersions));
     return socket;
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/RouteExceptionTest.java b/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteExceptionTest.java
similarity index 97%
rename from okhttp-tests/src/test/java/okhttp3/internal/http/RouteExceptionTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/connection/RouteExceptionTest.java
index 1a0c2d8f02..209d79d5c5 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/RouteExceptionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteExceptionTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.http;
+package okhttp3.internal.connection;
 
 import java.io.IOException;
 import org.junit.Test;
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/RouteSelectorTest.java b/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java
similarity index 97%
rename from okhttp-tests/src/test/java/okhttp3/internal/http/RouteSelectorTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java
index 7f0b47037d..c5418e1b51 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/RouteSelectorTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.http;
+package okhttp3.internal.connection;
 
 import java.io.IOException;
 import java.net.InetAddress;
@@ -30,7 +30,6 @@
 import javax.net.SocketFactory;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSocketFactory;
 import okhttp3.Address;
 import okhttp3.Authenticator;
@@ -38,9 +37,9 @@
 import okhttp3.FakeDns;
 import okhttp3.Protocol;
 import okhttp3.Route;
-import okhttp3.internal.RouteDatabase;
-import okhttp3.internal.SslContextBuilder;
 import okhttp3.internal.Util;
+import okhttp3.internal.http.RecordingProxySelector;
+import okhttp3.internal.tls.SslClient;
 import org.junit.Before;
 import org.junit.Test;
 
@@ -68,8 +67,8 @@
   private int uriPort = 1003;
 
   private SocketFactory socketFactory;
-  private final SSLContext sslContext = SslContextBuilder.localhost();
-  private final SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();
+  private final SslClient sslClient = SslClient.localhost();
+  private final SSLSocketFactory sslSocketFactory = sslClient.socketFactory;
   private HostnameVerifier hostnameVerifier;
 
   private final Authenticator authenticator = Authenticator.NONE;
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2ConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2ConnectionTest.java
deleted file mode 100644
index b2a583857d..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2ConnectionTest.java
+++ /dev/null
@@ -1,568 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.framed;
-
-import java.io.IOException;
-import java.net.Socket;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.concurrent.TimeUnit;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.Okio;
-import okio.Source;
-import org.junit.After;
-import org.junit.Test;
-
-import static okhttp3.TestUtil.headerEntries;
-import static okhttp3.TestUtil.repeat;
-import static okhttp3.internal.Util.EMPTY_BYTE_ARRAY;
-import static okhttp3.internal.framed.ErrorCode.CANCEL;
-import static okhttp3.internal.framed.ErrorCode.PROTOCOL_ERROR;
-import static okhttp3.internal.framed.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
-import static okhttp3.internal.framed.Settings.ENABLE_PUSH;
-import static okhttp3.internal.framed.Settings.HEADER_TABLE_SIZE;
-import static okhttp3.internal.framed.Settings.INITIAL_WINDOW_SIZE;
-import static okhttp3.internal.framed.Settings.MAX_FRAME_SIZE;
-import static okhttp3.internal.framed.Settings.PERSIST_VALUE;
-import static okhttp3.internal.framed.Spdy3.TYPE_DATA;
-import static okhttp3.internal.framed.Spdy3.TYPE_HEADERS;
-import static okhttp3.internal.framed.Spdy3.TYPE_PING;
-import static okhttp3.internal.framed.Spdy3.TYPE_RST_STREAM;
-import static okhttp3.internal.framed.Spdy3.TYPE_SETTINGS;
-import static okhttp3.internal.framed.Spdy3.TYPE_WINDOW_UPDATE;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public final class Http2ConnectionTest {
-  private static final Variant HTTP_2 = new Http2();
-  private final MockSpdyPeer peer = new MockSpdyPeer();
-
-  @After public void tearDown() throws Exception {
-    peer.close();
-  }
-
-  @Test public void serverPingsClientHttp2() throws Exception {
-    peer.setVariantAndClient(HTTP_2, false);
-
-    // write the mocking script
-    peer.sendFrame().ping(false, 2, 3);
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    connection(peer, HTTP_2);
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_PING, ping.type);
-    assertEquals(0, ping.streamId);
-    assertEquals(2, ping.payload1);
-    assertEquals(3, ping.payload2);
-    assertTrue(ping.ack);
-  }
-
-  @Test public void clientPingsServerHttp2() throws Exception {
-    peer.setVariantAndClient(HTTP_2, false);
-
-    // write the mocking script
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 5);
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, HTTP_2);
-    Ping ping = connection.ping();
-    assertTrue(ping.roundTripTime() > 0);
-    assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame pingFrame = peer.takeFrame();
-    assertEquals(0, pingFrame.streamId);
-    assertEquals(1, pingFrame.payload1);
-    assertEquals(0x4f4b6f6b, pingFrame.payload2); // connection.ping() sets this.
-    assertFalse(pingFrame.ack);
-  }
-
-  @Test public void peerHttp2ServerLowersInitialWindowSize() throws Exception {
-    peer.setVariantAndClient(HTTP_2, false);
-
-    Settings initial = new Settings();
-    initial.set(INITIAL_WINDOW_SIZE, PERSIST_VALUE, 1684);
-    Settings shouldntImpactConnection = new Settings();
-    shouldntImpactConnection.set(INITIAL_WINDOW_SIZE, PERSIST_VALUE, 3368);
-
-    peer.sendFrame().settings(initial);
-    peer.acceptFrame(); // ACK
-    peer.sendFrame().settings(shouldntImpactConnection);
-    peer.acceptFrame(); // ACK 2
-    peer.acceptFrame(); // HEADERS
-    peer.play();
-
-    FramedConnection connection = connection(peer, HTTP_2);
-
-    // Default is 64KiB - 1.
-    assertEquals(65535, connection.peerSettings.getInitialWindowSize(-1));
-
-    // Verify the peer received the ACK.
-    MockSpdyPeer.InFrame ackFrame = peer.takeFrame();
-    assertEquals(TYPE_SETTINGS, ackFrame.type);
-    assertEquals(0, ackFrame.streamId);
-    assertTrue(ackFrame.ack);
-    ackFrame = peer.takeFrame();
-    assertEquals(TYPE_SETTINGS, ackFrame.type);
-    assertEquals(0, ackFrame.streamId);
-    assertTrue(ackFrame.ack);
-
-    // This stream was created *after* the connection settings were adjusted.
-    FramedStream stream = connection.newStream(headerEntries("a", "android"), false, true);
-
-    assertEquals(3368, connection.peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE));
-    assertEquals(1684, connection.bytesLeftInWriteWindow); // initial wasn't affected.
-    // New Stream is has the most recent initial window size.
-    assertEquals(3368, stream.bytesLeftInWriteWindow);
-  }
-
-  @Test public void peerHttp2ServerZerosCompressionTable() throws Exception {
-    boolean client = false; // Peer is server, so we are client.
-    Settings settings = new Settings();
-    settings.set(HEADER_TABLE_SIZE, PERSIST_VALUE, 0);
-
-    FramedConnection connection = sendHttp2SettingsAndCheckForAck(client, settings);
-
-    // verify the peer's settings were read and applied.
-    assertEquals(0, connection.peerSettings.getHeaderTableSize());
-    Http2.Reader frameReader = (Http2.Reader) connection.readerRunnable.frameReader;
-    assertEquals(0, frameReader.hpackReader.maxDynamicTableByteCount());
-    // TODO: when supported, check the frameWriter's compression table is unaffected.
-  }
-
-  @Test public void peerHttp2ClientDisablesPush() throws Exception {
-    boolean client = false; // Peer is client, so we are server.
-    Settings settings = new Settings();
-    settings.set(ENABLE_PUSH, 0, 0); // The peer client disables push.
-
-    FramedConnection connection = sendHttp2SettingsAndCheckForAck(client, settings);
-
-    // verify the peer's settings were read and applied.
-    assertFalse(connection.peerSettings.getEnablePush(true));
-  }
-
-  @Test public void peerIncreasesMaxFrameSize() throws Exception {
-    int newMaxFrameSize = 0x4001;
-    Settings settings = new Settings();
-    settings.set(MAX_FRAME_SIZE, 0, newMaxFrameSize);
-
-    FramedConnection connection = sendHttp2SettingsAndCheckForAck(true, settings);
-
-    // verify the peer's settings were read and applied.
-    assertEquals(newMaxFrameSize, connection.peerSettings.getMaxFrameSize(-1));
-    assertEquals(newMaxFrameSize, connection.frameWriter.maxDataLength());
-  }
-
-  @Test public void receiveGoAwayHttp2() throws Exception {
-    peer.setVariantAndClient(HTTP_2, false);
-
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM 3
-    peer.acceptFrame(); // SYN_STREAM 5
-    peer.sendFrame().goAway(3, PROTOCOL_ERROR, EMPTY_BYTE_ARRAY);
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
-    peer.acceptFrame(); // DATA STREAM 3
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, HTTP_2);
-    FramedStream stream1 = connection.newStream(headerEntries("a", "android"), true, true);
-    FramedStream stream2 = connection.newStream(headerEntries("b", "banana"), true, true);
-    connection.ping().roundTripTime(); // Ensure the GO_AWAY that resets stream2 has been received.
-    BufferedSink sink1 = Okio.buffer(stream1.getSink());
-    BufferedSink sink2 = Okio.buffer(stream2.getSink());
-    sink1.writeUtf8("abc");
-    try {
-      sink2.writeUtf8("abc");
-      sink2.flush();
-      fail();
-    } catch (IOException expected) {
-      assertEquals("stream was reset: REFUSED_STREAM", expected.getMessage());
-    }
-    sink1.writeUtf8("def");
-    sink1.close();
-    try {
-      connection.newStream(headerEntries("c", "cola"), true, true);
-      fail();
-    } catch (IOException expected) {
-      assertEquals("shutdown", expected.getMessage());
-    }
-    assertTrue(stream1.isOpen());
-    assertFalse(stream2.isOpen());
-    assertEquals(1, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream1 = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream1.type);
-    MockSpdyPeer.InFrame synStream2 = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream2.type);
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_PING, ping.type);
-    MockSpdyPeer.InFrame data1 = peer.takeFrame();
-    assertEquals(TYPE_DATA, data1.type);
-    assertEquals(3, data1.streamId);
-    assertTrue(Arrays.equals("abcdef".getBytes("UTF-8"), data1.data));
-  }
-
-  @Test public void readSendsWindowUpdateHttp2() throws Exception {
-    peer.setVariantAndClient(HTTP_2, false);
-
-    int windowSize = 100;
-    int windowUpdateThreshold = 50;
-
-    // Write the mocking script.
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
-    for (int i = 0; i < 3; i++) {
-      // Send frames of summing to size 50, which is windowUpdateThreshold.
-      peer.sendFrame().data(false, 3, data(24), 24);
-      peer.sendFrame().data(false, 3, data(25), 25);
-      peer.sendFrame().data(false, 3, data(1), 1);
-      peer.acceptFrame(); // connection WINDOW UPDATE
-      peer.acceptFrame(); // stream WINDOW UPDATE
-    }
-    peer.sendFrame().data(true, 3, data(0), 0);
-    peer.play();
-
-    // Play it back.
-    FramedConnection connection = connection(peer, HTTP_2);
-    connection.okHttpSettings.set(INITIAL_WINDOW_SIZE, 0, windowSize);
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), false, true);
-    assertEquals(0, stream.unacknowledgedBytesRead);
-    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
-    Source in = stream.getSource();
-    Buffer buffer = new Buffer();
-    buffer.writeAll(in);
-    assertEquals(-1, in.read(buffer, 1));
-    assertEquals(150, buffer.size());
-
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    for (int i = 0; i < 3; i++) {
-      List<Integer> windowUpdateStreamIds = new ArrayList<>(2);
-      for (int j = 0; j < 2; j++) {
-        MockSpdyPeer.InFrame windowUpdate = peer.takeFrame();
-        assertEquals(TYPE_WINDOW_UPDATE, windowUpdate.type);
-        windowUpdateStreamIds.add(windowUpdate.streamId);
-        assertEquals(windowUpdateThreshold, windowUpdate.windowSizeIncrement);
-      }
-      assertTrue(windowUpdateStreamIds.contains(0)); // connection
-      assertTrue(windowUpdateStreamIds.contains(3)); // stream
-    }
-  }
-
-  private Buffer data(int byteCount) {
-    return new Buffer().write(new byte[byteCount]);
-  }
-
-  @Test public void serverSendsEmptyDataClientDoesntSendWindowUpdateHttp2() throws Exception {
-    peer.setVariantAndClient(HTTP_2, false);
-
-    // Write the mocking script.
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
-    peer.sendFrame().data(true, 3, data(0), 0);
-    peer.play();
-
-    // Play it back.
-    FramedConnection connection = connection(peer, HTTP_2);
-    FramedStream client = connection.newStream(headerEntries("b", "banana"), false, true);
-    assertEquals(-1, client.getSource().read(new Buffer(), 1));
-
-    // Verify the peer received what was expected.
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(3, peer.frameCount());
-  }
-
-  @Test public void clientSendsEmptyDataServerDoesntSendWindowUpdateHttp2() throws Exception {
-    peer.setVariantAndClient(HTTP_2, false);
-
-    // Write the mocking script.
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // DATA
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
-    peer.play();
-
-    // Play it back.
-    FramedConnection connection = connection(peer, HTTP_2);
-    FramedStream client = connection.newStream(headerEntries("b", "banana"), true, true);
-    BufferedSink out = Okio.buffer(client.getSink());
-    out.write(EMPTY_BYTE_ARRAY);
-    out.flush();
-    out.close();
-
-    // Verify the peer received what was expected.
-    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
-    assertEquals(TYPE_DATA, peer.takeFrame().type);
-    assertEquals(3, peer.frameCount());
-  }
-
-  @Test public void maxFrameSizeHonored() throws Exception {
-    peer.setVariantAndClient(HTTP_2, false);
-
-    byte[] buff = new byte[peer.maxOutboundDataLength() + 1];
-    Arrays.fill(buff, (byte) '*');
-
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
-    peer.acceptFrame(); // DATA
-    peer.acceptFrame(); // DATA
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, HTTP_2);
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    BufferedSink out = Okio.buffer(stream.getSink());
-    out.write(buff);
-    out.flush();
-    out.close();
-
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    MockSpdyPeer.InFrame data = peer.takeFrame();
-    assertEquals(peer.maxOutboundDataLength(), data.data.length);
-    data = peer.takeFrame();
-    assertEquals(1, data.data.length);
-  }
-
-  @Test public void pushPromiseStream() throws Exception {
-    peer.setVariantAndClient(HTTP_2, false);
-
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
-    final List<Header> expectedRequestHeaders = Arrays.asList(
-        new Header(Header.TARGET_METHOD, "GET"),
-        new Header(Header.TARGET_SCHEME, "https"),
-        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
-        new Header(Header.TARGET_PATH, "/cached")
-    );
-    peer.sendFrame().pushPromise(3, 2, expectedRequestHeaders);
-    final List<Header> expectedResponseHeaders = Arrays.asList(
-        new Header(Header.RESPONSE_STATUS, "200")
-    );
-    peer.sendFrame().synReply(true, 2, expectedResponseHeaders);
-    peer.sendFrame().data(true, 3, data(0), 0);
-    peer.play();
-
-    RecordingPushObserver observer = new RecordingPushObserver();
-
-    // play it back
-    FramedConnection connection = connectionBuilder(peer, HTTP_2)
-        .pushObserver(observer)
-        .build();
-    connection.start(false);
-    FramedStream client = connection.newStream(headerEntries("b", "banana"), false, true);
-    assertEquals(-1, client.getSource().read(new Buffer(), 1));
-
-    // verify the peer received what was expected
-    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
-
-    assertEquals(expectedRequestHeaders, observer.takeEvent());
-    assertEquals(expectedResponseHeaders, observer.takeEvent());
-  }
-
-  @Test public void doublePushPromise() throws Exception {
-    peer.setVariantAndClient(HTTP_2, false);
-
-    // write the mocking script
-    peer.sendFrame().pushPromise(3, 2, headerEntries("a", "android"));
-    peer.acceptFrame(); // SYN_REPLY
-    peer.sendFrame().pushPromise(3, 2, headerEntries("b", "banana"));
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connectionBuilder(peer, HTTP_2).build();
-    connection.start(false);
-    connection.newStream(headerEntries("b", "banana"), false, true);
-
-    // verify the peer received what was expected
-    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
-    assertEquals(PROTOCOL_ERROR, peer.takeFrame().errorCode);
-  }
-
-  @Test public void pushPromiseStreamsAutomaticallyCancel() throws Exception {
-    peer.setVariantAndClient(HTTP_2, false);
-
-    // write the mocking script
-    peer.sendFrame().pushPromise(3, 2, Arrays.asList(
-        new Header(Header.TARGET_METHOD, "GET"),
-        new Header(Header.TARGET_SCHEME, "https"),
-        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
-        new Header(Header.TARGET_PATH, "/cached")
-    ));
-    peer.sendFrame().synReply(true, 2, Arrays.asList(
-        new Header(Header.RESPONSE_STATUS, "200")
-    ));
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connectionBuilder(peer, HTTP_2)
-        .pushObserver(PushObserver.CANCEL)
-        .build();
-    connection.start(false);
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame rstStream = peer.takeFrame();
-    assertEquals(TYPE_RST_STREAM, rstStream.type);
-    assertEquals(2, rstStream.streamId);
-    assertEquals(CANCEL, rstStream.errorCode);
-  }
-
-  /**
-   * When writing a set of headers fails due to an {@code IOException}, make sure the writer is left
-   * in a consistent state so the next writer also gets an {@code IOException} also instead of
-   * something worse (like an {@link IllegalStateException}.
-   *
-   * <p>See https://github.com/square/okhttp/issues/1651
-   */
-  @Test public void socketExceptionWhileWritingHeaders() throws Exception {
-    peer.setVariantAndClient(HTTP_2, false);
-    peer.acceptFrame(); // SYN_STREAM.
-    peer.play();
-
-    String longString = repeat('a', Http2.INITIAL_MAX_FRAME_SIZE + 1);
-    Socket socket = peer.openSocket();
-    FramedConnection connection = new FramedConnection.Builder(true)
-        .socket(socket)
-        .pushObserver(IGNORE)
-        .protocol(HTTP_2.getProtocol())
-        .build();
-    connection.start(false);
-    socket.shutdownOutput();
-    try {
-      connection.newStream(headerEntries("a", longString), false, true);
-      fail();
-    } catch (IOException expected) {
-    }
-    try {
-      connection.newStream(headerEntries("b", longString), false, true);
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  private FramedConnection sendHttp2SettingsAndCheckForAck(boolean client, Settings settings)
-      throws IOException, InterruptedException {
-    peer.setVariantAndClient(HTTP_2, client);
-    peer.sendFrame().settings(settings);
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, HTTP_2);
-
-    // verify the peer received the ACK
-    MockSpdyPeer.InFrame ackFrame = peer.takeFrame();
-    assertEquals(TYPE_SETTINGS, ackFrame.type);
-    assertEquals(0, ackFrame.streamId);
-    assertTrue(ackFrame.ack);
-
-    connection.ping().roundTripTime(); // Ensure that settings have been applied before returning.
-    return connection;
-  }
-
-  private FramedConnection connection(MockSpdyPeer peer, Variant variant) throws IOException {
-    FramedConnection connection = connectionBuilder(peer, variant).build();
-    connection.start(false);
-    return connection;
-  }
-
-  private FramedConnection.Builder connectionBuilder(MockSpdyPeer peer, Variant variant)
-      throws IOException {
-    return new FramedConnection.Builder(true)
-        .socket(peer.openSocket())
-        .pushObserver(IGNORE)
-        .protocol(variant.getProtocol());
-  }
-
-  static final PushObserver IGNORE = new PushObserver() {
-
-    @Override public boolean onRequest(int streamId, List<Header> requestHeaders) {
-      return false;
-    }
-
-    @Override public boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last) {
-      return false;
-    }
-
-    @Override public boolean onData(int streamId, BufferedSource source, int byteCount,
-        boolean last) throws IOException {
-      source.skip(byteCount);
-      return false;
-    }
-
-    @Override public void onReset(int streamId, ErrorCode errorCode) {
-    }
-  };
-
-  private static class RecordingPushObserver implements PushObserver {
-    final List<Object> events = new ArrayList<>();
-
-    public synchronized Object takeEvent() throws InterruptedException {
-      while (events.isEmpty()) {
-        wait();
-      }
-      return events.remove(0);
-    }
-
-    @Override public synchronized boolean onRequest(int streamId, List<Header> requestHeaders) {
-      assertEquals(2, streamId);
-      events.add(requestHeaders);
-      notifyAll();
-      return false;
-    }
-
-    @Override public synchronized boolean onHeaders(
-        int streamId, List<Header> responseHeaders, boolean last) {
-      assertEquals(2, streamId);
-      assertTrue(last);
-      events.add(responseHeaders);
-      notifyAll();
-      return false;
-    }
-
-    @Override public synchronized boolean onData(
-        int streamId, BufferedSource source, int byteCount, boolean last) {
-      events.add(new AssertionError("onData"));
-      notifyAll();
-      return false;
-    }
-
-    @Override public synchronized void onReset(int streamId, ErrorCode errorCode) {
-      events.add(new AssertionError("onReset"));
-      notifyAll();
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverHttp2Test.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverHttp2Test.java
deleted file mode 100644
index c747f0b7a4..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverHttp2Test.java
+++ /dev/null
@@ -1,137 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.framed;
-
-import okhttp3.Call;
-import okhttp3.Headers;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.PushPromise;
-import okhttp3.mockwebserver.RecordedRequest;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-
-public class HttpOverHttp2Test extends HttpOverSpdyTest {
-
-  public HttpOverHttp2Test() {
-    super(Protocol.HTTP_2);
-    this.hostHeader = ":authority";
-  }
-
-  @Test public void serverSendsPushPromise_GET() throws Exception {
-    PushPromise pushPromise = new PushPromise("GET", "/foo/bar", Headers.of("foo", "bar"),
-        new MockResponse().setBody("bar").setStatus("HTTP/1.1 200 Sweet"));
-    server.enqueue(new MockResponse()
-        .setBody("ABCDE")
-        .setStatus("HTTP/1.1 200 Sweet")
-        .withPush(pushPromise));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/foo"))
-        .build());
-    Response response = call.execute();
-
-    assertEquals("ABCDE", response.body().string());
-    assertEquals(200, response.code());
-    assertEquals("Sweet", response.message());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-    assertEquals("https", request.getHeader(":scheme"));
-    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(hostHeader));
-
-    RecordedRequest pushedRequest = server.takeRequest();
-    assertEquals("GET /foo/bar HTTP/1.1", pushedRequest.getRequestLine());
-    assertEquals("bar", pushedRequest.getHeader("foo"));
-  }
-
-  @Test public void serverSendsPushPromise_HEAD() throws Exception {
-    PushPromise pushPromise = new PushPromise("HEAD", "/foo/bar", Headers.of("foo", "bar"),
-        new MockResponse().setStatus("HTTP/1.1 204 Sweet"));
-    server.enqueue(new MockResponse()
-        .setBody("ABCDE")
-        .setStatus("HTTP/1.1 200 Sweet")
-        .withPush(pushPromise));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/foo"))
-        .build());
-    Response response = call.execute();
-    assertEquals("ABCDE", response.body().string());
-    assertEquals(200, response.code());
-    assertEquals("Sweet", response.message());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-    assertEquals("https", request.getHeader(":scheme"));
-    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(hostHeader));
-
-    RecordedRequest pushedRequest = server.takeRequest();
-    assertEquals("HEAD /foo/bar HTTP/1.1", pushedRequest.getRequestLine());
-    assertEquals("bar", pushedRequest.getHeader("foo"));
-  }
-
-  /**
-   * Push a setting that permits up to 2 concurrent streams, then make 3 concurrent requests and
-   * confirm that the third concurrent request prepared a new connection.
-   */
-  @Test public void settingsLimitsMaxConcurrentStreams() throws Exception {
-    Settings settings = new Settings();
-    settings.set(Settings.MAX_CONCURRENT_STREAMS, 0, 2);
-
-    // Read & write a full request to confirm settings are accepted.
-    server.enqueue(new MockResponse().withSettings(settings));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    assertEquals("", response.body().string());
-
-    server.enqueue(new MockResponse()
-        .setBody("ABC"));
-    server.enqueue(new MockResponse()
-        .setBody("DEF"));
-    server.enqueue(new MockResponse()
-        .setBody("GHI"));
-
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response1 = call1.execute();
-
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response2 = call2.execute();
-
-    Call call3 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response3 = call3.execute();
-
-    assertEquals("ABC", response1.body().string());
-    assertEquals("DEF", response2.body().string());
-    assertEquals("GHI", response3.body().string());
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // Settings connection.
-    assertEquals(1, server.takeRequest().getSequenceNumber()); // Reuse settings connection.
-    assertEquals(2, server.takeRequest().getSequenceNumber()); // Reuse settings connection.
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection!
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/SettingsTest.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/SettingsTest.java
deleted file mode 100644
index 9eae7f89db..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/SettingsTest.java
+++ /dev/null
@@ -1,176 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.framed;
-
-import org.junit.Test;
-
-import static okhttp3.internal.framed.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
-import static okhttp3.internal.framed.Settings.DOWNLOAD_BANDWIDTH;
-import static okhttp3.internal.framed.Settings.DOWNLOAD_RETRANS_RATE;
-import static okhttp3.internal.framed.Settings.MAX_CONCURRENT_STREAMS;
-import static okhttp3.internal.framed.Settings.PERSISTED;
-import static okhttp3.internal.framed.Settings.PERSIST_VALUE;
-import static okhttp3.internal.framed.Settings.UPLOAD_BANDWIDTH;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
-public final class SettingsTest {
-  @Test public void unsetField() {
-    Settings settings = new Settings();
-    assertEquals(-3, settings.getUploadBandwidth(-3));
-  }
-
-  @Test public void setFields() {
-    Settings settings = new Settings();
-
-    // WARNING: clash on flags between spdy/3 and HTTP/2!
-    assertEquals(-3, settings.getUploadBandwidth(-3));
-    assertEquals(-1, settings.getHeaderTableSize());
-    settings.set(UPLOAD_BANDWIDTH, 0, 42);
-    assertEquals(42, settings.getUploadBandwidth(-3));
-    settings.set(Settings.HEADER_TABLE_SIZE, 0, 8096);
-    assertEquals(8096, settings.getHeaderTableSize());
-
-    // WARNING: clash on flags between spdy/3 and HTTP/2!
-    assertEquals(true, settings.getEnablePush(true));
-    settings.set(Settings.ENABLE_PUSH, 0, 1);
-    assertEquals(true, settings.getEnablePush(false));
-    settings.clear();
-    assertEquals(-3, settings.getDownloadBandwidth(-3));
-    settings.set(DOWNLOAD_BANDWIDTH, 0, 53);
-    assertEquals(53, settings.getDownloadBandwidth(-3));
-
-    assertEquals(-3, settings.getRoundTripTime(-3));
-    settings.set(Settings.ROUND_TRIP_TIME, 0, 64);
-    assertEquals(64, settings.getRoundTripTime(-3));
-
-    assertEquals(-3, settings.getMaxConcurrentStreams(-3));
-    settings.set(MAX_CONCURRENT_STREAMS, 0, 75);
-    assertEquals(75, settings.getMaxConcurrentStreams(-3));
-
-    // WARNING: clash on flags between spdy/3 and HTTP/2!
-    assertEquals(-3, settings.getCurrentCwnd(-3));
-    settings.set(Settings.CURRENT_CWND, 0, 86);
-    assertEquals(86, settings.getCurrentCwnd(-3));
-    settings.clear();
-    assertEquals(16384, settings.getMaxFrameSize(16384));
-    settings.set(Settings.MAX_FRAME_SIZE, 0, 16777215);
-    assertEquals(16777215, settings.getMaxFrameSize(16384));
-
-    // WARNING: clash on flags between spdy/3 and HTTP/2!
-    assertEquals(-3, settings.getDownloadRetransRate(-3));
-    settings.set(DOWNLOAD_RETRANS_RATE, 0, 97);
-    assertEquals(97, settings.getDownloadRetransRate(-3));
-    settings.clear();
-    assertEquals(-1, settings.getMaxHeaderListSize(-1));
-    settings.set(Settings.MAX_HEADER_LIST_SIZE, 0, 16777215);
-    assertEquals(16777215, settings.getMaxHeaderListSize(-1));
-
-    assertEquals(DEFAULT_INITIAL_WINDOW_SIZE,
-        settings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE));
-    settings.set(Settings.INITIAL_WINDOW_SIZE, 0, 108);
-    assertEquals(108, settings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE));
-
-    assertEquals(-3, settings.getClientCertificateVectorSize(-3));
-    settings.set(Settings.CLIENT_CERTIFICATE_VECTOR_SIZE, 0, 117);
-    assertEquals(117, settings.getClientCertificateVectorSize(-3));
-  }
-
-  @Test public void isPersisted() {
-    Settings settings = new Settings();
-
-    // Initially false.
-    assertFalse(settings.isPersisted(Settings.ROUND_TRIP_TIME));
-
-    // Set no flags.
-    settings.set(Settings.ROUND_TRIP_TIME, 0, 0);
-    assertFalse(settings.isPersisted(Settings.ROUND_TRIP_TIME));
-
-    // Set the wrong flag.
-    settings.set(Settings.ROUND_TRIP_TIME, PERSIST_VALUE, 0);
-    assertFalse(settings.isPersisted(Settings.ROUND_TRIP_TIME));
-
-    // Set the right flag.
-    settings.set(Settings.ROUND_TRIP_TIME, PERSISTED, 0);
-    assertTrue(settings.isPersisted(Settings.ROUND_TRIP_TIME));
-
-    // Set multiple flags.
-    settings.set(Settings.ROUND_TRIP_TIME, PERSIST_VALUE | PERSISTED, 0);
-    assertTrue(settings.isPersisted(Settings.ROUND_TRIP_TIME));
-
-    // Clear the flag.
-    settings.set(Settings.ROUND_TRIP_TIME, PERSIST_VALUE, 0);
-    assertFalse(settings.isPersisted(Settings.ROUND_TRIP_TIME));
-
-    // Clear all flags.
-    settings.set(Settings.ROUND_TRIP_TIME, 0, 0);
-    assertFalse(settings.isPersisted(Settings.ROUND_TRIP_TIME));
-  }
-
-  @Test public void persistValue() {
-    Settings settings = new Settings();
-
-    // Initially false.
-    assertFalse(settings.persistValue(Settings.ROUND_TRIP_TIME));
-
-    // Set no flags.
-    settings.set(Settings.ROUND_TRIP_TIME, 0, 0);
-    assertFalse(settings.persistValue(Settings.ROUND_TRIP_TIME));
-
-    // Set the wrong flag.
-    settings.set(Settings.ROUND_TRIP_TIME, PERSISTED, 0);
-    assertFalse(settings.persistValue(Settings.ROUND_TRIP_TIME));
-
-    // Set the right flag.
-    settings.set(Settings.ROUND_TRIP_TIME, PERSIST_VALUE, 0);
-    assertTrue(settings.persistValue(Settings.ROUND_TRIP_TIME));
-
-    // Set multiple flags.
-    settings.set(Settings.ROUND_TRIP_TIME, PERSIST_VALUE | PERSISTED, 0);
-    assertTrue(settings.persistValue(Settings.ROUND_TRIP_TIME));
-
-    // Clear the flag.
-    settings.set(Settings.ROUND_TRIP_TIME, PERSISTED, 0);
-    assertFalse(settings.persistValue(Settings.ROUND_TRIP_TIME));
-
-    // Clear all flags.
-    settings.set(Settings.ROUND_TRIP_TIME, 0, 0);
-    assertFalse(settings.persistValue(Settings.ROUND_TRIP_TIME));
-  }
-
-  @Test public void merge() {
-    Settings a = new Settings();
-    a.set(UPLOAD_BANDWIDTH, PERSIST_VALUE, 100);
-    a.set(DOWNLOAD_BANDWIDTH, PERSIST_VALUE, 200);
-    a.set(DOWNLOAD_RETRANS_RATE, 0, 300);
-
-    Settings b = new Settings();
-    b.set(DOWNLOAD_BANDWIDTH, 0, 400);
-    b.set(DOWNLOAD_RETRANS_RATE, PERSIST_VALUE, 500);
-    b.set(MAX_CONCURRENT_STREAMS, PERSIST_VALUE, 600);
-
-    a.merge(b);
-    assertEquals(100, a.getUploadBandwidth(-1));
-    assertEquals(PERSIST_VALUE, a.flags(UPLOAD_BANDWIDTH));
-    assertEquals(400, a.getDownloadBandwidth(-1));
-    assertEquals(0, a.flags(DOWNLOAD_BANDWIDTH));
-    assertEquals(500, a.getDownloadRetransRate(-1));
-    assertEquals(PERSIST_VALUE, a.flags(DOWNLOAD_RETRANS_RATE));
-    assertEquals(600, a.getMaxConcurrentStreams(-1));
-    assertEquals(PERSIST_VALUE, a.flags(MAX_CONCURRENT_STREAMS));
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3ConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3ConnectionTest.java
deleted file mode 100644
index 96a6fb4288..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3ConnectionTest.java
+++ /dev/null
@@ -1,1422 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.framed;
-
-import java.io.IOException;
-import java.io.InterruptedIOException;
-import java.net.Socket;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Random;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-import okhttp3.internal.Util;
-import okio.AsyncTimeout;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.ByteString;
-import okio.Okio;
-import okio.Sink;
-import okio.Source;
-import org.junit.After;
-import org.junit.Test;
-
-import static okhttp3.TestUtil.headerEntries;
-import static okhttp3.internal.framed.ErrorCode.CANCEL;
-import static okhttp3.internal.framed.ErrorCode.INTERNAL_ERROR;
-import static okhttp3.internal.framed.ErrorCode.INVALID_STREAM;
-import static okhttp3.internal.framed.ErrorCode.PROTOCOL_ERROR;
-import static okhttp3.internal.framed.ErrorCode.REFUSED_STREAM;
-import static okhttp3.internal.framed.ErrorCode.STREAM_IN_USE;
-import static okhttp3.internal.framed.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
-import static okhttp3.internal.framed.Settings.DOWNLOAD_BANDWIDTH;
-import static okhttp3.internal.framed.Settings.DOWNLOAD_RETRANS_RATE;
-import static okhttp3.internal.framed.Settings.INITIAL_WINDOW_SIZE;
-import static okhttp3.internal.framed.Settings.MAX_CONCURRENT_STREAMS;
-import static okhttp3.internal.framed.Settings.PERSIST_VALUE;
-import static okhttp3.internal.framed.Settings.UPLOAD_BANDWIDTH;
-import static okhttp3.internal.framed.Spdy3.TYPE_DATA;
-import static okhttp3.internal.framed.Spdy3.TYPE_GOAWAY;
-import static okhttp3.internal.framed.Spdy3.TYPE_HEADERS;
-import static okhttp3.internal.framed.Spdy3.TYPE_PING;
-import static okhttp3.internal.framed.Spdy3.TYPE_RST_STREAM;
-import static okhttp3.internal.framed.Spdy3.TYPE_WINDOW_UPDATE;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public final class Spdy3ConnectionTest {
-  private static final Variant SPDY3 = new Spdy3();
-  private final MockSpdyPeer peer = new MockSpdyPeer();
-
-  @After public void tearDown() throws Exception {
-    peer.close();
-  }
-
-  @Test public void clientCreatesStreamAndServerReplies() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame()
-        .synReply(false, 1, headerEntries("a", "android"));
-    peer.sendFrame().data(true, 1, new Buffer().writeUtf8("robot"), 5);
-    peer.acceptFrame(); // DATA
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
-    assertStreamData("robot", stream.getSource());
-    BufferedSink out = Okio.buffer(stream.getSink());
-    out.writeUtf8("c3po");
-    out.close();
-    assertEquals(0, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    assertFalse(synStream.inFinished);
-    assertFalse(synStream.outFinished);
-    assertEquals(1, synStream.streamId);
-    assertEquals(0, synStream.associatedStreamId);
-    assertEquals(headerEntries("b", "banana"), synStream.headerBlock);
-    MockSpdyPeer.InFrame requestData = peer.takeFrame();
-    assertTrue(Arrays.equals("c3po".getBytes("UTF-8"), requestData.data));
-  }
-
-  @Test public void headersOnlyStreamIsClosedAfterReplyHeaders() throws Exception {
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("a", "android"), false, false);
-    assertEquals(headerEntries("b", "banana"), stream.getResponseHeaders());
-    connection.ping().roundTripTime(); // Ensure that inFinished has been received.
-    assertEquals(0, connection.openStreamCount());
-  }
-
-  @Test public void clientCreatesStreamAndServerRepliesWithFin() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // PING
-    peer.sendFrame().synReply(true, 1, headerEntries("a", "android"));
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    connection.newStream(headerEntries("b", "banana"), false, true);
-    assertEquals(1, connection.openStreamCount());
-    connection.ping().roundTripTime(); // Ensure that the SYN_REPLY has been received.
-    assertEquals(0, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_PING, ping.type);
-  }
-
-  @Test public void serverCreatesStreamAndClientReplies() throws Exception {
-    final List<Header> pushHeaders = headerEntries(
-        ":scheme", "https",
-        ":host", "localhost:8888",
-        ":method", "GET",
-        ":path", "/index.html",
-        ":status", "200",
-        ":version", "HTTP/1.1",
-        "content-type", "text/html");
-    // write the mocking script
-    peer.sendFrame().synStream(false, false, 2, 0, pushHeaders);
-    peer.acceptFrame(); // SYN_REPLY
-    peer.play();
-
-    // play it back
-    final AtomicInteger receiveCount = new AtomicInteger();
-    FramedConnection.Listener handler = new FramedConnection.Listener() {
-      @Override public void onStream(FramedStream stream) throws IOException {
-        receiveCount.incrementAndGet();
-        assertEquals(pushHeaders, stream.getRequestHeaders());
-        assertEquals(null, stream.getErrorCode());
-        stream.reply(headerEntries("b", "banana"), true);
-      }
-    };
-    FramedConnection connection = new FramedConnection.Builder(true)
-        .socket(peer.openSocket())
-        .listener(handler)
-        .build();
-    connection.start(false);
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame reply = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, reply.type);
-    assertEquals(HeadersMode.SPDY_REPLY, reply.headersMode);
-    assertFalse(reply.inFinished);
-    assertEquals(2, reply.streamId);
-    assertEquals(headerEntries("b", "banana"), reply.headerBlock);
-    assertEquals(1, receiveCount.get());
-  }
-
-  @Test public void replyWithNoData() throws Exception {
-    // write the mocking script
-    peer.sendFrame().synStream(false, false, 2, 0, headerEntries("a", "android"));
-    peer.acceptFrame(); // SYN_REPLY
-    peer.play();
-
-    // play it back
-    final AtomicInteger receiveCount = new AtomicInteger();
-    FramedConnection.Listener listener = new FramedConnection.Listener() {
-      @Override public void onStream(FramedStream stream) throws IOException {
-        stream.reply(headerEntries("b", "banana"), false);
-        receiveCount.incrementAndGet();
-      }
-    };
-
-    FramedConnection connection = connectionBuilder(peer, SPDY3)
-        .listener(listener)
-        .build();
-    connection.start(false);
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame reply = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, reply.type);
-    assertTrue(reply.inFinished);
-    assertEquals(headerEntries("b", "banana"), reply.headerBlock);
-    assertEquals(1, receiveCount.get());
-    assertEquals(HeadersMode.SPDY_REPLY, reply.headersMode);
-  }
-
-  @Test public void serverPingsClient() throws Exception {
-    // write the mocking script
-    peer.sendFrame().ping(false, 2, 0);
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    connection(peer, SPDY3);
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(0, ping.streamId);
-    assertEquals(2, ping.payload1);
-    assertEquals(0, ping.payload2); // ignored in spdy!
-    assertTrue(ping.ack);
-  }
-
-  @Test public void clientPingsServer() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 5); // payload2 ignored in spdy!
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    Ping ping = connection.ping();
-    assertTrue(ping.roundTripTime() > 0);
-    assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame pingFrame = peer.takeFrame();
-    assertEquals(TYPE_PING, pingFrame.type);
-    assertEquals(1, pingFrame.payload1);
-    assertEquals(0, pingFrame.payload2);
-    assertFalse(pingFrame.ack);
-  }
-
-  @Test public void unexpectedPingIsNotReturned() throws Exception {
-    // write the mocking script
-    peer.sendFrame().ping(false, 2, 0);
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 3, 0); // This ping will not be returned.
-    peer.sendFrame().ping(false, 4, 0);
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    connection(peer, SPDY3);
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame ping2 = peer.takeFrame();
-    assertEquals(2, ping2.payload1);
-    MockSpdyPeer.InFrame ping4 = peer.takeFrame();
-    assertEquals(4, ping4.payload1);
-  }
-
-  @Test public void serverSendsSettingsToClient() throws Exception {
-    // write the mocking script
-    final Settings settings = new Settings();
-    settings.set(MAX_CONCURRENT_STREAMS, PERSIST_VALUE, 10);
-    peer.sendFrame().settings(settings);
-    peer.sendFrame().ping(false, 2, 0);
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    final AtomicInteger maxConcurrentStreams = new AtomicInteger();
-    FramedConnection.Listener listener = new FramedConnection.Listener() {
-      @Override public void onStream(FramedStream stream) throws IOException {
-        throw new AssertionError();
-      }
-
-      @Override public void onSettings(FramedConnection connection) {
-        maxConcurrentStreams.set(connection.maxConcurrentStreams());
-      }
-    };
-    FramedConnection connection = connectionBuilder(peer, SPDY3)
-        .listener(listener)
-        .build();
-    connection.start(false);
-
-    peer.takeFrame(); // Guarantees that the peer Settings frame has been processed.
-    synchronized (connection) {
-      assertEquals(10, connection.peerSettings.getMaxConcurrentStreams(-1));
-    }
-    assertEquals(10, maxConcurrentStreams.get());
-  }
-
-  @Test public void multipleSettingsFramesAreMerged() throws Exception {
-    // write the mocking script
-    Settings settings1 = new Settings();
-    settings1.set(UPLOAD_BANDWIDTH, PERSIST_VALUE, 100);
-    settings1.set(DOWNLOAD_BANDWIDTH, PERSIST_VALUE, 200);
-    settings1.set(DOWNLOAD_RETRANS_RATE, 0, 300);
-    peer.sendFrame().settings(settings1);
-    Settings settings2 = new Settings();
-    settings2.set(DOWNLOAD_BANDWIDTH, 0, 400);
-    settings2.set(DOWNLOAD_RETRANS_RATE, PERSIST_VALUE, 500);
-    settings2.set(MAX_CONCURRENT_STREAMS, PERSIST_VALUE, 600);
-    peer.sendFrame().settings(settings2);
-    peer.sendFrame().ping(false, 2, 0);
-    peer.acceptFrame();
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-
-    peer.takeFrame(); // Guarantees that the Settings frame has been processed.
-    synchronized (connection) {
-      assertEquals(100, connection.peerSettings.getUploadBandwidth(-1));
-      assertEquals(PERSIST_VALUE, connection.peerSettings.flags(UPLOAD_BANDWIDTH));
-      assertEquals(400, connection.peerSettings.getDownloadBandwidth(-1));
-      assertEquals(0, connection.peerSettings.flags(DOWNLOAD_BANDWIDTH));
-      assertEquals(500, connection.peerSettings.getDownloadRetransRate(-1));
-      assertEquals(PERSIST_VALUE, connection.peerSettings.flags(DOWNLOAD_RETRANS_RATE));
-      assertEquals(600, connection.peerSettings.getMaxConcurrentStreams(-1));
-      assertEquals(PERSIST_VALUE, connection.peerSettings.flags(MAX_CONCURRENT_STREAMS));
-    }
-  }
-
-  @Test public void clearSettingsBeforeMerge() throws Exception {
-    // write the mocking script
-    Settings settings1 = new Settings();
-    settings1.set(UPLOAD_BANDWIDTH, PERSIST_VALUE, 100);
-    settings1.set(DOWNLOAD_BANDWIDTH, PERSIST_VALUE, 200);
-    settings1.set(DOWNLOAD_RETRANS_RATE, 0, 300);
-    peer.sendFrame().settings(settings1);
-    peer.sendFrame().ping(false, 2, 0);
-    peer.acceptFrame();
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-
-    peer.takeFrame(); // Guarantees that the Settings frame has been processed.
-
-    // fake a settings frame with clear flag set.
-    Settings settings2 = new Settings();
-    settings2.set(MAX_CONCURRENT_STREAMS, PERSIST_VALUE, 600);
-    connection.readerRunnable.settings(true, settings2);
-
-    synchronized (connection) {
-      assertEquals(-1, connection.peerSettings.getUploadBandwidth(-1));
-      assertEquals(-1, connection.peerSettings.getDownloadBandwidth(-1));
-      assertEquals(-1, connection.peerSettings.getDownloadRetransRate(-1));
-      assertEquals(600, connection.peerSettings.getMaxConcurrentStreams(-1));
-    }
-  }
-
-  @Test public void bogusDataFrameDoesNotDisruptConnection() throws Exception {
-    // write the mocking script
-    peer.sendFrame().data(true, 41, new Buffer().writeUtf8("bogus"), 5);
-    peer.acceptFrame(); // RST_STREAM
-    peer.sendFrame().ping(false, 2, 0);
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    connection(peer, SPDY3);
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame rstStream = peer.takeFrame();
-    assertEquals(TYPE_RST_STREAM, rstStream.type);
-    assertEquals(41, rstStream.streamId);
-    assertEquals(INVALID_STREAM, rstStream.errorCode);
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(2, ping.payload1);
-  }
-
-  @Test public void bogusReplyFrameDoesNotDisruptConnection() throws Exception {
-    // write the mocking script
-    peer.sendFrame().synReply(false, 41, headerEntries("a", "android"));
-    peer.acceptFrame(); // RST_STREAM
-    peer.sendFrame().ping(false, 2, 0);
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    connection(peer, SPDY3);
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame rstStream = peer.takeFrame();
-    assertEquals(TYPE_RST_STREAM, rstStream.type);
-    assertEquals(41, rstStream.streamId);
-    assertEquals(INVALID_STREAM, rstStream.errorCode);
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(2, ping.payload1);
-  }
-
-  @Test public void clientClosesClientOutputStream() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
-    peer.acceptFrame(); // TYPE_DATA
-    peer.acceptFrame(); // TYPE_DATA with FLAG_FIN
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("a", "android"), true, false);
-    BufferedSink out = Okio.buffer(stream.getSink());
-    out.writeUtf8("square");
-    out.flush();
-    assertEquals(1, connection.openStreamCount());
-    out.close();
-    try {
-      out.writeUtf8("round");
-      fail();
-    } catch (Exception expected) {
-      assertEquals("closed", expected.getMessage());
-    }
-    connection.ping().roundTripTime(); // Ensure that the SYN_REPLY has been received.
-    assertEquals(0, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    assertFalse(synStream.inFinished);
-    assertTrue(synStream.outFinished);
-    MockSpdyPeer.InFrame data = peer.takeFrame();
-    assertEquals(TYPE_DATA, data.type);
-    assertFalse(data.inFinished);
-    assertTrue(Arrays.equals("square".getBytes("UTF-8"), data.data));
-    MockSpdyPeer.InFrame fin = peer.takeFrame();
-    assertEquals(TYPE_DATA, fin.type);
-    assertTrue(fin.inFinished);
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_PING, ping.type);
-    assertEquals(1, ping.payload1);
-  }
-
-  @Test public void serverClosesClientOutputStream() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().rstStream(1, CANCEL);
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("a", "android"), true, true);
-    BufferedSink out = Okio.buffer(stream.getSink());
-    connection.ping().roundTripTime(); // Ensure that the RST_CANCEL has been received.
-    try {
-      out.writeUtf8("square");
-      out.flush();
-      fail();
-    } catch (IOException expected) {
-      assertEquals("stream was reset: CANCEL", expected.getMessage());
-    }
-    try {
-      out.close();
-      fail();
-    } catch (IOException expected) {
-      // Close throws because buffered data wasn't flushed.
-    }
-    assertEquals(0, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    assertFalse(synStream.inFinished);
-    assertFalse(synStream.outFinished);
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_PING, ping.type);
-    assertEquals(1, ping.payload1);
-  }
-
-  /**
-   * Test that the client sends a RST_STREAM if doing so won't disrupt the output stream.
-   */
-  @Test public void clientClosesClientInputStream() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("a", "android"), false, true);
-    Source in = stream.getSource();
-    BufferedSink out = Okio.buffer(stream.getSink());
-    in.close();
-    try {
-      in.read(new Buffer(), 1);
-      fail();
-    } catch (IOException expected) {
-      assertEquals("stream closed", expected.getMessage());
-    }
-    try {
-      out.writeUtf8("a");
-      out.flush();
-      fail();
-    } catch (IOException expected) {
-      assertEquals("stream finished", expected.getMessage());
-    }
-    assertEquals(0, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    assertTrue(synStream.inFinished);
-    assertFalse(synStream.outFinished);
-    MockSpdyPeer.InFrame rstStream = peer.takeFrame();
-    assertEquals(TYPE_RST_STREAM, rstStream.type);
-    assertEquals(CANCEL, rstStream.errorCode);
-  }
-
-  /**
-   * Test that the client doesn't send a RST_STREAM if doing so will disrupt the output stream.
-   */
-  @Test public void clientClosesClientInputStreamIfOutputStreamIsClosed() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // DATA
-    peer.acceptFrame(); // DATA with FLAG_FIN
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("a", "android"), true, true);
-    Source source = stream.getSource();
-    BufferedSink out = Okio.buffer(stream.getSink());
-    source.close();
-    try {
-      source.read(new Buffer(), 1);
-      fail();
-    } catch (IOException expected) {
-      assertEquals("stream closed", expected.getMessage());
-    }
-    out.writeUtf8("square");
-    out.flush();
-    out.close();
-    assertEquals(0, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    assertFalse(synStream.inFinished);
-    assertFalse(synStream.outFinished);
-    MockSpdyPeer.InFrame data = peer.takeFrame();
-    assertEquals(TYPE_DATA, data.type);
-    assertTrue(Arrays.equals("square".getBytes("UTF-8"), data.data));
-    MockSpdyPeer.InFrame fin = peer.takeFrame();
-    assertEquals(TYPE_DATA, fin.type);
-    assertTrue(fin.inFinished);
-    assertFalse(fin.outFinished);
-    MockSpdyPeer.InFrame rstStream = peer.takeFrame();
-    assertEquals(TYPE_RST_STREAM, rstStream.type);
-    assertEquals(CANCEL, rstStream.errorCode);
-  }
-
-  @Test public void serverClosesClientInputStream() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
-    peer.sendFrame().data(true, 1, new Buffer().writeUtf8("square"), 6);
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("a", "android"), false, true);
-    Source source = stream.getSource();
-    assertStreamData("square", source);
-    connection.ping().roundTripTime(); // Ensure that inFinished has been received.
-    assertEquals(0, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    assertTrue(synStream.inFinished);
-    assertFalse(synStream.outFinished);
-  }
-
-  @Test public void remoteDoubleSynReply() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    peer.acceptFrame(); // PING
-    peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
-    peer.sendFrame().ping(true, 1, 0);
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("c", "cola"), true, true);
-    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
-    connection.ping().roundTripTime(); // Ensure that the 2nd SYN REPLY has been received.
-    try {
-      stream.getSource().read(new Buffer(), 1);
-      fail();
-    } catch (IOException expected) {
-      assertEquals("stream was reset: STREAM_IN_USE", expected.getMessage());
-    }
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_PING, ping.type);
-    MockSpdyPeer.InFrame rstStream = peer.takeFrame();
-    assertEquals(TYPE_RST_STREAM, rstStream.type);
-    assertEquals(1, rstStream.streamId);
-    assertEquals(STREAM_IN_USE, rstStream.errorCode);
-  }
-
-  @Test public void remoteDoubleSynStream() throws Exception {
-    // write the mocking script
-    peer.sendFrame().synStream(false, false, 2, 0, headerEntries("a", "android"));
-    peer.acceptFrame(); // SYN_REPLY
-    peer.sendFrame().synStream(false, false, 2, 0, headerEntries("b", "banana"));
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    final AtomicInteger receiveCount = new AtomicInteger();
-    FramedConnection.Listener listener = new FramedConnection.Listener() {
-      @Override public void onStream(FramedStream stream) throws IOException {
-        receiveCount.incrementAndGet();
-        assertEquals(headerEntries("a", "android"), stream.getRequestHeaders());
-        assertEquals(null, stream.getErrorCode());
-        stream.reply(headerEntries("c", "cola"), true);
-      }
-    };
-    FramedConnection connection = new FramedConnection.Builder(true)
-        .socket(peer.openSocket())
-        .listener(listener)
-        .build();
-    connection.start(false);
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame reply = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, reply.type);
-    assertEquals(HeadersMode.SPDY_REPLY, reply.headersMode);
-    MockSpdyPeer.InFrame rstStream = peer.takeFrame();
-    assertEquals(TYPE_RST_STREAM, rstStream.type);
-    assertEquals(2, rstStream.streamId);
-    assertEquals(PROTOCOL_ERROR, rstStream.errorCode);
-    assertEquals(1, receiveCount.intValue());
-  }
-
-  @Test public void remoteSendsDataAfterInFinished() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    peer.sendFrame().data(true, 1, new Buffer().writeUtf8("robot"), 5);
-    peer.sendFrame().data(true, 1, new Buffer().writeUtf8("c3po"), 4); // Ignored.
-    peer.sendFrame().ping(false, 2, 0); // Ping just to make sure the stream was fastforwarded.
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
-    assertStreamData("robot", stream.getSource());
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_PING, ping.type);
-    assertEquals(2, ping.payload1);
-  }
-
-  @Test public void clientDoesNotLimitFlowControl() throws Exception {
-    int dataLength = 64 * 1024 + 1;
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
-    peer.sendFrame().data(false, 1, new Buffer().write(new byte[dataLength]), dataLength);
-    peer.sendFrame().ping(false, 2, 0); // Ping just to make sure the stream was fastforwarded.
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("a", "android"), true, true);
-    assertEquals(headerEntries("b", "banana"), stream.getResponseHeaders());
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_PING, ping.type);
-    assertEquals(2, ping.payload1);
-  }
-
-  @Test public void remoteSendsRefusedStreamBeforeReplyHeaders() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().rstStream(1, REFUSED_STREAM);
-    peer.sendFrame().ping(false, 2, 0);
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("a", "android"), true, true);
-    try {
-      stream.getResponseHeaders();
-      fail();
-    } catch (IOException expected) {
-      assertEquals("stream was reset: REFUSED_STREAM", expected.getMessage());
-    }
-    assertEquals(0, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_PING, ping.type);
-    assertEquals(2, ping.payload1);
-  }
-
-  @Test public void receiveGoAway() throws Exception {
-    peer.setVariantAndClient(SPDY3, false);
-
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM 1
-    peer.acceptFrame(); // SYN_STREAM 3
-    peer.acceptFrame(); // PING.
-    peer.sendFrame().goAway(1, PROTOCOL_ERROR, Util.EMPTY_BYTE_ARRAY);
-    peer.sendFrame().ping(true, 1, 0);
-    peer.acceptFrame(); // DATA STREAM 1
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream1 = connection.newStream(headerEntries("a", "android"), true, true);
-    FramedStream stream2 = connection.newStream(headerEntries("b", "banana"), true, true);
-    connection.ping().roundTripTime(); // Ensure the GO_AWAY that resets stream2 has been received.
-    BufferedSink sink1 = Okio.buffer(stream1.getSink());
-    BufferedSink sink2 = Okio.buffer(stream2.getSink());
-    sink1.writeUtf8("abc");
-    try {
-      sink2.writeUtf8("abc");
-      sink2.flush();
-      fail();
-    } catch (IOException expected) {
-      assertEquals("stream was reset: REFUSED_STREAM", expected.getMessage());
-    }
-    sink1.writeUtf8("def");
-    sink1.close();
-    try {
-      connection.newStream(headerEntries("c", "cola"), true, true);
-      fail();
-    } catch (IOException expected) {
-      assertEquals("shutdown", expected.getMessage());
-    }
-    assertTrue(stream1.isOpen());
-    assertFalse(stream2.isOpen());
-    assertEquals(1, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream1 = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream1.type);
-    MockSpdyPeer.InFrame synStream2 = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream2.type);
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_PING, ping.type);
-    MockSpdyPeer.InFrame data1 = peer.takeFrame();
-    assertEquals(TYPE_DATA, data1.type);
-    assertEquals(1, data1.streamId);
-    assertTrue(Arrays.equals("abcdef".getBytes("UTF-8"), data1.data));
-  }
-
-  @Test public void sendGoAway() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM 1
-    peer.acceptFrame(); // GOAWAY
-    peer.acceptFrame(); // PING
-    peer.sendFrame().synStream(false, false, 2, 0, headerEntries("b", "b")); // Should be ignored!
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    connection.newStream(headerEntries("a", "android"), true, true);
-    Ping ping = connection.ping();
-    connection.shutdown(PROTOCOL_ERROR);
-    assertEquals(1, connection.openStreamCount());
-    ping.roundTripTime(); // Prevent the peer from exiting prematurely.
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream1 = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream1.type);
-    MockSpdyPeer.InFrame pingFrame = peer.takeFrame();
-    assertEquals(TYPE_PING, pingFrame.type);
-    MockSpdyPeer.InFrame goaway = peer.takeFrame();
-    assertEquals(TYPE_GOAWAY, goaway.type);
-    assertEquals(0, goaway.streamId);
-    assertEquals(PROTOCOL_ERROR, goaway.errorCode);
-  }
-
-  @Test public void noPingsAfterShutdown() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // GOAWAY
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    connection.shutdown(INTERNAL_ERROR);
-    try {
-      connection.ping();
-      fail();
-    } catch (IOException expected) {
-      assertEquals("shutdown", expected.getMessage());
-    }
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame goaway = peer.takeFrame();
-    assertEquals(TYPE_GOAWAY, goaway.type);
-    assertEquals(INTERNAL_ERROR, goaway.errorCode);
-  }
-
-  @Test public void close() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // GOAWAY
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("a", "android"), true, true);
-    assertEquals(1, connection.openStreamCount());
-    connection.close();
-    assertEquals(0, connection.openStreamCount());
-    try {
-      connection.newStream(headerEntries("b", "banana"), true, true);
-      fail();
-    } catch (IOException expected) {
-      assertEquals("shutdown", expected.getMessage());
-    }
-    BufferedSink sink = Okio.buffer(stream.getSink());
-    try {
-      sink.writeByte(0);
-      sink.flush();
-      fail();
-    } catch (IOException expected) {
-      assertEquals("stream was reset: CANCEL", expected.getMessage());
-    }
-    try {
-      stream.getSource().read(new Buffer(), 1);
-      fail();
-    } catch (IOException expected) {
-      assertEquals("stream was reset: CANCEL", expected.getMessage());
-    }
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    MockSpdyPeer.InFrame goaway = peer.takeFrame();
-    assertEquals(TYPE_GOAWAY, goaway.type);
-    MockSpdyPeer.InFrame rstStream = peer.takeFrame();
-    assertEquals(TYPE_RST_STREAM, rstStream.type);
-    assertEquals(1, rstStream.streamId);
-  }
-
-  @Test public void closeCancelsPings() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // PING
-    peer.acceptFrame(); // GOAWAY
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    Ping ping = connection.ping();
-    connection.close();
-    assertEquals(-1, ping.roundTripTime());
-  }
-
-  @Test public void getResponseHeadersTimesOut() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    stream.readTimeout().timeout(500, TimeUnit.MILLISECONDS);
-    long startNanos = System.nanoTime();
-    try {
-      stream.getResponseHeaders();
-      fail();
-    } catch (InterruptedIOException expected) {
-    }
-    long elapsedNanos = System.nanoTime() - startNanos;
-    awaitWatchdogIdle();
-    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
-    assertEquals(0, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
-    assertEquals(TYPE_RST_STREAM, peer.takeFrame().type);
-  }
-
-  @Test public void readTimesOut() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    stream.readTimeout().timeout(500, TimeUnit.MILLISECONDS);
-    Source source = stream.getSource();
-    long startNanos = System.nanoTime();
-    try {
-      source.read(new Buffer(), 1);
-      fail();
-    } catch (InterruptedIOException expected) {
-    }
-    long elapsedNanos = System.nanoTime() - startNanos;
-    awaitWatchdogIdle();
-    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
-    assertEquals(0, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
-    assertEquals(TYPE_RST_STREAM, peer.takeFrame().type);
-  }
-
-  @Test public void writeTimesOutAwaitingStreamWindow() throws Exception {
-    // Set the peer's receive window to 5 bytes!
-    Settings peerSettings = new Settings().set(INITIAL_WINDOW_SIZE, PERSIST_VALUE, 5);
-
-    // write the mocking script
-    peer.sendFrame().settings(peerSettings);
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    peer.acceptFrame(); // DATA
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    connection.ping().roundTripTime(); // Make sure settings have been received.
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    Sink sink = stream.getSink();
-    sink.write(new Buffer().writeUtf8("abcde"), 5);
-    stream.writeTimeout().timeout(500, TimeUnit.MILLISECONDS);
-    long startNanos = System.nanoTime();
-    sink.write(new Buffer().writeUtf8("f"), 1);
-    try {
-      sink.flush(); // This will time out waiting on the write window.
-      fail();
-    } catch (InterruptedIOException expected) {
-    }
-    long elapsedNanos = System.nanoTime() - startNanos;
-    awaitWatchdogIdle();
-    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
-    assertEquals(0, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    assertEquals(TYPE_PING, peer.takeFrame().type);
-    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
-    assertEquals(TYPE_DATA, peer.takeFrame().type);
-    assertEquals(TYPE_RST_STREAM, peer.takeFrame().type);
-  }
-
-  @Test public void writeTimesOutAwaitingConnectionWindow() throws Exception {
-    // Set the peer's receive window to 5 bytes. Give the stream 5 bytes back, so only the
-    // connection-level window is applicable.
-    Settings peerSettings = new Settings().set(INITIAL_WINDOW_SIZE, PERSIST_VALUE, 5);
-
-    // write the mocking script
-    peer.sendFrame().settings(peerSettings);
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    peer.sendFrame().windowUpdate(1, 5);
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
-    peer.acceptFrame(); // DATA
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    connection.ping().roundTripTime(); // Make sure the window update has been received.
-    Sink sink = stream.getSink();
-    stream.writeTimeout().timeout(500, TimeUnit.MILLISECONDS);
-    sink.write(new Buffer().writeUtf8("abcdef"), 6);
-    long startNanos = System.nanoTime();
-    try {
-      sink.flush(); // This will time out waiting on the write window.
-      fail();
-    } catch (InterruptedIOException expected) {
-    }
-    long elapsedNanos = System.nanoTime() - startNanos;
-    awaitWatchdogIdle();
-    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
-    assertEquals(0, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
-    assertEquals(TYPE_PING, peer.takeFrame().type);
-    assertEquals(TYPE_DATA, peer.takeFrame().type);
-    assertEquals(TYPE_RST_STREAM, peer.takeFrame().type);
-  }
-
-  @Test public void outgoingWritesAreBatched() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    peer.acceptFrame(); // DATA
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-
-    // two outgoing writes
-    Sink sink = stream.getSink();
-    sink.write(new Buffer().writeUtf8("abcde"), 5);
-    sink.write(new Buffer().writeUtf8("fghij"), 5);
-    sink.close();
-
-    // verify the peer received one incoming frame
-    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
-    MockSpdyPeer.InFrame data = peer.takeFrame();
-    assertEquals(TYPE_DATA, data.type);
-    assertTrue(Arrays.equals("abcdefghij".getBytes("UTF-8"), data.data));
-    assertTrue(data.inFinished);
-  }
-
-  @Test public void headers() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // PING
-    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    peer.sendFrame().headers(1, headerEntries("c", "c3po"));
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    connection.ping().roundTripTime(); // Ensure that the HEADERS has been received.
-    assertEquals(headerEntries("a", "android", "c", "c3po"), stream.getResponseHeaders());
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_PING, ping.type);
-  }
-
-  @Test public void headersBeforeReply() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // PING
-    peer.sendFrame().headers(1, headerEntries("c", "c3po"));
-    peer.acceptFrame(); // RST_STREAM
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    connection.ping().roundTripTime(); // Ensure that the HEADERS has been received.
-    try {
-      stream.getResponseHeaders();
-      fail();
-    } catch (IOException expected) {
-      assertEquals("stream was reset: PROTOCOL_ERROR", expected.getMessage());
-    }
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_PING, ping.type);
-    MockSpdyPeer.InFrame rstStream = peer.takeFrame();
-    assertEquals(TYPE_RST_STREAM, rstStream.type);
-    assertEquals(PROTOCOL_ERROR, rstStream.errorCode);
-  }
-
-  @Test public void readSendsWindowUpdate() throws Exception {
-    peer.setVariantAndClient(SPDY3, false);
-
-    int windowSize = 100;
-    int windowUpdateThreshold = 50;
-
-    // Write the mocking script.
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    for (int i = 0; i < 3; i++) {
-      // Send frames of summing to size 50, which is windowUpdateThreshold.
-      peer.sendFrame().data(false, 1, data(24), 24);
-      peer.sendFrame().data(false, 1, data(25), 25);
-      peer.sendFrame().data(false, 1, data(1), 1);
-      peer.acceptFrame(); // connection WINDOW UPDATE
-      peer.acceptFrame(); // stream WINDOW UPDATE
-    }
-    peer.sendFrame().data(true, 1, data(0), 0);
-    peer.play();
-
-    // Play it back.
-    FramedConnection connection = connection(peer, SPDY3);
-    connection.okHttpSettings.set(INITIAL_WINDOW_SIZE, 0, windowSize);
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), false, true);
-    assertEquals(0, stream.unacknowledgedBytesRead);
-    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
-    Source in = stream.getSource();
-    Buffer buffer = new Buffer();
-    buffer.writeAll(in);
-    assertEquals(-1, in.read(buffer, 1));
-    assertEquals(150, buffer.size());
-
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    for (int i = 0; i < 3; i++) {
-      List<Integer> windowUpdateStreamIds = new ArrayList<>(2);
-      for (int j = 0; j < 2; j++) {
-        MockSpdyPeer.InFrame windowUpdate = peer.takeFrame();
-        assertEquals(TYPE_WINDOW_UPDATE, windowUpdate.type);
-        windowUpdateStreamIds.add(windowUpdate.streamId);
-        assertEquals(windowUpdateThreshold, windowUpdate.windowSizeIncrement);
-      }
-      assertTrue(windowUpdateStreamIds.contains(0)); // connection
-      assertTrue(windowUpdateStreamIds.contains(1)); // stream
-    }
-  }
-
-  private Buffer data(int byteCount) {
-    return new Buffer().write(new byte[byteCount]);
-  }
-
-  @Test public void serverSendsEmptyDataClientDoesntSendWindowUpdate() throws Exception {
-    peer.setVariantAndClient(SPDY3, false);
-
-    // Write the mocking script.
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    peer.sendFrame().data(true, 1, data(0), 0);
-    peer.play();
-
-    // Play it back.
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream client = connection.newStream(headerEntries("b", "banana"), false, true);
-    assertEquals(-1, client.getSource().read(new Buffer(), 1));
-
-    // Verify the peer received what was expected.
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(3, peer.frameCount());
-  }
-
-  @Test public void clientSendsEmptyDataServerDoesntSendWindowUpdate() throws Exception {
-    peer.setVariantAndClient(SPDY3, false);
-
-    // Write the mocking script.
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // DATA
-    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    peer.play();
-
-    // Play it back.
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream client = connection.newStream(headerEntries("b", "banana"), true, true);
-    BufferedSink out = Okio.buffer(client.getSink());
-    out.write(Util.EMPTY_BYTE_ARRAY);
-    out.flush();
-    out.close();
-
-    // Verify the peer received what was expected.
-    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
-    assertEquals(TYPE_DATA, peer.takeFrame().type);
-    assertEquals(3, peer.frameCount());
-  }
-
-  @Test public void testTruncatedDataFrame() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    peer.sendFrame().data(false, 1, data(1024), 1024);
-    peer.truncateLastFrame(8 + 100);
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
-    Source in = stream.getSource();
-    try {
-      Okio.buffer(in).readByteString(101);
-      fail();
-    } catch (IOException expected) {
-      assertEquals("stream was reset: PROTOCOL_ERROR", expected.getMessage());
-    }
-  }
-
-  @Test public void blockedStreamDoesntStarveNewStream() throws Exception {
-    int framesThatFillWindow = roundUp(DEFAULT_INITIAL_WINDOW_SIZE, peer.maxOutboundDataLength());
-
-    // Write the mocking script. This accepts more data frames than necessary!
-    peer.acceptFrame(); // SYN_STREAM on stream 1
-    for (int i = 0; i < framesThatFillWindow; i++) {
-      peer.acceptFrame(); // DATA on stream 1
-    }
-    peer.acceptFrame(); // SYN_STREAM on stream 2
-    peer.acceptFrame(); // DATA on stream 2
-    peer.play();
-
-    // Play it back.
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream1 = connection.newStream(headerEntries("a", "apple"), true, true);
-    BufferedSink out1 = Okio.buffer(stream1.getSink());
-    out1.write(new byte[DEFAULT_INITIAL_WINDOW_SIZE]);
-    out1.flush();
-
-    // Check that we've filled the window for both the stream and also the connection.
-    assertEquals(0, connection.bytesLeftInWriteWindow);
-    assertEquals(0, connection.getStream(1).bytesLeftInWriteWindow);
-
-    // receiving a window update on the the connection will unblock new streams.
-    connection.readerRunnable.windowUpdate(0, 3);
-
-    assertEquals(3, connection.bytesLeftInWriteWindow);
-    assertEquals(0, connection.getStream(1).bytesLeftInWriteWindow);
-
-    // Another stream should be able to send data even though 1 is blocked.
-    FramedStream stream2 = connection.newStream(headerEntries("b", "banana"), true, true);
-    BufferedSink out2 = Okio.buffer(stream2.getSink());
-    out2.writeUtf8("foo");
-    out2.flush();
-
-    assertEquals(0, connection.bytesLeftInWriteWindow);
-    assertEquals(0, connection.getStream(1).bytesLeftInWriteWindow);
-    assertEquals(DEFAULT_INITIAL_WINDOW_SIZE - 3, connection.getStream(3).bytesLeftInWriteWindow);
-  }
-
-  /** https://github.com/square/okhttp/issues/333 */
-  @Test public void headerBlockHasTrailingCompressedBytes512() throws Exception {
-    // This specially-formatted frame has trailing deflated bytes after the name value block.
-    String frame = "gAMAAgAAAgkAAAABeLvjxqfCYgAAAAD//2IAAAAA//9iAAAAAP//YgQAAAD//2IAAAAA//9iAAAAAP/"
-        + "/YgAAAAD//2IEAAAA//9KBAAAAP//YgAAAAD//2IAAAAA//9iAAAAAP//sgEAAAD//2IAAAAA\n//9iBAAAAP//Y"
-        + "gIAAAD//2IGAAAA//9iAQAAAP//YgUAAAD//2IDAAAA//9iBwAAAP//4gAAAAD//+IEAAAA///iAgAAAP//4gYAA"
-        + "AD//+IBAAAA///iBQAAAP//4gMAAAD//+IHAAAA//8SAAAAAP//EgQAAAD//xICAAAA//8SBgAAAP//EgEAAAD//"
-        + "xIFAAAA//8SAwAAAP//EgcAAAD//5IAAAAA//+SBAAAAP//kgIAAAD//5IGAAAA//+SAQAAAP//kgUAAAD//5IDA"
-        + "AAA//+SBwAAAP//UgAAAAD//1IEAAAA//9SAgAAAP//UgYAAAD//1IBAAAA//9SBQAAAP//UgMAAAD//1IHAAAA/"
-        + "//SAAAAAP//0gQAAAD//9ICAAAA///SBgAAAP//0gEAAAD//9IFAAAA///SAwAAAP//0gcAAAD//zIAAAAA//8yB"
-        + "AAAAP//MgIAAAD//zIGAAAA//8yAQAAAP//MgUAAAD//zIDAAAA//8yBwAAAP//sgAAAAD//7IEAAAA//+yAgAAA"
-        + "P//sgYAAAD//w==";
-    headerBlockHasTrailingCompressedBytes(frame, 60);
-  }
-
-  @Test public void headerBlockHasTrailingCompressedBytes2048() throws Exception {
-    // This specially-formatted frame has trailing deflated bytes after the name value block.
-    String frame = "gAMAAgAAB/sAAAABeLvjxqfCAqYjRhAGJmxGxUQAAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAA"
-        + "AAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP/"
-        + "/SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQ"
-        + "AAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD"
-        + "//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0o"
-        + "EAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAA"
-        + "A//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9"
-        + "KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAA"
-        + "AAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP/"
-        + "/SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQ"
-        + "AAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD"
-        + "//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0o"
-        + "EAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAA"
-        + "A//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9"
-        + "KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAA"
-        + "AAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP/"
-        + "/SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQ"
-        + "AAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD"
-        + "//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0o"
-        + "EAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAA"
-        + "A//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9"
-        + "KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAA"
-        + "AAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP/"
-        + "/SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQ"
-        + "AAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD"
-        + "//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0o"
-        + "EAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAA"
-        + "A//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9"
-        + "KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAA"
-        + "AAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP/"
-        + "/SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQ"
-        + "AAAD//0oEAAAA//8=";
-    headerBlockHasTrailingCompressedBytes(frame, 289);
-  }
-
-  private void headerBlockHasTrailingCompressedBytes(String frame, int length) throws IOException {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    byte[] trailingCompressedBytes = ByteString.decodeBase64(frame).toByteArray();
-    trailingCompressedBytes[11] = 1; // Set SPDY/3 stream ID to 3.
-    peer.sendFrame(trailingCompressedBytes);
-    peer.sendFrame().data(true, 1, new Buffer().writeUtf8("robot"), 5);
-    peer.acceptFrame(); // DATA
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    assertEquals("a", stream.getResponseHeaders().get(0).name.utf8());
-    assertEquals(length, stream.getResponseHeaders().get(0).value.size());
-    assertStreamData("robot", stream.getSource());
-  }
-
-  @Test public void socketExceptionWhileWritingHeaders() throws Exception {
-    peer.acceptFrame(); // SYN_STREAM.
-    peer.play();
-
-    String longString = ByteString.of(randomBytes(2048)).base64();
-    Socket socket = peer.openSocket();
-    FramedConnection connection = new FramedConnection.Builder(true)
-        .socket(socket)
-        .protocol(SPDY3.getProtocol())
-        .build();
-    connection.start(false);
-    socket.shutdownOutput();
-    try {
-      connection.newStream(headerEntries("a", longString), false, true);
-      fail();
-    } catch (IOException expected) {
-    }
-    try {
-      connection.newStream(headerEntries("b", longString), false, true);
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  private byte[] randomBytes(int length) {
-    byte[] bytes = new byte[length];
-    new Random(0).nextBytes(bytes);
-    return bytes;
-  }
-
-  private FramedConnection connection(MockSpdyPeer peer, Variant variant) throws IOException {
-    FramedConnection connection = connectionBuilder(peer, variant).build();
-    connection.start(false);
-    return connection;
-  }
-
-  private FramedConnection.Builder connectionBuilder(MockSpdyPeer peer, Variant variant)
-      throws IOException {
-    return new FramedConnection.Builder(true)
-        .socket(peer.openSocket())
-        .protocol(variant.getProtocol());
-  }
-
-  private void assertStreamData(String expected, Source source) throws IOException {
-    String actual = Okio.buffer(source).readUtf8();
-    assertEquals(expected, actual);
-  }
-
-  /** Interrupts the current thread after {@code delayMillis}. */
-  private void interruptAfterDelay(final long delayMillis) {
-    final Thread toInterrupt = Thread.currentThread();
-    new Thread("interrupting cow") {
-      @Override public void run() {
-        try {
-          Thread.sleep(delayMillis);
-          toInterrupt.interrupt();
-        } catch (InterruptedException e) {
-          throw new AssertionError();
-        }
-      }
-    }.start();
-  }
-
-  /**
-   * Returns true when all work currently in progress by the watchdog have completed. This method
-   * creates more work for the watchdog and waits for that work to be executed. When it is, we know
-   * work that preceded this call is complete.
-   */
-  private void awaitWatchdogIdle() throws InterruptedException {
-    final CountDownLatch latch = new CountDownLatch(1);
-    AsyncTimeout watchdogJob = new AsyncTimeout() {
-      @Override protected void timedOut() {
-        latch.countDown();
-      }
-    };
-    watchdogJob.deadlineNanoTime(System.nanoTime()); // Due immediately!
-    watchdogJob.enter();
-    latch.await();
-  }
-
-  static int roundUp(int num, int divisor) {
-    return (num + divisor - 1) / divisor;
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3Test.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3Test.java
deleted file mode 100644
index 953009ffc1..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3Test.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.framed;
-
-import java.io.IOException;
-import okhttp3.internal.Util;
-import okio.Buffer;
-import okio.ByteString;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-
-public class Spdy3Test {
-  static final int expectedStreamId = 15;
-
-  @Test public void tooLargeDataFrame() throws IOException {
-    try {
-      sendDataFrame(new Buffer().write(new byte[0x1000000]));
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals("FRAME_TOO_LARGE max size is 16Mib: " + 0x1000000L, e.getMessage());
-    }
-  }
-
-  @Test public void badWindowSizeIncrement() throws IOException {
-    try {
-      windowUpdate(0);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals("windowSizeIncrement must be between 1 and 0x7fffffff: 0", e.getMessage());
-    }
-    try {
-      windowUpdate(0x80000000L);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals("windowSizeIncrement must be between 1 and 0x7fffffff: 2147483648",
-          e.getMessage());
-    }
-  }
-
-  @Test public void goAwayRoundTrip() throws IOException {
-    Buffer frame = new Buffer();
-
-    final ErrorCode expectedError = ErrorCode.PROTOCOL_ERROR;
-
-    // Compose the expected GOAWAY frame without debug data
-    // |C| Version(15bits) | Type(16bits) |
-    frame.writeInt(0x80000000 | (Spdy3.VERSION & 0x7fff) << 16 | Spdy3.TYPE_GOAWAY & 0xffff);
-    // | Flags (8)  |  Length (24 bits)   |
-    frame.writeInt(8); // no flags and length is 8.
-    frame.writeInt(expectedStreamId); // last good stream.
-    frame.writeInt(expectedError.spdyGoAwayCode);
-
-    // Check writer sends the same bytes.
-    assertEquals(frame, sendGoAway(expectedStreamId, expectedError, Util.EMPTY_BYTE_ARRAY));
-
-    // SPDY/3 does not send debug data, so bytes should be same!
-    assertEquals(frame, sendGoAway(expectedStreamId, expectedError, new byte[8]));
-
-    FrameReader fr = new Spdy3.Reader(frame, false);
-
-    fr.nextFrame(new BaseTestHandler() { // Consume the goAway frame.
-      @Override public void goAway(
-          int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
-        assertEquals(expectedStreamId, lastGoodStreamId);
-        assertEquals(expectedError, errorCode);
-        assertEquals(0, debugData.size());
-      }
-    });
-  }
-
-  private void sendDataFrame(Buffer source) throws IOException {
-    Spdy3.Writer writer = new Spdy3.Writer(new Buffer(), true);
-    writer.sendDataFrame(expectedStreamId, 0, source, (int) source.size());
-  }
-
-  private void windowUpdate(long increment) throws IOException {
-    new Spdy3.Writer(new Buffer(), true).windowUpdate(expectedStreamId, increment);
-  }
-
-  private Buffer sendGoAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
-      throws IOException {
-    Buffer out = new Buffer();
-    new Spdy3.Writer(out, true).goAway(lastGoodStreamId, errorCode, debugData);
-    return out;
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/ExternalSpdyExample.java b/okhttp-tests/src/test/java/okhttp3/internal/http/ExternalSpdyExample.java
deleted file mode 100644
index c1598480ec..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/ExternalSpdyExample.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package okhttp3.internal.http;
-
-import okhttp3.Call;
-import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.Util;
-
-public final class ExternalSpdyExample {
-  public static void main(String[] args) throws Exception {
-    OkHttpClient client = new OkHttpClient.Builder()
-        .protocols(Util.immutableList(Protocol.SPDY_3, Protocol.HTTP_1_1))
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url("https://www.google.ca/")
-        .build());
-
-    Response response = call.execute();
-    try {
-      System.out.println(response.code());
-      System.out.println("PROTOCOL " + response.protocol());
-
-      String line;
-      while ((line = response.body().source().readUtf8Line()) != null) {
-        System.out.println(line);
-      }
-    } finally {
-      response.body().close();
-    }
-
-    client.connectionPool().evictAll();
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java b/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
index 5b4b630d32..33a51500e0 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
@@ -24,6 +24,7 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
+import okhttp3.internal.Util;
 
 import static org.junit.Assert.assertEquals;
 
@@ -45,7 +46,7 @@ public void assertRequests(URI... expectedUris) {
   @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
     InetSocketAddress socketAddress = (InetSocketAddress) sa;
     failures.add(
-        String.format("%s %s:%d %s", uri, socketAddress.getHostName(), socketAddress.getPort(),
+        Util.format("%s %s:%d %s", uri, socketAddress.getHostName(), socketAddress.getPort(),
             ioe.getMessage()));
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/BaseTestHandler.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/BaseTestHandler.java
similarity index 87%
rename from okhttp-tests/src/test/java/okhttp3/internal/framed/BaseTestHandler.java
rename to okhttp-tests/src/test/java/okhttp3/internal/http2/BaseTestHandler.java
index d619feff7c..b0b552b937 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/BaseTestHandler.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/BaseTestHandler.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.framed;
+package okhttp3.internal.http2;
 
 import java.io.IOException;
 import java.util.List;
@@ -22,15 +22,14 @@
 
 import static org.junit.Assert.fail;
 
-class BaseTestHandler implements FrameReader.Handler {
+class BaseTestHandler implements Http2Reader.Handler {
   @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
       throws IOException {
     fail();
   }
 
-  @Override
-  public void headers(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
-      List<Header> headerBlock, HeadersMode headersMode) {
+  @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,
+      List<Header> headerBlock) {
     fail();
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2FrameLoggerTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/FrameLogTest.java
similarity index 65%
rename from okhttp-tests/src/test/java/okhttp3/internal/framed/Http2FrameLoggerTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/http2/FrameLogTest.java
index 864a368774..94e5e83581 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2FrameLoggerTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/FrameLogTest.java
@@ -13,77 +13,75 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.framed;
+package okhttp3.internal.http2;
 
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 import org.junit.Test;
 
-import static okhttp3.internal.framed.Http2.FLAG_ACK;
-import static okhttp3.internal.framed.Http2.FLAG_END_HEADERS;
-import static okhttp3.internal.framed.Http2.FLAG_END_STREAM;
-import static okhttp3.internal.framed.Http2.FLAG_NONE;
-import static okhttp3.internal.framed.Http2.FrameLogger.formatFlags;
-import static okhttp3.internal.framed.Http2.FrameLogger.formatHeader;
-import static okhttp3.internal.framed.Http2.TYPE_CONTINUATION;
-import static okhttp3.internal.framed.Http2.TYPE_DATA;
-import static okhttp3.internal.framed.Http2.TYPE_GOAWAY;
-import static okhttp3.internal.framed.Http2.TYPE_HEADERS;
-import static okhttp3.internal.framed.Http2.TYPE_PING;
-import static okhttp3.internal.framed.Http2.TYPE_PUSH_PROMISE;
-import static okhttp3.internal.framed.Http2.TYPE_SETTINGS;
+import static okhttp3.internal.http2.Http2.FLAG_ACK;
+import static okhttp3.internal.http2.Http2.FLAG_END_HEADERS;
+import static okhttp3.internal.http2.Http2.FLAG_END_STREAM;
+import static okhttp3.internal.http2.Http2.FLAG_NONE;
+import static okhttp3.internal.http2.Http2.TYPE_CONTINUATION;
+import static okhttp3.internal.http2.Http2.TYPE_DATA;
+import static okhttp3.internal.http2.Http2.TYPE_GOAWAY;
+import static okhttp3.internal.http2.Http2.TYPE_HEADERS;
+import static okhttp3.internal.http2.Http2.TYPE_PING;
+import static okhttp3.internal.http2.Http2.TYPE_PUSH_PROMISE;
+import static okhttp3.internal.http2.Http2.TYPE_SETTINGS;
+import static okhttp3.internal.http2.Http2.frameLog;
 import static org.junit.Assert.assertEquals;
 
-public class Http2FrameLoggerTest {
-
+public final class FrameLogTest {
   /** Real stream traffic applied to the log format. */
   @Test public void exampleStream() {
     assertEquals(">> 0x00000000     5 SETTINGS      ",
-        formatHeader(false, 0, 5, TYPE_SETTINGS, FLAG_NONE));
+        frameLog(false, 0, 5, TYPE_SETTINGS, FLAG_NONE));
     assertEquals(">> 0x00000003   100 HEADERS       END_HEADERS",
-        formatHeader(false, 3, 100, TYPE_HEADERS, FLAG_END_HEADERS));
+        frameLog(false, 3, 100, TYPE_HEADERS, FLAG_END_HEADERS));
     assertEquals(">> 0x00000003     0 DATA          END_STREAM",
-        formatHeader(false, 3, 0, TYPE_DATA, FLAG_END_STREAM));
+        frameLog(false, 3, 0, TYPE_DATA, FLAG_END_STREAM));
     assertEquals("<< 0x00000000    15 SETTINGS      ",
-        formatHeader(true, 0, 15, TYPE_SETTINGS, FLAG_NONE));
+        frameLog(true, 0, 15, TYPE_SETTINGS, FLAG_NONE));
     assertEquals(">> 0x00000000     0 SETTINGS      ACK",
-        formatHeader(false, 0, 0, TYPE_SETTINGS, FLAG_ACK));
+        frameLog(false, 0, 0, TYPE_SETTINGS, FLAG_ACK));
     assertEquals("<< 0x00000000     0 SETTINGS      ACK",
-        formatHeader(true, 0, 0, TYPE_SETTINGS, FLAG_ACK));
+        frameLog(true, 0, 0, TYPE_SETTINGS, FLAG_ACK));
     assertEquals("<< 0x00000003    22 HEADERS       END_HEADERS",
-        formatHeader(true, 3, 22, TYPE_HEADERS, FLAG_END_HEADERS));
+        frameLog(true, 3, 22, TYPE_HEADERS, FLAG_END_HEADERS));
     assertEquals("<< 0x00000003   226 DATA          END_STREAM",
-        formatHeader(true, 3, 226, TYPE_DATA, FLAG_END_STREAM));
+        frameLog(true, 3, 226, TYPE_DATA, FLAG_END_STREAM));
     assertEquals(">> 0x00000000     8 GOAWAY        ",
-        formatHeader(false, 0, 8, TYPE_GOAWAY, FLAG_NONE));
+        frameLog(false, 0, 8, TYPE_GOAWAY, FLAG_NONE));
   }
 
   @Test public void flagOverlapOn0x1() {
     assertEquals("<< 0x00000000     0 SETTINGS      ACK",
-        formatHeader(true, 0, 0, TYPE_SETTINGS, (byte) 0x1));
+        frameLog(true, 0, 0, TYPE_SETTINGS, (byte) 0x1));
     assertEquals("<< 0x00000000     8 PING          ACK",
-        formatHeader(true, 0, 8, TYPE_PING, (byte) 0x1));
+        frameLog(true, 0, 8, TYPE_PING, (byte) 0x1));
     assertEquals("<< 0x00000003     0 HEADERS       END_STREAM",
-        formatHeader(true, 3, 0, TYPE_HEADERS, (byte) 0x1));
+        frameLog(true, 3, 0, TYPE_HEADERS, (byte) 0x1));
     assertEquals("<< 0x00000003     0 DATA          END_STREAM",
-        formatHeader(true, 3, 0, TYPE_DATA, (byte) 0x1));
+        frameLog(true, 3, 0, TYPE_DATA, (byte) 0x1));
   }
 
   @Test public void flagOverlapOn0x4() {
     assertEquals("<< 0x00000003 10000 HEADERS       END_HEADERS",
-        formatHeader(true, 3, 10000, TYPE_HEADERS, (byte) 0x4));
+        frameLog(true, 3, 10000, TYPE_HEADERS, (byte) 0x4));
     assertEquals("<< 0x00000003 10000 CONTINUATION  END_HEADERS",
-        formatHeader(true, 3, 10000, TYPE_CONTINUATION, (byte) 0x4));
+        frameLog(true, 3, 10000, TYPE_CONTINUATION, (byte) 0x4));
     assertEquals("<< 0x00000004 10000 PUSH_PROMISE  END_PUSH_PROMISE",
-        formatHeader(true, 4, 10000, TYPE_PUSH_PROMISE, (byte) 0x4));
+        frameLog(true, 4, 10000, TYPE_PUSH_PROMISE, (byte) 0x4));
   }
 
   @Test public void flagOverlapOn0x20() {
     assertEquals("<< 0x00000003 10000 HEADERS       PRIORITY",
-        formatHeader(true, 3, 10000, TYPE_HEADERS, (byte) 0x20));
+        frameLog(true, 3, 10000, TYPE_HEADERS, (byte) 0x20));
     assertEquals("<< 0x00000003 10000 DATA          COMPRESSED",
-        formatHeader(true, 3, 10000, TYPE_DATA, (byte) 0x20));
+        frameLog(true, 3, 10000, TYPE_DATA, (byte) 0x20));
   }
 
   /**
@@ -92,7 +90,7 @@
    */
   @Test public void allFormattedFlagsWithValidBits() {
     List<String> formattedFlags = new ArrayList<>(0x40); // Highest valid flag is 0x20.
-    for (byte i = 0; i < 0x40; i++) formattedFlags.add(formatFlags(TYPE_HEADERS, i));
+    for (byte i = 0; i < 0x40; i++) formattedFlags.add(Http2.formatFlags(TYPE_HEADERS, i));
 
     assertEquals(Arrays.asList(
         "",
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/HpackTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/HpackTest.java
similarity index 63%
rename from okhttp-tests/src/test/java/okhttp3/internal/framed/HpackTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/http2/HpackTest.java
index 068ab647e7..6a90ac0458 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/HpackTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/HpackTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.framed;
+package okhttp3.internal.http2;
 
 import java.io.IOException;
 import java.util.Arrays;
@@ -28,8 +28,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
-public class HpackTest {
-
+public final class HpackTest {
   private final Buffer bytesIn = new Buffer();
   private Hpack.Reader hpackReader;
   private Buffer bytesOut = new Buffer();
@@ -37,7 +36,7 @@
 
   @Before public void reset() {
     hpackReader = newReader(bytesIn);
-    hpackWriter = new Hpack.Writer(bytesOut);
+    hpackWriter = new Hpack.Writer(4096, false, bytesOut);
   }
 
   /**
@@ -65,6 +64,7 @@
    * larger header content is not lost.
    */
   @Test public void tooLargeToHPackIsStillEmitted() throws IOException {
+    bytesIn.writeByte(0x21); // Dynamic table size update (size = 1).
     bytesIn.writeByte(0x00); // Literal indexed
     bytesIn.writeByte(0x0a); // Literal name (len = 10)
     bytesIn.writeUtf8("custom-key");
@@ -72,7 +72,6 @@
     bytesIn.writeByte(0x0d); // Literal value (len = 13)
     bytesIn.writeUtf8("custom-header");
 
-    hpackReader.headerTableSizeSetting(1);
     hpackReader.readHeaders();
 
     assertEquals(0, hpackReader.headerCount);
@@ -81,7 +80,13 @@
   }
 
   /** Oldest entries are evicted to support newer ones. */
-  @Test public void testEviction() throws IOException {
+  @Test public void writerEviction() throws IOException {
+    List<Header> headerBlock =
+        headerEntries(
+            "custom-foo", "custom-header",
+            "custom-bar", "custom-header",
+            "custom-baz", "custom-header");
+
     bytesIn.writeByte(0x40); // Literal indexed
     bytesIn.writeByte(0x0a); // Literal name (len = 10)
     bytesIn.writeUtf8("custom-foo");
@@ -104,33 +109,83 @@
     bytesIn.writeUtf8("custom-header");
 
     // Set to only support 110 bytes (enough for 2 headers).
-    hpackReader.headerTableSizeSetting(110);
-    hpackReader.readHeaders();
+    // Use a new Writer because we don't support change the dynamic table
+    // size after Writer constructed.
+    Hpack.Writer writer = new Hpack.Writer(110, false, bytesOut);
+    writer.writeHeaders(headerBlock);
 
-    assertEquals(2, hpackReader.headerCount);
+    assertEquals(bytesIn, bytesOut);
+    assertEquals(2, writer.headerCount);
 
-    Header entry = hpackReader.dynamicTable[headerTableLength() - 1];
+    int tableLength = writer.dynamicTable.length;
+    Header entry = writer.dynamicTable[tableLength - 1];
     checkEntry(entry, "custom-bar", "custom-header", 55);
 
-    entry = hpackReader.dynamicTable[headerTableLength() - 2];
+    entry = writer.dynamicTable[tableLength - 2];
     checkEntry(entry, "custom-baz", "custom-header", 55);
+  }
 
-    // Once a header field is decoded and added to the reconstructed header
-    // list, it cannot be removed from it. Hence, foo is here.
-    assertEquals(
+  @Test public void readerEviction() throws IOException {
+    List<Header> headerBlock =
         headerEntries(
             "custom-foo", "custom-header",
             "custom-bar", "custom-header",
-            "custom-baz", "custom-header"),
-        hpackReader.getAndResetHeaderList());
+            "custom-baz", "custom-header");
+
+    // Set to only support 110 bytes (enough for 2 headers).
+    bytesIn.writeByte(0x3F); // Dynamic table size update (size = 110).
+    bytesIn.writeByte(0x4F);
+
+    bytesIn.writeByte(0x40); // Literal indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-foo");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
+
+    bytesIn.writeByte(0x40); // Literal indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-bar");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
+
+    bytesIn.writeByte(0x40); // Literal indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-baz");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
+
+    hpackReader.readHeaders();
+
+    assertEquals(2, hpackReader.headerCount);
+
+    Header entry1 = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
+    checkEntry(entry1, "custom-bar", "custom-header", 55);
+
+    Header entry2 = hpackReader.dynamicTable[readerHeaderTableLength() - 2];
+    checkEntry(entry2, "custom-baz", "custom-header", 55);
+
+    // Once a header field is decoded and added to the reconstructed header
+    // list, it cannot be removed from it. Hence, foo is here.
+    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
 
-    // Simulate receiving a small settings frame, that implies eviction.
-    hpackReader.headerTableSizeSetting(55);
+    // Simulate receiving a small dynamic table size update, that implies eviction.
+    bytesIn.writeByte(0x3F); // Dynamic table size update (size = 55).
+    bytesIn.writeByte(0x18);
+    hpackReader.readHeaders();
     assertEquals(1, hpackReader.headerCount);
   }
 
   /** Header table backing array is initially 8 long, let's ensure it grows. */
   @Test public void dynamicallyGrowsBeyond64Entries() throws IOException {
+    // Lots of headers need more room!
+    hpackReader = new Hpack.Reader(16384, 4096, bytesIn);
+    bytesIn.writeByte(0x3F); // Dynamic table size update (size = 16384).
+    bytesIn.writeByte(0xE1);
+    bytesIn.writeByte(0x7F);
+
     for (int i = 0; i < 256; i++) {
       bytesIn.writeByte(0x40); // Literal indexed
       bytesIn.writeByte(0x0a); // Literal name (len = 10)
@@ -140,7 +195,6 @@
       bytesIn.writeUtf8("custom-header");
     }
 
-    hpackReader.headerTableSizeSetting(16384); // Lots of headers need more room!
     hpackReader.readHeaders();
 
     assertEquals(256, hpackReader.headerCount);
@@ -158,7 +212,7 @@
     assertEquals(1, hpackReader.headerCount);
     assertEquals(52, hpackReader.dynamicTableByteCount);
 
-    Header entry = hpackReader.dynamicTable[headerTableLength() - 1];
+    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
     checkEntry(entry, ":path", "www.example.com", 52);
   }
 
@@ -178,7 +232,7 @@
     assertEquals(1, hpackReader.headerCount);
     assertEquals(55, hpackReader.dynamicTableByteCount);
 
-    Header entry = hpackReader.dynamicTable[headerTableLength() - 1];
+    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
     checkEntry(entry, "custom-key", "custom-header", 55);
 
     assertEquals(headerEntries("custom-key", "custom-header"), hpackReader.getAndResetHeaderList());
@@ -215,9 +269,6 @@
     bytesIn.writeByte(0x0d); // Literal value (len = 13)
     bytesIn.writeUtf8("custom-header");
 
-    hpackWriter.writeHeaders(headerBlock);
-    assertEquals(bytesIn, bytesOut);
-
     hpackReader.readHeaders();
 
     assertEquals(0, hpackReader.headerCount);
@@ -239,6 +290,8 @@
   }
 
   @Test public void literalHeaderFieldNeverIndexedNewName() throws IOException {
+    List<Header> headerBlock = headerEntries("custom-key", "custom-header");
+
     bytesIn.writeByte(0x10); // Never indexed
     bytesIn.writeByte(0x0a); // Literal name (len = 10)
     bytesIn.writeUtf8("custom-key");
@@ -250,7 +303,76 @@
 
     assertEquals(0, hpackReader.headerCount);
 
-    assertEquals(headerEntries("custom-key", "custom-header"), hpackReader.getAndResetHeaderList());
+    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
+  }
+
+  @Test public void literalHeaderFieldWithIncrementalIndexingIndexedName() throws IOException {
+    List<Header> headerBlock = headerEntries(":path", "/sample/path");
+
+    bytesIn.writeByte(0x44); // Indexed name (idx = 4) -> :path
+    bytesIn.writeByte(0x0c); // Literal value (len = 12)
+    bytesIn.writeUtf8("/sample/path");
+
+    hpackReader.readHeaders();
+
+    assertEquals(1, hpackReader.headerCount);
+
+    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
+  }
+
+  @Test public void literalHeaderFieldWithIncrementalIndexingNewName() throws IOException {
+    List<Header> headerBlock = headerEntries("custom-key", "custom-header");
+
+    bytesIn.writeByte(0x40); // Never indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-key");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
+
+    hpackWriter.writeHeaders(headerBlock);
+    assertEquals(bytesIn, bytesOut);
+
+    assertEquals(1, hpackWriter.headerCount);
+
+    Header entry = hpackWriter.dynamicTable[hpackWriter.dynamicTable.length - 1];
+    checkEntry(entry, "custom-key", "custom-header", 55);
+
+    hpackReader.readHeaders();
+
+    assertEquals(1, hpackReader.headerCount);
+
+    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
+  }
+
+  @Test public void theSameHeaderAfterOneIncrementalIndexed() throws IOException {
+    List<Header> headerBlock =
+        headerEntries(
+            "custom-key", "custom-header",
+            "custom-key", "custom-header");
+
+    bytesIn.writeByte(0x40); // Never indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-key");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
+
+    bytesIn.writeByte(0xbe); // Indexed name and value (idx = 63)
+
+    hpackWriter.writeHeaders(headerBlock);
+    assertEquals(bytesIn, bytesOut);
+
+    assertEquals(1, hpackWriter.headerCount);
+
+    Header entry = hpackWriter.dynamicTable[hpackWriter.dynamicTable.length - 1];
+    checkEntry(entry, "custom-key", "custom-header", 55);
+
+    hpackReader.readHeaders();
+
+    assertEquals(1, hpackReader.headerCount);
+
+    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
   }
 
   @Test public void staticHeaderIsNotCopiedIntoTheIndexedTable() throws IOException {
@@ -262,7 +384,7 @@
     assertEquals(0, hpackReader.headerCount);
     assertEquals(0, hpackReader.dynamicTableByteCount);
 
-    assertEquals(null, hpackReader.dynamicTable[headerTableLength() - 1]);
+    assertEquals(null, hpackReader.dynamicTable[readerHeaderTableLength() - 1]);
 
     assertEquals(headerEntries(":method", "GET"), hpackReader.getAndResetHeaderList());
   }
@@ -350,10 +472,10 @@
    * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#appendix-C.2.4
    */
   @Test public void readIndexedHeaderFieldFromStaticTableWithoutBuffering() throws IOException {
+    bytesIn.writeByte(0x20); // Dynamic table size update (size = 0).
     bytesIn.writeByte(0x82); // == Indexed - Add ==
                              // idx = 2 -> :method: GET
 
-    hpackReader.headerTableSizeSetting(0); // SETTINGS_HEADER_TABLE_SIZE == 0
     hpackReader.readHeaders();
 
     // Not buffered in header table.
@@ -396,7 +518,7 @@ private void checkReadFirstRequestWithoutHuffman() {
     assertEquals(1, hpackReader.headerCount);
 
     // [  1] (s =  57) :authority: www.example.com
-    Header entry = hpackReader.dynamicTable[headerTableLength() - 1];
+    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
     checkEntry(entry, ":authority", "www.example.com", 57);
 
     // Table size: 57
@@ -429,11 +551,11 @@ private void checkReadSecondRequestWithoutHuffman() {
     assertEquals(2, hpackReader.headerCount);
 
     // [  1] (s =  53) cache-control: no-cache
-    Header entry = hpackReader.dynamicTable[headerTableLength() - 2];
+    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 2];
     checkEntry(entry, "cache-control", "no-cache", 53);
 
     // [  2] (s =  57) :authority: www.example.com
-    entry = hpackReader.dynamicTable[headerTableLength() - 1];
+    entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
     checkEntry(entry, ":authority", "www.example.com", 57);
 
     // Table size: 110
@@ -468,15 +590,15 @@ private void checkReadThirdRequestWithoutHuffman() {
     assertEquals(3, hpackReader.headerCount);
 
     // [  1] (s =  54) custom-key: custom-value
-    Header entry = hpackReader.dynamicTable[headerTableLength() - 3];
+    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 3];
     checkEntry(entry, "custom-key", "custom-value", 54);
 
     // [  2] (s =  53) cache-control: no-cache
-    entry = hpackReader.dynamicTable[headerTableLength() - 2];
+    entry = hpackReader.dynamicTable[readerHeaderTableLength() - 2];
     checkEntry(entry, "cache-control", "no-cache", 53);
 
     // [  3] (s =  57) :authority: www.example.com
-    entry = hpackReader.dynamicTable[headerTableLength() - 1];
+    entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
     checkEntry(entry, ":authority", "www.example.com", 57);
 
     // Table size: 164
@@ -526,7 +648,7 @@ private void checkReadFirstRequestWithHuffman() {
     assertEquals(1, hpackReader.headerCount);
 
     // [  1] (s =  57) :authority: www.example.com
-    Header entry = hpackReader.dynamicTable[headerTableLength() - 1];
+    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
     checkEntry(entry, ":authority", "www.example.com", 57);
 
     // Table size: 57
@@ -560,11 +682,11 @@ private void checkReadSecondRequestWithHuffman() {
     assertEquals(2, hpackReader.headerCount);
 
     // [  1] (s =  53) cache-control: no-cache
-    Header entry = hpackReader.dynamicTable[headerTableLength() - 2];
+    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 2];
     checkEntry(entry, "cache-control", "no-cache", 53);
 
     // [  2] (s =  57) :authority: www.example.com
-    entry = hpackReader.dynamicTable[headerTableLength() - 1];
+    entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
     checkEntry(entry, ":authority", "www.example.com", 57);
 
     // Table size: 110
@@ -601,15 +723,15 @@ private void checkReadThirdRequestWithHuffman() {
     assertEquals(3, hpackReader.headerCount);
 
     // [  1] (s =  54) custom-key: custom-value
-    Header entry = hpackReader.dynamicTable[headerTableLength() - 3];
+    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 3];
     checkEntry(entry, "custom-key", "custom-value", 54);
 
     // [  2] (s =  53) cache-control: no-cache
-    entry = hpackReader.dynamicTable[headerTableLength() - 2];
+    entry = hpackReader.dynamicTable[readerHeaderTableLength() - 2];
     checkEntry(entry, "cache-control", "no-cache", 53);
 
     // [  3] (s =  57) :authority: www.example.com
-    entry = hpackReader.dynamicTable[headerTableLength() - 1];
+    entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
     checkEntry(entry, ":authority", "www.example.com", 57);
 
     // Table size: 164
@@ -674,7 +796,7 @@ private void checkReadThirdRequestWithHuffman() {
 
   @Test public void lowercaseHeaderNameBeforeEmit() throws IOException {
     hpackWriter.writeHeaders(Arrays.asList(new Header("FoO", "BaR")));
-    assertBytes(0, 3, 'f', 'o', 'o', 3, 'B', 'a', 'R');
+    assertBytes(0x40, 3, 'f', 'o', 'o', 3, 'B', 'a', 'R');
   }
 
   @Test public void mixedCaseHeaderNameIsMalformed() throws IOException {
@@ -692,6 +814,208 @@ private void checkReadThirdRequestWithHuffman() {
     assertEquals(ByteString.EMPTY, newReader(byteStream(0)).readByteString());
   }
 
+  @Test public void emitsDynamicTableSizeUpdate() throws IOException {
+    hpackWriter.setHeaderTableSizeSetting(2048);
+    hpackWriter.writeHeaders(Arrays.asList(new Header("foo", "bar")));
+    assertBytes(
+        0x3F, 0xE1, 0xF, // Dynamic table size update (size = 2048).
+        0x40, 3, 'f', 'o', 'o', 3, 'b', 'a', 'r');
+
+    hpackWriter.setHeaderTableSizeSetting(8192);
+    hpackWriter.writeHeaders(Arrays.asList(new Header("bar", "foo")));
+    assertBytes(
+        0x3F, 0xE1, 0x3F, // Dynamic table size update (size = 8192).
+        0x40, 3, 'b', 'a', 'r', 3, 'f', 'o', 'o');
+
+    // No more dynamic table updates should be emitted.
+    hpackWriter.writeHeaders(Arrays.asList(new Header("far", "boo")));
+    assertBytes(0x40, 3, 'f', 'a', 'r', 3, 'b', 'o', 'o');
+  }
+
+  @Test public void noDynamicTableSizeUpdateWhenSizeIsEqual() throws IOException {
+    int currentSize = hpackWriter.headerTableSizeSetting;
+    hpackWriter.setHeaderTableSizeSetting(currentSize);
+    hpackWriter.writeHeaders(Arrays.asList(new Header("foo", "bar")));
+
+    assertBytes(0x40, 3, 'f', 'o', 'o', 3, 'b', 'a', 'r');
+  }
+
+  @Test public void growDynamicTableSize() throws IOException {
+    hpackWriter.setHeaderTableSizeSetting(8192);
+    hpackWriter.setHeaderTableSizeSetting(16384);
+    hpackWriter.writeHeaders(Arrays.asList(new Header("foo", "bar")));
+
+    assertBytes(
+        0x3F, 0xE1, 0x7F, // Dynamic table size update (size = 16384).
+        0x40, 3, 'f', 'o', 'o', 3, 'b', 'a', 'r');
+  }
+
+  @Test public void shrinkDynamicTableSize() throws IOException {
+    hpackWriter.setHeaderTableSizeSetting(2048);
+    hpackWriter.setHeaderTableSizeSetting(0);
+    hpackWriter.writeHeaders(Arrays.asList(new Header("foo", "bar")));
+
+    assertBytes(
+        0x20, // Dynamic size update (size = 0).
+        0x40, 3, 'f', 'o', 'o', 3, 'b', 'a', 'r');
+  }
+
+  @Test public void manyDynamicTableSizeChanges() throws IOException {
+    hpackWriter.setHeaderTableSizeSetting(16384);
+    hpackWriter.setHeaderTableSizeSetting(8096);
+    hpackWriter.setHeaderTableSizeSetting(0);
+    hpackWriter.setHeaderTableSizeSetting(4096);
+    hpackWriter.setHeaderTableSizeSetting(2048);
+    hpackWriter.writeHeaders(Arrays.asList(new Header("foo", "bar")));
+
+    assertBytes(
+        0x20, // Dynamic size update (size = 0).
+        0x3F, 0xE1, 0xF, // Dynamic size update (size = 2048).
+        0x40, 3, 'f', 'o', 'o', 3, 'b', 'a', 'r');
+  }
+
+  @Test public void dynamicTableEvictionWhenSizeLowered() throws IOException {
+    List<Header> headerBlock =
+        headerEntries(
+            "custom-key1", "custom-header",
+            "custom-key2", "custom-header");
+    hpackWriter.writeHeaders(headerBlock);
+    assertEquals(2, hpackWriter.headerCount);
+
+    hpackWriter.setHeaderTableSizeSetting(56);
+    assertEquals(1, hpackWriter.headerCount);
+
+    hpackWriter.setHeaderTableSizeSetting(0);
+    assertEquals(0, hpackWriter.headerCount);
+  }
+
+  @Test public void noEvictionOnDynamicTableSizeIncrease() throws IOException {
+    List<Header> headerBlock =
+        headerEntries(
+            "custom-key1", "custom-header",
+            "custom-key2", "custom-header");
+    hpackWriter.writeHeaders(headerBlock);
+    assertEquals(2, hpackWriter.headerCount);
+
+    hpackWriter.setHeaderTableSizeSetting(8192);
+    assertEquals(2, hpackWriter.headerCount);
+  }
+
+  @Test public void dynamicTableSizeHasAnUpperBound() {
+    hpackWriter.setHeaderTableSizeSetting(1048576);
+    assertEquals(16384, hpackWriter.maxDynamicTableByteCount);
+  }
+
+  @Test public void huffmanEncode() throws IOException {
+    hpackWriter = new Hpack.Writer(4096, true, bytesOut);
+    hpackWriter.writeHeaders(headerEntries("foo", "bar"));
+
+    ByteString expected = new Buffer()
+        .writeByte(0x40) // Literal header, new name.
+        .writeByte(0x82) // String literal is Huffman encoded (len = 2).
+        .writeByte(0x94) // 'foo' Huffman encoded.
+        .writeByte(0xE7)
+        .writeByte(3) // String literal not Huffman encoded (len = 3).
+        .writeByte('b')
+        .writeByte('a')
+        .writeByte('r')
+        .readByteString();
+
+    ByteString actual = bytesOut.readByteString();
+    assertEquals(expected, actual);
+  }
+
+  @Test public void staticTableIndexedHeaders() throws IOException {
+    hpackWriter.writeHeaders(headerEntries(":method", "GET"));
+    assertBytes(0x82);
+    assertEquals(0, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries(":method", "POST"));
+    assertBytes(0x83);
+    assertEquals(0, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries(":path", "/"));
+    assertBytes(0x84);
+    assertEquals(0, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries(":path", "/index.html"));
+    assertBytes(0x85);
+    assertEquals(0, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries(":scheme", "http"));
+    assertBytes(0x86);
+    assertEquals(0, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries(":scheme", "https"));
+    assertBytes(0x87);
+    assertEquals(0, hpackWriter.headerCount);
+  }
+
+  @Test public void dynamicTableIndexedHeader() throws IOException {
+    hpackWriter.writeHeaders(headerEntries("custom-key", "custom-header"));
+    assertBytes(0x40,
+        10, 'c', 'u', 's', 't', 'o', 'm', '-', 'k', 'e', 'y',
+        13, 'c', 'u', 's', 't', 'o', 'm', '-', 'h', 'e', 'a', 'd', 'e', 'r');
+    assertEquals(1, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries("custom-key", "custom-header"));
+    assertBytes(0xbe);
+    assertEquals(1, hpackWriter.headerCount);
+  }
+
+  @Test public void doNotIndexPseudoHeaders() throws IOException {
+    hpackWriter.writeHeaders(headerEntries(":method", "PUT"));
+    assertBytes(0x02, 3, 'P', 'U', 'T');
+    assertEquals(0, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries(":path", "/okhttp"));
+    assertBytes(0x04, 7, '/', 'o', 'k', 'h', 't', 't', 'p');
+    assertEquals(0, hpackWriter.headerCount);
+  }
+
+  @Test public void incrementalIndexingWithAuthorityPseudoHeader() throws IOException {
+    hpackWriter.writeHeaders(headerEntries(":authority", "foo.com"));
+    assertBytes(0x41, 7, 'f', 'o', 'o', '.', 'c', 'o', 'm');
+    assertEquals(1, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries(":authority", "foo.com"));
+    assertBytes(0xbe);
+    assertEquals(1, hpackWriter.headerCount);
+
+    // If the :authority header somehow changes, it should be re-added to the dynamic table.
+    hpackWriter.writeHeaders(headerEntries(":authority", "bar.com"));
+    assertBytes(0x41, 7, 'b', 'a', 'r', '.', 'c', 'o', 'm');
+    assertEquals(2, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries(":authority", "bar.com"));
+    assertBytes(0xbe);
+    assertEquals(2, hpackWriter.headerCount);
+  }
+
+  @Test public void incrementalIndexingWithStaticTableIndexedName() throws IOException {
+    hpackWriter.writeHeaders(headerEntries("accept-encoding", "gzip"));
+    assertBytes(0x50, 4, 'g', 'z', 'i', 'p');
+    assertEquals(1, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries("accept-encoding", "gzip"));
+    assertBytes(0xbe);
+    assertEquals(1, hpackWriter.headerCount);
+  }
+
+  @Test public void incrementalIndexingWithDynamcTableIndexedName() throws IOException {
+    hpackWriter.writeHeaders(headerEntries("foo", "bar"));
+    assertBytes(0x40, 3, 'f', 'o', 'o', 3, 'b', 'a', 'r');
+    assertEquals(1, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries("foo", "bar1"));
+    assertBytes(0x7e, 4, 'b', 'a', 'r', '1');
+    assertEquals(2, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries("foo", "bar1"));
+    assertBytes(0xbe);
+    assertEquals(2, hpackWriter.headerCount);
+  }
+
   private Hpack.Reader newReader(Buffer source) {
     return new Hpack.Reader(4096, source);
   }
@@ -720,7 +1044,7 @@ private ByteString intArrayToByteArray(int[] bytes) {
     return ByteString.of(data);
   }
 
-  private int headerTableLength() {
+  private int readerHeaderTableLength() {
     return hpackReader.dynamicTable.length;
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
new file mode 100644
index 0000000000..610e0898ec
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
@@ -0,0 +1,1595 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.net.Socket;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+import okhttp3.internal.Util;
+import okhttp3.internal.http2.MockHttp2Peer.InFrame;
+import okio.AsyncTimeout;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.Okio;
+import okio.Sink;
+import okio.Source;
+import org.junit.After;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import org.junit.rules.Timeout;
+
+import static okhttp3.TestUtil.headerEntries;
+import static okhttp3.TestUtil.repeat;
+import static okhttp3.internal.Util.EMPTY_BYTE_ARRAY;
+import static okhttp3.internal.http2.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
+import static okhttp3.internal.http2.Settings.ENABLE_PUSH;
+import static okhttp3.internal.http2.Settings.HEADER_TABLE_SIZE;
+import static okhttp3.internal.http2.Settings.INITIAL_WINDOW_SIZE;
+import static okhttp3.internal.http2.Settings.MAX_CONCURRENT_STREAMS;
+import static okhttp3.internal.http2.Settings.MAX_FRAME_SIZE;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class Http2ConnectionTest {
+  private final MockHttp2Peer peer = new MockHttp2Peer();
+
+  @Rule public final TestRule timeout = new Timeout(5_000);
+
+  @After public void tearDown() throws Exception {
+    peer.close();
+  }
+
+  @Test public void serverPingsClientHttp2() throws Exception {
+    // write the mocking script
+    peer.sendFrame().ping(false, 2, 3);
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    connection(peer);
+
+    // verify the peer received what was expected
+    InFrame ping = peer.takeFrame();
+    assertEquals(Http2.TYPE_PING, ping.type);
+    assertEquals(0, ping.streamId);
+    assertEquals(2, ping.payload1);
+    assertEquals(3, ping.payload2);
+    assertTrue(ping.ack);
+  }
+
+  @Test public void clientPingsServerHttp2() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 5);
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connection(peer);
+    Ping ping = connection.ping();
+    assertTrue(ping.roundTripTime() > 0);
+    assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
+
+    // verify the peer received what was expected
+    InFrame pingFrame = peer.takeFrame();
+    assertEquals(0, pingFrame.streamId);
+    assertEquals(1, pingFrame.payload1);
+    assertEquals(0x4f4b6f6b, pingFrame.payload2); // connection.ping() sets this.
+    assertFalse(pingFrame.ack);
+  }
+
+  @Test public void peerHttp2ServerLowersInitialWindowSize() throws Exception {
+    Settings initial = new Settings();
+    initial.set(INITIAL_WINDOW_SIZE, 1684);
+    Settings shouldntImpactConnection = new Settings();
+    shouldntImpactConnection.set(INITIAL_WINDOW_SIZE, 3368);
+
+    peer.sendFrame().settings(initial);
+    peer.acceptFrame(); // ACK
+    peer.sendFrame().settings(shouldntImpactConnection);
+    peer.acceptFrame(); // ACK 2
+    peer.acceptFrame(); // HEADERS
+    peer.play();
+
+    Http2Connection connection = connection(peer);
+
+    // Verify the peer received the ACK.
+    InFrame ackFrame = peer.takeFrame();
+    assertEquals(Http2.TYPE_SETTINGS, ackFrame.type);
+    assertEquals(0, ackFrame.streamId);
+    assertTrue(ackFrame.ack);
+    ackFrame = peer.takeFrame();
+    assertEquals(Http2.TYPE_SETTINGS, ackFrame.type);
+    assertEquals(0, ackFrame.streamId);
+    assertTrue(ackFrame.ack);
+
+    // This stream was created *after* the connection settings were adjusted.
+    Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
+
+    assertEquals(3368, connection.peerSettings.getInitialWindowSize());
+    assertEquals(1684, connection.bytesLeftInWriteWindow); // initial wasn't affected.
+    // New Stream is has the most recent initial window size.
+    assertEquals(3368, stream.bytesLeftInWriteWindow);
+  }
+
+  @Test public void peerHttp2ServerZerosCompressionTable() throws Exception {
+    boolean client = false; // Peer is server, so we are client.
+    Settings settings = new Settings();
+    settings.set(HEADER_TABLE_SIZE, 0);
+
+    Http2Connection connection = sendHttp2SettingsAndCheckForAck(client, settings);
+
+    // Verify the peer's settings were read and applied.
+    assertEquals(0, connection.peerSettings.getHeaderTableSize());
+    Http2Writer writer = connection.writer;
+    assertEquals(0, writer.hpackWriter.dynamicTableByteCount);
+    assertEquals(0, writer.hpackWriter.headerTableSizeSetting);
+  }
+
+  @Test public void peerHttp2ClientDisablesPush() throws Exception {
+    boolean client = false; // Peer is client, so we are server.
+    Settings settings = new Settings();
+    settings.set(ENABLE_PUSH, 0); // The peer client disables push.
+
+    Http2Connection connection = sendHttp2SettingsAndCheckForAck(client, settings);
+
+    // verify the peer's settings were read and applied.
+    assertFalse(connection.peerSettings.getEnablePush(true));
+  }
+
+  @Test public void peerIncreasesMaxFrameSize() throws Exception {
+    int newMaxFrameSize = 0x4001;
+    Settings settings = new Settings();
+    settings.set(MAX_FRAME_SIZE, newMaxFrameSize);
+
+    Http2Connection connection = sendHttp2SettingsAndCheckForAck(true, settings);
+
+    // verify the peer's settings were read and applied.
+    assertEquals(newMaxFrameSize, connection.peerSettings.getMaxFrameSize(-1));
+    assertEquals(newMaxFrameSize, connection.writer.maxDataLength());
+  }
+
+  /**
+   * Webservers may set the initial window size to zero, which is a special case because it means
+   * that we have to flush headers immediately before any request body can be sent.
+   * https://github.com/square/okhttp/issues/2543
+   */
+  @Test public void peerSetsZeroFlowControl() throws Exception {
+    peer.setClient(true);
+
+    // Write the mocking script.
+    peer.sendFrame().settings(new Settings().set(INITIAL_WINDOW_SIZE, 0));
+    peer.sendFrame().windowUpdate(0, 10); // Increase the connection window size.
+    peer.acceptFrame(); // PING or SETTINGS ACK
+    peer.acceptFrame(); // PING or SETTINGS ACK
+    peer.sendFrame().ping(true, 1, 0);
+    peer.acceptFrame(); // HEADERS STREAM 3
+    peer.sendFrame().windowUpdate(3, 5);
+    peer.acceptFrame(); // DATA STREAM 3 "abcde"
+    peer.sendFrame().windowUpdate(3, 5);
+    peer.acceptFrame(); // DATA STREAM 3 "fghi"
+    peer.play();
+
+    // Play it back.
+    Http2Connection connection = connection(peer);
+    connection.ping().roundTripTime(); // Ensure the SETTINGS have been received.
+    Http2Stream stream = connection.newStream(headerEntries("a", "android"), true);
+    BufferedSink sink = Okio.buffer(stream.getSink());
+    sink.writeUtf8("abcdefghi");
+    sink.flush();
+
+    // Verify the peer received what was expected.
+    peer.takeFrame(); // PING or SETTINGS ACK
+    peer.takeFrame(); // PING or SETTINGS ACK
+    InFrame headers = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, headers.type);
+    InFrame data1 = peer.takeFrame();
+    assertEquals(Http2.TYPE_DATA, data1.type);
+    assertEquals(3, data1.streamId);
+    assertTrue(Arrays.equals("abcde".getBytes("UTF-8"), data1.data));
+    InFrame data2 = peer.takeFrame();
+    assertEquals(Http2.TYPE_DATA, data2.type);
+    assertEquals(3, data2.streamId);
+    assertTrue(Arrays.equals("fghi".getBytes("UTF-8"), data2.data));
+  }
+
+  @Test public void receiveGoAwayHttp2() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM 3
+    peer.acceptFrame(); // SYN_STREAM 5
+    peer.sendFrame().goAway(3, ErrorCode.PROTOCOL_ERROR, EMPTY_BYTE_ARRAY);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
+    peer.acceptFrame(); // DATA STREAM 3
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connection(peer);
+    Http2Stream stream1 = connection.newStream(headerEntries("a", "android"), true);
+    Http2Stream stream2 = connection.newStream(headerEntries("b", "banana"), true);
+    connection.ping().roundTripTime(); // Ensure the GO_AWAY that resets stream2 has been received.
+    BufferedSink sink1 = Okio.buffer(stream1.getSink());
+    BufferedSink sink2 = Okio.buffer(stream2.getSink());
+    sink1.writeUtf8("abc");
+    try {
+      sink2.writeUtf8("abc");
+      sink2.flush();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream was reset: REFUSED_STREAM", expected.getMessage());
+    }
+    sink1.writeUtf8("def");
+    sink1.close();
+    try {
+      connection.newStream(headerEntries("c", "cola"), true);
+      fail();
+    } catch (IOException expected) {
+      assertEquals("shutdown", expected.getMessage());
+    }
+    assertTrue(stream1.isOpen());
+    assertFalse(stream2.isOpen());
+    assertEquals(1, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    InFrame synStream1 = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream1.type);
+    InFrame synStream2 = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream2.type);
+    InFrame ping = peer.takeFrame();
+    assertEquals(Http2.TYPE_PING, ping.type);
+    InFrame data1 = peer.takeFrame();
+    assertEquals(Http2.TYPE_DATA, data1.type);
+    assertEquals(3, data1.streamId);
+    assertTrue(Arrays.equals("abcdef".getBytes("UTF-8"), data1.data));
+  }
+
+  @Test public void readSendsWindowUpdateHttp2() throws Exception {
+    int windowSize = 100;
+    int windowUpdateThreshold = 50;
+
+    // Write the mocking script.
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    for (int i = 0; i < 3; i++) {
+      // Send frames of summing to size 50, which is windowUpdateThreshold.
+      peer.sendFrame().data(false, 3, data(24), 24);
+      peer.sendFrame().data(false, 3, data(25), 25);
+      peer.sendFrame().data(false, 3, data(1), 1);
+      peer.acceptFrame(); // connection WINDOW UPDATE
+      peer.acceptFrame(); // stream WINDOW UPDATE
+    }
+    peer.sendFrame().data(true, 3, data(0), 0);
+    peer.play();
+
+    // Play it back.
+    Http2Connection connection = connection(peer);
+    connection.okHttpSettings.set(INITIAL_WINDOW_SIZE, windowSize);
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
+    assertEquals(0, stream.unacknowledgedBytesRead);
+    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
+    Source in = stream.getSource();
+    Buffer buffer = new Buffer();
+    buffer.writeAll(in);
+    assertEquals(-1, in.read(buffer, 1));
+    assertEquals(150, buffer.size());
+
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    for (int i = 0; i < 3; i++) {
+      List<Integer> windowUpdateStreamIds = new ArrayList<>(2);
+      for (int j = 0; j < 2; j++) {
+        InFrame windowUpdate = peer.takeFrame();
+        assertEquals(Http2.TYPE_WINDOW_UPDATE, windowUpdate.type);
+        windowUpdateStreamIds.add(windowUpdate.streamId);
+        assertEquals(windowUpdateThreshold, windowUpdate.windowSizeIncrement);
+      }
+      assertTrue(windowUpdateStreamIds.contains(0)); // connection
+      assertTrue(windowUpdateStreamIds.contains(3)); // stream
+    }
+  }
+
+  @Test public void serverSendsEmptyDataClientDoesntSendWindowUpdateHttp2() throws Exception {
+    // Write the mocking script.
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().data(true, 3, data(0), 0);
+    peer.play();
+
+    // Play it back.
+    Http2Connection connection = connection(peer);
+    Http2Stream client = connection.newStream(headerEntries("b", "banana"), false);
+    assertEquals(-1, client.getSource().read(new Buffer(), 1));
+
+    // Verify the peer received what was expected.
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertEquals(3, peer.frameCount());
+  }
+
+  @Test public void clientSendsEmptyDataServerDoesntSendWindowUpdateHttp2() throws Exception {
+    // Write the mocking script.
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // DATA
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.play();
+
+    // Play it back.
+    Http2Connection connection = connection(peer);
+    Http2Stream client = connection.newStream(headerEntries("b", "banana"), true);
+    BufferedSink out = Okio.buffer(client.getSink());
+    out.write(EMPTY_BYTE_ARRAY);
+    out.flush();
+    out.close();
+
+    // Verify the peer received what was expected.
+    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_DATA, peer.takeFrame().type);
+    assertEquals(3, peer.frameCount());
+  }
+
+  @Test public void maxFrameSizeHonored() throws Exception {
+    byte[] buff = new byte[peer.maxOutboundDataLength() + 1];
+    Arrays.fill(buff, (byte) '*');
+
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.acceptFrame(); // DATA
+    peer.acceptFrame(); // DATA
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connection(peer);
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
+    BufferedSink out = Okio.buffer(stream.getSink());
+    out.write(buff);
+    out.flush();
+    out.close();
+
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    InFrame data = peer.takeFrame();
+    assertEquals(peer.maxOutboundDataLength(), data.data.length);
+    data = peer.takeFrame();
+    assertEquals(1, data.data.length);
+  }
+
+  @Test public void pushPromiseStream() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    final List<Header> expectedRequestHeaders = Arrays.asList(
+        new Header(Header.TARGET_METHOD, "GET"),
+        new Header(Header.TARGET_SCHEME, "https"),
+        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
+        new Header(Header.TARGET_PATH, "/cached")
+    );
+    peer.sendFrame().pushPromise(3, 2, expectedRequestHeaders);
+    final List<Header> expectedResponseHeaders = Arrays.asList(
+        new Header(Header.RESPONSE_STATUS, "200")
+    );
+    peer.sendFrame().synReply(true, 2, expectedResponseHeaders);
+    peer.sendFrame().data(true, 3, data(0), 0);
+    peer.play();
+
+    RecordingPushObserver observer = new RecordingPushObserver();
+
+    // play it back
+    Http2Connection connection = connectionBuilder(peer)
+        .pushObserver(observer)
+        .build();
+    connection.start(false);
+    Http2Stream client = connection.newStream(headerEntries("b", "banana"), false);
+    assertEquals(-1, client.getSource().read(new Buffer(), 1));
+
+    // verify the peer received what was expected
+    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
+
+    assertEquals(expectedRequestHeaders, observer.takeEvent());
+    assertEquals(expectedResponseHeaders, observer.takeEvent());
+  }
+
+  @Test public void doublePushPromise() throws Exception {
+    // write the mocking script
+    peer.sendFrame().pushPromise(3, 2, headerEntries("a", "android"));
+    peer.acceptFrame(); // SYN_REPLY
+    peer.sendFrame().pushPromise(3, 2, headerEntries("b", "banana"));
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connectionBuilder(peer).build();
+    connection.start(false);
+    connection.newStream(headerEntries("b", "banana"), false);
+
+    // verify the peer received what was expected
+    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(ErrorCode.PROTOCOL_ERROR, peer.takeFrame().errorCode);
+  }
+
+  @Test public void pushPromiseStreamsAutomaticallyCancel() throws Exception {
+    // write the mocking script
+    peer.sendFrame().pushPromise(3, 2, Arrays.asList(
+        new Header(Header.TARGET_METHOD, "GET"),
+        new Header(Header.TARGET_SCHEME, "https"),
+        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
+        new Header(Header.TARGET_PATH, "/cached")
+    ));
+    peer.sendFrame().synReply(true, 2, Arrays.asList(
+        new Header(Header.RESPONSE_STATUS, "200")
+    ));
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connectionBuilder(peer)
+        .pushObserver(PushObserver.CANCEL)
+        .build();
+    connection.start(false);
+
+    // verify the peer received what was expected
+    InFrame rstStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_RST_STREAM, rstStream.type);
+    assertEquals(2, rstStream.streamId);
+    assertEquals(ErrorCode.CANCEL, rstStream.errorCode);
+  }
+
+  /**
+   * When writing a set of headers fails due to an {@code IOException}, make sure the writer is left
+   * in a consistent state so the next writer also gets an {@code IOException} also instead of
+   * something worse (like an {@link IllegalStateException}.
+   *
+   * <p>See https://github.com/square/okhttp/issues/1651
+   */
+  @Test public void socketExceptionWhileWritingHeaders() throws Exception {
+    peer.acceptFrame(); // SYN_STREAM.
+    peer.play();
+
+    String longString = repeat('a', Http2.INITIAL_MAX_FRAME_SIZE + 1);
+    Socket socket = peer.openSocket();
+    Http2Connection connection = new Http2Connection.Builder(true)
+        .socket(socket)
+        .pushObserver(IGNORE)
+        .build();
+    connection.start(false);
+    socket.shutdownOutput();
+    try {
+      connection.newStream(headerEntries("a", longString), false);
+      fail();
+    } catch (IOException expected) {
+    }
+    try {
+      connection.newStream(headerEntries("b", longString), false);
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void clientCreatesStreamAndServerReplies() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // DATA
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().data(true, 3, new Buffer().writeUtf8("robot"), 5);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0); // PING
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connection(peer);
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
+    BufferedSink out = Okio.buffer(stream.getSink());
+    out.writeUtf8("c3po");
+    out.close();
+    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
+    assertStreamData("robot", stream.getSource());
+    connection.ping().roundTripTime();
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertFalse(synStream.outFinished);
+    assertEquals(3, synStream.streamId);
+    assertEquals(-1, synStream.associatedStreamId);
+    assertEquals(headerEntries("b", "banana"), synStream.headerBlock);
+    InFrame requestData = peer.takeFrame();
+    assertTrue(Arrays.equals("c3po".getBytes("UTF-8"), requestData.data));
+  }
+
+  @Test public void clientCreatesStreamAndServerRepliesWithFin() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // PING
+    peer.sendFrame().synReply(true, 3, headerEntries("a", "android"));
+    peer.sendFrame().ping(true, 1, 0);
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connection(peer);
+    connection.newStream(headerEntries("b", "banana"), false);
+    assertEquals(1, connection.openStreamCount());
+    connection.ping().roundTripTime(); // Ensure that the SYN_REPLY has been received.
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    InFrame ping = peer.takeFrame();
+    assertEquals(Http2.TYPE_PING, ping.type);
+  }
+
+  @Test public void serverPingsClient() throws Exception {
+    // write the mocking script
+    peer.sendFrame().ping(false, 2, 0);
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    connection(peer);
+
+    // verify the peer received what was expected
+    InFrame ping = peer.takeFrame();
+    assertEquals(0, ping.streamId);
+    assertEquals(2, ping.payload1);
+    assertEquals(0, ping.payload2);
+    assertTrue(ping.ack);
+  }
+
+  @Test public void clientPingsServer() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 5);
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connection(peer);
+    Ping ping = connection.ping();
+    assertTrue(ping.roundTripTime() > 0);
+    assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
+
+    // verify the peer received what was expected
+    InFrame pingFrame = peer.takeFrame();
+    assertEquals(Http2.TYPE_PING, pingFrame.type);
+    assertEquals(1, pingFrame.payload1);
+    assertEquals(new Buffer().writeUtf8("OKok").readInt(), pingFrame.payload2);
+    assertFalse(pingFrame.ack);
+  }
+
+  @Test public void unexpectedPingIsNotReturned() throws Exception {
+    // write the mocking script
+    peer.sendFrame().ping(false, 2, 0);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 3, 0); // This ping will not be returned.
+    peer.sendFrame().ping(false, 4, 0);
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    connection(peer);
+
+    // verify the peer received what was expected
+    InFrame ping2 = peer.takeFrame();
+    assertEquals(2, ping2.payload1);
+    InFrame ping4 = peer.takeFrame();
+    assertEquals(4, ping4.payload1);
+  }
+
+  @Test public void serverSendsSettingsToClient() throws Exception {
+    // write the mocking script
+    final Settings settings = new Settings();
+    settings.set(MAX_CONCURRENT_STREAMS, 10);
+    peer.sendFrame().settings(settings);
+    peer.sendFrame().ping(false, 2, 0);
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    final CountDownLatch maxConcurrentStreamsUpdated = new CountDownLatch(1);
+    final AtomicInteger maxConcurrentStreams = new AtomicInteger();
+    Http2Connection.Listener listener = new Http2Connection.Listener() {
+      @Override public void onStream(Http2Stream stream) throws IOException {
+        throw new AssertionError();
+      }
+
+      @Override public void onSettings(Http2Connection connection) {
+        maxConcurrentStreams.set(connection.maxConcurrentStreams());
+        maxConcurrentStreamsUpdated.countDown();
+      }
+    };
+    Http2Connection connection = connectionBuilder(peer)
+        .listener(listener)
+        .build();
+    connection.start(false);
+
+    peer.takeFrame(); // Guarantees that the peer Settings frame has been processed.
+    synchronized (connection) {
+      assertEquals(10, connection.peerSettings.getMaxConcurrentStreams(-1));
+    }
+    maxConcurrentStreamsUpdated.await();
+    assertEquals(10, maxConcurrentStreams.get());
+  }
+
+  @Test public void multipleSettingsFramesAreMerged() throws Exception {
+    // write the mocking script
+    Settings settings1 = new Settings();
+    settings1.set(HEADER_TABLE_SIZE, 10000);
+    settings1.set(INITIAL_WINDOW_SIZE, 20000);
+    settings1.set(MAX_FRAME_SIZE, 30000);
+    peer.sendFrame().settings(settings1);
+    peer.acceptFrame(); // ACK SETTINGS
+    Settings settings2 = new Settings();
+    settings2.set(INITIAL_WINDOW_SIZE, 40000);
+    settings2.set(MAX_FRAME_SIZE, 50000);
+    settings2.set(MAX_CONCURRENT_STREAMS, 60000);
+    peer.sendFrame().settings(settings2);
+    peer.acceptFrame(); // ACK SETTINGS
+    peer.sendFrame().ping(false, 2, 0);
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connection(peer);
+
+    assertEquals(Http2.TYPE_SETTINGS, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_SETTINGS, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_PING, peer.takeFrame().type);
+    synchronized (connection) {
+      assertEquals(10000, connection.peerSettings.getHeaderTableSize());
+      assertEquals(40000, connection.peerSettings.getInitialWindowSize());
+      assertEquals(50000, connection.peerSettings.getMaxFrameSize(-1));
+      assertEquals(60000, connection.peerSettings.getMaxConcurrentStreams(-1));
+    }
+  }
+
+  @Test public void clearSettingsBeforeMerge() throws Exception {
+    // write the mocking script
+    Settings settings1 = new Settings();
+    settings1.set(HEADER_TABLE_SIZE, 10000);
+    settings1.set(INITIAL_WINDOW_SIZE, 20000);
+    settings1.set(MAX_FRAME_SIZE, 30000);
+    peer.sendFrame().settings(settings1);
+    peer.sendFrame().ping(false, 2, 0);
+    peer.acceptFrame();
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connection(peer);
+
+    peer.takeFrame(); // Guarantees that the Settings frame has been processed.
+
+    // fake a settings frame with clear flag set.
+    Settings settings2 = new Settings();
+    settings2.set(MAX_CONCURRENT_STREAMS, 60000);
+    connection.readerRunnable.settings(true, settings2);
+
+    synchronized (connection) {
+      assertEquals(-1, connection.peerSettings.getHeaderTableSize());
+      assertEquals(DEFAULT_INITIAL_WINDOW_SIZE, connection.peerSettings.getInitialWindowSize());
+      assertEquals(-1, connection.peerSettings.getMaxFrameSize(-1));
+      assertEquals(60000, connection.peerSettings.getMaxConcurrentStreams(-1));
+    }
+  }
+
+  @Test public void bogusDataFrameDoesNotDisruptConnection() throws Exception {
+    // write the mocking script
+    peer.sendFrame().data(true, 41, new Buffer().writeUtf8("bogus"), 5);
+    peer.acceptFrame(); // RST_STREAM
+    peer.sendFrame().ping(false, 2, 0);
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    connection(peer);
+
+    // verify the peer received what was expected
+    InFrame rstStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_RST_STREAM, rstStream.type);
+    assertEquals(41, rstStream.streamId);
+    assertEquals(ErrorCode.PROTOCOL_ERROR, rstStream.errorCode);
+    InFrame ping = peer.takeFrame();
+    assertEquals(2, ping.payload1);
+  }
+
+  @Test public void bogusReplySilentlyIgnored() throws Exception {
+    // write the mocking script
+    peer.sendFrame().synReply(false, 41, headerEntries("a", "android"));
+    peer.sendFrame().ping(false, 2, 0);
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    connection(peer);
+
+    // verify the peer received what was expected
+    InFrame ping = peer.takeFrame();
+    assertEquals(2, ping.payload1);
+  }
+
+  @Test public void serverClosesClientOutputStream() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().rstStream(3, ErrorCode.CANCEL);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connection(peer);
+    Http2Stream stream = connection.newStream(headerEntries("a", "android"), true);
+    BufferedSink out = Okio.buffer(stream.getSink());
+    connection.ping().roundTripTime(); // Ensure that the RST_CANCEL has been received.
+    try {
+      out.writeUtf8("square");
+      out.flush();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream was reset: CANCEL", expected.getMessage());
+    }
+    try {
+      out.close();
+      fail();
+    } catch (IOException expected) {
+      // Close throws because buffered data wasn't flushed.
+    }
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertFalse(synStream.inFinished);
+    assertFalse(synStream.outFinished);
+    InFrame ping = peer.takeFrame();
+    assertEquals(Http2.TYPE_PING, ping.type);
+    assertEquals(1, ping.payload1);
+  }
+
+  /**
+   * Test that the client sends a RST_STREAM if doing so won't disrupt the output stream.
+   */
+  @Test public void clientClosesClientInputStream() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connection(peer);
+    Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
+    Source in = stream.getSource();
+    BufferedSink out = Okio.buffer(stream.getSink());
+    in.close();
+    try {
+      in.read(new Buffer(), 1);
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream closed", expected.getMessage());
+    }
+    try {
+      out.writeUtf8("a");
+      out.flush();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream finished", expected.getMessage());
+    }
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertTrue(synStream.inFinished);
+    assertFalse(synStream.outFinished);
+    InFrame rstStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_RST_STREAM, rstStream.type);
+    assertEquals(ErrorCode.CANCEL, rstStream.errorCode);
+  }
+
+  /**
+   * Test that the client doesn't send a RST_STREAM if doing so will disrupt the output stream.
+   */
+  @Test public void clientClosesClientInputStreamIfOutputStreamIsClosed() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // DATA
+    peer.acceptFrame(); // DATA with FLAG_FIN
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connection(peer);
+    Http2Stream stream = connection.newStream(headerEntries("a", "android"), true);
+    Source source = stream.getSource();
+    BufferedSink out = Okio.buffer(stream.getSink());
+    source.close();
+    try {
+      source.read(new Buffer(), 1);
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream closed", expected.getMessage());
+    }
+    out.writeUtf8("square");
+    out.flush();
+    out.close();
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertFalse(synStream.inFinished);
+    assertFalse(synStream.outFinished);
+    InFrame data = peer.takeFrame();
+    assertEquals(Http2.TYPE_DATA, data.type);
+    assertTrue(Arrays.equals("square".getBytes("UTF-8"), data.data));
+    InFrame fin = peer.takeFrame();
+    assertEquals(Http2.TYPE_DATA, fin.type);
+    assertTrue(fin.inFinished);
+    assertFalse(fin.outFinished);
+    InFrame rstStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_RST_STREAM, rstStream.type);
+    assertEquals(ErrorCode.CANCEL, rstStream.errorCode);
+  }
+
+  @Test public void serverClosesClientInputStream() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("b", "banana"));
+    peer.sendFrame().data(true, 3, new Buffer().writeUtf8("square"), 6);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connection(peer);
+    Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
+    Source source = stream.getSource();
+    assertStreamData("square", source);
+    connection.ping().roundTripTime(); // Ensure that inFinished has been received.
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertTrue(synStream.inFinished);
+    assertFalse(synStream.outFinished);
+  }
+
+  @Test public void remoteDoubleSynReply() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.acceptFrame(); // PING
+    peer.sendFrame().synReply(false, 3, headerEntries("b", "banana"));
+    peer.sendFrame().ping(true, 1, 0);
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connection(peer);
+    Http2Stream stream = connection.newStream(headerEntries("c", "cola"), false);
+    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
+    connection.ping().roundTripTime(); // Ensure that the 2nd SYN REPLY has been received.
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    InFrame ping = peer.takeFrame();
+    assertEquals(Http2.TYPE_PING, ping.type);
+  }
+
+  @Test public void remoteSendsDataAfterInFinished() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().data(true, 3, new Buffer().writeUtf8("robot"), 5);
+    peer.sendFrame().data(true, 3, new Buffer().writeUtf8("c3po"), 4);
+    peer.acceptFrame(); // RST_STREAM
+    peer.sendFrame().ping(false, 2, 0); // Ping just to make sure the stream was fastforwarded.
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connection(peer);
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
+    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
+    assertStreamData("robot", stream.getSource());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    InFrame rstStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_RST_STREAM, rstStream.type);
+    assertEquals(3, rstStream.streamId);
+    InFrame ping = peer.takeFrame();
+    assertEquals(Http2.TYPE_PING, ping.type);
+    assertEquals(2, ping.payload1);
+  }
+
+  @Test public void clientDoesNotLimitFlowControl() throws Exception {
+    int dataLength = 16384;
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("b", "banana"));
+    peer.sendFrame().data(false, 3, new Buffer().write(new byte[dataLength]), dataLength);
+    peer.sendFrame().data(false, 3, new Buffer().write(new byte[dataLength]), dataLength);
+    peer.sendFrame().data(false, 3, new Buffer().write(new byte[dataLength]), dataLength);
+    peer.sendFrame().data(false, 3, new Buffer().write(new byte[dataLength]), dataLength);
+    peer.sendFrame().data(false, 3, new Buffer().write(new byte[1]), 1);
+    peer.sendFrame().ping(false, 2, 0); // Ping just to make sure the stream was fastforwarded.
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connection(peer);
+    Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
+    assertEquals(headerEntries("b", "banana"), stream.getResponseHeaders());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    InFrame ping = peer.takeFrame();
+    assertEquals(Http2.TYPE_PING, ping.type);
+    assertEquals(2, ping.payload1);
+  }
+
+  @Test public void remoteSendsRefusedStreamBeforeReplyHeaders() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().rstStream(3, ErrorCode.REFUSED_STREAM);
+    peer.sendFrame().ping(false, 2, 0);
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connection(peer);
+    Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
+    try {
+      stream.getResponseHeaders();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream was reset: REFUSED_STREAM", expected.getMessage());
+    }
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    InFrame ping = peer.takeFrame();
+    assertEquals(Http2.TYPE_PING, ping.type);
+    assertEquals(2, ping.payload1);
+  }
+
+  @Test public void receiveGoAway() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM 1
+    peer.acceptFrame(); // SYN_STREAM 3
+    peer.acceptFrame(); // PING.
+    peer.sendFrame().goAway(3, ErrorCode.PROTOCOL_ERROR, Util.EMPTY_BYTE_ARRAY);
+    peer.sendFrame().ping(true, 1, 0);
+    peer.acceptFrame(); // DATA STREAM 1
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connection(peer);
+    Http2Stream stream1 = connection.newStream(headerEntries("a", "android"), true);
+    Http2Stream stream2 = connection.newStream(headerEntries("b", "banana"), true);
+    connection.ping().roundTripTime(); // Ensure the GO_AWAY that resets stream2 has been received.
+    BufferedSink sink1 = Okio.buffer(stream1.getSink());
+    BufferedSink sink2 = Okio.buffer(stream2.getSink());
+    sink1.writeUtf8("abc");
+    try {
+      sink2.writeUtf8("abc");
+      sink2.flush();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream was reset: REFUSED_STREAM", expected.getMessage());
+    }
+    sink1.writeUtf8("def");
+    sink1.close();
+    try {
+      connection.newStream(headerEntries("c", "cola"), false);
+      fail();
+    } catch (IOException expected) {
+      assertEquals("shutdown", expected.getMessage());
+    }
+    assertTrue(stream1.isOpen());
+    assertFalse(stream2.isOpen());
+    assertEquals(1, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    InFrame synStream1 = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream1.type);
+    InFrame synStream2 = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream2.type);
+    InFrame ping = peer.takeFrame();
+    assertEquals(Http2.TYPE_PING, ping.type);
+    InFrame data1 = peer.takeFrame();
+    assertEquals(Http2.TYPE_DATA, data1.type);
+    assertEquals(3, data1.streamId);
+    assertTrue(Arrays.equals("abcdef".getBytes("UTF-8"), data1.data));
+  }
+
+  @Test public void sendGoAway() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM 1
+    peer.acceptFrame(); // GOAWAY
+    peer.acceptFrame(); // PING
+    peer.sendFrame().synStream(false, 2, 0, headerEntries("b", "b")); // Should be ignored!
+    peer.sendFrame().ping(true, 1, 0);
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connection(peer);
+    connection.newStream(headerEntries("a", "android"), false);
+    Ping ping = connection.ping();
+    connection.shutdown(ErrorCode.PROTOCOL_ERROR);
+    assertEquals(1, connection.openStreamCount());
+    ping.roundTripTime(); // Prevent the peer from exiting prematurely.
+
+    // verify the peer received what was expected
+    InFrame synStream1 = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream1.type);
+    InFrame pingFrame = peer.takeFrame();
+    assertEquals(Http2.TYPE_PING, pingFrame.type);
+    InFrame goaway = peer.takeFrame();
+    assertEquals(Http2.TYPE_GOAWAY, goaway.type);
+    assertEquals(0, goaway.streamId);
+    assertEquals(ErrorCode.PROTOCOL_ERROR, goaway.errorCode);
+  }
+
+  @Test public void noPingsAfterShutdown() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // GOAWAY
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connection(peer);
+    connection.shutdown(ErrorCode.INTERNAL_ERROR);
+    try {
+      connection.ping();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("shutdown", expected.getMessage());
+    }
+
+    // verify the peer received what was expected
+    InFrame goaway = peer.takeFrame();
+    assertEquals(Http2.TYPE_GOAWAY, goaway.type);
+    assertEquals(ErrorCode.INTERNAL_ERROR, goaway.errorCode);
+  }
+
+  @Test public void close() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // GOAWAY
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connection(peer);
+    Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
+    assertEquals(1, connection.openStreamCount());
+    connection.close();
+    assertEquals(0, connection.openStreamCount());
+    try {
+      connection.newStream(headerEntries("b", "banana"), false);
+      fail();
+    } catch (IOException expected) {
+      assertEquals("shutdown", expected.getMessage());
+    }
+    BufferedSink sink = Okio.buffer(stream.getSink());
+    try {
+      sink.writeByte(0);
+      sink.flush();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream finished", expected.getMessage());
+    }
+    try {
+      stream.getSource().read(new Buffer(), 1);
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream was reset: CANCEL", expected.getMessage());
+    }
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    InFrame goaway = peer.takeFrame();
+    assertEquals(Http2.TYPE_GOAWAY, goaway.type);
+    InFrame rstStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_RST_STREAM, rstStream.type);
+    assertEquals(3, rstStream.streamId);
+  }
+
+  @Test public void closeCancelsPings() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // PING
+    peer.acceptFrame(); // GOAWAY
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connection(peer);
+    Ping ping = connection.ping();
+    connection.close();
+    assertEquals(-1, ping.roundTripTime());
+  }
+
+  @Test public void getResponseHeadersTimesOut() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connection(peer);
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
+    stream.readTimeout().timeout(500, TimeUnit.MILLISECONDS);
+    long startNanos = System.nanoTime();
+    try {
+      stream.getResponseHeaders();
+      fail();
+    } catch (InterruptedIOException expected) {
+    }
+    long elapsedNanos = System.nanoTime() - startNanos;
+    awaitWatchdogIdle();
+    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_RST_STREAM, peer.takeFrame().type);
+  }
+
+  @Test public void readTimesOut() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connection(peer);
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
+    stream.readTimeout().timeout(500, TimeUnit.MILLISECONDS);
+    Source source = stream.getSource();
+    long startNanos = System.nanoTime();
+    try {
+      source.read(new Buffer(), 1);
+      fail();
+    } catch (InterruptedIOException expected) {
+    }
+    long elapsedNanos = System.nanoTime() - startNanos;
+    awaitWatchdogIdle();
+    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_RST_STREAM, peer.takeFrame().type);
+  }
+
+  @Test public void writeTimesOutAwaitingStreamWindow() throws Exception {
+    // Set the peer's receive window to 5 bytes!
+    Settings peerSettings = new Settings().set(INITIAL_WINDOW_SIZE, 5);
+
+    // write the mocking script
+    peer.acceptFrame(); // PING
+    peer.sendFrame().settings(peerSettings);
+    peer.acceptFrame(); // ACK SETTINGS
+    peer.sendFrame().ping(true, 1, 0);
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.acceptFrame(); // DATA
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connection(peer);
+    connection.ping().roundTripTime(); // Make sure settings have been received.
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
+    Sink sink = stream.getSink();
+    sink.write(new Buffer().writeUtf8("abcde"), 5);
+    stream.writeTimeout().timeout(500, TimeUnit.MILLISECONDS);
+    long startNanos = System.nanoTime();
+    sink.write(new Buffer().writeUtf8("f"), 1);
+    try {
+      sink.flush(); // This will time out waiting on the write window.
+      fail();
+    } catch (InterruptedIOException expected) {
+    }
+    long elapsedNanos = System.nanoTime() - startNanos;
+    awaitWatchdogIdle();
+    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    assertEquals(Http2.TYPE_PING, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_SETTINGS, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_DATA, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_RST_STREAM, peer.takeFrame().type);
+  }
+
+  @Test public void writeTimesOutAwaitingConnectionWindow() throws Exception {
+    // Set the peer's receive window to 5 bytes. Give the stream 5 bytes back, so only the
+    // connection-level window is applicable.
+    Settings peerSettings = new Settings().set(INITIAL_WINDOW_SIZE, 5);
+
+    // write the mocking script
+    peer.acceptFrame(); // PING
+    peer.sendFrame().settings(peerSettings);
+    peer.acceptFrame(); // ACK SETTINGS
+    peer.sendFrame().ping(true, 1, 0);
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().windowUpdate(3, 5);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 3, 0);
+    peer.acceptFrame(); // DATA
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connection(peer);
+    connection.ping().roundTripTime(); // Make sure settings have been acked.
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
+    connection.ping().roundTripTime(); // Make sure the window update has been received.
+    Sink sink = stream.getSink();
+    stream.writeTimeout().timeout(500, TimeUnit.MILLISECONDS);
+    sink.write(new Buffer().writeUtf8("abcdef"), 6);
+    long startNanos = System.nanoTime();
+    try {
+      sink.flush(); // This will time out waiting on the write window.
+      fail();
+    } catch (InterruptedIOException expected) {
+    }
+    long elapsedNanos = System.nanoTime() - startNanos;
+    awaitWatchdogIdle();
+    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    assertEquals(Http2.TYPE_PING, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_SETTINGS, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_PING, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_DATA, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_RST_STREAM, peer.takeFrame().type);
+  }
+
+  @Test public void outgoingWritesAreBatched() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.acceptFrame(); // DATA
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connection(peer);
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
+
+    // two outgoing writes
+    Sink sink = stream.getSink();
+    sink.write(new Buffer().writeUtf8("abcde"), 5);
+    sink.write(new Buffer().writeUtf8("fghij"), 5);
+    sink.close();
+
+    // verify the peer received one incoming frame
+    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
+    InFrame data = peer.takeFrame();
+    assertEquals(Http2.TYPE_DATA, data.type);
+    assertTrue(Arrays.equals("abcdefghij".getBytes("UTF-8"), data.data));
+    assertTrue(data.inFinished);
+  }
+
+  @Test public void headers() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // PING
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(3, headerEntries("c", "c3po"));
+    peer.sendFrame().ping(true, 1, 0);
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connection(peer);
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
+    connection.ping().roundTripTime(); // Ensure that the HEADERS has been received.
+    assertEquals(headerEntries("a", "android", "c", "c3po"), stream.getResponseHeaders());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    InFrame ping = peer.takeFrame();
+    assertEquals(Http2.TYPE_PING, ping.type);
+  }
+
+  @Test public void readSendsWindowUpdate() throws Exception {
+    int windowSize = 100;
+    int windowUpdateThreshold = 50;
+
+    // Write the mocking script.
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    for (int i = 0; i < 3; i++) {
+      // Send frames of summing to size 50, which is windowUpdateThreshold.
+      peer.sendFrame().data(false, 3, data(24), 24);
+      peer.sendFrame().data(false, 3, data(25), 25);
+      peer.sendFrame().data(false, 3, data(1), 1);
+      peer.acceptFrame(); // connection WINDOW UPDATE
+      peer.acceptFrame(); // stream WINDOW UPDATE
+    }
+    peer.sendFrame().data(true, 3, data(0), 0);
+    peer.play();
+
+    // Play it back.
+    Http2Connection connection = connection(peer);
+    connection.okHttpSettings.set(INITIAL_WINDOW_SIZE, windowSize);
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
+    assertEquals(0, stream.unacknowledgedBytesRead);
+    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
+    Source in = stream.getSource();
+    Buffer buffer = new Buffer();
+    buffer.writeAll(in);
+    assertEquals(-1, in.read(buffer, 1));
+    assertEquals(150, buffer.size());
+
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    for (int i = 0; i < 3; i++) {
+      List<Integer> windowUpdateStreamIds = new ArrayList<>(2);
+      for (int j = 0; j < 2; j++) {
+        InFrame windowUpdate = peer.takeFrame();
+        assertEquals(Http2.TYPE_WINDOW_UPDATE, windowUpdate.type);
+        windowUpdateStreamIds.add(windowUpdate.streamId);
+        assertEquals(windowUpdateThreshold, windowUpdate.windowSizeIncrement);
+      }
+      assertTrue(windowUpdateStreamIds.contains(0)); // connection
+      assertTrue(windowUpdateStreamIds.contains(3)); // stream
+    }
+  }
+
+  @Test public void serverSendsEmptyDataClientDoesntSendWindowUpdate() throws Exception {
+    // Write the mocking script.
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().data(true, 3, data(0), 0);
+    peer.play();
+
+    // Play it back.
+    Http2Connection connection = connection(peer);
+    Http2Stream client = connection.newStream(headerEntries("b", "banana"), false);
+    assertEquals(-1, client.getSource().read(new Buffer(), 1));
+
+    // Verify the peer received what was expected.
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertEquals(3, peer.frameCount());
+  }
+
+  @Test public void clientSendsEmptyDataServerDoesntSendWindowUpdate() throws Exception {
+    // Write the mocking script.
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // DATA
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.play();
+
+    // Play it back.
+    Http2Connection connection = connection(peer);
+    Http2Stream client = connection.newStream(headerEntries("b", "banana"), true);
+    BufferedSink out = Okio.buffer(client.getSink());
+    out.write(Util.EMPTY_BYTE_ARRAY);
+    out.flush();
+    out.close();
+
+    // Verify the peer received what was expected.
+    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_DATA, peer.takeFrame().type);
+    assertEquals(3, peer.frameCount());
+  }
+
+  @Test public void testTruncatedDataFrame() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().data(false, 3, data(1024), 1024);
+    peer.truncateLastFrame(8 + 100);
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connection(peer);
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
+    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
+    Source in = stream.getSource();
+    try {
+      Okio.buffer(in).readByteString(101);
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream was reset: PROTOCOL_ERROR", expected.getMessage());
+    }
+  }
+
+  @Test public void blockedStreamDoesntStarveNewStream() throws Exception {
+    int framesThatFillWindow = roundUp(DEFAULT_INITIAL_WINDOW_SIZE, peer.maxOutboundDataLength());
+
+    // Write the mocking script. This accepts more data frames than necessary!
+    peer.acceptFrame(); // SYN_STREAM on stream 1
+    for (int i = 0; i < framesThatFillWindow; i++) {
+      peer.acceptFrame(); // DATA on stream 1
+    }
+    peer.acceptFrame(); // SYN_STREAM on stream 2
+    peer.acceptFrame(); // DATA on stream 2
+    peer.play();
+
+    // Play it back.
+    Http2Connection connection = connection(peer);
+    Http2Stream stream1 = connection.newStream(headerEntries("a", "apple"), true);
+    BufferedSink out1 = Okio.buffer(stream1.getSink());
+    out1.write(new byte[DEFAULT_INITIAL_WINDOW_SIZE]);
+    out1.flush();
+
+    // Check that we've filled the window for both the stream and also the connection.
+    assertEquals(0, connection.bytesLeftInWriteWindow);
+    assertEquals(0, connection.getStream(3).bytesLeftInWriteWindow);
+
+    // receiving a window update on the the connection will unblock new streams.
+    connection.readerRunnable.windowUpdate(0, 3);
+
+    assertEquals(3, connection.bytesLeftInWriteWindow);
+    assertEquals(0, connection.getStream(3).bytesLeftInWriteWindow);
+
+    // Another stream should be able to send data even though 1 is blocked.
+    Http2Stream stream2 = connection.newStream(headerEntries("b", "banana"), true);
+    BufferedSink out2 = Okio.buffer(stream2.getSink());
+    out2.writeUtf8("foo");
+    out2.flush();
+
+    assertEquals(0, connection.bytesLeftInWriteWindow);
+    assertEquals(0, connection.getStream(3).bytesLeftInWriteWindow);
+    assertEquals(DEFAULT_INITIAL_WINDOW_SIZE - 3, connection.getStream(5).bytesLeftInWriteWindow);
+  }
+
+  private Buffer data(int byteCount) {
+    return new Buffer().write(new byte[byteCount]);
+  }
+
+  private void assertStreamData(String expected, Source source) throws IOException {
+    String actual = Okio.buffer(source).readUtf8();
+    assertEquals(expected, actual);
+  }
+
+  /**
+   * Returns true when all work currently in progress by the watchdog have completed. This method
+   * creates more work for the watchdog and waits for that work to be executed. When it is, we know
+   * work that preceded this call is complete.
+   */
+  private void awaitWatchdogIdle() throws InterruptedException {
+    final CountDownLatch latch = new CountDownLatch(1);
+    AsyncTimeout watchdogJob = new AsyncTimeout() {
+      @Override protected void timedOut() {
+        latch.countDown();
+      }
+    };
+    watchdogJob.deadlineNanoTime(System.nanoTime()); // Due immediately!
+    watchdogJob.enter();
+    latch.await();
+  }
+
+  static int roundUp(int num, int divisor) {
+    return (num + divisor - 1) / divisor;
+  }
+
+  private Http2Connection sendHttp2SettingsAndCheckForAck(boolean client, Settings settings)
+      throws IOException, InterruptedException {
+    peer.setClient(client);
+    peer.sendFrame().settings(settings);
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connection(peer);
+
+    // verify the peer received the ACK
+    InFrame ackFrame = peer.takeFrame();
+    assertEquals(Http2.TYPE_SETTINGS, ackFrame.type);
+    assertEquals(0, ackFrame.streamId);
+    assertTrue(ackFrame.ack);
+
+    connection.ping().roundTripTime(); // Ensure that settings have been applied before returning.
+    return connection;
+  }
+
+  private Http2Connection connection(MockHttp2Peer peer) throws IOException {
+    Http2Connection connection = connectionBuilder(peer).build();
+    connection.start(false);
+    return connection;
+  }
+
+  private Http2Connection.Builder connectionBuilder(MockHttp2Peer peer) throws IOException {
+    return new Http2Connection.Builder(true)
+        .socket(peer.openSocket())
+        .pushObserver(IGNORE);
+  }
+
+  static final PushObserver IGNORE = new PushObserver() {
+
+    @Override public boolean onRequest(int streamId, List<Header> requestHeaders) {
+      return false;
+    }
+
+    @Override public boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last) {
+      return false;
+    }
+
+    @Override public boolean onData(int streamId, BufferedSource source, int byteCount,
+        boolean last) throws IOException {
+      source.skip(byteCount);
+      return false;
+    }
+
+    @Override public void onReset(int streamId, ErrorCode errorCode) {
+    }
+  };
+
+  private static class RecordingPushObserver implements PushObserver {
+    final List<Object> events = new ArrayList<>();
+
+    public synchronized Object takeEvent() throws InterruptedException {
+      while (events.isEmpty()) {
+        wait();
+      }
+      return events.remove(0);
+    }
+
+    @Override public synchronized boolean onRequest(int streamId, List<Header> requestHeaders) {
+      assertEquals(2, streamId);
+      events.add(requestHeaders);
+      notifyAll();
+      return false;
+    }
+
+    @Override public synchronized boolean onHeaders(
+        int streamId, List<Header> responseHeaders, boolean last) {
+      assertEquals(2, streamId);
+      assertTrue(last);
+      events.add(responseHeaders);
+      notifyAll();
+      return false;
+    }
+
+    @Override public synchronized boolean onData(
+        int streamId, BufferedSource source, int byteCount, boolean last) {
+      events.add(new AssertionError("onData"));
+      notifyAll();
+      return false;
+    }
+
+    @Override public synchronized void onReset(int streamId, ErrorCode errorCode) {
+      events.add(new AssertionError("onReset"));
+      notifyAll();
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2Test.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java
similarity index 86%
rename from okhttp-tests/src/test/java/okhttp3/internal/framed/Http2Test.java
rename to okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java
index 0ae2f31c78..548dbe0207 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2Test.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.framed;
+package okhttp3.internal.http2;
 
 import java.io.IOException;
 import java.util.Arrays;
@@ -29,20 +29,20 @@
 import org.junit.Test;
 
 import static okhttp3.TestUtil.headerEntries;
-import static okhttp3.internal.framed.Http2.FLAG_COMPRESSED;
-import static okhttp3.internal.framed.Http2.FLAG_END_HEADERS;
-import static okhttp3.internal.framed.Http2.FLAG_END_STREAM;
-import static okhttp3.internal.framed.Http2.FLAG_NONE;
-import static okhttp3.internal.framed.Http2.FLAG_PADDED;
-import static okhttp3.internal.framed.Http2.FLAG_PRIORITY;
+import static okhttp3.internal.http2.Http2.FLAG_COMPRESSED;
+import static okhttp3.internal.http2.Http2.FLAG_END_HEADERS;
+import static okhttp3.internal.http2.Http2.FLAG_END_STREAM;
+import static okhttp3.internal.http2.Http2.FLAG_NONE;
+import static okhttp3.internal.http2.Http2.FLAG_PADDED;
+import static okhttp3.internal.http2.Http2.FLAG_PRIORITY;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
-public class Http2Test {
+public final class Http2Test {
   final Buffer frame = new Buffer();
-  final FrameReader fr = new Http2.Reader(frame, 4096, false);
+  final Http2Reader reader = new Http2Reader(frame, false);
   final int expectedStreamId = 15;
 
   @Test public void unknownFrameTypeSkipped() throws IOException {
@@ -52,7 +52,7 @@
     frame.writeInt(expectedStreamId);
     frame.writeInt(111111111); // custom data
 
-    fr.nextFrame(new BaseTestHandler()); // Should not callback.
+    reader.nextFrame(new BaseTestHandler()); // Should not callback.
   }
 
   @Test public void onlyOneLiteralHeadersFrame() throws IOException {
@@ -67,16 +67,13 @@
 
     assertEquals(frame, sendHeaderFrames(true, sentHeaders)); // Check writer sends the same bytes.
 
-    fr.nextFrame(new BaseTestHandler() {
-      @Override
-      public void headers(boolean outFinished, boolean inFinished, int streamId,
-          int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {
-        assertFalse(outFinished);
+    reader.nextFrame(new BaseTestHandler() {
+      @Override public void headers(boolean inFinished, int streamId,
+          int associatedStreamId, List<Header> headerBlock) {
         assertTrue(inFinished);
         assertEquals(expectedStreamId, streamId);
         assertEquals(-1, associatedStreamId);
         assertEquals(sentHeaders, headerBlock);
-        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
       }
     });
   }
@@ -93,7 +90,7 @@ public void headers(boolean outFinished, boolean inFinished, int streamId,
     frame.writeByte(255); // Heaviest weight, zero-indexed.
     frame.writeAll(headerBytes);
 
-    fr.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(new BaseTestHandler() {
       @Override public void priority(int streamId, int streamDependency, int weight,
           boolean exclusive) {
         assertEquals(0, streamDependency);
@@ -101,15 +98,12 @@ public void headers(boolean outFinished, boolean inFinished, int streamId,
         assertFalse(exclusive);
       }
 
-      @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
-          int associatedStreamId, List<Header> nameValueBlock,
-          HeadersMode headersMode) {
-        assertFalse(outFinished);
+      @Override public void headers(boolean inFinished, int streamId,
+          int associatedStreamId, List<Header> nameValueBlock) {
         assertFalse(inFinished);
         assertEquals(expectedStreamId, streamId);
         assertEquals(-1, associatedStreamId);
         assertEquals(sentHeaders, nameValueBlock);
-        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
       }
     });
   }
@@ -137,15 +131,13 @@ public void headers(boolean outFinished, boolean inFinished, int streamId,
     assertEquals(frame, sendHeaderFrames(false, sentHeaders)); // Check writer sends the same bytes.
 
     // Reading the above frames should result in a concatenated headerBlock.
-    fr.nextFrame(new BaseTestHandler() {
-      @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
-          int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {
-        assertFalse(outFinished);
+    reader.nextFrame(new BaseTestHandler() {
+      @Override public void headers(boolean inFinished, int streamId,
+          int associatedStreamId, List<Header> headerBlock) {
         assertFalse(inFinished);
         assertEquals(expectedStreamId, streamId);
         assertEquals(-1, associatedStreamId);
         assertEquals(sentHeaders, headerBlock);
-        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
       }
     });
   }
@@ -171,7 +163,7 @@ public void headers(boolean outFinished, boolean inFinished, int streamId,
 
     assertEquals(frame, sendPushPromiseFrames(expectedPromisedStreamId, pushPromise));
 
-    fr.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(new BaseTestHandler() {
       @Override
       public void pushPromise(int streamId, int promisedStreamId, List<Header> headerBlock) {
         assertEquals(expectedStreamId, streamId);
@@ -207,7 +199,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     assertEquals(frame, sendPushPromiseFrames(expectedPromisedStreamId, pushPromise));
 
     // Reading the above frames should result in a concatenated headerBlock.
-    fr.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(new BaseTestHandler() {
       @Override
       public void pushPromise(int streamId, int promisedStreamId, List<Header> headerBlock) {
         assertEquals(expectedStreamId, streamId);
@@ -222,12 +214,12 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeByte(Http2.TYPE_RST_STREAM);
     frame.writeByte(Http2.FLAG_NONE);
     frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeInt(ErrorCode.COMPRESSION_ERROR.httpCode);
+    frame.writeInt(ErrorCode.PROTOCOL_ERROR.httpCode);
 
-    fr.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(new BaseTestHandler() {
       @Override public void rstStream(int streamId, ErrorCode errorCode) {
         assertEquals(expectedStreamId, streamId);
-        assertEquals(ErrorCode.COMPRESSION_ERROR, errorCode);
+        assertEquals(ErrorCode.PROTOCOL_ERROR, errorCode);
       }
     });
   }
@@ -244,7 +236,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeShort(2); // SETTINGS_ENABLE_PUSH
     frame.writeInt(0);
 
-    fr.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(new BaseTestHandler() {
       @Override public void settings(boolean clearPrevious, Settings settings) {
         assertFalse(clearPrevious); // No clearPrevious in HTTP/2.
         assertEquals(reducedTableSizeBytes, settings.getHeaderTableSize());
@@ -262,7 +254,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeInt(2);
 
     try {
-      fr.nextFrame(new BaseTestHandler());
+      reader.nextFrame(new BaseTestHandler());
       fail();
     } catch (IOException e) {
       assertEquals("PROTOCOL_ERROR SETTINGS_ENABLE_PUSH != 0 or 1", e.getMessage());
@@ -278,7 +270,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeInt(1);
 
     final AtomicInteger settingValue = new AtomicInteger();
-    fr.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(new BaseTestHandler() {
       @Override public void settings(boolean clearPrevious, Settings settings) {
         settingValue.set(settings.get(7));
       }
@@ -295,7 +287,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeInt(Integer.MIN_VALUE);
 
     try {
-      fr.nextFrame(new BaseTestHandler());
+      reader.nextFrame(new BaseTestHandler());
       fail();
     } catch (IOException e) {
       assertEquals("PROTOCOL_ERROR SETTINGS_INITIAL_WINDOW_SIZE > 2^31 - 1", e.getMessage());
@@ -311,7 +303,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeInt(Integer.MIN_VALUE);
 
     try {
-      fr.nextFrame(new BaseTestHandler());
+      reader.nextFrame(new BaseTestHandler());
       fail();
     } catch (IOException e) {
       assertEquals("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: -2147483648", e.getMessage());
@@ -327,7 +319,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeInt((int) Math.pow(2, 14) - 1);
 
     try {
-      fr.nextFrame(new BaseTestHandler());
+      reader.nextFrame(new BaseTestHandler());
       fail();
     } catch (IOException e) {
       assertEquals("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: 16383", e.getMessage());
@@ -343,7 +335,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeInt((int) Math.pow(2, 24));
 
     try {
-      fr.nextFrame(new BaseTestHandler());
+      reader.nextFrame(new BaseTestHandler());
       fail();
     } catch (IOException e) {
       assertEquals("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: 16777216", e.getMessage());
@@ -364,7 +356,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     // Check writer sends the same bytes.
     assertEquals(frame, sendPingFrame(true, expectedPayload1, expectedPayload2));
 
-    fr.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(new BaseTestHandler() {
       @Override public void ping(boolean ack, int payload1, int payload2) {
         assertTrue(ack);
         assertEquals(expectedPayload1, payload1);
@@ -386,7 +378,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     // Check writer sends the same bytes.
     assertEquals(frame, sendDataFrame(new Buffer().write(expectedData)));
 
-    fr.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(new BaseTestHandler() {
       @Override public void data(boolean inFinished, int streamId, BufferedSource source,
           int length) throws IOException {
         assertFalse(inFinished);
@@ -414,7 +406,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     zipped.readAll(frame);
 
     try {
-      fr.nextFrame(new BaseTestHandler());
+      reader.nextFrame(new BaseTestHandler());
       fail();
     } catch (IOException e) {
       assertEquals("PROTOCOL_ERROR: FLAG_COMPRESSED without SETTINGS_COMPRESS_DATA",
@@ -439,7 +431,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.write(expectedData);
     frame.write(padding);
 
-    fr.nextFrame(assertData());
+    reader.nextFrame(assertData());
     assertTrue(frame.exhausted()); // Padding was skipped.
   }
 
@@ -455,7 +447,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeByte(0);
     frame.write(expectedData);
 
-    fr.nextFrame(assertData());
+    reader.nextFrame(assertData());
   }
 
   @Test public void readPaddedHeadersFrame() throws IOException {
@@ -472,7 +464,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeAll(headerBlock);
     frame.write(padding);
 
-    fr.nextFrame(assertHeaderBlock());
+    reader.nextFrame(assertHeaderBlock());
     assertTrue(frame.exhausted()); // Padding was skipped.
   }
 
@@ -485,7 +477,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeByte(0);
     frame.writeAll(headerBlock);
 
-    fr.nextFrame(assertHeaderBlock());
+    reader.nextFrame(assertHeaderBlock());
   }
 
   /** Headers are compressed, then framed. */
@@ -513,7 +505,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeAll(headerBlock);
 
-    fr.nextFrame(assertHeaderBlock());
+    reader.nextFrame(assertHeaderBlock());
     assertTrue(frame.exhausted());
   }
 
@@ -538,7 +530,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     // Check writer sends the same bytes.
     assertEquals(frame, windowUpdate(expectedWindowSizeIncrement));
 
-    fr.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(new BaseTestHandler() {
       @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
         assertEquals(expectedStreamId, streamId);
         assertEquals(expectedWindowSizeIncrement, windowSizeIncrement);
@@ -576,7 +568,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     // Check writer sends the same bytes.
     assertEquals(frame, sendGoAway(expectedStreamId, expectedError, Util.EMPTY_BYTE_ARRAY));
 
-    fr.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(new BaseTestHandler() {
       @Override public void goAway(
           int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
         assertEquals(expectedStreamId, lastGoodStreamId);
@@ -602,7 +594,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     // Check writer sends the same bytes.
     assertEquals(frame, sendGoAway(0, expectedError, expectedData.toByteArray()));
 
-    fr.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(new BaseTestHandler() {
       @Override public void goAway(
           int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
         assertEquals(0, lastGoodStreamId);
@@ -613,7 +605,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
   }
 
   @Test public void frameSizeError() throws IOException {
-    Http2.Writer writer = new Http2.Writer(new Buffer(), true);
+    Http2Writer writer = new Http2Writer(new Buffer(), true);
 
     try {
       writer.frameHeader(0, 16777216, Http2.TYPE_DATA, FLAG_NONE);
@@ -627,16 +619,16 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
   @Test public void ackSettingsAppliesMaxFrameSize() throws IOException {
     int newMaxFrameSize = 16777215;
 
-    Http2.Writer writer = new Http2.Writer(new Buffer(), true);
+    Http2Writer writer = new Http2Writer(new Buffer(), true);
 
-    writer.ackSettings(new Settings().set(Settings.MAX_FRAME_SIZE, 0, newMaxFrameSize));
+    writer.applyAndAckSettings(new Settings().set(Settings.MAX_FRAME_SIZE, newMaxFrameSize));
 
     assertEquals(newMaxFrameSize, writer.maxDataLength());
     writer.frameHeader(0, newMaxFrameSize, Http2.TYPE_DATA, FLAG_NONE);
   }
 
   @Test public void streamIdHasReservedBit() throws IOException {
-    Http2.Writer writer = new Http2.Writer(new Buffer(), true);
+    Http2Writer writer = new Http2Writer(new Buffer(), true);
 
     try {
       int streamId = 3;
@@ -656,57 +648,55 @@ private Buffer literalHeaders(List<Header> sentHeaders) throws IOException {
 
   private Buffer sendHeaderFrames(boolean outFinished, List<Header> headers) throws IOException {
     Buffer out = new Buffer();
-    new Http2.Writer(out, true).headers(outFinished, expectedStreamId, headers);
+    new Http2Writer(out, true).headers(outFinished, expectedStreamId, headers);
     return out;
   }
 
   private Buffer sendPushPromiseFrames(int streamId, List<Header> headers) throws IOException {
     Buffer out = new Buffer();
-    new Http2.Writer(out, true).pushPromise(expectedStreamId, streamId, headers);
+    new Http2Writer(out, true).pushPromise(expectedStreamId, streamId, headers);
     return out;
   }
 
   private Buffer sendPingFrame(boolean ack, int payload1, int payload2) throws IOException {
     Buffer out = new Buffer();
-    new Http2.Writer(out, true).ping(ack, payload1, payload2);
+    new Http2Writer(out, true).ping(ack, payload1, payload2);
     return out;
   }
 
   private Buffer sendGoAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
       throws IOException {
     Buffer out = new Buffer();
-    new Http2.Writer(out, true).goAway(lastGoodStreamId, errorCode, debugData);
+    new Http2Writer(out, true).goAway(lastGoodStreamId, errorCode, debugData);
     return out;
   }
 
   private Buffer sendDataFrame(Buffer data) throws IOException {
     Buffer out = new Buffer();
-    new Http2.Writer(out, true).dataFrame(expectedStreamId, FLAG_NONE, data,
+    new Http2Writer(out, true).dataFrame(expectedStreamId, FLAG_NONE, data,
         (int) data.size());
     return out;
   }
 
   private Buffer windowUpdate(long windowSizeIncrement) throws IOException {
     Buffer out = new Buffer();
-    new Http2.Writer(out, true).windowUpdate(expectedStreamId, windowSizeIncrement);
+    new Http2Writer(out, true).windowUpdate(expectedStreamId, windowSizeIncrement);
     return out;
   }
 
-  private FrameReader.Handler assertHeaderBlock() {
+  private Http2Reader.Handler assertHeaderBlock() {
     return new BaseTestHandler() {
-      @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
-          int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {
-        assertFalse(outFinished);
+      @Override public void headers(boolean inFinished, int streamId,
+          int associatedStreamId, List<Header> headerBlock) {
         assertFalse(inFinished);
         assertEquals(expectedStreamId, streamId);
         assertEquals(-1, associatedStreamId);
         assertEquals(headerEntries("foo", "barrr", "baz", "qux"), headerBlock);
-        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
       }
     };
   }
 
-  private FrameReader.Handler assertData() {
+  private Http2Reader.Handler assertData() {
     return new BaseTestHandler() {
       @Override public void data(boolean inFinished, int streamId, BufferedSource source,
           int length) throws IOException {
@@ -727,7 +717,7 @@ private static Buffer gzip(byte[] data) throws IOException {
     return buffer;
   }
 
-  /** Create a sufficiently large header set to overflow Http20Draft12.INITIAL_MAX_FRAME_SIZE bytes. */
+  /** Create a sufficiently large header set to overflow INITIAL_MAX_FRAME_SIZE bytes. */
   private static List<Header> largeHeaders() {
     String[] nameValues = new String[32];
     char[] chars = new char[512];
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverSpdyTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
similarity index 67%
rename from okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverSpdyTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
index 7c27cd29d7..0ccbf3b9f3 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverSpdyTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.framed;
+package okhttp3.internal.http2;
 
 import java.io.IOException;
 import java.io.InputStream;
@@ -25,26 +25,29 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLContext;
 import okhttp3.Cache;
 import okhttp3.Call;
 import okhttp3.Cookie;
 import okhttp3.Credentials;
+import okhttp3.Headers;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
 import okhttp3.Protocol;
 import okhttp3.RecordingCookieJar;
+import okhttp3.RecordingHostnameVerifier;
 import okhttp3.Request;
 import okhttp3.RequestBody;
 import okhttp3.Response;
+import okhttp3.internal.DoubleInetAddressDns;
 import okhttp3.internal.RecordingOkAuthenticator;
-import okhttp3.internal.SslContextBuilder;
+import okhttp3.internal.SingleInetAddressDns;
 import okhttp3.internal.Util;
+import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.PushPromise;
 import okhttp3.mockwebserver.RecordedRequest;
 import okhttp3.mockwebserver.SocketPolicy;
-import okhttp3.RecordingHostnameVerifier;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.GzipSink;
@@ -63,30 +66,23 @@
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.fail;
 
-/** Test how SPDY interacts with HTTP features. */
-public abstract class HttpOverSpdyTest {
+/** Test how SPDY interacts with HTTP/2 features. */
+public final class HttpOverHttp2Test {
   @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
   @Rule public final MockWebServer server = new MockWebServer();
 
-  /** Protocol to test, for example {@link Protocol#SPDY_3} */
-  private final Protocol protocol;
-  protected String hostHeader = ":host";
-
-  protected SSLContext sslContext = SslContextBuilder.localhost();
-  protected HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-  protected OkHttpClient client;
-  protected Cache cache;
-
-  protected HttpOverSpdyTest(Protocol protocol) {
-    this.protocol = protocol;
-  }
+  private SslClient sslClient = SslClient.localhost();
+  private HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+  private OkHttpClient client;
+  private Cache cache;
 
   @Before public void setUp() throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
     client = new OkHttpClient.Builder()
-        .protocols(Arrays.asList(protocol, Protocol.HTTP_1_1))
-        .sslSocketFactory(sslContext.getSocketFactory())
+        .protocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1))
+        .dns(new SingleInetAddressDns())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
         .hostnameVerifier(hostnameVerifier)
         .build();
   }
@@ -112,7 +108,7 @@ protected HttpOverSpdyTest(Protocol protocol) {
     RecordedRequest request = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
     assertEquals("https", request.getHeader(":scheme"));
-    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(hostHeader));
+    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(":authority"));
   }
 
   @Test public void emptyResponse() throws IOException {
@@ -127,9 +123,9 @@ protected HttpOverSpdyTest(Protocol protocol) {
     response.body().close();
   }
 
-  byte[] postBytes = "FGHIJ".getBytes(Util.UTF_8);
-
   @Test public void noDefaultContentLengthOnStreamingPost() throws Exception {
+    final byte[] postBytes = "FGHIJ".getBytes(Util.UTF_8);
+
     server.enqueue(new MockResponse().setBody("ABCDE"));
 
     Call call = client.newCall(new Request.Builder()
@@ -155,6 +151,8 @@ protected HttpOverSpdyTest(Protocol protocol) {
   }
 
   @Test public void userSuppliedContentLengthHeader() throws Exception {
+    final byte[] postBytes = "FGHIJ".getBytes(Util.UTF_8);
+
     server.enqueue(new MockResponse().setBody("ABCDE"));
 
     Call call = client.newCall(new Request.Builder()
@@ -184,6 +182,8 @@ protected HttpOverSpdyTest(Protocol protocol) {
   }
 
   @Test public void closeAfterFlush() throws Exception {
+    final byte[] postBytes = "FGHIJ".getBytes(Util.UTF_8);
+
     server.enqueue(new MockResponse().setBody("ABCDE"));
 
     Call call = client.newCall(new Request.Builder()
@@ -198,7 +198,7 @@ protected HttpOverSpdyTest(Protocol protocol) {
           }
 
           @Override public void writeTo(BufferedSink sink) throws IOException {
-            sink.write(postBytes);  // push bytes into SpdyDataOutputStream.buffer
+            sink.write(postBytes);  // push bytes into the stream's buffer
             sink.flush(); // FramedConnection.writeData subject to write window
             sink.close(); // FramedConnection.writeData empty frame
           }
@@ -214,7 +214,7 @@ protected HttpOverSpdyTest(Protocol protocol) {
     assertEquals(postBytes.length, Integer.parseInt(request.getHeader("Content-Length")));
   }
 
-  @Test public void spdyConnectionReuse() throws Exception {
+  @Test public void connectionReuse() throws Exception {
     server.enqueue(new MockResponse().setBody("ABCDEF"));
     server.enqueue(new MockResponse().setBody("GHIJKL"));
 
@@ -235,14 +235,15 @@ protected HttpOverSpdyTest(Protocol protocol) {
     assertEquals(1, server.takeRequest().getSequenceNumber());
   }
 
-  @Test @Ignore public void synchronousSpdyRequest() throws Exception {
+  /** https://github.com/square/okhttp/issues/373 */
+  @Test @Ignore public void synchronousRequest() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
     server.enqueue(new MockResponse().setBody("A"));
 
     ExecutorService executor = Executors.newCachedThreadPool();
     CountDownLatch countDownLatch = new CountDownLatch(2);
-    executor.execute(new SpdyRequest("/r1", countDownLatch));
-    executor.execute(new SpdyRequest("/r2", countDownLatch));
+    executor.execute(new AsyncRequest("/r1", countDownLatch));
+    executor.execute(new AsyncRequest("/r2", countDownLatch));
     countDownLatch.await();
     assertEquals(0, server.takeRequest().getSequenceNumber());
     assertEquals(1, server.takeRequest().getSequenceNumber());
@@ -391,7 +392,7 @@ protected HttpOverSpdyTest(Protocol protocol) {
     }
   }
 
-  @Test public void spdyConnectionTimeout() throws Exception {
+  @Test public void connectionTimeout() throws Exception {
     server.enqueue(new MockResponse()
         .setBody("A")
         .setBodyDelay(1, SECONDS));
@@ -582,6 +583,214 @@ protected HttpOverSpdyTest(Protocol protocol) {
     assertEquals(0, server.takeRequest().getSequenceNumber());
   }
 
+  @Test public void recoverFromOneRefusedStreamReusesConnection() throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
+        .setHttp2ErrorCode(ErrorCode.REFUSED_STREAM.httpCode));
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("abc", response.body().string());
+
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    assertEquals(1, server.takeRequest().getSequenceNumber()); // Reused connection.
+  }
+
+  @Test public void recoverFromOneInternalErrorRequiresNewConnection() throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
+        .setHttp2ErrorCode(ErrorCode.INTERNAL_ERROR.httpCode));
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    client = client.newBuilder()
+        .dns(new DoubleInetAddressDns())
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("abc", response.body().string());
+
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+  }
+
+  @Test public void recoverFromMultipleRefusedStreamsRequiresNewConnection() throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
+        .setHttp2ErrorCode(ErrorCode.REFUSED_STREAM.httpCode));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
+        .setHttp2ErrorCode(ErrorCode.REFUSED_STREAM.httpCode));
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    client = client.newBuilder()
+        .dns(new DoubleInetAddressDns())
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("abc", response.body().string());
+
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    assertEquals(1, server.takeRequest().getSequenceNumber()); // Reused connection.
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+  }
+
+  @Test public void noRecoveryFromRefusedStreamWithRetryDisabled() throws Exception {
+    noRecoveryFromErrorWithRetryDisabled(ErrorCode.REFUSED_STREAM);
+  }
+
+  @Test public void noRecoveryFromInternalErrorWithRetryDisabled() throws Exception {
+    noRecoveryFromErrorWithRetryDisabled(ErrorCode.INTERNAL_ERROR);
+  }
+
+  private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
+        .setHttp2ErrorCode(errorCode.httpCode));
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    client = client.newBuilder()
+        .retryOnConnectionFailure(false)
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (StreamResetException expected) {
+      assertEquals(errorCode, expected.errorCode);
+    }
+  }
+
+  @Test public void nonAsciiResponseHeader() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeaderLenient("Alpha", "α")
+        .addHeaderLenient("β", "Beta"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+
+    assertEquals("α", response.header("Alpha"));
+    assertEquals("Beta", response.header("β"));
+  }
+
+  @Test public void serverSendsPushPromise_GET() throws Exception {
+    PushPromise pushPromise = new PushPromise("GET", "/foo/bar", Headers.of("foo", "bar"),
+        new MockResponse().setBody("bar").setStatus("HTTP/1.1 200 Sweet"));
+    server.enqueue(new MockResponse()
+        .setBody("ABCDE")
+        .setStatus("HTTP/1.1 200 Sweet")
+        .withPush(pushPromise));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/foo"))
+        .build());
+    Response response = call.execute();
+
+    assertEquals("ABCDE", response.body().string());
+    assertEquals(200, response.code());
+    assertEquals("Sweet", response.message());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
+    assertEquals("https", request.getHeader(":scheme"));
+    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(":authority"));
+
+    RecordedRequest pushedRequest = server.takeRequest();
+    assertEquals("GET /foo/bar HTTP/1.1", pushedRequest.getRequestLine());
+    assertEquals("bar", pushedRequest.getHeader("foo"));
+  }
+
+  @Test public void serverSendsPushPromise_HEAD() throws Exception {
+    PushPromise pushPromise = new PushPromise("HEAD", "/foo/bar", Headers.of("foo", "bar"),
+        new MockResponse().setStatus("HTTP/1.1 204 Sweet"));
+    server.enqueue(new MockResponse()
+        .setBody("ABCDE")
+        .setStatus("HTTP/1.1 200 Sweet")
+        .withPush(pushPromise));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/foo"))
+        .build());
+    Response response = call.execute();
+    assertEquals("ABCDE", response.body().string());
+    assertEquals(200, response.code());
+    assertEquals("Sweet", response.message());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
+    assertEquals("https", request.getHeader(":scheme"));
+    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(":authority"));
+
+    RecordedRequest pushedRequest = server.takeRequest();
+    assertEquals("HEAD /foo/bar HTTP/1.1", pushedRequest.getRequestLine());
+    assertEquals("bar", pushedRequest.getHeader("foo"));
+  }
+
+  /**
+   * Push a setting that permits up to 2 concurrent streams, then make 3 concurrent requests and
+   * confirm that the third concurrent request prepared a new connection.
+   */
+  @Test public void settingsLimitsMaxConcurrentStreams() throws Exception {
+    Settings settings = new Settings();
+    settings.set(Settings.MAX_CONCURRENT_STREAMS, 2);
+
+    // Read & write a full request to confirm settings are accepted.
+    server.enqueue(new MockResponse().withSettings(settings));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("", response.body().string());
+
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+    server.enqueue(new MockResponse()
+        .setBody("DEF"));
+    server.enqueue(new MockResponse()
+        .setBody("GHI"));
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+
+    Call call3 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response3 = call3.execute();
+
+    assertEquals("ABC", response1.body().string());
+    assertEquals("DEF", response2.body().string());
+    assertEquals("GHI", response3.body().string());
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // Settings connection.
+    assertEquals(1, server.takeRequest().getSequenceNumber()); // Reuse settings connection.
+    assertEquals(2, server.takeRequest().getSequenceNumber()); // Reuse settings connection.
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection!
+  }
+
   public Buffer gzip(String bytes) throws IOException {
     Buffer bytesOut = new Buffer();
     BufferedSink sink = Okio.buffer(new GzipSink(bytesOut));
@@ -590,11 +799,11 @@ public Buffer gzip(String bytes) throws IOException {
     return bytesOut;
   }
 
-  class SpdyRequest implements Runnable {
+  class AsyncRequest implements Runnable {
     String path;
     CountDownLatch countDownLatch;
 
-    public SpdyRequest(String path, CountDownLatch countDownLatch) {
+    public AsyncRequest(String path, CountDownLatch countDownLatch) {
       this.path = path;
       this.countDownLatch = countDownLatch;
     }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/HuffmanTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/HuffmanTest.java
similarity index 61%
rename from okhttp-tests/src/test/java/okhttp3/internal/framed/HuffmanTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/http2/HuffmanTest.java
index b85a1b35b7..53642c0ea0 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/HuffmanTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/HuffmanTest.java
@@ -13,43 +13,38 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.framed;
+package okhttp3.internal.http2;
 
-import java.io.ByteArrayOutputStream;
-import java.io.DataOutputStream;
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.Random;
+import okio.Buffer;
+import okio.ByteString;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
-/**
- * Original version of this class was lifted from {@code com.twitter.hpack.HuffmanTest}.
- */
-public class HuffmanTest {
-
+/** Original version of this class was lifted from {@code com.twitter.hpack.HuffmanTest}. */
+public final class HuffmanTest {
   @Test public void roundTripForRequestAndResponse() throws IOException {
     String s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
     for (int i = 0; i < s.length(); i++) {
-      assertRoundTrip(s.substring(0, i).getBytes());
+      assertRoundTrip(ByteString.encodeUtf8(s.substring(0, i)));
     }
 
     Random random = new Random(123456789L);
     byte[] buf = new byte[4096];
     random.nextBytes(buf);
-    assertRoundTrip(buf);
+    assertRoundTrip(ByteString.of(buf));
   }
 
-  private void assertRoundTrip(byte[] buf) throws IOException {
-    ByteArrayOutputStream baos = new ByteArrayOutputStream();
-    DataOutputStream dos = new DataOutputStream(baos);
-
-    Huffman.get().encode(buf, dos);
-    assertEquals(baos.size(), Huffman.get().encodedLength(buf));
+  private void assertRoundTrip(ByteString data) throws IOException {
+    Buffer buffer = new Buffer();
+    Huffman.get().encode(data, buffer);
+    assertEquals(buffer.size(), Huffman.get().encodedLength(data));
 
-    byte[] decodedBytes = Huffman.get().decode(baos.toByteArray());
-    assertTrue(Arrays.equals(buf, decodedBytes));
+    byte[] decodedBytes = Huffman.get().decode(buffer.readByteArray());
+    assertTrue(Arrays.equals(data.toByteArray(), decodedBytes));
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/MockSpdyPeer.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
similarity index 80%
rename from okhttp-tests/src/test/java/okhttp3/internal/framed/MockSpdyPeer.java
rename to okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
index edc8f41c30..9a5b946f7f 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/MockSpdyPeer.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package okhttp3.internal.framed;
+package okhttp3.internal.http2;
 
 import java.io.Closeable;
 import java.io.IOException;
@@ -38,29 +38,27 @@
 import okio.Okio;
 
 /** Replays prerecorded outgoing frames and records incoming frames. */
-public final class MockSpdyPeer implements Closeable {
-  private static final Logger logger = Logger.getLogger(MockSpdyPeer.class.getName());
+public final class MockHttp2Peer implements Closeable {
+  private static final Logger logger = Logger.getLogger(MockHttp2Peer.class.getName());
 
   private int frameCount = 0;
   private boolean client = false;
-  private Variant variant = new Spdy3();
   private final Buffer bytesOut = new Buffer();
-  private FrameWriter frameWriter = variant.newWriter(bytesOut, client);
+  private Http2Writer writer = new Http2Writer(bytesOut, client);
   private final List<OutFrame> outFrames = new ArrayList<>();
   private final BlockingQueue<InFrame> inFrames = new LinkedBlockingQueue<>();
   private int port;
   private final ExecutorService executor = Executors.newSingleThreadExecutor(
-      Util.threadFactory("MockSpdyPeer", false));
+      Util.threadFactory("MockHttp2Peer", false));
   private ServerSocket serverSocket;
   private Socket socket;
 
-  public void setVariantAndClient(Variant variant, boolean client) {
-    if (this.variant.getProtocol() == variant.getProtocol() && this.client == client) {
+  public void setClient(boolean client) {
+    if (this.client == client) {
       return;
     }
     this.client = client;
-    this.variant = variant;
-    this.frameWriter = variant.newWriter(bytesOut, client);
+    this.writer = new Http2Writer(bytesOut, client);
   }
 
   public void acceptFrame() {
@@ -69,7 +67,7 @@ public void acceptFrame() {
 
   /** Maximum length of an outbound data frame. */
   public int maxOutboundDataLength() {
-    return frameWriter.maxDataLength();
+    return writer.maxDataLength();
   }
 
   /** Count of frames sent or received. */
@@ -77,18 +75,9 @@ public int frameCount() {
     return frameCount;
   }
 
-  public FrameWriter sendFrame() {
+  public Http2Writer sendFrame() {
     outFrames.add(new OutFrame(frameCount++, bytesOut.size(), false));
-    return frameWriter;
-  }
-
-  /**
-   * Sends a manually-constructed frame. This is useful to test frames that won't be generated
-   * naturally.
-   */
-  public void sendFrame(byte[] frame) throws IOException {
-    outFrames.add(new OutFrame(frameCount++, bytesOut.size(), false));
-    bytesOut.write(frame);
+    return writer;
   }
 
   /**
@@ -96,7 +85,7 @@ public void sendFrame(byte[] frame) throws IOException {
    * close the socket as soon as this frame has been written; otherwise the peer stays open until
    * explicitly closed.
    */
-  public FrameWriter truncateLastFrame(int length) {
+  public Http2Writer truncateLastFrame(int length) {
     OutFrame lastFrame = outFrames.remove(outFrames.size() - 1);
     if (length >= bytesOut.size() - lastFrame.start) throw new IllegalArgumentException();
 
@@ -108,7 +97,7 @@ public FrameWriter truncateLastFrame(int length) {
     fullBuffer.read(bytesOut, lastFrame.start + length);
 
     outFrames.add(new OutFrame(lastFrame.sequence, lastFrame.start, true));
-    return frameWriter;
+    return writer;
   }
 
   public InFrame takeFrame() throws InterruptedException {
@@ -126,8 +115,8 @@ public void play() throws IOException {
         try {
           readAndWriteFrames();
         } catch (IOException e) {
-          Util.closeQuietly(MockSpdyPeer.this);
-          logger.info(MockSpdyPeer.this + " done: " + e.getMessage());
+          Util.closeQuietly(MockHttp2Peer.this);
+          logger.info(MockHttp2Peer.this + " done: " + e.getMessage());
         }
       }
     });
@@ -147,7 +136,7 @@ private void readAndWriteFrames() throws IOException {
 
     OutputStream out = socket.getOutputStream();
     InputStream in = socket.getInputStream();
-    FrameReader reader = variant.newReader(Okio.buffer(Okio.source(in)), client);
+    Http2Reader reader = new Http2Reader(Okio.buffer(Okio.source(in)), client);
 
     Iterator<OutFrame> outFramesIterator = outFrames.iterator();
     byte[] outBytes = bytesOut.readByteArray();
@@ -199,7 +188,7 @@ public Socket openSocket() throws IOException {
   }
 
   @Override public String toString() {
-    return "MockSpdyPeer[" + port + "]";
+    return "MockHttp2Peer[" + port + "]";
   }
 
   private static class OutFrame {
@@ -214,9 +203,9 @@ private OutFrame(int sequence, long start, boolean truncated) {
     }
   }
 
-  public static class InFrame implements FrameReader.Handler {
+  public static class InFrame implements Http2Reader.Handler {
     public final int sequence;
-    public final FrameReader reader;
+    public final Http2Reader reader;
     public int type = -1;
     public boolean clearPrevious;
     public boolean outFinished;
@@ -228,45 +217,42 @@ private OutFrame(int sequence, long start, boolean truncated) {
     public List<Header> headerBlock;
     public byte[] data;
     public Settings settings;
-    public HeadersMode headersMode;
     public boolean ack;
     public int payload1;
     public int payload2;
 
-    public InFrame(int sequence, FrameReader reader) {
+    public InFrame(int sequence, Http2Reader reader) {
       this.sequence = sequence;
       this.reader = reader;
     }
 
     @Override public void settings(boolean clearPrevious, Settings settings) {
       if (this.type != -1) throw new IllegalStateException();
-      this.type = Spdy3.TYPE_SETTINGS;
+      this.type = Http2.TYPE_SETTINGS;
       this.clearPrevious = clearPrevious;
       this.settings = settings;
     }
 
     @Override public void ackSettings() {
       if (this.type != -1) throw new IllegalStateException();
-      this.type = Spdy3.TYPE_SETTINGS;
+      this.type = Http2.TYPE_SETTINGS;
       this.ack = true;
     }
 
-    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
-        int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {
+    @Override public void headers(boolean inFinished, int streamId,
+        int associatedStreamId, List<Header> headerBlock) {
       if (this.type != -1) throw new IllegalStateException();
-      this.type = Spdy3.TYPE_HEADERS;
-      this.outFinished = outFinished;
+      this.type = Http2.TYPE_HEADERS;
       this.inFinished = inFinished;
       this.streamId = streamId;
       this.associatedStreamId = associatedStreamId;
       this.headerBlock = headerBlock;
-      this.headersMode = headersMode;
     }
 
     @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
         throws IOException {
       if (this.type != -1) throw new IllegalStateException();
-      this.type = Spdy3.TYPE_DATA;
+      this.type = Http2.TYPE_DATA;
       this.inFinished = inFinished;
       this.streamId = streamId;
       this.data = source.readByteString(length).toByteArray();
@@ -274,14 +260,14 @@ public InFrame(int sequence, FrameReader reader) {
 
     @Override public void rstStream(int streamId, ErrorCode errorCode) {
       if (this.type != -1) throw new IllegalStateException();
-      this.type = Spdy3.TYPE_RST_STREAM;
+      this.type = Http2.TYPE_RST_STREAM;
       this.streamId = streamId;
       this.errorCode = errorCode;
     }
 
     @Override public void ping(boolean ack, int payload1, int payload2) {
       if (this.type != -1) throw new IllegalStateException();
-      this.type = Spdy3.TYPE_PING;
+      this.type = Http2.TYPE_PING;
       this.ack = ack;
       this.payload1 = payload1;
       this.payload2 = payload2;
@@ -289,7 +275,7 @@ public InFrame(int sequence, FrameReader reader) {
 
     @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
       if (this.type != -1) throw new IllegalStateException();
-      this.type = Spdy3.TYPE_GOAWAY;
+      this.type = Http2.TYPE_GOAWAY;
       this.streamId = lastGoodStreamId;
       this.errorCode = errorCode;
       this.data = debugData.toByteArray();
@@ -297,7 +283,7 @@ public InFrame(int sequence, FrameReader reader) {
 
     @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
       if (this.type != -1) throw new IllegalStateException();
-      this.type = Spdy3.TYPE_WINDOW_UPDATE;
+      this.type = Http2.TYPE_WINDOW_UPDATE;
       this.streamId = streamId;
       this.windowSizeIncrement = windowSizeIncrement;
     }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/SettingsTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/SettingsTest.java
new file mode 100644
index 0000000000..a26506ca27
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/SettingsTest.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import org.junit.Test;
+
+import static okhttp3.internal.http2.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
+import static okhttp3.internal.http2.Settings.MAX_CONCURRENT_STREAMS;
+import static org.junit.Assert.assertEquals;
+
+public final class SettingsTest {
+  @Test public void unsetField() {
+    Settings settings = new Settings();
+    assertEquals(-3, settings.getMaxConcurrentStreams(-3));
+  }
+
+  @Test public void setFields() {
+    Settings settings = new Settings();
+
+    settings.set(Settings.HEADER_TABLE_SIZE, 8096);
+    assertEquals(8096, settings.getHeaderTableSize());
+
+    assertEquals(true, settings.getEnablePush(true));
+    settings.set(Settings.ENABLE_PUSH, 1);
+    assertEquals(true, settings.getEnablePush(false));
+    settings.clear();
+
+    assertEquals(-3, settings.getMaxConcurrentStreams(-3));
+    settings.set(MAX_CONCURRENT_STREAMS, 75);
+    assertEquals(75, settings.getMaxConcurrentStreams(-3));
+
+    settings.clear();
+    assertEquals(16384, settings.getMaxFrameSize(16384));
+    settings.set(Settings.MAX_FRAME_SIZE, 16777215);
+    assertEquals(16777215, settings.getMaxFrameSize(16384));
+
+    assertEquals(-1, settings.getMaxHeaderListSize(-1));
+    settings.set(Settings.MAX_HEADER_LIST_SIZE, 16777215);
+    assertEquals(16777215, settings.getMaxHeaderListSize(-1));
+
+    assertEquals(DEFAULT_INITIAL_WINDOW_SIZE,
+        settings.getInitialWindowSize());
+    settings.set(Settings.INITIAL_WINDOW_SIZE, 108);
+    assertEquals(108, settings.getInitialWindowSize());
+  }
+
+  @Test public void merge() {
+    Settings a = new Settings();
+    a.set(Settings.HEADER_TABLE_SIZE, 10000);
+    a.set(Settings.MAX_HEADER_LIST_SIZE, 20000);
+    a.set(Settings.INITIAL_WINDOW_SIZE, 30000);
+
+    Settings b = new Settings();
+    b.set(Settings.MAX_HEADER_LIST_SIZE, 40000);
+    b.set(Settings.INITIAL_WINDOW_SIZE, 50000);
+    b.set(Settings.MAX_CONCURRENT_STREAMS, 60000);
+
+    a.merge(b);
+    assertEquals(10000, a.getHeaderTableSize());
+    assertEquals(40000, a.getMaxHeaderListSize(-1));
+    assertEquals(50000, a.getInitialWindowSize());
+    assertEquals(60000, a.getMaxConcurrentStreams(-1));
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/FaultyFileSystem.java b/okhttp-tests/src/test/java/okhttp3/internal/io/FaultyFileSystem.java
similarity index 97%
rename from okhttp-tests/src/test/java/okhttp3/internal/FaultyFileSystem.java
rename to okhttp-tests/src/test/java/okhttp3/internal/io/FaultyFileSystem.java
index 3f237d0ad0..40aca93adb 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/FaultyFileSystem.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/io/FaultyFileSystem.java
@@ -13,14 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal;
+package okhttp3.internal.io;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.util.LinkedHashSet;
 import java.util.Set;
-import okhttp3.internal.io.FileSystem;
 import okio.Buffer;
 import okio.ForwardingSink;
 import okio.Sink;
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java b/okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java
new file mode 100644
index 0000000000..ada8f78969
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform;
+
+import org.junit.Test;
+
+import static okhttp3.internal.platform.PlatformTest.getPlatform;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assume.assumeTrue;
+
+public class Jdk9PlatformTest {
+  @Test
+  public void buildsWhenJdk9() {
+    assumeTrue(getPlatform().equals("jdk9"));
+
+    assertNotNull(Jdk9Platform.buildIfSupported());
+  }
+
+  @Test
+  public void findsAlpnMethods() {
+    assumeTrue(getPlatform().equals("jdk9"));
+
+    Jdk9Platform platform = Jdk9Platform.buildIfSupported();
+
+    assertEquals("getApplicationProtocol", platform.getProtocolMethod.getName());
+    assertEquals("setApplicationProtocols", platform.setProtocolMethod.getName());
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/platform/JdkWithJettyBootPlatformTest.java b/okhttp-tests/src/test/java/okhttp3/internal/platform/JdkWithJettyBootPlatformTest.java
new file mode 100644
index 0000000000..afe7145a01
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/platform/JdkWithJettyBootPlatformTest.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform;
+
+import org.junit.Test;
+
+import static okhttp3.internal.platform.PlatformTest.getPlatform;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assume.assumeTrue;
+
+public class JdkWithJettyBootPlatformTest {
+  @Test
+  public void testBuildsWithJettyBoot() {
+    assumeTrue(getPlatform().equals("jdk-with-jetty-boot"));
+
+    assertNotNull(JdkWithJettyBootPlatform.buildIfSupported());
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/OptionalMethodTest.java b/okhttp-tests/src/test/java/okhttp3/internal/platform/OptionalMethodTest.java
similarity index 94%
rename from okhttp-tests/src/test/java/okhttp3/internal/OptionalMethodTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/platform/OptionalMethodTest.java
index 08e025c5d9..82ac18fc14 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/OptionalMethodTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/platform/OptionalMethodTest.java
@@ -15,7 +15,7 @@
  *  limitations under the License.
  */
 
-package okhttp3.internal;
+package okhttp3.internal.platform;
 
 import java.io.IOException;
 import java.lang.reflect.InvocationTargetException;
@@ -75,32 +75,32 @@ protected void nonPublic() {
   }
 
   private final static OptionalMethod<BaseClass> STRING_METHOD_RETURNS_ANY =
-      new OptionalMethod<BaseClass>(null, "stringMethod");
+      new OptionalMethod<>(null, "stringMethod");
   private final static OptionalMethod<BaseClass> STRING_METHOD_RETURNS_STRING =
-      new OptionalMethod<BaseClass>(String.class, "stringMethod");
+      new OptionalMethod<>(String.class, "stringMethod");
   private final static OptionalMethod<BaseClass> STRING_METHOD_RETURNS_INT =
-      new OptionalMethod<BaseClass>(Integer.TYPE, "stringMethod");
+      new OptionalMethod<>(Integer.TYPE, "stringMethod");
   private final static OptionalMethod<BaseClass> VOID_METHOD_RETURNS_ANY =
-      new OptionalMethod<BaseClass>(null, "voidMethod");
+      new OptionalMethod<>(null, "voidMethod");
   private final static OptionalMethod<BaseClass> VOID_METHOD_RETURNS_VOID =
-      new OptionalMethod<BaseClass>(Void.TYPE, "voidMethod");
+      new OptionalMethod<>(Void.TYPE, "voidMethod");
   private final static OptionalMethod<BaseClass> SUBCLASS_METHOD_RETURNS_ANY =
-      new OptionalMethod<BaseClass>(null, "subclassMethod");
+      new OptionalMethod<>(null, "subclassMethod");
   private final static OptionalMethod<BaseClass> SUBCLASS_METHOD_RETURNS_STRING =
-      new OptionalMethod<BaseClass>(String.class, "subclassMethod");
+      new OptionalMethod<>(String.class, "subclassMethod");
   private final static OptionalMethod<BaseClass> SUBCLASS_METHOD_RETURNS_INT =
-      new OptionalMethod<BaseClass>(Integer.TYPE, "subclassMethod");
+      new OptionalMethod<>(Integer.TYPE, "subclassMethod");
   private final static OptionalMethod<BaseClass> METHOD_WITH_ARGS_WRONG_PARAMS =
-      new OptionalMethod<BaseClass>(null, "methodWithArgs", Integer.class);
+      new OptionalMethod<>(null, "methodWithArgs", Integer.class);
   private final static OptionalMethod<BaseClass> METHOD_WITH_ARGS_CORRECT_PARAMS =
-      new OptionalMethod<BaseClass>(null, "methodWithArgs", String.class);
+      new OptionalMethod<>(null, "methodWithArgs", String.class);
 
   private final static OptionalMethod<BaseClass> THROWS_EXCEPTION =
-      new OptionalMethod<BaseClass>(null, "throwsException");
+      new OptionalMethod<>(null, "throwsException");
   private final static OptionalMethod<BaseClass> THROWS_RUNTIME_EXCEPTION =
-      new OptionalMethod<BaseClass>(null, "throwsRuntimeException");
+      new OptionalMethod<>(null, "throwsRuntimeException");
   private final static OptionalMethod<BaseClass> NON_PUBLIC =
-      new OptionalMethod<BaseClass>(null, "nonPublic");
+      new OptionalMethod<>(null, "nonPublic");
 
   @Test
   public void isSupported() throws Exception {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/platform/PlatformTest.java b/okhttp-tests/src/test/java/okhttp3/internal/platform/PlatformTest.java
new file mode 100644
index 0000000000..ffd5842e83
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/platform/PlatformTest.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform;
+
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+public class PlatformTest {
+  @Test public void alwaysBuilds() {
+    new Platform();
+  }
+
+  /** Guard against the default value changing by accident. */
+  @Test public void defaultPrefix() {
+    assertEquals("OkHttp", new Platform().getPrefix());
+  }
+
+  public static String getPlatform() {
+    return System.getProperty("okhttp.platform", "platform");
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java b/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
index 8c50399878..ee8a2fe935 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
@@ -15,7 +15,6 @@
  */
 package okhttp3.internal.tls;
 
-import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import okhttp3.Call;
@@ -24,14 +23,13 @@
 import okhttp3.RecordingHostnameVerifier;
 import okhttp3.Request;
 import okhttp3.Response;
-import okhttp3.internal.HeldCertificate;
-import okhttp3.internal.SslContextBuilder;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.SocketPolicy;
 import org.junit.Rule;
 import org.junit.Test;
 
+import static okhttp3.internal.platform.PlatformTest.getPlatform;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -60,19 +58,19 @@
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
         .add(server.getHostName(), CertificatePinner.pin(rootCa.certificate))
         .build();
-    SSLContext clientContext = new SslContextBuilder()
+    SslClient sslClient = new SslClient.Builder()
         .addTrustedCertificate(rootCa.certificate)
         .build();
     OkHttpClient client = new OkHttpClient.Builder()
-        .sslSocketFactory(clientContext.getSocketFactory())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
         .hostnameVerifier(new RecordingHostnameVerifier())
         .certificatePinner(certificatePinner)
         .build();
 
-    SSLContext serverSslContext = new SslContextBuilder()
+    SslClient serverSslClient = new SslClient.Builder()
         .certificateChain(certificate, intermediateCa)
         .build();
-    server.useHttps(serverSslContext.getSocketFactory(), false);
+    server.useHttps(serverSslClient.socketFactory, false);
 
     // The request should complete successfully.
     server.enqueue(new MockResponse()
@@ -116,19 +114,19 @@
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
         .add(server.getHostName(), CertificatePinner.pin(intermediateCa.certificate))
         .build();
-    SSLContext clientContext = new SslContextBuilder()
+    SslClient contextBuilder = new SslClient.Builder()
         .addTrustedCertificate(rootCa.certificate)
         .build();
     OkHttpClient client = new OkHttpClient.Builder()
-        .sslSocketFactory(clientContext.getSocketFactory())
+        .sslSocketFactory(contextBuilder.socketFactory, contextBuilder.trustManager)
         .hostnameVerifier(new RecordingHostnameVerifier())
         .certificatePinner(certificatePinner)
         .build();
 
-    SSLContext serverSslContext = new SslContextBuilder()
-        .certificateChain(certificate, intermediateCa)
+    SslClient serverSslContext = new SslClient.Builder()
+        .certificateChain(certificate.keyPair, certificate.certificate, intermediateCa.certificate)
         .build();
-    server.useHttps(serverSslContext.getSocketFactory(), false);
+    server.useHttps(serverSslContext.socketFactory, false);
 
     // The request should complete successfully.
     server.enqueue(new MockResponse()
@@ -176,11 +174,11 @@
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
         .add(server.getHostName(), CertificatePinner.pin(goodCertificate.certificate))
         .build();
-    SSLContext clientContext = new SslContextBuilder()
+    SslClient clientContextBuilder = new SslClient.Builder()
         .addTrustedCertificate(rootCa.certificate)
         .build();
     OkHttpClient client = new OkHttpClient.Builder()
-        .sslSocketFactory(clientContext.getSocketFactory())
+        .sslSocketFactory(clientContextBuilder.socketFactory, clientContextBuilder.trustManager)
         .hostnameVerifier(new RecordingHostnameVerifier())
         .certificatePinner(certificatePinner)
         .build();
@@ -200,10 +198,22 @@
         .issuedBy(compromisedIntermediateCa)
         .commonName(server.getHostName())
         .build();
-    SSLContext serverSslContext = new SslContextBuilder()
-        .certificateChain(rogueCertificate, compromisedIntermediateCa, goodCertificate, rootCa)
+
+    SslClient.Builder sslBuilder = new SslClient.Builder();
+
+    // Test setup fails on JDK9
+    // java.security.KeyStoreException: Certificate chain is not valid
+    // at sun.security.pkcs12.PKCS12KeyStore.setKeyEntry
+    // http://openjdk.java.net/jeps/229
+    // http://hg.openjdk.java.net/jdk9/jdk9/jdk/file/2c1c21d11e58/src/share/classes/sun/security/pkcs12/PKCS12KeyStore.java#l596
+    if (getPlatform().equals("jdk9")) {
+      sslBuilder.keyStoreType("JKS");
+    }
+
+    SslClient serverSslContext = sslBuilder.certificateChain(
+        rogueCertificate.keyPair, rogueCertificate.certificate, compromisedIntermediateCa.certificate, goodCertificate.certificate, rootCa.certificate)
         .build();
-    server.useHttps(serverSslContext.getSocketFactory(), false);
+    server.useHttps(serverSslContext.socketFactory, false);
     server.enqueue(new MockResponse()
         .setBody("abc")
         .addHeader("Content-Type: text/plain"));
@@ -249,12 +259,12 @@
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
         .add(server.getHostName(), CertificatePinner.pin(goodIntermediateCa.certificate))
         .build();
-    SSLContext clientContext = new SslContextBuilder()
+    SslClient clientContextBuilder = new SslClient.Builder()
         .addTrustedCertificate(rootCa.certificate)
         .addTrustedCertificate(compromisedRootCa.certificate)
         .build();
     OkHttpClient client = new OkHttpClient.Builder()
-        .sslSocketFactory(clientContext.getSocketFactory())
+        .sslSocketFactory(clientContextBuilder.socketFactory, clientContextBuilder.trustManager)
         .hostnameVerifier(new RecordingHostnameVerifier())
         .certificatePinner(certificatePinner)
         .build();
@@ -274,11 +284,22 @@
         .issuedBy(compromisedIntermediateCa)
         .commonName(server.getHostName())
         .build();
-    SSLContext serverSslContext = new SslContextBuilder()
-        .certificateChain(
-            rogueCertificate, goodIntermediateCa, compromisedIntermediateCa, compromisedRootCa)
+
+    SslClient.Builder sslBuilder = new SslClient.Builder();
+
+    // Test setup fails on JDK9
+    // java.security.KeyStoreException: Certificate chain is not valid
+    // at sun.security.pkcs12.PKCS12KeyStore.setKeyEntry
+    // http://openjdk.java.net/jeps/229
+    // http://hg.openjdk.java.net/jdk9/jdk9/jdk/file/2c1c21d11e58/src/share/classes/sun/security/pkcs12/PKCS12KeyStore.java#l596
+    if (getPlatform().equals("jdk9")) {
+      sslBuilder.keyStoreType("JKS");
+    }
+
+    SslClient serverSslContext = sslBuilder.certificateChain(
+            rogueCertificate.keyPair, rogueCertificate.certificate, goodIntermediateCa.certificate, compromisedIntermediateCa.certificate, compromisedRootCa.certificate)
         .build();
-    server.useHttps(serverSslContext.getSocketFactory(), false);
+    server.useHttps(serverSslContext.socketFactory, false);
     server.enqueue(new MockResponse()
         .setBody("abc")
         .addHeader("Content-Type: text/plain"));
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java b/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
new file mode 100644
index 0000000000..5b3f1b8148
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
@@ -0,0 +1,221 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.tls;
+
+import java.io.IOException;
+import java.net.ConnectException;
+import java.security.GeneralSecurityException;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import javax.security.auth.x500.X500Principal;
+import okhttp3.Call;
+import okhttp3.DelegatingSSLSocketFactory;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class ClientAuthTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  public enum ClientAuth {
+    NONE, WANTS, NEEDS;
+  }
+
+  private HeldCertificate serverRootCa;
+  private HeldCertificate serverIntermediateCa;
+  private HeldCertificate serverCert;
+  private HeldCertificate clientRootCa;
+  private HeldCertificate clientIntermediateCa;
+  private HeldCertificate clientCert;
+
+  @Before
+  public void initialise() throws GeneralSecurityException {
+    serverRootCa = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .ca(3)
+        .commonName("root")
+        .build();
+    serverIntermediateCa = new HeldCertificate.Builder()
+        .issuedBy(serverRootCa)
+        .ca(2)
+        .serialNumber("2")
+        .commonName("intermediate_ca")
+        .build();
+
+    serverCert = new HeldCertificate.Builder()
+        .issuedBy(serverIntermediateCa)
+        .serialNumber("3")
+        .commonName(server.getHostName())
+        .build();
+
+    clientRootCa = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .ca(13)
+        .commonName("root")
+        .build();
+    clientIntermediateCa = new HeldCertificate.Builder()
+        .issuedBy(serverRootCa)
+        .ca(12)
+        .serialNumber("2")
+        .commonName("intermediate_ca")
+        .build();
+
+    clientCert = new HeldCertificate.Builder()
+        .issuedBy(clientIntermediateCa)
+        .serialNumber("4")
+        .commonName("Jethro Willis")
+        .build();
+  }
+
+  @Test public void clientAuthForWants() throws Exception {
+    OkHttpClient client = buildClient(clientCert, clientIntermediateCa);
+
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.WANTS);
+
+    server.useHttps(socketFactory, false);
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
+    Response response = call.execute();
+    assertEquals(new X500Principal("CN=localhost"), response.handshake().peerPrincipal());
+    assertEquals(new X500Principal("CN=Jethro Willis"), response.handshake().localPrincipal());
+    assertEquals("abc", response.body().string());
+  }
+
+  @Test public void clientAuthForNeeds() throws Exception {
+    OkHttpClient client = buildClient(clientCert, clientIntermediateCa);
+
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.NEEDS);
+
+    server.useHttps(socketFactory, false);
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
+    Response response = call.execute();
+    assertEquals(new X500Principal("CN=localhost"), response.handshake().peerPrincipal());
+    assertEquals(new X500Principal("CN=Jethro Willis"), response.handshake().localPrincipal());
+    assertEquals("abc", response.body().string());
+  }
+
+  @Test public void clientAuthSkippedForNone() throws Exception {
+    OkHttpClient client = buildClient(clientCert, clientIntermediateCa);
+
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.NONE);
+
+    server.useHttps(socketFactory, false);
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
+    Response response = call.execute();
+    assertEquals(new X500Principal("CN=localhost"), response.handshake().peerPrincipal());
+    assertEquals(null, response.handshake().localPrincipal());
+    assertEquals("abc", response.body().string());
+  }
+
+  @Test public void missingClientAuthSkippedForWantsOnly() throws Exception {
+    OkHttpClient client = buildClient(null, clientIntermediateCa);
+
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.WANTS);
+
+    server.useHttps(socketFactory, false);
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
+    Response response = call.execute();
+    assertEquals(new X500Principal("CN=localhost"), response.handshake().peerPrincipal());
+    assertEquals(null, response.handshake().localPrincipal());
+    assertEquals("abc", response.body().string());
+  }
+
+  @Test public void missingClientAuthFailsForNeeds() throws Exception {
+    OkHttpClient client = buildClient(null, clientIntermediateCa);
+
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.NEEDS);
+
+    server.useHttps(socketFactory, false);
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
+
+    try {
+      call.execute();
+      fail();
+    } catch (ConnectException expected) {
+    }
+  }
+
+  @Test public void invalidClientAuthFails() throws Throwable {
+    HeldCertificate clientCert2 = new HeldCertificate.Builder()
+        .serialNumber("4")
+        .commonName("Jethro Willis")
+        .build();
+
+    OkHttpClient client = buildClient(clientCert2);
+
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.NEEDS);
+
+    server.useHttps(socketFactory, false);
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
+
+    try {
+      call.execute();
+      fail();
+    } catch (ConnectException expected) {
+    }
+  }
+
+  public OkHttpClient buildClient(HeldCertificate cert, HeldCertificate... chain) {
+    SslClient.Builder sslClientBuilder = new SslClient.Builder()
+        .addTrustedCertificate(serverRootCa.certificate);
+
+    if (cert != null) {
+      sslClientBuilder.certificateChain(cert, chain);
+    }
+
+    SslClient sslClient = sslClientBuilder.build();
+    return new OkHttpClient.Builder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .build();
+  }
+
+  public SSLSocketFactory buildServerSslSocketFactory(final ClientAuth clientAuth) {
+    SslClient serverSslClient = new SslClient.Builder()
+        .addTrustedCertificate(serverRootCa.certificate)
+        .addTrustedCertificate(clientRootCa.certificate)
+        .certificateChain(serverCert, serverIntermediateCa)
+        .build();
+
+    return new DelegatingSSLSocketFactory(serverSslClient.socketFactory) {
+      @Override protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
+        if (clientAuth == ClientAuth.NEEDS) {
+          sslSocket.setNeedClientAuth(true);
+        } else if (clientAuth == ClientAuth.WANTS) {
+          sslSocket.setWantClientAuth(true);
+        }
+
+        return super.configureSocket(sslSocket);
+      }
+    };
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/EmptyWebSocketListener.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/EmptyWebSocketListener.java
new file mode 100644
index 0000000000..f3ba32e464
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/EmptyWebSocketListener.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.ws;
+
+import java.io.IOException;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.WebSocket;
+import okhttp3.WebSocketListener;
+import okio.ByteString;
+
+public class EmptyWebSocketListener implements WebSocketListener {
+  @Override public void onOpen(WebSocket webSocket, Response response) {
+  }
+
+  @Override public void onMessage(ResponseBody message) throws IOException {
+  }
+
+  @Override public void onPong(ByteString payload) {
+  }
+
+  @Override public void onClose(int code, String reason) {
+  }
+
+  @Override public void onFailure(Throwable t, Response response) {
+  }
+}
diff --git a/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
similarity index 75%
rename from okhttp-ws-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
index 90a803ec14..7a23b269cc 100644
--- a/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
@@ -21,8 +21,10 @@
 import java.util.Random;
 import java.util.concurrent.Executor;
 import okhttp3.MediaType;
+import okhttp3.Protocol;
+import okhttp3.Request;
 import okhttp3.RequestBody;
-import okhttp3.ws.WebSocketRecorder;
+import okhttp3.Response;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -35,8 +37,7 @@
 import org.junit.Before;
 import org.junit.Test;
 
-import static okhttp3.ws.WebSocket.BINARY;
-import static okhttp3.ws.WebSocket.TEXT;
+import static okhttp3.WebSocket.TEXT;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotEquals;
@@ -53,34 +54,39 @@
   private boolean clientConnectionCloseThrows;
   private boolean clientConnectionClosed;
   private final MemorySocket client2Server = new MemorySocket();
-  private final WebSocketRecorder clientListener = new WebSocketRecorder();
+  private final WebSocketRecorder clientListener = new WebSocketRecorder("client");
 
   private final Executor serverExecutor = new SynchronousExecutor();
   private RealWebSocket server;
   private boolean serverConnectionClosed;
   private final MemorySocket server2client = new MemorySocket();
-  private final WebSocketRecorder serverListener = new WebSocketRecorder();
+  private final WebSocketRecorder serverListener = new WebSocketRecorder("server");
 
   @Before public void setUp() {
     Random random = new Random(0);
     String url = "http://example.com/websocket";
+    Response response = new Response.Builder()
+        .code(101)
+        .request(new Request.Builder().url(url).build())
+        .protocol(Protocol.HTTP_1_1)
+        .build();
 
     client = new RealWebSocket(true, server2client.source(), client2Server.sink(), random,
-        clientExecutor, clientListener, url) {
-      @Override protected void close() throws IOException {
+        clientExecutor, clientListener, response, url) {
+      @Override protected void shutdown() {
         if (clientConnectionClosed) {
           throw new AssertionError("Already closed");
         }
         clientConnectionClosed = true;
 
         if (clientConnectionCloseThrows) {
-          throw new IOException("Oops!");
+          throw new RuntimeException("Oops!");
         }
       }
     };
     server = new RealWebSocket(false, client2Server.source(), server2client.sink(), random,
-        serverExecutor, serverListener, url) {
-      @Override protected void close() throws IOException {
+        serverExecutor, serverListener, response, url) {
+      @Override protected void shutdown() {
         if (serverConnectionClosed) {
           throw new AssertionError("Already closed");
         }
@@ -94,48 +100,6 @@
     serverListener.assertExhausted();
   }
 
-  @Test public void nullMessageThrows() throws IOException {
-    try {
-      client.sendMessage(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertEquals("message == null", e.getMessage());
-    }
-  }
-
-  @Test public void textMessage() throws IOException {
-    client.sendMessage(RequestBody.create(TEXT, "Hello!"));
-    server.readMessage();
-    serverListener.assertTextMessage("Hello!");
-  }
-
-  @Test public void binaryMessage() throws IOException {
-    client.sendMessage(RequestBody.create(BINARY, "Hello!"));
-    server.readMessage();
-    serverListener.assertBinaryMessage(new byte[] {'H', 'e', 'l', 'l', 'o', '!'});
-  }
-
-  @Test public void missingContentTypeThrows() throws IOException {
-    try {
-      client.sendMessage(RequestBody.create(null, "Hey!"));
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals("Message content type was null. Must use WebSocket.TEXT or WebSocket.BINARY.",
-          e.getMessage());
-    }
-  }
-
-  @Test public void unknownContentTypeThrows() throws IOException {
-    try {
-      client.sendMessage(RequestBody.create(MediaType.parse("text/plain"), "Hey!"));
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals(
-          "Unknown message content type: text/plain. Must use WebSocket.TEXT or WebSocket.BINARY.",
-          e.getMessage());
-    }
-  }
-
   @Test public void streamingMessage() throws IOException {
     RequestBody message = new RequestBody() {
       @Override public MediaType contentType() {
@@ -149,11 +113,11 @@
       }
     };
     client.sendMessage(message);
-    server.readMessage();
+    server.processNextFrame();
     serverListener.assertTextMessage("Hello!");
   }
 
-  @Test public void streamingMessageCanInterleavePing() throws IOException, InterruptedException {
+  @Test public void streamingMessageCanInterleavePing() throws IOException {
     RequestBody message = new RequestBody() {
       @Override public MediaType contentType() {
         return TEXT;
@@ -161,37 +125,46 @@
 
       @Override public void writeTo(BufferedSink sink) throws IOException {
         sink.writeUtf8("Hel").flush();
-        client.sendPing(new Buffer().writeUtf8("Pong?"));
+        client.sendPing(ByteString.encodeUtf8("Pong?"));
         sink.writeUtf8("lo!").flush();
         sink.close();
       }
     };
 
     client.sendMessage(message);
-    server.readMessage();
+    server.processNextFrame();
     serverListener.assertTextMessage("Hello!");
-    client.readMessage();
-    clientListener.assertPong(new Buffer().writeUtf8("Pong?"));
+    client.processNextFrame();
+    clientListener.assertPong(ByteString.encodeUtf8("Pong?"));
   }
 
-  @Test public void pingWritesPong() throws IOException, InterruptedException {
-    client.sendPing(new Buffer().writeUtf8("Hello!"));
-    server.readMessage(); // Read the ping, write the pong.
-    client.readMessage(); // Read the pong.
-    clientListener.assertPong(new Buffer().writeUtf8("Hello!"));
+  @Test public void pingWritesPong() throws IOException {
+    client.sendPing(ByteString.encodeUtf8("Hello!"));
+    server.processNextFrame(); // Read the ping, write the pong.
+    client.processNextFrame(); // Read the pong.
+    clientListener.assertPong(ByteString.encodeUtf8("Hello!"));
   }
 
   @Test public void unsolicitedPong() throws IOException {
-    client.sendPong(new Buffer().writeUtf8("Hello!"));
-    server.readMessage();
-    serverListener.assertPong(new Buffer().writeUtf8("Hello!"));
+    client.sendPong(ByteString.encodeUtf8("Hello!"));
+    server.processNextFrame();
+    serverListener.assertPong(ByteString.encodeUtf8("Hello!"));
+  }
+
+  @Test public void nullPongPayloadThrows() throws IOException {
+    try {
+      client.sendPong(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertEquals("payload == null", e.getMessage());
+    }
   }
 
   @Test public void close() throws IOException {
     client.close(1000, "Hello!");
-    assertFalse(server.readMessage()); // This will trigger a close response.
+    assertFalse(server.processNextFrame()); // This will trigger a close response.
     serverListener.assertClose(1000, "Hello!");
-    assertFalse(client.readMessage());
+    assertFalse(client.processNextFrame());
     clientListener.assertClose(1000, "Hello!");
   }
 
@@ -199,7 +172,7 @@
     client.close(1000, "Hello!");
 
     try {
-      client.sendPing(new Buffer().writeUtf8("Pong?"));
+      client.sendPing(ByteString.encodeUtf8("Pong?"));
       fail();
     } catch (IllegalStateException e) {
       assertEquals("closed", e.getMessage());
@@ -222,7 +195,7 @@
     client2Server.close();
 
     try {
-      client.sendPing(new Buffer().writeUtf8("Ping!"));
+      client.sendPing(ByteString.encodeUtf8("Ping!"));
       fail();
     } catch (IOException ignored) {
     }
@@ -235,7 +208,7 @@
       assertEquals("must call close()", e.getMessage());
     }
     try {
-      client.sendPing(new Buffer().writeUtf8("Ping!"));
+      client.sendPing(ByteString.encodeUtf8("Ping!"));
       fail();
     } catch (IllegalStateException e) {
       assertEquals("must call close()", e.getMessage());
@@ -259,7 +232,7 @@
       assertEquals("must call close()", e.getMessage());
     }
     try {
-      client.sendPing(new Buffer().writeUtf8("Ping!"));
+      client.sendPing(ByteString.encodeUtf8("Ping!"));
       fail();
     } catch (IllegalStateException e) {
       assertEquals("must call close()", e.getMessage());
@@ -268,11 +241,11 @@
 
   @Test public void serverCloseThenWritingPingThrows() throws IOException {
     server.close(1000, "Hello!");
-    client.readMessage();
+    client.processNextFrame();
     clientListener.assertClose(1000, "Hello!");
 
     try {
-      client.sendPing(new Buffer().writeUtf8("Pong?"));
+      client.sendPing(ByteString.encodeUtf8("Pong?"));
       fail();
     } catch (IOException e) {
       assertEquals("closed", e.getMessage());
@@ -281,7 +254,7 @@
 
   @Test public void serverCloseThenWritingMessageThrows() throws IOException {
     server.close(1000, "Hello!");
-    client.readMessage();
+    client.processNextFrame();
     clientListener.assertClose(1000, "Hello!");
 
     try {
@@ -294,7 +267,7 @@
 
   @Test public void serverCloseThenWritingCloseThrows() throws IOException {
     server.close(1000, "Hello!");
-    client.readMessage();
+    client.processNextFrame();
     clientListener.assertClose(1000, "Hello!");
 
     try {
@@ -316,7 +289,7 @@
         sink.writeUtf8("Hel").flush();
 
         server.close(1000, "Hello!");
-        client.readMessage();
+        client.processNextFrame();
         clientListener.assertClose(1000, "Hello!");
 
         try {
@@ -339,10 +312,10 @@
   @Test public void clientCloseClosesConnection() throws IOException {
     client.close(1000, "Hello!");
     assertFalse(clientConnectionClosed);
-    server.readMessage(); // Read client close, send server close.
+    server.processNextFrame(); // Read client close, send server close.
     serverListener.assertClose(1000, "Hello!");
 
-    client.readMessage(); // Read server close, close connection.
+    client.processNextFrame(); // Read server close, close connection.
     assertTrue(clientConnectionClosed);
     clientListener.assertClose(1000, "Hello!");
   }
@@ -350,11 +323,11 @@
   @Test public void serverCloseClosesConnection() throws IOException {
     server.close(1000, "Hello!");
 
-    client.readMessage(); // Read server close, send client close, close connection.
+    client.processNextFrame(); // Read server close, send client close, close connection.
     assertTrue(clientConnectionClosed);
     clientListener.assertClose(1000, "Hello!");
 
-    server.readMessage();
+    server.processNextFrame();
     serverListener.assertClose(1000, "Hello!");
   }
 
@@ -364,11 +337,11 @@
     client.close(1000, "Hi!");
     assertFalse(clientConnectionClosed);
 
-    client.readMessage(); // Read close, close connection close.
+    client.processNextFrame(); // Read close, close connection close.
     assertTrue(clientConnectionClosed);
     clientListener.assertClose(1000, "Hello!");
 
-    server.readMessage();
+    server.processNextFrame();
     serverListener.assertClose(1000, "Hi!");
 
     serverListener.assertExhausted(); // Client should not have sent second close.
@@ -378,38 +351,61 @@
   @Test public void serverCloseBreaksReadMessageLoop() throws IOException {
     server.sendMessage(RequestBody.create(TEXT, "Hello!"));
     server.close(1000, "Bye!");
-    assertTrue(client.readMessage());
+    assertTrue(client.processNextFrame());
     clientListener.assertTextMessage("Hello!");
-    assertFalse(client.readMessage());
+    assertFalse(client.processNextFrame());
     clientListener.assertClose(1000, "Bye!");
   }
 
-  @Test public void protocolErrorBeforeCloseSendsClose() throws IOException {
+  @Test public void protocolErrorBeforeCloseSendsClose() {
     server2client.raw().write(ByteString.decodeHex("0a00")); // Invalid non-final ping frame.
 
-    client.readMessage(); // Detects error, send close, close connection.
+    client.processNextFrame(); // Detects error, send close, close connection.
     assertTrue(clientConnectionClosed);
     clientListener.assertFailure(ProtocolException.class, "Control frames must be final.");
 
-    server.readMessage();
+    server.processNextFrame();
     serverListener.assertClose(1002, "");
   }
 
+  @Test public void protocolErrorInCloseResponseClosesConnection() throws IOException {
+    client.close(1000, "Hello");
+    assertFalse(clientConnectionClosed); // Not closed until close reply is received.
+
+    // Manually write an invalid masked close frame.
+    server2client.raw().write(ByteString.decodeHex("888760b420bb635c68de0cd84f"));
+
+    client.processNextFrame(); // Detects error, closes connection immediately since close already sent.
+    assertTrue(clientConnectionClosed);
+    clientListener.assertFailure(ProtocolException.class, "Server-sent frames must not be masked.");
+
+    server.processNextFrame();
+    serverListener.assertClose(1000, "Hello");
+
+    serverListener.assertExhausted(); // Client should not have sent second close.
+  }
+
   @Test public void protocolErrorAfterCloseDoesNotSendClose() throws IOException {
     client.close(1000, "Hello!");
     assertFalse(clientConnectionClosed); // Not closed until close reply is received.
     server2client.raw().write(ByteString.decodeHex("0a00")); // Invalid non-final ping frame.
 
-    client.readMessage(); // Detects error, closes connection immediately since close already sent.
+    client.processNextFrame(); // Detects error, closes connection immediately since close already sent.
     assertTrue(clientConnectionClosed);
     clientListener.assertFailure(ProtocolException.class, "Control frames must be final.");
 
-    server.readMessage();
+    server.processNextFrame();
     serverListener.assertClose(1000, "Hello!");
 
     serverListener.assertExhausted(); // Client should not have sent second close.
   }
 
+  @Test public void networkErrorReportedAsCloseNotFailure() {
+    server2client.close();
+    client.processNextFrame();
+    clientListener.assertClose(1006, "");
+  }
+
   @Test public void closeThrowingClosesConnection() {
     client2Server.close();
 
@@ -421,7 +417,7 @@
     assertTrue(clientConnectionClosed);
   }
 
-  @Test public void closeMessageAndConnectionCloseThrowingDoesNotMaskOriginal() throws IOException {
+  @Test public void closeMessageAndConnectionCloseThrowingDoesNotMaskOriginal() {
     client2Server.close();
     clientConnectionCloseThrows = true;
 
@@ -438,11 +434,11 @@
     clientConnectionCloseThrows = true;
 
     server.close(1000, "Bye!");
-    client.readMessage();
+    client.processNextFrame();
     assertTrue(clientConnectionClosed);
     clientListener.assertClose(1000, "Bye!");
 
-    server.readMessage();
+    server.processNextFrame();
     serverListener.assertClose(1000, "Bye!");
   }
 
@@ -469,7 +465,7 @@ BufferedSource source() {
           return Timeout.NONE;
         }
 
-        @Override public void close() throws IOException {
+        @Override public void close() {
           closed = true;
         }
       });
@@ -482,14 +478,14 @@ BufferedSink sink() {
           buffer.write(source, byteCount);
         }
 
-        @Override public void flush() throws IOException {
+        @Override public void flush() {
         }
 
         @Override public Timeout timeout() {
           return Timeout.NONE;
         }
 
-        @Override public void close() throws IOException {
+        @Override public void close() {
           closed = true;
         }
       });
diff --git a/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
similarity index 91%
rename from okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
index 358b35990a..f1ae34e51f 100644
--- a/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
@@ -22,8 +22,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.regex.Pattern;
 import okhttp3.ResponseBody;
-import okhttp3.ws.WebSocketRecorder;
-import okhttp3.ws.WebSocketRecorder.MessageDelegate;
+import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.ByteString;
@@ -37,12 +36,12 @@
 
 public final class WebSocketReaderTest {
   private final Buffer data = new Buffer();
-  private final WebSocketRecorder callback = new WebSocketRecorder();
+  private final WebSocketRecorder callback = new WebSocketRecorder("client");
   private final Random random = new Random(0);
 
   // Mutually exclusive. Use the one corresponding to the peer whose behavior you wish to test.
-  private final WebSocketReader serverReader = new WebSocketReader(false, data, callback);
-  private final WebSocketReader clientReader = new WebSocketReader(true, data, callback);
+  final WebSocketReader serverReader = new WebSocketReader(false, data, callback.asFrameCallback());
+  final WebSocketReader clientReader = new WebSocketReader(true, data, callback.asFrameCallback());
 
   @After public void tearDown() {
     callback.assertExhausted();
@@ -90,7 +89,7 @@
       serverReader.processNextFrame();
       fail();
     } catch (ProtocolException e) {
-      assertEquals("Client-sent frames must be masked. Server sent must not.", e.getMessage());
+      assertEquals("Client-sent frames must be masked.", e.getMessage());
     }
   }
 
@@ -100,7 +99,7 @@
       clientReader.processNextFrame();
       fail();
     } catch (ProtocolException e) {
-      assertEquals("Client-sent frames must be masked. Server sent must not.", e.getMessage());
+      assertEquals("Server-sent frames must not be masked.", e.getMessage());
     }
   }
 
@@ -152,7 +151,7 @@
     data.write(ByteString.decodeHex("818537fa213d7f9f4d")); // Hel
 
     final Buffer sink = new Buffer();
-    callback.setNextMessageDelegate(new MessageDelegate() {
+    callback.setNextEventDelegate(new EmptyWebSocketListener() {
       @Override public void onMessage(ResponseBody message) throws IOException {
         BufferedSource source = message.source();
         source.readFully(sink, 3); // Read "Hel"
@@ -181,10 +180,10 @@
     data.write(ByteString.decodeHex("8a00")); // Pong
     data.write(ByteString.decodeHex("80026c6f")); // lo
     clientReader.processNextFrame();
-    callback.assertPong(null);
-    callback.assertPong(null);
-    callback.assertPong(null);
-    callback.assertPong(null);
+    callback.assertPong(ByteString.EMPTY);
+    callback.assertPong(ByteString.EMPTY);
+    callback.assertPong(ByteString.EMPTY);
+    callback.assertPong(ByteString.EMPTY);
     callback.assertTextMessage("Hello");
   }
 
@@ -253,7 +252,7 @@
 
   @Test public void noCloseErrors() throws IOException {
     data.write(ByteString.decodeHex("810548656c6c6f")); // Hello
-    callback.setNextMessageDelegate(new MessageDelegate() {
+    callback.setNextEventDelegate(new EmptyWebSocketListener() {
       @Override public void onMessage(ResponseBody body) throws IOException {
         body.source().readAll(new Buffer());
       }
@@ -271,7 +270,7 @@
     data.write(ByteString.decodeHex("810448657921")); // Hey!
 
     final Buffer sink = new Buffer();
-    callback.setNextMessageDelegate(new MessageDelegate() {
+    callback.setNextEventDelegate(new EmptyWebSocketListener() {
       @Override public void onMessage(ResponseBody message) throws IOException {
         message.source().read(sink, 3);
         message.close();
@@ -293,7 +292,7 @@
     data.write(ByteString.decodeHex("810448657921")); // Hey!
 
     final Buffer sink = new Buffer();
-    callback.setNextMessageDelegate(new MessageDelegate() {
+    callback.setNextEventDelegate(new EmptyWebSocketListener() {
       @Override public void onMessage(ResponseBody message) throws IOException {
         message.source().read(sink, 2);
         message.close();
@@ -302,8 +301,8 @@
 
     clientReader.processNextFrame();
     assertEquals("He", sink.readUtf8());
-    callback.assertPong(null);
-    callback.assertPong(null);
+    callback.assertPong(ByteString.EMPTY);
+    callback.assertPong(ByteString.EMPTY);
 
     clientReader.processNextFrame();
     callback.assertTextMessage("Hey!");
@@ -313,7 +312,7 @@
     data.write(ByteString.decodeHex("810548656c6c6f")); // Hello
 
     final AtomicReference<Exception> exception = new AtomicReference<>();
-    callback.setNextMessageDelegate(new MessageDelegate() {
+    callback.setNextEventDelegate(new EmptyWebSocketListener() {
       @Override public void onMessage(ResponseBody message) throws IOException {
         message.close();
         try {
@@ -332,19 +331,19 @@
   @Test public void emptyPingCallsCallback() throws IOException {
     data.write(ByteString.decodeHex("8900")); // Empty ping
     clientReader.processNextFrame();
-    callback.assertPing(null);
+    callback.assertPing(ByteString.EMPTY);
   }
 
   @Test public void pingCallsCallback() throws IOException {
     data.write(ByteString.decodeHex("890548656c6c6f")); // Ping with "Hello"
     clientReader.processNextFrame();
-    callback.assertPing(new Buffer().writeUtf8("Hello"));
+    callback.assertPing(ByteString.encodeUtf8("Hello"));
   }
 
   @Test public void emptyCloseCallsCallback() throws IOException {
     data.write(ByteString.decodeHex("8800")); // Empty close
     clientReader.processNextFrame();
-    callback.assertClose(1000, "");
+    callback.assertClose(1005, "");
   }
 
   @Test public void closeLengthOfOneThrows() throws IOException {
@@ -385,7 +384,7 @@
     data.write(ByteString.decodeHex("880203ed")); // Close with code 1005
     data.write(ByteString.decodeHex("880203ee")); // Close with code 1006
     for (int i = 1012; i <= 2999; i++) {
-      data.write(ByteString.decodeHex("8802" + String.format("%04X", i))); // Close with code 'i'
+      data.write(ByteString.decodeHex("8802" + Util.format("%04X", i))); // Close with code 'i'
     }
 
     int count = 0;
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
new file mode 100644
index 0000000000..91510cdf56
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
@@ -0,0 +1,354 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.ws;
+
+import java.io.IOException;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
+import okhttp3.MediaType;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.WebSocket;
+import okhttp3.WebSocketListener;
+import okhttp3.internal.platform.Platform;
+import okio.Buffer;
+import okio.ByteString;
+
+import static okhttp3.WebSocket.BINARY;
+import static okhttp3.WebSocket.TEXT;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+
+public final class WebSocketRecorder implements WebSocketListener {
+  private final String name;
+  private final BlockingQueue<Object> events = new LinkedBlockingQueue<>();
+  private WebSocketListener delegate;
+
+  public WebSocketRecorder(String name) {
+    this.name = name;
+  }
+
+  /** Sets a delegate for handling the next callback to this listener. Cleared after invoked. */
+  public void setNextEventDelegate(WebSocketListener delegate) {
+    this.delegate = delegate;
+  }
+
+  @Override public void onOpen(WebSocket webSocket, Response response) {
+    Platform.get().log(Platform.INFO, "[WS " + name + "] onOpen", null);
+
+    WebSocketListener delegate = this.delegate;
+    if (delegate != null) {
+      this.delegate = null;
+      delegate.onOpen(webSocket, response);
+    } else {
+      events.add(new Open(webSocket, response));
+    }
+  }
+
+  @Override public void onMessage(ResponseBody message) throws IOException {
+    Platform.get().log(Platform.INFO, "[WS " + name + "] onMessage", null);
+
+    WebSocketListener delegate = this.delegate;
+    if (delegate != null) {
+      this.delegate = null;
+      delegate.onMessage(message);
+    } else {
+      Message event = new Message(message.contentType());
+      message.source().readAll(event.buffer);
+      message.close();
+      events.add(event);
+    }
+  }
+
+  @Override public void onPong(ByteString payload) {
+    Platform.get().log(Platform.INFO, "[WS " + name + "] onPong", null);
+
+    WebSocketListener delegate = this.delegate;
+    if (delegate != null) {
+      this.delegate = null;
+      delegate.onPong(payload);
+    } else {
+      events.add(new Pong(payload));
+    }
+  }
+
+  @Override public void onClose(int code, String reason) {
+    Platform.get().log(Platform.INFO, "[WS " + name + "] onClose " + code, null);
+
+    WebSocketListener delegate = this.delegate;
+    if (delegate != null) {
+      this.delegate = null;
+      delegate.onClose(code, reason);
+    } else {
+      events.add(new Close(code, reason));
+    }
+  }
+
+  @Override public void onFailure(Throwable t, Response response) {
+    Platform.get().log(Platform.INFO, "[WS " + name + "] onFailure", t);
+
+    WebSocketListener delegate = this.delegate;
+    if (delegate != null) {
+      this.delegate = null;
+      delegate.onFailure(t, response);
+    } else {
+      events.add(new Failure(t, response));
+    }
+  }
+
+  private Object nextEvent() {
+    try {
+      Object event = events.poll(10, TimeUnit.SECONDS);
+      if (event == null) {
+        throw new AssertionError("Timed out waiting for event.");
+      }
+      return event;
+    } catch (InterruptedException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  public void assertTextMessage(String payload) {
+    Message message = new Message(TEXT);
+    message.buffer.writeUtf8(payload);
+    Object actual = nextEvent();
+    assertEquals(message, actual);
+  }
+
+  public void assertBinaryMessage(byte[] payload) {
+    Message message = new Message(BINARY);
+    message.buffer.write(payload);
+    Object actual = nextEvent();
+    assertEquals(message, actual);
+  }
+
+  public void assertPong(ByteString payload) {
+    Object actual = nextEvent();
+    assertEquals(new Pong(payload), actual);
+  }
+
+  public void assertClose(int code, String reason) {
+    Object actual = nextEvent();
+    assertEquals(new Close(code, reason), actual);
+  }
+
+  public void assertExhausted() {
+    assertTrue("Remaining events: " + events, events.isEmpty());
+  }
+
+  public WebSocket assertOpen() {
+    Object event = nextEvent();
+    if (!(event instanceof Open)) {
+      throw new AssertionError("Expected Open but was " + event);
+    }
+    return ((Open) event).webSocket;
+  }
+
+  public void assertFailure(Throwable t) {
+    Object event = nextEvent();
+    if (!(event instanceof Failure)) {
+      throw new AssertionError("Expected Failure but was " + event);
+    }
+    Failure failure = (Failure) event;
+    assertNull(failure.response);
+    assertSame(t, failure.t);
+  }
+
+  public void assertFailure(Class<? extends IOException> cls, String message) {
+    Object event = nextEvent();
+    if (!(event instanceof Failure)) {
+      throw new AssertionError("Expected Failure but was " + event);
+    }
+    Failure failure = (Failure) event;
+    assertNull(failure.response);
+    assertEquals(cls, failure.t.getClass());
+    assertEquals(message, failure.t.getMessage());
+  }
+
+  public void assertFailure(int code, String body, Class<? extends IOException> cls, String message)
+      throws IOException {
+    Object event = nextEvent();
+    if (!(event instanceof Failure)) {
+      throw new AssertionError("Expected Failure but was " + event);
+    }
+    Failure failure = (Failure) event;
+    assertEquals(code, failure.response.code());
+    if (body != null) {
+      assertEquals(body, failure.response.body().string());
+    }
+    assertEquals(cls, failure.t.getClass());
+    assertEquals(message, failure.t.getMessage());
+  }
+
+  static final class Open {
+    final WebSocket webSocket;
+    final Response response;
+
+    Open(WebSocket webSocket, Response response) {
+      this.webSocket = webSocket;
+      this.response = response;
+    }
+
+    @Override public String toString() {
+      return "Open[" + response + "]";
+    }
+  }
+
+  static final class Failure {
+    final Throwable t;
+    final Response response;
+
+    Failure(Throwable t, Response response) {
+      this.t = t;
+      this.response = response;
+    }
+
+    @Override public String toString() {
+      if (response == null) {
+        return "Failure[" + t + "]";
+      }
+      return "Failure[" + response + "]";
+    }
+  }
+
+  static final class Message {
+    public final MediaType mediaType;
+    public final Buffer buffer = new Buffer();
+
+    Message(MediaType mediaType) {
+      this.mediaType = mediaType;
+    }
+
+    @Override public String toString() {
+      return "Message[" + mediaType + " " + buffer + "]";
+    }
+
+    @Override public int hashCode() {
+      return mediaType.hashCode() * 37 + buffer.hashCode();
+    }
+
+    @Override public boolean equals(Object obj) {
+      if (obj instanceof Message) {
+        Message other = (Message) obj;
+        return mediaType.equals(other.mediaType) && buffer.equals(other.buffer);
+      }
+      return false;
+    }
+  }
+
+  static final class Pong {
+    public final ByteString payload;
+
+    Pong(ByteString payload) {
+      this.payload = payload;
+    }
+
+    @Override public String toString() {
+      return "Pong[" + payload + "]";
+    }
+
+    @Override public int hashCode() {
+      return payload.hashCode();
+    }
+
+    @Override public boolean equals(Object obj) {
+      if (obj instanceof Pong) {
+        Pong other = (Pong) obj;
+        return payload == null ? other.payload == null : payload.equals(other.payload);
+      }
+      return false;
+    }
+  }
+
+  static final class Close {
+    public final int code;
+    public final String reason;
+
+    Close(int code, String reason) {
+      this.code = code;
+      this.reason = reason;
+    }
+
+    @Override public String toString() {
+      return "Close[" + code + " " + reason + "]";
+    }
+
+    @Override public int hashCode() {
+      return code * 37 + reason.hashCode();
+    }
+
+    @Override public boolean equals(Object obj) {
+      if (obj instanceof Close) {
+        Close other = (Close) obj;
+        return code == other.code && reason.equals(other.reason);
+      }
+      return false;
+    }
+  }
+
+  /** Expose this recorder as a frame callback and shim in "ping" events. */
+  WebSocketReader.FrameCallback asFrameCallback() {
+    return new WebSocketReader.FrameCallback() {
+      @Override public void onReadMessage(ResponseBody body) throws IOException {
+        onMessage(body);
+      }
+
+      @Override public void onReadPing(ByteString payload) {
+        events.add(new Ping(payload));
+      }
+
+      @Override public void onReadPong(ByteString padload) {
+        onPong(padload);
+      }
+
+      @Override public void onReadClose(int code, String reason) {
+        onClose(code, reason);
+      }
+    };
+  }
+
+  void assertPing(ByteString payload) {
+    Object actual = nextEvent();
+    assertEquals(new Ping(payload), actual);
+  }
+
+  static final class Ping {
+    public final ByteString buffer;
+
+    Ping(ByteString buffer) {
+      this.buffer = buffer;
+    }
+
+    @Override public String toString() {
+      return "Ping[" + buffer + "]";
+    }
+
+    @Override public int hashCode() {
+      return buffer.hashCode();
+    }
+
+    @Override public boolean equals(Object obj) {
+      if (obj instanceof Ping) {
+        Ping other = (Ping) obj;
+        return buffer == null ? other.buffer == null : buffer.equals(other.buffer);
+      }
+      return false;
+    }
+  }
+}
diff --git a/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
similarity index 91%
rename from okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
index 66475fb7b0..bb4d43ec10 100644
--- a/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
@@ -19,6 +19,7 @@
 import java.io.IOException;
 import java.util.Random;
 import okhttp3.RequestBody;
+import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.ByteString;
@@ -99,7 +100,7 @@
     sink.close();
 
     assertData("817e");
-    assertData(String.format("%04x", length));
+    assertData(Util.format("%04x", length));
     assertData(bytes);
     assertTrue(data.exhausted());
   }
@@ -117,16 +118,16 @@
     sink.write(body.readByteString(20_000));
     sink.close();
 
-    assertData("017e4800");
-    assertData(bytes.readByteArray(18_432));
-    assertData("007e5000");
-    assertData(bytes.readByteArray(20_480));
-    assertData("007e5000");
-    assertData(bytes.readByteArray(20_480));
-    assertData("007e5000");
-    assertData(bytes.readByteArray(20_480));
-    assertData("007e4800");
-    assertData(bytes.readByteArray(18_432));
+    assertData("017e4000");
+    assertData(bytes.readByteArray(16_384));
+    assertData("007e4000");
+    assertData(bytes.readByteArray(16_384));
+    assertData("007e6000");
+    assertData(bytes.readByteArray(24_576));
+    assertData("007e4000");
+    assertData(bytes.readByteArray(16_384));
+    assertData("007e6000");
+    assertData(bytes.readByteArray(24_576));
     assertData("807e06a0");
     assertData(bytes.readByteArray(1_696));
     assertTrue(data.exhausted());
@@ -199,7 +200,7 @@
     // Write directly to the unbuffered sink. This ensures it will become single frame.
     sink.write(payload.clone(), byteCount);
     assertData("027e"); // 'e' == 4-byte follow-up length.
-    assertData(String.format("%04X", payload.completeSegmentByteCount()));
+    assertData(Util.format("%04X", payload.completeSegmentByteCount()));
     assertData(payload.readByteArray());
 
     sink.close();
@@ -219,7 +220,7 @@
     // Write directly to the unbuffered sink. This ensures it will become single frame.
     sink.write(payload.clone(), byteCount);
     assertData("027f"); // 'f' == 16-byte follow-up length.
-    assertData(String.format("%016X", byteCount));
+    assertData(Util.format("%016X", byteCount));
     assertData(payload.readByteArray(byteCount));
 
     sink.close();
@@ -305,48 +306,48 @@
   }
 
   @Test public void serverEmptyPing() throws IOException {
-    serverWriter.writePing(null);
+    serverWriter.writePing(ByteString.EMPTY);
     assertData("8900");
   }
 
   @Test public void clientEmptyPing() throws IOException {
-    clientWriter.writePing(null);
+    clientWriter.writePing(ByteString.EMPTY);
     assertData("898060b420bb");
   }
 
   @Test public void serverPingWithPayload() throws IOException {
-    serverWriter.writePing(new Buffer().writeUtf8("Hello"));
+    serverWriter.writePing(ByteString.encodeUtf8("Hello"));
     assertData("890548656c6c6f");
   }
 
   @Test public void clientPingWithPayload() throws IOException {
-    clientWriter.writePing(new Buffer().writeUtf8("Hello"));
+    clientWriter.writePing(ByteString.encodeUtf8("Hello"));
     assertData("898560b420bb28d14cd70f");
   }
 
   @Test public void serverEmptyPong() throws IOException {
-    serverWriter.writePong(null);
+    serverWriter.writePong(ByteString.EMPTY);
     assertData("8a00");
   }
 
   @Test public void clientEmptyPong() throws IOException {
-    clientWriter.writePong(null);
+    clientWriter.writePong(ByteString.EMPTY);
     assertData("8a8060b420bb");
   }
 
   @Test public void serverPongWithPayload() throws IOException {
-    serverWriter.writePong(new Buffer().writeUtf8("Hello"));
+    serverWriter.writePong(ByteString.encodeUtf8("Hello"));
     assertData("8a0548656c6c6f");
   }
 
   @Test public void clientPongWithPayload() throws IOException {
-    clientWriter.writePong(new Buffer().writeUtf8("Hello"));
+    clientWriter.writePong(ByteString.encodeUtf8("Hello"));
     assertData("8a8560b420bb28d14cd70f");
   }
 
   @Test public void pingTooLongThrows() throws IOException {
     try {
-      serverWriter.writePing(new Buffer().write(binaryData(1000)));
+      serverWriter.writePing(ByteString.of(binaryData(1000)));
       fail();
     } catch (IllegalArgumentException e) {
       assertEquals("Payload size must be less than or equal to 125", e.getMessage());
@@ -355,7 +356,7 @@
 
   @Test public void pongTooLongThrows() throws IOException {
     try {
-      serverWriter.writePong(new Buffer().write(binaryData(1000)));
+      serverWriter.writePong(ByteString.of(binaryData(1000)));
       fail();
     } catch (IllegalArgumentException e) {
       assertEquals("Payload size must be less than or equal to 125", e.getMessage());
diff --git a/okhttp-urlconnection/pom.xml b/okhttp-urlconnection/pom.xml
index 2c95ffc6c2..bde049037c 100644
--- a/okhttp-urlconnection/pom.xml
+++ b/okhttp-urlconnection/pom.xml
@@ -6,13 +6,19 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.3.0-SNAPSHOT</version>
+    <version>3.5.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-urlconnection</artifactId>
   <name>OkHttp URLConnection</name>
 
   <dependencies>
+    <dependency>
+      <groupId>org.codehaus.mojo</groupId>
+      <artifactId>animal-sniffer-annotations</artifactId>
+      <version>${animal.sniffer.version}</version>
+      <optional>true</optional>
+    </dependency>
     <dependency>
       <groupId>${project.groupId}</groupId>
       <artifactId>okhttp</artifactId>
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java
index 3d9daf64b8..5d4f671a31 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java
@@ -22,11 +22,11 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
-import okhttp3.internal.Internal;
+import okhttp3.internal.platform.Platform;
 
-import static java.util.logging.Level.WARNING;
 import static okhttp3.internal.Util.delimiterOffset;
 import static okhttp3.internal.Util.trimSubstring;
+import static okhttp3.internal.platform.Platform.WARN;
 
 /** A cookie jar that delegates to a {@link java.net.CookieHandler}. */
 public final class JavaNetCookieJar implements CookieJar {
@@ -40,13 +40,13 @@ public JavaNetCookieJar(CookieHandler cookieHandler) {
     if (cookieHandler != null) {
       List<String> cookieStrings = new ArrayList<>();
       for (Cookie cookie : cookies) {
-        cookieStrings.add(cookie.toString());
+        cookieStrings.add(cookie.toString(true));
       }
       Map<String, List<String>> multimap = Collections.singletonMap("Set-Cookie", cookieStrings);
       try {
         cookieHandler.put(url.uri(), multimap);
       } catch (IOException e) {
-        Internal.logger.log(WARNING, "Saving cookies failed for " + url.resolve("/..."), e);
+        Platform.get().log(WARN, "Saving cookies failed for " + url.resolve("/..."), e);
       }
     }
   }
@@ -58,7 +58,7 @@ public JavaNetCookieJar(CookieHandler cookieHandler) {
     try {
       cookieHeaders = cookieHandler.get(url.uri(), headers);
     } catch (IOException e) {
-      Internal.logger.log(WARNING, "Loading cookies failed for " + url.resolve("/..."), e);
+      Platform.get().log(WARN, "Loading cookies failed for " + url.resolve("/..."), e);
       return Collections.emptyList();
     }
 
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/OkUrlFactory.java b/okhttp-urlconnection/src/main/java/okhttp3/OkUrlFactory.java
index 973c70578b..0bbe613492 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/OkUrlFactory.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/OkUrlFactory.java
@@ -22,8 +22,8 @@
 import java.net.URLStreamHandler;
 import java.net.URLStreamHandlerFactory;
 import okhttp3.internal.URLFilter;
-import okhttp3.internal.huc.HttpURLConnectionImpl;
-import okhttp3.internal.huc.HttpsURLConnectionImpl;
+import okhttp3.internal.huc.OkHttpURLConnection;
+import okhttp3.internal.huc.OkHttpsURLConnection;
 
 /**
  * @deprecated OkHttp will be dropping its ability to be used with {@link HttpURLConnection} in an
@@ -69,8 +69,8 @@ HttpURLConnection open(URL url, Proxy proxy) {
         .proxy(proxy)
         .build();
 
-    if (protocol.equals("http")) return new HttpURLConnectionImpl(url, copy, urlFilter);
-    if (protocol.equals("https")) return new HttpsURLConnectionImpl(url, copy, urlFilter);
+    if (protocol.equals("http")) return new OkHttpURLConnection(url, copy, urlFilter);
+    if (protocol.equals("https")) return new OkHttpsURLConnection(url, copy, urlFilter);
     throw new IllegalArgumentException("Unexpected protocol: " + protocol);
   }
 
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/SystemPropertiesConnectionPool.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/SystemPropertiesConnectionPool.java
deleted file mode 100644
index e0c9523fb0..0000000000
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/SystemPropertiesConnectionPool.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package okhttp3.internal;
-
-import java.util.concurrent.TimeUnit;
-import okhttp3.ConnectionPool;
-
-/**
- * A shared connection pool that uses system properties for tuning parameters:
- *
- * <ul>
- *     <li>{@code http.keepAlive} true if HTTP and SPDY connections should be pooled at all. Default
- *         is true.
- *     <li>{@code http.maxConnections} maximum number of idle connections to each to keep in the
- *         pool. Default is 5.
- *     <li>{@code http.keepAliveDuration} Time in milliseconds to keep the connection alive in the
- *         pool before closing it. Default is 5 minutes. This property isn't used by {@code
- *         HttpURLConnection}.
- * </ul>
- *
- * <p>The default instance <i>doesn't</i> adjust its configuration as system properties are changed.
- * This assumes that the applications that set these parameters do so before making HTTP
- * connections, and that this class is initialized lazily.
- */
-public final class SystemPropertiesConnectionPool {
-  private static final long DEFAULT_KEEP_ALIVE_DURATION_MS = 5 * 60 * 1000; // 5 min
-
-  public static final ConnectionPool INSTANCE;
-  static {
-    String keepAlive = System.getProperty("http.keepAlive");
-    int maxIdleConnections;
-    if (keepAlive != null && !Boolean.parseBoolean(keepAlive)) {
-      maxIdleConnections = 0;
-    } else {
-      String maxIdleConnectionsString = System.getProperty("http.maxConnections");
-      if (maxIdleConnectionsString != null) {
-        maxIdleConnections = Integer.parseInt(maxIdleConnectionsString);
-      } else {
-        maxIdleConnections = 5;
-      }
-    }
-
-    String keepAliveDurationString = System.getProperty("http.keepAliveDuration");
-    long keepAliveDurationMs = keepAliveDurationString != null
-        ? Long.parseLong(keepAliveDurationString)
-        : DEFAULT_KEEP_ALIVE_DURATION_MS;
-
-    INSTANCE = new ConnectionPool(maxIdleConnections, keepAliveDurationMs, TimeUnit.MILLISECONDS);
-  }
-
-  private SystemPropertiesConnectionPool() {
-  }
-}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/BufferedRequestBody.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/BufferedRequestBody.java
new file mode 100644
index 0000000000..b4b2f68347
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/BufferedRequestBody.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.huc;
+
+import java.io.IOException;
+import okhttp3.Request;
+import okio.Buffer;
+import okio.BufferedSink;
+
+/**
+ * This request body involves an application thread only. First all bytes are written to the buffer.
+ * Only once that is complete are bytes then copied to the network.
+ *
+ * <p>This body has two special powers. First, it can retransmit the same request body multiple
+ * times in order to recover from failures or cope with redirects. Second, it can compute the total
+ * length of the request body by measuring it after it has been written to the output stream.
+ */
+final class BufferedRequestBody extends OutputStreamRequestBody {
+  final Buffer buffer = new Buffer();
+  long contentLength = -1L;
+
+  BufferedRequestBody(long expectedContentLength) {
+    initOutputStream(buffer, expectedContentLength);
+  }
+
+  @Override public long contentLength() throws IOException {
+    return contentLength;
+  }
+
+  /**
+   * Now that we've buffered the entire request body, update the request headers and the body
+   * itself. This happens late to enable HttpURLConnection users to complete the socket connection
+   * before sending request body bytes.
+   */
+  @Override public Request prepareToSendRequest(Request request) throws IOException {
+    if (request.header("Content-Length") != null) return request;
+
+    outputStream().close();
+    contentLength = buffer.size();
+    return request.newBuilder()
+        .removeHeader("Transfer-Encoding")
+        .header("Content-Length", Long.toString(buffer.size()))
+        .build();
+  }
+
+  @Override public void writeTo(BufferedSink sink) throws IOException {
+    buffer.copyTo(sink.buffer(), 0, buffer.size());
+  }
+}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/DelegatingHttpsURLConnection.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/DelegatingHttpsURLConnection.java
index 86f4aa7807..9dd7cfd0b1 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/DelegatingHttpsURLConnection.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/DelegatingHttpsURLConnection.java
@@ -32,6 +32,7 @@
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSocketFactory;
 import okhttp3.Handshake;
+import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
 
 /**
  * Implement an HTTPS connection by delegating to an HTTP connection for everything but the
@@ -146,6 +147,11 @@ public DelegatingHttpsURLConnection(HttpURLConnection delegate) {
     return delegate.getContentLength();
   }
 
+  @IgnoreJRERequirement // Should only be invoked on Java 7+.
+  @Override public long getContentLengthLong() {
+    return delegate.getContentLengthLong();
+  }
+
   @Override public String getContentType() {
     return delegate.getContentType();
   }
@@ -190,6 +196,11 @@ public DelegatingHttpsURLConnection(HttpURLConnection delegate) {
     return delegate.getHeaderField(key);
   }
 
+  @IgnoreJRERequirement // Should only be invoked on Java 7+.
+  @Override public long getHeaderFieldLong(String field, long defaultValue) {
+    return delegate.getHeaderFieldLong(field, defaultValue);
+  }
+
   @Override public long getHeaderFieldDate(String field, long defaultValue) {
     return delegate.getHeaderFieldDate(field, defaultValue);
   }
@@ -250,6 +261,11 @@ public DelegatingHttpsURLConnection(HttpURLConnection delegate) {
     delegate.setDoOutput(newValue);
   }
 
+  @IgnoreJRERequirement // Should only be invoked on Java 7+.
+  @Override public void setFixedLengthStreamingMode(long contentLength) {
+    delegate.setFixedLengthStreamingMode(contentLength);
+  }
+
   @Override public void setIfModifiedSince(long newValue) {
     delegate.setIfModifiedSince(newValue);
   }
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java
deleted file mode 100644
index 65ca6ae400..0000000000
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java
+++ /dev/null
@@ -1,652 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package okhttp3.internal.huc;
-
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.HttpRetryException;
-import java.net.HttpURLConnection;
-import java.net.InetSocketAddress;
-import java.net.MalformedURLException;
-import java.net.ProtocolException;
-import java.net.Proxy;
-import java.net.SocketPermission;
-import java.net.URL;
-import java.net.UnknownHostException;
-import java.security.Permission;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Date;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.TimeUnit;
-import okhttp3.Connection;
-import okhttp3.Handshake;
-import okhttp3.Headers;
-import okhttp3.HttpUrl;
-import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.Route;
-import okhttp3.internal.Internal;
-import okhttp3.internal.JavaNetHeaders;
-import okhttp3.internal.Platform;
-import okhttp3.internal.URLFilter;
-import okhttp3.internal.Util;
-import okhttp3.internal.Version;
-import okhttp3.internal.http.HttpDate;
-import okhttp3.internal.http.HttpEngine;
-import okhttp3.internal.http.HttpMethod;
-import okhttp3.internal.http.OkHeaders;
-import okhttp3.internal.http.RequestException;
-import okhttp3.internal.http.RetryableSink;
-import okhttp3.internal.http.RouteException;
-import okhttp3.internal.http.StatusLine;
-import okhttp3.internal.http.StreamAllocation;
-import okio.BufferedSink;
-import okio.Sink;
-
-/**
- * This implementation uses HttpEngine to send requests and receive responses. This class may use
- * multiple HttpEngines to follow redirects, authentication retries, etc. to retrieve the final
- * response body.
- *
- * <h3>What does 'connected' mean?</h3> This class inherits a {@code connected} field from the
- * superclass. That field is <strong>not</strong> used to indicate whether this URLConnection is
- * currently connected. Instead, it indicates whether a connection has ever been attempted. Once a
- * connection has been attempted, certain properties (request header fields, request method, etc.)
- * are immutable.
- */
-public class HttpURLConnectionImpl extends HttpURLConnection {
-  private static final Set<String> METHODS = new LinkedHashSet<>(
-      Arrays.asList("OPTIONS", "GET", "HEAD", "POST", "PUT", "DELETE", "TRACE", "PATCH"));
-  private static final RequestBody EMPTY_REQUEST_BODY = RequestBody.create(null, new byte[0]);
-
-  OkHttpClient client;
-
-  private Headers.Builder requestHeaders = new Headers.Builder();
-
-  /** Like the superclass field of the same name, but a long and available on all platforms. */
-  private long fixedContentLength = -1;
-  private int followUpCount;
-  protected IOException httpEngineFailure;
-  protected HttpEngine httpEngine;
-  /** Lazily created (with synthetic headers) on first call to getHeaders(). */
-  private Headers responseHeaders;
-
-  /**
-   * The most recently attempted route. This will be null if we haven't sent a request yet, or if
-   * the response comes from a cache.
-   */
-  private Route route;
-
-  /**
-   * The most recently received TLS handshake. This will be null if we haven't connected yet, or if
-   * the most recent connection was HTTP (and not HTTPS).
-   */
-  Handshake handshake;
-
-  private URLFilter urlFilter;
-
-  public HttpURLConnectionImpl(URL url, OkHttpClient client) {
-    super(url);
-    this.client = client;
-  }
-
-  public HttpURLConnectionImpl(URL url, OkHttpClient client, URLFilter urlFilter) {
-    this(url, client);
-    this.urlFilter = urlFilter;
-  }
-
-  @Override public final void connect() throws IOException {
-    initHttpEngine();
-    boolean success;
-    do {
-      success = execute(false);
-    } while (!success);
-  }
-
-  @Override public final void disconnect() {
-    // Calling disconnect() before a connection exists should have no effect.
-    if (httpEngine == null) return;
-
-    httpEngine.cancel();
-
-    // This doesn't close the stream because doing so would require all stream
-    // access to be synchronized. It's expected that the thread using the
-    // connection will close its streams directly. If it doesn't, the worst
-    // case is that the GzipSource's Inflater won't be released until it's
-    // finalized. (This logs a warning on Android.)
-  }
-
-  /**
-   * Returns an input stream from the server in the case of error such as the requested file (txt,
-   * htm, html) is not found on the remote server.
-   */
-  @Override public final InputStream getErrorStream() {
-    try {
-      HttpEngine response = getResponse();
-      if (HttpEngine.hasBody(response.getResponse())
-          && response.getResponse().code() >= HTTP_BAD_REQUEST) {
-        return response.getResponse().body().byteStream();
-      }
-      return null;
-    } catch (IOException e) {
-      return null;
-    }
-  }
-
-  private Headers getHeaders() throws IOException {
-    if (responseHeaders == null) {
-      Response response = getResponse().getResponse();
-      Headers headers = response.headers();
-      responseHeaders = headers.newBuilder()
-          .add(OkHeaders.SELECTED_PROTOCOL, response.protocol().toString())
-          .add(OkHeaders.RESPONSE_SOURCE, responseSourceHeader(response))
-          .build();
-    }
-    return responseHeaders;
-  }
-
-  private static String responseSourceHeader(Response response) {
-    if (response.networkResponse() == null) {
-      if (response.cacheResponse() == null) {
-        return "NONE";
-      }
-      return "CACHE " + response.code();
-    }
-    if (response.cacheResponse() == null) {
-      return "NETWORK " + response.code();
-    }
-    return "CONDITIONAL_CACHE " + response.networkResponse().code();
-  }
-
-  /**
-   * Returns the value of the field at {@code position}. Returns null if there are fewer than {@code
-   * position} headers.
-   */
-  @Override public final String getHeaderField(int position) {
-    try {
-      Headers headers = getHeaders();
-      if (position < 0 || position >= headers.size()) return null;
-      return headers.value(position);
-    } catch (IOException e) {
-      return null;
-    }
-  }
-
-  /**
-   * Returns the value of the field corresponding to the {@code fieldName}, or null if there is no
-   * such field. If the field has multiple values, the last value is returned.
-   */
-  @Override public final String getHeaderField(String fieldName) {
-    try {
-      return fieldName == null
-          ? StatusLine.get(getResponse().getResponse()).toString()
-          : getHeaders().get(fieldName);
-    } catch (IOException e) {
-      return null;
-    }
-  }
-
-  @Override public final String getHeaderFieldKey(int position) {
-    try {
-      Headers headers = getHeaders();
-      if (position < 0 || position >= headers.size()) return null;
-      return headers.name(position);
-    } catch (IOException e) {
-      return null;
-    }
-  }
-
-  @Override public final Map<String, List<String>> getHeaderFields() {
-    try {
-      return JavaNetHeaders.toMultimap(getHeaders(),
-          StatusLine.get(getResponse().getResponse()).toString());
-    } catch (IOException e) {
-      return Collections.emptyMap();
-    }
-  }
-
-  @Override public final Map<String, List<String>> getRequestProperties() {
-    if (connected) {
-      throw new IllegalStateException(
-          "Cannot access request header fields after connection is set");
-    }
-
-    return JavaNetHeaders.toMultimap(requestHeaders.build(), null);
-  }
-
-  @Override public final InputStream getInputStream() throws IOException {
-    if (!doInput) {
-      throw new ProtocolException("This protocol does not support input");
-    }
-
-    HttpEngine response = getResponse();
-
-    // if the requested file does not exist, throw an exception formerly the
-    // Error page from the server was returned if the requested file was
-    // text/html this has changed to return FileNotFoundException for all
-    // file types
-    if (getResponseCode() >= HTTP_BAD_REQUEST) {
-      throw new FileNotFoundException(url.toString());
-    }
-
-    return response.getResponse().body().byteStream();
-  }
-
-  @Override public final OutputStream getOutputStream() throws IOException {
-    connect();
-
-    BufferedSink sink = httpEngine.getBufferedRequestBody();
-    if (sink == null) {
-      throw new ProtocolException("method does not support a request body: " + method);
-    } else if (httpEngine.hasResponse()) {
-      throw new ProtocolException("cannot write request body after response has been read");
-    }
-
-    return sink.outputStream();
-  }
-
-  @Override public final Permission getPermission() throws IOException {
-    URL url = getURL();
-    String hostname = url.getHost();
-    int hostPort = url.getPort() != -1
-        ? url.getPort()
-        : HttpUrl.defaultPort(url.getProtocol());
-    if (usingProxy()) {
-      InetSocketAddress proxyAddress = (InetSocketAddress) client.proxy().address();
-      hostname = proxyAddress.getHostName();
-      hostPort = proxyAddress.getPort();
-    }
-    return new SocketPermission(hostname + ":" + hostPort, "connect, resolve");
-  }
-
-  @Override public final String getRequestProperty(String field) {
-    if (field == null) return null;
-    return requestHeaders.get(field);
-  }
-
-  @Override public void setConnectTimeout(int timeoutMillis) {
-    client = client.newBuilder()
-        .connectTimeout(timeoutMillis, TimeUnit.MILLISECONDS)
-        .build();
-  }
-
-  @Override
-  public void setInstanceFollowRedirects(boolean followRedirects) {
-    client = client.newBuilder()
-        .followRedirects(followRedirects)
-        .build();
-  }
-
-  @Override public boolean getInstanceFollowRedirects() {
-    return client.followRedirects();
-  }
-
-  @Override public int getConnectTimeout() {
-    return client.connectTimeoutMillis();
-  }
-
-  @Override public void setReadTimeout(int timeoutMillis) {
-    client = client.newBuilder()
-        .readTimeout(timeoutMillis, TimeUnit.MILLISECONDS)
-        .build();
-  }
-
-  @Override public int getReadTimeout() {
-    return client.readTimeoutMillis();
-  }
-
-  private void initHttpEngine() throws IOException {
-    if (httpEngineFailure != null) {
-      throw httpEngineFailure;
-    } else if (httpEngine != null) {
-      return;
-    }
-
-    connected = true;
-    try {
-      if (doOutput) {
-        if (method.equals("GET")) {
-          // they are requesting a stream to write to. This implies a POST method
-          method = "POST";
-        } else if (!HttpMethod.permitsRequestBody(method)) {
-          throw new ProtocolException(method + " does not support writing");
-        }
-      }
-      // If the user set content length to zero, we know there will not be a request body.
-      httpEngine = newHttpEngine(method, null, null, null);
-    } catch (IOException e) {
-      httpEngineFailure = e;
-      throw e;
-    }
-  }
-
-  private HttpEngine newHttpEngine(String method, StreamAllocation streamAllocation,
-      RetryableSink requestBody, Response priorResponse)
-      throws MalformedURLException, UnknownHostException {
-    // OkHttp's Call API requires a placeholder body; the real body will be streamed separately.
-    RequestBody placeholderBody = HttpMethod.requiresRequestBody(method)
-        ? EMPTY_REQUEST_BODY
-        : null;
-    URL url = getURL();
-    HttpUrl httpUrl = Internal.instance.getHttpUrlChecked(url.toString());
-    Request.Builder builder = new Request.Builder()
-        .url(httpUrl)
-        .method(method, placeholderBody);
-    Headers headers = requestHeaders.build();
-    for (int i = 0, size = headers.size(); i < size; i++) {
-      builder.addHeader(headers.name(i), headers.value(i));
-    }
-
-    boolean bufferRequestBody = false;
-    if (HttpMethod.permitsRequestBody(method)) {
-      // Specify how the request body is terminated.
-      if (fixedContentLength != -1) {
-        builder.header("Content-Length", Long.toString(fixedContentLength));
-      } else if (chunkLength > 0) {
-        builder.header("Transfer-Encoding", "chunked");
-      } else {
-        bufferRequestBody = true;
-      }
-
-      // Add a content type for the request body, if one isn't already present.
-      if (headers.get("Content-Type") == null) {
-        builder.header("Content-Type", "application/x-www-form-urlencoded");
-      }
-    }
-
-    if (headers.get("User-Agent") == null) {
-      builder.header("User-Agent", defaultUserAgent());
-    }
-
-    Request request = builder.build();
-
-    // If we're currently not using caches, make sure the engine's client doesn't have one.
-    OkHttpClient engineClient = client;
-    if (Internal.instance.internalCache(engineClient) != null && !getUseCaches()) {
-      engineClient = client.newBuilder()
-          .cache(null)
-          .build();
-    }
-
-    return new HttpEngine(engineClient, request, bufferRequestBody, true, false, streamAllocation,
-        requestBody, priorResponse);
-  }
-
-  private String defaultUserAgent() {
-    String agent = System.getProperty("http.agent");
-    return agent != null ? Util.toHumanReadableAscii(agent) : Version.userAgent();
-  }
-
-  /**
-   * Aggressively tries to get the final HTTP response, potentially making many HTTP requests in the
-   * process in order to cope with redirects and authentication.
-   */
-  private HttpEngine getResponse() throws IOException {
-    initHttpEngine();
-
-    if (httpEngine.hasResponse()) {
-      return httpEngine;
-    }
-
-    while (true) {
-      if (!execute(true)) {
-        continue;
-      }
-
-      Response response = httpEngine.getResponse();
-      Request followUp = httpEngine.followUpRequest();
-
-      if (followUp == null) {
-        httpEngine.releaseStreamAllocation();
-        return httpEngine;
-      }
-
-      if (++followUpCount > HttpEngine.MAX_FOLLOW_UPS) {
-        throw new ProtocolException("Too many follow-up requests: " + followUpCount);
-      }
-
-      // The first request was insufficient. Prepare for another...
-      url = followUp.url().url();
-      requestHeaders = followUp.headers().newBuilder();
-
-      // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM redirect
-      // should keep the same method, Chrome, Firefox and the RI all issue GETs
-      // when following any redirect.
-      Sink requestBody = httpEngine.getRequestBody();
-      if (!followUp.method().equals(method)) {
-        requestBody = null;
-      }
-
-      if (requestBody != null && !(requestBody instanceof RetryableSink)) {
-        throw new HttpRetryException("Cannot retry streamed HTTP body", responseCode);
-      }
-
-      StreamAllocation streamAllocation = httpEngine.close();
-      if (!httpEngine.sameConnection(followUp.url())) {
-        streamAllocation.release();
-        streamAllocation = null;
-      }
-
-      httpEngine = newHttpEngine(followUp.method(), streamAllocation, (RetryableSink) requestBody,
-          response);
-    }
-  }
-
-  /**
-   * Sends a request and optionally reads a response. Returns true if the request was successfully
-   * executed, and false if the request can be retried. Throws an exception if the request failed
-   * permanently.
-   */
-  private boolean execute(boolean readResponse) throws IOException {
-    boolean releaseConnection = true;
-    if (urlFilter != null) {
-      urlFilter.checkURLPermitted(httpEngine.getRequest().url().url());
-    }
-    try {
-      httpEngine.sendRequest();
-      Connection connection = httpEngine.getConnection();
-      if (connection != null) {
-        route = connection.route();
-        handshake = connection.handshake();
-      } else {
-        route = null;
-        handshake = null;
-      }
-      if (readResponse) {
-        httpEngine.readResponse();
-      }
-      releaseConnection = false;
-
-      return true;
-    } catch (RequestException e) {
-      // An attempt to interpret a request failed.
-      IOException toThrow = e.getCause();
-      httpEngineFailure = toThrow;
-      throw toThrow;
-    } catch (RouteException e) {
-      // The attempt to connect via a route failed. The request will not have been sent.
-      HttpEngine retryEngine = httpEngine.recover(e.getLastConnectException(), true);
-      if (retryEngine != null) {
-        releaseConnection = false;
-        httpEngine = retryEngine;
-        return false;
-      }
-
-      // Give up; recovery is not possible.
-      IOException toThrow = e.getLastConnectException();
-      httpEngineFailure = toThrow;
-      throw toThrow;
-    } catch (IOException e) {
-      // An attempt to communicate with a server failed. The request may have been sent.
-      HttpEngine retryEngine = httpEngine.recover(e, false);
-      if (retryEngine != null) {
-        releaseConnection = false;
-        httpEngine = retryEngine;
-        return false;
-      }
-
-      // Give up; recovery is not possible.
-      httpEngineFailure = e;
-      throw e;
-    } finally {
-      // We're throwing an unchecked exception. Release any resources.
-      if (releaseConnection) {
-        StreamAllocation streamAllocation = httpEngine.close();
-        streamAllocation.release();
-      }
-    }
-  }
-
-  /**
-   * Returns true if either:
-   *
-   * <ul>
-   *   <li>A specific proxy was explicitly configured for this connection.
-   *   <li>The response has already been retrieved, and a proxy was {@link
-   *       java.net.ProxySelector selected} in order to get it.
-   * </ul>
-   *
-   * <p><strong>Warning:</strong> This method may return false before attempting to connect and true
-   * afterwards.
-   */
-  @Override public final boolean usingProxy() {
-    Proxy proxy = route != null
-        ? route.proxy()
-        : client.proxy();
-    return proxy != null && proxy.type() != Proxy.Type.DIRECT;
-  }
-
-  @Override public String getResponseMessage() throws IOException {
-    return getResponse().getResponse().message();
-  }
-
-  @Override public final int getResponseCode() throws IOException {
-    return getResponse().getResponse().code();
-  }
-
-  @Override public final void setRequestProperty(String field, String newValue) {
-    if (connected) {
-      throw new IllegalStateException("Cannot set request property after connection is made");
-    }
-    if (field == null) {
-      throw new NullPointerException("field == null");
-    }
-    if (newValue == null) {
-      // Silently ignore null header values for backwards compatibility with older
-      // android versions as well as with other URLConnection implementations.
-      //
-      // Some implementations send a malformed HTTP header when faced with
-      // such requests, we respect the spec and ignore the header.
-      Platform.get().logW("Ignoring header " + field + " because its value was null.");
-      return;
-    }
-
-    // TODO: Deprecate use of X-Android-Transports header?
-    if ("X-Android-Transports".equals(field) || "X-Android-Protocols".equals(field)) {
-      setProtocols(newValue, false /* append */);
-    } else {
-      requestHeaders.set(field, newValue);
-    }
-  }
-
-  @Override public void setIfModifiedSince(long newValue) {
-    super.setIfModifiedSince(newValue);
-    if (ifModifiedSince != 0) {
-      requestHeaders.set("If-Modified-Since", HttpDate.format(new Date(ifModifiedSince)));
-    } else {
-      requestHeaders.removeAll("If-Modified-Since");
-    }
-  }
-
-  @Override public final void addRequestProperty(String field, String value) {
-    if (connected) {
-      throw new IllegalStateException("Cannot add request property after connection is made");
-    }
-    if (field == null) {
-      throw new NullPointerException("field == null");
-    }
-    if (value == null) {
-      // Silently ignore null header values for backwards compatibility with older
-      // android versions as well as with other URLConnection implementations.
-      //
-      // Some implementations send a malformed HTTP header when faced with
-      // such requests, we respect the spec and ignore the header.
-      Platform.get().logW("Ignoring header " + field + " because its value was null.");
-      return;
-    }
-
-    // TODO: Deprecate use of X-Android-Transports header?
-    if ("X-Android-Transports".equals(field) || "X-Android-Protocols".equals(field)) {
-      setProtocols(value, true /* append */);
-    } else {
-      requestHeaders.add(field, value);
-    }
-  }
-
-  /*
-   * Splits and validates a comma-separated string of protocols.
-   * When append == false, we require that the transport list contains "http/1.1".
-   * Throws {@link IllegalStateException} when one of the protocols isn't
-   * defined in {@link Protocol OkHttp's protocol enumeration}.
-   */
-  private void setProtocols(String protocolsString, boolean append) {
-    List<Protocol> protocolsList = new ArrayList<>();
-    if (append) {
-      protocolsList.addAll(client.protocols());
-    }
-    for (String protocol : protocolsString.split(",", -1)) {
-      try {
-        protocolsList.add(Protocol.get(protocol));
-      } catch (IOException e) {
-        throw new IllegalStateException(e);
-      }
-    }
-    client = client.newBuilder()
-        .protocols(protocolsList)
-        .build();
-  }
-
-  @Override public void setRequestMethod(String method) throws ProtocolException {
-    if (!METHODS.contains(method)) {
-      throw new ProtocolException("Expected one of " + METHODS + " but was " + method);
-    }
-    this.method = method;
-  }
-
-  @Override public void setFixedLengthStreamingMode(int contentLength) {
-    setFixedLengthStreamingMode((long) contentLength);
-  }
-
-  @Override public void setFixedLengthStreamingMode(long contentLength) {
-    if (super.connected) throw new IllegalStateException("Already connected");
-    if (chunkLength > 0) throw new IllegalStateException("Already in chunked mode");
-    if (contentLength < 0) throw new IllegalArgumentException("contentLength < 0");
-    this.fixedContentLength = contentLength;
-    super.fixedContentLength = (int) Math.min(contentLength, Integer.MAX_VALUE);
-  }
-}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java
new file mode 100644
index 0000000000..046b098f2c
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java
@@ -0,0 +1,639 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3.internal.huc;
+
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InterruptedIOException;
+import java.io.OutputStream;
+import java.net.HttpURLConnection;
+import java.net.InetSocketAddress;
+import java.net.ProtocolException;
+import java.net.Proxy;
+import java.net.SocketPermission;
+import java.net.URL;
+import java.security.Permission;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Date;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+import okhttp3.Call;
+import okhttp3.Callback;
+import okhttp3.Dispatcher;
+import okhttp3.Handshake;
+import okhttp3.Headers;
+import okhttp3.HttpUrl;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.Internal;
+import okhttp3.internal.JavaNetHeaders;
+import okhttp3.internal.URLFilter;
+import okhttp3.internal.Util;
+import okhttp3.internal.Version;
+import okhttp3.internal.http.HttpDate;
+import okhttp3.internal.http.HttpHeaders;
+import okhttp3.internal.http.HttpMethod;
+import okhttp3.internal.http.StatusLine;
+import okhttp3.internal.platform.Platform;
+
+import static okhttp3.internal.platform.Platform.WARN;
+
+/**
+ * This implementation uses {@linkplain Call} to send requests and receive responses.
+ *
+ * <h3>What does 'connected' mean?</h3> This class inherits a {@code connected} field from the
+ * superclass. That field is <strong>not</strong> used to indicate whether this URLConnection is
+ * currently connected. Instead, it indicates whether a connection has ever been attempted. Once a
+ * connection has been attempted, certain properties (request header fields, request method, etc.)
+ * are immutable.
+ */
+public final class OkHttpURLConnection extends HttpURLConnection implements Callback {
+  /**
+   * Synthetic response header: the selected {@link Protocol protocol} ("spdy/3.1", "http/1.1",
+   * etc).
+   */
+  public static final String SELECTED_PROTOCOL = Platform.get().getPrefix() + "-Selected-Protocol";
+
+  /** Synthetic response header: the location from which the response was loaded. */
+  public static final String RESPONSE_SOURCE = Platform.get().getPrefix() + "-Response-Source";
+
+  private static final Set<String> METHODS = new LinkedHashSet<>(
+      Arrays.asList("OPTIONS", "GET", "HEAD", "POST", "PUT", "DELETE", "TRACE", "PATCH"));
+
+  // These fields are confined to the application thread that uses HttpURLConnection.
+
+  OkHttpClient client;
+  private final NetworkInterceptor networkInterceptor = new NetworkInterceptor();
+  private Headers.Builder requestHeaders = new Headers.Builder();
+  private boolean executed;
+  Call call;
+  URLFilter urlFilter;
+
+  /** Lazily created (with synthetic headers) on first call to getHeaders(). */
+  private Headers responseHeaders;
+
+  /** Like the superclass field of the same name, but a long and available on all platforms. */
+  private long fixedContentLength = -1L;
+
+  // These fields are guarded by lock.
+  private final Object lock = new Object();
+  private Response response;
+  private Throwable callFailure;
+  Response networkResponse;
+  boolean connectPending = true;
+  Proxy proxy;
+  Handshake handshake;
+
+  public OkHttpURLConnection(URL url, OkHttpClient client) {
+    super(url);
+    this.client = client;
+  }
+
+  public OkHttpURLConnection(URL url, OkHttpClient client, URLFilter urlFilter) {
+    this(url, client);
+    this.urlFilter = urlFilter;
+  }
+
+  @Override public void connect() throws IOException {
+    if (executed) return;
+
+    Call call = buildCall();
+    executed = true;
+    call.enqueue(this);
+
+    synchronized (lock) {
+      try {
+        while (connectPending && response == null && callFailure == null) {
+          lock.wait(); // Wait 'til the network interceptor is reached or the call fails.
+        }
+        if (callFailure != null) {
+          throw propagate(callFailure);
+        }
+      } catch (InterruptedException e) {
+        throw new InterruptedIOException();
+      }
+    }
+  }
+
+  @Override public void disconnect() {
+    // Calling disconnect() before a connection exists should have no effect.
+    if (call == null) return;
+
+    networkInterceptor.proceed(); // Unblock any waiting async thread.
+    call.cancel();
+  }
+
+  /**
+   * Returns an input stream from the server in the case of error such as the requested file (txt,
+   * htm, html) is not found on the remote server.
+   */
+  @Override public InputStream getErrorStream() {
+    try {
+      Response response = getResponse();
+      if (HttpHeaders.hasBody(response) && response.code() >= HTTP_BAD_REQUEST) {
+        return response.body().byteStream();
+      }
+      return null;
+    } catch (IOException e) {
+      return null;
+    }
+  }
+
+  private Headers getHeaders() throws IOException {
+    if (responseHeaders == null) {
+      Response response = getResponse();
+      Headers headers = response.headers();
+      responseHeaders = headers.newBuilder()
+          .add(SELECTED_PROTOCOL, response.protocol().toString())
+          .add(RESPONSE_SOURCE, responseSourceHeader(response))
+          .build();
+    }
+    return responseHeaders;
+  }
+
+  private static String responseSourceHeader(Response response) {
+    if (response.networkResponse() == null) {
+      if (response.cacheResponse() == null) {
+        return "NONE";
+      }
+      return "CACHE " + response.code();
+    }
+    if (response.cacheResponse() == null) {
+      return "NETWORK " + response.code();
+    }
+    return "CONDITIONAL_CACHE " + response.networkResponse().code();
+  }
+
+  /**
+   * Returns the value of the field at {@code position}. Returns null if there are fewer than {@code
+   * position} headers.
+   */
+  @Override public String getHeaderField(int position) {
+    try {
+      Headers headers = getHeaders();
+      if (position < 0 || position >= headers.size()) return null;
+      return headers.value(position);
+    } catch (IOException e) {
+      return null;
+    }
+  }
+
+  /**
+   * Returns the value of the field corresponding to the {@code fieldName}, or null if there is no
+   * such field. If the field has multiple values, the last value is returned.
+   */
+  @Override public String getHeaderField(String fieldName) {
+    try {
+      return fieldName == null
+          ? StatusLine.get(getResponse()).toString()
+          : getHeaders().get(fieldName);
+    } catch (IOException e) {
+      return null;
+    }
+  }
+
+  @Override public String getHeaderFieldKey(int position) {
+    try {
+      Headers headers = getHeaders();
+      if (position < 0 || position >= headers.size()) return null;
+      return headers.name(position);
+    } catch (IOException e) {
+      return null;
+    }
+  }
+
+  @Override public Map<String, List<String>> getHeaderFields() {
+    try {
+      return JavaNetHeaders.toMultimap(getHeaders(),
+          StatusLine.get(getResponse()).toString());
+    } catch (IOException e) {
+      return Collections.emptyMap();
+    }
+  }
+
+  @Override public Map<String, List<String>> getRequestProperties() {
+    if (connected) {
+      throw new IllegalStateException(
+          "Cannot access request header fields after connection is set");
+    }
+
+    return JavaNetHeaders.toMultimap(requestHeaders.build(), null);
+  }
+
+  @Override public InputStream getInputStream() throws IOException {
+    if (!doInput) {
+      throw new ProtocolException("This protocol does not support input");
+    }
+
+    Response response = getResponse();
+
+    if (response.code() >= HTTP_BAD_REQUEST) {
+      throw new FileNotFoundException(url.toString());
+    }
+
+    return response.body().byteStream();
+  }
+
+  @Override public OutputStream getOutputStream() throws IOException {
+    OutputStreamRequestBody requestBody = (OutputStreamRequestBody) buildCall().request().body();
+    if (requestBody == null) {
+      throw new ProtocolException("method does not support a request body: " + method);
+    }
+
+    // If this request needs to stream bytes to the server, build a physical connection immediately
+    // and start streaming those bytes over that connection.
+    if (requestBody instanceof StreamedRequestBody) {
+      connect();
+      networkInterceptor.proceed();
+    }
+
+    if (requestBody.isClosed()) {
+      throw new ProtocolException("cannot write request body after response has been read");
+    }
+
+    return requestBody.outputStream();
+  }
+
+  @Override public Permission getPermission() throws IOException {
+    URL url = getURL();
+    String hostname = url.getHost();
+    int hostPort = url.getPort() != -1
+        ? url.getPort()
+        : HttpUrl.defaultPort(url.getProtocol());
+    if (usingProxy()) {
+      InetSocketAddress proxyAddress = (InetSocketAddress) client.proxy().address();
+      hostname = proxyAddress.getHostName();
+      hostPort = proxyAddress.getPort();
+    }
+    return new SocketPermission(hostname + ":" + hostPort, "connect, resolve");
+  }
+
+  @Override public String getRequestProperty(String field) {
+    if (field == null) return null;
+    return requestHeaders.get(field);
+  }
+
+  @Override public void setConnectTimeout(int timeoutMillis) {
+    client = client.newBuilder()
+        .connectTimeout(timeoutMillis, TimeUnit.MILLISECONDS)
+        .build();
+  }
+
+  @Override public void setInstanceFollowRedirects(boolean followRedirects) {
+    client = client.newBuilder()
+        .followRedirects(followRedirects)
+        .build();
+  }
+
+  @Override public boolean getInstanceFollowRedirects() {
+    return client.followRedirects();
+  }
+
+  @Override public int getConnectTimeout() {
+    return client.connectTimeoutMillis();
+  }
+
+  @Override public void setReadTimeout(int timeoutMillis) {
+    client = client.newBuilder()
+        .readTimeout(timeoutMillis, TimeUnit.MILLISECONDS)
+        .build();
+  }
+
+  @Override public int getReadTimeout() {
+    return client.readTimeoutMillis();
+  }
+
+  private Call buildCall() throws IOException {
+    if (call != null) {
+      return call;
+    }
+
+    connected = true;
+    if (doOutput) {
+      if (method.equals("GET")) {
+        // they are requesting a stream to write to. This implies a POST method
+        method = "POST";
+      } else if (!HttpMethod.permitsRequestBody(method)) {
+        throw new ProtocolException(method + " does not support writing");
+      }
+    }
+
+    if (requestHeaders.get("User-Agent") == null) {
+      requestHeaders.add("User-Agent", defaultUserAgent());
+    }
+
+    OutputStreamRequestBody requestBody = null;
+    if (HttpMethod.permitsRequestBody(method)) {
+      // Add a content type for the request body, if one isn't already present.
+      String contentType = requestHeaders.get("Content-Type");
+      if (contentType == null) {
+        contentType = "application/x-www-form-urlencoded";
+        requestHeaders.add("Content-Type", contentType);
+      }
+
+      boolean stream = fixedContentLength != -1L || chunkLength > 0;
+
+      long contentLength = -1L;
+      String contentLengthString = requestHeaders.get("Content-Length");
+      if (fixedContentLength != -1L) {
+        contentLength = fixedContentLength;
+      } else if (contentLengthString != null) {
+        contentLength = Long.parseLong(contentLengthString);
+      }
+
+      requestBody = stream
+          ? new StreamedRequestBody(contentLength)
+          : new BufferedRequestBody(contentLength);
+      requestBody.timeout().timeout(client.writeTimeoutMillis(), TimeUnit.MILLISECONDS);
+    }
+
+    Request request = new Request.Builder()
+        .url(Internal.instance.getHttpUrlChecked(getURL().toString()))
+        .headers(requestHeaders.build())
+        .method(method, requestBody)
+        .build();
+
+    if (urlFilter != null) {
+      urlFilter.checkURLPermitted(request.url().url());
+    }
+
+    OkHttpClient.Builder clientBuilder = client.newBuilder();
+    clientBuilder.interceptors().clear();
+    clientBuilder.interceptors().add(UnexpectedException.INTERCEPTOR);
+    clientBuilder.networkInterceptors().clear();
+    clientBuilder.networkInterceptors().add(networkInterceptor);
+
+    // Use a separate dispatcher so that limits aren't impacted. But use the same executor service!
+    clientBuilder.dispatcher(new Dispatcher(client.dispatcher().executorService()));
+
+    // If we're currently not using caches, make sure the engine's client doesn't have one.
+    if (!getUseCaches()) {
+      clientBuilder.cache(null);
+    }
+
+    return call = clientBuilder.build().newCall(request);
+  }
+
+  private String defaultUserAgent() {
+    String agent = System.getProperty("http.agent");
+    return agent != null ? Util.toHumanReadableAscii(agent) : Version.userAgent();
+  }
+
+  /**
+   * Aggressively tries to get the final HTTP response, potentially making many HTTP requests in the
+   * process in order to cope with redirects and authentication.
+   */
+  private Response getResponse() throws IOException {
+    if (response != null) {
+      return response;
+    } else if (networkResponse != null) {
+      return networkResponse;
+    } else if (callFailure != null) {
+      throw propagate(callFailure);
+    }
+
+    Call call = buildCall();
+    networkInterceptor.proceed();
+
+    OutputStreamRequestBody requestBody = (OutputStreamRequestBody) call.request().body();
+    if (requestBody != null) requestBody.outputStream().close();
+
+    if (executed) {
+      synchronized (lock) {
+        try {
+          while (response == null && callFailure == null) {
+            lock.wait(); // Wait until the response is returned or the call fails.
+          }
+        } catch (InterruptedException e) {
+          throw new InterruptedIOException();
+        }
+      }
+    } else {
+      executed = true;
+      try {
+        onResponse(call, call.execute());
+      } catch (IOException e) {
+        onFailure(call, e);
+      }
+    }
+
+    synchronized (lock) {
+      if (callFailure != null) throw propagate(callFailure);
+      if (response != null) return response;
+    }
+
+    throw new AssertionError();
+  }
+
+  /**
+   * Returns true if either:
+   *
+   * <ul>
+   *   <li>A specific proxy was explicitly configured for this connection.
+   *   <li>The response has already been retrieved, and a proxy was {@link
+   *       java.net.ProxySelector selected} in order to get it.
+   * </ul>
+   *
+   * <p><strong>Warning:</strong> This method may return false before attempting to connect and true
+   * afterwards.
+   */
+  @Override public boolean usingProxy() {
+    if (proxy != null) return true;
+    Proxy clientProxy = client.proxy();
+    return clientProxy != null && clientProxy.type() != Proxy.Type.DIRECT;
+  }
+
+  @Override public String getResponseMessage() throws IOException {
+    return getResponse().message();
+  }
+
+  @Override public int getResponseCode() throws IOException {
+    return getResponse().code();
+  }
+
+  @Override public void setRequestProperty(String field, String newValue) {
+    if (connected) {
+      throw new IllegalStateException("Cannot set request property after connection is made");
+    }
+    if (field == null) {
+      throw new NullPointerException("field == null");
+    }
+    if (newValue == null) {
+      // Silently ignore null header values for backwards compatibility with older
+      // android versions as well as with other URLConnection implementations.
+      //
+      // Some implementations send a malformed HTTP header when faced with
+      // such requests, we respect the spec and ignore the header.
+      Platform.get().log(WARN, "Ignoring header " + field + " because its value was null.", null);
+      return;
+    }
+
+    requestHeaders.set(field, newValue);
+  }
+
+  @Override public void setIfModifiedSince(long newValue) {
+    super.setIfModifiedSince(newValue);
+    if (ifModifiedSince != 0) {
+      requestHeaders.set("If-Modified-Since", HttpDate.format(new Date(ifModifiedSince)));
+    } else {
+      requestHeaders.removeAll("If-Modified-Since");
+    }
+  }
+
+  @Override public void addRequestProperty(String field, String value) {
+    if (connected) {
+      throw new IllegalStateException("Cannot add request property after connection is made");
+    }
+    if (field == null) {
+      throw new NullPointerException("field == null");
+    }
+    if (value == null) {
+      // Silently ignore null header values for backwards compatibility with older
+      // android versions as well as with other URLConnection implementations.
+      //
+      // Some implementations send a malformed HTTP header when faced with
+      // such requests, we respect the spec and ignore the header.
+      Platform.get().log(WARN, "Ignoring header " + field + " because its value was null.", null);
+      return;
+    }
+
+    requestHeaders.add(field, value);
+  }
+
+  @Override public void setRequestMethod(String method) throws ProtocolException {
+    if (!METHODS.contains(method)) {
+      throw new ProtocolException("Expected one of " + METHODS + " but was " + method);
+    }
+    this.method = method;
+  }
+
+  @Override public void setFixedLengthStreamingMode(int contentLength) {
+    setFixedLengthStreamingMode((long) contentLength);
+  }
+
+  @Override public void setFixedLengthStreamingMode(long contentLength) {
+    if (super.connected) throw new IllegalStateException("Already connected");
+    if (chunkLength > 0) throw new IllegalStateException("Already in chunked mode");
+    if (contentLength < 0) throw new IllegalArgumentException("contentLength < 0");
+    this.fixedContentLength = contentLength;
+    super.fixedContentLength = (int) Math.min(contentLength, Integer.MAX_VALUE);
+  }
+
+  @Override public void onFailure(Call call, IOException e) {
+    synchronized (lock) {
+      this.callFailure = (e instanceof UnexpectedException) ? e.getCause() : e;
+      lock.notifyAll();
+    }
+  }
+
+  @Override public void onResponse(Call call, Response response) {
+    synchronized (lock) {
+      this.response = response;
+      this.handshake = response.handshake();
+      this.url = response.request().url().url();
+      lock.notifyAll();
+    }
+  }
+
+  static final class UnexpectedException extends IOException {
+    static final Interceptor INTERCEPTOR = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        try {
+          return chain.proceed(chain.request());
+        } catch (Error | RuntimeException e) {
+          throw new UnexpectedException(e);
+        }
+      }
+    };
+
+    public UnexpectedException(Throwable cause) {
+      super(cause);
+    }
+  }
+
+  /** Throws {@code throwable} as either an IOException, RuntimeException, or Error. */
+  private static IOException propagate(Throwable throwable) throws IOException {
+    if (throwable instanceof IOException) throw (IOException) throwable;
+    if (throwable instanceof Error) throw (Error) throwable;
+    if (throwable instanceof RuntimeException) throw (RuntimeException) throwable;
+    throw new AssertionError();
+  }
+
+  /**
+   * The HttpURLConnection gives the application control between establishing the connection and
+   * transmitting the request body. This interceptor stalls async calls right at this point. The
+   * call will remain stalled until {@link #proceed()} is called.
+   */
+  final class NetworkInterceptor implements Interceptor {
+    // Guarded by HttpUrlConnection.this.
+    private boolean proceed;
+
+    public void proceed() {
+      synchronized (lock) {
+        this.proceed = true;
+        lock.notifyAll();
+      }
+    }
+
+    @Override public Response intercept(Chain chain) throws IOException {
+      Request request = chain.request();
+
+      // Double-check the URL filter to prevent redirects from hitting filtered URLs.
+      if (urlFilter != null) {
+        urlFilter.checkURLPermitted(request.url().url());
+      }
+
+      synchronized (lock) {
+        connectPending = false;
+        proxy = chain.connection().route().proxy();
+        handshake = chain.connection().handshake();
+        lock.notifyAll();
+
+        try {
+          while (!proceed) {
+            lock.wait(); // Wait until proceed() is called.
+          }
+        } catch (InterruptedException e) {
+          throw new InterruptedIOException();
+        }
+      }
+
+      // Try to lock in the Content-Length before transmitting the request body.
+      if (request.body() instanceof OutputStreamRequestBody) {
+        OutputStreamRequestBody requestBody = (OutputStreamRequestBody) request.body();
+        request = requestBody.prepareToSendRequest(request);
+      }
+
+      Response response = chain.proceed(request);
+
+      synchronized (lock) {
+        networkResponse = response;
+        url = response.request().url().url();
+      }
+
+      return response;
+    }
+  }
+}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpsURLConnectionImpl.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpsURLConnection.java
similarity index 61%
rename from okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpsURLConnectionImpl.java
rename to okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpsURLConnection.java
index 1bf1fa6566..0057174226 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpsURLConnectionImpl.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpsURLConnection.java
@@ -23,33 +23,28 @@
 import okhttp3.OkHttpClient;
 import okhttp3.internal.URLFilter;
 
-public final class HttpsURLConnectionImpl extends DelegatingHttpsURLConnection {
-  private final HttpURLConnectionImpl delegate;
+public final class OkHttpsURLConnection extends DelegatingHttpsURLConnection {
+  private final OkHttpURLConnection delegate;
 
-  public HttpsURLConnectionImpl(URL url, OkHttpClient client) {
-    this(new HttpURLConnectionImpl(url, client));
+  public OkHttpsURLConnection(URL url, OkHttpClient client) {
+    this(new OkHttpURLConnection(url, client));
   }
 
-  public HttpsURLConnectionImpl(URL url, OkHttpClient client, URLFilter filter) {
-    this(new HttpURLConnectionImpl(url, client, filter));
+  public OkHttpsURLConnection(URL url, OkHttpClient client, URLFilter filter) {
+    this(new OkHttpURLConnection(url, client, filter));
   }
 
-  public HttpsURLConnectionImpl(HttpURLConnectionImpl delegate) {
+  public OkHttpsURLConnection(OkHttpURLConnection delegate) {
     super(delegate);
     this.delegate = delegate;
   }
 
   @Override protected Handshake handshake() {
-    if (delegate.httpEngine == null) {
+    if (delegate.call == null) {
       throw new IllegalStateException("Connection has not yet been established");
     }
 
-    // If there's a response, get the handshake from there so that caching
-    // works. Otherwise get the handshake from the connection because we might
-    // have not connected yet.
-    return delegate.httpEngine.hasResponse()
-        ? delegate.httpEngine.getResponse().handshake()
-        : delegate.handshake;
+    return delegate.handshake;
   }
 
   @Override public void setHostnameVerifier(HostnameVerifier hostnameVerifier) {
@@ -63,6 +58,7 @@ public HttpsURLConnectionImpl(HttpURLConnectionImpl delegate) {
   }
 
   @Override public void setSSLSocketFactory(SSLSocketFactory sslSocketFactory) {
+    // This fails in JDK 9 because OkHttp is unable to extract the trust manager.
     delegate.client = delegate.client.newBuilder()
         .sslSocketFactory(sslSocketFactory)
         .build();
@@ -72,15 +68,4 @@ public HttpsURLConnectionImpl(HttpURLConnectionImpl delegate) {
     return delegate.client.sslSocketFactory();
   }
 
-  @Override public long getContentLengthLong() {
-    return delegate.getContentLengthLong();
-  }
-
-  @Override public void setFixedLengthStreamingMode(long contentLength) {
-    delegate.setFixedLengthStreamingMode(contentLength);
-  }
-
-  @Override public long getHeaderFieldLong(String field, long defaultValue) {
-    return delegate.getHeaderFieldLong(field, defaultValue);
-  }
 }
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OutputStreamRequestBody.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OutputStreamRequestBody.java
new file mode 100644
index 0000000000..6f4e8ef9e9
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OutputStreamRequestBody.java
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.huc;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.io.OutputStream;
+import java.net.ProtocolException;
+import java.net.SocketTimeoutException;
+import okhttp3.MediaType;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okio.BufferedSink;
+import okio.Timeout;
+
+/**
+ * A request body that's populated by blocking writes to an output stream. The output data is either
+ * fully buffered (with {@link BufferedRequestBody}) or streamed (with {@link StreamedRequestBody}).
+ * In either case the bytes of the body aren't known until the caller writes them to the output
+ * stream.
+ */
+abstract class OutputStreamRequestBody extends RequestBody {
+  private Timeout timeout;
+  private long expectedContentLength;
+  private OutputStream outputStream;
+  boolean closed;
+
+  protected void initOutputStream(final BufferedSink sink, final long expectedContentLength) {
+    this.timeout = sink.timeout();
+    this.expectedContentLength = expectedContentLength;
+
+    // An output stream that writes to sink. If expectedContentLength is not -1, then this expects
+    // exactly that many bytes to be written.
+    this.outputStream = new OutputStream() {
+      private long bytesReceived;
+
+      @Override public void write(int b) throws IOException {
+        write(new byte[] {(byte) b}, 0, 1);
+      }
+
+      @Override public void write(byte[] source, int offset, int byteCount) throws IOException {
+        if (closed) throw new IOException("closed"); // Not IllegalStateException!
+
+        if (expectedContentLength != -1L && bytesReceived + byteCount > expectedContentLength) {
+          throw new ProtocolException("expected " + expectedContentLength
+              + " bytes but received " + bytesReceived + byteCount);
+        }
+
+        bytesReceived += byteCount;
+        try {
+          sink.write(source, offset, byteCount);
+        } catch (InterruptedIOException e) {
+          throw new SocketTimeoutException(e.getMessage());
+        }
+      }
+
+      @Override public void flush() throws IOException {
+        if (closed) return; // Weird, but consistent with historical behavior.
+        sink.flush();
+      }
+
+      @Override public void close() throws IOException {
+        closed = true;
+
+        if (expectedContentLength != -1L && bytesReceived < expectedContentLength) {
+          throw new ProtocolException("expected " + expectedContentLength
+              + " bytes but received " + bytesReceived);
+        }
+
+        sink.close();
+      }
+    };
+  }
+
+  public final OutputStream outputStream() {
+    return outputStream;
+  }
+
+  public final Timeout timeout() {
+    return timeout;
+  }
+
+  public final boolean isClosed() {
+    return closed;
+  }
+
+  @Override public long contentLength() throws IOException {
+    return expectedContentLength;
+  }
+
+  @Override public final MediaType contentType() {
+    return null; // Let the caller provide this in a regular header.
+  }
+
+  public Request prepareToSendRequest(Request request) throws IOException {
+    return request;
+  }
+}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/StreamedRequestBody.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/StreamedRequestBody.java
new file mode 100644
index 0000000000..201ab09b66
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/StreamedRequestBody.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.huc;
+
+import java.io.IOException;
+import okhttp3.internal.http.UnrepeatableRequestBody;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.Okio;
+import okio.Pipe;
+
+/**
+ * This request body streams bytes from an application thread to an OkHttp dispatcher thread via a
+ * pipe. Because the data is not buffered it can only be transmitted once.
+ */
+final class StreamedRequestBody extends OutputStreamRequestBody implements UnrepeatableRequestBody {
+  private final Pipe pipe = new Pipe(8192);
+
+  StreamedRequestBody(long expectedContentLength) {
+    initOutputStream(Okio.buffer(pipe.sink()), expectedContentLength);
+  }
+
+  @Override public void writeTo(BufferedSink sink) throws IOException {
+    Buffer buffer = new Buffer();
+    while (pipe.source().read(buffer, 8192) != -1L) {
+      sink.write(buffer, buffer.size());
+    }
+  }
+}
diff --git a/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java b/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java
index 39f6066805..d0f706f0d0 100644
--- a/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java
+++ b/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java
@@ -11,11 +11,10 @@
 import java.util.TimeZone;
 import java.util.concurrent.TimeUnit;
 import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLContext;
-import okhttp3.internal.SslContextBuilder;
 import okhttp3.internal.URLFilter;
-import okhttp3.internal.http.OkHeaders;
+import okhttp3.internal.huc.OkHttpURLConnection;
 import okhttp3.internal.io.InMemoryFileSystem;
+import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okio.BufferedSource;
@@ -184,10 +183,10 @@ public void testURLFilterRedirect() throws Exception {
         .setBody("Blocked!"));
     final URL blockedURL = cleartextServer.url("/").url();
 
-    SSLContext context = SslContextBuilder.localhost();
-    server.useHttps(context.getSocketFactory(), false);
+    SslClient contextBuilder = SslClient.localhost();
+    server.useHttps(contextBuilder.socketFactory, false);
     factory.setClient(factory.client().newBuilder()
-        .sslSocketFactory(context.getSocketFactory())
+        .sslSocketFactory(contextBuilder.socketFactory, contextBuilder.trustManager)
         .followSslRedirects(true)
         .build());
     factory.setUrlFilter(new URLFilter() {
@@ -208,8 +207,7 @@ public void checkURLPermitted(URL url) throws IOException {
       HttpsURLConnection httpsConnection = (HttpsURLConnection) factory.open(destination);
       httpsConnection.getInputStream();
       fail("Connection was successful");
-    } catch (IOException e) {
-      assertEquals("Blocked", e.getMessage());
+    } catch (IOException expected) {
     }
   }
 
@@ -221,7 +219,7 @@ private void assertResponseBody(HttpURLConnection connection, String expected) t
   }
 
   private void assertResponseHeader(HttpURLConnection connection, String expected) {
-    assertEquals(expected, connection.getHeaderField(OkHeaders.RESPONSE_SOURCE));
+    assertEquals(expected, connection.getHeaderField(OkHttpURLConnection.RESPONSE_SOURCE));
   }
 
   private void assertResponseCode(HttpURLConnection connection, int expected) throws IOException {
diff --git a/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java b/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java
index a5b1107868..d8845f2569 100644
--- a/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java
+++ b/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java
@@ -40,12 +40,12 @@
 import java.util.concurrent.TimeUnit;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSession;
 import okhttp3.internal.Internal;
-import okhttp3.internal.SslContextBuilder;
 import okhttp3.internal.Util;
 import okhttp3.internal.io.InMemoryFileSystem;
+import okhttp3.internal.platform.Platform;
+import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
@@ -66,6 +66,7 @@
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeFalse;
 
 /** Test caching with {@link OkUrlFactory}. */
 public final class UrlConnectionCacheTest {
@@ -79,7 +80,7 @@
   @Rule public MockWebServer server2 = new MockWebServer();
   @Rule public InMemoryFileSystem fileSystem = new InMemoryFileSystem();
 
-  private final SSLContext sslContext = SslContextBuilder.localhost();
+  private final SslClient sslClient = SslClient.localhost();
   private OkUrlFactory urlFactory = new OkUrlFactory(new OkHttpClient());
   private Cache cache;
   private final CookieManager cookieManager = new CookieManager();
@@ -174,6 +175,9 @@ private void assertCached(boolean shouldPut, int responseCode) throws Exception
       response.addHeader("Proxy-Authenticate: Basic realm=\"protected area\"");
     } else if (responseCode == HttpURLConnection.HTTP_UNAUTHORIZED) {
       response.addHeader("WWW-Authenticate: Basic realm=\"protected area\"");
+    } else if (responseCode == HttpURLConnection.HTTP_NO_CONTENT
+        || responseCode == HttpURLConnection.HTTP_RESET) {
+      response.setBody(""); // We forbid bodies for 204 and 205.
     }
     server.enqueue(response);
 
@@ -257,13 +261,15 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
   }
 
   @Test public void secureResponseCaching() throws IOException {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    assumeFalse(getPlatform().equals("jdk9"));
+
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
 
     HttpsURLConnection c1 = (HttpsURLConnection) urlFactory.open(server.url("/").url());
-    c1.setSSLSocketFactory(sslContext.getSocketFactory());
+    c1.setSSLSocketFactory(sslClient.socketFactory);
     c1.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
     assertEquals("ABC", readAscii(c1));
 
@@ -275,7 +281,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     Principal localPrincipal = c1.getLocalPrincipal();
 
     HttpsURLConnection c2 = (HttpsURLConnection) urlFactory.open(server.url("/").url()); // cached!
-    c2.setSSLSocketFactory(sslContext.getSocketFactory());
+    c2.setSSLSocketFactory(sslClient.socketFactory);
     c2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
     assertEquals("ABC", readAscii(c2));
 
@@ -335,7 +341,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
   }
 
   @Test public void secureResponseCachingAndRedirects() throws IOException {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
@@ -346,7 +352,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     server.enqueue(new MockResponse().setBody("DEF"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslContext.getSocketFactory())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
         .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
         .build());
 
@@ -372,7 +378,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
    * https://github.com/square/okhttp/issues/214
    */
   @Test public void secureResponseCachingAndProtocolRedirects() throws IOException {
-    server2.useHttps(sslContext.getSocketFactory(), false);
+    server2.useHttps(sslClient.socketFactory, false);
     server2.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
@@ -384,7 +390,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .addHeader("Location: " + server2.url("/").url()));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslContext.getSocketFactory())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
         .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
         .build());
 
@@ -1400,7 +1406,9 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   }
 
   @Test public void varyAndHttps() throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    assumeFalse(getPlatform().equals("jdk9"));
+
+    server.useHttps(sslClient.socketFactory, false);
     server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
         .addHeader("Vary: Accept-Language")
         .setBody("A"));
@@ -1408,13 +1416,13 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
 
     URL url = server.url("/").url();
     HttpsURLConnection connection1 = (HttpsURLConnection) urlFactory.open(url);
-    connection1.setSSLSocketFactory(sslContext.getSocketFactory());
+    connection1.setSSLSocketFactory(sslClient.socketFactory);
     connection1.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
     connection1.addRequestProperty("Accept-Language", "en-US");
     assertEquals("A", readAscii(connection1));
 
     HttpsURLConnection connection2 = (HttpsURLConnection) urlFactory.open(url);
-    connection2.setSSLSocketFactory(sslContext.getSocketFactory());
+    connection2.setSSLSocketFactory(sslClient.socketFactory);
     connection2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
     connection2.addRequestProperty("Accept-Language", "en-US");
     assertEquals("A", readAscii(connection2));
@@ -1612,6 +1620,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
 
     URL url = server.url("/").url();
     String urlKey = Util.md5Hex(url.toString());
+    String prefix = Platform.get().getPrefix();
     String entryMetadata = ""
         + "" + url + "\n"
         + "GET\n"
@@ -1622,7 +1631,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         + ":version: HTTP/1.1\n"
         + "etag: foo\n"
         + "content-length: 3\n"
-        + "OkHttp-Received-Millis: " + System.currentTimeMillis() + "\n"
+        + prefix + "-Received-Millis: " + System.currentTimeMillis() + "\n"
         + "X-Android-Response-Source: NETWORK 200\n"
         + "OkHttp-Sent-Millis: " + System.currentTimeMillis() + "\n"
         + "\n"
@@ -1834,4 +1843,8 @@ public Buffer gzip(String data) throws IOException {
     sink.close();
     return result;
   }
+
+  private String getPlatform() {
+    return System.getProperty("okhttp.platform", "platform");
+  }
 }
diff --git a/okhttp-urlconnection/src/test/java/okhttp3/internal/huc/URLEncodingTest.java b/okhttp-urlconnection/src/test/java/okhttp3/internal/huc/URLEncodingTest.java
index b61f266f4c..ec0de83e52 100644
--- a/okhttp-urlconnection/src/test/java/okhttp3/internal/huc/URLEncodingTest.java
+++ b/okhttp-urlconnection/src/test/java/okhttp3/internal/huc/URLEncodingTest.java
@@ -27,9 +27,9 @@
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.internal.Internal;
-import okhttp3.internal.InternalCache;
-import okhttp3.internal.http.CacheRequest;
-import okhttp3.internal.http.CacheStrategy;
+import okhttp3.internal.cache.CacheRequest;
+import okhttp3.internal.cache.CacheStrategy;
+import okhttp3.internal.cache.InternalCache;
 import org.junit.Ignore;
 import org.junit.Test;
 
@@ -125,35 +125,25 @@ private URI backdoorUrlToUri(URL url) throws Exception {
 
     OkHttpClient.Builder builder = new OkHttpClient.Builder();
     Internal.instance.setCache(builder, new InternalCache() {
-      @Override
-      public Response get(Request request) throws IOException {
+      @Override public Response get(Request request) throws IOException {
         uriReference.set(request.url().uri());
         throw new UnsupportedOperationException();
       }
 
-      @Override
-      public CacheRequest put(Response response) throws IOException {
+      @Override public CacheRequest put(Response response) throws IOException {
         return null;
       }
 
-      @Override
-      public void remove(Request request) throws IOException {
-
+      @Override public void remove(Request request) throws IOException {
       }
 
-      @Override
-      public void update(Response cached, Response network) throws IOException {
-
+      @Override public void update(Response cached, Response network) {
       }
 
-      @Override
-      public void trackConditionalCacheHit() {
-
+      @Override public void trackConditionalCacheHit() {
       }
 
-      @Override
-      public void trackResponse(CacheStrategy cacheStrategy) {
-
+      @Override public void trackResponse(CacheStrategy cacheStrategy) {
       }
     });
 
diff --git a/okhttp-ws-tests/pom.xml b/okhttp-ws-tests/pom.xml
deleted file mode 100644
index 783385c8f2..0000000000
--- a/okhttp-ws-tests/pom.xml
+++ /dev/null
@@ -1,76 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.3.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>okhttp-ws-tests</artifactId>
-  <name>OkHttp Web Socket Tests</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-ws</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-testing-support</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-assembly-plugin</artifactId>
-        <configuration>
-          <descriptorRefs>
-            <descriptorRef>jar-with-dependencies</descriptorRef>
-          </descriptorRefs>
-          <archive>
-            <manifest>
-              <mainClass>okhttp3.ws.AutobahnTester</mainClass>
-            </manifest>
-          </archive>
-        </configuration>
-        <executions>
-          <execution>
-            <phase>package</phase>
-            <goals>
-              <goal>single</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
-      <!-- Do not deploy this as an artifact to Maven central. -->
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-deploy-plugin</artifactId>
-        <configuration>
-          <skip>true</skip>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketCallTest.java b/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketCallTest.java
deleted file mode 100644
index 9315152093..0000000000
--- a/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketCallTest.java
+++ /dev/null
@@ -1,272 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.ws;
-
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.util.Random;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicReference;
-import javax.net.ssl.SSLContext;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.internal.SslContextBuilder;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.RecordingHostnameVerifier;
-import okio.Buffer;
-import org.junit.After;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static okhttp3.ws.WebSocket.TEXT;
-
-public final class WebSocketCallTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  private final SSLContext sslContext = SslContextBuilder.localhost();
-  private final WebSocketRecorder listener = new WebSocketRecorder();
-  private final Random random = new Random(0);
-  private OkHttpClient client = new OkHttpClient();
-
-  @After public void tearDown() {
-    listener.assertExhausted();
-  }
-
-  @Test public void clientPingPong() throws IOException {
-    WebSocketListener serverListener = new EmptyWebSocketListener();
-    server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-
-    WebSocket webSocket = awaitWebSocket();
-    webSocket.sendPing(new Buffer().writeUtf8("Hello, WebSockets!"));
-    listener.assertPong(new Buffer().writeUtf8("Hello, WebSockets!"));
-  }
-
-  @Test public void clientMessage() throws IOException {
-    WebSocketRecorder serverListener = new WebSocketRecorder();
-    server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-
-    WebSocket webSocket = awaitWebSocket();
-    webSocket.sendMessage(RequestBody.create(TEXT, "Hello, WebSockets!"));
-    serverListener.assertTextMessage("Hello, WebSockets!");
-  }
-
-  @Test public void serverMessage() throws IOException {
-    WebSocketListener serverListener = new EmptyWebSocketListener() {
-      @Override public void onOpen(final WebSocket webSocket, Response response) {
-        new Thread() {
-          @Override public void run() {
-            try {
-              webSocket.sendMessage(RequestBody.create(TEXT, "Hello, WebSockets!"));
-            } catch (IOException e) {
-              throw new AssertionError(e);
-            }
-          }
-        }.start();
-      }
-    };
-    server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-
-    awaitWebSocket();
-    listener.assertTextMessage("Hello, WebSockets!");
-  }
-
-  @Test public void okButNotOk() {
-    server.enqueue(new MockResponse().setResponseCode(200));
-    awaitWebSocket();
-    listener.assertFailure(ProtocolException.class, "Expected HTTP 101 response but was '200 OK'");
-  }
-
-  @Test public void notFound() {
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 404 Not Found"));
-    awaitWebSocket();
-    listener.assertFailure(ProtocolException.class,
-        "Expected HTTP 101 response but was '404 Not Found'");
-  }
-
-  @Test public void missingConnectionHeader() {
-    server.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Upgrade", "websocket")
-        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
-    awaitWebSocket();
-    listener.assertFailure(ProtocolException.class,
-        "Expected 'Connection' header value 'Upgrade' but was 'null'");
-  }
-
-  @Test public void wrongConnectionHeader() {
-    server.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Upgrade", "websocket")
-        .setHeader("Connection", "Downgrade")
-        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
-    awaitWebSocket();
-    listener.assertFailure(ProtocolException.class,
-        "Expected 'Connection' header value 'Upgrade' but was 'Downgrade'");
-  }
-
-  @Test public void missingUpgradeHeader() {
-    server.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Connection", "Upgrade")
-        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
-    awaitWebSocket();
-    listener.assertFailure(ProtocolException.class,
-        "Expected 'Upgrade' header value 'websocket' but was 'null'");
-  }
-
-  @Test public void wrongUpgradeHeader() {
-    server.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Connection", "Upgrade")
-        .setHeader("Upgrade", "Pepsi")
-        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
-    awaitWebSocket();
-    listener.assertFailure(ProtocolException.class,
-        "Expected 'Upgrade' header value 'websocket' but was 'Pepsi'");
-  }
-
-  @Test public void missingMagicHeader() {
-    server.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Connection", "Upgrade")
-        .setHeader("Upgrade", "websocket"));
-    awaitWebSocket();
-    listener.assertFailure(ProtocolException.class,
-        "Expected 'Sec-WebSocket-Accept' header value 'ujmZX4KXZqjwy6vi1aQFH5p4Ygk=' but was 'null'");
-  }
-
-  @Test public void wrongMagicHeader() {
-    server.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Connection", "Upgrade")
-        .setHeader("Upgrade", "websocket")
-        .setHeader("Sec-WebSocket-Accept", "magic"));
-    awaitWebSocket();
-    listener.assertFailure(ProtocolException.class,
-        "Expected 'Sec-WebSocket-Accept' header value 'ujmZX4KXZqjwy6vi1aQFH5p4Ygk=' but was 'magic'");
-  }
-
-  @Test public void wsScheme() throws IOException {
-    websocketScheme("ws");
-  }
-
-  @Test public void wsUppercaseScheme() throws IOException {
-    websocketScheme("WS");
-  }
-
-  @Test public void wssScheme() throws IOException {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    client = client.newBuilder()
-        .sslSocketFactory(sslContext.getSocketFactory())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-
-    websocketScheme("wss");
-  }
-
-  @Test public void httpsScheme() throws IOException {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    client = client.newBuilder()
-        .sslSocketFactory(sslContext.getSocketFactory())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-
-    websocketScheme("https");
-  }
-
-  private void websocketScheme(String scheme) throws IOException {
-    WebSocketRecorder serverListener = new WebSocketRecorder();
-    server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-
-    Request request1 = new Request.Builder()
-        .url(scheme + "://" + server.getHostName() + ":" + server.getPort() + "/")
-        .build();
-
-    WebSocket webSocket = awaitWebSocket(request1);
-    webSocket.sendMessage(RequestBody.create(TEXT, "abc"));
-    serverListener.assertTextMessage("abc");
-  }
-
-  private WebSocket awaitWebSocket() {
-    return awaitWebSocket(new Request.Builder().get().url(server.url("/")).build());
-  }
-
-  private WebSocket awaitWebSocket(Request request) {
-    WebSocketCall call = new WebSocketCall(client, request, random);
-
-    final AtomicReference<Response> responseRef = new AtomicReference<>();
-    final AtomicReference<WebSocket> webSocketRef = new AtomicReference<>();
-    final AtomicReference<IOException> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new WebSocketListener() {
-      @Override public void onOpen(WebSocket webSocket, Response response) {
-        webSocketRef.set(webSocket);
-        responseRef.set(response);
-        latch.countDown();
-      }
-
-      @Override public void onMessage(ResponseBody message) throws IOException {
-        listener.onMessage(message);
-      }
-
-      @Override public void onPong(Buffer payload) {
-        listener.onPong(payload);
-      }
-
-      @Override public void onClose(int code, String reason) {
-        listener.onClose(code, reason);
-      }
-
-      @Override public void onFailure(IOException e, Response response) {
-        listener.onFailure(e, null);
-        failureRef.set(e);
-        latch.countDown();
-      }
-    });
-
-    try {
-      if (!latch.await(10, TimeUnit.SECONDS)) {
-        throw new AssertionError("Timed out.");
-      }
-    } catch (InterruptedException e) {
-      throw new AssertionError(e);
-    }
-
-    return webSocketRef.get();
-  }
-
-  private static class EmptyWebSocketListener implements WebSocketListener {
-    @Override public void onOpen(WebSocket webSocket, Response response) {
-    }
-
-    @Override public void onMessage(ResponseBody message) throws IOException {
-    }
-
-    @Override public void onPong(Buffer payload) {
-    }
-
-    @Override public void onClose(int code, String reason) {
-    }
-
-    @Override public void onFailure(IOException e, Response response) {
-    }
-  }
-}
diff --git a/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketRecorder.java b/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketRecorder.java
deleted file mode 100644
index 0f019c6b79..0000000000
--- a/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketRecorder.java
+++ /dev/null
@@ -1,245 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.ws;
-
-import java.io.IOException;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.TimeUnit;
-import okhttp3.MediaType;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.internal.ws.WebSocketReader;
-import okio.Buffer;
-
-import static okhttp3.ws.WebSocket.BINARY;
-import static okhttp3.ws.WebSocket.TEXT;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-
-public final class WebSocketRecorder implements WebSocketReader.FrameCallback, WebSocketListener {
-  public interface MessageDelegate {
-    void onMessage(ResponseBody message) throws IOException;
-  }
-
-  private final BlockingQueue<Object> events = new LinkedBlockingQueue<>();
-  private MessageDelegate delegate;
-
-  /** Sets a delegate for the next call to {@link #onMessage}. Cleared after invoked. */
-  public void setNextMessageDelegate(MessageDelegate delegate) {
-    this.delegate = delegate;
-  }
-
-  @Override public void onOpen(WebSocket webSocket, Response response) {
-  }
-
-  @Override public void onMessage(ResponseBody message) throws IOException {
-    if (delegate != null) {
-      delegate.onMessage(message);
-      delegate = null;
-    } else {
-      Message event = new Message(message.contentType());
-      message.source().readAll(event.buffer);
-      message.close();
-      events.add(event);
-    }
-  }
-
-  @Override public void onPing(Buffer buffer) {
-    events.add(new Ping(buffer));
-  }
-
-  @Override public void onPong(Buffer buffer) {
-    events.add(new Pong(buffer));
-  }
-
-  @Override public void onClose(int code, String reason) {
-    events.add(new Close(code, reason));
-  }
-
-  @Override public void onFailure(IOException e, Response response) {
-    events.add(e);
-  }
-
-  private Object nextEvent() {
-    try {
-      Object event = events.poll(10, TimeUnit.SECONDS);
-      if (event == null) {
-        throw new AssertionError("Timed out.");
-      }
-      return event;
-    } catch (InterruptedException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  public void assertTextMessage(String payload) throws IOException {
-    Message message = new Message(TEXT);
-    message.buffer.writeUtf8(payload);
-    Object actual = nextEvent();
-    if (actual instanceof IOException) {
-      throw (IOException) actual;
-    }
-    assertEquals(message, actual);
-  }
-
-  public void assertBinaryMessage(byte[] payload) throws IOException {
-    Message message = new Message(BINARY);
-    message.buffer.write(payload);
-    Object actual = nextEvent();
-    if (actual instanceof IOException) {
-      throw (IOException) actual;
-    }
-    assertEquals(message, actual);
-  }
-
-  public void assertPing(Buffer payload) throws IOException {
-    Object actual = nextEvent();
-    if (actual instanceof IOException) {
-      throw (IOException) actual;
-    }
-    assertEquals(new Ping(payload), actual);
-  }
-
-  public void assertPong(Buffer payload) throws IOException {
-    Object actual = nextEvent();
-    if (actual instanceof IOException) {
-      throw (IOException) actual;
-    }
-    assertEquals(new Pong(payload), actual);
-  }
-
-  public void assertClose(int code, String reason) throws IOException {
-    Object actual = nextEvent();
-    if (actual instanceof IOException) {
-      throw (IOException) actual;
-    }
-    assertEquals(new Close(code, reason), actual);
-  }
-
-  public void assertFailure(Class<? extends IOException> cls, String message) {
-    Object event = nextEvent();
-    String errorMessage =
-        "Expected [" + cls.getName() + ": " + message + "] but was [" + event + "].";
-    assertNotNull(errorMessage, event);
-    assertEquals(errorMessage, cls, event.getClass());
-    assertEquals(errorMessage, cls.cast(event).getMessage(), message);
-  }
-
-  public void assertExhausted() {
-    assertTrue("Remaining events: " + events, events.isEmpty());
-  }
-
-  private static class Message {
-    public final MediaType mediaType;
-    public final Buffer buffer = new Buffer();
-
-    private Message(MediaType mediaType) {
-      this.mediaType = mediaType;
-    }
-
-    @Override public String toString() {
-      return "Message[" + mediaType + " " + buffer + "]";
-    }
-
-    @Override public int hashCode() {
-      return mediaType.hashCode() * 37 + buffer.hashCode();
-    }
-
-    @Override public boolean equals(Object obj) {
-      if (obj instanceof Message) {
-        Message other = (Message) obj;
-        return mediaType.equals(other.mediaType) && buffer.equals(other.buffer);
-      }
-      return false;
-    }
-  }
-
-  private static class Ping {
-    public final Buffer buffer;
-
-    private Ping(Buffer buffer) {
-      this.buffer = buffer;
-    }
-
-    @Override public String toString() {
-      return "Ping[" + buffer + "]";
-    }
-
-    @Override public int hashCode() {
-      return buffer.hashCode();
-    }
-
-    @Override public boolean equals(Object obj) {
-      if (obj instanceof Ping) {
-        Ping other = (Ping) obj;
-        return buffer == null ? other.buffer == null : buffer.equals(other.buffer);
-      }
-      return false;
-    }
-  }
-
-  private static class Pong {
-    public final Buffer buffer;
-
-    private Pong(Buffer buffer) {
-      this.buffer = buffer;
-    }
-
-    @Override public String toString() {
-      return "Pong[" + buffer + "]";
-    }
-
-    @Override public int hashCode() {
-      return buffer.hashCode();
-    }
-
-    @Override public boolean equals(Object obj) {
-      if (obj instanceof Pong) {
-        Pong other = (Pong) obj;
-        return buffer == null ? other.buffer == null : buffer.equals(other.buffer);
-      }
-      return false;
-    }
-  }
-
-  private static class Close {
-    public final int code;
-    public final String reason;
-
-    private Close(int code, String reason) {
-      this.code = code;
-      this.reason = reason;
-    }
-
-    @Override public String toString() {
-      return "Close[" + code + " " + reason + "]";
-    }
-
-    @Override public int hashCode() {
-      return code * 37 + reason.hashCode();
-    }
-
-    @Override public boolean equals(Object obj) {
-      if (obj instanceof Close) {
-        Close other = (Close) obj;
-        return code == other.code && reason.equals(other.reason);
-      }
-      return false;
-    }
-  }
-}
diff --git a/okhttp-ws/README.md b/okhttp-ws/README.md
deleted file mode 100644
index 054ea91fbf..0000000000
--- a/okhttp-ws/README.md
+++ /dev/null
@@ -1,22 +0,0 @@
-OkHttp Web Sockets
-==================
-
-RFC6455-compliant web socket implementation.
-
-Create a `WebSocketCall` with a `Request` and an `OkHttpClient` instance.
-```java
-WebSocketCall call = WebSocketCall.create(client, request);
-```
-
-A `WebSocketListener` will notify of the initial connection, server-sent messages, and any failures
-on the connection.
-
-Start the web socket by calling `enqueue` on `WebSocketCall` with the `WebSocketListener`.
-```java
-call.enqueue(new WebSocketListener() {
-  // ...
-});
-```
-
-*Note: This module's API should be considered experimental and may be subject to breaking changes
-in future releases.*
diff --git a/okhttp-ws/pom.xml b/okhttp-ws/pom.xml
deleted file mode 100644
index e6dbdb5472..0000000000
--- a/okhttp-ws/pom.xml
+++ /dev/null
@@ -1,37 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.3.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>okhttp-ws</artifactId>
-  <name>OkHttp Web Sockets</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-javadoc-plugin</artifactId>
-        <configuration>
-          <excludePackageNames>okhttp3.internal.*</excludePackageNames>
-          <links>
-            <link>http://square.github.io/okhttp/javadoc/</link>
-          </links>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/okhttp-ws/src/main/java/okhttp3/internal/ws/RealWebSocket.java b/okhttp-ws/src/main/java/okhttp3/internal/ws/RealWebSocket.java
deleted file mode 100644
index b9af6bdd65..0000000000
--- a/okhttp-ws/src/main/java/okhttp3/internal/ws/RealWebSocket.java
+++ /dev/null
@@ -1,222 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.ws;
-
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.util.Random;
-import java.util.concurrent.Executor;
-import java.util.concurrent.atomic.AtomicBoolean;
-import okhttp3.MediaType;
-import okhttp3.RequestBody;
-import okhttp3.ResponseBody;
-import okhttp3.internal.NamedRunnable;
-import okhttp3.ws.WebSocket;
-import okhttp3.ws.WebSocketListener;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.Okio;
-
-import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_BINARY;
-import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_TEXT;
-import static okhttp3.internal.ws.WebSocketReader.FrameCallback;
-
-public abstract class RealWebSocket implements WebSocket {
-  private static final int CLOSE_PROTOCOL_EXCEPTION = 1002;
-
-  private final WebSocketWriter writer;
-  private final WebSocketReader reader;
-  private final WebSocketListener listener;
-
-  /** True after calling {@link #close(int, String)}. No writes are allowed afterward. */
-  private volatile boolean writerSentClose;
-  /** True after {@link IOException}. {@link #close(int, String)} becomes only valid call. */
-  private boolean writerWantsClose;
-  /** True after a close frame was read by the reader. No frames will follow it. */
-  private boolean readerSentClose;
-
-  /** True after calling {@link #close()} to free connection resources. */
-  private final AtomicBoolean connectionClosed = new AtomicBoolean();
-
-  public RealWebSocket(boolean isClient, BufferedSource source, BufferedSink sink, Random random,
-      final Executor replyExecutor, final WebSocketListener listener, final String url) {
-    this.listener = listener;
-
-    writer = new WebSocketWriter(isClient, sink, random);
-    reader = new WebSocketReader(isClient, source, new FrameCallback() {
-      @Override public void onMessage(ResponseBody message) throws IOException {
-        listener.onMessage(message);
-      }
-
-      @Override public void onPing(final Buffer buffer) {
-        replyExecutor.execute(new NamedRunnable("OkHttp %s WebSocket Pong Reply", url) {
-          @Override protected void execute() {
-            try {
-              writer.writePong(buffer);
-            } catch (IOException ignored) {
-            }
-          }
-        });
-      }
-
-      @Override public void onPong(Buffer buffer) {
-        listener.onPong(buffer);
-      }
-
-      @Override public void onClose(final int code, final String reason) {
-        readerSentClose = true;
-        replyExecutor.execute(new NamedRunnable("OkHttp %s WebSocket Close Reply", url) {
-          @Override protected void execute() {
-            peerClose(code, reason);
-          }
-        });
-      }
-    });
-  }
-
-  /**
-   * Read a single message from the web socket and deliver it to the listener. This method should be
-   * called in a loop with the return value indicating whether looping should continue.
-   */
-  public boolean readMessage() {
-    try {
-      reader.processNextFrame();
-      return !readerSentClose;
-    } catch (IOException e) {
-      readerErrorClose(e);
-      return false;
-    }
-  }
-
-  @Override public void sendMessage(RequestBody message) throws IOException {
-    if (message == null) throw new NullPointerException("message == null");
-    if (writerSentClose) throw new IllegalStateException("closed");
-    if (writerWantsClose) throw new IllegalStateException("must call close()");
-
-    MediaType contentType = message.contentType();
-    if (contentType == null) {
-      throw new IllegalArgumentException(
-          "Message content type was null. Must use WebSocket.TEXT or WebSocket.BINARY.");
-    }
-    String contentSubtype = contentType.subtype();
-
-    int formatOpcode;
-    if (WebSocket.TEXT.subtype().equals(contentSubtype)) {
-      formatOpcode = OPCODE_TEXT;
-    } else if (WebSocket.BINARY.subtype().equals(contentSubtype)) {
-      formatOpcode = OPCODE_BINARY;
-    } else {
-      throw new IllegalArgumentException("Unknown message content type: "
-          + contentType.type() + "/" + contentType.subtype() // Omit any implicitly added charset.
-          + ". Must use WebSocket.TEXT or WebSocket.BINARY.");
-    }
-
-    BufferedSink sink = Okio.buffer(writer.newMessageSink(formatOpcode, message.contentLength()));
-    try {
-      message.writeTo(sink);
-      sink.close();
-    } catch (IOException e) {
-      writerWantsClose = true;
-      throw e;
-    }
-  }
-
-  @Override public void sendPing(Buffer payload) throws IOException {
-    if (writerSentClose) throw new IllegalStateException("closed");
-    if (writerWantsClose) throw new IllegalStateException("must call close()");
-
-    try {
-      writer.writePing(payload);
-    } catch (IOException e) {
-      writerWantsClose = true;
-      throw e;
-    }
-  }
-
-  /** Send an unsolicited pong with the specified payload. */
-  public void sendPong(Buffer payload) throws IOException {
-    if (writerSentClose) throw new IllegalStateException("closed");
-    if (writerWantsClose) throw new IllegalStateException("must call close()");
-
-    try {
-      writer.writePong(payload);
-    } catch (IOException e) {
-      writerWantsClose = true;
-      throw e;
-    }
-  }
-
-  @Override public void close(int code, String reason) throws IOException {
-    if (writerSentClose) throw new IllegalStateException("closed");
-    writerSentClose = true;
-
-    try {
-      writer.writeClose(code, reason);
-    } catch (IOException e) {
-      if (connectionClosed.compareAndSet(false, true)) {
-        // Try to close the connection without masking the original exception.
-        try {
-          close();
-        } catch (IOException ignored) {
-        }
-      }
-      throw e;
-    }
-  }
-
-  /** Replies and closes this web socket when a close frame is read from the peer. */
-  private void peerClose(int code, String reason) {
-    if (!writerSentClose) {
-      try {
-        writer.writeClose(code, reason);
-      } catch (IOException ignored) {
-      }
-    }
-
-    if (connectionClosed.compareAndSet(false, true)) {
-      try {
-        close();
-      } catch (IOException ignored) {
-      }
-    }
-
-    listener.onClose(code, reason);
-  }
-
-  /** Called on the reader thread when an error occurs. */
-  private void readerErrorClose(IOException e) {
-    // For protocol exceptions, try to inform the server of such.
-    if (!writerSentClose && e instanceof ProtocolException) {
-      try {
-        writer.writeClose(CLOSE_PROTOCOL_EXCEPTION, null);
-      } catch (IOException ignored) {
-      }
-    }
-
-    if (connectionClosed.compareAndSet(false, true)) {
-      try {
-        close();
-      } catch (IOException ignored) {
-      }
-    }
-
-    listener.onFailure(e, null);
-  }
-
-  /** Perform any tear-down work (close the connection, shutdown executors). */
-  protected abstract void close() throws IOException;
-}
diff --git a/okhttp-ws/src/main/java/okhttp3/ws/WebSocketListener.java b/okhttp-ws/src/main/java/okhttp3/ws/WebSocketListener.java
deleted file mode 100644
index 12d5e66aab..0000000000
--- a/okhttp-ws/src/main/java/okhttp3/ws/WebSocketListener.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.ws;
-
-import java.io.IOException;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okio.Buffer;
-
-/** Listener for server-initiated messages on a connected {@link WebSocket}. */
-public interface WebSocketListener {
-  /**
-   * Called when the request has successfully been upgraded to a web socket. This method is called
-   * on the message reading thread to allow setting up any state before the {@linkplain #onMessage
-   * message}, {@linkplain #onPong pong}, and {@link #onClose close} callbacks start.
-   *
-   * <p><b>Do not</b> use this callback to write to the web socket. Start a new thread or use
-   * another thread in your application.
-   */
-  void onOpen(WebSocket webSocket, Response response);
-
-  /**
-   * Called when the transport or protocol layer of this web socket errors during communication.
-   *
-   * @param response Present when the failure is a direct result of the response (e.g., failed
-   * upgrade, non-101 response code, etc.). {@code null} otherwise.
-   */
-  void onFailure(IOException e, Response response);
-
-  /**
-   * Called when a server message is received. The {@code type} indicates whether the {@code
-   * payload} should be interpreted as UTF-8 text or binary data.
-   *
-   * <p>Implementations <strong>must</strong> call {@code source.close()} before returning. This
-   * indicates completion of parsing the message payload and will consume any remaining bytes in the
-   * message.
-   *
-   * <p>The {@linkplain ResponseBody#contentType() content type} of {@code message} will be either
-   * {@link WebSocket#TEXT} or {@link WebSocket#BINARY} which indicates the format of the message.
-   */
-  void onMessage(ResponseBody message) throws IOException;
-
-  /**
-   * Called when a server pong is received. This is usually a result of calling {@link
-   * WebSocket#sendPing(Buffer)} but might also be unsolicited.
-   */
-  void onPong(Buffer payload);
-
-  /**
-   * Called when the server sends a close message. This may have been initiated from a call to
-   * {@link WebSocket#close(int, String) close()} or as an unprompted message from the server.
-   *
-   * @param code The <a href="http://tools.ietf.org/html/rfc6455#section-7.4.1">RFC-compliant</a>
-   * status code.
-   * @param reason Reason for close or an empty string.
-   */
-  void onClose(int code, String reason);
-}
diff --git a/okhttp/pom.xml b/okhttp/pom.xml
index 0db4e1a85e..2e07de0875 100644
--- a/okhttp/pom.xml
+++ b/okhttp/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.3.0-SNAPSHOT</version>
+    <version>3.5.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp</artifactId>
diff --git a/okhttp/src/main/java/okhttp3/Authenticator.java b/okhttp/src/main/java/okhttp3/Authenticator.java
index ede539805f..3463690f7b 100644
--- a/okhttp/src/main/java/okhttp3/Authenticator.java
+++ b/okhttp/src/main/java/okhttp3/Authenticator.java
@@ -33,7 +33,7 @@
  *        .build();
  * }</pre>
  *
- * <p>Whn authentication is requested by a proxy server, the response code is 407 and the
+ * <p>When authentication is requested by a proxy server, the response code is 407 and the
  * implementation should respond with a new request that sets the "Proxy-Authorization" header.
  * <pre>   {@code
  *
diff --git a/okhttp/src/main/java/okhttp3/Cache.java b/okhttp/src/main/java/okhttp3/Cache.java
index 7e0b2431a4..2f8a9c2405 100644
--- a/okhttp/src/main/java/okhttp3/Cache.java
+++ b/okhttp/src/main/java/okhttp3/Cache.java
@@ -28,15 +28,16 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.NoSuchElementException;
-import okhttp3.internal.DiskLruCache;
-import okhttp3.internal.InternalCache;
 import okhttp3.internal.Util;
-import okhttp3.internal.http.CacheRequest;
-import okhttp3.internal.http.CacheStrategy;
+import okhttp3.internal.cache.CacheRequest;
+import okhttp3.internal.cache.CacheStrategy;
+import okhttp3.internal.cache.DiskLruCache;
+import okhttp3.internal.cache.InternalCache;
+import okhttp3.internal.http.HttpHeaders;
 import okhttp3.internal.http.HttpMethod;
-import okhttp3.internal.http.OkHeaders;
 import okhttp3.internal.http.StatusLine;
 import okhttp3.internal.io.FileSystem;
+import okhttp3.internal.platform.Platform;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -151,7 +152,7 @@
       Cache.this.remove(request);
     }
 
-    @Override public void update(Response cached, Response network) throws IOException {
+    @Override public void update(Response cached, Response network) {
       Cache.this.update(cached, network);
     }
 
@@ -216,7 +217,7 @@ Response get(Request request) {
     return response;
   }
 
-  private CacheRequest put(Response response) throws IOException {
+  private CacheRequest put(Response response) {
     String requestMethod = response.request().method();
 
     if (HttpMethod.invalidatesCache(response.request().method())) {
@@ -234,7 +235,7 @@ private CacheRequest put(Response response) throws IOException {
       return null;
     }
 
-    if (OkHeaders.hasVaryAll(response)) {
+    if (HttpHeaders.hasVaryAll(response)) {
       return null;
     }
 
@@ -431,7 +432,7 @@ public synchronized int requestCount() {
     private boolean done;
     private Sink body;
 
-    public CacheRequestImpl(final DiskLruCache.Editor editor) throws IOException {
+    public CacheRequestImpl(final DiskLruCache.Editor editor) {
       this.editor = editor;
       this.cacheOut = editor.newSink(ENTRY_BODY);
       this.body = new ForwardingSink(cacheOut) {
@@ -470,6 +471,12 @@ public CacheRequestImpl(final DiskLruCache.Editor editor) throws IOException {
   }
 
   private static final class Entry {
+    /** Synthetic response header: the local time when the request was sent. */
+    private static final String SENT_MILLIS = Platform.get().getPrefix() + "-Sent-Millis";
+
+    /** Synthetic response header: the local time when the response was received. */
+    private static final String RECEIVED_MILLIS = Platform.get().getPrefix() + "-Received-Millis";
+
     private final String url;
     private final Headers varyHeaders;
     private final String requestMethod;
@@ -478,6 +485,8 @@ public CacheRequestImpl(final DiskLruCache.Editor editor) throws IOException {
     private final String message;
     private final Headers responseHeaders;
     private final Handshake handshake;
+    private final long sentRequestMillis;
+    private final long receivedResponseMillis;
 
     /**
      * Reads an entry from an input stream. A typical entry looks like this:
@@ -548,6 +557,16 @@ public Entry(Source in) throws IOException {
         for (int i = 0; i < responseHeaderLineCount; i++) {
           responseHeadersBuilder.addLenient(source.readUtf8LineStrict());
         }
+        String sendRequestMillisString = responseHeadersBuilder.get(SENT_MILLIS);
+        String receivedResponseMillisString = responseHeadersBuilder.get(RECEIVED_MILLIS);
+        responseHeadersBuilder.removeAll(SENT_MILLIS);
+        responseHeadersBuilder.removeAll(RECEIVED_MILLIS);
+        sentRequestMillis = sendRequestMillisString != null
+            ? Long.parseLong(sendRequestMillisString)
+            : 0L;
+        receivedResponseMillis = receivedResponseMillisString != null
+            ? Long.parseLong(receivedResponseMillisString)
+            : 0L;
         responseHeaders = responseHeadersBuilder.build();
 
         if (isHttps()) {
@@ -573,52 +592,62 @@ public Entry(Source in) throws IOException {
 
     public Entry(Response response) {
       this.url = response.request().url().toString();
-      this.varyHeaders = OkHeaders.varyHeaders(response);
+      this.varyHeaders = HttpHeaders.varyHeaders(response);
       this.requestMethod = response.request().method();
       this.protocol = response.protocol();
       this.code = response.code();
       this.message = response.message();
       this.responseHeaders = response.headers();
       this.handshake = response.handshake();
+      this.sentRequestMillis = response.sentRequestAtMillis();
+      this.receivedResponseMillis = response.receivedResponseAtMillis();
     }
 
     public void writeTo(DiskLruCache.Editor editor) throws IOException {
       BufferedSink sink = Okio.buffer(editor.newSink(ENTRY_METADATA));
 
-      sink.writeUtf8(url);
-      sink.writeByte('\n');
-      sink.writeUtf8(requestMethod);
-      sink.writeByte('\n');
-      sink.writeDecimalLong(varyHeaders.size());
-      sink.writeByte('\n');
+      sink.writeUtf8(url)
+          .writeByte('\n');
+      sink.writeUtf8(requestMethod)
+          .writeByte('\n');
+      sink.writeDecimalLong(varyHeaders.size())
+          .writeByte('\n');
       for (int i = 0, size = varyHeaders.size(); i < size; i++) {
-        sink.writeUtf8(varyHeaders.name(i));
-        sink.writeUtf8(": ");
-        sink.writeUtf8(varyHeaders.value(i));
-        sink.writeByte('\n');
+        sink.writeUtf8(varyHeaders.name(i))
+            .writeUtf8(": ")
+            .writeUtf8(varyHeaders.value(i))
+            .writeByte('\n');
       }
 
-      sink.writeUtf8(new StatusLine(protocol, code, message).toString());
-      sink.writeByte('\n');
-      sink.writeDecimalLong(responseHeaders.size());
-      sink.writeByte('\n');
+      sink.writeUtf8(new StatusLine(protocol, code, message).toString())
+          .writeByte('\n');
+      sink.writeDecimalLong(responseHeaders.size() + 2)
+          .writeByte('\n');
       for (int i = 0, size = responseHeaders.size(); i < size; i++) {
-        sink.writeUtf8(responseHeaders.name(i));
-        sink.writeUtf8(": ");
-        sink.writeUtf8(responseHeaders.value(i));
-        sink.writeByte('\n');
+        sink.writeUtf8(responseHeaders.name(i))
+            .writeUtf8(": ")
+            .writeUtf8(responseHeaders.value(i))
+            .writeByte('\n');
       }
+      sink.writeUtf8(SENT_MILLIS)
+          .writeUtf8(": ")
+          .writeDecimalLong(sentRequestMillis)
+          .writeByte('\n');
+      sink.writeUtf8(RECEIVED_MILLIS)
+          .writeUtf8(": ")
+          .writeDecimalLong(receivedResponseMillis)
+          .writeByte('\n');
 
       if (isHttps()) {
         sink.writeByte('\n');
-        sink.writeUtf8(handshake.cipherSuite().javaName());
-        sink.writeByte('\n');
+        sink.writeUtf8(handshake.cipherSuite().javaName())
+            .writeByte('\n');
         writeCertList(sink, handshake.peerCertificates());
         writeCertList(sink, handshake.localCertificates());
         // The handshake’s TLS version is null on HttpsURLConnection and on older cached responses.
         if (handshake.tlsVersion() != null) {
-          sink.writeUtf8(handshake.tlsVersion().javaName());
-          sink.writeByte('\n');
+          sink.writeUtf8(handshake.tlsVersion().javaName())
+              .writeByte('\n');
         }
       }
       sink.close();
@@ -650,13 +679,13 @@ private boolean isHttps() {
     private void writeCertList(BufferedSink sink, List<Certificate> certificates)
         throws IOException {
       try {
-        sink.writeDecimalLong(certificates.size());
-        sink.writeByte('\n');
+        sink.writeDecimalLong(certificates.size())
+            .writeByte('\n');
         for (int i = 0, size = certificates.size(); i < size; i++) {
           byte[] bytes = certificates.get(i).getEncoded();
           String line = ByteString.of(bytes).base64();
-          sink.writeUtf8(line);
-          sink.writeByte('\n');
+          sink.writeUtf8(line)
+              .writeByte('\n');
         }
       } catch (CertificateEncodingException e) {
         throw new IOException(e.getMessage());
@@ -666,7 +695,7 @@ private void writeCertList(BufferedSink sink, List<Certificate> certificates)
     public boolean matches(Request request, Response response) {
       return url.equals(request.url().toString())
           && requestMethod.equals(request.method())
-          && OkHeaders.varyMatches(response, varyHeaders, request);
+          && HttpHeaders.varyMatches(response, varyHeaders, request);
     }
 
     public Response response(DiskLruCache.Snapshot snapshot) {
@@ -685,6 +714,8 @@ public Response response(DiskLruCache.Snapshot snapshot) {
           .headers(responseHeaders)
           .body(new CacheResponseBody(snapshot, contentType, contentLength))
           .handshake(handshake)
+          .sentRequestAtMillis(sentRequestMillis)
+          .receivedResponseAtMillis(receivedResponseMillis)
           .build();
     }
   }
diff --git a/okhttp/src/main/java/okhttp3/CacheControl.java b/okhttp/src/main/java/okhttp3/CacheControl.java
index d8eb446149..9dcdbd3c2e 100644
--- a/okhttp/src/main/java/okhttp3/CacheControl.java
+++ b/okhttp/src/main/java/okhttp3/CacheControl.java
@@ -1,7 +1,7 @@
 package okhttp3;
 
 import java.util.concurrent.TimeUnit;
-import okhttp3.internal.http.HeaderParser;
+import okhttp3.internal.http.HttpHeaders;
 
 /**
  * A Cache-Control header with cache directives from a server or client. These directives set policy
@@ -178,7 +178,7 @@ public static CacheControl parse(Headers headers) {
       int pos = 0;
       while (pos < value.length()) {
         int tokenStart = pos;
-        pos = HeaderParser.skipUntil(value, pos, "=,;");
+        pos = HttpHeaders.skipUntil(value, pos, "=,;");
         String directive = value.substring(tokenStart, pos).trim();
         String parameter;
 
@@ -187,20 +187,20 @@ public static CacheControl parse(Headers headers) {
           parameter = null;
         } else {
           pos++; // consume '='
-          pos = HeaderParser.skipWhitespace(value, pos);
+          pos = HttpHeaders.skipWhitespace(value, pos);
 
           // quoted string
           if (pos < value.length() && value.charAt(pos) == '\"') {
             pos++; // consume '"' open quote
             int parameterStart = pos;
-            pos = HeaderParser.skipUntil(value, pos, "\"");
+            pos = HttpHeaders.skipUntil(value, pos, "\"");
             parameter = value.substring(parameterStart, pos);
             pos++; // consume '"' close quote (if necessary)
 
             // unquoted string
           } else {
             int parameterStart = pos;
-            pos = HeaderParser.skipUntil(value, pos, ",;");
+            pos = HttpHeaders.skipUntil(value, pos, ",;");
             parameter = value.substring(parameterStart, pos).trim();
           }
         }
@@ -210,9 +210,9 @@ public static CacheControl parse(Headers headers) {
         } else if ("no-store".equalsIgnoreCase(directive)) {
           noStore = true;
         } else if ("max-age".equalsIgnoreCase(directive)) {
-          maxAgeSeconds = HeaderParser.parseSeconds(parameter, -1);
+          maxAgeSeconds = HttpHeaders.parseSeconds(parameter, -1);
         } else if ("s-maxage".equalsIgnoreCase(directive)) {
-          sMaxAgeSeconds = HeaderParser.parseSeconds(parameter, -1);
+          sMaxAgeSeconds = HttpHeaders.parseSeconds(parameter, -1);
         } else if ("private".equalsIgnoreCase(directive)) {
           isPrivate = true;
         } else if ("public".equalsIgnoreCase(directive)) {
@@ -220,9 +220,9 @@ public static CacheControl parse(Headers headers) {
         } else if ("must-revalidate".equalsIgnoreCase(directive)) {
           mustRevalidate = true;
         } else if ("max-stale".equalsIgnoreCase(directive)) {
-          maxStaleSeconds = HeaderParser.parseSeconds(parameter, Integer.MAX_VALUE);
+          maxStaleSeconds = HttpHeaders.parseSeconds(parameter, Integer.MAX_VALUE);
         } else if ("min-fresh".equalsIgnoreCase(directive)) {
-          minFreshSeconds = HeaderParser.parseSeconds(parameter, -1);
+          minFreshSeconds = HttpHeaders.parseSeconds(parameter, -1);
         } else if ("only-if-cached".equalsIgnoreCase(directive)) {
           onlyIfCached = true;
         } else if ("no-transform".equalsIgnoreCase(directive)) {
diff --git a/okhttp/src/main/java/okhttp3/Call.java b/okhttp/src/main/java/okhttp3/Call.java
index 58506d1376..fccf857c13 100644
--- a/okhttp/src/main/java/okhttp3/Call.java
+++ b/okhttp/src/main/java/okhttp3/Call.java
@@ -21,7 +21,7 @@
  * A call is a request that has been prepared for execution. A call can be canceled. As this object
  * represents a single request/response pair (stream), it cannot be executed twice.
  */
-public interface Call {
+public interface Call extends Cloneable {
   /** Returns the original request that initiated this call. */
   Request request();
 
@@ -29,9 +29,8 @@
    * Invokes the request immediately, and blocks until the response can be processed or is in
    * error.
    *
-   * <p>The caller may read the response body with the response's {@link Response#body} method.  To
-   * facilitate connection recycling, callers should always {@link ResponseBody#close() close the
-   * response body}.
+   * <p>The caller may read the response body with the response's {@link Response#body} method. To
+   * avoid leaking resources callers must {@linkplain ResponseBody close the response body}.
    *
    * <p>Note that transport-layer success (receiving a HTTP response code, headers and body) does
    * not necessarily indicate application-layer success: {@code response} may still indicate an
@@ -68,6 +67,12 @@
 
   boolean isCanceled();
 
+  /**
+   * Create a new, identical call to this one which can be enqueued or executed even if this call
+   * has already been.
+   */
+  Call clone();
+
   interface Factory {
     Call newCall(Request request);
   }
diff --git a/okhttp/src/main/java/okhttp3/Callback.java b/okhttp/src/main/java/okhttp3/Callback.java
index 42a8a109b2..3b7ed85bf4 100644
--- a/okhttp/src/main/java/okhttp3/Callback.java
+++ b/okhttp/src/main/java/okhttp3/Callback.java
@@ -28,8 +28,8 @@
   /**
    * Called when the HTTP response was successfully returned by the remote server. The callback may
    * proceed to read the response body with {@link Response#body}. The response is still live until
-   * its response body is closed with {@code response.body().close()}. The recipient of the callback
-   * may even consume the response body on another thread.
+   * its response body is {@linkplain ResponseBody closed}. The recipient of the callback may
+   * consume the response body on another thread.
    *
    * <p>Note that transport-layer success (receiving a HTTP response code, headers and body) does
    * not necessarily indicate application-layer success: {@code response} may still indicate an
diff --git a/okhttp/src/main/java/okhttp3/CertificatePinner.java b/okhttp/src/main/java/okhttp3/CertificatePinner.java
index 2d90224922..2695a55e42 100644
--- a/okhttp/src/main/java/okhttp3/CertificatePinner.java
+++ b/okhttp/src/main/java/okhttp3/CertificatePinner.java
@@ -237,8 +237,11 @@ static ByteString sha256(X509Certificate x509Certificate) {
   }
 
   static final class Pin {
+    private static final String WILDCARD = "*.";
     /** A hostname like {@code example.com} or a pattern like {@code *.example.com}. */
     final String pattern;
+    /** The canonical hostname, i.e. {@code EXAMPLE.com} becomes {@code example.com}. */
+    final String canonicalHostname;
     /** Either {@code sha1/} or {@code sha256/}. */
     final String hashAlgorithm;
     /** The hash of the pinned certificate using {@link #hashAlgorithm}. */
@@ -246,6 +249,9 @@ static ByteString sha256(X509Certificate x509Certificate) {
 
     Pin(String pattern, String pin) {
       this.pattern = pattern;
+      this.canonicalHostname = pattern.startsWith(WILDCARD)
+          ? HttpUrl.parse("http://" + pattern.substring(WILDCARD.length())).host()
+          : HttpUrl.parse("http://" + pattern).host();
       if (pin.startsWith("sha1/")) {
         this.hashAlgorithm = "sha1/";
         this.hash = ByteString.decodeBase64(pin.substring("sha1/".length()));
@@ -262,11 +268,13 @@ static ByteString sha256(X509Certificate x509Certificate) {
     }
 
     boolean matches(String hostname) {
-      if (pattern.equals(hostname)) return true;
+      if (pattern.startsWith(WILDCARD)) {
+        int firstDot = hostname.indexOf('.');
+        return hostname.regionMatches(false, firstDot + 1, canonicalHostname, 0,
+            canonicalHostname.length());
+      }
 
-      int firstDot = hostname.indexOf('.');
-      return pattern.startsWith("*.")
-          && hostname.regionMatches(false, firstDot + 1, pattern, 2, pattern.length() - 2);
+      return hostname.equals(canonicalHostname);
     }
 
     @Override public boolean equals(Object other) {
diff --git a/okhttp/src/main/java/okhttp3/CipherSuite.java b/okhttp/src/main/java/okhttp3/CipherSuite.java
index 6697cad846..a3acd52e2f 100644
--- a/okhttp/src/main/java/okhttp3/CipherSuite.java
+++ b/okhttp/src/main/java/okhttp3/CipherSuite.java
@@ -15,7 +15,8 @@
  */
 package okhttp3;
 
-import static java.lang.Integer.MAX_VALUE;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 
 /**
  * <a href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml">TLS cipher
@@ -29,356 +30,385 @@
  * <p>See also <a href="https://android.googlesource.com/platform/external/conscrypt/+/master/src/main/java/org/conscrypt/NativeCrypto.java">NativeCrypto.java</a>
  * from conscrypt, which lists the cipher suites supported by Android.
  */
-public enum CipherSuite {
-  // Last updated 2014-11-11 using cipher suites from Android 21 and Java 8.
+public final class CipherSuite {
+  /**
+   * Holds interned instances. This needs to be above the of() calls below so that it's
+   * initialized by the time those parts of {@code <clinit>()} run.
+   */
+  private static final ConcurrentMap<String, CipherSuite> INSTANCES = new ConcurrentHashMap<>();
 
-  // TLS_NULL_WITH_NULL_NULL("TLS_NULL_WITH_NULL_NULL", 0x0000, 5246, MAX_VALUE, MAX_VALUE),
-  TLS_RSA_WITH_NULL_MD5("SSL_RSA_WITH_NULL_MD5", 0x0001, 5246, 6, 10),
-  TLS_RSA_WITH_NULL_SHA("SSL_RSA_WITH_NULL_SHA", 0x0002, 5246, 6, 10),
-  TLS_RSA_EXPORT_WITH_RC4_40_MD5("SSL_RSA_EXPORT_WITH_RC4_40_MD5", 0x0003, 4346, 6, 10),
-  TLS_RSA_WITH_RC4_128_MD5("SSL_RSA_WITH_RC4_128_MD5", 0x0004, 5246, 6, 10),
-  TLS_RSA_WITH_RC4_128_SHA("SSL_RSA_WITH_RC4_128_SHA", 0x0005, 5246, 6, 10),
-  // TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5("SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5", 0x0006, 4346, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_IDEA_CBC_SHA("TLS_RSA_WITH_IDEA_CBC_SHA", 0x0007, 5469, MAX_VALUE, MAX_VALUE),
-  TLS_RSA_EXPORT_WITH_DES40_CBC_SHA("SSL_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0008, 4346, 6, 10),
-  TLS_RSA_WITH_DES_CBC_SHA("SSL_RSA_WITH_DES_CBC_SHA", 0x0009, 5469, 6, 10),
-  TLS_RSA_WITH_3DES_EDE_CBC_SHA("SSL_RSA_WITH_3DES_EDE_CBC_SHA", 0x000a, 5246, 6, 10),
-  // TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA("SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x000b, 4346, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_DES_CBC_SHA("TLS_DH_DSS_WITH_DES_CBC_SHA", 0x000c, 5469, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA("TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA", 0x000d, 5246, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA("SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x000e, 4346, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_DES_CBC_SHA("TLS_DH_RSA_WITH_DES_CBC_SHA", 0x000f, 5469, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA("TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA", 0x0010, 5246, MAX_VALUE, MAX_VALUE),
-  TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA("SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x0011, 4346, 6, 10),
-  TLS_DHE_DSS_WITH_DES_CBC_SHA("SSL_DHE_DSS_WITH_DES_CBC_SHA", 0x0012, 5469, 6, 10),
-  TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA("SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA", 0x0013, 5246, 6, 10),
-  TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA("SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0014, 4346, 6, 10),
-  TLS_DHE_RSA_WITH_DES_CBC_SHA("SSL_DHE_RSA_WITH_DES_CBC_SHA", 0x0015, 5469, 6, 10),
-  TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA("SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA", 0x0016, 5246, 6, 10),
-  TLS_DH_anon_EXPORT_WITH_RC4_40_MD5("SSL_DH_anon_EXPORT_WITH_RC4_40_MD5", 0x0017, 4346, 6, 10),
-  TLS_DH_anon_WITH_RC4_128_MD5("SSL_DH_anon_WITH_RC4_128_MD5", 0x0018, 5246, 6, 10),
-  TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA("SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA", 0x0019, 4346, 6, 10),
-  TLS_DH_anon_WITH_DES_CBC_SHA("SSL_DH_anon_WITH_DES_CBC_SHA", 0x001a, 5469, 6, 10),
-  TLS_DH_anon_WITH_3DES_EDE_CBC_SHA("SSL_DH_anon_WITH_3DES_EDE_CBC_SHA", 0x001b, 5246, 6, 10),
-  TLS_KRB5_WITH_DES_CBC_SHA("TLS_KRB5_WITH_DES_CBC_SHA", 0x001e, 2712, 6, MAX_VALUE),
-  TLS_KRB5_WITH_3DES_EDE_CBC_SHA("TLS_KRB5_WITH_3DES_EDE_CBC_SHA", 0x001f, 2712, 6, MAX_VALUE),
-  TLS_KRB5_WITH_RC4_128_SHA("TLS_KRB5_WITH_RC4_128_SHA", 0x0020, 2712, 6, MAX_VALUE),
-  // TLS_KRB5_WITH_IDEA_CBC_SHA("TLS_KRB5_WITH_IDEA_CBC_SHA", 0x0021, 2712, MAX_VALUE, MAX_VALUE),
-  TLS_KRB5_WITH_DES_CBC_MD5("TLS_KRB5_WITH_DES_CBC_MD5", 0x0022, 2712, 6, MAX_VALUE),
-  TLS_KRB5_WITH_3DES_EDE_CBC_MD5("TLS_KRB5_WITH_3DES_EDE_CBC_MD5", 0x0023, 2712, 6, MAX_VALUE),
-  TLS_KRB5_WITH_RC4_128_MD5("TLS_KRB5_WITH_RC4_128_MD5", 0x0024, 2712, 6, MAX_VALUE),
-  // TLS_KRB5_WITH_IDEA_CBC_MD5("TLS_KRB5_WITH_IDEA_CBC_MD5", 0x0025, 2712, MAX_VALUE, MAX_VALUE),
-  TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA("TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA", 0x0026, 2712, 6, MAX_VALUE),
-  // TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA", 0x0027, 2712, MAX_VALUE, MAX_VALUE),
-  TLS_KRB5_EXPORT_WITH_RC4_40_SHA("TLS_KRB5_EXPORT_WITH_RC4_40_SHA", 0x0028, 2712, 6, MAX_VALUE),
-  TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5("TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5", 0x0029, 2712, 6, MAX_VALUE),
-  // TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5", 0x002a, 2712, MAX_VALUE, MAX_VALUE),
-  TLS_KRB5_EXPORT_WITH_RC4_40_MD5("TLS_KRB5_EXPORT_WITH_RC4_40_MD5", 0x002b, 2712, 6, MAX_VALUE),
-  // TLS_PSK_WITH_NULL_SHA("TLS_PSK_WITH_NULL_SHA", 0x002c, 4785, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_NULL_SHA("TLS_DHE_PSK_WITH_NULL_SHA", 0x002d, 4785, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_NULL_SHA("TLS_RSA_PSK_WITH_NULL_SHA", 0x002e, 4785, MAX_VALUE, MAX_VALUE),
-  TLS_RSA_WITH_AES_128_CBC_SHA("TLS_RSA_WITH_AES_128_CBC_SHA", 0x002f, 5246, 6, 10),
-  // TLS_DH_DSS_WITH_AES_128_CBC_SHA("TLS_DH_DSS_WITH_AES_128_CBC_SHA", 0x0030, 5246, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_AES_128_CBC_SHA("TLS_DH_RSA_WITH_AES_128_CBC_SHA", 0x0031, 5246, MAX_VALUE, MAX_VALUE),
-  TLS_DHE_DSS_WITH_AES_128_CBC_SHA("TLS_DHE_DSS_WITH_AES_128_CBC_SHA", 0x0032, 5246, 6, 10),
-  TLS_DHE_RSA_WITH_AES_128_CBC_SHA("TLS_DHE_RSA_WITH_AES_128_CBC_SHA", 0x0033, 5246, 6, 10),
-  TLS_DH_anon_WITH_AES_128_CBC_SHA("TLS_DH_anon_WITH_AES_128_CBC_SHA", 0x0034, 5246, 6, 10),
-  TLS_RSA_WITH_AES_256_CBC_SHA("TLS_RSA_WITH_AES_256_CBC_SHA", 0x0035, 5246, 6, 10),
-  // TLS_DH_DSS_WITH_AES_256_CBC_SHA("TLS_DH_DSS_WITH_AES_256_CBC_SHA", 0x0036, 5246, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_AES_256_CBC_SHA("TLS_DH_RSA_WITH_AES_256_CBC_SHA", 0x0037, 5246, MAX_VALUE, MAX_VALUE),
-  TLS_DHE_DSS_WITH_AES_256_CBC_SHA("TLS_DHE_DSS_WITH_AES_256_CBC_SHA", 0x0038, 5246, 6, 10),
-  TLS_DHE_RSA_WITH_AES_256_CBC_SHA("TLS_DHE_RSA_WITH_AES_256_CBC_SHA", 0x0039, 5246, 6, 10),
-  TLS_DH_anon_WITH_AES_256_CBC_SHA("TLS_DH_anon_WITH_AES_256_CBC_SHA", 0x003a, 5246, 6, 10),
-  TLS_RSA_WITH_NULL_SHA256("TLS_RSA_WITH_NULL_SHA256", 0x003b, 5246, 7, 21),
-  TLS_RSA_WITH_AES_128_CBC_SHA256("TLS_RSA_WITH_AES_128_CBC_SHA256", 0x003c, 5246, 7, 21),
-  TLS_RSA_WITH_AES_256_CBC_SHA256("TLS_RSA_WITH_AES_256_CBC_SHA256", 0x003d, 5246, 7, 21),
-  // TLS_DH_DSS_WITH_AES_128_CBC_SHA256("TLS_DH_DSS_WITH_AES_128_CBC_SHA256", 0x003e, 5246, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_AES_128_CBC_SHA256("TLS_DH_RSA_WITH_AES_128_CBC_SHA256", 0x003f, 5246, MAX_VALUE, MAX_VALUE),
-  TLS_DHE_DSS_WITH_AES_128_CBC_SHA256("TLS_DHE_DSS_WITH_AES_128_CBC_SHA256", 0x0040, 5246, 7, 21),
-  // TLS_RSA_WITH_CAMELLIA_128_CBC_SHA("TLS_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0041, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA("TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0042, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA("TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0043, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA("TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0044, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA("TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0045, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA("TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA", 0x0046, 5932, MAX_VALUE, MAX_VALUE),
-  TLS_DHE_RSA_WITH_AES_128_CBC_SHA256("TLS_DHE_RSA_WITH_AES_128_CBC_SHA256", 0x0067, 5246, 7, 21),
-  // TLS_DH_DSS_WITH_AES_256_CBC_SHA256("TLS_DH_DSS_WITH_AES_256_CBC_SHA256", 0x0068, 5246, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_AES_256_CBC_SHA256("TLS_DH_RSA_WITH_AES_256_CBC_SHA256", 0x0069, 5246, MAX_VALUE, MAX_VALUE),
-  TLS_DHE_DSS_WITH_AES_256_CBC_SHA256("TLS_DHE_DSS_WITH_AES_256_CBC_SHA256", 0x006a, 5246, 7, 21),
-  TLS_DHE_RSA_WITH_AES_256_CBC_SHA256("TLS_DHE_RSA_WITH_AES_256_CBC_SHA256", 0x006b, 5246, 7, 21),
-  TLS_DH_anon_WITH_AES_128_CBC_SHA256("TLS_DH_anon_WITH_AES_128_CBC_SHA256", 0x006c, 5246, 7, 21),
-  TLS_DH_anon_WITH_AES_256_CBC_SHA256("TLS_DH_anon_WITH_AES_256_CBC_SHA256", 0x006d, 5246, 7, 21),
-  // TLS_RSA_WITH_CAMELLIA_256_CBC_SHA("TLS_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0084, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA("TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0085, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA("TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0086, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA("TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0087, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA("TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0088, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA("TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA", 0x0089, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_RC4_128_SHA("TLS_PSK_WITH_RC4_128_SHA", 0x008a, 4279, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_3DES_EDE_CBC_SHA("TLS_PSK_WITH_3DES_EDE_CBC_SHA", 0x008b, 4279, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_AES_128_CBC_SHA("TLS_PSK_WITH_AES_128_CBC_SHA", 0x008c, 4279, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_AES_256_CBC_SHA("TLS_PSK_WITH_AES_256_CBC_SHA", 0x008d, 4279, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_RC4_128_SHA("TLS_DHE_PSK_WITH_RC4_128_SHA", 0x008e, 4279, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA("TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA", 0x008f, 4279, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_AES_128_CBC_SHA("TLS_DHE_PSK_WITH_AES_128_CBC_SHA", 0x0090, 4279, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_AES_256_CBC_SHA("TLS_DHE_PSK_WITH_AES_256_CBC_SHA", 0x0091, 4279, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_RC4_128_SHA("TLS_RSA_PSK_WITH_RC4_128_SHA", 0x0092, 4279, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA("TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA", 0x0093, 4279, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_AES_128_CBC_SHA("TLS_RSA_PSK_WITH_AES_128_CBC_SHA", 0x0094, 4279, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_AES_256_CBC_SHA("TLS_RSA_PSK_WITH_AES_256_CBC_SHA", 0x0095, 4279, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_SEED_CBC_SHA("TLS_RSA_WITH_SEED_CBC_SHA", 0x0096, 4162, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_SEED_CBC_SHA("TLS_DH_DSS_WITH_SEED_CBC_SHA", 0x0097, 4162, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_SEED_CBC_SHA("TLS_DH_RSA_WITH_SEED_CBC_SHA", 0x0098, 4162, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_DSS_WITH_SEED_CBC_SHA("TLS_DHE_DSS_WITH_SEED_CBC_SHA", 0x0099, 4162, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_SEED_CBC_SHA("TLS_DHE_RSA_WITH_SEED_CBC_SHA", 0x009a, 4162, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_anon_WITH_SEED_CBC_SHA("TLS_DH_anon_WITH_SEED_CBC_SHA", 0x009b, 4162, MAX_VALUE, MAX_VALUE),
-  TLS_RSA_WITH_AES_128_GCM_SHA256("TLS_RSA_WITH_AES_128_GCM_SHA256", 0x009c, 5288, 8, 21),
-  TLS_RSA_WITH_AES_256_GCM_SHA384("TLS_RSA_WITH_AES_256_GCM_SHA384", 0x009d, 5288, 8, 21),
-  TLS_DHE_RSA_WITH_AES_128_GCM_SHA256("TLS_DHE_RSA_WITH_AES_128_GCM_SHA256", 0x009e, 5288, 8, 21),
-  TLS_DHE_RSA_WITH_AES_256_GCM_SHA384("TLS_DHE_RSA_WITH_AES_256_GCM_SHA384", 0x009f, 5288, 8, 21),
-  // TLS_DH_RSA_WITH_AES_128_GCM_SHA256("TLS_DH_RSA_WITH_AES_128_GCM_SHA256", 0x00a0, 5288, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_AES_256_GCM_SHA384("TLS_DH_RSA_WITH_AES_256_GCM_SHA384", 0x00a1, 5288, MAX_VALUE, MAX_VALUE),
-  TLS_DHE_DSS_WITH_AES_128_GCM_SHA256("TLS_DHE_DSS_WITH_AES_128_GCM_SHA256", 0x00a2, 5288, 8, 21),
-  TLS_DHE_DSS_WITH_AES_256_GCM_SHA384("TLS_DHE_DSS_WITH_AES_256_GCM_SHA384", 0x00a3, 5288, 8, 21),
-  // TLS_DH_DSS_WITH_AES_128_GCM_SHA256("TLS_DH_DSS_WITH_AES_128_GCM_SHA256", 0x00a4, 5288, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_AES_256_GCM_SHA384("TLS_DH_DSS_WITH_AES_256_GCM_SHA384", 0x00a5, 5288, MAX_VALUE, MAX_VALUE),
-  TLS_DH_anon_WITH_AES_128_GCM_SHA256("TLS_DH_anon_WITH_AES_128_GCM_SHA256", 0x00a6, 5288, 8, 21),
-  TLS_DH_anon_WITH_AES_256_GCM_SHA384("TLS_DH_anon_WITH_AES_256_GCM_SHA384", 0x00a7, 5288, 8, 21),
-  // TLS_PSK_WITH_AES_128_GCM_SHA256("TLS_PSK_WITH_AES_128_GCM_SHA256", 0x00a8, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_AES_256_GCM_SHA384("TLS_PSK_WITH_AES_256_GCM_SHA384", 0x00a9, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_AES_128_GCM_SHA256("TLS_DHE_PSK_WITH_AES_128_GCM_SHA256", 0x00aa, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_AES_256_GCM_SHA384("TLS_DHE_PSK_WITH_AES_256_GCM_SHA384", 0x00ab, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_AES_128_GCM_SHA256("TLS_RSA_PSK_WITH_AES_128_GCM_SHA256", 0x00ac, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_AES_256_GCM_SHA384("TLS_RSA_PSK_WITH_AES_256_GCM_SHA384", 0x00ad, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_AES_128_CBC_SHA256("TLS_PSK_WITH_AES_128_CBC_SHA256", 0x00ae, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_AES_256_CBC_SHA384("TLS_PSK_WITH_AES_256_CBC_SHA384", 0x00af, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_NULL_SHA256("TLS_PSK_WITH_NULL_SHA256", 0x00b0, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_NULL_SHA384("TLS_PSK_WITH_NULL_SHA384", 0x00b1, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_AES_128_CBC_SHA256("TLS_DHE_PSK_WITH_AES_128_CBC_SHA256", 0x00b2, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_AES_256_CBC_SHA384("TLS_DHE_PSK_WITH_AES_256_CBC_SHA384", 0x00b3, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_NULL_SHA256("TLS_DHE_PSK_WITH_NULL_SHA256", 0x00b4, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_NULL_SHA384("TLS_DHE_PSK_WITH_NULL_SHA384", 0x00b5, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_AES_128_CBC_SHA256("TLS_RSA_PSK_WITH_AES_128_CBC_SHA256", 0x00b6, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_AES_256_CBC_SHA384("TLS_RSA_PSK_WITH_AES_256_CBC_SHA384", 0x00b7, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_NULL_SHA256("TLS_RSA_PSK_WITH_NULL_SHA256", 0x00b8, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_NULL_SHA384("TLS_RSA_PSK_WITH_NULL_SHA384", 0x00b9, 5487, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256("TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00ba, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256("TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256", 0x00bb, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256("TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00bc, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256("TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256", 0x00bd, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256("TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00be, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256("TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256", 0x00bf, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256("TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c0, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256("TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256", 0x00c1, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256("TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c2, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256("TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256", 0x00c3, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256("TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c4, 5932, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256("TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256", 0x00c5, 5932, MAX_VALUE, MAX_VALUE),
-  TLS_EMPTY_RENEGOTIATION_INFO_SCSV("TLS_EMPTY_RENEGOTIATION_INFO_SCSV", 0x00ff, 5746, 6, 14),
-  TLS_ECDH_ECDSA_WITH_NULL_SHA("TLS_ECDH_ECDSA_WITH_NULL_SHA", 0xc001, 4492, 7, 14),
-  TLS_ECDH_ECDSA_WITH_RC4_128_SHA("TLS_ECDH_ECDSA_WITH_RC4_128_SHA", 0xc002, 4492, 7, 14),
-  TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA("TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA", 0xc003, 4492, 7, 14),
-  TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA", 0xc004, 4492, 7, 14),
-  TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA", 0xc005, 4492, 7, 14),
-  TLS_ECDHE_ECDSA_WITH_NULL_SHA("TLS_ECDHE_ECDSA_WITH_NULL_SHA", 0xc006, 4492, 7, 14),
-  TLS_ECDHE_ECDSA_WITH_RC4_128_SHA("TLS_ECDHE_ECDSA_WITH_RC4_128_SHA", 0xc007, 4492, 7, 14),
-  TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA("TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA", 0xc008, 4492, 7, 14),
-  TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA", 0xc009, 4492, 7, 14),
-  TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA", 0xc00a, 4492, 7, 14),
-  TLS_ECDH_RSA_WITH_NULL_SHA("TLS_ECDH_RSA_WITH_NULL_SHA", 0xc00b, 4492, 7, 14),
-  TLS_ECDH_RSA_WITH_RC4_128_SHA("TLS_ECDH_RSA_WITH_RC4_128_SHA", 0xc00c, 4492, 7, 14),
-  TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA("TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA", 0xc00d, 4492, 7, 14),
-  TLS_ECDH_RSA_WITH_AES_128_CBC_SHA("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA", 0xc00e, 4492, 7, 14),
-  TLS_ECDH_RSA_WITH_AES_256_CBC_SHA("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA", 0xc00f, 4492, 7, 14),
-  TLS_ECDHE_RSA_WITH_NULL_SHA("TLS_ECDHE_RSA_WITH_NULL_SHA", 0xc010, 4492, 7, 14),
-  TLS_ECDHE_RSA_WITH_RC4_128_SHA("TLS_ECDHE_RSA_WITH_RC4_128_SHA", 0xc011, 4492, 7, 14),
-  TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA("TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA", 0xc012, 4492, 7, 14),
-  TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA", 0xc013, 4492, 7, 14),
-  TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA", 0xc014, 4492, 7, 14),
-  TLS_ECDH_anon_WITH_NULL_SHA("TLS_ECDH_anon_WITH_NULL_SHA", 0xc015, 4492, 7, 14),
-  TLS_ECDH_anon_WITH_RC4_128_SHA("TLS_ECDH_anon_WITH_RC4_128_SHA", 0xc016, 4492, 7, 14),
-  TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA("TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA", 0xc017, 4492, 7, 14),
-  TLS_ECDH_anon_WITH_AES_128_CBC_SHA("TLS_ECDH_anon_WITH_AES_128_CBC_SHA", 0xc018, 4492, 7, 14),
-  TLS_ECDH_anon_WITH_AES_256_CBC_SHA("TLS_ECDH_anon_WITH_AES_256_CBC_SHA", 0xc019, 4492, 7, 14),
-  // TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA("TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA", 0xc01a, 5054, MAX_VALUE, MAX_VALUE),
-  // TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA("TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA", 0xc01b, 5054, MAX_VALUE, MAX_VALUE),
-  // TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA("TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA", 0xc01c, 5054, MAX_VALUE, MAX_VALUE),
-  // TLS_SRP_SHA_WITH_AES_128_CBC_SHA("TLS_SRP_SHA_WITH_AES_128_CBC_SHA", 0xc01d, 5054, MAX_VALUE, MAX_VALUE),
-  // TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA("TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA", 0xc01e, 5054, MAX_VALUE, MAX_VALUE),
-  // TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA("TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA", 0xc01f, 5054, MAX_VALUE, MAX_VALUE),
-  // TLS_SRP_SHA_WITH_AES_256_CBC_SHA("TLS_SRP_SHA_WITH_AES_256_CBC_SHA", 0xc020, 5054, MAX_VALUE, MAX_VALUE),
-  // TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA("TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA", 0xc021, 5054, MAX_VALUE, MAX_VALUE),
-  // TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA("TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA", 0xc022, 5054, MAX_VALUE, MAX_VALUE),
-  TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256", 0xc023, 5289, 7, 21),
-  TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384", 0xc024, 5289, 7, 21),
-  TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256", 0xc025, 5289, 7, 21),
-  TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384", 0xc026, 5289, 7, 21),
-  TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256", 0xc027, 5289, 7, 21),
-  TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384", 0xc028, 5289, 7, 21),
-  TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256", 0xc029, 5289, 7, 21),
-  TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384", 0xc02a, 5289, 7, 21),
-  TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256("TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02b, 5289, 8, 21),
-  TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384("TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02c, 5289, 8, 21),
-  TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256("TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02d, 5289, 8, 21),
-  TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384("TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02e, 5289, 8, 21),
-  TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256("TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256", 0xc02f, 5289, 8, 21),
-  TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384("TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384", 0xc030, 5289, 8, 21),
-  TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256("TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256", 0xc031, 5289, 8, 21),
-  TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384("TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384", 0xc032, 5289, 8, 21),
-  // TLS_ECDHE_PSK_WITH_RC4_128_SHA("TLS_ECDHE_PSK_WITH_RC4_128_SHA", 0xc033, 5489, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA("TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA", 0xc034, 5489, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA("TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA", 0xc035, 5489, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA("TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA", 0xc036, 5489, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256("TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256", 0xc037, 5489, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384("TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384", 0xc038, 5489, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_PSK_WITH_NULL_SHA("TLS_ECDHE_PSK_WITH_NULL_SHA", 0xc039, 5489, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_PSK_WITH_NULL_SHA256("TLS_ECDHE_PSK_WITH_NULL_SHA256", 0xc03a, 5489, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_PSK_WITH_NULL_SHA384("TLS_ECDHE_PSK_WITH_NULL_SHA384", 0xc03b, 5489, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_ARIA_128_CBC_SHA256("TLS_RSA_WITH_ARIA_128_CBC_SHA256", 0xc03c, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_ARIA_256_CBC_SHA384("TLS_RSA_WITH_ARIA_256_CBC_SHA384", 0xc03d, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256("TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256", 0xc03e, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384("TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384", 0xc03f, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256("TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256", 0xc040, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384("TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384", 0xc041, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256("TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256", 0xc042, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384("TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384", 0xc043, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256("TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256", 0xc044, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384("TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384", 0xc045, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_anon_WITH_ARIA_128_CBC_SHA256("TLS_DH_anon_WITH_ARIA_128_CBC_SHA256", 0xc046, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_anon_WITH_ARIA_256_CBC_SHA384("TLS_DH_anon_WITH_ARIA_256_CBC_SHA384", 0xc047, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256("TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256", 0xc048, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384("TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384", 0xc049, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256("TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256", 0xc04a, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384("TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384", 0xc04b, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256("TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256", 0xc04c, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384("TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384", 0xc04d, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256("TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256", 0xc04e, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384("TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384", 0xc04f, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_ARIA_128_GCM_SHA256("TLS_RSA_WITH_ARIA_128_GCM_SHA256", 0xc050, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_ARIA_256_GCM_SHA384("TLS_RSA_WITH_ARIA_256_GCM_SHA384", 0xc051, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256("TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256", 0xc052, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384("TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384", 0xc053, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256("TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256", 0xc054, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384("TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384", 0xc055, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256("TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256", 0xc056, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384("TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384", 0xc057, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256("TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256", 0xc058, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384("TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384", 0xc059, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_anon_WITH_ARIA_128_GCM_SHA256("TLS_DH_anon_WITH_ARIA_128_GCM_SHA256", 0xc05a, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_anon_WITH_ARIA_256_GCM_SHA384("TLS_DH_anon_WITH_ARIA_256_GCM_SHA384", 0xc05b, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256("TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256", 0xc05c, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384("TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384", 0xc05d, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256("TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256", 0xc05e, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384("TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384", 0xc05f, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256("TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256", 0xc060, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384("TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384", 0xc061, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256("TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256", 0xc062, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384("TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384", 0xc063, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_ARIA_128_CBC_SHA256("TLS_PSK_WITH_ARIA_128_CBC_SHA256", 0xc064, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_ARIA_256_CBC_SHA384("TLS_PSK_WITH_ARIA_256_CBC_SHA384", 0xc065, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256("TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256", 0xc066, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384("TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384", 0xc067, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256("TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256", 0xc068, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384("TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384", 0xc069, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_ARIA_128_GCM_SHA256("TLS_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06a, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_ARIA_256_GCM_SHA384("TLS_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06b, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256("TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06c, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384("TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06d, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256("TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06e, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384("TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06f, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256("TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256", 0xc070, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384("TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384", 0xc071, 6209, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256("TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc072, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384("TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc073, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256("TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc074, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384("TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc075, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256("TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc076, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384("TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc077, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256("TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc078, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384("TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc079, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256("TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07a, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384("TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07b, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256("TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07c, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384("TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07d, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256("TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07e, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384("TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07f, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256("TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256", 0xc080, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384("TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384", 0xc081, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256("TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256", 0xc082, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384("TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384", 0xc083, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256("TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256", 0xc084, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384("TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384", 0xc085, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256("TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc086, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384("TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc087, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256("TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc088, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384("TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc089, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256("TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc08a, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384("TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc08b, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256("TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc08c, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384("TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc08d, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256("TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc08e, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384("TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc08f, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256("TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc090, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384("TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc091, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256("TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc092, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384("TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc093, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256("TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc094, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384("TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc095, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256("TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc096, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384("TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc097, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256("TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc098, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384("TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc099, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256("TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc09a, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384("TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc09b, 6367, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_AES_128_CCM("TLS_RSA_WITH_AES_128_CCM", 0xc09c, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_AES_256_CCM("TLS_RSA_WITH_AES_256_CCM", 0xc09d, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_AES_128_CCM("TLS_DHE_RSA_WITH_AES_128_CCM", 0xc09e, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_AES_256_CCM("TLS_DHE_RSA_WITH_AES_256_CCM", 0xc09f, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_AES_128_CCM_8("TLS_RSA_WITH_AES_128_CCM_8", 0xc0a0, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_RSA_WITH_AES_256_CCM_8("TLS_RSA_WITH_AES_256_CCM_8", 0xc0a1, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_AES_128_CCM_8("TLS_DHE_RSA_WITH_AES_128_CCM_8", 0xc0a2, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_RSA_WITH_AES_256_CCM_8("TLS_DHE_RSA_WITH_AES_256_CCM_8", 0xc0a3, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_AES_128_CCM("TLS_PSK_WITH_AES_128_CCM", 0xc0a4, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_AES_256_CCM("TLS_PSK_WITH_AES_256_CCM", 0xc0a5, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_AES_128_CCM("TLS_DHE_PSK_WITH_AES_128_CCM", 0xc0a6, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_DHE_PSK_WITH_AES_256_CCM("TLS_DHE_PSK_WITH_AES_256_CCM", 0xc0a7, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_AES_128_CCM_8("TLS_PSK_WITH_AES_128_CCM_8", 0xc0a8, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_WITH_AES_256_CCM_8("TLS_PSK_WITH_AES_256_CCM_8", 0xc0a9, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_DHE_WITH_AES_128_CCM_8("TLS_PSK_DHE_WITH_AES_128_CCM_8", 0xc0aa, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_PSK_DHE_WITH_AES_256_CCM_8("TLS_PSK_DHE_WITH_AES_256_CCM_8", 0xc0ab, 6655, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_ECDSA_WITH_AES_128_CCM("TLS_ECDHE_ECDSA_WITH_AES_128_CCM", 0xc0ac, 7251, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_ECDSA_WITH_AES_256_CCM("TLS_ECDHE_ECDSA_WITH_AES_256_CCM", 0xc0ad, 7251, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8("TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8", 0xc0ae, 7251, MAX_VALUE, MAX_VALUE),
-  // TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8("TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8", 0xc0af, 7251, MAX_VALUE, MAX_VALUE),
-  ;
+  // Last updated 2016-07-03 using cipher suites from Android 24 and Java 9.
+
+  // public static final CipherSuite TLS_NULL_WITH_NULL_NULL = of("TLS_NULL_WITH_NULL_NULL", 0x0000);
+  public static final CipherSuite TLS_RSA_WITH_NULL_MD5 = of("SSL_RSA_WITH_NULL_MD5", 0x0001);
+  public static final CipherSuite TLS_RSA_WITH_NULL_SHA = of("SSL_RSA_WITH_NULL_SHA", 0x0002);
+  public static final CipherSuite TLS_RSA_EXPORT_WITH_RC4_40_MD5 = of("SSL_RSA_EXPORT_WITH_RC4_40_MD5", 0x0003);
+  public static final CipherSuite TLS_RSA_WITH_RC4_128_MD5 = of("SSL_RSA_WITH_RC4_128_MD5", 0x0004);
+  public static final CipherSuite TLS_RSA_WITH_RC4_128_SHA = of("SSL_RSA_WITH_RC4_128_SHA", 0x0005);
+  // public static final CipherSuite TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 = of("SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5", 0x0006);
+  // public static final CipherSuite TLS_RSA_WITH_IDEA_CBC_SHA = of("TLS_RSA_WITH_IDEA_CBC_SHA", 0x0007);
+  public static final CipherSuite TLS_RSA_EXPORT_WITH_DES40_CBC_SHA = of("SSL_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0008);
+  public static final CipherSuite TLS_RSA_WITH_DES_CBC_SHA = of("SSL_RSA_WITH_DES_CBC_SHA", 0x0009);
+  public static final CipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA = of("SSL_RSA_WITH_3DES_EDE_CBC_SHA", 0x000a);
+  // public static final CipherSuite TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x000b);
+  // public static final CipherSuite TLS_DH_DSS_WITH_DES_CBC_SHA = of("TLS_DH_DSS_WITH_DES_CBC_SHA", 0x000c);
+  // public static final CipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA = of("TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA", 0x000d);
+  // public static final CipherSuite TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x000e);
+  // public static final CipherSuite TLS_DH_RSA_WITH_DES_CBC_SHA = of("TLS_DH_RSA_WITH_DES_CBC_SHA", 0x000f);
+  // public static final CipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA = of("TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA", 0x0010);
+  public static final CipherSuite TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x0011);
+  public static final CipherSuite TLS_DHE_DSS_WITH_DES_CBC_SHA = of("SSL_DHE_DSS_WITH_DES_CBC_SHA", 0x0012);
+  public static final CipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA = of("SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA", 0x0013);
+  public static final CipherSuite TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0014);
+  public static final CipherSuite TLS_DHE_RSA_WITH_DES_CBC_SHA = of("SSL_DHE_RSA_WITH_DES_CBC_SHA", 0x0015);
+  public static final CipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA = of("SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA", 0x0016);
+  public static final CipherSuite TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 = of("SSL_DH_anon_EXPORT_WITH_RC4_40_MD5", 0x0017);
+  public static final CipherSuite TLS_DH_anon_WITH_RC4_128_MD5 = of("SSL_DH_anon_WITH_RC4_128_MD5", 0x0018);
+  public static final CipherSuite TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA", 0x0019);
+  public static final CipherSuite TLS_DH_anon_WITH_DES_CBC_SHA = of("SSL_DH_anon_WITH_DES_CBC_SHA", 0x001a);
+  public static final CipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA = of("SSL_DH_anon_WITH_3DES_EDE_CBC_SHA", 0x001b);
+  public static final CipherSuite TLS_KRB5_WITH_DES_CBC_SHA = of("TLS_KRB5_WITH_DES_CBC_SHA", 0x001e);
+  public static final CipherSuite TLS_KRB5_WITH_3DES_EDE_CBC_SHA = of("TLS_KRB5_WITH_3DES_EDE_CBC_SHA", 0x001f);
+  public static final CipherSuite TLS_KRB5_WITH_RC4_128_SHA = of("TLS_KRB5_WITH_RC4_128_SHA", 0x0020);
+  // public static final CipherSuite TLS_KRB5_WITH_IDEA_CBC_SHA = of("TLS_KRB5_WITH_IDEA_CBC_SHA", 0x0021);
+  public static final CipherSuite TLS_KRB5_WITH_DES_CBC_MD5 = of("TLS_KRB5_WITH_DES_CBC_MD5", 0x0022);
+  public static final CipherSuite TLS_KRB5_WITH_3DES_EDE_CBC_MD5 = of("TLS_KRB5_WITH_3DES_EDE_CBC_MD5", 0x0023);
+  public static final CipherSuite TLS_KRB5_WITH_RC4_128_MD5 = of("TLS_KRB5_WITH_RC4_128_MD5", 0x0024);
+  // public static final CipherSuite TLS_KRB5_WITH_IDEA_CBC_MD5 = of("TLS_KRB5_WITH_IDEA_CBC_MD5", 0x0025);
+  public static final CipherSuite TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA = of("TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA", 0x0026);
+  // public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA = of("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA", 0x0027);
+  public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC4_40_SHA = of("TLS_KRB5_EXPORT_WITH_RC4_40_SHA", 0x0028);
+  public static final CipherSuite TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5 = of("TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5", 0x0029);
+  // public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5 = of("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5", 0x002a);
+  public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC4_40_MD5 = of("TLS_KRB5_EXPORT_WITH_RC4_40_MD5", 0x002b);
+  // public static final CipherSuite TLS_PSK_WITH_NULL_SHA = of("TLS_PSK_WITH_NULL_SHA", 0x002c);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_NULL_SHA = of("TLS_DHE_PSK_WITH_NULL_SHA", 0x002d);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_NULL_SHA = of("TLS_RSA_PSK_WITH_NULL_SHA", 0x002e);
+  public static final CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA = of("TLS_RSA_WITH_AES_128_CBC_SHA", 0x002f);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA = of("TLS_DH_DSS_WITH_AES_128_CBC_SHA", 0x0030);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA = of("TLS_DH_RSA_WITH_AES_128_CBC_SHA", 0x0031);
+  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA = of("TLS_DHE_DSS_WITH_AES_128_CBC_SHA", 0x0032);
+  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA = of("TLS_DHE_RSA_WITH_AES_128_CBC_SHA", 0x0033);
+  public static final CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA = of("TLS_DH_anon_WITH_AES_128_CBC_SHA", 0x0034);
+  public static final CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA = of("TLS_RSA_WITH_AES_256_CBC_SHA", 0x0035);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA = of("TLS_DH_DSS_WITH_AES_256_CBC_SHA", 0x0036);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA = of("TLS_DH_RSA_WITH_AES_256_CBC_SHA", 0x0037);
+  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA = of("TLS_DHE_DSS_WITH_AES_256_CBC_SHA", 0x0038);
+  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA = of("TLS_DHE_RSA_WITH_AES_256_CBC_SHA", 0x0039);
+  public static final CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA = of("TLS_DH_anon_WITH_AES_256_CBC_SHA", 0x003a);
+  public static final CipherSuite TLS_RSA_WITH_NULL_SHA256 = of("TLS_RSA_WITH_NULL_SHA256", 0x003b);
+  public static final CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_RSA_WITH_AES_128_CBC_SHA256", 0x003c);
+  public static final CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA256 = of("TLS_RSA_WITH_AES_256_CBC_SHA256", 0x003d);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA256 = of("TLS_DH_DSS_WITH_AES_128_CBC_SHA256", 0x003e);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_DH_RSA_WITH_AES_128_CBC_SHA256", 0x003f);
+  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 = of("TLS_DHE_DSS_WITH_AES_128_CBC_SHA256", 0x0040);
+  public static final CipherSuite TLS_RSA_WITH_CAMELLIA_128_CBC_SHA = of("TLS_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0041);
+  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0042);
+  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0043);
+  public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0044);
+  public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0045);
+  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA", 0x0046);
+  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_DHE_RSA_WITH_AES_128_CBC_SHA256", 0x0067);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA256 = of("TLS_DH_DSS_WITH_AES_256_CBC_SHA256", 0x0068);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA256 = of("TLS_DH_RSA_WITH_AES_256_CBC_SHA256", 0x0069);
+  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 = of("TLS_DHE_DSS_WITH_AES_256_CBC_SHA256", 0x006a);
+  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 = of("TLS_DHE_RSA_WITH_AES_256_CBC_SHA256", 0x006b);
+  public static final CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA256 = of("TLS_DH_anon_WITH_AES_128_CBC_SHA256", 0x006c);
+  public static final CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA256 = of("TLS_DH_anon_WITH_AES_256_CBC_SHA256", 0x006d);
+  public static final CipherSuite TLS_RSA_WITH_CAMELLIA_256_CBC_SHA = of("TLS_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0084);
+  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0085);
+  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0086);
+  public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0087);
+  public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0088);
+  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA", 0x0089);
+  public static final CipherSuite TLS_PSK_WITH_RC4_128_SHA = of("TLS_PSK_WITH_RC4_128_SHA", 0x008a);
+  public static final CipherSuite TLS_PSK_WITH_3DES_EDE_CBC_SHA = of("TLS_PSK_WITH_3DES_EDE_CBC_SHA", 0x008b);
+  public static final CipherSuite TLS_PSK_WITH_AES_128_CBC_SHA = of("TLS_PSK_WITH_AES_128_CBC_SHA", 0x008c);
+  public static final CipherSuite TLS_PSK_WITH_AES_256_CBC_SHA = of("TLS_PSK_WITH_AES_256_CBC_SHA", 0x008d);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_RC4_128_SHA = of("TLS_DHE_PSK_WITH_RC4_128_SHA", 0x008e);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA = of("TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA", 0x008f);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_CBC_SHA = of("TLS_DHE_PSK_WITH_AES_128_CBC_SHA", 0x0090);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_CBC_SHA = of("TLS_DHE_PSK_WITH_AES_256_CBC_SHA", 0x0091);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_RC4_128_SHA = of("TLS_RSA_PSK_WITH_RC4_128_SHA", 0x0092);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA = of("TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA", 0x0093);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_128_CBC_SHA = of("TLS_RSA_PSK_WITH_AES_128_CBC_SHA", 0x0094);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_256_CBC_SHA = of("TLS_RSA_PSK_WITH_AES_256_CBC_SHA", 0x0095);
+  public static final CipherSuite TLS_RSA_WITH_SEED_CBC_SHA = of("TLS_RSA_WITH_SEED_CBC_SHA", 0x0096);
+  // public static final CipherSuite TLS_DH_DSS_WITH_SEED_CBC_SHA = of("TLS_DH_DSS_WITH_SEED_CBC_SHA", 0x0097);
+  // public static final CipherSuite TLS_DH_RSA_WITH_SEED_CBC_SHA = of("TLS_DH_RSA_WITH_SEED_CBC_SHA", 0x0098);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_SEED_CBC_SHA = of("TLS_DHE_DSS_WITH_SEED_CBC_SHA", 0x0099);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_SEED_CBC_SHA = of("TLS_DHE_RSA_WITH_SEED_CBC_SHA", 0x009a);
+  // public static final CipherSuite TLS_DH_anon_WITH_SEED_CBC_SHA = of("TLS_DH_anon_WITH_SEED_CBC_SHA", 0x009b);
+  public static final CipherSuite TLS_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_RSA_WITH_AES_128_GCM_SHA256", 0x009c);
+  public static final CipherSuite TLS_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_RSA_WITH_AES_256_GCM_SHA384", 0x009d);
+  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_DHE_RSA_WITH_AES_128_GCM_SHA256", 0x009e);
+  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_DHE_RSA_WITH_AES_256_GCM_SHA384", 0x009f);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_DH_RSA_WITH_AES_128_GCM_SHA256", 0x00a0);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_DH_RSA_WITH_AES_256_GCM_SHA384", 0x00a1);
+  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_GCM_SHA256 = of("TLS_DHE_DSS_WITH_AES_128_GCM_SHA256", 0x00a2);
+  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_GCM_SHA384 = of("TLS_DHE_DSS_WITH_AES_256_GCM_SHA384", 0x00a3);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_GCM_SHA256 = of("TLS_DH_DSS_WITH_AES_128_GCM_SHA256", 0x00a4);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_GCM_SHA384 = of("TLS_DH_DSS_WITH_AES_256_GCM_SHA384", 0x00a5);
+  public static final CipherSuite TLS_DH_anon_WITH_AES_128_GCM_SHA256 = of("TLS_DH_anon_WITH_AES_128_GCM_SHA256", 0x00a6);
+  public static final CipherSuite TLS_DH_anon_WITH_AES_256_GCM_SHA384 = of("TLS_DH_anon_WITH_AES_256_GCM_SHA384", 0x00a7);
+  // public static final CipherSuite TLS_PSK_WITH_AES_128_GCM_SHA256 = of("TLS_PSK_WITH_AES_128_GCM_SHA256", 0x00a8);
+  // public static final CipherSuite TLS_PSK_WITH_AES_256_GCM_SHA384 = of("TLS_PSK_WITH_AES_256_GCM_SHA384", 0x00a9);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_GCM_SHA256 = of("TLS_DHE_PSK_WITH_AES_128_GCM_SHA256", 0x00aa);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_GCM_SHA384 = of("TLS_DHE_PSK_WITH_AES_256_GCM_SHA384", 0x00ab);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_128_GCM_SHA256 = of("TLS_RSA_PSK_WITH_AES_128_GCM_SHA256", 0x00ac);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_256_GCM_SHA384 = of("TLS_RSA_PSK_WITH_AES_256_GCM_SHA384", 0x00ad);
+  // public static final CipherSuite TLS_PSK_WITH_AES_128_CBC_SHA256 = of("TLS_PSK_WITH_AES_128_CBC_SHA256", 0x00ae);
+  // public static final CipherSuite TLS_PSK_WITH_AES_256_CBC_SHA384 = of("TLS_PSK_WITH_AES_256_CBC_SHA384", 0x00af);
+  // public static final CipherSuite TLS_PSK_WITH_NULL_SHA256 = of("TLS_PSK_WITH_NULL_SHA256", 0x00b0);
+  // public static final CipherSuite TLS_PSK_WITH_NULL_SHA384 = of("TLS_PSK_WITH_NULL_SHA384", 0x00b1);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_CBC_SHA256 = of("TLS_DHE_PSK_WITH_AES_128_CBC_SHA256", 0x00b2);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_CBC_SHA384 = of("TLS_DHE_PSK_WITH_AES_256_CBC_SHA384", 0x00b3);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_NULL_SHA256 = of("TLS_DHE_PSK_WITH_NULL_SHA256", 0x00b4);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_NULL_SHA384 = of("TLS_DHE_PSK_WITH_NULL_SHA384", 0x00b5);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_128_CBC_SHA256 = of("TLS_RSA_PSK_WITH_AES_128_CBC_SHA256", 0x00b6);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_256_CBC_SHA384 = of("TLS_RSA_PSK_WITH_AES_256_CBC_SHA384", 0x00b7);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_NULL_SHA256 = of("TLS_RSA_PSK_WITH_NULL_SHA256", 0x00b8);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_NULL_SHA384 = of("TLS_RSA_PSK_WITH_NULL_SHA384", 0x00b9);
+  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00ba);
+  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256", 0x00bb);
+  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00bc);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256", 0x00bd);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00be);
+  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256", 0x00bf);
+  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c0);
+  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256", 0x00c1);
+  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c2);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256", 0x00c3);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c4);
+  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256", 0x00c5);
+  public static final CipherSuite TLS_EMPTY_RENEGOTIATION_INFO_SCSV = of("TLS_EMPTY_RENEGOTIATION_INFO_SCSV", 0x00ff);
+  public static final CipherSuite TLS_FALLBACK_SCSV = of("TLS_FALLBACK_SCSV", 0x5600);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_NULL_SHA = of("TLS_ECDH_ECDSA_WITH_NULL_SHA", 0xc001);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_RC4_128_SHA = of("TLS_ECDH_ECDSA_WITH_RC4_128_SHA", 0xc002);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA", 0xc003);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA = of("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA", 0xc004);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA = of("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA", 0xc005);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_NULL_SHA = of("TLS_ECDHE_ECDSA_WITH_NULL_SHA", 0xc006);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_RC4_128_SHA = of("TLS_ECDHE_ECDSA_WITH_RC4_128_SHA", 0xc007);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA", 0xc008);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = of("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA", 0xc009);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = of("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA", 0xc00a);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_NULL_SHA = of("TLS_ECDH_RSA_WITH_NULL_SHA", 0xc00b);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_RC4_128_SHA = of("TLS_ECDH_RSA_WITH_RC4_128_SHA", 0xc00c);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA", 0xc00d);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA = of("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA", 0xc00e);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA = of("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA", 0xc00f);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_NULL_SHA = of("TLS_ECDHE_RSA_WITH_NULL_SHA", 0xc010);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_RC4_128_SHA = of("TLS_ECDHE_RSA_WITH_RC4_128_SHA", 0xc011);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA", 0xc012);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA = of("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA", 0xc013);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA = of("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA", 0xc014);
+  public static final CipherSuite TLS_ECDH_anon_WITH_NULL_SHA = of("TLS_ECDH_anon_WITH_NULL_SHA", 0xc015);
+  public static final CipherSuite TLS_ECDH_anon_WITH_RC4_128_SHA = of("TLS_ECDH_anon_WITH_RC4_128_SHA", 0xc016);
+  public static final CipherSuite TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA", 0xc017);
+  public static final CipherSuite TLS_ECDH_anon_WITH_AES_128_CBC_SHA = of("TLS_ECDH_anon_WITH_AES_128_CBC_SHA", 0xc018);
+  public static final CipherSuite TLS_ECDH_anon_WITH_AES_256_CBC_SHA = of("TLS_ECDH_anon_WITH_AES_256_CBC_SHA", 0xc019);
+  // public static final CipherSuite TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA = of("TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA", 0xc01a);
+  // public static final CipherSuite TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA = of("TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA", 0xc01b);
+  // public static final CipherSuite TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA = of("TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA", 0xc01c);
+  // public static final CipherSuite TLS_SRP_SHA_WITH_AES_128_CBC_SHA = of("TLS_SRP_SHA_WITH_AES_128_CBC_SHA", 0xc01d);
+  // public static final CipherSuite TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA = of("TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA", 0xc01e);
+  // public static final CipherSuite TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA = of("TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA", 0xc01f);
+  // public static final CipherSuite TLS_SRP_SHA_WITH_AES_256_CBC_SHA = of("TLS_SRP_SHA_WITH_AES_256_CBC_SHA", 0xc020);
+  // public static final CipherSuite TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA = of("TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA", 0xc021);
+  // public static final CipherSuite TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA = of("TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA", 0xc022);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 = of("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256", 0xc023);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 = of("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384", 0xc024);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 = of("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256", 0xc025);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 = of("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384", 0xc026);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256", 0xc027);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 = of("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384", 0xc028);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256", 0xc029);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 = of("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384", 0xc02a);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = of("TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02b);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = of("TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02c);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 = of("TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02d);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 = of("TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02e);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256", 0xc02f);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384", 0xc030);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256", 0xc031);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384", 0xc032);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_RC4_128_SHA = of("TLS_ECDHE_PSK_WITH_RC4_128_SHA", 0xc033);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA", 0xc034);
+  public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA = of("TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA", 0xc035);
+  public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA = of("TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA", 0xc036);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256 = of("TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256", 0xc037);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384 = of("TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384", 0xc038);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA = of("TLS_ECDHE_PSK_WITH_NULL_SHA", 0xc039);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA256 = of("TLS_ECDHE_PSK_WITH_NULL_SHA256", 0xc03a);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA384 = of("TLS_ECDHE_PSK_WITH_NULL_SHA384", 0xc03b);
+  // public static final CipherSuite TLS_RSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_RSA_WITH_ARIA_128_CBC_SHA256", 0xc03c);
+  // public static final CipherSuite TLS_RSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_RSA_WITH_ARIA_256_CBC_SHA384", 0xc03d);
+  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256 = of("TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256", 0xc03e);
+  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384 = of("TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384", 0xc03f);
+  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256", 0xc040);
+  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384", 0xc041);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256 = of("TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256", 0xc042);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384 = of("TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384", 0xc043);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256", 0xc044);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384", 0xc045);
+  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_128_CBC_SHA256 = of("TLS_DH_anon_WITH_ARIA_128_CBC_SHA256", 0xc046);
+  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_256_CBC_SHA384 = of("TLS_DH_anon_WITH_ARIA_256_CBC_SHA384", 0xc047);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256", 0xc048);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384", 0xc049);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256", 0xc04a);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384", 0xc04b);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256", 0xc04c);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384", 0xc04d);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256", 0xc04e);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384", 0xc04f);
+  // public static final CipherSuite TLS_RSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_RSA_WITH_ARIA_128_GCM_SHA256", 0xc050);
+  // public static final CipherSuite TLS_RSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_RSA_WITH_ARIA_256_GCM_SHA384", 0xc051);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256", 0xc052);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384", 0xc053);
+  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256", 0xc054);
+  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384", 0xc055);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256 = of("TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256", 0xc056);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384 = of("TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384", 0xc057);
+  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256 = of("TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256", 0xc058);
+  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384 = of("TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384", 0xc059);
+  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_128_GCM_SHA256 = of("TLS_DH_anon_WITH_ARIA_128_GCM_SHA256", 0xc05a);
+  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_256_GCM_SHA384 = of("TLS_DH_anon_WITH_ARIA_256_GCM_SHA384", 0xc05b);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256", 0xc05c);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384", 0xc05d);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256", 0xc05e);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384", 0xc05f);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256", 0xc060);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384", 0xc061);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256", 0xc062);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384", 0xc063);
+  // public static final CipherSuite TLS_PSK_WITH_ARIA_128_CBC_SHA256 = of("TLS_PSK_WITH_ARIA_128_CBC_SHA256", 0xc064);
+  // public static final CipherSuite TLS_PSK_WITH_ARIA_256_CBC_SHA384 = of("TLS_PSK_WITH_ARIA_256_CBC_SHA384", 0xc065);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256 = of("TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256", 0xc066);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384 = of("TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384", 0xc067);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256 = of("TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256", 0xc068);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384 = of("TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384", 0xc069);
+  // public static final CipherSuite TLS_PSK_WITH_ARIA_128_GCM_SHA256 = of("TLS_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06a);
+  // public static final CipherSuite TLS_PSK_WITH_ARIA_256_GCM_SHA384 = of("TLS_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06b);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256 = of("TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06c);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384 = of("TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06d);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256 = of("TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06e);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384 = of("TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06f);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256 = of("TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256", 0xc070);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384 = of("TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384", 0xc071);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc072);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc073);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc074);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc075);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc076);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc077);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc078);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc079);
+  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07a);
+  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07b);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07c);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07d);
+  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07e);
+  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07f);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256", 0xc080);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384", 0xc081);
+  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256", 0xc082);
+  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384", 0xc083);
+  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256", 0xc084);
+  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384", 0xc085);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc086);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc087);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc088);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc089);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc08a);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc08b);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc08c);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc08d);
+  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc08e);
+  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc08f);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc090);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc091);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc092);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc093);
+  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc094);
+  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc095);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc096);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc097);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc098);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc099);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc09a);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc09b);
+  // public static final CipherSuite TLS_RSA_WITH_AES_128_CCM = of("TLS_RSA_WITH_AES_128_CCM", 0xc09c);
+  // public static final CipherSuite TLS_RSA_WITH_AES_256_CCM = of("TLS_RSA_WITH_AES_256_CCM", 0xc09d);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CCM = of("TLS_DHE_RSA_WITH_AES_128_CCM", 0xc09e);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CCM = of("TLS_DHE_RSA_WITH_AES_256_CCM", 0xc09f);
+  // public static final CipherSuite TLS_RSA_WITH_AES_128_CCM_8 = of("TLS_RSA_WITH_AES_128_CCM_8", 0xc0a0);
+  // public static final CipherSuite TLS_RSA_WITH_AES_256_CCM_8 = of("TLS_RSA_WITH_AES_256_CCM_8", 0xc0a1);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CCM_8 = of("TLS_DHE_RSA_WITH_AES_128_CCM_8", 0xc0a2);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CCM_8 = of("TLS_DHE_RSA_WITH_AES_256_CCM_8", 0xc0a3);
+  // public static final CipherSuite TLS_PSK_WITH_AES_128_CCM = of("TLS_PSK_WITH_AES_128_CCM", 0xc0a4);
+  // public static final CipherSuite TLS_PSK_WITH_AES_256_CCM = of("TLS_PSK_WITH_AES_256_CCM", 0xc0a5);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_CCM = of("TLS_DHE_PSK_WITH_AES_128_CCM", 0xc0a6);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_CCM = of("TLS_DHE_PSK_WITH_AES_256_CCM", 0xc0a7);
+  // public static final CipherSuite TLS_PSK_WITH_AES_128_CCM_8 = of("TLS_PSK_WITH_AES_128_CCM_8", 0xc0a8);
+  // public static final CipherSuite TLS_PSK_WITH_AES_256_CCM_8 = of("TLS_PSK_WITH_AES_256_CCM_8", 0xc0a9);
+  // public static final CipherSuite TLS_PSK_DHE_WITH_AES_128_CCM_8 = of("TLS_PSK_DHE_WITH_AES_128_CCM_8", 0xc0aa);
+  // public static final CipherSuite TLS_PSK_DHE_WITH_AES_256_CCM_8 = of("TLS_PSK_DHE_WITH_AES_256_CCM_8", 0xc0ab);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CCM = of("TLS_ECDHE_ECDSA_WITH_AES_128_CCM", 0xc0ac);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CCM = of("TLS_ECDHE_ECDSA_WITH_AES_256_CCM", 0xc0ad);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 = of("TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8", 0xc0ae);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8 = of("TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8", 0xc0af);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256", 0xcca8);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256", 0xcca9);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256", 0xccaa);
+  // public static final CipherSuite TLS_PSK_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccab);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccac);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccad);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccae);
 
   final String javaName;
 
   /**
    * @param javaName the name used by Java APIs for this cipher suite. Different than the IANA name
    * for older cipher suites because the prefix is {@code SSL_} instead of {@code TLS_}.
-   * @param value the integer identifier for this cipher suite. (Documentation only.)
-   * @param rfc the RFC describing this cipher suite. (Documentation only.)
-   * @param sinceJavaVersion the first major Java release supporting this cipher suite.
-   * @param sinceAndroidVersion the first Android SDK version supporting this cipher suite.
    */
-  private CipherSuite(
-      String javaName, int value, int rfc, int sinceJavaVersion, int sinceAndroidVersion) {
+  public static CipherSuite forJavaName(String javaName) {
+    CipherSuite result = INSTANCES.get(javaName);
+    if (result == null) {
+      CipherSuite sample = new CipherSuite(javaName);
+      CipherSuite canonical = INSTANCES.putIfAbsent(javaName, sample);
+      result = (canonical == null) ? sample : canonical;
+    }
+    return result;
+  }
+
+  private CipherSuite(String javaName) {
+    if (javaName == null) {
+      throw new NullPointerException();
+    }
     this.javaName = javaName;
   }
 
+  /**
+   * @param javaName the name used by Java APIs for this cipher suite. Different than the IANA name
+   * for older cipher suites because the prefix is {@code SSL_} instead of {@code TLS_}.
+   * @param value the integer identifier for this cipher suite. (Documentation only.)
+   */
+  private static CipherSuite of(String javaName, int value) {
+    return forJavaName(javaName);
+  }
+
   /**
    * Returns the Java name of this cipher suite. For some older cipher suites the Java name has the
-   * prefix {@code SSL_}, causing the Java name to be different from the {@linkplain #name() enum
-   * name} which is always prefixed {@code TLS_}.
+   * prefix {@code SSL_}, causing the Java name to be different from the instance name which is
+   * always prefixed {@code TLS_}. For example, {@code TLS_RSA_EXPORT_WITH_RC4_40_MD5.javaName()}
+   * is {@code "SSL_RSA_EXPORT_WITH_RC4_40_MD5"}.
    */
   public String javaName() {
     return javaName;
   }
 
-  public static CipherSuite forJavaName(String javaName) {
-    return javaName.startsWith("SSL_")
-        ? valueOf("TLS_" + javaName.substring(4))
-        : valueOf(javaName);
+  @Override public String toString() {
+    return javaName;
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/Connection.java b/okhttp/src/main/java/okhttp3/Connection.java
index de3c22d98b..d07e861d8f 100644
--- a/okhttp/src/main/java/okhttp3/Connection.java
+++ b/okhttp/src/main/java/okhttp3/Connection.java
@@ -19,7 +19,7 @@
 import java.net.Socket;
 
 /**
- * The sockets and streams of an HTTP, HTTPS, or HTTPS+SPDY connection. May be used for multiple
+ * The sockets and streams of an HTTP, HTTPS, or HTTPS+HTTP/2 connection. May be used for multiple
  * HTTP request/response exchanges. Connections may be direct to the origin server or via a proxy.
  *
  * <p>Typically instances of this class are created, connected and exercised automatically by the
@@ -37,8 +37,8 @@
  * <ul>
  *     <li>Server Name Indication (SNI) enables one IP address to negotiate secure connections for
  *         multiple domain names.
- *     <li>Application Layer Protocol Negotiation (ALPN) enables the HTTPS port (443) to be used for
- *         different HTTP and SPDY protocols.
+ *     <li>Application Layer Protocol Negotiation (ALPN) enables the HTTPS port (443) to be used to
+ *         negotiate HTTP/2.
  * </ul>
  *
  * <p>Unfortunately, older HTTPS servers refuse to connect when such options are presented. Rather
@@ -73,7 +73,7 @@
 
   /**
    * Returns the socket that this connection is using. Returns an {@linkplain
-   * javax.net.ssl.SSLSocket SSL socket} if this connection is HTTPS. If this is an HTTP/2 or SPDY
+   * javax.net.ssl.SSLSocket SSL socket} if this connection is HTTPS. If this is an HTTP/2
    * connection the socket may be shared by multiple concurrent calls.
    */
   Socket socket();
diff --git a/okhttp/src/main/java/okhttp3/ConnectionPool.java b/okhttp/src/main/java/okhttp3/ConnectionPool.java
index 701a98813b..dcbc0b441e 100644
--- a/okhttp/src/main/java/okhttp3/ConnectionPool.java
+++ b/okhttp/src/main/java/okhttp3/ConnectionPool.java
@@ -26,18 +26,18 @@
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
-import okhttp3.internal.Internal;
-import okhttp3.internal.RouteDatabase;
 import okhttp3.internal.Util;
-import okhttp3.internal.http.StreamAllocation;
-import okhttp3.internal.io.RealConnection;
+import okhttp3.internal.connection.RealConnection;
+import okhttp3.internal.connection.RouteDatabase;
+import okhttp3.internal.connection.StreamAllocation;
+import okhttp3.internal.platform.Platform;
 
 import static okhttp3.internal.Util.closeQuietly;
 
 /**
- * Manages reuse of HTTP and SPDY connections for reduced network latency. HTTP requests that share
- * the same {@link Address} may share a {@link Connection}. This class implements the policy of
- * which connections to keep open for future use.
+ * Manages reuse of HTTP and HTTP/2 connections for reduced network latency. HTTP requests that
+ * share the same {@link Address} may share a {@link Connection}. This class implements the policy
+ * of which connections to keep open for future use.
  */
 public final class ConnectionPool {
   /**
@@ -105,7 +105,7 @@ public synchronized int idleConnectionCount() {
 
   /**
    * Returns total number of connections in the pool. Note that prior to OkHttp 2.7 this included
-   * only idle connections and SPDY connections. Since OkHttp 2.7 this includes all connections,
+   * only idle connections and HTTP/2 connections. Since OkHttp 2.7 this includes all connections,
    * both active and inactive. Use {@link #idleConnectionCount()} to count connections not currently
    * in use.
    */
@@ -245,8 +245,12 @@ private int pruneAndGetAllocationCount(RealConnection connection, long now) {
       }
 
       // We've discovered a leaked allocation. This is an application bug.
-      Internal.logger.warning("A connection to " + connection.route().address().url()
-          + " was leaked. Did you forget to close a response body?");
+      StreamAllocation.StreamAllocationReference streamAllocRef =
+          (StreamAllocation.StreamAllocationReference) reference;
+      String message = "A connection to " + connection.route().address().url()
+          + " was leaked. Did you forget to close a response body?";
+      Platform.get().logCloseableLeak(message, streamAllocRef.callStackTrace);
+
       references.remove(i);
       connection.noNewStreams = true;
 
diff --git a/okhttp/src/main/java/okhttp3/ConnectionSpec.java b/okhttp/src/main/java/okhttp3/ConnectionSpec.java
index 8c99932f9e..a229e2dd00 100644
--- a/okhttp/src/main/java/okhttp3/ConnectionSpec.java
+++ b/okhttp/src/main/java/okhttp3/ConnectionSpec.java
@@ -15,13 +15,14 @@
  */
 package okhttp3;
 
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 import javax.net.ssl.SSLSocket;
 
 import static okhttp3.internal.Util.concat;
-import static okhttp3.internal.Util.contains;
-import static okhttp3.internal.Util.immutableList;
+import static okhttp3.internal.Util.indexOf;
 import static okhttp3.internal.Util.intersect;
 
 /**
@@ -30,7 +31,7 @@
  * connection.
  *
  * <p>The TLS versions configured in a connection spec are only be used if they are also enabled in
- * the SSL socket. For example, if an SSL socket does not have TLS 1.2 enabled, it will not be used
+ * the SSL socket. For example, if an SSL socket does not have TLS 1.3 enabled, it will not be used
  * even if it is present on the connection spec. The same policy also applies to cipher suites.
  *
  * <p>Use {@link Builder#allEnabledTlsVersions()} and {@link Builder#allEnabledCipherSuites} to
@@ -38,24 +39,26 @@
  */
 public final class ConnectionSpec {
 
-  // This is a subset of the cipher suites supported in Chrome 46, current as of 2015-11-05.
-  // All of these suites are available on Android 5.0; earlier releases support a subset of
-  // these suites. https://github.com/square/okhttp/issues/330
+  // This is nearly equal to the cipher suites supported in Chrome 51, current as of 2016-05-25.
+  // All of these suites are available on Android 7.0; earlier releases support a subset of these
+  // suites. https://github.com/square/okhttp/issues/1972
   private static final CipherSuite[] APPROVED_CIPHER_SUITES = new CipherSuite[] {
       CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
       CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
-      CipherSuite.TLS_DHE_RSA_WITH_AES_128_GCM_SHA256,
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+      CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,
+      CipherSuite.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,
 
       // Note that the following cipher suites are all on HTTP/2's bad cipher suites list. We'll
       // continue to include them until better suites are commonly available. For example, none
       // of the better cipher suites listed above shipped with Android 4.4 or Java 7.
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
       CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
       CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
       CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
-      CipherSuite.TLS_DHE_RSA_WITH_AES_128_CBC_SHA,
-      CipherSuite.TLS_DHE_RSA_WITH_AES_256_CBC_SHA,
       CipherSuite.TLS_RSA_WITH_AES_128_GCM_SHA256,
+      CipherSuite.TLS_RSA_WITH_AES_256_GCM_SHA384,
       CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA,
       CipherSuite.TLS_RSA_WITH_AES_256_CBC_SHA,
       CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
@@ -64,7 +67,7 @@
   /** A modern TLS connection with extensions like SNI and ALPN available. */
   public static final ConnectionSpec MODERN_TLS = new Builder(true)
       .cipherSuites(APPROVED_CIPHER_SUITES)
-      .tlsVersions(TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0)
+      .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0)
       .supportsTlsExtensions(true)
       .build();
 
@@ -100,11 +103,11 @@ public boolean isTls() {
   public List<CipherSuite> cipherSuites() {
     if (cipherSuites == null) return null;
 
-    CipherSuite[] result = new CipherSuite[cipherSuites.length];
-    for (int i = 0; i < cipherSuites.length; i++) {
-      result[i] = CipherSuite.forJavaName(cipherSuites[i]);
+    List<CipherSuite> result = new ArrayList<>(cipherSuites.length);
+    for (String cipherSuite : cipherSuites) {
+      result.add(CipherSuite.forJavaName(cipherSuite));
     }
-    return immutableList(result);
+    return Collections.unmodifiableList(result);
   }
 
   /**
@@ -114,11 +117,11 @@ public boolean isTls() {
   public List<TlsVersion> tlsVersions() {
     if (tlsVersions == null) return null;
 
-    TlsVersion[] result = new TlsVersion[tlsVersions.length];
-    for (int i = 0; i < tlsVersions.length; i++) {
-      result[i] = TlsVersion.forJavaName(tlsVersions[i]);
+    List<TlsVersion> result = new ArrayList<>(tlsVersions.length);
+    for (String tlsVersion : tlsVersions) {
+      result.add(TlsVersion.forJavaName(tlsVersion));
     }
-    return immutableList(result);
+    return Collections.unmodifiableList(result);
   }
 
   public boolean supportsTlsExtensions() {
@@ -151,7 +154,7 @@ private ConnectionSpec supportedSpec(SSLSocket sslSocket, boolean isFallback) {
 
     // In accordance with https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00
     // the SCSV cipher is added to signal that a protocol fallback has taken place.
-    if (isFallback && contains(sslSocket.getSupportedCipherSuites(), "TLS_FALLBACK_SCSV")) {
+    if (isFallback && indexOf(sslSocket.getSupportedCipherSuites(), "TLS_FALLBACK_SCSV") != -1) {
       cipherSuitesIntersection = concat(cipherSuitesIntersection, "TLS_FALLBACK_SCSV");
     }
 
@@ -200,7 +203,7 @@ private static boolean nonEmptyIntersection(String[] a, String[] b) {
       return false;
     }
     for (String toFind : a) {
-      if (contains(b, toFind)) {
+      if (indexOf(b, toFind) != -1) {
         return true;
       }
     }
diff --git a/okhttp/src/main/java/okhttp3/Cookie.java b/okhttp/src/main/java/okhttp3/Cookie.java
index 29a4bf84d1..df882c01ab 100644
--- a/okhttp/src/main/java/okhttp3/Cookie.java
+++ b/okhttp/src/main/java/okhttp3/Cookie.java
@@ -100,7 +100,7 @@ public String value() {
     return value;
   }
 
-  /** Returns true if this cookie expires at the end of the current session. */
+  /** Returns true if this cookie does not expire at the end of the current session. */
   public boolean persistent() {
     return persistent;
   }
@@ -530,6 +530,15 @@ public Cookie build() {
   }
 
   @Override public String toString() {
+    return toString(false);
+  }
+
+  /**
+   * @param forObsoleteRfc2965 true to include a leading {@code .} on the domain pattern. This is
+   *     necessary for {@code example.com} to match {@code www.example.com} under RFC 2965. This
+   *     extra dot is ignored by more recent specifications.
+   */
+  String toString(boolean forObsoleteRfc2965) {
     StringBuilder result = new StringBuilder();
     result.append(name);
     result.append('=');
@@ -544,7 +553,11 @@ public Cookie build() {
     }
 
     if (!hostOnly) {
-      result.append("; domain=").append(domain);
+      result.append("; domain=");
+      if (forObsoleteRfc2965) {
+        result.append(".");
+      }
+      result.append(domain);
     }
 
     result.append("; path=").append(path);
diff --git a/okhttp/src/main/java/okhttp3/Dispatcher.java b/okhttp/src/main/java/okhttp3/Dispatcher.java
index 5a135b325d..d6f90bb3ac 100644
--- a/okhttp/src/main/java/okhttp3/Dispatcher.java
+++ b/okhttp/src/main/java/okhttp3/Dispatcher.java
@@ -38,6 +38,7 @@
 public final class Dispatcher {
   private int maxRequests = 64;
   private int maxRequestsPerHost = 5;
+  private Runnable idleCallback;
 
   /** Executes calls. Created lazily. */
   private ExecutorService executorService;
@@ -106,6 +107,22 @@ public synchronized int getMaxRequestsPerHost() {
     return maxRequestsPerHost;
   }
 
+  /**
+   * Set a callback to be invoked each time the dispatcher becomes idle (when the number of running
+   * calls returns to zero).
+   *
+   * <p>Note: The time at which a {@linkplain Call call} is considered idle is different depending
+   * on whether it was run {@linkplain Call#enqueue(Callback) asynchronously} or
+   * {@linkplain Call#execute() synchronously}. Asynchronous calls become idle after the
+   * {@link Callback#onResponse onResponse} or {@link Callback#onFailure onFailure} callback has
+   * returned. Synchronous calls become idle once {@link Call#execute() execute()} returns. This
+   * means that if you are doing synchronous calls the network layer will not truly be idle until
+   * every returned {@link Response} has been closed.
+   */
+  public synchronized void setIdleCallback(Runnable idleCallback) {
+    this.idleCallback = idleCallback;
+  }
+
   synchronized void enqueue(AsyncCall call) {
     if (runningAsyncCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {
       runningAsyncCalls.add(call);
@@ -121,11 +138,11 @@ synchronized void enqueue(AsyncCall call) {
    */
   public synchronized void cancelAll() {
     for (AsyncCall call : readyAsyncCalls) {
-      call.cancel();
+      call.get().cancel();
     }
 
     for (AsyncCall call : runningAsyncCalls) {
-      call.cancel();
+      call.get().cancel();
     }
 
     for (RealCall call : runningSyncCalls) {
@@ -133,12 +150,6 @@ public synchronized void cancelAll() {
     }
   }
 
-  /** Used by {@code AsyncCall#run} to signal completion. */
-  synchronized void finished(AsyncCall call) {
-    if (!runningAsyncCalls.remove(call)) throw new AssertionError("AsyncCall wasn't running!");
-    promoteCalls();
-  }
-
   private void promoteCalls() {
     if (runningAsyncCalls.size() >= maxRequests) return; // Already running max capacity.
     if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.
@@ -170,9 +181,29 @@ synchronized void executed(RealCall call) {
     runningSyncCalls.add(call);
   }
 
+  /** Used by {@code AsyncCall#run} to signal completion. */
+  void finished(AsyncCall call) {
+    finished(runningAsyncCalls, call, true);
+  }
+
   /** Used by {@code Call#execute} to signal completion. */
-  synchronized void finished(Call call) {
-    if (!runningSyncCalls.remove(call)) throw new AssertionError("Call wasn't in-flight!");
+  void finished(RealCall call) {
+    finished(runningSyncCalls, call, false);
+  }
+
+  private <T> void finished(Deque<T> calls, T call, boolean promoteCalls) {
+    int runningCallsCount;
+    Runnable idleCallback;
+    synchronized (this) {
+      if (!calls.remove(call)) throw new AssertionError("Call wasn't in-flight!");
+      if (promoteCalls) promoteCalls();
+      runningCallsCount = runningCallsCount();
+      idleCallback = this.idleCallback;
+    }
+
+    if (runningCallsCount == 0 && idleCallback != null) {
+      idleCallback.run();
+    }
   }
 
   /** Returns a snapshot of the calls currently awaiting execution. */
diff --git a/okhttp/src/main/java/okhttp3/Headers.java b/okhttp/src/main/java/okhttp3/Headers.java
index 992569a501..e6c7c359b5 100644
--- a/okhttp/src/main/java/okhttp3/Headers.java
+++ b/okhttp/src/main/java/okhttp3/Headers.java
@@ -18,13 +18,16 @@
 package okhttp3;
 
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.Date;
-import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
+import java.util.TreeMap;
 import java.util.TreeSet;
+import okhttp3.internal.Util;
 import okhttp3.internal.http.HttpDate;
 
 /**
@@ -112,6 +115,41 @@ public Builder newBuilder() {
     return result;
   }
 
+  /**
+   * Returns true if {@code other} is a {@code Headers} object with the same headers, with the same
+   * casing, in the same order. Note that two headers instances may be <i>semantically</i> equal
+   * but not equal according to this method. In particular, none of the following sets of headers
+   * are equal according to this method: <pre>   {@code
+   *
+   *   1. Original
+   *   Content-Type: text/html
+   *   Content-Length: 50
+   *
+   *   2. Different order
+   *   Content-Length: 50
+   *   Content-Type: text/html
+   *
+   *   3. Different case
+   *   content-type: text/html
+   *   content-length: 50
+   *
+   *   4. Different values
+   *   Content-Type: text/html
+   *   Content-Length: 050
+   * }</pre>
+   *
+   * Applications that require semantically equal headers should convert them into a canonical form
+   * before comparing them for equality.
+   */
+  @Override public boolean equals(Object other) {
+    return other instanceof Headers
+        && Arrays.equals(((Headers) other).namesAndValues, namesAndValues);
+  }
+
+  @Override public int hashCode() {
+    return Arrays.hashCode(namesAndValues);
+  }
+
   @Override public String toString() {
     StringBuilder result = new StringBuilder();
     for (int i = 0, size = size(); i < size; i++) {
@@ -121,9 +159,9 @@ public Builder newBuilder() {
   }
 
   public Map<String, List<String>> toMultimap() {
-    Map<String, List<String>> result = new LinkedHashMap<String, List<String>>();
+    Map<String, List<String>> result = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
     for (int i = 0, size = size(); i < size; i++) {
-      String name = name(i);
+      String name = name(i).toLowerCase(Locale.US);
       List<String> values = result.get(name);
       if (values == null) {
         values = new ArrayList<>(2);
@@ -271,15 +309,15 @@ private void checkNameAndValue(String name, String value) {
       for (int i = 0, length = name.length(); i < length; i++) {
         char c = name.charAt(i);
         if (c <= '\u001f' || c >= '\u007f') {
-          throw new IllegalArgumentException(String.format(
+          throw new IllegalArgumentException(Util.format(
               "Unexpected char %#04x at %d in header name: %s", (int) c, i, name));
         }
       }
       if (value == null) throw new NullPointerException("value == null");
       for (int i = 0, length = value.length(); i < length; i++) {
         char c = value.charAt(i);
-        if (c <= '\u001f' || c >= '\u007f') {
-          throw new IllegalArgumentException(String.format(
+        if ((c <= '\u001f' && c != '\u0009' /* htab */) || c >= '\u007f') {
+          throw new IllegalArgumentException(Util.format(
               "Unexpected char %#04x at %d in %s value: %s", (int) c, i, name, value));
         }
       }
diff --git a/okhttp/src/main/java/okhttp3/HttpUrl.java b/okhttp/src/main/java/okhttp3/HttpUrl.java
index 45effb8f6d..39741176d3 100644
--- a/okhttp/src/main/java/okhttp3/HttpUrl.java
+++ b/okhttp/src/main/java/okhttp3/HttpUrl.java
@@ -121,10 +121,16 @@
  * <h4>Path</h4>
  *
  * <p>The path identifies a specific resource on the host. Paths have a hierarchical structure like
- * "/square/okhttp/issues/1486". Each path segment is prefixed with "/". This class offers methods
- * to compose and decompose paths by segment. If a path's last segment is the empty string, then the
- * path ends with "/". This class always builds non-empty paths: if the path is omitted it defaults
- * to "/", which is a path whose only segment is the empty string.
+ * "/square/okhttp/issues/1486" and decompose into a list of segments like ["square", "okhttp",
+ * "issues", "1486"].
+ *
+ * <p>This class offers methods to compose and decompose paths by segment. It composes each path
+ * from a list of segments by alternating between "/" and the encoded segment. For example the
+ * segments ["a", "b"] build "/a/b" and the segments ["a", "b", ""] build "/a/b/".
+ *
+ * <p>If a path's last segment is the empty string then the path ends with "/". This class always
+ * builds non-empty paths: if the path is omitted it defaults to "/". The default path's segment
+ * list is a single empty string: [""].
  *
  * <h4>Query</h4>
  *
@@ -233,7 +239,7 @@
  *   String attack = "http://example.com/static/images/../../../../../etc/passwd";
  *   System.out.println(new URL(attack).getPath());
  *   System.out.println(new URI(attack).getPath());
- *   System.out.println(HttpUrl.parse(attack).path());
+ *   System.out.println(HttpUrl.parse(attack).encodedPath());
  * }</pre>
  *
  * By canonicalizing the input paths, they are complicit in directory traversal attacks. Code that
@@ -386,7 +392,17 @@ public boolean isHttps() {
     return scheme.equals("https");
   }
 
-  /** Returns the username, or an empty string if none is set. */
+  /**
+   * Returns the username, or an empty string if none is set.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code encodedUsername()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>{@code ""}</td></tr>
+   *   <tr><td>{@code http://username@host/}</td><td>{@code "username"}</td></tr>
+   *   <tr><td>{@code http://username:password@host/}</td><td>{@code "username"}</td></tr>
+   *   <tr><td>{@code http://a%20b:c%20d@host/}</td><td>{@code "a%20b"}</td></tr>
+   * </table>
+   */
   public String encodedUsername() {
     if (username.isEmpty()) return "";
     int usernameStart = scheme.length() + 3; // "://".length() == 3.
@@ -394,11 +410,32 @@ public String encodedUsername() {
     return url.substring(usernameStart, usernameEnd);
   }
 
+  /**
+   * Returns the decoded username, or an empty string if none is present.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code username()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>{@code ""}</td></tr>
+   *   <tr><td>{@code http://username@host/}</td><td>{@code "username"}</td></tr>
+   *   <tr><td>{@code http://username:password@host/}</td><td>{@code "username"}</td></tr>
+   *   <tr><td>{@code http://a%20b:c%20d@host/}</td><td>{@code "a b"}</td></tr>
+   * </table>
+   */
   public String username() {
     return username;
   }
 
-  /** Returns the password, or an empty string if none is set. */
+  /**
+   * Returns the password, or an empty string if none is set.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code encodedPassword()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>{@code ""}</td></tr>
+   *   <tr><td>{@code http://username@host/}</td><td>{@code ""}</td></tr>
+   *   <tr><td>{@code http://username:password@host/}</td><td>{@code "password"}</td></tr>
+   *   <tr><td>{@code http://a%20b:c%20d@host/}</td><td>{@code "c%20d"}</td></tr>
+   * </table>
+   */
   public String encodedPassword() {
     if (password.isEmpty()) return "";
     int passwordStart = url.indexOf(':', scheme.length() + 3) + 1;
@@ -406,7 +443,17 @@ public String encodedPassword() {
     return url.substring(passwordStart, passwordEnd);
   }
 
-  /** Returns the decoded password, or an empty string if none is present. */
+  /**
+   * Returns the decoded password, or an empty string if none is present.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code password()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>{@code ""}</td></tr>
+   *   <tr><td>{@code http://username@host/}</td><td>{@code ""}</td></tr>
+   *   <tr><td>{@code http://username:password@host/}</td><td>{@code "password"}</td></tr>
+   *   <tr><td>{@code http://a%20b:c%20d@host/}</td><td>{@code "c d"}</td></tr>
+   * </table>
+   */
   public String password() {
     return password;
   }
@@ -421,6 +468,14 @@ public String password() {
    *   <li>An IPv6 address, like {@code ::1}. Note that there are no square braces.
    *   <li>An encoded IDN, like {@code xn--n3h.net}.
    * </ul>
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code host()}</th></tr>
+   *   <tr><td>{@code http://android.com/}</td><td>{@code "android.com"}</td></tr>
+   *   <tr><td>{@code http://127.0.0.1/}</td><td>{@code "127.0.0.1"}</td></tr>
+   *   <tr><td>{@code http://[::1]/}</td><td>{@code "::1"}</td></tr>
+   *   <tr><td>{@code http://xn--n3h.net/}</td><td>{@code "xn--n3h.net"}</td></tr>
+   * </table>
    */
   public String host() {
     return host;
@@ -430,6 +485,13 @@ public String host() {
    * Returns the explicitly-specified port if one was provided, or the default port for this URL's
    * scheme. For example, this returns 8443 for {@code https://square.com:8443/} and 443 for {@code
    * https://square.com/}. The result is in {@code [1..65535]}.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code port()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>{@code 80}</td></tr>
+   *   <tr><td>{@code http://host:8000/}</td><td>{@code 8000}</td></tr>
+   *   <tr><td>{@code https://host/}</td><td>{@code 443}</td></tr>
+   * </table>
    */
   public int port() {
     return port;
@@ -449,13 +511,31 @@ public static int defaultPort(String scheme) {
     }
   }
 
+  /**
+   * Returns the number of segments in this URL's path. This is also the number of slashes in the
+   * URL's path, like 3 in {@code http://host/a/b/c}. This is always at least 1.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code pathSize()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>{@code 1}</td></tr>
+   *   <tr><td>{@code http://host/a/b/c}</td><td>{@code 3}</td></tr>
+   *   <tr><td>{@code http://host/a/b/c/}</td><td>{@code 4}</td></tr>
+   * </table>
+   */
   public int pathSize() {
     return pathSegments.size();
   }
 
   /**
-   * Returns the entire path of this URL, encoded for use in HTTP resource resolution. The returned
-   * path is always nonempty and is prefixed with {@code /}.
+   * Returns the entire path of this URL encoded for use in HTTP resource resolution. The returned
+   * path will start with {@code "/"}.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code encodedPath()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>{@code "/"}</td></tr>
+   *   <tr><td>{@code http://host/a/b/c}</td><td>{@code "/a/b/c"}</td></tr>
+   *   <tr><td>{@code http://host/a/b%20c/d}</td><td>{@code "/a/b%20c/d"}</td></tr>
+   * </table>
    */
   public String encodedPath() {
     int pathStart = url.indexOf('/', scheme.length() + 3); // "://".length() == 3.
@@ -470,6 +550,17 @@ static void pathSegmentsToString(StringBuilder out, List<String> pathSegments) {
     }
   }
 
+  /**
+   * Returns a list of encoded path segments like {@code ["a", "b", "c"]} for the URL {@code
+   * http://host/a/b/c}. This list is never empty though it may contain a single empty string.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code encodedPathSegments()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>{@code [""]}</td></tr>
+   *   <tr><td>{@code http://host/a/b/c}</td><td>{@code ["a", "b", "c"]}</td></tr>
+   *   <tr><td>{@code http://host/a/b%20c/d}</td><td>{@code ["a", "b%20c", "d"]}</td></tr>
+   * </table>
+   */
   public List<String> encodedPathSegments() {
     int pathStart = url.indexOf('/', scheme.length() + 3);
     int pathEnd = delimiterOffset(url, pathStart, url.length(), "?#");
@@ -483,6 +574,17 @@ static void pathSegmentsToString(StringBuilder out, List<String> pathSegments) {
     return result;
   }
 
+  /**
+   * Returns a list of path segments like {@code ["a", "b", "c"]} for the URL {@code
+   * http://host/a/b/c}. This list is never empty though it may contain a single empty string.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code pathSegments()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>{@code [""]}</td></tr>
+   *   <tr><td>{@code http://host/a/b/c"}</td><td>{@code ["a", "b", "c"]}</td></tr>
+   *   <tr><td>{@code http://host/a/b%20c/d"}</td><td>{@code ["a", "b c", "d"]}</td></tr>
+   * </table>
+   */
   public List<String> pathSegments() {
     return pathSegments;
   }
@@ -491,6 +593,16 @@ static void pathSegmentsToString(StringBuilder out, List<String> pathSegments) {
    * Returns the query of this URL, encoded for use in HTTP resource resolution. The returned string
    * may be null (for URLs with no query), empty (for URLs with an empty query) or non-empty (all
    * other URLs).
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code encodedQuery()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>null</td></tr>
+   *   <tr><td>{@code http://host/?}</td><td>{@code ""}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&k=key+lime}</td><td>{@code
+   *       "a=apple&k=key+lime"}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&a=apricot}</td><td>{@code "a=apple&a=apricot"}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code "a=apple&b"}</td></tr>
+   * </table>
    */
   public String encodedQuery() {
     if (queryNamesAndValues == null) return null; // No query.
@@ -537,6 +649,21 @@ static void namesAndValuesToQueryString(StringBuilder out, List<String> namesAnd
     return result;
   }
 
+  /**
+   * Returns this URL's query, like {@code "abc"} for {@code http://host/?abc}. Most callers should
+   * prefer {@link #queryParameterName} and {@link #queryParameterValue} because these methods offer
+   * direct access to individual query parameters.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code query()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>null</td></tr>
+   *   <tr><td>{@code http://host/?}</td><td>{@code ""}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&k=key+lime}</td><td>{@code "a=apple&k=key
+   *       lime"}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&a=apricot}</td><td>{@code "a=apple&a=apricot"}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code "a=apple&b"}</td></tr>
+   * </table>
+   */
   public String query() {
     if (queryNamesAndValues == null) return null; // No query.
     StringBuilder result = new StringBuilder();
@@ -544,6 +671,20 @@ public String query() {
     return result.toString();
   }
 
+  /**
+   * Returns the number of query parameters in this URL, like 2 for {@code
+   * http://host/?a=apple&b=banana}. If this URL has no query this returns 0. Otherwise it returns
+   * one more than the number of {@code "&"} separators in the query.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code querySize()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>{@code 0}</td></tr>
+   *   <tr><td>{@code http://host/?}</td><td>{@code 1}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&k=key+lime}</td><td>{@code 2}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&a=apricot}</td><td>{@code 2}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code 2}</td></tr>
+   * </table>
+   */
   public int querySize() {
     return queryNamesAndValues != null ? queryNamesAndValues.size() / 2 : 0;
   }
@@ -551,6 +692,15 @@ public int querySize() {
   /**
    * Returns the first query parameter named {@code name} decoded using UTF-8, or null if there is
    * no such query parameter.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code queryParameter("a")}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>null</td></tr>
+   *   <tr><td>{@code http://host/?}</td><td>null</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&k=key+lime}</td><td>{@code "apple"}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&a=apricot}</td><td>{@code "apple"}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code "apple"}</td></tr>
+   * </table>
    */
   public String queryParameter(String name) {
     if (queryNamesAndValues == null) return null;
@@ -562,6 +712,19 @@ public String queryParameter(String name) {
     return null;
   }
 
+  /**
+   * Returns the distinct query parameter names in this URL, like {@code ["a", "b"]} for {@code
+   * http://host/?a=apple&b=banana}. If this URL has no query this returns the empty set.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code queryParameterNames()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>{@code []}</td></tr>
+   *   <tr><td>{@code http://host/?}</td><td>{@code [""]}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&k=key+lime}</td><td>{@code ["a", "k"]}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&a=apricot}</td><td>{@code ["a"]}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code ["a", "b"]}</td></tr>
+   * </table>
+   */
   public Set<String> queryParameterNames() {
     if (queryNamesAndValues == null) return Collections.emptySet();
     Set<String> result = new LinkedHashSet<>();
@@ -571,6 +734,24 @@ public String queryParameter(String name) {
     return Collections.unmodifiableSet(result);
   }
 
+  /**
+   * Returns all values for the query parameter {@code name} ordered by their appearance in this
+   * URL. For example this returns {@code ["banana"]} for {@code queryParameterValue("b")} on {@code
+   * http://host/?a=apple&b=banana}.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code queryParameterValues("a")}</th><th>{@code
+   *       queryParameterValues("b")}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>{@code []}</td><td>{@code []}</td></tr>
+   *   <tr><td>{@code http://host/?}</td><td>{@code []}</td><td>{@code []}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&k=key+lime}</td><td>{@code ["apple"]}</td><td>{@code
+   *       []}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&a=apricot}</td><td>{@code ["apple",
+   *       "apricot"]}</td><td>{@code []}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code ["apple"]}</td><td>{@code
+   *       [null]}</td></tr>
+   * </table>
+   */
   public List<String> queryParameterValues(String name) {
     if (queryNamesAndValues == null) return Collections.emptyList();
     List<String> result = new ArrayList<>();
@@ -582,24 +763,95 @@ public String queryParameter(String name) {
     return Collections.unmodifiableList(result);
   }
 
+  /**
+   * Returns the name of the query parameter at {@code index}. For example this returns {@code "a"}
+   * for {@code queryParameterName(0)} on {@code http://host/?a=apple&b=banana}. This throws if
+   * {@code index} is not less than the {@linkplain #querySize query size}.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code queryParameterName(0)}</th><th>{@code
+   *       queryParameterName(1)}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>exception</td><td>exception</td></tr>
+   *   <tr><td>{@code http://host/?}</td><td>{@code ""}</td><td>exception</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&k=key+lime}</td><td>{@code "a"}</td><td>{@code
+   *       "k"}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&a=apricot}</td><td>{@code "a"}</td><td>{@code
+   *       "a"}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code "a"}</td><td>{@code "b"}</td></tr>
+   * </table>
+   */
   public String queryParameterName(int index) {
+    if (queryNamesAndValues == null) throw new IndexOutOfBoundsException();
     return queryNamesAndValues.get(index * 2);
   }
 
+  /**
+   * Returns the value of the query parameter at {@code index}. For example this returns {@code
+   * "apple"} for {@code queryParameterName(0)} on {@code http://host/?a=apple&b=banana}. This
+   * throws if {@code index} is not less than the {@linkplain #querySize query size}.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code queryParameterValue(0)}</th><th>{@code
+   *       queryParameterValue(1)}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>exception</td><td>exception</td></tr>
+   *   <tr><td>{@code http://host/?}</td><td>null</td><td>exception</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&k=key+lime}</td><td>{@code "apple"}</td><td>{@code
+   *       "key lime"}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&a=apricot}</td><td>{@code "apple"}</td><td>{@code
+   *       "apricot"}</td></tr>
+   *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code "apple"}</td><td>null</td></tr>
+   * </table>
+   */
   public String queryParameterValue(int index) {
+    if (queryNamesAndValues == null) throw new IndexOutOfBoundsException();
     return queryNamesAndValues.get(index * 2 + 1);
   }
 
+  /**
+   * Returns this URL's encoded fragment, like {@code "abc"} for {@code http://host/#abc}. This
+   * returns null if the URL has no fragment.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code encodedFragment()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>null</td></tr>
+   *   <tr><td>{@code http://host/#}</td><td>{@code ""}</td></tr>
+   *   <tr><td>{@code http://host/#abc}</td><td>{@code "abc"}</td></tr>
+   *   <tr><td>{@code http://host/#abc|def}</td><td>{@code "abc|def"}</td></tr>
+   * </table>
+   */
   public String encodedFragment() {
     if (fragment == null) return null;
     int fragmentStart = url.indexOf('#') + 1;
     return url.substring(fragmentStart);
   }
 
+  /**
+   * Returns this URL's fragment, like {@code "abc"} for {@code http://host/#abc}. This returns null
+   * if the URL has no fragment.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code fragment()}</th></tr>
+   *   <tr><td>{@code http://host/}</td><td>null</td></tr>
+   *   <tr><td>{@code http://host/#}</td><td>{@code ""}</td></tr>
+   *   <tr><td>{@code http://host/#abc}</td><td>{@code "abc"}</td></tr>
+   *   <tr><td>{@code http://host/#abc|def}</td><td>{@code "abc|def"}</td></tr>
+   * </table>
+   */
   public String fragment() {
     return fragment;
   }
 
+  /**
+   * Returns the HttpUrl with the username, password, path, query, and fragment stripped.
+   * Example: http://username:password@example.com/path returns http://example.com/...
+   */
+  public HttpUrl redact() {
+    Builder builder = newBuilder("/...");
+    builder.username("");
+    builder.password("");
+    return builder.build();
+  }
+
   /**
    * Returns the URL that would be retrieved by following {@code link} from this URL, or null if
    * the resulting URL is not well-formed.
@@ -1474,8 +1726,10 @@ static String percentDecode(String encoded, boolean plusIsSpace) {
   }
 
   private List<String> percentDecode(List<String> list, boolean plusIsSpace) {
-    List<String> result = new ArrayList<>(list.size());
-    for (String s : list) {
+    int size = list.size();
+    List<String> result = new ArrayList<>(size);
+    for (int i = 0; i < size; i++) {
+      String s = list.get(i);
       result.add(s != null ? percentDecode(s, plusIsSpace) : null);
     }
     return Collections.unmodifiableList(result);
diff --git a/okhttp/src/main/java/okhttp3/MediaType.java b/okhttp/src/main/java/okhttp3/MediaType.java
index bbdcedf686..77b943e589 100644
--- a/okhttp/src/main/java/okhttp3/MediaType.java
+++ b/okhttp/src/main/java/okhttp3/MediaType.java
@@ -61,9 +61,17 @@ public static MediaType parse(String string) {
 
       String name = parameter.group(1);
       if (name == null || !name.equalsIgnoreCase("charset")) continue;
-      String charsetParameter = parameter.group(2) != null
-          ? parameter.group(2)  // Value is a token.
-          : parameter.group(3); // Value is a quoted string.
+      String charsetParameter;
+      String token = parameter.group(2);
+      if (token != null) {
+        // If the token is 'single-quoted' it's invalid! But we're lenient and strip the quotes.
+        charsetParameter = (token.startsWith("'") && token.endsWith("'") && token.length() > 2)
+            ? token.substring(1, token.length() - 1)
+            : token;
+      } else {
+        // Value is "double-quoted". That's valid and our regex group already strips the quotes.
+        charsetParameter = parameter.group(3);
+      }
       if (charset != null && !charsetParameter.equalsIgnoreCase(charset)) {
         throw new IllegalArgumentException("Multiple different charsets: " + string);
       }
diff --git a/okhttp/src/main/java/okhttp3/MultipartBody.java b/okhttp/src/main/java/okhttp3/MultipartBody.java
index 7ac584d1d9..3aa31f310d 100644
--- a/okhttp/src/main/java/okhttp3/MultipartBody.java
+++ b/okhttp/src/main/java/okhttp3/MultipartBody.java
@@ -257,13 +257,21 @@ public static Part createFormData(String name, String filename, RequestBody body
       return create(Headers.of("Content-Disposition", disposition.toString()), body);
     }
 
-    private final Headers headers;
-    private final RequestBody body;
+    final Headers headers;
+    final RequestBody body;
 
     private Part(Headers headers, RequestBody body) {
       this.headers = headers;
       this.body = body;
     }
+
+    public Headers headers() {
+      return headers;
+    }
+
+    public RequestBody body() {
+      return body;
+    }
   }
 
   public static final class Builder {
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
index 8df00c54a4..999015996b 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.java
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java
@@ -23,7 +23,9 @@
 import java.security.KeyStore;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
+import java.util.concurrent.ExecutorService;
 import java.util.concurrent.TimeUnit;
 import javax.net.SocketFactory;
 import javax.net.ssl.HostnameVerifier;
@@ -34,36 +36,88 @@
 import javax.net.ssl.TrustManagerFactory;
 import javax.net.ssl.X509TrustManager;
 import okhttp3.internal.Internal;
-import okhttp3.internal.InternalCache;
-import okhttp3.internal.Platform;
-import okhttp3.internal.RouteDatabase;
 import okhttp3.internal.Util;
-import okhttp3.internal.http.StreamAllocation;
-import okhttp3.internal.io.RealConnection;
+import okhttp3.internal.cache.InternalCache;
+import okhttp3.internal.connection.RealConnection;
+import okhttp3.internal.connection.RouteDatabase;
+import okhttp3.internal.connection.StreamAllocation;
+import okhttp3.internal.platform.Platform;
 import okhttp3.internal.tls.CertificateChainCleaner;
 import okhttp3.internal.tls.OkHostnameVerifier;
 
 /**
  * Factory for {@linkplain Call calls}, which can be used to send HTTP requests and read their
- * responses. Most applications can use a single OkHttpClient for all of their HTTP requests,
- * benefiting from a shared response cache, thread pool, connection re-use, etc.
+ * responses.
  *
- * <p>To create an {@code OkHttpClient} with the default settings, use the {@linkplain
- * #OkHttpClient() default constructor}. Or create a configured instance with {@link
- * OkHttpClient.Builder}. To adjust an existing client before making a request, use {@link
- * #newBuilder()}. This example shows a call with a 30 second timeout:
+ * <h3>OkHttpClients should be shared</h3>
+ *
+ * <p>OkHttp performs best when you create a single {@code OkHttpClient} instance and reuse it for
+ * all of your HTTP calls. This is because each client holds its own connection pool and thread
+ * pools. Reusing connections and threads reduces latency and saves memory. Conversely, creating a
+ * client for each request wastes resources on idle pools.
+ *
+ * <p>Use {@code new OkHttpClient()} to create a shared instance with the default settings:
+ * <pre>   {@code
+ *
+ *   // The singleton HTTP client.
+ *   public final OkHttpClient client = new OkHttpClient();
+ * }</pre>
+ *
+ * <p>Or use {@code new OkHttpClient.Builder()} to create a shared instance with custom settings:
  * <pre>   {@code
  *
- *   OkHttpClient client = ...
- *   OkHttpClient clientWith30sTimeout = client.newBuilder()
- *       .readTimeout(30, TimeUnit.SECONDS)
+ *   // The singleton HTTP client.
+ *   public final OkHttpClient client = new OkHttpClient.Builder()
+ *       .addInterceptor(new HttpLoggingInterceptor())
+ *       .cache(new Cache(cacheDir, cacheSize))
+ *       .build();
+ * }</pre>
+ *
+ * <h3>Customize your client with newBuilder()</h3>
+ *
+ * <p>You can customize a shared OkHttpClient instance with {@link #newBuilder()}. This builds a
+ * client that shares the same connection pool, thread pools, and configuration. Use the builder
+ * methods to configure the derived client for a specific purpose.
+ *
+ * <p>This example shows a call with a short 500 millisecond timeout: <pre>   {@code
+ *
+ *   OkHttpClient eagerClient = client.newBuilder()
+ *       .readTimeout(500, TimeUnit.MILLISECONDS)
  *       .build();
- *   Response response = clientWith30sTimeout.newCall(request).execute();
+ *   Response response = eagerClient.newCall(request).execute();
+ * }</pre>
+ *
+ * <h3>Shutdown isn't necessary</h3>
+ *
+ * <p>The threads and connections that are held will be released automatically if they remain idle.
+ * But if you are writing a application that needs to aggressively release unused resources you may
+ * do so.
+ *
+ * <p>Shutdown the dispatcher's executor service with {@link ExecutorService#shutdown shutdown()}.
+ * This will also cause future calls to the client to be rejected. <pre>   {@code
+ *
+ *     client.dispatcher().executorService().shutdown();
+ * }</pre>
+ *
+ * <p>Clear the connection pool with {@link ConnectionPool#evictAll() evictAll()}. Note that the
+ * connection pool's daemon thread may not exit immediately. <pre>   {@code
+ *
+ *     client.connectionPool().evictAll();
  * }</pre>
+ *
+ * <p>If your client has a cache, call {@link Cache#close close()}. Note that it is an error to
+ * create calls against a cache that is closed, and doing so will cause the call to crash.
+ * <pre>   {@code
+ *
+ *     client.cache().close();
+ * }</pre>
+ *
+ * <p>OkHttp also uses daemon threads for HTTP/2 connections. These will exit automatically if they
+ * remain idle.
  */
-public class OkHttpClient implements Cloneable, Call.Factory {
+public class OkHttpClient implements Cloneable, Call.Factory, WebSocketCall.Factory {
   private static final List<Protocol> DEFAULT_PROTOCOLS = Util.immutableList(
-      Protocol.HTTP_2, Protocol.SPDY_3, Protocol.HTTP_1_1);
+      Protocol.HTTP_2, Protocol.HTTP_1_1);
 
   private static final List<ConnectionSpec> DEFAULT_CONNECTION_SPECS = Util.immutableList(
       ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS, ConnectionSpec.CLEARTEXT);
@@ -82,10 +136,6 @@
         builder.setInternalCache(internalCache);
       }
 
-      @Override public InternalCache internalCache(OkHttpClient client) {
-        return client.internalCache();
-      }
-
       @Override public boolean connectionBecameIdle(
           ConnectionPool pool, RealConnection connection) {
         return pool.connectionBecameIdle(connection);
@@ -104,15 +154,6 @@
         return connectionPool.routeDatabase;
       }
 
-      @Override
-      public void callEnqueue(Call call, Callback responseCallback, boolean forWebSocket) {
-        ((RealCall) call).enqueue(responseCallback, forWebSocket);
-      }
-
-      @Override public StreamAllocation callEngineGetStreamAllocation(Call call) {
-        return ((RealCall) call).engine.streamAllocation;
-      }
-
       @Override
       public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean isFallback) {
         tlsConfiguration.apply(sslSocket, isFallback);
@@ -336,7 +377,14 @@ public Dispatcher dispatcher() {
    * Prepares the {@code request} to be executed at some point in the future.
    */
   @Override public Call newCall(Request request) {
-    return new RealCall(this, request);
+    return new RealCall(this, request, false /* for web socket */);
+  }
+
+  /**
+   * Prepares the {@code request} to create a web socket at some point in the future.
+   */
+  @Override public WebSocketCall newWebSocketCall(Request request) {
+    return new RealWebSocketCall(this, request);
   }
 
   public Builder newBuilder() {
@@ -663,7 +711,7 @@ public Builder followSslRedirects(boolean followProtocolRedirects) {
       return this;
     }
 
-    /** Configure this client to follow redirects. If unset, redirects be followed. */
+    /** Configure this client to follow redirects. If unset, redirects will be followed. */
     public Builder followRedirects(boolean followRedirects) {
       this.followRedirects = followRedirects;
       return this;
@@ -705,14 +753,12 @@ public Builder dispatcher(Dispatcher dispatcher) {
      * Configure the protocols used by this client to communicate with remote servers. By default
      * this client will prefer the most efficient transport available, falling back to more
      * ubiquitous protocols. Applications should only call this method to avoid specific
-     * compatibility problems, such as web servers that behave incorrectly when SPDY is enabled.
+     * compatibility problems, such as web servers that behave incorrectly when HTTP/2 is enabled.
      *
      * <p>The following protocols are currently supported:
      *
      * <ul>
      *     <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>
-     *     <li><a
-     *         href="http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1">spdy/3.1</a>
      *     <li><a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-17">h2</a>
      * </ul>
      *
@@ -731,7 +777,10 @@ public Builder dispatcher(Dispatcher dispatcher) {
      * Protocol#HTTP_1_1}. It must not contain null or {@link Protocol#HTTP_1_0}.
      */
     public Builder protocols(List<Protocol> protocols) {
-      protocols = Util.immutableList(protocols);
+      // Create a private copy of the list.
+      protocols = new ArrayList<>(protocols);
+
+      // Validate that the list has everything we require and nothing we forbid.
       if (!protocols.contains(Protocol.HTTP_1_1)) {
         throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
       }
@@ -741,7 +790,14 @@ public Builder protocols(List<Protocol> protocols) {
       if (protocols.contains(null)) {
         throw new IllegalArgumentException("protocols must not contain null");
       }
-      this.protocols = Util.immutableList(protocols);
+
+      // Remove protocols that we no longer support.
+      if (protocols.contains(Protocol.SPDY_3)) {
+        protocols.remove(Protocol.SPDY_3);
+      }
+
+      // Assign as an unmodifiable list. This is effectively immutable.
+      this.protocols = Collections.unmodifiableList(protocols);
       return this;
     }
 
diff --git a/okhttp/src/main/java/okhttp3/Protocol.java b/okhttp/src/main/java/okhttp3/Protocol.java
index eec1c1219c..88d15b9b6b 100644
--- a/okhttp/src/main/java/okhttp3/Protocol.java
+++ b/okhttp/src/main/java/okhttp3/Protocol.java
@@ -44,9 +44,9 @@
    * Chromium's binary-framed protocol that includes header compression, multiplexing multiple
    * requests on the same socket, and server-push. HTTP/1.1 semantics are layered on SPDY/3.
    *
-   * <p>This version of OkHttp implements SPDY 3 <a
-   * href="http://dev.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1">draft 3.1</a>. Future
-   * releases of OkHttp may use this identifier for a newer draft of the SPDY spec.
+   * <p>Current versions of OkHttp do not support this protocol.
+   *
+   * @deprecated OkHttp has dropped support for SPDY. Prefer {@link #HTTP_2}.
    */
   SPDY_3("spdy/3.1"),
 
diff --git a/okhttp/src/main/java/okhttp3/RealCall.java b/okhttp/src/main/java/okhttp3/RealCall.java
index 58814d53f8..3c027a2caf 100644
--- a/okhttp/src/main/java/okhttp3/RealCall.java
+++ b/okhttp/src/main/java/okhttp3/RealCall.java
@@ -16,31 +16,36 @@
 package okhttp3;
 
 import java.io.IOException;
-import java.net.ProtocolException;
-import java.util.logging.Level;
+import java.util.ArrayList;
+import java.util.List;
 import okhttp3.internal.NamedRunnable;
-import okhttp3.internal.http.HttpEngine;
-import okhttp3.internal.http.RequestException;
-import okhttp3.internal.http.RouteException;
-import okhttp3.internal.http.StreamAllocation;
+import okhttp3.internal.cache.CacheInterceptor;
+import okhttp3.internal.connection.ConnectInterceptor;
+import okhttp3.internal.connection.StreamAllocation;
+import okhttp3.internal.http.BridgeInterceptor;
+import okhttp3.internal.http.CallServerInterceptor;
+import okhttp3.internal.http.RealInterceptorChain;
+import okhttp3.internal.http.RetryAndFollowUpInterceptor;
+import okhttp3.internal.platform.Platform;
 
-import static okhttp3.internal.Internal.logger;
-import static okhttp3.internal.http.HttpEngine.MAX_FOLLOW_UPS;
+import static okhttp3.internal.platform.Platform.INFO;
 
 final class RealCall implements Call {
-  private final OkHttpClient client;
+  final OkHttpClient client;
+  final RetryAndFollowUpInterceptor retryAndFollowUpInterceptor;
+
+  /** The application's original request unadulterated by redirects or auth headers. */
+  final Request originalRequest;
+  final boolean forWebSocket;
 
   // Guarded by this.
   private boolean executed;
-  volatile boolean canceled;
-
-  /** The application's original request unadulterated by redirects or auth headers. */
-  Request originalRequest;
-  HttpEngine engine;
 
-  protected RealCall(OkHttpClient client, Request originalRequest) {
+  RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
     this.client = client;
     this.originalRequest = originalRequest;
+    this.forWebSocket = forWebSocket;
+    this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket);
   }
 
   @Override public Request request() {
@@ -52,9 +57,10 @@ protected RealCall(OkHttpClient client, Request originalRequest) {
       if (executed) throw new IllegalStateException("Already Executed");
       executed = true;
     }
+    captureCallStackTrace();
     try {
       client.dispatcher().executed(this);
-      Response result = getResponseWithInterceptorChain(false);
+      Response result = getResponseWithInterceptorChain();
       if (result == null) throw new IOException("Canceled");
       return result;
     } finally {
@@ -62,25 +68,22 @@ protected RealCall(OkHttpClient client, Request originalRequest) {
     }
   }
 
-  Object tag() {
-    return originalRequest.tag();
+  private void captureCallStackTrace() {
+    Object callStackTrace = Platform.get().getStackTraceForCloseable("response.body().close()");
+    retryAndFollowUpInterceptor.setCallStackTrace(callStackTrace);
   }
 
   @Override public void enqueue(Callback responseCallback) {
-    enqueue(responseCallback, false);
-  }
-
-  void enqueue(Callback responseCallback, boolean forWebSocket) {
     synchronized (this) {
       if (executed) throw new IllegalStateException("Already Executed");
       executed = true;
     }
-    client.dispatcher().enqueue(new AsyncCall(responseCallback, forWebSocket));
+    captureCallStackTrace();
+    client.dispatcher().enqueue(new AsyncCall(responseCallback));
   }
 
   @Override public void cancel() {
-    canceled = true;
-    if (engine != null) engine.cancel();
+    retryAndFollowUpInterceptor.cancel();
   }
 
   @Override public synchronized boolean isExecuted() {
@@ -88,17 +91,24 @@ void enqueue(Callback responseCallback, boolean forWebSocket) {
   }
 
   @Override public boolean isCanceled() {
-    return canceled;
+    return retryAndFollowUpInterceptor.isCanceled();
+  }
+
+  @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
+  @Override public RealCall clone() {
+    return new RealCall(client, originalRequest, forWebSocket);
+  }
+
+  StreamAllocation streamAllocation() {
+    return retryAndFollowUpInterceptor.streamAllocation();
   }
 
   final class AsyncCall extends NamedRunnable {
     private final Callback responseCallback;
-    private final boolean forWebSocket;
 
-    private AsyncCall(Callback responseCallback, boolean forWebSocket) {
-      super("OkHttp %s", originalRequest.url().toString());
+    AsyncCall(Callback responseCallback) {
+      super("OkHttp %s", redactedUrl());
       this.responseCallback = responseCallback;
-      this.forWebSocket = forWebSocket;
     }
 
     String host() {
@@ -109,14 +119,6 @@ Request request() {
       return originalRequest;
     }
 
-    Object tag() {
-      return originalRequest.tag();
-    }
-
-    void cancel() {
-      RealCall.this.cancel();
-    }
-
     RealCall get() {
       return RealCall.this;
     }
@@ -124,8 +126,8 @@ RealCall get() {
     @Override protected void execute() {
       boolean signalledCallback = false;
       try {
-        Response response = getResponseWithInterceptorChain(forWebSocket);
-        if (canceled) {
+        Response response = getResponseWithInterceptorChain();
+        if (retryAndFollowUpInterceptor.isCanceled()) {
           signalledCallback = true;
           responseCallback.onFailure(RealCall.this, new IOException("Canceled"));
         } else {
@@ -135,7 +137,7 @@ RealCall get() {
       } catch (IOException e) {
         if (signalledCallback) {
           // Do not signal the callback twice!
-          logger.log(Level.INFO, "Callback failure for " + toLoggableString(), e);
+          Platform.get().log(INFO, "Callback failure for " + toLoggableString(), e);
         } else {
           responseCallback.onFailure(RealCall.this, e);
         }
@@ -149,154 +151,31 @@ RealCall get() {
    * Returns a string that describes this call. Doesn't include a full URL as that might contain
    * sensitive information.
    */
-  private String toLoggableString() {
-    String string = canceled ? "canceled call" : "call";
-    HttpUrl redactedUrl = originalRequest.url().resolve("/...");
-    return string + " to " + redactedUrl;
+  String toLoggableString() {
+    return (isCanceled() ? "canceled " : "")
+        + (forWebSocket ? "web socket" : "call")
+        + " to " + redactedUrl();
   }
 
-  private Response getResponseWithInterceptorChain(boolean forWebSocket) throws IOException {
-    Interceptor.Chain chain = new ApplicationInterceptorChain(0, originalRequest, forWebSocket);
-    return chain.proceed(originalRequest);
+  String redactedUrl() {
+    return originalRequest.url().redact().toString();
   }
 
-  class ApplicationInterceptorChain implements Interceptor.Chain {
-    private final int index;
-    private final Request request;
-    private final boolean forWebSocket;
-
-    ApplicationInterceptorChain(int index, Request request, boolean forWebSocket) {
-      this.index = index;
-      this.request = request;
-      this.forWebSocket = forWebSocket;
-    }
-
-    @Override public Connection connection() {
-      return null;
-    }
-
-    @Override public Request request() {
-      return request;
-    }
-
-    @Override public Response proceed(Request request) throws IOException {
-      // If there's another interceptor in the chain, call that.
-      if (index < client.interceptors().size()) {
-        Interceptor.Chain chain = new ApplicationInterceptorChain(index + 1, request, forWebSocket);
-        Interceptor interceptor = client.interceptors().get(index);
-        Response interceptedResponse = interceptor.intercept(chain);
-
-        if (interceptedResponse == null) {
-          throw new NullPointerException("application interceptor " + interceptor
-              + " returned null");
-        }
-
-        return interceptedResponse;
-      }
-
-      // No more interceptors. Do HTTP.
-      return getResponse(request, forWebSocket);
-    }
-  }
-
-  /**
-   * Performs the request and returns the response. May return null if this call was canceled.
-   */
-  Response getResponse(Request request, boolean forWebSocket) throws IOException {
-    // Copy body metadata to the appropriate request headers.
-    RequestBody body = request.body();
-    if (body != null) {
-      Request.Builder requestBuilder = request.newBuilder();
-
-      MediaType contentType = body.contentType();
-      if (contentType != null) {
-        requestBuilder.header("Content-Type", contentType.toString());
-      }
-
-      long contentLength = body.contentLength();
-      if (contentLength != -1) {
-        requestBuilder.header("Content-Length", Long.toString(contentLength));
-        requestBuilder.removeHeader("Transfer-Encoding");
-      } else {
-        requestBuilder.header("Transfer-Encoding", "chunked");
-        requestBuilder.removeHeader("Content-Length");
-      }
-
-      request = requestBuilder.build();
-    }
-
-    // Create the initial HTTP engine. Retries and redirects need new engine for each attempt.
-    engine = new HttpEngine(client, request, false, false, forWebSocket, null, null, null);
-
-    int followUpCount = 0;
-    while (true) {
-      if (canceled) {
-        engine.releaseStreamAllocation();
-        throw new IOException("Canceled");
-      }
-
-      boolean releaseConnection = true;
-      try {
-        engine.sendRequest();
-        engine.readResponse();
-        releaseConnection = false;
-      } catch (RequestException e) {
-        // The attempt to interpret the request failed. Give up.
-        throw e.getCause();
-      } catch (RouteException e) {
-        // The attempt to connect via a route failed. The request will not have been sent.
-        HttpEngine retryEngine = engine.recover(e.getLastConnectException(), true, null);
-        if (retryEngine != null) {
-          releaseConnection = false;
-          engine = retryEngine;
-          continue;
-        }
-        // Give up; recovery is not possible.
-        throw e.getLastConnectException();
-      } catch (IOException e) {
-        // An attempt to communicate with a server failed. The request may have been sent.
-        HttpEngine retryEngine = engine.recover(e, false, null);
-        if (retryEngine != null) {
-          releaseConnection = false;
-          engine = retryEngine;
-          continue;
-        }
-
-        // Give up; recovery is not possible.
-        throw e;
-      } finally {
-        // We're throwing an unchecked exception. Release any resources.
-        if (releaseConnection) {
-          StreamAllocation streamAllocation = engine.close();
-          streamAllocation.release();
-        }
-      }
-
-      Response response = engine.getResponse();
-      Request followUp = engine.followUpRequest();
-
-      if (followUp == null) {
-        if (!forWebSocket) {
-          engine.releaseStreamAllocation();
-        }
-        return response;
-      }
-
-      StreamAllocation streamAllocation = engine.close();
-
-      if (++followUpCount > MAX_FOLLOW_UPS) {
-        streamAllocation.release();
-        throw new ProtocolException("Too many follow-up requests: " + followUpCount);
-      }
-
-      if (!engine.sameConnection(followUp.url())) {
-        streamAllocation.release();
-        streamAllocation = null;
-      }
-
-      request = followUp;
-      engine = new HttpEngine(client, request, false, false, forWebSocket, streamAllocation, null,
-          response);
-    }
+  Response getResponseWithInterceptorChain() throws IOException {
+    // Build a full stack of interceptors.
+    List<Interceptor> interceptors = new ArrayList<>();
+    interceptors.addAll(client.interceptors());
+    interceptors.add(retryAndFollowUpInterceptor);
+    interceptors.add(new BridgeInterceptor(client.cookieJar()));
+    interceptors.add(new CacheInterceptor(client.internalCache()));
+    interceptors.add(new ConnectInterceptor(client));
+    if (!forWebSocket) {
+      interceptors.addAll(client.networkInterceptors());
+    }
+    interceptors.add(new CallServerInterceptor(forWebSocket));
+
+    Interceptor.Chain chain = new RealInterceptorChain(
+        interceptors, null, null, null, 0, originalRequest);
+    return chain.proceed(originalRequest);
   }
 }
diff --git a/okhttp-ws/src/main/java/okhttp3/ws/WebSocketCall.java b/okhttp/src/main/java/okhttp3/RealWebSocketCall.java
similarity index 51%
rename from okhttp-ws/src/main/java/okhttp3/ws/WebSocketCall.java
rename to okhttp/src/main/java/okhttp3/RealWebSocketCall.java
index 8e5c5ce055..f383c58e76 100644
--- a/okhttp-ws/src/main/java/okhttp3/ws/WebSocketCall.java
+++ b/okhttp/src/main/java/okhttp3/RealWebSocketCall.java
@@ -13,48 +13,39 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.ws;
+package okhttp3;
 
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.security.SecureRandom;
 import java.util.Collections;
+import java.util.List;
 import java.util.Random;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.LinkedBlockingDeque;
 import java.util.concurrent.ThreadPoolExecutor;
-import okhttp3.Call;
-import okhttp3.Callback;
-import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
-import okhttp3.internal.http.StreamAllocation;
+import okhttp3.internal.connection.StreamAllocation;
 import okhttp3.internal.ws.RealWebSocket;
 import okhttp3.internal.ws.WebSocketProtocol;
 import okio.ByteString;
 
 import static java.util.concurrent.TimeUnit.SECONDS;
 
-public final class WebSocketCall {
-  /**
-   * Prepares the {@code request} to create a web socket at some point in the future.
-   */
-  public static WebSocketCall create(OkHttpClient client, Request request) {
-    return new WebSocketCall(client, request);
-  }
+final class RealWebSocketCall implements WebSocketCall {
+  private static final List<Protocol> ONLY_HTTP1 = Collections.singletonList(Protocol.HTTP_1_1);
 
-  private final Call call;
+  /** The application's original request unadulterated by web socket headers. */
+  private final Request originalRequest;
+  private final RealCall call;
   private final Random random;
   private final String key;
 
-  WebSocketCall(OkHttpClient client, Request request) {
+  RealWebSocketCall(OkHttpClient client, Request request) {
     this(client, request, new SecureRandom());
   }
 
-  WebSocketCall(OkHttpClient client, Request request, Random random) {
+  RealWebSocketCall(OkHttpClient client, Request request, Random random) {
     if (!"GET".equals(request.method())) {
       throw new IllegalArgumentException("Request must be GET: " + request.method());
     }
@@ -65,9 +56,12 @@ public static WebSocketCall create(OkHttpClient client, Request request) {
     key = ByteString.of(nonce).base64();
 
     client = client.newBuilder()
-        .protocols(Collections.singletonList(Protocol.HTTP_1_1))
+        .readTimeout(0, SECONDS) // i.e., no timeout because this is a long-lived connection.
+        .writeTimeout(0, SECONDS) // i.e., no timeout because this is a long-lived connection.
+        .protocols(ONLY_HTTP1)
         .build();
 
+    originalRequest = request;
     request = request.newBuilder()
         .header("Upgrade", "websocket")
         .header("Connection", "Upgrade")
@@ -75,47 +69,32 @@ public static WebSocketCall create(OkHttpClient client, Request request) {
         .header("Sec-WebSocket-Version", "13")
         .build();
 
-    call = client.newCall(request);
+    call = new RealCall(client, request, true /* for web socket */);
   }
 
-  /**
-   * Schedules the request to be executed at some point in the future.
-   *
-   * <p>The {@link OkHttpClient#dispatcher dispatcher} defines when the request will run: usually
-   * immediately unless there are several other requests currently being executed.
-   *
-   * <p>This client will later call back {@code responseCallback} with either an HTTP response or a
-   * failure exception. If you {@link #cancel} a request before it completes the callback will not
-   * be invoked.
-   *
-   * @throws IllegalStateException when the call has already been executed.
-   */
-  public void enqueue(final WebSocketListener listener) {
+  @Override public void enqueue(final WebSocketListener listener) {
     Callback responseCallback = new Callback() {
-      @Override public void onResponse(Call call, Response response) throws IOException {
+      @Override public void onResponse(Call call, Response response) {
+        StreamWebSocket webSocket;
         try {
-          createWebSocket(response, listener);
+          webSocket = create(response, listener);
         } catch (IOException e) {
           listener.onFailure(e, response);
+          return;
         }
+
+        webSocket.loopReader();
       }
 
       @Override public void onFailure(Call call, IOException e) {
         listener.onFailure(e, null);
       }
     };
-    // TODO call.enqueue(responseCallback, true);
-    Internal.instance.callEnqueue(call, responseCallback, true);
-  }
-
-  /** Cancels the request, if possible. Requests that are already complete cannot be canceled. */
-  public void cancel() {
-    call.cancel();
+    call.enqueue(responseCallback);
   }
 
-  private void createWebSocket(Response response, WebSocketListener listener) throws IOException {
+  StreamWebSocket create(Response response, WebSocketListener listener) throws IOException {
     if (response.code() != 101) {
-      Util.closeQuietly(response.body());
       throw new ProtocolException("Expected HTTP 101 response but was '"
           + response.code()
           + " "
@@ -143,44 +122,53 @@ private void createWebSocket(Response response, WebSocketListener listener) thro
           + "'");
     }
 
-    StreamAllocation streamAllocation = Internal.instance.callEngineGetStreamAllocation(call);
-    RealWebSocket webSocket = StreamWebSocket.create(
-        streamAllocation, response, random, listener);
+    String name = response.request().url().redact().toString();
+    ThreadPoolExecutor replyExecutor =
+        new ThreadPoolExecutor(1, 1, 1, SECONDS, new LinkedBlockingDeque<Runnable>(),
+            Util.threadFactory(Util.format("OkHttp %s WebSocket Replier", name), true));
+    replyExecutor.allowCoreThreadTimeOut(true);
 
-    listener.onOpen(webSocket, response);
+    StreamAllocation streamAllocation = call.streamAllocation();
+    streamAllocation.noNewStreams(); // Web socket connections can't be re-used.
+    return new StreamWebSocket(streamAllocation, random, replyExecutor, listener, response, name);
+  }
 
-    while (webSocket.readMessage()) {
-    }
+  @Override public Request request() {
+    return originalRequest;
   }
 
-  // Keep static so that the WebSocketCall instance can be garbage collected.
-  private static class StreamWebSocket extends RealWebSocket {
-    static RealWebSocket create(StreamAllocation streamAllocation, Response response,
-        Random random, WebSocketListener listener) {
-      String url = response.request().url().toString();
-      ThreadPoolExecutor replyExecutor =
-          new ThreadPoolExecutor(1, 1, 1, SECONDS, new LinkedBlockingDeque<Runnable>(),
-              Util.threadFactory(String.format("OkHttp %s WebSocket", url), true));
-      replyExecutor.allowCoreThreadTimeOut(true);
-
-      return new StreamWebSocket(streamAllocation, random, replyExecutor, listener, url);
-    }
+  @Override public void cancel() {
+    call.cancel();
+  }
 
+  @Override public boolean isExecuted() {
+    return call.isExecuted();
+  }
+
+  @Override public boolean isCanceled() {
+    return call.isCanceled();
+  }
+
+  @Override public WebSocketCall clone() {
+    return new RealWebSocketCall(call.client, originalRequest, random);
+  }
+
+  // Keep static so that the WebSocketCall instance can be garbage collected.
+  static final class StreamWebSocket extends RealWebSocket {
     private final StreamAllocation streamAllocation;
-    private final ExecutorService replyExecutor;
+    private final ExecutorService executor;
 
-    private StreamWebSocket(StreamAllocation streamAllocation,
-        Random random, ExecutorService replyExecutor, WebSocketListener listener, String url) {
+    StreamWebSocket(StreamAllocation streamAllocation, Random random, ExecutorService executor,
+        WebSocketListener listener, Response response, String name) {
       super(true /* is client */, streamAllocation.connection().source,
-          streamAllocation.connection().sink, random, replyExecutor, listener, url);
+          streamAllocation.connection().sink, random, executor, listener, response, name);
       this.streamAllocation = streamAllocation;
-      this.replyExecutor = replyExecutor;
+      this.executor = executor;
     }
 
-    @Override protected void close() throws IOException {
-      replyExecutor.shutdown();
-      streamAllocation.noNewStreams();
-      streamAllocation.streamFinished(true, streamAllocation.stream());
+    @Override protected void shutdown() {
+      executor.shutdown();
+      streamAllocation.streamFinished(true, streamAllocation.codec());
     }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/Request.java b/okhttp/src/main/java/okhttp3/Request.java
index 89188ec587..17da07747c 100644
--- a/okhttp/src/main/java/okhttp3/Request.java
+++ b/okhttp/src/main/java/okhttp3/Request.java
@@ -17,6 +17,7 @@
 
 import java.net.URL;
 import java.util.List;
+import okhttp3.internal.Util;
 import okhttp3.internal.http.HttpMethod;
 
 /**
@@ -215,7 +216,7 @@ public Builder delete(RequestBody body) {
     }
 
     public Builder delete() {
-      return delete(RequestBody.create(null, new byte[0]));
+      return delete(Util.EMPTY_REQUEST);
     }
 
     public Builder put(RequestBody body) {
diff --git a/okhttp/src/main/java/okhttp3/Response.java b/okhttp/src/main/java/okhttp3/Response.java
index 7a3d80264b..b11eae6998 100644
--- a/okhttp/src/main/java/okhttp3/Response.java
+++ b/okhttp/src/main/java/okhttp3/Response.java
@@ -15,10 +15,11 @@
  */
 package okhttp3;
 
+import java.io.Closeable;
 import java.io.IOException;
 import java.util.Collections;
 import java.util.List;
-import okhttp3.internal.http.OkHeaders;
+import okhttp3.internal.http.HttpHeaders;
 import okio.Buffer;
 import okio.BufferedSource;
 
@@ -33,9 +34,12 @@
 
 /**
  * An HTTP response. Instances of this class are not immutable: the response body is a one-shot
- * value that may be consumed only once. All other properties are immutable.
+ * value that may be consumed only once and then closed. All other properties are immutable.
+ *
+ * <p>This class implements {@link Closeable}. Closing it simply closes its response body. See
+ * {@link ResponseBody} for an explanation and examples.
  */
-public final class Response {
+public final class Response implements Closeable {
   private final Request request;
   private final Protocol protocol;
   private final int code;
@@ -43,9 +47,11 @@
   private final Handshake handshake;
   private final Headers headers;
   private final ResponseBody body;
-  private Response networkResponse;
-  private Response cacheResponse;
+  private final Response networkResponse;
+  private final Response cacheResponse;
   private final Response priorResponse;
+  private final long sentRequestAtMillis;
+  private final long receivedResponseAtMillis;
 
   private volatile CacheControl cacheControl; // Lazily initialized.
 
@@ -60,18 +66,19 @@ private Response(Builder builder) {
     this.networkResponse = builder.networkResponse;
     this.cacheResponse = builder.cacheResponse;
     this.priorResponse = builder.priorResponse;
+    this.sentRequestAtMillis = builder.sentRequestAtMillis;
+    this.receivedResponseAtMillis = builder.receivedResponseAtMillis;
   }
 
   /**
-   * The wire-level request that initiated this HTTP response. This is not
-   * necessarily the same request issued by the application:
+   * The wire-level request that initiated this HTTP response. This is not necessarily the same
+   * request issued by the application:
    *
    * <ul>
-   *     <li>It may be transformed by the HTTP client. For example, the client
-   *         may copy headers like {@code Content-Length} from the request body.
-   *     <li>It may be the request generated in response to an HTTP redirect or
-   *         authentication challenge. In this case the request URL may be
-   *         different than the initial request URL.
+   *     <li>It may be transformed by the HTTP client. For example, the client may copy headers like
+   *         {@code Content-Length} from the request body.
+   *     <li>It may be the request generated in response to an HTTP redirect or authentication
+   *         challenge. In this case the request URL may be different than the initial request URL.
    * </ul>
    */
   public Request request() {
@@ -226,7 +233,7 @@ public Response priorResponse() {
     } else {
       return Collections.emptyList();
     }
-    return OkHeaders.parseChallenges(headers(), responseField);
+    return HttpHeaders.parseChallenges(headers(), responseField);
   }
 
   /**
@@ -238,6 +245,29 @@ public CacheControl cacheControl() {
     return result != null ? result : (cacheControl = CacheControl.parse(headers));
   }
 
+  /**
+   * Returns a {@linkplain System#currentTimeMillis() timestamp} taken immediately before OkHttp
+   * transmitted the initiating request over the network. If this response is being served from the
+   * cache then this is the timestamp of the original request.
+   */
+  public long sentRequestAtMillis() {
+    return sentRequestAtMillis;
+  }
+
+  /**
+   * Returns a {@linkplain System#currentTimeMillis() timestamp} taken immediately after OkHttp
+   * received this response's headers from the network. If this response is being served from the
+   * cache then this is the timestamp of the original response.
+   */
+  public long receivedResponseAtMillis() {
+    return receivedResponseAtMillis;
+  }
+
+  /** Closes the response body. Equivalent to {@code body().close()}. */
+  @Override public void close() {
+    body.close();
+  }
+
   @Override public String toString() {
     return "Response{protocol="
         + protocol
@@ -261,6 +291,8 @@ public CacheControl cacheControl() {
     private Response networkResponse;
     private Response cacheResponse;
     private Response priorResponse;
+    private long sentRequestAtMillis;
+    private long receivedResponseAtMillis;
 
     public Builder() {
       headers = new Headers.Builder();
@@ -277,6 +309,8 @@ private Builder(Response response) {
       this.networkResponse = response.networkResponse;
       this.cacheResponse = response.cacheResponse;
       this.priorResponse = response.priorResponse;
+      this.sentRequestAtMillis = response.sentRequestAtMillis;
+      this.receivedResponseAtMillis = response.receivedResponseAtMillis;
     }
 
     public Builder request(Request request) {
@@ -374,6 +408,16 @@ private void checkPriorResponse(Response response) {
       }
     }
 
+    public Builder sentRequestAtMillis(long sentRequestAtMillis) {
+      this.sentRequestAtMillis = sentRequestAtMillis;
+      return this;
+    }
+
+    public Builder receivedResponseAtMillis(long receivedResponseAtMillis) {
+      this.receivedResponseAtMillis = receivedResponseAtMillis;
+      return this;
+    }
+
     public Response build() {
       if (request == null) throw new IllegalStateException("request == null");
       if (protocol == null) throw new IllegalStateException("protocol == null");
diff --git a/okhttp/src/main/java/okhttp3/ResponseBody.java b/okhttp/src/main/java/okhttp3/ResponseBody.java
index 98223bbad1..113d607746 100644
--- a/okhttp/src/main/java/okhttp3/ResponseBody.java
+++ b/okhttp/src/main/java/okhttp3/ResponseBody.java
@@ -34,12 +34,57 @@
  *
  * <h3>The response body must be closed.</h3>
  *
- * <p>Each response body is backed by a limited resource like a socket (live network responses) or
- * an open file (for cached responses). Failing to close the response body will leak these resources
- * and may ultimately cause the application to slow down or crash. Close the response body by
- * calling either {@link ResponseBody#close close()}, {@link InputStream#close()
- * byteStream().close()}, or {@link Reader#close() reader().close()}. The {@link #bytes()} and
- * {@link #string()} methods both close the response body automatically.
+ * Each response body is backed by a limited resource like a socket (live network responses) or
+ * an open file (for cached responses). Failing to close the response body will leak resources and
+ * may ultimately cause the application to slow down or crash.
+ *
+ * <p>Both this class and {@link Response} implement {@link Closeable}. Closing a response simply
+ * closes its response body. If you invoke {@link Call#execute()} or implement {@link
+ * Callback#onResponse} you must close this body by calling any of the following methods:
+ *
+ * <ul>
+ *   <li>Response.close()</li>
+ *   <li>Response.body().close()</li>
+ *   <li>Response.body().source().close()</li>
+ *   <li>Response.body().charStream().close()</li>
+ *   <li>Response.body().byteString().close()</li>
+ *   <li>Response.body().bytes()</li>
+ *   <li>Response.body().string()</li>
+ * </ul>
+ *
+ * <p>There is no benefit to invoking multiple {@code close()} methods for the same response body.
+ *
+ * <p>For synchronous calls, the easiest way to make sure a response body is closed is with a {@code
+ * try} block. With this structure the compiler inserts an implicit {@code finally} clause that
+ * calls {@code close()} for you.
+ *
+ * <pre>   {@code
+ *
+ *   Call call = client.newCall(request);
+ *   try (Response response = call.execute()) {
+ *     ... // Use the response.
+ *   }
+ * }</pre>
+ *
+ * You can use a similar block for asynchronous calls: <pre>   {@code
+ *
+ *   Call call = client.newCall(request);
+ *   call.enqueue(new Callback() {
+ *     public void onResponse(Call call, Response response) throws IOException {
+ *       try (ResponseBody responseBody = response.body()) {
+ *         ... // Use the response.
+ *       }
+ *     }
+ *
+ *     public void onFailure(Call call, IOException e) {
+ *       ... // Handle the failure.
+ *     }
+ *   });
+ * }</pre>
+ *
+ * These examples will not work if you're consuming the response body on another thread. In such
+ * cases the consuming thread must call {@link #close} when it has finished reading the response
+ * body.
  *
  * <h3>The response body can be consumed only once.</h3>
  *
@@ -71,6 +116,13 @@ public final InputStream byteStream() {
 
   public abstract BufferedSource source();
 
+  /**
+   * Returns the response as a byte array.
+   *
+   * <p>This method loads entire response body into memory. If the response body is very large this
+   * may trigger an {@link OutOfMemoryError}. Prefer to stream the response body if this is a
+   * possibility for your response.
+   */
   public final byte[] bytes() throws IOException {
     long contentLength = contentLength();
     if (contentLength > Integer.MAX_VALUE) {
@@ -85,7 +137,11 @@ public final InputStream byteStream() {
       Util.closeQuietly(source);
     }
     if (contentLength != -1 && contentLength != bytes.length) {
-      throw new IOException("Content-Length and stream length disagree");
+      throw new IOException("Content-Length ("
+          + contentLength
+          + ") and stream length ("
+          + bytes.length
+          + ") disagree");
     }
     return bytes;
   }
@@ -93,20 +149,32 @@ public final InputStream byteStream() {
   /**
    * Returns the response as a character stream decoded with the charset of the Content-Type header.
    * If that header is either absent or lacks a charset, this will attempt to decode the response
-   * body as UTF-8.
+   * body in accordance to <a href="https://en.wikipedia.org/wiki/Byte_order_mark">its BOM</a> or
+   * UTF-8.
    */
   public final Reader charStream() {
     Reader r = reader;
-    return r != null ? r : (reader = new InputStreamReader(byteStream(), charset()));
+    return r != null ? r : (reader = new BomAwareReader(source(), charset()));
   }
 
   /**
    * Returns the response as a string decoded with the charset of the Content-Type header. If that
-   * header is either absent or lacks a charset, this will attempt to decode the response body as
-   * UTF-8.
+   * header is either absent or lacks a charset, this will attempt to decode the response body in
+   * accordance to <a href="https://en.wikipedia.org/wiki/Byte_order_mark">its BOM</a> or UTF-8.
+   * Closes {@link ResponseBody} automatically.
+   *
+   * <p>This method loads entire response body into memory. If the response body is very large this
+   * may trigger an {@link OutOfMemoryError}. Prefer to stream the response body if this is a
+   * possibility for your response.
    */
   public final String string() throws IOException {
-    return new String(bytes(), charset().name());
+    BufferedSource source = source();
+    try {
+      Charset charset = Util.bomAwareCharset(source, charset());
+      return source.readString(charset);
+    } finally {
+      Util.closeQuietly(source);
+    }
   }
 
   private Charset charset() {
@@ -159,4 +227,37 @@ public static ResponseBody create(
       }
     };
   }
+
+  static final class BomAwareReader extends Reader {
+    private final BufferedSource source;
+    private final Charset charset;
+
+    private boolean closed;
+    private Reader delegate;
+
+    private BomAwareReader(BufferedSource source, Charset charset) {
+      this.source = source;
+      this.charset = charset;
+    }
+
+    @Override public int read(char[] cbuf, int off, int len) throws IOException {
+      if (closed) throw new IOException("Stream closed");
+
+      Reader delegate = this.delegate;
+      if (delegate == null) {
+        Charset charset = Util.bomAwareCharset(source, this.charset);
+        delegate = this.delegate = new InputStreamReader(source.inputStream(), charset);
+      }
+      return delegate.read(cbuf, off, len);
+    }
+
+    @Override public void close() throws IOException {
+      closed = true;
+      if (delegate != null) {
+        delegate.close();
+      } else {
+        source.close();
+      }
+    }
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/TlsVersion.java b/okhttp/src/main/java/okhttp3/TlsVersion.java
index 668cd9732b..391af88e3a 100644
--- a/okhttp/src/main/java/okhttp3/TlsVersion.java
+++ b/okhttp/src/main/java/okhttp3/TlsVersion.java
@@ -20,6 +20,7 @@
  * javax.net.ssl.SSLSocket#setEnabledProtocols}.
  */
 public enum TlsVersion {
+  TLS_1_3("TLSv1.3"), // 2016.
   TLS_1_2("TLSv1.2"), // 2008.
   TLS_1_1("TLSv1.1"), // 2006.
   TLS_1_0("TLSv1"),   // 1999.
@@ -34,6 +35,8 @@
 
   public static TlsVersion forJavaName(String javaName) {
     switch (javaName) {
+      case "TLSv1.3":
+        return TLS_1_3;
       case "TLSv1.2":
         return TLS_1_2;
       case "TLSv1.1":
diff --git a/okhttp-ws/src/main/java/okhttp3/ws/WebSocket.java b/okhttp/src/main/java/okhttp3/WebSocket.java
similarity index 65%
rename from okhttp-ws/src/main/java/okhttp3/ws/WebSocket.java
rename to okhttp/src/main/java/okhttp3/WebSocket.java
index 7435c01d7f..8f80497b3b 100644
--- a/okhttp-ws/src/main/java/okhttp3/ws/WebSocket.java
+++ b/okhttp/src/main/java/okhttp3/WebSocket.java
@@ -13,14 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.ws;
+package okhttp3;
 
 import java.io.IOException;
-import okhttp3.MediaType;
-import okhttp3.RequestBody;
-import okio.Buffer;
+import okio.ByteString;
 
-/** Blocking interface to connect and write to a web socket. */
+/** Blocking interface to connect and write to a web socket. This class is not thread safe. */
 public interface WebSocket {
   /** A {@link MediaType} indicating UTF-8 text frames should be used when sending the message. */
   MediaType TEXT = MediaType.parse("application/vnd.okhttp.websocket+text; charset=utf-8");
@@ -28,28 +26,29 @@
   MediaType BINARY = MediaType.parse("application/vnd.okhttp.websocket+binary");
 
   /**
-   * Send a message payload to the server.
-   *
-   * <p>The {@linkplain RequestBody#contentType() content type} of {@code message} should be either
-   * {@link #TEXT} or {@link #BINARY}.
+   * Send a message to the server.
    *
+   * @param message The message body. The {@linkplain RequestBody#contentType() content type} of
+   * must be either {@link #TEXT} or {@link #BINARY}.
    * @throws IOException if unable to write the message. Clients must call {@link #close} when this
    * happens to ensure resources are cleaned up.
-   * @throws IllegalStateException if not connected, already closed, or another writer is active.
+   * @throws IllegalStateException if this web socket was already closed.
    */
   void sendMessage(RequestBody message) throws IOException;
 
   /**
-   * Send a ping to the server with optional payload.
+   * Send a ping to the server.
    *
+   * @param payload Ping payload which must not exceed 125 bytes. Use {@link ByteString#EMPTY} for
+   * no payload.
    * @throws IOException if unable to write the ping.  Clients must call {@link #close} when this
    * happens to ensure resources are cleaned up.
-   * @throws IllegalStateException if already closed.
+   * @throws IllegalStateException if this web socket was already closed.
    */
-  void sendPing(Buffer payload) throws IOException;
+  void sendPing(ByteString payload) throws IOException;
 
   /**
-   * Send a close frame to the server.
+   * Send a close indicator to the server.
    *
    * <p>The corresponding {@link WebSocketListener} will continue to get messages until its {@link
    * WebSocketListener#onClose onClose()} method is called.
@@ -57,8 +56,11 @@
    * <p>It is an error to call this method before calling close on an active writer. Calling this
    * method more than once has no effect.
    *
+   * @param code Status code as defined by <a
+   * href="http://tools.ietf.org/html/rfc6455#section-7.4">Section 7.4 of RFC 6455</a> or {@code 0}.
+   * @param reason Reason for shutting down or {@code null}.
    * @throws IOException if unable to write the close message. Resources will still be freed.
-   * @throws IllegalStateException if already closed.
+   * @throws IllegalStateException if this web socket was already closed.
    */
   void close(int code, String reason) throws IOException;
 }
diff --git a/okhttp/src/main/java/okhttp3/WebSocketCall.java b/okhttp/src/main/java/okhttp3/WebSocketCall.java
new file mode 100644
index 0000000000..3dc18bcba4
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/WebSocketCall.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+public interface WebSocketCall extends Cloneable {
+  /** Returns the original request that initiated this call. */
+  Request request();
+
+  /**
+   * Schedules the request to be executed at some point in the future.
+   *
+   * <p>The {@link OkHttpClient#dispatcher dispatcher} defines when the request will run: usually
+   * immediately unless there are several other requests currently being executed.
+   *
+   * <p>This client will later call back {@code responseCallback} with either an HTTP response or a
+   * failure exception. If you {@link #cancel} a request before it completes the callback will not
+   * be invoked.
+   *
+   * @throws IllegalStateException when the call has already been executed.
+   */
+  void enqueue(WebSocketListener listener);
+
+  /** Cancels the request, if possible. Requests that are already complete cannot be canceled. */
+  void cancel();
+
+  /**
+   * Returns true if this call has been {@linkplain #enqueue(WebSocketListener) enqueued}. It is an
+   * error to enqueue a call more than once.
+   */
+  boolean isExecuted();
+
+  boolean isCanceled();
+
+  /**
+   * Create a new, identical call to this one which can be enqueued even if this call has already
+   * been.
+   */
+  WebSocketCall clone();
+
+  interface Factory {
+    WebSocketCall newWebSocketCall(Request request);
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/WebSocketListener.java b/okhttp/src/main/java/okhttp3/WebSocketListener.java
new file mode 100644
index 0000000000..b25548b5f9
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/WebSocketListener.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import okio.ByteString;
+
+/**
+ * Listener for server-initiated messages on a connected {@link WebSocket}. All callbacks will be
+ * called on a single thread.
+ *
+ * <h2>Lifecycle Rules</h2>
+ * <ul>
+ * <li>Either {@link #onOpen} or {@link #onFailure} will be called first depending on if the web
+ * socket was successfully opened or if there was an error connecting to the server or parsing its
+ * response.</li>
+ * <li>After {@link #onOpen} is called, {@link #onFailure} can be called at any time. No more
+ * callbacks will follow a call to {@link #onFailure}.</li>
+ * <li>After {@link #onOpen} is called, {@link #onMessage} and {@link #onPong} will be called for
+ * each message and pong frame, respectively. Note: {@link #onPong} may be called while {@link
+ * #onMessage} is reading the message because pong frames may interleave in the message body.</li>
+ * <li>After {@link #onOpen} is called, {@link #onClose} may be called once. No calls to {@link
+ * #onMessage} or {@link #onPong} will follow a call to {@link #onClose}.</li>
+ * <li>{@link #onFailure} will be called if any of the other callbacks throws an exception.</li>
+ * </ul>
+ */
+public interface WebSocketListener {
+  /**
+   * Called when the request has successfully been upgraded to a web socket. <b>Do not</b> use this
+   * callback to write to the web socket. Start a new thread or use another thread in your
+   * application.
+   */
+  void onOpen(WebSocket webSocket, Response response);
+
+  /**
+   * Called when a server message is received. The {@code type} indicates whether the {@code
+   * payload} should be interpreted as UTF-8 text or binary data.
+   *
+   * <p>Implementations <strong>must</strong> call {@code source.close()} before returning. This
+   * indicates completion of parsing the message payload and will consume any remaining bytes in the
+   * message.
+   *
+   * <p>The {@linkplain ResponseBody#contentType() content type} of {@code message} will be either
+   * {@link WebSocket#TEXT} or {@link WebSocket#BINARY} which indicates the format of the message.
+   */
+  void onMessage(ResponseBody message) throws IOException;
+
+  /**
+   * Called when a server pong is received. This is usually a result of calling {@link
+   * WebSocket#sendPing(ByteString)} but might also be unsolicited directly from the server.
+   */
+  void onPong(ByteString payload);
+
+  /**
+   * Called when the server sends a close message. This may have been initiated from a call to
+   * {@link WebSocket#close(int, String) close()} or as an unprompted message from the server.
+   * If you did not explicitly call {@link WebSocket#close(int, String) close()}, you do not need
+   * to do so in response to this callback. A matching close frame is automatically sent back to
+   * the server.
+   *
+   * @param code The <a href="http://tools.ietf.org/html/rfc6455#section-7.4.1">RFC-compliant</a>
+   * status code.
+   * @param reason Reason for close or an empty string.
+   */
+  void onClose(int code, String reason);
+
+  /**
+   * Called when the transport or protocol layer of this web socket errors during communication, or
+   * when another listener callback throws an exception. If the web socket was successfully
+   * {@linkplain #onOpen opened} before this callback, it will have been closed automatically and
+   * future interactions with it will throw {@link IOException}.
+   *
+   * @param response Non-null when the failure is because of an unexpected HTTP response (e.g.,
+   * failed upgrade, non-101 response code, etc.).
+   */
+  void onFailure(Throwable t, Response response);
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/Internal.java b/okhttp/src/main/java/okhttp3/internal/Internal.java
index 54252084fb..6a25d3cdf8 100644
--- a/okhttp/src/main/java/okhttp3/internal/Internal.java
+++ b/okhttp/src/main/java/okhttp3/internal/Internal.java
@@ -17,25 +17,23 @@
 
 import java.net.MalformedURLException;
 import java.net.UnknownHostException;
-import java.util.logging.Logger;
 import javax.net.ssl.SSLSocket;
 import okhttp3.Address;
-import okhttp3.Call;
-import okhttp3.Callback;
 import okhttp3.ConnectionPool;
 import okhttp3.ConnectionSpec;
 import okhttp3.Headers;
 import okhttp3.HttpUrl;
 import okhttp3.OkHttpClient;
-import okhttp3.internal.http.StreamAllocation;
-import okhttp3.internal.io.RealConnection;
+import okhttp3.internal.cache.InternalCache;
+import okhttp3.internal.connection.RealConnection;
+import okhttp3.internal.connection.RouteDatabase;
+import okhttp3.internal.connection.StreamAllocation;
 
 /**
  * Escalate internal APIs in {@code okhttp3} so they can be used from OkHttp's implementation
  * packages. The only implementation of this interface is in {@link OkHttpClient}.
  */
 public abstract class Internal {
-  public static final Logger logger = Logger.getLogger(OkHttpClient.class.getName());
 
   public static void initializeInstanceForTests() {
     // Needed in tests to ensure that the instance is actually pointing to something.
@@ -50,8 +48,6 @@ public static void initializeInstanceForTests() {
 
   public abstract void setCache(OkHttpClient.Builder builder, InternalCache internalCache);
 
-  public abstract InternalCache internalCache(OkHttpClient client);
-
   public abstract RealConnection get(
       ConnectionPool pool, Address address, StreamAllocation streamAllocation);
 
@@ -66,9 +62,4 @@ public abstract void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket,
 
   public abstract HttpUrl getHttpUrlChecked(String url)
       throws MalformedURLException, UnknownHostException;
-
-  // TODO delete the following when web sockets move into the main package.
-  public abstract void callEnqueue(Call call, Callback responseCallback, boolean forWebSocket);
-
-  public abstract StreamAllocation callEngineGetStreamAllocation(Call call);
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/NamedRunnable.java b/okhttp/src/main/java/okhttp3/internal/NamedRunnable.java
index b5a4103604..ff9729e2af 100644
--- a/okhttp/src/main/java/okhttp3/internal/NamedRunnable.java
+++ b/okhttp/src/main/java/okhttp3/internal/NamedRunnable.java
@@ -22,7 +22,7 @@
   protected final String name;
 
   public NamedRunnable(String format, Object... args) {
-    this.name = String.format(format, args);
+    this.name = Util.format(format, args);
   }
 
   @Override public final void run() {
diff --git a/okhttp/src/main/java/okhttp3/internal/Platform.java b/okhttp/src/main/java/okhttp3/internal/Platform.java
deleted file mode 100644
index 2125c991d4..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/Platform.java
+++ /dev/null
@@ -1,422 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal;
-
-import android.util.Log;
-import java.io.IOException;
-import java.lang.reflect.Field;
-import java.lang.reflect.InvocationHandler;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.lang.reflect.Proxy;
-import java.net.InetSocketAddress;
-import java.net.Socket;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.logging.Level;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.Protocol;
-import okio.Buffer;
-
-import static okhttp3.internal.Internal.logger;
-
-/**
- * Access to platform-specific features.
- *
- * <h3>Server name indication (SNI)</h3>
- *
- * <p>Supported on Android 2.3+.
- *
- * <h3>Session Tickets</h3>
- *
- * <p>Supported on Android 2.3+.
- *
- * <h3>Android Traffic Stats (Socket Tagging)</h3>
- *
- * <p>Supported on Android 4.0+.
- *
- * <h3>ALPN (Application Layer Protocol Negotiation)</h3>
- *
- * <p>Supported on Android 5.0+. The APIs were present in Android 4.4, but that implementation was
- * unstable.
- *
- * Supported on OpenJDK 7 and 8 (via the JettyALPN-boot library).
- *
- * <h3>Trust Manager Extraction</h3>
- *
- * <p>Supported on Android 2.3+ and OpenJDK 7+. There are no public APIs to recover the trust
- * manager that was used to create an {@link SSLSocketFactory}.
- */
-public class Platform {
-  private static final Platform PLATFORM = findPlatform();
-
-  public static Platform get() {
-    return PLATFORM;
-  }
-
-  /** Prefix used on custom headers. */
-  public String getPrefix() {
-    return "OkHttp";
-  }
-
-  public void logW(String warning) {
-    System.out.println(warning);
-  }
-
-  public X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
-    // Attempt to get the trust manager from an OpenJDK socket factory. We attempt this on all
-    // platforms in order to support Robolectric, which mixes classes from both Android and the
-    // Oracle JDK. Note that we don't support HTTP/2 or other nice features on Robolectric.
-    try {
-      Class<?> sslContextClass = Class.forName("sun.security.ssl.SSLContextImpl");
-      Object context = readFieldOrNull(sslSocketFactory, sslContextClass, "context");
-      if (context == null) return null;
-      return readFieldOrNull(context, X509TrustManager.class, "trustManager");
-    } catch (ClassNotFoundException e) {
-      return null;
-    }
-  }
-
-  /**
-   * Configure TLS extensions on {@code sslSocket} for {@code route}.
-   *
-   * @param hostname non-null for client-side handshakes; null for server-side handshakes.
-   */
-  public void configureTlsExtensions(SSLSocket sslSocket, String hostname,
-      List<Protocol> protocols) {
-  }
-
-  /**
-   * Called after the TLS handshake to release resources allocated by {@link
-   * #configureTlsExtensions}.
-   */
-  public void afterHandshake(SSLSocket sslSocket) {
-  }
-
-  /** Returns the negotiated protocol, or null if no protocol was negotiated. */
-  public String getSelectedProtocol(SSLSocket socket) {
-    return null;
-  }
-
-  public void connectSocket(Socket socket, InetSocketAddress address,
-      int connectTimeout) throws IOException {
-    socket.connect(address, connectTimeout);
-  }
-
-  public void log(String message) {
-    System.out.println(message);
-  }
-
-  /** Attempt to match the host runtime to a capable Platform implementation. */
-  private static Platform findPlatform() {
-    // Attempt to find Android 2.3+ APIs.
-    try {
-      Class<?> sslParametersClass;
-      try {
-        sslParametersClass = Class.forName("com.android.org.conscrypt.SSLParametersImpl");
-      } catch (ClassNotFoundException e) {
-        // Older platform before being unbundled.
-        sslParametersClass = Class.forName(
-            "org.apache.harmony.xnet.provider.jsse.SSLParametersImpl");
-      }
-
-      OptionalMethod<Socket> setUseSessionTickets = new OptionalMethod<>(
-          null, "setUseSessionTickets", boolean.class);
-      OptionalMethod<Socket> setHostname = new OptionalMethod<>(
-          null, "setHostname", String.class);
-      OptionalMethod<Socket> getAlpnSelectedProtocol = null;
-      OptionalMethod<Socket> setAlpnProtocols = null;
-
-      // Attempt to find Android 5.0+ APIs.
-      try {
-        Class.forName("android.net.Network"); // Arbitrary class added in Android 5.0.
-        getAlpnSelectedProtocol = new OptionalMethod<>(byte[].class, "getAlpnSelectedProtocol");
-        setAlpnProtocols = new OptionalMethod<>(null, "setAlpnProtocols", byte[].class);
-      } catch (ClassNotFoundException ignored) {
-      }
-
-      return new Android(sslParametersClass, setUseSessionTickets, setHostname,
-          getAlpnSelectedProtocol, setAlpnProtocols);
-    } catch (ClassNotFoundException ignored) {
-      // This isn't an Android runtime.
-    }
-
-    // Find Jetty's ALPN extension for OpenJDK.
-    try {
-      String negoClassName = "org.eclipse.jetty.alpn.ALPN";
-      Class<?> negoClass = Class.forName(negoClassName);
-      Class<?> providerClass = Class.forName(negoClassName + "$Provider");
-      Class<?> clientProviderClass = Class.forName(negoClassName + "$ClientProvider");
-      Class<?> serverProviderClass = Class.forName(negoClassName + "$ServerProvider");
-      Method putMethod = negoClass.getMethod("put", SSLSocket.class, providerClass);
-      Method getMethod = negoClass.getMethod("get", SSLSocket.class);
-      Method removeMethod = negoClass.getMethod("remove", SSLSocket.class);
-      return new JdkWithJettyBootPlatform(
-          putMethod, getMethod, removeMethod, clientProviderClass, serverProviderClass);
-    } catch (ClassNotFoundException | NoSuchMethodException ignored) {
-    }
-
-    // Probably an Oracle JDK like OpenJDK.
-    return new Platform();
-  }
-
-  /** Android 2.3 or better. */
-  private static class Android extends Platform {
-    private static final int MAX_LOG_LENGTH = 4000;
-
-    private final Class<?> sslParametersClass;
-    private final OptionalMethod<Socket> setUseSessionTickets;
-    private final OptionalMethod<Socket> setHostname;
-
-    // Non-null on Android 5.0+.
-    private final OptionalMethod<Socket> getAlpnSelectedProtocol;
-    private final OptionalMethod<Socket> setAlpnProtocols;
-
-    public Android(Class<?> sslParametersClass, OptionalMethod<Socket> setUseSessionTickets,
-        OptionalMethod<Socket> setHostname, OptionalMethod<Socket> getAlpnSelectedProtocol,
-        OptionalMethod<Socket> setAlpnProtocols) {
-      this.sslParametersClass = sslParametersClass;
-      this.setUseSessionTickets = setUseSessionTickets;
-      this.setHostname = setHostname;
-      this.getAlpnSelectedProtocol = getAlpnSelectedProtocol;
-      this.setAlpnProtocols = setAlpnProtocols;
-    }
-
-    @Override public void connectSocket(Socket socket, InetSocketAddress address,
-        int connectTimeout) throws IOException {
-      try {
-        socket.connect(address, connectTimeout);
-      } catch (AssertionError e) {
-        if (Util.isAndroidGetsocknameError(e)) throw new IOException(e);
-        throw e;
-      } catch (SecurityException e) {
-        // Before android 4.3, socket.connect could throw a SecurityException
-        // if opening a socket resulted in an EACCES error.
-        IOException ioException = new IOException("Exception in connect");
-        ioException.initCause(e);
-        throw ioException;
-      }
-    }
-
-    @Override public X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
-      Object context = readFieldOrNull(sslSocketFactory, sslParametersClass, "sslParameters");
-      if (context == null) {
-        // If that didn't work, try the Google Play Services SSL provider before giving up. This
-        // must be loaded by the SSLSocketFactory's class loader.
-        try {
-          Class<?> gmsSslParametersClass = Class.forName(
-              "com.google.android.gms.org.conscrypt.SSLParametersImpl", false,
-              sslSocketFactory.getClass().getClassLoader());
-          context = readFieldOrNull(sslSocketFactory, gmsSslParametersClass, "sslParameters");
-        } catch (ClassNotFoundException e) {
-          return super.trustManager(sslSocketFactory);
-        }
-      }
-
-      X509TrustManager x509TrustManager = readFieldOrNull(
-          context, X509TrustManager.class, "x509TrustManager");
-      if (x509TrustManager != null) return x509TrustManager;
-
-      return readFieldOrNull(context, X509TrustManager.class, "trustManager");
-    }
-
-    @Override public void configureTlsExtensions(
-        SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
-      // Enable SNI and session tickets.
-      if (hostname != null) {
-        setUseSessionTickets.invokeOptionalWithoutCheckedException(sslSocket, true);
-        setHostname.invokeOptionalWithoutCheckedException(sslSocket, hostname);
-      }
-
-      // Enable ALPN.
-      if (setAlpnProtocols != null && setAlpnProtocols.isSupported(sslSocket)) {
-        Object[] parameters = {concatLengthPrefixed(protocols)};
-        setAlpnProtocols.invokeWithoutCheckedException(sslSocket, parameters);
-      }
-    }
-
-    @Override public String getSelectedProtocol(SSLSocket socket) {
-      if (getAlpnSelectedProtocol == null) return null;
-      if (!getAlpnSelectedProtocol.isSupported(socket)) return null;
-
-      byte[] alpnResult = (byte[]) getAlpnSelectedProtocol.invokeWithoutCheckedException(socket);
-      return alpnResult != null ? new String(alpnResult, Util.UTF_8) : null;
-    }
-
-    @Override public void log(String message) {
-      // Split by line, then ensure each line can fit into Log's maximum length.
-      for (int i = 0, length = message.length(); i < length; i++) {
-        int newline = message.indexOf('\n', i);
-        newline = newline != -1 ? newline : length;
-        do {
-          int end = Math.min(newline, i + MAX_LOG_LENGTH);
-          Log.d("OkHttp", message.substring(i, end));
-          i = end;
-        } while (i < newline);
-      }
-    }
-  }
-
-  /**
-   * OpenJDK 7+ with {@code org.mortbay.jetty.alpn/alpn-boot} in the boot class path.
-   */
-  private static class JdkWithJettyBootPlatform extends Platform {
-    private final Method putMethod;
-    private final Method getMethod;
-    private final Method removeMethod;
-    private final Class<?> clientProviderClass;
-    private final Class<?> serverProviderClass;
-
-    public JdkWithJettyBootPlatform(Method putMethod, Method getMethod, Method removeMethod,
-        Class<?> clientProviderClass, Class<?> serverProviderClass) {
-      this.putMethod = putMethod;
-      this.getMethod = getMethod;
-      this.removeMethod = removeMethod;
-      this.clientProviderClass = clientProviderClass;
-      this.serverProviderClass = serverProviderClass;
-    }
-
-    @Override public void configureTlsExtensions(
-        SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
-      List<String> names = new ArrayList<>(protocols.size());
-      for (int i = 0, size = protocols.size(); i < size; i++) {
-        Protocol protocol = protocols.get(i);
-        if (protocol == Protocol.HTTP_1_0) continue; // No HTTP/1.0 for ALPN.
-        names.add(protocol.toString());
-      }
-      try {
-        Object provider = Proxy.newProxyInstance(Platform.class.getClassLoader(),
-            new Class[] {clientProviderClass, serverProviderClass}, new JettyNegoProvider(names));
-        putMethod.invoke(null, sslSocket, provider);
-      } catch (InvocationTargetException | IllegalAccessException e) {
-        throw new AssertionError(e);
-      }
-    }
-
-    @Override public void afterHandshake(SSLSocket sslSocket) {
-      try {
-        removeMethod.invoke(null, sslSocket);
-      } catch (IllegalAccessException | InvocationTargetException ignored) {
-        throw new AssertionError();
-      }
-    }
-
-    @Override public String getSelectedProtocol(SSLSocket socket) {
-      try {
-        JettyNegoProvider provider =
-            (JettyNegoProvider) Proxy.getInvocationHandler(getMethod.invoke(null, socket));
-        if (!provider.unsupported && provider.selected == null) {
-          logger.log(Level.INFO, "ALPN callback dropped: SPDY and HTTP/2 are disabled. "
-              + "Is alpn-boot on the boot class path?");
-          return null;
-        }
-        return provider.unsupported ? null : provider.selected;
-      } catch (InvocationTargetException | IllegalAccessException e) {
-        throw new AssertionError();
-      }
-    }
-  }
-
-  /**
-   * Handle the methods of ALPN's ClientProvider and ServerProvider without a compile-time
-   * dependency on those interfaces.
-   */
-  private static class JettyNegoProvider implements InvocationHandler {
-    /** This peer's supported protocols. */
-    private final List<String> protocols;
-    /** Set when remote peer notifies ALPN is unsupported. */
-    private boolean unsupported;
-    /** The protocol the server selected. */
-    private String selected;
-
-    public JettyNegoProvider(List<String> protocols) {
-      this.protocols = protocols;
-    }
-
-    @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
-      String methodName = method.getName();
-      Class<?> returnType = method.getReturnType();
-      if (args == null) {
-        args = Util.EMPTY_STRING_ARRAY;
-      }
-      if (methodName.equals("supports") && boolean.class == returnType) {
-        return true; // ALPN is supported.
-      } else if (methodName.equals("unsupported") && void.class == returnType) {
-        this.unsupported = true; // Peer doesn't support ALPN.
-        return null;
-      } else if (methodName.equals("protocols") && args.length == 0) {
-        return protocols; // Client advertises these protocols.
-      } else if ((methodName.equals("selectProtocol") || methodName.equals("select"))
-          && String.class == returnType && args.length == 1 && args[0] instanceof List) {
-        List<String> peerProtocols = (List) args[0];
-        // Pick the first known protocol the peer advertises.
-        for (int i = 0, size = peerProtocols.size(); i < size; i++) {
-          if (protocols.contains(peerProtocols.get(i))) {
-            return selected = peerProtocols.get(i);
-          }
-        }
-        return selected = protocols.get(0); // On no intersection, try peer's first protocol.
-      } else if ((methodName.equals("protocolSelected") || methodName.equals("selected"))
-          && args.length == 1) {
-        this.selected = (String) args[0]; // Server selected this protocol.
-        return null;
-      } else {
-        return method.invoke(this, args);
-      }
-    }
-  }
-
-  /**
-   * Returns the concatenation of 8-bit, length prefixed protocol names.
-   * http://tools.ietf.org/html/draft-agl-tls-nextprotoneg-04#page-4
-   */
-  static byte[] concatLengthPrefixed(List<Protocol> protocols) {
-    Buffer result = new Buffer();
-    for (int i = 0, size = protocols.size(); i < size; i++) {
-      Protocol protocol = protocols.get(i);
-      if (protocol == Protocol.HTTP_1_0) continue; // No HTTP/1.0 for ALPN.
-      result.writeByte(protocol.toString().length());
-      result.writeUtf8(protocol.toString());
-    }
-    return result.readByteArray();
-  }
-
-  static <T> T readFieldOrNull(Object instance, Class<T> fieldType, String fieldName) {
-    for (Class<?> c = instance.getClass(); c != Object.class; c = c.getSuperclass()) {
-      try {
-        Field field = c.getDeclaredField(fieldName);
-        field.setAccessible(true);
-        Object value = field.get(instance);
-        if (value == null || !fieldType.isInstance(value)) return null;
-        return fieldType.cast(value);
-      } catch (NoSuchFieldException ignored) {
-      } catch (IllegalAccessException e) {
-        throw new AssertionError();
-      }
-    }
-
-    // Didn't find the field we wanted. As a last gasp attempt, try to find the value on a delegate.
-    if (!fieldName.equals("delegate")) {
-      Object delegate = readFieldOrNull(instance, Object.class, "delegate");
-      if (delegate != null) return readFieldOrNull(delegate, fieldType, fieldName);
-    }
-
-    return null;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/Util.java b/okhttp/src/main/java/okhttp3/internal/Util.java
index 4dc139f4fb..d31b55ae10 100644
--- a/okhttp/src/main/java/okhttp3/internal/Util.java
+++ b/okhttp/src/main/java/okhttp3/internal/Util.java
@@ -29,16 +29,17 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
-import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Locale;
-import java.util.Map;
 import java.util.TimeZone;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.TimeUnit;
 import java.util.regex.Pattern;
 import okhttp3.HttpUrl;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
 import okio.Buffer;
+import okio.BufferedSource;
 import okio.ByteString;
 import okio.Source;
 
@@ -47,8 +48,20 @@
   public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
   public static final String[] EMPTY_STRING_ARRAY = new String[0];
 
-  /** A cheap and type-safe constant for the UTF-8 Charset. */
+  public static final ResponseBody EMPTY_RESPONSE = ResponseBody.create(null, EMPTY_BYTE_ARRAY);
+  public static final RequestBody EMPTY_REQUEST = RequestBody.create(null, EMPTY_BYTE_ARRAY);
+
+  private static final ByteString UTF_8_BOM = ByteString.decodeHex("efbbff");
+  private static final ByteString UTF_16_BE_BOM = ByteString.decodeHex("feff");
+  private static final ByteString UTF_16_LE_BOM = ByteString.decodeHex("fffe");
+  private static final ByteString UTF_32_BE_BOM = ByteString.decodeHex("0000ffff");
+  private static final ByteString UTF_32_LE_BOM = ByteString.decodeHex("ffff0000");
+
   public static final Charset UTF_8 = Charset.forName("UTF-8");
+  private static final Charset UTF_16_BE = Charset.forName("UTF-16BE");
+  private static final Charset UTF_16_LE = Charset.forName("UTF-16LE");
+  private static final Charset UTF_32_BE = Charset.forName("UTF-32BE");
+  private static final Charset UTF_32_LE = Charset.forName("UTF-32LE");
 
   /** GMT and UTC are equivalent for our purposes. */
   public static final TimeZone UTC = TimeZone.getTimeZone("GMT");
@@ -127,29 +140,6 @@ public static void closeQuietly(ServerSocket serverSocket) {
     }
   }
 
-  /**
-   * Closes {@code a} and {@code b}. If either close fails, this completes the other close and
-   * rethrows the first encountered exception.
-   */
-  public static void closeAll(Closeable a, Closeable b) throws IOException {
-    Throwable thrown = null;
-    try {
-      a.close();
-    } catch (Throwable e) {
-      thrown = e;
-    }
-    try {
-      b.close();
-    } catch (Throwable e) {
-      if (thrown == null) thrown = e;
-    }
-    if (thrown == null) return;
-    if (thrown instanceof IOException) throw (IOException) thrown;
-    if (thrown instanceof RuntimeException) throw (RuntimeException) thrown;
-    if (thrown instanceof Error) throw (Error) thrown;
-    throw new AssertionError(thrown);
-  }
-
   /**
    * Attempts to exhaust {@code source}, returning true if successful. This is useful when reading a
    * complete source is helpful, such as when doing so completes a cache body or frees a socket
@@ -175,7 +165,7 @@ public static boolean skipAll(Source source, int duration, TimeUnit timeUnit) th
     source.timeout().deadlineNanoTime(now + Math.min(originalDuration, timeUnit.toNanos(duration)));
     try {
       Buffer skipBuffer = new Buffer();
-      while (source.read(skipBuffer, 2048) != -1) {
+      while (source.read(skipBuffer, 8192) != -1) {
         skipBuffer.clear();
       }
       return true; // Success! The source has been exhausted.
@@ -244,11 +234,6 @@ public static ByteString sha256(ByteString s) {
     return Collections.unmodifiableList(Arrays.asList(elements.clone()));
   }
 
-  /** Returns an immutable copy of {@code map}. */
-  public static <K, V> Map<K, V> immutableMap(Map<K, V> map) {
-    return Collections.unmodifiableMap(new LinkedHashMap<>(map));
-  }
-
   public static ThreadFactory threadFactory(final String name, final boolean daemon) {
     return new ThreadFactory() {
       @Override public Thread newThread(Runnable runnable) {
@@ -321,8 +306,11 @@ public static boolean isAndroidGetsocknameError(AssertionError e) {
         && e.getMessage().contains("getsockname failed");
   }
 
-  public static boolean contains(String[] array, String value) {
-    return Arrays.asList(array).contains(value);
+  public static <T> int indexOf(T[] array, T value) {
+    for (int i = 0, size = array.length; i < size; i++) {
+      if (equal(array[i], value)) return i;
+    }
+    return -1;
   }
 
   public static String[] concat(String[] array, String value) {
@@ -446,4 +434,40 @@ private static boolean containsInvalidHostnameAsciiCodes(String hostnameAscii) {
   public static boolean verifyAsIpAddress(String host) {
     return VERIFY_AS_IP_ADDRESS.matcher(host).matches();
   }
+
+  /** Returns a {@link Locale#US} formatted {@link String}. */
+  public static String format(String format, Object... args) {
+    return String.format(Locale.US, format, args);
+  }
+
+  public static Charset bomAwareCharset(BufferedSource source, Charset charset) throws IOException {
+    if (source.rangeEquals(0, UTF_8_BOM)) {
+      source.skip(UTF_8_BOM.size());
+      return UTF_8;
+    }
+    if (source.rangeEquals(0, UTF_16_BE_BOM)) {
+      source.skip(UTF_16_BE_BOM.size());
+      return UTF_16_BE;
+    }
+    if (source.rangeEquals(0, UTF_16_LE_BOM)) {
+      source.skip(UTF_16_LE_BOM.size());
+      return UTF_16_LE;
+    }
+    if (source.rangeEquals(0, UTF_32_BE_BOM)) {
+      source.skip(UTF_32_BE_BOM.size());
+      return UTF_32_BE;
+    }
+    if (source.rangeEquals(0, UTF_32_LE_BOM)) {
+      source.skip(UTF_32_LE_BOM.size());
+      return UTF_32_LE;
+    }
+    return charset;
+  }
+
+  /** Re-throws {@code t} if it is a fatal exception which should not be handled. */
+  public static void throwIfFatal(Throwable t) {
+    if (t instanceof VirtualMachineError) throw (VirtualMachineError) t;
+    if (t instanceof ThreadDeath) throw (ThreadDeath) t;
+    if (t instanceof LinkageError) throw (LinkageError) t;
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
new file mode 100644
index 0000000000..e876a631c4
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
@@ -0,0 +1,287 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3.internal.cache;
+
+import java.io.IOException;
+import java.util.Date;
+import okhttp3.Headers;
+import okhttp3.Interceptor;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.Internal;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.HttpCodec;
+import okhttp3.internal.http.HttpHeaders;
+import okhttp3.internal.http.HttpMethod;
+import okhttp3.internal.http.RealResponseBody;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.Okio;
+import okio.Sink;
+import okio.Source;
+import okio.Timeout;
+
+import static java.net.HttpURLConnection.HTTP_NOT_MODIFIED;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static okhttp3.internal.Util.closeQuietly;
+import static okhttp3.internal.Util.discard;
+
+/** Serves requests from the cache and writes responses to the cache. */
+public final class CacheInterceptor implements Interceptor {
+  final InternalCache cache;
+
+  public CacheInterceptor(InternalCache cache) {
+    this.cache = cache;
+  }
+
+  @Override public Response intercept(Chain chain) throws IOException {
+    Response cacheCandidate = cache != null
+        ? cache.get(chain.request())
+        : null;
+
+    long now = System.currentTimeMillis();
+
+    CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();
+    Request networkRequest = strategy.networkRequest;
+    Response cacheResponse = strategy.cacheResponse;
+
+    if (cache != null) {
+      cache.trackResponse(strategy);
+    }
+
+    if (cacheCandidate != null && cacheResponse == null) {
+      closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.
+    }
+
+    // If we're forbidden from using the network and the cache is insufficient, fail.
+    if (networkRequest == null && cacheResponse == null) {
+      return new Response.Builder()
+          .request(chain.request())
+          .protocol(Protocol.HTTP_1_1)
+          .code(504)
+          .message("Unsatisfiable Request (only-if-cached)")
+          .body(Util.EMPTY_RESPONSE)
+          .sentRequestAtMillis(-1L)
+          .receivedResponseAtMillis(System.currentTimeMillis())
+          .build();
+    }
+
+    // If we don't need the network, we're done.
+    if (networkRequest == null) {
+      return cacheResponse.newBuilder()
+          .cacheResponse(stripBody(cacheResponse))
+          .build();
+    }
+
+    Response networkResponse = null;
+    try {
+      networkResponse = chain.proceed(networkRequest);
+    } finally {
+      // If we're crashing on I/O or otherwise, don't leak the cache body.
+      if (networkResponse == null && cacheCandidate != null) {
+        closeQuietly(cacheCandidate.body());
+      }
+    }
+
+    // If we have a cache response too, then we're doing a conditional get.
+    if (cacheResponse != null) {
+      if (validate(cacheResponse, networkResponse)) {
+        Response response = cacheResponse.newBuilder()
+            .headers(combine(cacheResponse.headers(), networkResponse.headers()))
+            .cacheResponse(stripBody(cacheResponse))
+            .networkResponse(stripBody(networkResponse))
+            .build();
+        networkResponse.body().close();
+
+        // Update the cache after combining headers but before stripping the
+        // Content-Encoding header (as performed by initContentStream()).
+        cache.trackConditionalCacheHit();
+        cache.update(cacheResponse, response);
+        return response;
+      } else {
+        closeQuietly(cacheResponse.body());
+      }
+    }
+
+    Response response = networkResponse.newBuilder()
+        .cacheResponse(stripBody(cacheResponse))
+        .networkResponse(stripBody(networkResponse))
+        .build();
+
+    if (HttpHeaders.hasBody(response)) {
+      CacheRequest cacheRequest = maybeCache(response, networkResponse.request(), cache);
+      response = cacheWritingResponse(cacheRequest, response);
+    }
+
+    return response;
+  }
+
+  private static Response stripBody(Response response) {
+    return response != null && response.body() != null
+        ? response.newBuilder().body(null).build()
+        : response;
+  }
+
+  private CacheRequest maybeCache(Response userResponse, Request networkRequest,
+      InternalCache responseCache) throws IOException {
+    if (responseCache == null) return null;
+
+    // Should we cache this response for this request?
+    if (!CacheStrategy.isCacheable(userResponse, networkRequest)) {
+      if (HttpMethod.invalidatesCache(networkRequest.method())) {
+        try {
+          responseCache.remove(networkRequest);
+        } catch (IOException ignored) {
+          // The cache cannot be written.
+        }
+      }
+      return null;
+    }
+
+    // Offer this request to the cache.
+    return responseCache.put(userResponse);
+  }
+
+  /**
+   * Returns a new source that writes bytes to {@code cacheRequest} as they are read by the source
+   * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we
+   * may never exhaust the source stream and therefore not complete the cached response.
+   */
+  private Response cacheWritingResponse(final CacheRequest cacheRequest, Response response)
+      throws IOException {
+    // Some apps return a null body; for compatibility we treat that like a null cache request.
+    if (cacheRequest == null) return response;
+    Sink cacheBodyUnbuffered = cacheRequest.body();
+    if (cacheBodyUnbuffered == null) return response;
+
+    final BufferedSource source = response.body().source();
+    final BufferedSink cacheBody = Okio.buffer(cacheBodyUnbuffered);
+
+    Source cacheWritingSource = new Source() {
+      boolean cacheRequestClosed;
+
+      @Override public long read(Buffer sink, long byteCount) throws IOException {
+        long bytesRead;
+        try {
+          bytesRead = source.read(sink, byteCount);
+        } catch (IOException e) {
+          if (!cacheRequestClosed) {
+            cacheRequestClosed = true;
+            cacheRequest.abort(); // Failed to write a complete cache response.
+          }
+          throw e;
+        }
+
+        if (bytesRead == -1) {
+          if (!cacheRequestClosed) {
+            cacheRequestClosed = true;
+            cacheBody.close(); // The cache response is complete!
+          }
+          return -1;
+        }
+
+        sink.copyTo(cacheBody.buffer(), sink.size() - bytesRead, bytesRead);
+        cacheBody.emitCompleteSegments();
+        return bytesRead;
+      }
+
+      @Override public Timeout timeout() {
+        return source.timeout();
+      }
+
+      @Override public void close() throws IOException {
+        if (!cacheRequestClosed
+            && !discard(this, HttpCodec.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
+          cacheRequestClosed = true;
+          cacheRequest.abort();
+        }
+        source.close();
+      }
+    };
+
+    return response.newBuilder()
+        .body(new RealResponseBody(response.headers(), Okio.buffer(cacheWritingSource)))
+        .build();
+  }
+
+  /**
+   * Returns true if {@code cached} should be used; false if {@code network} response should be
+   * used.
+   */
+  private static boolean validate(Response cached, Response network) {
+    if (network.code() == HTTP_NOT_MODIFIED) return true;
+
+    // The HTTP spec says that if the network's response is older than our
+    // cached response, we may return the cache's response. Like Chrome (but
+    // unlike Firefox), this client prefers to return the newer response.
+    Date lastModified = cached.headers().getDate("Last-Modified");
+    if (lastModified != null) {
+      Date networkLastModified = network.headers().getDate("Last-Modified");
+      if (networkLastModified != null
+          && networkLastModified.getTime() < lastModified.getTime()) {
+        return true;
+      }
+    }
+
+    return false;
+  }
+
+  /** Combines cached headers with a network headers as defined by RFC 2616, 13.5.3. */
+  private static Headers combine(Headers cachedHeaders, Headers networkHeaders) {
+    Headers.Builder result = new Headers.Builder();
+
+    for (int i = 0, size = cachedHeaders.size(); i < size; i++) {
+      String fieldName = cachedHeaders.name(i);
+      String value = cachedHeaders.value(i);
+      if ("Warning".equalsIgnoreCase(fieldName) && value.startsWith("1")) {
+        continue; // Drop 100-level freshness warnings.
+      }
+      if (!isEndToEnd(fieldName) || networkHeaders.get(fieldName) == null) {
+        Internal.instance.addLenient(result, fieldName, value);
+      }
+    }
+
+    for (int i = 0, size = networkHeaders.size(); i < size; i++) {
+      String fieldName = networkHeaders.name(i);
+      if ("Content-Length".equalsIgnoreCase(fieldName)) {
+        continue; // Ignore content-length headers of validating responses.
+      }
+      if (isEndToEnd(fieldName)) {
+        Internal.instance.addLenient(result, fieldName, networkHeaders.value(i));
+      }
+    }
+
+    return result.build();
+  }
+
+  /**
+   * Returns true if {@code fieldName} is an end-to-end HTTP header, as defined by RFC 2616,
+   * 13.5.1.
+   */
+  static boolean isEndToEnd(String fieldName) {
+    return !"Connection".equalsIgnoreCase(fieldName)
+        && !"Keep-Alive".equalsIgnoreCase(fieldName)
+        && !"Proxy-Authenticate".equalsIgnoreCase(fieldName)
+        && !"Proxy-Authorization".equalsIgnoreCase(fieldName)
+        && !"TE".equalsIgnoreCase(fieldName)
+        && !"Trailers".equalsIgnoreCase(fieldName)
+        && !"Transfer-Encoding".equalsIgnoreCase(fieldName)
+        && !"Upgrade".equalsIgnoreCase(fieldName);
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/CacheRequest.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheRequest.java
similarity index 95%
rename from okhttp/src/main/java/okhttp3/internal/http/CacheRequest.java
rename to okhttp/src/main/java/okhttp3/internal/cache/CacheRequest.java
index 12c3134e8a..b4432b4e1d 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/CacheRequest.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheRequest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.http;
+package okhttp3.internal.cache;
 
 import java.io.IOException;
 import okio.Sink;
diff --git a/okhttp/src/main/java/okhttp3/internal/http/CacheStrategy.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
similarity index 89%
rename from okhttp/src/main/java/okhttp3/internal/http/CacheStrategy.java
rename to okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
index 940bd68b7c..93eacedef4 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/CacheStrategy.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
@@ -13,13 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.http;
+package okhttp3.internal.cache;
 
 import java.util.Date;
 import okhttp3.CacheControl;
 import okhttp3.Headers;
 import okhttp3.Request;
 import okhttp3.Response;
+import okhttp3.internal.Internal;
+import okhttp3.internal.http.HttpDate;
+import okhttp3.internal.http.HttpHeaders;
+import okhttp3.internal.http.StatusLine;
 
 import static java.net.HttpURLConnection.HTTP_BAD_METHOD;
 import static java.net.HttpURLConnection.HTTP_GONE;
@@ -138,6 +142,8 @@ public Factory(long nowMillis, Request request, Response cacheResponse) {
       this.cacheResponse = cacheResponse;
 
       if (cacheResponse != null) {
+        this.sentRequestMillis = cacheResponse.sentRequestAtMillis();
+        this.receivedResponseMillis = cacheResponse.receivedResponseAtMillis();
         Headers headers = cacheResponse.headers();
         for (int i = 0, size = headers.size(); i < size; i++) {
           String fieldName = headers.name(i);
@@ -153,11 +159,7 @@ public Factory(long nowMillis, Request request, Response cacheResponse) {
           } else if ("ETag".equalsIgnoreCase(fieldName)) {
             etag = value;
           } else if ("Age".equalsIgnoreCase(fieldName)) {
-            ageSeconds = HeaderParser.parseSeconds(value, -1);
-          } else if (OkHeaders.SENT_MILLIS.equalsIgnoreCase(fieldName)) {
-            sentRequestMillis = Long.parseLong(value);
-          } else if (OkHeaders.RECEIVED_MILLIS.equalsIgnoreCase(fieldName)) {
-            receivedResponseMillis = Long.parseLong(value);
+            ageSeconds = HttpHeaders.parseSeconds(value, -1);
           }
         }
       }
@@ -231,20 +233,30 @@ private CacheStrategy getCandidate() {
         return new CacheStrategy(null, builder.build());
       }
 
-      Request.Builder conditionalRequestBuilder = request.newBuilder();
-
+      // Find a condition to add to the request. If the condition is satisfied, the response body
+      // will not be transmitted.
+      String conditionName;
+      String conditionValue;
       if (etag != null) {
-        conditionalRequestBuilder.header("If-None-Match", etag);
+        conditionName = "If-None-Match";
+        conditionValue = etag;
       } else if (lastModified != null) {
-        conditionalRequestBuilder.header("If-Modified-Since", lastModifiedString);
+        conditionName = "If-Modified-Since";
+        conditionValue = lastModifiedString;
       } else if (servedDate != null) {
-        conditionalRequestBuilder.header("If-Modified-Since", servedDateString);
+        conditionName = "If-Modified-Since";
+        conditionValue = servedDateString;
+      } else {
+        return new CacheStrategy(request, null); // No condition! Make a regular request.
       }
 
-      Request conditionalRequest = conditionalRequestBuilder.build();
-      return hasConditions(conditionalRequest)
-          ? new CacheStrategy(conditionalRequest, cacheResponse)
-          : new CacheStrategy(conditionalRequest, null);
+      Headers.Builder conditionalRequestHeaders = request.headers().newBuilder();
+      Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue);
+
+      Request conditionalRequest = request.newBuilder()
+          .headers(conditionalRequestHeaders.build())
+          .build();
+      return new CacheStrategy(conditionalRequest, cacheResponse);
     }
 
     /**
diff --git a/okhttp/src/main/java/okhttp3/internal/DiskLruCache.java b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
similarity index 97%
rename from okhttp/src/main/java/okhttp3/internal/DiskLruCache.java
rename to okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
index 51ce88e9fc..4d3ef616ab 100644
--- a/okhttp/src/main/java/okhttp3/internal/DiskLruCache.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal;
+package okhttp3.internal.cache;
 
 import java.io.Closeable;
 import java.io.EOFException;
@@ -32,14 +32,16 @@
 import java.util.concurrent.TimeUnit;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+import okhttp3.internal.Util;
 import okhttp3.internal.io.FileSystem;
-import okio.Buffer;
+import okhttp3.internal.platform.Platform;
 import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.Okio;
 import okio.Sink;
 import okio.Source;
-import okio.Timeout;
+
+import static okhttp3.internal.platform.Platform.WARN;
 
 /**
  * A cache that uses a bounded amount of space on a filesystem. Each cache entry has a string key
@@ -183,7 +185,7 @@ public void run() {
           }
         } catch (IOException e) {
           mostRecentRebuildFailed = true;
-          journalWriter = Okio.buffer(NULL_SINK);
+          journalWriter = Okio.buffer(Okio.blackhole());
         }
       }
     }
@@ -227,8 +229,8 @@ public synchronized void initialize() throws IOException {
         initialized = true;
         return;
       } catch (IOException journalIsCorrupt) {
-        Platform.get().logW("DiskLruCache " + directory + " is corrupt: "
-            + journalIsCorrupt.getMessage() + ", removing");
+        Platform.get().log(WARN, "DiskLruCache " + directory + " is corrupt: "
+            + journalIsCorrupt.getMessage() + ", removing", journalIsCorrupt);
         delete();
         closed = false;
       }
@@ -818,22 +820,6 @@ public void close() {
     }
   }
 
-  private static final Sink NULL_SINK = new Sink() {
-    @Override public void write(Buffer source, long byteCount) throws IOException {
-      source.skip(byteCount);
-    }
-
-    @Override public void flush() throws IOException {
-    }
-
-    @Override public Timeout timeout() {
-      return Timeout.NONE;
-    }
-
-    @Override public void close() throws IOException {
-    }
-  };
-
   /** Edits the values for an entry. */
   public final class Editor {
     private final Entry entry;
@@ -868,7 +854,7 @@ void detach() {
      * Returns an unbuffered input stream to read the last committed value, or null if no value has
      * been committed.
      */
-    public Source newSource(int index) throws IOException {
+    public Source newSource(int index) {
       synchronized (DiskLruCache.this) {
         if (done) {
           throw new IllegalStateException();
@@ -889,13 +875,13 @@ public Source newSource(int index) throws IOException {
      * output stream encounters errors when writing to the filesystem, this edit will be aborted
      * when {@link #commit} is called. The returned output stream does not throw IOExceptions.
      */
-    public Sink newSink(int index) throws IOException {
+    public Sink newSink(int index) {
       synchronized (DiskLruCache.this) {
         if (done) {
           throw new IllegalStateException();
         }
         if (entry.currentEditor != this) {
-          return NULL_SINK;
+          return Okio.blackhole();
         }
         if (!entry.readable) {
           written[index] = true;
@@ -905,7 +891,7 @@ public Sink newSink(int index) throws IOException {
         try {
           sink = fileSystem.sink(dirtyFile);
         } catch (FileNotFoundException e) {
-          return NULL_SINK;
+          return Okio.blackhole();
         }
         return new FaultHidingSink(sink) {
           @Override protected void onException(IOException e) {
diff --git a/okhttp/src/main/java/okhttp3/internal/FaultHidingSink.java b/okhttp/src/main/java/okhttp3/internal/cache/FaultHidingSink.java
similarity index 98%
rename from okhttp/src/main/java/okhttp3/internal/FaultHidingSink.java
rename to okhttp/src/main/java/okhttp3/internal/cache/FaultHidingSink.java
index e77f6bb448..b10fddb956 100644
--- a/okhttp/src/main/java/okhttp3/internal/FaultHidingSink.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/FaultHidingSink.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal;
+package okhttp3.internal.cache;
 
 import java.io.IOException;
 import okio.Buffer;
diff --git a/okhttp/src/main/java/okhttp3/internal/InternalCache.java b/okhttp/src/main/java/okhttp3/internal/cache/InternalCache.java
similarity index 90%
rename from okhttp/src/main/java/okhttp3/internal/InternalCache.java
rename to okhttp/src/main/java/okhttp3/internal/cache/InternalCache.java
index 9752002bc5..6c70465b59 100644
--- a/okhttp/src/main/java/okhttp3/internal/InternalCache.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/InternalCache.java
@@ -13,13 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal;
+package okhttp3.internal.cache;
 
 import java.io.IOException;
 import okhttp3.Request;
 import okhttp3.Response;
-import okhttp3.internal.http.CacheRequest;
-import okhttp3.internal.http.CacheStrategy;
 
 /**
  * OkHttp's internal cache interface. Applications shouldn't implement this: instead use {@link
@@ -41,7 +39,7 @@
    * {@code network}. The cached response body is not updated. If the stored response has changed
    * since {@code cached} was returned, this does nothing.
    */
-  void update(Response cached, Response network) throws IOException;
+  void update(Response cached, Response network);
 
   /** Track an conditional GET that was satisfied by this cache. */
   void trackConditionalCacheHit();
diff --git a/okhttp/src/main/java/okhttp3/internal/cache2/FileOperator.java b/okhttp/src/main/java/okhttp3/internal/cache2/FileOperator.java
new file mode 100644
index 0000000000..70914226c3
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/cache2/FileOperator.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.cache2;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.channels.FileChannel;
+import okio.Buffer;
+import okio.Okio;
+
+/**
+ * Read and write a target file. Unlike Okio's built-in {@linkplain Okio#source(java.io.File) file
+ * source} and {@linkplain Okio#sink(java.io.File) file sink} this class offers:
+ *
+ * <ul>
+ *   <li><strong>Read/write:</strong> read and write using the same operator.
+ *   <li><strong>Random access:</strong> access any position within the file.
+ *   <li><strong>Shared channels:</strong> read and write a file channel that's shared between
+ *       multiple operators. Note that although the underlying {@code FileChannel} may be shared,
+ *       each {@code FileOperator} should not be.
+ * </ul>
+ */
+final class FileOperator {
+  private static final int BUFFER_SIZE = 8192;
+
+  private final byte[] byteArray = new byte[BUFFER_SIZE];
+  private final ByteBuffer byteBuffer = ByteBuffer.wrap(byteArray);
+  private final FileChannel fileChannel;
+
+  public FileOperator(FileChannel fileChannel) {
+    this.fileChannel = fileChannel;
+  }
+
+  /** Write {@code byteCount} bytes from {@code source} to the file at {@code pos}. */
+  public void write(long pos, Buffer source, long byteCount) throws IOException {
+    if (byteCount < 0 || byteCount > source.size()) throw new IndexOutOfBoundsException();
+
+    while (byteCount > 0L) {
+      try {
+        // Write bytes to the byte[], and tell the ByteBuffer wrapper about 'em.
+        int toWrite = (int) Math.min(BUFFER_SIZE, byteCount);
+        source.read(byteArray, 0, toWrite);
+        byteBuffer.limit(toWrite);
+
+        // Copy bytes from the ByteBuffer to the file.
+        do {
+          int bytesWritten = fileChannel.write(byteBuffer, pos);
+          pos += bytesWritten;
+        } while (byteBuffer.hasRemaining());
+
+        byteCount -= toWrite;
+      } finally {
+        byteBuffer.clear();
+      }
+    }
+  }
+
+  /**
+   * Copy {@code byteCount} bytes from the file at {@code pos} into to {@code source}. It is the
+   * caller's responsibility to make sure there are sufficient bytes to read: if there aren't this
+   * method throws an {@link EOFException}.
+   */
+  public void read(long pos, Buffer sink, long byteCount) throws IOException {
+    if (byteCount < 0) throw new IndexOutOfBoundsException();
+
+    while (byteCount > 0L) {
+      try {
+        // Read up to byteCount bytes.
+        byteBuffer.limit((int) Math.min(BUFFER_SIZE, byteCount));
+        if (fileChannel.read(byteBuffer, pos) == -1) throw new EOFException();
+        int bytesRead = byteBuffer.position();
+
+        // Write those bytes to sink.
+        sink.write(byteArray, 0, bytesRead);
+        pos += bytesRead;
+        byteCount -= bytesRead;
+      } finally {
+        byteBuffer.clear();
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/cache2/Relay.java b/okhttp/src/main/java/okhttp3/internal/cache2/Relay.java
new file mode 100644
index 0000000000..b2db592d1e
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/cache2/Relay.java
@@ -0,0 +1,361 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.cache2;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.RandomAccessFile;
+import okio.Buffer;
+import okio.ByteString;
+import okio.Source;
+import okio.Timeout;
+
+import static okhttp3.internal.Util.closeQuietly;
+
+/**
+ * Replicates a single upstream source into multiple downstream sources. Each downstream source
+ * returns the same bytes as the upstream source. Downstream sources may read data either as it
+ * is returned by upstream, or after the upstream source has been exhausted.
+ *
+ * <p>As bytes are returned from upstream they are written to a local file. Downstream sources read
+ * from this file as necessary.
+ *
+ * <p>This class also keeps a small buffer of bytes recently read from upstream. This is intended to
+ * save a small amount of file I/O and data copying.
+ */
+// TODO(jwilson): what to do about timeouts? They could be different and unfortunately when any
+//     timeout is hit we like to tear down the whole stream.
+final class Relay {
+  private static final int SOURCE_UPSTREAM = 1;
+  private static final int SOURCE_FILE = 2;
+
+  static final ByteString PREFIX_CLEAN = ByteString.encodeUtf8("OkHttp cache v1\n");
+  static final ByteString PREFIX_DIRTY = ByteString.encodeUtf8("OkHttp DIRTY :(\n");
+  private static final long FILE_HEADER_SIZE = 32L;
+
+  /**
+   * Read/write persistence of the upstream source and its metadata. Its layout is as follows:
+   *
+   * <ul>
+   *   <li>16 bytes: either {@code OkHttp cache v1\n} if the persisted file is complete. This is
+   *       another sequence of bytes if the file is incomplete and should not be used.
+   *   <li>8 bytes: <i>n</i>: upstream data size
+   *   <li>8 bytes: <i>m</i>: metadata size
+   *   <li><i>n</i> bytes: upstream data
+   *   <li><i>m</i> bytes: metadata
+   * </ul>
+   *
+   * <p>This is closed and assigned to null when the last source is closed and no further sources
+   * are permitted.
+   */
+  private RandomAccessFile file;
+
+  /** The thread that currently has access to upstream. Possibly null. Guarded by this. */
+  private Thread upstreamReader;
+
+  /**
+   * Null once the file has a complete copy of the upstream bytes. Only the {@code upstreamReader}
+   * thread may access this source.
+   */
+  private Source upstream;
+
+  /**
+   * A buffer for {@code upstreamReader} to use when pulling bytes from upstream. Only the {@code
+   * upstreamReader} thread may access this buffer.
+   */
+  private final Buffer upstreamBuffer = new Buffer();
+
+  /** The number of bytes consumed from {@link #upstream}. Guarded by this. */
+  private long upstreamPos;
+
+  /** True if there are no further bytes to read from {@code upstream}. Guarded by this. */
+  private boolean complete;
+
+  /** User-supplied additional data persisted with the source data. */
+  private final ByteString metadata;
+
+  /**
+   * The most recently read bytes from {@link #upstream}. This is a suffix of {@link #file}. Guarded
+   * by this.
+   */
+  private final Buffer buffer = new Buffer();
+
+  /** The maximum size of {@code buffer}. */
+  private final long bufferMaxSize;
+
+  /**
+   * Reference count of the number of active sources reading this stream. When decremented to 0
+   * resources are released and all following calls to {@link #newSource} return null. Guarded by
+   * this.
+   */
+  private int sourceCount;
+
+  private Relay(RandomAccessFile file, Source upstream, long upstreamPos, ByteString metadata,
+      long bufferMaxSize) {
+    this.file = file;
+    this.upstream = upstream;
+    this.complete = upstream == null;
+    this.upstreamPos = upstreamPos;
+    this.metadata = metadata;
+    this.bufferMaxSize = bufferMaxSize;
+  }
+
+  /**
+   * Creates a new relay that reads a live stream from {@code upstream}, using {@code file} to share
+   * that data with other sources.
+   *
+   * <p><strong>Warning:</strong> callers to this method must immediately call {@link #newSource} to
+   * create a source and close that when they're done. Otherwise a handle to {@code file} will be
+   * leaked.
+   */
+  public static Relay edit(
+      File file, Source upstream, ByteString metadata, long bufferMaxSize) throws IOException {
+    RandomAccessFile randomAccessFile = new RandomAccessFile(file, "rw");
+    Relay result = new Relay(randomAccessFile, upstream, 0L, metadata, bufferMaxSize);
+
+    // Write a dirty header. That way if we crash we won't attempt to recover this.
+    randomAccessFile.setLength(0L);
+    result.writeHeader(PREFIX_DIRTY, -1L, -1L);
+
+    return result;
+  }
+
+  /**
+   * Creates a relay that reads a recorded stream from {@code file}.
+   *
+   * <p><strong>Warning:</strong> callers to this method must immediately call {@link #newSource} to
+   * create a source and close that when they're done. Otherwise a handle to {@code file} will be
+   * leaked.
+   */
+  public static Relay read(File file) throws IOException {
+    RandomAccessFile randomAccessFile = new RandomAccessFile(file, "rw");
+    FileOperator fileOperator = new FileOperator(randomAccessFile.getChannel());
+
+    // Read the header.
+    Buffer header = new Buffer();
+    fileOperator.read(0, header, FILE_HEADER_SIZE);
+    ByteString prefix = header.readByteString(PREFIX_CLEAN.size());
+    if (!prefix.equals(PREFIX_CLEAN)) throw new IOException("unreadable cache file");
+    long upstreamSize = header.readLong();
+    long metadataSize = header.readLong();
+
+    // Read the metadata.
+    Buffer metadataBuffer = new Buffer();
+    fileOperator.read(FILE_HEADER_SIZE + upstreamSize, metadataBuffer, metadataSize);
+    ByteString metadata = metadataBuffer.readByteString();
+
+    // Return the result.
+    return new Relay(randomAccessFile, null, upstreamSize, metadata, 0L);
+  }
+
+  private void writeHeader(
+      ByteString prefix, long upstreamSize, long metadataSize) throws IOException {
+    Buffer header = new Buffer();
+    header.write(prefix);
+    header.writeLong(upstreamSize);
+    header.writeLong(metadataSize);
+    if (header.size() != FILE_HEADER_SIZE) throw new IllegalArgumentException();
+
+    FileOperator fileOperator = new FileOperator(file.getChannel());
+    fileOperator.write(0, header, FILE_HEADER_SIZE);
+  }
+
+  private void writeMetadata(long upstreamSize) throws IOException {
+    Buffer metadataBuffer = new Buffer();
+    metadataBuffer.write(metadata);
+
+    FileOperator fileOperator = new FileOperator(file.getChannel());
+    fileOperator.write(FILE_HEADER_SIZE + upstreamSize, metadataBuffer, metadata.size());
+  }
+
+  void commit(long upstreamSize) throws IOException {
+    // Write metadata to the end of the file.
+    writeMetadata(upstreamSize);
+    file.getChannel().force(false);
+
+    // Once everything else is in place we can swap the dirty header for a clean one.
+    writeHeader(PREFIX_CLEAN, upstreamSize, metadata.size());
+    file.getChannel().force(false);
+
+    // This file is complete.
+    synchronized (Relay.this) {
+      complete = true;
+    }
+
+    closeQuietly(upstream);
+    upstream = null;
+  }
+
+  boolean isClosed() {
+    return file == null;
+  }
+
+  public ByteString metadata() {
+    return metadata;
+  }
+
+  /**
+   * Returns a new source that returns the same bytes as upstream. Returns null if this relay has
+   * been closed and no further sources are possible. In that case callers should retry after
+   * building a new relay with {@link #read}.
+   */
+  public Source newSource() {
+    synchronized (Relay.this) {
+      if (file == null) return null;
+      sourceCount++;
+    }
+
+    return new RelaySource();
+  }
+
+  class RelaySource implements Source {
+    private final Timeout timeout = new Timeout();
+
+    /** The operator to read and write the shared file. Null if this source is closed. */
+    private FileOperator fileOperator = new FileOperator(file.getChannel());
+
+    /** The next byte to read. This is always less than or equal to {@code upstreamPos}. */
+    private long sourcePos;
+
+    /**
+     * Selects where to find the bytes for a read and read them. This is one of three sources.
+     *
+     * <h3>Upstream:</h3>
+     * In this case the current thread is assigned as the upstream reader. We read bytes from
+     * upstream and copy them to both the file and to the buffer. Finally we release the upstream
+     * reader lock and return the new bytes.
+     *
+     * <h3>The file</h3>
+     * In this case we copy bytes from the file to the {@code sink}.
+     *
+     * <h3>The buffer</h3>
+     * In this case the bytes are immediately copied into {@code sink} and the number of bytes
+     * copied is returned.
+     *
+     * <p>If upstream would be selected but another thread is already reading upstream this will
+     * block until that read completes. It is possible to time out while waiting for that.
+     */
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
+      if (fileOperator == null) throw new IllegalStateException("closed");
+
+      long upstreamPos;
+      int source;
+
+      selectSource:
+      synchronized (Relay.this) {
+        // We need new data from upstream.
+        while (sourcePos == (upstreamPos = Relay.this.upstreamPos)) {
+          // No more data upstream. We're done.
+          if (complete) return -1L;
+
+          // Another thread is already reading. Wait for that.
+          if (upstreamReader != null) {
+            timeout.waitUntilNotified(Relay.this);
+            continue;
+          }
+
+          // We will do the read.
+          upstreamReader = Thread.currentThread();
+          source = SOURCE_UPSTREAM;
+          break selectSource;
+        }
+
+        long bufferPos = upstreamPos - buffer.size();
+
+        // Bytes of the read precede the buffer. Read from the file.
+        if (sourcePos < bufferPos) {
+          source = SOURCE_FILE;
+          break selectSource;
+        }
+
+        // The buffer has the data we need. Read from there and return immediately.
+        long bytesToRead = Math.min(byteCount, upstreamPos - sourcePos);
+        buffer.copyTo(sink, sourcePos - bufferPos, bytesToRead);
+        sourcePos += bytesToRead;
+        return bytesToRead;
+      }
+
+      // Read from the file.
+      if (source == SOURCE_FILE) {
+        long bytesToRead = Math.min(byteCount, upstreamPos - sourcePos);
+        fileOperator.read(FILE_HEADER_SIZE + sourcePos, sink, bytesToRead);
+        sourcePos += bytesToRead;
+        return bytesToRead;
+      }
+
+      // Read from upstream. This always reads a full buffer: that might be more than what the
+      // current call to Source.read() has requested.
+      try {
+        long upstreamBytesRead = upstream.read(upstreamBuffer, bufferMaxSize);
+
+        // If we've exhausted upstream, we're done.
+        if (upstreamBytesRead == -1L) {
+          commit(upstreamPos);
+          return -1L;
+        }
+
+        // Update this source and prepare this call's result.
+        long bytesRead = Math.min(upstreamBytesRead, byteCount);
+        upstreamBuffer.copyTo(sink, 0, bytesRead);
+        sourcePos += bytesRead;
+
+        // Append the upstream bytes to the file.
+        fileOperator.write(
+            FILE_HEADER_SIZE + upstreamPos, upstreamBuffer.clone(), upstreamBytesRead);
+
+        synchronized (Relay.this) {
+          // Append new upstream bytes into the buffer. Trim it to its max size.
+          buffer.write(upstreamBuffer, upstreamBytesRead);
+          if (buffer.size() > bufferMaxSize) {
+            buffer.skip(buffer.size() - bufferMaxSize);
+          }
+
+          // Now that the file and buffer have bytes, adjust upstreamPos.
+          Relay.this.upstreamPos += upstreamBytesRead;
+        }
+
+        return bytesRead;
+      } finally {
+        synchronized (Relay.this) {
+          upstreamReader = null;
+          Relay.this.notifyAll();
+        }
+      }
+    }
+
+    @Override public Timeout timeout() {
+      return timeout;
+    }
+
+    @Override public void close() throws IOException {
+      if (fileOperator == null) return; // Already closed.
+      fileOperator = null;
+
+      RandomAccessFile fileToClose = null;
+      synchronized (Relay.this) {
+        sourceCount--;
+        if (sourceCount == 0) {
+          fileToClose = file;
+          file = null;
+        }
+      }
+
+      if (fileToClose != null) {
+        closeQuietly(fileToClose);
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java b/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java
new file mode 100644
index 0000000000..cabd065813
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java
@@ -0,0 +1,47 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3.internal.connection;
+
+import java.io.IOException;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.http.HttpCodec;
+import okhttp3.internal.http.RealInterceptorChain;
+
+/** Opens a connection to the target server and proceeds to the next interceptor. */
+public final class ConnectInterceptor implements Interceptor {
+  public final OkHttpClient client;
+
+  public ConnectInterceptor(OkHttpClient client) {
+    this.client = client;
+  }
+
+  @Override public Response intercept(Chain chain) throws IOException {
+    RealInterceptorChain realChain = (RealInterceptorChain) chain;
+    Request request = realChain.request();
+    StreamAllocation streamAllocation = realChain.streamAllocation();
+
+    // We need the network to satisfy this request. Possibly for validating a conditional GET.
+    boolean doExtensiveHealthChecks = !request.method().equals("GET");
+    HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks);
+    RealConnection connection = streamAllocation.connection();
+
+    return realChain.proceed(request, streamAllocation, httpCodec, connection);
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/ConnectionSpecSelector.java b/okhttp/src/main/java/okhttp3/internal/connection/ConnectionSpecSelector.java
similarity index 98%
rename from okhttp/src/main/java/okhttp3/internal/ConnectionSpecSelector.java
rename to okhttp/src/main/java/okhttp3/internal/connection/ConnectionSpecSelector.java
index 1393910b1b..0b438bfa1f 100644
--- a/okhttp/src/main/java/okhttp3/internal/ConnectionSpecSelector.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/ConnectionSpecSelector.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal;
+package okhttp3.internal.connection;
 
 import java.io.IOException;
 import java.io.InterruptedIOException;
@@ -27,6 +27,7 @@
 import javax.net.ssl.SSLProtocolException;
 import javax.net.ssl.SSLSocket;
 import okhttp3.ConnectionSpec;
+import okhttp3.internal.Internal;
 
 /**
  * Handles the connection spec fallback strategy: When a secure socket connection fails due to a
diff --git a/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
similarity index 86%
rename from okhttp/src/main/java/okhttp3/internal/io/RealConnection.java
rename to okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
index ef6e8f84d9..3652cba0c6 100644
--- a/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
@@ -14,7 +14,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package okhttp3.internal.io;
+package okhttp3.internal.connection;
 
 import java.io.IOException;
 import java.lang.ref.Reference;
@@ -41,17 +41,14 @@
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.Route;
-import okhttp3.internal.ConnectionSpecSelector;
-import okhttp3.internal.Platform;
 import okhttp3.internal.Util;
 import okhttp3.internal.Version;
-import okhttp3.internal.framed.ErrorCode;
-import okhttp3.internal.framed.FramedConnection;
-import okhttp3.internal.framed.FramedStream;
-import okhttp3.internal.http.Http1xStream;
-import okhttp3.internal.http.OkHeaders;
-import okhttp3.internal.http.RouteException;
-import okhttp3.internal.http.StreamAllocation;
+import okhttp3.internal.http.HttpHeaders;
+import okhttp3.internal.http1.Http1Codec;
+import okhttp3.internal.http2.ErrorCode;
+import okhttp3.internal.http2.Http2Connection;
+import okhttp3.internal.http2.Http2Stream;
+import okhttp3.internal.platform.Platform;
 import okhttp3.internal.tls.OkHostnameVerifier;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -63,7 +60,7 @@
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static okhttp3.internal.Util.closeQuietly;
 
-public final class RealConnection extends FramedConnection.Listener implements Connection {
+public final class RealConnection extends Http2Connection.Listener implements Connection {
   private final Route route;
 
   /** The low-level TCP socket. */
@@ -76,7 +73,7 @@
   public Socket socket;
   private Handshake handshake;
   private Protocol protocol;
-  public volatile FramedConnection framedConnection;
+  public volatile Http2Connection http2Connection;
   public int successCount;
   public BufferedSource source;
   public BufferedSink sink;
@@ -90,16 +87,22 @@ public RealConnection(Route route) {
   }
 
   public void connect(int connectTimeout, int readTimeout, int writeTimeout,
-      List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {
+      List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) {
     if (protocol != null) throw new IllegalStateException("already connected");
 
     RouteException routeException = null;
     ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);
 
-    if (route.address().sslSocketFactory() == null
-        && !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {
-      throw new RouteException(new UnknownServiceException(
-          "CLEARTEXT communication not supported: " + connectionSpecs));
+    if (route.address().sslSocketFactory() == null) {
+      if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {
+        throw new RouteException(new UnknownServiceException(
+            "CLEARTEXT communication not enabled for client"));
+      }
+      String host = route.address().url().host();
+      if (!Platform.get().isCleartextTrafficPermitted(host)) {
+        throw new RouteException(new UnknownServiceException(
+            "CLEARTEXT communication to " + host + " not permitted by network security policy"));
+      }
     }
 
     while (protocol == null) {
@@ -148,7 +151,7 @@ private void buildTunneledConnection(int connectTimeout, int readTimeout, int wr
         throw new ProtocolException("Too many tunnel connections attempted: " + maxAttempts);
       }
 
-      connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);
+      connectSocket(connectTimeout, readTimeout);
       tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url);
 
       if (tunnelRequest == null) break; // Tunnel successfully created.
@@ -167,12 +170,11 @@ private void buildTunneledConnection(int connectTimeout, int readTimeout, int wr
   /** Does all the work necessary to build a full HTTP or HTTPS connection on a raw socket. */
   private void buildConnection(int connectTimeout, int readTimeout, int writeTimeout,
       ConnectionSpecSelector connectionSpecSelector) throws IOException {
-    connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);
+    connectSocket(connectTimeout, readTimeout);
     establishProtocol(readTimeout, writeTimeout, connectionSpecSelector);
   }
 
-  private void connectSocket(int connectTimeout, int readTimeout, int writeTimeout,
-      ConnectionSpecSelector connectionSpecSelector) throws IOException {
+  private void connectSocket(int connectTimeout, int readTimeout) throws IOException {
     Proxy proxy = route.proxy();
     Address address = route.address();
 
@@ -199,19 +201,18 @@ private void establishProtocol(int readTimeout, int writeTimeout,
       socket = rawSocket;
     }
 
-    if (protocol == Protocol.SPDY_3 || protocol == Protocol.HTTP_2) {
+    if (protocol == Protocol.HTTP_2) {
       socket.setSoTimeout(0); // Framed connection timeouts are set per-stream.
 
-      FramedConnection framedConnection = new FramedConnection.Builder(true)
+      Http2Connection http2Connection = new Http2Connection.Builder(true)
           .socket(socket, route.address().url().host(), source, sink)
-          .protocol(protocol)
           .listener(this)
           .build();
-      framedConnection.start();
+      http2Connection.start();
 
       // Only assign the framed connection once the preface has been sent successfully.
-      this.allocationLimit = framedConnection.maxConcurrentStreams();
-      this.framedConnection = framedConnection;
+      this.allocationLimit = http2Connection.maxConcurrentStreams();
+      this.http2Connection = http2Connection;
     } else {
       this.allocationLimit = 1;
     }
@@ -286,7 +287,7 @@ private Request createTunnel(int readTimeout, int writeTimeout, Request tunnelRe
     // Make an SSL Tunnel on the first message pair of each SSL + proxy connection.
     String requestLine = "CONNECT " + Util.hostHeader(url, true) + " HTTP/1.1";
     while (true) {
-      Http1xStream tunnelConnection = new Http1xStream(null, source, sink);
+      Http1Codec tunnelConnection = new Http1Codec(null, null, source, sink);
       source.timeout().timeout(readTimeout, MILLISECONDS);
       sink.timeout().timeout(writeTimeout, MILLISECONDS);
       tunnelConnection.writeRequest(tunnelRequest.headers(), requestLine);
@@ -294,7 +295,7 @@ private Request createTunnel(int readTimeout, int writeTimeout, Request tunnelRe
       Response response = tunnelConnection.readResponse().request(tunnelRequest).build();
       // The response body from a CONNECT should be empty, but if it is not then we should consume
       // it before proceeding.
-      long contentLength = OkHeaders.contentLength(response);
+      long contentLength = HttpHeaders.contentLength(response);
       if (contentLength == -1L) {
         contentLength = 0L;
       }
@@ -334,7 +335,7 @@ private Request createTunnel(int readTimeout, int writeTimeout, Request tunnelRe
    * is sent unencrypted to the proxy server, so tunnels include only the minimum set of headers.
    * This avoids sending potentially sensitive data like HTTP cookies to the proxy unencrypted.
    */
-  private Request createTunnelRequest() throws IOException {
+  private Request createTunnelRequest() {
     return new Request.Builder()
         .url(route.address().url())
         .header("Host", Util.hostHeader(route.address().url(), true))
@@ -343,11 +344,6 @@ private Request createTunnelRequest() throws IOException {
         .build();
   }
 
-  /** Returns true if {@link #connect} has been attempted on this connection. */
-  boolean isConnected() {
-    return protocol != null;
-  }
-
   @Override public Route route() {
     return route;
   }
@@ -367,7 +363,7 @@ public boolean isHealthy(boolean doExtensiveChecks) {
       return false;
     }
 
-    if (framedConnection != null) {
+    if (http2Connection != null) {
       return true; // TODO: check framedConnection.shutdown.
     }
 
@@ -394,12 +390,12 @@ public boolean isHealthy(boolean doExtensiveChecks) {
   }
 
   /** Refuse incoming streams. */
-  @Override public void onStream(FramedStream stream) throws IOException {
+  @Override public void onStream(Http2Stream stream) throws IOException {
     stream.close(ErrorCode.REFUSED_STREAM);
   }
 
   /** When settings are received, adjust the allocation limit. */
-  @Override public void onSettings(FramedConnection connection) {
+  @Override public void onSettings(Http2Connection connection) {
     allocationLimit = connection.maxConcurrentStreams();
   }
 
@@ -408,18 +404,18 @@ public boolean isHealthy(boolean doExtensiveChecks) {
   }
 
   /**
-   * Returns true if this is a SPDY connection. Such connections can be used in multiple HTTP
+   * Returns true if this is an HTTP/2 connection. Such connections can be used in multiple HTTP
    * requests simultaneously.
    */
   public boolean isMultiplexed() {
-    return framedConnection != null;
+    return http2Connection != null;
   }
 
   @Override public Protocol protocol() {
-    if (framedConnection == null) {
+    if (http2Connection == null) {
       return protocol != null ? protocol : Protocol.HTTP_1_1;
     } else {
-      return framedConnection.getProtocol();
+      return Protocol.HTTP_2;
     }
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/RouteDatabase.java b/okhttp/src/main/java/okhttp3/internal/connection/RouteDatabase.java
similarity index 93%
rename from okhttp/src/main/java/okhttp3/internal/RouteDatabase.java
rename to okhttp/src/main/java/okhttp3/internal/connection/RouteDatabase.java
index 613e0bf215..1cc3f311b9 100644
--- a/okhttp/src/main/java/okhttp3/internal/RouteDatabase.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RouteDatabase.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal;
+package okhttp3.internal.connection;
 
 import java.util.LinkedHashSet;
 import java.util.Set;
@@ -42,8 +42,4 @@ public synchronized void connected(Route route) {
   public synchronized boolean shouldPostpone(Route route) {
     return failedRoutes.contains(route);
   }
-
-  public synchronized int failedRoutesCount() {
-    return failedRoutes.size();
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RouteException.java b/okhttp/src/main/java/okhttp3/internal/connection/RouteException.java
similarity index 94%
rename from okhttp/src/main/java/okhttp3/internal/http/RouteException.java
rename to okhttp/src/main/java/okhttp3/internal/connection/RouteException.java
index 030b346a5a..5f50576611 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RouteException.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RouteException.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.http;
+package okhttp3.internal.connection;
 
 import java.io.IOException;
 import java.lang.reflect.InvocationTargetException;
@@ -23,7 +23,7 @@
  * An exception thrown to indicate a problem connecting via a single Route. Multiple attempts may
  * have been made with alternative protocols, none of which were successful.
  */
-public final class RouteException extends Exception {
+public final class RouteException extends RuntimeException {
   private static final Method addSuppressedExceptionMethod;
 
   static {
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RouteSelector.java b/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.java
similarity index 99%
rename from okhttp/src/main/java/okhttp3/internal/http/RouteSelector.java
rename to okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.java
index 3b5725cbe6..95e9fbe5e8 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RouteSelector.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.http;
+package okhttp3.internal.connection;
 
 import java.io.IOException;
 import java.net.InetAddress;
@@ -28,7 +28,6 @@
 import okhttp3.Address;
 import okhttp3.HttpUrl;
 import okhttp3.Route;
-import okhttp3.internal.RouteDatabase;
 
 /**
  * Selects routes to connect to an origin server. Each connection requires a choice of proxy server,
diff --git a/okhttp/src/main/java/okhttp3/internal/http/StreamAllocation.java b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
similarity index 69%
rename from okhttp/src/main/java/okhttp3/internal/http/StreamAllocation.java
rename to okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
index 385dc2b2ac..73b2506f62 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/StreamAllocation.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
@@ -13,25 +13,22 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.http;
+package okhttp3.internal.connection;
 
 import java.io.IOException;
-import java.io.InterruptedIOException;
 import java.lang.ref.Reference;
 import java.lang.ref.WeakReference;
-import java.net.ProtocolException;
-import java.net.SocketTimeoutException;
-import java.security.cert.CertificateException;
-import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLPeerUnverifiedException;
 import okhttp3.Address;
 import okhttp3.ConnectionPool;
+import okhttp3.OkHttpClient;
 import okhttp3.Route;
 import okhttp3.internal.Internal;
-import okhttp3.internal.RouteDatabase;
 import okhttp3.internal.Util;
-import okhttp3.internal.io.RealConnection;
-import okio.Sink;
+import okhttp3.internal.http.HttpCodec;
+import okhttp3.internal.http1.Http1Codec;
+import okhttp3.internal.http2.ErrorCode;
+import okhttp3.internal.http2.Http2Codec;
+import okhttp3.internal.http2.StreamResetException;
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 
@@ -45,7 +42,7 @@
  *     <li><strong>Streams:</strong> logical HTTP request/response pairs that are layered on
  *         connections. Each connection has its own allocation limit, which defines how many
  *         concurrent streams that connection can carry. HTTP/1.x connections can carry 1 stream
- *         at a time, SPDY and HTTP/2 typically carry multiple.
+ *         at a time, HTTP/2 typically carry multiple.
  *     <li><strong>Calls:</strong> a logical sequence of streams, typically an initial request and
  *         its follow up requests. We prefer to keep all streams of a single call on the same
  *         connection for better behavior and locality.
@@ -76,40 +73,47 @@
   public final Address address;
   private Route route;
   private final ConnectionPool connectionPool;
+  private final Object callStackTrace;
 
   // State guarded by connectionPool.
-  private RouteSelector routeSelector;
+  private final RouteSelector routeSelector;
+  private int refusedStreamCount;
   private RealConnection connection;
   private boolean released;
   private boolean canceled;
-  private HttpStream stream;
+  private HttpCodec codec;
 
-  public StreamAllocation(ConnectionPool connectionPool, Address address) {
+  public StreamAllocation(ConnectionPool connectionPool, Address address, Object callStackTrace) {
     this.connectionPool = connectionPool;
     this.address = address;
     this.routeSelector = new RouteSelector(address, routeDatabase());
+    this.callStackTrace = callStackTrace;
   }
 
-  public HttpStream newStream(int connectTimeout, int readTimeout, int writeTimeout,
-      boolean connectionRetryEnabled, boolean doExtensiveHealthChecks)
-      throws RouteException, IOException {
+  public HttpCodec newStream(OkHttpClient client, boolean doExtensiveHealthChecks) {
+    int connectTimeout = client.connectTimeoutMillis();
+    int readTimeout = client.readTimeoutMillis();
+    int writeTimeout = client.writeTimeoutMillis();
+    boolean connectionRetryEnabled = client.retryOnConnectionFailure();
+
     try {
       RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,
           writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);
 
-      HttpStream resultStream;
-      if (resultConnection.framedConnection != null) {
-        resultStream = new Http2xStream(this, resultConnection.framedConnection);
+      HttpCodec resultCodec;
+      if (resultConnection.http2Connection != null) {
+        resultCodec = new Http2Codec(client, this, resultConnection.http2Connection);
       } else {
         resultConnection.socket().setSoTimeout(readTimeout);
         resultConnection.source.timeout().timeout(readTimeout, MILLISECONDS);
         resultConnection.sink.timeout().timeout(writeTimeout, MILLISECONDS);
-        resultStream = new Http1xStream(this, resultConnection.source, resultConnection.sink);
+        resultCodec = new Http1Codec(
+            client, this, resultConnection.source, resultConnection.sink);
       }
 
       synchronized (connectionPool) {
-        stream = resultStream;
-        return resultStream;
+        codec = resultCodec;
+        return resultCodec;
       }
     } catch (IOException e) {
       throw new RouteException(e);
@@ -122,7 +126,7 @@ public HttpStream newStream(int connectTimeout, int readTimeout, int writeTimeou
    */
   private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,
       int writeTimeout, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks)
-      throws IOException, RouteException {
+      throws IOException {
     while (true) {
       RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,
           connectionRetryEnabled);
@@ -134,12 +138,14 @@ private RealConnection findHealthyConnection(int connectTimeout, int readTimeout
         }
       }
 
-      // Otherwise do a potentially-slow check to confirm that the pooled connection is still good.
-      if (candidate.isHealthy(doExtensiveHealthChecks)) {
-        return candidate;
+      // Do a (potentially slow) check to confirm that the pooled connection is still good. If it
+      // isn't, take it out of the pool and start again.
+      if (!candidate.isHealthy(doExtensiveHealthChecks)) {
+        noNewStreams();
+        continue;
       }
 
-      connectionFailed(new IOException());
+      return candidate;
     }
   }
 
@@ -148,11 +154,11 @@ private RealConnection findHealthyConnection(int connectTimeout, int readTimeout
    * then the pool, finally building a new connection.
    */
   private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,
-      boolean connectionRetryEnabled) throws IOException, RouteException {
+      boolean connectionRetryEnabled) throws IOException {
     Route selectedRoute;
     synchronized (connectionPool) {
       if (released) throw new IllegalStateException("released");
-      if (stream != null) throw new IllegalStateException("stream != null");
+      if (codec != null) throw new IllegalStateException("codec != null");
       if (canceled) throw new IOException("Canceled");
 
       RealConnection allocatedConnection = this.connection;
@@ -174,12 +180,13 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
       selectedRoute = routeSelector.next();
       synchronized (connectionPool) {
         route = selectedRoute;
+        refusedStreamCount = 0;
       }
     }
     RealConnection newConnection = new RealConnection(selectedRoute);
-    acquire(newConnection);
 
     synchronized (connectionPool) {
+      acquire(newConnection);
       Internal.instance.put(connectionPool, newConnection);
       this.connection = newConnection;
       if (canceled) throw new IOException("Canceled");
@@ -192,10 +199,10 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
     return newConnection;
   }
 
-  public void streamFinished(boolean noNewStreams, HttpStream stream) {
+  public void streamFinished(boolean noNewStreams, HttpCodec codec) {
     synchronized (connectionPool) {
-      if (stream == null || stream != this.stream) {
-        throw new IllegalStateException("expected " + this.stream + " but was " + stream);
+      if (codec == null || codec != this.codec) {
+        throw new IllegalStateException("expected " + this.codec + " but was " + codec);
       }
       if (!noNewStreams) {
         connection.successCount++;
@@ -204,9 +211,9 @@ public void streamFinished(boolean noNewStreams, HttpStream stream) {
     deallocate(noNewStreams, false, true);
   }
 
-  public HttpStream stream() {
+  public HttpCodec codec() {
     synchronized (connectionPool) {
-      return stream;
+      return codec;
     }
   }
 
@@ -235,7 +242,7 @@ private void deallocate(boolean noNewStreams, boolean released, boolean streamFi
     RealConnection connectionToClose = null;
     synchronized (connectionPool) {
       if (streamFinished) {
-        this.stream = null;
+        this.codec = null;
       }
       if (released) {
         this.released = true;
@@ -244,7 +251,7 @@ private void deallocate(boolean noNewStreams, boolean released, boolean streamFi
         if (noNewStreams) {
           connection.noNewStreams = true;
         }
-        if (this.stream == null && (this.released || connection.noNewStreams)) {
+        if (this.codec == null && (this.released || connection.noNewStreams)) {
           release(connection);
           if (connection.allocations.isEmpty()) {
             connection.idleAtNanos = System.nanoTime();
@@ -262,31 +269,49 @@ private void deallocate(boolean noNewStreams, boolean released, boolean streamFi
   }
 
   public void cancel() {
-    HttpStream streamToCancel;
+    HttpCodec codecToCancel;
     RealConnection connectionToCancel;
     synchronized (connectionPool) {
       canceled = true;
-      streamToCancel = stream;
+      codecToCancel = codec;
       connectionToCancel = connection;
     }
-    if (streamToCancel != null) {
-      streamToCancel.cancel();
+    if (codecToCancel != null) {
+      codecToCancel.cancel();
     } else if (connectionToCancel != null) {
       connectionToCancel.cancel();
     }
   }
 
-  public void connectionFailed(IOException e) {
+  public void streamFailed(IOException e) {
+    boolean noNewStreams = false;
+
     synchronized (connectionPool) {
-      // Avoid this route if it's never seen a successful call.
-      if (connection != null && connection.successCount == 0) {
-        if (route != null && e != null) {
-          routeSelector.connectFailed(route, e);
+      if (e instanceof StreamResetException) {
+        StreamResetException streamResetException = (StreamResetException) e;
+        if (streamResetException.errorCode == ErrorCode.REFUSED_STREAM) {
+          refusedStreamCount++;
+        }
+        // On HTTP/2 stream errors, retry REFUSED_STREAM errors once on the same connection. All
+        // other errors must be retried on a new connection.
+        if (streamResetException.errorCode != ErrorCode.REFUSED_STREAM || refusedStreamCount > 1) {
+          noNewStreams = true;
+          route = null;
+        }
+      } else if (connection != null && !connection.isMultiplexed()) {
+        noNewStreams = true;
+
+        // If this route hasn't completed a call, avoid it for new connections.
+        if (connection.successCount == 0) {
+          if (route != null && e != null) {
+            routeSelector.connectFailed(route, e);
+          }
+          route = null;
         }
-        route = null;
       }
     }
-    deallocate(true, false, true);
+
+    deallocate(noNewStreams, false, true);
   }
 
   /**
@@ -294,7 +319,8 @@ public void connectionFailed(IOException e) {
    * {@link #release} on the same connection.
    */
   public void acquire(RealConnection connection) {
-    connection.allocations.add(new WeakReference<>(this));
+    assert (Thread.holdsLock(connectionPool));
+    connection.allocations.add(new StreamAllocationReference(this, callStackTrace));
   }
 
   /** Remove this allocation from the connection's list of allocations. */
@@ -309,54 +335,24 @@ private void release(RealConnection connection) {
     throw new IllegalStateException();
   }
 
-  public boolean recover(IOException e, boolean routeException, Sink requestBodyOut) {
-    if (connection != null) {
-      connectionFailed(e);
-    }
-
-    boolean canRetryRequestBody = requestBodyOut == null || requestBodyOut instanceof RetryableSink;
-    if ((routeSelector != null && !routeSelector.hasNext()) // No more routes to attempt.
-        || !isRecoverable(e, routeException)
-        || !canRetryRequestBody) {
-      return false;
-    }
-
-    return true;
+  public boolean hasMoreRoutes() {
+    return route != null || routeSelector.hasNext();
   }
 
-  private boolean isRecoverable(IOException e, boolean routeException) {
-    // If there was a protocol problem, don't recover.
-    if (e instanceof ProtocolException) {
-      return false;
-    }
+  @Override public String toString() {
+    return address.toString();
+  }
 
-    // If there was an interruption don't recover, but if there was a timeout connecting to a route
-    // we should try the next route (if there is one).
-    if (e instanceof InterruptedIOException) {
-      return e instanceof SocketTimeoutException && routeException;
-    }
+  public static final class StreamAllocationReference extends WeakReference<StreamAllocation> {
+    /**
+     * Captures the stack trace at the time the Call is executed or enqueued. This is helpful for
+     * identifying the origin of connection leaks.
+     */
+    public final Object callStackTrace;
 
-    // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
-    // again with a different route.
-    if (e instanceof SSLHandshakeException) {
-      // If the problem was a CertificateException from the X509TrustManager,
-      // do not retry.
-      if (e.getCause() instanceof CertificateException) {
-        return false;
-      }
+    StreamAllocationReference(StreamAllocation referent, Object callStackTrace) {
+      super(referent);
+      this.callStackTrace = callStackTrace;
     }
-    if (e instanceof SSLPeerUnverifiedException) {
-      // e.g. a certificate pinning error.
-      return false;
-    }
-
-    // An example of one we might want to retry with a different route is a problem connecting to a
-    // proxy and would manifest as a standard IOException. Unless it is one we know we should not
-    // retry, we return true and try a new route.
-    return true;
-  }
-
-  @Override public String toString() {
-    return address.toString();
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/ErrorCode.java b/okhttp/src/main/java/okhttp3/internal/framed/ErrorCode.java
deleted file mode 100644
index 1142319d7e..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/framed/ErrorCode.java
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.framed;
-
-// http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-7
-public enum ErrorCode {
-  /** Not an error! For SPDY stream resets, prefer null over NO_ERROR. */
-  NO_ERROR(0, -1, 0),
-
-  PROTOCOL_ERROR(1, 1, 1),
-
-  /** A subtype of PROTOCOL_ERROR used by SPDY. */
-  INVALID_STREAM(1, 2, -1),
-
-  /** A subtype of PROTOCOL_ERROR used by SPDY. */
-  UNSUPPORTED_VERSION(1, 4, -1),
-
-  /** A subtype of PROTOCOL_ERROR used by SPDY. */
-  STREAM_IN_USE(1, 8, -1),
-
-  /** A subtype of PROTOCOL_ERROR used by SPDY. */
-  STREAM_ALREADY_CLOSED(1, 9, -1),
-
-  INTERNAL_ERROR(2, 6, 2),
-
-  FLOW_CONTROL_ERROR(3, 7, -1),
-
-  STREAM_CLOSED(5, -1, -1),
-
-  FRAME_TOO_LARGE(6, 11, -1),
-
-  REFUSED_STREAM(7, 3, -1),
-
-  CANCEL(8, 5, -1),
-
-  COMPRESSION_ERROR(9, -1, -1),
-
-  CONNECT_ERROR(10, -1, -1),
-
-  ENHANCE_YOUR_CALM(11, -1, -1),
-
-  INADEQUATE_SECURITY(12, -1, -1),
-
-  HTTP_1_1_REQUIRED(13, -1, -1),
-
-  INVALID_CREDENTIALS(-1, 10, -1);
-
-  public final int httpCode;
-  public final int spdyRstCode;
-  public final int spdyGoAwayCode;
-
-  private ErrorCode(int httpCode, int spdyRstCode, int spdyGoAwayCode) {
-    this.httpCode = httpCode;
-    this.spdyRstCode = spdyRstCode;
-    this.spdyGoAwayCode = spdyGoAwayCode;
-  }
-
-  public static ErrorCode fromSpdy3Rst(int code) {
-    for (ErrorCode errorCode : ErrorCode.values()) {
-      if (errorCode.spdyRstCode == code) return errorCode;
-    }
-    return null;
-  }
-
-  public static ErrorCode fromHttp2(int code) {
-    for (ErrorCode errorCode : ErrorCode.values()) {
-      if (errorCode.httpCode == code) return errorCode;
-    }
-    return null;
-  }
-
-  public static ErrorCode fromSpdyGoAway(int code) {
-    for (ErrorCode errorCode : ErrorCode.values()) {
-      if (errorCode.spdyGoAwayCode == code) return errorCode;
-    }
-    return null;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/FrameReader.java b/okhttp/src/main/java/okhttp3/internal/framed/FrameReader.java
deleted file mode 100644
index 741a568c0d..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/framed/FrameReader.java
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.framed;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.util.List;
-import okio.BufferedSource;
-import okio.ByteString;
-
-/** Reads transport frames for SPDY/3 or HTTP/2. */
-public interface FrameReader extends Closeable {
-  void readConnectionPreface() throws IOException;
-
-  boolean nextFrame(Handler handler) throws IOException;
-
-  interface Handler {
-    void data(boolean inFinished, int streamId, BufferedSource source, int length)
-        throws IOException;
-
-    /**
-     * Create or update incoming headers, creating the corresponding streams if necessary. Frames
-     * that trigger this are SPDY SYN_STREAM, HEADERS, and SYN_REPLY, and HTTP/2 HEADERS and
-     * PUSH_PROMISE.
-     *
-     * @param outFinished true if the receiver should not send further frames.
-     * @param inFinished true if the sender will not send further frames.
-     * @param streamId the stream owning these headers.
-     * @param associatedStreamId the stream that triggered the sender to create this stream.
-     */
-    void headers(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
-        List<Header> headerBlock, HeadersMode headersMode);
-
-    void rstStream(int streamId, ErrorCode errorCode);
-
-    void settings(boolean clearPrevious, Settings settings);
-
-    /** HTTP/2 only. */
-    void ackSettings();
-
-    /**
-     * Read a connection-level ping from the peer.  {@code ack} indicates this is a reply.  Payload
-     * parameters are different between SPDY/3 and HTTP/2.
-     *
-     * <p>In SPDY/3, only the first {@code payload1} parameter is set.  If the reader is a client,
-     * it is an unsigned even number. Likewise, a server will receive an odd number.
-     *
-     * <p>In HTTP/2, both {@code payload1} and {@code payload2} parameters are set. The data is
-     * opaque binary, and there are no rules on the content.
-     */
-    void ping(boolean ack, int payload1, int payload2);
-
-    /**
-     * The peer tells us to stop creating streams.  It is safe to replay streams with {@code ID >
-     * lastGoodStreamId} on a new connection.  In- flight streams with {@code ID <=
-     * lastGoodStreamId} can only be replayed on a new connection if they are idempotent.
-     *
-     * @param lastGoodStreamId the last stream ID the peer processed before sending this message. If
-     * {@code lastGoodStreamId} is zero, the peer processed no frames.
-     * @param errorCode reason for closing the connection.
-     * @param debugData only valid for HTTP/2; opaque debug data to send.
-     */
-    void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData);
-
-    /**
-     * Notifies that an additional {@code windowSizeIncrement} bytes can be sent on {@code
-     * streamId}, or the connection if {@code streamId} is zero.
-     */
-    void windowUpdate(int streamId, long windowSizeIncrement);
-
-    /**
-     * Called when reading a headers or priority frame. This may be used to change the stream's
-     * weight from the default (16) to a new value.
-     *
-     * @param streamId stream which has a priority change.
-     * @param streamDependency the stream ID this stream is dependent on.
-     * @param weight relative proportion of priority in [1..256].
-     * @param exclusive inserts this stream ID as the sole child of {@code streamDependency}.
-     */
-    void priority(int streamId, int streamDependency, int weight, boolean exclusive);
-
-    /**
-     * HTTP/2 only. Receive a push promise header block. <p> A push promise contains all the headers
-     * that pertain to a server-initiated request, and a {@code promisedStreamId} to which response
-     * frames will be delivered. Push promise frames are sent as a part of the response to {@code
-     * streamId}.
-     *
-     * @param streamId client-initiated stream ID.  Must be an odd number.
-     * @param promisedStreamId server-initiated stream ID.  Must be an even number.
-     * @param requestHeaders minimally includes {@code :method}, {@code :scheme}, {@code
-     * :authority}, and (@code :path}.
-     */
-    void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
-        throws IOException;
-
-    /**
-     * HTTP/2 only. Expresses that resources for the connection or a client- initiated stream are
-     * available from a different network location or protocol configuration.
-     *
-     * <p>See <a href="http://tools.ietf.org/html/draft-ietf-httpbis-alt-svc-01">alt-svc</a>
-     *
-     * @param streamId when a client-initiated stream ID (odd number), the origin of this alternate
-     * service is the origin of the stream. When zero, the origin is specified in the {@code origin}
-     * parameter.
-     * @param origin when present, the <a href="http://tools.ietf.org/html/rfc6454">origin</a> is
-     * typically represented as a combination of scheme, host and port. When empty, the origin is
-     * that of the {@code streamId}.
-     * @param protocol an ALPN protocol, such as {@code h2}.
-     * @param host an IP address or hostname.
-     * @param port the IP port associated with the service.
-     * @param maxAge time in seconds that this alternative is considered fresh.
-     */
-    void alternateService(int streamId, String origin, ByteString protocol, String host, int port,
-        long maxAge);
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/FrameWriter.java b/okhttp/src/main/java/okhttp3/internal/framed/FrameWriter.java
deleted file mode 100644
index 5e8c7ebef9..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/framed/FrameWriter.java
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.framed;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.util.List;
-import okio.Buffer;
-
-/** Writes transport frames for SPDY/3 or HTTP/2. */
-public interface FrameWriter extends Closeable {
-  /** HTTP/2 only. */
-  void connectionPreface() throws IOException;
-
-  /** Informs the peer that we've applied its latest settings. */
-  void ackSettings(Settings peerSettings) throws IOException;
-
-  /**
-   * HTTP/2 only. Send a push promise header block.
-   *
-   * <p>A push promise contains all the headers that pertain to a server-initiated request, and a
-   * {@code promisedStreamId} to which response frames will be delivered. Push promise frames are
-   * sent as a part of the response to {@code streamId}. The {@code promisedStreamId} has a priority
-   * of one greater than {@code streamId}.
-   *
-   * @param streamId client-initiated stream ID.  Must be an odd number.
-   * @param promisedStreamId server-initiated stream ID.  Must be an even number.
-   * @param requestHeaders minimally includes {@code :method}, {@code :scheme}, {@code :authority},
-   * and (@code :path}.
-   */
-  void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
-      throws IOException;
-
-  /** SPDY/3 only. */
-  void flush() throws IOException;
-
-  void synStream(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
-      List<Header> headerBlock) throws IOException;
-
-  void synReply(boolean outFinished, int streamId, List<Header> headerBlock)
-      throws IOException;
-
-  void headers(int streamId, List<Header> headerBlock) throws IOException;
-
-  void rstStream(int streamId, ErrorCode errorCode) throws IOException;
-
-  /** The maximum size of bytes that may be sent in a single call to {@link #data}. */
-  int maxDataLength();
-
-  /**
-   * {@code source.length} may be longer than the max length of the variant's data frame.
-   * Implementations must send multiple frames as necessary.
-   *
-   * @param source the buffer to draw bytes from. May be null if byteCount is 0.
-   * @param byteCount must be between 0 and the minimum of {code source.length} and {@link
-   * #maxDataLength}.
-   */
-  void data(boolean outFinished, int streamId, Buffer source, int byteCount) throws IOException;
-
-  /** Write okhttp's settings to the peer. */
-  void settings(Settings okHttpSettings) throws IOException;
-
-  /**
-   * Send a connection-level ping to the peer.  {@code ack} indicates this is a reply.  Payload
-   * parameters are different between SPDY/3 and HTTP/2.
-   *
-   * <p>In SPDY/3, only the first {@code payload1} parameter is sent.  If the sender is a client, it
-   * is an unsigned odd number. Likewise, a server will send an even number.
-   *
-   * <p>In HTTP/2, both {@code payload1} and {@code payload2} parameters are sent.  The data is
-   * opaque binary, and there are no rules on the content.
-   */
-  void ping(boolean ack, int payload1, int payload2) throws IOException;
-
-  /**
-   * Tell the peer to stop creating streams and that we last processed {@code lastGoodStreamId}, or
-   * zero if no streams were processed.
-   *
-   * @param lastGoodStreamId the last stream ID processed, or zero if no streams were processed.
-   * @param errorCode reason for closing the connection.
-   * @param debugData only valid for HTTP/2; opaque debug data to send.
-   */
-  void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) throws IOException;
-
-  /**
-   * Inform peer that an additional {@code windowSizeIncrement} bytes can be sent on {@code
-   * streamId}, or the connection if {@code streamId} is zero.
-   */
-  void windowUpdate(int streamId, long windowSizeIncrement) throws IOException;
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/HeadersMode.java b/okhttp/src/main/java/okhttp3/internal/framed/HeadersMode.java
deleted file mode 100644
index bc851ed784..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/framed/HeadersMode.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.framed;
-
-public enum HeadersMode {
-  SPDY_SYN_STREAM,
-  SPDY_REPLY,
-  SPDY_HEADERS,
-  HTTP_20_HEADERS;
-
-  /** Returns true if it is an error these headers to create a new stream. */
-  public boolean failIfStreamAbsent() {
-    return this == SPDY_REPLY || this == SPDY_HEADERS;
-  }
-
-  /** Returns true if it is an error these headers to update an existing stream. */
-  public boolean failIfStreamPresent() {
-    return this == SPDY_SYN_STREAM;
-  }
-
-  /**
-   * Returns true if it is an error these headers to be the initial headers of a response.
-   */
-  public boolean failIfHeadersAbsent() {
-    return this == SPDY_HEADERS;
-  }
-
-  /**
-   * Returns true if it is an error these headers to be update existing headers of a response.
-   */
-  public boolean failIfHeadersPresent() {
-    return this == SPDY_REPLY;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/Http2.java b/okhttp/src/main/java/okhttp3/internal/framed/Http2.java
deleted file mode 100644
index a6c177cc60..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/framed/Http2.java
+++ /dev/null
@@ -1,770 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.framed;
-
-import java.io.IOException;
-import java.util.List;
-import java.util.logging.Logger;
-import okhttp3.Protocol;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.Source;
-import okio.Timeout;
-
-import static java.lang.String.format;
-import static java.util.logging.Level.FINE;
-import static okhttp3.internal.framed.Http2.FrameLogger.formatHeader;
-import static okio.ByteString.EMPTY;
-
-/**
- * Read and write HTTP/2 frames.
- *
- * <p>This implementation assumes we do not send an increased {@link Settings#getMaxFrameSize frame
- * size setting} to the peer. Hence, we expect all frames to have a max length of {@link
- * #INITIAL_MAX_FRAME_SIZE}. <p>http://tools.ietf.org/html/draft-ietf-httpbis-http2-17
- */
-public final class Http2 implements Variant {
-  private static final Logger logger = Logger.getLogger(FrameLogger.class.getName());
-
-  @Override public Protocol getProtocol() {
-    return Protocol.HTTP_2;
-  }
-
-  private static final ByteString CONNECTION_PREFACE
-      = ByteString.encodeUtf8("PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n");
-
-  /** The initial max frame size, applied independently writing to, or reading from the peer. */
-  static final int INITIAL_MAX_FRAME_SIZE = 0x4000; // 16384
-
-  static final byte TYPE_DATA = 0x0;
-  static final byte TYPE_HEADERS = 0x1;
-  static final byte TYPE_PRIORITY = 0x2;
-  static final byte TYPE_RST_STREAM = 0x3;
-  static final byte TYPE_SETTINGS = 0x4;
-  static final byte TYPE_PUSH_PROMISE = 0x5;
-  static final byte TYPE_PING = 0x6;
-  static final byte TYPE_GOAWAY = 0x7;
-  static final byte TYPE_WINDOW_UPDATE = 0x8;
-  static final byte TYPE_CONTINUATION = 0x9;
-
-  static final byte FLAG_NONE = 0x0;
-  static final byte FLAG_ACK = 0x1; // Used for settings and ping.
-  static final byte FLAG_END_STREAM = 0x1; // Used for headers and data.
-  static final byte FLAG_END_HEADERS = 0x4; // Used for headers and continuation.
-  static final byte FLAG_END_PUSH_PROMISE = 0x4;
-  static final byte FLAG_PADDED = 0x8; // Used for headers and data.
-  static final byte FLAG_PRIORITY = 0x20; // Used for headers.
-  static final byte FLAG_COMPRESSED = 0x20; // Used for data.
-
-  /**
-   * Creates a frame reader with max header table size of 4096 and data frame compression disabled.
-   */
-  @Override public FrameReader newReader(BufferedSource source, boolean client) {
-    return new Reader(source, 4096, client);
-  }
-
-  @Override public FrameWriter newWriter(BufferedSink sink, boolean client) {
-    return new Writer(sink, client);
-  }
-
-  static final class Reader implements FrameReader {
-    private final BufferedSource source;
-    private final ContinuationSource continuation;
-    private final boolean client;
-
-    // Visible for testing.
-    final Hpack.Reader hpackReader;
-
-    Reader(BufferedSource source, int headerTableSize, boolean client) {
-      this.source = source;
-      this.client = client;
-      this.continuation = new ContinuationSource(this.source);
-      this.hpackReader = new Hpack.Reader(headerTableSize, continuation);
-    }
-
-    @Override public void readConnectionPreface() throws IOException {
-      if (client) return; // Nothing to read; servers doesn't send a connection preface!
-      ByteString connectionPreface = source.readByteString(CONNECTION_PREFACE.size());
-      if (logger.isLoggable(FINE)) logger.fine(format("<< CONNECTION %s", connectionPreface.hex()));
-      if (!CONNECTION_PREFACE.equals(connectionPreface)) {
-        throw ioException("Expected a connection header but was %s", connectionPreface.utf8());
-      }
-    }
-
-    @Override public boolean nextFrame(Handler handler) throws IOException {
-      try {
-        source.require(9); // Frame header size
-      } catch (IOException e) {
-        return false; // This might be a normal socket close.
-      }
-
-      /*  0                   1                   2                   3
-       *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
-       * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-       * |                 Length (24)                   |
-       * +---------------+---------------+---------------+
-       * |   Type (8)    |   Flags (8)   |
-       * +-+-+-----------+---------------+-------------------------------+
-       * |R|                 Stream Identifier (31)                      |
-       * +=+=============================================================+
-       * |                   Frame Payload (0...)                      ...
-       * +---------------------------------------------------------------+
-       */
-      int length = readMedium(source);
-      if (length < 0 || length > INITIAL_MAX_FRAME_SIZE) {
-        throw ioException("FRAME_SIZE_ERROR: %s", length);
-      }
-      byte type = (byte) (source.readByte() & 0xff);
-      byte flags = (byte) (source.readByte() & 0xff);
-      int streamId = (source.readInt() & 0x7fffffff); // Ignore reserved bit.
-      if (logger.isLoggable(FINE)) logger.fine(formatHeader(true, streamId, length, type, flags));
-
-      switch (type) {
-        case TYPE_DATA:
-          readData(handler, length, flags, streamId);
-          break;
-
-        case TYPE_HEADERS:
-          readHeaders(handler, length, flags, streamId);
-          break;
-
-        case TYPE_PRIORITY:
-          readPriority(handler, length, flags, streamId);
-          break;
-
-        case TYPE_RST_STREAM:
-          readRstStream(handler, length, flags, streamId);
-          break;
-
-        case TYPE_SETTINGS:
-          readSettings(handler, length, flags, streamId);
-          break;
-
-        case TYPE_PUSH_PROMISE:
-          readPushPromise(handler, length, flags, streamId);
-          break;
-
-        case TYPE_PING:
-          readPing(handler, length, flags, streamId);
-          break;
-
-        case TYPE_GOAWAY:
-          readGoAway(handler, length, flags, streamId);
-          break;
-
-        case TYPE_WINDOW_UPDATE:
-          readWindowUpdate(handler, length, flags, streamId);
-          break;
-
-        default:
-          // Implementations MUST discard frames that have unknown or unsupported types.
-          source.skip(length);
-      }
-      return true;
-    }
-
-    private void readHeaders(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      if (streamId == 0) throw ioException("PROTOCOL_ERROR: TYPE_HEADERS streamId == 0");
-
-      boolean endStream = (flags & FLAG_END_STREAM) != 0;
-
-      short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
-
-      if ((flags & FLAG_PRIORITY) != 0) {
-        readPriority(handler, streamId);
-        length -= 5; // account for above read.
-      }
-
-      length = lengthWithoutPadding(length, flags, padding);
-
-      List<Header> headerBlock = readHeaderBlock(length, padding, flags, streamId);
-
-      handler.headers(false, endStream, streamId, -1, headerBlock, HeadersMode.HTTP_20_HEADERS);
-    }
-
-    private List<Header> readHeaderBlock(int length, short padding, byte flags, int streamId)
-        throws IOException {
-      continuation.length = continuation.left = length;
-      continuation.padding = padding;
-      continuation.flags = flags;
-      continuation.streamId = streamId;
-
-      // TODO: Concat multi-value headers with 0x0, except COOKIE, which uses 0x3B, 0x20.
-      // http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-8.1.2.5
-      hpackReader.readHeaders();
-      return hpackReader.getAndResetHeaderList();
-    }
-
-    private void readData(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      // TODO: checkState open or half-closed (local) or raise STREAM_CLOSED
-      boolean inFinished = (flags & FLAG_END_STREAM) != 0;
-      boolean gzipped = (flags & FLAG_COMPRESSED) != 0;
-      if (gzipped) {
-        throw ioException("PROTOCOL_ERROR: FLAG_COMPRESSED without SETTINGS_COMPRESS_DATA");
-      }
-
-      short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
-      length = lengthWithoutPadding(length, flags, padding);
-
-      handler.data(inFinished, streamId, source, length);
-      source.skip(padding);
-    }
-
-    private void readPriority(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      if (length != 5) throw ioException("TYPE_PRIORITY length: %d != 5", length);
-      if (streamId == 0) throw ioException("TYPE_PRIORITY streamId == 0");
-      readPriority(handler, streamId);
-    }
-
-    private void readPriority(Handler handler, int streamId) throws IOException {
-      int w1 = source.readInt();
-      boolean exclusive = (w1 & 0x80000000) != 0;
-      int streamDependency = (w1 & 0x7fffffff);
-      int weight = (source.readByte() & 0xff) + 1;
-      handler.priority(streamId, streamDependency, weight, exclusive);
-    }
-
-    private void readRstStream(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      if (length != 4) throw ioException("TYPE_RST_STREAM length: %d != 4", length);
-      if (streamId == 0) throw ioException("TYPE_RST_STREAM streamId == 0");
-      int errorCodeInt = source.readInt();
-      ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
-      if (errorCode == null) {
-        throw ioException("TYPE_RST_STREAM unexpected error code: %d", errorCodeInt);
-      }
-      handler.rstStream(streamId, errorCode);
-    }
-
-    private void readSettings(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      if (streamId != 0) throw ioException("TYPE_SETTINGS streamId != 0");
-      if ((flags & FLAG_ACK) != 0) {
-        if (length != 0) throw ioException("FRAME_SIZE_ERROR ack frame should be empty!");
-        handler.ackSettings();
-        return;
-      }
-
-      if (length % 6 != 0) throw ioException("TYPE_SETTINGS length %% 6 != 0: %s", length);
-      Settings settings = new Settings();
-      for (int i = 0; i < length; i += 6) {
-        short id = source.readShort();
-        int value = source.readInt();
-
-        switch (id) {
-          case 1: // SETTINGS_HEADER_TABLE_SIZE
-            break;
-          case 2: // SETTINGS_ENABLE_PUSH
-            if (value != 0 && value != 1) {
-              throw ioException("PROTOCOL_ERROR SETTINGS_ENABLE_PUSH != 0 or 1");
-            }
-            break;
-          case 3: // SETTINGS_MAX_CONCURRENT_STREAMS
-            id = 4; // Renumbered in draft 10.
-            break;
-          case 4: // SETTINGS_INITIAL_WINDOW_SIZE
-            id = 7; // Renumbered in draft 10.
-            if (value < 0) {
-              throw ioException("PROTOCOL_ERROR SETTINGS_INITIAL_WINDOW_SIZE > 2^31 - 1");
-            }
-            break;
-          case 5: // SETTINGS_MAX_FRAME_SIZE
-            if (value < INITIAL_MAX_FRAME_SIZE || value > 16777215) {
-              throw ioException("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: %s", value);
-            }
-            break;
-          case 6: // SETTINGS_MAX_HEADER_LIST_SIZE
-            break; // Advisory only, so ignored.
-          default:
-            break; // Must ignore setting with unknown id.
-        }
-        settings.set(id, 0, value);
-      }
-      handler.settings(false, settings);
-      if (settings.getHeaderTableSize() >= 0) {
-        hpackReader.headerTableSizeSetting(settings.getHeaderTableSize());
-      }
-    }
-
-    private void readPushPromise(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      if (streamId == 0) {
-        throw ioException("PROTOCOL_ERROR: TYPE_PUSH_PROMISE streamId == 0");
-      }
-      short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
-      int promisedStreamId = source.readInt() & 0x7fffffff;
-      length -= 4; // account for above read.
-      length = lengthWithoutPadding(length, flags, padding);
-      List<Header> headerBlock = readHeaderBlock(length, padding, flags, streamId);
-      handler.pushPromise(streamId, promisedStreamId, headerBlock);
-    }
-
-    private void readPing(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      if (length != 8) throw ioException("TYPE_PING length != 8: %s", length);
-      if (streamId != 0) throw ioException("TYPE_PING streamId != 0");
-      int payload1 = source.readInt();
-      int payload2 = source.readInt();
-      boolean ack = (flags & FLAG_ACK) != 0;
-      handler.ping(ack, payload1, payload2);
-    }
-
-    private void readGoAway(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      if (length < 8) throw ioException("TYPE_GOAWAY length < 8: %s", length);
-      if (streamId != 0) throw ioException("TYPE_GOAWAY streamId != 0");
-      int lastStreamId = source.readInt();
-      int errorCodeInt = source.readInt();
-      int opaqueDataLength = length - 8;
-      ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
-      if (errorCode == null) {
-        throw ioException("TYPE_GOAWAY unexpected error code: %d", errorCodeInt);
-      }
-      ByteString debugData = EMPTY;
-      if (opaqueDataLength > 0) { // Must read debug data in order to not corrupt the connection.
-        debugData = source.readByteString(opaqueDataLength);
-      }
-      handler.goAway(lastStreamId, errorCode, debugData);
-    }
-
-    private void readWindowUpdate(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      if (length != 4) throw ioException("TYPE_WINDOW_UPDATE length !=4: %s", length);
-      long increment = (source.readInt() & 0x7fffffffL);
-      if (increment == 0) throw ioException("windowSizeIncrement was 0", increment);
-      handler.windowUpdate(streamId, increment);
-    }
-
-    @Override public void close() throws IOException {
-      source.close();
-    }
-  }
-
-  static final class Writer implements FrameWriter {
-    private final BufferedSink sink;
-    private final boolean client;
-    private final Buffer hpackBuffer;
-    private final Hpack.Writer hpackWriter;
-    private int maxFrameSize;
-    private boolean closed;
-
-    Writer(BufferedSink sink, boolean client) {
-      this.sink = sink;
-      this.client = client;
-      this.hpackBuffer = new Buffer();
-      this.hpackWriter = new Hpack.Writer(hpackBuffer);
-      this.maxFrameSize = INITIAL_MAX_FRAME_SIZE;
-    }
-
-    @Override public synchronized void flush() throws IOException {
-      if (closed) throw new IOException("closed");
-      sink.flush();
-    }
-
-    @Override public synchronized void ackSettings(Settings peerSettings) throws IOException {
-      if (closed) throw new IOException("closed");
-      this.maxFrameSize = peerSettings.getMaxFrameSize(maxFrameSize);
-      int length = 0;
-      byte type = TYPE_SETTINGS;
-      byte flags = FLAG_ACK;
-      int streamId = 0;
-      frameHeader(streamId, length, type, flags);
-      sink.flush();
-    }
-
-    @Override public synchronized void connectionPreface() throws IOException {
-      if (closed) throw new IOException("closed");
-      if (!client) return; // Nothing to write; servers don't send connection headers!
-      if (logger.isLoggable(FINE)) {
-        logger.fine(format(">> CONNECTION %s", CONNECTION_PREFACE.hex()));
-      }
-      sink.write(CONNECTION_PREFACE.toByteArray());
-      sink.flush();
-    }
-
-    @Override public synchronized void synStream(boolean outFinished, boolean inFinished,
-        int streamId, int associatedStreamId, List<Header> headerBlock)
-        throws IOException {
-      if (inFinished) throw new UnsupportedOperationException();
-      if (closed) throw new IOException("closed");
-      headers(outFinished, streamId, headerBlock);
-    }
-
-    @Override public synchronized void synReply(boolean outFinished, int streamId,
-        List<Header> headerBlock) throws IOException {
-      if (closed) throw new IOException("closed");
-      headers(outFinished, streamId, headerBlock);
-    }
-
-    @Override public synchronized void headers(int streamId, List<Header> headerBlock)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      headers(false, streamId, headerBlock);
-    }
-
-    @Override public synchronized void pushPromise(int streamId, int promisedStreamId,
-        List<Header> requestHeaders) throws IOException {
-      if (closed) throw new IOException("closed");
-      hpackWriter.writeHeaders(requestHeaders);
-
-      long byteCount = hpackBuffer.size();
-      int length = (int) Math.min(maxFrameSize - 4, byteCount);
-      byte type = TYPE_PUSH_PROMISE;
-      byte flags = byteCount == length ? FLAG_END_HEADERS : 0;
-      frameHeader(streamId, length + 4, type, flags);
-      sink.writeInt(promisedStreamId & 0x7fffffff);
-      sink.write(hpackBuffer, length);
-
-      if (byteCount > length) writeContinuationFrames(streamId, byteCount - length);
-    }
-
-    void headers(boolean outFinished, int streamId, List<Header> headerBlock) throws IOException {
-      if (closed) throw new IOException("closed");
-      hpackWriter.writeHeaders(headerBlock);
-
-      long byteCount = hpackBuffer.size();
-      int length = (int) Math.min(maxFrameSize, byteCount);
-      byte type = TYPE_HEADERS;
-      byte flags = byteCount == length ? FLAG_END_HEADERS : 0;
-      if (outFinished) flags |= FLAG_END_STREAM;
-      frameHeader(streamId, length, type, flags);
-      sink.write(hpackBuffer, length);
-
-      if (byteCount > length) writeContinuationFrames(streamId, byteCount - length);
-    }
-
-    private void writeContinuationFrames(int streamId, long byteCount) throws IOException {
-      while (byteCount > 0) {
-        int length = (int) Math.min(maxFrameSize, byteCount);
-        byteCount -= length;
-        frameHeader(streamId, length, TYPE_CONTINUATION, byteCount == 0 ? FLAG_END_HEADERS : 0);
-        sink.write(hpackBuffer, length);
-      }
-    }
-
-    @Override public synchronized void rstStream(int streamId, ErrorCode errorCode)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      if (errorCode.httpCode == -1) throw new IllegalArgumentException();
-
-      int length = 4;
-      byte type = TYPE_RST_STREAM;
-      byte flags = FLAG_NONE;
-      frameHeader(streamId, length, type, flags);
-      sink.writeInt(errorCode.httpCode);
-      sink.flush();
-    }
-
-    @Override public int maxDataLength() {
-      return maxFrameSize;
-    }
-
-    @Override public synchronized void data(boolean outFinished, int streamId, Buffer source,
-        int byteCount) throws IOException {
-      if (closed) throw new IOException("closed");
-      byte flags = FLAG_NONE;
-      if (outFinished) flags |= FLAG_END_STREAM;
-      dataFrame(streamId, flags, source, byteCount);
-    }
-
-    void dataFrame(int streamId, byte flags, Buffer buffer, int byteCount) throws IOException {
-      byte type = TYPE_DATA;
-      frameHeader(streamId, byteCount, type, flags);
-      if (byteCount > 0) {
-        sink.write(buffer, byteCount);
-      }
-    }
-
-    @Override public synchronized void settings(Settings settings) throws IOException {
-      if (closed) throw new IOException("closed");
-      int length = settings.size() * 6;
-      byte type = TYPE_SETTINGS;
-      byte flags = FLAG_NONE;
-      int streamId = 0;
-      frameHeader(streamId, length, type, flags);
-      for (int i = 0; i < Settings.COUNT; i++) {
-        if (!settings.isSet(i)) continue;
-        int id = i;
-        if (id == 4) {
-          id = 3; // SETTINGS_MAX_CONCURRENT_STREAMS renumbered.
-        } else if (id == 7) {
-          id = 4; // SETTINGS_INITIAL_WINDOW_SIZE renumbered.
-        }
-        sink.writeShort(id);
-        sink.writeInt(settings.get(i));
-      }
-      sink.flush();
-    }
-
-    @Override public synchronized void ping(boolean ack, int payload1, int payload2)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      int length = 8;
-      byte type = TYPE_PING;
-      byte flags = ack ? FLAG_ACK : FLAG_NONE;
-      int streamId = 0;
-      frameHeader(streamId, length, type, flags);
-      sink.writeInt(payload1);
-      sink.writeInt(payload2);
-      sink.flush();
-    }
-
-    @Override public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode,
-        byte[] debugData) throws IOException {
-      if (closed) throw new IOException("closed");
-      if (errorCode.httpCode == -1) throw illegalArgument("errorCode.httpCode == -1");
-      int length = 8 + debugData.length;
-      byte type = TYPE_GOAWAY;
-      byte flags = FLAG_NONE;
-      int streamId = 0;
-      frameHeader(streamId, length, type, flags);
-      sink.writeInt(lastGoodStreamId);
-      sink.writeInt(errorCode.httpCode);
-      if (debugData.length > 0) {
-        sink.write(debugData);
-      }
-      sink.flush();
-    }
-
-    @Override public synchronized void windowUpdate(int streamId, long windowSizeIncrement)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      if (windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL) {
-        throw illegalArgument("windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: %s",
-            windowSizeIncrement);
-      }
-      int length = 4;
-      byte type = TYPE_WINDOW_UPDATE;
-      byte flags = FLAG_NONE;
-      frameHeader(streamId, length, type, flags);
-      sink.writeInt((int) windowSizeIncrement);
-      sink.flush();
-    }
-
-    @Override public synchronized void close() throws IOException {
-      closed = true;
-      sink.close();
-    }
-
-    void frameHeader(int streamId, int length, byte type, byte flags) throws IOException {
-      if (logger.isLoggable(FINE)) logger.fine(formatHeader(false, streamId, length, type, flags));
-      if (length > maxFrameSize) {
-        throw illegalArgument("FRAME_SIZE_ERROR length > %d: %d", maxFrameSize, length);
-      }
-      if ((streamId & 0x80000000) != 0) throw illegalArgument("reserved bit set: %s", streamId);
-      writeMedium(sink, length);
-      sink.writeByte(type & 0xff);
-      sink.writeByte(flags & 0xff);
-      sink.writeInt(streamId & 0x7fffffff);
-    }
-  }
-
-  private static IllegalArgumentException illegalArgument(String message, Object... args) {
-    throw new IllegalArgumentException(format(message, args));
-  }
-
-  private static IOException ioException(String message, Object... args) throws IOException {
-    throw new IOException(format(message, args));
-  }
-
-  /**
-   * Decompression of the header block occurs above the framing layer. This class lazily reads
-   * continuation frames as they are needed by {@link Hpack.Reader#readHeaders()}.
-   */
-  static final class ContinuationSource implements Source {
-    private final BufferedSource source;
-
-    int length;
-    byte flags;
-    int streamId;
-
-    int left;
-    short padding;
-
-    public ContinuationSource(BufferedSource source) {
-      this.source = source;
-    }
-
-    @Override public long read(Buffer sink, long byteCount) throws IOException {
-      while (left == 0) {
-        source.skip(padding);
-        padding = 0;
-        if ((flags & FLAG_END_HEADERS) != 0) return -1;
-        readContinuationHeader();
-        // TODO: test case for empty continuation header?
-      }
-
-      long read = source.read(sink, Math.min(byteCount, left));
-      if (read == -1) return -1;
-      left -= read;
-      return read;
-    }
-
-    @Override public Timeout timeout() {
-      return source.timeout();
-    }
-
-    @Override public void close() throws IOException {
-    }
-
-    private void readContinuationHeader() throws IOException {
-      int previousStreamId = streamId;
-
-      length = left = readMedium(source);
-      byte type = (byte) (source.readByte() & 0xff);
-      flags = (byte) (source.readByte() & 0xff);
-      if (logger.isLoggable(FINE)) logger.fine(formatHeader(true, streamId, length, type, flags));
-      streamId = (source.readInt() & 0x7fffffff);
-      if (type != TYPE_CONTINUATION) throw ioException("%s != TYPE_CONTINUATION", type);
-      if (streamId != previousStreamId) throw ioException("TYPE_CONTINUATION streamId changed");
-    }
-  }
-
-  private static int lengthWithoutPadding(int length, byte flags, short padding)
-      throws IOException {
-    if ((flags & FLAG_PADDED) != 0) length--; // Account for reading the padding length.
-    if (padding > length) {
-      throw ioException("PROTOCOL_ERROR padding %s > remaining length %s", padding, length);
-    }
-    return (short) (length - padding);
-  }
-
-  /**
-   * Logs a human-readable representation of HTTP/2 frame headers.
-   *
-   * <p>The format is:
-   *
-   * <pre>
-   *   direction streamID length type flags
-   * </pre>
-   * Where direction is {@code <<} for inbound and {@code >>} for outbound.
-   *
-   * <p>For example, the following would indicate a HEAD request sent from the client.
-   * <pre>
-   * {@code
-   *   << 0x0000000f    12 HEADERS       END_HEADERS|END_STREAM
-   * }
-   * </pre>
-   */
-  static final class FrameLogger {
-
-    static String formatHeader(boolean inbound, int streamId, int length, byte type, byte flags) {
-      String formattedType = type < TYPES.length ? TYPES[type] : format("0x%02x", type);
-      String formattedFlags = formatFlags(type, flags);
-      return format("%s 0x%08x %5d %-13s %s", inbound ? "<<" : ">>", streamId, length,
-          formattedType, formattedFlags);
-    }
-
-    /**
-     * Looks up valid string representing flags from the table. Invalid combinations are represented
-     * in binary.
-     */
-    // Visible for testing.
-    static String formatFlags(byte type, byte flags) {
-      if (flags == 0) return "";
-      switch (type) { // Special case types that have 0 or 1 flag.
-        case TYPE_SETTINGS:
-        case TYPE_PING:
-          return flags == FLAG_ACK ? "ACK" : BINARY[flags];
-        case TYPE_PRIORITY:
-        case TYPE_RST_STREAM:
-        case TYPE_GOAWAY:
-        case TYPE_WINDOW_UPDATE:
-          return BINARY[flags];
-      }
-      String result = flags < FLAGS.length ? FLAGS[flags] : BINARY[flags];
-      // Special case types that have overlap flag values.
-      if (type == TYPE_PUSH_PROMISE && (flags & FLAG_END_PUSH_PROMISE) != 0) {
-        return result.replace("HEADERS", "PUSH_PROMISE"); // TODO: Avoid allocation.
-      } else if (type == TYPE_DATA && (flags & FLAG_COMPRESSED) != 0) {
-        return result.replace("PRIORITY", "COMPRESSED"); // TODO: Avoid allocation.
-      }
-      return result;
-    }
-
-    /** Lookup table for valid frame types. */
-    private static final String[] TYPES = new String[] {
-        "DATA",
-        "HEADERS",
-        "PRIORITY",
-        "RST_STREAM",
-        "SETTINGS",
-        "PUSH_PROMISE",
-        "PING",
-        "GOAWAY",
-        "WINDOW_UPDATE",
-        "CONTINUATION"
-    };
-
-    /**
-     * Lookup table for valid flags for DATA, HEADERS, CONTINUATION. Invalid combinations are
-     * represented in binary.
-     */
-    private static final String[] FLAGS = new String[0x40]; // Highest bit flag is 0x20.
-    private static final String[] BINARY = new String[256];
-
-    static {
-      for (int i = 0; i < BINARY.length; i++) {
-        BINARY[i] = format("%8s", Integer.toBinaryString(i)).replace(' ', '0');
-      }
-
-      FLAGS[FLAG_NONE] = "";
-      FLAGS[FLAG_END_STREAM] = "END_STREAM";
-
-      int[] prefixFlags = new int[] {FLAG_END_STREAM};
-
-      FLAGS[FLAG_PADDED] = "PADDED";
-      for (int prefixFlag : prefixFlags) {
-        FLAGS[prefixFlag | FLAG_PADDED] = FLAGS[prefixFlag] + "|PADDED";
-      }
-
-      FLAGS[FLAG_END_HEADERS] = "END_HEADERS"; // Same as END_PUSH_PROMISE.
-      FLAGS[FLAG_PRIORITY] = "PRIORITY"; // Same as FLAG_COMPRESSED.
-      FLAGS[FLAG_END_HEADERS | FLAG_PRIORITY] = "END_HEADERS|PRIORITY"; // Only valid on HEADERS.
-      int[] frameFlags =
-          new int[] {FLAG_END_HEADERS, FLAG_PRIORITY, FLAG_END_HEADERS | FLAG_PRIORITY};
-
-      for (int frameFlag : frameFlags) {
-        for (int prefixFlag : prefixFlags) {
-          FLAGS[prefixFlag | frameFlag] = FLAGS[prefixFlag] + '|' + FLAGS[frameFlag];
-          FLAGS[prefixFlag | frameFlag | FLAG_PADDED] =
-              FLAGS[prefixFlag] + '|' + FLAGS[frameFlag] + "|PADDED";
-        }
-      }
-
-      for (int i = 0; i < FLAGS.length; i++) { // Fill in holes with binary representation.
-        if (FLAGS[i] == null) FLAGS[i] = BINARY[i];
-      }
-    }
-  }
-
-  private static int readMedium(BufferedSource source) throws IOException {
-    return (source.readByte() & 0xff) << 16
-        | (source.readByte() & 0xff) << 8
-        | (source.readByte() & 0xff);
-  }
-
-  private static void writeMedium(BufferedSink sink, int i) throws IOException {
-    sink.writeByte((i >>> 16) & 0xff);
-    sink.writeByte((i >>> 8) & 0xff);
-    sink.writeByte(i & 0xff);
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/NameValueBlockReader.java b/okhttp/src/main/java/okhttp3/internal/framed/NameValueBlockReader.java
deleted file mode 100644
index 75cd9594f7..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/framed/NameValueBlockReader.java
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.framed;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.zip.DataFormatException;
-import java.util.zip.Inflater;
-import okio.Buffer;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.ForwardingSource;
-import okio.InflaterSource;
-import okio.Okio;
-import okio.Source;
-
-/**
- * Reads a SPDY/3 Name/Value header block. This class is made complicated by the requirement that
- * we're strict with which bytes we put in the compressed bytes buffer. We need to put all
- * compressed bytes into that buffer -- but no other bytes.
- */
-class NameValueBlockReader {
-  /** This source transforms compressed bytes into uncompressed bytes. */
-  private final InflaterSource inflaterSource;
-
-  /**
-   * How many compressed bytes must be read into inflaterSource before {@link #readNameValueBlock}
-   * returns.
-   */
-  private int compressedLimit;
-
-  /** This source holds inflated bytes. */
-  private final BufferedSource source;
-
-  public NameValueBlockReader(BufferedSource source) {
-    // Limit the inflater input stream to only those bytes in the Name/Value
-    // block. We cut the inflater off at its source because we can't predict the
-    // ratio of compressed bytes to uncompressed bytes.
-    Source throttleSource = new ForwardingSource(source) {
-      @Override public long read(Buffer sink, long byteCount) throws IOException {
-        if (compressedLimit == 0) return -1; // Out of data for the current block.
-        long read = super.read(sink, Math.min(byteCount, compressedLimit));
-        if (read == -1) return -1;
-        compressedLimit -= read;
-        return read;
-      }
-    };
-
-    // Subclass inflater to install a dictionary when it's needed.
-    Inflater inflater = new Inflater() {
-      @Override public int inflate(byte[] buffer, int offset, int count)
-          throws DataFormatException {
-        int result = super.inflate(buffer, offset, count);
-        if (result == 0 && needsDictionary()) {
-          setDictionary(Spdy3.DICTIONARY);
-          result = super.inflate(buffer, offset, count);
-        }
-        return result;
-      }
-    };
-
-    this.inflaterSource = new InflaterSource(throttleSource, inflater);
-    this.source = Okio.buffer(inflaterSource);
-  }
-
-  public List<Header> readNameValueBlock(int length) throws IOException {
-    this.compressedLimit += length;
-
-    int numberOfPairs = source.readInt();
-    if (numberOfPairs < 0) throw new IOException("numberOfPairs < 0: " + numberOfPairs);
-    if (numberOfPairs > 1024) throw new IOException("numberOfPairs > 1024: " + numberOfPairs);
-
-    List<Header> entries = new ArrayList<>(numberOfPairs);
-    for (int i = 0; i < numberOfPairs; i++) {
-      ByteString name = readByteString().toAsciiLowercase();
-      ByteString values = readByteString();
-      if (name.size() == 0) throw new IOException("name.size == 0");
-      entries.add(new Header(name, values));
-    }
-
-    doneReading();
-    return entries;
-  }
-
-  private ByteString readByteString() throws IOException {
-    int length = source.readInt();
-    return source.readByteString(length);
-  }
-
-  private void doneReading() throws IOException {
-    // Move any outstanding unread bytes into the inflater. One side-effect of
-    // deflate compression is that sometimes there are bytes remaining in the
-    // stream after we've consumed all of the content.
-    if (compressedLimit > 0) {
-      inflaterSource.refill();
-      if (compressedLimit != 0) throw new IOException("compressedLimit > 0: " + compressedLimit);
-    }
-  }
-
-  public void close() throws IOException {
-    source.close();
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/Settings.java b/okhttp/src/main/java/okhttp3/internal/framed/Settings.java
deleted file mode 100644
index f4eab01731..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/framed/Settings.java
+++ /dev/null
@@ -1,239 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.framed;
-
-import java.util.Arrays;
-
-/**
- * Settings describe characteristics of the sending peer, which are used by the receiving peer.
- * Settings are {@link FramedConnection connection} scoped.
- */
-public final class Settings {
-  /**
-   * From the SPDY/3 and HTTP/2 specs, the default initial window size for all streams is 64 KiB.
-   * (Chrome 25 uses 10 MiB).
-   */
-  static final int DEFAULT_INITIAL_WINDOW_SIZE = 64 * 1024;
-
-  /** Peer request to clear durable settings. */
-  static final int FLAG_CLEAR_PREVIOUSLY_PERSISTED_SETTINGS = 0x1;
-
-  /** Sent by servers only. The peer requests this setting persisted for future connections. */
-  static final int PERSIST_VALUE = 0x1;
-  /** Sent by clients only. The client is reminding the server of a persisted value. */
-  static final int PERSISTED = 0x2;
-
-  /** spdy/3: Sender's estimate of max incoming kbps. */
-  static final int UPLOAD_BANDWIDTH = 1;
-  /** HTTP/2: Size in bytes of the table used to decode the sender's header blocks. */
-  static final int HEADER_TABLE_SIZE = 1;
-  /** spdy/3: Sender's estimate of max outgoing kbps. */
-  static final int DOWNLOAD_BANDWIDTH = 2;
-  /** HTTP/2: The peer must not send a PUSH_PROMISE frame when this is 0. */
-  static final int ENABLE_PUSH = 2;
-  /** spdy/3: Sender's estimate of millis between sending a request and receiving a response. */
-  static final int ROUND_TRIP_TIME = 3;
-  /** Sender's maximum number of concurrent streams. */
-  static final int MAX_CONCURRENT_STREAMS = 4;
-  /** spdy/3: Current CWND in Packets. */
-  static final int CURRENT_CWND = 5;
-  /** HTTP/2: Size in bytes of the largest frame payload the sender will accept. */
-  static final int MAX_FRAME_SIZE = 5;
-  /** spdy/3: Retransmission rate. Percentage */
-  static final int DOWNLOAD_RETRANS_RATE = 6;
-  /** HTTP/2: Advisory only. Size in bytes of the largest header list the sender will accept. */
-  static final int MAX_HEADER_LIST_SIZE = 6;
-  /** Window size in bytes. */
-  static final int INITIAL_WINDOW_SIZE = 7;
-  /** spdy/3: Size of the client certificate vector. Unsupported. */
-  static final int CLIENT_CERTIFICATE_VECTOR_SIZE = 8;
-  /** Flow control options. */
-  static final int FLOW_CONTROL_OPTIONS = 10;
-
-  /** Total number of settings. */
-  static final int COUNT = 10;
-
-  /** If set, flow control is disabled for streams directed to the sender of these settings. */
-  static final int FLOW_CONTROL_OPTIONS_DISABLED = 0x1;
-
-  /** Bitfield of which flags that values. */
-  private int set;
-
-  /** Bitfield of flags that have {@link #PERSIST_VALUE}. */
-  private int persistValue;
-
-  /** Bitfield of flags that have {@link #PERSISTED}. */
-  private int persisted;
-
-  /** Flag values. */
-  private final int[] values = new int[COUNT];
-
-  void clear() {
-    set = persistValue = persisted = 0;
-    Arrays.fill(values, 0);
-  }
-
-  Settings set(int id, int idFlags, int value) {
-    if (id >= values.length) {
-      return this; // Discard unknown settings.
-    }
-
-    int bit = 1 << id;
-    set |= bit;
-    if ((idFlags & PERSIST_VALUE) != 0) {
-      persistValue |= bit;
-    } else {
-      persistValue &= ~bit;
-    }
-    if ((idFlags & PERSISTED) != 0) {
-      persisted |= bit;
-    } else {
-      persisted &= ~bit;
-    }
-
-    values[id] = value;
-    return this;
-  }
-
-  /** Returns true if a value has been assigned for the setting {@code id}. */
-  boolean isSet(int id) {
-    int bit = 1 << id;
-    return (set & bit) != 0;
-  }
-
-  /** Returns the value for the setting {@code id}, or 0 if unset. */
-  int get(int id) {
-    return values[id];
-  }
-
-  /** Returns the flags for the setting {@code id}, or 0 if unset. */
-  int flags(int id) {
-    int result = 0;
-    if (isPersisted(id)) result |= Settings.PERSISTED;
-    if (persistValue(id)) result |= Settings.PERSIST_VALUE;
-    return result;
-  }
-
-  /** Returns the number of settings that have values assigned. */
-  int size() {
-    return Integer.bitCount(set);
-  }
-
-  /** spdy/3 only. */
-  int getUploadBandwidth(int defaultValue) {
-    int bit = 1 << UPLOAD_BANDWIDTH;
-    return (bit & set) != 0 ? values[UPLOAD_BANDWIDTH] : defaultValue;
-  }
-
-  /** HTTP/2 only. Returns -1 if unset. */
-  int getHeaderTableSize() {
-    int bit = 1 << HEADER_TABLE_SIZE;
-    return (bit & set) != 0 ? values[HEADER_TABLE_SIZE] : -1;
-  }
-
-  /** spdy/3 only. */
-  int getDownloadBandwidth(int defaultValue) {
-    int bit = 1 << DOWNLOAD_BANDWIDTH;
-    return (bit & set) != 0 ? values[DOWNLOAD_BANDWIDTH] : defaultValue;
-  }
-
-  /** HTTP/2 only. */
-  // TODO: honor this setting in HTTP/2.
-  boolean getEnablePush(boolean defaultValue) {
-    int bit = 1 << ENABLE_PUSH;
-    return ((bit & set) != 0 ? values[ENABLE_PUSH] : defaultValue ? 1 : 0) == 1;
-  }
-
-  /** spdy/3 only. */
-  int getRoundTripTime(int defaultValue) {
-    int bit = 1 << ROUND_TRIP_TIME;
-    return (bit & set) != 0 ? values[ROUND_TRIP_TIME] : defaultValue;
-  }
-
-  // TODO: honor this setting in spdy/3 and HTTP/2.
-  int getMaxConcurrentStreams(int defaultValue) {
-    int bit = 1 << MAX_CONCURRENT_STREAMS;
-    return (bit & set) != 0 ? values[MAX_CONCURRENT_STREAMS] : defaultValue;
-  }
-
-  /** spdy/3 only. */
-  int getCurrentCwnd(int defaultValue) {
-    int bit = 1 << CURRENT_CWND;
-    return (bit & set) != 0 ? values[CURRENT_CWND] : defaultValue;
-  }
-
-  /** HTTP/2 only. */
-  int getMaxFrameSize(int defaultValue) {
-    int bit = 1 << MAX_FRAME_SIZE;
-    return (bit & set) != 0 ? values[MAX_FRAME_SIZE] : defaultValue;
-  }
-
-  /** spdy/3 only. */
-  int getDownloadRetransRate(int defaultValue) {
-    int bit = 1 << DOWNLOAD_RETRANS_RATE;
-    return (bit & set) != 0 ? values[DOWNLOAD_RETRANS_RATE] : defaultValue;
-  }
-
-  /** HTTP/2 only. */
-  int getMaxHeaderListSize(int defaultValue) {
-    int bit = 1 << MAX_HEADER_LIST_SIZE;
-    return (bit & set) != 0 ? values[MAX_HEADER_LIST_SIZE] : defaultValue;
-  }
-
-  int getInitialWindowSize(int defaultValue) {
-    int bit = 1 << INITIAL_WINDOW_SIZE;
-    return (bit & set) != 0 ? values[INITIAL_WINDOW_SIZE] : defaultValue;
-  }
-
-  /** spdy/3 only. */
-  int getClientCertificateVectorSize(int defaultValue) {
-    int bit = 1 << CLIENT_CERTIFICATE_VECTOR_SIZE;
-    return (bit & set) != 0 ? values[CLIENT_CERTIFICATE_VECTOR_SIZE] : defaultValue;
-  }
-
-  // TODO: honor this setting in spdy/3 and HTTP/2.
-  boolean isFlowControlDisabled() {
-    int bit = 1 << FLOW_CONTROL_OPTIONS;
-    int value = (bit & set) != 0 ? values[FLOW_CONTROL_OPTIONS] : 0;
-    return (value & FLOW_CONTROL_OPTIONS_DISABLED) != 0;
-  }
-
-  /**
-   * Returns true if this user agent should use this setting in future spdy/3 connections to the
-   * same host.
-   */
-  boolean persistValue(int id) {
-    int bit = 1 << id;
-    return (persistValue & bit) != 0;
-  }
-
-  /** Returns true if this setting was persisted. */
-  boolean isPersisted(int id) {
-    int bit = 1 << id;
-    return (persisted & bit) != 0;
-  }
-
-  /**
-   * Writes {@code other} into this. If any setting is populated by this and {@code other}, the
-   * value and flags from {@code other} will be kept.
-   */
-  void merge(Settings other) {
-    for (int i = 0; i < COUNT; i++) {
-      if (!other.isSet(i)) continue;
-      set(i, other.flags(i), other.get(i));
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/Spdy3.java b/okhttp/src/main/java/okhttp3/internal/framed/Spdy3.java
deleted file mode 100644
index 72053e0066..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/framed/Spdy3.java
+++ /dev/null
@@ -1,491 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.framed;
-
-import java.io.IOException;
-import java.io.UnsupportedEncodingException;
-import java.net.ProtocolException;
-import java.util.List;
-import java.util.zip.Deflater;
-import okhttp3.Protocol;
-import okhttp3.internal.Util;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.DeflaterSink;
-import okio.Okio;
-
-/**
- * Read and write spdy/3.1 frames. http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1
- */
-public final class Spdy3 implements Variant {
-
-  @Override public Protocol getProtocol() {
-    return Protocol.SPDY_3;
-  }
-
-  static final int TYPE_DATA = 0x0;
-  static final int TYPE_SYN_STREAM = 0x1;
-  static final int TYPE_SYN_REPLY = 0x2;
-  static final int TYPE_RST_STREAM = 0x3;
-  static final int TYPE_SETTINGS = 0x4;
-  static final int TYPE_PING = 0x6;
-  static final int TYPE_GOAWAY = 0x7;
-  static final int TYPE_HEADERS = 0x8;
-  static final int TYPE_WINDOW_UPDATE = 0x9;
-
-  static final int FLAG_FIN = 0x1;
-  static final int FLAG_UNIDIRECTIONAL = 0x2;
-
-  static final int VERSION = 3;
-
-  static final byte[] DICTIONARY;
-
-  static {
-    try {
-      DICTIONARY = ("\u0000\u0000\u0000\u0007options\u0000\u0000\u0000\u0004hea"
-          + "d\u0000\u0000\u0000\u0004post\u0000\u0000\u0000\u0003put\u0000\u0000\u0000\u0006dele"
-          + "te\u0000\u0000\u0000\u0005trace\u0000\u0000\u0000\u0006accept\u0000\u0000\u0000"
-          + "\u000Eaccept-charset\u0000\u0000\u0000\u000Faccept-encoding\u0000\u0000\u0000\u000Fa"
-          + "ccept-language\u0000\u0000\u0000\raccept-ranges\u0000\u0000\u0000\u0003age\u0000"
-          + "\u0000\u0000\u0005allow\u0000\u0000\u0000\rauthorization\u0000\u0000\u0000\rcache-co"
-          + "ntrol\u0000\u0000\u0000\nconnection\u0000\u0000\u0000\fcontent-base\u0000\u0000"
-          + "\u0000\u0010content-encoding\u0000\u0000\u0000\u0010content-language\u0000\u0000"
-          + "\u0000\u000Econtent-length\u0000\u0000\u0000\u0010content-location\u0000\u0000\u0000"
-          + "\u000Bcontent-md5\u0000\u0000\u0000\rcontent-range\u0000\u0000\u0000\fcontent-type"
-          + "\u0000\u0000\u0000\u0004date\u0000\u0000\u0000\u0004etag\u0000\u0000\u0000\u0006expe"
-          + "ct\u0000\u0000\u0000\u0007expires\u0000\u0000\u0000\u0004from\u0000\u0000\u0000"
-          + "\u0004host\u0000\u0000\u0000\bif-match\u0000\u0000\u0000\u0011if-modified-since"
-          + "\u0000\u0000\u0000\rif-none-match\u0000\u0000\u0000\bif-range\u0000\u0000\u0000"
-          + "\u0013if-unmodified-since\u0000\u0000\u0000\rlast-modified\u0000\u0000\u0000\blocati"
-          + "on\u0000\u0000\u0000\fmax-forwards\u0000\u0000\u0000\u0006pragma\u0000\u0000\u0000"
-          + "\u0012proxy-authenticate\u0000\u0000\u0000\u0013proxy-authorization\u0000\u0000"
-          + "\u0000\u0005range\u0000\u0000\u0000\u0007referer\u0000\u0000\u0000\u000Bretry-after"
-          + "\u0000\u0000\u0000\u0006server\u0000\u0000\u0000\u0002te\u0000\u0000\u0000\u0007trai"
-          + "ler\u0000\u0000\u0000\u0011transfer-encoding\u0000\u0000\u0000\u0007upgrade\u0000"
-          + "\u0000\u0000\nuser-agent\u0000\u0000\u0000\u0004vary\u0000\u0000\u0000\u0003via"
-          + "\u0000\u0000\u0000\u0007warning\u0000\u0000\u0000\u0010www-authenticate\u0000\u0000"
-          + "\u0000\u0006method\u0000\u0000\u0000\u0003get\u0000\u0000\u0000\u0006status\u0000"
-          + "\u0000\u0000\u0006200 OK\u0000\u0000\u0000\u0007version\u0000\u0000\u0000\bHTTP/1.1"
-          + "\u0000\u0000\u0000\u0003url\u0000\u0000\u0000\u0006public\u0000\u0000\u0000\nset-coo"
-          + "kie\u0000\u0000\u0000\nkeep-alive\u0000\u0000\u0000\u0006origin100101201202205206300"
-          + "302303304305306307402405406407408409410411412413414415416417502504505203 Non-Authori"
-          + "tative Information204 No Content301 Moved Permanently400 Bad Request401 Unauthorized"
-          + "403 Forbidden404 Not Found500 Internal Server Error501 Not Implemented503 Service Un"
-          + "availableJan Feb Mar Apr May Jun Jul Aug Sept Oct Nov Dec 00:00:00 Mon, Tue, Wed, Th"
-          + "u, Fri, Sat, Sun, GMTchunked,text/html,image/png,image/jpg,image/gif,application/xml"
-          + ",application/xhtml+xml,text/plain,text/javascript,publicprivatemax-age=gzip,deflate,"
-          + "sdchcharset=utf-8charset=iso-8859-1,utf-,*,enq=0.").getBytes(Util.UTF_8.name());
-    } catch (UnsupportedEncodingException e) {
-      throw new AssertionError();
-    }
-  }
-
-  @Override public FrameReader newReader(BufferedSource source, boolean client) {
-    return new Reader(source, client);
-  }
-
-  @Override public FrameWriter newWriter(BufferedSink sink, boolean client) {
-    return new Writer(sink, client);
-  }
-
-  /** Read spdy/3 frames. */
-  static final class Reader implements FrameReader {
-    private final BufferedSource source;
-    private final boolean client;
-    private final NameValueBlockReader headerBlockReader;
-
-    Reader(BufferedSource source, boolean client) {
-      this.source = source;
-      this.headerBlockReader = new NameValueBlockReader(this.source);
-      this.client = client;
-    }
-
-    @Override public void readConnectionPreface() {
-    }
-
-    /**
-     * Send the next frame to {@code handler}. Returns true unless there are no more frames on the
-     * stream.
-     */
-    @Override public boolean nextFrame(Handler handler) throws IOException {
-      int w1;
-      int w2;
-      try {
-        w1 = source.readInt();
-        w2 = source.readInt();
-      } catch (IOException e) {
-        return false; // This might be a normal socket close.
-      }
-
-      boolean control = (w1 & 0x80000000) != 0;
-      int flags = (w2 & 0xff000000) >>> 24;
-      int length = (w2 & 0xffffff);
-
-      if (control) {
-        int version = (w1 & 0x7fff0000) >>> 16;
-        int type = (w1 & 0xffff);
-
-        if (version != 3) {
-          throw new ProtocolException("version != 3: " + version);
-        }
-
-        switch (type) {
-          case TYPE_SYN_STREAM:
-            readSynStream(handler, flags, length);
-            return true;
-
-          case TYPE_SYN_REPLY:
-            readSynReply(handler, flags, length);
-            return true;
-
-          case TYPE_RST_STREAM:
-            readRstStream(handler, flags, length);
-            return true;
-
-          case TYPE_SETTINGS:
-            readSettings(handler, flags, length);
-            return true;
-
-          case TYPE_PING:
-            readPing(handler, flags, length);
-            return true;
-
-          case TYPE_GOAWAY:
-            readGoAway(handler, flags, length);
-            return true;
-
-          case TYPE_HEADERS:
-            readHeaders(handler, flags, length);
-            return true;
-
-          case TYPE_WINDOW_UPDATE:
-            readWindowUpdate(handler, flags, length);
-            return true;
-
-          default:
-            source.skip(length);
-            return true;
-        }
-      } else {
-        int streamId = w1 & 0x7fffffff;
-        boolean inFinished = (flags & FLAG_FIN) != 0;
-        handler.data(inFinished, streamId, source, length);
-        return true;
-      }
-    }
-
-    private void readSynStream(Handler handler, int flags, int length) throws IOException {
-      int w1 = source.readInt();
-      int w2 = source.readInt();
-      int streamId = w1 & 0x7fffffff;
-      int associatedStreamId = w2 & 0x7fffffff;
-      source.readShort(); // int priority = (s3 & 0xe000) >>> 13; int slot = s3 & 0xff;
-      List<Header> headerBlock = headerBlockReader.readNameValueBlock(length - 10);
-
-      boolean inFinished = (flags & FLAG_FIN) != 0;
-      boolean outFinished = (flags & FLAG_UNIDIRECTIONAL) != 0;
-      handler.headers(outFinished, inFinished, streamId, associatedStreamId, headerBlock,
-          HeadersMode.SPDY_SYN_STREAM);
-    }
-
-    private void readSynReply(Handler handler, int flags, int length) throws IOException {
-      int w1 = source.readInt();
-      int streamId = w1 & 0x7fffffff;
-      List<Header> headerBlock = headerBlockReader.readNameValueBlock(length - 4);
-      boolean inFinished = (flags & FLAG_FIN) != 0;
-      handler.headers(false, inFinished, streamId, -1, headerBlock, HeadersMode.SPDY_REPLY);
-    }
-
-    private void readRstStream(Handler handler, int flags, int length) throws IOException {
-      if (length != 8) throw ioException("TYPE_RST_STREAM length: %d != 8", length);
-      int streamId = source.readInt() & 0x7fffffff;
-      int errorCodeInt = source.readInt();
-      ErrorCode errorCode = ErrorCode.fromSpdy3Rst(errorCodeInt);
-      if (errorCode == null) {
-        throw ioException("TYPE_RST_STREAM unexpected error code: %d", errorCodeInt);
-      }
-      handler.rstStream(streamId, errorCode);
-    }
-
-    private void readHeaders(Handler handler, int flags, int length) throws IOException {
-      int w1 = source.readInt();
-      int streamId = w1 & 0x7fffffff;
-      List<Header> headerBlock = headerBlockReader.readNameValueBlock(length - 4);
-      handler.headers(false, false, streamId, -1, headerBlock, HeadersMode.SPDY_HEADERS);
-    }
-
-    private void readWindowUpdate(Handler handler, int flags, int length) throws IOException {
-      if (length != 8) throw ioException("TYPE_WINDOW_UPDATE length: %d != 8", length);
-      int w1 = source.readInt();
-      int w2 = source.readInt();
-      int streamId = w1 & 0x7fffffff;
-      long increment = w2 & 0x7fffffff;
-      if (increment == 0) throw ioException("windowSizeIncrement was 0", increment);
-      handler.windowUpdate(streamId, increment);
-    }
-
-    private void readPing(Handler handler, int flags, int length) throws IOException {
-      if (length != 4) throw ioException("TYPE_PING length: %d != 4", length);
-      int id = source.readInt();
-      boolean ack = client == ((id & 1) == 1);
-      handler.ping(ack, id, 0);
-    }
-
-    private void readGoAway(Handler handler, int flags, int length) throws IOException {
-      if (length != 8) throw ioException("TYPE_GOAWAY length: %d != 8", length);
-      int lastGoodStreamId = source.readInt() & 0x7fffffff;
-      int errorCodeInt = source.readInt();
-      ErrorCode errorCode = ErrorCode.fromSpdyGoAway(errorCodeInt);
-      if (errorCode == null) {
-        throw ioException("TYPE_GOAWAY unexpected error code: %d", errorCodeInt);
-      }
-      handler.goAway(lastGoodStreamId, errorCode, ByteString.EMPTY);
-    }
-
-    private void readSettings(Handler handler, int flags, int length) throws IOException {
-      int numberOfEntries = source.readInt();
-      if (length != 4 + 8 * numberOfEntries) {
-        throw ioException("TYPE_SETTINGS length: %d != 4 + 8 * %d", length, numberOfEntries);
-      }
-      Settings settings = new Settings();
-      for (int i = 0; i < numberOfEntries; i++) {
-        int w1 = source.readInt();
-        int value = source.readInt();
-        int idFlags = (w1 & 0xff000000) >>> 24;
-        int id = w1 & 0xffffff;
-        settings.set(id, idFlags, value);
-      }
-      boolean clearPrevious = (flags & Settings.FLAG_CLEAR_PREVIOUSLY_PERSISTED_SETTINGS) != 0;
-      handler.settings(clearPrevious, settings);
-    }
-
-    private static IOException ioException(String message, Object... args) throws IOException {
-      throw new IOException(String.format(message, args));
-    }
-
-    @Override public void close() throws IOException {
-      headerBlockReader.close();
-    }
-  }
-
-  /** Write spdy/3 frames. */
-  static final class Writer implements FrameWriter {
-    private final BufferedSink sink;
-    private final Buffer headerBlockBuffer;
-    private final BufferedSink headerBlockOut;
-    private final boolean client;
-    private boolean closed;
-
-    Writer(BufferedSink sink, boolean client) {
-      this.sink = sink;
-      this.client = client;
-
-      Deflater deflater = new Deflater();
-      deflater.setDictionary(DICTIONARY);
-      headerBlockBuffer = new Buffer();
-      headerBlockOut = Okio.buffer(new DeflaterSink(headerBlockBuffer, deflater));
-    }
-
-    @Override public void ackSettings(Settings peerSettings) {
-      // Do nothing: no ACK for SPDY/3 settings.
-    }
-
-    @Override
-    public void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
-        throws IOException {
-      // Do nothing: no push promise for SPDY/3.
-    }
-
-    @Override public synchronized void connectionPreface() {
-      // Do nothing: no connection preface for SPDY/3.
-    }
-
-    @Override public synchronized void flush() throws IOException {
-      if (closed) throw new IOException("closed");
-      sink.flush();
-    }
-
-    @Override public synchronized void synStream(boolean outFinished, boolean inFinished,
-        int streamId, int associatedStreamId, List<Header> headerBlock)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      writeNameValueBlockToBuffer(headerBlock);
-      int length = (int) (10 + headerBlockBuffer.size());
-      int type = TYPE_SYN_STREAM;
-      int flags = (outFinished ? FLAG_FIN : 0) | (inFinished ? FLAG_UNIDIRECTIONAL : 0);
-
-      int unused = 0;
-      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      sink.writeInt(streamId & 0x7fffffff);
-      sink.writeInt(associatedStreamId & 0x7fffffff);
-      sink.writeShort((unused & 0x7) << 13 | (unused & 0x1f) << 8 | (unused & 0xff));
-      sink.writeAll(headerBlockBuffer);
-      sink.flush();
-    }
-
-    @Override public synchronized void synReply(boolean outFinished, int streamId,
-        List<Header> headerBlock) throws IOException {
-      if (closed) throw new IOException("closed");
-      writeNameValueBlockToBuffer(headerBlock);
-      int type = TYPE_SYN_REPLY;
-      int flags = (outFinished ? FLAG_FIN : 0);
-      int length = (int) (headerBlockBuffer.size() + 4);
-
-      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      sink.writeInt(streamId & 0x7fffffff);
-      sink.writeAll(headerBlockBuffer);
-      sink.flush();
-    }
-
-    @Override public synchronized void headers(int streamId, List<Header> headerBlock)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      writeNameValueBlockToBuffer(headerBlock);
-      int flags = 0;
-      int type = TYPE_HEADERS;
-      int length = (int) (headerBlockBuffer.size() + 4);
-
-      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      sink.writeInt(streamId & 0x7fffffff);
-      sink.writeAll(headerBlockBuffer);
-    }
-
-    @Override public synchronized void rstStream(int streamId, ErrorCode errorCode)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      if (errorCode.spdyRstCode == -1) throw new IllegalArgumentException();
-      int flags = 0;
-      int type = TYPE_RST_STREAM;
-      int length = 8;
-      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      sink.writeInt(streamId & 0x7fffffff);
-      sink.writeInt(errorCode.spdyRstCode);
-      sink.flush();
-    }
-
-    @Override public int maxDataLength() {
-      return 16383;
-    }
-
-    @Override public synchronized void data(boolean outFinished, int streamId, Buffer source,
-        int byteCount) throws IOException {
-      int flags = (outFinished ? FLAG_FIN : 0);
-      sendDataFrame(streamId, flags, source, byteCount);
-    }
-
-    void sendDataFrame(int streamId, int flags, Buffer buffer, int byteCount)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      if (byteCount > 0xffffffL) {
-        throw new IllegalArgumentException("FRAME_TOO_LARGE max size is 16Mib: " + byteCount);
-      }
-      sink.writeInt(streamId & 0x7fffffff);
-      sink.writeInt((flags & 0xff) << 24 | byteCount & 0xffffff);
-      if (byteCount > 0) {
-        sink.write(buffer, byteCount);
-      }
-    }
-
-    private void writeNameValueBlockToBuffer(List<Header> headerBlock) throws IOException {
-      headerBlockOut.writeInt(headerBlock.size());
-      for (int i = 0, size = headerBlock.size(); i < size; i++) {
-        ByteString name = headerBlock.get(i).name;
-        headerBlockOut.writeInt(name.size());
-        headerBlockOut.write(name);
-        ByteString value = headerBlock.get(i).value;
-        headerBlockOut.writeInt(value.size());
-        headerBlockOut.write(value);
-      }
-      headerBlockOut.flush();
-    }
-
-    @Override public synchronized void settings(Settings settings) throws IOException {
-      if (closed) throw new IOException("closed");
-      int type = TYPE_SETTINGS;
-      int flags = 0;
-      int size = settings.size();
-      int length = 4 + size * 8;
-      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      sink.writeInt(size);
-      for (int i = 0; i <= Settings.COUNT; i++) {
-        if (!settings.isSet(i)) continue;
-        int settingsFlags = settings.flags(i);
-        sink.writeInt((settingsFlags & 0xff) << 24 | (i & 0xffffff));
-        sink.writeInt(settings.get(i));
-      }
-      sink.flush();
-    }
-
-    @Override public synchronized void ping(boolean reply, int payload1, int payload2)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      boolean payloadIsReply = client != ((payload1 & 1) == 1);
-      if (reply != payloadIsReply) throw new IllegalArgumentException("payload != reply");
-      int type = TYPE_PING;
-      int flags = 0;
-      int length = 4;
-      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      sink.writeInt(payload1);
-      sink.flush();
-    }
-
-    @Override public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode,
-        byte[] ignored) throws IOException {
-      if (closed) throw new IOException("closed");
-      if (errorCode.spdyGoAwayCode == -1) {
-        throw new IllegalArgumentException("errorCode.spdyGoAwayCode == -1");
-      }
-      int type = TYPE_GOAWAY;
-      int flags = 0;
-      int length = 8;
-      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      sink.writeInt(lastGoodStreamId);
-      sink.writeInt(errorCode.spdyGoAwayCode);
-      sink.flush();
-    }
-
-    @Override public synchronized void windowUpdate(int streamId, long increment)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      if (increment == 0 || increment > 0x7fffffffL) {
-        throw new IllegalArgumentException(
-            "windowSizeIncrement must be between 1 and 0x7fffffff: " + increment);
-      }
-      int type = TYPE_WINDOW_UPDATE;
-      int flags = 0;
-      int length = 8;
-      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      sink.writeInt(streamId);
-      sink.writeInt((int) increment);
-      sink.flush();
-    }
-
-    @Override public synchronized void close() throws IOException {
-      closed = true;
-      Util.closeAll(sink, headerBlockOut);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
new file mode 100644
index 0000000000..f8a720ff8a
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
@@ -0,0 +1,127 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3.internal.http;
+
+import java.io.IOException;
+import java.util.List;
+import okhttp3.Cookie;
+import okhttp3.CookieJar;
+import okhttp3.Headers;
+import okhttp3.Interceptor;
+import okhttp3.MediaType;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.internal.Version;
+import okio.GzipSource;
+import okio.Okio;
+
+import static okhttp3.internal.Util.hostHeader;
+
+/**
+ * Bridges from application code to network code. First it builds a network request from a user
+ * request. Then it proceeds to call the network. Finally it builds a user response from the network
+ * response.
+ */
+public final class BridgeInterceptor implements Interceptor {
+  private final CookieJar cookieJar;
+
+  public BridgeInterceptor(CookieJar cookieJar) {
+    this.cookieJar = cookieJar;
+  }
+
+  @Override public Response intercept(Chain chain) throws IOException {
+    Request userRequest = chain.request();
+    Request.Builder requestBuilder = userRequest.newBuilder();
+
+    RequestBody body = userRequest.body();
+    if (body != null) {
+      MediaType contentType = body.contentType();
+      if (contentType != null) {
+        requestBuilder.header("Content-Type", contentType.toString());
+      }
+
+      long contentLength = body.contentLength();
+      if (contentLength != -1) {
+        requestBuilder.header("Content-Length", Long.toString(contentLength));
+        requestBuilder.removeHeader("Transfer-Encoding");
+      } else {
+        requestBuilder.header("Transfer-Encoding", "chunked");
+        requestBuilder.removeHeader("Content-Length");
+      }
+    }
+
+    if (userRequest.header("Host") == null) {
+      requestBuilder.header("Host", hostHeader(userRequest.url(), false));
+    }
+
+    if (userRequest.header("Connection") == null) {
+      requestBuilder.header("Connection", "Keep-Alive");
+    }
+
+    // If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing
+    // the transfer stream.
+    boolean transparentGzip = false;
+    if (userRequest.header("Accept-Encoding") == null) {
+      transparentGzip = true;
+      requestBuilder.header("Accept-Encoding", "gzip");
+    }
+
+    List<Cookie> cookies = cookieJar.loadForRequest(userRequest.url());
+    if (!cookies.isEmpty()) {
+      requestBuilder.header("Cookie", cookieHeader(cookies));
+    }
+
+    if (userRequest.header("User-Agent") == null) {
+      requestBuilder.header("User-Agent", Version.userAgent());
+    }
+
+    Response networkResponse = chain.proceed(requestBuilder.build());
+
+    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());
+
+    Response.Builder responseBuilder = networkResponse.newBuilder()
+        .request(userRequest);
+
+    if (transparentGzip
+        && "gzip".equalsIgnoreCase(networkResponse.header("Content-Encoding"))
+        && HttpHeaders.hasBody(networkResponse)) {
+      GzipSource responseBody = new GzipSource(networkResponse.body().source());
+      Headers strippedHeaders = networkResponse.headers().newBuilder()
+          .removeAll("Content-Encoding")
+          .removeAll("Content-Length")
+          .build();
+      responseBuilder.headers(strippedHeaders);
+      responseBuilder.body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));
+    }
+
+    return responseBuilder.build();
+  }
+
+  /** Returns a 'Cookie' HTTP request header with all cookies, like {@code a=b; c=d}. */
+  private String cookieHeader(List<Cookie> cookies) {
+    StringBuilder cookieHeader = new StringBuilder();
+    for (int i = 0, size = cookies.size(); i < size; i++) {
+      if (i > 0) {
+        cookieHeader.append("; ");
+      }
+      Cookie cookie = cookies.get(i);
+      cookieHeader.append(cookie.name()).append('=').append(cookie.value());
+    }
+    return cookieHeader.toString();
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
new file mode 100644
index 0000000000..6adbc28b56
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http;
+
+import java.io.IOException;
+import java.net.ProtocolException;
+import okhttp3.Interceptor;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.Util;
+import okhttp3.internal.connection.StreamAllocation;
+import okio.BufferedSink;
+import okio.Okio;
+import okio.Sink;
+
+/** This is the last interceptor in the chain. It makes a network call to the server. */
+public final class CallServerInterceptor implements Interceptor {
+  private final boolean forWebSocket;
+
+  public CallServerInterceptor(boolean forWebSocket) {
+    this.forWebSocket = forWebSocket;
+  }
+
+  @Override public Response intercept(Chain chain) throws IOException {
+    HttpCodec httpCodec = ((RealInterceptorChain) chain).httpStream();
+    StreamAllocation streamAllocation = ((RealInterceptorChain) chain).streamAllocation();
+    Request request = chain.request();
+
+    long sentRequestMillis = System.currentTimeMillis();
+    httpCodec.writeRequestHeaders(request);
+
+    if (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {
+      Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());
+      BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
+      request.body().writeTo(bufferedRequestBody);
+      bufferedRequestBody.close();
+    }
+
+    httpCodec.finishRequest();
+
+    Response response = httpCodec.readResponseHeaders()
+        .request(request)
+        .handshake(streamAllocation.connection().handshake())
+        .sentRequestAtMillis(sentRequestMillis)
+        .receivedResponseAtMillis(System.currentTimeMillis())
+        .build();
+
+    int code = response.code();
+    if (forWebSocket && code == 101) {
+      // Connection is upgrading, but we need to ensure interceptors see a non-null response body.
+      response = response.newBuilder()
+          .body(Util.EMPTY_RESPONSE)
+          .build();
+    } else {
+      response = response.newBuilder()
+          .body(httpCodec.openResponseBody(response))
+          .build();
+    }
+
+    if ("close".equalsIgnoreCase(response.request().header("Connection"))
+        || "close".equalsIgnoreCase(response.header("Connection"))) {
+      streamAllocation.noNewStreams();
+    }
+
+    if ((code == 204 || code == 205) && response.body().contentLength() > 0) {
+      throw new ProtocolException(
+          "HTTP " + code + " had non-zero Content-Length: " + response.body().contentLength());
+    }
+
+    return response;
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HeaderParser.java b/okhttp/src/main/java/okhttp3/internal/http/HeaderParser.java
deleted file mode 100644
index 1e27c988c4..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http/HeaderParser.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http;
-
-public final class HeaderParser {
-  /**
-   * Returns the next index in {@code input} at or after {@code pos} that contains a character from
-   * {@code characters}. Returns the input length if none of the requested characters can be found.
-   */
-  public static int skipUntil(String input, int pos, String characters) {
-    for (; pos < input.length(); pos++) {
-      if (characters.indexOf(input.charAt(pos)) != -1) {
-        break;
-      }
-    }
-    return pos;
-  }
-
-  /**
-   * Returns the next non-whitespace character in {@code input} that is white space. Result is
-   * undefined if input contains newline characters.
-   */
-  public static int skipWhitespace(String input, int pos) {
-    for (; pos < input.length(); pos++) {
-      char c = input.charAt(pos);
-      if (c != ' ' && c != '\t') {
-        break;
-      }
-    }
-    return pos;
-  }
-
-  /**
-   * Returns {@code value} as a positive integer, or 0 if it is negative, or {@code defaultValue} if
-   * it cannot be parsed.
-   */
-  public static int parseSeconds(String value, int defaultValue) {
-    try {
-      long seconds = Long.parseLong(value);
-      if (seconds > Integer.MAX_VALUE) {
-        return Integer.MAX_VALUE;
-      } else if (seconds < 0) {
-        return 0;
-      } else {
-        return (int) seconds;
-      }
-    } catch (NumberFormatException e) {
-      return defaultValue;
-    }
-  }
-
-  private HeaderParser() {
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java b/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java
deleted file mode 100644
index 99151f8371..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java
+++ /dev/null
@@ -1,295 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http;
-
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.util.ArrayList;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Locale;
-import java.util.Set;
-import java.util.concurrent.TimeUnit;
-import okhttp3.Headers;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.internal.Util;
-import okhttp3.internal.framed.ErrorCode;
-import okhttp3.internal.framed.FramedConnection;
-import okhttp3.internal.framed.FramedStream;
-import okhttp3.internal.framed.Header;
-import okio.ByteString;
-import okio.ForwardingSource;
-import okio.Okio;
-import okio.Sink;
-import okio.Source;
-
-import static okhttp3.internal.framed.Header.RESPONSE_STATUS;
-import static okhttp3.internal.framed.Header.TARGET_AUTHORITY;
-import static okhttp3.internal.framed.Header.TARGET_HOST;
-import static okhttp3.internal.framed.Header.TARGET_METHOD;
-import static okhttp3.internal.framed.Header.TARGET_PATH;
-import static okhttp3.internal.framed.Header.TARGET_SCHEME;
-import static okhttp3.internal.framed.Header.VERSION;
-
-/** An HTTP stream for HTTP/2 and SPDY. */
-public final class Http2xStream implements HttpStream {
-  private static final ByteString CONNECTION = ByteString.encodeUtf8("connection");
-  private static final ByteString HOST = ByteString.encodeUtf8("host");
-  private static final ByteString KEEP_ALIVE = ByteString.encodeUtf8("keep-alive");
-  private static final ByteString PROXY_CONNECTION = ByteString.encodeUtf8("proxy-connection");
-  private static final ByteString TRANSFER_ENCODING = ByteString.encodeUtf8("transfer-encoding");
-  private static final ByteString TE = ByteString.encodeUtf8("te");
-  private static final ByteString ENCODING = ByteString.encodeUtf8("encoding");
-  private static final ByteString UPGRADE = ByteString.encodeUtf8("upgrade");
-
-  /** See http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1#TOC-3.2.1-Request. */
-  private static final List<ByteString> SPDY_3_SKIPPED_REQUEST_HEADERS = Util.immutableList(
-      CONNECTION,
-      HOST,
-      KEEP_ALIVE,
-      PROXY_CONNECTION,
-      TRANSFER_ENCODING,
-      TARGET_METHOD,
-      TARGET_PATH,
-      TARGET_SCHEME,
-      TARGET_AUTHORITY,
-      TARGET_HOST,
-      VERSION);
-  private static final List<ByteString> SPDY_3_SKIPPED_RESPONSE_HEADERS = Util.immutableList(
-      CONNECTION,
-      HOST,
-      KEEP_ALIVE,
-      PROXY_CONNECTION,
-      TRANSFER_ENCODING);
-
-  /** See http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-8.1.3. */
-  private static final List<ByteString> HTTP_2_SKIPPED_REQUEST_HEADERS = Util.immutableList(
-      CONNECTION,
-      HOST,
-      KEEP_ALIVE,
-      PROXY_CONNECTION,
-      TE,
-      TRANSFER_ENCODING,
-      ENCODING,
-      UPGRADE,
-      TARGET_METHOD,
-      TARGET_PATH,
-      TARGET_SCHEME,
-      TARGET_AUTHORITY,
-      TARGET_HOST,
-      VERSION);
-  private static final List<ByteString> HTTP_2_SKIPPED_RESPONSE_HEADERS = Util.immutableList(
-      CONNECTION,
-      HOST,
-      KEEP_ALIVE,
-      PROXY_CONNECTION,
-      TE,
-      TRANSFER_ENCODING,
-      ENCODING,
-      UPGRADE);
-
-  private final StreamAllocation streamAllocation;
-  private final FramedConnection framedConnection;
-  private HttpEngine httpEngine;
-  private FramedStream stream;
-
-  public Http2xStream(StreamAllocation streamAllocation, FramedConnection framedConnection) {
-    this.streamAllocation = streamAllocation;
-    this.framedConnection = framedConnection;
-  }
-
-  @Override public void setHttpEngine(HttpEngine httpEngine) {
-    this.httpEngine = httpEngine;
-  }
-
-  @Override public Sink createRequestBody(Request request, long contentLength) throws IOException {
-    return stream.getSink();
-  }
-
-  @Override public void writeRequestHeaders(Request request) throws IOException {
-    if (stream != null) return;
-
-    httpEngine.writingRequestHeaders();
-    boolean permitsRequestBody = httpEngine.permitsRequestBody(request);
-    List<Header> requestHeaders = framedConnection.getProtocol() == Protocol.HTTP_2
-        ? http2HeadersList(request)
-        : spdy3HeadersList(request);
-    boolean hasResponseBody = true;
-    stream = framedConnection.newStream(requestHeaders, permitsRequestBody, hasResponseBody);
-    stream.readTimeout().timeout(httpEngine.client.readTimeoutMillis(), TimeUnit.MILLISECONDS);
-    stream.writeTimeout().timeout(httpEngine.client.writeTimeoutMillis(), TimeUnit.MILLISECONDS);
-  }
-
-  @Override public void writeRequestBody(RetryableSink requestBody) throws IOException {
-    requestBody.writeToSocket(stream.getSink());
-  }
-
-  @Override public void finishRequest() throws IOException {
-    stream.getSink().close();
-  }
-
-  @Override public Response.Builder readResponseHeaders() throws IOException {
-    return framedConnection.getProtocol() == Protocol.HTTP_2
-        ? readHttp2HeadersList(stream.getResponseHeaders())
-        : readSpdy3HeadersList(stream.getResponseHeaders());
-  }
-
-  /**
-   * Returns a list of alternating names and values containing a SPDY request. Names are all
-   * lowercase. No names are repeated. If any name has multiple values, they are concatenated using
-   * "\0" as a delimiter.
-   */
-  public static List<Header> spdy3HeadersList(Request request) {
-    Headers headers = request.headers();
-    List<Header> result = new ArrayList<>(headers.size() + 5);
-    result.add(new Header(TARGET_METHOD, request.method()));
-    result.add(new Header(TARGET_PATH, RequestLine.requestPath(request.url())));
-    result.add(new Header(VERSION, "HTTP/1.1"));
-    result.add(new Header(TARGET_HOST, Util.hostHeader(request.url(), false)));
-    result.add(new Header(TARGET_SCHEME, request.url().scheme()));
-
-    Set<ByteString> names = new LinkedHashSet<>();
-    for (int i = 0, size = headers.size(); i < size; i++) {
-      // header names must be lowercase.
-      ByteString name = ByteString.encodeUtf8(headers.name(i).toLowerCase(Locale.US));
-
-      // Drop headers that are forbidden when layering HTTP over SPDY.
-      if (SPDY_3_SKIPPED_REQUEST_HEADERS.contains(name)) continue;
-
-      // If we haven't seen this name before, add the pair to the end of the list...
-      String value = headers.value(i);
-      if (names.add(name)) {
-        result.add(new Header(name, value));
-        continue;
-      }
-
-      // ...otherwise concatenate the existing values and this value.
-      for (int j = 0; j < result.size(); j++) {
-        if (result.get(j).name.equals(name)) {
-          String concatenated = joinOnNull(result.get(j).value.utf8(), value);
-          result.set(j, new Header(name, concatenated));
-          break;
-        }
-      }
-    }
-    return result;
-  }
-
-  private static String joinOnNull(String first, String second) {
-    return new StringBuilder(first).append('\0').append(second).toString();
-  }
-
-  public static List<Header> http2HeadersList(Request request) {
-    Headers headers = request.headers();
-    List<Header> result = new ArrayList<>(headers.size() + 4);
-    result.add(new Header(TARGET_METHOD, request.method()));
-    result.add(new Header(TARGET_PATH, RequestLine.requestPath(request.url())));
-    result.add(new Header(TARGET_AUTHORITY, Util.hostHeader(request.url(), false))); // Optional.
-    result.add(new Header(TARGET_SCHEME, request.url().scheme()));
-
-    for (int i = 0, size = headers.size(); i < size; i++) {
-      // header names must be lowercase.
-      ByteString name = ByteString.encodeUtf8(headers.name(i).toLowerCase(Locale.US));
-      if (!HTTP_2_SKIPPED_REQUEST_HEADERS.contains(name)) {
-        result.add(new Header(name, headers.value(i)));
-      }
-    }
-    return result;
-  }
-
-  /** Returns headers for a name value block containing a SPDY response. */
-  public static Response.Builder readSpdy3HeadersList(List<Header> headerBlock) throws IOException {
-    String status = null;
-    String version = "HTTP/1.1";
-    Headers.Builder headersBuilder = new Headers.Builder();
-    for (int i = 0, size = headerBlock.size(); i < size; i++) {
-      ByteString name = headerBlock.get(i).name;
-
-      String values = headerBlock.get(i).value.utf8();
-      for (int start = 0; start < values.length(); ) {
-        int end = values.indexOf('\0', start);
-        if (end == -1) {
-          end = values.length();
-        }
-        String value = values.substring(start, end);
-        if (name.equals(RESPONSE_STATUS)) {
-          status = value;
-        } else if (name.equals(VERSION)) {
-          version = value;
-        } else if (!SPDY_3_SKIPPED_RESPONSE_HEADERS.contains(name)) {
-          headersBuilder.add(name.utf8(), value);
-        }
-        start = end + 1;
-      }
-    }
-    if (status == null) throw new ProtocolException("Expected ':status' header not present");
-
-    StatusLine statusLine = StatusLine.parse(version + " " + status);
-    return new Response.Builder()
-        .protocol(Protocol.SPDY_3)
-        .code(statusLine.code)
-        .message(statusLine.message)
-        .headers(headersBuilder.build());
-  }
-
-  /** Returns headers for a name value block containing an HTTP/2 response. */
-  public static Response.Builder readHttp2HeadersList(List<Header> headerBlock) throws IOException {
-    String status = null;
-
-    Headers.Builder headersBuilder = new Headers.Builder();
-    for (int i = 0, size = headerBlock.size(); i < size; i++) {
-      ByteString name = headerBlock.get(i).name;
-
-      String value = headerBlock.get(i).value.utf8();
-      if (name.equals(RESPONSE_STATUS)) {
-        status = value;
-      } else if (!HTTP_2_SKIPPED_RESPONSE_HEADERS.contains(name)) {
-        headersBuilder.add(name.utf8(), value);
-      }
-    }
-    if (status == null) throw new ProtocolException("Expected ':status' header not present");
-
-    StatusLine statusLine = StatusLine.parse("HTTP/1.1 " + status);
-    return new Response.Builder()
-        .protocol(Protocol.HTTP_2)
-        .code(statusLine.code)
-        .message(statusLine.message)
-        .headers(headersBuilder.build());
-  }
-
-  @Override public ResponseBody openResponseBody(Response response) throws IOException {
-    Source source = new StreamFinishingSource(stream.getSource());
-    return new RealResponseBody(response.headers(), Okio.buffer(source));
-  }
-
-  @Override public void cancel() {
-    if (stream != null) stream.closeLater(ErrorCode.CANCEL);
-  }
-
-  class StreamFinishingSource extends ForwardingSource {
-    public StreamFinishingSource(Source delegate) {
-      super(delegate);
-    }
-
-    @Override public void close() throws IOException {
-      streamAllocation.streamFinished(false, Http2xStream.this);
-      super.close();
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpStream.java b/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java
similarity index 84%
rename from okhttp/src/main/java/okhttp3/internal/http/HttpStream.java
rename to okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java
index 34c471345c..b227399e91 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpStream.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java
@@ -21,7 +21,8 @@
 import okhttp3.ResponseBody;
 import okio.Sink;
 
-public interface HttpStream {
+/** Encodes HTTP requests and decodes HTTP responses. */
+public interface HttpCodec {
   /**
    * The timeout to use while discarding a stream of input data. Since this is used for connection
    * reuse, this timeout should be significantly less than the time it takes to establish a new
@@ -30,16 +31,11 @@
   int DISCARD_STREAM_TIMEOUT_MILLIS = 100;
 
   /** Returns an output stream where the request body can be streamed. */
-  Sink createRequestBody(Request request, long contentLength) throws IOException;
+  Sink createRequestBody(Request request, long contentLength);
 
   /** This should update the HTTP engine's sentRequestMillis field. */
   void writeRequestHeaders(Request request) throws IOException;
 
-  /**
-   * Sends the request body returned by {@link #createRequestBody} to the remote peer.
-   */
-  void writeRequestBody(RetryableSink requestBody) throws IOException;
-
   /** Flush the request to the underlying socket. */
   void finishRequest() throws IOException;
 
@@ -49,8 +45,6 @@
   /** Returns a stream that reads the response body. */
   ResponseBody openResponseBody(Response response) throws IOException;
 
-  void setHttpEngine(HttpEngine httpEngine);
-
   /**
    * Cancel this stream. Resources held by this stream will be cleaned up, though not synchronously.
    * That may happen later by the connection pool thread.
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java b/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
deleted file mode 100644
index 9643cbc594..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
+++ /dev/null
@@ -1,989 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package okhttp3.internal.http;
-
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.net.Proxy;
-import java.util.Date;
-import java.util.List;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLSocketFactory;
-import okhttp3.Address;
-import okhttp3.CertificatePinner;
-import okhttp3.Connection;
-import okhttp3.Cookie;
-import okhttp3.CookieJar;
-import okhttp3.Headers;
-import okhttp3.HttpUrl;
-import okhttp3.Interceptor;
-import okhttp3.MediaType;
-import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.Route;
-import okhttp3.internal.Internal;
-import okhttp3.internal.InternalCache;
-import okhttp3.internal.Version;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.GzipSource;
-import okio.Okio;
-import okio.Sink;
-import okio.Source;
-import okio.Timeout;
-
-import static java.net.HttpURLConnection.HTTP_CLIENT_TIMEOUT;
-import static java.net.HttpURLConnection.HTTP_MOVED_PERM;
-import static java.net.HttpURLConnection.HTTP_MOVED_TEMP;
-import static java.net.HttpURLConnection.HTTP_MULT_CHOICE;
-import static java.net.HttpURLConnection.HTTP_NOT_MODIFIED;
-import static java.net.HttpURLConnection.HTTP_NO_CONTENT;
-import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
-import static java.net.HttpURLConnection.HTTP_SEE_OTHER;
-import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
-import static java.util.concurrent.TimeUnit.MILLISECONDS;
-import static okhttp3.internal.Util.closeQuietly;
-import static okhttp3.internal.Util.discard;
-import static okhttp3.internal.Util.hostHeader;
-import static okhttp3.internal.http.StatusLine.HTTP_CONTINUE;
-import static okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT;
-import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
-
-/**
- * Handles a single HTTP request/response pair. Each HTTP engine follows this lifecycle: <ol> <li>It
- * is created. <li>The HTTP request message is sent with sendRequest(). Once the request is sent it
- * is an error to modify the request headers. After sendRequest() has been called the request body
- * can be written to if it exists. <li>The HTTP response message is read with readResponse(). After
- * the response has been read the response headers and body can be read. All responses have a
- * response body input stream, though in some instances this stream is empty. </ol>
- *
- * <p>The request and response may be served by the HTTP response cache, by the network, or by both
- * in the event of a conditional GET.
- */
-public final class HttpEngine {
-  /**
-   * How many redirects and auth challenges should we attempt? Chrome follows 21 redirects; Firefox,
-   * curl, and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5.
-   */
-  public static final int MAX_FOLLOW_UPS = 20;
-
-  private static final ResponseBody EMPTY_BODY = new ResponseBody() {
-    @Override public MediaType contentType() {
-      return null;
-    }
-
-    @Override public long contentLength() {
-      return 0;
-    }
-
-    @Override public BufferedSource source() {
-      return new Buffer();
-    }
-  };
-
-  final OkHttpClient client;
-
-  public final StreamAllocation streamAllocation;
-  private final Response priorResponse;
-  private HttpStream httpStream;
-
-  /** The time when the request headers were written, or -1 if they haven't been written yet. */
-  long sentRequestMillis = -1;
-
-  /**
-   * True if this client added an "Accept-Encoding: gzip" header field and is therefore responsible
-   * for also decompressing the transfer stream.
-   */
-  private boolean transparentGzip;
-
-  /**
-   * True if the request body must be completely buffered before transmission; false if it can be
-   * streamed. Buffering has two advantages: we don't need the content-length in advance and we can
-   * retransmit if necessary. The upside of streaming is that we can save memory.
-   */
-  public final boolean bufferRequestBody;
-
-  /**
-   * The original application-provided request. Never modified by OkHttp. When follow-up requests
-   * are necessary, they are derived from this request.
-   */
-  private final Request userRequest;
-
-  /**
-   * The request to send on the network, or null for no network request. This is derived from the
-   * user request, and customized to support OkHttp features like compression and caching.
-   */
-  private Request networkRequest;
-
-  /**
-   * The cached response, or null if the cache doesn't exist or cannot be used for this request.
-   * Conditional caching means this may be non-null even when the network request is non-null. Never
-   * modified by OkHttp.
-   */
-  private Response cacheResponse;
-
-  /**
-   * The user-visible response. This is derived from either the network response, cache response, or
-   * both. It is customized to support OkHttp features like compression and caching.
-   */
-  private Response userResponse;
-
-  private Sink requestBodyOut;
-  private BufferedSink bufferedRequestBody;
-  private final boolean callerWritesRequestBody;
-  private final boolean forWebSocket;
-
-  /** The cache request currently being populated from a network response. */
-  private CacheRequest storeRequest;
-  private CacheStrategy cacheStrategy;
-
-  /**
-   * @param request the HTTP request without a body. The body must be written via the engine's
-   * request body stream.
-   * @param callerWritesRequestBody true for the {@code HttpURLConnection}-style interaction model
-   * where control flow is returned to the calling application to write the request body before the
-   * response body is readable.
-   */
-  public HttpEngine(OkHttpClient client, Request request, boolean bufferRequestBody,
-      boolean callerWritesRequestBody, boolean forWebSocket, StreamAllocation streamAllocation,
-      RetryableSink requestBodyOut, Response priorResponse) {
-    this.client = client;
-    this.userRequest = request;
-    this.bufferRequestBody = bufferRequestBody;
-    this.callerWritesRequestBody = callerWritesRequestBody;
-    this.forWebSocket = forWebSocket;
-    this.streamAllocation = streamAllocation != null
-        ? streamAllocation
-        : new StreamAllocation(client.connectionPool(), createAddress(client, request));
-    this.requestBodyOut = requestBodyOut;
-    this.priorResponse = priorResponse;
-  }
-
-  /**
-   * Figures out what the response source will be, and opens a socket to that source if necessary.
-   * Prepares the request headers and gets ready to start writing the request body if it exists.
-   *
-   * @throws RequestException if there was a problem with request setup. Unrecoverable.
-   * @throws RouteException if the was a problem during connection via a specific route. Sometimes
-   * recoverable. See {@link #recover}.
-   * @throws IOException if there was a problem while making a request. Sometimes recoverable. See
-   * {@link #recover(IOException, boolean)}.
-   */
-  public void sendRequest() throws RequestException, RouteException, IOException {
-    if (cacheStrategy != null) return; // Already sent.
-    if (httpStream != null) throw new IllegalStateException();
-
-    Request request = networkRequest(userRequest);
-
-    InternalCache responseCache = Internal.instance.internalCache(client);
-    Response cacheCandidate = responseCache != null
-        ? responseCache.get(request)
-        : null;
-
-    long now = System.currentTimeMillis();
-    cacheStrategy = new CacheStrategy.Factory(now, request, cacheCandidate).get();
-    networkRequest = cacheStrategy.networkRequest;
-    cacheResponse = cacheStrategy.cacheResponse;
-
-    if (responseCache != null) {
-      responseCache.trackResponse(cacheStrategy);
-    }
-
-    if (cacheCandidate != null && cacheResponse == null) {
-      closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.
-    }
-
-    // If we're forbidden from using the network and the cache is insufficient, fail.
-    if (networkRequest == null && cacheResponse == null) {
-      userResponse = new Response.Builder()
-          .request(userRequest)
-          .priorResponse(stripBody(priorResponse))
-          .protocol(Protocol.HTTP_1_1)
-          .code(504)
-          .message("Unsatisfiable Request (only-if-cached)")
-          .body(EMPTY_BODY)
-          .build();
-      return;
-    }
-
-    // If we don't need the network, we're done.
-    if (networkRequest == null) {
-      userResponse = cacheResponse.newBuilder()
-          .request(userRequest)
-          .priorResponse(stripBody(priorResponse))
-          .cacheResponse(stripBody(cacheResponse))
-          .build();
-      userResponse = unzip(userResponse);
-      return;
-    }
-
-    // We need the network to satisfy this request. Possibly for validating a conditional GET.
-    boolean success = false;
-    try {
-      httpStream = connect();
-      httpStream.setHttpEngine(this);
-
-      if (writeRequestHeadersEagerly()) {
-        long contentLength = OkHeaders.contentLength(request);
-        if (bufferRequestBody) {
-          if (contentLength > Integer.MAX_VALUE) {
-            throw new IllegalStateException("Use setFixedLengthStreamingMode() or "
-                + "setChunkedStreamingMode() for requests larger than 2 GiB.");
-          }
-
-          if (contentLength != -1) {
-            // Buffer a request body of a known length.
-            httpStream.writeRequestHeaders(networkRequest);
-            requestBodyOut = new RetryableSink((int) contentLength);
-          } else {
-            // Buffer a request body of an unknown length. Don't write request headers until the
-            // entire body is ready; otherwise we can't set the Content-Length header correctly.
-            requestBodyOut = new RetryableSink();
-          }
-        } else {
-          httpStream.writeRequestHeaders(networkRequest);
-          requestBodyOut = httpStream.createRequestBody(networkRequest, contentLength);
-        }
-      }
-      success = true;
-    } finally {
-      // If we're crashing on I/O or otherwise, don't leak the cache body.
-      if (!success && cacheCandidate != null) {
-        closeQuietly(cacheCandidate.body());
-      }
-    }
-  }
-
-  /**
-   * If the caller's control flow writes the request body, we need to create that stream
-   * immediately. And that means we need to immediately write the request headers, so we can
-   * start streaming the request body. (We may already have a request body if we're retrying a
-   * failed POST.)
-   */
-  private boolean writeRequestHeadersEagerly() {
-    return callerWritesRequestBody
-        && permitsRequestBody(networkRequest)
-        && requestBodyOut == null;
-  }
-
-  private HttpStream connect() throws RouteException, RequestException, IOException {
-    boolean doExtensiveHealthChecks = !networkRequest.method().equals("GET");
-    return streamAllocation.newStream(client.connectTimeoutMillis(),
-        client.readTimeoutMillis(), client.writeTimeoutMillis(),
-        client.retryOnConnectionFailure(), doExtensiveHealthChecks);
-  }
-
-  private static Response stripBody(Response response) {
-    return response != null && response.body() != null
-        ? response.newBuilder().body(null).build()
-        : response;
-  }
-
-  /**
-   * Called immediately before the transport transmits HTTP request headers. This is used to observe
-   * the sent time should the request be cached.
-   */
-  public void writingRequestHeaders() {
-    if (sentRequestMillis != -1) throw new IllegalStateException();
-    sentRequestMillis = System.currentTimeMillis();
-  }
-
-  boolean permitsRequestBody(Request request) {
-    return HttpMethod.permitsRequestBody(request.method());
-  }
-
-  /** Returns the request body or null if this request doesn't have a body. */
-  public Sink getRequestBody() {
-    if (cacheStrategy == null) throw new IllegalStateException();
-    return requestBodyOut;
-  }
-
-  public BufferedSink getBufferedRequestBody() {
-    BufferedSink result = bufferedRequestBody;
-    if (result != null) return result;
-    Sink requestBody = getRequestBody();
-    return requestBody != null
-        ? (bufferedRequestBody = Okio.buffer(requestBody))
-        : null;
-  }
-
-  public boolean hasResponse() {
-    return userResponse != null;
-  }
-
-  public Request getRequest() {
-    return userRequest;
-  }
-
-  /** Returns the engine's response. */
-  // TODO: the returned body will always be null.
-  public Response getResponse() {
-    if (userResponse == null) throw new IllegalStateException();
-    return userResponse;
-  }
-
-  public Connection getConnection() {
-    return streamAllocation.connection();
-  }
-
-  /**
-   * Report and attempt to recover from a failure to communicate with a server. Returns a new HTTP
-   * engine that should be used for the retry if {@code e} is recoverable, or null if the failure is
-   * permanent. Requests with a body can only be recovered if the body is buffered.
-   */
-  public HttpEngine recover(IOException e, boolean routeException, Sink requestBodyOut) {
-    if (!streamAllocation.recover(e, routeException, requestBodyOut)) {
-      return null;
-    }
-
-    if (!client.retryOnConnectionFailure()) {
-      return null;
-    }
-
-    StreamAllocation streamAllocation = close();
-
-    // For failure recovery, use the same route selector with a new connection.
-    return new HttpEngine(client, userRequest, bufferRequestBody, callerWritesRequestBody,
-        forWebSocket, streamAllocation, (RetryableSink) requestBodyOut, priorResponse);
-  }
-
-  public HttpEngine recover(IOException e, boolean routeException) {
-    return recover(e, routeException, requestBodyOut);
-  }
-
-  private void maybeCache() throws IOException {
-    InternalCache responseCache = Internal.instance.internalCache(client);
-    if (responseCache == null) return;
-
-    // Should we cache this response for this request?
-    if (!CacheStrategy.isCacheable(userResponse, networkRequest)) {
-      if (HttpMethod.invalidatesCache(networkRequest.method())) {
-        try {
-          responseCache.remove(networkRequest);
-        } catch (IOException ignored) {
-          // The cache cannot be written.
-        }
-      }
-      return;
-    }
-
-    // Offer this request to the cache.
-    storeRequest = responseCache.put(stripBody(userResponse));
-  }
-
-  /**
-   * Configure the socket connection to be either pooled or closed when it is either exhausted or
-   * closed. If it is unneeded when this is called, it will be released immediately.
-   */
-  public void releaseStreamAllocation() throws IOException {
-    streamAllocation.release();
-  }
-
-  /**
-   * Immediately closes the socket connection if it's currently held by this engine. Use this to
-   * interrupt an in-flight request from any thread. It's the caller's responsibility to close the
-   * request body and response body streams; otherwise resources may be leaked.
-   *
-   * <p>This method is safe to be called concurrently, but provides limited guarantees. If a
-   * transport layer connection has been established (such as a HTTP/2 stream) that is terminated.
-   * Otherwise if a socket connection is being established, that is terminated.
-   */
-  public void cancel() {
-    streamAllocation.cancel();
-  }
-
-  /**
-   * Release any resources held by this engine. Returns the stream allocation held by this engine,
-   * which itself must be used or released.
-   */
-  public StreamAllocation close() {
-    if (bufferedRequestBody != null) {
-      // This also closes the wrapped requestBodyOut.
-      closeQuietly(bufferedRequestBody);
-    } else if (requestBodyOut != null) {
-      closeQuietly(requestBodyOut);
-    }
-
-    if (userResponse != null) {
-      closeQuietly(userResponse.body());
-    } else {
-      // If this engine never achieved a response body, its stream allocation is dead.
-      streamAllocation.connectionFailed(null);
-    }
-
-    return streamAllocation;
-  }
-
-  /**
-   * Returns a new response that does gzip decompression on {@code response}, if transparent gzip
-   * was both offered by OkHttp and used by the origin server.
-   *
-   * <p>In addition to decompression, this will also strip the corresponding headers. We strip the
-   * Content-Encoding header to prevent the application from attempting to double decompress. We
-   * strip the Content-Length header because it is the length of the compressed content, but the
-   * application is only interested in the length of the uncompressed content.
-   *
-   * <p>This method should only be used for non-empty response bodies. Response codes like "304 Not
-   * Modified" can include "Content-Encoding: gzip" without a response body and we will crash if we
-   * attempt to decompress the zero-byte source.
-   */
-  private Response unzip(final Response response) throws IOException {
-    if (!transparentGzip || !"gzip".equalsIgnoreCase(userResponse.header("Content-Encoding"))) {
-      return response;
-    }
-
-    if (response.body() == null) {
-      return response;
-    }
-
-    GzipSource responseBody = new GzipSource(response.body().source());
-    Headers strippedHeaders = response.headers().newBuilder()
-        .removeAll("Content-Encoding")
-        .removeAll("Content-Length")
-        .build();
-    return response.newBuilder()
-        .headers(strippedHeaders)
-        .body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)))
-        .build();
-  }
-
-  /**
-   * Returns true if the response must have a (possibly 0-length) body. See RFC 2616 section 4.3.
-   */
-  public static boolean hasBody(Response response) {
-    // HEAD requests never yield a body regardless of the response headers.
-    if (response.request().method().equals("HEAD")) {
-      return false;
-    }
-
-    int responseCode = response.code();
-    if ((responseCode < HTTP_CONTINUE || responseCode >= 200)
-        && responseCode != HTTP_NO_CONTENT
-        && responseCode != HTTP_NOT_MODIFIED) {
-      return true;
-    }
-
-    // If the Content-Length or Transfer-Encoding headers disagree with the
-    // response code, the response is malformed. For best compatibility, we
-    // honor the headers.
-    if (OkHeaders.contentLength(response) != -1
-        || "chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {
-      return true;
-    }
-
-    return false;
-  }
-
-  /**
-   * Populates request with defaults and cookies.
-   *
-   * <p>This client doesn't specify a default {@code Accept} header because it doesn't know what
-   * content types the application is interested in.
-   */
-  private Request networkRequest(Request request) throws IOException {
-    Request.Builder result = request.newBuilder();
-
-    if (request.header("Host") == null) {
-      result.header("Host", hostHeader(request.url(), false));
-    }
-
-    if (request.header("Connection") == null) {
-      result.header("Connection", "Keep-Alive");
-    }
-
-    if (request.header("Accept-Encoding") == null) {
-      transparentGzip = true;
-      result.header("Accept-Encoding", "gzip");
-    }
-
-    List<Cookie> cookies = client.cookieJar().loadForRequest(request.url());
-    if (!cookies.isEmpty()) {
-      result.header("Cookie", cookieHeader(cookies));
-    }
-
-    if (request.header("User-Agent") == null) {
-      result.header("User-Agent", Version.userAgent());
-    }
-
-    return result.build();
-  }
-
-  /** Returns a 'Cookie' HTTP request header with all cookies, like {@code a=b; c=d}. */
-  private String cookieHeader(List<Cookie> cookies) {
-    StringBuilder cookieHeader = new StringBuilder();
-    for (int i = 0, size = cookies.size(); i < size; i++) {
-      if (i > 0) {
-        cookieHeader.append("; ");
-      }
-      Cookie cookie = cookies.get(i);
-      cookieHeader.append(cookie.name()).append('=').append(cookie.value());
-    }
-    return cookieHeader.toString();
-  }
-
-  /**
-   * Flushes the remaining request header and body, parses the HTTP response headers and starts
-   * reading the HTTP response body if it exists.
-   */
-  public void readResponse() throws IOException {
-    if (userResponse != null) {
-      return; // Already ready.
-    }
-    if (networkRequest == null && cacheResponse == null) {
-      throw new IllegalStateException("call sendRequest() first!");
-    }
-    if (networkRequest == null) {
-      return; // No network response to read.
-    }
-
-    Response networkResponse;
-
-    if (forWebSocket) {
-      httpStream.writeRequestHeaders(networkRequest);
-      networkResponse = readNetworkResponse();
-    } else if (!callerWritesRequestBody) {
-      networkResponse = new NetworkInterceptorChain(0, networkRequest,
-          streamAllocation.connection()).proceed(networkRequest);
-    } else {
-      // Emit the request body's buffer so that everything is in requestBodyOut.
-      if (bufferedRequestBody != null && bufferedRequestBody.buffer().size() > 0) {
-        bufferedRequestBody.emit();
-      }
-
-      // Emit the request headers if we haven't yet. We might have just learned the Content-Length.
-      if (sentRequestMillis == -1) {
-        if (OkHeaders.contentLength(networkRequest) == -1
-            && requestBodyOut instanceof RetryableSink) {
-          long contentLength = ((RetryableSink) requestBodyOut).contentLength();
-          networkRequest = networkRequest.newBuilder()
-              .header("Content-Length", Long.toString(contentLength))
-              .build();
-        }
-        httpStream.writeRequestHeaders(networkRequest);
-      }
-
-      // Write the request body to the socket.
-      if (requestBodyOut != null) {
-        if (bufferedRequestBody != null) {
-          // This also closes the wrapped requestBodyOut.
-          bufferedRequestBody.close();
-        } else {
-          requestBodyOut.close();
-        }
-        if (requestBodyOut instanceof RetryableSink) {
-          httpStream.writeRequestBody((RetryableSink) requestBodyOut);
-        }
-      }
-
-      networkResponse = readNetworkResponse();
-    }
-
-    receiveHeaders(networkResponse.headers());
-
-    // If we have a cache response too, then we're doing a conditional get.
-    if (cacheResponse != null) {
-      if (validate(cacheResponse, networkResponse)) {
-        userResponse = cacheResponse.newBuilder()
-            .request(userRequest)
-            .priorResponse(stripBody(priorResponse))
-            .headers(combine(cacheResponse.headers(), networkResponse.headers()))
-            .cacheResponse(stripBody(cacheResponse))
-            .networkResponse(stripBody(networkResponse))
-            .build();
-        networkResponse.body().close();
-        releaseStreamAllocation();
-
-        // Update the cache after combining headers but before stripping the
-        // Content-Encoding header (as performed by initContentStream()).
-        InternalCache responseCache = Internal.instance.internalCache(client);
-        responseCache.trackConditionalCacheHit();
-        responseCache.update(cacheResponse, stripBody(userResponse));
-        userResponse = unzip(userResponse);
-        return;
-      } else {
-        closeQuietly(cacheResponse.body());
-      }
-    }
-
-    userResponse = networkResponse.newBuilder()
-        .request(userRequest)
-        .priorResponse(stripBody(priorResponse))
-        .cacheResponse(stripBody(cacheResponse))
-        .networkResponse(stripBody(networkResponse))
-        .build();
-
-    if (hasBody(userResponse)) {
-      maybeCache();
-      userResponse = unzip(cacheWritingResponse(storeRequest, userResponse));
-    }
-  }
-
-  class NetworkInterceptorChain implements Interceptor.Chain {
-    private final int index;
-    private final Request request;
-    private final Connection connection;
-    private int calls;
-
-    NetworkInterceptorChain(int index, Request request, Connection connection) {
-      this.index = index;
-      this.request = request;
-      this.connection = connection;
-    }
-
-    @Override public Connection connection() {
-      return connection;
-    }
-
-    @Override public Request request() {
-      return request;
-    }
-
-    @Override public Response proceed(Request request) throws IOException {
-      calls++;
-
-      if (index > 0) {
-        Interceptor caller = client.networkInterceptors().get(index - 1);
-        Address address = connection().route().address();
-
-        // Confirm that the interceptor uses the connection we've already prepared.
-        if (!request.url().host().equals(address.url().host())
-            || request.url().port() != address.url().port()) {
-          throw new IllegalStateException("network interceptor " + caller
-              + " must retain the same host and port");
-        }
-
-        // Confirm that this is the interceptor's first call to chain.proceed().
-        if (calls > 1) {
-          throw new IllegalStateException("network interceptor " + caller
-              + " must call proceed() exactly once");
-        }
-      }
-
-      if (index < client.networkInterceptors().size()) {
-        // There's another interceptor in the chain. Call that.
-        NetworkInterceptorChain chain = new NetworkInterceptorChain(index + 1, request, connection);
-        Interceptor interceptor = client.networkInterceptors().get(index);
-        Response interceptedResponse = interceptor.intercept(chain);
-
-        // Confirm that the interceptor made the required call to chain.proceed().
-        if (chain.calls != 1) {
-          throw new IllegalStateException("network interceptor " + interceptor
-              + " must call proceed() exactly once");
-        }
-        if (interceptedResponse == null) {
-          throw new NullPointerException("network interceptor " + interceptor
-              + " returned null");
-        }
-
-        return interceptedResponse;
-      }
-
-      httpStream.writeRequestHeaders(request);
-
-      //Update the networkRequest with the possibly updated interceptor request.
-      networkRequest = request;
-
-      if (permitsRequestBody(request) && request.body() != null) {
-        Sink requestBodyOut = httpStream.createRequestBody(request, request.body().contentLength());
-        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
-        request.body().writeTo(bufferedRequestBody);
-        bufferedRequestBody.close();
-      }
-
-      Response response = readNetworkResponse();
-
-      int code = response.code();
-      if ((code == 204 || code == 205) && response.body().contentLength() > 0) {
-        throw new ProtocolException(
-            "HTTP " + code + " had non-zero Content-Length: " + response.body().contentLength());
-      }
-
-      return response;
-    }
-  }
-
-  private Response readNetworkResponse() throws IOException {
-    httpStream.finishRequest();
-
-    Response networkResponse = httpStream.readResponseHeaders()
-        .request(networkRequest)
-        .handshake(streamAllocation.connection().handshake())
-        .header(OkHeaders.SENT_MILLIS, Long.toString(sentRequestMillis))
-        .header(OkHeaders.RECEIVED_MILLIS, Long.toString(System.currentTimeMillis()))
-        .build();
-
-    if (!forWebSocket) {
-      networkResponse = networkResponse.newBuilder()
-          .body(httpStream.openResponseBody(networkResponse))
-          .build();
-    }
-
-    if ("close".equalsIgnoreCase(networkResponse.request().header("Connection"))
-        || "close".equalsIgnoreCase(networkResponse.header("Connection"))) {
-      streamAllocation.noNewStreams();
-    }
-
-    return networkResponse;
-  }
-
-  /**
-   * Returns a new source that writes bytes to {@code cacheRequest} as they are read by the source
-   * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we
-   * may never exhaust the source stream and therefore not complete the cached response.
-   */
-  private Response cacheWritingResponse(final CacheRequest cacheRequest, Response response)
-      throws IOException {
-    // Some apps return a null body; for compatibility we treat that like a null cache request.
-    if (cacheRequest == null) return response;
-    Sink cacheBodyUnbuffered = cacheRequest.body();
-    if (cacheBodyUnbuffered == null) return response;
-
-    final BufferedSource source = response.body().source();
-    final BufferedSink cacheBody = Okio.buffer(cacheBodyUnbuffered);
-
-    Source cacheWritingSource = new Source() {
-      boolean cacheRequestClosed;
-
-      @Override public long read(Buffer sink, long byteCount) throws IOException {
-        long bytesRead;
-        try {
-          bytesRead = source.read(sink, byteCount);
-        } catch (IOException e) {
-          if (!cacheRequestClosed) {
-            cacheRequestClosed = true;
-            cacheRequest.abort(); // Failed to write a complete cache response.
-          }
-          throw e;
-        }
-
-        if (bytesRead == -1) {
-          if (!cacheRequestClosed) {
-            cacheRequestClosed = true;
-            cacheBody.close(); // The cache response is complete!
-          }
-          return -1;
-        }
-
-        sink.copyTo(cacheBody.buffer(), sink.size() - bytesRead, bytesRead);
-        cacheBody.emitCompleteSegments();
-        return bytesRead;
-      }
-
-      @Override public Timeout timeout() {
-        return source.timeout();
-      }
-
-      @Override public void close() throws IOException {
-        if (!cacheRequestClosed
-            && !discard(this, HttpStream.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-          cacheRequestClosed = true;
-          cacheRequest.abort();
-        }
-        source.close();
-      }
-    };
-
-    return response.newBuilder()
-        .body(new RealResponseBody(response.headers(), Okio.buffer(cacheWritingSource)))
-        .build();
-  }
-
-  /**
-   * Returns true if {@code cached} should be used; false if {@code network} response should be
-   * used.
-   */
-  private static boolean validate(Response cached, Response network) {
-    if (network.code() == HTTP_NOT_MODIFIED) {
-      return true;
-    }
-
-    // The HTTP spec says that if the network's response is older than our
-    // cached response, we may return the cache's response. Like Chrome (but
-    // unlike Firefox), this client prefers to return the newer response.
-    Date lastModified = cached.headers().getDate("Last-Modified");
-    if (lastModified != null) {
-      Date networkLastModified = network.headers().getDate("Last-Modified");
-      if (networkLastModified != null
-          && networkLastModified.getTime() < lastModified.getTime()) {
-        return true;
-      }
-    }
-
-    return false;
-  }
-
-  /**
-   * Combines cached headers with a network headers as defined by RFC 2616, 13.5.3.
-   */
-  private static Headers combine(Headers cachedHeaders, Headers networkHeaders) throws IOException {
-    Headers.Builder result = new Headers.Builder();
-
-    for (int i = 0, size = cachedHeaders.size(); i < size; i++) {
-      String fieldName = cachedHeaders.name(i);
-      String value = cachedHeaders.value(i);
-      if ("Warning".equalsIgnoreCase(fieldName) && value.startsWith("1")) {
-        continue; // Drop 100-level freshness warnings.
-      }
-      if (!OkHeaders.isEndToEnd(fieldName) || networkHeaders.get(fieldName) == null) {
-        result.add(fieldName, value);
-      }
-    }
-
-    for (int i = 0, size = networkHeaders.size(); i < size; i++) {
-      String fieldName = networkHeaders.name(i);
-      if ("Content-Length".equalsIgnoreCase(fieldName)) {
-        continue; // Ignore content-length headers of validating responses.
-      }
-      if (OkHeaders.isEndToEnd(fieldName)) {
-        result.add(fieldName, networkHeaders.value(i));
-      }
-    }
-
-    return result.build();
-  }
-
-  public void receiveHeaders(Headers headers) throws IOException {
-    if (client.cookieJar() == CookieJar.NO_COOKIES) return;
-
-    List<Cookie> cookies = Cookie.parseAll(userRequest.url(), headers);
-    if (cookies.isEmpty()) return;
-
-    client.cookieJar().saveFromResponse(userRequest.url(), cookies);
-  }
-
-  /**
-   * Figures out the HTTP request to make in response to receiving this engine's response. This will
-   * either add authentication headers, follow redirects or handle a client request timeout. If a
-   * follow-up is either unnecessary or not applicable, this returns null.
-   */
-  public Request followUpRequest() throws IOException {
-    if (userResponse == null) throw new IllegalStateException();
-    Connection connection = streamAllocation.connection();
-    Route route = connection != null
-        ? connection.route()
-        : null;
-    int responseCode = userResponse.code();
-
-    final String method = userRequest.method();
-    switch (responseCode) {
-      case HTTP_PROXY_AUTH:
-        Proxy selectedProxy = route != null
-            ? route.proxy()
-            : client.proxy();
-        if (selectedProxy.type() != Proxy.Type.HTTP) {
-          throw new ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy");
-        }
-        return client.proxyAuthenticator().authenticate(route, userResponse);
-
-      case HTTP_UNAUTHORIZED:
-        return client.authenticator().authenticate(route, userResponse);
-
-      case HTTP_PERM_REDIRECT:
-      case HTTP_TEMP_REDIRECT:
-        // "If the 307 or 308 status code is received in response to a request other than GET
-        // or HEAD, the user agent MUST NOT automatically redirect the request"
-        if (!method.equals("GET") && !method.equals("HEAD")) {
-          return null;
-        }
-        // fall-through
-      case HTTP_MULT_CHOICE:
-      case HTTP_MOVED_PERM:
-      case HTTP_MOVED_TEMP:
-      case HTTP_SEE_OTHER:
-        // Does the client allow redirects?
-        if (!client.followRedirects()) return null;
-
-        String location = userResponse.header("Location");
-        if (location == null) return null;
-        HttpUrl url = userRequest.url().resolve(location);
-
-        // Don't follow redirects to unsupported protocols.
-        if (url == null) return null;
-
-        // If configured, don't follow redirects between SSL and non-SSL.
-        boolean sameScheme = url.scheme().equals(userRequest.url().scheme());
-        if (!sameScheme && !client.followSslRedirects()) return null;
-
-        // Redirects don't include a request body.
-        Request.Builder requestBuilder = userRequest.newBuilder();
-        if (HttpMethod.permitsRequestBody(method)) {
-          if (HttpMethod.redirectsToGet(method)) {
-            requestBuilder.method("GET", null);
-          } else {
-            requestBuilder.method(method, null);
-          }
-          requestBuilder.removeHeader("Transfer-Encoding");
-          requestBuilder.removeHeader("Content-Length");
-          requestBuilder.removeHeader("Content-Type");
-        }
-
-        // When redirecting across hosts, drop all authentication headers. This
-        // is potentially annoying to the application layer since they have no
-        // way to retain them.
-        if (!sameConnection(url)) {
-          requestBuilder.removeHeader("Authorization");
-        }
-
-        return requestBuilder.url(url).build();
-
-      case HTTP_CLIENT_TIMEOUT:
-        // 408's are rare in practice, but some servers like HAProxy use this response code. The
-        // spec says that we may repeat the request without modifications. Modern browsers also
-        // repeat the request (even non-idempotent ones.)
-        boolean retryableBody = requestBodyOut == null || requestBodyOut instanceof RetryableSink;
-        if (callerWritesRequestBody && !retryableBody) {
-          return null;
-        }
-
-        return userRequest;
-
-      default:
-        return null;
-    }
-  }
-
-  /**
-   * Returns true if an HTTP request for {@code followUp} can reuse the connection used by this
-   * engine.
-   */
-  public boolean sameConnection(HttpUrl followUp) {
-    HttpUrl url = userRequest.url();
-    return url.host().equals(followUp.host())
-        && url.port() == followUp.port()
-        && url.scheme().equals(followUp.scheme());
-  }
-
-  private static Address createAddress(OkHttpClient client, Request request) {
-    SSLSocketFactory sslSocketFactory = null;
-    HostnameVerifier hostnameVerifier = null;
-    CertificatePinner certificatePinner = null;
-    if (request.isHttps()) {
-      sslSocketFactory = client.sslSocketFactory();
-      hostnameVerifier = client.hostnameVerifier();
-      certificatePinner = client.certificatePinner();
-    }
-
-    return new Address(request.url().host(), request.url().port(), client.dns(),
-        client.socketFactory(), sslSocketFactory, hostnameVerifier, certificatePinner,
-        client.proxyAuthenticator(), client.proxy(), client.protocols(),
-        client.connectionSpecs(), client.proxySelector());
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/OkHeaders.java b/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java
similarity index 65%
rename from okhttp/src/main/java/okhttp3/internal/http/OkHeaders.java
rename to okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java
index db8011c542..6c68bf9fec 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/OkHeaders.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java
@@ -21,43 +21,21 @@
 import java.util.Set;
 import java.util.TreeSet;
 import okhttp3.Challenge;
+import okhttp3.Cookie;
+import okhttp3.CookieJar;
 import okhttp3.Headers;
-import okhttp3.Protocol;
+import okhttp3.HttpUrl;
 import okhttp3.Request;
 import okhttp3.Response;
-import okhttp3.internal.Platform;
 
+import static java.net.HttpURLConnection.HTTP_NOT_MODIFIED;
+import static java.net.HttpURLConnection.HTTP_NO_CONTENT;
 import static okhttp3.internal.Util.equal;
+import static okhttp3.internal.http.StatusLine.HTTP_CONTINUE;
 
 /** Headers and utilities for internal use by OkHttp. */
-public final class OkHeaders {
-
-  static final String PREFIX = Platform.get().getPrefix();
-
-  /**
-   * Synthetic response header: the local time when the request was sent.
-   */
-  public static final String SENT_MILLIS = PREFIX + "-Sent-Millis";
-
-  /**
-   * Synthetic response header: the local time when the response was received.
-   */
-  public static final String RECEIVED_MILLIS = PREFIX + "-Received-Millis";
-
-  /**
-   * Synthetic response header: the selected {@link Protocol protocol} ("spdy/3.1", "http/1.1",
-   * etc).
-   */
-  public static final String SELECTED_PROTOCOL = PREFIX + "-Selected-Protocol";
-
-  /** Synthetic response header: the location from which the response was loaded. */
-  public static final String RESPONSE_SOURCE = PREFIX + "-Response-Source";
-
-  private OkHeaders() {
-  }
-
-  public static long contentLength(Request request) {
-    return contentLength(request.headers());
+public final class HttpHeaders {
+  private HttpHeaders() {
   }
 
   public static long contentLength(Response response) {
@@ -157,24 +135,7 @@ public static Headers varyHeaders(Headers requestHeaders, Headers responseHeader
     return result.build();
   }
 
-  /**
-   * Returns true if {@code fieldName} is an end-to-end HTTP header, as defined by RFC 2616,
-   * 13.5.1.
-   */
-  static boolean isEndToEnd(String fieldName) {
-    return !"Connection".equalsIgnoreCase(fieldName)
-        && !"Keep-Alive".equalsIgnoreCase(fieldName)
-        && !"Proxy-Authenticate".equalsIgnoreCase(fieldName)
-        && !"Proxy-Authorization".equalsIgnoreCase(fieldName)
-        && !"TE".equalsIgnoreCase(fieldName)
-        && !"Trailers".equalsIgnoreCase(fieldName)
-        && !"Transfer-Encoding".equalsIgnoreCase(fieldName)
-        && !"Upgrade".equalsIgnoreCase(fieldName);
-  }
-
-  /**
-   * Parse RFC 2617 challenges. This API is only interested in the scheme name and realm.
-   */
+  /** Parse RFC 2617 challenges. This API is only interested in the scheme name and realm. */
   public static List<Challenge> parseChallenges(Headers responseHeaders, String challengeHeader) {
     // auth-scheme = token
     // auth-param  = token "=" ( token | quoted-string )
@@ -190,10 +151,10 @@ static boolean isEndToEnd(String fieldName) {
       int pos = 0;
       while (pos < value.length()) {
         int tokenStart = pos;
-        pos = HeaderParser.skipUntil(value, pos, " ");
+        pos = skipUntil(value, pos, " ");
 
         String scheme = value.substring(tokenStart, pos).trim();
-        pos = HeaderParser.skipWhitespace(value, pos);
+        pos = skipWhitespace(value, pos);
 
         // TODO: This currently only handles schemes with a 'realm' parameter;
         //       It needs to be fixed to handle any scheme and any parameters
@@ -205,15 +166,94 @@ static boolean isEndToEnd(String fieldName) {
 
         pos += "realm=\"".length();
         int realmStart = pos;
-        pos = HeaderParser.skipUntil(value, pos, "\"");
+        pos = skipUntil(value, pos, "\"");
         String realm = value.substring(realmStart, pos);
         pos++; // Consume '"' close quote.
-        pos = HeaderParser.skipUntil(value, pos, ",");
+        pos = skipUntil(value, pos, ",");
         pos++; // Consume ',' comma.
-        pos = HeaderParser.skipWhitespace(value, pos);
+        pos = skipWhitespace(value, pos);
         result.add(new Challenge(scheme, realm));
       }
     }
     return result;
   }
+
+  public static void receiveHeaders(CookieJar cookieJar, HttpUrl url, Headers headers) {
+    if (cookieJar == CookieJar.NO_COOKIES) return;
+
+    List<Cookie> cookies = Cookie.parseAll(url, headers);
+    if (cookies.isEmpty()) return;
+
+    cookieJar.saveFromResponse(url, cookies);
+  }
+
+  /** Returns true if the response must have a (possibly 0-length) body. See RFC 7231. */
+  public static boolean hasBody(Response response) {
+    // HEAD requests never yield a body regardless of the response headers.
+    if (response.request().method().equals("HEAD")) {
+      return false;
+    }
+
+    int responseCode = response.code();
+    if ((responseCode < HTTP_CONTINUE || responseCode >= 200)
+        && responseCode != HTTP_NO_CONTENT
+        && responseCode != HTTP_NOT_MODIFIED) {
+      return true;
+    }
+
+    // If the Content-Length or Transfer-Encoding headers disagree with the response code, the
+    // response is malformed. For best compatibility, we honor the headers.
+    if (contentLength(response) != -1
+        || "chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {
+      return true;
+    }
+
+    return false;
+  }
+
+  /**
+   * Returns the next index in {@code input} at or after {@code pos} that contains a character from
+   * {@code characters}. Returns the input length if none of the requested characters can be found.
+   */
+  public static int skipUntil(String input, int pos, String characters) {
+    for (; pos < input.length(); pos++) {
+      if (characters.indexOf(input.charAt(pos)) != -1) {
+        break;
+      }
+    }
+    return pos;
+  }
+
+  /**
+   * Returns the next non-whitespace character in {@code input} that is white space. Result is
+   * undefined if input contains newline characters.
+   */
+  public static int skipWhitespace(String input, int pos) {
+    for (; pos < input.length(); pos++) {
+      char c = input.charAt(pos);
+      if (c != ' ' && c != '\t') {
+        break;
+      }
+    }
+    return pos;
+  }
+
+  /**
+   * Returns {@code value} as a positive integer, or 0 if it is negative, or {@code defaultValue} if
+   * it cannot be parsed.
+   */
+  public static int parseSeconds(String value, int defaultValue) {
+    try {
+      long seconds = Long.parseLong(value);
+      if (seconds > Integer.MAX_VALUE) {
+        return Integer.MAX_VALUE;
+      } else if (seconds < 0) {
+        return 0;
+      } else {
+        return (int) seconds;
+      }
+    } catch (NumberFormatException e) {
+      return defaultValue;
+    }
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.java b/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.java
index 3629810c0e..e10fa88a77 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.java
@@ -41,6 +41,10 @@ public static boolean permitsRequestBody(String method) {
         || method.equals("LOCK");     // (WebDAV) body: create lock, without body: refresh lock
   }
 
+  public static boolean redirectsWithBody(String method) {
+    return method.equals("PROPFIND"); // (WebDAV) redirects should also maintain the request body
+  }
+
   public static boolean redirectsToGet(String method) {
     // All requests but PROPFIND should redirect to a GET request.
     return !method.equals("PROPFIND");
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
new file mode 100644
index 0000000000..d5326c64f5
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
@@ -0,0 +1,112 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http;
+
+import java.io.IOException;
+import java.util.List;
+import okhttp3.Connection;
+import okhttp3.HttpUrl;
+import okhttp3.Interceptor;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.connection.StreamAllocation;
+
+/**
+ * A concrete interceptor chain that carries the entire interceptor chain: all application
+ * interceptors, the OkHttp core, all network interceptors, and finally the network caller.
+ */
+public final class RealInterceptorChain implements Interceptor.Chain {
+  private final List<Interceptor> interceptors;
+  private final StreamAllocation streamAllocation;
+  private final HttpCodec httpCodec;
+  private final Connection connection;
+  private final int index;
+  private final Request request;
+  private int calls;
+
+  public RealInterceptorChain(List<Interceptor> interceptors, StreamAllocation streamAllocation,
+      HttpCodec httpCodec, Connection connection, int index, Request request) {
+    this.interceptors = interceptors;
+    this.connection = connection;
+    this.streamAllocation = streamAllocation;
+    this.httpCodec = httpCodec;
+    this.index = index;
+    this.request = request;
+  }
+
+  @Override public Connection connection() {
+    return connection;
+  }
+
+  public StreamAllocation streamAllocation() {
+    return streamAllocation;
+  }
+
+  public HttpCodec httpStream() {
+    return httpCodec;
+  }
+
+  @Override public Request request() {
+    return request;
+  }
+
+  @Override public Response proceed(Request request) throws IOException {
+    return proceed(request, streamAllocation, httpCodec, connection);
+  }
+
+  public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,
+      Connection connection) throws IOException {
+    if (index >= interceptors.size()) throw new AssertionError();
+
+    calls++;
+
+    // If we already have a stream, confirm that the incoming request will use it.
+    if (this.httpCodec != null && !sameConnection(request.url())) {
+      throw new IllegalStateException("network interceptor " + interceptors.get(index - 1)
+          + " must retain the same host and port");
+    }
+
+    // If we already have a stream, confirm that this is the only call to chain.proceed().
+    if (this.httpCodec != null && calls > 1) {
+      throw new IllegalStateException("network interceptor " + interceptors.get(index - 1)
+          + " must call proceed() exactly once");
+    }
+
+    // Call the next interceptor in the chain.
+    RealInterceptorChain next = new RealInterceptorChain(
+        interceptors, streamAllocation, httpCodec, connection, index + 1, request);
+    Interceptor interceptor = interceptors.get(index);
+    Response response = interceptor.intercept(next);
+
+    // Confirm that the next interceptor made its required call to chain.proceed().
+    if (httpCodec != null && index + 1 < interceptors.size() && next.calls != 1) {
+      throw new IllegalStateException("network interceptor " + interceptor
+          + " must call proceed() exactly once");
+    }
+
+    // Confirm that the intercepted response isn't null.
+    if (response == null) {
+      throw new NullPointerException("interceptor " + interceptor + " returned null");
+    }
+
+    return response;
+  }
+
+  private boolean sameConnection(HttpUrl url) {
+    return url.host().equals(connection.route().address().url().host())
+        && url.port() == connection.route().address().url().port();
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RealResponseBody.java b/okhttp/src/main/java/okhttp3/internal/http/RealResponseBody.java
index d66fed988c..673189c299 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RealResponseBody.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RealResponseBody.java
@@ -35,7 +35,7 @@ public RealResponseBody(Headers headers, BufferedSource source) {
   }
 
   @Override public long contentLength() {
-    return OkHeaders.contentLength(headers);
+    return HttpHeaders.contentLength(headers);
   }
 
   @Override public BufferedSource source() {
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RequestLine.java b/okhttp/src/main/java/okhttp3/internal/http/RequestLine.java
index c70a86934e..3e09098097 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RequestLine.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RequestLine.java
@@ -27,9 +27,9 @@ private RequestLine() {
   /**
    * Returns the request status line, like "GET / HTTP/1.1". This is exposed to the application by
    * {@link HttpURLConnection#getHeaderFields}, so it needs to be set even if the transport is
-   * SPDY.
+   * HTTP/2.
    */
-  static String get(Request request, Proxy.Type proxyType) {
+  public static String get(Request request, Proxy.Type proxyType) {
     StringBuilder result = new StringBuilder();
     result.append(request.method());
     result.append(' ');
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
new file mode 100644
index 0000000000..2a7cd13822
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
@@ -0,0 +1,358 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.net.HttpRetryException;
+import java.net.ProtocolException;
+import java.net.Proxy;
+import java.net.SocketTimeoutException;
+import java.security.cert.CertificateException;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSocketFactory;
+import okhttp3.Address;
+import okhttp3.CertificatePinner;
+import okhttp3.Connection;
+import okhttp3.HttpUrl;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.Route;
+import okhttp3.internal.connection.RouteException;
+import okhttp3.internal.connection.StreamAllocation;
+
+import static java.net.HttpURLConnection.HTTP_CLIENT_TIMEOUT;
+import static java.net.HttpURLConnection.HTTP_MOVED_PERM;
+import static java.net.HttpURLConnection.HTTP_MOVED_TEMP;
+import static java.net.HttpURLConnection.HTTP_MULT_CHOICE;
+import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
+import static java.net.HttpURLConnection.HTTP_SEE_OTHER;
+import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
+import static okhttp3.internal.Util.closeQuietly;
+import static okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT;
+import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
+
+/**
+ * This interceptor recovers from failures and follows redirects as necessary. It may throw an
+ * {@link IOException} if the call was canceled.
+ */
+public final class RetryAndFollowUpInterceptor implements Interceptor {
+  /**
+   * How many redirects and auth challenges should we attempt? Chrome follows 21 redirects; Firefox,
+   * curl, and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5.
+   */
+  private static final int MAX_FOLLOW_UPS = 20;
+
+  private final OkHttpClient client;
+  private final boolean forWebSocket;
+  private StreamAllocation streamAllocation;
+  private Object callStackTrace;
+  private volatile boolean canceled;
+
+  public RetryAndFollowUpInterceptor(OkHttpClient client, boolean forWebSocket) {
+    this.client = client;
+    this.forWebSocket = forWebSocket;
+  }
+
+  /**
+   * Immediately closes the socket connection if it's currently held. Use this to interrupt an
+   * in-flight request from any thread. It's the caller's responsibility to close the request body
+   * and response body streams; otherwise resources may be leaked.
+   *
+   * <p>This method is safe to be called concurrently, but provides limited guarantees. If a
+   * transport layer connection has been established (such as a HTTP/2 stream) that is terminated.
+   * Otherwise if a socket connection is being established, that is terminated.
+   */
+  public void cancel() {
+    canceled = true;
+    StreamAllocation streamAllocation = this.streamAllocation;
+    if (streamAllocation != null) streamAllocation.cancel();
+  }
+
+  public boolean isCanceled() {
+    return canceled;
+  }
+
+  public void setCallStackTrace(Object callStackTrace) {
+    this.callStackTrace = callStackTrace;
+  }
+
+  public StreamAllocation streamAllocation() {
+    return streamAllocation;
+  }
+
+  @Override public Response intercept(Chain chain) throws IOException {
+    Request request = chain.request();
+
+    streamAllocation = new StreamAllocation(
+        client.connectionPool(), createAddress(request.url()), callStackTrace);
+
+    int followUpCount = 0;
+    Response priorResponse = null;
+    while (true) {
+      if (canceled) {
+        streamAllocation.release();
+        throw new IOException("Canceled");
+      }
+
+      Response response = null;
+      boolean releaseConnection = true;
+      try {
+        response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);
+        releaseConnection = false;
+      } catch (RouteException e) {
+        // The attempt to connect via a route failed. The request will not have been sent.
+        if (!recover(e.getLastConnectException(), true, request)) throw e.getLastConnectException();
+        releaseConnection = false;
+        continue;
+      } catch (IOException e) {
+        // An attempt to communicate with a server failed. The request may have been sent.
+        if (!recover(e, false, request)) throw e;
+        releaseConnection = false;
+        continue;
+      } finally {
+        // We're throwing an unchecked exception. Release any resources.
+        if (releaseConnection) {
+          streamAllocation.streamFailed(null);
+          streamAllocation.release();
+        }
+      }
+
+      // Attach the prior response if it exists. Such responses never have a body.
+      if (priorResponse != null) {
+        response = response.newBuilder()
+            .priorResponse(priorResponse.newBuilder()
+                    .body(null)
+                    .build())
+            .build();
+      }
+
+      Request followUp = followUpRequest(response);
+
+      if (followUp == null) {
+        if (!forWebSocket) {
+          streamAllocation.release();
+        }
+        return response;
+      }
+
+      closeQuietly(response.body());
+
+      if (++followUpCount > MAX_FOLLOW_UPS) {
+        streamAllocation.release();
+        throw new ProtocolException("Too many follow-up requests: " + followUpCount);
+      }
+
+      if (followUp.body() instanceof UnrepeatableRequestBody) {
+        streamAllocation.release();
+        throw new HttpRetryException("Cannot retry streamed HTTP body", response.code());
+      }
+
+      if (!sameConnection(response, followUp.url())) {
+        streamAllocation.release();
+        streamAllocation = new StreamAllocation(
+            client.connectionPool(), createAddress(followUp.url()), callStackTrace);
+      } else if (streamAllocation.codec() != null) {
+        throw new IllegalStateException("Closing the body of " + response
+            + " didn't close its backing stream. Bad interceptor?");
+      }
+
+      request = followUp;
+      priorResponse = response;
+    }
+  }
+
+  private Address createAddress(HttpUrl url) {
+    SSLSocketFactory sslSocketFactory = null;
+    HostnameVerifier hostnameVerifier = null;
+    CertificatePinner certificatePinner = null;
+    if (url.isHttps()) {
+      sslSocketFactory = client.sslSocketFactory();
+      hostnameVerifier = client.hostnameVerifier();
+      certificatePinner = client.certificatePinner();
+    }
+
+    return new Address(url.host(), url.port(), client.dns(), client.socketFactory(),
+        sslSocketFactory, hostnameVerifier, certificatePinner, client.proxyAuthenticator(),
+        client.proxy(), client.protocols(), client.connectionSpecs(), client.proxySelector());
+  }
+
+  /**
+   * Report and attempt to recover from a failure to communicate with a server. Returns true if
+   * {@code e} is recoverable, or false if the failure is permanent. Requests with a body can only
+   * be recovered if the body is buffered.
+   */
+  private boolean recover(IOException e, boolean routeException, Request userRequest) {
+    streamAllocation.streamFailed(e);
+
+    // The application layer has forbidden retries.
+    if (!client.retryOnConnectionFailure()) return false;
+
+    // We can't send the request body again.
+    if (!routeException && userRequest.body() instanceof UnrepeatableRequestBody) return false;
+
+    // This exception is fatal.
+    if (!isRecoverable(e, routeException)) return false;
+
+    // No more routes to attempt.
+    if (!streamAllocation.hasMoreRoutes()) return false;
+
+    // For failure recovery, use the same route selector with a new connection.
+    return true;
+  }
+
+  private boolean isRecoverable(IOException e, boolean routeException) {
+    // If there was a protocol problem, don't recover.
+    if (e instanceof ProtocolException) {
+      return false;
+    }
+
+    // If there was an interruption don't recover, but if there was a timeout connecting to a route
+    // we should try the next route (if there is one).
+    if (e instanceof InterruptedIOException) {
+      return e instanceof SocketTimeoutException && routeException;
+    }
+
+    // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
+    // again with a different route.
+    if (e instanceof SSLHandshakeException) {
+      // If the problem was a CertificateException from the X509TrustManager,
+      // do not retry.
+      if (e.getCause() instanceof CertificateException) {
+        return false;
+      }
+    }
+    if (e instanceof SSLPeerUnverifiedException) {
+      // e.g. a certificate pinning error.
+      return false;
+    }
+
+    // An example of one we might want to retry with a different route is a problem connecting to a
+    // proxy and would manifest as a standard IOException. Unless it is one we know we should not
+    // retry, we return true and try a new route.
+    return true;
+  }
+
+  /**
+   * Figures out the HTTP request to make in response to receiving {@code userResponse}. This will
+   * either add authentication headers, follow redirects or handle a client request timeout. If a
+   * follow-up is either unnecessary or not applicable, this returns null.
+   */
+  private Request followUpRequest(Response userResponse) throws IOException {
+    if (userResponse == null) throw new IllegalStateException();
+    Connection connection = streamAllocation.connection();
+    Route route = connection != null
+        ? connection.route()
+        : null;
+    int responseCode = userResponse.code();
+
+    final String method = userResponse.request().method();
+    switch (responseCode) {
+      case HTTP_PROXY_AUTH:
+        Proxy selectedProxy = route != null
+            ? route.proxy()
+            : client.proxy();
+        if (selectedProxy.type() != Proxy.Type.HTTP) {
+          throw new ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy");
+        }
+        return client.proxyAuthenticator().authenticate(route, userResponse);
+
+      case HTTP_UNAUTHORIZED:
+        return client.authenticator().authenticate(route, userResponse);
+
+      case HTTP_PERM_REDIRECT:
+      case HTTP_TEMP_REDIRECT:
+        // "If the 307 or 308 status code is received in response to a request other than GET
+        // or HEAD, the user agent MUST NOT automatically redirect the request"
+        if (!method.equals("GET") && !method.equals("HEAD")) {
+          return null;
+        }
+        // fall-through
+      case HTTP_MULT_CHOICE:
+      case HTTP_MOVED_PERM:
+      case HTTP_MOVED_TEMP:
+      case HTTP_SEE_OTHER:
+        // Does the client allow redirects?
+        if (!client.followRedirects()) return null;
+
+        String location = userResponse.header("Location");
+        if (location == null) return null;
+        HttpUrl url = userResponse.request().url().resolve(location);
+
+        // Don't follow redirects to unsupported protocols.
+        if (url == null) return null;
+
+        // If configured, don't follow redirects between SSL and non-SSL.
+        boolean sameScheme = url.scheme().equals(userResponse.request().url().scheme());
+        if (!sameScheme && !client.followSslRedirects()) return null;
+
+        // Most redirects don't include a request body.
+        Request.Builder requestBuilder = userResponse.request().newBuilder();
+        if (HttpMethod.permitsRequestBody(method)) {
+          final boolean maintainBody = HttpMethod.redirectsWithBody(method);
+          if (HttpMethod.redirectsToGet(method)) {
+            requestBuilder.method("GET", null);
+          } else {
+            RequestBody requestBody = maintainBody ? userResponse.request().body() : null;
+            requestBuilder.method(method, requestBody);
+          }
+          if (!maintainBody) {
+            requestBuilder.removeHeader("Transfer-Encoding");
+            requestBuilder.removeHeader("Content-Length");
+            requestBuilder.removeHeader("Content-Type");
+          }
+        }
+
+        // When redirecting across hosts, drop all authentication headers. This
+        // is potentially annoying to the application layer since they have no
+        // way to retain them.
+        if (!sameConnection(userResponse, url)) {
+          requestBuilder.removeHeader("Authorization");
+        }
+
+        return requestBuilder.url(url).build();
+
+      case HTTP_CLIENT_TIMEOUT:
+        // 408's are rare in practice, but some servers like HAProxy use this response code. The
+        // spec says that we may repeat the request without modifications. Modern browsers also
+        // repeat the request (even non-idempotent ones.)
+        if (userResponse.request().body() instanceof UnrepeatableRequestBody) {
+          return null;
+        }
+
+        return userResponse.request();
+
+      default:
+        return null;
+    }
+  }
+
+  /**
+   * Returns true if an HTTP request for {@code followUp} can reuse the connection used by this
+   * engine.
+   */
+  private boolean sameConnection(Response response, HttpUrl followUp) {
+    HttpUrl url = response.request().url();
+    return url.host().equals(followUp.host())
+        && url.port() == followUp.port()
+        && url.scheme().equals(followUp.scheme());
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RetryableSink.java b/okhttp/src/main/java/okhttp3/internal/http/RetryableSink.java
deleted file mode 100644
index c0010d1898..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http/RetryableSink.java
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http;
-
-import java.io.IOException;
-import java.net.ProtocolException;
-import okio.Buffer;
-import okio.Sink;
-import okio.Timeout;
-
-import static okhttp3.internal.Util.checkOffsetAndCount;
-
-/**
- * An HTTP request body that's completely buffered in memory. This allows the post body to be
- * transparently re-sent if the HTTP request must be sent multiple times.
- */
-public final class RetryableSink implements Sink {
-  private boolean closed;
-  private final int limit;
-  private final Buffer content = new Buffer();
-
-  public RetryableSink(int limit) {
-    this.limit = limit;
-  }
-
-  public RetryableSink() {
-    this(-1);
-  }
-
-  @Override public void close() throws IOException {
-    if (closed) return;
-    closed = true;
-    if (content.size() < limit) {
-      throw new ProtocolException(
-          "content-length promised " + limit + " bytes, but received " + content.size());
-    }
-  }
-
-  @Override public void write(Buffer source, long byteCount) throws IOException {
-    if (closed) throw new IllegalStateException("closed");
-    checkOffsetAndCount(source.size(), 0, byteCount);
-    if (limit != -1 && content.size() > limit - byteCount) {
-      throw new ProtocolException("exceeded content-length limit of " + limit + " bytes");
-    }
-    content.write(source, byteCount);
-  }
-
-  @Override public void flush() throws IOException {
-  }
-
-  @Override public Timeout timeout() {
-    return Timeout.NONE;
-  }
-
-  public long contentLength() throws IOException {
-    return content.size();
-  }
-
-  public void writeToSocket(Sink socketOut) throws IOException {
-    // Copy the content; otherwise we won't have data to retry.
-    Buffer buffer = new Buffer();
-    content.copyTo(buffer, 0, content.size());
-    socketOut.write(buffer, buffer.size());
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverSpdy3Test.java b/okhttp/src/main/java/okhttp3/internal/http/UnrepeatableRequestBody.java
similarity index 72%
rename from okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverSpdy3Test.java
rename to okhttp/src/main/java/okhttp3/internal/http/UnrepeatableRequestBody.java
index 6f7e793165..60b893fbf3 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverSpdy3Test.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/UnrepeatableRequestBody.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2016 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,13 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.framed;
+package okhttp3.internal.http;
 
-import okhttp3.Protocol;
-
-public class HttpOverSpdy3Test extends HttpOverSpdyTest {
-
-  public HttpOverSpdy3Test() {
-    super(Protocol.SPDY_3);
-  }
+public interface UnrepeatableRequestBody {
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/Http1xStream.java b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
similarity index 92%
rename from okhttp/src/main/java/okhttp3/internal/http/Http1xStream.java
rename to okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
index 320788755b..3df3696e1f 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/Http1xStream.java
+++ b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
@@ -13,18 +13,26 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.http;
+package okhttp3.internal.http1;
 
 import java.io.EOFException;
 import java.io.IOException;
 import java.net.ProtocolException;
 import okhttp3.Headers;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.ResponseBody;
 import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
-import okhttp3.internal.io.RealConnection;
+import okhttp3.internal.connection.RealConnection;
+import okhttp3.internal.connection.StreamAllocation;
+import okhttp3.internal.http.HttpCodec;
+import okhttp3.internal.http.HttpHeaders;
+import okhttp3.internal.http.RealResponseBody;
+import okhttp3.internal.http.RequestLine;
+import okhttp3.internal.http.StatusLine;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -58,7 +66,7 @@
  * Exchanges that do not have a response body can call {@link #newFixedLengthSource(long)
  * newFixedLengthSource(0)} and may skip reading and closing that source.
  */
-public final class Http1xStream implements HttpStream {
+public final class Http1Codec implements HttpCodec {
   private static final int STATE_IDLE = 0; // Idle connections are ready to write request headers.
   private static final int STATE_OPEN_REQUEST_BODY = 1;
   private static final int STATE_WRITING_REQUEST_BODY = 2;
@@ -67,24 +75,24 @@
   private static final int STATE_READING_RESPONSE_BODY = 5;
   private static final int STATE_CLOSED = 6;
 
+  /** The client that configures this stream. May be null for HTTPS proxy tunnels. */
+  private final OkHttpClient client;
   /** The stream allocation that owns this stream. May be null for HTTPS proxy tunnels. */
   private final StreamAllocation streamAllocation;
+
   private final BufferedSource source;
   private final BufferedSink sink;
-  private HttpEngine httpEngine;
   private int state = STATE_IDLE;
 
-  public Http1xStream(StreamAllocation streamAllocation, BufferedSource source, BufferedSink sink) {
+  public Http1Codec(OkHttpClient client, StreamAllocation streamAllocation, BufferedSource source,
+      BufferedSink sink) {
+    this.client = client;
     this.streamAllocation = streamAllocation;
     this.source = source;
     this.sink = sink;
   }
 
-  @Override public void setHttpEngine(HttpEngine httpEngine) {
-    this.httpEngine = httpEngine;
-  }
-
-  @Override public Sink createRequestBody(Request request, long contentLength) throws IOException {
+  @Override public Sink createRequestBody(Request request, long contentLength) {
     if ("chunked".equalsIgnoreCase(request.header("Transfer-Encoding"))) {
       // Stream a request body of unknown length.
       return newChunkedSink();
@@ -115,9 +123,8 @@ public Http1xStream(StreamAllocation streamAllocation, BufferedSource source, Bu
    * header field receives the proper value.
    */
   @Override public void writeRequestHeaders(Request request) throws IOException {
-    httpEngine.writingRequestHeaders();
     String requestLine = RequestLine.get(
-        request, httpEngine.getConnection().route().proxy().type());
+        request, streamAllocation.connection().route().proxy().type());
     writeRequest(request.headers(), requestLine);
   }
 
@@ -131,15 +138,15 @@ public Http1xStream(StreamAllocation streamAllocation, BufferedSource source, Bu
   }
 
   private Source getTransferStream(Response response) throws IOException {
-    if (!HttpEngine.hasBody(response)) {
+    if (!HttpHeaders.hasBody(response)) {
       return newFixedLengthSource(0);
     }
 
     if ("chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {
-      return newChunkedSource(httpEngine);
+      return newChunkedSource(response.request().url());
     }
 
-    long contentLength = OkHeaders.contentLength(response);
+    long contentLength = HttpHeaders.contentLength(response);
     if (contentLength != -1) {
       return newFixedLengthSource(contentLength);
     }
@@ -224,22 +231,16 @@ public Sink newFixedLengthSink(long contentLength) {
     return new FixedLengthSink(contentLength);
   }
 
-  @Override public void writeRequestBody(RetryableSink requestBody) throws IOException {
-    if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException("state: " + state);
-    state = STATE_READ_RESPONSE_HEADERS;
-    requestBody.writeToSocket(sink);
-  }
-
   public Source newFixedLengthSource(long length) throws IOException {
     if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
     state = STATE_READING_RESPONSE_BODY;
     return new FixedLengthSource(length);
   }
 
-  public Source newChunkedSource(HttpEngine httpEngine) throws IOException {
+  public Source newChunkedSource(HttpUrl url) throws IOException {
     if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
     state = STATE_READING_RESPONSE_BODY;
-    return new ChunkedSource(httpEngine);
+    return new ChunkedSource(url);
   }
 
   public Source newUnknownLengthSource() throws IOException {
@@ -357,7 +358,7 @@ protected final void endOfInput(boolean reuseConnection) throws IOException {
 
       state = STATE_CLOSED;
       if (streamAllocation != null) {
-        streamAllocation.streamFinished(!reuseConnection, Http1xStream.this);
+        streamAllocation.streamFinished(!reuseConnection, Http1Codec.this);
       }
     }
   }
@@ -405,12 +406,12 @@ public FixedLengthSource(long length) throws IOException {
   /** An HTTP body with alternating chunk sizes and chunk bodies. */
   private class ChunkedSource extends AbstractSource {
     private static final long NO_CHUNK_YET = -1L;
+    private final HttpUrl url;
     private long bytesRemainingInChunk = NO_CHUNK_YET;
     private boolean hasMoreChunks = true;
-    private final HttpEngine httpEngine;
 
-    ChunkedSource(HttpEngine httpEngine) throws IOException {
-      this.httpEngine = httpEngine;
+    ChunkedSource(HttpUrl url) {
+      this.url = url;
     }
 
     @Override public long read(Buffer sink, long byteCount) throws IOException {
@@ -449,7 +450,7 @@ private void readChunkSize() throws IOException {
       }
       if (bytesRemainingInChunk == 0L) {
         hasMoreChunks = false;
-        httpEngine.receiveHeaders(readHeaders());
+        HttpHeaders.receiveHeaders(client.cookieJar(), url, readHeaders());
         endOfInput(true);
       }
     }
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/Variant.java b/okhttp/src/main/java/okhttp3/internal/http2/ErrorCode.java
similarity index 50%
rename from okhttp/src/main/java/okhttp3/internal/framed/Variant.java
rename to okhttp/src/main/java/okhttp3/internal/http2/ErrorCode.java
index 4ff3794007..26defebe06 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/Variant.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/ErrorCode.java
@@ -13,25 +13,33 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.framed;
+package okhttp3.internal.http2;
 
-import okhttp3.Protocol;
-import okio.BufferedSink;
-import okio.BufferedSource;
+// http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-7
+public enum ErrorCode {
+  /** Not an error! */
+  NO_ERROR(0),
 
-/** A version and dialect of the framed socket protocol. */
-public interface Variant {
+  PROTOCOL_ERROR(1),
 
-  /** The protocol as selected using ALPN. */
-  Protocol getProtocol();
+  INTERNAL_ERROR(2),
 
-  /**
-   * @param client true if this is the HTTP client's reader, reading frames from a server.
-   */
-  FrameReader newReader(BufferedSource source, boolean client);
+  FLOW_CONTROL_ERROR(3),
 
-  /**
-   * @param client true if this is the HTTP client's writer, writing frames to a server.
-   */
-  FrameWriter newWriter(BufferedSink sink, boolean client);
+  REFUSED_STREAM(7),
+
+  CANCEL(8);
+
+  public final int httpCode;
+
+  ErrorCode(int httpCode) {
+    this.httpCode = httpCode;
+  }
+
+  public static ErrorCode fromHttp2(int code) {
+    for (ErrorCode errorCode : ErrorCode.values()) {
+      if (errorCode.httpCode == code) return errorCode;
+    }
+    return null;
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/Header.java b/okhttp/src/main/java/okhttp3/internal/http2/Header.java
similarity index 85%
rename from okhttp/src/main/java/okhttp3/internal/framed/Header.java
rename to okhttp/src/main/java/okhttp3/internal/http2/Header.java
index 953671eb32..3cfd7be8d7 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/Header.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Header.java
@@ -13,20 +13,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.framed;
+package okhttp3.internal.http2;
 
+import okhttp3.internal.Util;
 import okio.ByteString;
 
 /** HTTP header: the name is an ASCII string, but the value can be UTF-8. */
 public final class Header {
-  // Special header names defined in the SPDY and HTTP/2 specs.
+  // Special header names defined in HTTP/2 spec.
+  public static final ByteString PSEUDO_PREFIX = ByteString.encodeUtf8(":");
   public static final ByteString RESPONSE_STATUS = ByteString.encodeUtf8(":status");
   public static final ByteString TARGET_METHOD = ByteString.encodeUtf8(":method");
   public static final ByteString TARGET_PATH = ByteString.encodeUtf8(":path");
   public static final ByteString TARGET_SCHEME = ByteString.encodeUtf8(":scheme");
-  public static final ByteString TARGET_AUTHORITY = ByteString.encodeUtf8(":authority"); // HTTP/2
-  public static final ByteString TARGET_HOST = ByteString.encodeUtf8(":host"); // spdy/3
-  public static final ByteString VERSION = ByteString.encodeUtf8(":version"); // spdy/3
+  public static final ByteString TARGET_AUTHORITY = ByteString.encodeUtf8(":authority");
 
   /** Name in case-insensitive ASCII encoding. */
   public final ByteString name;
@@ -66,6 +66,6 @@ public Header(ByteString name, ByteString value) {
   }
 
   @Override public String toString() {
-    return String.format("%s: %s", name.utf8(), value.utf8());
+    return Util.format("%s: %s", name.utf8(), value.utf8());
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/Hpack.java b/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
similarity index 65%
rename from okhttp/src/main/java/okhttp3/internal/framed/Hpack.java
rename to okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
index 2b49784e9b..3aeed262b4 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/Hpack.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.framed;
+package okhttp3.internal.http2;
 
 import java.io.IOException;
 import java.util.ArrayList;
@@ -22,6 +22,7 @@
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.ByteString;
@@ -116,8 +117,9 @@ private Hpack() {
     private final List<Header> headerList = new ArrayList<>();
     private final BufferedSource source;
 
-    private int headerTableSizeSetting;
+    private final int headerTableSizeSetting;
     private int maxDynamicTableByteCount;
+
     // Visible for testing.
     Header[] dynamicTable = new Header[8];
     // Array is populated back to front, so new entries always have lowest index.
@@ -126,8 +128,12 @@ private Hpack() {
     int dynamicTableByteCount = 0;
 
     Reader(int headerTableSizeSetting, Source source) {
+      this(headerTableSizeSetting, headerTableSizeSetting, source);
+    }
+
+    Reader(int headerTableSizeSetting, int maxDynamicTableByteCount, Source source) {
       this.headerTableSizeSetting = headerTableSizeSetting;
-      this.maxDynamicTableByteCount = headerTableSizeSetting;
+      this.maxDynamicTableByteCount = maxDynamicTableByteCount;
       this.source = Okio.buffer(source);
     }
 
@@ -135,19 +141,6 @@ int maxDynamicTableByteCount() {
       return maxDynamicTableByteCount;
     }
 
-    /**
-     * Called by the reader when the peer sent {@link Settings#HEADER_TABLE_SIZE}. While this
-     * establishes the maximum dynamic table size, the {@link #maxDynamicTableByteCount} set during
-     * processing may limit the table size to a smaller amount.
-     *
-     * <p>Evicts entries or clears the table as needed.
-     */
-    void headerTableSizeSetting(int headerTableSizeSetting) {
-      this.headerTableSizeSetting = headerTableSizeSetting;
-      this.maxDynamicTableByteCount = headerTableSizeSetting;
-      adjustDynamicTableByteCount();
-    }
-
     private void adjustDynamicTableByteCount() {
       if (maxDynamicTableByteCount < dynamicTableByteCount) {
         if (maxDynamicTableByteCount == 0) {
@@ -159,7 +152,6 @@ private void adjustDynamicTableByteCount() {
     }
 
     private void clearDynamicTable() {
-      headerList.clear();
       Arrays.fill(dynamicTable, null);
       nextHeaderIndex = dynamicTable.length - 1;
       headerCount = 0;
@@ -367,33 +359,171 @@ ByteString readByteString() throws IOException {
   }
 
   static final class Writer {
+    private static final int SETTINGS_HEADER_TABLE_SIZE = 4096;
+
+    /**
+     * The decoder has ultimate control of the maximum size of the dynamic table but we can choose
+     * to use less. We'll put a cap at 16K. This is arbitrary but should be enough for most
+     * purposes.
+     */
+    private static final int SETTINGS_HEADER_TABLE_SIZE_LIMIT = 16384;
+
     private final Buffer out;
+    private final boolean useCompression;
+
+    /**
+     * In the scenario where the dynamic table size changes multiple times between transmission of
+     * header blocks, we need to keep track of the smallest value in that interval.
+     */
+    private int smallestHeaderTableSizeSetting = Integer.MAX_VALUE;
+    private boolean emitDynamicTableSizeUpdate;
+
+    int headerTableSizeSetting;
+    int maxDynamicTableByteCount;
+
+    // Visible for testing.
+    Header[] dynamicTable = new Header[8];
+    // Array is populated back to front, so new entries always have lowest index.
+    int nextHeaderIndex = dynamicTable.length - 1;
+    int headerCount = 0;
+    int dynamicTableByteCount = 0;
 
     Writer(Buffer out) {
+      this(SETTINGS_HEADER_TABLE_SIZE, true, out);
+    }
+
+    Writer(int headerTableSizeSetting, boolean useCompression, Buffer out) {
+      this.headerTableSizeSetting = headerTableSizeSetting;
+      this.maxDynamicTableByteCount = headerTableSizeSetting;
+      this.useCompression = useCompression;
       this.out = out;
     }
 
+    private void clearDynamicTable() {
+      Arrays.fill(dynamicTable, null);
+      nextHeaderIndex = dynamicTable.length - 1;
+      headerCount = 0;
+      dynamicTableByteCount = 0;
+    }
+
+    /** Returns the count of entries evicted. */
+    private int evictToRecoverBytes(int bytesToRecover) {
+      int entriesToEvict = 0;
+      if (bytesToRecover > 0) {
+        // determine how many headers need to be evicted.
+        for (int j = dynamicTable.length - 1; j >= nextHeaderIndex && bytesToRecover > 0; j--) {
+          bytesToRecover -= dynamicTable[j].hpackSize;
+          dynamicTableByteCount -= dynamicTable[j].hpackSize;
+          headerCount--;
+          entriesToEvict++;
+        }
+        System.arraycopy(dynamicTable, nextHeaderIndex + 1, dynamicTable,
+            nextHeaderIndex + 1 + entriesToEvict, headerCount);
+        Arrays.fill(dynamicTable, nextHeaderIndex + 1, nextHeaderIndex + 1 + entriesToEvict, null);
+        nextHeaderIndex += entriesToEvict;
+      }
+      return entriesToEvict;
+    }
+
+    private void insertIntoDynamicTable(Header entry) {
+      int delta = entry.hpackSize;
+
+      // if the new or replacement header is too big, drop all entries.
+      if (delta > maxDynamicTableByteCount) {
+        clearDynamicTable();
+        return;
+      }
+
+      // Evict headers to the required length.
+      int bytesToRecover = (dynamicTableByteCount + delta) - maxDynamicTableByteCount;
+      evictToRecoverBytes(bytesToRecover);
+
+      if (headerCount + 1 > dynamicTable.length) { // Need to grow the dynamic table.
+        Header[] doubled = new Header[dynamicTable.length * 2];
+        System.arraycopy(dynamicTable, 0, doubled, dynamicTable.length, dynamicTable.length);
+        nextHeaderIndex = dynamicTable.length - 1;
+        dynamicTable = doubled;
+      }
+      int index = nextHeaderIndex--;
+      dynamicTable[index] = entry;
+      headerCount++;
+      dynamicTableByteCount += delta;
+    }
+
     /** This does not use "never indexed" semantics for sensitive headers. */
     // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-6.2.3
     void writeHeaders(List<Header> headerBlock) throws IOException {
-      // TODO: implement index tracking
+      if (emitDynamicTableSizeUpdate) {
+        if (smallestHeaderTableSizeSetting < maxDynamicTableByteCount) {
+          // Multiple dynamic table size updates!
+          writeInt(smallestHeaderTableSizeSetting, PREFIX_5_BITS, 0x20);
+        }
+        emitDynamicTableSizeUpdate = false;
+        smallestHeaderTableSizeSetting = Integer.MAX_VALUE;
+        writeInt(maxDynamicTableByteCount, PREFIX_5_BITS, 0x20);
+      }
+
       for (int i = 0, size = headerBlock.size(); i < size; i++) {
-        ByteString name = headerBlock.get(i).name.toAsciiLowercase();
+        Header header = headerBlock.get(i);
+        ByteString name = header.name.toAsciiLowercase();
+        ByteString value = header.value;
+        int headerIndex = -1;
+        int headerNameIndex = -1;
+
         Integer staticIndex = NAME_TO_FIRST_INDEX.get(name);
         if (staticIndex != null) {
-          // Literal Header Field without Indexing - Indexed Name.
-          writeInt(staticIndex + 1, PREFIX_4_BITS, 0);
-          writeByteString(headerBlock.get(i).value);
-        } else {
-          out.writeByte(0x00); // Literal Header without Indexing - New Name.
+          headerNameIndex = staticIndex + 1;
+          if (headerNameIndex > 1 && headerNameIndex < 8) {
+            // Only search a subset of the static header table. Most entries have an empty value, so
+            // it's unnecessary to waste cycles looking at them. This check is built on the
+            // observation that the header entries we care about are in adjacent pairs, and we
+            // always know the first index of the pair.
+            if (Util.equal(STATIC_HEADER_TABLE[headerNameIndex - 1].value, value)) {
+              headerIndex = headerNameIndex;
+            } else if (Util.equal(STATIC_HEADER_TABLE[headerNameIndex].value, value)) {
+              headerIndex = headerNameIndex + 1;
+            }
+          }
+        }
+
+        if (headerIndex == -1) {
+          for (int j = nextHeaderIndex + 1, length = dynamicTable.length; j < length; j++) {
+            if (Util.equal(dynamicTable[j].name, name)) {
+              if (Util.equal(dynamicTable[j].value, value)) {
+                headerIndex = j - nextHeaderIndex + STATIC_HEADER_TABLE.length;
+                break;
+              } else if (headerNameIndex == -1) {
+                headerNameIndex = j - nextHeaderIndex + STATIC_HEADER_TABLE.length;
+              }
+            }
+          }
+        }
+
+        if (headerIndex != -1) {
+          // Indexed Header Field.
+          writeInt(headerIndex, PREFIX_7_BITS, 0x80);
+        } else if (headerNameIndex == -1) {
+          // Literal Header Field with Incremental Indexing - New Name.
+          out.writeByte(0x40);
           writeByteString(name);
-          writeByteString(headerBlock.get(i).value);
+          writeByteString(value);
+          insertIntoDynamicTable(header);
+        } else if (name.startsWith(Header.PSEUDO_PREFIX) && !Header.TARGET_AUTHORITY.equals(name)) {
+          // Follow Chromes lead - only include the :authority pseudo header, but exclude all other
+          // pseudo headers. Literal Header Field without Indexing - Indexed Name.
+          writeInt(headerNameIndex, PREFIX_4_BITS, 0);
+          writeByteString(value);
+        } else {
+          // Literal Header Field with Incremental Indexing - Indexed Name.
+          writeInt(headerNameIndex, PREFIX_6_BITS, 0x40);
+          writeByteString(value);
+          insertIntoDynamicTable(header);
         }
       }
     }
 
     // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-4.1.1
-    void writeInt(int value, int prefixMask, int bits) throws IOException {
+    void writeInt(int value, int prefixMask, int bits) {
       // Write the raw value for a single byte value.
       if (value < prefixMask) {
         out.writeByte(bits | value);
@@ -414,8 +544,42 @@ void writeInt(int value, int prefixMask, int bits) throws IOException {
     }
 
     void writeByteString(ByteString data) throws IOException {
-      writeInt(data.size(), PREFIX_7_BITS, 0);
-      out.write(data);
+      if (useCompression && Huffman.get().encodedLength(data) < data.size()) {
+        Buffer huffmanBuffer = new Buffer();
+        Huffman.get().encode(data, huffmanBuffer);
+        ByteString huffmanBytes = huffmanBuffer.readByteString();
+        writeInt(huffmanBytes.size(), PREFIX_7_BITS, 0x80);
+        out.write(huffmanBytes);
+      } else {
+        writeInt(data.size(), PREFIX_7_BITS, 0);
+        out.write(data);
+      }
+    }
+
+    void setHeaderTableSizeSetting(int headerTableSizeSetting) {
+      this.headerTableSizeSetting = headerTableSizeSetting;
+      int effectiveHeaderTableSize = Math.min(headerTableSizeSetting,
+          SETTINGS_HEADER_TABLE_SIZE_LIMIT);
+
+      if (maxDynamicTableByteCount == effectiveHeaderTableSize) return; // No change.
+
+      if (effectiveHeaderTableSize < maxDynamicTableByteCount) {
+        smallestHeaderTableSizeSetting = Math.min(smallestHeaderTableSizeSetting,
+            effectiveHeaderTableSize);
+      }
+      emitDynamicTableSizeUpdate = true;
+      maxDynamicTableByteCount = effectiveHeaderTableSize;
+      adjustDynamicTableByteCount();
+    }
+
+    private void adjustDynamicTableByteCount() {
+      if (maxDynamicTableByteCount < dynamicTableByteCount) {
+        if (maxDynamicTableByteCount == 0) {
+          clearDynamicTable();
+        } else {
+          evictToRecoverBytes(dynamicTableByteCount - maxDynamicTableByteCount);
+        }
+      }
     }
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2.java
new file mode 100644
index 0000000000..cecee406ce
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2.java
@@ -0,0 +1,167 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import java.io.IOException;
+import okio.ByteString;
+
+import static okhttp3.internal.Util.format;
+
+public final class Http2 {
+  static final ByteString CONNECTION_PREFACE
+      = ByteString.encodeUtf8("PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n");
+
+  /** The initial max frame size, applied independently writing to, or reading from the peer. */
+  static final int INITIAL_MAX_FRAME_SIZE = 0x4000; // 16384
+
+  static final byte TYPE_DATA = 0x0;
+  static final byte TYPE_HEADERS = 0x1;
+  static final byte TYPE_PRIORITY = 0x2;
+  static final byte TYPE_RST_STREAM = 0x3;
+  static final byte TYPE_SETTINGS = 0x4;
+  static final byte TYPE_PUSH_PROMISE = 0x5;
+  static final byte TYPE_PING = 0x6;
+  static final byte TYPE_GOAWAY = 0x7;
+  static final byte TYPE_WINDOW_UPDATE = 0x8;
+  static final byte TYPE_CONTINUATION = 0x9;
+
+  static final byte FLAG_NONE = 0x0;
+  static final byte FLAG_ACK = 0x1; // Used for settings and ping.
+  static final byte FLAG_END_STREAM = 0x1; // Used for headers and data.
+  static final byte FLAG_END_HEADERS = 0x4; // Used for headers and continuation.
+  static final byte FLAG_END_PUSH_PROMISE = 0x4;
+  static final byte FLAG_PADDED = 0x8; // Used for headers and data.
+  static final byte FLAG_PRIORITY = 0x20; // Used for headers.
+  static final byte FLAG_COMPRESSED = 0x20; // Used for data.
+
+  /** Lookup table for valid frame types. */
+  private static final String[] FRAME_NAMES = new String[] {
+      "DATA",
+      "HEADERS",
+      "PRIORITY",
+      "RST_STREAM",
+      "SETTINGS",
+      "PUSH_PROMISE",
+      "PING",
+      "GOAWAY",
+      "WINDOW_UPDATE",
+      "CONTINUATION"
+  };
+
+  /**
+   * Lookup table for valid flags for DATA, HEADERS, CONTINUATION. Invalid combinations are
+   * represented in binary.
+   */
+  static final String[] FLAGS = new String[0x40]; // Highest bit flag is 0x20.
+  static final String[] BINARY = new String[256];
+  static {
+    for (int i = 0; i < BINARY.length; i++) {
+      BINARY[i] = format("%8s", Integer.toBinaryString(i)).replace(' ', '0');
+    }
+
+    FLAGS[FLAG_NONE] = "";
+    FLAGS[FLAG_END_STREAM] = "END_STREAM";
+
+    int[] prefixFlags = new int[] {FLAG_END_STREAM};
+
+    FLAGS[FLAG_PADDED] = "PADDED";
+    for (int prefixFlag : prefixFlags) {
+      FLAGS[prefixFlag | FLAG_PADDED] = FLAGS[prefixFlag] + "|PADDED";
+    }
+
+    FLAGS[FLAG_END_HEADERS] = "END_HEADERS"; // Same as END_PUSH_PROMISE.
+    FLAGS[FLAG_PRIORITY] = "PRIORITY"; // Same as FLAG_COMPRESSED.
+    FLAGS[FLAG_END_HEADERS | FLAG_PRIORITY] = "END_HEADERS|PRIORITY"; // Only valid on HEADERS.
+    int[] frameFlags = new int[] {
+        FLAG_END_HEADERS, FLAG_PRIORITY, FLAG_END_HEADERS | FLAG_PRIORITY
+    };
+
+    for (int frameFlag : frameFlags) {
+      for (int prefixFlag : prefixFlags) {
+        FLAGS[prefixFlag | frameFlag] = FLAGS[prefixFlag] + '|' + FLAGS[frameFlag];
+        FLAGS[prefixFlag | frameFlag | FLAG_PADDED]
+            = FLAGS[prefixFlag] + '|' + FLAGS[frameFlag] + "|PADDED";
+      }
+    }
+
+    for (int i = 0; i < FLAGS.length; i++) { // Fill in holes with binary representation.
+      if (FLAGS[i] == null) FLAGS[i] = BINARY[i];
+    }
+  }
+
+  private Http2() {
+  }
+
+  static IllegalArgumentException illegalArgument(String message, Object... args) {
+    throw new IllegalArgumentException(format(message, args));
+  }
+
+  static IOException ioException(String message, Object... args) throws IOException {
+    throw new IOException(format(message, args));
+  }
+
+  /**
+   * Returns human-readable representation of HTTP/2 frame headers.
+   *
+   * <p>The format is:
+   *
+   * <pre>
+   *   direction streamID length type flags
+   * </pre>
+   *
+   * Where direction is {@code <<} for inbound and {@code >>} for outbound.
+   *
+   * <p>For example, the following would indicate a HEAD request sent from the client.
+   * <pre>
+   * {@code
+   *   << 0x0000000f    12 HEADERS       END_HEADERS|END_STREAM
+   * }
+   * </pre>
+   */
+  static String frameLog(boolean inbound, int streamId, int length, byte type, byte flags) {
+    String formattedType = type < FRAME_NAMES.length ? FRAME_NAMES[type] : format("0x%02x", type);
+    String formattedFlags = formatFlags(type, flags);
+    return format("%s 0x%08x %5d %-13s %s", inbound ? "<<" : ">>", streamId, length,
+        formattedType, formattedFlags);
+  }
+
+  /**
+   * Looks up valid string representing flags from the table. Invalid combinations are represented
+   * in binary.
+   */
+  // Visible for testing.
+  static String formatFlags(byte type, byte flags) {
+    if (flags == 0) return "";
+    switch (type) { // Special case types that have 0 or 1 flag.
+      case TYPE_SETTINGS:
+      case TYPE_PING:
+        return flags == FLAG_ACK ? "ACK" : BINARY[flags];
+      case TYPE_PRIORITY:
+      case TYPE_RST_STREAM:
+      case TYPE_GOAWAY:
+      case TYPE_WINDOW_UPDATE:
+        return BINARY[flags];
+    }
+    String result = flags < FLAGS.length ? FLAGS[flags] : BINARY[flags];
+    // Special case types that have overlap flag values.
+    if (type == TYPE_PUSH_PROMISE && (flags & FLAG_END_PUSH_PROMISE) != 0) {
+      return result.replace("HEADERS", "PUSH_PROMISE"); // TODO: Avoid allocation.
+    } else if (type == TYPE_DATA && (flags & FLAG_COMPRESSED) != 0) {
+      return result.replace("PRIORITY", "COMPRESSED"); // TODO: Avoid allocation.
+    }
+    return result;
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
new file mode 100644
index 0000000000..c2e0a38582
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
@@ -0,0 +1,181 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Locale;
+import java.util.concurrent.TimeUnit;
+import okhttp3.Headers;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.Internal;
+import okhttp3.internal.Util;
+import okhttp3.internal.connection.StreamAllocation;
+import okhttp3.internal.http.HttpCodec;
+import okhttp3.internal.http.HttpMethod;
+import okhttp3.internal.http.RealResponseBody;
+import okhttp3.internal.http.RequestLine;
+import okhttp3.internal.http.StatusLine;
+import okio.ByteString;
+import okio.ForwardingSource;
+import okio.Okio;
+import okio.Sink;
+import okio.Source;
+
+import static okhttp3.internal.http2.Header.RESPONSE_STATUS;
+import static okhttp3.internal.http2.Header.TARGET_AUTHORITY;
+import static okhttp3.internal.http2.Header.TARGET_METHOD;
+import static okhttp3.internal.http2.Header.TARGET_PATH;
+import static okhttp3.internal.http2.Header.TARGET_SCHEME;
+
+/** Encode requests and responses using HTTP/2 frames. */
+public final class Http2Codec implements HttpCodec {
+  private static final ByteString CONNECTION = ByteString.encodeUtf8("connection");
+  private static final ByteString HOST = ByteString.encodeUtf8("host");
+  private static final ByteString KEEP_ALIVE = ByteString.encodeUtf8("keep-alive");
+  private static final ByteString PROXY_CONNECTION = ByteString.encodeUtf8("proxy-connection");
+  private static final ByteString TRANSFER_ENCODING = ByteString.encodeUtf8("transfer-encoding");
+  private static final ByteString TE = ByteString.encodeUtf8("te");
+  private static final ByteString ENCODING = ByteString.encodeUtf8("encoding");
+  private static final ByteString UPGRADE = ByteString.encodeUtf8("upgrade");
+
+  /** See http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-8.1.3. */
+  private static final List<ByteString> HTTP_2_SKIPPED_REQUEST_HEADERS = Util.immutableList(
+      CONNECTION,
+      HOST,
+      KEEP_ALIVE,
+      PROXY_CONNECTION,
+      TE,
+      TRANSFER_ENCODING,
+      ENCODING,
+      UPGRADE,
+      TARGET_METHOD,
+      TARGET_PATH,
+      TARGET_SCHEME,
+      TARGET_AUTHORITY);
+  private static final List<ByteString> HTTP_2_SKIPPED_RESPONSE_HEADERS = Util.immutableList(
+      CONNECTION,
+      HOST,
+      KEEP_ALIVE,
+      PROXY_CONNECTION,
+      TE,
+      TRANSFER_ENCODING,
+      ENCODING,
+      UPGRADE);
+
+  private final OkHttpClient client;
+  private final StreamAllocation streamAllocation;
+  private final Http2Connection connection;
+  private Http2Stream stream;
+
+  public Http2Codec(
+      OkHttpClient client, StreamAllocation streamAllocation, Http2Connection connection) {
+    this.client = client;
+    this.streamAllocation = streamAllocation;
+    this.connection = connection;
+  }
+
+  @Override public Sink createRequestBody(Request request, long contentLength) {
+    return stream.getSink();
+  }
+
+  @Override public void writeRequestHeaders(Request request) throws IOException {
+    if (stream != null) return;
+
+    boolean permitsRequestBody = HttpMethod.permitsRequestBody(request.method());
+    List<Header> requestHeaders = http2HeadersList(request);
+    stream = connection.newStream(requestHeaders, permitsRequestBody);
+    stream.readTimeout().timeout(client.readTimeoutMillis(), TimeUnit.MILLISECONDS);
+    stream.writeTimeout().timeout(client.writeTimeoutMillis(), TimeUnit.MILLISECONDS);
+  }
+
+  @Override public void finishRequest() throws IOException {
+    stream.getSink().close();
+  }
+
+  @Override public Response.Builder readResponseHeaders() throws IOException {
+    return readHttp2HeadersList(stream.getResponseHeaders());
+  }
+
+  public static List<Header> http2HeadersList(Request request) {
+    Headers headers = request.headers();
+    List<Header> result = new ArrayList<>(headers.size() + 4);
+    result.add(new Header(TARGET_METHOD, request.method()));
+    result.add(new Header(TARGET_PATH, RequestLine.requestPath(request.url())));
+    result.add(new Header(TARGET_AUTHORITY, Util.hostHeader(request.url(), false))); // Optional.
+    result.add(new Header(TARGET_SCHEME, request.url().scheme()));
+
+    for (int i = 0, size = headers.size(); i < size; i++) {
+      // header names must be lowercase.
+      ByteString name = ByteString.encodeUtf8(headers.name(i).toLowerCase(Locale.US));
+      if (!HTTP_2_SKIPPED_REQUEST_HEADERS.contains(name)) {
+        result.add(new Header(name, headers.value(i)));
+      }
+    }
+    return result;
+  }
+
+  /** Returns headers for a name value block containing an HTTP/2 response. */
+  public static Response.Builder readHttp2HeadersList(List<Header> headerBlock) throws IOException {
+    String status = null;
+
+    Headers.Builder headersBuilder = new Headers.Builder();
+    for (int i = 0, size = headerBlock.size(); i < size; i++) {
+      ByteString name = headerBlock.get(i).name;
+
+      String value = headerBlock.get(i).value.utf8();
+      if (name.equals(RESPONSE_STATUS)) {
+        status = value;
+      } else if (!HTTP_2_SKIPPED_RESPONSE_HEADERS.contains(name)) {
+        Internal.instance.addLenient(headersBuilder, name.utf8(), value);
+      }
+    }
+    if (status == null) throw new ProtocolException("Expected ':status' header not present");
+
+    StatusLine statusLine = StatusLine.parse("HTTP/1.1 " + status);
+    return new Response.Builder()
+        .protocol(Protocol.HTTP_2)
+        .code(statusLine.code)
+        .message(statusLine.message)
+        .headers(headersBuilder.build());
+  }
+
+  @Override public ResponseBody openResponseBody(Response response) throws IOException {
+    Source source = new StreamFinishingSource(stream.getSource());
+    return new RealResponseBody(response.headers(), Okio.buffer(source));
+  }
+
+  @Override public void cancel() {
+    if (stream != null) stream.closeLater(ErrorCode.CANCEL);
+  }
+
+  class StreamFinishingSource extends ForwardingSource {
+    public StreamFinishingSource(Source delegate) {
+      super(delegate);
+    }
+
+    @Override public void close() throws IOException {
+      streamAllocation.streamFinished(false, Http2Codec.this);
+      super.close();
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/FramedConnection.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
similarity index 72%
rename from okhttp/src/main/java/okhttp3/internal/framed/FramedConnection.java
rename to okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
index 4a6a8e7d09..b367c521e5 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/FramedConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.framed;
+package okhttp3.internal.http2;
 
 import java.io.Closeable;
 import java.io.IOException;
@@ -30,29 +30,29 @@
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
-import java.util.logging.Level;
 import okhttp3.Protocol;
 import okhttp3.internal.NamedRunnable;
 import okhttp3.internal.Util;
+import okhttp3.internal.platform.Platform;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.ByteString;
 import okio.Okio;
 
-import static okhttp3.internal.Internal.logger;
-import static okhttp3.internal.framed.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
+import static okhttp3.internal.http2.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
+import static okhttp3.internal.platform.Platform.INFO;
 
 /**
  * A socket connection to a remote peer. A connection hosts streams which can send and receive
  * data.
  *
  * <p>Many methods in this API are <strong>synchronous:</strong> the call is completed before the
- * method returns. This is typical for Java but atypical for SPDY. This is motivated by exception
+ * method returns. This is typical for Java but atypical for HTTP/2. This is motivated by exception
  * transparency: an IOException that was triggered by a certain caller can be caught and handled by
  * that caller.
  */
-public final class FramedConnection implements Closeable {
+public final class Http2Connection implements Closeable {
 
   // Internal state of this connection is guarded by 'this'. No blocking
   // operations may be performed while holding this lock!
@@ -70,9 +70,6 @@
       Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),
       Util.threadFactory("OkHttp FramedConnection", true));
 
-  /** The protocol variant, like {@link Spdy3}. */
-  final Protocol protocol;
-
   /** True if this peer initiated the connection. */
   final boolean client;
 
@@ -81,12 +78,11 @@
    * on {@link #executor}.
    */
   private final Listener listener;
-  private final Map<Integer, FramedStream> streams = new HashMap<>();
+  private final Map<Integer, Http2Stream> streams = new HashMap<>();
   private final String hostname;
   private int lastGoodStreamId;
   private int nextStreamId;
   private boolean shutdown;
-  private long idleStartTimeNs = System.nanoTime();
 
   /** Ensures push promise callbacks events are sent in order per stream. */
   private final ExecutorService pushExecutor;
@@ -120,21 +116,19 @@
   final Settings peerSettings = new Settings();
 
   private boolean receivedInitialPeerSettings = false;
-  final Variant variant;
   final Socket socket;
-  final FrameWriter frameWriter;
+  final Http2Writer writer;
 
   // Visible for testing
-  final Reader readerRunnable;
+  final ReaderRunnable readerRunnable;
 
-  private FramedConnection(Builder builder) throws IOException {
-    protocol = builder.protocol;
+  private Http2Connection(Builder builder) {
     pushObserver = builder.pushObserver;
     client = builder.client;
     listener = builder.listener;
     // http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-5.1.1
     nextStreamId = builder.client ? 1 : 2;
-    if (builder.client && protocol == Protocol.HTTP_2) {
+    if (builder.client) {
       nextStreamId += 2; // In HTTP/2, 1 on client is reserved for Upgrade.
     }
 
@@ -145,79 +139,50 @@ private FramedConnection(Builder builder) throws IOException {
     // thrashing window updates every 64KiB, yet small enough to avoid blowing
     // up the heap.
     if (builder.client) {
-      okHttpSettings.set(Settings.INITIAL_WINDOW_SIZE, 0, OKHTTP_CLIENT_WINDOW_SIZE);
+      okHttpSettings.set(Settings.INITIAL_WINDOW_SIZE, OKHTTP_CLIENT_WINDOW_SIZE);
     }
 
     hostname = builder.hostname;
 
-    if (protocol == Protocol.HTTP_2) {
-      variant = new Http2();
-      // Like newSingleThreadExecutor, except lazy creates the thread.
-      pushExecutor = new ThreadPoolExecutor(0, 1, 60, TimeUnit.SECONDS,
-          new LinkedBlockingQueue<Runnable>(),
-          Util.threadFactory(String.format("OkHttp %s Push Observer", hostname), true));
-      // 1 less than SPDY http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-6.9.2
-      peerSettings.set(Settings.INITIAL_WINDOW_SIZE, 0, 65535);
-      peerSettings.set(Settings.MAX_FRAME_SIZE, 0, Http2.INITIAL_MAX_FRAME_SIZE);
-    } else if (protocol == Protocol.SPDY_3) {
-      variant = new Spdy3();
-      pushExecutor = null;
-    } else {
-      throw new AssertionError(protocol);
-    }
-    bytesLeftInWriteWindow = peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE);
+    // Like newSingleThreadExecutor, except lazy creates the thread.
+    pushExecutor = new ThreadPoolExecutor(0, 1, 60, TimeUnit.SECONDS,
+        new LinkedBlockingQueue<Runnable>(),
+        Util.threadFactory(Util.format("OkHttp %s Push Observer", hostname), true));
+    peerSettings.set(Settings.INITIAL_WINDOW_SIZE, DEFAULT_INITIAL_WINDOW_SIZE);
+    peerSettings.set(Settings.MAX_FRAME_SIZE, Http2.INITIAL_MAX_FRAME_SIZE);
+    bytesLeftInWriteWindow = peerSettings.getInitialWindowSize();
     socket = builder.socket;
-    frameWriter = variant.newWriter(builder.sink, client);
+    writer = new Http2Writer(builder.sink, client);
 
-    readerRunnable = new Reader(variant.newReader(builder.source, client));
+    readerRunnable = new ReaderRunnable(new Http2Reader(builder.source, client));
   }
 
   /** The protocol as selected using ALPN. */
   public Protocol getProtocol() {
-    return protocol;
+    return Protocol.HTTP_2;
   }
 
   /**
-   * Returns the number of {@link FramedStream#isOpen() open streams} on this connection.
+   * Returns the number of {@link Http2Stream#isOpen() open streams} on this connection.
    */
   public synchronized int openStreamCount() {
     return streams.size();
   }
 
-  synchronized FramedStream getStream(int id) {
+  synchronized Http2Stream getStream(int id) {
     return streams.get(id);
   }
 
-  synchronized FramedStream removeStream(int streamId) {
-    FramedStream stream = streams.remove(streamId);
-    if (stream != null && streams.isEmpty()) {
-      setIdle(true);
-    }
+  synchronized Http2Stream removeStream(int streamId) {
+    Http2Stream stream = streams.remove(streamId);
     notifyAll(); // The removed stream may be blocked on a connection-wide window update.
     return stream;
   }
 
-  private synchronized void setIdle(boolean value) {
-    idleStartTimeNs = value ? System.nanoTime() : Long.MAX_VALUE;
-  }
-
-  /** Returns true if this connection is idle. */
-  public synchronized boolean isIdle() {
-    return idleStartTimeNs != Long.MAX_VALUE;
-  }
-
   public synchronized int maxConcurrentStreams() {
     return peerSettings.getMaxConcurrentStreams(Integer.MAX_VALUE);
   }
 
-  /**
-   * Returns the time in ns when this connection became idle or Long.MAX_VALUE if connection is not
-   * idle.
-   */
-  public synchronized long getIdleStartTimeNs() {
-    return idleStartTimeNs;
-  }
-
   /**
    * Returns a new server-initiated stream.
    *
@@ -225,58 +190,53 @@ public synchronized long getIdleStartTimeNs() {
    * @param out true to create an output stream that we can use to send data to the remote peer.
    * Corresponds to {@code FLAG_FIN}.
    */
-  public FramedStream pushStream(int associatedStreamId, List<Header> requestHeaders, boolean out)
+  public Http2Stream pushStream(int associatedStreamId, List<Header> requestHeaders, boolean out)
       throws IOException {
     if (client) throw new IllegalStateException("Client cannot push requests.");
-    if (protocol != Protocol.HTTP_2) throw new IllegalStateException("protocol != HTTP_2");
-    return newStream(associatedStreamId, requestHeaders, out, false);
+    return newStream(associatedStreamId, requestHeaders, out);
   }
 
   /**
    * Returns a new locally-initiated stream.
-   *
    * @param out true to create an output stream that we can use to send data to the remote peer.
    * Corresponds to {@code FLAG_FIN}.
-   * @param in true to create an input stream that the remote peer can use to send data to us.
-   * Corresponds to {@code FLAG_UNIDIRECTIONAL}.
    */
-  public FramedStream newStream(List<Header> requestHeaders, boolean out, boolean in)
-      throws IOException {
-    return newStream(0, requestHeaders, out, in);
+  public Http2Stream newStream(List<Header> requestHeaders, boolean out) throws IOException {
+    return newStream(0, requestHeaders, out);
   }
 
-  private FramedStream newStream(int associatedStreamId, List<Header> requestHeaders, boolean out,
-      boolean in) throws IOException {
+  private Http2Stream newStream(
+      int associatedStreamId, List<Header> requestHeaders, boolean out) throws IOException {
     boolean outFinished = !out;
-    boolean inFinished = !in;
-    FramedStream stream;
+    boolean inFinished = false;
+    boolean flushHeaders;
+    Http2Stream stream;
     int streamId;
 
-    synchronized (frameWriter) {
+    synchronized (writer) {
       synchronized (this) {
         if (shutdown) {
           throw new IOException("shutdown");
         }
         streamId = nextStreamId;
         nextStreamId += 2;
-        stream = new FramedStream(streamId, this, outFinished, inFinished, requestHeaders);
+        stream = new Http2Stream(streamId, this, outFinished, inFinished, requestHeaders);
+        flushHeaders = !out || bytesLeftInWriteWindow == 0L || stream.bytesLeftInWriteWindow == 0L;
         if (stream.isOpen()) {
           streams.put(streamId, stream);
-          setIdle(false);
         }
       }
       if (associatedStreamId == 0) {
-        frameWriter.synStream(outFinished, inFinished, streamId, associatedStreamId,
-            requestHeaders);
+        writer.synStream(outFinished, streamId, associatedStreamId, requestHeaders);
       } else if (client) {
         throw new IllegalArgumentException("client streams shouldn't have associated stream IDs");
       } else { // HTTP/2 has a PUSH_PROMISE frame.
-        frameWriter.pushPromise(associatedStreamId, streamId, requestHeaders);
+        writer.pushPromise(associatedStreamId, streamId, requestHeaders);
       }
     }
 
-    if (!out) {
-      frameWriter.flush();
+    if (flushHeaders) {
+      writer.flush();
     }
 
     return stream;
@@ -284,7 +244,7 @@ private FramedStream newStream(int associatedStreamId, List<Header> requestHeade
 
   void writeSynReply(int streamId, boolean outFinished, List<Header> alternating)
       throws IOException {
-    frameWriter.synReply(outFinished, streamId, alternating);
+    writer.synReply(outFinished, streamId, alternating);
   }
 
   /**
@@ -302,13 +262,13 @@ void writeSynReply(int streamId, boolean outFinished, List<Header> alternating)
   public void writeData(int streamId, boolean outFinished, Buffer buffer, long byteCount)
       throws IOException {
     if (byteCount == 0) { // Empty data frames are not flow-controlled.
-      frameWriter.data(outFinished, streamId, buffer, 0);
+      writer.data(outFinished, streamId, buffer, 0);
       return;
     }
 
     while (byteCount > 0) {
       int toWrite;
-      synchronized (FramedConnection.this) {
+      synchronized (Http2Connection.this) {
         try {
           while (bytesLeftInWriteWindow <= 0) {
             // Before blocking, confirm that the stream we're writing is still open. It's possible
@@ -316,19 +276,19 @@ public void writeData(int streamId, boolean outFinished, Buffer buffer, long byt
             if (!streams.containsKey(streamId)) {
               throw new IOException("stream closed");
             }
-            FramedConnection.this.wait(); // Wait until we receive a WINDOW_UPDATE.
+            Http2Connection.this.wait(); // Wait until we receive a WINDOW_UPDATE.
           }
         } catch (InterruptedException e) {
           throw new InterruptedIOException();
         }
 
         toWrite = (int) Math.min(byteCount, bytesLeftInWriteWindow);
-        toWrite = Math.min(toWrite, frameWriter.maxDataLength());
+        toWrite = Math.min(toWrite, writer.maxDataLength());
         bytesLeftInWriteWindow -= toWrite;
       }
 
       byteCount -= toWrite;
-      frameWriter.data(outFinished && byteCount == 0, streamId, buffer, toWrite);
+      writer.data(outFinished && byteCount == 0, streamId, buffer, toWrite);
     }
   }
 
@@ -337,7 +297,7 @@ public void writeData(int streamId, boolean outFinished, Buffer buffer, long byt
    */
   void addBytesToWriteWindow(long delta) {
     bytesLeftInWriteWindow += delta;
-    if (delta > 0) FramedConnection.this.notifyAll();
+    if (delta > 0) Http2Connection.this.notifyAll();
   }
 
   void writeSynResetLater(final int streamId, final ErrorCode errorCode) {
@@ -352,14 +312,14 @@ void writeSynResetLater(final int streamId, final ErrorCode errorCode) {
   }
 
   void writeSynReset(int streamId, ErrorCode statusCode) throws IOException {
-    frameWriter.rstStream(streamId, statusCode);
+    writer.rstStream(streamId, statusCode);
   }
 
   void writeWindowUpdateLater(final int streamId, final long unacknowledgedBytesRead) {
     executor.execute(new NamedRunnable("OkHttp Window Update %s stream %d", hostname, streamId) {
       @Override public void execute() {
         try {
-          frameWriter.windowUpdate(streamId, unacknowledgedBytesRead);
+          writer.windowUpdate(streamId, unacknowledgedBytesRead);
         } catch (IOException ignored) {
         }
       }
@@ -400,10 +360,10 @@ private void writePingLater(
   }
 
   private void writePing(boolean reply, int payload1, int payload2, Ping ping) throws IOException {
-    synchronized (frameWriter) {
+    synchronized (writer) {
       // Observe the sent time immediately before performing I/O.
       if (ping != null) ping.send();
-      frameWriter.ping(reply, payload1, payload2);
+      writer.ping(reply, payload1, payload2);
     }
   }
 
@@ -412,7 +372,7 @@ private synchronized Ping removePing(int id) {
   }
 
   public void flush() throws IOException {
-    frameWriter.flush();
+    writer.flush();
   }
 
   /**
@@ -421,7 +381,7 @@ public void flush() throws IOException {
    * to gracefully stop accepting new requests without harming previously established streams.
    */
   public void shutdown(ErrorCode statusCode) throws IOException {
-    synchronized (frameWriter) {
+    synchronized (writer) {
       int lastGoodStreamId;
       synchronized (this) {
         if (shutdown) {
@@ -431,7 +391,7 @@ public void shutdown(ErrorCode statusCode) throws IOException {
         lastGoodStreamId = this.lastGoodStreamId;
       }
       // TODO: propagate exception message into debugData
-      frameWriter.goAway(lastGoodStreamId, statusCode, Util.EMPTY_BYTE_ARRAY);
+      writer.goAway(lastGoodStreamId, statusCode, Util.EMPTY_BYTE_ARRAY);
     }
   }
 
@@ -452,13 +412,12 @@ private void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOExce
       thrown = e;
     }
 
-    FramedStream[] streamsToClose = null;
+    Http2Stream[] streamsToClose = null;
     Ping[] pingsToCancel = null;
     synchronized (this) {
       if (!streams.isEmpty()) {
-        streamsToClose = streams.values().toArray(new FramedStream[streams.size()]);
+        streamsToClose = streams.values().toArray(new Http2Stream[streams.size()]);
         streams.clear();
-        setIdle(false);
       }
       if (pings != null) {
         pingsToCancel = pings.values().toArray(new Ping[pings.size()]);
@@ -467,7 +426,7 @@ private void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOExce
     }
 
     if (streamsToClose != null) {
-      for (FramedStream stream : streamsToClose) {
+      for (Http2Stream stream : streamsToClose) {
         try {
           stream.close(streamCode);
         } catch (IOException e) {
@@ -484,7 +443,7 @@ private void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOExce
 
     // Close the writer to release its resources (such as deflaters).
     try {
-      frameWriter.close();
+      writer.close();
     } catch (IOException e) {
       if (thrown == null) thrown = e;
     }
@@ -513,11 +472,11 @@ public void start() throws IOException {
    */
   void start(boolean sendConnectionPreface) throws IOException {
     if (sendConnectionPreface) {
-      frameWriter.connectionPreface();
-      frameWriter.settings(okHttpSettings);
-      int windowSize = okHttpSettings.getInitialWindowSize(Settings.DEFAULT_INITIAL_WINDOW_SIZE);
+      writer.connectionPreface();
+      writer.settings(okHttpSettings);
+      int windowSize = okHttpSettings.getInitialWindowSize();
       if (windowSize != Settings.DEFAULT_INITIAL_WINDOW_SIZE) {
-        frameWriter.windowUpdate(0, windowSize - Settings.DEFAULT_INITIAL_WINDOW_SIZE);
+        writer.windowUpdate(0, windowSize - Settings.DEFAULT_INITIAL_WINDOW_SIZE);
       }
     }
     new Thread(readerRunnable).start(); // Not a daemon thread.
@@ -525,13 +484,13 @@ void start(boolean sendConnectionPreface) throws IOException {
 
   /** Merges {@code settings} into this peer's settings and sends them to the remote peer. */
   public void setSettings(Settings settings) throws IOException {
-    synchronized (frameWriter) {
+    synchronized (writer) {
       synchronized (this) {
         if (shutdown) {
           throw new IOException("shutdown");
         }
         okHttpSettings.merge(settings);
-        frameWriter.settings(settings);
+        writer.settings(settings);
       }
     }
   }
@@ -542,7 +501,6 @@ public void setSettings(Settings settings) throws IOException {
     private BufferedSource source;
     private BufferedSink sink;
     private Listener listener = Listener.REFUSE_INCOMING_STREAMS;
-    private Protocol protocol = Protocol.SPDY_3;
     private PushObserver pushObserver = PushObserver.CANCEL;
     private boolean client;
 
@@ -550,7 +508,7 @@ public void setSettings(Settings settings) throws IOException {
      * @param client true if this peer initiated the connection; false if this peer accepted the
      * connection.
      */
-    public Builder(boolean client) throws IOException {
+    public Builder(boolean client) {
       this.client = client;
     }
 
@@ -573,18 +531,13 @@ public Builder listener(Listener listener) {
       return this;
     }
 
-    public Builder protocol(Protocol protocol) {
-      this.protocol = protocol;
-      return this;
-    }
-
     public Builder pushObserver(PushObserver pushObserver) {
       this.pushObserver = pushObserver;
       return this;
     }
 
-    public FramedConnection build() throws IOException {
-      return new FramedConnection(this);
+    public Http2Connection build() throws IOException {
+      return new Http2Connection(this);
     }
   }
 
@@ -592,12 +545,12 @@ public FramedConnection build() throws IOException {
    * Methods in this class must not lock FrameWriter.  If a method needs to write a frame, create an
    * async task to do so.
    */
-  class Reader extends NamedRunnable implements FrameReader.Handler {
-    final FrameReader frameReader;
+  class ReaderRunnable extends NamedRunnable implements Http2Reader.Handler {
+    final Http2Reader reader;
 
-    private Reader(FrameReader frameReader) {
+    private ReaderRunnable(Http2Reader reader) {
       super("OkHttp %s", hostname);
-      this.frameReader = frameReader;
+      this.reader = reader;
     }
 
     @Override protected void execute() {
@@ -605,9 +558,9 @@ private Reader(FrameReader frameReader) {
       ErrorCode streamErrorCode = ErrorCode.INTERNAL_ERROR;
       try {
         if (!client) {
-          frameReader.readConnectionPreface();
+          reader.readConnectionPreface();
         }
-        while (frameReader.nextFrame(this)) {
+        while (reader.nextFrame(this)) {
         }
         connectionErrorCode = ErrorCode.NO_ERROR;
         streamErrorCode = ErrorCode.CANCEL;
@@ -619,7 +572,7 @@ private Reader(FrameReader frameReader) {
           close(connectionErrorCode, streamErrorCode);
         } catch (IOException ignored) {
         }
-        Util.closeQuietly(frameReader);
+        Util.closeQuietly(reader);
       }
     }
 
@@ -629,9 +582,9 @@ private Reader(FrameReader frameReader) {
         pushDataLater(streamId, source, length, inFinished);
         return;
       }
-      FramedStream dataStream = getStream(streamId);
+      Http2Stream dataStream = getStream(streamId);
       if (dataStream == null) {
-        writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);
+        writeSynResetLater(streamId, ErrorCode.PROTOCOL_ERROR);
         source.skip(length);
         return;
       }
@@ -641,26 +594,20 @@ private Reader(FrameReader frameReader) {
       }
     }
 
-    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
-        int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {
+    @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,
+        List<Header> headerBlock) {
       if (pushedStream(streamId)) {
         pushHeadersLater(streamId, headerBlock, inFinished);
         return;
       }
-      FramedStream stream;
-      synchronized (FramedConnection.this) {
+      Http2Stream stream;
+      synchronized (Http2Connection.this) {
         // If we're shutdown, don't bother with this stream.
         if (shutdown) return;
 
         stream = getStream(streamId);
 
         if (stream == null) {
-          // The headers claim to be for an existing stream, but we don't have one.
-          if (headersMode.failIfStreamAbsent()) {
-            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);
-            return;
-          }
-
           // If the stream ID is less than the last created ID, assume it's already closed.
           if (streamId <= lastGoodStreamId) return;
 
@@ -668,9 +615,8 @@ private Reader(FrameReader frameReader) {
           if (streamId % 2 == nextStreamId % 2) return;
 
           // Create a stream.
-          final FramedStream
-              newStream = new FramedStream(streamId, FramedConnection.this, outFinished,
-              inFinished, headerBlock);
+          final Http2Stream newStream = new Http2Stream(streamId, Http2Connection.this,
+              false, inFinished, headerBlock);
           lastGoodStreamId = streamId;
           streams.put(streamId, newStream);
           executor.execute(new NamedRunnable("OkHttp %s stream %d", hostname, streamId) {
@@ -678,7 +624,7 @@ private Reader(FrameReader frameReader) {
               try {
                 listener.onStream(newStream);
               } catch (IOException e) {
-                logger.log(Level.INFO, "FramedConnection.Listener failure for " + hostname, e);
+                Platform.get().log(INFO, "FramedConnection.Listener failure for " + hostname, e);
                 try {
                   newStream.close(ErrorCode.PROTOCOL_ERROR);
                 } catch (IOException ignored) {
@@ -690,15 +636,8 @@ private Reader(FrameReader frameReader) {
         }
       }
 
-      // The headers claim to be for a new stream, but we already have one.
-      if (headersMode.failIfStreamPresent()) {
-        stream.closeLater(ErrorCode.PROTOCOL_ERROR);
-        removeStream(streamId);
-        return;
-      }
-
       // Update an existing stream.
-      stream.receiveHeaders(headerBlock, headersMode);
+      stream.receiveHeaders(headerBlock);
       if (inFinished) stream.receiveFin();
     }
 
@@ -707,7 +646,7 @@ private Reader(FrameReader frameReader) {
         pushResetLater(streamId, errorCode);
         return;
       }
-      FramedStream rstStream = removeStream(streamId);
+      Http2Stream rstStream = removeStream(streamId);
       if (rstStream != null) {
         rstStream.receiveRstStream(errorCode);
       }
@@ -715,15 +654,13 @@ private Reader(FrameReader frameReader) {
 
     @Override public void settings(boolean clearPrevious, Settings newSettings) {
       long delta = 0;
-      FramedStream[] streamsToNotify = null;
-      synchronized (FramedConnection.this) {
-        int priorWriteWindowSize = peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE);
+      Http2Stream[] streamsToNotify = null;
+      synchronized (Http2Connection.this) {
+        int priorWriteWindowSize = peerSettings.getInitialWindowSize();
         if (clearPrevious) peerSettings.clear();
         peerSettings.merge(newSettings);
-        if (getProtocol() == Protocol.HTTP_2) {
-          ackSettingsLater(newSettings);
-        }
-        int peerInitialWindowSize = peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE);
+        applyAndAckSettings(newSettings);
+        int peerInitialWindowSize = peerSettings.getInitialWindowSize();
         if (peerInitialWindowSize != -1 && peerInitialWindowSize != priorWriteWindowSize) {
           delta = peerInitialWindowSize - priorWriteWindowSize;
           if (!receivedInitialPeerSettings) {
@@ -731,17 +668,17 @@ private Reader(FrameReader frameReader) {
             receivedInitialPeerSettings = true;
           }
           if (!streams.isEmpty()) {
-            streamsToNotify = streams.values().toArray(new FramedStream[streams.size()]);
+            streamsToNotify = streams.values().toArray(new Http2Stream[streams.size()]);
           }
         }
         executor.execute(new NamedRunnable("OkHttp %s settings", hostname) {
           @Override public void execute() {
-            listener.onSettings(FramedConnection.this);
+            listener.onSettings(Http2Connection.this);
           }
         });
       }
       if (streamsToNotify != null && delta != 0) {
-        for (FramedStream stream : streamsToNotify) {
+        for (Http2Stream stream : streamsToNotify) {
           synchronized (stream) {
             stream.addBytesToWriteWindow(delta);
           }
@@ -749,11 +686,11 @@ private Reader(FrameReader frameReader) {
       }
     }
 
-    private void ackSettingsLater(final Settings peerSettings) {
+    private void applyAndAckSettings(final Settings peerSettings) {
       executor.execute(new NamedRunnable("OkHttp %s ACK Settings", hostname) {
         @Override public void execute() {
           try {
-            frameWriter.ackSettings(peerSettings);
+            writer.applyAndAckSettings(peerSettings);
           } catch (IOException ignored) {
           }
         }
@@ -781,29 +718,29 @@ private void ackSettingsLater(final Settings peerSettings) {
       }
 
       // Copy the streams first. We don't want to hold a lock when we call receiveRstStream().
-      FramedStream[] streamsCopy;
-      synchronized (FramedConnection.this) {
-        streamsCopy = streams.values().toArray(new FramedStream[streams.size()]);
+      Http2Stream[] streamsCopy;
+      synchronized (Http2Connection.this) {
+        streamsCopy = streams.values().toArray(new Http2Stream[streams.size()]);
         shutdown = true;
       }
 
       // Fail all streams created after the last good stream ID.
-      for (FramedStream framedStream : streamsCopy) {
-        if (framedStream.getId() > lastGoodStreamId && framedStream.isLocallyInitiated()) {
-          framedStream.receiveRstStream(ErrorCode.REFUSED_STREAM);
-          removeStream(framedStream.getId());
+      for (Http2Stream http2Stream : streamsCopy) {
+        if (http2Stream.getId() > lastGoodStreamId && http2Stream.isLocallyInitiated()) {
+          http2Stream.receiveRstStream(ErrorCode.REFUSED_STREAM);
+          removeStream(http2Stream.getId());
         }
       }
     }
 
     @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
       if (streamId == 0) {
-        synchronized (FramedConnection.this) {
+        synchronized (Http2Connection.this) {
           bytesLeftInWriteWindow += windowSizeIncrement;
-          FramedConnection.this.notifyAll();
+          Http2Connection.this.notifyAll();
         }
       } else {
-        FramedStream stream = getStream(streamId);
+        Http2Stream stream = getStream(streamId);
         if (stream != null) {
           synchronized (stream) {
             stream.addBytesToWriteWindow(windowSizeIncrement);
@@ -830,7 +767,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> request
 
   /** Even, positive numbered streams are pushed streams in HTTP/2. */
   private boolean pushedStream(int streamId) {
-    return protocol == Protocol.HTTP_2 && streamId != 0 && (streamId & 1) == 0;
+    return streamId != 0 && (streamId & 1) == 0;
   }
 
   // Guarded by this.
@@ -849,8 +786,8 @@ private void pushRequestLater(final int streamId, final List<Header> requestHead
         boolean cancel = pushObserver.onRequest(streamId, requestHeaders);
         try {
           if (cancel) {
-            frameWriter.rstStream(streamId, ErrorCode.CANCEL);
-            synchronized (FramedConnection.this) {
+            writer.rstStream(streamId, ErrorCode.CANCEL);
+            synchronized (Http2Connection.this) {
               currentPushRequests.remove(streamId);
             }
           }
@@ -866,9 +803,9 @@ private void pushHeadersLater(final int streamId, final List<Header> requestHead
       @Override public void execute() {
         boolean cancel = pushObserver.onHeaders(streamId, requestHeaders, inFinished);
         try {
-          if (cancel) frameWriter.rstStream(streamId, ErrorCode.CANCEL);
+          if (cancel) writer.rstStream(streamId, ErrorCode.CANCEL);
           if (cancel || inFinished) {
-            synchronized (FramedConnection.this) {
+            synchronized (Http2Connection.this) {
               currentPushRequests.remove(streamId);
             }
           }
@@ -892,9 +829,9 @@ private void pushDataLater(final int streamId, final BufferedSource source, fina
       @Override public void execute() {
         try {
           boolean cancel = pushObserver.onData(streamId, buffer, byteCount, inFinished);
-          if (cancel) frameWriter.rstStream(streamId, ErrorCode.CANCEL);
+          if (cancel) writer.rstStream(streamId, ErrorCode.CANCEL);
           if (cancel || inFinished) {
-            synchronized (FramedConnection.this) {
+            synchronized (Http2Connection.this) {
               currentPushRequests.remove(streamId);
             }
           }
@@ -908,7 +845,7 @@ private void pushResetLater(final int streamId, final ErrorCode errorCode) {
     pushExecutor.execute(new NamedRunnable("OkHttp %s Push Reset[%s]", hostname, streamId) {
       @Override public void execute() {
         pushObserver.onReset(streamId, errorCode);
-        synchronized (FramedConnection.this) {
+        synchronized (Http2Connection.this) {
           currentPushRequests.remove(streamId);
         }
       }
@@ -918,17 +855,17 @@ private void pushResetLater(final int streamId, final ErrorCode errorCode) {
   /** Listener of streams and settings initiated by the peer. */
   public abstract static class Listener {
     public static final Listener REFUSE_INCOMING_STREAMS = new Listener() {
-      @Override public void onStream(FramedStream stream) throws IOException {
+      @Override public void onStream(Http2Stream stream) throws IOException {
         stream.close(ErrorCode.REFUSED_STREAM);
       }
     };
 
     /**
      * Handle a new stream from this connection's peer. Implementations should respond by either
-     * {@linkplain FramedStream#reply replying to the stream} or {@linkplain FramedStream#close
+     * {@linkplain Http2Stream#reply replying to the stream} or {@linkplain Http2Stream#close
      * closing it}. This response does not need to be synchronous.
      */
-    public abstract void onStream(FramedStream stream) throws IOException;
+    public abstract void onStream(Http2Stream stream) throws IOException;
 
     /**
      * Notification that the connection's peer's settings may have changed. Implementations should
@@ -938,7 +875,7 @@ private void pushResetLater(final int streamId, final ErrorCode errorCode) {
      * remote peer that sends multiple settings frames will trigger multiple calls to this method,
      * and those calls are not necessarily serialized.
      */
-    public void onSettings(FramedConnection connection) {
+    public void onSettings(Http2Connection connection) {
     }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java
new file mode 100644
index 0000000000..a2d9e63678
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java
@@ -0,0 +1,494 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.util.List;
+import java.util.logging.Logger;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.Source;
+import okio.Timeout;
+
+import static java.util.logging.Level.FINE;
+import static okhttp3.internal.Util.format;
+import static okhttp3.internal.http2.Http2.CONNECTION_PREFACE;
+import static okhttp3.internal.http2.Http2.FLAG_ACK;
+import static okhttp3.internal.http2.Http2.FLAG_COMPRESSED;
+import static okhttp3.internal.http2.Http2.FLAG_END_HEADERS;
+import static okhttp3.internal.http2.Http2.FLAG_END_STREAM;
+import static okhttp3.internal.http2.Http2.FLAG_PADDED;
+import static okhttp3.internal.http2.Http2.FLAG_PRIORITY;
+import static okhttp3.internal.http2.Http2.INITIAL_MAX_FRAME_SIZE;
+import static okhttp3.internal.http2.Http2.TYPE_CONTINUATION;
+import static okhttp3.internal.http2.Http2.TYPE_DATA;
+import static okhttp3.internal.http2.Http2.TYPE_GOAWAY;
+import static okhttp3.internal.http2.Http2.TYPE_HEADERS;
+import static okhttp3.internal.http2.Http2.TYPE_PING;
+import static okhttp3.internal.http2.Http2.TYPE_PRIORITY;
+import static okhttp3.internal.http2.Http2.TYPE_PUSH_PROMISE;
+import static okhttp3.internal.http2.Http2.TYPE_RST_STREAM;
+import static okhttp3.internal.http2.Http2.TYPE_SETTINGS;
+import static okhttp3.internal.http2.Http2.TYPE_WINDOW_UPDATE;
+import static okhttp3.internal.http2.Http2.frameLog;
+import static okhttp3.internal.http2.Http2.ioException;
+import static okio.ByteString.EMPTY;
+
+/**
+ * Reads HTTP/2 transport frames.
+ *
+ * <p>This implementation assumes we do not send an increased {@link Settings#getMaxFrameSize frame
+ * size setting} to the peer. Hence, we expect all frames to have a max length of {@link
+ * Http2#INITIAL_MAX_FRAME_SIZE}.
+ */
+final class Http2Reader implements Closeable {
+  private static final Logger logger = Logger.getLogger(Http2.class.getName());
+
+  private final BufferedSource source;
+  private final ContinuationSource continuation;
+  private final boolean client;
+
+  // Visible for testing.
+  final Hpack.Reader hpackReader;
+
+  /** Creates a frame reader with max header table size of 4096. */
+  public Http2Reader(BufferedSource source, boolean client) {
+    this.source = source;
+    this.client = client;
+    this.continuation = new ContinuationSource(this.source);
+    this.hpackReader = new Hpack.Reader(4096, continuation);
+  }
+
+  public void readConnectionPreface() throws IOException {
+    if (client) return; // Nothing to read; servers doesn't send a connection preface!
+    ByteString connectionPreface = source.readByteString(CONNECTION_PREFACE.size());
+    if (logger.isLoggable(FINE)) logger.fine(format("<< CONNECTION %s", connectionPreface.hex()));
+    if (!CONNECTION_PREFACE.equals(connectionPreface)) {
+      throw ioException("Expected a connection header but was %s", connectionPreface.utf8());
+    }
+  }
+
+  public boolean nextFrame(Handler handler) throws IOException {
+    try {
+      source.require(9); // Frame header size
+    } catch (IOException e) {
+      return false; // This might be a normal socket close.
+    }
+
+      /*  0                   1                   2                   3
+       *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+       * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       * |                 Length (24)                   |
+       * +---------------+---------------+---------------+
+       * |   Type (8)    |   Flags (8)   |
+       * +-+-+-----------+---------------+-------------------------------+
+       * |R|                 Stream Identifier (31)                      |
+       * +=+=============================================================+
+       * |                   Frame Payload (0...)                      ...
+       * +---------------------------------------------------------------+
+       */
+    int length = readMedium(source);
+    if (length < 0 || length > INITIAL_MAX_FRAME_SIZE) {
+      throw ioException("FRAME_SIZE_ERROR: %s", length);
+    }
+    byte type = (byte) (source.readByte() & 0xff);
+    byte flags = (byte) (source.readByte() & 0xff);
+    int streamId = (source.readInt() & 0x7fffffff); // Ignore reserved bit.
+    if (logger.isLoggable(FINE)) logger.fine(frameLog(true, streamId, length, type, flags));
+
+    switch (type) {
+      case TYPE_DATA:
+        readData(handler, length, flags, streamId);
+        break;
+
+      case TYPE_HEADERS:
+        readHeaders(handler, length, flags, streamId);
+        break;
+
+      case TYPE_PRIORITY:
+        readPriority(handler, length, flags, streamId);
+        break;
+
+      case TYPE_RST_STREAM:
+        readRstStream(handler, length, flags, streamId);
+        break;
+
+      case TYPE_SETTINGS:
+        readSettings(handler, length, flags, streamId);
+        break;
+
+      case TYPE_PUSH_PROMISE:
+        readPushPromise(handler, length, flags, streamId);
+        break;
+
+      case TYPE_PING:
+        readPing(handler, length, flags, streamId);
+        break;
+
+      case TYPE_GOAWAY:
+        readGoAway(handler, length, flags, streamId);
+        break;
+
+      case TYPE_WINDOW_UPDATE:
+        readWindowUpdate(handler, length, flags, streamId);
+        break;
+
+      default:
+        // Implementations MUST discard frames that have unknown or unsupported types.
+        source.skip(length);
+    }
+    return true;
+  }
+
+  private void readHeaders(Handler handler, int length, byte flags, int streamId)
+      throws IOException {
+    if (streamId == 0) throw ioException("PROTOCOL_ERROR: TYPE_HEADERS streamId == 0");
+
+    boolean endStream = (flags & FLAG_END_STREAM) != 0;
+
+    short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
+
+    if ((flags & FLAG_PRIORITY) != 0) {
+      readPriority(handler, streamId);
+      length -= 5; // account for above read.
+    }
+
+    length = lengthWithoutPadding(length, flags, padding);
+
+    List<Header> headerBlock = readHeaderBlock(length, padding, flags, streamId);
+
+    handler.headers(endStream, streamId, -1, headerBlock);
+  }
+
+  private List<Header> readHeaderBlock(int length, short padding, byte flags, int streamId)
+      throws IOException {
+    continuation.length = continuation.left = length;
+    continuation.padding = padding;
+    continuation.flags = flags;
+    continuation.streamId = streamId;
+
+    // TODO: Concat multi-value headers with 0x0, except COOKIE, which uses 0x3B, 0x20.
+    // http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-8.1.2.5
+    hpackReader.readHeaders();
+    return hpackReader.getAndResetHeaderList();
+  }
+
+  private void readData(Handler handler, int length, byte flags, int streamId)
+      throws IOException {
+    // TODO: checkState open or half-closed (local) or raise STREAM_CLOSED
+    boolean inFinished = (flags & FLAG_END_STREAM) != 0;
+    boolean gzipped = (flags & FLAG_COMPRESSED) != 0;
+    if (gzipped) {
+      throw ioException("PROTOCOL_ERROR: FLAG_COMPRESSED without SETTINGS_COMPRESS_DATA");
+    }
+
+    short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
+    length = lengthWithoutPadding(length, flags, padding);
+
+    handler.data(inFinished, streamId, source, length);
+    source.skip(padding);
+  }
+
+  private void readPriority(Handler handler, int length, byte flags, int streamId)
+      throws IOException {
+    if (length != 5) throw ioException("TYPE_PRIORITY length: %d != 5", length);
+    if (streamId == 0) throw ioException("TYPE_PRIORITY streamId == 0");
+    readPriority(handler, streamId);
+  }
+
+  private void readPriority(Handler handler, int streamId) throws IOException {
+    int w1 = source.readInt();
+    boolean exclusive = (w1 & 0x80000000) != 0;
+    int streamDependency = (w1 & 0x7fffffff);
+    int weight = (source.readByte() & 0xff) + 1;
+    handler.priority(streamId, streamDependency, weight, exclusive);
+  }
+
+  private void readRstStream(Handler handler, int length, byte flags, int streamId)
+      throws IOException {
+    if (length != 4) throw ioException("TYPE_RST_STREAM length: %d != 4", length);
+    if (streamId == 0) throw ioException("TYPE_RST_STREAM streamId == 0");
+    int errorCodeInt = source.readInt();
+    ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
+    if (errorCode == null) {
+      throw ioException("TYPE_RST_STREAM unexpected error code: %d", errorCodeInt);
+    }
+    handler.rstStream(streamId, errorCode);
+  }
+
+  private void readSettings(Handler handler, int length, byte flags, int streamId)
+      throws IOException {
+    if (streamId != 0) throw ioException("TYPE_SETTINGS streamId != 0");
+    if ((flags & FLAG_ACK) != 0) {
+      if (length != 0) throw ioException("FRAME_SIZE_ERROR ack frame should be empty!");
+      handler.ackSettings();
+      return;
+    }
+
+    if (length % 6 != 0) throw ioException("TYPE_SETTINGS length %% 6 != 0: %s", length);
+    Settings settings = new Settings();
+    for (int i = 0; i < length; i += 6) {
+      short id = source.readShort();
+      int value = source.readInt();
+
+      switch (id) {
+        case 1: // SETTINGS_HEADER_TABLE_SIZE
+          break;
+        case 2: // SETTINGS_ENABLE_PUSH
+          if (value != 0 && value != 1) {
+            throw ioException("PROTOCOL_ERROR SETTINGS_ENABLE_PUSH != 0 or 1");
+          }
+          break;
+        case 3: // SETTINGS_MAX_CONCURRENT_STREAMS
+          id = 4; // Renumbered in draft 10.
+          break;
+        case 4: // SETTINGS_INITIAL_WINDOW_SIZE
+          id = 7; // Renumbered in draft 10.
+          if (value < 0) {
+            throw ioException("PROTOCOL_ERROR SETTINGS_INITIAL_WINDOW_SIZE > 2^31 - 1");
+          }
+          break;
+        case 5: // SETTINGS_MAX_FRAME_SIZE
+          if (value < INITIAL_MAX_FRAME_SIZE || value > 16777215) {
+            throw ioException("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: %s", value);
+          }
+          break;
+        case 6: // SETTINGS_MAX_HEADER_LIST_SIZE
+          break; // Advisory only, so ignored.
+        default:
+          break; // Must ignore setting with unknown id.
+      }
+      settings.set(id, value);
+    }
+    handler.settings(false, settings);
+  }
+
+  private void readPushPromise(Handler handler, int length, byte flags, int streamId)
+      throws IOException {
+    if (streamId == 0) {
+      throw ioException("PROTOCOL_ERROR: TYPE_PUSH_PROMISE streamId == 0");
+    }
+    short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
+    int promisedStreamId = source.readInt() & 0x7fffffff;
+    length -= 4; // account for above read.
+    length = lengthWithoutPadding(length, flags, padding);
+    List<Header> headerBlock = readHeaderBlock(length, padding, flags, streamId);
+    handler.pushPromise(streamId, promisedStreamId, headerBlock);
+  }
+
+  private void readPing(Handler handler, int length, byte flags, int streamId)
+      throws IOException {
+    if (length != 8) throw ioException("TYPE_PING length != 8: %s", length);
+    if (streamId != 0) throw ioException("TYPE_PING streamId != 0");
+    int payload1 = source.readInt();
+    int payload2 = source.readInt();
+    boolean ack = (flags & FLAG_ACK) != 0;
+    handler.ping(ack, payload1, payload2);
+  }
+
+  private void readGoAway(Handler handler, int length, byte flags, int streamId)
+      throws IOException {
+    if (length < 8) throw ioException("TYPE_GOAWAY length < 8: %s", length);
+    if (streamId != 0) throw ioException("TYPE_GOAWAY streamId != 0");
+    int lastStreamId = source.readInt();
+    int errorCodeInt = source.readInt();
+    int opaqueDataLength = length - 8;
+    ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
+    if (errorCode == null) {
+      throw ioException("TYPE_GOAWAY unexpected error code: %d", errorCodeInt);
+    }
+    ByteString debugData = EMPTY;
+    if (opaqueDataLength > 0) { // Must read debug data in order to not corrupt the connection.
+      debugData = source.readByteString(opaqueDataLength);
+    }
+    handler.goAway(lastStreamId, errorCode, debugData);
+  }
+
+  private void readWindowUpdate(Handler handler, int length, byte flags, int streamId)
+      throws IOException {
+    if (length != 4) throw ioException("TYPE_WINDOW_UPDATE length !=4: %s", length);
+    long increment = (source.readInt() & 0x7fffffffL);
+    if (increment == 0) throw ioException("windowSizeIncrement was 0", increment);
+    handler.windowUpdate(streamId, increment);
+  }
+
+  @Override public void close() throws IOException {
+    source.close();
+  }
+
+  /**
+   * Decompression of the header block occurs above the framing layer. This class lazily reads
+   * continuation frames as they are needed by {@link Hpack.Reader#readHeaders()}.
+   */
+  static final class ContinuationSource implements Source {
+    private final BufferedSource source;
+
+    int length;
+    byte flags;
+    int streamId;
+
+    int left;
+    short padding;
+
+    public ContinuationSource(BufferedSource source) {
+      this.source = source;
+    }
+
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
+      while (left == 0) {
+        source.skip(padding);
+        padding = 0;
+        if ((flags & FLAG_END_HEADERS) != 0) return -1;
+        readContinuationHeader();
+        // TODO: test case for empty continuation header?
+      }
+
+      long read = source.read(sink, Math.min(byteCount, left));
+      if (read == -1) return -1;
+      left -= read;
+      return read;
+    }
+
+    @Override public Timeout timeout() {
+      return source.timeout();
+    }
+
+    @Override public void close() throws IOException {
+    }
+
+    private void readContinuationHeader() throws IOException {
+      int previousStreamId = streamId;
+
+      length = left = readMedium(source);
+      byte type = (byte) (source.readByte() & 0xff);
+      flags = (byte) (source.readByte() & 0xff);
+      if (logger.isLoggable(FINE)) logger.fine(frameLog(true, streamId, length, type, flags));
+      streamId = (source.readInt() & 0x7fffffff);
+      if (type != TYPE_CONTINUATION) throw ioException("%s != TYPE_CONTINUATION", type);
+      if (streamId != previousStreamId) throw ioException("TYPE_CONTINUATION streamId changed");
+    }
+  }
+
+  static int readMedium(BufferedSource source) throws IOException {
+    return (source.readByte() & 0xff) << 16
+        | (source.readByte() & 0xff) << 8
+        | (source.readByte() & 0xff);
+  }
+
+  static int lengthWithoutPadding(int length, byte flags, short padding)
+      throws IOException {
+    if ((flags & FLAG_PADDED) != 0) length--; // Account for reading the padding length.
+    if (padding > length) {
+      throw ioException("PROTOCOL_ERROR padding %s > remaining length %s", padding, length);
+    }
+    return (short) (length - padding);
+  }
+
+  interface Handler {
+    void data(boolean inFinished, int streamId, BufferedSource source, int length)
+        throws IOException;
+
+    /**
+     * Create or update incoming headers, creating the corresponding streams if necessary. Frames
+     * that trigger this are HEADERS and PUSH_PROMISE.
+     *
+     * @param inFinished true if the sender will not send further frames.
+     * @param streamId the stream owning these headers.
+     * @param associatedStreamId the stream that triggered the sender to create this stream.
+     */
+    void headers(boolean inFinished, int streamId, int associatedStreamId,
+        List<Header> headerBlock);
+
+    void rstStream(int streamId, ErrorCode errorCode);
+
+    void settings(boolean clearPrevious, Settings settings);
+
+    /** HTTP/2 only. */
+    void ackSettings();
+
+    /**
+     * Read a connection-level ping from the peer. {@code ack} indicates this is a reply. The data
+     * in {@code payload1} and {@code payload2} opaque binary, and there are no rules on the
+     * content.
+     */
+    void ping(boolean ack, int payload1, int payload2);
+
+    /**
+     * The peer tells us to stop creating streams.  It is safe to replay streams with {@code ID >
+     * lastGoodStreamId} on a new connection.  In- flight streams with {@code ID <=
+     * lastGoodStreamId} can only be replayed on a new connection if they are idempotent.
+     *
+     * @param lastGoodStreamId the last stream ID the peer processed before sending this message. If
+     * {@code lastGoodStreamId} is zero, the peer processed no frames.
+     * @param errorCode reason for closing the connection.
+     * @param debugData only valid for HTTP/2; opaque debug data to send.
+     */
+    void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData);
+
+    /**
+     * Notifies that an additional {@code windowSizeIncrement} bytes can be sent on {@code
+     * streamId}, or the connection if {@code streamId} is zero.
+     */
+    void windowUpdate(int streamId, long windowSizeIncrement);
+
+    /**
+     * Called when reading a headers or priority frame. This may be used to change the stream's
+     * weight from the default (16) to a new value.
+     *
+     * @param streamId stream which has a priority change.
+     * @param streamDependency the stream ID this stream is dependent on.
+     * @param weight relative proportion of priority in [1..256].
+     * @param exclusive inserts this stream ID as the sole child of {@code streamDependency}.
+     */
+    void priority(int streamId, int streamDependency, int weight, boolean exclusive);
+
+    /**
+     * HTTP/2 only. Receive a push promise header block. <p> A push promise contains all the headers
+     * that pertain to a server-initiated request, and a {@code promisedStreamId} to which response
+     * frames will be delivered. Push promise frames are sent as a part of the response to {@code
+     * streamId}.
+     *
+     * @param streamId client-initiated stream ID.  Must be an odd number.
+     * @param promisedStreamId server-initiated stream ID.  Must be an even number.
+     * @param requestHeaders minimally includes {@code :method}, {@code :scheme}, {@code
+     * :authority}, and (@code :path}.
+     */
+    void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
+        throws IOException;
+
+    /**
+     * HTTP/2 only. Expresses that resources for the connection or a client- initiated stream are
+     * available from a different network location or protocol configuration.
+     *
+     * <p>See <a href="http://tools.ietf.org/html/draft-ietf-httpbis-alt-svc-01">alt-svc</a>
+     *
+     * @param streamId when a client-initiated stream ID (odd number), the origin of this alternate
+     * service is the origin of the stream. When zero, the origin is specified in the {@code origin}
+     * parameter.
+     * @param origin when present, the <a href="http://tools.ietf.org/html/rfc6454">origin</a> is
+     * typically represented as a combination of scheme, host and port. When empty, the origin is
+     * that of the {@code streamId}.
+     * @param protocol an ALPN protocol, such as {@code h2}.
+     * @param host an IP address or hostname.
+     * @param port the IP port associated with the service.
+     * @param maxAge time in seconds that this alternative is considered fresh.
+     */
+    void alternateService(int streamId, String origin, ByteString protocol, String host, int port,
+        long maxAge);
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/FramedStream.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
similarity index 86%
rename from okhttp/src/main/java/okhttp3/internal/framed/FramedStream.java
rename to okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
index c94a8449ec..5997b21288 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/FramedStream.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.framed;
+package okhttp3.internal.http2;
 
 import java.io.EOFException;
 import java.io.IOException;
@@ -28,10 +28,8 @@
 import okio.Source;
 import okio.Timeout;
 
-import static okhttp3.internal.framed.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
-
 /** A logical bidirectional stream. */
-public final class FramedStream {
+public final class Http2Stream {
   // Internal state is guarded by this. No long-running or potentially
   // blocking operations are performed while the lock is held.
 
@@ -51,7 +49,7 @@
   long bytesLeftInWriteWindow;
 
   private final int id;
-  private final FramedConnection connection;
+  private final Http2Connection connection;
 
   /** Headers sent by the stream initiator. Immutable and non null. */
   private final List<Header> requestHeaders;
@@ -71,16 +69,16 @@
    */
   private ErrorCode errorCode = null;
 
-  FramedStream(int id, FramedConnection connection, boolean outFinished, boolean inFinished,
+  Http2Stream(int id, Http2Connection connection, boolean outFinished, boolean inFinished,
       List<Header> requestHeaders) {
     if (connection == null) throw new NullPointerException("connection == null");
     if (requestHeaders == null) throw new NullPointerException("requestHeaders == null");
     this.id = id;
     this.connection = connection;
     this.bytesLeftInWriteWindow =
-        connection.peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE);
+        connection.peerSettings.getInitialWindowSize();
     this.source = new FramedDataSource(
-        connection.okHttpSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE));
+        connection.okHttpSettings.getInitialWindowSize());
     this.sink = new FramedDataSink();
     this.source.finished = inFinished;
     this.sink.finished = outFinished;
@@ -120,7 +118,7 @@ public boolean isLocallyInitiated() {
     return connection.client == streamIsClient;
   }
 
-  public FramedConnection getConnection() {
+  public Http2Connection getConnection() {
     return connection;
   }
 
@@ -142,7 +140,7 @@ public FramedConnection getConnection() {
       readTimeout.exitAndThrowIfTimedOut();
     }
     if (responseHeaders != null) return responseHeaders;
-    throw new IOException("stream was reset: " + errorCode);
+    throw new StreamResetException(errorCode);
   }
 
   /**
@@ -160,7 +158,7 @@ public synchronized ErrorCode getErrorCode() {
    * Corresponds to {@code FLAG_FIN}.
    */
   public void reply(List<Header> responseHeaders, boolean out) throws IOException {
-    assert (!Thread.holdsLock(FramedStream.this));
+    assert (!Thread.holdsLock(Http2Stream.this));
     boolean outFinished = false;
     synchronized (this) {
       if (responseHeaders == null) {
@@ -249,44 +247,33 @@ private boolean closeInternal(ErrorCode errorCode) {
     return true;
   }
 
-  void receiveHeaders(List<Header> headers, HeadersMode headersMode) {
-    assert (!Thread.holdsLock(FramedStream.this));
-    ErrorCode errorCode = null;
+  void receiveHeaders(List<Header> headers) {
+    assert (!Thread.holdsLock(Http2Stream.this));
     boolean open = true;
     synchronized (this) {
       if (responseHeaders == null) {
-        if (headersMode.failIfHeadersAbsent()) {
-          errorCode = ErrorCode.PROTOCOL_ERROR;
-        } else {
-          responseHeaders = headers;
-          open = isOpen();
-          notifyAll();
-        }
+        responseHeaders = headers;
+        open = isOpen();
+        notifyAll();
       } else {
-        if (headersMode.failIfHeadersPresent()) {
-          errorCode = ErrorCode.STREAM_IN_USE;
-        } else {
-          List<Header> newHeaders = new ArrayList<>();
-          newHeaders.addAll(responseHeaders);
-          newHeaders.addAll(headers);
-          this.responseHeaders = newHeaders;
-        }
+        List<Header> newHeaders = new ArrayList<>();
+        newHeaders.addAll(responseHeaders);
+        newHeaders.addAll(headers);
+        this.responseHeaders = newHeaders;
       }
     }
-    if (errorCode != null) {
-      closeLater(errorCode);
-    } else if (!open) {
+    if (!open) {
       connection.removeStream(id);
     }
   }
 
   void receiveData(BufferedSource in, int length) throws IOException {
-    assert (!Thread.holdsLock(FramedStream.this));
+    assert (!Thread.holdsLock(Http2Stream.this));
     this.source.receive(in, length);
   }
 
   void receiveFin() {
-    assert (!Thread.holdsLock(FramedStream.this));
+    assert (!Thread.holdsLock(Http2Stream.this));
     boolean open;
     synchronized (this) {
       this.source.finished = true;
@@ -338,7 +325,7 @@ private FramedDataSource(long maxByteCount) {
       if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
 
       long read;
-      synchronized (FramedStream.this) {
+      synchronized (Http2Stream.this) {
         waitUntilReadable();
         checkNotClosed();
         if (readBuffer.size() == 0) return -1; // This source is exhausted.
@@ -349,7 +336,7 @@ private FramedDataSource(long maxByteCount) {
         // Flow control: notify the peer that we're ready for more data!
         unacknowledgedBytesRead += read;
         if (unacknowledgedBytesRead
-            >= connection.okHttpSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE) / 2) {
+            >= connection.okHttpSettings.getInitialWindowSize() / 2) {
           connection.writeWindowUpdateLater(id, unacknowledgedBytesRead);
           unacknowledgedBytesRead = 0;
         }
@@ -359,7 +346,7 @@ private FramedDataSource(long maxByteCount) {
       synchronized (connection) { // Multiple application threads may hit this section.
         connection.unacknowledgedBytesRead += read;
         if (connection.unacknowledgedBytesRead
-            >= connection.okHttpSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE) / 2) {
+            >= connection.okHttpSettings.getInitialWindowSize() / 2) {
           connection.writeWindowUpdateLater(0, connection.unacknowledgedBytesRead);
           connection.unacknowledgedBytesRead = 0;
         }
@@ -381,12 +368,12 @@ private void waitUntilReadable() throws IOException {
     }
 
     void receive(BufferedSource in, long byteCount) throws IOException {
-      assert (!Thread.holdsLock(FramedStream.this));
+      assert (!Thread.holdsLock(Http2Stream.this));
 
       while (byteCount > 0) {
         boolean finished;
         boolean flowControlError;
-        synchronized (FramedStream.this) {
+        synchronized (Http2Stream.this) {
           finished = this.finished;
           flowControlError = byteCount + readBuffer.size() > maxByteCount;
         }
@@ -410,11 +397,11 @@ void receive(BufferedSource in, long byteCount) throws IOException {
         byteCount -= read;
 
         // Move the received data to the read buffer to the reader can read it.
-        synchronized (FramedStream.this) {
+        synchronized (Http2Stream.this) {
           boolean wasEmpty = readBuffer.size() == 0;
           readBuffer.writeAll(receiveBuffer);
           if (wasEmpty) {
-            FramedStream.this.notifyAll();
+            Http2Stream.this.notifyAll();
           }
         }
       }
@@ -425,10 +412,10 @@ void receive(BufferedSource in, long byteCount) throws IOException {
     }
 
     @Override public void close() throws IOException {
-      synchronized (FramedStream.this) {
+      synchronized (Http2Stream.this) {
         closed = true;
         readBuffer.clear();
-        FramedStream.this.notifyAll();
+        Http2Stream.this.notifyAll();
       }
       cancelStreamIfNecessary();
     }
@@ -438,13 +425,13 @@ private void checkNotClosed() throws IOException {
         throw new IOException("stream closed");
       }
       if (errorCode != null) {
-        throw new IOException("stream was reset: " + errorCode);
+        throw new StreamResetException(errorCode);
       }
     }
   }
 
   private void cancelStreamIfNecessary() throws IOException {
-    assert (!Thread.holdsLock(FramedStream.this));
+    assert (!Thread.holdsLock(Http2Stream.this));
     boolean open;
     boolean cancel;
     synchronized (this) {
@@ -456,7 +443,7 @@ private void cancelStreamIfNecessary() throws IOException {
       // is safe because the input stream is closed (we won't use any
       // further bytes) and the output stream is either finished or closed
       // (so RSTing both streams doesn't cause harm).
-      FramedStream.this.close(ErrorCode.CANCEL);
+      Http2Stream.this.close(ErrorCode.CANCEL);
     } else if (!open) {
       connection.removeStream(id);
     }
@@ -482,7 +469,7 @@ private void cancelStreamIfNecessary() throws IOException {
     private boolean finished;
 
     @Override public void write(Buffer source, long byteCount) throws IOException {
-      assert (!Thread.holdsLock(FramedStream.this));
+      assert (!Thread.holdsLock(Http2Stream.this));
       sendBuffer.write(source, byteCount);
       while (sendBuffer.size() >= EMIT_BUFFER_SIZE) {
         emitDataFrame(false);
@@ -495,7 +482,7 @@ private void cancelStreamIfNecessary() throws IOException {
      */
     private void emitDataFrame(boolean outFinished) throws IOException {
       long toWrite;
-      synchronized (FramedStream.this) {
+      synchronized (Http2Stream.this) {
         writeTimeout.enter();
         try {
           while (bytesLeftInWriteWindow <= 0 && !finished && !closed && errorCode == null) {
@@ -519,8 +506,8 @@ private void emitDataFrame(boolean outFinished) throws IOException {
     }
 
     @Override public void flush() throws IOException {
-      assert (!Thread.holdsLock(FramedStream.this));
-      synchronized (FramedStream.this) {
+      assert (!Thread.holdsLock(Http2Stream.this));
+      synchronized (Http2Stream.this) {
         checkOutNotClosed();
       }
       while (sendBuffer.size() > 0) {
@@ -534,8 +521,8 @@ private void emitDataFrame(boolean outFinished) throws IOException {
     }
 
     @Override public void close() throws IOException {
-      assert (!Thread.holdsLock(FramedStream.this));
-      synchronized (FramedStream.this) {
+      assert (!Thread.holdsLock(Http2Stream.this));
+      synchronized (Http2Stream.this) {
         if (closed) return;
       }
       if (!sink.finished) {
@@ -549,7 +536,7 @@ private void emitDataFrame(boolean outFinished) throws IOException {
           connection.writeData(id, true, null, 0);
         }
       }
-      synchronized (FramedStream.this) {
+      synchronized (Http2Stream.this) {
         closed = true;
       }
       connection.flush();
@@ -562,7 +549,7 @@ private void emitDataFrame(boolean outFinished) throws IOException {
    */
   void addBytesToWriteWindow(long delta) {
     bytesLeftInWriteWindow += delta;
-    if (delta > 0) FramedStream.this.notifyAll();
+    if (delta > 0) Http2Stream.this.notifyAll();
   }
 
   private void checkOutNotClosed() throws IOException {
@@ -571,7 +558,7 @@ private void checkOutNotClosed() throws IOException {
     } else if (sink.finished) {
       throw new IOException("stream finished");
     } else if (errorCode != null) {
-      throw new IOException("stream was reset: " + errorCode);
+      throw new StreamResetException(errorCode);
     }
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.java
new file mode 100644
index 0000000000..e23d8c9996
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.java
@@ -0,0 +1,311 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.util.List;
+import java.util.logging.Logger;
+import okio.Buffer;
+import okio.BufferedSink;
+
+import static java.util.logging.Level.FINE;
+import static okhttp3.internal.Util.format;
+import static okhttp3.internal.http2.Http2.CONNECTION_PREFACE;
+import static okhttp3.internal.http2.Http2.FLAG_ACK;
+import static okhttp3.internal.http2.Http2.FLAG_END_HEADERS;
+import static okhttp3.internal.http2.Http2.FLAG_END_STREAM;
+import static okhttp3.internal.http2.Http2.FLAG_NONE;
+import static okhttp3.internal.http2.Http2.INITIAL_MAX_FRAME_SIZE;
+import static okhttp3.internal.http2.Http2.TYPE_CONTINUATION;
+import static okhttp3.internal.http2.Http2.TYPE_DATA;
+import static okhttp3.internal.http2.Http2.TYPE_GOAWAY;
+import static okhttp3.internal.http2.Http2.TYPE_HEADERS;
+import static okhttp3.internal.http2.Http2.TYPE_PING;
+import static okhttp3.internal.http2.Http2.TYPE_PUSH_PROMISE;
+import static okhttp3.internal.http2.Http2.TYPE_RST_STREAM;
+import static okhttp3.internal.http2.Http2.TYPE_SETTINGS;
+import static okhttp3.internal.http2.Http2.TYPE_WINDOW_UPDATE;
+import static okhttp3.internal.http2.Http2.frameLog;
+import static okhttp3.internal.http2.Http2.illegalArgument;
+
+/** Writes HTTP/2 transport frames. */
+final class Http2Writer implements Closeable {
+  private static final Logger logger = Logger.getLogger(Http2.class.getName());
+
+  private final BufferedSink sink;
+  private final boolean client;
+  private final Buffer hpackBuffer;
+  private int maxFrameSize;
+  private boolean closed;
+
+  final Hpack.Writer hpackWriter;
+
+  public Http2Writer(BufferedSink sink, boolean client) {
+    this.sink = sink;
+    this.client = client;
+    this.hpackBuffer = new Buffer();
+    this.hpackWriter = new Hpack.Writer(hpackBuffer);
+    this.maxFrameSize = INITIAL_MAX_FRAME_SIZE;
+  }
+
+  public synchronized void connectionPreface() throws IOException {
+    if (closed) throw new IOException("closed");
+    if (!client) return; // Nothing to write; servers don't send connection headers!
+    if (logger.isLoggable(FINE)) {
+      logger.fine(format(">> CONNECTION %s", CONNECTION_PREFACE.hex()));
+    }
+    sink.write(CONNECTION_PREFACE.toByteArray());
+    sink.flush();
+  }
+
+  /** Applies {@code peerSettings} and then sends a settings ACK. */
+  public synchronized void applyAndAckSettings(Settings peerSettings) throws IOException {
+    if (closed) throw new IOException("closed");
+    this.maxFrameSize = peerSettings.getMaxFrameSize(maxFrameSize);
+    if (peerSettings.getHeaderTableSize() != -1) {
+      hpackWriter.setHeaderTableSizeSetting(peerSettings.getHeaderTableSize());
+    }
+    int length = 0;
+    byte type = TYPE_SETTINGS;
+    byte flags = FLAG_ACK;
+    int streamId = 0;
+    frameHeader(streamId, length, type, flags);
+    sink.flush();
+  }
+
+  /**
+   * HTTP/2 only. Send a push promise header block.
+   *
+   * <p>A push promise contains all the headers that pertain to a server-initiated request, and a
+   * {@code promisedStreamId} to which response frames will be delivered. Push promise frames are
+   * sent as a part of the response to {@code streamId}. The {@code promisedStreamId} has a priority
+   * of one greater than {@code streamId}.
+   *
+   * @param streamId client-initiated stream ID.  Must be an odd number.
+   * @param promisedStreamId server-initiated stream ID.  Must be an even number.
+   * @param requestHeaders minimally includes {@code :method}, {@code :scheme}, {@code :authority},
+   * and (@code :path}.
+   */
+  public synchronized void pushPromise(int streamId, int promisedStreamId,
+      List<Header> requestHeaders) throws IOException {
+    if (closed) throw new IOException("closed");
+    hpackWriter.writeHeaders(requestHeaders);
+
+    long byteCount = hpackBuffer.size();
+    int length = (int) Math.min(maxFrameSize - 4, byteCount);
+    byte type = TYPE_PUSH_PROMISE;
+    byte flags = byteCount == length ? FLAG_END_HEADERS : 0;
+    frameHeader(streamId, length + 4, type, flags);
+    sink.writeInt(promisedStreamId & 0x7fffffff);
+    sink.write(hpackBuffer, length);
+
+    if (byteCount > length) writeContinuationFrames(streamId, byteCount - length);
+  }
+
+  public synchronized void flush() throws IOException {
+    if (closed) throw new IOException("closed");
+    sink.flush();
+  }
+
+  public synchronized void synStream(boolean outFinished, int streamId,
+      int associatedStreamId, List<Header> headerBlock) throws IOException {
+    if (closed) throw new IOException("closed");
+    headers(outFinished, streamId, headerBlock);
+  }
+
+  public synchronized void synReply(boolean outFinished, int streamId,
+      List<Header> headerBlock) throws IOException {
+    if (closed) throw new IOException("closed");
+    headers(outFinished, streamId, headerBlock);
+  }
+
+  public synchronized void headers(int streamId, List<Header> headerBlock)
+      throws IOException {
+    if (closed) throw new IOException("closed");
+    headers(false, streamId, headerBlock);
+  }
+
+  public synchronized void rstStream(int streamId, ErrorCode errorCode)
+      throws IOException {
+    if (closed) throw new IOException("closed");
+    if (errorCode.httpCode == -1) throw new IllegalArgumentException();
+
+    int length = 4;
+    byte type = TYPE_RST_STREAM;
+    byte flags = FLAG_NONE;
+    frameHeader(streamId, length, type, flags);
+    sink.writeInt(errorCode.httpCode);
+    sink.flush();
+  }
+
+  /** The maximum size of bytes that may be sent in a single call to {@link #data}. */
+  public int maxDataLength() {
+    return maxFrameSize;
+  }
+
+  /**
+   * {@code source.length} may be longer than the max length of the variant's data frame.
+   * Implementations must send multiple frames as necessary.
+   *
+   * @param source the buffer to draw bytes from. May be null if byteCount is 0.
+   * @param byteCount must be between 0 and the minimum of {code source.length} and {@link
+   * #maxDataLength}.
+   */
+  public synchronized void data(boolean outFinished, int streamId, Buffer source, int byteCount)
+      throws IOException {
+    if (closed) throw new IOException("closed");
+    byte flags = FLAG_NONE;
+    if (outFinished) flags |= FLAG_END_STREAM;
+    dataFrame(streamId, flags, source, byteCount);
+  }
+
+  void dataFrame(int streamId, byte flags, Buffer buffer, int byteCount) throws IOException {
+    byte type = TYPE_DATA;
+    frameHeader(streamId, byteCount, type, flags);
+    if (byteCount > 0) {
+      sink.write(buffer, byteCount);
+    }
+  }
+
+  /** Write okhttp's settings to the peer. */
+  public synchronized void settings(Settings settings) throws IOException {
+    if (closed) throw new IOException("closed");
+    int length = settings.size() * 6;
+    byte type = TYPE_SETTINGS;
+    byte flags = FLAG_NONE;
+    int streamId = 0;
+    frameHeader(streamId, length, type, flags);
+    for (int i = 0; i < Settings.COUNT; i++) {
+      if (!settings.isSet(i)) continue;
+      int id = i;
+      if (id == 4) {
+        id = 3; // SETTINGS_MAX_CONCURRENT_STREAMS renumbered.
+      } else if (id == 7) {
+        id = 4; // SETTINGS_INITIAL_WINDOW_SIZE renumbered.
+      }
+      sink.writeShort(id);
+      sink.writeInt(settings.get(i));
+    }
+    sink.flush();
+  }
+
+  /**
+   * Send a connection-level ping to the peer. {@code ack} indicates this is a reply. The data in
+   * {@code payload1} and {@code payload2} opaque binary, and there are no rules on the content.
+   */
+  public synchronized void ping(boolean ack, int payload1, int payload2) throws IOException {
+    if (closed) throw new IOException("closed");
+    int length = 8;
+    byte type = TYPE_PING;
+    byte flags = ack ? FLAG_ACK : FLAG_NONE;
+    int streamId = 0;
+    frameHeader(streamId, length, type, flags);
+    sink.writeInt(payload1);
+    sink.writeInt(payload2);
+    sink.flush();
+  }
+
+  /**
+   * Tell the peer to stop creating streams and that we last processed {@code lastGoodStreamId}, or
+   * zero if no streams were processed.
+   *
+   * @param lastGoodStreamId the last stream ID processed, or zero if no streams were processed.
+   * @param errorCode reason for closing the connection.
+   * @param debugData only valid for HTTP/2; opaque debug data to send.
+   */
+  public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
+      throws IOException {
+    if (closed) throw new IOException("closed");
+    if (errorCode.httpCode == -1) throw illegalArgument("errorCode.httpCode == -1");
+    int length = 8 + debugData.length;
+    byte type = TYPE_GOAWAY;
+    byte flags = FLAG_NONE;
+    int streamId = 0;
+    frameHeader(streamId, length, type, flags);
+    sink.writeInt(lastGoodStreamId);
+    sink.writeInt(errorCode.httpCode);
+    if (debugData.length > 0) {
+      sink.write(debugData);
+    }
+    sink.flush();
+  }
+
+  /**
+   * Inform peer that an additional {@code windowSizeIncrement} bytes can be sent on {@code
+   * streamId}, or the connection if {@code streamId} is zero.
+   */
+  public synchronized void windowUpdate(int streamId, long windowSizeIncrement) throws IOException {
+    if (closed) throw new IOException("closed");
+    if (windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL) {
+      throw illegalArgument("windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: %s",
+          windowSizeIncrement);
+    }
+    int length = 4;
+    byte type = TYPE_WINDOW_UPDATE;
+    byte flags = FLAG_NONE;
+    frameHeader(streamId, length, type, flags);
+    sink.writeInt((int) windowSizeIncrement);
+    sink.flush();
+  }
+
+  public void frameHeader(int streamId, int length, byte type, byte flags) throws IOException {
+    if (logger.isLoggable(FINE)) logger.fine(frameLog(false, streamId, length, type, flags));
+    if (length > maxFrameSize) {
+      throw illegalArgument("FRAME_SIZE_ERROR length > %d: %d", maxFrameSize, length);
+    }
+    if ((streamId & 0x80000000) != 0) throw illegalArgument("reserved bit set: %s", streamId);
+    writeMedium(sink, length);
+    sink.writeByte(type & 0xff);
+    sink.writeByte(flags & 0xff);
+    sink.writeInt(streamId & 0x7fffffff);
+  }
+
+  @Override public synchronized void close() throws IOException {
+    closed = true;
+    sink.close();
+  }
+
+  private static void writeMedium(BufferedSink sink, int i) throws IOException {
+    sink.writeByte((i >>> 16) & 0xff);
+    sink.writeByte((i >>> 8) & 0xff);
+    sink.writeByte(i & 0xff);
+  }
+
+  private void writeContinuationFrames(int streamId, long byteCount) throws IOException {
+    while (byteCount > 0) {
+      int length = (int) Math.min(maxFrameSize, byteCount);
+      byteCount -= length;
+      frameHeader(streamId, length, TYPE_CONTINUATION, byteCount == 0 ? FLAG_END_HEADERS : 0);
+      sink.write(hpackBuffer, length);
+    }
+  }
+
+  void headers(boolean outFinished, int streamId, List<Header> headerBlock) throws IOException {
+    if (closed) throw new IOException("closed");
+    hpackWriter.writeHeaders(headerBlock);
+
+    long byteCount = hpackBuffer.size();
+    int length = (int) Math.min(maxFrameSize, byteCount);
+    byte type = TYPE_HEADERS;
+    byte flags = byteCount == length ? FLAG_END_HEADERS : 0;
+    if (outFinished) flags |= FLAG_END_STREAM;
+    frameHeader(streamId, length, type, flags);
+    sink.write(hpackBuffer, length);
+
+    if (byteCount > length) writeContinuationFrames(streamId, byteCount - length);
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/Huffman.java b/okhttp/src/main/java/okhttp3/internal/http2/Huffman.java
similarity index 94%
rename from okhttp/src/main/java/okhttp3/internal/framed/Huffman.java
rename to okhttp/src/main/java/okhttp3/internal/http2/Huffman.java
index 0c7f3012a7..32582e9f40 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/Huffman.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Huffman.java
@@ -13,11 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.framed;
+package okhttp3.internal.http2;
 
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
-import java.io.OutputStream;
+import okio.BufferedSink;
+import okio.ByteString;
 
 /**
  * This class was originally composed from the following classes in <a
@@ -87,12 +88,12 @@ private Huffman() {
     buildTree();
   }
 
-  void encode(byte[] data, OutputStream out) throws IOException {
+  void encode(ByteString data, BufferedSink sink) throws IOException {
     long current = 0;
     int n = 0;
 
-    for (int i = 0; i < data.length; i++) {
-      int b = data[i] & 0xFF;
+    for (int i = 0; i < data.size(); i++) {
+      int b = data.getByte(i) & 0xFF;
       int code = CODES[b];
       int nbits = CODE_LENGTHS[b];
 
@@ -102,29 +103,29 @@ void encode(byte[] data, OutputStream out) throws IOException {
 
       while (n >= 8) {
         n -= 8;
-        out.write(((int) (current >> n)));
+        sink.writeByte(((int) (current >> n)));
       }
     }
 
     if (n > 0) {
       current <<= (8 - n);
       current |= (0xFF >>> n);
-      out.write((int) current);
+      sink.writeByte((int) current);
     }
   }
 
-  int encodedLength(byte[] bytes) {
+  int encodedLength(ByteString bytes) {
     long len = 0;
 
-    for (int i = 0; i < bytes.length; i++) {
-      int b = bytes[i] & 0xFF;
+    for (int i = 0; i < bytes.size(); i++) {
+      int b = bytes.getByte(i) & 0xFF;
       len += CODE_LENGTHS[b];
     }
 
     return (int) ((len + 7) >> 3);
   }
 
-  byte[] decode(byte[] buf) throws IOException {
+  byte[] decode(byte[] buf) {
     ByteArrayOutputStream baos = new ByteArrayOutputStream();
     Node node = root;
     int current = 0;
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/Ping.java b/okhttp/src/main/java/okhttp3/internal/http2/Ping.java
similarity index 97%
rename from okhttp/src/main/java/okhttp3/internal/framed/Ping.java
rename to okhttp/src/main/java/okhttp3/internal/http2/Ping.java
index d3e0b428d6..7847db7aab 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/Ping.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Ping.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.framed;
+package okhttp3.internal.http2;
 
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
@@ -21,7 +21,7 @@
 /**
  * A locally-originated ping.
  */
-public final class Ping {
+final class Ping {
   private final CountDownLatch latch = new CountDownLatch(1);
   private long sent = -1;
   private long received = -1;
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/PushObserver.java b/okhttp/src/main/java/okhttp3/internal/http2/PushObserver.java
similarity index 99%
rename from okhttp/src/main/java/okhttp3/internal/framed/PushObserver.java
rename to okhttp/src/main/java/okhttp3/internal/http2/PushObserver.java
index 95dd41a5b9..126908a0a9 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/PushObserver.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/PushObserver.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.framed;
+package okhttp3.internal.http2;
 
 import java.io.IOException;
 import java.util.List;
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Settings.java b/okhttp/src/main/java/okhttp3/internal/http2/Settings.java
new file mode 100644
index 0000000000..a43280c695
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Settings.java
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import java.util.Arrays;
+
+/**
+ * Settings describe characteristics of the sending peer, which are used by the receiving peer.
+ * Settings are {@link Http2Connection connection} scoped.
+ */
+public final class Settings {
+  /**
+   * From the HTTP/2 specs, the default initial window size for all streams is 64 KiB. (Chrome 25
+   * uses 10 MiB).
+   */
+  static final int DEFAULT_INITIAL_WINDOW_SIZE = 65535;
+
+  /** HTTP/2: Size in bytes of the table used to decode the sender's header blocks. */
+  static final int HEADER_TABLE_SIZE = 1;
+  /** HTTP/2: The peer must not send a PUSH_PROMISE frame when this is 0. */
+  static final int ENABLE_PUSH = 2;
+  /** Sender's maximum number of concurrent streams. */
+  static final int MAX_CONCURRENT_STREAMS = 4;
+  /** HTTP/2: Size in bytes of the largest frame payload the sender will accept. */
+  static final int MAX_FRAME_SIZE = 5;
+  /** HTTP/2: Advisory only. Size in bytes of the largest header list the sender will accept. */
+  static final int MAX_HEADER_LIST_SIZE = 6;
+  /** Window size in bytes. */
+  static final int INITIAL_WINDOW_SIZE = 7;
+
+  /** Total number of settings. */
+  static final int COUNT = 10;
+
+  /** Bitfield of which flags that values. */
+  private int set;
+
+  /** Flag values. */
+  private final int[] values = new int[COUNT];
+
+  void clear() {
+    set = 0;
+    Arrays.fill(values, 0);
+  }
+
+  Settings set(int id, int value) {
+    if (id >= values.length) {
+      return this; // Discard unknown settings.
+    }
+
+    int bit = 1 << id;
+    set |= bit;
+    values[id] = value;
+    return this;
+  }
+
+  /** Returns true if a value has been assigned for the setting {@code id}. */
+  boolean isSet(int id) {
+    int bit = 1 << id;
+    return (set & bit) != 0;
+  }
+
+  /** Returns the value for the setting {@code id}, or 0 if unset. */
+  int get(int id) {
+    return values[id];
+  }
+
+  /** Returns the number of settings that have values assigned. */
+  int size() {
+    return Integer.bitCount(set);
+  }
+
+  /** Returns -1 if unset. */
+  int getHeaderTableSize() {
+    int bit = 1 << HEADER_TABLE_SIZE;
+    return (bit & set) != 0 ? values[HEADER_TABLE_SIZE] : -1;
+  }
+
+  // TODO: honor this setting.
+  boolean getEnablePush(boolean defaultValue) {
+    int bit = 1 << ENABLE_PUSH;
+    return ((bit & set) != 0 ? values[ENABLE_PUSH] : defaultValue ? 1 : 0) == 1;
+  }
+
+  // TODO: honor this setting.
+  int getMaxConcurrentStreams(int defaultValue) {
+    int bit = 1 << MAX_CONCURRENT_STREAMS;
+    return (bit & set) != 0 ? values[MAX_CONCURRENT_STREAMS] : defaultValue;
+  }
+
+  int getMaxFrameSize(int defaultValue) {
+    int bit = 1 << MAX_FRAME_SIZE;
+    return (bit & set) != 0 ? values[MAX_FRAME_SIZE] : defaultValue;
+  }
+
+  int getMaxHeaderListSize(int defaultValue) {
+    int bit = 1 << MAX_HEADER_LIST_SIZE;
+    return (bit & set) != 0 ? values[MAX_HEADER_LIST_SIZE] : defaultValue;
+  }
+
+  int getInitialWindowSize() {
+    int bit = 1 << INITIAL_WINDOW_SIZE;
+    return (bit & set) != 0 ? values[INITIAL_WINDOW_SIZE] : DEFAULT_INITIAL_WINDOW_SIZE;
+  }
+
+  /**
+   * Writes {@code other} into this. If any setting is populated by this and {@code other}, the
+   * value and flags from {@code other} will be kept.
+   */
+  void merge(Settings other) {
+    for (int i = 0; i < COUNT; i++) {
+      if (!other.isSet(i)) continue;
+      set(i, other.get(i));
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RequestException.java b/okhttp/src/main/java/okhttp3/internal/http2/StreamResetException.java
similarity index 55%
rename from okhttp/src/main/java/okhttp3/internal/http/RequestException.java
rename to okhttp/src/main/java/okhttp3/internal/http2/StreamResetException.java
index 56884c811f..299f81e1b9 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RequestException.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/StreamResetException.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Square, Inc.
+ * Copyright (C) 2016 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,22 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.http;
+package okhttp3.internal.http2;
 
 import java.io.IOException;
 
-/**
- * Indicates a problem with interpreting a request. It may indicate there was a problem with the
- * request itself, or the environment being used to interpret the request (network failure, etc.).
- */
-public final class RequestException extends Exception {
-
-  public RequestException(IOException cause) {
-    super(cause);
-  }
+/** Thrown when an HTTP/2 stream is canceled without damage to the socket that carries it. */
+public final class StreamResetException extends IOException {
+  public final ErrorCode errorCode;
 
-  @Override
-  public IOException getCause() {
-    return (IOException) super.getCause();
+  public StreamResetException(ErrorCode errorCode) {
+    super("stream was reset: " + errorCode);
+    this.errorCode = errorCode;
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java b/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java
new file mode 100644
index 0000000000..fc646ead5f
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java
@@ -0,0 +1,302 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform;
+
+import android.util.Log;
+import java.io.IOException;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.net.InetSocketAddress;
+import java.net.Socket;
+import java.security.cert.Certificate;
+import java.security.cert.X509Certificate;
+import java.util.List;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.Protocol;
+import okhttp3.internal.Util;
+import okhttp3.internal.tls.CertificateChainCleaner;
+
+/** Android 2.3 or better. */
+class AndroidPlatform extends Platform {
+  private static final int MAX_LOG_LENGTH = 4000;
+
+  private final Class<?> sslParametersClass;
+  private final OptionalMethod<Socket> setUseSessionTickets;
+  private final OptionalMethod<Socket> setHostname;
+
+  // Non-null on Android 5.0+.
+  private final OptionalMethod<Socket> getAlpnSelectedProtocol;
+  private final OptionalMethod<Socket> setAlpnProtocols;
+
+  private final CloseGuard closeGuard = CloseGuard.get();
+
+  public AndroidPlatform(Class<?> sslParametersClass, OptionalMethod<Socket> setUseSessionTickets,
+      OptionalMethod<Socket> setHostname, OptionalMethod<Socket> getAlpnSelectedProtocol,
+      OptionalMethod<Socket> setAlpnProtocols) {
+    this.sslParametersClass = sslParametersClass;
+    this.setUseSessionTickets = setUseSessionTickets;
+    this.setHostname = setHostname;
+    this.getAlpnSelectedProtocol = getAlpnSelectedProtocol;
+    this.setAlpnProtocols = setAlpnProtocols;
+  }
+
+  @Override public void connectSocket(Socket socket, InetSocketAddress address,
+      int connectTimeout) throws IOException {
+    try {
+      socket.connect(address, connectTimeout);
+    } catch (AssertionError e) {
+      if (Util.isAndroidGetsocknameError(e)) throw new IOException(e);
+      throw e;
+    } catch (SecurityException e) {
+      // Before android 4.3, socket.connect could throw a SecurityException
+      // if opening a socket resulted in an EACCES error.
+      IOException ioException = new IOException("Exception in connect");
+      ioException.initCause(e);
+      throw ioException;
+    }
+  }
+
+  @Override public X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
+    Object context = readFieldOrNull(sslSocketFactory, sslParametersClass, "sslParameters");
+    if (context == null) {
+      // If that didn't work, try the Google Play Services SSL provider before giving up. This
+      // must be loaded by the SSLSocketFactory's class loader.
+      try {
+        Class<?> gmsSslParametersClass = Class.forName(
+            "com.google.android.gms.org.conscrypt.SSLParametersImpl", false,
+            sslSocketFactory.getClass().getClassLoader());
+        context = readFieldOrNull(sslSocketFactory, gmsSslParametersClass, "sslParameters");
+      } catch (ClassNotFoundException e) {
+        return super.trustManager(sslSocketFactory);
+      }
+    }
+
+    X509TrustManager x509TrustManager = readFieldOrNull(
+        context, X509TrustManager.class, "x509TrustManager");
+    if (x509TrustManager != null) return x509TrustManager;
+
+    return readFieldOrNull(context, X509TrustManager.class, "trustManager");
+  }
+
+  @Override public void configureTlsExtensions(
+      SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
+    // Enable SNI and session tickets.
+    if (hostname != null) {
+      setUseSessionTickets.invokeOptionalWithoutCheckedException(sslSocket, true);
+      setHostname.invokeOptionalWithoutCheckedException(sslSocket, hostname);
+    }
+
+    // Enable ALPN.
+    if (setAlpnProtocols != null && setAlpnProtocols.isSupported(sslSocket)) {
+      Object[] parameters = {concatLengthPrefixed(protocols)};
+      setAlpnProtocols.invokeWithoutCheckedException(sslSocket, parameters);
+    }
+  }
+
+  @Override public String getSelectedProtocol(SSLSocket socket) {
+    if (getAlpnSelectedProtocol == null) return null;
+    if (!getAlpnSelectedProtocol.isSupported(socket)) return null;
+
+    byte[] alpnResult = (byte[]) getAlpnSelectedProtocol.invokeWithoutCheckedException(socket);
+    return alpnResult != null ? new String(alpnResult, Util.UTF_8) : null;
+  }
+
+  @Override public void log(int level, String message, Throwable t) {
+    int logLevel = level == WARN ? Log.WARN : Log.DEBUG;
+    if (t != null) message = message + '\n' + Log.getStackTraceString(t);
+
+    // Split by line, then ensure each line can fit into Log's maximum length.
+    for (int i = 0, length = message.length(); i < length; i++) {
+      int newline = message.indexOf('\n', i);
+      newline = newline != -1 ? newline : length;
+      do {
+        int end = Math.min(newline, i + MAX_LOG_LENGTH);
+        Log.println(logLevel, "OkHttp", message.substring(i, end));
+        i = end;
+      } while (i < newline);
+    }
+  }
+
+  @Override public Object getStackTraceForCloseable(String closer) {
+    return closeGuard.createAndOpen(closer);
+  }
+
+  @Override public void logCloseableLeak(String message, Object stackTrace) {
+    boolean reported = closeGuard.warnIfOpen(stackTrace);
+    if (!reported) {
+      // Unable to report via CloseGuard. As a last-ditch effort, send it to the logger.
+      log(WARN, message, null);
+    }
+  }
+
+  @Override public boolean isCleartextTrafficPermitted(String hostname) {
+    try {
+      Class<?> networkPolicyClass = Class.forName("android.security.NetworkSecurityPolicy");
+      Method getInstanceMethod = networkPolicyClass.getMethod("getInstance");
+      Object networkSecurityPolicy = getInstanceMethod.invoke(null);
+      Method isCleartextTrafficPermittedMethod = networkPolicyClass
+          .getMethod("isCleartextTrafficPermitted", String.class);
+      return (boolean) isCleartextTrafficPermittedMethod.invoke(networkSecurityPolicy, hostname);
+    } catch (ClassNotFoundException | NoSuchMethodException e) {
+      return super.isCleartextTrafficPermitted(hostname);
+    } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
+      throw new AssertionError();
+    }
+  }
+
+  public CertificateChainCleaner buildCertificateChainCleaner(X509TrustManager trustManager) {
+    try {
+      Class<?> extensionsClass = Class.forName("android.net.http.X509TrustManagerExtensions");
+      Constructor<?> constructor = extensionsClass.getConstructor(X509TrustManager.class);
+      Object extensions = constructor.newInstance(trustManager);
+      Method checkServerTrusted = extensionsClass.getMethod(
+          "checkServerTrusted", X509Certificate[].class, String.class, String.class);
+      return new AndroidCertificateChainCleaner(extensions, checkServerTrusted);
+    } catch (Exception e) {
+      return super.buildCertificateChainCleaner(trustManager);
+    }
+  }
+
+  public static Platform buildIfSupported() {
+    // Attempt to find Android 2.3+ APIs.
+    try {
+      Class<?> sslParametersClass;
+      try {
+        sslParametersClass = Class.forName("com.android.org.conscrypt.SSLParametersImpl");
+      } catch (ClassNotFoundException e) {
+        // Older platform before being unbundled.
+        sslParametersClass = Class.forName(
+            "org.apache.harmony.xnet.provider.jsse.SSLParametersImpl");
+      }
+
+      OptionalMethod<Socket> setUseSessionTickets = new OptionalMethod<>(
+          null, "setUseSessionTickets", boolean.class);
+      OptionalMethod<Socket> setHostname = new OptionalMethod<>(
+          null, "setHostname", String.class);
+      OptionalMethod<Socket> getAlpnSelectedProtocol = null;
+      OptionalMethod<Socket> setAlpnProtocols = null;
+
+      // Attempt to find Android 5.0+ APIs.
+      try {
+        Class.forName("android.net.Network"); // Arbitrary class added in Android 5.0.
+        getAlpnSelectedProtocol = new OptionalMethod<>(byte[].class, "getAlpnSelectedProtocol");
+        setAlpnProtocols = new OptionalMethod<>(null, "setAlpnProtocols", byte[].class);
+      } catch (ClassNotFoundException ignored) {
+      }
+
+      return new AndroidPlatform(sslParametersClass, setUseSessionTickets, setHostname,
+          getAlpnSelectedProtocol, setAlpnProtocols);
+    } catch (ClassNotFoundException ignored) {
+      // This isn't an Android runtime.
+    }
+
+    return null;
+  }
+
+  /**
+   * X509TrustManagerExtensions was added to Android in API 17 (Android 4.2, released in late 2012).
+   * This is the best way to get a clean chain on Android because it uses the same code as the TLS
+   * handshake.
+   */
+  static final class AndroidCertificateChainCleaner extends CertificateChainCleaner {
+    private final Object x509TrustManagerExtensions;
+    private final Method checkServerTrusted;
+
+    AndroidCertificateChainCleaner(Object x509TrustManagerExtensions, Method checkServerTrusted) {
+      this.x509TrustManagerExtensions = x509TrustManagerExtensions;
+      this.checkServerTrusted = checkServerTrusted;
+    }
+
+    @SuppressWarnings({"unchecked", "SuspiciousToArrayCall"}) // Reflection on List<Certificate>.
+    @Override public List<Certificate> clean(List<Certificate> chain, String hostname)
+        throws SSLPeerUnverifiedException {
+      try {
+        X509Certificate[] certificates = chain.toArray(new X509Certificate[chain.size()]);
+        return (List<Certificate>) checkServerTrusted.invoke(
+            x509TrustManagerExtensions, certificates, "RSA", hostname);
+      } catch (InvocationTargetException e) {
+        SSLPeerUnverifiedException exception = new SSLPeerUnverifiedException(e.getMessage());
+        exception.initCause(e);
+        throw exception;
+      } catch (IllegalAccessException e) {
+        throw new AssertionError(e);
+      }
+    }
+  }
+
+  /**
+   * Provides access to the internal dalvik.system.CloseGuard class. Android uses this in
+   * combination with android.os.StrictMode to report on leaked java.io.Closeable's. Available since
+   * Android API 11.
+   */
+  static final class CloseGuard {
+    private final Method getMethod;
+    private final Method openMethod;
+    private final Method warnIfOpenMethod;
+
+    CloseGuard(Method getMethod, Method openMethod, Method warnIfOpenMethod) {
+      this.getMethod = getMethod;
+      this.openMethod = openMethod;
+      this.warnIfOpenMethod = warnIfOpenMethod;
+    }
+
+    Object createAndOpen(String closer) {
+      if (getMethod != null) {
+        try {
+          Object closeGuardInstance = getMethod.invoke(null);
+          openMethod.invoke(closeGuardInstance, closer);
+          return closeGuardInstance;
+        } catch (Exception ignored) {
+        }
+      }
+      return null;
+    }
+
+    boolean warnIfOpen(Object closeGuardInstance) {
+      boolean reported = false;
+      if (closeGuardInstance != null) {
+        try {
+          warnIfOpenMethod.invoke(closeGuardInstance);
+          reported = true;
+        } catch (Exception ignored) {
+        }
+      }
+      return reported;
+    }
+
+    static CloseGuard get() {
+      Method getMethod;
+      Method openMethod;
+      Method warnIfOpenMethod;
+
+      try {
+        Class<?> closeGuardClass = Class.forName("dalvik.system.CloseGuard");
+        getMethod = closeGuardClass.getMethod("get");
+        openMethod = closeGuardClass.getMethod("open", String.class);
+        warnIfOpenMethod = closeGuardClass.getMethod("warnIfOpen");
+      } catch (Exception ignored) {
+        getMethod = null;
+        openMethod = null;
+        warnIfOpenMethod = null;
+      }
+      return new CloseGuard(getMethod, openMethod, warnIfOpenMethod);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java b/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java
new file mode 100644
index 0000000000..683e5c1cd4
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.List;
+import javax.net.ssl.SSLParameters;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.Protocol;
+
+/**
+ * OpenJDK 9+.
+ */
+final class Jdk9Platform extends Platform {
+  final Method setProtocolMethod;
+  final Method getProtocolMethod;
+
+  public Jdk9Platform(Method setProtocolMethod, Method getProtocolMethod) {
+    this.setProtocolMethod = setProtocolMethod;
+    this.getProtocolMethod = getProtocolMethod;
+  }
+
+  @Override
+  public void configureTlsExtensions(SSLSocket sslSocket, String hostname,
+      List<Protocol> protocols) {
+    try {
+      SSLParameters sslParameters = sslSocket.getSSLParameters();
+
+      List<String> names = alpnProtocolNames(protocols);
+
+      setProtocolMethod.invoke(sslParameters,
+          new Object[] {names.toArray(new String[names.size()])});
+
+      sslSocket.setSSLParameters(sslParameters);
+    } catch (IllegalAccessException | InvocationTargetException e) {
+      throw new AssertionError();
+    }
+  }
+
+  @Override
+  public String getSelectedProtocol(SSLSocket socket) {
+    try {
+      String protocol = (String) getProtocolMethod.invoke(socket);
+
+      // SSLSocket.getApplicationProtocol returns "" if application protocols values will not
+      // be used. Observed if you didn't specify SSLParameters.setApplicationProtocols
+      if (protocol == null || protocol.equals("")) {
+        return null;
+      }
+
+      return protocol;
+    } catch (IllegalAccessException | InvocationTargetException e) {
+      throw new AssertionError();
+    }
+  }
+
+  @Override public X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
+    // Not supported due to access checks on JDK 9+:
+    // java.lang.reflect.InaccessibleObjectException: Unable to make member of class
+    // sun.security.ssl.SSLSocketFactoryImpl accessible:  module java.base does not export
+    // sun.security.ssl to unnamed module @xxx
+    throw new UnsupportedOperationException(
+        "clientBuilder.sslSocketFactory(SSLSocketFactory) not supported on JDK 9+");
+  }
+
+  public static Jdk9Platform buildIfSupported() {
+    // Find JDK 9 new methods
+    try {
+      Method setProtocolMethod =
+          SSLParameters.class.getMethod("setApplicationProtocols", String[].class);
+      Method getProtocolMethod = SSLSocket.class.getMethod("getApplicationProtocol");
+
+      return new Jdk9Platform(setProtocolMethod, getProtocolMethod);
+    } catch (NoSuchMethodException ignored) {
+      // pre JDK 9
+    }
+
+    return null;
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java b/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java
new file mode 100644
index 0000000000..3d092b5cc2
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java
@@ -0,0 +1,149 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform;
+
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Proxy;
+import java.util.List;
+import javax.net.ssl.SSLSocket;
+import okhttp3.Protocol;
+import okhttp3.internal.Util;
+
+/**
+ * OpenJDK 7 or OpenJDK 8 with {@code org.mortbay.jetty.alpn/alpn-boot} in the boot class path.
+ */
+class JdkWithJettyBootPlatform extends Platform {
+  private final Method putMethod;
+  private final Method getMethod;
+  private final Method removeMethod;
+  private final Class<?> clientProviderClass;
+  private final Class<?> serverProviderClass;
+
+  public JdkWithJettyBootPlatform(Method putMethod, Method getMethod, Method removeMethod,
+      Class<?> clientProviderClass, Class<?> serverProviderClass) {
+    this.putMethod = putMethod;
+    this.getMethod = getMethod;
+    this.removeMethod = removeMethod;
+    this.clientProviderClass = clientProviderClass;
+    this.serverProviderClass = serverProviderClass;
+  }
+
+  @Override public void configureTlsExtensions(
+      SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
+    List<String> names = alpnProtocolNames(protocols);
+
+    try {
+      Object provider = Proxy.newProxyInstance(Platform.class.getClassLoader(),
+          new Class[] {clientProviderClass, serverProviderClass}, new JettyNegoProvider(names));
+      putMethod.invoke(null, sslSocket, provider);
+    } catch (InvocationTargetException | IllegalAccessException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  @Override public void afterHandshake(SSLSocket sslSocket) {
+    try {
+      removeMethod.invoke(null, sslSocket);
+    } catch (IllegalAccessException | InvocationTargetException ignored) {
+      throw new AssertionError();
+    }
+  }
+
+  @Override public String getSelectedProtocol(SSLSocket socket) {
+    try {
+      JettyNegoProvider provider =
+          (JettyNegoProvider) Proxy.getInvocationHandler(getMethod.invoke(null, socket));
+      if (!provider.unsupported && provider.selected == null) {
+        Platform.get().log(INFO, "ALPN callback dropped: HTTP/2 is disabled. "
+            + "Is alpn-boot on the boot class path?", null);
+        return null;
+      }
+      return provider.unsupported ? null : provider.selected;
+    } catch (InvocationTargetException | IllegalAccessException e) {
+      throw new AssertionError();
+    }
+  }
+
+  public static Platform buildIfSupported() {
+    // Find Jetty's ALPN extension for OpenJDK.
+    try {
+      String negoClassName = "org.eclipse.jetty.alpn.ALPN";
+      Class<?> negoClass = Class.forName(negoClassName);
+      Class<?> providerClass = Class.forName(negoClassName + "$Provider");
+      Class<?> clientProviderClass = Class.forName(negoClassName + "$ClientProvider");
+      Class<?> serverProviderClass = Class.forName(negoClassName + "$ServerProvider");
+      Method putMethod = negoClass.getMethod("put", SSLSocket.class, providerClass);
+      Method getMethod = negoClass.getMethod("get", SSLSocket.class);
+      Method removeMethod = negoClass.getMethod("remove", SSLSocket.class);
+      return new JdkWithJettyBootPlatform(
+          putMethod, getMethod, removeMethod, clientProviderClass, serverProviderClass);
+    } catch (ClassNotFoundException | NoSuchMethodException ignored) {
+    }
+
+    return null;
+  }
+
+  /**
+   * Handle the methods of ALPN's ClientProvider and ServerProvider without a compile-time
+   * dependency on those interfaces.
+   */
+  private static class JettyNegoProvider implements InvocationHandler {
+    /** This peer's supported protocols. */
+    private final List<String> protocols;
+    /** Set when remote peer notifies ALPN is unsupported. */
+    private boolean unsupported;
+    /** The protocol the server selected. */
+    private String selected;
+
+    public JettyNegoProvider(List<String> protocols) {
+      this.protocols = protocols;
+    }
+
+    @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
+      String methodName = method.getName();
+      Class<?> returnType = method.getReturnType();
+      if (args == null) {
+        args = Util.EMPTY_STRING_ARRAY;
+      }
+      if (methodName.equals("supports") && boolean.class == returnType) {
+        return true; // ALPN is supported.
+      } else if (methodName.equals("unsupported") && void.class == returnType) {
+        this.unsupported = true; // Peer doesn't support ALPN.
+        return null;
+      } else if (methodName.equals("protocols") && args.length == 0) {
+        return protocols; // Client advertises these protocols.
+      } else if ((methodName.equals("selectProtocol") || methodName.equals("select"))
+          && String.class == returnType && args.length == 1 && args[0] instanceof List) {
+        List<String> peerProtocols = (List) args[0];
+        // Pick the first known protocol the peer advertises.
+        for (int i = 0, size = peerProtocols.size(); i < size; i++) {
+          if (protocols.contains(peerProtocols.get(i))) {
+            return selected = peerProtocols.get(i);
+          }
+        }
+        return selected = protocols.get(0); // On no intersection, try peer's first protocol.
+      } else if ((methodName.equals("protocolSelected") || methodName.equals("selected"))
+          && args.length == 1) {
+        this.selected = (String) args[0]; // Server selected this protocol.
+        return null;
+      } else {
+        return method.invoke(this, args);
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/OptionalMethod.java b/okhttp/src/main/java/okhttp3/internal/platform/OptionalMethod.java
similarity index 99%
rename from okhttp/src/main/java/okhttp3/internal/OptionalMethod.java
rename to okhttp/src/main/java/okhttp3/internal/platform/OptionalMethod.java
index 108ec292d1..b7b1717b0e 100644
--- a/okhttp/src/main/java/okhttp3/internal/OptionalMethod.java
+++ b/okhttp/src/main/java/okhttp3/internal/platform/OptionalMethod.java
@@ -15,7 +15,7 @@
  *  limitations under the License.
  */
 
-package okhttp3.internal;
+package okhttp3.internal.platform;
 
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Platform.java b/okhttp/src/main/java/okhttp3/internal/platform/Platform.java
new file mode 100644
index 0000000000..83c36fdd0f
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/Platform.java
@@ -0,0 +1,231 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform;
+
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.net.InetSocketAddress;
+import java.net.Socket;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.internal.tls.BasicCertificateChainCleaner;
+import okhttp3.internal.tls.CertificateChainCleaner;
+import okhttp3.internal.tls.TrustRootIndex;
+import okio.Buffer;
+
+/**
+ * Access to platform-specific features.
+ *
+ * <h3>Server name indication (SNI)</h3>
+ *
+ * <p>Supported on Android 2.3+.
+ *
+ * Supported on OpenJDK 7+
+ *
+ * <h3>Session Tickets</h3>
+ *
+ * <p>Supported on Android 2.3+.
+ *
+ * <h3>Android Traffic Stats (Socket Tagging)</h3>
+ *
+ * <p>Supported on Android 4.0+.
+ *
+ * <h3>ALPN (Application Layer Protocol Negotiation)</h3>
+ *
+ * <p>Supported on Android 5.0+. The APIs were present in Android 4.4, but that implementation was
+ * unstable.
+ *
+ * Supported on OpenJDK 7 and 8 (via the JettyALPN-boot library).
+ *
+ * Supported on OpenJDK 9 via SSLParameters and SSLSocket features.
+ *
+ * <h3>Trust Manager Extraction</h3>
+ *
+ * <p>Supported on Android 2.3+ and OpenJDK 7+. There are no public APIs to recover the trust
+ * manager that was used to create an {@link SSLSocketFactory}.
+ *
+ * <h3>Android Cleartext Permit Detection</h3>
+ *
+ * <p>Supported on Android 6.0+ via {@code NetworkSecurityPolicy}.
+ */
+public class Platform {
+  private static final Platform PLATFORM = findPlatform();
+  public static final int INFO = 4;
+  public static final int WARN = 5;
+  private static final Logger logger = Logger.getLogger(OkHttpClient.class.getName());
+
+  public static Platform get() {
+    return PLATFORM;
+  }
+
+  /** Prefix used on custom headers. */
+  public String getPrefix() {
+    return "OkHttp";
+  }
+
+  public X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
+    // Attempt to get the trust manager from an OpenJDK socket factory. We attempt this on all
+    // platforms in order to support Robolectric, which mixes classes from both Android and the
+    // Oracle JDK. Note that we don't support HTTP/2 or other nice features on Robolectric.
+    try {
+      Class<?> sslContextClass = Class.forName("sun.security.ssl.SSLContextImpl");
+      Object context = readFieldOrNull(sslSocketFactory, sslContextClass, "context");
+      if (context == null) return null;
+      return readFieldOrNull(context, X509TrustManager.class, "trustManager");
+    } catch (ClassNotFoundException e) {
+      return null;
+    }
+  }
+
+  /**
+   * Configure TLS extensions on {@code sslSocket} for {@code route}.
+   *
+   * @param hostname non-null for client-side handshakes; null for server-side handshakes.
+   */
+  public void configureTlsExtensions(SSLSocket sslSocket, String hostname,
+      List<Protocol> protocols) {
+  }
+
+  /**
+   * Called after the TLS handshake to release resources allocated by {@link
+   * #configureTlsExtensions}.
+   */
+  public void afterHandshake(SSLSocket sslSocket) {
+  }
+
+  /** Returns the negotiated protocol, or null if no protocol was negotiated. */
+  public String getSelectedProtocol(SSLSocket socket) {
+    return null;
+  }
+
+  public void connectSocket(Socket socket, InetSocketAddress address,
+      int connectTimeout) throws IOException {
+    socket.connect(address, connectTimeout);
+  }
+
+  public void log(int level, String message, Throwable t) {
+    Level logLevel = level == WARN ? Level.WARNING : Level.INFO;
+    logger.log(logLevel, message, t);
+  }
+
+  public boolean isCleartextTrafficPermitted(String hostname) {
+    return true;
+  }
+
+  /**
+   * Returns an object that holds a stack trace created at the moment this method is executed. This
+   * should be used specifically for {@link java.io.Closeable} objects and in conjunction with
+   * {@link #logCloseableLeak(String, Object)}.
+   */
+  public Object getStackTraceForCloseable(String closer) {
+    if (logger.isLoggable(Level.FINE)) {
+      return new Throwable(closer); // These are expensive to allocate.
+    }
+    return null;
+  }
+
+  public void logCloseableLeak(String message, Object stackTrace) {
+    if (stackTrace == null) {
+      message += " To see where this was allocated, set the OkHttpClient logger level to FINE: "
+          + "Logger.getLogger(OkHttpClient.class.getName()).setLevel(Level.FINE);";
+    }
+    log(WARN, message, (Throwable) stackTrace);
+  }
+
+  public static List<String> alpnProtocolNames(List<Protocol> protocols) {
+    List<String> names = new ArrayList<>(protocols.size());
+    for (int i = 0, size = protocols.size(); i < size; i++) {
+      Protocol protocol = protocols.get(i);
+      if (protocol == Protocol.HTTP_1_0) continue; // No HTTP/1.0 for ALPN.
+      names.add(protocol.toString());
+    }
+    return names;
+  }
+
+  public CertificateChainCleaner buildCertificateChainCleaner(X509TrustManager trustManager) {
+    return new BasicCertificateChainCleaner(TrustRootIndex.get(trustManager));
+  }
+
+  /** Attempt to match the host runtime to a capable Platform implementation. */
+  private static Platform findPlatform() {
+    Platform android = AndroidPlatform.buildIfSupported();
+
+    if (android != null) {
+      return android;
+    }
+
+    Platform jdk9 = Jdk9Platform.buildIfSupported();
+
+    if (jdk9 != null) {
+      return jdk9;
+    }
+
+    Platform jdkWithJettyBoot = JdkWithJettyBootPlatform.buildIfSupported();
+
+    if (jdkWithJettyBoot != null) {
+      return jdkWithJettyBoot;
+    }
+
+    // Probably an Oracle JDK like OpenJDK.
+    return new Platform();
+  }
+
+  /**
+   * Returns the concatenation of 8-bit, length prefixed protocol names.
+   * http://tools.ietf.org/html/draft-agl-tls-nextprotoneg-04#page-4
+   */
+  static byte[] concatLengthPrefixed(List<Protocol> protocols) {
+    Buffer result = new Buffer();
+    for (int i = 0, size = protocols.size(); i < size; i++) {
+      Protocol protocol = protocols.get(i);
+      if (protocol == Protocol.HTTP_1_0) continue; // No HTTP/1.0 for ALPN.
+      result.writeByte(protocol.toString().length());
+      result.writeUtf8(protocol.toString());
+    }
+    return result.readByteArray();
+  }
+
+  static <T> T readFieldOrNull(Object instance, Class<T> fieldType, String fieldName) {
+    for (Class<?> c = instance.getClass(); c != Object.class; c = c.getSuperclass()) {
+      try {
+        Field field = c.getDeclaredField(fieldName);
+        field.setAccessible(true);
+        Object value = field.get(instance);
+        if (value == null || !fieldType.isInstance(value)) return null;
+        return fieldType.cast(value);
+      } catch (NoSuchFieldException ignored) {
+      } catch (IllegalAccessException e) {
+        throw new AssertionError();
+      }
+    }
+
+    // Didn't find the field we wanted. As a last gasp attempt, try to find the value on a delegate.
+    if (!fieldName.equals("delegate")) {
+      Object delegate = readFieldOrNull(instance, Object.class, "delegate");
+      if (delegate != null) return readFieldOrNull(delegate, fieldType, fieldName);
+    }
+
+    return null;
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/BasicCertificateChainCleaner.java b/okhttp/src/main/java/okhttp3/internal/tls/BasicCertificateChainCleaner.java
new file mode 100644
index 0000000000..cd9ac03971
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/tls/BasicCertificateChainCleaner.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.tls;
+
+import java.security.GeneralSecurityException;
+import java.security.cert.Certificate;
+import java.security.cert.X509Certificate;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Deque;
+import java.util.Iterator;
+import java.util.List;
+import javax.net.ssl.SSLPeerUnverifiedException;
+
+/**
+ * A certificate chain cleaner that uses a set of trusted root certificates to build the trusted
+ * chain. This class duplicates the clean chain building performed during the TLS handshake. We
+ * prefer other mechanisms where they exist, such as with
+ * {@code okhttp3.internal.platform.AndroidPlatform.AndroidCertificateChainCleaner}.
+ *
+ * <p>This class includes code from <a href="https://conscrypt.org/">Conscrypt's</a> {@code
+ * TrustManagerImpl} and {@code TrustedCertificateIndex}.
+ */
+public final class BasicCertificateChainCleaner extends CertificateChainCleaner {
+  /** The maximum number of signers in a chain. We use 9 for consistency with OpenSSL. */
+  private static final int MAX_SIGNERS = 9;
+
+  private final TrustRootIndex trustRootIndex;
+
+  public BasicCertificateChainCleaner(TrustRootIndex trustRootIndex) {
+    this.trustRootIndex = trustRootIndex;
+  }
+
+  /**
+   * Returns a cleaned chain for {@code chain}.
+   *
+   * <p>This method throws if the complete chain to a trusted CA certificate cannot be constructed.
+   * This is unexpected unless the trust root index in this class has a different trust manager than
+   * what was used to establish {@code chain}.
+   */
+  @Override public List<Certificate> clean(List<Certificate> chain, String hostname)
+      throws SSLPeerUnverifiedException {
+    Deque<Certificate> queue = new ArrayDeque<>(chain);
+    List<Certificate> result = new ArrayList<>();
+    result.add(queue.removeFirst());
+    boolean foundTrustedCertificate = false;
+
+    followIssuerChain:
+    for (int c = 0; c < MAX_SIGNERS; c++) {
+      X509Certificate toVerify = (X509Certificate) result.get(result.size() - 1);
+
+      // If this cert has been signed by a trusted cert, use that. Add the trusted certificate to
+      // the end of the chain unless it's already present. (That would happen if the first
+      // certificate in the chain is itself a self-signed and trusted CA certificate.)
+      X509Certificate trustedCert = trustRootIndex.findByIssuerAndSignature(toVerify);
+      if (trustedCert != null) {
+        if (result.size() > 1 || !toVerify.equals(trustedCert)) {
+          result.add(trustedCert);
+        }
+        if (verifySignature(trustedCert, trustedCert)) {
+          return result; // The self-signed cert is a root CA. We're done.
+        }
+        foundTrustedCertificate = true;
+        continue;
+      }
+
+      // Search for the certificate in the chain that signed this certificate. This is typically
+      // the next element in the chain, but it could be any element.
+      for (Iterator<Certificate> i = queue.iterator(); i.hasNext(); ) {
+        X509Certificate signingCert = (X509Certificate) i.next();
+        if (verifySignature(toVerify, signingCert)) {
+          i.remove();
+          result.add(signingCert);
+          continue followIssuerChain;
+        }
+      }
+
+      // We've reached the end of the chain. If any cert in the chain is trusted, we're done.
+      if (foundTrustedCertificate) {
+        return result;
+      }
+
+      // The last link isn't trusted. Fail.
+      throw new SSLPeerUnverifiedException(
+          "Failed to find a trusted cert that signed " + toVerify);
+    }
+
+    throw new SSLPeerUnverifiedException("Certificate chain too long: " + result);
+  }
+
+  /** Returns true if {@code toVerify} was signed by {@code signingCert}'s public key. */
+  private boolean verifySignature(X509Certificate toVerify, X509Certificate signingCert) {
+    if (!toVerify.getIssuerDN().equals(signingCert.getSubjectDN())) return false;
+    try {
+      toVerify.verify(signingCert.getPublicKey());
+      return true;
+    } catch (GeneralSecurityException verifyFailed) {
+      return false;
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java b/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java
index 672e48651b..3e69f23061 100644
--- a/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java
+++ b/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java
@@ -16,19 +16,12 @@
  */
 package okhttp3.internal.tls;
 
-import java.lang.reflect.Constructor;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.security.GeneralSecurityException;
 import java.security.cert.Certificate;
 import java.security.cert.X509Certificate;
-import java.util.ArrayDeque;
-import java.util.ArrayList;
-import java.util.Deque;
-import java.util.Iterator;
 import java.util.List;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.X509TrustManager;
+import okhttp3.internal.platform.Platform;
 
 /**
  * Computes the effective certificate chain from the raw array returned by Java's built in TLS APIs.
@@ -45,137 +38,10 @@
       throws SSLPeerUnverifiedException;
 
   public static CertificateChainCleaner get(X509TrustManager trustManager) {
-    try {
-      Class<?> extensionsClass = Class.forName("android.net.http.X509TrustManagerExtensions");
-      Constructor<?> constructor = extensionsClass.getConstructor(X509TrustManager.class);
-      Object extensions = constructor.newInstance(trustManager);
-      Method checkServerTrusted = extensionsClass.getMethod(
-          "checkServerTrusted", X509Certificate[].class, String.class, String.class);
-      return new AndroidCertificateChainCleaner(extensions, checkServerTrusted);
-    } catch (Exception e) {
-      return new BasicCertificateChainCleaner(TrustRootIndex.get(trustManager));
-    }
+    return Platform.get().buildCertificateChainCleaner(trustManager);
   }
 
   public static CertificateChainCleaner get(X509Certificate... caCerts) {
     return new BasicCertificateChainCleaner(TrustRootIndex.get(caCerts));
   }
-
-  /**
-   * A certificate chain cleaner that uses a set of trusted root certificates to build the trusted
-   * chain. This class duplicates the clean chain building performed during the TLS handshake. We
-   * prefer other mechanisms where they exist, such as with {@link AndroidCertificateChainCleaner}.
-   *
-   * <p>This class includes code from <a href="https://conscrypt.org/">Conscrypt's</a> {@code
-   * TrustManagerImpl} and {@code TrustedCertificateIndex}.
-   */
-  static final class BasicCertificateChainCleaner extends CertificateChainCleaner {
-    /** The maximum number of signers in a chain. We use 9 for consistency with OpenSSL. */
-    private static final int MAX_SIGNERS = 9;
-
-    private final TrustRootIndex trustRootIndex;
-
-    public BasicCertificateChainCleaner(TrustRootIndex trustRootIndex) {
-      this.trustRootIndex = trustRootIndex;
-    }
-
-    /**
-     * Returns a cleaned chain for {@code chain}.
-     *
-     * <p>This method throws if the complete chain to a trusted CA certificate cannot be
-     * constructed. This is unexpected unless the trust root index in this class has a different
-     * trust manager than what was used to establish {@code chain}.
-     */
-    @Override public List<Certificate> clean(List<Certificate> chain, String hostname)
-        throws SSLPeerUnverifiedException {
-      Deque<Certificate> queue = new ArrayDeque<>(chain);
-      List<Certificate> result = new ArrayList<>();
-      result.add(queue.removeFirst());
-      boolean foundTrustedCertificate = false;
-
-      followIssuerChain:
-      for (int c = 0; c < MAX_SIGNERS; c++) {
-        X509Certificate toVerify = (X509Certificate) result.get(result.size() - 1);
-
-        // If this cert has been signed by a trusted cert, use that. Add the trusted certificate to
-        // the end of the chain unless it's already present. (That would happen if the first
-        // certificate in the chain is itself a self-signed and trusted CA certificate.)
-        X509Certificate trustedCert = trustRootIndex.findByIssuerAndSignature(toVerify);
-        if (trustedCert != null) {
-          if (result.size() > 1 || !toVerify.equals(trustedCert)) {
-            result.add(trustedCert);
-          }
-          if (verifySignature(trustedCert, trustedCert)) {
-            return result; // The self-signed cert is a root CA. We're done.
-          }
-          foundTrustedCertificate = true;
-          continue;
-        }
-
-        // Search for the certificate in the chain that signed this certificate. This is typically
-        // the next element in the chain, but it could be any element.
-        for (Iterator<Certificate> i = queue.iterator(); i.hasNext(); ) {
-          X509Certificate signingCert = (X509Certificate) i.next();
-          if (verifySignature(toVerify, signingCert)) {
-            i.remove();
-            result.add(signingCert);
-            continue followIssuerChain;
-          }
-        }
-
-        // We've reached the end of the chain. If any cert in the chain is trusted, we're done.
-        if (foundTrustedCertificate) {
-          return result;
-        }
-
-        // The last link isn't trusted. Fail.
-        throw new SSLPeerUnverifiedException(
-            "Failed to find a trusted cert that signed " + toVerify);
-      }
-
-      throw new SSLPeerUnverifiedException("Certificate chain too long: " + result);
-    }
-
-    /** Returns true if {@code toVerify} was signed by {@code signingCert}'s public key. */
-    private boolean verifySignature(X509Certificate toVerify, X509Certificate signingCert) {
-      if (!toVerify.getIssuerDN().equals(signingCert.getSubjectDN())) return false;
-      try {
-        toVerify.verify(signingCert.getPublicKey());
-        return true;
-      } catch (GeneralSecurityException verifyFailed) {
-        return false;
-      }
-    }
-  }
-
-  /**
-   * X509TrustManagerExtensions was added to Android in API 17 (Android 4.2, released in late 2012).
-   * This is the best way to get a clean chain on Android because it uses the same code as the TLS
-   * handshake.
-   */
-  static final class AndroidCertificateChainCleaner extends CertificateChainCleaner {
-    private final Object x509TrustManagerExtensions;
-    private final Method checkServerTrusted;
-
-    AndroidCertificateChainCleaner(Object x509TrustManagerExtensions, Method checkServerTrusted) {
-      this.x509TrustManagerExtensions = x509TrustManagerExtensions;
-      this.checkServerTrusted = checkServerTrusted;
-    }
-
-    @SuppressWarnings({"unchecked", "SuspiciousToArrayCall"}) // Reflection on List<Certificate>.
-    @Override public List<Certificate> clean(List<Certificate> chain, String hostname)
-        throws SSLPeerUnverifiedException {
-      try {
-        X509Certificate[] certificates = chain.toArray(new X509Certificate[chain.size()]);
-        return (List<Certificate>) checkServerTrusted.invoke(
-            x509TrustManagerExtensions, certificates, "RSA", hostname);
-      } catch (InvocationTargetException e) {
-        SSLPeerUnverifiedException exception = new SSLPeerUnverifiedException(e.getMessage());
-        exception.initCause(e);
-        throw exception;
-      } catch (IllegalAccessException e) {
-        throw new AssertionError(e);
-      }
-    }
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java b/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java
index fcc7468e0e..8b5439b182 100644
--- a/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java
+++ b/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java
@@ -29,7 +29,7 @@
 
 public abstract class TrustRootIndex {
   /** Returns the trusted CA certificate that signed {@code cert}. */
-  abstract X509Certificate findByIssuerAndSignature(X509Certificate cert);
+  public abstract X509Certificate findByIssuerAndSignature(X509Certificate cert);
 
   public static TrustRootIndex get(X509TrustManager trustManager) {
     try {
@@ -55,7 +55,7 @@ public static TrustRootIndex get(X509Certificate... caCerts) {
    *
    * <p>This class uses APIs added to Android in API 14 (Android 4.0, released October 2011). This
    * class shouldn't be used in Android API 17 or better because those releases are better served by
-   * {@link CertificateChainCleaner.AndroidCertificateChainCleaner}.
+   * {@link okhttp3.internal.AndroidPlatform.AndroidCertificateChainCleaner}.
    */
   static final class AndroidTrustRootIndex extends TrustRootIndex {
     private final X509TrustManager trustManager;
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
new file mode 100644
index 0000000000..bf7d1d60f5
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
@@ -0,0 +1,322 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.ws;
+
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.util.Random;
+import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicBoolean;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.WebSocket;
+import okhttp3.WebSocketListener;
+import okhttp3.internal.NamedRunnable;
+import okhttp3.internal.Util;
+import okhttp3.internal.platform.Platform;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.Okio;
+
+import static okhttp3.internal.platform.Platform.INFO;
+import static okhttp3.internal.ws.WebSocketProtocol.CLOSE_ABNORMAL_TERMINATION;
+import static okhttp3.internal.ws.WebSocketProtocol.CLOSE_CLIENT_GOING_AWAY;
+import static okhttp3.internal.ws.WebSocketProtocol.CLOSE_PROTOCOL_EXCEPTION;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_BINARY;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_TEXT;
+import static okhttp3.internal.ws.WebSocketReader.FrameCallback;
+
+/**
+ * An implementation of {@link WebSocket} which sits on top of {@link WebSocketReader} and
+ * {@link WebSocketWriter}.
+ *
+ * <h2>Threading</h2>
+ * This class deals with three threads concurrently and care must be taken to only access the
+ * appropriate resources on each:
+ * <ul>
+ * <li><b>Reader</b>: This is the only thread allowed to access {@link #reader}. Methods from
+ * {@link FrameCallback} will happen on this thread as a result. This is the only thread that
+ * should invoke methods on the {@link #readerListener}.</li>
+ * <li><b>Replier</b>: Invoked on {@link #replier} to write responses from reading
+ * frames. Contends with the "Sender" thread for access to {@link #writer}.</li>
+ * <li><b>Sender</b>: Methods from {@link WebSocket} will happen on this thread. Contends with the
+ * "Replier" thread</li>
+ * </ul>
+ * Instance variables have prefixes matching the thread names based on the thread on which they can
+ * be accessed. A prefix of "writer" indicates both "Sender" and "Replier" threads can access.
+ */
+public abstract class RealWebSocket implements WebSocket, FrameCallback {
+  private final WebSocketReader reader;
+  private final WebSocketListener readerListener;
+  /** True after a close frame was read by the reader. No frames will follow it. */
+  private boolean readerSawClose;
+
+  final WebSocketWriter writer;
+  /** True after calling {@link WebSocketWriter#writeClose(int, String)} to send a close frame. */
+  final AtomicBoolean writerClosed = new AtomicBoolean();
+
+  /** Guarded by itself. Must check {@link #isShutdown} before enqueuing work. */
+  private final Executor replier;
+
+  /** True after calling {@link #close(int, String)}. No writes are allowed afterward. */
+  private boolean senderSentClose;
+  /** True after {@link IOException}. {@link #close(int, String)} becomes only valid call. */
+  private boolean senderWantsClose;
+
+  private final Response response;
+  private final String name;
+
+  /** Guarded by {@link #replier}. True after calling {@link #shutdown()}. */
+  private boolean isShutdown;
+
+  protected RealWebSocket(boolean isClient, BufferedSource source, BufferedSink sink, Random random,
+      Executor replier, WebSocketListener readerListener, Response response, String name) {
+    this.readerListener = readerListener;
+    this.replier = replier;
+    this.response = response;
+    this.name = name;
+
+    reader = new WebSocketReader(isClient, source, this);
+    writer = new WebSocketWriter(isClient, sink, random);
+  }
+
+  ////// READER THREAD
+
+  /** Read and process all socket messages delivering callbacks to the supplied listener. */
+  public final void loopReader() {
+    try {
+      readerListener.onOpen(this, response);
+    } catch (Throwable t) {
+      Util.throwIfFatal(t);
+      replyToReaderError(t);
+      readerListener.onFailure(t, null);
+      return;
+    }
+
+    while (processNextFrame()) {
+    }
+  }
+
+  /**
+   * Read a single control frame or all frames of a message from the web socket and deliver any
+   * notifications to the listener. Returns false when no more messages can be read.
+   */
+  final boolean processNextFrame() {
+    try {
+      // This method call results in one or more onRead* methods being called on this thread.
+      reader.processNextFrame();
+
+      return !readerSawClose;
+    } catch (Throwable t) {
+      Util.throwIfFatal(t);
+      replyToReaderError(t);
+      if (t instanceof IOException && !(t instanceof ProtocolException)) {
+        readerListener.onClose(CLOSE_ABNORMAL_TERMINATION, "");
+      } else {
+        readerListener.onFailure(t, null);
+      }
+      return false;
+    }
+  }
+
+  @Override public final void onReadMessage(ResponseBody message) throws IOException {
+    readerListener.onMessage(message);
+  }
+
+  @Override public final void onReadPing(ByteString buffer) {
+    replyToPeerPing(buffer);
+  }
+
+  @Override public final void onReadPong(ByteString buffer) {
+    readerListener.onPong(buffer);
+  }
+
+  @Override public final void onReadClose(int code, String reason) {
+    replyToPeerClose(code, reason);
+    readerSawClose = true;
+    readerListener.onClose(code, reason);
+  }
+
+  ///// REPLIER THREAD (executed on replier, contends with sender thread)
+
+  /** Replies with a pong when a ping frame is read from the peer. */
+  private void replyToPeerPing(final ByteString payload) {
+    Runnable replierPong = new NamedRunnable("OkHttp %s WebSocket Pong Reply", name) {
+      @Override protected void execute() {
+        try {
+          writer.writePong(payload);
+        } catch (IOException t) {
+          Platform.get().log(INFO, "Unable to send pong reply in response to peer ping.", t);
+        }
+      }
+    };
+    synchronized (replier) {
+      if (!isShutdown) {
+        replier.execute(replierPong);
+      }
+    }
+  }
+
+  /** Replies and closes this web socket when a close frame is read from the peer. */
+  private void replyToPeerClose(final int code, final String reason) {
+    Runnable replierClose = new NamedRunnable("OkHttp %s WebSocket Close Reply", name) {
+      @Override protected void execute() {
+        if (writerClosed.compareAndSet(false, true)) {
+          try {
+            writer.writeClose(code, reason);
+          } catch (IOException t) {
+            Platform.get().log(INFO, "Unable to send close reply in response to peer close.", t);
+          }
+        }
+
+        quietlyCloseConnection();
+      }
+    };
+    synchronized (replier) {
+      if (!isShutdown) {
+        replier.execute(replierClose);
+      }
+    }
+  }
+
+  private void replyToReaderError(final Throwable t) {
+    Runnable replierClose = new NamedRunnable("OkHttp %s WebSocket Fatal Reply", name) {
+      @Override protected void execute() {
+        if (writerClosed.compareAndSet(false, true)) {
+          // For protocol and runtime exceptions, try to inform the server of such.
+          boolean protocolException = t instanceof ProtocolException;
+          boolean runtimeException = !(t instanceof IOException);
+          if (protocolException || runtimeException) {
+            int code = protocolException ? CLOSE_PROTOCOL_EXCEPTION : CLOSE_CLIENT_GOING_AWAY;
+            try {
+              writer.writeClose(code, null);
+            } catch (IOException inner) {
+              Platform.get()
+                  .log(INFO, "Unable to send close in response to listener error.", inner);
+            }
+          }
+        }
+
+        quietlyCloseConnection();
+      }
+    };
+    synchronized (replier) {
+      if (!isShutdown) {
+        replier.execute(replierClose);
+      }
+    }
+  }
+
+  ////// SENDER THREAD (aka user thread)
+
+  @Override public final void sendMessage(RequestBody message) throws IOException {
+    if (message == null) throw new NullPointerException("message == null");
+    if (senderSentClose) throw new IllegalStateException("closed");
+    if (senderWantsClose) throw new IllegalStateException("must call close()");
+
+    MediaType contentType = message.contentType();
+    if (contentType == null) {
+      throw new IllegalArgumentException(
+          "Message content type was null. Must use WebSocket.TEXT or WebSocket.BINARY.");
+    }
+    String contentSubtype = contentType.subtype();
+
+    int formatOpcode;
+    if (WebSocket.TEXT.subtype().equals(contentSubtype)) {
+      formatOpcode = OPCODE_TEXT;
+    } else if (WebSocket.BINARY.subtype().equals(contentSubtype)) {
+      formatOpcode = OPCODE_BINARY;
+    } else {
+      throw new IllegalArgumentException("Unknown message content type: "
+          + contentType.type() + "/" + contentType.subtype() // Omit any implicitly added charset.
+          + ". Must use WebSocket.TEXT or WebSocket.BINARY.");
+    }
+
+    BufferedSink sink = Okio.buffer(writer.newMessageSink(formatOpcode, message.contentLength()));
+    try {
+      message.writeTo(sink);
+      sink.close();
+    } catch (IOException e) {
+      senderWantsClose = true;
+      throw e;
+    }
+  }
+
+  @Override public final void sendPing(ByteString payload) throws IOException {
+    if (payload == null) throw new NullPointerException("payload == null");
+    if (senderSentClose) throw new IllegalStateException("closed");
+    if (senderWantsClose) throw new IllegalStateException("must call close()");
+
+    try {
+      writer.writePing(payload);
+    } catch (IOException e) {
+      senderWantsClose = true;
+      throw e;
+    }
+  }
+
+  /** Send an unsolicited pong with the specified payload. */
+  final void sendPong(ByteString payload) throws IOException {
+    if (payload == null) throw new NullPointerException("payload == null");
+    if (senderSentClose) throw new IllegalStateException("closed");
+    if (senderWantsClose) throw new IllegalStateException("must call close()");
+
+    try {
+      writer.writePong(payload);
+    } catch (IOException e) {
+      senderWantsClose = true;
+      throw e;
+    }
+  }
+
+  @Override public final void close(int code, String reason) throws IOException {
+    if (senderSentClose) throw new IllegalStateException("closed");
+    senderSentClose = true;
+
+    // Not doing a CAS because we want writer to throw if already closed via peer close.
+    writerClosed.set(true);
+
+    try {
+      writer.writeClose(code, reason);
+    } catch (IOException e) {
+      quietlyCloseConnection();
+      throw e;
+    }
+
+    // NOTE: We do not close the connection here! That will happen when we read the close reply.
+  }
+
+  ////// ANY THREAD
+
+  void quietlyCloseConnection() {
+    synchronized (replier) {
+      if (isShutdown) return;
+      isShutdown = true;
+    }
+    try {
+      shutdown();
+    } catch (Throwable inner) {
+      Util.throwIfFatal(inner);
+      Platform.get().log(INFO, "Unable to close web socket connection.", inner);
+    }
+  }
+
+  /** Perform any tear-down work (close the connection, shutdown executors). */
+  protected abstract void shutdown();
+}
diff --git a/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
similarity index 88%
rename from okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
rename to okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
index 0a1126a147..bff2d9c992 100644
--- a/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
@@ -15,6 +15,7 @@
  */
 package okhttp3.internal.ws;
 
+import java.io.IOException;
 import java.net.ProtocolException;
 
 public final class WebSocketProtocol {
@@ -84,6 +85,15 @@
    */
   static final int PAYLOAD_LONG = 127;
 
+  /** Used when an unchecked exception was thrown in a listener. */
+  static final int CLOSE_CLIENT_GOING_AWAY = 1001;
+  /** Used when a {@link ProtocolException} was thrown by the reader or writer. */
+  static final int CLOSE_PROTOCOL_EXCEPTION = 1002;
+  /** Used when an empty close frame was received (i.e., without a status code). */
+  static final int CLOSE_NO_STATUS_CODE = 1005;
+  /** Used when a non-{@link ProtocolException} {@link IOException} was thrown by the reader. */
+  static final int CLOSE_ABNORMAL_TERMINATION = 1006;
+
   static void toggleMask(byte[] buffer, long byteCount, byte[] key, long frameBytesRead) {
     int keyLength = key.length;
     for (int i = 0; i < byteCount; i++, frameBytesRead++) {
diff --git a/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketReader.java b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java
similarity index 82%
rename from okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketReader.java
rename to okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java
index 6a72c6c77e..bb6f5760d8 100644
--- a/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketReader.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java
@@ -20,9 +20,10 @@
 import java.net.ProtocolException;
 import okhttp3.MediaType;
 import okhttp3.ResponseBody;
-import okhttp3.ws.WebSocket;
+import okhttp3.WebSocket;
 import okio.Buffer;
 import okio.BufferedSource;
+import okio.ByteString;
 import okio.Okio;
 import okio.Source;
 import okio.Timeout;
@@ -35,6 +36,7 @@
 import static okhttp3.internal.ws.WebSocketProtocol.B0_MASK_OPCODE;
 import static okhttp3.internal.ws.WebSocketProtocol.B1_FLAG_MASK;
 import static okhttp3.internal.ws.WebSocketProtocol.B1_MASK_LENGTH;
+import static okhttp3.internal.ws.WebSocketProtocol.CLOSE_NO_STATUS_CODE;
 import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_BINARY;
 import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTINUATION;
 import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTROL_CLOSE;
@@ -50,39 +52,38 @@
 
 /**
  * An <a href="http://tools.ietf.org/html/rfc6455">RFC 6455</a>-compatible WebSocket frame reader.
+ * <p>
+ * This class is not thread safe.
  */
-public final class WebSocketReader {
+final class WebSocketReader {
   public interface FrameCallback {
-    void onMessage(ResponseBody body) throws IOException;
-
-    void onPing(Buffer buffer);
-
-    void onPong(Buffer buffer);
-
-    void onClose(int code, String reason);
+    void onReadMessage(ResponseBody body) throws IOException;
+    void onReadPing(ByteString buffer);
+    void onReadPong(ByteString buffer);
+    void onReadClose(int code, String reason);
   }
 
-  private final boolean isClient;
-  private final BufferedSource source;
-  private final FrameCallback frameCallback;
+  final boolean isClient;
+  final BufferedSource source;
+  final FrameCallback frameCallback;
 
-  private final Source framedMessageSource = new FramedMessageSource();
+  final Source framedMessageSource = new FramedMessageSource();
 
-  private boolean closed;
-  private boolean messageClosed;
+  boolean closed;
+  boolean messageClosed;
 
   // Stateful data about the current frame.
-  private int opcode;
-  private long frameLength;
-  private long frameBytesRead;
-  private boolean isFinalFrame;
-  private boolean isControlFrame;
-  private boolean isMasked;
+  int opcode;
+  long frameLength;
+  long frameBytesRead;
+  boolean isFinalFrame;
+  boolean isControlFrame;
+  boolean isMasked;
 
-  private final byte[] maskKey = new byte[4];
-  private final byte[] maskBuffer = new byte[2048];
+  final byte[] maskKey = new byte[4];
+  final byte[] maskBuffer = new byte[8192];
 
-  public WebSocketReader(boolean isClient, BufferedSource source, FrameCallback frameCallback) {
+  WebSocketReader(boolean isClient, BufferedSource source, FrameCallback frameCallback) {
     if (source == null) throw new NullPointerException("source == null");
     if (frameCallback == null) throw new NullPointerException("frameCallback == null");
     this.isClient = isClient;
@@ -96,11 +97,11 @@ public WebSocketReader(boolean isClient, BufferedSource source, FrameCallback fr
    * <ul>
    *     <li>If it is a control frame this will result in a single call to {@link FrameCallback}.
    *     <li>If it is a message frame this will result in a single call to {@link
-   *         FrameCallback#onMessage}. If the message spans multiple frames, each interleaved
+   *         FrameCallback#onReadMessage}. If the message spans multiple frames, each interleaved
    *         control frame will result in a corresponding call to {@link FrameCallback}.
    * </ul>
    */
-  public void processNextFrame() throws IOException {
+  void processNextFrame() throws IOException {
     readHeader();
     if (isControlFrame) {
       readControlFrame();
@@ -136,7 +137,9 @@ private void readHeader() throws IOException {
     isMasked = (b1 & B1_FLAG_MASK) != 0;
     if (isMasked == isClient) {
       // Masked payloads must be read on the server. Unmasked payloads must be read on the client.
-      throw new ProtocolException("Client-sent frames must be masked. Server sent must not.");
+      throw new ProtocolException(isClient
+          ? "Server-sent frames must not be masked."
+          : "Client-sent frames must be masked.");
     }
 
     // Get frame length, optionally reading from follow-up bytes if indicated by special values.
@@ -163,10 +166,8 @@ private void readHeader() throws IOException {
   }
 
   private void readControlFrame() throws IOException {
-    Buffer buffer = null;
+    Buffer buffer = new Buffer();
     if (frameBytesRead < frameLength) {
-      buffer = new Buffer();
-
       if (isClient) {
         source.readFully(buffer, frameLength);
       } else {
@@ -183,26 +184,23 @@ private void readControlFrame() throws IOException {
 
     switch (opcode) {
       case OPCODE_CONTROL_PING:
-        frameCallback.onPing(buffer);
+        frameCallback.onReadPing(buffer.readByteString());
         break;
       case OPCODE_CONTROL_PONG:
-        frameCallback.onPong(buffer);
+        frameCallback.onReadPong(buffer.readByteString());
         break;
       case OPCODE_CONTROL_CLOSE:
-        int code = 1000;
+        int code = CLOSE_NO_STATUS_CODE;
         String reason = "";
-        if (buffer != null) {
-          long bufferSize = buffer.size();
-          if (bufferSize == 1) {
-            throw new ProtocolException("Malformed close payload length of 1.");
-          } else if (bufferSize != 0) {
-            code = buffer.readShort();
-            validateCloseCode(code, false);
-
-            reason = buffer.readUtf8();
-          }
+        long bufferSize = buffer.size();
+        if (bufferSize == 1) {
+          throw new ProtocolException("Malformed close payload length of 1.");
+        } else if (bufferSize != 0) {
+          code = buffer.readShort();
+          reason = buffer.readUtf8();
+          validateCloseCode(code, false);
         }
-        frameCallback.onClose(code, reason);
+        frameCallback.onReadClose(code, reason);
         closed = true;
         break;
       default:
@@ -239,14 +237,14 @@ private void readMessageFrame() throws IOException {
     };
 
     messageClosed = false;
-    frameCallback.onMessage(body);
+    frameCallback.onReadMessage(body);
     if (!messageClosed) {
       throw new IllegalStateException("Listener failed to call close on message payload.");
     }
   }
 
   /** Read headers and process any control frames until we reach a non-control frame. */
-  private void readUntilNonControlFrame() throws IOException {
+  void readUntilNonControlFrame() throws IOException {
     while (!closed) {
       readHeader();
       if (!isControlFrame) {
@@ -261,7 +259,7 @@ private void readUntilNonControlFrame() throws IOException {
    * frames that occur between fragments will be processed. If the message payload is masked this
    * will unmask as it's being processed.
    */
-  private final class FramedMessageSource implements Source {
+  final class FramedMessageSource implements Source {
     @Override public long read(Buffer sink, long byteCount) throws IOException {
       if (closed) throw new IOException("closed");
       if (messageClosed) throw new IllegalStateException("closed");
diff --git a/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketWriter.java b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
similarity index 71%
rename from okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
rename to okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
index 5d86be4019..e232857eed 100644
--- a/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
@@ -19,7 +19,7 @@
 import java.util.Random;
 import okio.Buffer;
 import okio.BufferedSink;
-import okio.BufferedSource;
+import okio.ByteString;
 import okio.Sink;
 import okio.Timeout;
 
@@ -44,24 +44,24 @@
  * may call {@link #writePing}, {@link #writePong}, or {@link #writeClose} which will interleave on
  * the wire with frames from the "main" sending thread.
  */
-public final class WebSocketWriter {
-  private final boolean isClient;
-  private final Random random;
+final class WebSocketWriter {
+  final boolean isClient;
+  final Random random;
 
   /** Writes must be guarded by synchronizing on 'this'. */
-  private final BufferedSink sink;
+  final BufferedSink sink;
   /** Access must be guarded by synchronizing on 'this'. */
-  private boolean writerClosed;
+  boolean writerClosed;
 
-  private final Buffer buffer = new Buffer();
-  private final FrameSink frameSink = new FrameSink();
+  final Buffer buffer = new Buffer();
+  final FrameSink frameSink = new FrameSink();
 
-  private boolean activeWriter;
+  boolean activeWriter;
 
-  private final byte[] maskKey;
-  private final byte[] maskBuffer;
+  final byte[] maskKey;
+  final byte[] maskBuffer;
 
-  public WebSocketWriter(boolean isClient, BufferedSink sink, Random random) {
+  WebSocketWriter(boolean isClient, BufferedSink sink, Random random) {
     if (sink == null) throw new NullPointerException("sink == null");
     if (random == null) throw new NullPointerException("random == null");
     this.isClient = isClient;
@@ -70,18 +70,18 @@ public WebSocketWriter(boolean isClient, BufferedSink sink, Random random) {
 
     // Masks are only a concern for client writers.
     maskKey = isClient ? new byte[4] : null;
-    maskBuffer = isClient ? new byte[2048] : null;
+    maskBuffer = isClient ? new byte[8192] : null;
   }
 
-  /** Send a ping with the supplied {@code payload}. Payload may be {@code null} */
-  public void writePing(Buffer payload) throws IOException {
+  /** Send a ping with the supplied {@code payload}. */
+  void writePing(ByteString payload) throws IOException {
     synchronized (this) {
       writeControlFrameSynchronized(OPCODE_CONTROL_PING, payload);
     }
   }
 
-  /** Send a pong with the supplied {@code payload}. Payload may be {@code null} */
-  public void writePong(Buffer payload) throws IOException {
+  /** Send a pong with the supplied {@code payload}. */
+  void writePong(ByteString payload) throws IOException {
     synchronized (this) {
       writeControlFrameSynchronized(OPCODE_CONTROL_PONG, payload);
     }
@@ -94,37 +94,38 @@ public void writePong(Buffer payload) throws IOException {
    * href="http://tools.ietf.org/html/rfc6455#section-7.4">Section 7.4 of RFC 6455</a> or {@code 0}.
    * @param reason Reason for shutting down or {@code null}.
    */
-  public void writeClose(int code, String reason) throws IOException {
-    Buffer payload = null;
+  void writeClose(int code, String reason) throws IOException {
+    ByteString payload = ByteString.EMPTY;
     if (code != 0 || reason != null) {
       if (code != 0) {
         validateCloseCode(code, true);
       }
-      payload = new Buffer();
-      payload.writeShort(code);
+      Buffer buffer = new Buffer();
+      buffer.writeShort(code);
       if (reason != null) {
-        payload.writeUtf8(reason);
+        buffer.writeUtf8(reason);
       }
+      payload = buffer.readByteString();
     }
 
     synchronized (this) {
-      writeControlFrameSynchronized(OPCODE_CONTROL_CLOSE, payload);
-      writerClosed = true;
+      try {
+        writeControlFrameSynchronized(OPCODE_CONTROL_CLOSE, payload);
+      } finally {
+        writerClosed = true;
+      }
     }
   }
 
-  private void writeControlFrameSynchronized(int opcode, Buffer payload) throws IOException {
+  private void writeControlFrameSynchronized(int opcode, ByteString payload) throws IOException {
     assert Thread.holdsLock(this);
 
     if (writerClosed) throw new IOException("closed");
 
-    int length = 0;
-    if (payload != null) {
-      length = (int) payload.size();
-      if (length > PAYLOAD_BYTE_MAX) {
-        throw new IllegalArgumentException(
-            "Payload size must be less than or equal to " + PAYLOAD_BYTE_MAX);
-      }
+    int length = payload.size();
+    if (length > PAYLOAD_BYTE_MAX) {
+      throw new IllegalArgumentException(
+          "Payload size must be less than or equal to " + PAYLOAD_BYTE_MAX);
     }
 
     int b0 = B0_FLAG_FIN | opcode;
@@ -138,25 +139,22 @@ private void writeControlFrameSynchronized(int opcode, Buffer payload) throws IO
       random.nextBytes(maskKey);
       sink.write(maskKey);
 
-      if (payload != null) {
-        writeMaskedSynchronized(payload, length);
-      }
+      byte[] bytes = payload.toByteArray();
+      toggleMask(bytes, bytes.length, maskKey, 0);
+      sink.write(bytes);
     } else {
       sink.writeByte(b1);
-
-      if (payload != null) {
-        sink.writeAll(payload);
-      }
+      sink.write(payload);
     }
 
-    sink.emit();
+    sink.flush();
   }
 
   /**
    * Stream a message payload as a series of frames. This allows control frames to be interleaved
    * between parts of the message.
    */
-  public Sink newMessageSink(int formatOpcode, long contentLength) {
+  Sink newMessageSink(int formatOpcode, long contentLength) {
     if (activeWriter) {
       throw new IllegalStateException("Another message writer is active. Did you call close()?");
     }
@@ -171,7 +169,7 @@ public Sink newMessageSink(int formatOpcode, long contentLength) {
     return frameSink;
   }
 
-  private void writeMessageFrameSynchronized(int formatOpcode, long byteCount, boolean isFirstFrame,
+  void writeMessageFrameSynchronized(int formatOpcode, long byteCount, boolean isFirstFrame,
       boolean isFinal) throws IOException {
     assert Thread.holdsLock(this);
 
@@ -186,7 +184,6 @@ private void writeMessageFrameSynchronized(int formatOpcode, long byteCount, boo
     int b1 = 0;
     if (isClient) {
       b1 |= B1_FLAG_MASK;
-      random.nextBytes(maskKey);
     }
     if (byteCount <= PAYLOAD_BYTE_MAX) {
       b1 |= (int) byteCount;
@@ -202,8 +199,17 @@ private void writeMessageFrameSynchronized(int formatOpcode, long byteCount, boo
     }
 
     if (isClient) {
+      random.nextBytes(maskKey);
       sink.write(maskKey);
-      writeMaskedSynchronized(buffer, byteCount);
+
+      for (long written = 0; written < byteCount; ) {
+        int toRead = (int) Math.min(byteCount, maskBuffer.length);
+        int read = buffer.read(maskBuffer, 0, toRead);
+        if (read == -1) throw new AssertionError();
+        toggleMask(maskBuffer, read, maskKey, written);
+        sink.write(maskBuffer, 0, read);
+        written += read;
+      }
     } else {
       sink.write(buffer, byteCount);
     }
@@ -211,25 +217,11 @@ private void writeMessageFrameSynchronized(int formatOpcode, long byteCount, boo
     sink.emit();
   }
 
-  private void writeMaskedSynchronized(BufferedSource source, long byteCount) throws IOException {
-    assert Thread.holdsLock(this);
-
-    long written = 0;
-    while (written < byteCount) {
-      int toRead = (int) Math.min(byteCount, maskBuffer.length);
-      int read = source.read(maskBuffer, 0, toRead);
-      if (read == -1) throw new AssertionError();
-      toggleMask(maskBuffer, read, maskKey, written);
-      sink.write(maskBuffer, 0, read);
-      written += read;
-    }
-  }
-
-  private final class FrameSink implements Sink {
-    private int formatOpcode;
-    private long contentLength;
-    private boolean isFirstFrame;
-    private boolean closed;
+  final class FrameSink implements Sink {
+    int formatOpcode;
+    long contentLength;
+    boolean isFirstFrame;
+    boolean closed;
 
     @Override public void write(Buffer source, long byteCount) throws IOException {
       if (closed) throw new IOException("closed");
@@ -239,7 +231,7 @@ private void writeMaskedSynchronized(BufferedSource source, long byteCount) thro
       // Determine if this is a buffered write which we can defer until close() flushes.
       boolean deferWrite = isFirstFrame
           && contentLength != -1
-          && buffer.size() > contentLength - 2048 /* segment size */;
+          && buffer.size() > contentLength - 8192 /* segment size */;
 
       long emitCount = buffer.completeSegmentByteCount();
       if (emitCount > 0 && !deferWrite) {
diff --git a/pom.xml b/pom.xml
index 52c283ed13..aff4da184f 100644
--- a/pom.xml
+++ b/pom.xml
@@ -11,11 +11,11 @@
 
   <groupId>com.squareup.okhttp3</groupId>
   <artifactId>parent</artifactId>
-  <version>3.3.0-SNAPSHOT</version>
+  <version>3.5.0-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>OkHttp (Parent)</name>
-  <description>An HTTP+SPDY client for Android and Java applications</description>
+  <description>An HTTP+HTTP/2 client for Android and Java applications</description>
   <url>https://github.com/square/okhttp</url>
 
   <modules>
@@ -28,9 +28,6 @@
     <module>okhttp-testing-support</module>
     <module>okhttp-urlconnection</module>
 
-    <module>okhttp-ws</module>
-    <module>okhttp-ws-tests</module>
-
     <module>okhttp-logging-interceptor</module>
 
     <module>okcurl</module>
@@ -43,21 +40,23 @@
     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
 
     <!-- Compilation -->
-    <java.version>1.7</java.version>
-    <okio.version>1.6.0</okio.version>
+    <airlift.version>0.7</airlift.version>
     <!-- ALPN library targeted to Java 7 -->
     <alpn.jdk7.version>7.1.2.v20141202</alpn.jdk7.version>
-    <!-- ALPN library targeted to Java 8 update 25. -->
-    <alpn.jdk8.version>8.1.2.v20141202</alpn.jdk8.version>
-    <bouncycastle.version>1.50</bouncycastle.version>
-    <gson.version>2.2.3</gson.version>
+    <android.version>4.1.1.4</android.version>
+    <animal.sniffer.version>1.11</animal.sniffer.version>
     <apache.http.version>4.2.2</apache.http.version>
-    <airlift.version>0.7</airlift.version>
+    <bouncycastle.version>1.50</bouncycastle.version>
     <guava.version>16.0</guava.version>
-    <android.version>4.1.1.4</android.version>
+    <java.version>1.7</java.version>
+    <moshi.version>1.1.0</moshi.version>
+    <okio.version>1.10.0</okio.version>
 
     <!-- Test Dependencies -->
-    <junit.version>4.11</junit.version>
+    <junit.version>4.12</junit.version>
+
+    <!-- platform test mode -->
+    <okhttp.platform>platform</okhttp.platform>
   </properties>
 
   <scm>
@@ -96,11 +95,6 @@
         <artifactId>bcprov-jdk15on</artifactId>
         <version>${bouncycastle.version}</version>
       </dependency>
-      <dependency>
-        <groupId>com.google.code.gson</groupId>
-        <artifactId>gson</artifactId>
-        <version>${gson.version}</version>
-      </dependency>
       <dependency>
         <groupId>org.apache.httpcomponents</groupId>
         <artifactId>httpclient</artifactId>
@@ -121,6 +115,11 @@
         <artifactId>android</artifactId>
         <version>${android.version}</version>
       </dependency>
+      <dependency>
+        <groupId>com.squareup.moshi</groupId>
+        <artifactId>moshi</artifactId>
+        <version>${moshi.version}</version>
+      </dependency>
     </dependencies>
   </dependencyManagement>
 
@@ -142,6 +141,9 @@
           <artifactId>maven-surefire-plugin</artifactId>
           <version>2.17</version>
           <configuration>
+            <systemPropertyVariables>
+              <okhttp.platform>${okhttp.platform}</okhttp.platform>
+            </systemPropertyVariables>
             <properties>
               <!--
                 Configure a listener for enforcing that no uncaught exceptions issue from OkHttp
@@ -210,7 +212,7 @@
       <plugin>
         <groupId>org.codehaus.mojo</groupId>
         <artifactId>animal-sniffer-maven-plugin</artifactId>
-        <version>1.11</version>
+        <version>${animal.sniffer.version}</version>
         <executions>
           <execution>
             <phase>test</phase>
@@ -240,6 +242,7 @@
         <bootclasspathPrefix>
           ${settings.localRepository}/org/mortbay/jetty/alpn/alpn-boot/${alpn.jdk7.version}/alpn-boot-${alpn.jdk7.version}.jar
         </bootclasspathPrefix>
+        <okhttp.platform>jdk-with-jetty-boot</okhttp.platform>
       </properties>
       <build>
         <pluginManagement>
@@ -248,7 +251,7 @@
               <groupId>org.apache.maven.plugins</groupId>
               <artifactId>maven-surefire-plugin</artifactId>
               <configuration>
-                <argLine>-Xbootclasspath/p:${bootclasspathPrefix}</argLine>
+                <argLine>-Xbootclasspath/p:${bootclasspathPrefix} -Xms512m -Xmx512m</argLine>
               </configuration>
               <dependencies>
                 <dependency>
@@ -271,6 +274,7 @@
         <bootclasspathPrefix>
           ${settings.localRepository}/org/mortbay/jetty/alpn/alpn-boot/${alpn.jdk8.version}/alpn-boot-${alpn.jdk8.version}.jar
         </bootclasspathPrefix>
+        <okhttp.platform>jdk-with-jetty-boot</okhttp.platform>
       </properties>
       <build>
         <pluginManagement>
@@ -279,7 +283,7 @@
               <groupId>org.apache.maven.plugins</groupId>
               <artifactId>maven-surefire-plugin</artifactId>
               <configuration>
-                <argLine>-Xbootclasspath/p:${bootclasspathPrefix}</argLine>
+                <argLine>-Xbootclasspath/p:${bootclasspathPrefix} -Xms512m -Xmx512m</argLine>
               </configuration>
               <dependencies>
                 <dependency>
@@ -293,6 +297,198 @@
         </pluginManagement>
       </build>
     </profile>
+    <profile>
+      <id>jdk9</id>
+      <activation>
+        <jdk>9</jdk>
+      </activation>
+      <properties>
+        <okhttp.platform>jdk9</okhttp.platform>
+      </properties>
+    </profile>
+    <!-- ALPN Versions targeted for each Java 8 minor release -->
+    <!-- Check versions with this page: -->
+    <!-- http://www.eclipse.org/jetty/documentation/current/alpn-chapter.html#alpn-chapterchapterversions -->
+        <profile>
+      <id>alpn-when-jdk8_05</id>
+      <activation>
+        <jdk>1.8.0_05</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.0.v20141016</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_11</id>
+      <activation>
+        <jdk>1.8.0_11</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.0.v20141016</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_20</id>
+      <activation>
+        <jdk>1.8.0_20</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.0.v20141016</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_25</id>
+      <activation>
+        <jdk>1.8.0_25</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.2.v20141202</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_31</id>
+      <activation>
+        <jdk>1.8.0_31</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.3.v20150130</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_40</id>
+      <activation>
+        <jdk>1.8.0_40</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.3.v20150130</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_45</id>
+      <activation>
+        <jdk>1.8.0_45</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.3.v20150130</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_51</id>
+      <activation>
+        <jdk>1.8.0_51</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.4.v20150727</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_60</id>
+      <activation>
+        <jdk>1.8.0_60</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.5.v20150921</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_65</id>
+      <activation>
+        <jdk>1.8.0_65</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.6.v20151105</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_66</id>
+      <activation>
+        <jdk>1.8.0_66</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.6.v20151105</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_71</id>
+      <activation>
+        <jdk>1.8.0_71</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.7.v20160121</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_72</id>
+      <activation>
+        <jdk>1.8.0_72</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.7.v20160121</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_73</id>
+      <activation>
+        <jdk>1.8.0_73</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.7.v20160121</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_74</id>
+      <activation>
+        <jdk>1.8.0_74</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.7.v20160121</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_77</id>
+      <activation>
+        <jdk>1.8.0_77</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.7.v20160121</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_91</id>
+      <activation>
+        <jdk>1.8.0_91</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.7.v20160121</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_92</id>
+      <activation>
+        <jdk>1.8.0_92</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.8.v20160420</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_101</id>
+      <activation>
+        <jdk>1.8.0_101</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.8.v20160420</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_102</id>
+      <activation>
+        <jdk>1.8.0_102</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.9.v20160720</alpn.jdk8.version>
+      </properties>
+    </profile>
   </profiles>
 </project>
 
diff --git a/samples/crawler/pom.xml b/samples/crawler/pom.xml
index 0daef2b940..8b91ca2dd7 100644
--- a/samples/crawler/pom.xml
+++ b/samples/crawler/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.3.0-SNAPSHOT</version>
+    <version>3.5.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>crawler</artifactId>
diff --git a/samples/crawler/src/main/java/okhttp3/sample/Crawler.java b/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
index 7fad2ee5e1..c0964fdf8a 100644
--- a/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
+++ b/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
@@ -27,6 +27,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import okhttp3.Cache;
 import okhttp3.HttpUrl;
+import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.Response;
@@ -103,6 +104,12 @@ public void fetch(HttpUrl url) throws IOException {
       return;
     }
 
+    MediaType mediaType = MediaType.parse(contentType);
+    if (mediaType == null || !mediaType.subtype().equalsIgnoreCase("html")) {
+      response.body().close();
+      return;
+    }
+
     Document document = Jsoup.parse(response.body().string(), url.toString());
     for (Element element : document.select("a[href]")) {
       String href = element.attr("href");
diff --git a/samples/guide/pom.xml b/samples/guide/pom.xml
index cb497502f2..2d0c791c38 100644
--- a/samples/guide/pom.xml
+++ b/samples/guide/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.3.0-SNAPSHOT</version>
+    <version>3.5.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>guide</artifactId>
@@ -19,13 +19,8 @@
       <version>${project.version}</version>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>okhttp-ws</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.google.code.gson</groupId>
-      <artifactId>gson</artifactId>
+      <groupId>com.squareup.moshi</groupId>
+      <artifactId>moshi</artifactId>
     </dependency>
   </dependencies>
 </project>
diff --git a/samples/guide/src/main/java/okhttp3/guide/GetExample.java b/samples/guide/src/main/java/okhttp3/guide/GetExample.java
index 19ef73bf2e..35a1cc658c 100644
--- a/samples/guide/src/main/java/okhttp3/guide/GetExample.java
+++ b/samples/guide/src/main/java/okhttp3/guide/GetExample.java
@@ -13,8 +13,9 @@ String run(String url) throws IOException {
         .url(url)
         .build();
 
-    Response response = client.newCall(request).execute();
-    return response.body().string();
+    try (Response response = client.newCall(request).execute()) {
+      return response.body().string();
+    }
   }
 
   public static void main(String[] args) throws IOException {
diff --git a/samples/guide/src/main/java/okhttp3/guide/PostExample.java b/samples/guide/src/main/java/okhttp3/guide/PostExample.java
index 74ddc56127..b6e70ccc7d 100644
--- a/samples/guide/src/main/java/okhttp3/guide/PostExample.java
+++ b/samples/guide/src/main/java/okhttp3/guide/PostExample.java
@@ -19,8 +19,9 @@ String post(String url, String json) throws IOException {
         .url(url)
         .post(body)
         .build();
-    Response response = client.newCall(request).execute();
-    return response.body().string();
+    try (Response response = client.newCall(request).execute()) {
+      return response.body().string();
+    }
   }
 
   String bowlingJson(String player1, String player2) {
diff --git a/samples/guide/src/main/java/okhttp3/recipes/AccessHeaders.java b/samples/guide/src/main/java/okhttp3/recipes/AccessHeaders.java
index fe4d2f521f..95fa49241c 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/AccessHeaders.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/AccessHeaders.java
@@ -31,12 +31,13 @@ public void run() throws Exception {
         .addHeader("Accept", "application/vnd.github.v3+json")
         .build();
 
-    Response response = client.newCall(request).execute();
-    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
-    System.out.println("Server: " + response.header("Server"));
-    System.out.println("Date: " + response.header("Date"));
-    System.out.println("Vary: " + response.headers("Vary"));
+      System.out.println("Server: " + response.header("Server"));
+      System.out.println("Date: " + response.header("Date"));
+      System.out.println("Vary: " + response.headers("Vary"));
+    }
   }
 
   public static void main(String... args) throws Exception {
diff --git a/samples/guide/src/main/java/okhttp3/recipes/AsynchronousGet.java b/samples/guide/src/main/java/okhttp3/recipes/AsynchronousGet.java
index ad49c3e487..68f1c2d591 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/AsynchronousGet.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/AsynchronousGet.java
@@ -22,6 +22,7 @@
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.Response;
+import okhttp3.ResponseBody;
 
 public final class AsynchronousGet {
   private final OkHttpClient client = new OkHttpClient();
@@ -37,14 +38,16 @@ public void run() throws Exception {
       }
 
       @Override public void onResponse(Call call, Response response) throws IOException {
-        if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+        try (ResponseBody responseBody = response.body()) {
+          if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
-        Headers responseHeaders = response.headers();
-        for (int i = 0, size = responseHeaders.size(); i < size; i++) {
-          System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i));
-        }
+          Headers responseHeaders = response.headers();
+          for (int i = 0, size = responseHeaders.size(); i < size; i++) {
+            System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i));
+          }
 
-        System.out.println(response.body().string());
+          System.out.println(responseBody.string());
+        }
       }
     });
   }
diff --git a/samples/guide/src/main/java/okhttp3/recipes/Authenticate.java b/samples/guide/src/main/java/okhttp3/recipes/Authenticate.java
index 04c8cae2a8..61eb27f2b1 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/Authenticate.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/Authenticate.java
@@ -46,10 +46,11 @@ public void run() throws Exception {
         .url("http://publicobject.com/secrets/hellosecret.txt")
         .build();
 
-    Response response = client.newCall(request).execute();
-    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
-    System.out.println(response.body().string());
+      System.out.println(response.body().string());
+    }
   }
 
   public static void main(String... args) throws Exception {
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CacheResponse.java b/samples/guide/src/main/java/okhttp3/recipes/CacheResponse.java
index 8e82f4ab5f..c43f9214ab 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/CacheResponse.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/CacheResponse.java
@@ -39,21 +39,25 @@ public void run() throws Exception {
         .url("http://publicobject.com/helloworld.txt")
         .build();
 
-    Response response1 = client.newCall(request).execute();
-    if (!response1.isSuccessful()) throw new IOException("Unexpected code " + response1);
+    String response1Body;
+    try (Response response1 = client.newCall(request).execute()) {
+      if (!response1.isSuccessful()) throw new IOException("Unexpected code " + response1);
 
-    String response1Body = response1.body().string();
-    System.out.println("Response 1 response:          " + response1);
-    System.out.println("Response 1 cache response:    " + response1.cacheResponse());
-    System.out.println("Response 1 network response:  " + response1.networkResponse());
+      response1Body = response1.body().string();
+      System.out.println("Response 1 response:          " + response1);
+      System.out.println("Response 1 cache response:    " + response1.cacheResponse());
+      System.out.println("Response 1 network response:  " + response1.networkResponse());
+    }
 
-    Response response2 = client.newCall(request).execute();
-    if (!response2.isSuccessful()) throw new IOException("Unexpected code " + response2);
+    String response2Body;
+    try (Response response2 = client.newCall(request).execute()) {
+      if (!response2.isSuccessful()) throw new IOException("Unexpected code " + response2);
 
-    String response2Body = response2.body().string();
-    System.out.println("Response 2 response:          " + response2);
-    System.out.println("Response 2 cache response:    " + response2.cacheResponse());
-    System.out.println("Response 2 network response:  " + response2.networkResponse());
+      response2Body = response2.body().string();
+      System.out.println("Response 2 response:          " + response2);
+      System.out.println("Response 2 cache response:    " + response2.cacheResponse());
+      System.out.println("Response 2 network response:  " + response2.networkResponse());
+    }
 
     System.out.println("Response 2 equals Response 1? " + response1Body.equals(response2Body));
   }
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CancelCall.java b/samples/guide/src/main/java/okhttp3/recipes/CancelCall.java
index c3551f78be..644f638300 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/CancelCall.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/CancelCall.java
@@ -45,9 +45,8 @@ public void run() throws Exception {
       }
     }, 1, TimeUnit.SECONDS);
 
-    try {
-      System.out.printf("%.2f Executing call.%n", (System.nanoTime() - startNanos) / 1e9f);
-      Response response = call.execute();
+    System.out.printf("%.2f Executing call.%n", (System.nanoTime() - startNanos) / 1e9f);
+    try (Response response = call.execute()) {
       System.out.printf("%.2f Call was expected to fail, but completed: %s%n",
           (System.nanoTime() - startNanos) / 1e9f, response);
     } catch (IOException e) {
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java b/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java
index 0dbf7aaf9a..91c3fcc59f 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java
@@ -30,9 +30,6 @@ public CertificatePinning() {
         .certificatePinner(
             new CertificatePinner.Builder()
                 .add("publicobject.com", "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
-                .add("publicobject.com", "sha256/klO23nT2ehFDXCfx3eHTDRESMz3asj1muO+4aIdjiuY=")
-                .add("publicobject.com", "sha256/grX4Ta9HpZx6tSHkmCrvpApTQGo67CYDnvprLg5yRME=")
-                .add("publicobject.com", "sha256/lCppFqbkrlJ3EcVFAkeip0+44VaoJUymbnOaEUk7tEU=")
                 .build())
         .build();
   }
@@ -42,11 +39,12 @@ public void run() throws Exception {
         .url("https://publicobject.com/robots.txt")
         .build();
 
-    Response response = client.newCall(request).execute();
-    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
-    for (Certificate certificate : response.handshake().peerCertificates()) {
-      System.out.println(CertificatePinner.pin(certificate));
+      for (Certificate certificate : response.handshake().peerCertificates()) {
+        System.out.println(CertificatePinner.pin(certificate));
+      }
     }
   }
 
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CheckHandshake.java b/samples/guide/src/main/java/okhttp3/recipes/CheckHandshake.java
index 0f52fb426d..164e879079 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/CheckHandshake.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/CheckHandshake.java
@@ -50,10 +50,11 @@ public void run() throws Exception {
         .url("https://publicobject.com/helloworld.txt")
         .build();
 
-    Response response = client.newCall(request).execute();
-    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
-    System.out.println(response.body().string());
+      System.out.println(response.body().string());
+    }
   }
 
   public static void main(String... args) throws Exception {
diff --git a/samples/guide/src/main/java/okhttp3/recipes/ConfigureTimeouts.java b/samples/guide/src/main/java/okhttp3/recipes/ConfigureTimeouts.java
index 2f93880260..a6d3000732 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/ConfigureTimeouts.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/ConfigureTimeouts.java
@@ -36,8 +36,9 @@ public void run() throws Exception {
         .url("http://httpbin.org/delay/2") // This URL is served with a 2 second delay.
         .build();
 
-    Response response = client.newCall(request).execute();
-    System.out.println("Response completed: " + response);
+    try (Response response = client.newCall(request).execute()) {
+      System.out.println("Response completed: " + response);
+    }
   }
 
   public static void main(String... args) throws Exception {
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CustomTrust.java b/samples/guide/src/main/java/okhttp3/recipes/CustomTrust.java
index 0ee606cbf0..a8df15ba32 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/CustomTrust.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/CustomTrust.java
@@ -61,15 +61,16 @@ public void run() throws Exception {
         .url("https://publicobject.com/helloworld.txt")
         .build();
 
-    Response response = client.newCall(request).execute();
-    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
-    Headers responseHeaders = response.headers();
-    for (int i = 0; i < responseHeaders.size(); i++) {
-      System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i));
-    }
+      Headers responseHeaders = response.headers();
+      for (int i = 0; i < responseHeaders.size(); i++) {
+        System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i));
+      }
 
-    System.out.println(response.body().string());
+      System.out.println(response.body().string());
+    }
   }
 
   /**
diff --git a/samples/guide/src/main/java/okhttp3/recipes/ParseResponseWithGson.java b/samples/guide/src/main/java/okhttp3/recipes/ParseResponseWithMoshi.java
similarity index 66%
rename from samples/guide/src/main/java/okhttp3/recipes/ParseResponseWithGson.java
rename to samples/guide/src/main/java/okhttp3/recipes/ParseResponseWithMoshi.java
index 7ca4ccb731..68570bf13f 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/ParseResponseWithGson.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/ParseResponseWithMoshi.java
@@ -15,30 +15,32 @@
  */
 package okhttp3.recipes;
 
-import com.google.gson.Gson;
+import com.squareup.moshi.JsonAdapter;
+import com.squareup.moshi.Moshi;
 import java.io.IOException;
 import java.util.Map;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.Response;
 
-public final class ParseResponseWithGson {
+public final class ParseResponseWithMoshi {
   private final OkHttpClient client = new OkHttpClient();
-  private final Gson gson = new Gson();
+  private final Moshi moshi = new Moshi.Builder().build();
+  private final JsonAdapter<Gist> gistJsonAdapter = moshi.adapter(Gist.class);
 
   public void run() throws Exception {
     Request request = new Request.Builder()
         .url("https://api.github.com/gists/c2a7c39532239ff261be")
         .build();
-    Response response = client.newCall(request).execute();
-    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
-    Gist gist = gson.fromJson(response.body().charStream(), Gist.class);
-    response.body().close();
+      Gist gist = gistJsonAdapter.fromJson(response.body().source());
 
-    for (Map.Entry<String, GistFile> entry : gist.files.entrySet()) {
-      System.out.println(entry.getKey());
-      System.out.println(entry.getValue().content);
+      for (Map.Entry<String, GistFile> entry : gist.files.entrySet()) {
+        System.out.println(entry.getKey());
+        System.out.println(entry.getValue().content);
+      }
     }
   }
 
@@ -51,6 +53,6 @@ public void run() throws Exception {
   }
 
   public static void main(String... args) throws Exception {
-    new ParseResponseWithGson().run();
+    new ParseResponseWithMoshi().run();
   }
 }
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PerCallSettings.java b/samples/guide/src/main/java/okhttp3/recipes/PerCallSettings.java
index 9f82d1efae..6aa266c11d 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PerCallSettings.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PerCallSettings.java
@@ -29,25 +29,21 @@ public void run() throws Exception {
         .url("http://httpbin.org/delay/1") // This URL is served with a 1 second delay.
         .build();
 
-    try {
-      // Copy to customize OkHttp for this request.
-      OkHttpClient copy = client.newBuilder()
-          .readTimeout(500, TimeUnit.MILLISECONDS)
-          .build();
-
-      Response response = copy.newCall(request).execute();
+    // Copy to customize OkHttp for this request.
+    OkHttpClient client1 = client.newBuilder()
+        .readTimeout(500, TimeUnit.MILLISECONDS)
+        .build();
+    try (Response response = client1.newCall(request).execute()) {
       System.out.println("Response 1 succeeded: " + response);
     } catch (IOException e) {
       System.out.println("Response 1 failed: " + e);
     }
 
-    try {
-      // Copy to customize OkHttp for this request.
-      OkHttpClient copy = client.newBuilder()
-          .readTimeout(3000, TimeUnit.MILLISECONDS)
-          .build();
-
-      Response response = copy.newCall(request).execute();
+    // Copy to customize OkHttp for this request.
+    OkHttpClient client2 = client.newBuilder()
+        .readTimeout(3000, TimeUnit.MILLISECONDS)
+        .build();
+    try (Response response = client2.newCall(request).execute()) {
       System.out.println("Response 2 succeeded: " + response);
     } catch (IOException e) {
       System.out.println("Response 2 failed: " + e);
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostFile.java b/samples/guide/src/main/java/okhttp3/recipes/PostFile.java
index 4d69844a7a..b216b24b3b 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PostFile.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostFile.java
@@ -37,10 +37,11 @@ public void run() throws Exception {
         .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file))
         .build();
 
-    Response response = client.newCall(request).execute();
-    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
-    System.out.println(response.body().string());
+      System.out.println(response.body().string());
+    }
   }
 
   public static void main(String... args) throws Exception {
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostForm.java b/samples/guide/src/main/java/okhttp3/recipes/PostForm.java
index f2f05def19..eab32b01ab 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PostForm.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostForm.java
@@ -34,10 +34,11 @@ public void run() throws Exception {
         .post(formBody)
         .build();
 
-    Response response = client.newCall(request).execute();
-    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
-    System.out.println(response.body().string());
+      System.out.println(response.body().string());
+    }
   }
 
   public static void main(String... args) throws Exception {
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java b/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java
index ab3708fab5..3e93a00e82 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java
@@ -49,10 +49,11 @@ public void run() throws Exception {
         .post(requestBody)
         .build();
 
-    Response response = client.newCall(request).execute();
-    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
-    System.out.println(response.body().string());
+      System.out.println(response.body().string());
+    }
   }
 
   public static void main(String... args) throws Exception {
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java b/samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java
index 4651240d67..440c7768ea 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java
@@ -57,10 +57,11 @@ private String factor(int n) {
         .post(requestBody)
         .build();
 
-    Response response = client.newCall(request).execute();
-    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
-    System.out.println(response.body().string());
+      System.out.println(response.body().string());
+    }
   }
 
   public static void main(String... args) throws Exception {
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostString.java b/samples/guide/src/main/java/okhttp3/recipes/PostString.java
index f956f97f1f..8a312bde8a 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PostString.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostString.java
@@ -42,10 +42,11 @@ public void run() throws Exception {
         .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody))
         .build();
 
-    Response response = client.newCall(request).execute();
-    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
-    System.out.println(response.body().string());
+      System.out.println(response.body().string());
+    }
   }
 
   public static void main(String... args) throws Exception {
diff --git a/samples/guide/src/main/java/okhttp3/recipes/Progress.java b/samples/guide/src/main/java/okhttp3/recipes/Progress.java
index f499a90cf1..f04de79340 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/Progress.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/Progress.java
@@ -55,10 +55,11 @@ public void run() throws Exception {
         })
         .build();
 
-    Response response = client.newCall(request).execute();
-    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
-    System.out.println(response.body().string());
+      System.out.println(response.body().string());
+    }
   }
 
   public static void main(String... args) throws Exception {
diff --git a/samples/guide/src/main/java/okhttp3/recipes/RequestBodyCompression.java b/samples/guide/src/main/java/okhttp3/recipes/RequestBodyCompression.java
index d1dc18a3b1..b1a62c0fa3 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/RequestBodyCompression.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/RequestBodyCompression.java
@@ -15,7 +15,9 @@
  */
 package okhttp3.recipes;
 
-import com.google.gson.Gson;
+import com.squareup.moshi.JsonAdapter;
+import com.squareup.moshi.Moshi;
+import com.squareup.moshi.Types;
 import java.io.IOException;
 import java.util.LinkedHashMap;
 import java.util.Map;
@@ -42,21 +44,25 @@
   private final OkHttpClient client = new OkHttpClient.Builder()
       .addInterceptor(new GzipRequestInterceptor())
       .build();
+  private final Moshi moshi = new Moshi.Builder().build();
+  private final JsonAdapter<Map<String, String>> mapJsonAdapter = moshi.adapter(
+      Types.newParameterizedType(Map.class, String.class, String.class));
 
   public void run() throws Exception {
     Map<String, String> requestBody = new LinkedHashMap<>();
     requestBody.put("longUrl", "https://publicobject.com/2014/12/04/html-formatting-javadocs/");
     RequestBody jsonRequestBody = RequestBody.create(
-        MEDIA_TYPE_JSON, new Gson().toJson(requestBody));
+        MEDIA_TYPE_JSON, mapJsonAdapter.toJson(requestBody));
     Request request = new Request.Builder()
         .url("https://www.googleapis.com/urlshortener/v1/url?key=" + GOOGLE_API_KEY)
         .post(jsonRequestBody)
         .build();
 
-    Response response = client.newCall(request).execute();
-    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
-    System.out.println(response.body().string());
+      System.out.println(response.body().string());
+    }
   }
 
   public static void main(String... args) throws Exception {
diff --git a/samples/guide/src/main/java/okhttp3/recipes/RewriteResponseCacheControl.java b/samples/guide/src/main/java/okhttp3/recipes/RewriteResponseCacheControl.java
index d034c505c2..92d65d8169 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/RewriteResponseCacheControl.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/RewriteResponseCacheControl.java
@@ -66,12 +66,12 @@ public void run() throws Exception {
         clientForCall = client;
       }
 
-      Response response = clientForCall.newCall(request).execute();
-      response.body().close();
-      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+      try (Response response = clientForCall.newCall(request).execute()) {
+        if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
-      System.out.println("    Network: " + (response.networkResponse() != null));
-      System.out.println();
+        System.out.println("    Network: " + (response.networkResponse() != null));
+        System.out.println();
+      }
     }
   }
 
diff --git a/samples/guide/src/main/java/okhttp3/recipes/SynchronousGet.java b/samples/guide/src/main/java/okhttp3/recipes/SynchronousGet.java
index ab8d48e3d2..38c91a50c2 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/SynchronousGet.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/SynchronousGet.java
@@ -29,15 +29,16 @@ public void run() throws Exception {
         .url("https://publicobject.com/helloworld.txt")
         .build();
 
-    Response response = client.newCall(request).execute();
-    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
-    Headers responseHeaders = response.headers();
-    for (int i = 0; i < responseHeaders.size(); i++) {
-      System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i));
-    }
+      Headers responseHeaders = response.headers();
+      for (int i = 0; i < responseHeaders.size(); i++) {
+        System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i));
+      }
 
-    System.out.println(response.body().string());
+      System.out.println(response.body().string());
+    }
   }
 
   public static void main(String... args) throws Exception {
diff --git a/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java b/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java
index c7ee9438b0..77c873020d 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java
@@ -1,32 +1,33 @@
 package okhttp3.recipes;
 
 import java.io.IOException;
-import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.RequestBody;
 import okhttp3.Response;
 import okhttp3.ResponseBody;
-import okhttp3.ws.WebSocket;
-import okhttp3.ws.WebSocketCall;
-import okhttp3.ws.WebSocketListener;
-import okio.Buffer;
+import okhttp3.WebSocket;
+import okhttp3.WebSocketListener;
 import okio.ByteString;
 
-import static okhttp3.ws.WebSocket.BINARY;
-import static okhttp3.ws.WebSocket.TEXT;
+import static okhttp3.WebSocket.BINARY;
+import static okhttp3.WebSocket.TEXT;
 
 public final class WebSocketEcho implements WebSocketListener {
-  private final Executor writeExecutor = Executors.newSingleThreadExecutor();
+  private final ExecutorService writeExecutor = Executors.newSingleThreadExecutor();
 
-  private void run() throws IOException {
-    OkHttpClient client = new OkHttpClient();
+  private void run() {
+    OkHttpClient client = new OkHttpClient.Builder()
+        .readTimeout(0,  TimeUnit.MILLISECONDS)
+        .build();
 
     Request request = new Request.Builder()
         .url("ws://echo.websocket.org")
         .build();
-    WebSocketCall.create(client, request).enqueue(this);
+    client.newWebSocketCall(request).enqueue(this);
 
     // Trigger shutdown of the dispatcher's executor so this process can exit cleanly.
     client.dispatcher().executorService().shutdown();
@@ -56,19 +57,21 @@ private void run() throws IOException {
     message.close();
   }
 
-  @Override public void onPong(Buffer payload) {
-    System.out.println("PONG: " + payload.readUtf8());
+  @Override public void onPong(ByteString payload) {
+    System.out.println("PONG: " + payload.utf8());
   }
 
   @Override public void onClose(int code, String reason) {
     System.out.println("CLOSE: " + code + " " + reason);
+    writeExecutor.shutdown();
   }
 
-  @Override public void onFailure(IOException e, Response response) {
-    e.printStackTrace();
+  @Override public void onFailure(Throwable t, Response response) {
+    t.printStackTrace();
+    writeExecutor.shutdown();
   }
 
-  public static void main(String... args) throws IOException {
+  public static void main(String... args) {
     new WebSocketEcho().run();
   }
 }
diff --git a/samples/pom.xml b/samples/pom.xml
index 4c484cbf13..c1c21d63c8 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.3.0-SNAPSHOT</version>
+    <version>3.5.0-SNAPSHOT</version>
   </parent>
 
   <groupId>com.squareup.okhttp3.sample</groupId>
@@ -20,4 +20,19 @@
     <module>simple-client</module>
     <module>static-server</module>
   </modules>
+
+  <build>
+    <plugins>
+      <plugin>
+        <!-- Fails on Throwable.addSuppressed() in ARM blocks. -->
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>animal-sniffer-maven-plugin</artifactId>
+        <executions>
+          <execution>
+            <phase>none</phase>
+          </execution>
+        </executions>
+      </plugin>
+    </plugins>
+  </build>
 </project>
diff --git a/samples/simple-client/pom.xml b/samples/simple-client/pom.xml
index 1e40e2ea19..c3330e4025 100644
--- a/samples/simple-client/pom.xml
+++ b/samples/simple-client/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.3.0-SNAPSHOT</version>
+    <version>3.5.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>simple-client</artifactId>
@@ -20,8 +20,8 @@
     </dependency>
 
     <dependency>
-      <groupId>com.google.code.gson</groupId>
-      <artifactId>gson</artifactId>
+      <groupId>com.squareup.moshi</groupId>
+      <artifactId>moshi</artifactId>
     </dependency>
   </dependencies>
 </project>
diff --git a/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java b/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java
index bbd5755dec..ec9019110b 100644
--- a/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java
+++ b/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java
@@ -1,8 +1,8 @@
 package okhttp3.sample;
 
-import com.google.gson.Gson;
-import com.google.gson.reflect.TypeToken;
-import java.io.Reader;
+import com.squareup.moshi.JsonAdapter;
+import com.squareup.moshi.Moshi;
+import com.squareup.moshi.Types;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
@@ -13,10 +13,9 @@
 
 public class OkHttpContributors {
   private static final String ENDPOINT = "https://api.github.com/repos/square/okhttp/contributors";
-  private static final Gson GSON = new Gson();
-  private static final TypeToken<List<Contributor>> CONTRIBUTORS =
-      new TypeToken<List<Contributor>>() {
-      };
+  private static final Moshi MOSHI = new Moshi.Builder().build();
+  private static final JsonAdapter<List<Contributor>> CONTRIBUTORS_JSON_ADAPTER = MOSHI.adapter(
+      Types.newParameterizedType(List.class, Contributor.class));
 
   static class Contributor {
     String login;
@@ -36,8 +35,7 @@ public static void main(String... args) throws Exception {
 
     // Deserialize HTTP response to concrete type.
     ResponseBody body = response.body();
-    Reader charStream = body.charStream();
-    List<Contributor> contributors = GSON.fromJson(charStream, CONTRIBUTORS.getType());
+    List<Contributor> contributors = CONTRIBUTORS_JSON_ADAPTER.fromJson(body.source());
     body.close();
 
     // Sort list by the most contributions.
diff --git a/samples/static-server/pom.xml b/samples/static-server/pom.xml
index f9e5101f9c..ca52ac4b8a 100644
--- a/samples/static-server/pom.xml
+++ b/samples/static-server/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.3.0-SNAPSHOT</version>
+    <version>3.5.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>static-server</artifactId>
