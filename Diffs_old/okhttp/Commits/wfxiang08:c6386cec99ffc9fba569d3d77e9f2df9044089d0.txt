diff --git a/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/RealWebSocketTest.java b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/RealWebSocketTest.java
index 241376d073..0ca96656f7 100644
--- a/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/RealWebSocketTest.java
+++ b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/RealWebSocketTest.java
@@ -15,6 +15,8 @@
  */
 package com.squareup.okhttp.internal.ws;
 
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.ws.WebSocketRecorder;
 import java.io.IOException;
 import java.net.ProtocolException;
@@ -30,8 +32,8 @@
 import org.junit.Before;
 import org.junit.Test;
 
-import static com.squareup.okhttp.ws.WebSocket.PayloadType.BINARY;
-import static com.squareup.okhttp.ws.WebSocket.PayloadType.TEXT;
+import static com.squareup.okhttp.ws.WebSocket.BINARY;
+import static com.squareup.okhttp.ws.WebSocket.TEXT;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -79,33 +81,80 @@
     serverListener.assertExhausted();
   }
 
+  @Test public void nullMessageThrows() throws IOException {
+    try {
+      client.sendMessage(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertEquals("message == null", e.getMessage());
+    }
+  }
+
   @Test public void textMessage() throws IOException {
-    client.sendMessage(TEXT, new Buffer().writeUtf8("Hello!"));
+    client.sendMessage(RequestBody.create(TEXT, "Hello!"));
     server.readMessage();
     serverListener.assertTextMessage("Hello!");
   }
 
   @Test public void binaryMessage() throws IOException {
-    client.sendMessage(BINARY, new Buffer().writeUtf8("Hello!"));
+    client.sendMessage(RequestBody.create(BINARY, "Hello!"));
     server.readMessage();
     serverListener.assertBinaryMessage(new byte[] { 'H', 'e', 'l', 'l', 'o', '!' });
   }
 
+  @Test public void missingContentTypeThrows() throws IOException {
+    try {
+      client.sendMessage(RequestBody.create(null, "Hey!"));
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("Message content type was null. Must use WebSocket.TEXT or WebSocket.BINARY.",
+          e.getMessage());
+    }
+  }
+
+  @Test public void unknownContentTypeThrows() throws IOException {
+    try {
+      client.sendMessage(RequestBody.create(MediaType.parse("text/plain"), "Hey!"));
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals(
+          "Unknown message content type: text/plain. Must use WebSocket.TEXT or WebSocket.BINARY.",
+          e.getMessage());
+    }
+  }
+
   @Test public void streamingMessage() throws IOException {
-    BufferedSink sink = client.newMessageSink(TEXT);
-    sink.writeUtf8("Hel").flush();
-    sink.writeUtf8("lo!").flush();
-    sink.close();
+    RequestBody message = new RequestBody() {
+      @Override public MediaType contentType() {
+        return TEXT;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.writeUtf8("Hel").flush();
+        sink.writeUtf8("lo!").flush();
+        sink.close();
+      }
+    };
+    client.sendMessage(message);
     server.readMessage();
     serverListener.assertTextMessage("Hello!");
   }
 
   @Test public void streamingMessageCanInterleavePing() throws IOException, InterruptedException {
-    BufferedSink sink = client.newMessageSink(TEXT);
-    sink.writeUtf8("Hel").flush();
-    client.sendPing(new Buffer().writeUtf8("Pong?"));
-    sink.writeUtf8("lo!").flush();
-    sink.close();
+    RequestBody message = new RequestBody() {
+      @Override public MediaType contentType() {
+        return TEXT;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.writeUtf8("Hel").flush();
+        client.sendPing(new Buffer().writeUtf8("Pong?"));
+        sink.writeUtf8("lo!").flush();
+        sink.close();
+      }
+    };
+
+    client.sendMessage(message);
     server.readMessage();
     serverListener.assertTextMessage("Hello!");
     waitForExecutor(serverExecutor); // Pong write happens asynchronously.
@@ -151,13 +200,7 @@
       assertEquals("closed", e.getMessage());
     }
     try {
-      client.sendMessage(TEXT, new Buffer().writeUtf8("Hello!"));
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("closed", e.getMessage());
-    }
-    try {
-      client.newMessageSink(TEXT);
+      client.sendMessage(RequestBody.create(TEXT, "Hello!"));
       fail();
     } catch (IllegalStateException e) {
       assertEquals("closed", e.getMessage());
@@ -176,7 +219,7 @@
       assertEquals("closed", e.getMessage());
     }
     try {
-      client.sendMessage(TEXT, new Buffer().writeUtf8("Hi!"));
+      client.sendMessage(RequestBody.create(TEXT, "Hi!"));
       fail();
     } catch (IOException e) {
       assertEquals("closed", e.getMessage());
@@ -190,33 +233,41 @@
   }
 
   @Test public void serverCloseWhileWritingThrows() throws IOException {
-    // Start writing data.
-    BufferedSink sink = client.newMessageSink(TEXT);
-    sink.writeUtf8("Hel").flush();
+    RequestBody message = new RequestBody() {
+      @Override public MediaType contentType() {
+        return TEXT;
+      }
 
-    server.close(1000, "Hello!");
-    client.readMessage();
-    clientListener.assertClose(1000, "Hello!");
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        // Start writing data.
+        sink.writeUtf8("Hel").flush();
 
-    try {
-      sink.writeUtf8("lo!").emit(); // No writing to the underlying sink.
-      fail();
-    } catch (IOException e) {
-      assertEquals("closed", e.getMessage());
-      sink.buffer().clear();
-    }
-    try {
-      sink.flush(); // No flushing.
-      fail();
-    } catch (IOException e) {
-      assertEquals("closed", e.getMessage());
-    }
-    try {
-      sink.close(); // No closing because this requires writing a frame.
-      fail();
-    } catch (IOException e) {
-      assertEquals("closed", e.getMessage());
-    }
+        server.close(1000, "Hello!");
+        client.readMessage();
+        clientListener.assertClose(1000, "Hello!");
+
+        try {
+          sink.writeUtf8("lo!").emit(); // No writing to the underlying sink.
+          fail();
+        } catch (IOException e) {
+          assertEquals("closed", e.getMessage());
+          sink.buffer().clear();
+        }
+        try {
+          sink.flush(); // No flushing.
+          fail();
+        } catch (IOException e) {
+          assertEquals("closed", e.getMessage());
+        }
+        try {
+          sink.close(); // No closing because this requires writing a frame.
+          fail();
+        } catch (IOException e) {
+          assertEquals("closed", e.getMessage());
+        }
+      }
+    };
+    client.sendMessage(message);
   }
 
   @Test public void clientCloseClosesConnection() throws IOException {
@@ -261,7 +312,7 @@
   }
 
   @Test public void serverCloseBreaksReadMessageLoop() throws IOException {
-    server.sendMessage(TEXT, new Buffer().writeUtf8("Hello!"));
+    server.sendMessage(RequestBody.create(TEXT, "Hello!"));
     server.close(1000, "Bye!");
     assertTrue(client.readMessage());
     clientListener.assertTextMessage("Hello!");
diff --git a/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketReaderTest.java b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketReaderTest.java
index 1674511a43..c8252e7146 100644
--- a/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketReaderTest.java
+++ b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketReaderTest.java
@@ -15,6 +15,7 @@
  */
 package com.squareup.okhttp.internal.ws;
 
+import com.squareup.okhttp.ResponseBody;
 import com.squareup.okhttp.ws.WebSocketRecorder;
 import java.io.EOFException;
 import java.io.IOException;
@@ -27,7 +28,6 @@
 import org.junit.After;
 import org.junit.Test;
 
-import static com.squareup.okhttp.ws.WebSocket.PayloadType;
 import static com.squareup.okhttp.ws.WebSocketRecorder.MessageDelegate;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
@@ -151,11 +151,12 @@
 
     final Buffer sink = new Buffer();
     callback.setNextMessageDelegate(new MessageDelegate() {
-      @Override public void onMessage(BufferedSource payload, PayloadType type) throws IOException {
-        payload.readFully(sink, 3); // Read "Hel"
+      @Override public void onMessage(ResponseBody message) throws IOException {
+        BufferedSource source = message.source();
+        source.readFully(sink, 3); // Read "Hel"
         data.write(ByteString.decodeHex("5158")); // lo
-        payload.readFully(sink, 2); // Read "lo"
-        payload.close();
+        source.readFully(sink, 2); // Read "lo"
+        source.close();
       }
     });
     serverReader.processNextFrame();
@@ -251,8 +252,8 @@
   @Test public void noCloseErrors() throws IOException {
     data.write(ByteString.decodeHex("810548656c6c6f")); // Hello
     callback.setNextMessageDelegate(new MessageDelegate() {
-      @Override public void onMessage(BufferedSource payload, PayloadType type) throws IOException {
-        payload.readAll(new Buffer());
+      @Override public void onMessage(ResponseBody body) throws IOException {
+        body.source().readAll(new Buffer());
       }
     });
     try {
@@ -269,9 +270,9 @@
 
     final Buffer sink = new Buffer();
     callback.setNextMessageDelegate(new MessageDelegate() {
-      @Override public void onMessage(BufferedSource payload, PayloadType type) throws IOException {
-        payload.read(sink, 3);
-        payload.close();
+      @Override public void onMessage(ResponseBody message) throws IOException {
+        message.source().read(sink, 3);
+        message.close();
       }
     });
 
@@ -291,9 +292,9 @@
 
     final Buffer sink = new Buffer();
     callback.setNextMessageDelegate(new MessageDelegate() {
-      @Override public void onMessage(BufferedSource payload, PayloadType type) throws IOException {
-        payload.read(sink, 2);
-        payload.close();
+      @Override public void onMessage(ResponseBody message) throws IOException {
+        message.source().read(sink, 2);
+        message.close();
       }
     });
 
@@ -311,10 +312,10 @@
 
     final AtomicReference<Exception> exception = new AtomicReference<>();
     callback.setNextMessageDelegate(new MessageDelegate() {
-      @Override public void onMessage(BufferedSource payload, PayloadType type) throws IOException {
-        payload.close();
+      @Override public void onMessage(ResponseBody message) throws IOException {
+        message.close();
         try {
-          payload.readAll(new Buffer());
+          message.source().readAll(new Buffer());
           fail();
         } catch (IllegalStateException e) {
           exception.set(e);
diff --git a/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketWriterTest.java b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketWriterTest.java
index a98e6bbf9d..4a53546e7d 100644
--- a/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketWriterTest.java
+++ b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketWriterTest.java
@@ -17,16 +17,20 @@
 
 import java.io.EOFException;
 import java.io.IOException;
-import java.util.Arrays;
 import java.util.Random;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.ByteString;
-import org.junit.After;
+import okio.Okio;
+import okio.Sink;
+import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
 
-import static com.squareup.okhttp.ws.WebSocket.PayloadType.BINARY;
-import static com.squareup.okhttp.ws.WebSocket.PayloadType.TEXT;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_BINARY;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_TEXT;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.toggleMask;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
@@ -35,28 +39,27 @@
   private final Buffer data = new Buffer();
   private final Random random = new Random(0);
 
+  /**
+   * Check all data as verified inside of the test. We do this in a rule instead of @After so that
+   * exceptions thrown from the test do not cause this check to fail.
+   */
+  @Rule public final TestRule noDataLeftBehind = new TestRule() {
+    @Override public Statement apply(final Statement base, Description description) {
+      return new Statement() {
+        @Override public void evaluate() throws Throwable {
+          base.evaluate();
+          assertEquals("Data not empty", "", data.readByteString().hex());
+        }
+      };
+    }
+  };
+
   // Mutually exclusive. Use the one corresponding to the peer whose behavior you wish to test.
   private final WebSocketWriter serverWriter = new WebSocketWriter(false, data, random);
   private final WebSocketWriter clientWriter = new WebSocketWriter(true, data, random);
 
-  @After public void tearDown() throws IOException {
-    assertEquals("Data not empty", "", data.readByteString().hex());
-  }
-
-  @Test public void serverSendSimpleHello() throws IOException {
-    Buffer payload = new Buffer().writeUtf8("Hello");
-    serverWriter.sendMessage(TEXT, payload);
-    assertData("810548656c6c6f");
-  }
-
-  @Test public void clientSendSimpleHello() throws IOException {
-    Buffer payload = new Buffer().writeUtf8("Hello");
-    clientWriter.sendMessage(TEXT, payload);
-    assertData("818560b420bb28d14cd70f");
-  }
-
-  @Test public void serverStreamSimpleHello() throws IOException {
-    BufferedSink sink = serverWriter.newMessageSink(TEXT);
+  @Test public void serverTextMessage() throws IOException {
+    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT));
 
     sink.writeUtf8("Hel").flush();
     assertData("010348656c");
@@ -68,8 +71,8 @@
     assertData("8000");
   }
 
-  @Test public void serverStreamCloseFlushes() throws IOException {
-    BufferedSink sink = serverWriter.newMessageSink(TEXT);
+  @Test public void serverCloseFlushes() throws IOException {
+    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT));
 
     sink.writeUtf8("Hel").flush();
     assertData("010348656c");
@@ -79,8 +82,8 @@
     assertData("8000");
   }
 
-  @Test public void clientStreamSimpleHello() throws IOException {
-    BufferedSink sink = clientWriter.newMessageSink(TEXT);
+  @Test public void clientTextMessage() throws IOException {
+    BufferedSink sink = Okio.buffer(clientWriter.newMessageSink(OPCODE_TEXT));
 
     sink.writeUtf8("Hel").flush();
     assertData("018360b420bb28d14c");
@@ -92,58 +95,46 @@
     assertData("80807acb933d");
   }
 
-  @Test public void serverSendBinary() throws IOException {
-    byte[] payload = binaryData(100);
-    serverWriter.sendMessage(BINARY, new Buffer().write(payload));
-    assertData("8264");
-    assertData(payload);
-  }
+  @Test public void serverBinaryMessage() throws IOException {
+    Sink sink = serverWriter.newMessageSink(OPCODE_BINARY);
 
-  @Test public void serverSendBinaryShort() throws IOException {
-    byte[] payload = binaryData(0xffff);
-    serverWriter.sendMessage(BINARY, new Buffer().write(payload));
-    assertData("827effff");
-    assertData(payload);
-  }
+    sink.write(binaryData(50), 50);
+    assertData("0232");
+    assertData(binaryData(50).readByteArray());
+
+    sink.write(binaryData(50), 50);
+    assertData("0032");
+    assertData(binaryData(50).readByteArray());
 
-  @Test public void serverSendBinaryLong() throws IOException {
-    byte[] payload = binaryData(65537);
-    serverWriter.sendMessage(BINARY, new Buffer().write(payload));
-    assertData("827f0000000000010001");
-    assertData(payload);
+    sink.close();
+    assertData("8000");
   }
 
-  @Test public void clientSendBinary() throws IOException {
-    byte[] payload = binaryData(100);
-    clientWriter.sendMessage(BINARY, new Buffer().write(payload));
-    assertData("82e4");
+  @Test public void serverBinaryMessageLengthShort() throws IOException {
+    Sink sink = serverWriter.newMessageSink(OPCODE_BINARY);
 
-    byte[] maskKey = new byte[4];
-    random.setSeed(0); // Reset the seed so we can mask the payload.
-    random.nextBytes(maskKey);
-    toggleMask(payload, payload.length, maskKey, 0);
+    int length = 0xffff;
+    sink.write(binaryData(length), length);
+    assertData("027effff");
+    assertData(binaryData(length).readByteArray());
 
-    assertData(maskKey);
-    assertData(payload);
+    sink.close();
+    assertData("8000");
   }
 
-  @Test public void serverStreamBinary() throws IOException {
-    byte[] payload = binaryData(100);
-    BufferedSink sink = serverWriter.newMessageSink(BINARY);
+  @Test public void serverBinaryMessageLengthLong() throws IOException {
+    Sink sink = serverWriter.newMessageSink(OPCODE_BINARY);
 
-    sink.write(payload, 0, 50).flush();
-    assertData("0232");
-    assertData(Arrays.copyOfRange(payload, 0, 50));
-
-    sink.write(payload, 50, 50).flush();
-    assertData("0032");
-    assertData(Arrays.copyOfRange(payload, 50, 100));
+    int length = 65537;
+    sink.write(binaryData(length), length);
+    assertData("027f0000000000010001");
+    assertData(binaryData(length).readByteArray());
 
     sink.close();
     assertData("8000");
   }
 
-  @Test public void clientStreamBinary() throws IOException {
+  @Test public void clientBinary() throws IOException {
     byte[] maskKey1 = new byte[4];
     random.nextBytes(maskKey1);
     byte[] maskKey2 = new byte[4];
@@ -153,18 +144,17 @@
 
     random.setSeed(0); // Reset the seed so real data matches.
 
-    byte[] payload = binaryData(100);
-    BufferedSink sink = clientWriter.newMessageSink(BINARY);
+    Sink sink = clientWriter.newMessageSink(OPCODE_BINARY);
 
-    sink.write(payload, 0, 50).flush();
-    byte[] part1 = Arrays.copyOfRange(payload, 0, 50);
+    sink.write(binaryData(50), 50);
+    byte[] part1 = binaryData(50).readByteArray();
     toggleMask(part1, 50, maskKey1, 0);
     assertData("02b2");
     assertData(maskKey1);
     assertData(part1);
 
-    sink.write(payload, 50, 50).flush();
-    byte[] part2 = Arrays.copyOfRange(payload, 50, 100);
+    sink.write(binaryData(50), 50);
+    byte[] part2 = binaryData(50).readByteArray();
     toggleMask(part2, 50, maskKey2, 0);
     assertData("00b2");
     assertData(maskKey2);
@@ -261,7 +251,7 @@
 
   @Test public void pingTooLongThrows() throws IOException {
     try {
-      serverWriter.writePing(new Buffer().write(binaryData(1000)));
+      serverWriter.writePing(binaryData(1000));
       fail();
     } catch (IllegalArgumentException e) {
       assertEquals("Payload size must be less than or equal to 125", e.getMessage());
@@ -270,7 +260,7 @@
 
   @Test public void pongTooLongThrows() throws IOException {
     try {
-      serverWriter.writePong(new Buffer().write(binaryData(1000)));
+      serverWriter.writePong(binaryData(1000));
       fail();
     } catch (IllegalArgumentException e) {
       assertEquals("Payload size must be less than or equal to 125", e.getMessage());
@@ -279,7 +269,7 @@
 
   @Test public void closeTooLongThrows() throws IOException {
     try {
-      String longString = ByteString.of(binaryData(75)).hex();
+      String longString = binaryData(75).readByteString().hex();
       serverWriter.writeClose(1000, longString);
       fail();
     } catch (IllegalArgumentException e) {
@@ -287,26 +277,16 @@
     }
   }
 
-  @Test public void twoWritersThrows() {
-    clientWriter.newMessageSink(TEXT);
+  @Test public void twoMessageSinksThrows() {
+    clientWriter.newMessageSink(OPCODE_TEXT);
     try {
-      clientWriter.newMessageSink(TEXT);
+      clientWriter.newMessageSink(OPCODE_TEXT);
       fail();
     } catch (IllegalStateException e) {
       assertEquals("Another message writer is active. Did you call close()?", e.getMessage());
     }
   }
 
-  @Test public void writeWhileWriterThrows() throws IOException {
-    clientWriter.newMessageSink(TEXT);
-    try {
-      clientWriter.sendMessage(TEXT, new Buffer());
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("A message writer is active. Did you call close()?", e.getMessage());
-    }
-  }
-
   private void assertData(String hex) throws EOFException {
     ByteString expected = ByteString.decodeHex(hex);
     ByteString actual = data.readByteString(expected.size());
@@ -323,9 +303,9 @@ private void assertData(byte[] data) throws IOException {
     }
   }
 
-  private static byte[] binaryData(int length) {
+  private static Buffer binaryData(int length) {
     byte[] junk = new byte[length];
     new Random(0).nextBytes(junk);
-    return junk;
+    return new Buffer().write(junk);
   }
 }
diff --git a/okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/AutobahnTester.java b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/AutobahnTester.java
index a592624c67..ce730fdbad 100644
--- a/okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/AutobahnTester.java
+++ b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/AutobahnTester.java
@@ -17,7 +17,9 @@
 
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
 import com.squareup.okhttp.internal.Version;
 import java.io.IOException;
 import java.util.concurrent.CountDownLatch;
@@ -27,7 +29,7 @@
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 import okio.Buffer;
-import okio.BufferedSource;
+import okio.ByteString;
 
 /**
  * Exercises the web socket implementation against the
@@ -74,16 +76,15 @@ private void runTest(final long number, final long count) throws IOException {
             this.webSocket = webSocket;
           }
 
-          @Override public void onMessage(BufferedSource payload, final WebSocket.PayloadType type)
-              throws IOException {
-            final Buffer buffer = new Buffer();
-            payload.readAll(buffer);
-            payload.close();
+          @Override public void onMessage(final ResponseBody message) throws IOException {
+            ByteString body = message.source().readByteString();
+            message.close();
 
+            final RequestBody response = RequestBody.create(message.contentType(), body);
             sendExecutor.execute(new Runnable() {
               @Override public void run() {
                 try {
-                  webSocket.sendMessage(type, buffer);
+                  webSocket.sendMessage(response);
                 } catch (IOException e) {
                   e.printStackTrace();
                 }
@@ -120,10 +121,9 @@ private long getTestCount() throws IOException {
       @Override public void onOpen(WebSocket webSocket, Response response) {
       }
 
-      @Override public void onMessage(BufferedSource payload, WebSocket.PayloadType type)
-          throws IOException {
-        countRef.set(payload.readDecimalLong());
-        payload.close();
+      @Override public void onMessage(ResponseBody message) throws IOException {
+        countRef.set(message.source().readDecimalLong());
+        message.close();
       }
 
       @Override public void onPong(Buffer payload) {
@@ -158,8 +158,7 @@ private void updateReports() {
       @Override public void onOpen(WebSocket webSocket, Response response) {
       }
 
-      @Override public void onMessage(BufferedSource payload, WebSocket.PayloadType type)
-          throws IOException {
+      @Override public void onMessage(ResponseBody message) throws IOException {
       }
 
       @Override public void onPong(Buffer payload) {
diff --git a/okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/WebSocketCallTest.java b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/WebSocketCallTest.java
index 895eb1f658..bbc908cd19 100644
--- a/okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/WebSocketCallTest.java
+++ b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/WebSocketCallTest.java
@@ -17,7 +17,9 @@
 
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
@@ -30,13 +32,11 @@
 import java.util.concurrent.atomic.AtomicReference;
 import javax.net.ssl.SSLContext;
 import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
 import org.junit.After;
 import org.junit.Rule;
 import org.junit.Test;
 
-import static com.squareup.okhttp.ws.WebSocket.PayloadType.TEXT;
+import static com.squareup.okhttp.ws.WebSocket.TEXT;
 
 public final class WebSocketCallTest {
   @Rule public final MockWebServer server = new MockWebServer();
@@ -64,7 +64,7 @@
     server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
 
     WebSocket webSocket = awaitWebSocket();
-    webSocket.sendMessage(TEXT, new Buffer().writeUtf8("Hello, WebSockets!"));
+    webSocket.sendMessage(RequestBody.create(TEXT, "Hello, WebSockets!"));
     serverListener.assertTextMessage("Hello, WebSockets!");
   }
 
@@ -74,43 +74,7 @@
         new Thread() {
           @Override public void run() {
             try {
-              webSocket.sendMessage(TEXT, new Buffer().writeUtf8("Hello, WebSockets!"));
-            } catch (IOException e) {
-              throw new AssertionError(e);
-            }
-          }
-        }.start();
-      }
-    };
-    server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-
-    awaitWebSocket();
-    listener.assertTextMessage("Hello, WebSockets!");
-  }
-
-  @Test public void clientStreamingMessage() throws IOException {
-    WebSocketRecorder serverListener = new WebSocketRecorder();
-    server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-
-    WebSocket webSocket = awaitWebSocket();
-    BufferedSink sink = webSocket.newMessageSink(TEXT);
-    sink.writeUtf8("Hello, ").flush();
-    sink.writeUtf8("WebSockets!").flush();
-    sink.close();
-
-    serverListener.assertTextMessage("Hello, WebSockets!");
-  }
-
-  @Test public void serverStreamingMessage() throws IOException {
-    WebSocketListener serverListener = new EmptyWebSocketListener() {
-      @Override public void onOpen(final WebSocket webSocket, Response response) {
-        new Thread() {
-          @Override public void run() {
-            try {
-              BufferedSink sink = webSocket.newMessageSink(TEXT);
-              sink.writeUtf8("Hello, ").flush();
-              sink.writeUtf8("WebSockets!").flush();
-              sink.close();
+              webSocket.sendMessage(RequestBody.create(TEXT, "Hello, WebSockets!"));
             } catch (IOException e) {
               throw new AssertionError(e);
             }
@@ -233,7 +197,7 @@ private void websocketScheme(String scheme) throws IOException {
         .build();
 
     WebSocket webSocket = awaitWebSocket(request1);
-    webSocket.sendMessage(TEXT, new Buffer().writeUtf8("abc"));
+    webSocket.sendMessage(RequestBody.create(TEXT, "abc"));
     serverListener.assertTextMessage("abc");
   }
 
@@ -255,9 +219,8 @@ private WebSocket awaitWebSocket(Request request) {
         latch.countDown();
       }
 
-      @Override public void onMessage(BufferedSource payload, WebSocket.PayloadType type)
-          throws IOException {
-        listener.onMessage(payload, type);
+      @Override public void onMessage(ResponseBody message) throws IOException {
+        listener.onMessage(message);
       }
 
       @Override public void onPong(Buffer payload) {
@@ -290,8 +253,7 @@ private WebSocket awaitWebSocket(Request request) {
     @Override public void onOpen(WebSocket webSocket, Response response) {
     }
 
-    @Override public void onMessage(BufferedSource payload, WebSocket.PayloadType type)
-        throws IOException {
+    @Override public void onMessage(ResponseBody message) throws IOException {
     }
 
     @Override public void onPong(Buffer payload) {
diff --git a/okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/WebSocketRecorder.java b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/WebSocketRecorder.java
index 56b3810630..12fb2ef8a9 100644
--- a/okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/WebSocketRecorder.java
+++ b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/WebSocketRecorder.java
@@ -15,24 +15,25 @@
  */
 package com.squareup.okhttp.ws;
 
+import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
 import com.squareup.okhttp.internal.ws.WebSocketReader;
 import java.io.IOException;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.TimeUnit;
 import okio.Buffer;
-import okio.BufferedSource;
 
-import static com.squareup.okhttp.ws.WebSocket.PayloadType.BINARY;
-import static com.squareup.okhttp.ws.WebSocket.PayloadType.TEXT;
+import static com.squareup.okhttp.ws.WebSocket.BINARY;
+import static com.squareup.okhttp.ws.WebSocket.TEXT;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 
 public final class WebSocketRecorder implements WebSocketReader.FrameCallback, WebSocketListener {
   public interface MessageDelegate {
-    void onMessage(BufferedSource payload, WebSocket.PayloadType type) throws IOException;
+    void onMessage(ResponseBody message) throws IOException;
   }
 
   private final BlockingQueue<Object> events = new LinkedBlockingQueue<>();
@@ -46,16 +47,15 @@ public void setNextMessageDelegate(MessageDelegate delegate) {
   @Override public void onOpen(WebSocket webSocket, Response response) {
   }
 
-  @Override public void onMessage(BufferedSource source, WebSocket.PayloadType type)
-      throws IOException {
+  @Override public void onMessage(ResponseBody message) throws IOException {
     if (delegate != null) {
-      delegate.onMessage(source, type);
+      delegate.onMessage(message);
       delegate = null;
     } else {
-      Message message = new Message(type);
-      source.readAll(message.buffer);
-      source.close();
-      events.add(message);
+      Message event = new Message(message.contentType());
+      message.source().readAll(event.buffer);
+      message.close();
+      events.add(event);
     }
   }
 
@@ -125,25 +125,25 @@ public void assertExhausted() {
   }
 
   private static class Message {
-    public final WebSocket.PayloadType type;
+    public final MediaType mediaType;
     public final Buffer buffer = new Buffer();
 
-    private Message(WebSocket.PayloadType type) {
-      this.type = type;
+    private Message(MediaType mediaType) {
+      this.mediaType = mediaType;
     }
 
     @Override public String toString() {
-      return "Message[" + type + " " + buffer + "]";
+      return "Message[" + mediaType + " " + buffer + "]";
     }
 
     @Override public int hashCode() {
-      return type.hashCode() * 37 + buffer.hashCode();
+      return mediaType.hashCode() * 37 + buffer.hashCode();
     }
 
     @Override public boolean equals(Object obj) {
       if (obj instanceof Message) {
         Message other = (Message) obj;
-        return type == other.type && buffer.equals(other.buffer);
+        return mediaType.equals(other.mediaType) && buffer.equals(other.buffer);
       }
       return false;
     }
diff --git a/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/RealWebSocket.java b/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/RealWebSocket.java
index 8d6b7c498b..3a56bf2276 100644
--- a/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/RealWebSocket.java
+++ b/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/RealWebSocket.java
@@ -15,6 +15,9 @@
  */
 package com.squareup.okhttp.internal.ws;
 
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
 import com.squareup.okhttp.internal.NamedRunnable;
 import com.squareup.okhttp.ws.WebSocket;
 import com.squareup.okhttp.ws.WebSocketListener;
@@ -25,7 +28,10 @@
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
+import okio.Okio;
 
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_BINARY;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_TEXT;
 import static com.squareup.okhttp.internal.ws.WebSocketReader.FrameCallback;
 
 public abstract class RealWebSocket implements WebSocket {
@@ -49,8 +55,8 @@ public RealWebSocket(boolean isClient, BufferedSource source, BufferedSink sink,
 
     writer = new WebSocketWriter(isClient, sink, random);
     reader = new WebSocketReader(isClient, source, new FrameCallback() {
-      @Override public void onMessage(BufferedSource source, PayloadType type) throws IOException {
-        listener.onMessage(source, type);
+      @Override public void onMessage(ResponseBody message) throws IOException {
+        listener.onMessage(message);
       }
 
       @Override public void onPing(final Buffer buffer) {
@@ -100,14 +106,31 @@ public boolean readMessage() {
     }
   }
 
-  @Override public BufferedSink newMessageSink(PayloadType type) {
+  @Override public void sendMessage(RequestBody message) throws IOException {
+    if (message == null) throw new NullPointerException("message == null");
     if (writerSentClose) throw new IllegalStateException("closed");
-    return writer.newMessageSink(type);
-  }
 
-  @Override public void sendMessage(PayloadType type, Buffer payload) throws IOException {
-    if (writerSentClose) throw new IllegalStateException("closed");
-    writer.sendMessage(type, payload);
+    MediaType contentType = message.contentType();
+    if (contentType == null) {
+      throw new IllegalArgumentException(
+          "Message content type was null. Must use WebSocket.TEXT or WebSocket.BINARY.");
+    }
+    String contentSubtype = contentType.subtype();
+
+    int formatOpcode;
+    if (WebSocket.TEXT.subtype().equals(contentSubtype)) {
+      formatOpcode = OPCODE_TEXT;
+    } else if (WebSocket.BINARY.subtype().equals(contentSubtype)) {
+      formatOpcode = OPCODE_BINARY;
+    } else {
+      throw new IllegalArgumentException("Unknown message content type: "
+          + contentType.type() + "/" + contentType.subtype() // Omit any implicitly added charset.
+          + ". Must use WebSocket.TEXT or WebSocket.BINARY.");
+    }
+
+    BufferedSink sink = Okio.buffer(writer.newMessageSink(formatOpcode));
+    message.writeTo(sink);
+    sink.close();
   }
 
   @Override public void sendPing(Buffer payload) throws IOException {
diff --git a/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketReader.java b/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketReader.java
index ce548b17ea..5e7baf5c2a 100644
--- a/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketReader.java
+++ b/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketReader.java
@@ -15,6 +15,9 @@
  */
 package com.squareup.okhttp.internal.ws;
 
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.ResponseBody;
+import com.squareup.okhttp.ws.WebSocket;
 import java.io.EOFException;
 import java.io.IOException;
 import java.net.ProtocolException;
@@ -24,7 +27,6 @@
 import okio.Source;
 import okio.Timeout;
 
-import static com.squareup.okhttp.ws.WebSocket.PayloadType;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B0_FLAG_FIN;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B0_FLAG_RSV1;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B0_FLAG_RSV2;
@@ -50,7 +52,7 @@
  */
 public final class WebSocketReader {
   public interface FrameCallback {
-    void onMessage(BufferedSource source, PayloadType type) throws IOException;
+    void onMessage(ResponseBody body) throws IOException;
     void onPing(Buffer buffer);
     void onPong(Buffer buffer);
     void onClose(int code, String reason);
@@ -204,20 +206,35 @@ private void readControlFrame() throws IOException {
   }
 
   private void readMessageFrame() throws IOException {
-    PayloadType type;
+    final MediaType type;
     switch (opcode) {
       case OPCODE_TEXT:
-        type = PayloadType.TEXT;
+        type = WebSocket.TEXT;
         break;
       case OPCODE_BINARY:
-        type = PayloadType.BINARY;
+        type = WebSocket.BINARY;
         break;
       default:
         throw new ProtocolException("Unknown opcode: " + toHexString(opcode));
     }
 
+    final BufferedSource source = Okio.buffer(framedMessageSource);
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return type;
+      }
+
+      @Override public long contentLength() throws IOException {
+        return -1;
+      }
+
+      @Override public BufferedSource source() throws IOException {
+        return source;
+      }
+    };
+
     messageClosed = false;
-    frameCallback.onMessage(Okio.buffer(framedMessageSource), type);
+    frameCallback.onMessage(body);
     if (!messageClosed) {
       throw new IllegalStateException("Listener failed to call close on message payload.");
     }
diff --git a/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketWriter.java b/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketWriter.java
index fc5de753a1..11dcd287d5 100644
--- a/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketWriter.java
+++ b/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketWriter.java
@@ -20,19 +20,15 @@
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
-import okio.Okio;
 import okio.Sink;
 import okio.Timeout;
 
-import static com.squareup.okhttp.ws.WebSocket.PayloadType;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B0_FLAG_FIN;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B1_FLAG_MASK;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_BINARY;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_CONTINUATION;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_CONTROL_CLOSE;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PING;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PONG;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_TEXT;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_LONG;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_MAX;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_SHORT;
@@ -42,10 +38,9 @@
  * An <a href="http://tools.ietf.org/html/rfc6455">RFC 6455</a>-compatible WebSocket frame writer.
  * <p>
  * This class is partially thread safe. Only a single "main" thread should be sending messages via
- * calls to {@link #newMessageSink} or {@link #sendMessage} as well as any calls to
- * {@link #writePing} or {@link #writeClose}. Other threads may call {@link #writePing},
- * {@link #writePong}, or {@link #writeClose} which will interleave on the wire with frames from
- * the main thread.
+ * calls to {@link #newMessageSink}, {@link #writePing}, or {@link #writeClose}. Other threads may
+ * call {@link #writePing}, {@link #writePong}, or {@link #writeClose} which will interleave on the
+ * wire with frames from the "main" sending thread.
  */
 public final class WebSocketWriter {
   private final boolean isClient;
@@ -155,48 +150,22 @@ private void writeControlFrame(int opcode, Buffer payload) throws IOException {
    * Stream a message payload as a series of frames. This allows control frames to be interleaved
    * between parts of the message.
    */
-  public BufferedSink newMessageSink(PayloadType type) {
-    if (type == null) throw new NullPointerException("type == null");
+  public Sink newMessageSink(int formatOpcode) {
     if (activeWriter) {
       throw new IllegalStateException("Another message writer is active. Did you call close()?");
     }
     activeWriter = true;
 
-    frameSink.payloadType = type;
+    frameSink.formatOpcode = formatOpcode;
     frameSink.isFirstFrame = true;
-    return Okio.buffer(frameSink);
+    return frameSink;
   }
 
-  /**
-   * Send a message payload as a single frame. This will block any control frames that need sent
-   * until it is completed.
-   */
-  public void sendMessage(PayloadType type, Buffer payload) throws IOException {
-    if (type == null) throw new NullPointerException("type == null");
-    if (payload == null) throw new NullPointerException("payload == null");
-    if (activeWriter) {
-      throw new IllegalStateException("A message writer is active. Did you call close()?");
-    }
-    writeFrame(type, payload, payload.size(), true /* first frame */, true /* final */);
-  }
-
-  private void writeFrame(PayloadType payloadType, Buffer source, long byteCount,
+  private void writeFrame(int formatOpcode, Buffer source, long byteCount,
       boolean isFirstFrame, boolean isFinal) throws IOException {
     if (closed) throw new IOException("closed");
 
-    int opcode = OPCODE_CONTINUATION;
-    if (isFirstFrame) {
-      switch (payloadType) {
-        case TEXT:
-          opcode = OPCODE_TEXT;
-          break;
-        case BINARY:
-          opcode = OPCODE_BINARY;
-          break;
-        default:
-          throw new IllegalStateException("Unknown payload type: " + payloadType);
-      }
-    }
+    int opcode = isFirstFrame ? formatOpcode : OPCODE_CONTINUATION;
 
     synchronized (sink) {
       int b0 = opcode;
@@ -247,11 +216,11 @@ private void writeAllMasked(BufferedSource source, long byteCount) throws IOExce
   }
 
   private final class FrameSink implements Sink {
-    private PayloadType payloadType;
+    private int formatOpcode;
     private boolean isFirstFrame;
 
     @Override public void write(Buffer source, long byteCount) throws IOException {
-      writeFrame(payloadType, source, byteCount, isFirstFrame, false /* final */);
+      writeFrame(formatOpcode, source, byteCount, isFirstFrame, false /* final */);
       isFirstFrame = false;
     }
 
diff --git a/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocket.java b/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocket.java
index 4cf2f42d6f..df1490d5b8 100644
--- a/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocket.java
+++ b/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocket.java
@@ -15,36 +15,27 @@
  */
 package com.squareup.okhttp.ws;
 
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
 import java.io.IOException;
 import okio.Buffer;
-import okio.BufferedSink;
 
 /** Blocking interface to connect and write to a web socket. */
 public interface WebSocket {
-  /** The format of a message payload. */
-  enum PayloadType {
-    /** UTF8-encoded text data. */
-    TEXT,
-    /** Arbitrary binary data. */
-    BINARY
-  }
+  /** A {@link MediaType} indicating UTF-8 text frames should be used when sending the message. */
+  MediaType TEXT = MediaType.parse("application/vnd.okhttp.websocket+text; charset=utf-8");
+  /** A {@link MediaType} indicating binary frames should be used when sending the message. */
+  MediaType BINARY = MediaType.parse("application/vnd.okhttp.websocket+binary");
 
   /**
-   * Stream a message payload to the server of the specified {code type}.
-   * <p>
-   * You must call {@link BufferedSink#close() close()} to complete the message. Calls to
-   * {@link BufferedSink#flush() flush()} write a frame fragment. The message may be empty.
+   * Send a message payload to the server.
    *
-   * @throws IllegalStateException if not connected, already closed, or another writer is active.
-   */
-  BufferedSink newMessageSink(WebSocket.PayloadType type);
-
-  /**
-   * Send a message payload to the server of the specified {@code type}.
+   * <p>The {@linkplain RequestBody#contentType() content type} of {@code message} should be either
+   * {@link #TEXT} or {@link #BINARY}.
    *
    * @throws IllegalStateException if not connected, already closed, or another writer is active.
    */
-  void sendMessage(WebSocket.PayloadType type, Buffer payload) throws IOException;
+  void sendMessage(RequestBody message) throws IOException;
 
   /**
    * Send a ping to the server with optional payload.
diff --git a/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocketListener.java b/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocketListener.java
index 8941b7443b..5a5a8b1a26 100644
--- a/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocketListener.java
+++ b/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocketListener.java
@@ -16,11 +16,9 @@
 package com.squareup.okhttp.ws;
 
 import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import okio.Buffer;
-import okio.BufferedSource;
-
-import static com.squareup.okhttp.ws.WebSocket.PayloadType;
 
 /** Listener for server-initiated messages on a connected {@link WebSocket}. */
 public interface WebSocketListener {
@@ -50,8 +48,11 @@
    * <p>Implementations <strong>must</strong> call {@code source.close()} before returning. This
    * indicates completion of parsing the message payload and will consume any remaining bytes in
    * the message.
+   *
+   * <p>The {@linkplain ResponseBody#contentType() content type} of {@code message} will be either
+   * {@link WebSocket#TEXT} or {@link WebSocket#BINARY} which indicates the format of the message.
    */
-  void onMessage(BufferedSource payload, PayloadType type) throws IOException;
+  void onMessage(ResponseBody message) throws IOException;
 
   /**
    * Called when a server pong is received. This is usually a result of calling {@link
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/WebSocketEcho.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/WebSocketEcho.java
index d439e99b68..93298a1580 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/WebSocketEcho.java
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/WebSocketEcho.java
@@ -2,7 +2,9 @@
 
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
 import com.squareup.okhttp.ws.WebSocket;
 import com.squareup.okhttp.ws.WebSocketCall;
 import com.squareup.okhttp.ws.WebSocketListener;
@@ -10,12 +12,15 @@
 import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
 import okio.Buffer;
-import okio.BufferedSource;
+import okio.ByteString;
 
-import static com.squareup.okhttp.ws.WebSocket.PayloadType;
-import static com.squareup.okhttp.ws.WebSocket.PayloadType.BINARY;
-import static com.squareup.okhttp.ws.WebSocket.PayloadType.TEXT;
+import static com.squareup.okhttp.ws.WebSocket.BINARY;
+import static com.squareup.okhttp.ws.WebSocket.TEXT;
 
+/**
+ * NOTE: This is currently broken because the Echo server does not correctly echo empty frames
+ * which OkHttp uses for final frames on streamed messages.
+ */
 public final class WebSocketEcho implements WebSocketListener {
   private final Executor writeExecutor = Executors.newSingleThreadExecutor();
 
@@ -35,9 +40,9 @@ private void run() throws IOException {
     writeExecutor.execute(new Runnable() {
       @Override public void run() {
         try {
-          webSocket.sendMessage(TEXT, new Buffer().writeUtf8("Hello..."));
-          webSocket.sendMessage(TEXT, new Buffer().writeUtf8("...World!"));
-          webSocket.sendMessage(BINARY, new Buffer().writeInt(0xdeadbeef));
+          webSocket.sendMessage(RequestBody.create(TEXT, "Hello..."));
+          webSocket.sendMessage(RequestBody.create(TEXT, "...World!"));
+          webSocket.sendMessage(RequestBody.create(BINARY, ByteString.decodeHex("deadbeef")));
           webSocket.close(1000, "Goodbye, World!");
         } catch (IOException e) {
           System.err.println("Unable to send messages: " + e.getMessage());
@@ -46,18 +51,13 @@ private void run() throws IOException {
     });
   }
 
-  @Override public void onMessage(BufferedSource payload, PayloadType type) throws IOException {
-    switch (type) {
-      case TEXT:
-        System.out.println("MESSAGE: " + payload.readUtf8());
-        break;
-      case BINARY:
-        System.out.println("MESSAGE: " + payload.readByteString().hex());
-        break;
-      default:
-        throw new IllegalStateException("Unknown payload type: " + type);
+  @Override public void onMessage(ResponseBody message) throws IOException {
+    if (message.contentType() == TEXT) {
+      System.out.println("MESSAGE: " + message.string());
+    } else {
+      System.out.println("MESSAGE: " + message.source().readByteString().hex());
     }
-    payload.close();
+    message.close();
   }
 
   @Override public void onPong(Buffer payload) {
