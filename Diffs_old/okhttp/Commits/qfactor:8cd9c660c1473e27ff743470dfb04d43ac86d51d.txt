diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/BaseTestHandler.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/BaseTestHandler.java
index b0b552b937..38e3d44a9d 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/BaseTestHandler.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/BaseTestHandler.java
@@ -17,19 +17,21 @@
 
 import java.io.IOException;
 import java.util.List;
+
+import okhttp3.StatisticsData;
 import okio.BufferedSource;
 import okio.ByteString;
 
 import static org.junit.Assert.fail;
 
 class BaseTestHandler implements Http2Reader.Handler {
-  @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
+  @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length, StatisticsData statsData)
       throws IOException {
     fail();
   }
 
   @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,
-      List<Header> headerBlock) {
+      List<Header> headerBlock, StatisticsData statsData) {
     fail();
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java
index b1df905a4f..4792824713 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java
@@ -19,6 +19,8 @@
 import java.util.Arrays;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicInteger;
+
+import okhttp3.StatisticsData;
 import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSink;
@@ -69,7 +71,7 @@
 
     reader.nextFrame(false, new BaseTestHandler() {
       @Override public void headers(boolean inFinished, int streamId,
-          int associatedStreamId, List<Header> headerBlock) {
+          int associatedStreamId, List<Header> headerBlock, StatisticsData statsData) {
         assertTrue(inFinished);
         assertEquals(expectedStreamId, streamId);
         assertEquals(-1, associatedStreamId);
@@ -99,7 +101,7 @@
       }
 
       @Override public void headers(boolean inFinished, int streamId,
-          int associatedStreamId, List<Header> nameValueBlock) {
+          int associatedStreamId, List<Header> nameValueBlock, StatisticsData statsData) {
         assertFalse(inFinished);
         assertEquals(expectedStreamId, streamId);
         assertEquals(-1, associatedStreamId);
@@ -133,7 +135,7 @@
     // Reading the above frames should result in a concatenated headerBlock.
     reader.nextFrame(false, new BaseTestHandler() {
       @Override public void headers(boolean inFinished, int streamId,
-          int associatedStreamId, List<Header> headerBlock) {
+          int associatedStreamId, List<Header> headerBlock, StatisticsData statsData) {
         assertFalse(inFinished);
         assertEquals(expectedStreamId, streamId);
         assertEquals(-1, associatedStreamId);
@@ -380,7 +382,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
 
     reader.nextFrame(false, new BaseTestHandler() {
       @Override public void data(boolean inFinished, int streamId, BufferedSource source,
-          int length) throws IOException {
+          int length, StatisticsData statsData) throws IOException {
         assertFalse(inFinished);
         assertEquals(expectedStreamId, streamId);
         assertEquals(Http2.INITIAL_MAX_FRAME_SIZE, length);
@@ -704,7 +706,7 @@ private Buffer windowUpdate(long windowSizeIncrement) throws IOException {
   private Http2Reader.Handler assertHeaderBlock() {
     return new BaseTestHandler() {
       @Override public void headers(boolean inFinished, int streamId,
-          int associatedStreamId, List<Header> headerBlock) {
+          int associatedStreamId, List<Header> headerBlock, StatisticsData statsData) {
         assertFalse(inFinished);
         assertEquals(expectedStreamId, streamId);
         assertEquals(-1, associatedStreamId);
@@ -716,7 +718,7 @@ private Buffer windowUpdate(long windowSizeIncrement) throws IOException {
   private Http2Reader.Handler assertData() {
     return new BaseTestHandler() {
       @Override public void data(boolean inFinished, int streamId, BufferedSource source,
-          int length) throws IOException {
+          int length, StatisticsData statsData) throws IOException {
         assertFalse(inFinished);
         assertEquals(expectedStreamId, streamId);
         assertEquals(1123, length);
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
index 3ef429a957..f87b9c17c9 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
@@ -42,6 +42,7 @@
 import okhttp3.Request;
 import okhttp3.RequestBody;
 import okhttp3.Response;
+import okhttp3.StatisticsData;
 import okhttp3.TestUtil;
 import okhttp3.internal.DoubleInetAddressDns;
 import okhttp3.internal.RecordingOkAuthenticator;
@@ -1137,13 +1138,13 @@ public AsyncRequest(String path, CountDownLatch countDownLatch) {
     @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
     }
 
-    @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
+    @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length, StatisticsData statsData)
         throws IOException {
       dataFrames.add(length);
     }
 
     @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,
-        List<Header> headerBlock) {
+        List<Header> headerBlock, StatisticsData statsData) {
       headerFrameCount++;
     }
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
index fe5f82fd4a..b7c5a6a0c4 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
@@ -31,6 +31,8 @@
 import java.util.concurrent.Executors;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.logging.Logger;
+
+import okhttp3.StatisticsData;
 import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSource;
@@ -240,7 +242,7 @@ public InFrame(int sequence, Http2Reader reader) {
     }
 
     @Override public void headers(boolean inFinished, int streamId,
-        int associatedStreamId, List<Header> headerBlock) {
+        int associatedStreamId, List<Header> headerBlock, StatisticsData statsData) {
       if (this.type != -1) throw new IllegalStateException();
       this.type = Http2.TYPE_HEADERS;
       this.inFinished = inFinished;
@@ -249,7 +251,7 @@ public InFrame(int sequence, Http2Reader reader) {
       this.headerBlock = headerBlock;
     }
 
-    @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
+    @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length, StatisticsData statsData)
         throws IOException {
       if (this.type != -1) throw new IllegalStateException();
       this.type = Http2.TYPE_DATA;
diff --git a/okhttp/src/main/java/okhttp3/Request.java b/okhttp/src/main/java/okhttp3/Request.java
index f4b0f6dba4..648dc4384a 100644
--- a/okhttp/src/main/java/okhttp3/Request.java
+++ b/okhttp/src/main/java/okhttp3/Request.java
@@ -30,6 +30,7 @@
   final Headers headers;
   final RequestBody body;
   final Object tag;
+  final StatisticsObserver observer;
 
   private volatile CacheControl cacheControl; // Lazily initialized.
 
@@ -39,6 +40,7 @@
     this.headers = builder.headers.build();
     this.body = builder.body;
     this.tag = builder.tag != null ? builder.tag : this;
+    this.observer = builder.observer;
   }
 
   public HttpUrl url() {
@@ -69,6 +71,8 @@ public Object tag() {
     return tag;
   }
 
+  public StatisticsObserver observer() { return observer; }
+
   public Builder newBuilder() {
     return new Builder(this);
   }
@@ -102,6 +106,7 @@ public boolean isHttps() {
     Headers.Builder headers;
     RequestBody body;
     Object tag;
+    StatisticsObserver observer;
 
     public Builder() {
       this.method = "GET";
@@ -113,6 +118,7 @@ public Builder() {
       this.method = request.method;
       this.body = request.body;
       this.tag = request.tag;
+      this.observer = request.observer;
       this.headers = request.headers.newBuilder();
     }
 
@@ -250,6 +256,11 @@ public Builder tag(Object tag) {
       return this;
     }
 
+    public Builder observer(StatisticsObserver observer) {
+      this.observer = observer;
+      return this;
+    }
+
     public Request build() {
       if (url == null) throw new IllegalStateException("url == null");
       return new Request(this);
diff --git a/okhttp/src/main/java/okhttp3/Response.java b/okhttp/src/main/java/okhttp3/Response.java
index 810309b013..1da079a34f 100644
--- a/okhttp/src/main/java/okhttp3/Response.java
+++ b/okhttp/src/main/java/okhttp3/Response.java
@@ -68,6 +68,12 @@
     this.priorResponse = builder.priorResponse;
     this.sentRequestAtMillis = builder.sentRequestAtMillis;
     this.receivedResponseAtMillis = builder.receivedResponseAtMillis;
+
+    if (builder.statsData != null) {
+      builder.statsData.response = this;
+      if (builder.statsData.request == null)
+        builder.statsData.request = this.request;
+    }
   }
 
   /**
@@ -298,6 +304,7 @@ public long receivedResponseAtMillis() {
     Response priorResponse;
     long sentRequestAtMillis;
     long receivedResponseAtMillis;
+    StatisticsData statsData;
 
     public Builder() {
       headers = new Headers.Builder();
@@ -423,6 +430,11 @@ public Builder receivedResponseAtMillis(long receivedResponseAtMillis) {
       return this;
     }
 
+    public Builder statisticsData(StatisticsData statsData) {
+      this.statsData = statsData;
+      return this;
+    }
+
     public Response build() {
       if (request == null) throw new IllegalStateException("request == null");
       if (protocol == null) throw new IllegalStateException("protocol == null");
diff --git a/okhttp/src/main/java/okhttp3/StatisticsData.java b/okhttp/src/main/java/okhttp3/StatisticsData.java
new file mode 100644
index 0000000000..da28cf9dc3
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/StatisticsData.java
@@ -0,0 +1,117 @@
+package okhttp3;
+
+public class StatisticsData {
+
+  // All timestamps are in milliseconds since the epoch as returned by System.currentTimeMillis()
+  // It is possible for the DNS query timestamps to be populated without the connect timestamps.
+  // In this case, either connection coalescing of different hostnames to the same IP address was used,
+  // or there was a race between two threads in establishing the connection.
+
+  // Connection establishment
+  public long initiateDNSQueryAtMillis;
+  public long finishDNSQueryAtMillis;
+  public long initiateConnectAtMillis;
+  public long finishConnectAtMillis;
+
+  // Request and Response times. May be zero on abort.
+  public long initiateSendAtMillis;
+  public long finishSendAtMillis;
+  public long receivedHeadersAtMillis;
+  public long receivedBodyAtMillis;
+
+  public long abortAtMillis;        // zero on success
+
+  public long byteCountHeadersSent;
+  public long byteCountBodySent;
+
+  public long byteCountHeadersReceived;
+  public long byteCountBodyReceived;
+
+  public Request request;
+  public Response response;
+
+  public boolean isNewConnection = false;
+  public boolean reported = false;
+
+  public void mergeHeaderStats(StatisticsData otherData) {
+    
+    if (initiateDNSQueryAtMillis == 0)
+      initiateDNSQueryAtMillis = otherData.initiateDNSQueryAtMillis;
+
+    if (initiateConnectAtMillis == 0)
+      initiateConnectAtMillis = otherData.initiateConnectAtMillis;
+
+    if (finishConnectAtMillis == 0)
+      finishConnectAtMillis = otherData.finishConnectAtMillis;
+
+    if (initiateSendAtMillis == 0)
+      initiateSendAtMillis = otherData.initiateSendAtMillis;
+
+    if (finishSendAtMillis == 0)
+      finishSendAtMillis = otherData.finishSendAtMillis;
+
+    if (receivedHeadersAtMillis == 0)
+      receivedHeadersAtMillis = otherData.receivedHeadersAtMillis;
+
+    if (abortAtMillis == 0)
+      abortAtMillis = otherData.abortAtMillis;
+
+    byteCountHeadersSent += otherData.byteCountHeadersSent;
+    byteCountBodySent += otherData.byteCountBodySent;
+
+    byteCountHeadersReceived += otherData.byteCountHeadersReceived;
+
+    if (request == null)
+      request = otherData.request;
+
+    // Response generally isn't populated until the very end, but just in case...
+    if (response == null)
+      response = otherData.response;
+  }
+
+  public void mergeDataStats(StatisticsData otherData) {
+
+    if (otherData.receivedBodyAtMillis != 0)  // Always take the latest
+      receivedBodyAtMillis = otherData.receivedBodyAtMillis;
+
+    if (abortAtMillis == 0)
+      abortAtMillis = otherData.abortAtMillis;
+
+    byteCountBodyReceived += otherData.byteCountBodyReceived;
+  }
+
+  public void reportCompleted(StatisticsObserver observer) {
+    if ( ! reported) {
+      reported = true;
+      if (observer != null)
+        observer.streamCompletion(this);
+    }
+  }
+
+  public void reportAborted(StatisticsObserver observer) {
+    reportAborted(observer, System.currentTimeMillis());
+  }
+
+  public void reportAborted(StatisticsObserver observer, long abortTime) {
+    if ( ! reported) {
+      reported = true;
+      this.abortAtMillis = abortTime;
+      if (observer != null)
+        observer.streamCompletion(this);
+    }
+  }
+
+  public static StatisticsData allocateForReceivedHeaders(long frameRecvTime, long byteCountHeaders) {
+    StatisticsData statsData = new StatisticsData();
+    statsData.receivedHeadersAtMillis = frameRecvTime;
+    statsData.byteCountHeadersReceived = byteCountHeaders;
+    return statsData;
+  }
+
+  public static StatisticsData allocateForReceivedData(long frameRecvTime, long byteCountBody) {
+    StatisticsData statsData = new StatisticsData();
+    statsData.receivedBodyAtMillis = frameRecvTime;
+    statsData.byteCountBodyReceived = byteCountBody;
+    return statsData;
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/StatisticsObserver.java b/okhttp/src/main/java/okhttp3/StatisticsObserver.java
new file mode 100644
index 0000000000..b63272e436
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/StatisticsObserver.java
@@ -0,0 +1,7 @@
+package okhttp3;
+
+public interface StatisticsObserver {
+
+  // Whenever a stream completes, regardless of success or failure.
+  void streamCompletion(StatisticsData statsData);
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
index c6ee1ff8bd..9d5a9de13e 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
@@ -44,6 +44,7 @@
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.Route;
+import okhttp3.StatisticsData;
 import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
 import okhttp3.internal.Version;
@@ -120,7 +121,8 @@ public static RealConnection testConnection(
   }
 
   public void connect(
-      int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled) {
+      int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled,
+      StatisticsData statsData) {
     if (protocol != null) throw new IllegalStateException("already connected");
 
     RouteException routeException = null;
@@ -142,7 +144,7 @@ public void connect(
     while (true) {
       try {
         if (route.requiresTunnel()) {
-          connectTunnel(connectTimeout, readTimeout, writeTimeout);
+          connectTunnel(connectTimeout, readTimeout, writeTimeout, statsData);
         } else {
           connectSocket(connectTimeout, readTimeout);
         }
@@ -182,7 +184,7 @@ public void connect(
    * Does all the work to build an HTTPS connection over a proxy tunnel. The catch here is that a
    * proxy server can issue an auth challenge and then close the connection.
    */
-  private void connectTunnel(int connectTimeout, int readTimeout, int writeTimeout)
+  private void connectTunnel(int connectTimeout, int readTimeout, int writeTimeout, StatisticsData statsData)
       throws IOException {
     Request tunnelRequest = createTunnelRequest();
     HttpUrl url = tunnelRequest.url();
@@ -194,7 +196,7 @@ private void connectTunnel(int connectTimeout, int readTimeout, int writeTimeout
       }
 
       connectSocket(connectTimeout, readTimeout);
-      tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url);
+      tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url, statsData);
 
       if (tunnelRequest == null) break; // Tunnel successfully created.
 
@@ -311,11 +313,11 @@ private void connectTls(ConnectionSpecSelector connectionSpecSelector) throws IO
    * the proxy connection. This may need to be retried if the proxy requires authorization.
    */
   private Request createTunnel(int readTimeout, int writeTimeout, Request tunnelRequest,
-      HttpUrl url) throws IOException {
+      HttpUrl url, StatisticsData statsData) throws IOException {
     // Make an SSL Tunnel on the first message pair of each SSL + proxy connection.
     String requestLine = "CONNECT " + Util.hostHeader(url, true) + " HTTP/1.1";
     while (true) {
-      Http1Codec tunnelConnection = new Http1Codec(null, null, source, sink);
+      Http1Codec tunnelConnection = new Http1Codec(null, null, source, sink, statsData);
       source.timeout().timeout(readTimeout, MILLISECONDS);
       sink.timeout().timeout(writeTimeout, MILLISECONDS);
       tunnelConnection.writeRequest(tunnelRequest.headers(), requestLine);
@@ -442,7 +444,7 @@ public HttpCodec newCodec(
       socket.setSoTimeout(client.readTimeoutMillis());
       source.timeout().timeout(client.readTimeoutMillis(), MILLISECONDS);
       sink.timeout().timeout(client.writeTimeoutMillis(), MILLISECONDS);
-      return new Http1Codec(client, streamAllocation, source, sink);
+      return new Http1Codec(client, streamAllocation, source, sink, streamAllocation.statisticsData());
     }
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
index 211181961f..5671483e63 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
@@ -23,6 +23,7 @@
 import okhttp3.ConnectionPool;
 import okhttp3.OkHttpClient;
 import okhttp3.Route;
+import okhttp3.StatisticsData;
 import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
 import okhttp3.internal.http.HttpCodec;
@@ -82,12 +83,14 @@
   private boolean released;
   private boolean canceled;
   private HttpCodec codec;
+  private StatisticsData statsData;
 
   public StreamAllocation(ConnectionPool connectionPool, Address address, Object callStackTrace) {
     this.connectionPool = connectionPool;
     this.address = address;
     this.routeSelector = new RouteSelector(address, routeDatabase());
     this.callStackTrace = callStackTrace;
+    statsData = new StatisticsData();
   }
 
   public HttpCodec newStream(OkHttpClient client, boolean doExtensiveHealthChecks) {
@@ -110,6 +113,10 @@ public HttpCodec newStream(OkHttpClient client, boolean doExtensiveHealthChecks)
     }
   }
 
+  public StatisticsData statisticsData() { return statsData; }
+
+  public void resetStatistics() { statsData = new StatisticsData(); }
+
   /**
    * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated
    * until a healthy connection is found.
@@ -166,11 +173,15 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
       selectedRoute = route;
     }
 
+    statsData.initiateDNSQueryAtMillis = System.currentTimeMillis();
+
     // If we need a route, make one. This is a blocking operation.
     if (selectedRoute == null) {
       selectedRoute = routeSelector.next();
     }
 
+    statsData.finishDNSQueryAtMillis = System.currentTimeMillis();
+
     RealConnection result;
     synchronized (connectionPool) {
       if (canceled) throw new IOException("Canceled");
@@ -188,9 +199,12 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
       acquire(result);
     }
 
+    statsData.initiateConnectAtMillis = statsData.finishDNSQueryAtMillis;
     // Do TCP + TLS handshakes. This is a blocking operation.
-    result.connect(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled);
+    result.connect(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled, statsData);
     routeDatabase().connected(result.route());
+    statsData.finishConnectAtMillis = System.currentTimeMillis();
+    statsData.isNewConnection = true;
 
     Socket socket = null;
     synchronized (connectionPool) {
diff --git a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
index 3bc47183eb..0d5cfdc118 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
@@ -80,6 +80,7 @@ public CallServerInterceptor(boolean forWebSocket) {
         .handshake(streamAllocation.connection().handshake())
         .sentRequestAtMillis(sentRequestMillis)
         .receivedResponseAtMillis(System.currentTimeMillis())
+        .statisticsData(httpCodec.statisticsData())
         .build();
 
     int code = response.code();
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java b/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java
index ad9759acce..9cad87a018 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java
@@ -19,6 +19,7 @@
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.ResponseBody;
+import okhttp3.StatisticsData;
 import okio.Sink;
 
 /** Encodes HTTP requests and decodes HTTP responses. */
@@ -58,4 +59,7 @@
    * That may happen later by the connection pool thread.
    */
   void cancel();
+
+  /** Returns the statistics data allocated for this codec. */
+  StatisticsData statisticsData();
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
index 398f29d661..b7911d4de6 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
@@ -89,7 +89,19 @@ public Response proceed(Request request, StreamAllocation streamAllocation, Http
     RealInterceptorChain next = new RealInterceptorChain(
         interceptors, streamAllocation, httpCodec, connection, index + 1, request);
     Interceptor interceptor = interceptors.get(index);
-    Response response = interceptor.intercept(next);
+
+    if (streamAllocation != null && streamAllocation.statisticsData() != null)
+      streamAllocation.statisticsData().request = request;
+
+    Response response;
+    boolean succeeded = false;
+    try {
+      response = interceptor.intercept(next);
+      succeeded = true;
+    } finally {
+      if ( ! succeeded && streamAllocation != null && streamAllocation.statisticsData() != null)
+        streamAllocation.statisticsData().reportAborted(request.observer());
+    }
 
     // Confirm that the next interceptor made its required call to chain.proceed().
     if (httpCodec != null && index + 1 < interceptors.size() && next.calls != 1) {
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
index 792ddc9299..2de4a16896 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
@@ -177,6 +177,9 @@ public StreamAllocation streamAllocation() {
       } else if (streamAllocation.codec() != null) {
         throw new IllegalStateException("Closing the body of " + response
             + " didn't close its backing stream. Bad interceptor?");
+      } else {
+        // We're starting a new request on the same stream. Reset statistics.
+        streamAllocation.resetStatistics();
       }
 
       request = followUp;
diff --git a/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
index 625c173bf3..2ff1cff015 100644
--- a/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
@@ -24,6 +24,8 @@
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.ResponseBody;
+import okhttp3.StatisticsData;
+import okhttp3.StatisticsObserver;
 import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
 import okhttp3.internal.connection.RealConnection;
@@ -83,13 +85,18 @@
   final BufferedSource source;
   final BufferedSink sink;
   int state = STATE_IDLE;
+  final StatisticsData statsData;
+  StatisticsObserver observer;
 
   public Http1Codec(OkHttpClient client, StreamAllocation streamAllocation, BufferedSource source,
-      BufferedSink sink) {
+      BufferedSink sink, StatisticsData statsData) {
     this.client = client;
     this.streamAllocation = streamAllocation;
     this.source = source;
     this.sink = sink;
+    if (statsData == null) // shouldn't be, but maybe from test code.
+      statsData = new StatisticsData();
+    this.statsData = statsData;
   }
 
   @Override public Sink createRequestBody(Request request, long contentLength) {
@@ -112,6 +119,11 @@ public Http1Codec(OkHttpClient client, StreamAllocation streamAllocation, Buffer
     if (connection != null) connection.cancel();
   }
 
+  @Override
+  public StatisticsData statisticsData() {
+    return statsData;
+  }
+
   /**
    * Prepares the HTTP headers and sends them to the server.
    *
@@ -123,6 +135,7 @@ public Http1Codec(OkHttpClient client, StreamAllocation streamAllocation, Buffer
    * header field receives the proper value.
    */
   @Override public void writeRequestHeaders(Request request) throws IOException {
+    observer = request.observer();
     String requestLine = RequestLine.get(
         request, streamAllocation.connection().route().proxy().type());
     writeRequest(request.headers(), requestLine);
@@ -164,11 +177,14 @@ public boolean isClosed() {
 
   @Override public void finishRequest() throws IOException {
     sink.flush();
+    statsData.finishSendAtMillis = System.currentTimeMillis();
   }
 
   /** Returns bytes of a request header for sending on an HTTP transport. */
   public void writeRequest(Headers headers, String requestLine) throws IOException {
     if (state != STATE_IDLE) throw new IllegalStateException("state: " + state);
+    long origSize = sink.buffer().size();
+    statsData.initiateSendAtMillis = System.currentTimeMillis();
     sink.writeUtf8(requestLine).writeUtf8("\r\n");
     for (int i = 0, size = headers.size(); i < size; i++) {
       sink.writeUtf8(headers.name(i))
@@ -177,6 +193,10 @@ public void writeRequest(Headers headers, String requestLine) throws IOException
           .writeUtf8("\r\n");
     }
     sink.writeUtf8("\r\n");
+    long newSize = sink.buffer().size();
+    long len = newSize - origSize;
+    if (len > 0)
+      statsData.byteCountHeadersSent += len;
     state = STATE_OPEN_REQUEST_BODY;
   }
 
@@ -186,7 +206,13 @@ public void writeRequest(Headers headers, String requestLine) throws IOException
     }
 
     try {
+      long origSize = source.buffer().size();
       StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict());
+      statsData.receivedHeadersAtMillis = System.currentTimeMillis();
+      long newSize = source.buffer().size();
+      long len = newSize - origSize;
+      if (len > 0)
+        statsData.byteCountHeadersReceived += len;
 
       Response.Builder responseBuilder = new Response.Builder()
           .protocol(statusLine.protocol)
@@ -211,10 +237,15 @@ public void writeRequest(Headers headers, String requestLine) throws IOException
   /** Reads headers or trailers. */
   public Headers readHeaders() throws IOException {
     Headers.Builder headers = new Headers.Builder();
+    long origSize = source.buffer().size();
     // parse the result headers until the first blank line
     for (String line; (line = source.readUtf8LineStrict()).length() != 0; ) {
       Internal.instance.addLenient(headers, line);
     }
+    long newSize = source.buffer().size();
+    long len = newSize - origSize;
+    if (len > 0)
+      statsData.byteCountHeadersReceived += len;
     return headers.build();
   }
 
@@ -285,6 +316,7 @@ void detachTimeout(ForwardingTimeout timeout) {
       }
       sink.write(source, byteCount);
       bytesRemaining -= byteCount;
+      statsData.byteCountBodySent += byteCount; // only track what we've actually written.
     }
 
     @Override public void flush() throws IOException {
@@ -320,10 +352,18 @@ void detachTimeout(ForwardingTimeout timeout) {
       if (closed) throw new IllegalStateException("closed");
       if (byteCount == 0) return;
 
+      long origSize = sink.buffer().size();
       sink.writeHexadecimalUnsignedLong(byteCount);
+      long newSize = sink.buffer().size();
+      long len = newSize - origSize;
+      if (len > 0)
+        statsData.byteCountBodySent += len;
+
       sink.writeUtf8("\r\n");
       sink.write(source, byteCount);
       sink.writeUtf8("\r\n");
+
+      statsData.byteCountBodySent += byteCount + 4;
     }
 
     @Override public synchronized void flush() throws IOException {
@@ -358,10 +398,18 @@ protected final void endOfInput(boolean reuseConnection) throws IOException {
 
       detachTimeout(timeout);
 
+      long now = System.currentTimeMillis();
+      if (reuseConnection)
+        statsData.receivedBodyAtMillis = now;
+      else
+        statsData.abortAtMillis = now;
+
       state = STATE_CLOSED;
       if (streamAllocation != null) {
         streamAllocation.streamFinished(!reuseConnection, Http1Codec.this);
       }
+
+      statsData.reportCompleted(observer);
     }
   }
 
@@ -387,6 +435,8 @@ public FixedLengthSource(long length) throws IOException {
         throw new ProtocolException("unexpected end of stream");
       }
 
+      statsData.byteCountBodyReceived += read;
+
       bytesRemaining -= read;
       if (bytesRemaining == 0) {
         endOfInput(true);
@@ -431,6 +481,9 @@ public FixedLengthSource(long length) throws IOException {
         endOfInput(false); // The server didn't supply the promised chunk length.
         throw new ProtocolException("unexpected end of stream");
       }
+
+      statsData.byteCountBodyReceived += read;
+
       bytesRemainingInChunk -= read;
       return read;
     }
@@ -485,6 +538,7 @@ private void readChunkSize() throws IOException {
         endOfInput(true);
         return -1;
       }
+      statsData.byteCountBodyReceived += read;
       return read;
     }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java b/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
index a28698bf01..768876b689 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
@@ -114,12 +114,14 @@ private Hpack() {
   // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-3.1
   static final class Reader {
 
-    private final List<Header> headerList = new ArrayList<>();
+    private List<Header> headerList = new ArrayList<>();
     private final BufferedSource source;
 
     private final int headerTableSizeSetting;
     private int maxDynamicTableByteCount;
 
+    private long totalBytesRead;
+
     // Visible for testing.
     Header[] dynamicTable = new Header[8];
     // Array is populated back to front, so new entries always have lowest index.
@@ -137,6 +139,8 @@ private Hpack() {
       this.source = Okio.buffer(source);
     }
 
+    long totalBytesRead() { return totalBytesRead; }
+
     int maxDynamicTableByteCount() {
       return maxDynamicTableByteCount;
     }
@@ -182,7 +186,7 @@ private int evictToRecoverBytes(int bytesToRecover) {
      */
     void readHeaders() throws IOException {
       while (!source.exhausted()) {
-        int b = source.readByte() & 0xff;
+        int b = readByte();
         if (b == 0x80) { // 10000000
           throw new IOException("index == 0");
         } else if ((b & 0x80) == 0x80) { // 1NNNNNNN
@@ -210,8 +214,9 @@ void readHeaders() throws IOException {
     }
 
     public List<Header> getAndResetHeaderList() {
-      List<Header> result = new ArrayList<>(headerList);
-      headerList.clear();
+      List<Header> result = headerList;
+      headerList = new ArrayList<>();
+      totalBytesRead = 0;
       return result;
     }
 
@@ -307,7 +312,9 @@ private void insertIntoDynamicTable(int index, Header entry) {
     }
 
     private int readByte() throws IOException {
-      return source.readByte() & 0xff;
+      int b = source.readByte() & 0xff;
+      totalBytesRead += 1;
+      return b;
     }
 
     int readInt(int firstByte, int prefixMask) throws IOException {
@@ -338,11 +345,15 @@ ByteString readByteString() throws IOException {
       boolean huffmanDecode = (firstByte & 0x80) == 0x80; // 1NNNNNNN
       int length = readInt(firstByte, PREFIX_7_BITS);
 
+      ByteString bs;
+
       if (huffmanDecode) {
-        return ByteString.of(Huffman.get().decode(source.readByteArray(length)));
+        bs = ByteString.of(Huffman.get().decode(source.readByteArray(length)));
       } else {
-        return source.readByteString(length);
+        bs = source.readByteString(length);
       }
+      totalBytesRead += length;
+      return bs;
     }
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
index 61680d565e..e7911e8be9 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
@@ -27,6 +27,7 @@
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.ResponseBody;
+import okhttp3.StatisticsData;
 import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
 import okhttp3.internal.connection.StreamAllocation;
@@ -86,12 +87,14 @@
   final StreamAllocation streamAllocation;
   private final Http2Connection connection;
   private Http2Stream stream;
+  private StatisticsData statsData;
 
   public Http2Codec(
       OkHttpClient client, StreamAllocation streamAllocation, Http2Connection connection) {
     this.client = client;
     this.streamAllocation = streamAllocation;
     this.connection = connection;
+    this.statsData = streamAllocation.statisticsData();
   }
 
   @Override public Sink createRequestBody(Request request, long contentLength) {
@@ -103,7 +106,7 @@ public Http2Codec(
 
     boolean hasRequestBody = request.body() != null;
     List<Header> requestHeaders = http2HeadersList(request);
-    stream = connection.newStream(requestHeaders, hasRequestBody);
+    stream = connection.newStream(requestHeaders, hasRequestBody, statsData, request.observer());
     stream.readTimeout().timeout(client.readTimeoutMillis(), TimeUnit.MILLISECONDS);
     stream.writeTimeout().timeout(client.writeTimeoutMillis(), TimeUnit.MILLISECONDS);
   }
@@ -114,6 +117,7 @@ public Http2Codec(
 
   @Override public void finishRequest() throws IOException {
     stream.getSink().close();
+    statsData.finishSendAtMillis = System.currentTimeMillis();
   }
 
   @Override public Response.Builder readResponseHeaders(boolean expectContinue) throws IOException {
@@ -189,6 +193,11 @@ public Http2Codec(
     if (stream != null) stream.closeLater(ErrorCode.CANCEL);
   }
 
+  @Override
+  public StatisticsData statisticsData() {
+    return statsData;
+  }
+
   class StreamFinishingSource extends ForwardingSource {
     public StreamFinishingSource(Source delegate) {
       super(delegate);
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
index fc89d0f10b..7b02551ca3 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
@@ -31,6 +31,8 @@
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 import okhttp3.Protocol;
+import okhttp3.StatisticsData;
+import okhttp3.StatisticsObserver;
 import okhttp3.internal.NamedRunnable;
 import okhttp3.internal.Util;
 import okhttp3.internal.platform.Platform;
@@ -193,7 +195,7 @@ public synchronized int maxConcurrentStreams() {
   public Http2Stream pushStream(int associatedStreamId, List<Header> requestHeaders, boolean out)
       throws IOException {
     if (client) throw new IllegalStateException("Client cannot push requests.");
-    return newStream(associatedStreamId, requestHeaders, out);
+    return newStream(associatedStreamId, requestHeaders, out, new StatisticsData(), null);
   }
 
   /**
@@ -201,12 +203,16 @@ public Http2Stream pushStream(int associatedStreamId, List<Header> requestHeader
    * @param out true to create an output stream that we can use to send data to the remote peer.
    * Corresponds to {@code FLAG_FIN}.
    */
-  public Http2Stream newStream(List<Header> requestHeaders, boolean out) throws IOException {
-    return newStream(0, requestHeaders, out);
+  Http2Stream newStream(List<Header> requestHeaders, boolean out) throws IOException {
+    return newStream(requestHeaders, out, new StatisticsData(), null);
+  }
+
+  public Http2Stream newStream(List<Header> requestHeaders, boolean out, StatisticsData statsData, StatisticsObserver observer) throws IOException {
+    return newStream(0, requestHeaders, out, statsData, observer);
   }
 
   private Http2Stream newStream(
-      int associatedStreamId, List<Header> requestHeaders, boolean out) throws IOException {
+      int associatedStreamId, List<Header> requestHeaders, boolean out, StatisticsData statsData, StatisticsObserver observer) throws IOException {
     boolean outFinished = !out;
     boolean inFinished = false;
     boolean flushHeaders;
@@ -220,18 +226,18 @@ private Http2Stream newStream(
         }
         streamId = nextStreamId;
         nextStreamId += 2;
-        stream = new Http2Stream(streamId, this, outFinished, inFinished, requestHeaders);
+        stream = new Http2Stream(streamId, this, outFinished, inFinished, requestHeaders, statsData, observer);
         flushHeaders = !out || bytesLeftInWriteWindow == 0L || stream.bytesLeftInWriteWindow == 0L;
         if (stream.isOpen()) {
           streams.put(streamId, stream);
         }
       }
       if (associatedStreamId == 0) {
-        writer.synStream(outFinished, streamId, associatedStreamId, requestHeaders);
+        writer.synStream(outFinished, streamId, associatedStreamId, requestHeaders, statsData);
       } else if (client) {
         throw new IllegalArgumentException("client streams shouldn't have associated stream IDs");
       } else { // HTTP/2 has a PUSH_PROMISE frame.
-        writer.pushPromise(associatedStreamId, streamId, requestHeaders);
+        writer.pushPromise(associatedStreamId, streamId, requestHeaders, statsData);
       }
     }
 
@@ -242,9 +248,9 @@ private Http2Stream newStream(
     return stream;
   }
 
-  void writeSynReply(int streamId, boolean outFinished, List<Header> alternating)
+  void writeSynReply(int streamId, boolean outFinished, List<Header> alternating, StatisticsData statsData)
       throws IOException {
-    writer.synReply(outFinished, streamId, alternating);
+    writer.synReply(outFinished, streamId, alternating, statsData);
   }
 
   /**
@@ -259,10 +265,10 @@ void writeSynReply(int streamId, boolean outFinished, List<Header> alternating)
    * <p>Zero {@code byteCount} writes are not subject to flow control and will not block. The only
    * use case for zero {@code byteCount} is closing a flushed output stream.
    */
-  public void writeData(int streamId, boolean outFinished, Buffer buffer, long byteCount)
+  public void writeData(int streamId, boolean outFinished, Buffer buffer, long byteCount, StatisticsData statsData)
       throws IOException {
     if (byteCount == 0) { // Empty data frames are not flow-controlled.
-      writer.data(outFinished, streamId, buffer, 0);
+      writer.data(outFinished, streamId, buffer, 0, statsData);
       return;
     }
 
@@ -288,7 +294,7 @@ public void writeData(int streamId, boolean outFinished, Buffer buffer, long byt
       }
 
       byteCount -= toWrite;
-      writer.data(outFinished && byteCount == 0, streamId, buffer, toWrite);
+      writer.data(outFinished && byteCount == 0, streamId, buffer, toWrite, statsData);
     }
   }
 
@@ -508,6 +514,7 @@ public synchronized boolean isShutdown() {
     Listener listener = Listener.REFUSE_INCOMING_STREAMS;
     PushObserver pushObserver = PushObserver.CANCEL;
     boolean client;
+    StatisticsData statsData;
 
     /**
      * @param client true if this peer initiated the connection; false if this peer accepted the
@@ -541,6 +548,11 @@ public Builder pushObserver(PushObserver pushObserver) {
       return this;
     }
 
+    public Builder statisticsData(StatisticsData statsData) {
+      this.statsData = statsData;
+      return this;
+    }
+
     public Http2Connection build() throws IOException {
       return new Http2Connection(this);
     }
@@ -579,7 +591,7 @@ public Http2Connection build() throws IOException {
       }
     }
 
-    @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
+    @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length, StatisticsData statsData)
         throws IOException {
       if (pushedStream(streamId)) {
         pushDataLater(streamId, source, length, inFinished);
@@ -591,6 +603,7 @@ public Http2Connection build() throws IOException {
         source.skip(length);
         return;
       }
+      dataStream.mergeDataStats(statsData);
       dataStream.receiveData(source, length);
       if (inFinished) {
         dataStream.receiveFin();
@@ -598,7 +611,7 @@ public Http2Connection build() throws IOException {
     }
 
     @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,
-        List<Header> headerBlock) {
+        List<Header> headerBlock, StatisticsData statsData) {
       if (pushedStream(streamId)) {
         pushHeadersLater(streamId, headerBlock, inFinished);
         return;
@@ -619,7 +632,7 @@ public Http2Connection build() throws IOException {
 
           // Create a stream.
           final Http2Stream newStream = new Http2Stream(streamId, Http2Connection.this,
-              false, inFinished, headerBlock);
+              false, inFinished, headerBlock, statsData, null);
           lastGoodStreamId = streamId;
           streams.put(streamId, newStream);
           executor.execute(new NamedRunnable("OkHttp %s stream %d", hostname, streamId) {
@@ -640,6 +653,7 @@ public Http2Connection build() throws IOException {
       }
 
       // Update an existing stream.
+      stream.mergeHeaderStats(statsData);
       stream.receiveHeaders(headerBlock);
       if (inFinished) stream.receiveFin();
     }
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java
index c6fd4ccdac..686a59fb03 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java
@@ -19,6 +19,8 @@
 import java.io.IOException;
 import java.util.List;
 import java.util.logging.Logger;
+
+import okhttp3.StatisticsData;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.ByteString;
@@ -63,6 +65,10 @@
   private final ContinuationSource continuation;
   private final boolean client;
 
+  private long totalBytesRead;
+  private long frameInitialTBR;
+  private long frameRecvTime;
+
   // Visible for testing.
   final Hpack.Reader hpackReader;
 
@@ -74,6 +80,9 @@ public Http2Reader(BufferedSource source, boolean client) {
     this.hpackReader = new Hpack.Reader(4096, continuation);
   }
 
+  public long totalBytesRead() { return totalBytesRead; }
+  public long frameBytesRead() { return totalBytesRead - frameInitialTBR; }
+
   public void readConnectionPreface(Handler handler) throws IOException {
     if (client) {
       // The client reads the initial SETTINGS frame.
@@ -83,6 +92,7 @@ public void readConnectionPreface(Handler handler) throws IOException {
     } else {
       // The server reads the CONNECTION_PREFACE byte string.
       ByteString connectionPreface = source.readByteString(CONNECTION_PREFACE.size());
+      totalBytesRead += CONNECTION_PREFACE.size();
       if (logger.isLoggable(FINE)) logger.fine(format("<< CONNECTION %s", connectionPreface.hex()));
       if (!CONNECTION_PREFACE.equals(connectionPreface)) {
         throw ioException("Expected a connection header but was %s", connectionPreface.utf8());
@@ -97,6 +107,8 @@ public boolean nextFrame(boolean requireSettings, Handler handler) throws IOExce
       return false; // This might be a normal socket close.
     }
 
+    frameInitialTBR = totalBytesRead;
+
     //  0                   1                   2                   3
     //  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     // +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
@@ -109,15 +121,19 @@ public boolean nextFrame(boolean requireSettings, Handler handler) throws IOExce
     // |                   Frame Payload (0...)                      ...
     // +---------------------------------------------------------------+
     int length = readMedium(source);
+    frameRecvTime = System.currentTimeMillis();
     if (length < 0 || length > INITIAL_MAX_FRAME_SIZE) {
       throw ioException("FRAME_SIZE_ERROR: %s", length);
     }
     byte type = (byte) (source.readByte() & 0xff);
+    totalBytesRead += 1;
     if (requireSettings && type != TYPE_SETTINGS) {
       throw ioException("Expected a SETTINGS frame but was %s", type);
     }
     byte flags = (byte) (source.readByte() & 0xff);
+    totalBytesRead += 1;
     int streamId = (source.readInt() & 0x7fffffff); // Ignore reserved bit.
+    totalBytesRead += 4;
     if (logger.isLoggable(FINE)) logger.fine(frameLog(true, streamId, length, type, flags));
 
     switch (type) {
@@ -170,7 +186,12 @@ private void readHeaders(Handler handler, int length, byte flags, int streamId)
 
     boolean endStream = (flags & FLAG_END_STREAM) != 0;
 
-    short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
+    short padding = 0;
+
+    if ((flags & FLAG_PADDED) != 0) {
+      padding = (short) (source.readByte() & 0xff);
+      totalBytesRead += 1;
+    }
 
     if ((flags & FLAG_PRIORITY) != 0) {
       readPriority(handler, streamId);
@@ -181,7 +202,8 @@ private void readHeaders(Handler handler, int length, byte flags, int streamId)
 
     List<Header> headerBlock = readHeaderBlock(length, padding, flags, streamId);
 
-    handler.headers(endStream, streamId, -1, headerBlock);
+    handler.headers(endStream, streamId, -1, headerBlock,
+      StatisticsData.allocateForReceivedHeaders(frameRecvTime, frameBytesRead()));
   }
 
   private List<Header> readHeaderBlock(int length, short padding, byte flags, int streamId)
@@ -194,6 +216,7 @@ private void readHeaders(Handler handler, int length, byte flags, int streamId)
     // TODO: Concat multi-value headers with 0x0, except COOKIE, which uses 0x3B, 0x20.
     // http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-8.1.2.5
     hpackReader.readHeaders();
+    totalBytesRead += hpackReader.totalBytesRead();
     return hpackReader.getAndResetHeaderList();
   }
 
@@ -208,10 +231,16 @@ private void readData(Handler handler, int length, byte flags, int streamId)
       throw ioException("PROTOCOL_ERROR: FLAG_COMPRESSED without SETTINGS_COMPRESS_DATA");
     }
 
-    short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
+    short padding = 0;
+    if ((flags & FLAG_PADDED) != 0) {
+      padding = (short) (source.readByte() & 0xff);
+      totalBytesRead += 1;
+    }
+
     length = lengthWithoutPadding(length, flags, padding);
 
-    handler.data(inFinished, streamId, source, length);
+    handler.data(inFinished, streamId, source, length,
+      StatisticsData.allocateForReceivedData(frameRecvTime, frameBytesRead()));
     source.skip(padding);
   }
 
@@ -224,9 +253,11 @@ private void readPriority(Handler handler, int length, byte flags, int streamId)
 
   private void readPriority(Handler handler, int streamId) throws IOException {
     int w1 = source.readInt();
+    totalBytesRead += 4;
     boolean exclusive = (w1 & 0x80000000) != 0;
     int streamDependency = (w1 & 0x7fffffff);
     int weight = (source.readByte() & 0xff) + 1;
+    totalBytesRead += 1;
     handler.priority(streamId, streamDependency, weight, exclusive);
   }
 
@@ -235,6 +266,7 @@ private void readRstStream(Handler handler, int length, byte flags, int streamId
     if (length != 4) throw ioException("TYPE_RST_STREAM length: %d != 4", length);
     if (streamId == 0) throw ioException("TYPE_RST_STREAM streamId == 0");
     int errorCodeInt = source.readInt();
+    totalBytesRead += 4;
     ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
     if (errorCode == null) {
       throw ioException("TYPE_RST_STREAM unexpected error code: %d", errorCodeInt);
@@ -255,7 +287,9 @@ private void readSettings(Handler handler, int length, byte flags, int streamId)
     Settings settings = new Settings();
     for (int i = 0; i < length; i += 6) {
       short id = source.readShort();
+      totalBytesRead += 2;
       int value = source.readInt();
+      totalBytesRead += 4;
 
       switch (id) {
         case 1: // SETTINGS_HEADER_TABLE_SIZE
@@ -294,8 +328,13 @@ private void readPushPromise(Handler handler, int length, byte flags, int stream
     if (streamId == 0) {
       throw ioException("PROTOCOL_ERROR: TYPE_PUSH_PROMISE streamId == 0");
     }
-    short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
+    short padding = 0;
+    if ((flags & FLAG_PADDED) != 0) {
+      padding = (short) (source.readByte() & 0xff);
+      totalBytesRead += 1;
+    }
     int promisedStreamId = source.readInt() & 0x7fffffff;
+    totalBytesRead += 4;
     length -= 4; // account for above read.
     length = lengthWithoutPadding(length, flags, padding);
     List<Header> headerBlock = readHeaderBlock(length, padding, flags, streamId);
@@ -307,7 +346,9 @@ private void readPing(Handler handler, int length, byte flags, int streamId)
     if (length != 8) throw ioException("TYPE_PING length != 8: %s", length);
     if (streamId != 0) throw ioException("TYPE_PING streamId != 0");
     int payload1 = source.readInt();
+    totalBytesRead += 4;
     int payload2 = source.readInt();
+    totalBytesRead += 4;
     boolean ack = (flags & FLAG_ACK) != 0;
     handler.ping(ack, payload1, payload2);
   }
@@ -317,7 +358,9 @@ private void readGoAway(Handler handler, int length, byte flags, int streamId)
     if (length < 8) throw ioException("TYPE_GOAWAY length < 8: %s", length);
     if (streamId != 0) throw ioException("TYPE_GOAWAY streamId != 0");
     int lastStreamId = source.readInt();
+    totalBytesRead += 4;
     int errorCodeInt = source.readInt();
+    totalBytesRead += 4;
     int opaqueDataLength = length - 8;
     ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
     if (errorCode == null) {
@@ -326,6 +369,7 @@ private void readGoAway(Handler handler, int length, byte flags, int streamId)
     ByteString debugData = EMPTY;
     if (opaqueDataLength > 0) { // Must read debug data in order to not corrupt the connection.
       debugData = source.readByteString(opaqueDataLength);
+      totalBytesRead += opaqueDataLength;
     }
     handler.goAway(lastStreamId, errorCode, debugData);
   }
@@ -334,6 +378,7 @@ private void readWindowUpdate(Handler handler, int length, byte flags, int strea
       throws IOException {
     if (length != 4) throw ioException("TYPE_WINDOW_UPDATE length !=4: %s", length);
     long increment = (source.readInt() & 0x7fffffffL);
+    totalBytesRead += 4;
     if (increment == 0) throw ioException("windowSizeIncrement was 0", increment);
     handler.windowUpdate(streamId, increment);
   }
@@ -369,7 +414,9 @@ public ContinuationSource(BufferedSource source) {
         // TODO: test case for empty continuation header?
       }
 
-      long read = source.read(sink, Math.min(byteCount, left));
+      final long amt = Math.min(byteCount, left);
+      long read = source.read(sink, amt);
+      // We track the number of bytes read from the Hpack.Reader
       if (read == -1) return -1;
       left -= read;
       return read;
@@ -411,7 +458,7 @@ static int lengthWithoutPadding(int length, byte flags, short padding)
   }
 
   interface Handler {
-    void data(boolean inFinished, int streamId, BufferedSource source, int length)
+    void data(boolean inFinished, int streamId, BufferedSource source, int length, StatisticsData statsData)
         throws IOException;
 
     /**
@@ -423,7 +470,7 @@ void data(boolean inFinished, int streamId, BufferedSource source, int length)
      * @param associatedStreamId the stream that triggered the sender to create this stream.
      */
     void headers(boolean inFinished, int streamId, int associatedStreamId,
-        List<Header> headerBlock);
+        List<Header> headerBlock, StatisticsData statsData);
 
     void rstStream(int streamId, ErrorCode errorCode);
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
index 19ac954d7e..4fbe00a112 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
@@ -21,6 +21,8 @@
 import java.net.SocketTimeoutException;
 import java.util.ArrayList;
 import java.util.List;
+import okhttp3.StatisticsData;
+import okhttp3.StatisticsObserver;
 import okio.AsyncTimeout;
 import okio.Buffer;
 import okio.BufferedSource;
@@ -65,6 +67,9 @@
   final StreamTimeout readTimeout = new StreamTimeout();
   final StreamTimeout writeTimeout = new StreamTimeout();
 
+  private StatisticsObserver observer;
+  private final StatisticsData statsData; // This instance is shared across several objects.
+
   /**
    * The reason why this stream was abnormally closed. If there are multiple reasons to abnormally
    * close this stream (such as both peers closing it near-simultaneously) then this is the first
@@ -73,7 +78,7 @@
   ErrorCode errorCode = null;
 
   Http2Stream(int id, Http2Connection connection, boolean outFinished, boolean inFinished,
-      List<Header> requestHeaders) {
+      List<Header> requestHeaders, StatisticsData statsData, StatisticsObserver observer) {
     if (connection == null) throw new NullPointerException("connection == null");
     if (requestHeaders == null) throw new NullPointerException("requestHeaders == null");
     this.id = id;
@@ -85,12 +90,22 @@
     this.source.finished = inFinished;
     this.sink.finished = outFinished;
     this.requestHeaders = requestHeaders;
+    this.observer = observer;
+    this.statsData = statsData;
   }
 
   public int getId() {
     return id;
   }
 
+  public void mergeHeaderStats(StatisticsData otherData) {
+    statsData.mergeHeaderStats(otherData);
+  }
+
+  public void mergeDataStats(StatisticsData otherData) {
+    statsData.mergeDataStats(otherData);
+  }
+
   /**
    * Returns true if this stream is open. A stream is open until either:
    *
@@ -180,7 +195,7 @@ public void sendResponseHeaders(List<Header> responseHeaders, boolean out) throw
         outFinished = true;
       }
     }
-    connection.writeSynReply(id, outFinished, responseHeaders);
+    connection.writeSynReply(id, outFinished, responseHeaders, statsData);
 
     if (outFinished) {
       connection.flush();
@@ -292,6 +307,8 @@ void receiveFin() {
     if (!open) {
       connection.removeStream(id);
     }
+
+    statsData.reportCompleted(observer);
   }
 
   synchronized void receiveRstStream(ErrorCode errorCode) {
@@ -402,9 +419,10 @@ void receive(BufferedSource in, long byteCount) throws IOException {
         // Fill the receive buffer without holding any locks.
         long read = in.read(receiveBuffer, byteCount);
         if (read == -1) throw new EOFException();
+        statsData.byteCountBodyReceived += read;
         byteCount -= read;
 
-        // Move the received data to the read buffer to the reader can read it.
+        // Move the received data to the read buffer so the reader can read it.
         synchronized (Http2Stream.this) {
           boolean wasEmpty = readBuffer.size() == 0;
           readBuffer.writeAll(receiveBuffer);
@@ -505,7 +523,7 @@ private void emitFrame(boolean outFinished) throws IOException {
 
       writeTimeout.enter();
       try {
-        connection.writeData(id, outFinished && toWrite == sendBuffer.size(), sendBuffer, toWrite);
+        connection.writeData(id, outFinished && toWrite == sendBuffer.size(), sendBuffer, toWrite, statsData);
       } finally {
         writeTimeout.exitAndThrowIfTimedOut();
       }
@@ -539,7 +557,7 @@ private void emitFrame(boolean outFinished) throws IOException {
           }
         } else {
           // Send an empty frame just so we can set the END_STREAM flag.
-          connection.writeData(id, true, null, 0);
+          connection.writeData(id, true, null, 0, statsData);
         }
       }
       synchronized (Http2Stream.this) {
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.java
index 7490b09ba0..d8415cfc16 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.java
@@ -19,6 +19,7 @@
 import java.io.IOException;
 import java.util.List;
 import java.util.logging.Logger;
+import okhttp3.StatisticsData;
 import okio.Buffer;
 import okio.BufferedSink;
 
@@ -100,8 +101,12 @@ public synchronized void applyAndAckSettings(Settings peerSettings) throws IOExc
    * @param requestHeaders minimally includes {@code :method}, {@code :scheme}, {@code :authority},
    * and {@code :path}.
    */
+  void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders) throws IOException {
+    pushPromise(streamId, promisedStreamId, requestHeaders, new StatisticsData());
+  }
+
   public synchronized void pushPromise(int streamId, int promisedStreamId,
-      List<Header> requestHeaders) throws IOException {
+      List<Header> requestHeaders, StatisticsData statsData) throws IOException {
     if (closed) throw new IOException("closed");
     hpackWriter.writeHeaders(requestHeaders);
 
@@ -112,8 +117,10 @@ public synchronized void pushPromise(int streamId, int promisedStreamId,
     frameHeader(streamId, length + 4, type, flags);
     sink.writeInt(promisedStreamId & 0x7fffffff);
     sink.write(hpackBuffer, length);
+    statsData.byteCountHeadersSent = 9 + 4 + length; // 9 = framing data. 4 = promised id. length = headers.
 
-    if (byteCount > length) writeContinuationFrames(streamId, byteCount - length);
+    if (byteCount > length) writeContinuationFrames(streamId, byteCount - length, statsData);
+    statsData.finishSendAtMillis = System.currentTimeMillis();
   }
 
   public synchronized void flush() throws IOException {
@@ -121,22 +128,35 @@ public synchronized void flush() throws IOException {
     sink.flush();
   }
 
-  public synchronized void synStream(boolean outFinished, int streamId,
+  void synStream(boolean outFinished, int streamId,
       int associatedStreamId, List<Header> headerBlock) throws IOException {
+    synStream(outFinished, streamId, associatedStreamId, headerBlock, new StatisticsData());
+  }
+
+  public synchronized void synStream(boolean outFinished, int streamId,
+      int associatedStreamId, List<Header> headerBlock, StatisticsData statsData) throws IOException {
     if (closed) throw new IOException("closed");
-    headers(outFinished, streamId, headerBlock);
+    headers(outFinished, streamId, headerBlock, statsData);
+  }
+
+  void synReply(boolean outFinished, int streamId, List<Header> headerBlock) throws IOException {
+    synReply(outFinished, streamId, headerBlock, new StatisticsData());
   }
 
   public synchronized void synReply(boolean outFinished, int streamId,
-      List<Header> headerBlock) throws IOException {
+      List<Header> headerBlock, StatisticsData statsData) throws IOException {
     if (closed) throw new IOException("closed");
-    headers(outFinished, streamId, headerBlock);
+    headers(outFinished, streamId, headerBlock, statsData);
   }
 
-  public synchronized void headers(int streamId, List<Header> headerBlock)
-      throws IOException {
+  synchronized void headers(int streamId, List<Header> headerBlock) throws IOException {
     if (closed) throw new IOException("closed");
-    headers(false, streamId, headerBlock);
+    headers(false, streamId, headerBlock, new StatisticsData());
+  }
+
+  public synchronized void headers(int streamId, List<Header> headerBlock, StatisticsData statsData) throws IOException {
+    if (closed) throw new IOException("closed");
+    headers(false, streamId, headerBlock, statsData);
   }
 
   public synchronized void rstStream(int streamId, ErrorCode errorCode)
@@ -165,19 +185,28 @@ public int maxDataLength() {
    * @param byteCount must be between 0 and the minimum of {@code source.length} and {@link
    * #maxDataLength}.
    */
-  public synchronized void data(boolean outFinished, int streamId, Buffer source, int byteCount)
+  void data(boolean outFinished, int streamId, Buffer source, int byteCount) throws IOException {
+    data(outFinished, streamId, source, byteCount, new StatisticsData());
+  }
+
+  public synchronized void data(boolean outFinished, int streamId, Buffer source, int byteCount, StatisticsData statsData)
       throws IOException {
     if (closed) throw new IOException("closed");
     byte flags = FLAG_NONE;
     if (outFinished) flags |= FLAG_END_STREAM;
-    dataFrame(streamId, flags, source, byteCount);
+    dataFrame(streamId, flags, source, byteCount, statsData);
   }
 
   void dataFrame(int streamId, byte flags, Buffer buffer, int byteCount) throws IOException {
+    dataFrame(streamId, flags, buffer, byteCount, new StatisticsData());
+  }
+
+  void dataFrame(int streamId, byte flags, Buffer buffer, int byteCount, StatisticsData statsData) throws IOException {
     byte type = TYPE_DATA;
     frameHeader(streamId, byteCount, type, flags);
     if (byteCount > 0) {
       sink.write(buffer, byteCount);
+      statsData.byteCountBodySent += byteCount;
     }
   }
 
@@ -285,16 +314,21 @@ private static void writeMedium(BufferedSink sink, int i) throws IOException {
     sink.writeByte(i & 0xff);
   }
 
-  private void writeContinuationFrames(int streamId, long byteCount) throws IOException {
+  private void writeContinuationFrames(int streamId, long byteCount, StatisticsData statsData) throws IOException {
     while (byteCount > 0) {
       int length = (int) Math.min(maxFrameSize, byteCount);
       byteCount -= length;
       frameHeader(streamId, length, TYPE_CONTINUATION, byteCount == 0 ? FLAG_END_HEADERS : 0);
       sink.write(hpackBuffer, length);
+      statsData.byteCountHeadersSent += length + 9; // 9 for the frame header.
     }
   }
 
   void headers(boolean outFinished, int streamId, List<Header> headerBlock) throws IOException {
+    headers(outFinished, streamId, headerBlock, new StatisticsData());
+  }
+
+  void headers(boolean outFinished, int streamId, List<Header> headerBlock, StatisticsData statsData) throws IOException {
     if (closed) throw new IOException("closed");
     hpackWriter.writeHeaders(headerBlock);
 
@@ -303,9 +337,13 @@ void headers(boolean outFinished, int streamId, List<Header> headerBlock) throws
     byte type = TYPE_HEADERS;
     byte flags = byteCount == length ? FLAG_END_HEADERS : 0;
     if (outFinished) flags |= FLAG_END_STREAM;
+    statsData.initiateSendAtMillis = System.currentTimeMillis();
     frameHeader(streamId, length, type, flags);
     sink.write(hpackBuffer, length);
+    statsData.byteCountHeadersSent += length + 9; // 9 for the frame header.
 
-    if (byteCount > length) writeContinuationFrames(streamId, byteCount - length);
+    if (byteCount > length) writeContinuationFrames(streamId, byteCount - length, statsData);
+    if (outFinished)
+      statsData.finishSendAtMillis = System.currentTimeMillis();
   }
 }
