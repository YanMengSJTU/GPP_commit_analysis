diff --git a/src/main/java/net/disy/commons/web/WebUrl.java b/src/main/java/net/disy/commons/web/WebUrl.java
index 4227564f30..315cff82bb 100644
--- a/src/main/java/net/disy/commons/web/WebUrl.java
+++ b/src/main/java/net/disy/commons/web/WebUrl.java
@@ -26,6 +26,7 @@
 import java.util.Collections;
 import java.util.LinkedHashSet;
 import java.util.List;
+import java.util.Optional;
 import java.util.Set;
 
 import okio.Buffer;
@@ -275,10 +276,14 @@
  * {@code java.net.URL} it's possible to create an awkward URL like {@code http:/} with scheme and
  * path but no hostname. Building APIs that consume such malformed values is difficult!
  *
- * <p>This class has a modern API. It avoids punitive checked exceptions: {@link #from get()}
- * throws {@link IllegalArgumentException} on invalid input or {@link #parse parse()}
- * returns null if the input is an invalid URL. You can even be explicit about whether each
- * component has been encoded already.
+ * <p>This class has a modern API. It avoids nulls and checked exceptions:
+ * <ul>
+ *   <li>{@link #get(String)} returns a {@link WebUrl} or throws an {@link IllegalArgumentException} on invalid input</li>
+ *   <li>{@link #parse(String)} returns an {@link Optional<WebUrl>}</li>
+ *   <li>{@link #from(URI)} and {@link #from(URL)} return an {@link Optional<WebUrl>}</li>
+ * </ul>
+ *
+ * <p>You can even be explicit about whether each component has been encoded already.
  */
 public final class WebUrl {
   private static final char[] HEX_DIGITS =
@@ -891,19 +896,22 @@ public Builder newBuilder() {
   }
 
   /**
-   * Returns a new {@code WebUrl} representing {@code url} if it is a well-formed HTTP or HTTPS
-   * URL, or null if it isn't.
+   * Returns a new {@code Optional<WebUrl>} representing {@code url} if it is a well-formed HTTP or HTTPS URL,
+   * or {@code Optional.empty()} if it isn't.
    */
-  public static /*@Nullable*/ WebUrl parse(String url) {
+  public static Optional<WebUrl> parse(String url) {
     try {
-      return get(url);
+      return Optional.of(get(url));
     } catch (IllegalArgumentException ignored) {
-      return null;
+      return Optional.empty();
     }
   }
 
   /**
    * Returns a new {@code WebUrl} representing {@code url}.
+   * This method is intended for inputs that are known to be valid.
+   *
+   * If the validity of the input string is unknown, use {@link #parse(String)} instead.
    *
    * @throws IllegalArgumentException If {@code url} is not a well-formed HTTP or HTTPS URL.
    */
@@ -912,18 +920,18 @@ public static WebUrl get(String url) {
   }
 
   /**
-   * Returns an {@link WebUrl} for {@code url} if its protocol is {@code http} or {@code https}, or
-   * null if it has any other protocol.
+   * Returns an {@link Optional<WebUrl>} for {@code url} if its protocol is {@code http} or {@code https},
+   * or {@code Optional.empty()} if it has any other protocol.
    */
-  static /*@Nullable*/ WebUrl from(URL url) {
+  static Optional<WebUrl> from(URL url) {
     return parse(url.toString());
   }
 
   /**
-   * Returns an {@link WebUrl} for {@code uri} if its protocol is {@code http} or {@code https}, or
-   * null if it has any other protocol.
+   * Returns an {@link Optional<WebUrl>} for {@code uri} if its protocol is {@code http} or {@code https},
+   * or {@code Optional.empty()} if it has any other protocol.
    */
-  public static /*@Nullable*/ WebUrl from(URI uri) {
+  public static Optional<WebUrl> from(URI uri) {
     return parse(uri.toString());
   }
 
diff --git a/src/test/java/net/disy/commons/web/UrlComponentEncodingTester.java b/src/test/java/net/disy/commons/web/UrlComponentEncodingTester.java
index 2419769073..cf85723c94 100644
--- a/src/test/java/net/disy/commons/web/UrlComponentEncodingTester.java
+++ b/src/test/java/net/disy/commons/web/UrlComponentEncodingTester.java
@@ -273,7 +273,7 @@ private void testToUrl(int codePoint, Encoding encoding, Component component) {
   private void testFromUrl(int codePoint, Encoding encoding, Component component) {
     String encoded = encoding.encode(codePoint);
     WebUrl httpUrl = WebUrl.get(component.urlString(encoded));
-    WebUrl toAndFromJavaNetUrl = WebUrl.from(httpUrl.url());
+    WebUrl toAndFromJavaNetUrl = WebUrl.from(httpUrl.url()).orElse(null);
     if (!toAndFromJavaNetUrl.equals(httpUrl)) {
       fail(format("Encoding %s %#x using %s", component, codePoint, encoding));
     }
@@ -285,7 +285,7 @@ private void testUri(
     String encoded = encoding.encode(codePoint);
     WebUrl httpUrl = WebUrl.get(component.urlString(encoded));
     URI uri = httpUrl.uri();
-    WebUrl toAndFromUri = WebUrl.from(uri);
+    WebUrl toAndFromUri = WebUrl.from(uri).orElse(null);
     if (uriEscaped) {
       // The URI has more escaping than the HttpURL. Check that the decoded values still match.
       if (uri.toString().equals(httpUrl.toString())) {
diff --git a/src/test/java/net/disy/commons/web/WebUrlTest.java b/src/test/java/net/disy/commons/web/WebUrlTest.java
index 173f22c837..a54330982b 100644
--- a/src/test/java/net/disy/commons/web/WebUrlTest.java
+++ b/src/test/java/net/disy/commons/web/WebUrlTest.java
@@ -50,7 +50,7 @@
   WebUrl parse(String url) {
     return useGet
         ? WebUrl.get(url)
-        : WebUrl.parse(url);
+        : WebUrl.parse(url).orElse(null);
   }
 
   @Test public void parseTrimsAsciiWhitespace() throws Exception {
@@ -1473,31 +1473,31 @@ WebUrl parse(String url) {
 
   @Test public void fromJavaNetUrl() throws Exception {
     URL javaNetUrl = new URL("http://username:password@host/path?query#fragment");
-    WebUrl httpUrl = WebUrl.from(javaNetUrl);
+    WebUrl httpUrl = WebUrl.from(javaNetUrl).orElse(null);
     assertThat(httpUrl.toString()).isEqualTo(
         "http://username:password@host/path?query#fragment");
   }
 
   @Test public void fromJavaNetUrlUnsupportedScheme() throws Exception {
     URL javaNetUrl = new URL("mailto:user@example.com");
-    assertThat(WebUrl.from(javaNetUrl)).isNull();
+    assertThat(WebUrl.from(javaNetUrl).orElse(null)).isNull();
   }
 
   @Test public void fromUri() throws Exception {
     URI uri = new URI("http://username:password@host/path?query#fragment");
-    WebUrl httpUrl = WebUrl.from(uri);
+    WebUrl httpUrl = WebUrl.from(uri).orElse(null);
     assertThat(httpUrl.toString()).isEqualTo(
         "http://username:password@host/path?query#fragment");
   }
 
   @Test public void fromUriUnsupportedScheme() throws Exception {
     URI uri = new URI("mailto:user@example.com");
-    assertThat(WebUrl.from(uri)).isNull();
+    assertThat(WebUrl.from(uri).orElse(null)).isNull();
   }
 
   @Test public void fromUriPartial() throws Exception {
     URI uri = new URI("/path");
-    assertThat(WebUrl.from(uri)).isNull();
+    assertThat(WebUrl.from(uri).orElse(null)).isNull();
   }
 
   @Test public void composeQueryWithComponents() throws Exception {
